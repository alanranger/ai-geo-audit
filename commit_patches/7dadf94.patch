From 7dadf94bc68798ac19968a358a8bdaf8b1101eed Mon Sep 17 00:00:00 2001
From: alanranger <info@alanranger.com>
Date: Tue, 23 Dec 2025 17:02:35 +0000
Subject: [PATCH] Fix commit 5866276: Remove broken references to non-existent
 loadAuditHistoryAndRenderKpis function

---
 audit-dashboard.html | 14877 +----------------------------------------
 1 file changed, 5 insertions(+), 14872 deletions(-)

diff --git a/audit-dashboard.html b/audit-dashboard.html
index af2b6d8..cf9367d 100644
--- a/audit-dashboard.html
+++ b/audit-dashboard.html
@@ -15110,33 +15110,11 @@ <h3>üîç Debug Log</h3>
               }
             }
             
-            const sparklineCanvas = document.getElementById('money-kpi-sparkline');
-            if (sparklineCanvas && typeof loadAuditHistoryAndRenderKpis === 'function') {
-              const rect = sparklineCanvas.getBoundingClientRect();
-              if (rect.width === 0 || rect.height === 0) {
-                debugLog('‚ö† Money KPI sparkline: Canvas has zero dimensions, will retry', 'warn');
-                setTimeout(renderMoneyCharts, 200);
-                return;
-              }
-              
-              const propertyUrl = document.getElementById('propertyUrl')?.value;
-              if (propertyUrl) {
-                requestAnimationFrame(() => {
-                  requestAnimationFrame(() => {
-                    const canvas = document.getElementById('money-kpi-sparkline');
-                    if (canvas) {
-                      const rect = canvas.getBoundingClientRect();
-                      if (rect.width > 0 && rect.height > 0) {
-                        loadAuditHistoryAndRenderKpis(propertyUrl);
-                      } else {
-                        debugLog('‚ö† Money KPI sparkline: Canvas still has zero dimensions, retrying...', 'warn');
-                        setTimeout(() => renderMoneyCharts(), 200);
-                      }
-                    }
-                  });
-                });
-              }
-            }
+            // KPI Tracker functionality not yet implemented at this commit
+            // const sparklineCanvas = document.getElementById('money-kpi-sparkline');
+            // if (sparklineCanvas && typeof loadAuditHistoryAndRenderKpis === 'function') {
+            //   ... (commented out - function doesn't exist yet at this commit)
+            // }
             };
             
             // Start rendering charts with retry logic
@@ -32462,14848 +32440,3 @@ <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e
                 const propertyUrl = document.getElementById('propertyUrl')?.value;
                 if (propertyUrl) {
                   loadAuditHistoryAndRenderKpis(propertyUrl);
-                } else {
-                  // Fallback: use cached data but still need timeseries
-                  debugLog('‚ö† Metric selector: No propertyUrl available, cannot reload timeseries', 'warn');
-                }
-              }
-            });
-          }
-        }
-        
-        // Store queryPages globally for filtering
-        // Use data parameter (searchData) first, then fallback to saved data
-        if (data && data.queryPages) {
-          window.currentQueryPages = data.queryPages;
-        } else if (saved && saved.searchData && saved.searchData.queryPages) {
-          window.currentQueryPages = saved.searchData.queryPages;
-        }
-        // Render behaviour KPIs and chart after a delay to ensure DOM and Chart.js are ready
-        // Apply filters and update all sections with filtered data
-        if (moneyPagesMetricsToRender) {
-          setTimeout(() => {
-            const queryPages = window.currentQueryPages || null;
-            const moneyPagesMetrics = moneyPagesMetricsToRender;
-            
-            // Use saved behaviour data if available (from Supabase/localStorage)
-            let savedBehaviour = null;
-            if (moneyPagesMetrics && moneyPagesMetrics.behaviour) {
-              savedBehaviour = moneyPagesMetrics.behaviour;
-              debugLog(`üéØ Using saved behaviour data: score=${savedBehaviour.score}, impressions=${savedBehaviour.impressions}`, 'info');
-            }
-            
-            // Get filtered metrics based on current filters (defaults to 'ALL' on initial load)
-            const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
-            if (filteredMetrics) {
-              // Try to recalculate behaviour for filtered pages, but use saved if calculation fails
-              const filteredRows = filteredMetrics.rows || [];
-              let filteredBehaviour = null;
-              
-              if (window.computeMoneyPagesBehaviour && queryPages && filteredRows.length > 0) {
-                filteredBehaviour = window.computeMoneyPagesBehaviour(queryPages, filteredRows, true);
-                debugLog(`üéØ Recalculated behaviour for filtered pages: ${!!filteredBehaviour}, impressions=${filteredBehaviour?.impressions || 0}`, 'info');
-              }
-              
-              // Use saved behaviour as fallback if recalculation failed or returned no data
-              if (!filteredBehaviour || !filteredBehaviour.impressions) {
-                if (savedBehaviour && savedBehaviour.impressions) {
-                  debugLog(`üéØ Using saved behaviour as fallback (recalculation had no data)`, 'info');
-                  filteredBehaviour = savedBehaviour;
-                }
-              }
-              
-              // Update all sections with filtered data
-              renderMoneyPagesBehaviourKpis(filteredBehaviour, filteredMetrics, queryPages);
-              updateMoneyPagesSummaryMetrics(moneyPagesMetrics); // Pass original metrics so function can apply filters internally
-              updateMoneyPagesChartSummary(filteredMetrics);
-              
-              // Render chart with filtered data
-              // Always re-render chart to ensure it uses current filters
-                renderMoneyPagesCategoryChart(moneyPagesMetrics, 0);
-            } else {
-              // Fallback: render with unfiltered data if filtering fails
-              renderMoneyPagesBehaviourKpis(savedBehaviour || moneyPagesMetrics.behaviour, moneyPagesMetrics, queryPages);
-              if (!moneyPagesCategoryChart) {
-                renderMoneyPagesCategoryChart(moneyPagesMetrics, 0);
-              }
-            }
-          }, 200);
-        }
-      }, 100);
-      
-      // Remove existing scorecard table if it exists
-      const existingScorecard = pillarCards.parentNode.querySelector('.scorecard-section');
-      if (existingScorecard) {
-        existingScorecard.remove();
-      }
-      
-      // Function to render segment comparison table (shared by both createTopPagesSection functions)
-      function renderSegmentComparisonTable(authorityBySegment, currentMode) {
-        const segments = [
-          { key: 'all', label: 'All pages', data: authorityBySegment.all },
-          { key: 'nonEducation', label: 'Exclude education (blogs / free course)', data: authorityBySegment.nonEducation },
-          { key: 'money', label: 'Money pages only', data: authorityBySegment.money }
-        ];
-        
-        let tableHtml = `
-          <div style="margin-bottom: 0.5rem;">
-            <h4 style="margin: 0 0 0.5rem 0; font-size: 1.15rem; font-weight: 700; color: #1e293b;">Segment overview (CTR & ranking)</h4>
-          </div>
-          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
-            <table style="width: 100%; border-collapse: collapse; font-size: 0.95rem;">
-              <thead>
-                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
-                  <th style="text-align: left; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Segment</th>
-                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Site CTR</th>
-                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Top-10 CTR</th>
-                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Avg pos.</th>
-                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Top-10 share</th>
-                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Behaviour</th>
-                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Ranking</th>
-                </tr>
-              </thead>
-              <tbody>
-        `;
-        
-        segments.forEach(({ key, label, data }, idx) => {
-          const isActive = key === currentMode;
-          const siteCtr = data?.siteCtr || 0;
-          const top10Ctr = data?.top10Ctr || 0;
-          const avgPosition = data?.avgPosition || 0;
-          const top10Share = (data?.top10Share || 0) * 100;
-          const behaviourScore = data?.behaviour || 0;
-          const rankingScore = data?.ranking || 0;
-          
-          tableHtml += `
-            <tr 
-              onclick="window.currentAuthorityMode = '${key}'; if(window.updateTopPagesSection) window.updateTopPagesSection('${key}');"
-              style="
-                cursor: pointer;
-                border-bottom: 1px solid #f1f5f9;
-                background: ${isActive ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : (idx % 2 === 0 ? '#ffffff' : '#fafafa')};
-                transition: all 0.2s;
-              "
-              onmouseover="this.style.background='${isActive ? 'linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%)' : '#f8f9fa'}';"
-              onmouseout="this.style.background='${isActive ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : (idx % 2 === 0 ? '#ffffff' : '#fafafa')}';"
-            >
-              <td style="padding: 0.75rem 1rem; font-weight: ${isActive ? '600' : '500'}; color: #0f172a; font-size: 0.95rem;">
-                ${label}
-                ${isActive ? '<span style="margin-left: 0.5rem; font-size: 0.8rem; padding: 0.15rem 0.5rem; border-radius: 999px; background: #10b981; color: white; font-weight: 600;">current</span>' : ''}
-              </td>
-              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${siteCtr != null ? siteCtr.toFixed(1) : 'N/A'}%</td>
-              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${top10Ctr != null ? top10Ctr.toFixed(1) : 'N/A'}%</td>
-              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${avgPosition != null ? avgPosition.toFixed(1) : 'N/A'}</td>
-              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${top10Share != null ? top10Share.toFixed(1) : 'N/A'}%</td>
-              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 0.95rem;">${behaviourScore != null ? Math.round(behaviourScore) : 'N/A'}</td>
-              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 0.95rem;">${rankingScore != null ? Math.round(rankingScore) : 'N/A'}</td>
-            </tr>
-          `;
-        });
-        
-        tableHtml += `
-              </tbody>
-            </table>
-          </div>
-        `;
-        
-        return tableHtml;
-      }
-      
-      // Function to create Top Pages section (full width, below pillar cards)
-      function createTopPagesSection(scores, saved) {
-        // Get Authority segment data from current scores (latest snapshot, not historical)
-        // This uses the most recent audit data, not historical Supabase data
-        const authorityObj = scores?.authority;
-        let authorityBySegment = (typeof authorityObj === 'object' && authorityObj !== null) 
-          ? authorityObj.bySegment 
-          : null;
-        
-        // If no segment data in scores, try to get from saved audit (latest audit data from localStorage)
-        if (!authorityBySegment && saved) {
-          const savedScores = saved.scores;
-          if (savedScores && savedScores.authority) {
-            const savedAuthorityObj = savedScores.authority;
-            if (typeof savedAuthorityObj === 'object' && savedAuthorityObj !== null) {
-              authorityBySegment = savedAuthorityObj.bySegment || null;
-              debugLog('üìä Top Pages: Using Authority segment data from saved audit (latest snapshot)', 'info');
-            }
-          }
-        }
-        
-        if (!authorityBySegment) {
-          debugLog('‚ö† No Authority segment data available for Top Pages table. This requires GSC queryPages data from your most recent audit.', 'warn');
-          // Still create the section but show a helpful message - don't return early
-        }
-        
-        // Remove existing top pages section if it exists
-        const existingTopPages = document.getElementById('authority-top-pages-section');
-        if (existingTopPages) {
-          existingTopPages.remove();
-        }
-        
-        // Create new section
-        const topPagesSection = document.createElement('div');
-        topPagesSection.id = 'authority-top-pages-section';
-        topPagesSection.className = 'section-break';
-        topPagesSection.style.marginTop = '2rem';
-        topPagesSection.style.marginBottom = '2rem';
-        
-        // Get current mode from Authority card toggle (default to 'all')
-        let currentMode = 'all';
-        const authorityCard = Array.from(document.querySelectorAll('.pillar-card')).find(card => {
-          const h3 = card.querySelector('h3');
-          return h3 && h3.textContent === 'Authority';
-        });
-        
-        if (authorityCard && authorityCard._authorityMode) {
-          currentMode = authorityCard._authorityMode;
-        }
-        
-        // Get top pages for current mode
-        const topPages = currentMode === 'all'
-          ? (authorityBySegment?.all?.topPages || [])
-          : currentMode === 'nonEducation'
-          ? (authorityBySegment?.nonEducation?.topPages || [])
-          : (authorityBySegment?.money?.topPages || []);
-        
-        const segmentLabel = currentMode === 'all'
-          ? 'All pages'
-          : currentMode === 'nonEducation'
-          ? 'Exclude education (blogs / free course)'
-          : 'Money pages only';
-        
-        // Get segment metrics for summary display
-        const getSegmentSummary = (mode) => {
-          if (!authorityBySegment || !authorityBySegment[mode]) return null;
-          const segmentData = authorityBySegment[mode];
-          return {
-            behaviour: segmentData.behaviour || 0,
-            ranking: segmentData.ranking || 0,
-            total: segmentData.total || segmentData.score || 0
-          };
-        };
-        
-        const currentSummary = getSegmentSummary(currentMode);
-        const rag = currentSummary ? getRAGStatus(currentSummary.total) : { status: 'amber', label: 'N/A' };
-        
-        // Get date range for display
-        const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
-        const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
-        
-        // Get brand queries for mini-table
-        const topQueries = saved?.searchData?.topQueries || [];
-        const brandQueries = topQueries
-          .filter(q => isBrandQuery(q.query || ''))
-          .sort((a, b) => (b.impressions || 0) - (a.impressions || 0))
-          .slice(0, 10);
-        
-        // Create section HTML with improved styling and pastel background
-        topPagesSection.innerHTML = `
-          <div style="background: #F5F0F5; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border-left: 4px solid #99004C;">
-            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem;">
-              <div style="flex: 1;">
-                <h3 style="margin: 0 0 0.5rem 0; color: var(--brand-dark); font-size: 1.25rem; font-weight: 700;">Authority - Behaviour & Ranking</h3>
-                <div style="margin-bottom: 1rem; padding: 1rem; background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-radius: 6px; font-size: 0.85rem; line-height: 1.6; color: #555; border-left: 3px solid #99004C;">
-                  <p style="margin: 0 0 0.75rem 0;"><strong style="color: #99004C;">Behaviour:</strong> Measures click-through rate (CTR) performance. Combines Overall CTR (50% weight) for all ranking search terms and Top-10 Ranked Search Terms CTR (50% weight) for queries ranking in positions 1-10. Indicates how well your titles and descriptions convert impressions to clicks. Data source: Google Search Console query+page metrics.</p>
-                  <p style="margin: 0;"><strong style="color: #99004C;">Ranking:</strong> Measures search visibility and position quality. Combines Average Position Score (50% weight) and Top-10 Impression Share (50% weight). Shows how high you rank on average and what percentage of impressions appear in positions 1-10. Data source: Google Search Console query+page metrics.</p>
-                </div>
-              </div>
-            </div>
-            
-            ${currentSummary ? `
-            <div style="margin-bottom: 1rem; padding: 1rem; background: rgba(221, 160, 221, 0.2); border-radius: 6px; border: 1px solid #e2e8f0;">
-              <div style="text-align: center; margin-bottom: 0.75rem;">
-                <span style="font-weight: 600; color: #333; font-size: 1.08rem;">Segment Summary: </span>
-                <span id="top-pages-segment-label" style="color: #666; font-size: 0.85rem; padding: 0.25rem 0.75rem; background: #f1f5f9; border-radius: 4px;">${segmentLabel}</span>
-              </div>
-              <div style="display: flex; justify-content: center; align-items: center; gap: 1.5rem; flex-wrap: wrap;">
-                <div id="top-pages-segment-summary" style="display: flex; align-items: center; gap: 1.5rem; font-size: 1rem;">
-                  ${formatComponentScore('Behaviour', currentSummary.behaviour)}
-                  ${formatComponentScore('Ranking', currentSummary.ranking)}
-                </div>
-                <div style="display: flex; align-items: center; gap: 0.5rem;">
-                  <span style="font-size: 1.5rem; font-weight: 700; color: ${rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444'};">${Math.round(currentSummary.total)}</span>
-                  <span class="rag-badge ${rag.status}" style="display: inline-block; padding: 0.35rem 0.85rem; border-radius: 4px; font-size: 0.85rem; font-weight: 600;">${rag.label}</span>
-                </div>
-              </div>
-            </div>
-            ` : `
-            <div style="margin-bottom: 1rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem;">
-              <span style="font-weight: 600; color: #666;">Current Segment:</span>
-              <span id="top-pages-segment-label" style="color: #333; margin-left: 0.5rem;">${segmentLabel}</span>
-            </div>
-            `}
-            
-            ${authorityBySegment ? `
-            <div style="margin-bottom: 1rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem;">
-              <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
-                <span style="font-weight: 600; color: #666;">View:</span>
-                <button id="top-pages-mode-all" class="authority-mode-btn" data-mode="all" style="padding: 0.35rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: ${currentMode === 'all' ? '#10b981' : 'white'}; color: ${currentMode === 'all' ? 'white' : '#666'}; cursor: pointer; font-size: 0.75rem; font-weight: ${currentMode === 'all' ? '600' : '400'}; transition: all 0.2s;">
-                  All pages
-                </button>
-                <button id="top-pages-mode-nonEducation" class="authority-mode-btn" data-mode="nonEducation" style="padding: 0.35rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: ${currentMode === 'nonEducation' ? '#10b981' : 'white'}; color: ${currentMode === 'nonEducation' ? 'white' : '#666'}; cursor: pointer; font-size: 0.75rem; font-weight: ${currentMode === 'nonEducation' ? '600' : '400'}; transition: all 0.2s;">
-                  Exclude education
-                </button>
-                <button id="top-pages-mode-money" class="authority-mode-btn" data-mode="money" style="padding: 0.35rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: ${currentMode === 'money' ? '#10b981' : 'white'}; color: ${currentMode === 'money' ? 'white' : '#666'}; cursor: pointer; font-size: 0.75rem; font-weight: ${currentMode === 'money' ? '600' : '400'}; transition: all 0.2s;">
-                  Money pages only
-                </button>
-              </div>
-            </div>
-            ` : ''}
-            
-            ${authorityBySegment ? `
-            <div id="top-pages-comparison-table" style="margin-bottom: 1.5rem;">
-              ${renderSegmentComparisonTable(authorityBySegment, currentMode)}
-            </div>
-            ` : ''}
-            
-            <div id="top-pages-table-container">
-              ${renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText)}
-            </div>
-            
-            ${authorityBySegment && authorityBySegment[currentMode] ? `
-            <div id="top-pages-recommendations-container" style="margin-top: 2rem;">
-              ${renderRecommendationsTable(currentMode, {
-                siteCtr: authorityBySegment[currentMode].siteCtr || 0,
-                top10Ctr: authorityBySegment[currentMode].top10Ctr || 0,
-                avgPosition: authorityBySegment[currentMode].avgPosition || 0,
-                top10Share: authorityBySegment[currentMode].top10Share || 0,
-                behaviourScore: authorityBySegment[currentMode].behaviour || 0,
-                rankingScore: authorityBySegment[currentMode].ranking || 0
-              }, segmentLabel, dateRangeText)}
-            </div>
-            ` : ''}
-            
-            ${brandQueries.length > 0 ? `
-            <div style="margin-top: 2rem; padding: 1rem; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #f59e0b;">
-              <h4 style="margin: 0 0 0.75rem 0; color: #92400e; font-size: 1rem; font-weight: 600;">Top Branded Queries</h4>
-              <p style="margin: 0 0 1rem 0; font-size: 0.85rem; color: #666; line-height: 1.5;">Branded search queries (e.g., "Alan Ranger Photography") with CTR and position metrics.</p>
-              <div style="overflow-x: auto;">
-                <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
-                  <thead>
-                    <tr style="background: #e5e7eb; border-bottom: 2px solid #d1d5db;">
-                      <th style="padding: 0.5rem; text-align: left; font-weight: 600; color: #374151;">Query</th>
-                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Impressions</th>
-                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Clicks</th>
-                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">CTR</th>
-                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Position</th>
-                    </tr>
-                  </thead>
-                  <tbody>
-                    ${brandQueries.map((q, idx) => {
-                      const ctr = q.impressions > 0 ? ((q.clicks || 0) / q.impressions * 100) : 0;
-                      const ctrColor = ctr >= 25 ? '#10b981' : ctr >= 10 ? '#f59e0b' : '#ef4444';
-                      const posColor = (q.position || 0) <= 3 ? '#10b981' : (q.position || 0) <= 5 ? '#f59e0b' : '#ef4444';
-                      return `
-                      <tr style="border-bottom: 1px solid #e5e7eb; ${idx % 2 === 0 ? 'background: #ffffff;' : 'background: #f9fafb;'}">
-                        <td style="padding: 0.5rem; color: #1f2937; font-weight: 500;">${(q.query || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</td>
-                        <td style="padding: 0.5rem; text-align: right; color: #6b7280;">${(q.impressions || 0).toLocaleString()}</td>
-                        <td style="padding: 0.5rem; text-align: right; color: #6b7280;">${(q.clicks || 0).toLocaleString()}</td>
-                        <td style="padding: 0.5rem; text-align: right; color: ${ctrColor}; font-weight: 600;">${ctr.toFixed(1)}%</td>
-                        <td style="padding: 0.5rem; text-align: right; color: ${posColor}; font-weight: 600;">${(q.position || 0).toFixed(1)}</td>
-                      </tr>
-                    `;
-                    }).join('')}
-                  </tbody>
-                </table>
-              </div>
-            </div>
-            ` : ''}
-          </div>
-        `;
-        
-        // Insert into Authority panel instead of Overview
-        const authorityPanel = document.querySelector('.aigeo-panel[data-panel="authority"]');
-        if (authorityPanel) {
-          // Clear any existing content
-          const existing = document.getElementById('authority-top-pages-section');
-          if (existing) existing.remove();
-          authorityPanel.appendChild(topPagesSection);
-          debugLog('‚úì Authority section inserted into Authority panel', 'success');
-        } else {
-          // Fallback: insert after pillar cards (old behavior)
-        pillarCards.parentNode.insertBefore(topPagesSection, pillarCards.nextSibling);
-          debugLog('‚úì Authority section inserted after pillar cards (fallback)', 'info');
-        }
-        
-        // Store authorityBySegment globally so updateTopPagesSection can access it
-        window.authorityBySegment = authorityBySegment;
-        
-        // Attach toggle button handlers
-        setTimeout(() => {
-          ['all', 'nonEducation', 'money'].forEach(mode => {
-            const btn = document.getElementById(`top-pages-mode-${mode}`);
-            if (btn) {
-              // Remove existing listeners by cloning
-              const newBtn = btn.cloneNode(true);
-              btn.parentNode.replaceChild(newBtn, btn);
-              
-              newBtn.addEventListener('click', () => {
-                window.currentAuthorityMode = mode;
-                if (window.updateTopPagesSection) {
-                  window.updateTopPagesSection(mode);
-                }
-                // Also update Authority pillar card if it exists
-                const authorityCard = Array.from(document.querySelectorAll('.pillar-card')).find(card => {
-                  const h3 = card.querySelector('h3');
-                  return h3 && h3.textContent === 'Authority';
-                });
-                if (authorityCard && authorityCard._updateAuthorityDisplay) {
-                  authorityCard._authorityMode = mode;
-                  authorityCard._updateAuthorityDisplay();
-                  // Update Authority pillar toggle buttons
-                  const modeId = authorityCard._modeId;
-                  ['all', 'nonEducation', 'money'].forEach(m => {
-                    const authBtn = document.getElementById(`${modeId}-${m}`);
-                    if (authBtn) {
-                      if (m === mode) {
-                        authBtn.style.background = '#10b981';
-                        authBtn.style.color = 'white';
-                      } else {
-                        authBtn.style.background = 'white';
-                        authBtn.style.color = '#666';
-                      }
-                    }
-                  });
-                }
-              });
-            }
-          });
-        }, 100);
-        
-        // Store update function globally so Authority mode toggle can call it
-        window.updateTopPagesSection = function(mode) {
-          // Get fresh authorityBySegment from global or try to get from current scores
-          let segData = window.authorityBySegment;
-          if (!segData) {
-            // Try to get from current scores
-            const authorityObj = scores?.authority;
-            segData = (typeof authorityObj === 'object' && authorityObj !== null) 
-              ? authorityObj.bySegment 
-              : null;
-          }
-          
-          const topPages = mode === 'all'
-            ? (segData?.all?.topPages || [])
-            : mode === 'nonEducation'
-            ? (segData?.nonEducation?.topPages || [])
-            : (segData?.money?.topPages || []);
-          
-          const segmentLabel = mode === 'all'
-            ? 'All pages'
-            : mode === 'nonEducation'
-            ? 'Exclude education (blogs / free course)'
-            : 'Money pages only';
-          
-          debugLog(`üìä Top Pages: Updating to segment "${mode}", found ${topPages.length} pages`, 'info');
-          
-          // Update segment label
-          const labelEl = document.getElementById('top-pages-segment-label');
-          if (labelEl) labelEl.textContent = segmentLabel;
-          
-          // Update summary if available
-          const getSegmentSummary = (m) => {
-            if (!segData || !segData[m]) return null;
-            const segmentData = segData[m];
-            return {
-              behaviour: segmentData.behaviour || 0,
-              ranking: segmentData.ranking || 0,
-              total: segmentData.total || segmentData.score || 0
-            };
-          };
-          
-          const summary = getSegmentSummary(mode);
-          const summaryDiv = document.getElementById('top-pages-segment-summary');
-          if (summary && summaryDiv) {
-            const rag = getRAGStatus(summary.total);
-            summaryDiv.innerHTML = `
-              ${formatComponentScore('Behaviour', summary.behaviour)}
-              ${formatComponentScore('Ranking', summary.ranking)}
-            `;
-            // Update RAG badge and score
-            const ragBadge = summaryDiv.parentElement.querySelector('.rag-badge');
-            const scoreSpan = summaryDiv.parentElement.querySelector('span[style*="font-size: 1.5rem"]');
-            if (ragBadge) {
-              ragBadge.className = `rag-badge ${rag.status}`;
-              ragBadge.textContent = rag.label;
-            }
-            if (scoreSpan) {
-              scoreSpan.textContent = Math.round(summary.total);
-              scoreSpan.style.color = rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444';
-            }
-          }
-          
-          // Update toggle buttons
-          ['all', 'nonEducation', 'money'].forEach(m => {
-            const btn = document.getElementById(`top-pages-mode-${m}`);
-            if (btn) {
-              if (m === mode) {
-                btn.style.background = '#10b981';
-                btn.style.color = 'white';
-                btn.style.fontWeight = '600';
-              } else {
-                btn.style.background = 'white';
-                btn.style.color = '#666';
-                btn.style.fontWeight = '400';
-              }
-            }
-          });
-          
-          // Update comparison table
-          const comparisonDiv = document.getElementById('top-pages-comparison-table');
-          if (comparisonDiv && segData) {
-            comparisonDiv.innerHTML = renderSegmentComparisonTable(segData, mode);
-          }
-          
-          // Get date range for display
-          const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
-          const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
-          
-          // Update table (reset sort when switching segments)
-          window.topPagesData = topPages;
-          window.topPagesSortColumn = null;
-          window.topPagesSortDirection = 'desc';
-          const tableContainer = document.getElementById('top-pages-table-container');
-          if (tableContainer) {
-            tableContainer.innerHTML = renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText);
-            attachCopyButtonHandler();
-            attachSortHandlers();
-          }
-          
-          // Update recommendations table
-          const recommendationsContainer = document.getElementById('top-pages-recommendations-container');
-          if (recommendationsContainer && segData && segData[mode]) {
-            const segmentLabel = mode === 'all'
-              ? 'All pages'
-              : mode === 'nonEducation'
-              ? 'Exclude education (blogs / free course)'
-              : 'Money pages only';
-            const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
-            const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
-            recommendationsContainer.innerHTML = renderRecommendationsTable(mode, {
-              siteCtr: segData[mode].siteCtr || 0,
-              top10Ctr: segData[mode].top10Ctr || 0,
-              avgPosition: segData[mode].avgPosition || 0,
-              top10Share: segData[mode].top10Share || 0,
-              behaviourScore: segData[mode].behaviour || 0,
-              rankingScore: segData[mode].ranking || 0
-            }, segmentLabel, dateRangeText);
-          }
-        };
-        
-        // Helper to attach sort handlers after table is in DOM
-        function attachSortHandlers() {
-          setTimeout(() => {
-            ['ctr', 'impressions', 'clicks', 'position'].forEach(col => {
-              const th = document.getElementById(`sort-${col}`);
-              if (th) {
-                // Remove existing listeners by cloning
-                const newTh = th.cloneNode(true);
-                th.parentNode.replaceChild(newTh, th);
-                newTh.addEventListener('click', () => {
-                  if (window.handleSort) {
-                    window.handleSort(col);
-                  }
-                });
-              }
-            });
-          }, 50);
-        }
-        
-        // Attach initial handlers after section is created
-        setTimeout(() => {
-          attachCopyButtonHandler();
-          attachSortHandlers();
-        }, 150);
-        
-        function attachCopyButtonHandler() {
-          setTimeout(() => {
-            const copyBtn = document.getElementById('top-pages-copy-urls');
-            if (copyBtn) {
-              // Remove existing listener
-              const newCopyBtn = copyBtn.cloneNode(true);
-              copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
-              
-              newCopyBtn.addEventListener('click', async () => {
-                const currentMode = window.currentAuthorityMode || 'all';
-                const currentTopPages = currentMode === 'all'
-                  ? (authorityBySegment?.all?.topPages || [])
-                  : currentMode === 'nonEducation'
-                  ? (authorityBySegment?.nonEducation?.topPages || [])
-                  : (authorityBySegment?.money?.topPages || []);
-                
-                const text = currentTopPages.map(p => p.url).join('\n');
-                try {
-                  await navigator.clipboard.writeText(text);
-                  newCopyBtn.textContent = 'Copied!';
-                  newCopyBtn.style.color = '#10b981';
-                  setTimeout(() => {
-                    newCopyBtn.textContent = 'Copy URLs';
-                    newCopyBtn.style.color = '#666';
-                  }, 2000);
-                } catch (err) {
-                  console.error('Failed to copy URLs:', err);
-                  newCopyBtn.textContent = 'Copy failed';
-                  setTimeout(() => {
-                    newCopyBtn.textContent = 'Copy URLs';
-                  }, 2000);
-                }
-              });
-            }
-          }, 0);
-        }
-      }
-      
-      // Add pillar scorecard table
-      // Use current audit data (from function parameters) instead of stale localStorage data
-      const auditTimestamp = saved?.timestamp;
-      
-      // Define schemaAuditData in scope accessible to scorecard table
-      const schemaAuditData = schemaAudit || saved?.schemaAudit;
-      
-      // Fetch historical scores for the last date in chart range to ensure scorecard matches chart
-      // This fixes the issue where scorecard shows latest audit score but chart shows historical score
-      let historicalScoresForLastDate = {};
-      const propertyUrlForHistorical = document.getElementById('propertyUrl')?.value || data?.propertyUrl || propertyUrl || '';
-      if (propertyUrlForHistorical) {
-        try {
-          // Get the last date from timeseries or maps
-          let lastChartDate = null;
-          if (data && data.timeseries && Array.isArray(data.timeseries) && data.timeseries.length > 0) {
-            lastChartDate = data.timeseries[data.timeseries.length - 1].date;
-          } else if (window.lastGscTimeseriesDate) {
-            lastChartDate = window.lastGscTimeseriesDate;
-          } else if (window.authorityMap && window.authorityMap.size > 0) {
-            const authorityDates = Array.from(window.authorityMap.keys()).sort();
-            lastChartDate = authorityDates[authorityDates.length - 1];
-          }
-          
-          if (lastChartDate) {
-            debugLog(`[Scorecard] Fetching historical scores for last chart date: ${lastChartDate}`, 'info');
-            const historicalResponse = await fetch(apiUrl(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrlForHistorical)}&startDate=${lastChartDate}&endDate=${lastChartDate}`));
-            if (historicalResponse.ok) {
-              const historicalData = await historicalResponse.json();
-              if (historicalData.status === 'ok' && historicalData.data && Array.isArray(historicalData.data) && historicalData.data.length > 0) {
-                // Get the latest audit for this date (in case of multiple audits per day)
-                const auditsForDate = historicalData.data.filter(r => r.date === lastChartDate);
-                if (auditsForDate.length > 0) {
-                  // Sort by timestamp/updated_at to get the latest
-                  auditsForDate.sort((a, b) => {
-                    const aTime = a.updated_at || a.timestamp || 0;
-                    const bTime = b.updated_at || b.timestamp || 0;
-                    return bTime - aTime;
-                  });
-                  const latestAudit = auditsForDate[0];
-                  historicalScoresForLastDate = {
-                    authority: latestAudit.authorityScore,
-                    contentSchema: latestAudit.contentSchemaScore,
-                    localEntity: latestAudit.localEntityScore,
-                    serviceArea: latestAudit.serviceAreaScore,
-                    visibility: latestAudit.visibilityScore
-                  };
-                  debugLog(`[Scorecard] Found historical scores for ${lastChartDate}: Authority=${historicalScoresForLastDate.authority}, Content/Schema=${historicalScoresForLastDate.contentSchema}`, 'info');
-                }
-              }
-            }
-          }
-        } catch (e) {
-          debugLog(`[Scorecard] Error fetching historical scores: ${e.message}`, 'warn');
-        }
-      }
-      
-      // Get last GSC data date from current data (for Authority, Visibility, and Brand & Entity)
-      // CRITICAL: Always fetch fresh from Supabase to get the actual last timeseries date
-      // data.timeseries may be stale (from localStorage), so we can't rely on it for the Data Date
-      let gscLastDate = null;
-      
-      // Always fetch fresh from Supabase to ensure we have the latest date
-      const propertyUrl = document.getElementById('propertyUrl')?.value || data?.propertyUrl || '';
-      if (propertyUrl) {
-        try {
-          // Try window first (if renderTrendChart already ran and set it)
-          if (window.lastGscTimeseriesDate) {
-            gscLastDate = window.lastGscTimeseriesDate;
-            debugLog(`Using last GSC timeseries date from window: ${gscLastDate}`, 'info');
-          } else {
-            // Fetch from Supabase API to get the last timeseries date
-            const endDate = new Date().toISOString().split('T')[0];
-            const startDate = new Date();
-            startDate.setDate(startDate.getDate() - 30); // Last 30 days
-            const startDateStr = startDate.toISOString().split('T')[0];
-            
-            debugLog(`Fetching last GSC timeseries date from Supabase for Data Date...`, 'info');
-            const timeseriesResponse = await fetch(apiUrl(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDate}`));
-            if (timeseriesResponse.ok) {
-              const timeseriesData = await timeseriesResponse.json();
-              if (timeseriesData.status === 'ok' && timeseriesData.timeseries && Array.isArray(timeseriesData.timeseries) && timeseriesData.timeseries.length > 0) {
-                const lastPoint = timeseriesData.timeseries[timeseriesData.timeseries.length - 1];
-                if (lastPoint && lastPoint.date) {
-                  gscLastDate = lastPoint.date;
-                  debugLog(`‚úì Using last GSC timeseries date from Supabase API: ${gscLastDate}`, 'success');
-                } else {
-                  debugLog(`‚ö† Supabase timeseries response missing date in last point`, 'warn');
-                }
-              } else {
-                debugLog(`‚ö† Supabase timeseries response missing data: status=${timeseriesData.status}, hasTimeseries=${!!timeseriesData.timeseries}`, 'warn');
-              }
-            } else {
-              debugLog(`‚ö† Failed to fetch timeseries from Supabase: ${timeseriesResponse.status}`, 'warn');
-            }
-          }
-        } catch (e) {
-          debugLog(`Error fetching GSC date: ${e.message}`, 'warn');
-        }
-      }
-      
-      // Fallback to data.timeseries only if Supabase fetch failed
-      if (!gscLastDate && data && data.timeseries && Array.isArray(data.timeseries) && data.timeseries.length > 0) {
-        const lastTimeseriesPoint = data.timeseries[data.timeseries.length - 1];
-        if (lastTimeseriesPoint && lastTimeseriesPoint.date) {
-          gscLastDate = lastTimeseriesPoint.date;
-          debugLog(`Using last GSC timeseries date from data (fallback): ${gscLastDate}`, 'warn');
-        }
-      }
-      
-      // Fallback to global maps, but filter to only dates <= last timeseries date if available
-      if (!gscLastDate) {
-        // Try to get from maps, but only if we can verify it's <= last timeseries date
-        // For now, use the latest from maps but log a warning
-        if (window.visibilityMap && window.visibilityMap.size > 0) {
-          const visibilityDates = Array.from(window.visibilityMap.keys()).sort();
-          const latestMapDate = visibilityDates[visibilityDates.length - 1];
-          // Only use if we don't have a timeseries date to compare against
-          // If we have window.lastGscTimeseriesDate, use that instead
-          if (window.lastGscTimeseriesDate) {
-            gscLastDate = window.lastGscTimeseriesDate;
-            debugLog(`Using last GSC timeseries date from window (filtered): ${gscLastDate}`, 'info');
-          } else {
-            gscLastDate = latestMapDate;
-            debugLog(`Using last GSC date from visibilityMap (fallback): ${gscLastDate}`, 'warn');
-          }
-        } else if (window.authorityMap && window.authorityMap.size > 0) {
-          const authorityDates = Array.from(window.authorityMap.keys()).sort();
-          const latestMapDate = authorityDates[authorityDates.length - 1];
-          if (window.lastGscTimeseriesDate) {
-            gscLastDate = window.lastGscTimeseriesDate;
-            debugLog(`Using last GSC timeseries date from window (filtered): ${gscLastDate}`, 'info');
-          } else {
-            gscLastDate = latestMapDate;
-            debugLog(`Using last GSC date from authorityMap (fallback): ${gscLastDate}`, 'warn');
-          }
-        }
-      }
-      
-      // Final fallback to date from current data if available
-      if (!gscLastDate && data && data.date) {
-        gscLastDate = data.date;
-        debugLog(`Using GSC data date (fallback): ${gscLastDate}`, 'info');
-      }
-      
-      // If still no date, try to get it from saved audit data
-      if (!gscLastDate && saved && saved.searchData && saved.searchData.date) {
-        gscLastDate = saved.searchData.date;
-        debugLog(`Using saved GSC data date (fallback): ${gscLastDate}`, 'info');
-      }
-      
-      // Format date for display
-      function formatDataDate(dateStr) {
-        if (!dateStr) return '';
-        const date = new Date(dateStr + 'T00:00:00'); // Add time to avoid timezone issues
-        return date.toLocaleDateString('en-GB', {
-          day: '2-digit',
-          month: 'short',
-          year: 'numeric'
-        });
-      }
-      
-      // Format timestamp for display
-      function formatTimestamp(timestamp) {
-        if (!timestamp) return '';
-        const date = new Date(timestamp);
-        return date.toLocaleString('en-GB', {
-          day: '2-digit',
-          month: 'short',
-          year: 'numeric',
-          hour: '2-digit',
-          minute: '2-digit'
-        });
-      }
-      
-      // Get data date for each pillar
-      function getPillarDataDate(pillarKey) {
-        if (pillarKey === 'authority' || pillarKey === 'visibility' || pillarKey === 'brandOverlay') {
-          // GSC-based pillars - use last GSC data date (Brand & Entity uses GSC query data)
-          return gscLastDate ? formatDataDate(gscLastDate) : (auditTimestamp ? formatTimestamp(auditTimestamp) : '');
-        } else {
-          // Business Profile and schema audit - use audit timestamp
-          return auditTimestamp ? formatTimestamp(auditTimestamp) : '';
-        }
-      }
-      
-      const scorecardTable = document.createElement('div');
-      scorecardTable.className = 'scorecard-section';
-      scorecardTable.innerHTML = `
-        <h3 style="margin: 0 0 1rem 0; color: var(--brand-orange);">Pillar Scorecard</h3>
-        <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow-x: auto;">
-          <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
-            <thead>
-              <tr style="background: #f5f5f5;">
-                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 10%;">Pillar</th>
-                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 6%;">Score</th>
-                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 6%;">Weight</th>
-                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 8%;">Status</th>
-                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 42%;">Description</th>
-                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 22%;">Improvement Suggestions</th>
-                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 6%;">Data Date</th>
-              </tr>
-            </thead>
-            <tbody>
-              ${(() => {
-                // Phase 3: Insert Brand & Entity row after Authority
-                const orderedPillars = getOrderedPillars(scores);
-                const brandOverlay = scores.brandOverlay;
-                const brandRowIndex = orderedPillars.findIndex(([key]) => key === 'authority');
-                
-                // Insert Brand row after Authority if it exists
-                if (brandRowIndex >= 0 && brandOverlay) {
-                  orderedPillars.splice(brandRowIndex + 1, 0, ['brandOverlay', brandOverlay.score || 0]);
-                }
-                
-                // Use historical scores for the last date in chart range (if available)
-                // This ensures scorecard matches what's shown in the trend chart
-                // Priority: 1) Fetched historical scores, 2) Window maps, 3) Current scores
-                const lastChartDate = window.latestAuditDateStr || window.lastGscTimeseriesDate || 
-                  (data && data.timeseries && data.timeseries.length > 0 ? data.timeseries[data.timeseries.length - 1].date : null);
-                
-                if (lastChartDate) {
-                  // Override scores with historical values if available
-                  orderedPillars.forEach(([key, currentScore], idx) => {
-                    let historicalScore = null;
-                    
-                    // First, try fetched historical scores
-                    if (key === 'authority' && historicalScoresForLastDate.authority !== null && historicalScoresForLastDate.authority !== undefined) {
-                      historicalScore = historicalScoresForLastDate.authority;
-                    } else if (key === 'contentSchema' && historicalScoresForLastDate.contentSchema !== null && historicalScoresForLastDate.contentSchema !== undefined) {
-                      historicalScore = historicalScoresForLastDate.contentSchema;
-                    } else if (key === 'localEntity' && historicalScoresForLastDate.localEntity !== null && historicalScoresForLastDate.localEntity !== undefined) {
-                      historicalScore = historicalScoresForLastDate.localEntity;
-                    } else if (key === 'serviceArea' && historicalScoresForLastDate.serviceArea !== null && historicalScoresForLastDate.serviceArea !== undefined) {
-                      historicalScore = historicalScoresForLastDate.serviceArea;
-                    } else if (key === 'visibility' && historicalScoresForLastDate.visibility !== null && historicalScoresForLastDate.visibility !== undefined) {
-                      historicalScore = historicalScoresForLastDate.visibility;
-                    }
-                    // Fallback to window maps if fetched scores not available
-                    else if (key === 'authority' && window.authorityMap && window.authorityMap.has(lastChartDate)) {
-                      historicalScore = window.authorityMap.get(lastChartDate);
-                    } else if (key === 'contentSchema' && window.contentSchemaMap && window.contentSchemaMap.has(lastChartDate)) {
-                      historicalScore = window.contentSchemaMap.get(lastChartDate);
-                    } else if (key === 'localEntity' && window.localEntityMap && window.localEntityMap.has(lastChartDate)) {
-                      historicalScore = window.localEntityMap.get(lastChartDate);
-                    } else if (key === 'serviceArea' && window.serviceAreaMap && window.serviceAreaMap.has(lastChartDate)) {
-                      historicalScore = window.serviceAreaMap.get(lastChartDate);
-                    } else if (key === 'visibility' && window.visibilityMap && window.visibilityMap.has(lastChartDate)) {
-                      historicalScore = window.visibilityMap.get(lastChartDate);
-                    }
-                    
-                    if (historicalScore !== null && historicalScore !== undefined) {
-                      orderedPillars[idx][1] = historicalScore;
-                      debugLog(`[Scorecard] Using historical ${key} score (${historicalScore}) for ${lastChartDate} instead of current (${currentScore})`, 'info');
-                    } else {
-                      debugLog(`[Scorecard] No historical ${key} score found for ${lastChartDate}, using current (${currentScore})`, 'info');
-                    }
-                  });
-                } else {
-                  debugLog(`[Scorecard] No last chart date available, using current audit scores`, 'info');
-                }
-                
-                return orderedPillars;
-              })().map(([key, score], index) => {
-                const rag = getRAGStatus(score);
-                
-                // Define pillar colors for scorecard table (matching charts)
-                const scorecardPillarColors = {
-                  localEntity: 'rgba(147, 51, 234, 1)', // Purple
-                  serviceArea: '#00FFFF', // Cyan
-                  authority: '#99004C', // Dark pink/magenta
-                  visibility: 'rgba(37, 99, 235, 1)', // Blue
-                  contentSchema: 'rgba(107, 114, 128, 1)' // Grey
-                };
-                
-                const pillarColor = scorecardPillarColors[key] || '#666';
-                
-                // Build Content/Schema description with schema audit data
-                let contentSchemaDesc = 'Quality and completeness of structured data markup across your domain.<br><strong>AI Importance:</strong> Structured data is the primary way AI understands your content. Schema markup directly feeds AI systems, enabling them to extract facts, relationships, and context for use in AI Overviews and answer generation.<br><strong>Diversity:</strong> Measures how varied your structured content is ‚Äì different schema types (Article, Event, Course, FAQPage, HowTo, Product, Review, VideoObject, ImageObject, ItemList, LocalBusiness) and formats across the site. A broader mix of types gives AI more reliable, context-rich signals for understanding what you do and for building accurate summaries.<br><strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from schema audit (crawls actual website pages for JSON-LD markup).<br><strong>Calculation:</strong> Weighted score based on Foundation schemas (30%), Rich Result eligibility (35%), Coverage (20%), and Type Diversity (15%).';
-                
-                if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
-                  const schemaData = schemaAudit.data;
-                  const { coverage, totalPages, pagesWithSchema, missingSchemaCount, missingSchemaPages, schemaTypes } = schemaData;
-                  
-                  // Handle pagesWithSchema - it might be an array or a number
-                  const pagesWithSchemaCount = Array.isArray(pagesWithSchema) ? pagesWithSchema.length : (typeof pagesWithSchema === 'number' ? pagesWithSchema : 0);
-                  const totalPagesCount = typeof totalPages === 'number' ? totalPages : (Array.isArray(schemaData.pages) ? schemaData.pages.length : 0);
-                  let coverageValue = 'N/A';
-                  if (typeof coverage === 'number' && !isNaN(coverage)) {
-                    coverageValue = coverage.toFixed(1);
-                  } else if (totalPagesCount > 0) {
-                    coverageValue = ((pagesWithSchemaCount / totalPagesCount) * 100).toFixed(1);
-                  }
-                  
-                  // Calculate foundation schemas - PRIORITY: use schemaData.foundation object first (most reliable)
-                  // foundation object has {Organization: true, Person: true, WebSite: true, BreadcrumbList: true}
-                  const allTypes = new Set();
-                  
-                  // First, use foundation object if available (most reliable source)
-                  if (schemaData.foundation && typeof schemaData.foundation === 'object') {
-                    Object.keys(schemaData.foundation).forEach(type => {
-                      if (schemaData.foundation[type] === true) {
-                        allTypes.add(type);
-                      }
-                    });
-                  }
-                  
-                  // Also add types from allDetectedTypes if available (for complete type list)
-                  if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
-                    schemaData.allDetectedTypes.forEach(type => {
-                      if (type) allTypes.add(type);
-                    });
-                  }
-                  
-                  // Fallback: collect from schemaTypes array (contains all types, sorted by count)
-                  // IMPORTANT: schemaTypes might be the pages array, so filter carefully
-                  if (schemaTypes && Array.isArray(schemaTypes) && allTypes.size === 0) {
-                    schemaTypes.forEach(item => {
-                      // Skip page objects (have 'url' property) - these are NOT schema types
-                      if (item && typeof item === 'object' && item.url) {
-                        return; // Skip page objects
-                      }
-                      // Only process valid schema type objects (not page objects with url property)
-                      if (item && typeof item === 'object' && item.type && typeof item.type === 'string' && !item.url) {
-                        allTypes.add(item.type);
-                      } else if (typeof item === 'string') {
-                        allTypes.add(item);
-                      }
-                    });
-                  }
-                  const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
-                  const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
-                  
-                  // Count rich result types
-                  const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
-                  const uniqueTypesCount = allTypes.size;
-                  
-                  const richResultTypesList = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
-                  const richTypesPresent = richResultTypesList.filter(type => allTypes.has(type));
-                  contentSchemaDesc += ` <strong>Data Checked:</strong> Foundation schemas: ${foundationPresent}/4 (${foundationTypes.filter(t => allTypes.has(t)).join(', ') || 'none'}), Rich result types: ${richEligibleCount}/${richResultTypesList.length} eligible, Coverage: ${coverageValue}% (${pagesWithSchemaCount}/${totalPagesCount} pages), Type diversity: ${richTypesPresent.length}/${richResultTypesList.length} rich result types present (${richTypesPresent.join(', ') || 'none'}), ${uniqueTypesCount} total unique types across the site. `;
-                  
-                  // Display schema types - use allDetectedTypes if available, otherwise try schemaTypes (but filter out pages)
-                  let schemaTypesToDisplay = [];
-                  if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
-                    schemaTypesToDisplay = schemaData.allDetectedTypes.slice(0, 15);
-                  } else if (schemaTypes && Array.isArray(schemaTypes)) {
-                    // Filter out page objects (those with 'url' property) - these are NOT schema types
-                    schemaTypesToDisplay = schemaTypes
-                      .filter(t => {
-                        // Skip null/undefined
-                        if (!t) return false;
-                        // Skip page objects (have 'url' property) - these are pages, not types!
-                        if (typeof t === 'object' && ('url' in t || ('title' in t && 'metaDescription' in t))) return false;
-                        // Only keep valid type objects or strings
-                        return typeof t === 'string' || (typeof t === 'object' && t.type && typeof t.type === 'string' && !t.url);
-                      })
-                      .slice(0, 15);
-                  }
-                  
-                  if (schemaTypesToDisplay.length > 0) {
-                    // Convert to display strings
-                    const topTypes = schemaTypesToDisplay
-                      .map(t => {
-                        if (typeof t === 'string' && t.trim()) {
-                          return t.trim();
-                        } else if (t && typeof t === 'object' && t.type && typeof t.type === 'string') {
-                          return `${t.type}${t.count ? ` (${t.count})` : ''}`;
-                        } else {
-                          // Skip objects without a valid type property - don't convert to [object Object]
-                          return null;
-                        }
-                      })
-                      .filter(t => t !== null && t !== undefined && t !== '' && typeof t === 'string' && !t.includes('[object Object]'))
-                      .join(', ');
-                    if (topTypes) {
-                      contentSchemaDesc += `Schema types found: ${topTypes}${schemaTypesToDisplay.length > 15 ? '...' : ''}. `;
-                    }
-                  }
-                  
-                  if (schemaData.missingTypes && Array.isArray(schemaData.missingTypes) && schemaData.missingTypes.length > 0) {
-                    // Ensure all items are strings - properly handle objects
-                    const missingTypesList = schemaData.missingTypes
-                      .map(t => {
-                        if (typeof t === 'string') return t;
-                        if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type;
-                        // Skip objects that can't be converted
-                        return null;
-                      })
-                      .filter(t => t !== null && t !== undefined && typeof t === 'string');
-                    if (missingTypesList.length > 0) {
-                      contentSchemaDesc += `Missing foundation types: ${missingTypesList.join(', ')}. `;
-                    }
-                  }
-                  
-                  const richTypes = Object.entries(schemaData.richEligible || {})
-                    .filter(([type, eligible]) => eligible)
-                    .map(([type]) => type);
-                  if (richTypes.length > 0) {
-                    contentSchemaDesc += `Rich result eligible: ${richTypes.join(', ')}. `;
-                  }
-                  
-                  // Check if Review schema is detected (even if not in top 10 types)
-                  const hasReviewSchema = allTypes.has('Review');
-                  if (hasReviewSchema) {
-                    // Try to get count from schemaTypes array first, otherwise check schemaData for actual count
-                    let reviewCount = schemaTypes?.find(t => t.type === 'Review')?.count || 0;
-                    // If not in top 10, check if we have schemaData with all types info
-                    if (reviewCount === 0 && schemaData.schemaTypes) {
-                      // schemaTypes in response is top 10, but we need to check if Review exists
-                      // Since it's in allTypes, it exists, but we don't have the exact count
-                      // Just indicate it's detected without showing 0
-                      contentSchemaDesc += `Review schema detected - matches GSC review snippets data. `;
-                    } else if (reviewCount > 0) {
-                      contentSchemaDesc += `Review schema detected (${reviewCount} instances) - matches GSC review snippets data. `;
-                } else {
-                      contentSchemaDesc += `Review schema detected - matches GSC review snippets data. `;
-                    }
-                  }
-                } else {
-                  contentSchemaDesc += ' <strong>Data Checked:</strong> Foundation schemas (Organization, Person, WebSite, BreadcrumbList), Rich result eligibility (Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList), schema coverage percentage, schema type diversity.';
-                }
-                
-                // Build Local Entity and Service Area descriptions based on whether we have real Business Profile data
-                let localEntityDesc, serviceAreaDesc;
-                if (hasLocalSignals && localSignalsData) {
-                  const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
-                  const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
-                  const locationsCount = localSignalsData.locations?.length || 0;
-                  const knowledgePanel = localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected';
-                  localEntityDesc = `Consistency and clarity of brand, person and business entity signals.<br><strong>AI Importance:</strong> AI systems rely on clear entity signals to understand who you are and connect your brand across platforms. Strong entity recognition helps AI include you in knowledge panels and entity-based results.<br><strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from Google Business Profile API.<br><strong>Data Checked:</strong> NAP consistency (${napScore}%), knowledge panel (${knowledgePanel}), locations (${locationsCount}), LocalBusiness schema presence, Google Business Profile data.`;
-                  serviceAreaDesc = `How clearly AI understands where lessons/workshops run and which regions you cover.<br><strong>AI Importance:</strong> AI uses geographic signals to match queries with local intent. Clear service area data helps AI surface your content for location-specific searches and local AI Overviews.<br><strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from Google Business Profile API.<br><strong>Data Checked:</strong> Service areas (${serviceAreasCount}), NAP consistency (${napScore}%), Google Business Profile service areas.`;
-                } else {
-                  localEntityDesc = 'Consistency and clarity of brand, person and business entity signals.<br><strong>AI Importance:</strong> AI systems rely on clear entity signals to understand who you are and connect your brand across platforms. Strong entity recognition helps AI include you in knowledge panels and entity-based results.<br><strong>Data Source:</strong> ‚ö†Ô∏è <span style="color: #f59e0b;">Derived calculation</span> from GSC position/CTR (not using real local signals yet).<br><strong>Data Checked:</strong> Currently calculated from search performance metrics. Real data pending: LocalBusiness schema presence, NAP consistency, Google Business Profile data, knowledge panel detection.';
-                  serviceAreaDesc = 'How clearly AI understands where lessons/workshops run and which regions you cover.<br><strong>AI Importance:</strong> AI uses geographic signals to match queries with local intent. Clear service area data helps AI surface your content for location-specific searches and local AI Overviews.<br><strong>Data Source:</strong> ‚ö†Ô∏è <span style="color: #f59e0b;">Derived calculation</span> from Local Entity score (not using real service area data yet).<br><strong>Data Checked:</strong> Currently calculated from Local Entity. Real data pending: ServiceArea schema markup, Google Business Profile service areas, geographic keywords, location pages.';
-                }
-                
-                // Format GSC data for display - use current data parameter
-                const currentGSCData = data || searchDataForBreakdown || {};
-                const ctr = currentGSCData.ctr || 0;
-                const avgPosition = currentGSCData.averagePosition || 0;
-                const totalClicks = currentGSCData.totalClicks || 0;
-                const totalImpressions = currentGSCData.totalImpressions || 0;
-                
-                // Phase 3: Build Brand & Entity description
-                let brandDesc = '';
-                if (key === 'brandOverlay') {
-                  const brand = scores.brandOverlay;
-                  if (brand) {
-                    const share = brand.brandQueryShare || 0;
-                    const brandCtr = brand.brandCtr || 0;
-                    const pos = brand.brandAvgPosition || 0;
-                    const reviewScore = brand.reviewScore || 0;
-                    const entityScore = brand.entityScore || 0;
-                    
-                    brandDesc = `E-A-T overlay for brand demand, reviews, and entity strength. Shows how clearly "Alan Ranger / Alan Ranger Photography" is recognised as a distinct brand in search and AI systems.<br><strong>AI Importance:</strong> Strong branded signals make it easier for AI to trust and summarise you correctly. High branded search share, strong review footprint and a clear entity graph (GBP + knowledge panel) all increase the chance of accurate AI overviews.<br><strong>Calculation:</strong> Combined overlay score from:<br>‚Ä¢ Brand search: share of branded queries, CTR, and average position<br>‚Ä¢ Reviews: Google Business Profile + on-site review scores and volumes<br>‚Ä¢ Entity: NAP consistency, locations, and knowledge panel detection<br><strong>Data Source:</strong> Live data from Google Search Console (brand queries), Google Business Profile API (rating, reviews, locations, service areas), and site reviews snapshot.`;
-                    
-                    // Show metrics when available
-                    if (share > 0 || brandCtr > 0 || pos > 0) {
-                      const sharePct = share != null ? (share * 100).toFixed(1) : 'N/A';
-                      const brandCtrPct = brandCtr != null ? (brandCtr * 100).toFixed(1) : 'N/A';
-                      const posStr = pos != null ? pos.toFixed(1) : 'N/A';
-                      brandDesc += ` <strong>Current Metrics:</strong> Brand queries: ${sharePct}% of impressions, brand CTR ${brandCtrPct}%, avg brand position ${posStr}.`;
-                    }
-                  } else {
-                    brandDesc = 'No brand overlay data available ‚Äì run an audit with access to query data.';
-                  }
-                }
-                
-                const descriptions = {
-                  localEntity: localEntityDesc,
-                  serviceArea: serviceAreaDesc,
-                  authority: `E-A-T (Experience, Expertise, Authoritativeness, Trustworthiness): Perceived expertise and trust in the topic space. Authority measures how much the outside world and searchers trust and choose you, not just content quality.<br><strong>AI Importance:</strong> E-A-T is critical for AI systems - they prioritize authoritative, trustworthy sources. Strong E-A-T signals help AI confidently feature your content in AI Overviews and answer boxes.<br><strong>Calculation:</strong> Behaviour Score (40%): CTR for ranking queries (position ‚â§20) + top-10 CTR. Ranking Score (20%): Average position + top-10 impression share. Backlink Score (20%): Referring domains + quality ratio. Review Score (20%): Combined ratings and counts from GBP + Trustpilot snapshot.<br><strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from Google Search Console API, Google Business Profile API, historic Trustpilot reviews snapshot, and backlink CSV upload.<br><strong>Data Checked:</strong> CTR ${ctr.toFixed(1)}%, average position ${avgPosition.toFixed(1)}, clicks ${totalClicks.toLocaleString()}, impressions ${totalImpressions.toLocaleString()}, ranking query performance (position ‚â§20), backlink metrics (referring domains, follow ratio), review ratings and counts.`,
-                  visibility: `Frequency and prominence in organic search, local pack, snippets and AI Overviews.<br><strong>AI Importance:</strong> AI systems learn from existing search performance. Higher visibility signals quality and relevance, making AI more likely to surface your content in AI-powered results and featured snippets.<br><strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from Google Search Console API.<br><strong>Data Checked:</strong> Average position ${avgPosition.toFixed(1)}, CTR ${ctr.toFixed(1)}%, total clicks ${totalClicks.toLocaleString()}, total impressions ${totalImpressions.toLocaleString()}, SERP feature appearances.`,
-                  contentSchema: contentSchemaDesc,
-                  brandOverlay: brandDesc
-                };
-                
-                // Generate dynamic next steps based on actual data and scores
-                // Use current data from function parameters
-                const getNextSteps = (pillarKey, pillarScore, gscData, schemaData) => {
-                  // Use the schemaData parameter passed to this function
-                  const currentSchemaData = schemaData;
-                  const steps = [];
-                  
-                  switch(pillarKey) {
-                    case 'contentSchema':
-                      if (schemaData && schemaData.status === 'ok' && schemaData.data) {
-                        const schemaAuditData = schemaData.data;
-                        const { coverage, missingSchemaCount, totalPages, pagesWithSchema, schemaTypes, richEligible, missingTypes } = schemaAuditData;
-                        
-                        // Collect all types for analysis - use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
-                        const allTypes = new Set();
-                        if (schemaAuditData.allDetectedTypes && Array.isArray(schemaAuditData.allDetectedTypes)) {
-                          // Use all detected types for accurate calculation
-                          schemaAuditData.allDetectedTypes.forEach(type => {
-                            if (type) allTypes.add(type);
-                          });
-                        } else if (schemaTypes && Array.isArray(schemaTypes)) {
-                          // Fallback: collect from schemaTypes array (contains all types, sorted by count)
-                          schemaTypes.forEach(item => {
-                            if (item.type) allTypes.add(item.type);
-                          });
-                        }
-                        
-                        // 1. Foundation Schemas (30% weight)
-                        const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
-                        const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
-                        const foundationMissing = foundationTypes.filter(type => !allTypes.has(type));
-                        
-                        if (foundationPresent < 4) {
-                          steps.push(`<strong>Foundation schemas (30%):</strong> ${foundationPresent}/4 present. Add: ${foundationMissing.join(', ')}`);
-                        } else {
-                          steps.push(`<strong>Foundation schemas (30%):</strong> ‚úÖ All 4 present (Organization, Person, WebSite, BreadcrumbList)`);
-                        }
-                        
-                        // 2. Rich Result Eligibility (35% weight)
-                        const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
-                        const richEligibleCount = Object.values(richEligible || {}).filter(eligible => eligible === true).length;
-                        const richMissing = richResultTypes.filter(type => !richEligible[type]);
-                        
-                        // Check for failed crawls that might affect rich result detection
-                        const failedPages = schemaAuditData.missingSchemaPages ? schemaAuditData.missingSchemaPages.filter(p => p.error).length : 0;
-                        const hasFailedCrawls = failedPages > 0;
-                        
-                        if (richEligibleCount < richResultTypes.length) {
-                          let richResultMsg = `<strong>Rich results (35%):</strong> ${richEligibleCount}/${richResultTypes.length} eligible.`;
-                          if (richMissing.length > 0) {
-                            richResultMsg += ` Missing: ${richMissing.slice(0, 3).join(', ')}${richMissing.length > 3 ? '...' : ''}`;
-                            if (hasFailedCrawls) {
-                              richResultMsg += ` <em>(Note: ${failedPages} page${failedPages !== 1 ? 's' : ''} failed to crawl - missing types may exist but weren't detected)</em>`;
-                            }
-                          }
-                          steps.push(richResultMsg);
-                        } else {
-                          steps.push(`<strong>Rich results (35%):</strong> ‚úÖ All ${richResultTypes.length} types eligible`);
-                        }
-                        
-                        // 3. Coverage (20% weight)
-                        if (coverage < 100) {
-                          steps.push(`<strong>Coverage (20%):</strong> ${coverage}% - Add schema to ${missingSchemaCount || 0} pages without markup`);
-                        } else {
-                          steps.push(`<strong>Coverage (20%):</strong> ‚úÖ 100% - All pages have schema`);
-                        }
-                        
-                        // 4. Type Diversity (15% weight)
-                        const uniqueTypesCount = allTypes.size;
-                        if (uniqueTypesCount < 15) {
-                          steps.push(`<strong>Diversity (15%):</strong> ${uniqueTypesCount} unique types. Add more schema types to reach 15+ for maximum score`);
-                        } else {
-                          steps.push(`<strong>Diversity (15%):</strong> ‚úÖ ${uniqueTypesCount} unique types (excellent diversity)`);
-                        }
-                      } else {
-                        steps.push(`<strong>Status:</strong> Schema audit data not available - run audit to see detailed metrics`);
-                      }
-                      break;
-                      
-                    case 'visibility':
-                      // Use current data from function parameters
-                      const currentGSCForVisibility = data || searchDataForBreakdown || {};
-                      if (currentGSCForVisibility) {
-                        const position = currentGSCForVisibility.averagePosition || 0;
-                        const ctr = currentGSCForVisibility.ctr || 0;
-                        
-                        if (position > 10) {
-                          steps.push(`<strong>Average position: ${position.toFixed(1)}</strong> - Target top 10 positions (currently ranking ${position > 20 ? 'below' : 'in'} page ${Math.ceil(position / 10)})`);
-                        } else {
-                          steps.push(`<strong>Average position: ${position.toFixed(1)}</strong> - Excellent! Maintain top 10 rankings`);
-                        }
-                        
-                        if (ctr < 2.0) {
-                          steps.push(`<strong>CTR: ${ctr.toFixed(1)}%</strong> - Improve click-through rate (target: 2%+) with better titles/meta descriptions`);
-                        } else {
-                          steps.push(`<strong>CTR: ${ctr.toFixed(1)}%</strong> - Good CTR! Continue optimizing for featured snippets`);
-                        }
-                        
-                        if (currentGSCForVisibility.totalImpressions < 1000) {
-                          steps.push(`<strong>Impressions: ${currentGSCForVisibility.totalImpressions}</strong> - Increase visibility by targeting more keywords`);
-                        }
-                      }
-                      break;
-                      
-                    case 'authority':
-                      // Use current data from function parameters, not stale localStorage
-                      const currentGSCForAuthority = data || searchDataForBreakdown || {};
-                      if (currentGSCForAuthority) {
-                        const ctr = currentGSCForAuthority.ctr || 0;
-                        const position = currentGSCForAuthority.averagePosition || 0;
-                        // Use current saved data (already loaded at function start)
-                        const authorityComponents = scores?.authorityComponents;
-                        const backlinkMetrics = saved?.backlinkMetrics;
-                        const localSignals = saved?.localSignals;
-                        // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
-                        const siteReviews = getTrustpilotSnapshot(saved?.siteReviews);
-                        
-                        // Show component-specific suggestions
-                        if (authorityComponents) {
-                          if (authorityComponents.behaviour < 50) {
-                            steps.push(`<strong>Behaviour Score (${Math.round(authorityComponents.behaviour)}):</strong> Improve CTR for ranking queries. Target 5%+ CTR for all queries, 10%+ for top-10 positions`);
-                          }
-                          
-                          if (authorityComponents.ranking < 50) {
-                            steps.push(`<strong>Ranking Score (${Math.round(authorityComponents.ranking)}):</strong> Improve average position and increase top-10 impression share`);
-                          }
-                          
-                          if (authorityComponents.backlinks < 50) {
-                            if (backlinkMetrics && backlinkMetrics.referringDomains > 0) {
-                              steps.push(`<strong>Backlink Score (${Math.round(authorityComponents.backlinks)}):</strong> Increase referring domains (current: ${backlinkMetrics.referringDomains}, target: 100+) and improve follow ratio (current: ${Math.round((backlinkMetrics.followRatio || 0) * 100)}%)`);
-                            } else {
-                              steps.push(`<strong>Backlink Score (${Math.round(authorityComponents.backlinks)}):</strong> Upload backlink CSV to measure domain authority`);
-                            }
-                          }
-                          
-                          if (authorityComponents.reviews < 50) {
-                            const gbpRating = (localSignals && localSignals.status === 'ok' && localSignals.data) ? localSignals.data.gbpRating : null;
-                            const gbpCount = (localSignals && localSignals.status === 'ok' && localSignals.data) ? localSignals.data.gbpReviewCount : null;
-                            const siteRating = siteReviews?.siteRating || null;
-                            const siteCount = siteReviews?.siteReviewCount || null;
-                            
-                            if (!gbpRating && !siteRating) {
-                              steps.push(`<strong>Review Score (${Math.round(authorityComponents.reviews)}):</strong> Add GBP and Trustpilot reviews to build trust signals`);
-                            } else {
-                              steps.push(`<strong>Review Score (${Math.round(authorityComponents.reviews)}):</strong> Increase review count and maintain high ratings (target: 4.5+ rating, 100+ reviews)`);
-                            }
-                          }
-                        } else {
-                          // Fallback to general suggestions if components not available
-                          if (ctr < 1.5) {
-                            steps.push(`<strong>CTR: ${ctr.toFixed(1)}%</strong> - Low click-through indicates trust issues. Improve E-A-T signals`);
-                          }
-                          
-                          if (position > 15) {
-                            steps.push(`<strong>Position: ${position.toFixed(1)}</strong> - Improve rankings through comprehensive, expert content`);
-                          }
-                        }
-                      }
-                      break;
-                      
-                    case 'localEntity':
-                      if (hasLocalSignals && localSignalsData) {
-                        const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
-                        const locationsCount = localSignalsData.locations?.length || 0;
-                        const knowledgePanel = localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected';
-                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using real Business Profile data`);
-                        steps.push(`<strong>Data:</strong> NAP consistency: ${napScore}%, Knowledge panel: ${knowledgePanel}, Locations: ${locationsCount}`);
-                        if (pillarScore < 70) {
-                          if (napScore < 100) {
-                            steps.push(`<strong>Action:</strong> Improve NAP consistency (currently ${napScore}%) - ensure Name, Address, and Phone are consistent across all platforms`);
-                          }
-                          if (!localSignalsData.knowledgePanelDetected) {
-                            steps.push(`<strong>Action:</strong> Work on knowledge panel detection - improve entity signals and citations`);
-                          }
-                          if (locationsCount === 0) {
-                            steps.push(`<strong>Action:</strong> Add business location to Google Business Profile`);
-                          }
-                        } else {
-                          steps.push(`<strong>Status:</strong> ‚úÖ Strong local entity signals detected`);
-                        }
-                      } else {
-                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using derived calculation from search performance`);
-                        steps.push(`<strong>Priority:</strong> Integrate Google Business Profile API to use real local signals data`);
-                        if (pillarScore < 70) {
-                          steps.push(`<strong>Action:</strong> Add LocalBusiness schema markup and ensure NAP consistency`);
-                        }
-                      }
-                      break;
-                      
-                    case 'serviceArea':
-                      if (hasLocalSignals && localSignalsData) {
-                        const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
-                        const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
-                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using real Business Profile data`);
-                        steps.push(`<strong>Data:</strong> Service areas: ${serviceAreasCount}, NAP consistency: ${napScore}%`);
-                        if (pillarScore < 70) {
-                          if (serviceAreasCount < 5) {
-                            steps.push(`<strong>Action:</strong> Add more service areas to Google Business Profile (currently ${serviceAreasCount}, target: 5+)`);
-                          }
-                          if (napScore < 100) {
-                            steps.push(`<strong>Action:</strong> Improve NAP consistency to boost service area score (currently ${napScore}%)`);
-                          }
-                        } else {
-                          steps.push(`<strong>Status:</strong> ‚úÖ Good service area coverage`);
-                        }
-                      } else {
-                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using derived calculation from Local Entity`);
-                        steps.push(`<strong>Priority:</strong> Integrate Google Business Profile API to get real service area data`);
-                        if (pillarScore < 70) {
-                          steps.push(`<strong>Action:</strong> Add ServiceArea schema and create location-specific pages`);
-                        }
-                      }
-                      break;
-                  }
-                  
-                  // If no specific steps generated, add generic ones
-                  if (steps.length === 0) {
-                    if (pillarScore >= 70) {
-                      steps.push('Maintain current performance');
-                      steps.push('Monitor for any score drops');
-                    } else if (pillarScore >= 40) {
-                      steps.push('Focus on improving this pillar');
-                      steps.push('Review specific metrics above');
-                    } else {
-                      steps.push('Critical: Immediate action required');
-                      steps.push('Review all data sources and implement fixes');
-                    }
-                  }
-                  
-                  return steps.slice(0, 3).map(s => `‚Ä¢ ${s}`).join('<br>') || 'No next steps available';
-                };
-                
-                // Generate suggestions based on pillar and score (fallback)
-                const getSuggestions = (pillarKey, pillarScore) => {
-                  const suggestions = {
-                    localEntity: {
-                      high: ['Maintain consistent NAP (Name, Address, Phone) across all platforms', 'Continue building personal brand mentions and citations', 'Monitor entity recognition in knowledge panels'],
-                      medium: ['Add LocalBusiness schema markup to all location pages', 'Ensure consistent business name and person name across website', 'Build more local citations and directory listings', 'Create an About page with clear entity information', 'Add author markup to content'],
-                      low: ['Implement LocalBusiness schema markup immediately', 'Create consistent NAP (Name, Address, Phone) across all platforms', 'Build local citations in relevant directories', 'Add clear About page with entity information', 'Ensure consistent branding across all touchpoints']
-                    },
-                    serviceArea: {
-                      high: ['Continue maintaining clear service area information', 'Update location pages as service areas expand'],
-                      medium: ['Add ServiceArea schema markup to location pages', 'Create dedicated pages for each service area/region', 'Include clear geographic information in content', 'Add location-specific keywords naturally', 'Update Google Business Profile with service areas'],
-                      low: ['Implement ServiceArea schema markup immediately', 'Create location-specific landing pages', 'Add clear geographic service information to homepage', 'Update all location pages with service area details', 'Include city/region names in page titles and content']
-                    },
-                    authority: {
-                      high: ['Continue producing in-depth, expert content', 'Maintain citation and backlink building efforts', 'Seek opportunities for expert quotes and mentions', 'Keep author bios and credentials up to date'],
-                      medium: ['Create more comprehensive, long-form content (2000+ words)', 'Build backlinks from authoritative photography/education sites', 'Seek guest posting opportunities on relevant blogs', 'Collect and display customer reviews/testimonials', 'Create case studies and detailed tutorials', 'Get cited in industry publications', 'Add author bylines with credentials and experience', 'Display certifications, qualifications, and awards', 'Showcase real-world experience and portfolio work', 'Build trust signals (secure site, clear contact info, privacy policy)'],
-                      low: ['Produce comprehensive, expert-level content immediately', 'Build backlinks from authoritative sources', 'Create detailed case studies and tutorials', 'Seek media mentions and expert quotes', 'Display customer reviews prominently', 'Build relationships with industry publications', 'Add clear author credentials and experience to all content', 'Display qualifications, certifications, and professional memberships', 'Create About page highlighting expertise and experience', 'Build trust signals (HTTPS, clear contact, privacy policy, terms)']
-                    },
-                    visibility: {
-                      high: ['Continue optimizing for featured snippets', 'Maintain strong ranking positions', 'Monitor SERP feature opportunities'],
-                      medium: ['Optimize content for featured snippets (answer boxes)', 'Target long-tail keywords with lower competition', 'Improve page load speed and Core Web Vitals', 'Create FAQ schema for common questions', 'Optimize for "People Also Ask" sections', 'Build internal linking structure'],
-                      low: ['Optimize for featured snippets immediately', 'Target low-competition long-tail keywords', 'Improve page speed and mobile experience', 'Add FAQ schema markup', 'Create content targeting "People Also Ask" queries', 'Build strong internal linking structure']
-                    },
-                    contentSchema: {
-                      high: ['Continue maintaining all foundation schemas (Organization, Person, WebSite, BreadcrumbList)', 'Expand rich result eligible types (Article, Event, Course, FAQ, HowTo)', 'Monitor schema validation errors', 'Add more schema type diversity'],
-                      medium: ['Add missing foundation schemas (Organization, Person, WebSite, BreadcrumbList)', 'Add rich result eligible types (Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList)', 'Ensure 100% schema coverage across all pages', 'Increase schema type diversity (target 15+ unique types)', 'Validate all schema using Google Rich Results Test'],
-                      low: ['Implement foundation schemas immediately (Organization, Person, WebSite, BreadcrumbList)', 'Add rich result eligible schemas (Article, Event, Course, FAQ, HowTo)', 'Ensure schema coverage reaches 100%', 'Add schema type diversity (target 15+ unique types)', 'Validate all schema using Google Rich Results Test']
-                    }
-                  };
-                  
-                  const pillarSuggestions = suggestions[pillarKey];
-                  if (!pillarSuggestions) return 'No suggestions available';
-                  
-                  let selectedSuggestions = [];
-                  if (pillarScore >= 70) {
-                    selectedSuggestions = pillarSuggestions.high || [];
-                  } else if (pillarScore >= 40) {
-                    selectedSuggestions = pillarSuggestions.medium || [];
-                  } else {
-                    selectedSuggestions = pillarSuggestions.low || [];
-                  }
-                  
-                  // Return top 3-4 suggestions as bullet points
-                  return selectedSuggestions.slice(0, 4).map(s => `‚Ä¢ ${s}`).join('<br>') || 'No suggestions available';
-                };
-                
-                // Phase 3: Handle Brand & Entity overlay row
-                if (key === 'brandOverlay') {
-                  const brand = scores.brandOverlay;
-                  const brandScore = brand?.score ?? 0;
-                  let brandStatus = 'red';
-                  let brandLabel = 'Red';
-                  if (brandScore >= 70) {
-                    brandStatus = 'green';
-                    brandLabel = 'Green';
-                  } else if (brandScore >= 40) {
-                    brandStatus = 'amber';
-                    brandLabel = 'Amber';
-                  }
-                  
-                  // Get brand priority for improvement suggestions
-                  const brandPriority = getBrandPriority({ brandOverlay: brand });
-                  let brandSuggestion = '';
-                  if (brandPriority) {
-                    brandSuggestion = brandPriority.message;
-                  } else if (brandScore >= 70) {
-                    brandSuggestion = 'Brand & entity signals are strong. Maintain a steady flow of new reviews and consistent use of your full brand name across site and off-site mentions.';
-                  } else if (!brand) {
-                    brandSuggestion = 'No brand overlay data available ‚Äì run an audit with access to query data.';
-                  } else {
-                    brandSuggestion = 'No immediate brand actions ‚Äì focus on Authority behaviour first.';
-                  }
-                  
-                  const brandDataDate = getPillarDataDate('authority'); // Use same date as Authority (GSC-based)
-                  const brandDataDateDisplay = brandDataDate 
-                    ? `<span style="font-size: 0.8rem; color: #666;">${brandDataDate}</span>`
-                    : '<span style="font-size: 0.8rem; color: #999;">N/A</span>';
-                  
-                  return `
-                    <tr style="border-bottom: 1px solid #eee; background: ${index % 2 === 0 ? '#ffffff' : '#fafafa'};">
-                      <td style="padding: 0.75rem; font-weight: 500;">
-                        <div style="display: flex; align-items: center; gap: 0.5rem;">
-                          <div style="width: 16px; height: 16px; background: #f59e0b; border-radius: 2px; border: 1px solid rgba(0,0,0,0.1); flex-shrink: 0;" title="Brand & Entity overlay"></div>
-                          <span>Brand & Entity <span style="color: #999; font-size: 0.85em;">(overlay)</span></span>
-                        </div>
-                      </td>
-                      <td style="padding: 0.75rem; text-align: center; font-size: 1.1rem; font-weight: 600; color: ${brandStatus === 'green' ? '#10b981' : brandStatus === 'amber' ? '#f59e0b' : '#ef4444'};">
-                        ${brand ? Math.round(brandScore) : 0}
-                      </td>
-                      <td style="padding: 0.75rem; text-align: center; font-size: 0.9rem; font-weight: 600; color: #999;" title="Overlay only - does not affect GAIO score">
-                        <span style="color: #999;">‚Äî</span>
-                      </td>
-                      <td style="padding: 0.75rem; text-align: center;">
-                        ${brand ? `
-                          <span class="rag-badge ${brandStatus}" style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.8rem;">
-                            ${brandLabel}
-                          </span>
-                        ` : `
-                          <span style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.8rem; background: #e5e7eb; color: #6b7280;">
-                            N/A
-                          </span>
-                        `}
-                      </td>
-                      <td style="padding: 0.75rem; color: #666; font-size: 0.85rem; line-height: 1.6; width: 42%;">${descriptions.brandOverlay || ''}</td>
-                      <td style="padding: 0.75rem; color: #555; font-size: 0.85rem; line-height: 1.6; width: 22%;">${brandSuggestion || 'No suggestions available'}</td>
-                      <td style="padding: 0.75rem; text-align: center; width: 6%;">${brandDataDateDisplay}</td>
-                    </tr>
-                  `;
-                }
-                
-                const weight = pillarWeights[key] || 0;
-                const isEven = index % 2 === 0;
-                
-                // Add CSV download button for Content/Schema
-                let descriptionCell = descriptions[key] || '';
-                if (key === 'contentSchema' && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
-                  const schemaData = schemaAudit.data;
-                  const missingSchemaCount = schemaData.missingSchemaCount || 0;
-                  const missingSchemaPages = schemaData.missingSchemaPages || [];
-                  
-                  // Always show button, but disable if no missing pages
-                  const buttonDisabled = missingSchemaCount === 0;
-                  const buttonStyle = buttonDisabled 
-                    ? 'padding: 0.4rem 0.8rem; font-size: 0.8rem; background: #9ca3af; color: white; border: none; border-radius: 4px; cursor: not-allowed; opacity: 0.6;'
-                    : 'padding: 0.4rem 0.8rem; font-size: 0.8rem; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;';
-                  const buttonText = missingSchemaCount > 0 
-                    ? `Download pages without schema (CSV) - ${missingSchemaCount} pages`
-                    : 'Download pages without schema (CSV) - No missing pages';
-                  
-                  const downloadTooltip = missingSchemaCount > 0 
-                    ? `Download a CSV file containing ${missingSchemaCount} page URLs that are missing schema markup. Use this list to prioritize which pages need schema added.`
-                    : 'All pages have schema markup. No download available.';
-                  descriptionCell += `<div style="margin-top: 0.75rem;"><button id="download-missing-schema" class="btn-small" style="${buttonStyle}" ${buttonDisabled ? 'disabled' : ''} title="${downloadTooltip}">${buttonText}</button></div>`;
-                }
-                
-                // Get data date for this pillar
-                const pillarDataDate = getPillarDataDate(key);
-                const dataDateDisplay = pillarDataDate 
-                  ? `<span style="font-size: 0.8rem; color: #666;">${pillarDataDate}</span>`
-                  : '<span style="font-size: 0.8rem; color: #999;">N/A</span>';
-                
-                return `
-                  <tr style="border-bottom: 1px solid #eee; background: ${isEven ? '#ffffff' : '#fafafa'};">
-                    <td style="padding: 0.75rem; font-weight: 500;">
-                      <div style="display: flex; align-items: center; gap: 0.5rem;">
-                        <div style="width: 16px; height: 16px; background: ${pillarColor}; border-radius: 2px; border: 1px solid rgba(0,0,0,0.1); flex-shrink: 0;" title="Color key for ${pillarNames[key]} in all reports"></div>
-                        <span>${pillarNames[key]}</span>
-                      </div>
-                    </td>
-                    <td style="padding: 0.75rem; text-align: center; font-size: 1.1rem; font-weight: 600; color: ${rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444'};">
-                      ${Math.round(score)}
-                    </td>
-                    <td style="padding: 0.75rem; text-align: center; font-size: 0.9rem; font-weight: 600; color: #666;">
-                      ${(weight * 100).toFixed(0)}%
-                    </td>
-                    <td style="padding: 0.75rem; text-align: center;">
-                      <span class="rag-badge ${rag.status}" style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.8rem;">
-                        ${rag.label}
-                      </span>
-                    </td>
-                    <td style="padding: 0.75rem; color: #666; font-size: 0.85rem; line-height: 1.6; width: 42%;">${descriptionCell}</td>
-                    <td style="padding: 0.75rem; color: #555; font-size: 0.85rem; line-height: 1.6; width: 22%;">${getNextSteps(key, score, currentGSCData, schemaAuditData)}</td>
-                    <td style="padding: 0.75rem; text-align: center; width: 6%;">${dataDateDisplay}</td>
-                  </tr>
-                `;
-              }).join('')}
-            </tbody>
-          </table>
-        </div>
-        <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-top: 1rem; border-left: 4px solid var(--brand-orange);">
-          <p style="margin: 0; font-size: 0.9rem; color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
-            <strong>RAG Status Guide:</strong> 
-            <span style="color: #10b981; font-weight: 600;">Green (70-100)</span> = Strong performance, 
-            <span style="color: #f59e0b; font-weight: 600;">Amber (40-69)</span> = Needs improvement, 
-            <span style="color: #ef4444; font-weight: 600;">Red (0-39)</span> = Critical issues
-          </p>
-          <p style="margin: 0; font-size: 0.9rem; color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
-            <strong>Weighting:</strong> Pillars are weighted by their importance for AI search systems. Authority (30%) and Content/Schema (25%) are most critical, as AI relies heavily on E-A-T signals and structured data. Visibility (20%) reflects how AI learns from existing performance, while Local Entity (15%) and Service Area (10%) are less critical for AI-powered results. Brand & Entity is treated as an overlay metric ‚Äì it does not change the GAIO score but influences how AI systems attribute your content and build summaries.
-          </p>
-          <p style="margin: 0; font-size: 0.85rem; color: #666; line-height: 1.6; font-style: italic;">
-            <strong>Note:</strong> Scores shown are for the last date in the trend chart range. If different audits were run on different days with different page counts or data scopes, scores may vary even if the underlying content didn't change. The "Data Date" column shows when the data was collected for each pillar.
-          </p>
-        </div>
-      `;
-      // Insert scorecard table after Score Trends chart (at the end)
-      const trendChart = document.getElementById('trendChart');
-      if (trendChart && trendChart.parentElement && trendChart.parentElement.parentNode) {
-        // Find the chart container (parent of canvas) and insert after it
-        const trendChartContainer = trendChart.parentElement;
-        trendChartContainer.parentNode.insertBefore(scorecardTable, trendChartContainer.nextSibling);
-      } else {
-        // Fallback: insert at end of dashboard container
-        const dashboardContainer = document.getElementById('dashboard');
-        if (dashboardContainer) {
-          dashboardContainer.appendChild(scorecardTable);
-        } else {
-          // Last resort: insert after pillar cards
-          pillarCards.parentNode.insertBefore(scorecardTable, pillarCards.nextSibling);
-        }
-      }
-
-      // Add CSV download handler for missing schema pages
-      const downloadBtn = document.getElementById('download-missing-schema');
-      if (downloadBtn && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
-        const schemaData = schemaAudit.data;
-        const missingSchemaCount = schemaData.missingSchemaCount || 0;
-        const missingSchemaPages = schemaData.missingSchemaPages || [];
-        
-        debugLog(`Missing schema pages: count=${missingSchemaCount}, pages=${missingSchemaPages.length}`, 'info');
-        debugLog(`Missing schema data: ${JSON.stringify(missingSchemaPages)}`, 'info');
-        
-        if (missingSchemaCount > 0 && missingSchemaPages.length > 0) {
-          downloadBtn.addEventListener('click', () => {
-            // Check if any pages have error field to determine CSV columns
-            const hasErrors = missingSchemaPages.some(p => p.error);
-            const headers = hasErrors ? ['url', 'parentUrl', 'error'] : ['url', 'parentUrl'];
-            
-            const rows = [
-              headers,
-              ...missingSchemaPages.map(p => [
-                p.url, 
-                p.parentUrl || '', 
-                ...(hasErrors ? [p.error || ''] : [])
-              ]),
-            ];
-            
-            const csv = rows
-              .map(r => r.map(v => `"${(v || '').replace(/"/g, '""')}"`).join(','))
-              .join('\n');
-            
-            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
-            const url = URL.createObjectURL(blob);
-            const a = document.createElement('a');
-            a.href = url;
-            a.download = 'ai-geo-missing-schema-pages.csv';
-            document.body.appendChild(a);
-            a.click();
-            document.body.removeChild(a);
-            URL.revokeObjectURL(url);
-          });
-        } else {
-          // Button is already disabled in the HTML, just log
-          debugLog(`No missing schema pages to download (count: ${missingSchemaCount})`, 'info');
-        }
-      } else if (!downloadBtn) {
-        debugLog('Download button not found in DOM', 'warn');
-      }
-
-      // Display snippet readiness with pie chart visualization
-      const snippetScoreElement = document.getElementById('snippetReadinessScore');
-      const gaugeStatus = document.getElementById('gaugeStatus');
-      const legendElement = document.getElementById('snippetReadinessLegend');
-      
-      if (snippetScoreElement) {
-        snippetScoreElement.textContent = snippetReadiness;
-        
-        // Color code overall score based on value
-        let colorClass = '#ef4444'; // red
-        let statusText = 'Critical';
-        if (snippetReadiness >= 70) {
-          colorClass = '#10b981'; // green
-          statusText = 'Strong';
-        } else if (snippetReadiness >= 40) {
-          colorClass = '#f59e0b'; // amber
-          statusText = 'Needs Improvement';
-        }
-        
-        snippetScoreElement.style.color = colorClass;
-        
-        // Update status text
-        if (gaugeStatus) {
-          gaugeStatus.textContent = statusText;
-          gaugeStatus.style.color = colorClass;
-        }
-      }
-      
-      // Create pie chart showing weighted components
-      const pieChartCanvas = document.getElementById('snippetReadinessPieChart');
-      if (pieChartCanvas && scores) {
-        // Destroy existing chart if it exists
-        if (window.snippetReadinessChart) {
-          window.snippetReadinessChart.destroy();
-        }
-        
-        const contentSchemaScore = Math.round(scores.contentSchema || 0);
-        const visibilityScore = Math.round(scores.visibility || 0);
-        const authorityScore = Math.round(typeof scores.authority === 'object' ? (scores.authority.score || 0) : (scores.authority || 0));
-        
-        // Generate top 5 actionable levers to improve snippet readiness
-        const explanationDiv = document.getElementById('snippetReadinessExplanation');
-        const topActionsList = document.getElementById('topActionsList');
-        if (explanationDiv && topActionsList && scores) {
-          const contentSchemaScore = Math.round(scores.contentSchema || 0);
-          const visibilityScore = Math.round(scores.visibility || 0);
-          const authorityScore = Math.round(typeof scores.authority === 'object' ? (scores.authority.score || 0) : (scores.authority || 0));
-          
-          const actions = [];
-          
-          // Authority (25% weight) - usually lowest, highest impact potential
-          if (authorityScore < 70) {
-            const potentialGain = (70 - authorityScore) * 0.25; // Max potential points if improved to 70
-            if (data && data.ctr !== undefined) {
-              const ctr = data.ctr || 0;
-              if (ctr < 1.5) {
-                actions.push({
-                  priority: 1,
-                  impact: potentialGain,
-                  text: `Improve Authority (currently ${authorityScore}%): Increase CTR from ${ctr.toFixed(1)}% to 2%+ by optimizing titles and meta descriptions. Potential gain: +${potentialGain.toFixed(1)} points.`
-                });
-              } else {
-                actions.push({
-                  priority: 1,
-                  impact: potentialGain,
-                  text: `Improve Authority (currently ${authorityScore}%): Build backlinks and improve E-A-T signals. Potential gain: +${potentialGain.toFixed(1)} points.`
-                });
-              }
-            } else {
-              actions.push({
-                priority: 1,
-                impact: potentialGain,
-                text: `Improve Authority (currently ${authorityScore}%): Build backlinks, improve E-A-T signals, and optimize CTR. Potential gain: +${potentialGain.toFixed(1)} points.`
-              });
-            }
-          }
-          
-          // Content/Schema (40% weight) - highest weight
-          if (contentSchemaScore < 100 && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
-            const schemaData = schemaAudit.data;
-            const allTypes = new Set();
-            // Use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
-            if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
-              schemaData.allDetectedTypes.forEach(type => {
-                if (type) allTypes.add(type);
-              });
-            } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
-              schemaData.schemaTypes.forEach(item => {
-                if (item.type) allTypes.add(item.type);
-              });
-            }
-            
-            const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
-            const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
-            const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
-            const uniqueTypesCount = allTypes.size;
-            
-            // Calculate potential improvements
-            if (foundationPresent < 4) {
-              const missingFoundation = foundationTypes.filter(type => !allTypes.has(type));
-              const potentialGain = ((4 - foundationPresent) / 4) * 30 * 0.4; // 30% weight of 40% total
-              actions.push({
-                priority: 2,
-                impact: potentialGain,
-                text: `Add missing foundation schemas: ${missingFoundation.join(', ')}. Currently ${foundationPresent}/4. Potential gain: +${potentialGain.toFixed(1)} points.`
-              });
-            }
-            
-            // Get list of all rich result types (must match api/schema-audit.js)
-            const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
-            const totalRichResultTypes = richResultTypes.length;
-            
-            if (richEligibleCount < totalRichResultTypes) {
-              const potentialGain = ((totalRichResultTypes - richEligibleCount) / totalRichResultTypes) * 35 * 0.4; // 35% weight of 40% total
-              
-              // Get list of which rich result types are missing
-              const applicableMissingTypes = richResultTypes.filter(type => {
-                return !schemaData.richEligible || !schemaData.richEligible[type];
-              });
-              
-              // Check for failed crawls that might affect rich result detection
-              const failedPages = schemaData.missingSchemaPages ? schemaData.missingSchemaPages.filter(p => p.error).length : 0;
-              const hasFailedCrawls = failedPages > 0;
-              
-              // Build suggestion text
-              let suggestionText;
-              if (applicableMissingTypes.length > 0) {
-                suggestionText = `Add more rich result types. Currently ${richEligibleCount}/${totalRichResultTypes} eligible. Add: ${applicableMissingTypes.join(', ')} schemas.`;
-                if (hasFailedCrawls) {
-                  suggestionText += ` Note: ${failedPages} page${failedPages !== 1 ? 's' : ''} failed to crawl - missing types may exist but weren't detected.`;
-                }
-                suggestionText += ` Potential gain: +${potentialGain.toFixed(1)} points.`;
-              } else {
-                suggestionText = `Add more rich result types. Currently ${richEligibleCount}/${totalRichResultTypes} eligible. Potential gain: +${potentialGain.toFixed(1)} points.`;
-              }
-              
-              actions.push({
-                priority: 3,
-                impact: potentialGain,
-                text: suggestionText
-              });
-            }
-            
-            if (uniqueTypesCount < 15) {
-              const potentialGain = ((15 - uniqueTypesCount) / 15) * 15 * 0.4; // 15% weight of 40% total
-              actions.push({
-                priority: 4,
-                impact: potentialGain,
-                text: `Increase schema diversity. Currently ${uniqueTypesCount} types (target: 15+). Add more schema types across different page types. Potential gain: +${potentialGain.toFixed(1)} points.`
-              });
-            }
-          }
-          
-          // Visibility (35% weight)
-          if (visibilityScore < 90 && data && data.averagePosition !== undefined) {
-            const position = data.averagePosition || 0;
-            const ctr = data.ctr || 0;
-            const potentialGain = (90 - visibilityScore) * 0.35;
-            
-            if (position > 10) {
-              actions.push({
-                priority: 5,
-                impact: potentialGain,
-                text: `Improve Visibility (currently ${visibilityScore}%): Target top 10 positions. Current average position: ${position.toFixed(1)}. Optimize for featured snippets. Potential gain: +${potentialGain.toFixed(1)} points.`
-              });
-            } else if (ctr < 2.0) {
-              actions.push({
-                priority: 5,
-                impact: potentialGain,
-                text: `Improve Visibility (currently ${visibilityScore}%): Increase CTR from ${ctr.toFixed(1)}% to 2%+ with better titles and meta descriptions. Potential gain: +${potentialGain.toFixed(1)} points.`
-              });
-            }
-          }
-          
-          // Sort by impact (highest first) and take top 5
-          actions.sort((a, b) => b.impact - a.impact);
-          const top5Actions = actions.slice(0, 5);
-          
-          // Update the list
-          topActionsList.innerHTML = top5Actions.map((action, index) => 
-            `<li style="margin: 0.5rem 0; line-height: 1.5; color: #78350f;">${action.text}</li>`
-          ).join('');
-          
-          if (top5Actions.length === 0) {
-            topActionsList.innerHTML = '<li style="margin: 0.5rem 0;">All components are performing well! Maintain current performance.</li>';
-          }
-          
-          explanationDiv.style.display = 'block';
-        } else if (explanationDiv) {
-          explanationDiv.style.display = 'none';
-        }
-        
-        // Calculate weighted contribution of each component
-        const contentSchemaContribution = (contentSchemaScore * 0.4).toFixed(1);
-        const visibilityContribution = (visibilityScore * 0.35).toFixed(1);
-        const authorityContribution = (authorityScore * 0.25).toFixed(1);
-        
-        // Create nested pie chart with fill percentages
-        // Outer ring: Weighting (40%, 35%, 25%)
-        // Inner fill: Score percentage within each segment (like fuel gauge)
-        
-        const weights = [40, 35, 25];
-        const scoresArray = [contentSchemaScore, visibilityScore, authorityScore];
-        // Match trend chart colors (avoid red/amber/green to prevent RAG confusion)
-        const colors = ['#6b7280', '#2563eb', '#99004C']; // Grey (Content/Schema), Blue (Visibility), Dark pink/magenta (Authority)
-        
-        // Calculate outer ring data (weighting percentages)
-        const outerData = weights;
-        
-        // Inner ring: Same segment sizes as outer, but we'll use custom drawing to fill only the score percentage
-        // The inner data must match outer segment sizes so they align
-        const innerData = weights; // Same sizes as outer
-        
-        // Create chart with custom drawing for inner fill segments
-        window.snippetReadinessChart = new Chart(pieChartCanvas, {
-          type: 'doughnut',
-          data: {
-            labels: [
-              `Content/Schema`,
-              `Visibility`,
-              `Authority`
-            ],
-            datasets: [
-              {
-                // Outer ring: Weighting percentages (40%, 35%, 25%)
-                label: 'Weight',
-                data: outerData,
-                backgroundColor: colors,
-                borderWidth: 4,
-                borderColor: '#ffffff',
-                cutout: '60%' // Leave room for inner fill
-              },
-              {
-                // Inner ring: Same segment sizes, but will be custom-drawn to show score fill
-                label: 'Score Fill',
-                data: innerData,
-                backgroundColor: colors.map((color, i) => {
-                  // Use darker version of segment color for unfilled portion
-                  return color + '40'; // Add transparency
-                }),
-                borderWidth: 4,
-                borderColor: '#ffffff',
-                cutout: '75%' // Inner ring showing fill
-              }
-            ]
-          },
-          options: {
-            responsive: true,
-            maintainAspectRatio: true,
-            plugins: {
-              legend: {
-                display: false // We'll use custom legend
-              },
-              tooltip: {
-                callbacks: {
-                  label: function(context) {
-                    const datasetIndex = context.datasetIndex;
-                    const index = context.dataIndex;
-                    
-                    if (datasetIndex === 0) {
-                      // Outer ring: Show weighting
-                      return `Weight: ${weights[index]}%`;
-                    } else {
-                      // Inner fill: Show score and fill percentage
-                      const score = scoresArray[index];
-                      const fillPercent = (score / 100) * 100;
-                      return `Score: ${score}% (${fillPercent.toFixed(0)}% of segment filled)`;
-                    }
-                  }
-                }
-              }
-            }
-          },
-          plugins: [{
-            id: 'innerFillAndLabels',
-            afterDraw: (chart) => {
-              const ctx = chart.ctx;
-              const outerMeta = chart.getDatasetMeta(0); // Outer ring
-              const innerMeta = chart.getDatasetMeta(1); // Inner ring
-              const centerX = chart.chartArea.left + (chart.chartArea.right - chart.chartArea.left) / 2;
-              const centerY = chart.chartArea.top + (chart.chartArea.bottom - chart.chartArea.top) / 2;
-              const outerRadius = (chart.chartArea.right - chart.chartArea.left) / 2;
-              const innerRadius = outerRadius * 0.75; // 75% cutout
-              const outerInnerRadius = outerRadius * 0.60; // 60% cutout (where inner ring starts)
-              
-              // First, clear the inner ring segments (they're drawn by Chart.js but we'll redraw them)
-              // Then draw custom filled portions based on scores
-              
-              outerMeta.data.forEach((outerSegment, index) => {
-                const score = scoresArray[index];
-                const scorePercent = score / 100; // 0 to 1
-                const startAngle = outerSegment.startAngle;
-                const endAngle = outerSegment.endAngle;
-                const segmentAngle = endAngle - startAngle;
-                const filledAngle = segmentAngle * scorePercent;
-                const filledEndAngle = startAngle + filledAngle;
-                
-                // Get RAG color for fill
-                let fillColor;
-                if (score >= 70) fillColor = '#10b981'; // Green
-                else if (score >= 40) fillColor = '#f59e0b'; // Amber
-                else fillColor = '#ef4444'; // Red
-                
-                // Draw the filled portion of this inner segment (fuel gauge effect)
-                ctx.save();
-                ctx.beginPath();
-                ctx.arc(centerX, centerY, outerInnerRadius, startAngle, filledEndAngle, false);
-                ctx.arc(centerX, centerY, innerRadius, filledEndAngle, startAngle, true);
-                ctx.closePath();
-                ctx.fillStyle = fillColor;
-                ctx.fill();
-                ctx.strokeStyle = '#ffffff';
-                ctx.lineWidth = 4;
-                ctx.stroke();
-                ctx.restore();
-                
-                // Draw weight percentage in outer segment (larger, white for grey and blue segments, black for yellow)
-                const outerSegmentMidAngle = (startAngle + endAngle) / 2;
-                // Position closer to outer edge but still inside segment (about 75% of outer ring width)
-                const outerSegmentTextRadius = outerRadius - ((outerRadius - outerInnerRadius) * 0.25);
-                const weightTextX = centerX + Math.cos(outerSegmentMidAngle) * outerSegmentTextRadius;
-                const weightTextY = centerY + Math.sin(outerSegmentMidAngle) * outerSegmentTextRadius;
-                
-                ctx.save();
-                // Use white text for grey (Content/Schema), blue (Visibility), and dark pink (Authority) segments
-                const textColor = (colors[index] === '#6b7280' || colors[index] === '#2563eb' || colors[index] === '#99004C') ? '#ffffff' : '#000000';
-                ctx.fillStyle = textColor;
-                ctx.font = 'bold 18px system-ui'; // Increased from 14px to 18px
-                ctx.textAlign = 'center';
-                ctx.textBaseline = 'middle';
-                // Add shadow for readability (dark shadow for white text, light shadow for black text)
-                if (textColor === '#ffffff') {
-                  ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
-                } else {
-                  ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
-                }
-                ctx.shadowBlur = 4;
-                ctx.shadowOffsetX = 0;
-                ctx.shadowOffsetY = 0;
-                ctx.fillText(`${weights[index]}%`, weightTextX, weightTextY);
-                ctx.restore();
-                
-                // Draw label in the center area, aligned to segment
-                const midAngle = (startAngle + endAngle) / 2;
-                // Position label in center area (about 30% from center, well inside the 75% cutout)
-                const labelRadius = outerRadius * 0.25; // Position in center area
-                const labelX = centerX + Math.cos(midAngle) * labelRadius;
-                const labelY = centerY + Math.sin(midAngle) * labelRadius;
-                
-                // Get component names
-                const componentNames = ['Content/Schema', 'Visibility', 'Authority'];
-                const weight = weights[index];
-                
-                // Calculate text bounds to avoid arrow overlap
-                // Estimate text height: 3 lines with spacing ‚âà 45px total height
-                const textHeight = 45;
-                const textWidth = 80; // Approximate max text width
-                
-                // Draw dotted arrow from label to segment edge, routing around text
-                ctx.save();
-                ctx.strokeStyle = colors[index];
-                ctx.lineWidth = 2;
-                ctx.setLineDash([5, 5]); // Dotted line
-                ctx.beginPath();
-                
-                // Start arrow from edge of text area with more padding to avoid overlap
-                // Calculate perpendicular offset to route around text
-                const perpAngle = midAngle + Math.PI / 2; // Perpendicular to segment angle
-                const textOffset = 35; // Increased from 25 to 35 - more padding from text edge
-                const perpOffset = (textHeight / 2) + 8; // Increased padding perpendicular to text
-                const arrowStartX = labelX + Math.cos(midAngle) * textOffset + Math.cos(perpAngle) * perpOffset;
-                const arrowStartY = labelY + Math.sin(midAngle) * textOffset + Math.sin(perpAngle) * perpOffset;
-                
-                // End at inner ring edge
-                const segmentEdgeX = centerX + Math.cos(midAngle) * innerRadius;
-                const segmentEdgeY = centerY + Math.sin(midAngle) * innerRadius;
-                
-                // Draw curved path around text (simple two-segment path)
-                const midX = (arrowStartX + segmentEdgeX) / 2;
-                const midY = (arrowStartY + segmentEdgeY) / 2;
-                // Offset midpoint further outward to curve around text with more clearance
-                const curveOffset = 25; // Increased from 15 to 25 for more clearance
-                const curveMidX = midX + Math.cos(perpAngle) * curveOffset;
-                const curveMidY = midY + Math.sin(perpAngle) * curveOffset;
-                
-                ctx.moveTo(arrowStartX, arrowStartY);
-                ctx.quadraticCurveTo(curveMidX, curveMidY, segmentEdgeX, segmentEdgeY);
-                ctx.stroke();
-                
-                // Draw arrowhead
-                const arrowLength = 8;
-                const arrowAngle = Math.atan2(segmentEdgeY - curveMidY, segmentEdgeX - curveMidX);
-                ctx.setLineDash([]); // Solid for arrowhead
-                ctx.beginPath();
-                ctx.moveTo(segmentEdgeX, segmentEdgeY);
-                ctx.lineTo(
-                  segmentEdgeX - arrowLength * Math.cos(arrowAngle - Math.PI / 6),
-                  segmentEdgeY - arrowLength * Math.sin(arrowAngle - Math.PI / 6)
-                );
-                ctx.moveTo(segmentEdgeX, segmentEdgeY);
-                ctx.lineTo(
-                  segmentEdgeX - arrowLength * Math.cos(arrowAngle + Math.PI / 6),
-                  segmentEdgeY - arrowLength * Math.sin(arrowAngle + Math.PI / 6)
-                );
-                ctx.stroke();
-                ctx.restore();
-                
-                // Draw text labels without circles (to prevent overlap)
-                ctx.save();
-                // Add text shadow for better readability without background
-                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
-                ctx.shadowBlur = 8;
-                ctx.shadowOffsetX = 0;
-                ctx.shadowOffsetY = 0;
-                
-                // Draw text with readable fonts
-                ctx.fillStyle = colors[index];
-                ctx.font = 'bold 13px system-ui';
-                ctx.textAlign = 'center';
-                ctx.textBaseline = 'middle';
-                
-                // First line: Component name
-                ctx.fillText(`${componentNames[index]}`, labelX, labelY - 8);
-                // Second line: Score percentage (colored) - weight removed, now in outer segment
-                ctx.fillStyle = fillColor;
-                ctx.font = 'bold 15px system-ui';
-                ctx.fillText(`Score: ${score}%`, labelX, labelY + 8);
-                
-                ctx.restore();
-              });
-            }
-          }]
-        });
-        
-        // Create custom legend with scores
-        if (legendElement) {
-          const getRAGColor = (score) => {
-            if (score >= 70) return '#10b981';
-            if (score >= 40) return '#f59e0b';
-            return '#ef4444';
-          };
-          
-          const getRAGLabel = (score) => {
-            if (score >= 70) return 'Green';
-            if (score >= 40) return 'Amber';
-            return 'Red';
-          };
-          
-          legendElement.innerHTML = `
-            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #6b7280;">
-              <div style="width: 12px; height: 12px; background: #6b7280; border-radius: 2px; flex-shrink: 0;"></div>
-              <div style="flex: 1;">
-                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Content/Schema</div>
-                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 40%<br>Score: <strong style="color: ${getRAGColor(contentSchemaScore)};">${contentSchemaScore}</strong> (${getRAGLabel(contentSchemaScore)})<br>Contribution: ${contentSchemaContribution} pts</div>
-              </div>
-            </div>
-            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #2563eb;">
-              <div style="width: 12px; height: 12px; background: #2563eb; border-radius: 2px; flex-shrink: 0;"></div>
-              <div style="flex: 1;">
-                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Visibility</div>
-                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 35%<br>Score: <strong style="color: ${getRAGColor(visibilityScore)};">${visibilityScore}</strong> (${getRAGLabel(visibilityScore)})<br>Contribution: ${visibilityContribution} pts</div>
-              </div>
-            </div>
-            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #99004C;">
-              <div style="width: 12px; height: 12px; background: #99004C; border-radius: 2px; flex-shrink: 0;"></div>
-              <div style="flex: 1;">
-                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Authority</div>
-                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 25%<br>Score: <strong style="color: ${getRAGColor(authorityScore)};">${authorityScore}</strong> (${getRAGLabel(authorityScore)})<br>Contribution: ${authorityContribution} pts</div>
-              </div>
-            </div>
-          `;
-        }
-      }
-
-      // Format numbers for display
-      const formatNumber = (num) => {
-        if (num >= 1000000) {
-          return (num / 1000000).toFixed(2) + 'M';
-        } else if (num >= 1000) {
-          return (num / 1000).toFixed(2) + 'K';
-        }
-        return num.toLocaleString();
-      };
-
-      // Display metrics
-      const metricsGrid = document.getElementById('metricsGrid');
-      metricsGrid.innerHTML = `
-        <div class="metric-card">
-          <div class="value">${formatNumber(data.totalClicks)}</div>
-          <div class="label">Total Clicks</div>
-        </div>
-        <div class="metric-card">
-          <div class="value">${formatNumber(data.totalImpressions)}</div>
-          <div class="label">Total Impressions</div>
-        </div>
-        <div class="metric-card">
-          <div class="value">${data.averagePosition.toFixed(1)}</div>
-          <div class="label">Avg Position</div>
-        </div>
-        <div class="metric-card">
-          <div class="value">${(data.ctr || 0).toFixed(1)}%</div>
-          <div class="label">CTR</div>
-        </div>
-      `;
-
-      // Wait a moment for DOM to update, then create charts (charts need visible canvas)
-      setTimeout(async () => {
-        debugLog('Starting chart creation (setTimeout callback)...', 'info');
-        
-        // Check if Chart.js is loaded
-        debugLog('Checking Chart.js availability...', 'info');
-        if (typeof Chart === 'undefined') {
-          debugLog('‚úó Chart.js library not loaded', 'error');
-          console.error('Chart.js library not loaded');
-          showStatus('Chart.js library failed to load. Please refresh the page.', 'error');
-          return;
-        }
-        debugLog('‚úì Chart.js library available', 'success');
-        debugLog(`Chart constructor: ${typeof Chart}`, 'info');
-
-        // Create radar chart
-        debugLog('Creating radar chart...', 'info');
-        const radarCanvas = document.getElementById('radarChart');
-        if (!radarCanvas) {
-          debugLog('‚úó Radar chart canvas not found', 'error');
-          console.error('Radar chart canvas not found');
-          return;
-        }
-        debugLog('‚úì Radar chart canvas found', 'success');
-        
-        // Safely destroy existing chart if it exists
-        debugLog(`Checking for existing radarChart: ${window.radarChart ? 'exists' : 'null'}`, 'info');
-        try {
-          if (window.radarChart) {
-            debugLog(`radarChart type: ${typeof window.radarChart}`, 'info');
-            debugLog(`radarChart instanceof Chart: ${window.radarChart instanceof Chart}`, 'info');
-            debugLog(`radarChart.destroy type: ${typeof window.radarChart.destroy}`, 'info');
-            
-            // Check if it's actually a Chart instance
-            if (window.radarChart instanceof Chart && typeof window.radarChart.destroy === 'function') {
-              debugLog('Destroying existing radar chart...', 'info');
-              window.radarChart.destroy();
-              debugLog('‚úì Existing radar chart destroyed', 'success');
-            } else {
-              debugLog('Existing radarChart is not a valid Chart instance, clearing...', 'info');
-            }
-            window.radarChart = null;
-          } else {
-            debugLog('No existing radar chart to destroy', 'info');
-          }
-        } catch (e) {
-          debugLog(`‚úó Error destroying existing radar chart: ${e.message}`, 'error');
-          debugLog(`Stack: ${e.stack}`, 'error');
-          console.warn('Error destroying existing radar chart:', e);
-          window.radarChart = null;
-        }
-        
-        const radarCtx = radarCanvas.getContext('2d');
-        debugLog('Creating new Chart instance for radar chart...', 'info');
-        try {
-          // Use ordered pillars for consistent ordering
-          const orderedPillars = getOrderedPillars(scores);
-          const orderedLabels = orderedPillars.map(([key]) => pillarNames[key]);
-          const orderedData = orderedPillars.map(([, score]) => score);
-          
-          // Define pillar colors for radar chart (matching trend chart)
-          const radarPillarColors = {
-            'Local Entity': 'rgba(147, 51, 234, 1)', // Purple
-            'Service Area': '#00FFFF', // Cyan (not RAG color)
-            'Authority': '#99004C', // Dark pink/magenta
-            'Visibility': 'rgba(37, 99, 235, 1)', // Blue
-            'Content / Schema': 'rgba(107, 114, 128, 1)' // Grey
-          };
-          
-          window.radarChart = new Chart(radarCtx, {
-            type: 'radar',
-            data: {
-              labels: orderedLabels,
-              datasets: [{
-                label: 'Current Scores',
-                data: orderedData,
-                backgroundColor: 'rgba(59, 130, 246, 0.2)',
-                borderColor: 'rgba(37, 99, 235, 1)',
-                pointBackgroundColor: 'rgba(37, 99, 235, 1)',
-                pointBorderColor: '#fff',
-                pointHoverBackgroundColor: '#fff',
-                pointHoverBorderColor: 'rgba(37, 99, 235, 1)'
-              }]
-            },
-            options: {
-              responsive: true,
-              maintainAspectRatio: false,
-              layout: {
-                padding: {
-                  top: 20,
-                  bottom: 20,
-                  left: 20,
-                  right: 20
-                }
-              },
-              scales: {
-                r: {
-                  beginAtZero: false,
-                  min: 20,
-                  max: 100,
-                  ticks: {
-                    stepSize: 20,
-                    font: {
-                      size: 14,
-                      weight: 'bold'
-                    },
-                    color: '#1e293b'
-                  },
-                  pointLabels: {
-                    font: {
-                      size: 16,
-                      weight: 'bold'
-                    },
-                    color: '#1e293b',
-                    padding: 20
-                  },
-                  grid: {
-                    color: 'rgba(100, 116, 139, 0.2)'
-                  },
-                  angleLines: {
-                    color: 'rgba(100, 116, 139, 0.3)'
-                  }
-                }
-              },
-              plugins: {
-                legend: {
-                  labels: {
-                    font: {
-                      size: 14,
-                      weight: 'bold'
-                    },
-                    padding: 15
-                  }
-                }
-              }
-            },
-            plugins: [{
-              id: 'radarScoreLabels',
-              afterDraw: (chart) => {
-                const ctx = chart.ctx;
-                const scale = chart.scales.r;
-                const pointLabelItems = scale._pointLabelItems || [];
-                const dataset = chart.data.datasets[0];
-                const meta = chart.getDatasetMeta(0);
-                
-                // Color each point with its pillar color (Chart.js already draws the lines)
-                pointLabelItems.forEach((item, index) => {
-                  if (item && orderedData[index] !== undefined) {
-                    const score = orderedData[index];
-                    const label = orderedLabels[index];
-                    const color = radarPillarColors[label] || 'rgba(37, 99, 235, 1)';
-                    
-                    // Get the point for this index
-                    const point = meta.data[index];
-                    if (point) {
-                      // Draw point in pillar color (Chart.js already draws the connecting lines)
-                      ctx.save();
-                      ctx.fillStyle = color;
-                      ctx.beginPath();
-                      ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
-                      ctx.fill();
-                      ctx.strokeStyle = '#fff';
-                      ctx.lineWidth = 2;
-                      ctx.stroke();
-                      ctx.restore();
-                    }
-                    
-                    // Get RAG color based on score for text
-                    let ragColor = '#1e293b'; // Default dark
-                    if (score >= 70) ragColor = '#10b981'; // Green
-                    else if (score >= 40) ragColor = '#f59e0b'; // Amber
-                    else ragColor = '#ef4444'; // Red
-                    
-                    // Draw the score percentage directly below the label
-                    ctx.save();
-                    ctx.fillStyle = ragColor;
-                    ctx.font = 'bold 14px system-ui';
-                    ctx.textAlign = 'center';
-                    ctx.textBaseline = 'top';
-                    ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
-                    ctx.shadowBlur = 4;
-                    // Position it 20px below the label
-                    const scoreY = item.y + 20;
-                    ctx.fillText(`${Math.round(score)}%`, item.x, scoreY);
-                    ctx.restore();
-                  }
-                });
-              }
-            }]
-          });
-          debugLog('‚úì Radar chart created successfully', 'success');
-          debugLog(`radarChart type after creation: ${typeof window.radarChart}`, 'info');
-          debugLog(`radarChart instanceof Chart: ${window.radarChart instanceof Chart}`, 'info');
-        } catch (e) {
-          debugLog(`‚úó Error creating radar chart: ${e.message}`, 'error');
-          debugLog(`Stack: ${e.stack}`, 'error');
-          console.error('Error creating radar chart:', e);
-        }
-
-        // Create trend chart (mock data for now)
-        debugLog('Creating trend chart...', 'info');
-        const trendCanvas = document.getElementById('trendChart');
-        if (!trendCanvas) {
-          debugLog('‚úó Trend chart canvas not found', 'error');
-          console.error('Trend chart canvas not found');
-          return;
-        }
-        debugLog('‚úì Trend chart canvas found', 'success');
-        
-        // Show loading state while fetching data
-        const trendChartContainer = trendCanvas.parentElement;
-        if (trendChartContainer) {
-          // Remove any existing error messages
-          const existingError = trendChartContainer.querySelector('.trend-chart-error');
-          if (existingError) existingError.remove();
-          
-          // Show loading spinner
-          const loadingDiv = document.createElement('div');
-          loadingDiv.className = 'trend-chart-loading';
-          loadingDiv.style.cssText = 'text-align: center; padding: 2rem; color: #64748b; font-size: 0.9rem;';
-          loadingDiv.innerHTML = '<div style="display: inline-block; width: 20px; height: 20px; border: 3px solid #e2e8f0; border-top-color: #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 0.5rem;"></div>Loading historical data from Supabase...';
-          // Add spin animation if not already in stylesheet
-          if (!document.getElementById('trend-chart-spin-style')) {
-            const style = document.createElement('style');
-            style.id = 'trend-chart-spin-style';
-            style.textContent = '@keyframes spin { to { transform: rotate(360deg); } }';
-            document.head.appendChild(style);
-          }
-          trendChartContainer.insertBefore(loadingDiv, trendCanvas);
-        }
-        
-        // Safely destroy existing chart if it exists
-        debugLog(`Checking for existing trendChart: ${window.trendChart ? 'exists' : 'null'}`, 'info');
-        try {
-          if (window.trendChart) {
-            debugLog(`trendChart type: ${typeof window.trendChart}`, 'info');
-            debugLog(`trendChart instanceof Chart: ${window.trendChart instanceof Chart}`, 'info');
-            debugLog(`trendChart.destroy type: ${typeof window.trendChart.destroy}`, 'info');
-            // Check if it's actually a Chart instance
-            if (window.trendChart instanceof Chart && typeof window.trendChart.destroy === 'function') {
-              debugLog('Destroying existing trend chart...', 'info');
-              window.trendChart.destroy();
-              debugLog('‚úì Existing trend chart destroyed', 'success');
-            } else {
-              debugLog('Existing trendChart is not a valid Chart instance, clearing...', 'info');
-            }
-            window.trendChart = null;
-          } else {
-            debugLog('No existing trend chart to destroy', 'info');
-          }
-        } catch (e) {
-          debugLog(`‚úó Error destroying existing trend chart: ${e.message}`, 'error');
-          debugLog(`Stack: ${e.stack}`, 'error');
-          console.warn('Error destroying existing trend chart:', e);
-          window.trendChart = null;
-        }
-        
-        const trendCtx = trendCanvas.getContext('2d');
-        const dateRange = parseInt(document.getElementById('dateRange').value) || 30;
-        debugLog(`Creating trend chart for date range: ${dateRange} days`, 'info');
-        
-        // Determine number of data points and label frequency based on date range
-        let numDataPoints, labelStep, dateFormat;
-        if (dateRange <= 30) {
-          // For 30 days or less: show daily data, all labels
-          numDataPoints = dateRange;
-          labelStep = 1;
-          dateFormat = { month: 'short', day: 'numeric' };
-        } else if (dateRange <= 90) {
-          // For 90 days: show daily data, label every 3-5 days
-          numDataPoints = dateRange;
-          labelStep = Math.ceil(dateRange / 20); // ~20 labels max
-          dateFormat = { month: 'short', day: 'numeric' };
-        } else if (dateRange <= 180) {
-          // For 6 months: show weekly data, label every week
-          numDataPoints = Math.ceil(dateRange / 7);
-          labelStep = 1;
-          dateFormat = { month: 'short', day: 'numeric' };
-        } else {
-          // For 12 months: show weekly data, label every 2-4 weeks
-          numDataPoints = Math.ceil(dateRange / 7);
-          labelStep = Math.ceil(numDataPoints / 15); // ~15 labels max
-          dateFormat = { month: 'short', day: 'numeric' };
-        }
-        
-        // Generate date labels and store Date objects
-        const allDates = Array.from({ length: numDataPoints }, (_, i) => {
-          const d = new Date();
-          if (dateRange <= 90) {
-            // Daily data
-            d.setDate(d.getDate() - (numDataPoints - 1 - i));
-          } else {
-            // Weekly data
-            d.setDate(d.getDate() - ((numDataPoints - 1 - i) * 7));
-          }
-          return d;
-        });
-        
-        // Store Date objects for period detection (for mock data)
-        const mockDateObjects = allDates.slice();
-        
-        // Create labels array with appropriate spacing and year detection
-        let lastVisibleYear = null;
-        const dates = allDates.map((d, i) => {
-          if (i % labelStep === 0 || i === allDates.length - 1) {
-            const currentYear = d.getFullYear();
-            const formattedDate = d.toLocaleDateString('en-GB', dateFormat);
-            
-            // Add year if it changed from the last visible label
-            if (lastVisibleYear !== null && currentYear !== lastVisibleYear) {
-              lastVisibleYear = currentYear;
-              return `${formattedDate} ${currentYear}`;
-            }
-            
-            lastVisibleYear = currentYear;
-            return formattedDate;
-          }
-          return ''; // Empty string for labels we don't want to show
-        });
-        
-        // Store date objects for mock data (will be updated if timeseries data exists)
-        chartDateObjects = mockDateObjects;
-        debugLog('Creating new Chart instance for trend chart...', 'info');
-        try {
-          // CRITICAL FIX: Always fetch fresh timeseries from Supabase instead of using stale data.timeseries
-          // This ensures we have the latest GSC data, not just what was saved during the last audit
-          let timeseries = [];
-          const propertyUrl = document.getElementById('propertyUrl')?.value || data?.propertyUrl || '';
-          if (propertyUrl) {
-            try {
-              const endDate = new Date().toISOString().split('T')[0];
-              const startDate = new Date();
-              startDate.setDate(startDate.getDate() - dateRange); // Use chart's date range
-              const startDateStr = startDate.toISOString().split('T')[0];
-              
-              debugLog(`Fetching fresh timeseries from Supabase for date range: ${startDateStr} to ${endDate}`, 'info');
-              const timeseriesResponse = await fetch(apiUrl(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDate}`));
-              if (timeseriesResponse.ok) {
-                const timeseriesData = await timeseriesResponse.json();
-                if (timeseriesData.status === 'ok' && timeseriesData.timeseries && Array.isArray(timeseriesData.timeseries)) {
-                  timeseries = timeseriesData.timeseries;
-                  debugLog(`‚úì Fetched ${timeseries.length} fresh timeseries data points from Supabase (last date: ${timeseries.length > 0 ? timeseries[timeseries.length - 1].date : 'none'})`, 'success');
-                } else {
-                  debugLog(`‚ö† Supabase timeseries response missing data, falling back to data.timeseries`, 'warn');
-                  timeseries = data.timeseries || [];
-                }
-              } else {
-                debugLog(`‚ö† Failed to fetch timeseries from Supabase (${timeseriesResponse.status}), falling back to data.timeseries`, 'warn');
-                timeseries = data.timeseries || [];
-              }
-            } catch (fetchError) {
-              debugLog(`‚ö† Error fetching fresh timeseries: ${fetchError.message}, falling back to data.timeseries`, 'warn');
-              timeseries = data.timeseries || [];
-            }
-          } else {
-            debugLog(`‚ö† No property URL found, using data.timeseries`, 'warn');
-            timeseries = data.timeseries || [];
-          }
-          
-          debugLog(`Using ${timeseries.length} timeseries data points (last date: ${timeseries.length > 0 ? timeseries[timeseries.length - 1].date : 'none'})`, 'info');
-          
-          // Check if we have data
-          if (!timeseries || timeseries.length === 0) {
-            debugLog('‚ö† No timeseries data available. Chart will show mock data. Run a new audit to get real GSC historical data.', 'warn');
-            // Show message to user (only if message doesn't already exist)
-            const trendCanvas = document.getElementById('trendChart');
-            if (trendCanvas && trendCanvas.parentElement) {
-              // Check if message already exists
-              const existingMessage = trendCanvas.parentElement.querySelector('.trend-chart-warning');
-              if (!existingMessage) {
-                const messageDiv = document.createElement('div');
-                messageDiv.className = 'trend-chart-warning';
-                messageDiv.style.cssText = 'background: #fff3cd; padding: 1rem; border-radius: 4px; border-left: 3px solid #f59e0b; margin-bottom: 1rem; font-size: 0.9rem; color: #856404;';
-                messageDiv.innerHTML = '<strong>No historical data available.</strong> The trend chart requires timeseries data from Google Search Console. Please run a new audit to populate the chart with real historical data.';
-                trendCanvas.parentElement.insertBefore(messageDiv, trendCanvas);
-              }
-            }
-          }
-          
-          // If we have timeseries data, use it; otherwise fall back to mock data
-          let localEntityData, serviceAreaData, authorityData, visibilityData, contentSchemaData, brandOverlayData;
-          let contentSchemaDataEstimated = []; // Declare in outer scope for use in chart creation
-          let chartDates = dates;
-          let chartDateObjects = []; // Store Date objects for period detection
-          
-          // Declare maps in outer scope so they're accessible everywhere
-          // Also make them global so displayDashboard can access them for Data Date display
-          let contentSchemaHistory = [];
-          let contentSchemaMap = new Map();
-          let localEntityMap = new Map();
-          let serviceAreaMap = new Map();
-          let authorityMap = new Map(); // Store historical Authority scores from Supabase (legacy: single value)
-          let authorityBySegmentMap = new Map(); // Store historical segmented Authority scores from Supabase (new: {all, nonEducation, money})
-          let visibilityMap = new Map(); // Store historical Visibility scores from Supabase
-          let brandOverlayMap = new Map(); // Store historical Brand Overlay scores from Supabase
-          
-          // Make maps global for access by displayDashboard
-          window.visibilityMap = visibilityMap;
-          window.authorityMap = authorityMap;
-          window.brandOverlayMap = brandOverlayMap;
-          const currentContentSchema = scores.contentSchema || 0;
-          const currentBrandOverlay = scores.brandOverlay?.score || null;
-          
-          // Declare latestAuditDateStr and latestAuditDate in outer scope so they're accessible in timeseries.forEach
-          let today = new Date();
-          today.setHours(0, 0, 0, 0);
-          let todayStr = today.toISOString().split('T')[0];
-          let latestAuditDateStr = todayStr; // Default to today if no audit found
-          let latestAuditDate = null; // Will be set from historical data
-          
-          if (timeseries.length > 0) {
-            // Fetch historical Content/Schema data from Supabase (async operation)
-            const propertyUrl = document.getElementById('propertyUrl')?.value || '';
-            // Use the actual date range from timeseries data (not calculated from today)
-            // This ensures we query the correct year (2024 vs 2025)
-            const timeseriesStartDate = timeseries[0].date; // First date in timeseries
-            const timeseriesEndDate = timeseries[timeseries.length - 1].date; // Last date in timeseries
-            // CRITICAL: Query ALL historical audit data, not just timeseries range
-            // The user manually added 18 months of historical data, so we need to fetch all of it
-            // Query from 2 years ago to today to ensure we get all historical data
-            // Don't limit to timeseries range - fetch all available historical audit data
-            const historicalStartDate = new Date();
-            historicalStartDate.setFullYear(historicalStartDate.getFullYear() - 2);
-            const startDate = historicalStartDate.toISOString().split('T')[0]; // 2 years ago
-            const endDate = todayStr; // Use today, not timeseries end date
-            
-            debugLog(`Fetching Content/Schema history from Supabase: ${startDate} to ${endDate} (ALL historical data)`, 'info');
-            debugLog(`Timeseries date range: ${timeseriesStartDate} to ${timeseriesEndDate}`, 'info');
-            
-            // Fetch historical data asynchronously (includes Content/Schema AND Business Profile data)
-            if (propertyUrl) {
-              try {
-                contentSchemaHistory = await fetchContentSchemaHistory(propertyUrl, startDate, endDate);
-                
-                // Handle multiple audits per day: only keep the latest audit for each date
-                // Group by date and keep only the most recent one (by timestamp if available, or last in array)
-                const auditsByDate = new Map();
-                contentSchemaHistory.forEach(record => {
-                  let normalizedDate = null;
-                  if (record.date) {
-                    if (typeof record.date === 'string') {
-                      normalizedDate = record.date.split('T')[0];
-                    } else if (record.date instanceof Date) {
-                      normalizedDate = record.date.toISOString().split('T')[0];
-                    } else {
-                      normalizedDate = String(record.date).split('T')[0];
-                    }
-                  }
-                  
-                  if (normalizedDate) {
-                    // If we already have an audit for this date, keep the one with later timestamp
-                    const existing = auditsByDate.get(normalizedDate);
-                    if (!existing || (record.timestamp && existing.timestamp && record.timestamp > existing.timestamp)) {
-                      auditsByDate.set(normalizedDate, record);
-                    }
-                  }
-                });
-                
-                // Use only the latest audit per date
-                const deduplicatedHistory = Array.from(auditsByDate.values());
-                debugLog(`Deduplicated ${contentSchemaHistory.length} audits to ${deduplicatedHistory.length} unique dates (removed ${contentSchemaHistory.length - deduplicatedHistory.length} duplicate dates)`, 'info');
-                contentSchemaHistory = deduplicatedHistory;
-                
-                // CRITICAL: Validate audits for partial/failed data (for non-GSC pillars only)
-                // Detect audits with suspiciously low page counts compared to recent audits
-                // This prevents using partial audit data for Content/Schema and Local Entity/Service Area
-                const validateAuditQuality = (records) => {
-                  if (records.length === 0) return records;
-                  
-                  // Sort by date to find baseline
-                  const sortedRecords = [...records].sort((a, b) => {
-                    const dateA = a.date ? (typeof a.date === 'string' ? a.date.split('T')[0] : String(a.date).split('T')[0]) : '';
-                    const dateB = b.date ? (typeof b.date === 'string' ? b.date.split('T')[0] : String(b.date).split('T')[0]) : '';
-                    return dateA.localeCompare(dateB);
-                  });
-                  
-                  // Find the median page count from recent audits (last 10 audits or all if < 10)
-                  const recentAudits = sortedRecords.slice(-10);
-                  const pageCounts = recentAudits
-                    .map(r => r.schemaTotalPages || r.schema_total_pages || 0)
-                    .filter(count => count > 0)
-                    .sort((a, b) => a - b);
-                  
-                  if (pageCounts.length === 0) {
-                    debugLog(`[Audit Validation] No page count data available, skipping validation`, 'info');
-                    return records;
-                  }
-                  
-                  // Use median as baseline (more robust than mean for outliers)
-                  const medianPageCount = pageCounts[Math.floor(pageCounts.length / 2)];
-                  const minAcceptablePages = Math.max(10, medianPageCount * 0.1); // At least 10% of median, minimum 10 pages
-                  
-                  debugLog(`[Audit Validation] Median page count: ${medianPageCount}, Minimum acceptable: ${minAcceptablePages}`, 'info');
-                  
-                  // Mark records with suspiciously low page counts
-                  const validatedRecords = records.map(record => {
-                    const pageCount = record.schemaTotalPages || record.schema_total_pages || 0;
-                    const isSuspicious = pageCount > 0 && pageCount < minAcceptablePages;
-                    
-                    if (isSuspicious) {
-                      debugLog(`[Audit Validation] ‚ö†Ô∏è Marking audit ${record.date} as suspicious: ${pageCount} pages (expected ~${medianPageCount})`, 'warn');
-                      record._isPartialAudit = true;
-                      record._partialReason = `Low page count: ${pageCount} pages (expected ~${medianPageCount})`;
-                    }
-                    
-                    return record;
-                  });
-                  
-                  return validatedRecords;
-                };
-                
-                // Validate audit quality
-                contentSchemaHistory = validateAuditQuality(contentSchemaHistory);
-                
-                // CRITICAL: Sort by date to ensure chronological processing
-                // This ensures we always have a "last good value" to fall back to for partial audits
-                contentSchemaHistory.sort((a, b) => {
-                  const dateA = a.date ? (typeof a.date === 'string' ? a.date.split('T')[0] : String(a.date).split('T')[0]) : '';
-                  const dateB = b.date ? (typeof b.date === 'string' ? b.date.split('T')[0] : String(b.date).split('T')[0]) : '';
-                  return dateA.localeCompare(dateB);
-                });
-                
-                // CRITICAL: Validate and smooth Authority scores
-                // Backlink scores can drop to 0 if CSV isn't loaded, causing Authority to fluctuate wildly
-                // Use last known good backlink score if current one is suspiciously low
-                let lastGoodBacklinkScore = null;
-                contentSchemaHistory.forEach(record => {
-                  const backlinkScore = record.authorityBacklinkScore || record.authority_backlink_score;
-                  if (backlinkScore !== null && backlinkScore !== undefined && backlinkScore > 0) {
-                    lastGoodBacklinkScore = backlinkScore;
-                  } else if (lastGoodBacklinkScore !== null && backlinkScore === 0) {
-                    // Backlink score dropped to 0 - likely CSV not loaded, use last good value
-                    record._useLastGoodBacklink = true;
-                    record._lastGoodBacklinkScore = lastGoodBacklinkScore;
-                    debugLog(`[Authority Validation] ‚ö†Ô∏è Backlink score is 0 for ${record.date}, using last good value (${lastGoodBacklinkScore})`, 'warn');
-                  }
-                });
-                
-                // Recalculate Authority scores with smoothed backlink data
-                contentSchemaHistory.forEach(record => {
-                  if (record._useLastGoodBacklink && record.authorityScore !== null && record.authorityScore !== undefined) {
-                    const behaviour = record.authorityBehaviourScore || record.authority_behaviour_score || 0;
-                    const ranking = record.authorityRankingScore || record.authority_ranking_score || 0;
-                    const backlinks = record._lastGoodBacklinkScore || 0;
-                    const reviews = record.authorityReviewScore || record.authority_review_score || 0;
-                    
-                    // Recalculate Authority with smoothed backlink score
-                    const recalculated = Math.round(
-                      0.4 * behaviour +
-                      0.2 * ranking +
-                      0.2 * backlinks +
-                      0.2 * reviews
-                    );
-                    
-                    if (recalculated !== record.authorityScore) {
-                      debugLog(`[Authority Validation] Recalculated Authority for ${record.date}: ${record.authorityScore} ‚Üí ${recalculated} (using last good backlink score ${backlinks})`, 'info');
-                      record._recalculatedAuthorityScore = recalculated; // Store separately, don't overwrite original
-                    }
-                  }
-                });
-                
-                // Create maps of dates to scores from Supabase
-                // Normalize dates to YYYY-MM-DD format (Supabase might return with timezone)
-                // latestAuditDate is already tracked from the deduplication loop above
-                // CRITICAL: Skip partial audits for non-GSC pillars (Content/Schema, Local Entity, Service Area)
-                let lastGoodContentSchema = null;
-                let lastGoodContentSchemaDate = null;
-                let lastGoodLocalEntity = null;
-                let lastGoodLocalEntityDate = null;
-                let lastGoodServiceArea = null;
-                let lastGoodServiceAreaDate = null;
-                
-                contentSchemaHistory.forEach(record => {
-                  // Ensure date is in YYYY-MM-DD format (strip time if present)
-                  // Handle both date strings and Date objects
-                  let normalizedDate = null;
-                  if (record.date) {
-                    if (typeof record.date === 'string') {
-                      normalizedDate = record.date.split('T')[0];
-                    } else if (record.date instanceof Date) {
-                      normalizedDate = record.date.toISOString().split('T')[0];
-                    } else {
-                      normalizedDate = String(record.date).split('T')[0];
-                    }
-                  }
-                  
-                  if (normalizedDate) {
-                    // Update latestAuditDate if this date is newer
-                    if (!latestAuditDate || normalizedDate > latestAuditDate) {
-                      latestAuditDate = normalizedDate;
-                      latestAuditDateStr = normalizedDate;
-                    }
-                    // Content/Schema data - SKIP if partial audit
-                    if (record.contentSchemaScore !== null && record.contentSchemaScore !== undefined) {
-                      if (record._isPartialAudit) {
-                        debugLog(`[Audit Validation] ‚ö†Ô∏è Skipping Content/Schema for ${normalizedDate} (partial audit: ${record._partialReason}), using last good value (${lastGoodContentSchema} from ${lastGoodContentSchemaDate || 'none'})`, 'warn');
-                        // Use last good value instead
-                        if (lastGoodContentSchema !== null && lastGoodContentSchema !== undefined) {
-                          contentSchemaMap.set(normalizedDate, lastGoodContentSchema);
-                        }
-                      } else {
-                        contentSchemaMap.set(normalizedDate, record.contentSchemaScore);
-                        lastGoodContentSchema = record.contentSchemaScore;
-                        lastGoodContentSchemaDate = normalizedDate;
-                        debugLog(`Mapped Content/Schema: ${normalizedDate} = ${record.contentSchemaScore}`, 'info');
-                      }
-                    }
-                    // Business Profile data (Local Entity and Service Area) - SKIP if partial audit
-                    if (record.localEntityScore !== null && record.localEntityScore !== undefined) {
-                      if (record._isPartialAudit) {
-                        debugLog(`[Audit Validation] ‚ö†Ô∏è Skipping Local Entity for ${normalizedDate} (partial audit: ${record._partialReason}), using last good value (${lastGoodLocalEntity} from ${lastGoodLocalEntityDate || 'none'})`, 'warn');
-                        // Use last good value instead
-                        if (lastGoodLocalEntity !== null && lastGoodLocalEntity !== undefined) {
-                          localEntityMap.set(normalizedDate, lastGoodLocalEntity);
-                        }
-                      } else {
-                        localEntityMap.set(normalizedDate, record.localEntityScore);
-                        lastGoodLocalEntity = record.localEntityScore;
-                        lastGoodLocalEntityDate = normalizedDate;
-                        debugLog(`Mapped Local Entity: ${normalizedDate} = ${record.localEntityScore}`, 'info');
-                      }
-                    }
-                    if (record.serviceAreaScore !== null && record.serviceAreaScore !== undefined) {
-                      if (record._isPartialAudit) {
-                        debugLog(`[Audit Validation] ‚ö†Ô∏è Skipping Service Area for ${normalizedDate} (partial audit: ${record._partialReason}), using last good value (${lastGoodServiceArea} from ${lastGoodServiceAreaDate || 'none'})`, 'warn');
-                        // Use last good value instead
-                        if (lastGoodServiceArea !== null && lastGoodServiceArea !== undefined) {
-                          serviceAreaMap.set(normalizedDate, lastGoodServiceArea);
-                        }
-                      } else {
-                        serviceAreaMap.set(normalizedDate, record.serviceAreaScore);
-                        lastGoodServiceArea = record.serviceAreaScore;
-                        lastGoodServiceAreaDate = normalizedDate;
-                        debugLog(`Mapped Service Area: ${normalizedDate} = ${record.serviceAreaScore}`, 'info');
-                      }
-                    }
-                    // Authority data (use stored Authority score if available, calculated with new formula)
-                    // CRITICAL: Use recalculated Authority score if backlink smoothing was applied
-                    if (record.authorityScore !== null && record.authorityScore !== undefined) {
-                      // Use recalculated score if available (from backlink smoothing)
-                      const authorityScoreToUse = record._recalculatedAuthorityScore !== undefined 
-                        ? record._recalculatedAuthorityScore 
-                        : record.authorityScore;
-                      authorityMap.set(normalizedDate, authorityScoreToUse);
-                      if (record._recalculatedAuthorityScore !== undefined) {
-                        debugLog(`Mapped Authority (smoothed): ${normalizedDate} = ${authorityScoreToUse} (was ${record.authorityScore})`, 'info');
-                      } else {
-                        debugLog(`Mapped Authority: ${normalizedDate} = ${authorityScoreToUse}`, 'info');
-                      }
-                    }
-                    // Segmented Authority data (new: store segmented scores for historical tracking)
-                    if (record.authorityBySegment !== null && record.authorityBySegment !== undefined) {
-                      // authorityBySegment is a JSON object: {all: {total, behaviour, ranking, backlinks, reviews}, nonEducation: {...}, money: {...}}
-                      authorityBySegmentMap.set(normalizedDate, record.authorityBySegment);
-                      debugLog(`Mapped Authority by Segment: ${normalizedDate} = ${JSON.stringify(record.authorityBySegment)}`, 'info');
-                    }
-                    // Visibility data (use stored Visibility score from Supabase)
-                    if (record.visibilityScore !== null && record.visibilityScore !== undefined) {
-                      visibilityMap.set(normalizedDate, record.visibilityScore);
-                      debugLog(`Mapped Visibility: ${normalizedDate} = ${record.visibilityScore}`, 'info');
-                    }
-                    // Brand Overlay data (Phase 1: stored as brand_score)
-                    if (record.brandScore !== null && record.brandScore !== undefined) {
-                      brandOverlayMap.set(normalizedDate, record.brandScore);
-                      debugLog(`Mapped Brand Overlay: ${normalizedDate} = ${record.brandScore}`, 'info');
-                    }
-                  }
-                });
-                
-                const hasHistoricalData = contentSchemaHistory.length > 0;
-                if (hasHistoricalData) {
-                  debugLog(`Using ${contentSchemaHistory.length} historical audit records from Supabase`, 'info');
-                  // Debug: Show what data we have for each pillar
-                  const contentSchemaCount = Array.from(contentSchemaMap.values()).filter(v => v !== null && v !== undefined).length;
-                  const localEntityCount = Array.from(localEntityMap.values()).filter(v => v !== null && v !== undefined).length;
-                  const serviceAreaCount = Array.from(serviceAreaMap.values()).filter(v => v !== null && v !== undefined).length;
-                  const authorityCount = Array.from(authorityMap.values()).filter(v => v !== null && v !== undefined).length;
-                  const visibilityCount = Array.from(visibilityMap.values()).filter(v => v !== null && v !== undefined).length;
-                  const brandCount = Array.from(brandOverlayMap.values()).filter(v => v !== null && v !== undefined).length;
-                  debugLog(`[Supabase Data] Content/Schema: ${contentSchemaCount} entries, Local Entity: ${localEntityCount} entries, Service Area: ${serviceAreaCount} entries, Authority: ${authorityCount} entries, Visibility: ${visibilityCount} entries, Brand: ${brandCount} entries`, 'info');
-                  
-                  // Debug: Show sample records to understand structure
-                  if (contentSchemaHistory.length > 0) {
-                    const sampleRecord = contentSchemaHistory[0];
-                    debugLog(`[Sample Record] Keys: ${Object.keys(sampleRecord).join(', ')}, date: ${sampleRecord.date}, contentSchemaScore: ${sampleRecord.contentSchemaScore}, localEntityScore: ${sampleRecord.localEntityScore}, serviceAreaScore: ${sampleRecord.serviceAreaScore}`, 'info');
-                  }
-                  
-                  // Show latest dates for each pillar
-                  if (contentSchemaMap.size > 0) {
-                    const latestContentSchemaDate = Array.from(contentSchemaMap.keys()).sort().reverse()[0];
-                    debugLog(`[Supabase Data] Latest Content/Schema date: ${latestContentSchemaDate}`, 'info');
-                  }
-                  if (localEntityMap.size > 0) {
-                    const latestLocalEntityDate = Array.from(localEntityMap.keys()).sort().reverse()[0];
-                    debugLog(`[Supabase Data] Latest Local Entity date: ${latestLocalEntityDate}`, 'info');
-                  }
-                  if (serviceAreaMap.size > 0) {
-                    const latestServiceAreaDate = Array.from(serviceAreaMap.keys()).sort().reverse()[0];
-                    debugLog(`[Supabase Data] Latest Service Area date: ${latestServiceAreaDate}`, 'info');
-                  }
-                } else {
-                  debugLog(`No historical data found. Will use current scores for all points.`, 'info');
-                }
-                
-                // Phase 3: Render Money Pages trend chart
-                if (typeof renderMoneyPagesTrendChart === 'function') {
-                  setTimeout(() => {
-                    renderMoneyPagesTrendChart(contentSchemaHistory);
-                  }, 1000); // Delay to ensure DOM is ready and chart container exists
-                } else {
-                  debugLog('‚ö† renderMoneyPagesTrendChart function not found', 'warn');
-                }
-              } catch (error) {
-                debugLog(`‚ö† Error fetching historical data: ${error.message}`, 'warn');
-                // Ensure latestAuditDateStr is still defined even if fetch fails
-                // It's already set to todayStr as default, so it should be fine
-                debugLog(`Using default latestAuditDateStr: ${latestAuditDateStr}`, 'info');
-                contentSchemaHistory = [];
-              }
-            } else {
-              debugLog(`No property URL found. Cannot fetch historical data.`, 'info');
-            }
-            
-            // Get current Business Profile data for Local Entity and Service Area (fallback if no historical data)
-            const hasLocalSignals = saved && saved.localSignals && saved.localSignals.status === 'ok' && saved.localSignals.data;
-            const localSignalsData = hasLocalSignals ? saved.localSignals.data : null;
-            
-            // Calculate current Local Entity and Service Area scores from Business Profile data (if available)
-            // These will be used as fallback when historical data is not available for a specific date
-            let currentLocalEntity, currentServiceArea;
-            if (hasLocalSignals && localSignalsData) {
-              // Local Entity: NAP consistency + bonuses
-              let baseScore = localSignalsData.napConsistencyScore || 0;
-              if (localSignalsData.knowledgePanelDetected) {
-                baseScore = Math.min(100, baseScore + 10);
-              }
-              if (localSignalsData.locations && localSignalsData.locations.length > 0) {
-                baseScore = Math.min(100, baseScore + 5);
-              }
-              currentLocalEntity = clampScore(baseScore);
-              
-              // Service Area: based on service areas count
-              const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
-              if (serviceAreasCount === 0) {
-                currentServiceArea = 0;
-              } else if (serviceAreasCount >= 8) {
-                // 8+ service areas = 100 (more reasonable threshold)
-                currentServiceArea = 100;
-              } else {
-                // Linear scale: 1 area = 12.5 points (8 areas = 100)
-                currentServiceArea = Math.min(100, serviceAreasCount * 12.5);
-              }
-              
-              // Apply NAP consistency as a multiplier (if NAP is low, reduce service area score)
-              if (localSignalsData.napConsistencyScore !== null && localSignalsData.napConsistencyScore < 100) {
-                const napMultiplier = localSignalsData.napConsistencyScore / 100;
-                currentServiceArea = Math.round(currentServiceArea * napMultiplier);
-              }
-              currentServiceArea = clampScore(currentServiceArea);
-              
-              debugLog(`Trend chart: Current Business Profile data - Local Entity=${currentLocalEntity}, Service Area=${currentServiceArea} (used as fallback)`, 'info');
-            } else {
-              // Fallback: use derived calculation
-              currentLocalEntity = null;
-              currentServiceArea = null;
-              debugLog('Trend chart: No Business Profile data available, will use derived calculation for dates without historical data', 'warn');
-            }
-            
-            // Calculate pillar scores for each timeseries point
-            // For Local Entity and Service Area: use historical Business Profile data if available,
-            // otherwise use calculated data from GSC (derived calculation)
-            const calculatePillarFromMetrics = (position, ctr, dateStr = null, topQueries = null, backlinkMetrics = null, localSignals = null, siteReviews = null) => {
-              // Position score (same formula as main calculation)
-              const clampedPos = Math.max(1, Math.min(40, position));
-              const scale = (clampedPos - 1) / 39;
-              const posScore = 100 - scale * 90;
-              
-              // CTR score (needed for Local Entity calculation and Authority fallback)
-              // Convert ctr from percentage (0-100) to decimal (0-1), then apply formula
-              const ctrDecimal = ctr / 100; // Convert percentage to decimal (e.g., 10% -> 0.10)
-              const ctrScore = Math.min((ctrDecimal / 0.10) * 100, 100);
-              
-              // Calculate each pillar (same formulas as main calculation)
-              const visibility = clampScore(posScore);
-              
-              // Authority: New 4-component model
-              // Check if we have stored Authority component scores for this date
-              let authority;
-              if (dateStr && authorityMap && authorityMap.has(dateStr)) {
-                // Use stored Authority score from Supabase (calculated with new formula)
-                authority = authorityMap.get(dateStr);
-                debugLog(`Authority: Using stored score (${authority}) for ${dateStr}`, 'info');
-              } else if (topQueries && Array.isArray(topQueries) && topQueries.length > 0) {
-                // We have topQueries data - use full 4-component calculation
-                const queriesForCalculation = topQueries.map(q => ({
-                  clicks: q.clicks || 0,
-                  impressions: q.impressions || 0,
-                  ctr: (q.ctr || 0) / 100, // Convert percentage to decimal
-                  position: q.position || 0
-                }));
-                
-                const behaviourScore = computeBehaviourScore(queriesForCalculation);
-                const rankingScore = computeRankingScore(queriesForCalculation);
-                
-                // Use real backlink and review scores if available (for today's date)
-                const backlinkScore = computeBacklinkScore(backlinkMetrics);
-                
-                // Get review data
-                const gbpRating = (localSignals && localSignals.status === 'ok' && localSignals.data) 
-                  ? (localSignals.data.gbpRating !== null && localSignals.data.gbpRating !== undefined ? localSignals.data.gbpRating : null)
-                  : null;
-                const gbpCount = (localSignals && localSignals.status === 'ok' && localSignals.data) 
-                  ? (localSignals.data.gbpReviewCount !== null && localSignals.data.gbpReviewCount !== undefined ? localSignals.data.gbpReviewCount : null)
-                  : null;
-                const siteRating = siteReviews?.siteRating !== null && siteReviews?.siteRating !== undefined ? siteReviews.siteRating : null;
-                const siteCount = siteReviews?.siteReviewCount !== null && siteReviews?.siteReviewCount !== undefined ? siteReviews.siteReviewCount : null;
-                
-                const reviewScore = computeReviewScore({
-                  gbpRating,
-                  gbpCount,
-                  siteRating,
-                  siteCount
-                });
-                
-                authority = clampScore(
-                  0.4 * behaviourScore +
-                  0.2 * rankingScore +
-                  0.2 * backlinkScore +
-                  0.2 * reviewScore
-                );
-                debugLog(`Authority: Calculated from topQueries for ${dateStr || 'current'}: Behaviour=${behaviourScore.toFixed(1)}, Ranking=${rankingScore.toFixed(1)}, Backlinks=${backlinkScore}, Reviews=${reviewScore}, Final=${authority}`, 'info');
-              } else {
-                // Fallback: Simplified Authority calculation from aggregate metrics
-                // Estimate Behaviour and Ranking scores from aggregate metrics
-                // Behaviour: Use aggregate CTR as proxy (simplified)
-                const estimatedBehaviourScore = Math.min(ctrScore * 0.7, 70); // Max 70 points
-                
-                // Ranking: Use position score (simplified)
-                const estimatedRankingScore = posScore * 0.6; // Max 60 points (position) + 40 (share estimate)
-                const estimatedShareScore = 20; // Conservative estimate for top-10 share
-                const estimatedRanking = estimatedRankingScore + estimatedShareScore;
-                
-                const backlinkScore = 50; // Placeholder
-                const reviewScore = 50; // Placeholder
-                
-                authority = clampScore(
-                  0.4 * estimatedBehaviourScore +
-                  0.2 * estimatedRanking +
-                  0.2 * backlinkScore +
-                  0.2 * reviewScore
-                );
-                debugLog(`Authority: Using simplified calculation from aggregate metrics for ${dateStr || 'current'}: Estimated Behaviour=${estimatedBehaviourScore.toFixed(1)}, Estimated Ranking=${estimatedRanking.toFixed(1)}, Final=${authority}`, 'info');
-              }
-              
-              // For Local Entity and Service Area:
-              // 1. Check for historical Business Profile data for this specific date
-              // 2. If no historical data, use calculated data from GSC (derived calculation)
-              // 3. Only use current Business Profile data as last resort (for recent dates without historical data)
-              let localEntity, serviceArea;
-              
-              if (dateStr) {
-                const historicalLocalEntity = localEntityMap.get(dateStr);
-                const historicalServiceArea = serviceAreaMap.get(dateStr);
-                
-                if (historicalLocalEntity !== null && historicalLocalEntity !== undefined) {
-                  // Use historical Business Profile data
-                  localEntity = historicalLocalEntity;
-                } else {
-                  // Use calculated data from GSC (derived calculation) for historical dates
-                  localEntity = clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
-                }
-                
-                if (historicalServiceArea !== null && historicalServiceArea !== undefined) {
-                  // Use historical Business Profile data
-                  serviceArea = historicalServiceArea;
-                } else {
-                  // Use calculated data from GSC (derived calculation) for historical dates
-                  serviceArea = clampScore(localEntity - 5);
-                }
-              } else {
-                // No date provided - use current Business Profile data if available, otherwise calculated
-                localEntity = currentLocalEntity !== null 
-                  ? currentLocalEntity 
-                  : clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
-                serviceArea = currentServiceArea !== null 
-                  ? currentServiceArea 
-                  : clampScore(localEntity - 5);
-              }
-              
-              return { visibility, authority, localEntity, serviceArea };
-            };
-            
-            // Extract data arrays from timeseries
-            localEntityData = [];
-            serviceAreaData = [];
-            authorityData = [];
-            visibilityData = [];
-            contentSchemaData = [];
-            brandOverlayData = [];
-            contentSchemaDataEstimated = []; // Reset array for timeseries data
-            const allDateObjects = []; // Store Date objects for year detection
-            const allDates = [];
-            
-            debugLog(`Content/Schema map has ${contentSchemaMap.size} entries: ${Array.from(contentSchemaMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
-            debugLog(`Local Entity map has ${localEntityMap.size} entries: ${Array.from(localEntityMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
-            debugLog(`Service Area map has ${serviceAreaMap.size} entries: ${Array.from(serviceAreaMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
-            debugLog(`Timeseries has ${timeseries.length} points`, 'info');
-            
-            // Get current audit data for today's full Authority calculation
-            const savedAuditForTrend = loadAuditResults();
-            const currentTopQueries = savedAuditForTrend?.searchData?.topQueries || null;
-            const currentBacklinkMetrics = savedAuditForTrend?.backlinkMetrics || null;
-            const currentLocalSignals = savedAuditForTrend?.localSignals || null;
-            // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
-            const currentSiteReviews = getTrustpilotSnapshot(savedAuditForTrend?.siteReviews || null);
-            const currentScores = savedAuditForTrend?.scores;
-            
-            // Check if segmentation data is available and show/hide toggle
-            const authorityBySegment = currentScores?.authority?.bySegment || null;
-            const trendToggle = document.getElementById('trendAuthorityModeToggle');
-            if (trendToggle) {
-              if (authorityBySegment) {
-                trendToggle.style.display = 'block';
-                // Initialize mode if not set
-                if (!window.trendAuthorityMode) {
-                  window.trendAuthorityMode = 'all';
-                }
-              } else {
-                trendToggle.style.display = 'none';
-                window.trendAuthorityMode = 'all'; // Default to all
-              }
-            }
-            
-            // Get Authority score for selected mode
-            const getAuthorityForMode = (mode) => {
-              if (authorityBySegment && authorityBySegment[mode]) {
-                return authorityBySegment[mode].total || authorityBySegment[mode].score || 0;
-              }
-              // Fallback to all or main score
-              if (authorityBySegment && authorityBySegment.all) {
-                return authorityBySegment.all.total || authorityBySegment.all.score || 0;
-              }
-              // Legacy fallback
-              const authObj = currentScores?.authority;
-              if (typeof authObj === 'object' && authObj !== null) {
-                return authObj.score || 0;
-              }
-              return authObj || 0;
-            };
-            
-            timeseries.forEach(point => {
-              const pointDate = point.date; // YYYY-MM-DD format
-              
-              // Check if this is the latest audit date - if so, use stored scores from Supabase or current audit
-              // Use latestAuditDateStr (from Supabase) instead of todayStr to ensure we use actual latest audit
-              const isLatestAudit = pointDate === latestAuditDateStr;
-              
-              // Check if we have historical data from Supabase for Local Entity, Service Area, and Authority
-              const historicalLocalEntity = localEntityMap.get(pointDate);
-              const historicalServiceArea = serviceAreaMap.get(pointDate);
-              const historicalAuthority = authorityMap.get(pointDate);
-              
-              // For latest audit date, use current topQueries, backlinkMetrics, and reviews for full calculation
-              // For historical dates, pass null (will use simplified calculation)
-              const topQueriesForDate = isLatestAudit ? currentTopQueries : null;
-              const backlinkMetricsForDate = isLatestAudit ? currentBacklinkMetrics : null;
-              const localSignalsForDate = isLatestAudit ? currentLocalSignals : null;
-              const siteReviewsForDate = isLatestAudit ? currentSiteReviews : null;
-              
-              // Pass date to calculatePillarFromMetrics so it can check for historical data
-              // For today, pass topQueries and other data for full calculation
-              // For historical dates, pass null (will use simplified calculation)
-              const pillarScores = calculatePillarFromMetrics(
-                point.position, 
-                point.ctr, 
-                pointDate, 
-                topQueriesForDate,
-                backlinkMetricsForDate,
-                localSignalsForDate,
-                siteReviewsForDate
-              );
-              
-              // Local Entity and Service Area: Use historical data from Supabase if available
-              // These don't require GSC data, so should use latest available score for missing dates
-              if (historicalLocalEntity !== undefined && historicalLocalEntity !== null) {
-                localEntityData.push(historicalLocalEntity);
-                debugLog(`Using historical Local Entity (${historicalLocalEntity}) for ${pointDate}`, 'info');
-              } else {
-                // For missing dates, use the most recent available score from the map
-                let latestAvailableLocalEntity = null;
-                let latestAvailableDate = null;
-                localEntityMap.forEach((score, mapDate) => {
-                  if (mapDate <= pointDate && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
-                    latestAvailableDate = mapDate;
-                    latestAvailableLocalEntity = score;
-                  }
-                });
-                
-                if (latestAvailableLocalEntity !== null && latestAvailableLocalEntity !== undefined) {
-                  localEntityData.push(latestAvailableLocalEntity);
-                  debugLog(`Using latest available Local Entity (${latestAvailableLocalEntity} from ${latestAvailableDate}) for ${pointDate}`, 'info');
-                } else if (isLatestAudit) {
-                  // For latest audit date, use current score
-                  const savedAuditForLocal = loadAuditResultsSync();
-                  const currentLocalEntity = savedAuditForLocal?.scores?.localEntity;
-                  if (currentLocalEntity !== null && currentLocalEntity !== undefined && currentLocalEntity > 0) {
-                    localEntityData.push(currentLocalEntity);
-                    debugLog(`Using current Local Entity (${currentLocalEntity}) for ${pointDate} (latest audit)`, 'info');
-                  } else {
-                    localEntityData.push(null);
-                    debugLog(`No Local Entity data for ${pointDate}`, 'warn');
-                  }
-                } else {
-                  localEntityData.push(null);
-                  debugLog(`No Local Entity data for ${pointDate} (no historical or current data)`, 'info');
-                }
-              }
-              
-              if (historicalServiceArea !== undefined && historicalServiceArea !== null) {
-                serviceAreaData.push(historicalServiceArea);
-                debugLog(`Using historical Service Area (${historicalServiceArea}) for ${pointDate}`, 'info');
-              } else {
-                // For missing dates, use the most recent available score from the map
-                let latestAvailableServiceArea = null;
-                let latestAvailableDate = null;
-                serviceAreaMap.forEach((score, mapDate) => {
-                  if (mapDate <= pointDate && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
-                    latestAvailableDate = mapDate;
-                    latestAvailableServiceArea = score;
-                  }
-                });
-                
-                if (latestAvailableServiceArea !== null && latestAvailableServiceArea !== undefined) {
-                  serviceAreaData.push(latestAvailableServiceArea);
-                  debugLog(`Using latest available Service Area (${latestAvailableServiceArea} from ${latestAvailableDate}) for ${pointDate}`, 'info');
-                } else if (isLatestAudit) {
-                  // For latest audit date, use current score
-                  const savedAuditForService = loadAuditResultsSync();
-                  const currentServiceArea = savedAuditForService?.scores?.serviceArea;
-                  if (currentServiceArea !== null && currentServiceArea !== undefined && currentServiceArea > 0) {
-                    serviceAreaData.push(currentServiceArea);
-                    debugLog(`Using current Service Area (${currentServiceArea}) for ${pointDate} (latest audit)`, 'info');
-                  } else {
-                    serviceAreaData.push(null);
-                    debugLog(`No Service Area data for ${pointDate}`, 'warn');
-                  }
-                } else {
-                  serviceAreaData.push(null);
-                  debugLog(`No Service Area data for ${pointDate} (no historical or current data)`, 'info');
-                }
-              }
-              
-              // Use Authority score based on selected mode, prioritizing segmented historical data when available
-              // Check if we have segmented Authority data for this date in Supabase
-              const historicalAuthorityBySegment = authorityBySegmentMap.get(pointDate);
-              const selectedMode = window.trendAuthorityMode || 'all';
-              
-              if (historicalAuthorityBySegment && historicalAuthorityBySegment[selectedMode]) {
-                // Use segmented Authority score from Supabase for the selected mode
-                const modeScore = historicalAuthorityBySegment[selectedMode].total || historicalAuthorityBySegment[selectedMode].score || historicalAuthorityBySegment[selectedMode];
-                authorityData.push(modeScore);
-                debugLog(`Using historical segmented Authority (${modeScore}) for ${pointDate} (mode: ${selectedMode})`, 'info');
-              } else if (isLatestAudit) {
-                // For latest audit date, prioritize stored Authority score from current audit
-                const savedAuditForAuthority = loadAuditResultsSync();
-                const currentAuthority = savedAuditForAuthority?.scores?.authority;
-                let authorityScoreToUse = null;
-                
-                // Try to get Authority score based on selected mode
-                if (authorityBySegment) {
-                  authorityScoreToUse = getAuthorityForMode(selectedMode);
-                } else if (typeof currentAuthority === 'object' && currentAuthority !== null) {
-                  authorityScoreToUse = currentAuthority.score || currentAuthority;
-                } else if (typeof currentAuthority === 'number') {
-                  authorityScoreToUse = currentAuthority;
-                }
-                
-                if (authorityScoreToUse !== null && authorityScoreToUse !== undefined && authorityScoreToUse > 0) {
-                  authorityData.push(authorityScoreToUse);
-                  debugLog(`Using current stored Authority (${authorityScoreToUse}) for ${pointDate} (mode: ${selectedMode}, latest audit)`, 'info');
-                } else {
-                  // Fallback to calculated score if stored score not available
-                  const authScore = typeof pillarScores.authority === 'object' ? pillarScores.authority.score : pillarScores.authority;
-                  authorityData.push(authScore);
-                  debugLog(`Using calculated Authority (${authScore}) for ${pointDate} (stored score not available)`, 'info');
-                }
-              } else if (historicalAuthority !== undefined && historicalAuthority !== null) {
-                // Fallback: use legacy historical Authority from Supabase (single value, not segmented)
-                authorityData.push(historicalAuthority);
-                debugLog(`Using legacy historical Authority (${historicalAuthority}) for ${pointDate}`, 'info');
-              } else {
-                // For missing dates, use the most recent available score from Supabase (prevents artificial dips)
-                let latestAvailableAuthority = null;
-                let latestAvailableAuthorityDate = null;
-                
-                // Prefer segmented historical Authority if available (match selected mode)
-                authorityBySegmentMap.forEach((seg, mapDate) => {
-                  if (mapDate <= pointDate && (latestAvailableAuthorityDate === null || mapDate > latestAvailableAuthorityDate)) {
-                    if (seg && seg[selectedMode] !== undefined && seg[selectedMode] !== null) {
-                      const v = seg[selectedMode].total || seg[selectedMode].score || seg[selectedMode];
-                      latestAvailableAuthorityDate = mapDate;
-                      latestAvailableAuthority = v;
-                    }
-                  }
-                });
-                
-                // Fallback to legacy Authority map if segmented isn't available
-                if (latestAvailableAuthority === null || latestAvailableAuthority === undefined) {
-                  authorityMap.forEach((score, mapDate) => {
-                    if (mapDate <= pointDate && (latestAvailableAuthorityDate === null || mapDate > latestAvailableAuthorityDate)) {
-                      latestAvailableAuthorityDate = mapDate;
-                      latestAvailableAuthority = score;
-                    }
-                  });
-                }
-                
-                if (latestAvailableAuthority !== null && latestAvailableAuthority !== undefined) {
-                  authorityData.push(latestAvailableAuthority);
-                  debugLog(`Using latest available Authority (${latestAvailableAuthority} from ${latestAvailableAuthorityDate}) for ${pointDate}`, 'info');
-                } else {
-                  // Final fallback: calculate from GSC metrics (only if we have valid data)
-                  const hasValidGscData = point.position && point.position > 0 && point.ctr !== null && point.ctr >= 0;
-                  if (hasValidGscData) {
-                    const authScore = typeof pillarScores.authority === 'object' ? pillarScores.authority.score : pillarScores.authority;
-                    authorityData.push(authScore);
-                    debugLog(`Using calculated Authority (${authScore}) for ${pointDate}`, 'info');
-                  } else {
-                    authorityData.push(null);
-                    debugLog(`No valid GSC data for Authority on ${pointDate} (position=${point.position}, ctr=${point.ctr}) - using null`, 'warn');
-                  }
-                }
-              }
-              
-              // Visibility data (check historical data from Supabase FIRST, then use current audit score, then calculate only if missing and valid GSC data)
-              const historicalVisibility = visibilityMap.get(pointDate);
-              if (historicalVisibility !== undefined && historicalVisibility !== null) {
-                // Use stored score from database (fast - no calculation needed)
-                visibilityData.push(historicalVisibility);
-                debugLog(`Using stored Visibility (${historicalVisibility}) for ${pointDate}`, 'info');
-              } else if (isLatestAudit) {
-                // For latest audit date, prioritize stored Visibility score from current audit
-                const savedAuditForVisibility = loadAuditResultsSync();
-                const currentVisibility = savedAuditForVisibility?.scores?.visibility;
-                if (currentVisibility !== null && currentVisibility !== undefined && currentVisibility > 0) {
-                  visibilityData.push(currentVisibility);
-                  debugLog(`Using current stored Visibility (${currentVisibility}) for ${pointDate} (latest audit)`, 'info');
-                } else {
-                  // Fallback to calculated score if stored score not available
-                  visibilityData.push(pillarScores.visibility);
-                  debugLog(`Using calculated Visibility (${pillarScores.visibility}) for ${pointDate} (stored score not available)`, 'info');
-                }
-              } else {
-                // For past dates: calculate from GSC data as fallback (only if stored score missing AND valid GSC data)
-                const hasValidGscData = point.position && point.position > 0 && point.ctr !== null && point.ctr >= 0;
-                if (hasValidGscData) {
-                  visibilityData.push(pillarScores.visibility);
-                  debugLog(`Calculated Visibility (${pillarScores.visibility}) for ${pointDate} - stored score missing, using GSC fallback`, 'info');
-                } else {
-                  visibilityData.push(null);
-                  debugLog(`No valid GSC data for Visibility on ${pointDate} (position=${point.position}, ctr=${point.ctr}) - using null`, 'warn');
-                }
-              }
-              
-              // Check if we have real historical data for this date
-              // Content/Schema doesn't require GSC data, so should always have values
-              // NOTE: 0 is a valid score, so check for null/undefined only
-              const realScore = contentSchemaMap.get(pointDate);
-              
-              if (realScore !== undefined && realScore !== null) {
-                // We have real data for this date (including 0, which is valid)
-                contentSchemaData.push(realScore);
-                contentSchemaDataEstimated.push(null); // No estimated value
-                debugLog(`Content/Schema: Added ${realScore} for ${pointDate} from Supabase`, 'info');
-              } else {
-                // For missing dates, use the most recent available score from the map
-                let latestAvailableContentSchema = null;
-                let latestAvailableDate = null;
-                contentSchemaMap.forEach((score, mapDate) => {
-                  if (mapDate <= pointDate && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
-                    latestAvailableDate = mapDate;
-                    latestAvailableContentSchema = score;
-                  }
-                });
-                
-                // If no historical data found, use current score for latest audit date
-                // NOTE: 0 is a valid score, so check for null/undefined only
-                if (latestAvailableContentSchema !== null && latestAvailableContentSchema !== undefined) {
-                  contentSchemaData.push(latestAvailableContentSchema);
-                  contentSchemaDataEstimated.push(null);
-                  debugLog(`Content/Schema: Added ${latestAvailableContentSchema} for ${pointDate} from latest available (${latestAvailableDate})`, 'info');
-                } else if (isLatestAudit) {
-                  // For latest audit date, try multiple sources
-                  const savedAuditForContentSchema = loadAuditResultsSync();
-                  const savedContentSchema = savedAuditForContentSchema?.scores?.contentSchema;
-                  // NOTE: 0 is a valid score, so check for null/undefined only
-                  const scoreToUse = (currentContentSchema !== null && currentContentSchema !== undefined)
-                    ? currentContentSchema
-                    : (savedContentSchema !== null && savedContentSchema !== undefined)
-                      ? savedContentSchema
-                      : null;
-                  
-                  if (scoreToUse !== null && scoreToUse !== undefined) {
-                    contentSchemaData.push(scoreToUse);
-                    contentSchemaDataEstimated.push(null);
-                    debugLog(`Content/Schema: Added ${scoreToUse} for ${pointDate} from ${scoreToUse === currentContentSchema ? 'current audit' : 'saved audit'} (latest)`, 'info');
-                  } else {
-                    contentSchemaData.push(null);
-                    contentSchemaDataEstimated.push(null);
-                    debugLog(`Content/Schema: No valid score for ${pointDate} (isLatestAudit=${isLatestAudit}, currentContentSchema=${currentContentSchema}, savedContentSchema=${savedContentSchema})`, 'warn');
-                  }
-                } else {
-                  // No real data for this date - use null (don't show estimated line)
-                  contentSchemaData.push(null);
-                  contentSchemaDataEstimated.push(null);
-                  debugLog(`Content/Schema: No data for ${pointDate} (not latest audit, map has ${contentSchemaMap.size} entries)`, 'info');
-                }
-              }
-              
-              // Brand Overlay data (prioritize Supabase; if missing for a date, carry-forward latest available)
-              const historicalBrandOverlay = brandOverlayMap.get(pointDate);
-              if (historicalBrandOverlay !== undefined && historicalBrandOverlay !== null) {
-                brandOverlayData.push(historicalBrandOverlay);
-                debugLog(`‚úì Added Brand Overlay score (${historicalBrandOverlay}) for ${pointDate} from Supabase (historical)`, 'info');
-              } else {
-                let latestAvailableBrand = null;
-                let latestAvailableBrandDate = null;
-                brandOverlayMap.forEach((score, mapDate) => {
-                  if (mapDate <= pointDate && (latestAvailableBrandDate === null || mapDate > latestAvailableBrandDate)) {
-                    latestAvailableBrandDate = mapDate;
-                    latestAvailableBrand = score;
-                  }
-                });
-
-                if (latestAvailableBrand !== null && latestAvailableBrand !== undefined) {
-                  brandOverlayData.push(latestAvailableBrand);
-                  debugLog(`‚úì Using latest available Brand Overlay (${latestAvailableBrand} from ${latestAvailableBrandDate}) for ${pointDate}`, 'info');
-                } else if (isLatestAudit && currentBrandOverlay !== null) {
-                  brandOverlayData.push(currentBrandOverlay);
-                  debugLog(`‚ö† Using current Brand Overlay score (${currentBrandOverlay}) for ${pointDate} - no historical data found in Supabase`, 'warn');
-                } else {
-                  // Final fallback: estimate from GSC metrics
-                  const historicalRecord = contentSchemaHistory.find(r => {
-                    const rDate = typeof r.date === 'string' ? r.date.split('T')[0] : (r.date instanceof Date ? r.date.toISOString().split('T')[0] : String(r.date).split('T')[0]);
-                    return rDate === pointDate;
-                  });
-                  const historicalReviewScore = historicalRecord?.authorityReviewScore;
-                  const historicalEntityScore = historicalLocalEntity !== undefined && historicalLocalEntity !== null ? historicalLocalEntity : null;
-
-                  const reviewScore = historicalReviewScore !== undefined && historicalReviewScore !== null
-                    ? historicalReviewScore
-                    : (currentScores?.authorityComponents?.reviews || currentScores?.authority?.bySegment?.all?.reviews || 0);
-                  const entityScore = historicalEntityScore !== null && historicalEntityScore !== undefined
-                    ? historicalEntityScore
-                    : (currentScores?.localEntity || 0);
-
-                  const hasValidGscData = point.position && point.position > 0 && point.ctr !== null && point.ctr >= 0;
-                  if (!hasValidGscData) {
-                    brandOverlayData.push(null);
-                    debugLog(`No valid GSC data for Brand Overlay on ${pointDate} (position=${point.position}, ctr=${point.ctr}) - using null`, 'warn');
-                  } else {
-                    const position = point.position || 40;
-                    const ctr = point.ctr || 0;
-                    const estimatedBrandCtr = Math.min(ctr * 1.5, 0.4);
-                    const estimatedBrandPosition = Math.max(position * 0.7, 1);
-                    const estimatedBrandShare = 0.02;
-
-                    try {
-                      const fallbackBrandOverlay = computeBrandOverlay({
-                        brandQueryShare: estimatedBrandShare,
-                        brandCtr: estimatedBrandCtr,
-                        brandAvgPosition: estimatedBrandPosition,
-                        reviewScore: reviewScore,
-                        entityScore: entityScore
-                      });
-                      brandOverlayData.push(fallbackBrandOverlay.score);
-                      debugLog(`‚úì Calculated fallback Brand Overlay score (${fallbackBrandOverlay.score}) for ${pointDate} from GSC timeseries data`, 'info');
-                    } catch (e) {
-                      debugLog(`‚ö† Error calculating fallback Brand Overlay for ${pointDate}: ${e.message}`, 'warn');
-                      brandOverlayData.push(null);
-                    }
-                  }
-                }
-              }
-              
-              // Format date for chart (timeseries dates are YYYY-MM-DD)
-              const dateObj = new Date(point.date);
-              allDateObjects.push(dateObj);
-              allDates.push(dateObj.toLocaleDateString('en-GB', dateFormat));
-            });
-            
-            // Log Content/Schema data array summary after timeseries loop
-            const contentSchemaValid = contentSchemaData.filter(v => v !== null && v !== undefined);
-            debugLog(`Content/Schema data after timeseries: ${contentSchemaValid.length} valid values out of ${contentSchemaData.length} total. Values: ${contentSchemaValid.join(', ')}`, 'info');
-            
-            // Fill in missing dates between last GSC date and latest audit date
-            // GSC data is delayed by 2-3 days, but we want to show the latest audit date
-            // Reuse 'today' and 'todayStr' variables (already declared above)
-            today = new Date();
-            today.setHours(0, 0, 0, 0); // Normalize to start of day
-            todayStr = today.toISOString().split('T')[0];
-            const lastTimeseriesDate = timeseries.length > 0 ? timeseries[timeseries.length - 1].date : null;
-            
-            // Store last timeseries date globally so displayDashboard can use it for Data Date
-            window.lastGscTimeseriesDate = lastTimeseriesDate;
-            if (lastTimeseriesDate) {
-              debugLog(`Stored last GSC timeseries date globally: ${lastTimeseriesDate}`, 'info');
-            }
-            
-            // Determine actual last GSC data date
-            // CRITICAL: Only use dates from maps that are <= lastTimeseriesDate (actual GSC data)
-            // Never forward-fill GSC data beyond the last actual GSC timeseries date
-            // Maps may have dates after lastTimeseriesDate (from audits), but those aren't from actual GSC data
-            const allGscDates = new Set();
-            
-            // Add all dates from timeseries (actual GSC API data)
-            timeseries.forEach(point => {
-              if (point.date) {
-                allGscDates.add(point.date);
-              }
-            });
-            
-            // Add dates from historical maps ONLY if they're <= lastTimeseriesDate
-            // This ensures we only use GSC-derived scores that are based on actual GSC data
-            if (lastTimeseriesDate) {
-              visibilityMap.forEach((score, date) => {
-                if (date && date <= lastTimeseriesDate && score !== null && score !== undefined) {
-                  allGscDates.add(date);
-                }
-              });
-              authorityMap.forEach((score, date) => {
-                if (date && date <= lastTimeseriesDate && score !== null && score !== undefined) {
-                  allGscDates.add(date);
-                }
-              });
-              brandOverlayMap.forEach((score, date) => {
-                if (date && date <= lastTimeseriesDate && score !== null && score !== undefined) {
-                  allGscDates.add(date);
-                }
-              });
-            }
-            
-            // Use the latest date from timeseries OR valid map dates (all <= lastTimeseriesDate)
-            // This is the definitive last GSC data date - never forward-fill beyond this
-            let lastGscDateForRange = lastTimeseriesDate; // Default to timeseries date (most accurate)
-            if (allGscDates.size > 0) {
-              const sortedDates = Array.from(allGscDates).sort();
-              const latestDate = sortedDates[sortedDates.length - 1];
-              // Use the later of: lastTimeseriesDate or latest valid map date
-              // But latestDate should never be > lastTimeseriesDate due to filtering above
-              lastGscDateForRange = latestDate > lastTimeseriesDate ? lastTimeseriesDate : latestDate;
-              debugLog(`Last GSC date: ${lastGscDateForRange} (timeseries: ${lastTimeseriesDate}, valid map dates: ${sortedDates.length})`, 'info');
-              if (sortedDates.length > 0) {
-                debugLog(`GSC date range: ${sortedDates[0]} to ${lastGscDateForRange}`, 'info');
-              }
-            } else {
-              debugLog(`No GSC dates found, using lastTimeseriesDate: ${lastGscDateForRange}`, 'warn');
-            }
-            
-            // Ensure latest audit date is included even if not in timeseries
-            // Add it to the chart if it's after the last GSC date
-            if (latestAuditDateStr && lastGscDateForRange && latestAuditDateStr > lastGscDateForRange) {
-              debugLog(`Latest audit date (${latestAuditDateStr}) is after last GSC date (${lastGscDateForRange}), will add to chart`, 'info');
-            }
-            
-            // Check if we're missing recent dates (likely due to GSC delay)
-            let hasRecentMissingDates = false;
-            if (lastTimeseriesDate) {
-              const lastDate = new Date(lastTimeseriesDate);
-              lastDate.setHours(0, 0, 0, 0);
-              const daysSinceLastData = Math.floor((today - lastDate) / (1000 * 60 * 60 * 24));
-              hasRecentMissingDates = daysSinceLastData > 1; // More than 1 day gap indicates GSC delay
-              
-              // Show a note about GSC delay if we're missing recent dates
-              if (hasRecentMissingDates) {
-                const trendCanvas = document.getElementById('trendChart');
-                if (trendCanvas && trendCanvas.parentElement) {
-                  // Check if note already exists
-                  const existingNote = trendCanvas.parentElement.querySelector('.gsc-delay-note');
-                  if (!existingNote) {
-                    const noteDiv = document.createElement('div');
-                    noteDiv.className = 'gsc-delay-note';
-                    noteDiv.style.cssText = 'background: #e0f2fe; padding: 0.75rem; border-radius: 4px; border-left: 3px solid #0284c7; margin-bottom: 1rem; font-size: 0.85rem; color: #0c4a6e;';
-                    noteDiv.innerHTML = `<strong>Note:</strong> Google Search Console data is typically delayed by 2-3 days. Recent dates (last ${daysSinceLastData} day${daysSinceLastData > 1 ? 's' : ''}) may show no data until GSC updates.`;
-                    trendCanvas.parentElement.insertBefore(noteDiv, trendCanvas);
-                  }
-                }
-              }
-            }
-            
-            // Always extend chart to latestAuditDateStr (or today) for non-GSC pillars
-            // GSC pillars will only show data up to lastGscDateForRange
-            // CRITICAL: Use the last date from the timeseries array (what's already in the chart)
-            // NOT from the maps, because the maps may have dates that aren't in the chart yet
-            const lastTimeseriesDateStr = timeseries.length > 0 ? timeseries[timeseries.length - 1].date : null;
-            
-            // Find the latest date from all maps for fallback/validation
-            const allMapDates = new Set();
-            contentSchemaMap.forEach((score, date) => allMapDates.add(date));
-            localEntityMap.forEach((score, date) => allMapDates.add(date));
-            serviceAreaMap.forEach((score, date) => allMapDates.add(date));
-            visibilityMap.forEach((score, date) => allMapDates.add(date));
-            authorityMap.forEach((score, date) => allMapDates.add(date));
-            brandOverlayMap.forEach((score, date) => allMapDates.add(date));
-            const latestMapDateStr = allMapDates.size > 0 ? Array.from(allMapDates).sort().reverse()[0] : null;
-            
-            // Use the last date from timeseries (what's already in the chart) as the starting point
-            // This ensures we fill dates from the last timeseries date to the latest audit date
-            const lastDateInChartStr = lastTimeseriesDateStr || (timeseries.length === 0 && latestMapDateStr ? latestMapDateStr : null);
-            const targetDateStr = latestAuditDateStr || latestMapDateStr || today.toISOString().split('T')[0];
-            
-            debugLog(`Chart extension: lastDateInChart=${lastDateInChartStr}, targetDate=${targetDateStr}, latestAuditDateStr=${latestAuditDateStr}, latestMapDate=${latestMapDateStr}`, 'info');
-            debugLog(`Last GSC date: ${lastGscDateForRange} (from all sources, timeseries last: ${lastTimeseriesDate})`, 'info');
-            debugLog(`Content/Schema map has ${contentSchemaMap.size} entries before filling missing dates`, 'info');
-            debugLog(`Content/Schema map entries: ${Array.from(contentSchemaMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
-            
-            // Always fill dates from last date in chart to latest audit date
-            // Use string comparison to ensure we extend the chart
-            if (lastDateInChartStr && targetDateStr) {
-              const dateComparison = lastDateInChartStr.localeCompare(targetDateStr);
-              if (dateComparison < 0) {
-              const lastDate = new Date(lastDateInChartStr);
-              lastDate.setHours(0, 0, 0, 0);
-              const currentDate = new Date(lastDate);
-              currentDate.setDate(currentDate.getDate() + 1); // Start from day after last date
-              
-              debugLog(`Filling missing dates from ${currentDate.toISOString().split('T')[0]} to ${targetDateStr} (latest audit: ${latestAuditDateStr})`, 'info');
-              
-              while (currentDate.toISOString().split('T')[0] <= targetDateStr) {
-                const dateStr = currentDate.toISOString().split('T')[0];
-                const dateObj = new Date(dateStr);
-                
-                allDateObjects.push(dateObj);
-                allDates.push(dateObj.toLocaleDateString('en-GB', dateFormat));
-                
-                // For GSC-based pillars (Authority, Visibility), only use data from Supabase if it exists for that specific date
-                // These rely on GSC data being fetched and stored, so NO forward-filling
-                // CRITICAL: Only show data for dates <= lastGscDateForRange (last GSC data date from maps or timeseries)
-                // Never show data for dates after lastGscDateForRange, even if an audit was run on that date
-                const isDateWithinGscRange = lastGscDateForRange && dateStr <= lastGscDateForRange;
-                const historicalVisibility = visibilityMap.get(dateStr);
-                const historicalAuthority = authorityMap.get(dateStr);
-                
-                // Visibility: only use historical data from Supabase if date is within GSC data range
-                if (isDateWithinGscRange && historicalVisibility !== undefined && historicalVisibility !== null) {
-                  visibilityData.push(historicalVisibility);
-                  debugLog(`‚úì Added Visibility score (${historicalVisibility}) for ${dateStr} from Supabase`, 'info');
-                } else {
-                  // No data for dates after last GSC data date - GSC-based metrics require real GSC data
-                  visibilityData.push(null);
-                  if (!isDateWithinGscRange) {
-                    debugLog(`No Visibility data for ${dateStr} (date is after last GSC data date: ${lastGscDateForRange})`, 'info');
-                  } else {
-                    debugLog(`No Visibility data for ${dateStr} (no historical audit data)`, 'info');
-                  }
-                }
-                
-                // Authority: only use historical data from Supabase if date is within GSC data range
-                if (isDateWithinGscRange && historicalAuthority !== undefined && historicalAuthority !== null) {
-                  authorityData.push(historicalAuthority);
-                  debugLog(`‚úì Added Authority score (${historicalAuthority}) for ${dateStr} from Supabase`, 'info');
-                } else {
-                  // No data for dates after last GSC data date - GSC-based metrics require real GSC data
-                  authorityData.push(null);
-                  if (!isDateWithinGscRange) {
-                    debugLog(`No Authority data for ${dateStr} (date is after last GSC data date: ${lastGscDateForRange})`, 'info');
-                  } else {
-                    debugLog(`No Authority data for ${dateStr} (no historical audit data)`, 'info');
-                  }
-                }
-                
-                // For Local Entity and Service Area, check if we have historical data from Supabase
-                // These don't require GSC data, so should always have values up to today
-                const historicalLocalEntity = localEntityMap.get(dateStr);
-                const historicalServiceArea = serviceAreaMap.get(dateStr);
-                
-                // Local Entity: use historical data, or latest available, or current score for today
-                if (historicalLocalEntity !== undefined && historicalLocalEntity !== null) {
-                  localEntityData.push(historicalLocalEntity);
-                  debugLog(`‚úì Added Local Entity score (${historicalLocalEntity}) for ${dateStr} from Supabase`, 'info');
-                } else {
-                  // For missing dates, use the most recent available score from the map
-                  let latestAvailableLocalEntity = null;
-                  let latestAvailableDate = null;
-                  localEntityMap.forEach((score, mapDate) => {
-                    if (mapDate <= dateStr && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
-                      latestAvailableDate = mapDate;
-                      latestAvailableLocalEntity = score;
-                    }
-                  });
-                  
-                  // If no historical data found, use current score for today/latest audit
-                  if (latestAvailableLocalEntity !== null && latestAvailableLocalEntity !== undefined) {
-                    localEntityData.push(latestAvailableLocalEntity);
-                    debugLog(`‚úì Added Local Entity score (${latestAvailableLocalEntity}) for ${dateStr} from latest available (${latestAvailableDate})`, 'info');
-                  } else if (dateStr === latestAuditDateStr || dateStr >= todayStr) {
-                    const savedAuditForLocal = loadAuditResultsSync();
-                    const currentLocalEntity = savedAuditForLocal?.scores?.localEntity;
-                    if (currentLocalEntity !== null && currentLocalEntity !== undefined && currentLocalEntity > 0) {
-                      localEntityData.push(currentLocalEntity);
-                      debugLog(`‚úì Added Local Entity score (${currentLocalEntity}) for ${dateStr} from current audit`, 'info');
-                    } else {
-                      localEntityData.push(null);
-                      debugLog(`No Local Entity data for ${dateStr}`, 'warn');
-                    }
-                  } else {
-                    localEntityData.push(null);
-                    debugLog(`No Local Entity data for ${dateStr} (no historical or current data)`, 'info');
-                  }
-                }
-                
-                // Service Area: use historical data, or latest available, or current score for today
-                if (historicalServiceArea !== undefined && historicalServiceArea !== null) {
-                  serviceAreaData.push(historicalServiceArea);
-                  debugLog(`‚úì Added Service Area score (${historicalServiceArea}) for ${dateStr} from Supabase`, 'info');
-                } else {
-                  // For missing dates, use the most recent available score from the map
-                  let latestAvailableServiceArea = null;
-                  let latestAvailableDate = null;
-                  serviceAreaMap.forEach((score, mapDate) => {
-                    if (mapDate <= dateStr && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
-                      latestAvailableDate = mapDate;
-                      latestAvailableServiceArea = score;
-                    }
-                  });
-                  
-                  // If no historical data found, use current score for today/latest audit
-                  if (latestAvailableServiceArea !== null && latestAvailableServiceArea !== undefined) {
-                    serviceAreaData.push(latestAvailableServiceArea);
-                    debugLog(`‚úì Added Service Area score (${latestAvailableServiceArea}) for ${dateStr} from latest available (${latestAvailableDate})`, 'info');
-                  } else if (dateStr === latestAuditDateStr || dateStr >= todayStr) {
-                    const savedAuditForService = loadAuditResultsSync();
-                    const currentServiceArea = savedAuditForService?.scores?.serviceArea;
-                    if (currentServiceArea !== null && currentServiceArea !== undefined && currentServiceArea > 0) {
-                      serviceAreaData.push(currentServiceArea);
-                      debugLog(`‚úì Added Service Area score (${currentServiceArea}) for ${dateStr} from current audit`, 'info');
-                    } else {
-                      serviceAreaData.push(null);
-                      debugLog(`No Service Area data for ${dateStr}`, 'warn');
-                    }
-                  } else {
-                    serviceAreaData.push(null);
-                    debugLog(`No Service Area data for ${dateStr} (no historical or current data)`, 'info');
-                  }
-                }
-                
-                // For Content/Schema, use latest audit score for dates after last GSC date
-                // This ensures we show the latest audit data instead of intermediate values
-                const isAfterLastTimeseries = lastGscDateForRange && dateStr > lastGscDateForRange;
-                
-                if (isAfterLastTimeseries && dateStr <= latestAuditDateStr) {
-                  // For dates after last timeseries but up to latest audit, use latest audit score (forward-fill)
-                  const savedAuditForContentSchema = loadAuditResultsSync();
-                  const savedContentSchema = savedAuditForContentSchema?.scores?.contentSchema;
-                  // NOTE: 0 is a valid score, so check for null/undefined only
-                  const scoreToUse = (currentContentSchema !== null && currentContentSchema !== undefined)
-                    ? currentContentSchema
-                    : (savedContentSchema !== null && savedContentSchema !== undefined)
-                      ? savedContentSchema
-                      : null;
-                  
-                  if (scoreToUse !== null && scoreToUse !== undefined) {
-                    contentSchemaData.push(scoreToUse);
-                    contentSchemaDataEstimated.push(null);
-                    debugLog(`‚úì Added Content/Schema score (${scoreToUse}) for ${dateStr} from latest audit (forward-filled from ${latestAuditDateStr})`, 'info');
-                  } else {
-                    // Fallback: use latest available from map
-                    let latestAvailableContentSchema = null;
-                    let latestAvailableDate = null;
-                    contentSchemaMap.forEach((score, mapDate) => {
-                      if (mapDate <= latestAuditDateStr && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
-                        latestAvailableDate = mapDate;
-                        latestAvailableContentSchema = score;
-                      }
-                    });
-                    if (latestAvailableContentSchema !== null && latestAvailableContentSchema !== undefined) {
-                      contentSchemaData.push(latestAvailableContentSchema);
-                      contentSchemaDataEstimated.push(null);
-                      debugLog(`‚úì Added Content/Schema score (${latestAvailableContentSchema}) for ${dateStr} from latest available (${latestAvailableDate})`, 'info');
-                    } else {
-                      contentSchemaData.push(null);
-                      contentSchemaDataEstimated.push(null);
-                      debugLog(`No Content/Schema data for ${dateStr}`, 'warn');
-                    }
-                  }
-                } else {
-                  // For dates within timeseries range, use actual database values
-                  const realScore = contentSchemaMap.get(dateStr);
-                  if (realScore !== undefined && realScore !== null) {
-                    // We have real data for this date (including 0, which is valid)
-                    contentSchemaData.push(realScore);
-                    contentSchemaDataEstimated.push(null);
-                    debugLog(`‚úì Added Content/Schema score (${realScore}) for ${dateStr} from Supabase`, 'info');
-                  } else {
-                    // For missing dates, use the most recent available score from the map
-                    let latestAvailableContentSchema = null;
-                    let latestAvailableDate = null;
-                    contentSchemaMap.forEach((score, mapDate) => {
-                      if (mapDate <= dateStr && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
-                        latestAvailableDate = mapDate;
-                        latestAvailableContentSchema = score;
-                      }
-                    });
-                    
-                    // If no historical data found, use current score for today/latest audit
-                    if (latestAvailableContentSchema !== null && latestAvailableContentSchema !== undefined) {
-                      contentSchemaData.push(latestAvailableContentSchema);
-                      contentSchemaDataEstimated.push(null);
-                      debugLog(`‚úì Added Content/Schema score (${latestAvailableContentSchema}) for ${dateStr} from latest available (${latestAvailableDate})`, 'info');
-                    } else if (dateStr === latestAuditDateStr || dateStr >= todayStr) {
-                      const savedAuditForContentSchema = loadAuditResultsSync();
-                      const savedContentSchema = savedAuditForContentSchema?.scores?.contentSchema;
-                      const scoreToUse = (currentContentSchema !== null && currentContentSchema !== undefined)
-                        ? currentContentSchema
-                        : (savedContentSchema !== null && savedContentSchema !== undefined)
-                          ? savedContentSchema
-                          : null;
-                      
-                      if (scoreToUse !== null && scoreToUse !== undefined) {
-                        contentSchemaData.push(scoreToUse);
-                        contentSchemaDataEstimated.push(null);
-                        debugLog(`‚úì Added Content/Schema score (${scoreToUse}) for ${dateStr} from current/saved audit`, 'info');
-                      } else {
-                        contentSchemaData.push(null);
-                        contentSchemaDataEstimated.push(null);
-                        debugLog(`No Content/Schema data for ${dateStr} (latest date but no score available)`, 'warn');
-                      }
-                    } else {
-                      // No real data - use null (don't show estimated)
-                      contentSchemaData.push(null);
-                      contentSchemaDataEstimated.push(null);
-                      debugLog(`No Content/Schema data for ${dateStr} (no historical or current data)`, 'info');
-                    }
-                  }
-                }
-                
-                // Brand Overlay data (check historical data from Supabase)
-                // Brand Overlay is GSC-based, so only show data for dates <= lastTimeseriesDate
-                const historicalBrandOverlay = brandOverlayMap.get(dateStr);
-                if (isDateWithinGscRange && historicalBrandOverlay !== undefined && historicalBrandOverlay !== null) {
-                  brandOverlayData.push(historicalBrandOverlay);
-                  debugLog(`‚úì Added Brand Overlay score (${historicalBrandOverlay}) for ${dateStr} from Supabase`, 'info');
-                } else {
-                  // No data for dates after last GSC data date - Brand Overlay is GSC-based
-                  brandOverlayData.push(null);
-                  if (!isDateWithinGscRange) {
-                    debugLog(`No Brand Overlay data for ${dateStr} (date is after last GSC data date: ${lastGscDateForRange})`, 'info');
-                  } else {
-                    debugLog(`No Brand Overlay data for ${dateStr} (no historical audit data)`, 'info');
-                  }
-                }
-                
-                // Move to next day
-                currentDate.setDate(currentDate.getDate() + 1);
-              }
-              
-              debugLog(`Filled missing dates: added ${allDateObjects.length - timeseries.length} additional dates`, 'info');
-              } else {
-                debugLog(`No dates to fill: lastDateInChart=${lastDateInChartStr}, targetDate=${targetDateStr}`, 'info');
-              }
-            } else {
-              debugLog(`Cannot fill dates: lastDateInChart=${lastDateInChartStr}, targetDate=${targetDateStr}`, 'warn');
-            }
-            
-            debugLog(`Chart date range: ${allDates[0]} to ${allDates[allDates.length - 1]} (${allDates.length} total dates)`, 'info');
-            debugLog(`Latest audit date: ${latestAuditDateStr}`, 'info');
-            debugLog(`Chart labels (first 5, last 5): ${allDates.slice(0, 5).join(', ')} ... ${allDates.slice(-5).join(', ')}`, 'info');
-            
-            if (timeseries.length === 0) {
-              // No timeseries data at all - just add latest audit date or today
-              const targetDateStr = latestAuditDateStr || todayStr;
-              const targetDateObj = new Date(targetDateStr);
-              allDateObjects.push(targetDateObj);
-              allDates.push(targetDateObj.toLocaleDateString('en-GB', dateFormat));
-              
-              // For GSC-based pillars (Authority, Visibility), use current audit data if available
-              if (savedAuditForTrend) {
-                const currentSearchData = savedAuditForTrend?.searchData;
-                const currentScores = savedAuditForTrend?.scores;
-                
-                if (currentSearchData) {
-                  // Calculate Visibility from current position
-                  const currentPosition = currentSearchData.averagePosition || 40;
-                  const clampedPos = Math.max(1, Math.min(40, currentPosition));
-                  const scale = (clampedPos - 1) / 39;
-                  const posScore = 100 - scale * 90;
-                  const visibility = clampScore(posScore);
-                  visibilityData.push(visibility);
-                  debugLog(`‚úì Added Visibility score (${visibility}) for today from current audit`, 'info');
-                  
-                  // Use current Authority score if available
-                  const currentAuthority = currentScores?.authority || null;
-                  if (currentAuthority !== null && currentAuthority !== undefined) {
-                    authorityData.push(currentAuthority);
-                    debugLog(`‚úì Added Authority score (${currentAuthority}) for today from current audit`, 'info');
-                  } else {
-                    // Fallback: calculate Authority from current data
-                    const pillarScores = calculatePillarFromMetrics(
-                      currentPosition,
-                      currentSearchData.ctr || 0,
-                      todayStr,
-                      currentTopQueries,
-                      currentBacklinkMetrics,
-                      currentLocalSignals,
-                        currentSiteReviews
-                      );
-                    const authScore = typeof pillarScores.authority === 'object' ? pillarScores.authority.score : pillarScores.authority;
-                    authorityData.push(authScore);
-                    debugLog(`‚úì Calculated Authority score (${authScore}) for today from current audit data`, 'info');
-                  }
-                } else {
-                  // No current search data - use null
-                  authorityData.push(null);
-                  visibilityData.push(null);
-                }
-              } else {
-                // No saved audit data - use null
-                authorityData.push(null);
-                visibilityData.push(null);
-              }
-              
-              // For today, use current Business Profile data if available, otherwise calculated
-              if (currentLocalEntity !== null) {
-                localEntityData.push(currentLocalEntity);
-              } else {
-                localEntityData.push(null);
-              }
-              if (currentServiceArea !== null) {
-                serviceAreaData.push(currentServiceArea);
-              } else {
-                serviceAreaData.push(null);
-              }
-              
-              // For Content/Schema, check if we have real data for today
-              const todayRealScore = contentSchemaMap.get(todayStr);
-              if (todayRealScore !== undefined) {
-                contentSchemaData.push(todayRealScore);
-                contentSchemaDataEstimated.push(null);
-                debugLog(`‚úì Added today's Content/Schema score (${todayRealScore}) from Supabase`, 'info');
-              } else {
-                contentSchemaData.push(null);
-                contentSchemaDataEstimated.push(currentContentSchema);
-                debugLog(`Using current Content/Schema score (${currentContentSchema}) as estimate for today`, 'info');
-              }
-              
-              // For Brand Overlay, use current score if available
-              if (currentBrandOverlay !== null) {
-                brandOverlayData.push(currentBrandOverlay);
-                debugLog(`‚úì Added Brand Overlay score (${currentBrandOverlay}) for today from current audit`, 'info');
-              } else {
-                brandOverlayData.push(null);
-              }
-            }
-            
-            // Apply label spacing to dates with year detection (show every labelStep-th label)
-            let lastVisibleYear = null;
-            chartDates = allDates.map((d, i) => {
-              if (i % labelStep === 0 || i === allDates.length - 1) {
-                const currentYear = allDateObjects[i].getFullYear();
-                
-                // Add year if it changed from the last visible label
-                if (lastVisibleYear !== null && currentYear !== lastVisibleYear) {
-                  lastVisibleYear = currentYear;
-                  return `${d} ${currentYear}`;
-                }
-                
-                lastVisibleYear = currentYear;
-                return d;
-              }
-              return ''; // Empty string for labels we don't want to show
-            });
-            
-            // Store date objects for timeseries data
-            chartDateObjects = allDateObjects;
-          } else {
-            // No timeseries data available - use all nulls (no mock data)
-            debugLog('No timeseries data available - chart will show empty with null values', 'warn');
-            
-            // Still fetch historical data for Money Pages trend chart even without timeseries
-            const propertyUrl = document.getElementById('propertyUrl')?.value || '';
-            if (propertyUrl) {
-              try {
-                // Calculate date range from saved audit or use default
-                const dateRange = parseInt(document.getElementById('dateRange')?.value || '30', 10);
-                const endDate = new Date().toISOString().split('T')[0];
-                const startDate = new Date();
-                startDate.setDate(startDate.getDate() - dateRange);
-                const startDateStr = startDate.toISOString().split('T')[0];
-                
-                debugLog(`Fetching historical data for Money Pages trend (no timeseries): ${startDateStr} to ${endDate}`, 'info');
-                const moneyPagesHistory = await fetchContentSchemaHistory(propertyUrl, startDateStr, endDate);
-                
-                // Phase 3: Render Money Pages trend chart
-                if (typeof renderMoneyPagesTrendChart === 'function') {
-                  setTimeout(() => {
-                    renderMoneyPagesTrendChart(moneyPagesHistory);
-                  }, 1000); // Delay to ensure DOM is ready and chart container exists
-                } else {
-                  debugLog('‚ö† renderMoneyPagesTrendChart function not found', 'warn');
-                }
-              } catch (error) {
-                debugLog(`‚ö† Error fetching historical data for Money Pages: ${error.message}`, 'warn');
-                // Still try to render with empty history (will show current audit data if available)
-                if (typeof renderMoneyPagesTrendChart === 'function') {
-                  setTimeout(() => {
-                    renderMoneyPagesTrendChart([]);
-                  }, 1000);
-                }
-              }
-            }
-            
-            // Use all null values - no mock/estimated data
-            localEntityData = new Array(numDataPoints).fill(null);
-            serviceAreaData = new Array(numDataPoints).fill(null);
-            authorityData = new Array(numDataPoints).fill(null);
-            visibilityData = new Array(numDataPoints).fill(null);
-            contentSchemaData = new Array(numDataPoints).fill(null);
-            contentSchemaDataEstimated = new Array(numDataPoints).fill(null);
-            brandOverlayData = new Array(numDataPoints).fill(null);
-            
-            // Generate dates for the date range
-            const fallbackDates = [];
-            const fallbackDateObjects = [];
-              for (let i = 0; i < numDataPoints; i++) {
-              const dateObj = new Date();
-              if (dateRange <= 90) {
-                // Daily data
-                dateObj.setDate(dateObj.getDate() - (numDataPoints - 1 - i));
-              } else {
-                // Weekly data
-                dateObj.setDate(dateObj.getDate() - ((numDataPoints - 1 - i) * 7));
-              }
-              fallbackDateObjects.push(dateObj);
-              fallbackDates.push(dateObj.toLocaleDateString('en-GB', dateFormat));
-            }
-            chartDates = fallbackDates;
-            chartDateObjects = fallbackDateObjects;
-          }
-          
-          // Calculate min and max across all datasets (filter out null values)
-          const allData = [...localEntityData, ...serviceAreaData, ...authorityData, ...visibilityData, ...contentSchemaData, ...brandOverlayData].filter(v => v !== null && v !== undefined && !isNaN(v));
-          const dataMin = allData.length > 0 ? Math.min(...allData) : 0;
-          const dataMax = allData.length > 0 ? Math.max(...allData) : 100;
-          const dataRange = dataMax - dataMin;
-          
-          // Debug: Log Content/Schema data to see what we have
-          const contentSchemaValid = contentSchemaData.filter(v => v !== null && v !== undefined && !isNaN(v));
-          debugLog(`Content/Schema dataset: ${contentSchemaValid.length} valid values out of ${contentSchemaData.length} total. Values: ${contentSchemaValid.join(', ')}`, 'info');
-          debugLog(`Content/Schema data array length: ${contentSchemaData.length}, chart dates length: ${chartDates.length}`, 'info');
-          debugLog(`Last few Content/Schema values: ${contentSchemaData.slice(-5).join(', ')}`, 'info');
-          debugLog(`Content/Schema map size: ${contentSchemaMap.size}, map entries: ${Array.from(contentSchemaMap.entries()).slice(-10).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
-          
-          // Debug: Log Local Entity and Service Area data arrays
-          const localEntityValid = localEntityData.filter(v => v !== null && v !== undefined && !isNaN(v));
-          const serviceAreaValid = serviceAreaData.filter(v => v !== null && v !== undefined && !isNaN(v));
-          debugLog(`Local Entity dataset: ${localEntityValid.length} valid values out of ${localEntityData.length} total. Last 5 values: ${localEntityData.slice(-5).join(', ')}`, 'info');
-          debugLog(`Service Area dataset: ${serviceAreaValid.length} valid values out of ${serviceAreaData.length} total. Last 5 values: ${serviceAreaData.slice(-5).join(', ')}`, 'info');
-          debugLog(`Local Entity map size: ${localEntityMap.size}, Service Area map size: ${serviceAreaMap.size}`, 'info');
-          
-          // If Content/Schema has no valid data, log a warning
-          if (contentSchemaValid.length === 0) {
-            debugLog(`‚ö† WARNING: Content/Schema dataset has NO valid values! Map has ${contentSchemaMap.size} entries.`, 'error');
-            debugLog(`Content/Schema history fetched: ${contentSchemaHistory.length} records`, 'info');
-          }
-          
-          // Calculate dynamic Y-axis range
-          // Minimum range of 30, or actual range + padding if larger
-          const minRange = 30;
-          const padding = 5; // Add 5 points padding above and below
-          const actualRange = Math.max(minRange, dataRange + (padding * 2));
-          
-          // Calculate Y-axis min and max
-          let yAxisMin = Math.max(0, Math.floor(dataMin - padding));
-          // Ensure the red risk band (30-39) is always visible in the chart area
-          // by never allowing the bottom of the axis to sit above 30.
-          if (yAxisMin > 30) {
-            yAxisMin = 30;
-          }
-          const yAxisMax = Math.min(100, Math.ceil(yAxisMin + actualRange));
-          
-          // Adjust step size based on range (smaller steps for smaller ranges)
-          let stepSize = 10;
-          if (actualRange <= 40) {
-            stepSize = 5;
-          } else if (actualRange <= 60) {
-            stepSize = 10;
-          } else {
-            stepSize = 20;
-          }
-          
-          debugLog(`Y-axis range: ${yAxisMin} to ${yAxisMax} (range: ${actualRange}, step: ${stepSize})`, 'info');
-          
-          // Calculate trend percentages for each dataset
-          // Filter out null values to get actual first and last data points
-          const calculateTrend = (data) => {
-            // Filter out null/undefined values
-            const validData = data.filter(v => v !== null && v !== undefined && !isNaN(v));
-            if (validData.length < 2) return { percent: 0, isUp: false, isNeutral: true };
-            
-            const first = validData[0];
-            const last = validData[validData.length - 1];
-            
-            // Handle division by zero (when first value is 0)
-            if (first === 0) {
-              // If first is 0 and last is also 0, no change
-              if (last === 0) {
-                return { percent: 0, isUp: false, isNeutral: true };
-              }
-              // If first is 0 but last has value, show as 100% increase
-              return { percent: 100, isUp: true, isNeutral: false };
-            }
-            
-            const percent = ((last - first) / first) * 100;
-            
-            // Handle NaN or infinite result
-            if (isNaN(percent) || !isFinite(percent)) {
-              return { percent: 0, isUp: false, isNeutral: true };
-            }
-            
-            // Cap at 100% to avoid showing unrealistic percentages
-            const cappedPercent = Math.min(Math.abs(percent), 100);
-            // Consider values very close to 0 as neutral (within 0.1% threshold)
-            const isNeutral = Math.abs(percent) < 0.1;
-            return { 
-              percent: cappedPercent, 
-              isUp: percent > 0, 
-              isNeutral: isNeutral 
-            };
-          };
-          
-          const localEntityTrend = calculateTrend(localEntityData);
-          const serviceAreaTrend = calculateTrend(serviceAreaData);
-          const authorityTrend = calculateTrend(authorityData);
-          const visibilityTrend = calculateTrend(visibilityData);
-          const contentSchemaTrend = calculateTrend(contentSchemaData);
-          const brandOverlayTrend = calculateTrend(brandOverlayData);
-
-          // Update HTML trend summary row
-          const trendSummaryRow = document.getElementById('trendSummaryRow');
-          if (trendSummaryRow) {
-            const buildPill = (label, trend) => {
-              let arrow, sign, cls;
-              if (trend.isNeutral) {
-                arrow = '‚Üí';
-                sign = '';
-                cls = 'neutral';
-              } else {
-                arrow = trend.isUp ? '‚Üë' : '‚Üì';
-                sign = trend.isUp ? '+' : '';
-                cls = trend.isUp ? 'up' : 'down';
-              }
-              return `
-                <div class="trend-pill">
-                  <span class="label">${label}</span>
-                  <span class="value ${cls}">${arrow} ${sign}${trend.percent.toFixed(1)}%</span>
-                </div>
-              `;
-            };
-            trendSummaryRow.innerHTML = [
-              buildPill('Local Entity', localEntityTrend),
-              buildPill('Service Area', serviceAreaTrend),
-              buildPill('Authority', authorityTrend),
-              buildPill('Visibility', visibilityTrend),
-              buildPill('Content/Schema', contentSchemaTrend),
-              buildPill('Brand & Entity', brandOverlayTrend)
-            ].join('');
-            
-            // Add note explaining trend calculation
-            const trendNote = trendSummaryRow.nextElementSibling;
-            if (!trendNote || !trendNote.classList.contains('trend-calculation-note')) {
-              const noteDiv = document.createElement('div');
-              noteDiv.className = 'trend-calculation-note';
-              noteDiv.style.cssText = 'font-size: 0.75rem; color: #64748b; margin-top: 0.5rem; font-style: italic;';
-              noteDiv.textContent = 'Percentage changes are calculated from the first date to the last date in the selected range.';
-              trendSummaryRow.parentElement.insertBefore(noteDiv, trendSummaryRow.nextSibling);
-            }
-          }
-          
-          // Plugin to make year transition labels bold
-          const yearLabelBoldPlugin = {
-            id: 'yearLabelBold',
-            afterDraw: (chart) => {
-              const xScale = chart.scales.x;
-              const ctx = chart.ctx;
-              const rotation = -45 * (Math.PI / 180); // -45 degrees in radians
-              
-              // Get the chart dates array from the chart's data labels (original labels before callback)
-              const chartDates = chart.data.labels || [];
-              
-              // Iterate through all data points to find year labels
-              chartDates.forEach((originalLabel, dataIndex) => {
-                // Check if original label contains a year (4-digit number at the end)
-                if (originalLabel && /\d{4}$/.test(originalLabel)) {
-                  const label = originalLabel;
-                  // Get pixel position for this data point
-                  const tickPosition = xScale.getPixelForValue(dataIndex);
-                  const yPosition = chart.chartArea.bottom + 25;
-                  
-                  // Save context
-                  ctx.save();
-                  
-                  // Translate to tick position and rotate
-                  ctx.translate(tickPosition, yPosition);
-                  ctx.rotate(rotation);
-                  
-                  // Set bold font with larger size
-                  ctx.font = 'bold 14px Arial';
-                  ctx.fillStyle = '#000';
-                  ctx.textAlign = 'center';
-                  ctx.textBaseline = 'middle';
-                  
-                  // Measure text to clear area properly
-                  const metrics = ctx.measureText(label);
-                  const textWidth = metrics.width;
-                  const textHeight = 18;
-                  
-                  // Clear a larger area to remove the original label
-                  ctx.globalCompositeOperation = 'destination-out';
-                  ctx.fillRect(-textWidth/2 - 6, -textHeight/2 - 3, textWidth + 12, textHeight + 6);
-                  
-                  // Switch back to normal drawing
-                  ctx.globalCompositeOperation = 'source-over';
-                  
-                  // Draw bold label
-                  ctx.fillText(label, 0, 0);
-                  
-                  // Restore context
-                  ctx.restore();
-                }
-              });
-            }
-          };
-          
-          // Plugin to add RAG background bands with stronger contrast
-          const ragBackgroundPlugin = {
-            id: 'ragBackground',
-            beforeDraw: (chart) => {
-              const ctx = chart.ctx;
-              const chartArea = chart.chartArea;
-              const yScale = chart.scales.y;
-              
-              // Red zone (0-39) - increased opacity and saturation
-              if (yAxisMin <= 39) {
-                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(0, yAxisMin)));
-                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(39, yAxisMax)));
-                ctx.fillStyle = 'rgba(220, 38, 38, 0.18)'; // More saturated red, higher opacity
-                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
-              }
-              
-              // Amber zone (40-69) - increased opacity and saturation
-              if (yAxisMin <= 69 && yAxisMax >= 40) {
-                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(40, yAxisMin)));
-                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(69, yAxisMax)));
-                ctx.fillStyle = 'rgba(234, 179, 8, 0.18)'; // More saturated amber/yellow, higher opacity
-                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
-              }
-              
-              // Green zone (70-100) - increased opacity and saturation
-              if (yAxisMax >= 70) {
-                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(70, yAxisMin)));
-                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(100, yAxisMax)));
-                ctx.fillStyle = 'rgba(22, 163, 74, 0.18)'; // More saturated green, higher opacity
-                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
-              }
-            }
-          };
-          
-          // Plugin to draw vertical dividing lines at period transitions (months and years)
-          const periodDividingLinePlugin = {
-            id: 'periodDividingLine',
-            afterDraw: (chart) => {
-              const xScale = chart.scales.x;
-              const ctx = chart.ctx;
-              const chartArea = chart.chartArea;
-              
-              // Detect period transitions (month and year changes)
-              const periodTransitions = [];
-              let lastMonth = null;
-              let lastYear = null;
-              
-              // Use stored date objects to detect month/year changes
-              chartDateObjects.forEach((dateObj, index) => {
-                if (dateObj instanceof Date) {
-                  const currentMonth = dateObj.getMonth(); // 0-11
-                  const currentYear = dateObj.getFullYear();
-                  
-                  // Check for month or year transition
-                  if (lastMonth !== null && lastYear !== null) {
-                    if (currentYear !== lastYear || currentMonth !== lastMonth) {
-                      periodTransitions.push(index);
-                    }
-                  }
-                  
-                  lastMonth = currentMonth;
-                  lastYear = currentYear;
-                }
-              });
-              
-              // Draw vertical dotted lines at period transitions
-              periodTransitions.forEach((dataIndex) => {
-                // Get pixel position for this data point
-                const tickPosition = xScale.getPixelForValue(dataIndex);
-                
-                // Only draw if within chart area horizontally
-                if (tickPosition >= chartArea.left && tickPosition <= chartArea.right) {
-                  ctx.save();
-                  ctx.strokeStyle = 'rgba(120, 120, 120, 0.7)'; // Medium grey, more visible
-                  ctx.lineWidth = 3; // Thicker lines
-                  ctx.setLineDash([3, 4]); // Dotted line pattern
-                  ctx.beginPath();
-                  // Extend line beyond chart area to reach axis labels
-                  const lineTop = chartArea.top - 10; // Extend above chart
-                  const lineBottom = chartArea.bottom + 50; // Extend below chart to reach axis labels
-                  ctx.moveTo(tickPosition, lineTop);
-                  ctx.lineTo(tickPosition, lineBottom);
-                  ctx.stroke();
-                  ctx.restore();
-                }
-              });
-            }
-          };
-          
-          // Debug: Log the actual data arrays being passed to the chart
-          const brandOverlayValid = brandOverlayData.filter(v => v !== null && v !== undefined && !isNaN(v));
-          debugLog(`Chart creation: Local Entity data length=${localEntityData.length}, last 3 values=${localEntityData.slice(-3).join(', ')}, Service Area data length=${serviceAreaData.length}, last 3 values=${serviceAreaData.slice(-3).join(', ')}, Brand & Entity data length=${brandOverlayData.length}, valid values=${brandOverlayValid.length}, last 3 values=${brandOverlayData.slice(-3).join(', ')}, all values=${brandOverlayData.join(', ')}`, 'info');
-          
-          // DEBUG: Log exact labels being passed to Chart.js
-          debugLog(`[Trend Chart] Creating chart with ${chartDates.length} labels`, 'info');
-          debugLog(`[Trend Chart] First 5 labels: ${chartDates.slice(0, 5).join(', ')}`, 'info');
-          debugLog(`[Trend Chart] Last 5 labels: ${chartDates.slice(-5).join(', ')}`, 'info');
-          debugLog(`[Trend Chart] Latest audit date: ${latestAuditDateStr}`, 'info');
-          debugLog(`[Trend Chart] Data arrays length - Local Entity: ${localEntityData.length}, Service Area: ${serviceAreaData.length}, Authority: ${authorityData.length}, Visibility: ${visibilityData.length}, Content/Schema: ${contentSchemaData.length}`, 'info');
-          
-          // Remove inline loading spinner if it exists
-          const existingLoading = trendChartContainer.querySelector('.trend-chart-loading');
-          if (existingLoading) {
-            existingLoading.remove();
-            debugLog('Removed inline trend chart loading spinner', 'info');
-          }
-          
-          // Hide full-screen loading overlay
-          hideFullScreenLoading();
-          
-          // Destroy existing chart if it exists (prevent "Canvas is already in use" error)
-          if (window.trendChart) {
-            try {
-              window.trendChart.destroy();
-              debugLog('‚úì Destroyed existing trend chart before creating new one', 'info');
-            } catch (e) {
-              debugLog(`‚ö† Error destroying existing trend chart: ${e.message}`, 'warn');
-            }
-            window.trendChart = null;
-          }
-          
-          // Also check if Chart.js has an instance registered for this canvas
-          try {
-            const existingChart = Chart.getChart(trendCtx);
-            if (existingChart) {
-              existingChart.destroy();
-              debugLog('‚úì Destroyed Chart.js registered instance for trendChart canvas', 'info');
-            }
-          } catch (e) {
-            debugLog(`‚ö† Error checking/destroying Chart.js instance: ${e.message}`, 'warn');
-          }
-          
-          window.trendChart = new Chart(trendCtx, {
-            type: 'line',
-            data: {
-              labels: chartDates,
-              datasets: [
-                {
-                  label: 'Local Entity',
-                  data: localEntityData,
-                  borderColor: 'rgba(147, 51, 234, 1)', // Purple
-                  backgroundColor: 'rgba(147, 51, 234, 0.1)',
-                  borderWidth: 3,
-                  tension: 0.4,
-                  pointRadius: 0,
-                  pointHoverRadius: 5,
-                  spanGaps: true // Connect across null values to show continuous line
-                },
-                {
-                  label: 'Service Area',
-                  data: serviceAreaData,
-                  borderColor: '#00FFFF', // Cyan (not RAG color)
-                  backgroundColor: 'rgba(0, 255, 255, 0.1)',
-                  borderWidth: 3,
-                  tension: 0.4,
-                  pointRadius: 0,
-                  pointHoverRadius: 5,
-                  spanGaps: true // Connect across null values to show continuous line
-                },
-                {
-                  label: 'Authority',
-                  data: authorityData,
-                  borderColor: '#99004C', // Dark pink/magenta
-                  backgroundColor: 'rgba(153, 0, 76, 0.1)',
-                  borderWidth: 3,
-                  tension: 0.4,
-                  pointRadius: 0,
-                  pointHoverRadius: 5
-                  // No spanGaps - stop at last available GSC data (Dec 4)
-                },
-                {
-                  label: 'Visibility',
-                  data: visibilityData,
-                  borderColor: 'rgba(37, 99, 235, 1)', // Blue
-                  backgroundColor: 'rgba(59, 130, 246, 0.1)',
-                  borderWidth: 3,
-                  tension: 0.4,
-                  pointRadius: 0,
-                  pointHoverRadius: 5
-                  // No spanGaps - stop at last available GSC data (Dec 4)
-                },
-                {
-                  label: 'Content / Schema',
-                  data: contentSchemaData,
-                  borderColor: 'rgba(107, 114, 128, 1)', // Grey
-                  backgroundColor: 'rgba(107, 114, 128, 0.1)',
-                  borderWidth: 3,
-                  tension: 0.4,
-                  pointRadius: 0, // Hide points - show as solid line
-                  pointHoverRadius: 5,
-                  spanGaps: true, // Connect across null values to show continuous line
-                  pointBackgroundColor: 'rgba(107, 114, 128, 1)',
-                  pointBorderColor: '#ffffff',
-                  pointBorderWidth: 2
-                },
-                {
-                  label: 'Brand & Entity',
-                  data: brandOverlayData.length === chartDates.length ? brandOverlayData : (() => {
-                    // Ensure data array matches labels length
-                    const adjusted = [...brandOverlayData];
-                    while (adjusted.length < chartDates.length) {
-                      adjusted.push(null);
-                    }
-                    return adjusted.slice(0, chartDates.length);
-                  })(),
-                  borderColor: '#FFFF66', // Bright yellow
-                  backgroundColor: 'rgba(255, 255, 102, 0.1)', // Bright yellow with transparency
-                  borderWidth: 3, // Increased from 2 to make more visible
-                  borderDash: [5, 5], // Dashed line to indicate overlay
-                  tension: 0.4,
-                  pointRadius: 3, // Show points to make line more visible
-                  pointHoverRadius: 6,
-                  pointBackgroundColor: '#FFFF66',
-                  pointBorderColor: '#FFFF66',
-                  spanGaps: true,
-                  hidden: false // Explicitly ensure dataset is visible
-                }
-              ]
-            },
-            plugins: [ragBackgroundPlugin, yearLabelBoldPlugin, periodDividingLinePlugin],
-            options: {
-              responsive: true,
-              maintainAspectRatio: false,
-              animation: false, // Disable animation for better performance when changing periods
-              layout: {
-                padding: {
-                  bottom: 100, // Extra padding for rotated 45-degree X-axis labels (need space for diagonal text)
-                  left: 15, // Space for left Y-axis labels
-                  right: 50, // Extra space for right Y-axis labels (100, 80, 60, 40, 29)
-                  top: 10
-                }
-              },
-              scales: {
-                x: {
-                  ticks: {
-                    maxRotation: 45,
-                    minRotation: 45,
-                    font: {
-                      size: 11,
-                      weight: 'normal'
-                    },
-                    callback: function(value, index) {
-                      // Only show non-empty labels
-                      const label = this.getLabelForValue(value);
-                      // Hide year labels (they'll be drawn by plugin in bold)
-                      if (label && /\d{4}$/.test(label)) {
-                        return ''; // Return empty to hide, plugin will draw it
-                      }
-                      return label || '';
-                    }
-                  },
-                  grid: {
-                    display: true,
-                    color: 'rgba(0, 0, 0, 0.05)'
-                  }
-                },
-                y: {
-                  min: yAxisMin,
-                  max: yAxisMax,
-                  position: 'left',
-                  ticks: {
-                    stepSize: stepSize,
-                    font: {
-                      size: 12,
-                      weight: 'bold'
-                    }
-                  },
-                  grid: {
-                    color: 'rgba(0, 0, 0, 0.1)',
-                    drawBorder: true
-                  }
-                },
-                y1: {
-                  min: yAxisMin,
-                  max: yAxisMax,
-                  position: 'right',
-                  ticks: {
-                    stepSize: stepSize,
-                    font: {
-                      size: 12,
-                      weight: 'bold'
-                    }
-                  },
-                  grid: {
-                    display: false,
-                    drawBorder: false
-                  }
-                }
-              },
-              plugins: {
-                legend: {
-                  display: true,
-                  position: 'top',
-                  labels: {
-                    font: {
-                      size: 16,
-                      weight: 'bold'
-                    },
-                    padding: 25,
-                    usePointStyle: false,
-                    boxWidth: 60,
-                    boxHeight: 4,
-                    // Use default legend labels (pillar names only, no trends)
-                    generateLabels: function(chart) {
-                      const original = Chart.defaults.plugins.legend.labels.generateLabels;
-                      return original.call(this, chart);
-                    }
-                  }
-                },
-                tooltip: {
-                  mode: 'index',
-                  intersect: false
-                }
-              }
-            }
-          });
-          debugLog('‚úì Trend chart created successfully', 'success');
-          debugLog(`trendChart type after creation: ${typeof window.trendChart}`, 'info');
-          debugLog(`trendChart instanceof Chart: ${window.trendChart instanceof Chart}`, 'info');
-          debugLog(`Chart data points: Local Entity=${localEntityData.length}, Visibility=${visibilityData.length}, Authority=${authorityData.length}`, 'info');
-          
-          // Add event listeners for Authority mode toggle buttons (sync with KPI toggle)
-          ['all', 'nonEducation', 'money'].forEach(mode => {
-            const btn = document.getElementById(`trend-mode-${mode}`);
-            if (btn) {
-              btn.addEventListener('click', () => {
-                // Update selected mode (shared with KPI toggle)
-                window.trendAuthorityMode = mode;
-                debugLog(`üìä Trend chart Authority mode changed to: ${mode === 'all' ? 'All pages' : mode === 'nonEducation' ? 'Exclude education' : 'Money pages only'}`, 'info');
-                
-                // Update button styles for both KPI and trend toggles
-                ['all', 'nonEducation', 'money'].forEach(m => {
-                  // Update trend toggle buttons
-                  const trendBtn = document.getElementById(`trend-mode-${m}`);
-                  if (trendBtn) {
-                    if (m === mode) {
-                      trendBtn.style.background = '#10b981';
-                      trendBtn.style.color = 'white';
-                    } else {
-                      trendBtn.style.background = 'white';
-                      trendBtn.style.color = '#666';
-                    }
-                  }
-                  // Update KPI toggle buttons
-                  const kpiBtn = document.getElementById(`kpi-mode-${m}`);
-                  if (kpiBtn) {
-                    if (m === mode) {
-                      kpiBtn.style.background = '#10b981';
-                      kpiBtn.style.color = 'white';
-                    } else {
-                      kpiBtn.style.background = 'white';
-                      kpiBtn.style.color = '#666';
-                    }
-                  }
-                });
-                
-                // Redraw the chart with new Authority data
-                if (window.trendChart && typeof displayDashboard === 'function') {
-                  // Re-run displayDashboard to recalculate with new mode
-                  displayDashboard();
-                }
-              });
-            }
-          });
-          
-          debugLog('=== DISPLAY DASHBOARD: Complete ===', 'success');
-        } catch (e) {
-          debugLog(`‚úó Error creating trend chart: ${e.message}`, 'error');
-          debugLog(`Stack: ${e.stack}`, 'error');
-          console.error('Error creating trend chart:', e);
-          
-          // Hide full-screen loading overlay
-          hideFullScreenLoading();
-          
-          // Show error message to user
-          const trendCanvas = document.getElementById('trendChart');
-          if (trendCanvas && trendCanvas.parentElement) {
-            // Remove any existing error messages
-            const existingError = trendCanvas.parentElement.querySelector('.trend-chart-error');
-            if (existingError) existingError.remove();
-            
-            // Show error message to user
-            const errorDiv = document.createElement('div');
-            errorDiv.className = 'trend-chart-error';
-            errorDiv.style.cssText = 'background: #fee2e2; padding: 1rem; border-radius: 4px; border-left: 3px solid #ef4444; margin-bottom: 1rem; font-size: 0.9rem; color: #991b1b;';
-            errorDiv.innerHTML = `<strong>Error loading trend chart:</strong> ${e.message}. Please refresh the page or run a new audit.`;
-            trendCanvas.parentElement.insertBefore(errorDiv, trendCanvas);
-          }
-        }
-      }, 100);
-    }
-
-    // Function to load shared audit data
-    async function loadSharedAudit(shareId) {
-      try {
-        debugLog(`Loading shared audit: ${shareId}`, 'info');
-        const response = await fetch(apiUrl(`/api/supabase/get-shared-audit?shareId=${encodeURIComponent(shareId)}`));
-        
-        if (!response.ok) {
-          const error = await response.json();
-          throw new Error(error.message || 'Failed to load shared audit');
-        }
-        
-        const result = await response.json();
-        if (result.status === 'ok' && result.data) {
-          debugLog('‚úì Shared audit loaded successfully', 'success');
-          return result.data;
-        } else {
-          throw new Error('Invalid shared audit data');
-        }
-      } catch (error) {
-        debugLog(`‚úó Error loading shared audit: ${error.message}`, 'error');
-        showStatus(`Failed to load shared audit: ${error.message}`, 'error');
-        return null;
-      }
-    }
-
-    // Function to create shareable link (exposed globally for onclick)
-    window.createShareableLink = async function() {
-      const savedAudit = await loadAuditResults();
-      if (!savedAudit || !savedAudit.scores) {
-        showStatus('No audit data available to share. Please run an audit first.', 'error');
-        return;
-      }
-
-      try {
-        showStatus('Creating shareable link...', 'info');
-        const response = await fetch(apiUrl('/api/supabase/create-shared-audit'), {
-          method: 'POST',
-          headers: {
-            'Content-Type': 'application/json'
-          },
-          body: JSON.stringify({
-            auditData: savedAudit
-          })
-        });
-
-        if (!response.ok) {
-          const error = await response.json();
-          throw new Error(error.message || 'Failed to create shareable link');
-        }
-
-        const result = await response.json();
-        if (result.status === 'ok' && result.shareUrl) {
-          // Copy to clipboard
-          await navigator.clipboard.writeText(result.shareUrl);
-          showStatus(`Shareable link created and copied to clipboard! Link expires in 30 days.`, 'success');
-          
-          // Show the link in an alert or modal
-          alert(`Shareable link created!\n\n${result.shareUrl}\n\n(Link copied to clipboard)\n\nThis link expires in 30 days.`);
-        } else {
-          throw new Error('Invalid response from server');
-        }
-      } catch (error) {
-        debugLog(`‚úó Error creating shareable link: ${error.message}`, 'error');
-        showStatus(`Failed to create shareable link: ${error.message}`, 'error');
-      }
-    }
-
-    // Initialize on load
-    window.addEventListener('DOMContentLoaded', () => {
-      debugLog('=== PAGE LOAD: DOMContentLoaded event fired ===', 'info');
-      debugLog(`Window location: ${window.location.href}`, 'info');
-      debugLog(`User agent: ${navigator.userAgent}`, 'info');
-      loadConfig();
-      
-      // Check for share parameter in URL
-      const urlParams = new URLSearchParams(window.location.search);
-      const shareId = urlParams.get('share');
-      
-      // Load and display last audit results if available
-      // Wait a tick to ensure loadConfig() has finished updating the date range input
-      setTimeout(async () => {
-        let auditToDisplay = null;
-        
-        if (shareId) {
-          // Load shared audit
-          debugLog(`Share ID detected: ${shareId}`, 'info');
-          auditToDisplay = await loadSharedAudit(shareId);
-          if (auditToDisplay) {
-            // Save shared audit to localStorage temporarily for display
-            safeSetLocalStorage('last_audit_results', auditToDisplay);
-            // Show a banner indicating this is a shared view
-            const banner = document.createElement('div');
-            banner.style.cssText = 'background: #dbeafe; padding: 1rem; border-radius: 4px; border-left: 4px solid #3b82f6; margin-bottom: 1rem; font-size: 0.9rem; color: #1e40af;';
-            banner.innerHTML = '<strong>üì§ Shared Audit View</strong> - This is a shared audit. You can view all results but cannot run new audits from this view.';
-            const dashboard = document.getElementById('dashboard');
-            if (dashboard) {
-              dashboard.insertBefore(banner, dashboard.firstChild);
-            }
-            // Hide the run audit button
-            const runAuditBtn = document.getElementById('runAudit');
-            if (runAuditBtn) {
-              runAuditBtn.style.display = 'none';
-            }
-          }
-        }
-        
-        // If no shared audit or failed to load, try localStorage or Supabase
-        if (!auditToDisplay) {
-          auditToDisplay = await loadAuditResults();
-        }
-        
-        // If still no audit data, try fetching from Supabase
-        if (!auditToDisplay) {
-          const propertyUrl = localStorage.getItem('gsc_property_url');
-          if (propertyUrl) {
-            debugLog('No audit data in localStorage, fetching from Supabase...', 'info');
-            auditToDisplay = await fetchLatestAuditFromSupabase(propertyUrl);
-            if (auditToDisplay) {
-              // Save to localStorage for future use
-              safeSetLocalStorage('last_audit_results', auditToDisplay);
-              // Update timestamp display
-              if (auditToDisplay.timestamp) {
-                updateAuditTimestamp(auditToDisplay.timestamp);
-              }
-              debugLog('‚úì Latest audit loaded from Supabase and saved to localStorage', 'success');
-            } else {
-              debugLog('‚ö† No audit data found in Supabase either', 'warn');
-            }
-          } else {
-            debugLog('‚ö† Cannot fetch from Supabase: property URL not configured', 'warn');
-          }
-        }
-        
-        const savedAudit = auditToDisplay;
-        if (savedAudit && savedAudit.scores && savedAudit.searchData) {
-          // CRITICAL: Restore Money Pages Priority data FIRST before any rendering
-          debugLog(`Checking saved audit for moneyPagePriorityData: ${!!savedAudit.moneyPagePriorityData}, type: ${Array.isArray(savedAudit.moneyPagePriorityData) ? 'array' : typeof savedAudit.moneyPagePriorityData}, length: ${Array.isArray(savedAudit.moneyPagePriorityData) ? savedAudit.moneyPagePriorityData.length : 'N/A'}, value: ${JSON.stringify(savedAudit.moneyPagePriorityData ? (Array.isArray(savedAudit.moneyPagePriorityData) ? `[${savedAudit.moneyPagePriorityData.length} items]` : savedAudit.moneyPagePriorityData) : 'null').substring(0, 100)}`, 'info');
-          
-          // Check if moneyPagePriorityData exists but is null/empty
-          if (savedAudit.moneyPagePriorityData !== null && savedAudit.moneyPagePriorityData !== undefined) {
-            if (Array.isArray(savedAudit.moneyPagePriorityData) && savedAudit.moneyPagePriorityData.length > 0) {
-              window.moneyPagePriorityData = savedAudit.moneyPagePriorityData;
-              debugLog(`‚úì Restored moneyPagePriorityData from saved audit: ${savedAudit.moneyPagePriorityData.length} pages`, 'success');
-            } else if (Array.isArray(savedAudit.moneyPagePriorityData) && savedAudit.moneyPagePriorityData.length === 0) {
-              debugLog(`‚ö† moneyPagePriorityData exists but is empty array`, 'warn');
-              window.moneyPagePriorityData = [];
-            } else {
-              debugLog(`‚ö† moneyPagePriorityData exists but is not an array: ${typeof savedAudit.moneyPagePriorityData}`, 'warn');
-              window.moneyPagePriorityData = [];
-            }
-          } else {
-            debugLog(`‚ö† moneyPagePriorityData is null/undefined in saved audit. Keys in savedAudit: ${Object.keys(savedAudit).join(', ')}`, 'warn');
-            // Try to rebuild if we have moneyPagesMetrics
-            if (savedAudit.scores?.moneyPagesMetrics?.rows && savedAudit.scores.moneyPagesMetrics.rows.length > 0) {
-              debugLog(`‚ö† Will try to rebuild moneyPagePriorityData from moneyPagesMetrics (${savedAudit.scores.moneyPagesMetrics.rows.length} rows)`, 'info');
-            }
-          }
-          
-          if (savedAudit.moneySegmentMetrics) {
-            window.moneySegmentMetrics = savedAudit.moneySegmentMetrics;
-            debugLog(`‚úì Restored moneySegmentMetrics from saved audit`, 'success');
-          } else {
-            debugLog(`‚ö† moneySegmentMetrics NOT found in saved audit`, 'warn');
-          }
-          
-          // Ensure moneyPagesMetrics is in scores if it exists in the audit data
-          if (!savedAudit.scores.moneyPagesMetrics && savedAudit.moneyPagesMetrics) {
-            savedAudit.scores.moneyPagesMetrics = savedAudit.moneyPagesMetrics;
-            debugLog('‚úì Moved moneyPagesMetrics from audit root to scores', 'success');
-          }
-          
-          // Store globally for Money Pages sections
-          if (savedAudit.scores.moneyPagesMetrics) {
-            window.currentMoneyPagesMetrics = savedAudit.scores.moneyPagesMetrics;
-            window.moneyPagesMetrics = savedAudit.scores.moneyPagesMetrics;
-            debugLog(`‚úì Stored moneyPagesMetrics globally: ${savedAudit.scores.moneyPagesMetrics.rows?.length || 0} rows`, 'success');
-          }
-          
-          // If saved audit has a date range, use it to set the input field and button
-          // This ensures the UI matches the saved audit's date range
-          if (savedAudit.dateRange) {
-            const savedDateRange = savedAudit.dateRange;
-            document.getElementById('dateRange').value = savedDateRange;
-            // Update active button to match saved date range
-            document.querySelectorAll('.date-range-btn').forEach(btn => {
-              btn.classList.remove('active');
-              const btnDays = parseInt(btn.getAttribute('data-days'));
-              if (btnDays === savedDateRange) {
-                btn.classList.add('active');
-              }
-            });
-            // Update localStorage to match
-            localStorage.setItem('gsc_date_range', savedDateRange);
-            debugLog(`Set date range to ${savedDateRange} to match saved audit`, 'info');
-          }
-          
-          // Now check if they match (they should, since we just set it)
-          const currentDateRange = parseInt(document.getElementById('dateRange')?.value) || 30;
-          const savedDateRange = savedAudit.dateRange || currentDateRange;
-          
-          debugLog(`Checking date range match: saved=${savedDateRange}, current=${currentDateRange}`, 'info');
-          
-          if (savedDateRange === currentDateRange) {
-            debugLog('Loading last audit results from localStorage...', 'info');
-            
-            // CRITICAL: If moneyPagePriorityData is null but we have moneyPagesMetrics, try to rebuild it
-            // But only if buildMoneyPageMetrics is available
-            if ((!window.moneyPagePriorityData || window.moneyPagePriorityData.length === 0) && 
-                savedAudit.scores?.moneyPagesMetrics?.rows && 
-                savedAudit.scores.moneyPagesMetrics.rows.length > 0) {
-              debugLog(`Attempting to rebuild moneyPagePriorityData from moneyPagesMetrics (${savedAudit.scores.moneyPagesMetrics.rows.length} rows)...`, 'info');
-              
-              // Wait for buildMoneyPageMetrics to be available (with timeout)
-              let attempts = 0;
-              const maxAttempts = 20; // 2 seconds total wait
-              debugLog(`Waiting for buildMoneyPageMetrics... (currently: ${typeof window.buildMoneyPageMetrics})`, 'info');
-              while (typeof window.buildMoneyPageMetrics !== 'function' && attempts < maxAttempts) {
-                await new Promise(resolve => setTimeout(resolve, 100));
-                attempts++;
-                if (attempts % 5 === 0) {
-                  debugLog(`Still waiting for buildMoneyPageMetrics... (attempt ${attempts}/${maxAttempts})`, 'info');
-                }
-              }
-              
-              debugLog(`buildMoneyPageMetrics check after wait: ${typeof window.buildMoneyPageMetrics}`, 'info');
-              
-              if (typeof window.buildMoneyPageMetrics === 'function') {
-                try {
-                  const topPagesForPriority = savedAudit.scores.moneyPagesMetrics.rows.map(row => ({
-                    page: row.url,
-                    url: row.url,
-                    clicks: row.clicks || 0,
-                    impressions: row.impressions || 0,
-                    ctr: (row.ctr || 0) * 100,
-                    position: row.avgPosition || 0,
-                    avgPosition: row.avgPosition || 0,
-                    title: row.title || row.url
-                  }));
-                  
-                  window.moneyPagePriorityData = window.buildMoneyPageMetrics(topPagesForPriority, savedAudit.schemaAudit || null);
-                  debugLog(`‚úì Rebuilt moneyPagePriorityData: ${window.moneyPagePriorityData.length} pages`, 'success');
-                  
-                  // Save rebuilt data back to localStorage
-                  savedAudit.moneyPagePriorityData = window.moneyPagePriorityData;
-                  safeSetLocalStorage('last_audit_results', savedAudit);
-                } catch (error) {
-                  debugLog(`‚ö† Failed to rebuild moneyPagePriorityData: ${error.message}`, 'warn');
-                }
-              } else {
-                debugLog(`‚ö† buildMoneyPageMetrics still not available after ${maxAttempts * 100}ms wait`, 'warn');
-              }
-            }
-            
-            // Show dashboard immediately with saved results
-            document.getElementById('dashboard').style.display = 'block';
-            document.getElementById('loading').classList.remove('show');
-            // Ensure searchData has timeseries if available
-            const searchDataWithTimeseries = savedAudit.searchData || {};
-            if (!searchDataWithTimeseries.timeseries) {
-              // Try to load timeseries from saved audit
-              if (savedAudit.timeseries) {
-                searchDataWithTimeseries.timeseries = savedAudit.timeseries;
-                debugLog(`‚úì Restored timeseries data from saved audit: ${savedAudit.timeseries.length} data points`, 'success');
-              } else {
-                // Try to fetch timeseries from Supabase gsc_timeseries table
-                debugLog('Fetching timeseries data from Supabase for Score Trends chart...', 'info');
-                try {
-                  const propertyUrl = savedAudit.searchData?.propertyUrl || localStorage.getItem('gsc_property_url');
-                  if (propertyUrl) {
-                    const endDate = new Date().toISOString().split('T')[0];
-                    const startDate = new Date();
-                    startDate.setDate(startDate.getDate() - 30); // Last 30 days
-                    const startDateStr = startDate.toISOString().split('T')[0];
-                    
-                    const timeseriesResponse = await fetch(apiUrl(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDate}`));
-                    if (timeseriesResponse.ok) {
-                      const timeseriesData = await timeseriesResponse.json();
-                      if (timeseriesData.status === 'ok' && timeseriesData.timeseries && Array.isArray(timeseriesData.timeseries)) {
-                        searchDataWithTimeseries.timeseries = timeseriesData.timeseries;
-                        debugLog(`‚úì Loaded timeseries data from Supabase: ${timeseriesData.timeseries.length} data points`, 'success');
-                      }
-                    }
-                  }
-                } catch (error) {
-                  debugLog(`‚ö† Failed to load timeseries data: ${error.message}`, 'warn');
-                }
-              }
-            }
-            
-            displayDashboard(
-              savedAudit.scores,
-              searchDataWithTimeseries,
-              savedAudit.snippetReadiness || 0,
-              savedAudit.schemaAudit || null,
-              savedAudit.localSignals || null
-            );
-            debugLog('‚úì Last audit results displayed', 'success');
-          } else {
-            debugLog(`Saved audit date range (${savedDateRange}) doesn't match current (${currentDateRange}). Dashboard not displayed.`, 'warn');
-            // Don't show dashboard - user needs to run new audit
-          }
-        } else {
-          // No audit data found - show empty state message
-          debugLog('‚ö† No audit data found. Please run a new audit.', 'warn');
-          const dashboard = document.getElementById('dashboard');
-          if (dashboard) {
-            dashboard.style.display = 'block';
-            dashboard.innerHTML = `
-              <div style="padding: 3rem; text-align: center; background: white; border-radius: 8px; margin: 2rem;">
-                <h2 style="color: #1e293b; margin-bottom: 1rem;">No Audit Data Found</h2>
-                <p style="color: #64748b; margin-bottom: 2rem;">Run your first audit to see the dashboard content.</p>
-                <button id="runAudit" onclick="runAudit()" style="background: #f97316; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; font-size: 1rem; cursor: pointer; font-weight: 600;">
-                  Run Audit
-                </button>
-              </div>
-            `;
-          }
-          document.getElementById('loading').classList.remove('show');
-        }
-      }, 100); // Increased delay to ensure loadConfig completes
-      
-      debugLog('=== PAGE LOAD: Initialization complete ===', 'success');
-    });
-
-    // PDF Report Generation
-    async function generatePDFReport() {
-      console.log('[PDF] ===== PDF GENERATION STARTED =====');
-      
-      const btn = document.getElementById('generatePdfBtn');
-      const statusDiv = document.getElementById('pdfStatus');
-      
-      if (!btn) {
-        console.error('[PDF] Generate PDF button not found!');
-        alert('Error: Generate PDF button not found. Please refresh the page.');
-        return;
-      }
-      
-      if (!statusDiv) {
-        console.error('[PDF] PDF status div not found!');
-      }
-      
-      // Check if html2pdf is available
-      if (typeof html2pdf === 'undefined') {
-        const errorMsg = '‚ùå PDF library not loaded. Please refresh the page.';
-        if (statusDiv) {
-          statusDiv.textContent = errorMsg;
-          statusDiv.style.color = '#dc2626';
-        }
-        console.error('[PDF] html2pdf is not defined');
-        alert(errorMsg);
-        return;
-      }
-      
-      console.log('[PDF] html2pdf library is available');
-      
-      // Check if dashboard has data
-      const dashboard = document.getElementById('dashboard');
-      if (!dashboard || dashboard.style.display === 'none') {
-        const errorMsg = '‚ö†Ô∏è Please run an audit first to generate a report.';
-        if (statusDiv) {
-          statusDiv.textContent = errorMsg;
-          statusDiv.style.color = '#dc2626';
-        }
-        console.warn('[PDF] Dashboard not available or hidden');
-        return;
-      }
-
-      console.log('[PDF] Dashboard is available and visible');
-
-      // Disable button and show status
-      btn.disabled = true;
-      btn.style.opacity = '0.6';
-      if (statusDiv) {
-        statusDiv.textContent = '‚è≥ Generating PDF report...';
-        statusDiv.style.color = '#2563eb';
-      }
-      
-      console.log('[PDF] Starting PDF generation process...');
-
-      try {
-        // Load saved audit data
-        const savedAudit = loadAuditResultsSync();
-        if (!savedAudit || !savedAudit.scores) {
-          throw new Error('No audit data available. Please run an audit first.');
-        }
-
-        // Get property URL and date range
-        const propertyUrl = document.getElementById('propertyUrl')?.value || 'N/A';
-        const dateRange = document.getElementById('dateRange')?.value || 30;
-        const auditDate = savedAudit.auditDate || new Date().toISOString().split('T')[0];
-
-        // Convert charts to images first (before creating HTML)
-        console.log('[PDF] Converting charts to images...');
-        
-        // Create temporary canvas elements to capture charts
-        const radarCanvas = document.getElementById('radarChart');
-        const trendCanvas = document.getElementById('trendChart');
-        const snippetCanvas = document.getElementById('snippetReadinessPieChart');
-        
-        let radarImgData = '';
-        let trendImgData = '';
-        let snippetImgData = '';
-        
-        if (radarCanvas && window.radarChart) {
-          radarImgData = radarCanvas.toDataURL('image/png');
-          console.log('[PDF] Radar chart converted to image');
-        }
-        
-        if (trendCanvas && window.trendChart) {
-          trendImgData = trendCanvas.toDataURL('image/png');
-          console.log('[PDF] Trend chart converted to image');
-        }
-        
-        if (snippetCanvas && window.snippetReadinessChart) {
-          snippetImgData = snippetCanvas.toDataURL('image/png');
-          console.log('[PDF] Snippet readiness chart converted to image');
-        }
-
-        // Create report HTML with embedded chart images
-        console.log('[PDF] Creating report HTML...');
-        const reportHTML = createReportHTML(savedAudit, propertyUrl, dateRange, auditDate, {
-          radarChart: radarImgData,
-          trendChart: trendImgData,
-          snippetReadinessChart: snippetImgData
-        });
-
-        // Verify reportHTML has content
-        if (!reportHTML || reportHTML.length < 100) {
-          console.error('[PDF] Report HTML is empty or too short:', reportHTML ? reportHTML.length : 'null/undefined');
-          throw new Error('Report HTML is empty or too short. Cannot generate PDF.');
-        }
-        
-        console.log('[PDF] Report HTML created successfully');
-        console.log('[PDF] Report HTML length:', reportHTML.length);
-        console.log('[PDF] Report HTML starts with:', reportHTML.substring(0, 100));
-        console.log('[PDF] Report HTML ends with:', reportHTML.substring(reportHTML.length - 100));
-        
-        // Check if reportHTML contains expected content
-        if (!reportHTML.includes('GAIO Audit Report')) {
-          console.warn('[PDF] Warning: Report HTML may not contain expected content');
-        }
-        
-        // Use Workshop Planner approach: exactly match printJourney pattern from print-export-dialog.tsx
-        const printWindow = window.open('', '_blank');
-        if (!printWindow) {
-          throw new Error('Could not open print window. Please allow popups for this site.');
-        }
-        
-        console.log('[PDF] Print window opened');
-        console.log('[PDF] Writing HTML content (length:', reportHTML.length, ')');
-        
-        // Write the complete report HTML directly (it already includes full HTML structure)
-        printWindow.document.write(reportHTML);
-        printWindow.document.close();
-        
-        console.log('[PDF] HTML written and document closed');
-        
-        // Add a slight delay before triggering print to ensure content is fully loaded (exactly like printJourney)
-        setTimeout(function() {
-          try {
-            console.log('[PDF] Attempting to print styled report...');
-            printWindow.focus();
-            printWindow.print();
-            console.log('[PDF] Print dialog triggered');
-            
-            if (statusDiv) {
-              statusDiv.textContent = '‚úÖ Print dialog opened. Save as PDF from the print dialog.';
-              statusDiv.style.color = '#10b981';
-              setTimeout(() => {
-                statusDiv.textContent = '';
-              }, 5000);
-            }
-          } catch (error) {
-            console.error('[PDF] Print error:', error);
-            if (statusDiv) {
-              statusDiv.textContent = '‚ùå Error opening print dialog. Please try again.';
-              statusDiv.style.color = '#dc2626';
-            }
-            alert('Failed to open print dialog: ' + error.message);
-          }
-        }, 1500); // Increased timeout to ensure content is fully loaded (matches printJourney)
-
-      } catch (error) {
-        console.error('[PDF] ===== PDF GENERATION ERROR =====');
-        console.error('[PDF] Error message:', error.message);
-        console.error('[PDF] Error stack:', error.stack);
-        console.error('[PDF] Error object:', error);
-        
-        const errorMsg = `‚ùå Error: ${error.message}`;
-        if (statusDiv) {
-          statusDiv.textContent = errorMsg;
-          statusDiv.style.color = '#dc2626';
-        }
-        
-        // Also show alert so user definitely sees the error
-        alert(`PDF Generation Failed:\n\n${error.message}\n\nCheck the browser console for more details.`);
-      } finally {
-        btn.disabled = false;
-        btn.style.opacity = '1';
-        console.log('[PDF] ===== PDF GENERATION COMPLETE =====');
-      }
-    }
-
-    // Convert Chart.js charts to images
-    async function convertChartsToImages(container) {
-      console.log('[PDF] Converting charts to images...');
-      
-      // Convert radar chart
-      const radarCanvas = document.getElementById('radarChart');
-      if (radarCanvas && window.radarChart) {
-        console.log('[PDF] Converting radar chart...');
-        const radarImg = radarCanvas.toDataURL('image/png');
-        const radarImgElement = container.querySelector('#radarChartImg');
-        if (radarImgElement) {
-          radarImgElement.src = radarImg;
-          radarImgElement.style.display = 'block';
-          console.log('[PDF] Radar chart image set, data URL length:', radarImg.length);
-        } else {
-          console.warn('[PDF] Radar chart image element not found in container');
-        }
-      } else {
-        console.warn('[PDF] Radar chart canvas or chart instance not found');
-      }
-
-      // Convert trend chart
-      const trendCanvas = document.getElementById('trendChart');
-      if (trendCanvas && window.trendChart) {
-        console.log('[PDF] Converting trend chart...');
-        const trendImg = trendCanvas.toDataURL('image/png');
-        const trendImgElement = container.querySelector('#trendChartImg');
-        if (trendImgElement) {
-          trendImgElement.src = trendImg;
-          trendImgElement.style.display = 'block';
-          console.log('[PDF] Trend chart image set, data URL length:', trendImg.length);
-        } else {
-          console.warn('[PDF] Trend chart image element not found in container');
-        }
-      } else {
-        console.warn('[PDF] Trend chart canvas or chart instance not found');
-      }
-
-      // Convert snippet readiness chart
-      const snippetCanvas = document.getElementById('snippetReadinessPieChart');
-      if (snippetCanvas && window.snippetReadinessChart) {
-        console.log('[PDF] Converting snippet readiness chart...');
-        const snippetImg = snippetCanvas.toDataURL('image/png');
-        const snippetImgElement = container.querySelector('#snippetReadinessChartImg');
-        if (snippetImgElement) {
-          snippetImgElement.src = snippetImg;
-          snippetImgElement.style.display = 'block';
-          console.log('[PDF] Snippet readiness chart image set, data URL length:', snippetImg.length);
-        } else {
-          console.warn('[PDF] Snippet readiness chart image element not found in container');
-        }
-      } else {
-        console.warn('[PDF] Snippet readiness chart canvas or chart instance not found');
-      }
-      
-      console.log('[PDF] Chart conversion complete');
-    }
-
-    // Create report HTML content
-    function createReportHTML(auditData, propertyUrl, dateRange, auditDate, chartImages = {}) {
-      const scores = auditData.scores || {};
-      const searchData = auditData.searchData || {};
-      const schemaAudit = auditData.schemaAudit || {};
-      const snippetReadiness = auditData.snippetReadiness || 0;
-      const localSignals = auditData.localSignals || null;
-      const hasLocalSignals = localSignals && localSignals.status === 'ok' && localSignals.data;
-      const localSignalsData = hasLocalSignals ? localSignals.data : null;
-
-      // Helper function for RAG status
-      const getRAGStatus = (score) => {
-        if (score >= 70) return { color: '#10b981', label: 'Green', text: 'Good' };
-        if (score >= 40) return { color: '#f59e0b', label: 'Amber', text: 'Needs Improvement' };
-        return { color: '#ef4444', label: 'Red', text: 'Poor' };
-      };
-
-      // Get next steps (create a helper function similar to the one in displayDashboard)
-      const getNextStepsForPDF = (scores, searchData, schemaAudit) => {
-        const nextSteps = {};
-        
-        Object.entries(scores).forEach(([key, score]) => {
-          const steps = [];
-          
-          switch(key) {
-            case 'contentSchema':
-              if (schemaAudit && schemaAudit.data) {
-                const schemaData = schemaAudit.data;
-                const { coverage, schemaTypes, richEligible } = schemaData;
-                
-                // Use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
-                const allTypes = new Set();
-                if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
-                  // Use all detected types for accurate calculation
-                  schemaData.allDetectedTypes.forEach(type => {
-                    if (type) allTypes.add(type);
-                  });
-                } else if (schemaTypes && Array.isArray(schemaTypes)) {
-                  // Fallback: collect from schemaTypes array (contains all types, sorted by count)
-                  schemaTypes.forEach(item => {
-                    if (item.type) allTypes.add(item.type);
-                  });
-                }
-                
-                const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
-                const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
-                const foundationMissing = foundationTypes.filter(type => !allTypes.has(type));
-                
-                if (foundationPresent < 4) {
-                  steps.push(`Foundation schemas (30%): ${foundationPresent}/4 present. Add: ${foundationMissing.join(', ')}`);
-                } else {
-                  steps.push(`Foundation schemas (30%): All 4 present`);
-                }
-                
-                const richEligibleCount = Object.values(richEligible || {}).filter(eligible => eligible === true).length;
-                const richResultTypesCount = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'].length;
-                if (richEligibleCount < richResultTypesCount) {
-                  steps.push(`Rich results (35%): ${richEligibleCount}/${richResultTypesCount} eligible. Add more rich result types`);
-                } else {
-                  steps.push(`Rich results (35%): All ${richResultTypesCount} types eligible`);
-                }
-                
-                if (coverage < 100) {
-                  steps.push(`Coverage (20%): ${coverage.toFixed(1)}% - Add schema to pages without markup`);
-                } else {
-                  steps.push(`Coverage (20%): 100% - All pages have schema`);
-                }
-                
-                const uniqueTypesCount = allTypes.size;
-                if (uniqueTypesCount < 15) {
-                  steps.push(`Diversity (15%): ${uniqueTypesCount} unique types. Add more schema types to reach 15+`);
-                } else {
-                  steps.push(`Diversity (15%): ${uniqueTypesCount} unique types (excellent)`);
-                }
-              } else {
-                steps.push('Schema audit data not available - run audit to see detailed metrics');
-              }
-              break;
-              
-            case 'visibility':
-              if (searchData) {
-                const position = searchData.averagePosition || 0;
-                const ctr = searchData.ctr || 0;
-                
-                if (position > 10) {
-                  steps.push(`Average position: ${position.toFixed(1)} - Target top 10 positions`);
-                } else {
-                  steps.push(`Average position: ${position.toFixed(1)} - Excellent! Maintain top 10 rankings`);
-                }
-                
-                if (ctr < 2.0) {
-                  steps.push(`CTR: ${ctr.toFixed(1)}% - Improve click-through rate (target: 2%+)`);
-                } else {
-                  steps.push(`CTR: ${ctr.toFixed(1)}% - Good CTR! Continue optimizing`);
-                }
-              }
-              break;
-              
-            case 'authority':
-              if (searchData) {
-                const ctr = searchData.ctr || 0;
-                const position = searchData.averagePosition || 0;
-                
-                if (ctr < 1.5) {
-                  steps.push(`CTR: ${ctr.toFixed(1)}% - Low click-through indicates trust issues. Improve E-A-T signals`);
-                } else {
-                  steps.push(`CTR: ${ctr.toFixed(1)}% - Good engagement. Build more backlinks to strengthen authority`);
-                }
-                
-                if (position > 15) {
-                  steps.push(`Position: ${position.toFixed(1)} - Improve rankings through comprehensive, expert content`);
-                }
-              }
-              break;
-              
-            case 'localEntity':
-              if (hasLocalSignals && localSignalsData) {
-                const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
-                const locationsCount = localSignalsData.locations?.length || 0;
-                const knowledgePanel = localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected';
-                steps.push(`Current score: ${Math.round(score)} - Using real Business Profile data`);
-                steps.push(`Data: NAP consistency: ${napScore}%, Knowledge panel: ${knowledgePanel}, Locations: ${locationsCount}`);
-                if (score < 70) {
-                  if (napScore < 100) {
-                    steps.push(`Action: Improve NAP consistency (currently ${napScore}%)`);
-                  }
-                  if (!localSignalsData.knowledgePanelDetected) {
-                    steps.push(`Action: Work on knowledge panel detection`);
-                  }
-                }
-              } else {
-                steps.push(`Current score: ${Math.round(score)} - Using derived calculation from search performance`);
-                steps.push(`Priority: Integrate Google Business Profile API to use real local signals data`);
-                if (score < 70) {
-                  steps.push(`Action: Add LocalBusiness schema markup and ensure NAP consistency`);
-                }
-              }
-              break;
-              
-            case 'serviceArea':
-              if (hasLocalSignals && localSignalsData) {
-                const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
-                const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
-                steps.push(`Current score: ${Math.round(score)} - Using real Business Profile data`);
-                steps.push(`Data: Service areas: ${serviceAreasCount}, NAP consistency: ${napScore}%`);
-                if (score < 70) {
-                  if (serviceAreasCount < 5) {
-                    steps.push(`Action: Add more service areas (currently ${serviceAreasCount}, target: 5+)`);
-                  }
-                  if (napScore < 100) {
-                    steps.push(`Action: Improve NAP consistency (currently ${napScore}%)`);
-                  }
-                }
-              } else {
-                steps.push(`Current score: ${Math.round(score)} - Using derived calculation from Local Entity`);
-                steps.push(`Priority: Integrate Google Business Profile API to get real service area data`);
-                if (score < 70) {
-                  steps.push(`Action: Add ServiceArea schema and create location-specific pages`);
-                }
-              }
-              break;
-          }
-          
-          if (steps.length === 0) {
-            if (score >= 70) {
-              steps.push('Maintain current performance');
-              steps.push('Monitor for any score drops');
-            } else if (score >= 40) {
-              steps.push('Focus on improving this pillar');
-              steps.push('Review specific metrics above');
-            } else {
-              steps.push('Critical: Immediate action required');
-              steps.push('Review all data sources and implement fixes');
-            }
-          }
-          
-          nextSteps[key] = steps;
-        });
-        
-        return nextSteps;
-      };
-      
-      const nextSteps = getNextStepsForPDF(scores, searchData, schemaAudit);
-
-      return `
-        <!DOCTYPE html>
-        <html>
-        <head>
-          <meta charset="UTF-8">
-          <style>
-            body {
-              font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
-              color: #333;
-              line-height: 1.6;
-              margin: 0;
-              padding: 0;
-            }
-            .report-header {
-              text-align: center;
-              border-bottom: 3px solid #f97316;
-              padding-bottom: 20px;
-              margin-bottom: 30px;
-            }
-            .report-header h1 {
-              color: #f97316;
-              margin: 0 0 10px 0;
-              font-size: 28px;
-            }
-            .report-header .meta {
-              color: #666;
-              font-size: 14px;
-            }
-            .section {
-              margin-bottom: 40px;
-              page-break-inside: avoid;
-            }
-            .section-title {
-              background: #f97316;
-              color: white;
-              padding: 12px 20px;
-              margin: 0 0 20px 0;
-              font-size: 20px;
-              font-weight: bold;
-              border-radius: 4px;
-            }
-            .pillar-grid {
-              display: grid;
-              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
-              gap: 15px;
-              margin-bottom: 30px;
-            }
-            .pillar-card {
-              border: 2px solid #e2e8f0;
-              border-radius: 8px;
-              padding: 15px;
-              background: #f8f9fa;
-            }
-            .pillar-card h3 {
-              margin: 0 0 10px 0;
-              font-size: 16px;
-              color: #333;
-            }
-            .pillar-score {
-              font-size: 36px;
-              font-weight: bold;
-              margin: 10px 0;
-            }
-            .rag-indicator {
-              display: inline-block;
-              width: 12px;
-              height: 12px;
-              border-radius: 50%;
-              margin-right: 5px;
-            }
-            .metrics-grid {
-              display: grid;
-              grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
-              gap: 15px;
-              margin-bottom: 30px;
-            }
-            .metric-card {
-              border: 1px solid #e2e8f0;
-              border-radius: 6px;
-              padding: 15px;
-              text-align: center;
-              background: #ffffff;
-            }
-            .metric-value {
-              font-size: 28px;
-              font-weight: bold;
-              color: #2563eb;
-              margin: 10px 0;
-            }
-            .metric-label {
-              color: #666;
-              font-size: 14px;
-            }
-            .chart-container {
-              text-align: center;
-              margin: 30px 0;
-              page-break-inside: avoid;
-            }
-            .chart-container img {
-              max-width: 100%;
-              height: auto;
-              border: 1px solid #e2e8f0;
-              border-radius: 4px;
-            }
-            .chart-title {
-              font-size: 18px;
-              font-weight: bold;
-              margin-bottom: 15px;
-              color: #333;
-            }
-            .definition-box {
-              background: #f0f9ff;
-              border-left: 4px solid #2563eb;
-              padding: 15px;
-              margin: 20px 0;
-              border-radius: 4px;
-            }
-            .definition-box h4 {
-              margin: 0 0 10px 0;
-              color: #2563eb;
-            }
-            .next-steps {
-              background: #fff7ed;
-              border-left: 4px solid #f59e0b;
-              padding: 15px;
-              margin: 20px 0;
-              border-radius: 4px;
-            }
-            .next-steps h4 {
-              margin: 0 0 10px 0;
-              color: #f59e0b;
-            }
-            .next-steps ul {
-              margin: 10px 0;
-              padding-left: 20px;
-            }
-            .next-steps li {
-              margin: 8px 0;
-            }
-            table {
-              width: 100%;
-              border-collapse: collapse;
-              margin: 20px 0;
-            }
-            table th, table td {
-              border: 1px solid #e2e8f0;
-              padding: 10px;
-              text-align: left;
-            }
-            table th {
-              background: #f8f9fa;
-              font-weight: bold;
-            }
-            .footer {
-              margin-top: 50px;
-              padding-top: 20px;
-              border-top: 1px solid #e2e8f0;
-              text-align: center;
-              color: #666;
-              font-size: 12px;
-            }
-          </style>
-        </head>
-        <body>
-          <div class="report-header">
-            <h1>GAIO Audit Report</h1>
-            <div class="meta">
-              <strong>Property:</strong> ${propertyUrl}<br>
-              <strong>Date Range:</strong> Last ${dateRange} days<br>
-              <strong>Audit Date:</strong> ${new Date(auditDate).toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' })}
-            </div>
-          </div>
-
-          <!-- Executive Summary -->
-          <div class="section">
-            <div class="section-title">Executive Summary</div>
-            <div style="margin-bottom: 20px;">
-              <p><strong>Overall Snippet Readiness:</strong> <span style="font-size: 24px; font-weight: bold; color: ${getRAGStatus(snippetReadiness).color};">${snippetReadiness}%</span> 
-              <span class="rag-indicator" style="background-color: ${getRAGStatus(snippetReadiness).color};"></span>${getRAGStatus(snippetReadiness).text}</p>
-              <p>The Snippet Readiness score indicates how likely your content is to appear in featured snippets and AI answers. It combines Content/Schema (40%), Visibility (35%), and Authority (25%).</p>
-            </div>
-          </div>
-
-          <!-- Pillar Scores -->
-          <div class="section">
-            <div class="section-title">Pillar Scores Overview</div>
-            <div class="pillar-grid">
-              ${Object.entries(scores).map(([key, score]) => {
-                const rag = getRAGStatus(score);
-                const pillarNames = {
-                  localEntity: 'Local Entity',
-                  serviceArea: 'Service Area',
-                  authority: 'Authority',
-                  visibility: 'Visibility',
-                  contentSchema: 'Content/Schema'
-                };
-                return `
-                  <div class="pillar-card">
-                    <h3>${pillarNames[key] || key}</h3>
-                    <div class="pillar-score" style="color: ${rag.color};">${score}%</div>
-                    <div>
-                      <span class="rag-indicator" style="background-color: ${rag.color};"></span>
-                      <strong>${rag.label}</strong> - ${rag.text}
-                    </div>
-                  </div>
-                `;
-              }).join('')}
-            </div>
-          </div>
-
-          <!-- Charts -->
-          <div class="section">
-            <div class="section-title">Visual Analytics</div>
-            
-            <div class="chart-container">
-              <div class="chart-title">Pillar Scores Radar Chart</div>
-              ${chartImages.radarChart ? '<img src="' + chartImages.radarChart + '" alt="Radar Chart" style="max-width: 600px; margin: 0 auto; display: block;">' : '<p style="color: #999;">Chart not available</p>'}
-              <p style="color: #666; font-size: 14px; margin-top: 10px;">Radar chart showing current performance across all five pillars. The larger the area, the stronger your overall entity recognition.</p>
-            </div>
-            
-            <div class="chart-container">
-              <div class="chart-title">Performance Trends</div>
-              ${chartImages.trendChart ? '<img src="' + chartImages.trendChart + '" alt="Trend Chart" style="max-width: 100%; margin: 0 auto; display: block;">' : '<p style="color: #999;">Chart not available</p>'}
-              <p style="color: #666; font-size: 14px; margin-top: 10px;">Historical performance trends showing clicks, impressions, CTR, position, and Content/Schema scores over the selected date range.</p>
-            </div>
-            
-            <div class="chart-container">
-              <div class="chart-title">Snippet Readiness Gauge</div>
-              ${chartImages.snippetReadinessChart ? '<img src="' + chartImages.snippetReadinessChart + '" alt="Snippet Readiness Chart" style="max-width: 500px; margin: 0 auto; display: block;">' : '<p style="color: #999;">Chart not available</p>'}
-              <p style="color: #666; font-size: 14px; margin-top: 10px;">Nested doughnut chart showing weighted breakdown of snippet readiness components with actual performance scores.</p>
-            </div>
-          </div>
-
-          <!-- Metrics -->
-          <div class="section">
-            <div class="section-title">Key Metrics</div>
-            <div class="metrics-grid">
-              <div class="metric-card">
-                <div class="metric-value">${(searchData.totalClicks || 0).toLocaleString()}</div>
-                <div class="metric-label">Total Clicks</div>
-              </div>
-              <div class="metric-card">
-                <div class="metric-value">${(searchData.totalImpressions || 0).toLocaleString()}</div>
-                <div class="metric-label">Total Impressions</div>
-              </div>
-              <div class="metric-card">
-                <div class="metric-value">${(searchData.ctr || 0).toFixed(1)}%</div>
-                <div class="metric-label">Average CTR</div>
-              </div>
-              <div class="metric-card">
-                <div class="metric-value">${(searchData.averagePosition || 0).toFixed(1)}</div>
-                <div class="metric-label">Average Position</div>
-              </div>
-            </div>
-          </div>
-
-          <!-- Pillar Definitions -->
-          <div class="section">
-            <div class="section-title">Pillar Definitions & Current Status</div>
-            ${Object.entries(scores).map(([key, score]) => {
-              const rag = getRAGStatus(score);
-              const pillarNames = {
-                localEntity: 'Local Entity',
-                serviceArea: 'Service Area',
-                authority: 'Authority',
-                visibility: 'Visibility',
-                contentSchema: 'Content/Schema'
-              };
-              // Build definitions dynamically based on whether we have real Business Profile data
-              let localEntityDef, serviceAreaDef;
-              if (hasLocalSignals && localSignalsData) {
-                const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
-                const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
-                const locationsCount = localSignalsData.locations?.length || 0;
-                localEntityDef = `Measures how well your business is recognized as a local entity. Uses real data from Google Business Profile API: NAP consistency (${napScore}%), knowledge panel (${localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected'}), locations (${locationsCount}).`;
-                serviceAreaDef = `Assesses your service area coverage and geographic relevance. Uses real data from Google Business Profile API: ${serviceAreasCount} service areas, NAP consistency (${napScore}%).`;
-              } else {
-                localEntityDef = 'Measures how well your business is recognized as a local entity. Based on LocalBusiness schema presence, NAP consistency, and knowledge panel detection. Currently uses derived calculations from GSC data.';
-                serviceAreaDef = 'Assesses your service area coverage and geographic relevance. Derived from Local Entity score. Will use real service area data when Google Business Profile API is integrated.';
-              }
-              
-              const definitions = {
-                localEntity: localEntityDef,
-                serviceArea: serviceAreaDef,
-                authority: 'Evaluates your domain authority and trust signals. Calculated from four components: Behaviour Score (40%): CTR for ranking queries + top-10 CTR. Ranking Score (20%): Average position + top-10 impression share. Backlink Score (20%): Referring domains + quality from CSV upload. Review Score (20%): Combined ratings and counts from Google Business Profile + on-site/Trustpilot reviews.',
-                visibility: 'Tracks your search visibility and ranking performance. Based on average position from Google Search Console (1 = best, 40 = worst). Score ranges from 10 to 100.',
-                contentSchema: 'Measures schema markup quality and completeness. Weighted calculation: Foundation Schemas (30%), Rich Results (35%), Coverage (20%), Diversity (15%).'
-              };
-              return `
-                <div class="definition-box">
-                  <h4>${pillarNames[key] || key} - ${score}% 
-                    <span class="rag-indicator" style="background-color: ${rag.color};"></span>${rag.label}
-                  </h4>
-                  <p>${definitions[key] || 'No definition available.'}</p>
-                </div>
-              `;
-            }).join('')}
-          </div>
-
-          <!-- Next Steps -->
-          <div class="section">
-            <div class="section-title">Recommended Next Steps</div>
-            ${Object.entries(nextSteps).map(([pillar, steps]) => {
-              if (!steps || steps.length === 0) return '';
-              const pillarNames = {
-                localEntity: 'Local Entity',
-                serviceArea: 'Service Area',
-                authority: 'Authority',
-                visibility: 'Visibility',
-                contentSchema: 'Content/Schema'
-              };
-              return `
-                <div class="next-steps">
-                  <h4>${pillarNames[pillar] || pillar}</h4>
-                  <ul>
-                    ${steps.map(step => `<li>${step}</li>`).join('')}
-                  </ul>
-                </div>
-              `;
-            }).join('')}
-          </div>
-
-          <!-- Schema Audit Summary -->
-          ${schemaAudit.data ? `
-          <div class="section">
-            <div class="section-title">Schema Audit Summary</div>
-            <div class="metrics-grid">
-              <div class="metric-card">
-                <div class="metric-value">${schemaAudit.data.totalPages || 0}</div>
-                <div class="metric-label">Total Pages Scanned</div>
-              </div>
-              <div class="metric-card">
-                <div class="metric-value">${schemaAudit.data.pagesWithSchema || 0}</div>
-                <div class="metric-label">Pages With Schema</div>
-              </div>
-              <div class="metric-card">
-                <div class="metric-value">${(schemaAudit.data.coverage || 0).toFixed(1)}%</div>
-                <div class="metric-label">Schema Coverage</div>
-              </div>
-              <div class="metric-card">
-                <div class="metric-value">${(schemaAudit.data.schemaTypes || []).length}</div>
-                <div class="metric-label">Schema Types Found</div>
-              </div>
-            </div>
-            ${schemaAudit.data.missingSchemaPages && schemaAudit.data.missingSchemaPages.length > 0 ? `
-              <div style="margin-top: 20px;">
-                <h4>Pages Missing Schema (${schemaAudit.data.missingSchemaPages.length}):</h4>
-                <ul style="font-size: 12px; max-height: 200px; overflow-y: auto;">
-                  ${schemaAudit.data.missingSchemaPages.slice(0, 20).map(url => `<li>${url}</li>`).join('')}
-                  ${schemaAudit.data.missingSchemaPages.length > 20 ? `<li><em>... and ${schemaAudit.data.missingSchemaPages.length - 20} more</em></li>` : ''}
-                </ul>
-              </div>
-            ` : ''}
-          </div>
-          ` : ''}
-
-          <!-- Top Queries -->
-          ${searchData.topQueries && searchData.topQueries.length > 0 ? `
-          <div class="section">
-            <div class="section-title">Top Queries</div>
-            <table>
-              <thead>
-                <tr>
-                  <th>Query</th>
-                  <th>Clicks</th>
-                  <th>Impressions</th>
-                  <th>CTR</th>
-                  <th>Position</th>
-                </tr>
-              </thead>
-              <tbody>
-                ${searchData.topQueries.slice(0, 20).map(query => `
-                  <tr>
-                    <td>${query.query || 'N/A'}</td>
-                    <td>${(query.clicks || 0).toLocaleString()}</td>
-                    <td>${(query.impressions || 0).toLocaleString()}</td>
-                    <td>${(query.ctr || 0).toFixed(1)}%</td>
-                    <td>${(query.position || 0).toFixed(1)}</td>
-                  </tr>
-                `).join('')}
-              </tbody>
-            </table>
-          </div>
-          ` : ''}
-
-          <div class="footer">
-            <p>Generated by AIO Audit Dashboard on ${new Date().toLocaleString('en-GB')}</p>
-            <p>This report contains data from Google Search Console API and schema audit results.</p>
-          </div>
-        </body>
-        </html>
-      `;
-    }
-    // ======================
-    // Ranking & AI: Progress Modal Functions
-    // ======================
-    const RankingAiProgressModal = {
-      steps: [
-        { id: 'init', label: 'Initializing', narrative: 'Preparing to fetch ranking and AI data...' },
-        { id: 'serp', label: 'Fetching SERP Rankings', narrative: 'Retrieving search engine rankings and search volume data...' },
-        { id: 'ai', label: 'Fetching AI Overview Data', narrative: 'Checking AI Overview presence and citations...' },
-        { id: 'process', label: 'Processing Results', narrative: 'Combining data and calculating metrics...' },
-        { id: 'save', label: 'Saving Data', narrative: 'Storing results to database...' },
-        { id: 'complete', label: 'Complete', narrative: 'Ranking & AI check completed successfully!' }
-      ],
-      
-      show() {
-        const modal = document.getElementById('rankingAiProgressModal');
-        if (modal) {
-          modal.style.display = 'block';
-          this.updateProgress(0);
-          this.renderSteps();
-          
-          // Hide summary section when starting new scan
-          const summaryEl = document.getElementById('rankingAiSummary');
-          if (summaryEl) {
-            summaryEl.style.display = 'none';
-          }
-          
-          // Disable close button during processing
-          const closeBtn = document.getElementById('rankingAiProgressClose');
-          if (closeBtn) {
-            closeBtn.disabled = true;
-            closeBtn.style.opacity = '0.5';
-            closeBtn.onclick = null;
-          }
-        }
-      },
-      
-      hide() {
-        const modal = document.getElementById('rankingAiProgressModal');
-        if (modal) {
-          modal.style.display = 'none';
-        }
-      },
-      
-      updateProgress(percent, stepIndex = null) {
-        const fill = document.getElementById('rankingAiProgressFill');
-        const text = document.getElementById('rankingAiProgressText');
-        if (fill) fill.style.width = `${Math.min(100, Math.max(0, percent))}%`;
-        if (text) text.textContent = `${Math.round(percent)}%`;
-        
-        if (stepIndex !== null) {
-          this.setActiveStep(stepIndex);
-        }
-      },
-      
-      setActiveStep(stepIndex) {
-        const steps = document.querySelectorAll('.ranking-ai-step-item');
-        steps.forEach((step, idx) => {
-          step.classList.remove('active', 'completed', 'pending');
-          const icon = step.querySelector('.ranking-ai-step-icon');
-          if (idx < stepIndex) {
-            step.classList.add('completed');
-            if (icon) icon.textContent = '‚úì';
-          } else if (idx === stepIndex) {
-            step.classList.add('active');
-            if (icon) icon.textContent = idx + 1;
-          } else {
-            step.classList.add('pending');
-            if (icon) icon.textContent = idx + 1;
-          }
-        });
-        
-        const step = this.steps[stepIndex];
-        if (step) {
-          const currentStepEl = document.getElementById('rankingAiCurrentStep');
-          const narrativeEl = document.getElementById('rankingAiStepNarrative');
-          if (currentStepEl) currentStepEl.textContent = step.label;
-          if (narrativeEl) narrativeEl.textContent = step.narrative;
-        }
-      },
-      
-      updateCounts(text) {
-        const countsEl = document.getElementById('rankingAiStepCounts');
-        if (countsEl) countsEl.textContent = text;
-      },
-      
-      renderSteps() {
-        const listEl = document.getElementById('rankingAiStepsList');
-        if (!listEl) return;
-        
-        listEl.innerHTML = this.steps.map((step, idx) => `
-          <div class="ranking-ai-step-item pending">
-            <div class="ranking-ai-step-icon">${idx + 1}</div>
-            <div class="ranking-ai-step-label">${step.label}</div>
-          </div>
-        `).join('');
-      },
-
-      showSummary(summary) {
-        const summaryEl = document.getElementById('rankingAiSummary');
-        const summaryContentEl = document.getElementById('rankingAiSummaryContent');
-        if (!summaryEl || !summaryContentEl) return;
-
-        // Build summary HTML
-        const summaryItems = [];
-        
-        // Handle error case
-        if (summary.error) {
-          summaryItems.push(`<div style="padding: 1rem; background: #fef2f2; border-radius: 6px; border-left: 3px solid #ef4444; margin-bottom: 1rem;"><strong style="color: #ef4444;">Error:</strong><br><span style="font-size: 1rem;">${summary.errorMessage || 'Unknown error occurred'}</span></div>`);
-        }
-        
-        if (summary.totalKeywords !== undefined) {
-          summaryItems.push(`<div style="padding: 0.75rem; background: #f0f9ff; border-radius: 6px; border-left: 3px solid #0284c7;"><strong style="color: #0284c7;">Total Keywords:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.totalKeywords}</span></div>`);
-        }
-        
-        if (summary.keywordsWithRank !== undefined) {
-          summaryItems.push(`<div style="padding: 0.75rem; background: #f0fdf4; border-radius: 6px; border-left: 3px solid #10b981;"><strong style="color: #10b981;">With Rankings:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.keywordsWithRank}</span></div>`);
-        }
-        
-        if (summary.top10 !== undefined) {
-          summaryItems.push(`<div style="padding: 0.75rem; background: #fffbeb; border-radius: 6px; border-left: 3px solid #f59e0b;"><strong style="color: #f59e0b;">Top 10 Rankings:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.top10}</span></div>`);
-        }
-        
-        if (summary.top3 !== undefined) {
-          summaryItems.push(`<div style="padding: 0.75rem; background: #fef3c7; border-radius: 6px; border-left: 3px solid #fbbf24;"><strong style="color: #fbbf24;">Top 3 Rankings:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.top3}</span></div>`);
-        }
-        
-        if (summary.keywordsWithAiOverview !== undefined) {
-          summaryItems.push(`<div style="padding: 0.75rem; background: #f5f3ff; border-radius: 6px; border-left: 3px solid #8b5cf6;"><strong style="color: #8b5cf6;">AI Overview Present:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.keywordsWithAiOverview}</span></div>`);
-        }
-        
-        if (summary.keywordsWithAiCitations !== undefined) {
-          summaryItems.push(`<div style="padding: 0.75rem; background: #ede9fe; border-radius: 6px; border-left: 3px solid #a78bfa;"><strong style="color: #a78bfa;">AI Citations:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.keywordsWithAiCitations}</span></div>`);
-        }
-        
-        if (summary.avgPositionUnweighted !== null && summary.avgPositionUnweighted !== undefined) {
-          summaryItems.push(`<div style="padding: 0.75rem; background: #f0f9ff; border-radius: 6px; border-left: 3px solid #0284c7;"><strong style="color: #0284c7;">Avg Position (Unweighted):</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.avgPositionUnweighted.toFixed(1)}</span></div>`);
-        }
-        
-        if (summary.avgPositionVolumeWeighted !== null && summary.avgPositionVolumeWeighted !== undefined) {
-          summaryItems.push(`<div style="padding: 0.75rem; background: #f0f9ff; border-radius: 6px; border-left: 3px solid #0284c7;"><strong style="color: #0284c7;">Avg Position (Weighted):</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.avgPositionVolumeWeighted.toFixed(1)}</span></div>`);
-        }
-        
-        if (summary.keywordsWithVolume !== undefined) {
-          summaryItems.push(`<div style="padding: 0.75rem; background: #f0fdf4; border-radius: 6px; border-left: 3px solid #10b981;"><strong style="color: #10b981;">With Search Volume:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.keywordsWithVolume}</span></div>`);
-        }
-
-        summaryContentEl.innerHTML = summaryItems.join('');
-        summaryEl.style.display = 'block';
-      }
-    };
-    
-    // Make progress modal globally available
-    window.RankingAiProgressModal = RankingAiProgressModal;
-
-    // ======================
-    // Ranking & AI: Save data to Supabase and localStorage
-    // ======================
-    /**
-     * Save a single batch of keywords incrementally to Supabase keyword_rankings table
-     * This allows partial results to be saved even if later batches fail
-     */
-    async function saveRankingAiDataIncremental(batchRows, auditDate, propertyUrl) {
-      try {
-        if (!batchRows || batchRows.length === 0) {
-          return { success: true, saved: 0 };
-        }
-
-        // Prepare keyword rows for insertion
-        const keywordRows = batchRows.map(row => ({
-          audit_date: auditDate,
-          property_url: String(propertyUrl).trim(),
-          keyword: String(row.keyword || '').trim(),
-          best_rank_group: row.best_rank_group !== null && row.best_rank_group !== undefined ? parseInt(row.best_rank_group) : null,
-          best_rank_absolute: row.best_rank_absolute !== null && row.best_rank_absolute !== undefined ? parseInt(row.best_rank_absolute) : null,
-          best_url: row.best_url ? String(row.best_url).trim() : null,
-          best_title: row.best_title ? String(row.best_title).trim() : null,
-          search_volume: row.search_volume !== null && row.search_volume !== undefined ? parseInt(row.search_volume) : null,
-          has_ai_overview: row.has_ai_overview === true,
-          ai_total_citations: row.ai_total_citations !== null && row.ai_total_citations !== undefined ? parseInt(row.ai_total_citations) : null,
-          ai_alan_citations_count: row.ai_alan_citations_count !== null && row.ai_alan_citations_count !== undefined ? parseInt(row.ai_alan_citations_count) : null,
-          ai_alan_citations: row.ai_alan_citations ? (Array.isArray(row.ai_alan_citations) ? row.ai_alan_citations : []) : null,
-          competitor_counts: row.competitor_counts ? (typeof row.competitor_counts === 'object' ? row.competitor_counts : {}) : null,
-          serp_features: row.serp_features ? (typeof row.serp_features === 'object' ? row.serp_features : {}) : null,
-          // New boolean fields for SERP feature coverage
-          ai_overview_present_any: row.ai_overview_present_any === true || row.has_ai_overview === true,
-          local_pack_present_any: row.local_pack_present_any === true || (row.serp_features && row.serp_features.local_pack === true),
-          paa_present_any: row.paa_present_any === true || (row.serp_features && row.serp_features.people_also_ask === true),
-          featured_snippet_present_any: row.featured_snippet_present_any === true || (row.serp_features && row.serp_features.featured_snippet === true),
-          segment: row.segment ? String(row.segment).trim() : null,
-          page_type: row.pageType ? String(row.pageType).trim() : null,
-          demand_share: row.demand_share !== null && row.demand_share !== undefined ? parseFloat(row.demand_share) : null,
-          opportunity_score: row.opportunityScore !== null && row.opportunityScore !== undefined ? parseInt(row.opportunityScore) : null,
-          updated_at: new Date().toISOString()
-        }));
-
-        // Use upsert endpoint to save batch (will merge duplicates based on unique constraint)
-        const response = await fetch(apiUrl('/api/supabase/save-keyword-batch'), {
-          method: 'POST',
-          headers: { 'Content-Type': 'application/json' },
-          body: JSON.stringify({
-            keywordRows,
-            auditDate,
-            propertyUrl
-          })
-        });
-
-        if (response.ok) {
-          const responseData = await response.json();
-          debugLog(`‚úì Incremental save: ${batchRows.length} keywords saved to keyword_rankings`, 'success');
-          return { success: true, saved: batchRows.length };
-        } else {
-          const errorText = await response.text();
-          debugLog(`‚ö† Incremental save failed: ${response.status} - ${errorText}`, 'warn');
-          return { success: false, saved: 0, error: errorText };
-        }
-      } catch (err) {
-        debugLog(`‚úó Error in incremental save: ${err.message}`, 'error');
-        return { success: false, saved: 0, error: err.message };
-      }
-    }
-
-    async function saveRankingAiData(combinedRows, summary) {
-      try {
-        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
-        if (!propertyUrl) {
-          debugLog('‚ö† Cannot save Ranking & AI data: property URL not set', 'warn');
-          return;
-        }
-
-        // Save to localStorage first
-        const rankingAiData = {
-          combinedRows,
-          summary,
-          timestamp: new Date().toISOString()
-        };
-        localStorage.setItem('rankingAiData', JSON.stringify(rankingAiData));
-        debugLog('‚úì Ranking & AI data saved to localStorage', 'success');
-
-        // Save to Supabase
-        const auditDate = new Date().toISOString().split('T')[0];
-        const response = await fetch(apiUrl('/api/supabase/save-audit'), {
-          method: 'POST',
-          headers: { 'Content-Type': 'application/json' },
-          body: JSON.stringify({
-            propertyUrl,
-            auditDate,
-            rankingAiData // New field for ranking AI data
-          })
-        });
-
-        if (response.ok) {
-          const responseData = await response.json();
-          debugLog(`‚úì Ranking & AI data saved to Supabase (${combinedRows.length} keywords)`, 'success');
-          if (responseData.data) {
-            debugLog(`‚úì Supabase confirmed save: ${JSON.stringify(responseData.data).substring(0, 200)}...`, 'info');
-          }
-        } else {
-          const errorText = await response.text();
-          debugLog(`‚ö† Failed to save Ranking & AI data to Supabase: ${response.status} - ${errorText}`, 'warn');
-          console.error('[Save Ranking & AI] Full error response:', errorText);
-        }
-      } catch (err) {
-        debugLog(`‚úó Error saving Ranking & AI data: ${err.message}`, 'error');
-        console.error('Save Ranking & AI data error:', err);
-      }
-    }
-
-    // ======================
-    // Ranking & AI: Normalize summary field names (snake_case to camelCase)
-    // ======================
-    function normalizeSummaryFields(summary) {
-      if (!summary) return summary;
-      // Convert snake_case to camelCase for display compatibility
-      return {
-        totalKeywords: summary.total_keywords ?? summary.totalKeywords,
-        keywordsWithRank: summary.keywords_with_rank ?? summary.keywordsWithRank,
-        keywordsWithAiOverview: summary.keywords_with_ai_overview ?? summary.keywordsWithAiOverview,
-        keywordsWithAiCitations: summary.keywords_with_ai_citations ?? summary.keywordsWithAiCitations,
-        top10: summary.top10,
-        top3: summary.top3,
-        avgPositionUnweighted: summary.avg_position_unweighted ?? summary.avgPositionUnweighted,
-        avgPositionVolumeWeighted: summary.avg_position_volume_weighted ?? summary.avgPositionVolumeWeighted,
-        keywordsUsedForAvg: summary.keywords_used_for_avg ?? summary.keywordsUsedForAvg,
-        keywordsWithVolume: summary.keywords_with_volume ?? summary.keywordsWithVolume,
-        // v1.4: Domain Strength context (read-only)
-        domainStrength: summary.domainStrength ?? null,
-        authorityPriority: summary.authorityPriority ?? null
-      };
-    }
-
-    // ======================
-    // Ranking & AI: Domain Strength context (read-only)
-    // ======================
-    let __rankingAiAuthorityContext = null;
-    async function fetchRankingAiAuthorityContext() {
-      if (__rankingAiAuthorityContext) return __rankingAiAuthorityContext;
-      try {
-        const resp = await fetch(apiUrl('/api/ranking-ai/summary'));
-        const json = await resp.json();
-        if (!resp.ok || !json || json.status !== 'ok') {
-          __rankingAiAuthorityContext = { domainStrength: null, authorityPriority: null };
-          return __rankingAiAuthorityContext;
-        }
-        __rankingAiAuthorityContext = {
-          domainStrength: json.domainStrength || null,
-          authorityPriority: json.authorityPriority || null
-        };
-        return __rankingAiAuthorityContext;
-      } catch {
-        __rankingAiAuthorityContext = { domainStrength: null, authorityPriority: null };
-        return __rankingAiAuthorityContext;
-      }
-    }
-
-    // ======================
-    // Ranking & AI: Load data from localStorage or Supabase
-    // ======================
-    async function loadRankingAiDataFromStorage(forceCheckSupabase = false) {
-      try {
-        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
-        if (!propertyUrl) {
-          debugLog('‚ö† Cannot load Ranking & AI data: property URL not set', 'warn');
-          return null;
-        }
-
-        // Store localStorage data as fallback (in case Supabase check fails)
-        let localStorageFallback = null;
-        
-        // If forcing Supabase check, skip localStorage
-        if (!forceCheckSupabase) {
-          // Try localStorage first
-          const localData = localStorage.getItem('rankingAiData');
-          if (localData) {
-            try {
-              const parsed = JSON.parse(localData);
-              if (parsed.combinedRows && parsed.summary) {
-                debugLog('‚úì Ranking & AI data found in localStorage', 'success');
-                debugLog(`  Found ${parsed.combinedRows.length} keywords in localStorage`, 'info');
-                
-                // Re-classify pageType for all rows (fixes stale values)
-                if (typeof window.classifyUrlForRankingAi === 'function') {
-                  let reclassifiedCount = 0;
-                  parsed.combinedRows.forEach(row => {
-                    const bestUrl = row.best_url || row.bestUrl || null;
-                    if (bestUrl) {
-                      const oldPageType = row.pageType || 'Landing';
-                      const classification = window.classifyUrlForRankingAi(bestUrl, row.keyword || null);
-                      const newPageType = classification.pageType;
-                      if (newPageType !== oldPageType) {
-                        row.pageType = newPageType;
-                        if (classification.segment && classification.segment !== row.segment) {
-                          row.segment = classification.segment;
-                        }
-                        reclassifiedCount++;
-                      }
-                    }
-                  });
-                  if (reclassifiedCount > 0) {
-                    debugLog(`‚úì Re-classified pageType for ${reclassifiedCount} keywords from localStorage`, 'info');
-                  }
-                }
-                
-                // Normalize summary field names for compatibility
-                parsed.summary = normalizeSummaryFields(parsed.summary);
-                // Store as fallback before checking Supabase
-                localStorageFallback = parsed;
-                
-                // Check if localStorage data is missing search_volume (indicates stale data)
-                const keywordsMissingVolume = parsed.combinedRows.filter(r => r.search_volume == null || r.search_volume === undefined).length;
-                const hasMissingVolume = keywordsMissingVolume > 0;
-                
-                // Always check Supabase if localStorage has fewer than 10 keywords (likely stale data)
-                if (parsed.combinedRows.length < 10) {
-                  debugLog(`‚ö† LocalStorage has only ${parsed.combinedRows.length} keywords, checking Supabase for more...`, 'info');
-                  // Continue to Supabase check below
-                } else if (hasMissingVolume) {
-                  // Check Supabase if localStorage data is missing search_volume
-                  debugLog(`‚ö† LocalStorage data is missing search_volume for ${keywordsMissingVolume}/${parsed.combinedRows.length} keywords, checking Supabase...`, 'info');
-                  // Continue to Supabase check below
-                } else {
-                  // Check if data is recent (within last 24 hours) - if older, check Supabase
-                  if (parsed.timestamp) {
-                    const localTime = new Date(parsed.timestamp);
-                    const now = new Date();
-                    const hoursDiff = (now - localTime) / (1000 * 60 * 60);
-                    if (hoursDiff < 24) {
-                      return parsed;
-                    } else {
-                      debugLog(`‚ö† LocalStorage data is ${Math.round(hoursDiff)} hours old, checking Supabase for newer data...`, 'info');
-                    }
-                  } else {
-                    return parsed;
-                  }
-                }
-              }
-            } catch (e) {
-              debugLog('‚ö† Invalid Ranking & AI data in localStorage', 'warn');
-            }
-          }
-        }
-
-        // Try Supabase (either forced or as fallback)
-        debugLog(`üìä Loading Ranking & AI data from Supabase for propertyUrl: ${propertyUrl}`, 'info');
-        const response = await fetch(apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`));
-        debugLog(`üìä API fetch response status: ${response.status} ${response.statusText}`, 'info');
-        
-        if (response.ok) {
-          const json = await response.json();
-          debugLog(`üìä API response parsed: status=${json.status}`, 'info');
-          debugLog(`üìä Response has data object: ${!!json.data}`, 'info');
-          debugLog(`üìä Response has rankingAiData: ${!!json.data?.rankingAiData}`, 'info');
-          
-          if (json.status === 'ok' && json.data) {
-            if (json.data.rankingAiData) {
-              if (json.data.rankingAiData.combinedRows) {
-                const keywordCount = json.data.rankingAiData.combinedRows.length;
-                const summaryKeys = json.data.rankingAiData.summary ? Object.keys(json.data.rankingAiData.summary).join(', ') : 'none';
-                debugLog(`‚úì Ranking & AI data loaded from Supabase: ${keywordCount} keywords`, 'success');
-                debugLog(`  Summary fields: ${summaryKeys}`, 'info');
-                debugLog(`  First keyword sample: ${json.data.rankingAiData.combinedRows[0]?.keyword || 'none'}`, 'info');
-                
-                // Compute opportunity scores if missing (for older data)
-                const combinedRows = json.data.rankingAiData.combinedRows;
-                
-                // Re-classify pageType for all rows (fixes stale database values)
-                // This ensures Event/Product pages are correctly identified even if DB has old values
-                if (typeof window.classifyUrlForRankingAi === 'function') {
-                  let reclassifiedCount = 0;
-                  combinedRows.forEach(row => {
-                    const bestUrl = row.best_url || row.bestUrl || null;
-                    if (bestUrl) {
-                      const oldPageType = row.pageType || 'Landing';
-                      const classification = window.classifyUrlForRankingAi(bestUrl, row.keyword || null);
-                      const newPageType = classification.pageType;
-                      if (newPageType !== oldPageType) {
-                        row.pageType = newPageType;
-                        // Also update segment if it changed
-                        if (classification.segment && classification.segment !== row.segment) {
-                          row.segment = classification.segment;
-                        }
-                        reclassifiedCount++;
-                      }
-                    }
-                  });
-                  if (reclassifiedCount > 0) {
-                    debugLog(`‚úì Re-classified pageType for ${reclassifiedCount} keywords (fixed stale DB values)`, 'info');
-                  }
-                }
-                
-                const needsOpportunityScore = combinedRows.some(r => r.opportunityScore == null);
-                if (needsOpportunityScore) {
-                  debugLog(`‚ö† Computing opportunity scores for ${keywordCount} keywords (missing from Supabase)`, 'info');
-                  const maxDemandShare = combinedRows.reduce((max, r) => {
-                    const ds = r.demand_share ?? 0;
-                    return ds > max ? ds : max;
-                  }, 0);
-                  combinedRows.forEach(row => {
-                    if (row.opportunityScore == null) {
-                      const oppResult = computeKeywordOpportunityScore(row, maxDemandShare);
-                      row.opportunityScore = oppResult.score;
-                      row.oppDemandComponent = oppResult.demandComponent;
-                      row.oppRankComponent = oppResult.rankComponent;
-                      row.oppAiComponent = oppResult.aiComponent;
-                    }
-                  });
-                }
-                
-                // Normalize summary field names (convert snake_case to camelCase for compatibility)
-                const normalizedSummary = normalizeSummaryFields(json.data.rankingAiData.summary);
-                
-                // Also save to localStorage for faster access next time
-                localStorage.setItem('rankingAiData', JSON.stringify({
-                  combinedRows: combinedRows,
-                  summary: normalizedSummary,
-                  timestamp: new Date().toISOString()
-                }));
-                debugLog(`‚úì Saved ${keywordCount} keywords to localStorage`, 'success');
-                return { combinedRows, summary: normalizedSummary };
-              } else {
-                debugLog('‚ö† rankingAiData exists but missing combinedRows array', 'warn');
-                debugLog(`  rankingAiData keys: ${Object.keys(json.data.rankingAiData || {}).join(', ')}`, 'warn');
-              }
-            } else {
-              debugLog('‚ö† rankingAiData is null or undefined in Supabase response', 'warn');
-              debugLog(`  Available data keys: ${Object.keys(json.data || {}).join(', ')}`, 'warn');
-              if (json.data.rankingAiData === null) {
-                debugLog('  rankingAiData is explicitly null - no keyword rows found in database', 'warn');
-              }
-            }
-          } else {
-            debugLog(`‚ö† API returned error status: ${json.status}`, 'warn');
-            debugLog(`  Error message: ${json.message || 'unknown'}`, 'warn');
-            if (json.details) {
-              debugLog(`  Error details: ${typeof json.details === 'string' ? json.details : JSON.stringify(json.details)}`, 'warn');
-            }
-          }
-        } else {
-          const errorText = await response.text();
-          debugLog(`‚ö† Failed to load from Supabase: HTTP ${response.status}`, 'error');
-          debugLog(`  Error response: ${errorText.substring(0, 200)}`, 'error');
-        }
-        
-        // If Supabase check failed or returned no data, fall back to localStorage if available
-        if (localStorageFallback) {
-          debugLog(`‚úì Falling back to localStorage data (${localStorageFallback.combinedRows.length} keywords)`, 'success');
-          return localStorageFallback;
-        }
-      } catch (err) {
-        debugLog(`‚úó Error loading Ranking & AI data from storage: ${err.message}`, 'error');
-        // If error occurred but we have localStorage fallback, return it
-        if (localStorageFallback) {
-          debugLog(`‚úì Falling back to localStorage data after error (${localStorageFallback.combinedRows.length} keywords)`, 'success');
-          return localStorageFallback;
-        }
-      }
-      return null;
-    }
-
-    // ======================
-    // Ranking & AI: Fetch and combine data
-    // ======================
-    async function loadRankingAiData(force = false) {
-      debugLog('üìä loadRankingAiData called with force=' + force, 'info');
-      
-      // Get RankingAiModule from window (it should always be there)
-      const mod = window.RankingAiModule;
-      if (!mod) {
-        debugLog('‚úó RankingAiModule is not defined in window', 'error');
-        debugLog('‚úó Available window properties: ' + Object.keys(window).filter(k => k.includes('Ranking') || k.includes('AI')).join(', '), 'error');
-        throw new Error('RankingAiModule is not defined. Please refresh the page.');
-      }
-      
-      debugLog('‚úì RankingAiModule found', 'success');
-      debugLog('‚úì RankingAiModule has TRACKED_KEYWORDS: ' + (mod.TRACKED_KEYWORDS ? mod.TRACKED_KEYWORDS.length + ' keywords' : 'missing'), 'success');
-      const { hasLoadedOnce, isLoading } = mod.state();
-
-      debugLog(`üìä State check: hasLoadedOnce=${hasLoadedOnce}, isLoading=${isLoading}, force=${force}`, 'info');
-
-      if (isLoading) {
-        debugLog('‚ö† Already loading, skipping', 'warn');
-        return;
-      }
-
-      // If not forcing, try to load from storage first
-      // But if force=false and hasLoadedOnce=true, still check Supabase for newer data
-      if (!force) {
-        const storedData = await loadRankingAiDataFromStorage(hasLoadedOnce);
-        debugLog(`üìä loadRankingAiDataFromStorage returned: ${storedData ? 'data found' : 'null'}`, 'info');
-        if (storedData) {
-          debugLog(`üìä Stored data has combinedRows: ${!!storedData.combinedRows}, count: ${storedData.combinedRows?.length || 0}`, 'info');
-          debugLog(`üìä Stored data has summary: ${!!storedData.summary}`, 'info');
-        }
-        
-        if (storedData && storedData.combinedRows && storedData.summary) {
-          debugLog(`‚úì Setting data in RankingAiModule: ${storedData.combinedRows.length} keywords`, 'success');
-          // Normalize summary field names before setting
-          const normalizedSummary = normalizeSummaryFields(storedData.summary);
-          mod.setData(storedData.combinedRows, normalizedSummary);
-          mod.setLoadedOnce(true);
-          debugLog(`‚úì Calling renderRankingAiTab()`, 'info');
-          renderRankingAiTab();
-          const lastRunEl = document.getElementById("ranking-ai-last-run");
-          if (lastRunEl && storedData.timestamp) {
-            const date = new Date(storedData.timestamp);
-            // Format in GMT/UTC: "DD MMM YYYY, HH:MM:SS GMT"
-            const day = String(date.getUTCDate()).padStart(2, '0');
-            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
-            const month = monthNames[date.getUTCMonth()];
-            const year = date.getUTCFullYear();
-            const hours = String(date.getUTCHours()).padStart(2, '0');
-            const minutes = String(date.getUTCMinutes()).padStart(2, '0');
-            const seconds = String(date.getUTCSeconds()).padStart(2, '0');
-            const formatted = `${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
-            lastRunEl.textContent = `Last run: ${formatted}`;
-            debugLog(`‚úì Updated last run timestamp: ${formatted}`, 'info');
-          }
-          debugLog(`‚úì Ranking & AI data loaded from storage (${storedData.combinedRows.length} keywords)`, 'success');
-          return;
-        } else {
-          debugLog(`‚ö† Stored data incomplete or missing`, 'warn');
-          if (storedData) {
-            debugLog(`  Missing combinedRows: ${!storedData.combinedRows}`, 'warn');
-            debugLog(`  Missing summary: ${!storedData.summary}`, 'warn');
-          }
-        }
-      }
-      
-      if (hasLoadedOnce && !force) {
-        debugLog('‚ö† Already loaded once and force=false, skipping', 'warn');
-        return;
-      }
-
-      debugLog('üìä Starting data fetch from APIs...', 'info');
-      mod.setLoading(true);
-      const refreshBtn = document.getElementById("ranking-ai-refresh");
-      if (refreshBtn) {
-        refreshBtn.disabled = true;
-        refreshBtn.textContent = "Loading‚Ä¶";
-      }
-
-      // Show progress modal
-      RankingAiProgressModal.show();
-      RankingAiProgressModal.updateProgress(5, 0); // Initialize step
-      RankingAiProgressModal.updateCounts('');
-
-      // Declare variables outside try block for catch block access
-      let allSerpResults = [];
-      let keywords = [];
-      let scanAborted = false; // Flag to track if scan should be aborted
-
-      // Set up abort handler
-      const stopBtn = document.getElementById('rankingAiProgressStop');
-      if (stopBtn) {
-        stopBtn.onclick = () => {
-          scanAborted = true;
-          stopBtn.disabled = true;
-          stopBtn.textContent = 'Stopping...';
-          debugLog('‚ö†Ô∏è Scan abort requested by user', 'warn');
-          RankingAiProgressModal.updateCounts('‚ö†Ô∏è Scan abort requested...');
-        };
-      }
-
-      try {
-        // Load keywords from database instead of hardcoded list
-        let keywordsFromDb = [];
-        try {
-          const keywordsResp = await fetch(apiUrl('/api/keywords/get'));
-          if (keywordsResp.ok) {
-            const keywordsData = await keywordsResp.json();
-            if (keywordsData.status === 'ok' && Array.isArray(keywordsData.keywords) && keywordsData.keywords.length > 0) {
-              keywordsFromDb = keywordsData.keywords;
-              debugLog(`‚úì Loaded ${keywordsFromDb.length} keywords from database`, 'success');
-            }
-          }
-        } catch (err) {
-          debugLog(`‚ö†Ô∏è Failed to load keywords from database: ${err.message}. Falling back to hardcoded list.`, 'warn');
-        }
-        
-        // Use database keywords if available, otherwise fall back to hardcoded list
-        // Filter out empty strings and ensure all keywords are valid
-        const rawKeywords = keywordsFromDb.length > 0 ? keywordsFromDb : mod.TRACKED_KEYWORDS;
-        keywords = rawKeywords
-          .filter(kw => kw && typeof kw === 'string' && kw.trim().length > 0)
-          .map(kw => kw.trim());
-        
-        const BATCH_SIZE = 20; // Match API limit
-
-        // Show keyword count BEFORE starting scan
-        const keywordCountEl = document.getElementById('rankingAiKeywordCount');
-        const keywordCountValueEl = document.getElementById('rankingAiKeywordCountValue');
-        if (keywordCountEl && keywordCountValueEl) {
-          keywordCountValueEl.textContent = `${keywords.length} keyword${keywords.length !== 1 ? 's' : ''}`;
-          keywordCountEl.style.display = 'block';
-          RankingAiProgressModal.updateCounts(`Ready to scan ${keywords.length} keywords. Click "Start Scan" to begin.`);
-        }
-
-        // Wait for user confirmation before starting (show count for 2 seconds, then auto-start)
-        await new Promise(resolve => setTimeout(resolve, 2000));
-        
-        // Check if aborted during wait
-        if (scanAborted) {
-          throw new Error('Scan aborted by user');
-        }
-
-        // Hide keyword count and show stop button
-        if (keywordCountEl) keywordCountEl.style.display = 'none';
-        if (stopBtn) {
-          stopBtn.style.display = 'block';
-          stopBtn.disabled = false;
-        }
-
-        debugLog(`üìä Fetching ranking & AI data for ${keywords.length} keywords`, 'info');
-        debugLog(`üìä Keywords: ${keywords.slice(0, 5).join(', ')}${keywords.length > 5 ? '... (+' + (keywords.length - 5) + ' more)' : ''}`, 'info');
-        debugLog(`üìä SERP endpoint: ${mod.SERP_RANK_ENDPOINT}`, 'info');
-        debugLog(`üìä AI endpoint: ${mod.AI_MODE_ENDPOINT}`, 'info');
-
-        // Step 1: Fetch SERP Rankings (batched if needed) with incremental saving
-        RankingAiProgressModal.updateProgress(15, 1);
-        RankingAiProgressModal.updateCounts(`Processing ${keywords.length} keywords...`);
-        RankingAiProgressModal.setActiveStep(1);
-        
-        debugLog('üìä Starting SERP fetch with incremental saving...', 'info');
-        
-        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
-        const auditDate = new Date().toISOString().split('T')[0];
-        
-        // Batch keywords if needed
-        allSerpResults = [];
-        const batches = [];
-        for (let i = 0; i < keywords.length; i += BATCH_SIZE) {
-          batches.push(keywords.slice(i, i + BATCH_SIZE));
-        }
-        
-        debugLog(`üìä Processing ${batches.length} batch(es) of keywords`, 'info');
-        
-        // Accumulate combined rows for final summary calculation
-        let allCombinedRows = [];
-        
-        for (let batchIdx = 0; batchIdx < batches.length; batchIdx++) {
-          // Check if scan was aborted
-          if (scanAborted) {
-            throw new Error('Scan aborted by user');
-          }
-          
-          const batch = batches[batchIdx];
-          const queryParam = encodeURIComponent(batch.join(","));
-          const progressPercent = 15 + Math.floor((batchIdx / batches.length) * 35);
-          
-          RankingAiProgressModal.updateProgress(progressPercent, 1);
-          RankingAiProgressModal.updateCounts(`Processing batch ${batchIdx + 1}/${batches.length} (${batch.length} keywords)...`);
-          
-          debugLog(`üìä Fetching batch ${batchIdx + 1}/${batches.length} (${batch.length} keywords)`, 'info');
-          
-          try {
-            const serpRes = await fetch(`${mod.SERP_RANK_ENDPOINT}?keywords=${queryParam}`);
-            debugLog(`üìä SERP response status for batch ${batchIdx + 1}: ${serpRes.status}`, 'info');
-            
-            if (!serpRes.ok) {
-              const errorText = await serpRes.text();
-              debugLog(`‚úó SERP request failed for batch ${batchIdx + 1}: ${serpRes.status} - ${errorText}`, 'error');
-              
-              // If it's a timeout or server error, show warning but continue with partial results
-              if (serpRes.status === 504 || serpRes.status === 500) {
-                debugLog(`‚ö†Ô∏è Batch ${batchIdx + 1} timed out or errored, continuing with remaining batches...`, 'warn');
-                RankingAiProgressModal.updateCounts(`‚ö†Ô∏è Batch ${batchIdx + 1} failed (${serpRes.status}), continuing...`);
-                // Add error results for this batch
-                batch.forEach(kw => {
-                  allSerpResults.push({
-                    keyword: kw,
-                    best_rank_group: null,
-                    best_rank_absolute: null,
-                    best_url: null,
-                    best_title: null,
-                    has_ai_overview: false,
-                    serp_features: { local_pack: false, featured_snippet: false, people_also_ask: false },
-                    ai_overview_present_any: false,
-                    local_pack_present_any: false,
-                    paa_present_any: false,
-                    featured_snippet_present_any: false,
-                    search_volume: null,
-                    error: `Batch request failed: ${serpRes.status}`
-                  });
-                });
-                continue;
-              } else {
-                RankingAiProgressModal.updateCounts(`Error: ${serpRes.status}`);
-                throw new Error(`SERP rank request failed: ${serpRes.status} - ${errorText}`);
-              }
-            }
-            
-            const serpJson = await serpRes.json();
-            const batchResults = serpJson.per_keyword || [];
-            allSerpResults.push(...batchResults);
-            
-            debugLog(`‚úì Batch ${batchIdx + 1} completed: ${batchResults.length} results`, 'success');
-            
-            // Save this batch incrementally (without AI data for now - will update later)
-            // Create minimal combined rows for this batch
-            const batchCombinedRows = batchResults.map(row => {
-              const bestUrl = row.best_url || null;
-              let classification = { segment: "Education", pageType: "Landing" };
-              if (typeof window.classifyUrlForRankingAi === 'function') {
-                classification = window.classifyUrlForRankingAi(bestUrl || '', row.keyword);
-              }
-              
-              return {
-                keyword: row.keyword,
-                segment: classification.segment,
-                pageType: classification.pageType,
-                best_rank_group: row.best_rank_group,
-                best_rank_absolute: row.best_rank_absolute,
-                best_url: bestUrl,
-                best_title: row.best_title || "",
-                // Use SERP response's has_ai_overview (from DataForSEO) - AI fetch will add citation details later
-                has_ai_overview: !!(row.has_ai_overview),
-                ai_total_citations: 0,
-                ai_alan_citations_count: 0,
-                ai_alan_citations: [],
-                ai_sample_citations: [],
-                serp_features: row.serp_features || {
-                  has_ai_overview: false,
-                  has_local_pack: false,
-                  has_featured_snippet: false,
-                  has_people_also_ask: false
-                },
-                // New boolean fields for SERP feature coverage (from SERP API response)
-                ai_overview_present_any: row.ai_overview_present_any === true || row.has_ai_overview === true,
-                local_pack_present_any: row.local_pack_present_any === true || (row.serp_features && row.serp_features.local_pack === true),
-                paa_present_any: row.paa_present_any === true || (row.serp_features && row.serp_features.people_also_ask === true),
-                featured_snippet_present_any: row.featured_snippet_present_any === true || (row.serp_features && row.serp_features.featured_snippet === true),
-                competitor_counts: {},
-                search_volume: row.search_volume ?? null,
-                demand_share: 0 // Will be recalculated after all batches
-              };
-            });
-            
-            // Save batch incrementally
-            if (propertyUrl) {
-              const saveResult = await saveRankingAiDataIncremental(batchCombinedRows, auditDate, propertyUrl);
-              if (saveResult.success) {
-                debugLog(`‚úì Batch ${batchIdx + 1} saved incrementally: ${saveResult.saved} keywords`, 'success');
-                RankingAiProgressModal.updateCounts(`‚úì Batch ${batchIdx + 1} saved (${saveResult.saved} keywords)`);
-              } else {
-                debugLog(`‚ö† Batch ${batchIdx + 1} incremental save failed: ${saveResult.error}`, 'warn');
-              }
-            }
-            
-            allCombinedRows.push(...batchCombinedRows);
-          } catch (batchErr) {
-            debugLog(`‚úó Error processing batch ${batchIdx + 1}: ${batchErr.message}`, 'error');
-            
-            // If it's a timeout, continue with remaining batches
-            if (batchErr.message.includes('timeout') || batchErr.message.includes('504')) {
-              debugLog(`‚ö†Ô∏è Batch ${batchIdx + 1} timed out, continuing with remaining batches...`, 'warn');
-              RankingAiProgressModal.updateCounts(`‚ö†Ô∏è Batch ${batchIdx + 1} timed out, continuing...`);
-              // Add error results for this batch
-              batch.forEach(kw => {
-                allSerpResults.push({
-                  keyword: kw,
-                  best_rank_group: null,
-                  best_rank_absolute: null,
-                  best_url: null,
-                  best_title: null,
-                  has_ai_overview: false,
-                  serp_features: { local_pack: false, featured_snippet: false, people_also_ask: false },
-                  ai_overview_present_any: false,
-                  local_pack_present_any: false,
-                  paa_present_any: false,
-                  featured_snippet_present_any: false,
-                  search_volume: null,
-                  error: `Batch request timed out`
-                });
-              });
-              continue;
-            } else {
-              throw batchErr;
-            }
-          }
-        }
-        
-        RankingAiProgressModal.updateProgress(50, 1);
-        RankingAiProgressModal.updateCounts(`‚úì Retrieved SERP data for ${allSerpResults.length}/${keywords.length} keywords (saved incrementally)`);
-        
-        // Step 2: Fetch AI Overview Data (batched to avoid server timeout)
-        RankingAiProgressModal.updateProgress(55, 2);
-        RankingAiProgressModal.setActiveStep(2);
-        RankingAiProgressModal.updateCounts(`Checking AI Overview presence and citations...`);
-        
-        debugLog('üìä Starting AI fetch (batched)...', 'info');
-        let aiRows = [];
-        let aiFetchError = null;
-        
-        try {
-          // Batch AI requests to avoid Vercel 300s timeout
-          // Process 10 keywords per batch (each API call takes ~5s, so 10 keywords = ~50s per batch)
-          const AI_BATCH_SIZE = 10;
-          const aiBatches = [];
-          for (let i = 0; i < keywords.length; i += AI_BATCH_SIZE) {
-            aiBatches.push(keywords.slice(i, i + AI_BATCH_SIZE));
-          }
-          
-          debugLog(`üìä Processing AI data in ${aiBatches.length} batches of up to ${AI_BATCH_SIZE} keywords each`, 'info');
-          
-          // Process batches sequentially to avoid overwhelming the API
-          for (let batchIdx = 0; batchIdx < aiBatches.length; batchIdx++) {
-            // Check if scan was aborted
-            if (scanAborted) {
-              throw new Error('Scan aborted by user');
-            }
-            
-            const batch = aiBatches[batchIdx];
-            const batchProgress = 55 + Math.floor((batchIdx / aiBatches.length) * 20); // 55-75% progress
-            
-            RankingAiProgressModal.updateProgress(batchProgress, 2);
-            RankingAiProgressModal.updateCounts(`Fetching AI data: batch ${batchIdx + 1}/${aiBatches.length} (${batch.length} keywords)...`);
-            
-            debugLog(`üìä AI batch ${batchIdx + 1}/${aiBatches.length}: ${batch.length} keywords`, 'info');
-            
-            try {
-              // Timeout per batch: 90 seconds (should be enough for 10 keywords)
-              const aiFetchPromise = fetch(mod.AI_MODE_ENDPOINT, {
-                method: 'POST',
-                headers: {
-                  'Content-Type': 'application/json'
-                },
-                body: JSON.stringify({ queries: batch })
-              });
-              
-              // Increase timeout to 300 seconds (5 minutes) to match Vercel serverless function timeout
-              const timeoutPromise = new Promise((_, reject) => 
-                setTimeout(() => reject(new Error(`AI batch ${batchIdx + 1} timeout after 300 seconds`)), 300000)
-              );
-              
-              const aiRes = await Promise.race([aiFetchPromise, timeoutPromise]);
-              debugLog(`üìä AI batch ${batchIdx + 1} response status: ${aiRes.status}`, 'info');
-
-              if (!aiRes.ok) {
-                const errorText = await aiRes.text();
-                debugLog(`‚úó AI batch ${batchIdx + 1} failed: ${aiRes.status} - ${errorText}`, 'error');
-                // Add empty results for this batch
-                batch.forEach(keyword => {
-                  aiRows.push({
-                    query: keyword,
-                    has_ai_overview: false,
-                    total_citations: 0,
-                    alanranger_citations_count: 0,
-                    alanranger_citations: [],
-                    sample_citations: [],
-                    error: `Batch request failed: ${aiRes.status}`
-                  });
-                });
-              } else {
-                const aiJson = await aiRes.json();
-                const batchResults = aiJson.per_query || [];
-                aiRows.push(...batchResults);
-                debugLog(`‚úì AI batch ${batchIdx + 1}: Retrieved ${batchResults.length} results`, 'success');
-              }
-            } catch (batchErr) {
-              debugLog(`‚úó AI batch ${batchIdx + 1} error: ${batchErr.message}`, 'error');
-              // Add empty results for this batch
-              batch.forEach(keyword => {
-                aiRows.push({
-                  query: keyword,
-                  has_ai_overview: false,
-                  total_citations: 0,
-                  alanranger_citations_count: 0,
-                  alanranger_citations: [],
-                  sample_citations: [],
-                  error: batchErr.message
-                });
-              });
-            }
-            
-            // Small delay between batches to avoid rate limiting
-            if (batchIdx < aiBatches.length - 1) {
-              await new Promise(resolve => setTimeout(resolve, 500));
-            }
-          }
-          
-          RankingAiProgressModal.updateProgress(75, 2);
-          RankingAiProgressModal.updateCounts(`‚úì Retrieved AI Overview data for ${aiRows.length} keywords`);
-          debugLog(`‚úì Retrieved ${aiRows.length} AI results total`, 'success');
-          
-        } catch (aiErr) {
-          debugLog(`‚úó AI fetch error: ${aiErr.message}`, 'error');
-          RankingAiProgressModal.updateCounts(`‚ö† AI Overview check failed (${aiErr.message}), continuing with SERP data only...`);
-          aiFetchError = aiErr.message;
-          // Continue with empty AI data - UI will still show SERP results
-        }
-        
-        // Step 3: Process Results and merge AI data
-        RankingAiProgressModal.updateProgress(80, 3);
-        RankingAiProgressModal.setActiveStep(3);
-        RankingAiProgressModal.updateCounts(`Combining SERP and AI data...`);
-        
-        debugLog('üìä Parsing JSON responses...', 'info');
-        debugLog(`üìä SERP results: ${allSerpResults.length} keywords processed`, 'info');
-        if (aiFetchError) {
-          debugLog(`‚ö† AI data unavailable: ${aiFetchError}`, 'warn');
-        }
-
-        const serpRows = allSerpResults; // Use batched results
-
-        debugLog(`Received ${serpRows.length} SERP results and ${aiRows.length} AI results`, 'info');
-        RankingAiProgressModal.updateCounts(`Processing ${serpRows.length} SERP results and ${aiRows.length} AI results...`);
-
-        // Map AI rows by normalised query
-        const aiByKeyword = {};
-        aiRows.forEach(row => {
-          const key = RankingAiModule.normaliseKeyword(row.query);
-          aiByKeyword[key] = row;
-        });
-
-        // Update existing combined rows with AI data, or create new ones if needed
-        // First, create a map of existing combined rows by keyword
-        const combinedByKeyword = {};
-        allCombinedRows.forEach(row => {
-          const key = RankingAiModule.normaliseKeyword(row.keyword);
-          combinedByKeyword[key] = row;
-        });
-
-        // First pass: classify all SERP rows and collect search volumes for demand_share calculation
-        const rowsWithClassification = serpRows.map(row => {
-          const key = RankingAiModule.normaliseKeyword(row.keyword);
-          const aiRow = aiByKeyword[key] || null;
-          const bestUrl = row.best_url || null;
-          
-          // Use intent-based classification (keyword text drives segment, not URL)
-          const segment = RankingAiModule.classifyKeywordSegment(row.keyword, bestUrl);
-          const pageType = RankingAiModule.classifyPageTypeForKeyword ? 
-            RankingAiModule.classifyPageTypeForKeyword(bestUrl) : "Landing";
-          const classification = { segment, pageType };
-          
-          return {
-            ...row,
-            aiRow,
-            classification,
-            search_volume: row.search_volume ?? null
-          };
-        });
-        
-        // Calculate total demand for demand_share
-        const totalDemand = rowsWithClassification.reduce((sum, r) => {
-          const vol = r.search_volume;
-          return sum + (vol && vol > 0 ? vol : 0);
-        }, 0);
-        
-        // Second pass: build combined rows with demand_share and AI data
-        const combined = rowsWithClassification.map(row => {
-          const key = RankingAiModule.normaliseKeyword(row.keyword);
-          const aiRow = row.aiRow || null;
-          const bestUrl = row.best_url || null;
-          const { segment, pageType } = row.classification;
-
-          const aiCitations = aiRow?.alanranger_citations || [];
-          const aiOtherCitations = (aiRow?.sample_citations || []).filter(c => {
-            const domain = (c.domain || "").toLowerCase();
-            return domain && !domain.includes("alanranger.com");
-          });
-
-          // Count competitor domains
-          const competitorCounts = {};
-          aiOtherCitations.forEach(c => {
-            const d = (c.domain || "").toLowerCase();
-            if (!d) return;
-            competitorCounts[d] = (competitorCounts[d] || 0) + 1;
-          });
-
-          // Calculate demand_share
-          const searchVolume = row.search_volume;
-          const demandShare = (searchVolume && searchVolume > 0 && totalDemand > 0) 
-            ? searchVolume / totalDemand 
-            : 0;
-
-          // Debug: Log search volume for first few keywords
-          if (serpRows.indexOf(row) < 3) {
-            debugLog(`[DEBUG] Keyword "${row.keyword}": search_volume=${searchVolume}, demand_share=${(demandShare * 100).toFixed(1)}%, segment=${segment}, pageType=${pageType}`, 'info');
-          }
-
-          // Canonicalize URL - store both raw and canonical
-          const rawTargetUrl = bestUrl || "";
-          const canonicalTargetUrl = canonicalizeUrl(rawTargetUrl);
-          
-          return {
-            keyword: row.keyword,
-            segment: segment, // Keep capitalized: Brand/Money/Education/Other
-            pageType,
-            best_rank_group: row.best_rank_group,
-            best_rank_absolute: row.best_rank_absolute,
-            best_url: bestUrl, // Keep raw for backward compatibility
-            rawTargetUrl: rawTargetUrl, // Explicit raw URL
-            targetUrl: canonicalTargetUrl, // Canonical URL (single source of truth)
-            best_title: row.best_title || "",
-            // Use SERP response's has_ai_overview (from DataForSEO) as primary source,
-            // fallback to AI API response if SERP doesn't have it
-            has_ai_overview: !!(row.has_ai_overview || (aiRow && aiRow.has_ai_overview)),
-            ai_total_citations: aiRow?.total_citations ?? 0,
-            ai_alan_citations_count: aiRow?.alanranger_citations_count ?? 0,
-            ai_alan_citations: aiCitations,
-            ai_sample_citations: aiOtherCitations,
-            serp_features: row.serp_features || {
-              has_ai_overview: false,
-              has_local_pack: false,
-              has_featured_snippet: false,
-              has_people_also_ask: false
-            },
-            // New boolean fields for SERP feature coverage (from SERP API response)
-            ai_overview_present_any: row.ai_overview_present_any === true || row.has_ai_overview === true,
-            local_pack_present_any: row.local_pack_present_any === true || (row.serp_features && row.serp_features.local_pack === true),
-            paa_present_any: row.paa_present_any === true || (row.serp_features && row.serp_features.people_also_ask === true),
-            featured_snippet_present_any: row.featured_snippet_present_any === true || (row.serp_features && row.serp_features.featured_snippet === true),
-            competitor_counts: competitorCounts,
-            search_volume: searchVolume,
-            search_volume_trend: row.search_volume_trend || undefined,
-            demand_share: demandShare
-            // opportunityScore will be added after all rows are created (see below)
-          };
-        });
-        
-        // Compute maxDemandShare for opportunity score calculation
-        const maxDemandShare = combined.reduce((max, r) => {
-          const ds = r.demand_share ?? 0;
-          return ds > max ? ds : max;
-        }, 0);
-        
-        // Add opportunity score to each row
-        combined.forEach(row => {
-          const oppResult = computeKeywordOpportunityScore(row, maxDemandShare);
-          row.opportunityScore = oppResult.score;
-          row.oppDemandComponent = oppResult.demandComponent;
-          row.oppRankComponent = oppResult.rankComponent;
-          row.oppAiComponent = oppResult.aiComponent;
-        });
-        
-        // Debug: Log opportunity scores for first few keywords
-        if (combined.length > 0) {
-          const sampleRows = combined.slice(0, 3);
-          sampleRows.forEach(r => {
-            console.debug(`[Opportunity Score] "${r.keyword}": score=${r.opportunityScore}, D=${(r.oppDemandComponent * 100).toFixed(0)}%, R=${(r.oppRankComponent * 100).toFixed(0)}%, A=${(r.oppAiComponent * 100).toFixed(0)}%`);
-          });
-        }
-
-        // Summary metrics
-        const totalKeywords = combined.length;
-        const withRank = combined.filter(r => r.best_rank_group != null).length;
-        const withAiOverview = combined.filter(r => r.has_ai_overview).length;
-        const withAiCitation = combined.filter(r => r.ai_alan_citations_count > 0).length;
-        const top10 = combined.filter(r => r.best_rank_group != null && r.best_rank_group <= 10).length;
-        const top3 = combined.filter(r => r.best_rank_group != null && r.best_rank_group <= 3).length;
-        // Count keywords with search volume (including 0, but not null/undefined)
-        const withSearchVolume = combined.filter(r => r.search_volume != null && r.search_volume !== undefined).length;
-        
-        // Log search volume for each keyword
-        combined.forEach(row => {
-          const volume = row.search_volume != null && row.search_volume !== undefined
-            ? row.search_volume.toLocaleString() 
-            : 'none';
-          debugLog(`Search volume for "${row.keyword}": ${volume}`, 'info');
-        });
-        
-        debugLog(`Search volume summary: ${withSearchVolume}/${totalKeywords} keywords have search volume data`, 'info');
-        RankingAiProgressModal.updateProgress(90, 3);
-        RankingAiProgressModal.updateCounts(`‚úì Processed ${totalKeywords} keywords (${withRank} ranked, ${withAiOverview} with AI Overview, ${withSearchVolume} with search volume)`);
-
-        // Calculate visibility metrics from combined results (Ranking API only - not part of AIO pillars)
-        const validRankingRows = combined.filter(r => r.best_rank_group != null && typeof r.best_rank_group === 'number');
-        let avgPositionUnweighted = null;
-        let avgPositionVolumeWeighted = null;
-        
-        if (validRankingRows.length >= 1) {
-          // Unweighted average position
-          const sumRanks = validRankingRows.reduce((sum, k) => sum + k.best_rank_group, 0);
-          avgPositionUnweighted = Math.round((sumRanks / validRankingRows.length) * 100) / 100;
-          
-          // Demand-weighted average position
-          let sumWeightedRanks = 0;
-          let sumVolumes = 0;
-          
-          for (const row of validRankingRows) {
-            const vol = (row.search_volume !== null && row.search_volume !== undefined && row.search_volume > 0)
-              ? row.search_volume
-              : 10; // Fallback
-            sumWeightedRanks += row.best_rank_group * vol;
-            sumVolumes += vol;
-          }
-          
-          if (sumVolumes > 0) {
-            avgPositionVolumeWeighted = Math.round((sumWeightedRanks / sumVolumes) * 100) / 100;
-          }
-        }
-        
-        const summary = {
-          total_keywords: totalKeywords,
-          keywords_with_rank: withRank,
-          keywords_with_ai_overview: withAiOverview,
-          keywords_with_ai_citations: withAiCitation,
-          top10,
-          top3,
-          // Include visibility metrics (Ranking API only - not part of AIO pillars)
-          avg_position_unweighted: avgPositionUnweighted,
-          avg_position_volume_weighted: avgPositionVolumeWeighted,
-          keywords_used_for_avg: validRankingRows.length,
-          keywords_with_volume: withSearchVolume
-        };
-
-        // Debug: Log AI citations for first few keywords
-        const keywordsWithCitations = combined.filter(r => r.ai_alan_citations_count > 0);
-        debugLog(`üìä AI Citations Summary: ${keywordsWithCitations.length}/${totalKeywords} keywords have citations`, 'info');
-        if (keywordsWithCitations.length > 0) {
-          keywordsWithCitations.slice(0, 5).forEach(row => {
-            debugLog(`  ‚úì "${row.keyword}": ${row.ai_alan_citations_count} citations`, 'info');
-          });
-        } else {
-          debugLog(`  ‚ö† No keywords have AI citations. AI fetch error: ${aiFetchError || 'none'}`, 'warn');
-          if (aiRows.length > 0) {
-            debugLog(`  üìä AI rows received: ${aiRows.length}, checking first few...`, 'info');
-            aiRows.slice(0, 3).forEach(aiRow => {
-              debugLog(`    - "${aiRow.query}": alanranger_citations_count=${aiRow.alanranger_citations_count ?? 'undefined'}, total_citations=${aiRow.total_citations ?? 'undefined'}`, 'info');
-            });
-          }
-        }
-
-        // Normalize summary field names before setting (ensure camelCase for display)
-        const normalizedSummary = normalizeSummaryFields(summary);
-        mod.setData(combined, normalizedSummary);
-        mod.setLoadedOnce(true);
-        
-        // Step 4: Save Data
-        RankingAiProgressModal.updateProgress(95, 4);
-        RankingAiProgressModal.setActiveStep(4);
-        RankingAiProgressModal.updateCounts(`Saving to database...`);
-        
-        // Update incrementally saved rows with merged AI data
-        if (propertyUrl && combined.length > 0) {
-          debugLog(`üìä Updating incrementally saved rows with merged AI data...`, 'info');
-          const updateResult = await saveRankingAiDataIncremental(combined, auditDate, propertyUrl);
-          if (updateResult.success) {
-            debugLog(`‚úì Updated ${updateResult.saved} keyword rows with AI data`, 'success');
-          } else {
-            debugLog(`‚ö† Failed to update rows with AI data: ${updateResult.error}`, 'warn');
-          }
-        }
-        
-        // Save to Supabase and localStorage
-        await saveRankingAiData(combined, summary);
-        
-        // CRITICAL: Fetch and save queryTotals for all ranking keywords
-        RankingAiProgressModal.updateProgress(96, 4);
-        RankingAiProgressModal.updateCounts(`Fetching GSC query totals for ${combined.length} keywords...`);
-        debugLog(`üìä Fetching queryTotals for ${combined.length} ranking keywords...`, 'info');
-        
-        try {
-          const allKeywords = combined.map(r => r.keyword).filter(k => k && k.trim());
-          if (allKeywords.length > 0) {
-            const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
-            const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28');
-            
-            // Fetch queryTotals from GSC API
-            const keywordsParam = encodeURIComponent(JSON.stringify(allKeywords));
-            const propertyParam = encodeURIComponent(propertyUrl);
-            const gscResponse = await fetch(apiUrl(`/api/aigeo/gsc-entity-metrics?property=${propertyParam}&keywords=${keywordsParam}&days=${dateRange}`));
-            
-            if (gscResponse.ok) {
-              const gscData = await gscResponse.json();
-              if (gscData.status === 'ok' && gscData.data && Array.isArray(gscData.data.queryTotals)) {
-                const queryTotals = gscData.data.queryTotals;
-                debugLog(`‚úì Fetched queryTotals for ${queryTotals.length} keywords from GSC`, 'success');
-                
-                // Load existing audit data
-                const savedAudit = loadAuditResultsSync();
-                if (savedAudit && savedAudit.searchData) {
-                  // Merge queryTotals into searchData
-                  savedAudit.searchData.queryTotals = queryTotals;
-                  
-                  // CRITICAL: Use the SAME audit_date as the existing audit, not today's date
-                  // This ensures queryTotals are saved to the same audit record
-                  let auditDate = new Date().toISOString().split('T')[0]; // Fallback to today
-                  if (savedAudit.timestamp) {
-                    try {
-                      auditDate = new Date(savedAudit.timestamp).toISOString().split('T')[0];
-                      debugLog(`üìä Using existing audit date for queryTotals: ${auditDate}`, 'info');
-                    } catch (e) {
-                      debugLog(`‚ö† Failed to parse saved audit timestamp, using today's date`, 'warn');
-                    }
-                  }
-                  
-                  // Save to Supabase
-                  const saveResponse = await fetch(apiUrl('/api/supabase/save-audit'), {
-                    method: 'POST',
-                    headers: { 'Content-Type': 'application/json' },
-                    body: JSON.stringify({
-                      propertyUrl: propertyUrl,
-                      auditDate: auditDate,
-                      searchData: savedAudit.searchData // Include updated searchData with queryTotals
-                    })
-                  });
-                  
-                  if (saveResponse.ok) {
-                    debugLog(`‚úì Saved queryTotals to Supabase (${queryTotals.length} keywords) for audit_date: ${auditDate}`, 'success');
-                    
-                    // CRITICAL: Also update localStorage so loadAuditResultsSync() can find the data
-                    try {
-                      safeSetLocalStorage('last_audit_results', savedAudit);
-                      debugLog(`‚úì Updated localStorage with queryTotals`, 'success');
-                    } catch (localStorageErr) {
-                      debugLog(`‚ö† Failed to update localStorage: ${localStorageErr.message}`, 'warn');
-                    }
-                    
-                    // Update audit date pill to reflect new scan
-                    updateAuditTimestamp(new Date().toISOString());
-                  } else {
-                    const errorText = await saveResponse.text();
-                    debugLog(`‚ö† Failed to save queryTotals to Supabase: ${saveResponse.status} - ${errorText}`, 'warn');
-                  }
-                } else {
-                  debugLog(`‚ö† No existing audit data found, creating new audit record with queryTotals...`, 'warn');
-                  // Create new audit record with queryTotals
-                  const auditDate = new Date().toISOString().split('T')[0];
-                  const saveResponse = await fetch(apiUrl('/api/supabase/save-audit'), {
-                    method: 'POST',
-                    headers: { 'Content-Type': 'application/json' },
-                    body: JSON.stringify({
-                      propertyUrl: propertyUrl,
-                      auditDate: auditDate,
-                      searchData: { queryTotals: queryTotals }
-                    })
-                  });
-                  
-                  if (saveResponse.ok) {
-                    debugLog(`‚úì Created new audit record with queryTotals (${queryTotals.length} keywords)`, 'success');
-                    
-                    // CRITICAL: Also save to localStorage so loadAuditResultsSync() can find the data
-                    try {
-                      const newAuditData = {
-                        searchData: { queryTotals: queryTotals },
-                        timestamp: new Date().toISOString(),
-                        propertyUrl: propertyUrl
-                      };
-                      safeSetLocalStorage('last_audit_results', newAuditData);
-                      debugLog(`‚úì Saved new audit record to localStorage with queryTotals`, 'success');
-                    } catch (localStorageErr) {
-                      debugLog(`‚ö† Failed to save to localStorage: ${localStorageErr.message}`, 'warn');
-                    }
-                    
-                    updateAuditTimestamp(new Date().toISOString());
-                  } else {
-                    const errorText = await saveResponse.text();
-                    debugLog(`‚ö† Failed to create audit record with queryTotals: ${saveResponse.status} - ${errorText}`, 'warn');
-                  }
-                }
-              } else {
-                debugLog(`‚ö† GSC API did not return queryTotals data`, 'warn');
-              }
-            } else {
-              const errorText = await gscResponse.text();
-              debugLog(`‚ö† Failed to fetch queryTotals from GSC: ${gscResponse.status} - ${errorText}`, 'warn');
-            }
-          } else {
-            debugLog(`‚ö† No keywords to fetch queryTotals for`, 'warn');
-          }
-        } catch (queryTotalsErr) {
-          debugLog(`‚úó Error fetching/saving queryTotals: ${queryTotalsErr.message}`, 'error');
-          // Don't fail the entire scan if queryTotals fetch fails
-        }
-        
-        RankingAiProgressModal.updateProgress(98, 4);
-        RankingAiProgressModal.updateCounts(`‚úì Data saved successfully`);
-        
-        // Step 5: Complete
-        RankingAiProgressModal.updateProgress(100, 5);
-        RankingAiProgressModal.setActiveStep(5);
-        
-        // Show completion summary
-        RankingAiProgressModal.showSummary({
-          totalKeywords,
-          keywordsWithRank: withRank,
-          top10,
-          top3,
-          keywordsWithAiOverview: withAiOverview,
-          keywordsWithAiCitations: withAiCitation,
-          avgPositionUnweighted: summary.avg_position_unweighted,
-          avgPositionVolumeWeighted: summary.avg_position_volume_weighted,
-          keywordsWithVolume: summary.keywords_with_volume,
-          aiFetchError: aiFetchError || null
-        });
-        
-        RankingAiProgressModal.updateCounts(`‚úì Scan completed successfully!`);
-        
-        renderRankingAiTab();
-
-        const lastRunEl = document.getElementById("ranking-ai-last-run");
-        if (lastRunEl) {
-          const now = new Date();
-          // Format in GMT/UTC: "DD MMM YYYY, HH:MM:SS GMT"
-          const day = String(now.getUTCDate()).padStart(2, '0');
-          const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
-          const month = monthNames[now.getUTCMonth()];
-          const year = now.getUTCFullYear();
-          const hours = String(now.getUTCHours()).padStart(2, '0');
-          const minutes = String(now.getUTCMinutes()).padStart(2, '0');
-          const seconds = String(now.getUTCSeconds()).padStart(2, '0');
-          const formatted = `${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
-          lastRunEl.textContent = `Last run: ${formatted}`;
-        }
-        debugLog(`‚úì Ranking & AI data loaded: ${totalKeywords} keywords, ${withRank} with ranks, ${withAiOverview} with AI Overview`, 'success');
-        
-        // Don't hide modal - keep it visible with summary
-      } catch (err) {
-        console.error("Ranking & AI load error", err);
-        const errorMsg = scanAborted ? 'Scan aborted by user' : err.message;
-        debugLog(`‚úó Ranking & AI load error: ${errorMsg}`, 'error');
-        
-        // If aborted, show specific message
-        if (scanAborted) {
-          RankingAiProgressModal.updateCounts('‚ö†Ô∏è Scan aborted by user');
-          RankingAiProgressModal.showSummary({
-            error: true,
-            errorMessage: 'Scan was aborted by user. No data was saved.',
-            totalKeywords: keywords?.length || 0
-          });
-          return;
-        }
-        
-        // Try to load any saved data from Supabase (SERP data may have been saved incrementally)
-        debugLog('üìä Attempting to load saved data from Supabase after error...', 'info');
-        try {
-          const savedData = await loadRankingAiDataFromStorage(true); // Force Supabase check
-          if (savedData && savedData.combinedRows && savedData.combinedRows.length > 0) {
-            debugLog(`‚úì Loaded ${savedData.combinedRows.length} keywords from Supabase after error`, 'success');
-            const normalizedSummary = normalizeSummaryFields(savedData.summary);
-            mod.setData(savedData.combinedRows, normalizedSummary);
-            mod.setLoadedOnce(true);
-            renderRankingAiTab();
-            RankingAiProgressModal.updateProgress(100, 5);
-            RankingAiProgressModal.setActiveStep(5);
-            RankingAiProgressModal.showSummary({
-              error: true,
-              errorMessage: `Scan encountered an error, but loaded ${savedData.combinedRows.length} saved keywords from database: ${err.message}`,
-              totalKeywords: savedData.combinedRows.length,
-              keywordsWithRank: savedData.summary?.keywords_with_rank || 0,
-              top10: savedData.summary?.top10 || 0,
-              top3: savedData.summary?.top3 || 0,
-              keywordsWithAiOverview: savedData.summary?.keywords_with_ai_overview || 0,
-              keywordsWithAiCitations: savedData.summary?.keywords_with_ai_citations || 0
-            });
-            RankingAiProgressModal.updateCounts(`‚ö† Error occurred, but loaded saved data from database`);
-            return; // Exit early since we loaded saved data
-          }
-        } catch (loadErr) {
-          debugLog(`‚úó Failed to load saved data: ${loadErr.message}`, 'error');
-        }
-        
-        const lastRunEl = document.getElementById("ranking-ai-last-run");
-        if (lastRunEl) {
-          lastRunEl.textContent = "Error loading ranking & AI data. See console for details.";
-        }
-        
-        // Show error summary in modal instead of hiding
-        RankingAiProgressModal.updateProgress(100, 5);
-        RankingAiProgressModal.setActiveStep(5);
-        RankingAiProgressModal.showSummary({
-          error: true,
-          errorMessage: err.message,
-          totalKeywords: keywords?.length || 0,
-          keywordsWithRank: allSerpResults?.filter(r => r.best_rank_group != null).length || 0
-        });
-        RankingAiProgressModal.updateCounts(`‚úó Error: ${err.message}`);
-      } finally {
-        RankingAiModule.setLoading(false);
-        const refreshBtn = document.getElementById("ranking-ai-refresh");
-        if (refreshBtn) {
-          refreshBtn.disabled = false;
-          refreshBtn.textContent = "Run ranking & AI check";
-        }
-        
-        // Enable close button
-        const closeBtn = document.getElementById('rankingAiProgressClose');
-        if (closeBtn) {
-          closeBtn.disabled = false;
-          closeBtn.style.opacity = '1';
-          closeBtn.onclick = () => RankingAiProgressModal.hide();
-        }
-      }
-    }
-    
-    // Make loadRankingAiData globally available
-    window.loadRankingAiData = loadRankingAiData;
-
-    // ======================
-    // Ranking & AI: Rendering functions
-    // ======================
-    // Filter and sort state
-    let rankingFilterState = {
-      segment: 'all',
-      rank: 'all',
-      volume: 'all',
-      ctr: 'all',
-      opportunity: 'all',
-      aiOverview: 'all',
-      aiCitation: 'all',
-      pageType: 'all',
-      serpFeatures: 'all',
-      optimisationStatus: 'all',
-      keyword: '',
-      minOpportunity: null // number | null
-    };
-    let rankingSortState = {
-      column: 'opportunityScore', // Default sort by opportunity score (descending)
-      direction: 'desc'
-    };
-    let rankingPaginationState = {
-      currentPage: 1,
-      rowsPerPage: 10  // Default to 10 rows so all show without scrolling
-    };
-    let rankingPriorityFilter = null; // { impact: 'high'|'medium'|'low', difficulty: 'high'|'medium'|'low' } | null
-    let selectedKeywordId = null; // Store selected keyword identifier (keyword + url combination)
-    let activePreset = null; // Track which preset is currently active ('all', 'high-impact-money', etc.)
-
-    // Impact and Difficulty bucket thresholds (constants for tuning)
-    const IMPACT_THRESHOLDS = {
-      HIGH: 0.20,   // >= 20% of tracked demand
-      MEDIUM: 0.10  // 10-19.99% of tracked demand
-    };
-    const DIFFICULTY_THRESHOLDS = {
-      LOW: { min: 4, max: 15 },      // Easy win: rank 4-15
-      MEDIUM: { min: 16, max: 30 }   // Medium: rank 16-30
-    };
-
-    /**
-     * Calculate impact bucket for a keyword based on demand_share
-     * @param {number} demandShare - Fraction (0-1) of total demand
-     * @returns {'high'|'medium'|'low'}
-     */
-    /**
-     * Compute Keyword Opportunity Score (0-100) with component breakdown
-     * @param {Object} row - Keyword row with demand_share, best_rank_group, has_ai_overview, etc.
-     * @param {number} maxDemandShare - Maximum demand_share across all keywords (0-1)
-     * @returns {Object} { score: 0-100, demandComponent: 0-1, rankComponent: 0-1, aiComponent: 0-1 }
-     */
-    function computeKeywordOpportunityScore(row, maxDemandShare) {
-      // 2.1 Demand component D (0-1)
-      const demandShare = (row.demand_share ?? 0) * 100; // Convert to 0-100 if stored as 0-1
-      const maxShare = (maxDemandShare ?? 0) * 100; // Convert to 0-100 if stored as 0-1
-      
-      let D = 0;
-      if (maxShare > 0) {
-        D = demandShare / maxShare; // relative to biggest keyword
-      }
-      D = Math.min(Math.max(D, 0), 1);
-
-      // 2.2 Rank component R (0-1)
-      const rank = row.best_rank_group ?? row.best_rank_absolute ?? null;
-      let R;
-      
-      if (rank == null) {
-        R = 0.2;          // effectively not ranked
-      } else if (rank <= 3) {
-        R = 0.2;          // already very strong; little upside
-      } else if (rank <= 10) {
-        R = 1.0;          // page 1 but not top 3: sweet spot
-      } else if (rank <= 20) {
-        R = 0.8;          // page 2
-      } else if (rank <= 50) {
-        R = 0.5;          // visible but weaker
-      } else {
-        R = 0.2;          // very weak
-      }
-
-      // 2.3 AI leverage component A (0-1)
-      const hasAi = row.has_ai_overview === true;
-      const total = row.ai_total_citations ?? row.ai_citations_total ?? 0;
-      const ours = row.ai_alan_citations_count ?? row.ai_citations_from_alan ?? 0;
-      
-      let A;
-      
-      if (!hasAi) {
-        A = 0.5; // neutral: AI not helping or hurting yet
-      } else if (!total) {
-        A = 0.5; // overview present, but no citation info
-      } else {
-        const share = ours / total; // 0-1
-        
-        if (share < 0.33) {
-          A = 1.0; // overview exists, you're under-represented
-        } else if (share <= 0.66) {
-          A = 0.7; // present but not owning it
-        } else {
-          A = 0.4; // you already dominate AI answers
-        }
-      }
-
-      // 2.4 Combined score S (0-100)
-      const opportunity0to1 =
-        0.5 * D +   // demand is main driver
-        0.3 * R +   // room to move in classic rank
-        0.2 * A;    // AI leverage
-
-      const keywordOpportunityScore = Math.round(opportunity0to1 * 100);
-
-      return {
-        score: keywordOpportunityScore,
-        demandComponent: D,
-        rankComponent: R,
-        aiComponent: A
-      };
-    }
-
-    function calculateImpactBucket(demandShare) {
-      if (demandShare >= IMPACT_THRESHOLDS.HIGH) return 'high';
-      if (demandShare >= IMPACT_THRESHOLDS.MEDIUM) return 'medium';
-      return 'low';
-    }
-
-    /**
-     * Calculate difficulty bucket for a keyword based on best_rank_group
-     * @param {number|null} bestRankGroup - Best rank group (position)
-     * @returns {'low'|'medium'|'high'}
-     */
-    function calculateDifficultyBucket(bestRankGroup) {
-      // If already ranking in top 3, treat as low difficulty (already winning)
-      if (bestRankGroup != null && bestRankGroup >= 1 && bestRankGroup <= 3) {
-        return 'low';
-      }
-      
-      // Low difficulty: rank 4-15 (easy win)
-      if (bestRankGroup != null && 
-          bestRankGroup >= DIFFICULTY_THRESHOLDS.LOW.min && 
-          bestRankGroup <= DIFFICULTY_THRESHOLDS.LOW.max) {
-        return 'low';
-      }
-      
-      // Medium difficulty: rank 16-30
-      if (bestRankGroup != null && 
-          bestRankGroup >= DIFFICULTY_THRESHOLDS.MEDIUM.min && 
-          bestRankGroup <= DIFFICULTY_THRESHOLDS.MEDIUM.max) {
-        return 'medium';
-      }
-      
-      // High difficulty: rank > 30 or null (no rank)
-      return 'high';
-    }
-
-    /**
-     * Build comprehensive scorecard data for a keyword row
-     * @param {Object} row - Keyword row from combinedRows
-     * @returns {Object} Enriched scorecard data
-     */
-    function buildKeywordScorecardData(row) {
-      if (!row) return null;
-
-      // Demand level from search_volume
-      const searchVolume = row.search_volume;
-      let demandLevel = 'Low';
-      if (searchVolume != null && searchVolume >= 500) {
-        demandLevel = 'High';
-      } else if (searchVolume != null && searchVolume >= 200) {
-        demandLevel = 'Medium';
-      }
-
-      // Rank bucket
-      const rank = row.best_rank_group;
-      let rankBucket = 'page2plus';
-      let rankBucketLabel = 'beyond page 2';
-      let positionStrength = 'Weak';
-      if (rank != null) {
-        if (rank >= 1 && rank <= 3) {
-          rankBucket = 'top3';
-          rankBucketLabel = 'page 1';
-          positionStrength = 'Strong';
-        } else if (rank >= 4 && rank <= 10) {
-          rankBucket = 'top10';
-          rankBucketLabel = 'page 1';
-          positionStrength = 'OK';
-        } else if (rank > 10) {
-          rankBucket = 'page2plus';
-          rankBucketLabel = 'beyond page 2';
-          positionStrength = 'Weak';
-        }
-      }
-
-      // AI status bucket
-      const hasAiOverview = row.has_ai_overview || false;
-      const aiCitationsOurs = row.ai_alan_citations_count || 0;
-      const aiCitationsTotal = row.ai_total_citations || 0;
-      let aiStatus = 'no_ai';
-      let aiStatusLabel = 'No AI Overview';
-      if (hasAiOverview) {
-        if (aiCitationsOurs === 0) {
-          aiStatus = 'ai_no_citation';
-          aiStatusLabel = 'AI Overview present, not cited';
-        } else {
-          const ourShare = aiCitationsTotal > 0 ? (aiCitationsOurs / aiCitationsTotal) : 0;
-          if (ourShare >= 0.25) {
-            aiStatus = 'ai_cited_strong';
-            aiStatusLabel = `AI Overview present, cited in ${aiCitationsOurs}/${aiCitationsTotal} citations (strong)`;
-          } else {
-            aiStatus = 'ai_cited_light';
-            aiStatusLabel = `AI Overview present, cited in ${aiCitationsOurs}/${aiCitationsTotal} citations (light)`;
-          }
-        }
-      }
-
-      // Impact, Difficulty, and Priority from opportunity score components
-      // Use opportunity score components if available, otherwise fall back to old logic
-      let impact, difficulty, priorityLevel;
-      
-      if (row.opportunityScore != null && row.oppDemandComponent != null && row.oppRankComponent != null && row.oppAiComponent != null) {
-        // Use opportunity score components (new logic)
-        // Impact raw: 0.7 * D + 0.3 * A
-        const impactRaw = 0.7 * row.oppDemandComponent + 0.3 * row.oppAiComponent;
-        if (impactRaw >= 0.66) impact = 'high';
-        else if (impactRaw >= 0.33) impact = 'medium';
-        else impact = 'low';
-        
-        // Difficulty raw: 1 - R (harder if there is less room to move)
-        const difficultyRaw = 1 - row.oppRankComponent;
-        if (difficultyRaw <= 0.33) difficulty = 'low';
-        else if (difficultyRaw <= 0.66) difficulty = 'medium';
-        else difficulty = 'high';
-        
-        // Priority from numeric opportunity score
-        if (row.opportunityScore >= 70) priorityLevel = 'High';
-        else if (row.opportunityScore >= 40) priorityLevel = 'Medium';
-        else priorityLevel = 'Low';
-      } else {
-        // Fallback to old logic if opportunity score not available
-        impact = calculateImpactBucket(row.demand_share || 0);
-        difficulty = calculateDifficultyBucket(rank);
-        
-        // Priority level from Impact + Difficulty
-        priorityLevel = 'Low';
-        if (impact === 'high' && (difficulty === 'low' || difficulty === 'medium')) {
-          priorityLevel = 'High';
-        } else if (impact === 'high' && difficulty === 'high' || 
-                   impact === 'medium' && (difficulty === 'low' || difficulty === 'medium')) {
-          priorityLevel = 'Medium';
-        }
-      }
-
-      return {
-        // Raw data
-        keyword: row.keyword,
-        segment: row.segment,
-        best_rank_group: rank,
-        search_volume: searchVolume,
-        demand_share: row.demand_share || 0,
-        has_ai_overview: hasAiOverview,
-        ai_citations_total: aiCitationsTotal,
-        ai_citations_ours: aiCitationsOurs,
-        ai_alan_citations: row.ai_alan_citations || [], // Store citations for display
-        serp_features: row.serp_features || {},
-        // SERP feature boolean fields
-        ai_overview_present_any: row.ai_overview_present_any === true || row.has_ai_overview === true,
-        local_pack_present_any: row.local_pack_present_any === true || (row.serp_features && row.serp_features.local_pack === true),
-        paa_present_any: row.paa_present_any === true || (row.serp_features && row.serp_features.people_also_ask === true),
-        featured_snippet_present_any: row.featured_snippet_present_any === true || (row.serp_features && row.serp_features.featured_snippet === true),
-        // Canonicalize URL - store both raw and canonical
-        rawTargetUrl: row.rawTargetUrl || row.best_url || '',
-        targetUrl: row.targetUrl || (row.best_url ? canonicalizeUrl(row.best_url) : ''),
-        ranking_url: row.targetUrl || (row.best_url ? canonicalizeUrl(row.best_url) : ''), // Use canonical for ranking_url
-        page_type: row.pageType || 'Landing',
-        
-        // Derived fields
-        demand_level: demandLevel,
-        rank_bucket: rankBucket,
-        rank_bucket_label: rankBucketLabel,
-        position_strength: positionStrength,
-        ai_status: aiStatus,
-        ai_status_label: aiStatusLabel,
-        impact_bucket: impact,
-        difficulty_bucket: difficulty,
-        priority_level: priorityLevel,
-        // Opportunity score fields
-        opportunity_score: row.opportunityScore ?? null,
-        opp_demand_component: row.oppDemandComponent ?? null,
-        opp_rank_component: row.oppRankComponent ?? null,
-        opp_ai_component: row.oppAiComponent ?? null
-      };
-    }
-
-    /**
-     * Generate summary sentence for keyword based on demand, rank, and AI status
-     * @param {Object} scorecardData - Data from buildKeywordScorecardData
-     * @returns {string} Summary sentence
-     */
-    function generateKeywordSummary(scorecardData) {
-      const { demand_level, best_rank_group, has_ai_overview, ai_citations_ours, segment } = scorecardData;
-      const parts = [];
-      
-      // Build summary sentence based on demand, rank, and AI status
-      // Format: "[Demand level]-demand [segment] keyword currently ranking #[rank] and [AI status]. [Win assessment]."
-      
-      // Demand level prefix
-      const demandPrefix = demand_level === 'High' ? 'High-demand' : 
-                          demand_level === 'Medium' ? 'Medium-demand' : 
-                          'Low-demand';
-      
-      // Segment context
-      const segmentContext = segment && segment.toLowerCase() === 'education' ? 'education ' :
-                            segment && segment.toLowerCase() === 'money' ? 'commercial ' : '';
-      
-      // Rank description
-      if (best_rank_group != null && best_rank_group <= 10) {
-        parts.push(`${demandPrefix} ${segmentContext}keyword currently ranking #${best_rank_group}`);
-        
-        // AI Overview status
-        if (has_ai_overview && ai_citations_ours > 0) {
-          parts.push('and cited in AI Overviews.');
-        } else if (has_ai_overview) {
-          parts.push('with AI Overview present but not cited.');
-        } else {
-          parts.push('but not yet cited in AI Overviews.');
-        }
-        
-        // Win assessment for page 1 keywords
-        if (demand_level === 'High' && has_ai_overview && ai_citations_ours > 0) {
-          parts.push('Good win if you can improve CTR and schema.');
-        } else if (demand_level === 'High') {
-          parts.push('Good win potential if you can improve CTR, schema, and AI citations.');
-        }
-      } else {
-        // Page 2+ keywords
-        if (demand_level === 'High') {
-          parts.push(`${demandPrefix} ${segmentContext}keyword currently on page 2+; big upside if you move into page 1.`);
-        } else {
-          parts.push(`${demandPrefix} ${segmentContext}keyword currently on page 2+; opportunity to improve ranking.`);
-        }
-        
-        // Add AI status for page 2+ if present
-        if (has_ai_overview && ai_citations_ours > 0) {
-          parts.push('Cited in AI Overviews.');
-        }
-      }
-      
-      return parts.join(' ');
-    }
-
-    /**
-     * Generate action bullets based on scorecard data (always returns 3 bullets)
-     * @param {Object} scorecardData - Data from buildKeywordScorecardData
-     * @returns {Array<string>} Array of exactly 3 action bullet strings
-     */
-    function generateActionBullets(scorecardData) {
-      const { demand_level, rank_bucket, ai_status, segment, page_type, position_strength } = scorecardData;
-      const standardActions = [];
-      
-      // Bullet 1: Classic ranking & CTR
-      if (demand_level === 'High' && rank_bucket !== 'top3') {
-        standardActions.push('Improve title and meta description for this page to win more clicks for this high-demand term.');
-      } else if (position_strength === 'Weak') {
-        standardActions.push('Improve title and meta description to improve CTR and push this page into top 10.');
-      } else {
-        standardActions.push('Continue optimizing title and meta description to maintain strong CTR for this keyword.');
-      }
-      
-      // Bullet 2: AI usage / authority
-      if (ai_status === 'ai_no_citation') {
-        standardActions.push('Strengthen on-page answer content and schema so AI can confidently cite this page in AI Overviews.');
-      } else if (ai_status === 'ai_cited_strong' || ai_status === 'ai_cited_light') {
-        if (rank_bucket === 'page1' || rank_bucket === 'page2plus') {
-          standardActions.push('You\'re already cited in AI Overviews ‚Äì improve classic ranking (links and snippet) to capture more traffic.');
-        } else {
-          standardActions.push('You\'re already cited in AI Overviews ‚Äì maintain strong ranking and authority signals.');
-        }
-      } else {
-        standardActions.push('No AI Overview yet ‚Äì improve content depth and schema to increase chances of AI citation.');
-      }
-      
-      // Bullet 3: Commercialisation / internal links
-      if (segment && segment.toLowerCase() === 'education' && page_type === 'Landing') {
-        standardActions.push('Consider adding stronger calls-to-action and internal links from money pages to capture more commercial value from this educational query.');
-      } else if (segment && segment.toLowerCase() === 'money') {
-        standardActions.push('Strengthen internal links from high-authority pages and optimize conversion elements on this money page.');
-      } else {
-        standardActions.push('Consider internal linking strategy to boost authority and capture related commercial queries.');
-      }
-      
-      return standardActions;
-    }
-
-    /**
-     * Normalize page URL for GSC matching - strips query params, fragments, ensures canonical format
-     * @param {string} url - URL to normalize
-     * @returns {string} Normalized URL path
-     */
-    function normalizeGscPageUrl(url) {
-      if (!url || typeof url !== 'string') return '';
-      
-      let cleanUrl = url.trim();
-      
-      // Strip query parameters (srsltid, utm_*, gclid, fbclid, etc.) and fragments
-      cleanUrl = cleanUrl.split('?')[0].split('#')[0];
-      
-      try {
-        // Handle relative URLs by adding base URL
-        let urlToParse = cleanUrl;
-        if (!cleanUrl.startsWith('http://') && !cleanUrl.startsWith('https://')) {
-          urlToParse = 'https://www.alanranger.com' + (cleanUrl.startsWith('/') ? cleanUrl : '/' + cleanUrl);
-        }
-        const urlObj = new URL(urlToParse);
-        // Use pathname (automatically excludes query params and hash)
-        let normalized = urlObj.pathname.toLowerCase().replace(/\/$/, '').trim();
-        // If pathname is empty or just '/', treat as homepage
-        if (!normalized || normalized === '/') {
-          normalized = '/';
-        }
-        return normalized;
-      } catch (e) {
-        // If URL parsing fails, use manually cleaned URL
-        return cleanUrl.toLowerCase().replace(/\/$/, '').trim() || '/';
-      }
-    }
-
-    /**
-     * Get GSC metrics for a keyword row - unified helper for table and scorecard
-     * Returns atomic bundle with clicks, impressions, CTR (decimal), scope, and normalized page URL
-     * @param {Object} params - Object with query (keyword) and pageUrl
-     * @returns {Object} { clicks, impressions, ctrDecimal, scope, pageUsed } or null if no data
-     *   - scope: 'query+page' | 'query-only' | 'page-only' | 'none'
-     *   - ctrDecimal: 0-1 (decimal format, e.g., 0.0117 for 1.17%)
-     *   - impressions: must be > 0 for CTR to be valid
-     */
-    function getGscMetricsForKeywordRow(params) {
-      try {
-        const { query, pageUrl } = params || {};
-        if (!query) {
-          return null;
-        }
-
-        // Get audit data from localStorage
-        const savedAudit = loadAuditResultsSync();
-        if (!savedAudit?.searchData?.queryPages) {
-          return null;
-        }
-
-        const queryPages = savedAudit.searchData.queryPages || [];
-        if (!Array.isArray(queryPages) || queryPages.length === 0) {
-          return null;
-        }
-
-        // Normalize keyword for matching
-        const normalizedKeyword = (query || '').toLowerCase().trim();
-        if (!normalizedKeyword) {
-          return null;
-        }
-
-        // Normalize page URL (strip query params, fragments, ensure canonical format)
-        const normalizedPageUrl = pageUrl ? normalizeGscPageUrl(pageUrl) : null;
-
-        // First try: exact match on keyword + URL (query+page scope)
-        if (normalizedPageUrl) {
-          const exactMatches = queryPages.filter(p => {
-            const pKeyword = (p.query || '').toLowerCase().trim();
-            const pPage = normalizeGscPageUrl(p.page || p.url || '');
-            return pKeyword === normalizedKeyword && pPage === normalizedPageUrl;
-          });
-
-          if (exactMatches.length > 0) {
-            // Aggregate all matches for this query+page combination
-            let totalImpressions = 0;
-            let totalClicks = 0;
-            exactMatches.forEach(m => {
-              totalImpressions += (m.impressions || 0);
-              totalClicks += (m.clicks || 0);
-            });
-
-            // Only return data if impressions > 0 (CTR requires impressions)
-            if (totalImpressions > 0) {
-              // CTR from GSC is stored as percentage (0-100), convert to decimal
-              const ctrDecimal = totalImpressions > 0 ? (totalClicks / totalImpressions) : 0;
-              return {
-                clicks: totalClicks,
-                impressions: totalImpressions,
-                ctrDecimal: ctrDecimal,
-                scope: 'query+page',
-                pageUsed: normalizedPageUrl
-              };
-            }
-          }
-        }
-
-        // Second try: match by keyword only (query-only scope)
-        const keywordMatches = queryPages.filter(p => {
-          const pKeyword = (p.query || '').toLowerCase().trim();
-          return pKeyword === normalizedKeyword;
-        });
-
-        if (keywordMatches.length > 0) {
-          let totalImpressions = 0;
-          let totalClicks = 0;
-          keywordMatches.forEach(m => {
-            totalImpressions += (m.impressions || 0);
-            totalClicks += (m.clicks || 0);
-          });
-
-          if (totalImpressions > 0) {
-            const ctrDecimal = totalClicks / totalImpressions;
-            return {
-              clicks: totalClicks,
-              impressions: totalImpressions,
-              ctrDecimal: ctrDecimal,
-              scope: 'query-only',
-              pageUsed: null
-            };
-          }
-        }
-
-        // Third try: match by URL only (page-only scope)
-        if (normalizedPageUrl) {
-          const urlMatches = queryPages.filter(p => {
-            const pPage = normalizeGscPageUrl(p.page || p.url || '');
-            return pPage === normalizedPageUrl;
-          });
-
-          if (urlMatches.length > 0) {
-            let totalImpressions = 0;
-            let totalClicks = 0;
-            urlMatches.forEach(m => {
-              totalImpressions += (m.impressions || 0);
-              totalClicks += (m.clicks || 0);
-            });
-
-            if (totalImpressions > 0) {
-              const ctrDecimal = totalClicks / totalImpressions;
-              return {
-                clicks: totalClicks,
-                impressions: totalImpressions,
-                ctrDecimal: ctrDecimal,
-                scope: 'page-only',
-                pageUsed: normalizedPageUrl
-              };
-            }
-          }
-        }
-
-        // No data found
-        return null;
-      } catch (err) {
-        console.error('Error getting GSC metrics for keyword row:', err);
-        return null;
-      }
-    }
-
-    /**
-     * Get CTR metrics for a keyword from GSC audit data
-     * @deprecated Use getGscMetricsForKeywordRow instead for consistent behavior
-     * @param {Object} key - Object with keyword and url
-     * @returns {Object|null} CTR metrics or null if not found
-     */
-    function getCtrMetricsForKeyword(key) {
-      // Use unified helper for consistency
-      const metrics = getGscMetricsForKeywordRow({
-        query: key.keyword,
-        pageUrl: key.url
-      });
-
-      if (!metrics) {
-        return null;
-      }
-
-      // Return in legacy format for backward compatibility
-      return {
-        ctr: metrics.ctrDecimal,
-        impressions: metrics.impressions,
-        clicks: metrics.clicks
-      };
-    }
-
-    /**
-     * Get position bucket from rank
-     * @param {number|null} rank - Ranking position
-     * @returns {string} Position bucket: 'top3', '4-10', '11-20', or '20+'
-     */
-    function getPositionBucket(rank) {
-      if (rank == null) return '20+';
-      if (rank <= 3) return 'top3';
-      if (rank <= 10) return '4-10';
-      if (rank <= 20) return '11-20';
-      return '20+';
-    }
-
-    /**
-     * Get expected CTR benchmark for a position bucket
-     * @param {string} positionBucket - Position bucket: 'top3', '4-10', '11-20', or '20+'
-     * @returns {number} Expected CTR as decimal (e.g., 0.15 for 15%)
-     */
-    function getCtrBenchmarkForPosition(positionBucket) {
-      // Industry benchmarks for CTR by position
-      const benchmarks = {
-        'top3': 0.15,    // ~15% CTR for positions 1-3
-        '4-10': 0.05,   // ~5% CTR for positions 4-10
-        '11-20': 0.02,  // ~2% CTR for positions 11-20
-        '20+': 0.01     // ~1% CTR for positions 21+
-      };
-      return benchmarks[positionBucket] || 0.01;
-    }
-
-    /**
-     * Normalize URL by stripping query parameters, hash, and trailing slashes
-     * Returns just the pathname for matching
-     */
-    function normalizeUrlForMatching(url) {
-      if (!url || typeof url !== 'string') return '';
-      
-      // Explicitly strip everything from ? onwards (query parameters) and # onwards (hash)
-      // This ensures URLs with Google SERP params like ?srsltid=... are matched correctly
-      let cleanUrl = url.split('?')[0].split('#')[0];
-      
-      let normalized = cleanUrl.toLowerCase().trim();
-      try {
-        // Handle relative URLs by adding a base URL
-        let urlToParse = normalized;
-        if (!normalized.startsWith('http://') && !normalized.startsWith('https://')) {
-          urlToParse = 'https://www.alanranger.com' + (normalized.startsWith('/') ? normalized : '/' + normalized);
-        }
-        const urlObj = new URL(urlToParse);
-        // pathname automatically excludes query params and hash, but we already stripped them above
-        normalized = urlObj.pathname.toLowerCase().replace(/\/$/, '').trim();
-        // If pathname is empty or just '/', treat as homepage
-        if (!normalized || normalized === '/') {
-          normalized = '/';
-        }
-      } catch (e) {
-        // If URL parsing fails, use the manually cleaned URL
-        normalized = cleanUrl.toLowerCase().replace(/\/$/, '').trim();
-        // Ensure it starts with / if it's a path
-        if (normalized && !normalized.startsWith('/')) {
-          normalized = '/' + normalized;
-        }
-        if (!normalized || normalized === '/') {
-          normalized = '/';
-        }
-      }
-      return normalized;
-    }
-
-    async function getSchemaCoverageForUrl(url) {
-      try {
-        // Get audit data from localStorage using loadAuditResultsSync
-        let savedAudit = loadAuditResultsSync();
-        if (!savedAudit) {
-          debugLog('[Schema Coverage] No saved audit found in localStorage', 'warn');
-          return null;
-        }
-        if (!savedAudit.schemaAudit || !savedAudit.schemaAudit.data) {
-          debugLog('[Schema Coverage] No schemaAudit.data in saved audit', 'warn');
-          return null;
-        }
-
-        let schemaData = savedAudit.schemaAudit.data;
-        // Check both pages and pagesWithSchema arrays
-        let pagesArray = schemaData.pages || [];
-        let pagesWithSchema = schemaData.pagesWithSchema || [];
-        
-        // Use pages array if available (more reliable), otherwise use pagesWithSchema
-        let allPages = Array.isArray(pagesArray) && pagesArray.length > 0 ? pagesArray : 
-                       (Array.isArray(pagesWithSchema) && pagesWithSchema.length > 0 ? pagesWithSchema : []);
-        
-        // Normalize the input URL first to use for matching
-        const normalizedUrl = normalizeUrlForMatching(url);
-        debugLog('[Schema Coverage] Looking for normalized URL: ' + normalizedUrl + ' (original: ' + url + ')', 'info');
-        
-        // Try to find the page in the current array
-        let pageData = allPages.find(p => {
-          if (!p || !p.url) return false;
-          const pNormalized = normalizeUrlForMatching(p.url);
-          const exactMatch = pNormalized === normalizedUrl;
-          const homepageMatch = (normalizedUrl === '/' || normalizedUrl === '') && (pNormalized === '/' || pNormalized === '');
-          return exactMatch || homepageMatch;
-        });
-        
-        const domPropertyUrl = document.getElementById('propertyUrl')?.value;
-        const effectivePropertyUrl =
-          domPropertyUrl ||
-          savedAudit.propertyUrl ||
-          localStorage.getItem('gsc_property_url') ||
-          '';
-
-        // If not found and we have a truncated array (200 items), try fetching from Supabase
-        // The API truncates to 200, but the full data exists in Supabase
-        if (!pageData && allPages.length === 200) {
-          debugLog('[Schema Coverage] Page not found in truncated array (200 items), fetching full data from Supabase...', 'info');
-          const propertyUrl = effectivePropertyUrl;
-          try {
-            const supabaseData = await fetchLatestAuditFromSupabase(propertyUrl);
-            if (supabaseData && supabaseData.schemaAudit && supabaseData.schemaAudit.data) {
-              schemaData = supabaseData.schemaAudit.data;
-              pagesArray = schemaData.pages || [];
-              pagesWithSchema = schemaData.pagesWithSchema || [];
-              const supabasePages = Array.isArray(pagesArray) && pagesArray.length > 0 ? pagesArray : 
-                                   (Array.isArray(pagesWithSchema) && pagesWithSchema.length > 0 ? pagesWithSchema : []);
-              debugLog('[Schema Coverage] Loaded schema data from Supabase (' + supabasePages.length + ' pages, may still be truncated)', 'info');
-              
-              // Search in the Supabase data (may still be truncated, but worth trying)
-              if (supabasePages.length > 0) {
-                pageData = supabasePages.find(p => {
-                  if (!p || !p.url) return false;
-                  const pNormalized = normalizeUrlForMatching(p.url);
-                  const exactMatch = pNormalized === normalizedUrl;
-                  const homepageMatch = (normalizedUrl === '/' || normalizedUrl === '') && (pNormalized === '/' || pNormalized === '');
-                  return exactMatch || homepageMatch;
-                });
-                
-                if (pageData) {
-                  debugLog('[Schema Coverage] ‚úÖ Found page in Supabase data', 'success');
-                  allPages = supabasePages;
-                } else if (supabasePages.length === 200) {
-                  debugLog('[Schema Coverage] ‚ö†Ô∏è Supabase data also truncated to 200 items. Querying full data from API...', 'info');
-                  // Try the dedicated API endpoint that searches the full JSONB field
-                  try {
-                    const propertyUrl = effectivePropertyUrl;
-                    const urlHelper = window.apiUrl || ((path) => {
-                      const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || !window.location.hostname;
-                      const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
-                      const cleanPath = path.startsWith('/') ? path : `/${path}`;
-                      return `${baseUrl}${cleanPath}`;
-                    });
-                    const apiUrl = urlHelper(`/api/supabase/get-schema-for-url?propertyUrl=${encodeURIComponent(propertyUrl)}&searchUrl=${encodeURIComponent(url)}`);
-                    const apiRes = await fetch(apiUrl);
-                    if (apiRes.ok) {
-                      const apiData = await apiRes.json();
-                      if (apiData.status === 'ok' && apiData.data) {
-                        pageData = apiData.data;
-                        debugLog('[Schema Coverage] ‚úÖ Found page in full Supabase data via API', 'success');
-                      } else {
-                        debugLog('[Schema Coverage] API returned: ' + (apiData.message || 'no data'), 'warn');
-                      }
-                    } else {
-                      debugLog('[Schema Coverage] API request failed: ' + apiRes.status, 'warn');
-                    }
-                  } catch (apiErr) {
-                    debugLog('[Schema Coverage] API request error: ' + apiErr.message, 'warn');
-                  }
-                }
-              }
-            }
-          } catch (e) {
-            debugLog('[Schema Coverage] Failed to fetch from Supabase: ' + e.message, 'warn');
-          }
-        }
-        
-        // If still not found, check if pagesWithSchema is just a count (not an array)
-        if (!pageData && allPages.length === 0 && typeof pagesWithSchema === 'number') {
-          debugLog('[Schema Coverage] pagesWithSchema is a count in localStorage, trying Supabase...', 'warn');
-          const propertyUrl = effectivePropertyUrl;
-          try {
-            const supabaseData = await fetchLatestAuditFromSupabase(propertyUrl);
-            if (supabaseData && supabaseData.schemaAudit && supabaseData.schemaAudit.data) {
-              schemaData = supabaseData.schemaAudit.data;
-              pagesArray = schemaData.pages || [];
-              pagesWithSchema = schemaData.pagesWithSchema || [];
-              const supabasePages = Array.isArray(pagesArray) && pagesArray.length > 0 ? pagesArray : 
-                                   (Array.isArray(pagesWithSchema) && pagesWithSchema.length > 0 ? pagesWithSchema : []);
-              debugLog('[Schema Coverage] Loaded detailed schema data from Supabase (' + supabasePages.length + ' pages)', 'info');
-              // Update localStorage with the correct structure
-              savedAudit.schemaAudit.data = schemaData;
-              safeSetLocalStorage('last_audit_results', savedAudit);
-              if (supabasePages.length > 0) {
-                allPages = supabasePages;
-                // Try to find the page in the newly loaded data
-                pageData = allPages.find(p => {
-                  if (!p || !p.url) return false;
-                  const pNormalized = normalizeUrlForMatching(p.url);
-                  const exactMatch = pNormalized === normalizedUrl;
-                  const homepageMatch = (normalizedUrl === '/' || normalizedUrl === '') && (pNormalized === '/' || pNormalized === '');
-                  return exactMatch || homepageMatch;
-                });
-
-                // If still not found and we only have a truncated 200-page array, query full JSONB via API
-                if (!pageData && allPages.length === 200) {
-                  debugLog('[Schema Coverage] Still not found after Supabase load (200 items). Querying full data from API...', 'info');
-                  try {
-                    const urlHelper = window.apiUrl || ((path) => {
-                      const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || !window.location.hostname;
-                      const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
-                      const cleanPath = path.startsWith('/') ? path : `/${path}`;
-                      return `${baseUrl}${cleanPath}`;
-                    });
-                    const apiUrl = urlHelper(`/api/supabase/get-schema-for-url?propertyUrl=${encodeURIComponent(propertyUrl)}&searchUrl=${encodeURIComponent(url)}`);
-                    const apiRes = await fetch(apiUrl);
-                    if (apiRes.ok) {
-                      const apiData = await apiRes.json();
-                      if (apiData.status === 'ok' && apiData.data) {
-                        pageData = apiData.data;
-                        debugLog('[Schema Coverage] ‚úÖ Found page in full Supabase data via API', 'success');
-                      } else {
-                        debugLog('[Schema Coverage] API returned: ' + (apiData.message || 'no data'), 'warn');
-                      }
-                    } else {
-                      debugLog('[Schema Coverage] API request failed: ' + apiRes.status, 'warn');
-                    }
-                  } catch (apiErr) {
-                    debugLog('[Schema Coverage] API request error: ' + apiErr.message, 'warn');
-                  }
-                }
-              }
-            }
-          } catch (e) {
-            debugLog('[Schema Coverage] Failed to fetch from Supabase: ' + e.message, 'warn');
-          }
-        }
-        
-        if (!Array.isArray(allPages) || allPages.length === 0) {
-          debugLog('[Schema Coverage] No pages array available (length: ' + (Array.isArray(allPages) ? allPages.length : 'not array') + ')', 'warn');
-          debugLog('[Schema Coverage] This usually means the schema audit hasn\'t been run yet, or the data is missing from localStorage/Supabase.', 'info');
-          return null;
-        }
-
-        // If pageData wasn't found yet, search in allPages
-        if (!pageData) {
-          pageData = allPages.find(p => {
-            if (!p || !p.url) return false;
-            const pNormalized = normalizeUrlForMatching(p.url);
-            
-            // Exact match after normalization (both URLs stripped of query params, hash, trailing slashes)
-            const exactMatch = pNormalized === normalizedUrl;
-            
-            // For homepage, also check if both are '/' or empty
-            const homepageMatch = (normalizedUrl === '/' || normalizedUrl === '') && (pNormalized === '/' || pNormalized === '');
-            
-            if (exactMatch || homepageMatch) {
-              debugLog('[Schema Coverage] ‚úÖ Exact URL match: ' + p.url + ' -> ' + pNormalized + ' (search: ' + normalizedUrl + ')', 'info');
-              return true;
-            }
-            return false;
-          });
-        }
-
-        if (!pageData) {
-          // Enhanced debugging: show sample URLs and search for similar URLs
-          debugLog('[Schema Coverage] ‚ùå No page data found for URL: ' + url, 'warn');
-          debugLog('[Schema Coverage] Normalized search URL: ' + normalizedUrl, 'warn');
-          debugLog('[Schema Coverage] Total pages in array: ' + allPages.length, 'warn');
-          if (allPages.length > 0) {
-            debugLog('[Schema Coverage] Sample URLs in pages array (first 10):', 'warn');
-            allPages.slice(0, 10).forEach((p, idx) => {
-              const pNorm = normalizeUrlForMatching(p.url);
-              debugLog(`  ${idx + 1}. ${p.url} -> ${pNorm}`, 'warn');
-            });
-            // Try to find similar URLs (contains photography-courses or courses-coventry)
-            const similarUrls = allPages.filter(p => {
-              const pNorm = normalizeUrlForMatching(p.url);
-              return pNorm.includes('photography-courses') || 
-                     pNorm.includes('courses-coventry') ||
-                     normalizedUrl.includes(pNorm.split('/').pop() || '') ||
-                     (pNorm.split('/').pop() || '').includes(normalizedUrl.split('/').pop() || '');
-            });
-            if (similarUrls.length > 0) {
-              debugLog('[Schema Coverage] Found similar URLs that might match:', 'warn');
-              similarUrls.forEach((p, idx) => {
-                const pNorm = normalizeUrlForMatching(p.url);
-                debugLog(`  ${idx + 1}. ${p.url} -> ${pNorm}`, 'warn');
-              });
-            }
-          }
-          return null;
-        }
-        
-        if (!pageData.schemaTypes) {
-          debugLog('[Schema Coverage] ‚ö† Page found but no schemaTypes: ' + pageData.url, 'warn');
-          return null;
-        }
-
-        // Extract schema types from array
-        const schemaTypes = Array.isArray(pageData.schemaTypes) ? pageData.schemaTypes : [];
-        
-        // Check for specific schema types (case-insensitive)
-        const typeStrings = schemaTypes.map(t => {
-          if (typeof t === 'string') return t.toLowerCase();
-          if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type.toLowerCase();
-          return String(t).toLowerCase();
-        }).filter(t => t && t !== '[object object]');
-        
-        return {
-          hasFAQ: typeStrings.some(t => t.includes('faq') || t === 'faqpage'),
-          hasHowTo: typeStrings.some(t => t.includes('howto') || t === 'howto'),
-          hasEvent: typeStrings.some(t => t.includes('event') && !t.includes('product')),
-          hasProduct: typeStrings.some(t => t.includes('product')),
-          hasBreadcrumb: typeStrings.some(t => t.includes('breadcrumb') || t === 'breadcrumblist'),
-          hasImageObject: typeStrings.some(t => t.includes('image') || t === 'imageobject'),
-          schemaTypes: schemaTypes,
-          url: pageData.url
-        };
-      } catch (err) {
-        console.error('Error getting schema coverage:', err);
-        return null;
-      }
-    }
-
-    /**
-     * Render Keyword Priority Matrix (3x3 grid: Impact √ó Difficulty)
-     * @param {Array} filteredRows - Filtered keyword rows
-     * @param {HTMLElement} container - Container element
-     * @param {Function} onCellClick - Callback(filter)
-     */
-    function renderKeywordPriorityMatrix(filteredRows, container, onCellClick) {
-      if (!filteredRows || !filteredRows.length) {
-        container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b;">No keyword data available.</div>';
-        return;
-      }
-
-      // Calculate impact and difficulty for each row
-      const rowsWithBuckets = filteredRows.map(row => ({
-        ...row,
-        impact: calculateImpactBucket(row.demand_share || 0),
-        difficulty: calculateDifficultyBucket(row.best_rank_group)
-      }));
-
-      // Calculate total demand share for percentages
-      const totalDemandShare = filteredRows.reduce((sum, r) => {
-        const share = r.demand_share || 0;
-        return sum + share;
-      }, 0) || 0.0001; // Avoid division by zero
-      
-      // Calculate total search volume for debug logging
-      const totalSearchVolume = filteredRows.reduce((sum, r) => {
-        const vol = r.search_volume || 0;
-        return sum + (vol > 0 ? vol : 0);
-      }, 0);
-
-      const impacts = ['high', 'medium', 'low'];
-      const difficulties = ['low', 'medium', 'high'];
-
-      let html = `
-        <div class="matrix-header" style="margin-bottom: 1rem;">
-          <div class="axis-label impact" style="text-align: center; font-weight: 600; font-size: 1.1rem; margin-bottom: 0.5rem; color: #1e293b;">Impact ‚Üë</div>
-          <div class="matrix-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem;">
-      `;
-
-      for (const impact of impacts) {
-        for (const difficulty of difficulties) {
-          const cellRows = rowsWithBuckets.filter(
-            r => r.impact === impact && r.difficulty === difficulty
-          );
-          const count = cellRows.length;
-          // Sum demand_share (0-1) for keywords in this cell
-          const demandShareSum = cellRows.reduce((sum, r) => {
-            const share = r.demand_share || 0;
-            return sum + share;
-          }, 0);
-          // Convert to percentage
-          const demandSharePct = totalDemandShare > 0 ? (demandShareSum / totalDemandShare) * 100 : 0;
-          
-          // Calculate average opportunity score for this cell
-          const totalOpportunityScore = cellRows.reduce((sum, r) => {
-            const score = r.opportunityScore ?? 0;
-            return sum + score;
-          }, 0);
-          const avgOpportunityScore = count > 0 ? totalOpportunityScore / count : 0;
-
-          // Background intensity based on avgOpportunityScore
-          let backgroundColor;
-          if (avgOpportunityScore >= 70) {
-            backgroundColor = '#dcfce7'; // Strong green highlight (High)
-          } else if (avgOpportunityScore >= 40) {
-            backgroundColor = '#fef3c7'; // Medium amber highlight (Medium)
-          } else {
-            backgroundColor = '#f9fafb'; // Light/neutral background (Low)
-          }
-          
-          // RAG styling: High impact + Low/Medium difficulty = high priority (green)
-          const ragClass =
-            impact === 'high' && (difficulty === 'low' || difficulty === 'medium') ? 'rag-high' :
-            impact === 'high' && difficulty === 'high' ? 'rag-medium' :
-            'rag-low';
-          
-          // Check if this cell is active
-          const isActive = rankingPriorityFilter && 
-            rankingPriorityFilter.impact === impact && 
-            rankingPriorityFilter.difficulty === difficulty;
-          
-          // Active state styling
-          const borderColor = isActive 
-            ? '#2563eb' 
-            : (ragClass === 'rag-high' ? '#10b981' : ragClass === 'rag-medium' ? '#f59e0b' : '#e5e7eb');
-          const borderWidth = isActive ? '4px' : '2px';
-          
-          // Override background color if active
-          if (isActive) {
-            backgroundColor = '#dbeafe';
-          }
-
-          html += `
-            <button
-              class="matrix-cell ${ragClass} ${isActive ? 'active' : ''}"
-              data-impact="${impact}"
-              data-difficulty="${difficulty}"
-              type="button"
-              style="padding: 1.25rem; border: ${borderWidth} solid ${borderColor}; border-radius: 8px; background: ${backgroundColor}; cursor: pointer; text-align: center; transition: all 0.2s; box-shadow: ${isActive ? '0 4px 8px rgba(37, 99, 235, 0.3)' : 'none'};"
-              onmouseover="this.style.transform='scale(1.05)'"
-              onmouseout="this.style.transform='scale(1)'"
-              title="${impact.toUpperCase()} / ${difficulty.toUpperCase()}"
-            >
-              <div class="cell-title" style="font-weight: 600; font-size: 0.9rem; margin-bottom: 0.5rem; color: #64748b; text-transform: uppercase;">${impact.toUpperCase()} / ${difficulty.toUpperCase()}</div>
-              <div class="cell-count" style="font-size: 1.5rem; font-weight: 700; color: #1e293b; margin-bottom: 0.25rem;">${count}</div>
-              <div class="cell-share" style="font-size: 0.9rem; color: #64748b; font-weight: 500;">${demandSharePct.toFixed(1)}% of demand</div>
-            </button>
-          `;
-        }
-      }
-
-      html += `
-          </div>
-          <div class="axis-label difficulty" style="text-align: center; font-weight: 600; font-size: 1.1rem; margin-top: 0.5rem; color: #1e293b;">Difficulty ‚Üí</div>
-        </div>
-      `;
-
-      container.innerHTML = html;
-
-      // Wire up click handlers
-      container.querySelectorAll('.matrix-cell').forEach(btn => {
-        btn.addEventListener('click', () => {
-          const impact = btn.getAttribute('data-impact');
-          const difficulty = btn.getAttribute('data-difficulty');
-          
-          // Toggle: if clicking the same cell, clear filter; otherwise set it
-          if (rankingPriorityFilter && 
-              rankingPriorityFilter.impact === impact && 
-              rankingPriorityFilter.difficulty === difficulty) {
-            rankingPriorityFilter = null;
-            selectedKeywordId = null; // Clear selection when clearing filter
-          } else {
-            rankingPriorityFilter = { impact, difficulty };
-          }
-          
-          debugLog(`[RankingAI Scorecard] Priority grid cell clicked - impact: ${impact}, difficulty: ${difficulty}`, 'info');
-          
-          if (onCellClick) onCellClick(rankingPriorityFilter);
-          
-          // After filter is applied, check if exactly one row matches and auto-select it
-          setTimeout(async () => {
-            const { combinedRows } = RankingAiModule.state();
-            const filteredAfterClick = applyRankingFilters(combinedRows);
-            if (filteredAfterClick.length === 1) {
-              const singleRow = filteredAfterClick[0];
-              selectedKeywordId = `${singleRow.keyword}|${singleRow.best_url || ''}`;
-              debugLog(`[RankingAI Scorecard] Auto-selecting single matching keyword: "${singleRow.keyword}"`, 'info');
-              await renderKeywordScorecard(singleRow);
-              // Also update table row selection
-              const tbody = document.getElementById("ranking-ai-table-body");
-              if (tbody) {
-                tbody.querySelectorAll("tr").forEach(tr => {
-                  tr.classList.remove("ranking-table-row--selected");
-                  const idx = Number(tr.dataset.index || "-1");
-                  if (!Number.isNaN(idx) && combinedRows[idx] === singleRow) {
-                    tr.classList.add("ranking-table-row--selected");
-                  }
-                });
-              }
-            } else {
-              selectedKeywordId = null; // Clear selection if multiple or no rows
-            }
-          }, 100); // Small delay to ensure renderRankingAiTab has completed
-        });
-      });
-
-      // Debug logging
-      debugLog(`[Keyword Priority Matrix] Rendered matrix with ${filteredRows.length} filtered rows`, 'info');
-      rowsWithBuckets.forEach(row => {
-        debugLog(`[Keyword Priority Matrix] "${row.keyword}": impact=${row.impact}, difficulty=${row.difficulty}, demand_share=${((row.demand_share || 0) * 100).toFixed(1)}%, rank=${row.best_rank_group ?? 'null'}`, 'info');
-      });
-      
-      // Log cell totals
-      for (const impact of impacts) {
-        for (const difficulty of difficulties) {
-          const cellRows = rowsWithBuckets.filter(r => r.impact === impact && r.difficulty === difficulty);
-          const demandShareSum = cellRows.reduce((sum, r) => sum + ((r.search_volume && r.search_volume > 0 ? r.search_volume : 0)), 0);
-          const demandSharePct = totalSearchVolume > 0 ? (demandShareSum / totalSearchVolume) * 100 : 0;
-          debugLog(`[Keyword Priority Matrix] Cell ${impact}/${difficulty}: count=${cellRows.length}, demand_share=${demandSharePct.toFixed(1)}%`, 'info');
-        }
-      }
-    }
-
-    // Rank normalization helper
-    function normalizeRank(rank) {
-      const r = Number(rank);
-      if (!Number.isFinite(r) || r <= 0) return null; // treat missing/unranked
-      return r;
-    }
-
-    // Apply filters to rows
-    function applyRankingFilters(rows, excludeFilter = null) {
-      return rows.filter(row => {
-        // Segment filter (normalize to lowercase for comparison)
-        if (excludeFilter !== 'segment' && rankingFilterState.segment !== 'all') {
-          const rowSegment = (row.segment || '').toLowerCase();
-          const filterSegment = rankingFilterState.segment.toLowerCase();
-          if (rowSegment !== filterSegment) {
-            return false;
-          }
-        }
-
-        // Rank bucket filter
-        if (excludeFilter !== 'rank' && rankingFilterState.rank !== 'all') {
-          const rank = normalizeRank(row.best_rank_group);
-          if (rankingFilterState.rank === 'top3' && (rank === null || rank > 3)) return false;
-          if (rankingFilterState.rank === '4-10' && (rank === null || rank < 4 || rank > 10)) return false;
-          if (rankingFilterState.rank === '11-20' && (rank === null || rank < 11 || rank > 20)) return false;
-          if (rankingFilterState.rank === '21+' && rank !== null && rank <= 20) return false;
-          if (rankingFilterState.rank === 'not-top3' && rank !== null && rank <= 3) return false;
-        }
-        
-        // Preset-specific rank predicates (when rank filter is 'all' but preset requires specific range)
-        // Note: Most presets now use explicit rank filter values (e.g., 'not-top3'), so this is rarely needed
-        // Keeping for backward compatibility if any presets still use 'all' with predicates
-        if (excludeFilter !== 'rank' && rankingFilterState.rank === 'all' && activePreset) {
-          const rank = normalizeRank(row.best_rank_group);
-          // No preset-specific predicates needed - all presets now use explicit rank filter values
-        }
-
-        // Search volume filter
-        if (excludeFilter !== 'volume' && rankingFilterState.volume !== 'all') {
-          const volume = row.search_volume;
-          if (rankingFilterState.volume === 'high' && (volume == null || volume < 200)) return false;
-          if (rankingFilterState.volume === 'medium' && (volume == null || volume < 50 || volume >= 200)) return false;
-          if (rankingFilterState.volume === 'low' && (volume == null || volume < 1 || volume >= 50)) return false;
-          if (rankingFilterState.volume === 'none' && volume != null && volume > 0) return false;
-          
-        }
-
-        // CTR filter
-        if (excludeFilter !== 'ctr' && rankingFilterState.ctr !== 'all') {
-          // Use canonical targetUrl for CTR metrics
-          const urlForCtr = row.targetUrl || row.ranking_url || '';
-          const ctrMetrics = getCtrMetricsForKeyword({ keyword: row.keyword, url: urlForCtr });
-          const ctr = ctrMetrics && ctrMetrics.ctr != null ? (ctrMetrics.ctr * 100) : null;
-          if (rankingFilterState.ctr === 'high' && (ctr == null || ctr < 5)) return false;
-          if (rankingFilterState.ctr === 'medium' && (ctr == null || ctr < 2 || ctr >= 5)) return false;
-          if (rankingFilterState.ctr === 'low' && (ctr == null || ctr >= 2)) return false;
-          if (rankingFilterState.ctr === 'none' && ctr != null) return false;
-        }
-
-        // Demand share filter removed - replaced with Impressions (30d) column
-
-        // Page type filter
-        if (excludeFilter !== 'pageType' && rankingFilterState.pageType && rankingFilterState.pageType !== 'all') {
-          const rowPageType = row.pageType || 'Landing';
-          if (rowPageType !== rankingFilterState.pageType) {
-            return false;
-          }
-        }
-
-        // SERP features filter
-        if (excludeFilter !== 'serpFeatures' && rankingFilterState.serpFeatures !== 'all') {
-          const hasAiOverview = row.ai_overview_present_any === true;
-          const hasLocalPack = row.local_pack_present_any === true;
-          const hasPaa = row.paa_present_any === true;
-          const hasFeaturedSnippet = row.featured_snippet_present_any === true;
-          if (rankingFilterState.serpFeatures === 'ai-overview' && !hasAiOverview) return false;
-          if (rankingFilterState.serpFeatures === 'local-pack' && !hasLocalPack) return false;
-          if (rankingFilterState.serpFeatures === 'paa' && !hasPaa) return false;
-          if (rankingFilterState.serpFeatures === 'featured-snippet' && !hasFeaturedSnippet) return false;
-          if (rankingFilterState.serpFeatures === 'none' && (hasAiOverview || hasLocalPack || hasPaa || hasFeaturedSnippet)) return false;
-        }
-
-        // AI Overview filter
-        if (excludeFilter !== 'aiOverview' && rankingFilterState.aiOverview !== 'all') {
-          if (rankingFilterState.aiOverview === 'has' && !row.has_ai_overview) return false;
-          if (rankingFilterState.aiOverview === 'no' && row.has_ai_overview) return false;
-        }
-
-        // AI Citation filter
-        if (excludeFilter !== 'aiCitation' && rankingFilterState.aiCitation !== 'all') {
-          const isCited = row.ai_alan_citations_count > 0;
-          if (rankingFilterState.aiCitation === 'cited' && !isCited) return false;
-          if (rankingFilterState.aiCitation === 'not-cited' && isCited) return false;
-        }
-
-        // Opportunity band constants
-        const OP_BANDS = {
-          highMin: 70,
-          mediumMin: 40
-        };
-
-        // Opportunity Score filter
-        if (excludeFilter !== 'opportunity' && rankingFilterState.opportunity !== 'all') {
-          const oppScore = row.opportunityScore ?? -1; // Treat null as -1 (below low threshold)
-          if (rankingFilterState.opportunity === 'high' && (oppScore < OP_BANDS.highMin || oppScore > 100)) return false;
-          if (rankingFilterState.opportunity === 'medium' && (oppScore < OP_BANDS.mediumMin || oppScore >= OP_BANDS.highMin)) return false;
-          if (rankingFilterState.opportunity === 'low' && (oppScore >= OP_BANDS.mediumMin || oppScore < 0)) return false;
-        }
-
-        // Min opportunity filter (applied after band filter if set)
-        if (rankingFilterState.minOpportunity != null) {
-          const oppScore = Number(row.opportunityScore) || 0;
-          if (oppScore < rankingFilterState.minOpportunity) return false;
-        }
-
-        // Keyword search
-        if (excludeFilter !== 'keyword' && rankingFilterState.keyword) {
-          const kw = rankingFilterState.keyword.toLowerCase();
-          if (!row.keyword.toLowerCase().includes(kw)) return false;
-        }
-
-        // Optimisation status filter
-        if (excludeFilter !== 'optimisationStatus' && rankingFilterState.optimisationStatus !== 'all') {
-          const taskType = 'on_page'; // Default task type
-          const status = window.getOptimisationStatus ? window.getOptimisationStatus(row, taskType) : null;
-          const rowStatus = status && status.status ? status.status : 'not-tracked';
-          
-          if (rankingFilterState.optimisationStatus === 'not-tracked' && rowStatus !== 'not-tracked') return false;
-          if (rankingFilterState.optimisationStatus === 'planned' && rowStatus !== 'planned') return false;
-          if (rankingFilterState.optimisationStatus === 'in_progress' && rowStatus !== 'in_progress') return false;
-          if (rankingFilterState.optimisationStatus === 'monitoring' && rowStatus !== 'monitoring') return false;
-          if (rankingFilterState.optimisationStatus === 'done' && rowStatus !== 'done') return false;
-          if (rankingFilterState.optimisationStatus === 'paused' && rowStatus !== 'paused') return false;
-          if (rankingFilterState.optimisationStatus === 'cancelled' && rowStatus !== 'cancelled') return false;
-        }
-
-        // Priority matrix filter (Impact √ó Difficulty)
-        if (rankingPriorityFilter) {
-          const impact = calculateImpactBucket(row.demand_share || 0);
-          const difficulty = calculateDifficultyBucket(row.best_rank_group);
-          if (impact !== rankingPriorityFilter.impact || difficulty !== rankingPriorityFilter.difficulty) {
-            return false;
-          }
-        }
-
-        return true;
-      });
-    }
-
-    // Sort rows
-    function sortRankingRows(rows) {
-      const sorted = [...rows];
-      sorted.sort((a, b) => {
-        let aVal, bVal;
-        switch (rankingSortState.column) {
-          case 'keyword':
-            aVal = a.keyword.toLowerCase();
-            bVal = b.keyword.toLowerCase();
-            break;
-          case 'segment':
-            aVal = a.segment;
-            bVal = b.segment;
-            break;
-          case 'rank':
-            aVal = a.best_rank_group ?? 999;
-            bVal = b.best_rank_group ?? 999;
-            break;
-          case 'citations':
-            aVal = a.ai_alan_citations_count ?? 0;
-            bVal = b.ai_alan_citations_count ?? 0;
-            break;
-          case 'volume':
-            aVal = a.search_volume ?? 0;
-            bVal = b.search_volume ?? 0;
-            break;
-          case 'ctr':
-            const aCtr = getCtrMetricsForKeyword({ keyword: a.keyword, url: a.ranking_url });
-            const bCtr = getCtrMetricsForKeyword({ keyword: b.keyword, url: b.ranking_url });
-            aVal = (aCtr && aCtr.ctr != null) ? aCtr.ctr : -1; // Put nulls at end
-            bVal = (bCtr && bCtr.ctr != null) ? bCtr.ctr : -1;
-            break;
-          case 'impressions30d':
-            aVal = a.impressions30d ?? -1; // Put nulls at end
-            bVal = b.impressions30d ?? -1;
-            break;
-          case 'opportunityScore':
-            aVal = a.opportunityScore ?? -1; // Put nulls at end
-            bVal = b.opportunityScore ?? -1;
-            break;
-          case 'pageType':
-            aVal = a.pageType || 'Landing';
-            bVal = b.pageType || 'Landing';
-            break;
-          default:
-            return 0;
-        }
-        if (aVal < bVal) return rankingSortState.direction === 'asc' ? -1 : 1;
-        if (aVal > bVal) return rankingSortState.direction === 'asc' ? 1 : -1;
-        
-        // Secondary sort: for high-impact-money, sort by rank (asc) when opportunity scores are equal
-        if (rankingSortState.column === 'opportunityScore' && activePreset === 'high-impact-money') {
-          const aRank = normalizeRank(a.best_rank_group) ?? 999;
-          const bRank = normalizeRank(b.best_rank_group) ?? 999;
-          if (aRank < bRank) return -1;
-          if (aRank > bRank) return 1;
-        }
-        
-        return 0;
-      });
-      return sorted;
-    }
-
-    // Toggle metric pill details
-    function toggleMetricPillDetails(cardId) {
-      const card = document.getElementById(cardId);
-      if (!card) return;
-      
-      const detailsEl = card.querySelector(".metric-pill-details");
-      const toggleEl = card.querySelector(".metric-pill-toggle");
-      
-      if (detailsEl && toggleEl) {
-        const isExpanded = detailsEl.classList.contains("expanded");
-        if (isExpanded) {
-          detailsEl.classList.remove("expanded");
-          toggleEl.textContent = "Show details";
-        } else {
-          detailsEl.classList.add("expanded");
-          toggleEl.textContent = "Hide details";
-        }
-      }
-    }
-
-    // Set all metric pill details to be expanded by default on desktop
-    function expandAllMetricPillDetails() {
-      const pillIds = ['ranking-card-ai-coverage', 'ranking-card-ai-citations', 'ranking-card-top10', 'ranking-card-serp-features'];
-      pillIds.forEach(cardId => {
-        const card = document.getElementById(cardId);
-        if (card) {
-          const detailsEl = card.querySelector(".metric-pill-details");
-          const toggleEl = card.querySelector(".metric-pill-toggle");
-          if (detailsEl && toggleEl && detailsEl.innerHTML.trim() !== '') {
-            detailsEl.classList.add("expanded");
-            toggleEl.textContent = "Hide details";
-          }
-        }
-      });
-    }
-
-    // Update metric pills with RAG
-    function updateMetricPills(filteredRows, allRows) {
-      const totalKeywords = allRows.length;
-      const filteredCount = filteredRows.length;
-      
-      // Check if filters are active (if filtered count differs from total, filters are active)
-      const filtersActive = filteredCount !== totalKeywords;
-      
-      // Use filtered rows if filters are active, otherwise use all rows
-      const rowsToUse = filtersActive ? filteredRows : allRows;
-      const countToUse = filtersActive ? filteredCount : totalKeywords;
-
-      // Tracked keywords (always shows total, but can show filtered count)
-      const trackedCard = document.getElementById("ranking-card-tracked");
-      if (trackedCard) {
-        const valueEl = trackedCard.querySelector(".metric-pill-value[data-field='value']");
-        if (valueEl) {
-          valueEl.textContent = filtersActive 
-            ? `${filteredCount} of ${totalKeywords}` 
-            : totalKeywords.toString();
-        }
-        trackedCard.className = "metric-pill metric-pill--neutral";
-        const statusEl = trackedCard.querySelector(".metric-pill-status[data-field='status']");
-        if (statusEl) statusEl.textContent = "Info only";
-      }
-
-      // Calculate metrics from rowsToUse (filtered if filters active, all if not)
-      const withAiOverview = rowsToUse.filter(r => r.has_ai_overview).length;
-      const withAiCitation = rowsToUse.filter(r => r.ai_alan_citations_count > 0).length;
-      const top10 = rowsToUse.filter(r => r.best_rank_group != null && r.best_rank_group <= 10).length;
-
-      const aiCoveragePct = countToUse > 0 ? Math.round((withAiOverview / countToUse) * 100) : 0;
-      const aiCitationPct = countToUse > 0 ? Math.round((withAiCitation / countToUse) * 100) : 0;
-      const top10Pct = countToUse > 0 ? Math.round((top10 / countToUse) * 100) : 0;
-
-      // AI Overview coverage
-      const coverageCard = document.getElementById("ranking-card-ai-coverage");
-      if (coverageCard) {
-        const valueEl = coverageCard.querySelector(".metric-pill-value[data-field='value']");
-        const statusEl = coverageCard.querySelector(".metric-pill-status[data-field='status']");
-        const detailsEl = coverageCard.querySelector(".metric-pill-details");
-        if (valueEl) valueEl.textContent = `${withAiOverview}/${countToUse} (${aiCoveragePct}%)`;
-        
-        let ragClass = 'red';
-        let statusLabel = 'Low';
-        if (aiCoveragePct >= 80) { ragClass = 'green'; statusLabel = 'Strong'; }
-        else if (aiCoveragePct >= 40) { ragClass = 'amber'; statusLabel = 'Moderate'; }
-        
-        coverageCard.className = `metric-pill metric-pill--${ragClass}`;
-        if (statusEl) statusEl.textContent = statusLabel;
-        
-        // Update details
-        if (detailsEl) {
-          const withoutOverview = countToUse - withAiOverview;
-          const pctWithoutOverview = countToUse > 0 ? Math.round((withoutOverview / countToUse) * 100) : 0;
-          detailsEl.innerHTML = `
-            <p class="tile-details-title">How often any AI Overview appears for your tracked keywords.</p>
-            <ul class="tile-details-list">
-              <li>
-                <strong>With AI Overview:</strong> ${withAiOverview}/${countToUse} (${aiCoveragePct}%)
-              </li>
-              <li>
-                <strong>Without AI Overview:</strong> ${withoutOverview}/${countToUse} (${pctWithoutOverview}%)
-              </li>
-            </ul>
-            <p class="tile-details-footnote">
-              Counted per keyword. It does not matter which domains are cited.
-            </p>
-          `;
-        }
-      }
-
-      // AI Citations
-      const citationsCard = document.getElementById("ranking-card-ai-citations");
-      if (citationsCard) {
-        const valueEl = citationsCard.querySelector(".metric-pill-value[data-field='value']");
-        const statusEl = citationsCard.querySelector(".metric-pill-status[data-field='status']");
-        const detailsEl = citationsCard.querySelector(".metric-pill-details");
-        if (valueEl) valueEl.textContent = `${withAiCitation}/${countToUse} (${aiCitationPct}%)`;
-        
-        let ragClass = 'red';
-        let statusLabel = 'Not cited';
-        if (aiCitationPct >= 60) { ragClass = 'green'; statusLabel = 'Strong'; }
-        else if (aiCitationPct >= 30) { ragClass = 'amber'; statusLabel = 'Some'; }
-        
-        citationsCard.className = `metric-pill metric-pill--${ragClass}`;
-        if (statusEl) statusEl.textContent = statusLabel;
-        
-        // Calculate total citations
-        const totalCitations = rowsToUse.reduce((sum, r) => sum + (r.ai_alan_citations_count || 0), 0);
-        
-        // Calculate withOverviewNoCitation (keywords with AI Overview but no alanranger.com citation)
-        const withOverviewNoCitation = rowsToUse.filter(r => r.has_ai_overview && r.ai_alan_citations_count === 0).length;
-        const pctWithOverviewNoCitation = countToUse > 0 ? Math.round((withOverviewNoCitation / countToUse) * 100) : 0;
-        
-        // Update details
-        if (detailsEl) {
-          detailsEl.innerHTML = `
-            <p class="tile-details-title">
-              How often alanranger.com is actually cited inside the AI Overview.
-            </p>
-            <ul class="tile-details-list">
-              <li>
-                <strong>Keywords with citations:</strong> ${withAiCitation}/${countToUse} (${aiCitationPct}%)
-              </li>
-              <li>
-                <strong>With AI Overview but no alanranger.com citation:</strong> ${withOverviewNoCitation}/${countToUse} (${pctWithOverviewNoCitation}%)
-              </li>
-              <li>
-                <strong>Total citations across all keywords:</strong> ${totalCitations}
-              </li>
-            </ul>
-            <p class="tile-details-footnote">
-              A single keyword can cite alanranger.com multiple times; all those links are counted in "Total citations".
-            </p>
-          `;
-        }
-      }
-
-      // Top-10 coverage
-      const top10Card = document.getElementById("ranking-card-top10");
-      if (top10Card) {
-        const valueEl = top10Card.querySelector(".metric-pill-value[data-field='value']");
-        const statusEl = top10Card.querySelector(".metric-pill-status[data-field='status']");
-        const detailsEl = top10Card.querySelector(".metric-pill-details");
-        if (valueEl) valueEl.textContent = `${top10}/${countToUse} (${top10Pct}%)`;
-        
-        // Calculate rank buckets
-        const top3 = rowsToUse.filter(r => r.best_rank_group != null && r.best_rank_group <= 3).length;
-        const top3Pct = countToUse > 0 ? Math.round((top3 / countToUse) * 100) : 0;
-        const rank11to20 = rowsToUse.filter(r => r.best_rank_group != null && r.best_rank_group >= 11 && r.best_rank_group <= 20).length;
-        const rank11to20Pct = countToUse > 0 ? Math.round((rank11to20 / countToUse) * 100) : 0;
-        const notRanked = rowsToUse.filter(r => r.best_rank_group == null || r.best_rank_group > 20).length;
-        const notRankedPct = countToUse > 0 ? Math.round((notRanked / countToUse) * 100) : 0;
-        
-        let ragClass = 'red';
-        let statusLabel = 'Weak';
-        if (top10Pct >= 60) { ragClass = 'green'; statusLabel = 'Strong'; }
-        else if (top10Pct >= 30) { ragClass = 'amber'; statusLabel = 'OK'; }
-        
-        top10Card.className = `metric-pill metric-pill--${ragClass}`;
-        if (statusEl) statusEl.textContent = statusLabel;
-        
-        // Calculate top10Only (positions 4-10)
-        const top10Only = top10 - top3;
-        const pctTop10Only = countToUse > 0 ? Math.round((top10Only / countToUse) * 100) : 0;
-        const pct11to20 = countToUse > 0 ? Math.round((rank11to20 / countToUse) * 100) : 0;
-        const pctNotRanked = countToUse > 0 ? Math.round((notRanked / countToUse) * 100) : 0;
-        
-        // Update details
-        if (detailsEl) {
-          detailsEl.innerHTML = `
-            <p class="tile-details-title">
-              Distribution of best classic (blue-link) rankings across your tracked keywords.
-            </p>
-            <ul class="tile-details-list">
-              <li>
-                <strong>Top 3 (positions 1‚Äì3):</strong> ${top3}/${countToUse} (${top3Pct}%)
-              </li>
-              <li>
-                <strong>Positions 4‚Äì10:</strong> ${top10Only}/${countToUse} (${pctTop10Only}%)
-              </li>
-              <li>
-                <strong>Positions 11‚Äì20:</strong> ${rank11to20}/${countToUse} (${pct11to20}%)
-              </li>
-              <li>
-                <strong>Not ranked (21+):</strong> ${notRanked}/${countToUse} (${pctNotRanked}%)
-              </li>
-            </ul>
-            <p class="tile-details-footnote">
-              "Top 3" and "4‚Äì10" together make up your total Top-10 coverage.
-            </p>
-          `;
-        }
-      }
-
-      // SERP feature coverage
-      const serpFeaturesCard = document.getElementById("ranking-card-serp-features");
-      if (serpFeaturesCard) {
-        // Count keywords with each SERP feature
-        const withAiOverview = rowsToUse.filter(r => r.ai_overview_present_any === true || r.has_ai_overview === true).length;
-        const withLocalPack = rowsToUse.filter(r => r.local_pack_present_any === true || (r.serp_features && r.serp_features.local_pack === true)).length;
-        const withPaa = rowsToUse.filter(r => r.paa_present_any === true || (r.serp_features && r.serp_features.people_also_ask === true)).length;
-        const withFeaturedSnippet = rowsToUse.filter(r => r.featured_snippet_present_any === true || (r.serp_features && r.serp_features.featured_snippet === true)).length;
-        
-        // Calculate average feature presence (0-100%)
-        const avgFeaturePresence = countToUse > 0 
-          ? Math.round(((withAiOverview + withLocalPack + withPaa + withFeaturedSnippet) / (countToUse * 4)) * 100)
-          : 0;
-        
-        // Calculate individual percentages
-        const aiOverviewPct = countToUse > 0 ? Math.round((withAiOverview / countToUse) * 100) : 0;
-        const localPackPct = countToUse > 0 ? Math.round((withLocalPack / countToUse) * 100) : 0;
-        const paaPct = countToUse > 0 ? Math.round((withPaa / countToUse) * 100) : 0;
-        const featuredSnippetPct = countToUse > 0 ? Math.round((withFeaturedSnippet / countToUse) * 100) : 0;
-        
-        const valueEl = serpFeaturesCard.querySelector(".metric-pill-value[data-field='value']");
-        const statusEl = serpFeaturesCard.querySelector(".metric-pill-status[data-field='status']");
-        const detailsEl = serpFeaturesCard.querySelector(".metric-pill-details");
-        
-        // Show as "X/4 features (Y%)" format
-        const featuresPresent = [withAiOverview, withLocalPack, withPaa, withFeaturedSnippet].filter(count => count > 0).length;
-        if (valueEl) valueEl.textContent = `${featuresPresent}/4 features (${avgFeaturePresence}%)`;
-        
-        let ragClass = 'red';
-        let statusLabel = 'Low';
-        if (avgFeaturePresence >= 70) { ragClass = 'green'; statusLabel = 'Strong'; }
-        else if (avgFeaturePresence >= 40) { ragClass = 'amber'; statusLabel = 'Moderate'; }
-        
-        serpFeaturesCard.className = `metric-pill metric-pill--${ragClass}`;
-        if (statusEl) statusEl.textContent = statusLabel;
-        
-        // Update details content
-        if (detailsEl) {
-          detailsEl.innerHTML = `
-            <p class="tile-details-title">
-              How often rich SERP features appear for your tracked keywords.
-            </p>
-            <ul class="tile-details-list">
-              <li>
-                <strong>AI Overview present:</strong> ${withAiOverview}/${countToUse} (${aiOverviewPct}%)
-              </li>
-              <li>
-                <strong>Local pack present:</strong> ${withLocalPack}/${countToUse} (${localPackPct}%)
-              </li>
-              <li>
-                <strong>People Also Ask present:</strong> ${withPaa}/${countToUse} (${paaPct}%)
-              </li>
-              <li>
-                <strong>Featured snippet present:</strong> ${withFeaturedSnippet}/${countToUse} (${featuredSnippetPct}%)
-              </li>
-            </ul>
-            <p class="tile-details-footnote">
-              Counts are per keyword. A single SERP can contain multiple features (for example AI Overview + People Also Ask).
-            </p>
-          `;
-        }
-      }
-    }
-
-    // Update filter counts in dropdowns
-    // Counts show how many items match each option given the current state of OTHER filters
-    function updateFilterCounts(rows) {
-      if (!rows || rows.length === 0) return;
-
-      // For each filter, calculate counts based on rows that match all OTHER filters
-      // Segment counts (excluding segment filter)
-      const segmentRows = applyRankingFilters(rows, 'segment');
-      const segmentCounts = { all: segmentRows.length, brand: 0, money: 0, education: 0, other: 0 };
-      segmentRows.forEach(r => {
-        const seg = (r.segment || '').toLowerCase();
-        if (segmentCounts.hasOwnProperty(seg)) segmentCounts[seg]++;
-        else segmentCounts.other++;
-      });
-      updateSelectCounts('ranking-filter-segment', segmentCounts);
-
-      // Rank counts (excluding rank filter)
-      const rankRows = applyRankingFilters(rows, 'rank');
-      const rankCounts = { all: rankRows.length, top3: 0, '4-10': 0, '11-20': 0, '21+': 0, 'not-top3': 0 };
-      rankRows.forEach(r => {
-        const rank = normalizeRank(r.best_rank_group);
-        if (rank !== null && rank <= 3) {
-          rankCounts.top3++;
-        } else {
-          // Count rows that are NOT top 3 (rank > 3 or null)
-          rankCounts['not-top3']++;
-        }
-        if (rank !== null && rank >= 4 && rank <= 10) rankCounts['4-10']++;
-        if (rank !== null && rank >= 11 && rank <= 20) rankCounts['11-20']++;
-        if (rank === null || rank >= 21) rankCounts['21+']++;
-      });
-      updateSelectCounts('ranking-filter-rank', rankCounts);
-
-      // Volume counts (excluding volume filter)
-      const volumeRows = applyRankingFilters(rows, 'volume');
-      const volumeCounts = { all: volumeRows.length, high: 0, medium: 0, low: 0, none: 0 };
-      volumeRows.forEach(r => {
-        const vol = r.search_volume;
-        if (vol == null || vol === 0) volumeCounts.none++;
-        else if (vol < 50) volumeCounts.low++;
-        else if (vol < 200) volumeCounts.medium++;
-        else volumeCounts.high++;
-      });
-      updateSelectCounts('ranking-filter-volume', volumeCounts);
-
-      // CTR counts (excluding CTR filter)
-      const ctrRows = applyRankingFilters(rows, 'ctr');
-      const ctrCounts = { all: ctrRows.length, high: 0, medium: 0, low: 0, none: 0 };
-      ctrRows.forEach(r => {
-        const ctrMetrics = getCtrMetricsForKeyword({ keyword: r.keyword, url: r.ranking_url });
-        const ctr = ctrMetrics && ctrMetrics.ctr != null ? (ctrMetrics.ctr * 100) : null;
-        if (ctr == null) ctrCounts.none++;
-        else if (ctr < 2) ctrCounts.low++;
-        else if (ctr < 5) ctrCounts.medium++;
-        else ctrCounts.high++;
-      });
-      updateSelectCounts('ranking-filter-ctr', ctrCounts);
-
-      // Demand share filter removed - replaced with Impressions (30d) column
-
-      // Opportunity score counts (excluding opportunity filter)
-      const oppRows = applyRankingFilters(rows, 'opportunity');
-      const oppCounts = { all: oppRows.length, high: 0, medium: 0, low: 0 };
-      oppRows.forEach(r => {
-        const opp = r.opportunityScore ?? -1;
-        if (opp >= 70) oppCounts.high++;
-        else if (opp >= 40) oppCounts.medium++;
-        else if (opp >= 0) oppCounts.low++;
-      });
-      updateSelectCounts('ranking-filter-opportunity', oppCounts);
-
-      // AI Overview counts (excluding AI Overview filter)
-      const aiOverviewRows = applyRankingFilters(rows, 'aiOverview');
-      const aiOverviewCounts = { all: aiOverviewRows.length, has: 0, no: 0 };
-      aiOverviewRows.forEach(r => {
-        if (r.has_ai_overview) aiOverviewCounts.has++;
-        else aiOverviewCounts.no++;
-      });
-      updateSelectCounts('ranking-filter-ai-overview', aiOverviewCounts);
-
-      // AI Citation counts (excluding AI Citation filter)
-      const aiCitationRows = applyRankingFilters(rows, 'aiCitation');
-      const aiCitationCounts = { all: aiCitationRows.length, cited: 0, 'not-cited': 0 };
-      aiCitationRows.forEach(r => {
-        if (r.ai_alan_citations_count > 0) aiCitationCounts.cited++;
-        else aiCitationCounts['not-cited']++;
-      });
-      updateSelectCounts('ranking-filter-ai-citation', aiCitationCounts);
-
-      // Page type counts (excluding page type filter)
-      const pageTypeRows = applyRankingFilters(rows, 'pageType');
-      const pageTypeCounts = { all: pageTypeRows.length, GBP: 0, Blog: 0, Landing: 0, Event: 0, Product: 0, Other: 0 };
-      pageTypeRows.forEach(r => {
-        const pt = r.pageType || 'Landing';
-        if (pageTypeCounts.hasOwnProperty(pt)) pageTypeCounts[pt]++;
-        else pageTypeCounts.Other++;
-      });
-      updateSelectCounts('ranking-filter-page-type', pageTypeCounts);
-
-      // SERP features counts (excluding SERP features filter)
-      const serpRows = applyRankingFilters(rows, 'serpFeatures');
-      const serpCounts = { all: serpRows.length, 'ai-overview': 0, 'local-pack': 0, paa: 0, 'featured-snippet': 0, none: 0 };
-      serpRows.forEach(r => {
-        const hasAi = r.ai_overview_present_any === true;
-        const hasLocal = r.local_pack_present_any === true;
-        const hasPaa = r.paa_present_any === true;
-        const hasFeatured = r.featured_snippet_present_any === true;
-        if (hasAi) serpCounts['ai-overview']++;
-        if (hasLocal) serpCounts['local-pack']++;
-        if (hasPaa) serpCounts.paa++;
-        if (hasFeatured) serpCounts['featured-snippet']++;
-        if (!hasAi && !hasLocal && !hasPaa && !hasFeatured) serpCounts.none++;
-      });
-      updateSelectCounts('ranking-filter-serp-features', serpCounts);
-
-      // Optimisation status counts (excluding optimisation status filter)
-      const optimisationRows = applyRankingFilters(rows, 'optimisationStatus');
-      const optimisationCounts = { all: optimisationRows.length, 'not-tracked': 0, 'planned': 0, 'in_progress': 0, 'monitoring': 0, 'done': 0, 'paused': 0, 'cancelled': 0 };
-      optimisationRows.forEach(r => {
-        const taskType = 'on_page'; // Default task type
-        const status = window.getOptimisationStatus ? window.getOptimisationStatus(r, taskType) : null;
-        const rowStatus = status && status.status ? status.status : 'not-tracked';
-        if (optimisationCounts.hasOwnProperty(rowStatus)) {
-          optimisationCounts[rowStatus]++;
-        } else {
-          optimisationCounts['not-tracked']++;
-        }
-      });
-      updateSelectCounts('ranking-filter-optimisation-status', optimisationCounts);
-    }
-
-    function updateSelectCounts(selectId, counts) {
-      const select = document.getElementById(selectId);
-      if (!select) return;
-      // Store original labels (without counts) for each option
-      const originalLabels = {};
-      Array.from(select.options).forEach(opt => {
-        const value = opt.value;
-        if (!originalLabels[value]) {
-          // Store original label (remove existing count if any)
-          originalLabels[value] = opt.textContent.split(' (')[0].trim();
-        }
-      });
-      // Update with counts - ensure ALL options get counts, even if 0
-      Array.from(select.options).forEach(opt => {
-        const value = opt.value;
-        const label = originalLabels[value] || opt.textContent.split(' (')[0].trim();
-        if (counts.hasOwnProperty(value)) {
-          const count = counts[value];
-          opt.textContent = value === 'all' ? `All (${count})` : `${label} (${count})`;
-        } else {
-          // If count not found, show 0 (for options that might not have been in the data)
-          opt.textContent = value === 'all' ? `All (0)` : `${label} (0)`;
-        }
-      });
-    }
-
-    // Helper function to get query-only totals for a keyword (PATCH A2)
-    // Helper function to normalize keywords for matching
-    function normalizeKeywordForMatching(keyword) {
-      if (!keyword) return '';
-      // Normalize: lowercase, trim, collapse multiple spaces to single space
-      return keyword.toLowerCase().trim().replace(/\s+/g, ' ');
-    }
-    
-    function getQueryTotalForKeyword(keyword) {
-      try {
-        const savedAudit = loadAuditResultsSync();
-        if (!savedAudit || !savedAudit.searchData) {
-          debugLog(`getQueryTotalForKeyword: No queryTotals found for "${keyword}" - savedAudit=${!!savedAudit}, searchData=${!!savedAudit?.searchData}`, 'warn');
-          return null;
-        }
-        
-        // CRITICAL: Check if queryTotals exists and handle object vs array
-        let queryTotals = savedAudit.searchData.queryTotals;
-        if (!queryTotals) {
-          debugLog(`getQueryTotalForKeyword: No queryTotals found for "${keyword}" - queryTotals is null/undefined`, 'warn');
-          return null;
-        }
-        
-        // If queryTotals is an object instead of an array, try to convert it
-        if (typeof queryTotals === 'object' && !Array.isArray(queryTotals)) {
-          debugLog(`getQueryTotalForKeyword: queryTotals is an object, not an array. Type: ${typeof queryTotals}, keys: ${Object.keys(queryTotals).join(', ')}`, 'warn');
-          // Try to extract array from object
-          if (Object.keys(queryTotals).every(key => !isNaN(parseInt(key)))) {
-            // Array-like object with numeric keys
-            queryTotals = Object.values(queryTotals);
-            debugLog(`getQueryTotalForKeyword: Converted array-like object to array (${queryTotals.length} items)`, 'info');
-          } else {
-            // Check if there's an array property inside the object
-            for (const key in queryTotals) {
-              if (Array.isArray(queryTotals[key])) {
-                queryTotals = queryTotals[key];
-                debugLog(`getQueryTotalForKeyword: Extracted array from object at key '${key}' (${queryTotals.length} items)`, 'info');
-                break;
-              }
-            }
-          }
-        }
-        
-        if (!Array.isArray(queryTotals)) {
-          debugLog(`getQueryTotalForKeyword: queryTotals is still not an array after conversion attempt. Type: ${typeof queryTotals}`, 'warn');
-          return null;
-        }
-        
-        if (queryTotals.length === 0) {
-          debugLog(`getQueryTotalForKeyword: queryTotals array is empty`, 'warn');
-          return null;
-        }
-        
-        // Normalize the search keyword
-        const normalizedKeyword = normalizeKeywordForMatching(keyword);
-        
-        // Try exact match first (normalized)
-        let queryTotal = queryTotals.find(
-          qt => qt.query && normalizeKeywordForMatching(qt.query) === normalizedKeyword
-        );
-        
-        // If no exact match, try fuzzy matching (check if keyword is contained in query or vice versa)
-        if (!queryTotal) {
-          queryTotal = queryTotals.find(
-            qt => {
-              if (!qt.query) return false;
-              const normalizedQuery = normalizeKeywordForMatching(qt.query);
-              // Check if normalized keyword is contained in normalized query or vice versa
-              return normalizedQuery === normalizedKeyword || 
-                     normalizedQuery.includes(normalizedKeyword) || 
-                     normalizedKeyword.includes(normalizedQuery);
-            }
-          );
-        }
-        
-        if (!queryTotal) {
-          // Enhanced debugging: show sample queries from queryTotals to help diagnose mismatches
-          const sampleQueries = queryTotals.slice(0, 10).map(qt => qt.query || '(no query)').join(', ');
-          debugLog(`getQueryTotalForKeyword: No match found for "${keyword}" (normalized: "${normalizedKeyword}") in ${queryTotals.length} queryTotals. Sample queries: ${sampleQueries}${queryTotals.length > 10 ? '...' : ''}`, 'warn');
-          
-          // Also check if there are any queries with zero impressions (these might be the missing ones)
-          const zeroImpressionQueries = queryTotals.filter(qt => qt.impressions === 0 || qt.impressions == null).slice(0, 5).map(qt => qt.query || '(no query)').join(', ');
-          if (zeroImpressionQueries) {
-            debugLog(`getQueryTotalForKeyword: Found ${queryTotals.filter(qt => qt.impressions === 0 || qt.impressions == null).length} queries with zero impressions. Sample: ${zeroImpressionQueries}`, 'info');
-          }
-        }
-        
-        return queryTotal || null;
-      } catch (error) {
-        debugLog(`Error in getQueryTotalForKeyword: ${error.message}`, 'warn');
-        return null;
-      }
-    }
-
-    async function renderRankingAiTab() {
-      debugLog('üìä renderRankingAiTab() called', 'info');
-      const { combinedRows, summary } = RankingAiModule.state();
-      debugLog(`üìä renderRankingAiTab: combinedRows=${combinedRows?.length || 0}, hasSummary=${!!summary}`, 'info');
-      
-      // Always render table, even if no data (will show empty state)
-      const tbody = document.getElementById("ranking-ai-table-body");
-      if (!tbody) {
-        debugLog('‚ö† renderRankingAiTab: Table body not found', 'warn');
-        return;
-      }
-      
-      if (!summary || !Array.isArray(combinedRows) || combinedRows.length === 0) {
-        debugLog(`‚ö† renderRankingAiTab: No data - summary=${!!summary}, combinedRows is array=${Array.isArray(combinedRows)}, length=${combinedRows?.length || 0}`, 'warn');
-        // Show empty state message
-        tbody.innerHTML = '<tr><td colspan="11" class="ranking-table-empty">Click "Run ranking &amp; AI check" to load data.</td></tr>';
-        const paginationControls = document.getElementById("ranking-pagination-controls");
-        if (paginationControls) paginationControls.style.display = "none";
-        return;
-      }
-      
-      debugLog(`‚úì renderRankingAiTab: Proceeding with ${combinedRows.length} keywords`, 'success');
-
-      // Apply filters first
-      const filteredRows = applyRankingFilters(combinedRows);
-      
-      // Update filter counts based on all rows (before filtering)
-      updateFilterCounts(combinedRows);
-      
-      // Update preset button active states and render criteria chips
-      if (typeof updatePresetButtonActiveStates === 'function') {
-        updatePresetButtonActiveStates();
-      }
-      if (typeof renderPresetCriteriaChips === 'function') {
-        renderPresetCriteriaChips();
-      }
-      
-      // Note: demand_share is no longer recalculated from filtered rows
-      // It remains as originally calculated from all tracked keywords (global-fixed)
-      // Used internally for opportunity score calculation only
-      
-      // Calculate visibility metrics from filtered subset
-      const validRankingRows = filteredRows.filter(
-        r => r.best_rank_group !== null && typeof r.best_rank_group === 'number'
-      );
-      
-      let avgPositionUnweighted = null;
-      let avgPositionVolumeWeighted = null;
-      
-      if (validRankingRows.length >= 1) {
-        // Unweighted average position
-        const sumRanks = validRankingRows.reduce((sum, r) => sum + r.best_rank_group, 0);
-        avgPositionUnweighted = sumRanks / validRankingRows.length;
-        
-        // Demand-weighted average position
-        let sumWeightedRanks = 0;
-        let sumVolumes = 0;
-        
-        for (const row of validRankingRows) {
-          const vol = (row.search_volume !== null && row.search_volume !== undefined && row.search_volume > 0)
-            ? row.search_volume
-            : 10; // Fallback
-          
-          sumWeightedRanks += row.best_rank_group * vol;
-          sumVolumes += vol;
-        }
-        
-        if (sumVolumes > 0) {
-          avgPositionVolumeWeighted = sumWeightedRanks / sumVolumes;
-        }
-      }
-      
-      // Display tracked keyword visibility metrics (DataForSEO only - not part of AIO pillars)
-      const visibilityMetricsSection = document.getElementById('ranking-visibility-metrics');
-      const avgPositionWeightedEl = document.getElementById('ranking-avg-position-weighted');
-      const avgPositionUnweightedEl = document.getElementById('ranking-avg-position-unweighted');
-      
-      if (visibilityMetricsSection) {
-        // Always show the visibility metrics section (it's part of the side-by-side layout)
-        visibilityMetricsSection.style.display = 'block';
-        if (avgPositionVolumeWeighted !== null && avgPositionVolumeWeighted !== undefined) {
-          visibilityMetricsSection.style.display = 'block';
-          if (avgPositionWeightedEl) {
-            avgPositionWeightedEl.textContent = avgPositionVolumeWeighted.toFixed(2);
-          }
-          if (avgPositionUnweightedEl && avgPositionUnweighted !== null && avgPositionUnweighted !== undefined) {
-            avgPositionUnweightedEl.textContent = avgPositionUnweighted.toFixed(2);
-          } else if (avgPositionUnweightedEl) {
-            avgPositionUnweightedEl.textContent = '‚Äî';
-          }
-        } else {
-          visibilityMetricsSection.style.display = 'block';
-          if (avgPositionWeightedEl) {
-            avgPositionWeightedEl.textContent = '‚Äî';
-            avgPositionWeightedEl.title = 'Not enough valid keywords to calculate.';
-          }
-          if (avgPositionUnweightedEl) {
-            avgPositionUnweightedEl.textContent = '‚Äî';
-            avgPositionUnweightedEl.title = 'Not enough valid keywords to calculate.';
-          }
-        }
-      }
-      
-      // Update metric pills from filtered data
-      updateMetricPills(filteredRows, combinedRows);
-      
-      // Expand all metric pill details by default
-      setTimeout(() => expandAllMetricPillDetails(), 100);
-
-      // Render Keyword Priority Matrix
-      const matrixContainer = document.getElementById('ranking-keyword-priority-matrix');
-      const matrixSection = document.getElementById('ranking-priority-matrix-section');
-      if (matrixContainer && filteredRows.length > 0) {
-        if (matrixSection) matrixSection.style.display = 'block';
-        renderKeywordPriorityMatrix(filteredRows, matrixContainer, (filter) => {
-          // Filter changed - re-render table
-          renderRankingAiTab();
-        });
-      } else if (matrixSection) {
-        matrixSection.style.display = 'none';
-      }
-
-      // Sort filtered rows
-      const sortedRows = sortRankingRows(filteredRows);
-      
-      // Calculate pagination
-      const totalRows = sortedRows.length;
-      const rowsPerPage = rankingPaginationState.rowsPerPage === 'all' ? totalRows : rankingPaginationState.rowsPerPage;
-      const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
-      const currentPage = Math.min(Math.max(1, rankingPaginationState.currentPage), totalPages);
-      rankingPaginationState.currentPage = currentPage;
-      
-      const startIdx = rowsPerPage === 'all' ? 0 : (currentPage - 1) * rowsPerPage;
-      const endIdx = rowsPerPage === 'all' ? totalRows : Math.min(startIdx + rowsPerPage, totalRows);
-      const paginatedRows = sortedRows.slice(startIdx, endIdx);
-
-      // -------- Fetch optimisation statuses (Phase 2) --------
-      if (typeof window.fetchOptimisationStatuses === 'function') {
-        await window.fetchOptimisationStatuses(sortedRows);
-      }
-
-      // -------- Keyword table --------
-      // tbody already declared at top of function, just clear it
-      tbody.innerHTML = "";
-
-      if (!sortedRows.length) {
-        const tr = document.createElement("tr");
-        const td = document.createElement("td");
-        td.colSpan = 12; // Updated: 12 columns (Keyword, Segment, Best rank, Search volume, CTR, Impressions (30d), Opportunity score, AI Overview, AI citations, Classic Ranking URL, Page type, SERP features)
-        td.className = "ranking-table-empty";
-        td.textContent = filteredRows.length === 0 && combinedRows.length > 0
-          ? "No rows match the current filters."
-          : "No data returned from ranking / AI endpoints.";
-        tr.appendChild(td);
-        tbody.appendChild(tr);
-        
-        // Hide pagination when no data
-        const paginationControls = document.getElementById("ranking-pagination-controls");
-        if (paginationControls) paginationControls.style.display = "none";
-        return;
-      }
-
-      // Store original index mapping for detail panel
-      const originalIndexMap = new Map();
-      paginatedRows.forEach((row, idx) => {
-        const origIdx = combinedRows.indexOf(row);
-        originalIndexMap.set(idx, origIdx >= 0 ? origIdx : idx);
-      });
-
-      paginatedRows.forEach((row, index) => {
-        try {
-        const tr = document.createElement("tr");
-        tr.dataset.index = String(originalIndexMap.get(index));
-
-        // Keyword
-        const tdKeyword = document.createElement("td");
-        tdKeyword.textContent = row.keyword;
-        tr.appendChild(tdKeyword);
-
-        // Segment
-        const tdSegment = document.createElement("td");
-        const segBadge = document.createElement("span");
-        const segLower = (row.segment || "").toLowerCase();
-        segBadge.className = "ranking-badge " + (
-          segLower === "money" ? "ranking-badge--segment-money" :
-          segLower === "education" ? "ranking-badge--segment-education" :
-          segLower === "brand" ? "ranking-badge--segment-brand" :
-          "ranking-badge--segment-general"
-        );
-        segBadge.textContent = row.segment || "Other";
-        tdSegment.appendChild(segBadge);
-        tr.appendChild(tdSegment);
-
-        // Best rank with RAG badge
-        const tdRank = document.createElement("td");
-        if (row.best_rank_group == null) {
-          const badge = document.createElement("span");
-          badge.className = "ranking-badge-rank ranking-badge-rank--weak";
-          badge.textContent = "‚Äî";
-          tdRank.appendChild(badge);
-        } else {
-          const badge = document.createElement("span");
-          let ragClass = "ranking-badge-rank--weak";
-          if (row.best_rank_group <= 10) ragClass = "ranking-badge-rank--good";
-          else if (row.best_rank_group <= 20) ragClass = "ranking-badge-rank--ok";
-          badge.className = `ranking-badge-rank ${ragClass}`;
-          badge.textContent = `#${row.best_rank_group}`;
-          tdRank.appendChild(badge);
-        }
-        tr.appendChild(tdRank);
-
-        // Search volume with RAG badge
-        const tdVolume = document.createElement("td");
-        const volumeBadge = document.createElement("span");
-        const searchVolume = row.search_volume;
-        // IMPORTANT: Only treat as missing if null/undefined, not if 0 (0 is a valid value)
-        if (searchVolume == null || searchVolume === undefined) {
-          volumeBadge.className = "ranking-badge-volume ranking-badge-volume--none";
-          volumeBadge.textContent = "‚Äî";
-        } else {
-          const formatted = searchVolume.toLocaleString();
-          let ragClass = "ranking-badge-volume--low";
-          let label = "Low";
-          if (searchVolume > 200) {
-            ragClass = "ranking-badge-volume--high";
-            label = "High";
-          } else if (searchVolume > 50) {
-            ragClass = "ranking-badge-volume--med";
-            label = "Med";
-          }
-          volumeBadge.className = `ranking-badge-volume ${ragClass}`;
-          volumeBadge.textContent = `${formatted} ${label}`;
-        }
-        tdVolume.appendChild(volumeBadge);
-        tr.appendChild(tdVolume);
-
-        // CTR (30d) - query-only from queryTotals
-        const tdCtr = document.createElement("td");
-        const queryTotal = getQueryTotalForKeyword(row.keyword);
-        if (queryTotal && queryTotal.impressions > 0 && queryTotal.ctr != null) {
-          // queryTotal.ctr is already a percentage (0-100) from API, not a decimal
-          const ctrPercent = queryTotal.ctr.toFixed(1);
-          tdCtr.textContent = `${ctrPercent}%`;
-          tdCtr.style.color = '#1e293b';
-          tdCtr.title = `Google Search Console. Query-only (keyword totals across all pages). Last 28 days (matches GSC UI).`;
-        } else {
-          tdCtr.textContent = "‚Äî";
-          tdCtr.style.color = '#94a3b8';
-          tdCtr.title = `No query totals returned for this keyword in the last 28 days.`;
-        }
-        tr.appendChild(tdCtr);
-
-        // Impressions (28d) - query-only from queryTotals
-        const tdImpressions = document.createElement("td");
-        if (queryTotal && queryTotal.impressions != null && queryTotal.impressions > 0) {
-          tdImpressions.textContent = queryTotal.impressions.toLocaleString();
-          tdImpressions.style.color = '#1e293b';
-          tdImpressions.title = `Google Search Console. Query-only (keyword totals across all pages). Last 28 days (matches GSC UI).`;
-        } else {
-          tdImpressions.textContent = "‚Äî";
-          tdImpressions.style.color = '#94a3b8';
-          tdImpressions.title = `No query totals returned for this keyword in the last 28 days.`;
-        }
-        tr.appendChild(tdImpressions);
-
-        // Opportunity Score
-        const tdOpportunity = document.createElement("td");
-        const oppScore = row.opportunityScore ?? null;
-        if (oppScore != null) {
-          const oppBadge = document.createElement("span");
-          let oppClass = "ranking-badge-opportunity--low";
-          if (oppScore >= 70) {
-            oppClass = "ranking-badge-opportunity--high";
-          } else if (oppScore >= 40) {
-            oppClass = "ranking-badge-opportunity--medium";
-          }
-          oppBadge.className = `ranking-badge-opportunity ${oppClass}`;
-          oppBadge.textContent = `${oppScore}/100`;
-          tdOpportunity.appendChild(oppBadge);
-        } else {
-          tdOpportunity.textContent = "‚Äî";
-        }
-        tr.appendChild(tdOpportunity);
-
-        // AI Overview
-        const tdAi = document.createElement("td");
-        const aiBadge = document.createElement("span");
-        aiBadge.className =
-          "ranking-badge " + (row.has_ai_overview ? "ranking-badge--ai-on" : "ranking-badge--ai-off");
-        aiBadge.textContent = row.has_ai_overview ? "On" : "Off";
-        tdAi.appendChild(aiBadge);
-        tr.appendChild(tdAi);
-
-        // AI citation with RAG badge
-        const tdCitation = document.createElement("td");
-        const citBadge = document.createElement("span");
-        const isCited = row.ai_alan_citations_count > 0;
-        const totalCits = row.ai_total_citations || 0;
-        const label = isCited
-          ? `${row.ai_alan_citations_count}/${totalCits || "?"}`
-          : "0";
-        citBadge.className = isCited
-          ? "ranking-badge-citation ranking-badge-citation--good"
-          : "ranking-badge-citation ranking-badge-citation--weak";
-        citBadge.textContent = label;
-        tdCitation.appendChild(citBadge);
-        tr.appendChild(tdCitation);
-
-        // Classic Ranking URL
-        const tdUrl = document.createElement("td");
-        if (row.best_url) {
-          const a = document.createElement("a");
-          a.href = row.targetUrl || row.ranking_url || row.best_url || '';
-          a.target = "_blank";
-          a.rel = "noopener noreferrer";
-          a.textContent = row.best_title || row.best_url;
-          tdUrl.appendChild(a);
-        } else {
-          tdUrl.textContent = "‚Äî";
-        }
-        tr.appendChild(tdUrl);
-
-        // Page type
-        const tdType = document.createElement("td");
-        const pageType = row.pageType || "Landing";
-        const typeBadge = document.createElement("span");
-        // Use similar styling to Money Pages matrix
-        let typeClass = "ranking-badge-page-type";
-        if (pageType === "Event") typeClass += " ranking-badge-page-type--event";
-        else if (pageType === "Product") typeClass += " ranking-badge-page-type--product";
-        else if (pageType === "Blog") typeClass += " ranking-badge-page-type--blog";
-        else if (pageType === "GBP") typeClass += " ranking-badge-page-type--gbp";
-        else typeClass += " ranking-badge-page-type--landing";
-        typeBadge.className = typeClass;
-        typeBadge.textContent = pageType;
-        tdType.appendChild(typeBadge);
-        tr.appendChild(tdType);
-
-        // Optimisation column
-        const tdOptimisation = document.createElement("td");
-        tdOptimisation.style.position = "relative";
-        
-        // Ranking & AI tasks are keyword-level tasks, use 'content' task type
-        // (not 'on_page' which is for page-level tasks without keywords)
-        const taskType = 'content';
-        const status = window.getOptimisationStatus(row, taskType);
-        
-        // Safety check: ensure status object has expected structure
-        if (!status || typeof status !== 'object' || !status.status) {
-          // Not tracked - show "Not tracked" pill + Track button
-          const notTrackedBadge = document.createElement("span");
-          notTrackedBadge.className = "ranking-badge ranking-badge--segment-general";
-          notTrackedBadge.style.marginRight = "0.5rem";
-          notTrackedBadge.textContent = "Not tracked";
-          notTrackedBadge.title = "No optimisation task exists for this keyword + URL.";
-          tdOptimisation.appendChild(notTrackedBadge);
-          
-          const trackBtn = document.createElement("button");
-          trackBtn.className = "btn btn-small";
-          trackBtn.style.padding = "0.15rem 0.4rem";
-          trackBtn.style.fontSize = "0.3rem";
-          trackBtn.style.fontWeight = "550";
-          trackBtn.style.background = "#2563eb";
-          trackBtn.style.color = "#ffffff";
-          trackBtn.style.border = "1px solid #1e40af";
-          trackBtn.textContent = "Track";
-          trackBtn.title = "Create a task for this keyword + URL and capture baseline metrics.";
-          if (window.isShareMode) {
-            trackBtn.disabled = true;
-            trackBtn.title = "Not available in share mode (read-only)";
-            trackBtn.style.opacity = "0.5";
-            trackBtn.style.cursor = "not-allowed";
-          } else if (!window.hasAdminKey()) {
-            trackBtn.disabled = true;
-            trackBtn.title = "Admin key required - set your admin key in the configuration section";
-            trackBtn.style.opacity = "0.5";
-            trackBtn.style.cursor = "not-allowed";
-          }
-          trackBtn.onclick = (e) => {
-            e.stopPropagation();
-            if (window.isShareMode) {
-              alert('Write operations are not available in share mode (read-only).');
-              return;
-            }
-            if (!window.hasAdminKey()) {
-              alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
-              return;
-            }
-            window.openTrackKeywordModal(row, taskType);
-          };
-          tdOptimisation.appendChild(trackBtn);
-        } else {
-          // Tracked - check if status is 'done' or 'cancelled', show Track again button
-          // Note: 'deleted' should never appear - if task is deleted, it won't exist in status map
-          if (status.status === 'done' || status.status === 'cancelled') {
-            // Show status pill + Track again button
-            const statusBadge = document.createElement("span");
-            statusBadge.className = "ranking-badge ranking-badge--segment-general";
-            statusBadge.style.marginRight = "0.5rem";
-            const statusLabels = {
-              'done': 'Done',
-              'cancelled': 'Cancelled'
-            };
-            statusBadge.textContent = statusLabels[status.status] || status.status;
-            const statusTooltips = {
-              'done': 'Cycle completed; start a new cycle if optimising again.',
-              'cancelled': 'Tracking stopped; you can start a new cycle later.'
-            };
-            statusBadge.title = statusTooltips[status.status] || 'Click Track again to start a new cycle.';
-            tdOptimisation.appendChild(statusBadge);
-            
-            const trackBtn = document.createElement("button");
-            trackBtn.className = "btn btn-small";
-            trackBtn.style.padding = "0.03rem 0.08rem";
-            trackBtn.style.fontSize = "0.35rem";
-            trackBtn.style.fontWeight = "550";
-            trackBtn.style.background = "#2563eb";
-            trackBtn.style.color = "#ffffff";
-            trackBtn.style.border = "1px solid #1e40af";
-            trackBtn.textContent = "Track again";
-            trackBtn.title = "Start a new cycle for this keyword + URL.";
-            if (window.isShareMode) {
-              trackBtn.disabled = true;
-              trackBtn.title = "Not available in share mode (read-only)";
-              trackBtn.style.opacity = "0.5";
-              trackBtn.style.cursor = "not-allowed";
-            } else if (!window.hasAdminKey()) {
-              trackBtn.disabled = true;
-              trackBtn.title = "Admin key required - set your admin key in the configuration section";
-              trackBtn.style.opacity = "0.5";
-              trackBtn.style.cursor = "not-allowed";
-            }
-            trackBtn.onclick = (e) => {
-              e.stopPropagation();
-              if (window.isShareMode) {
-                alert('Write operations are not available in share mode (read-only).');
-                return;
-              }
-              if (!window.hasAdminKey()) {
-                alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
-                return;
-              }
-              window.openTrackKeywordModal(row, taskType);
-            };
-            tdOptimisation.appendChild(trackBtn);
-            
-            tr.appendChild(tdOptimisation);
-            tbody.appendChild(tr);
-            return; // Exit early, don't show Manage button
-          }
-          
-          // Handle 'deleted' status gracefully (shouldn't happen with hard delete, but safety check)
-          if (status.status === 'deleted') {
-            // Show "Not tracked" + Track button
-            const notTrackedBadge = document.createElement("span");
-            notTrackedBadge.className = "ranking-badge ranking-badge--segment-general";
-            notTrackedBadge.style.marginRight = "0.5rem";
-            notTrackedBadge.textContent = "Not tracked";
-            notTrackedBadge.title = "No optimisation task exists for this keyword + URL.";
-            tdOptimisation.appendChild(notTrackedBadge);
-            
-            const trackBtn = document.createElement("button");
-            trackBtn.className = "btn btn-small";
-            trackBtn.style.padding = "0.03rem 0.08rem";
-            trackBtn.style.fontSize = "0.35rem";
-            trackBtn.style.fontWeight = "550";
-            trackBtn.style.background = "#2563eb";
-            trackBtn.style.color = "#ffffff";
-            trackBtn.style.border = "1px solid #1e40af";
-            trackBtn.textContent = "Track";
-            trackBtn.title = "Create a task for this keyword + URL and capture baseline metrics.";
-            if (!window.hasAdminKey()) {
-              trackBtn.disabled = true;
-              trackBtn.title = "Admin key required - set your admin key in the configuration section";
-              trackBtn.style.opacity = "0.5";
-              trackBtn.style.cursor = "not-allowed";
-            }
-            trackBtn.onclick = (e) => {
-              e.stopPropagation();
-              if (!window.hasAdminKey()) {
-                alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
-                return;
-              }
-              window.openTrackKeywordModal(row, taskType);
-            };
-            tdOptimisation.appendChild(trackBtn);
-            tr.appendChild(tdOptimisation);
-            tbody.appendChild(tr);
-            return; // Exit early
-          }
-          
-          // Tracked - show status pill + metadata + Manage button
-          console.log('[Optimisation] Creating Manage button for tracked keyword:', row.keyword, 'Status:', status);
-          const statusBadge = document.createElement("span");
-          const statusText = {
-            'planned': 'Planned',
-            'in_progress': 'In progress',
-            'monitoring': 'Monitoring',
-            'done': 'Done',
-            'paused': 'Paused',
-            'cancelled': 'Cancelled'
-          }[status.status] || status.status;
-          
-          // Distinct color scheme for optimization statuses (different from page type badges)
-          statusBadge.className = "ranking-badge";
-          
-          // Apply status-specific colors
-          if (status.status === 'planned') {
-            // Light lavender - queued/upcoming
-            statusBadge.style.background = "#e9d5ff";
-            statusBadge.style.color = "#6b21a8";
-          } else if (status.status === 'in_progress') {
-            // Orange - active work
-            statusBadge.style.background = "#fed7aa";
-            statusBadge.style.color = "#9a3412";
-          } else if (status.status === 'monitoring') {
-            // Teal - watching/observing
-            statusBadge.style.background = "#a7f3d0";
-            statusBadge.style.color = "#065f46";
-          } else if (status.status === 'done') {
-            // Green - completed successfully
-            statusBadge.style.background = "#dcfce7";
-            statusBadge.style.color = "#166534";
-          } else if (status.status === 'paused') {
-            // Grey - on hold
-            statusBadge.style.background = "#e5e7eb";
-            statusBadge.style.color = "#374151";
-          } else if (status.status === 'cancelled') {
-            // Red - stopped/error
-            statusBadge.style.background = "#fee2e2";
-            statusBadge.style.color = "#991b1b";
-          } else {
-            // Default grey
-            statusBadge.style.background = "#f9fafb";
-            statusBadge.style.color = "#4b5563";
-          }
-          statusBadge.textContent = statusText;
-          statusBadge.style.marginRight = "0.5rem";
-          
-          // Add tooltip based on status
-          const statusTooltips = {
-            'planned': 'Task created but work not started.',
-            'in_progress': 'Currently being worked on.',
-            'monitoring': 'Changes shipped‚Äîmonitor metrics.',
-            'done': 'Cycle completed; start a new cycle if optimising again.',
-            'paused': 'Tracking stopped; you can start a new cycle later.',
-            'cancelled': 'Tracking stopped; you can start a new cycle later.'
-          };
-          statusBadge.title = statusTooltips[status.status] || `Status: ${statusText}`;
-          
-          tdOptimisation.appendChild(statusBadge);
-          
-          // Metadata (cycle + last activity)
-          const metadataDiv = document.createElement("div");
-          metadataDiv.style.fontSize = "0.7rem";
-          metadataDiv.style.color = "#64748b";
-          metadataDiv.style.marginTop = "0.25rem";
-          metadataDiv.style.marginBottom = "0.25rem";
-          
-          const cycleText = document.createElement("span");
-          cycleText.textContent = `Cycle ${status.cycle_active || 1}`;
-          cycleText.style.marginRight = "0.5rem";
-          metadataDiv.appendChild(cycleText);
-          
-          if (status.last_activity_at) {
-            const lastActivityText = document.createElement("span");
-            const lastActivity = new Date(status.last_activity_at);
-            const now = new Date();
-            const daysAgo = Math.floor((now - lastActivity) / (1000 * 60 * 60 * 24));
-            lastActivityText.textContent = daysAgo === 0 ? "Today" : daysAgo === 1 ? "1 day ago" : `${daysAgo} days ago`;
-            metadataDiv.appendChild(lastActivityText);
-          }
-          
-          tdOptimisation.appendChild(metadataDiv);
-          
-          // Manage button
-          const manageBtn = document.createElement("button");
-          manageBtn.className = "btn btn-small";
-          manageBtn.style.padding = "0.15rem 0.4rem";
-          manageBtn.style.fontSize = "0.3rem";
-          manageBtn.style.fontWeight = "550";
-          manageBtn.style.background = "#E5FFCC";
-          manageBtn.style.color = "#000000";
-          manageBtn.style.border = "1px solid #a3d977";
-          manageBtn.textContent = "Manage";
-          manageBtn.title = "Open task details, update status, add notes, record measurements, start new cycle.";
-          manageBtn.style.position = "relative";
-          manageBtn.style.zIndex = "100";
-          manageBtn.style.pointerEvents = "auto";
-          manageBtn.type = "button"; // Prevent form submission
-          
-          // Store status and row data on button for access in handler (closure safety)
-          const statusId = status.id;
-          const statusObj = status;
-          const rowData = row;
-          const taskTypeValue = taskType;
-          
-          console.log('[Optimisation] Setting up Manage button onclick, statusId:', statusId);
-          
-          if (!window.hasAdminKey()) {
-            manageBtn.disabled = true;
-            manageBtn.title = "Admin key required - set your admin key in the configuration section";
-            manageBtn.style.opacity = "0.5";
-            manageBtn.style.cursor = "not-allowed";
-          }
-          
-          // Use onclick - simpler and more reliable
-          manageBtn.onclick = async function(e) {
-            e.stopPropagation();
-            e.preventDefault();
-            
-            if (!window.hasAdminKey()) {
-              alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
-              return;
-            }
-            
-            if (!statusId) {
-              alert('No task ID found. Please try refreshing the page.');
-              return;
-            }
-            
-            // Open the drawer with the status ID
-            // The drawer function will handle loading tasks if needed and switching tabs
-            if (typeof window.openOptimisationTaskDrawer === 'function') {
-              try {
-                await window.openOptimisationTaskDrawer(statusId);
-              } catch (error) {
-                console.error('[Optimisation] Error opening drawer:', error);
-                // Fallback to modal
-                window.openManageOptimisationModal(rowData, statusObj, taskTypeValue);
-              }
-            } else {
-              // Fallback to modal if drawer function doesn't exist
-              window.openManageOptimisationModal(rowData, statusObj, taskTypeValue);
-            }
-          };
-          
-          tdOptimisation.appendChild(manageBtn);
-        }
-        
-        tr.appendChild(tdOptimisation);
-
-        tbody.appendChild(tr);
-        } catch (error) {
-          console.error(`[Ranking Table] Error rendering row ${index} for keyword "${row?.keyword || 'unknown'}":`, error);
-          // Continue to next row instead of stopping the loop
-        }
-      });
-
-      // Update sort indicators
-      document.querySelectorAll('.ranking-table th.sortable').forEach(th => {
-        th.classList.remove('sort-asc', 'sort-desc');
-        if (th.dataset.sort === rankingSortState.column) {
-          th.classList.add(`sort-${rankingSortState.direction}`);
-        }
-      });
-
-      // Update pagination controls
-      updatePaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx);
-      
-      // Re-wire sorting after render completes
-      wireRankingSorting();
-
-      // Row click ‚Üí scorecard panel
-      tbody.querySelectorAll("tr").forEach(tr => {
-        tr.addEventListener("click", async () => {
-          tbody.querySelectorAll("tr").forEach(r => r.classList.remove("ranking-table-row--selected"));
-          tr.classList.add("ranking-table-row--selected");
-          const idx = Number(tr.dataset.index || "-1");
-          if (!Number.isNaN(idx) && combinedRows[idx]) {
-            const row = combinedRows[idx];
-            // Create unique identifier for selected keyword
-            selectedKeywordId = `${row.keyword}|${row.best_url || ''}`;
-            debugLog(`[RankingAI Scorecard] Row clicked - keyword: "${row.keyword}", selectedKeywordId: "${selectedKeywordId}"`, 'info');
-            await renderKeywordScorecard(row);
-          }
-        });
-      });
-
-      // Competitors (use filtered rows)
-      renderRankingAiCompetitors(filteredRows);
-      
-      // Insights (use all rows for global insights across all tracked keywords)
-      renderRankingAiInsights(combinedRows, summary);
-    }
-    
-    function updatePaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx) {
-      const paginationControls = document.getElementById("ranking-pagination-controls");
-      const paginationInfo = document.getElementById("ranking-pagination-info");
-      const pageInfo = document.getElementById("ranking-pagination-page-info");
-      const firstBtn = document.getElementById("ranking-pagination-first");
-      const prevBtn = document.getElementById("ranking-pagination-prev");
-      const nextBtn = document.getElementById("ranking-pagination-next");
-      const lastBtn = document.getElementById("ranking-pagination-last");
-      const rowsPerPageSelect = document.getElementById("ranking-rows-per-page");
-      
-      if (!paginationControls) return;
-      
-      if (totalRows === 0) {
-        paginationControls.style.display = "none";
-        return;
-      }
-      
-      paginationControls.style.display = "flex";
-      
-      if (paginationInfo) {
-        paginationInfo.textContent = `Showing ${startIdx + 1}-${endIdx} of ${totalRows}`;
-      }
-      
-      if (pageInfo) {
-        pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
-      }
-      
-      if (firstBtn) {
-        firstBtn.disabled = currentPage === 1;
-      }
-      if (prevBtn) {
-        prevBtn.disabled = currentPage === 1;
-      }
-      if (nextBtn) {
-        nextBtn.disabled = currentPage === totalPages;
-      }
-      if (lastBtn) {
-        lastBtn.disabled = currentPage === totalPages;
-      }
-      
-      if (rowsPerPageSelect) {
-        rowsPerPageSelect.value = rankingPaginationState.rowsPerPage;
-      }
-    }
-
-    /**
-     * Render Keyword Scorecard Panel
-     * @param {Object} row - Keyword row from combinedRows
-     */
-    async function renderKeywordScorecard(row) {
-      const emptyEl = document.getElementById("ranking-ai-detail-empty");
-      const contentEl = document.getElementById("ranking-ai-detail-content");
-      if (!emptyEl || !contentEl) return;
-
-      if (!row) {
-        emptyEl.hidden = false;
-        contentEl.hidden = true;
-        emptyEl.textContent = "Select a keyword in the table or a cell in the priority grid to see a detailed scorecard.";
-        
-        // Hide citations section
-        const citationsEmpty = document.getElementById("ranking-ai-citations-empty");
-        const citationsContent = document.getElementById("ranking-ai-citations-content");
-        if (citationsEmpty) citationsEmpty.hidden = false;
-        if (citationsContent) citationsContent.hidden = true;
-        
-        return;
-      }
-
-      const scorecardData = buildKeywordScorecardData(row);
-      if (!scorecardData) {
-        emptyEl.hidden = false;
-        contentEl.hidden = true;
-        return;
-      }
-      
-      // Fetch authority context for authority-building block (v1.4)
-      const authorityContext = await fetchRankingAiAuthorityContext();
-      const authorityPriority = authorityContext?.authorityPriority ?? null;
-      const domainStrength = authorityContext?.domainStrength ?? null;
-
-      debugLog(`[RankingAI Scorecard] Rendering scorecard for keyword: "${scorecardData.keyword}"`, 'info');
-      debugLog(`[RankingAI Scorecard] Demand: ${scorecardData.demand_level}, Rank: ${scorecardData.rank_bucket_label}, AI: ${scorecardData.ai_status}, Priority: ${scorecardData.priority_level}`, 'info');
-
-      emptyEl.hidden = true;
-      contentEl.hidden = false;
-
-      // Apply RAG color class to content element based on priority
-      contentEl.classList.remove('scorecard-priority-high', 'scorecard-priority-medium', 'scorecard-priority-low');
-      if (scorecardData.priority_level === 'High') {
-        contentEl.classList.add('scorecard-priority-high');
-      } else if (scorecardData.priority_level === 'Medium') {
-        contentEl.classList.add('scorecard-priority-medium');
-      } else {
-        contentEl.classList.add('scorecard-priority-low');
-      }
-
-      // Build HTML for scorecard
-      let html = '';
-
-      // Impact & Difficulty summary line (under card header) - RAG color-coded
-      const impactLabel = scorecardData.impact_bucket.charAt(0).toUpperCase() + scorecardData.impact_bucket.slice(1);
-      const difficultyLabel = scorecardData.difficulty_bucket.charAt(0).toUpperCase() + scorecardData.difficulty_bucket.slice(1);
-      const priorityLabel = scorecardData.priority_level;
-      
-      // RAG colors for each level
-      const getRagColor = (level) => {
-        const lower = level.toLowerCase();
-        if (lower === 'high') return '#ef4444'; // Red
-        if (lower === 'medium') return '#f59e0b'; // Amber
-        return '#10b981'; // Green (Low)
-      };
-      
-      const impactColor = getRagColor(impactLabel);
-      const difficultyColor = getRagColor(difficultyLabel);
-      const priorityColor = getRagColor(priorityLabel);
-      
-      // Opportunity Score (under header title, in same section as Impact/Difficulty/Priority)
-      const oppScore = scorecardData.opportunity_score ?? null;
-      let oppColor = '#b91c1c'; // Red (Low)
-      let oppClass = 'low';
-      if (oppScore != null) {
-        if (oppScore >= 70) {
-          oppColor = '#166534'; // Green (High)
-          oppClass = 'high';
-        } else if (oppScore >= 40) {
-          oppColor = '#92400e'; // Amber (Medium)
-          oppClass = 'medium';
-        }
-      }
-      
-      html += `<div style="margin-bottom: 1.25rem; padding-bottom: 0.75rem; border-bottom: 1px solid #e5e7eb;">`;
-      if (oppScore != null) {
-        html += `<p style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: ${oppColor}; line-height: 1.4;">`;
-        html += `Keyword opportunity score: <span style="color: ${oppColor};">${oppScore}/100</span>`;
-        html += ` <span title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10;‚Ä¢ Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10;‚Ä¢ Classic ranking strength (page 1 vs page 2+ and current position).&#10;‚Ä¢ AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first." style="opacity: 0.6; cursor: help; font-size: 0.875rem;">‚Ñπ</span>`;
-        html += `</p>`;
-      }
-      html += `<p style="margin: 0; font-size: 1.1rem; font-weight: 700; color: #1e293b; line-height: 1.4;">`;
-      html += `<span>Impact: <span style="color: ${impactColor};">${impactLabel}</span></span> ‚Ä¢ `;
-      html += `<span>Difficulty: <span style="color: ${difficultyColor};">${difficultyLabel}</span></span> ‚Ä¢ `;
-      html += `<span>Priority: <span style="color: ${priorityColor};">${priorityLabel}</span></span>`;
-      html += `</p>`;
-      
-      // Add derived summary sentence
-      const summarySentence = generateKeywordSummary(scorecardData);
-      html += `<p style="margin: 0.5rem 0 0 0; font-size: 0.875rem; font-weight: 400; color: #64748b; line-height: 1.5;">${summarySentence}</p>`;
-      html += `</div>`;
-
-      // Keyword & URL header - Keyword as prominent nameplate
-      html += `<div style="margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 2px solid #e5e7eb;">`;
-      // Keyword nameplate - large and prominent
-      html += `<div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-left: 6px solid #f59e0b; padding: 1.25rem 1.5rem; margin-bottom: 1rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);">`;
-      html += `<h4 style="font-size: 1.75rem; font-weight: 800; color: #92400e; margin: 0; letter-spacing: 0.02em; line-height: 1.2;">${scorecardData.keyword}</h4>`;
-      html += `</div>`;
-      // Use canonical targetUrl for display
-      const displayUrl = scorecardData.targetUrl || scorecardData.ranking_url || '';
-      if (displayUrl) {
-        html += `<p style="margin: 0.25rem 0; font-size: 0.875rem;"><a href="${displayUrl}" target="_blank" rel="noopener noreferrer" style="color: #0284c7; text-decoration: none;">${displayUrl}</a></p>`;
-      }
-      html += `<div style="display: flex; gap: 1rem; margin-top: 0.5rem; flex-wrap: wrap;">`;
-      html += `<span class="ranking-badge ${scorecardData.segment === 'money' ? 'ranking-badge--segment-money' : scorecardData.segment === 'education' ? 'ranking-badge--segment-education' : scorecardData.segment === 'brand' ? 'ranking-badge--segment-brand' : 'ranking-badge--segment-general'}" style="font-size: 0.875rem;">${scorecardData.segment || 'Other'}</span>`;
-      html += `<span style="font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">${scorecardData.page_type}</span>`;
-      html += `</div>`;
-      
-      // Grey meta line (under chips)
-      const metaParts = [];
-      if (row.best_rank_group != null) {
-        metaParts.push(`Classic rank: #${row.best_rank_group}`);
-      } else {
-        metaParts.push("Classic rank: not in top 50");
-      }
-      if (row.has_ai_overview) {
-        const total = row.ai_total_citations || 0;
-        const ours = row.ai_alan_citations_count || 0;
-        metaParts.push(`AI Overview: present (${ours}/${total || "?"} citations from alanranger.com)`);
-      } else {
-        metaParts.push("AI Overview: not present");
-      }
-      const segLabel = row.segment === "money" ? "Money page (commercial intent)" :
-                      row.segment === "education" ? "Education content" :
-                      row.segment === "brand" ? "Brand query" : "General / other";
-      metaParts.push(`Segment: ${segLabel}`);
-      html += `<p style="margin: 0.5rem 0 0 0; font-size: 0.875rem; color: #3d3d3d; line-height: 1.6; font-weight: 400;">${metaParts.join(" ‚Ä¢ ")}</p>`;
-      html += `</div>`;
-
-      // Priority & Next Actions (moved to top, before Demand and Classic ranking)
-      html += `<div class="scorecard-section" style="background: #fcfcfc !important;">`;
-      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">Priority & Next Actions</h5>`;
-      const priorityBg = scorecardData.priority_level === 'High' ? '#fef2f2' : 
-                        scorecardData.priority_level === 'Medium' ? '#fffbeb' : '#f0fdf4';
-      const priorityBorder = scorecardData.priority_level === 'High' ? '#ef4444' : 
-                            scorecardData.priority_level === 'Medium' ? '#f59e0b' : '#10b981';
-      html += `<p style="margin-bottom: 0.75rem; font-size: 0.875rem; color: #3d3d3d; line-height: 1.6; font-weight: 400;">Overall priority: <span style="padding: 0.25rem 0.5rem; border-radius: 4px; font-weight: 600; background: ${priorityBg}; border-left: 3px solid ${priorityBorder}; color: #1e293b;">${scorecardData.priority_level}</span></p>`;
-      
-      // Authority-building block (v1.4: Domain Strength integration)
-      const opportunityScore = scorecardData.opportunity_score ?? 0;
-      const currentRank = scorecardData.best_rank_group ?? null;
-      const isAuthorityLimited = authorityPriority === 'high' && 
-                                 opportunityScore >= 60 && 
-                                 (currentRank === null || currentRank > 10);
-      
-      if (isAuthorityLimited) {
-        html += `<div style="margin-bottom: 1rem; padding: 0.75rem; background: #fef3c7; border-left: 3px solid #f59e0b; border-radius: 4px;">`;
-        html += `<h6 style="font-size: 0.875rem; font-weight: 600; color: #92400e; margin: 0 0 0.5rem 0;">Authority & external signals</h6>`;
-        html += `<ul style="margin: 0; padding-left: 1.25rem; list-style-type: disc; font-size: 0.875rem; line-height: 1.6; color: #3d3d3d; font-weight: 400;">`;
-        const domainStrengthScore = domainStrength?.score ?? null;
-        const scoreText = domainStrengthScore !== null ? `~${domainStrengthScore.toFixed(1)}` : 'unknown';
-        const bandText = domainStrength?.band ?? 'unknown';
-        html += `<li style="margin-bottom: 0.25rem;">Overall domain strength is currently ${bandText} (score ${scoreText}).</li>`;
-        html += `<li style="margin-bottom: 0.25rem;">For this high-impact keyword on page 2+, focus on authority-building: relevant backlinks, citations, PR, and mentions from trusted sites in the same topic.</li>`;
-        html += `</ul>`;
-        html += `</div>`;
-      } else if (authorityPriority === 'medium' && opportunityScore >= 60 && (currentRank === null || currentRank > 10)) {
-        // Medium priority - softer wording
-        html += `<div style="margin-bottom: 1rem; padding: 0.75rem; background: #fef3c7; border-left: 3px solid #f59e0b; border-radius: 4px;">`;
-        html += `<h6 style="font-size: 0.875rem; font-weight: 600; color: #92400e; margin: 0 0 0.5rem 0;">Authority & external signals</h6>`;
-        html += `<ul style="margin: 0; padding-left: 1.25rem; list-style-type: disc; font-size: 0.875rem; line-height: 1.6; color: #1e293b;">`;
-        const domainStrengthScore = domainStrength?.score ?? null;
-        const scoreText = domainStrengthScore !== null ? `~${domainStrengthScore.toFixed(1)}` : 'unknown';
-        html += `<li style="margin-bottom: 0.25rem;">Domain strength is moderate (score ${scoreText}). Also consider authority-building alongside on-page improvements for this high-impact keyword.</li>`;
-        html += `</ul>`;
-        html += `</div>`;
-      }
-      
-      const actions = generateActionBullets(scorecardData);
-      // Always show 3 bullets (function now guarantees 3)
-      html += `<ul style="margin: 0; padding-left: 1.5rem; list-style-type: disc; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">`;
-      actions.forEach(action => {
-        html += `<li style="margin-bottom: 0.5rem; color: #3d3d3d;">${action}</li>`;
-      });
-      html += `</ul>`;
-      html += `</div>`;
-
-      // 1. Target page totals and 2. Classic ranking - side by side with equal height/width/padding
-      html += `<div style="display: flex; gap: 1rem; margin-bottom: 1.0rem; align-items: stretch;">`;
-      
-      // 1. Target page totals (left half) - page-only GSC data
-      html += `<div class="scorecard-section" style="flex: 1 1 50%; min-width: 0; display: flex; flex-direction: column; height: 100%;">`;
-      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">1. Target page totals (GSC, 28d) <span title="All queries to this page, last 28 days (matches GSC Pages tab with no query filter)." style="opacity: 0.6; cursor: help; font-size: 0.75rem;">‚Ñπ</span></h5>`;
-      // Display target page URL (clickable) - use canonical targetUrl
-      const canonicalUrl = scorecardData.targetUrl || scorecardData.ranking_url || '';
-      if (canonicalUrl) {
-        // URL is already canonicalized, just use it directly
-        const cleanUrl = canonicalUrl;
-        html += `<div style="margin-bottom: 0.75rem; padding-left: 0.75rem;">`;
-        html += `<div style="font-size: 0.8125rem; color: #64748b; margin-bottom: 0.25rem;">Target page (all queries):</div>`;
-        html += `<a href="${canonicalUrl}" target="_blank" rel="noopener noreferrer" style="font-size: 0.8125rem; color: #2563eb; text-decoration: underline; word-break: break-all; display: inline-block; max-width: 100%;" title="Open target page in new tab">${cleanUrl}</a>`;
-        html += `<div style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;" title="Totals for this page across all search queries (not just this keyword).">‚Ñπ Totals for this page across all search queries (not just this keyword).</div>`;
-        html += `</div>`;
-      }
-      html += `<div style="padding-left: 0.75rem;" id="scorecard-page-totals-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}">`;
-      html += `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">Loading page totals...</div>`;
-      html += `</div></div>`;
-
-      // 2. Classic ranking (right half)
-      html += `<div class="scorecard-section" style="flex: 1 1 50%; min-width: 0; display: flex; flex-direction: column; height: 100%;">`;
-      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">2. Classic ranking</h5>`;
-      html += `<div style="padding-left: 0.75rem;">`;
-      let rankText = '';
-      if (scorecardData.best_rank_group != null) {
-        const rankBucket = scorecardData.rank_bucket || scorecardData.rank_bucket_label || '';
-        // Format: "Currently ranking #24 (page 2+ / Not ranked)"
-        if (rankBucket === 'top3' || rankBucket === 'page 1') {
-          rankText = `Currently ranking #${scorecardData.best_rank_group} (page 1)`;
-        } else if (rankBucket === 'top10' || rankBucket === 'page 1') {
-          rankText = `Currently ranking #${scorecardData.best_rank_group} (page 1)`;
-        } else if (rankBucket === 'page2plus' || rankBucket === 'beyond page 2') {
-          rankText = `Currently ranking #${scorecardData.best_rank_group} (page 2+)`;
-        } else {
-          rankText = `Currently ranking #${scorecardData.best_rank_group} (${rankBucket || 'beyond page 2'})`;
-        }
-      } else {
-        rankText = 'Currently ranking (beyond page 2 / Not ranked)';
-      }
-      html += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.8125rem; line-height: 1.5; color: #1e293b; font-weight: 400;">${rankText}</div>`;
-      const strengthClass = scorecardData.position_strength === 'Strong' ? 'status-green' : 
-                         scorecardData.position_strength === 'OK' ? 'status-amber' : 'status-red';
-      const strengthBg = scorecardData.position_strength === 'Strong' ? '#f0fdf4' : 
-                        scorecardData.position_strength === 'OK' ? '#fffbeb' : '#fef2f2';
-      const strengthBorder = scorecardData.position_strength === 'Strong' ? '#10b981' : 
-                            scorecardData.position_strength === 'OK' ? '#f59e0b' : '#ef4444';
-      html += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.5; color: #3d3d3d; font-weight: 400;">Position strength: <span style="padding: 0.25rem 0.5rem; border-radius: 4px; font-weight: 600; background: ${strengthBg}; border-left: 3px solid ${strengthBorder}; color: #1e293b;">${scorecardData.position_strength}</span></div>`;
-      html += `</div></div>`;
-      
-      html += `</div>`; // Close flex container
-
-      // 3. CTR & snippet (query-only)
-      html += `<div class="scorecard-section">`;
-      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">3. CTR & snippet (GSC, 28d) <span title="Query-only totals for this keyword (matches GSC Queries tab)." style="opacity: 0.6; cursor: help; font-size: 0.75rem;">‚Ñπ</span></h5>`;
-      html += `<div style="padding-left: 0.75rem;">`;
-      
-      // Get query-only totals from queryTotals
-      const queryTotal = getQueryTotalForKeyword(scorecardData.keyword);
-      
-      // Only show CTR if impressions > 0 (CTR requires impressions)
-      if (queryTotal && queryTotal.impressions > 0 && queryTotal.ctr != null) {
-        // Real CTR data available (query-only)
-        // queryTotal.ctr is already a percentage (0-100) from API, not a decimal
-        const ctrPercent = queryTotal.ctr.toFixed(1);
-        const impressionsFormatted = queryTotal.impressions.toLocaleString();
-        const clicksFormatted = queryTotal.clicks.toLocaleString();
-        const positionBucket = getPositionBucket(scorecardData.best_rank_group);
-        const ctrBenchmark = getCtrBenchmarkForPosition(positionBucket);
-        const benchmarkPercent = (ctrBenchmark * 100).toFixed(1);
-        
-        // Determine CTR performance label
-        let ctrPerformance = 'OK';
-        let ctrPerformanceColor = '#f59e0b'; // Amber
-        let ctrPerformanceBg = '#fffbeb';
-        if (queryTotal.ctr >= ctrBenchmark * 1.1) {
-          ctrPerformance = 'Strong';
-          ctrPerformanceColor = '#10b981'; // Green
-          ctrPerformanceBg = '#f0fdf4';
-        } else if (queryTotal.ctr < ctrBenchmark * 0.8) {
-          ctrPerformance = 'Weak';
-          ctrPerformanceColor = '#ef4444'; // Red
-          ctrPerformanceBg = '#fef2f2';
-        }
-        
-        html += `<div style="margin-bottom: 0.75rem;">`;
-        html += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">`;
-        html += `<span>CTR (last 28 days): <strong style="color: #1e293b;">${ctrPercent}%</strong></span>`;
-        html += `<span>¬∑</span>`;
-        html += `<span>Impressions: <strong style="color: #1e293b;">${impressionsFormatted}</strong></span>`;
-        html += `<span>¬∑</span>`;
-        html += `<span>Clicks: <strong style="color: #1e293b;">${clicksFormatted}</strong></span>`;
-        html += `<span style="font-size: 0.75rem; color: #64748b;">(query-only)</span>`;
-        html += `</div>`;
-        html += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">`;
-        html += `<span>Expected CTR at this position: <strong style="color: #64748b;">${benchmarkPercent}%</strong> <span title="Heuristic benchmark based on rank position (not from GSC)." style="opacity: 0.6; cursor: help; font-size: 0.75rem;">‚Ñπ</span></span>`;
-        html += `</div>`;
-        html += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.75rem;">`;
-        html += `<span style="font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">CTR performance: <span style="padding: 0.25rem 0.5rem; border-radius: 4px; font-weight: 600; background: ${ctrPerformanceBg}; border-left: 3px solid ${ctrPerformanceColor}; color: #1e293b;">${ctrPerformance}</span></span>`;
-        html += `</div>`;
-        html += `</div>`;
-        
-        // Explanatory text based on performance
-        if (ctrPerformance === 'Weak') {
-          html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">CTR is weak for this position. Improving the snippet (title, meta description and rich results) should unlock more clicks for this keyword.</p>`;
-        } else if (ctrPerformance === 'Strong') {
-          html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">CTR is in line with expectations for this position. Further gains are more likely to come from improving rank (links and authority) than snippet tweaks alone.</p>`;
-        } else {
-          // OK performance
-          html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">CTR is in line with expectations for this position. Further gains are more likely to come from improving rank (links and authority) than snippet tweaks alone.</p>`;
-        }
-      } else {
-        // No query-only data found for last 28 days
-        html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">No query-only totals returned for this keyword in the last 28 days.</p>`;
-      }
-      html += `</div></div>`;
-      
-      // Advanced: Pages with impressions for this keyword (query‚Üípages breakdown)
-      html += `<div class="scorecard-section" style="margin-top: 1rem;">`;
-      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">Advanced: Pages with impressions for this keyword (GSC) <span title="Pages with impressions for this keyword (GSC query‚Üípages breakdown)." style="opacity: 0.6; cursor: help; font-size: 0.75rem;">‚Ñπ</span></h5>`;
-      html += `<div style="padding-left: 0.75rem;" id="scorecard-query-pages-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}">`;
-      html += `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">Loading pages breakdown...</div>`;
-      html += `</div></div>`;
-
-      // 4. Schema & rich results
-      html += `<div class="scorecard-section" data-scorecard-section="schema">`;
-      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">4. Schema & rich results</h5>`;
-      html += `<div style="padding-left: 0.75rem;">`;
-      
-      // Get schema coverage if available
-      // Try to use the async getSchemaCoverageForUrl function which handles Supabase fallback
-      let schemaCoverage = null;
-      let schemaSummary = null;
-      try {
-        // First try sync (localStorage) for immediate display
-        const savedAudit = loadAuditResultsSync();
-        if (savedAudit && savedAudit.schemaAudit && savedAudit.schemaAudit.data) {
-          const schemaData = savedAudit.schemaAudit.data;
-          // Lightweight debug for the object used in this card
-          try {
-            const pagesWithSchemaCount = Array.isArray(schemaData.pagesWithSchema)
-              ? schemaData.pagesWithSchema.length
-              : (typeof schemaData.pagesWithSchema === 'number' ? schemaData.pagesWithSchema : 0);
-            const totalPagesCount = typeof schemaData.totalPages === 'number'
-              ? schemaData.totalPages
-              : (Array.isArray(schemaData.pages) ? schemaData.pages.length : 0);
-            const coveragePct = (typeof schemaData.coverage === 'number' && !Number.isNaN(schemaData.coverage))
-              ? schemaData.coverage
-              : (totalPagesCount > 0 ? (pagesWithSchemaCount / totalPagesCount) * 100 : 0);
-
-            const allTypes = new Set();
-            if (Array.isArray(schemaData.allDetectedTypes)) {
-              schemaData.allDetectedTypes.forEach(t => t && allTypes.add(t));
-            } else if (Array.isArray(schemaData.schemaTypes)) {
-              schemaData.schemaTypes.forEach(item => {
-                if (typeof item === 'string') allTypes.add(item);
-                else if (item && typeof item === 'object' && item.type) allTypes.add(item.type);
-              });
-            }
-
-            schemaSummary = {
-              pagesWithSchemaCount,
-              totalPagesCount,
-              coveragePct,
-              uniqueTypesCount: allTypes.size
-            };
-
-            debugLog(
-              `Ranking&AI schemaAuditForCard: totalPages=${totalPagesCount}, pagesWithSchema=${pagesWithSchemaCount}, coverage=${coveragePct.toFixed(1)}%, uniqueTypes=${allTypes.size}`,
-              'info'
-            );
-          } catch (e) {
-            // Ignore summary extraction errors; per-page logic may still work
-          }
-          
-          // PRIORITY: Check pages first (original array from schema audit API - most reliable)
-          // Then check pagesWithSchema ONLY if it's an array (from Supabase schema_pages_detail)
-          // Note: pagesWithSchema might be a number (count) instead of an array
-          let pagesArray = null;
-          if (Array.isArray(schemaData.pages) && schemaData.pages.length > 0) {
-            pagesArray = schemaData.pages;
-            debugLog('[Schema Coverage] Using schemaData.pages array (' + pagesArray.length + ' pages)', 'info');
-          } else if (Array.isArray(schemaData.pagesWithSchema) && schemaData.pagesWithSchema.length > 0) {
-            pagesArray = schemaData.pagesWithSchema;
-            debugLog('[Schema Coverage] Using schemaData.pagesWithSchema array from Supabase (' + pagesArray.length + ' pages)', 'info');
-          } else {
-            debugLog('[Schema Coverage] No pages array found. pages=' + typeof schemaData.pages + ' (isArray=' + Array.isArray(schemaData.pages) + '), pagesWithSchema=' + typeof schemaData.pagesWithSchema + ' (isArray=' + Array.isArray(schemaData.pagesWithSchema) + ')', 'warn');
-          }
-          
-          if (pagesArray && pagesArray.length > 0) {
-            // Normalize URL: remove query params and trailing slashes for matching
-            const rankingUrl = scorecardData.ranking_url || '';
-            const normalizedUrl = normalizeUrlForMatching(rankingUrl);
-            
-            debugLog('[Schema Coverage] Looking for URL: ' + normalizedUrl + ' (original: ' + rankingUrl + ')', 'info');
-            
-            // Fallback matching: some ranking URLs include redirect/variant slugs (e.g. "121" vs "1-2-1")
-            // If exact pathname match fails, compare a "loose" slug that strips non-alphanumerics.
-            const normalizeLooseSlug = (pathname) => {
-              const p = (pathname || '').toString().toLowerCase().trim();
-              const last = p.split('/').filter(Boolean).pop() || '';
-              return last.replace(/[^a-z0-9]/g, '');
-            };
-            const normalizedLoose = normalizeLooseSlug(normalizedUrl);
-            
-            // Exact matching only - normalize both URLs identically (strips query params, hash, trailing slashes)
-            let looseMatchedUrl = null;
-            const pageData = pagesArray.find(p => {
-              if (!p || !p.url) return false;
-              const pNormalized = normalizeUrlForMatching(p.url);
-              
-              // Exact match after normalization (both URLs stripped of query params, hash, trailing slashes)
-              const exactMatch = pNormalized === normalizedUrl;
-              
-              // For homepage, also check if both are '/' or empty
-              const homepageMatch = (normalizedUrl === '/' || normalizedUrl === '') && (pNormalized === '/' || pNormalized === '');
-              
-              if (exactMatch || homepageMatch) {
-                debugLog('[Schema Coverage] ‚úÖ Exact URL match: ' + p.url + ' -> ' + pNormalized + ' (search: ' + normalizedUrl + ')', 'info');
-                return true;
-              }
-
-              // Fallback: loose slug match (handles minor slug variants)
-              if (!exactMatch && normalizedLoose) {
-                const pLoose = normalizeLooseSlug(pNormalized);
-                if (pLoose && pLoose === normalizedLoose) {
-                  looseMatchedUrl = p.url;
-                  debugLog('[Schema Coverage] ‚ö† Loose slug match: ' + p.url + ' -> ' + pNormalized + ' (search: ' + normalizedUrl + ')', 'warn');
-                  return true;
-                }
-              }
-              return false;
-            });
-            
-            if (pageData) {
-              debugLog('[Schema Coverage] ‚úÖ Found page data for URL: ' + scorecardData.ranking_url, 'info');
-              debugLog('[Schema Coverage] Matched page URL: ' + (pageData.url || 'missing'), 'info');
-              if (looseMatchedUrl) {
-                debugLog('[Schema Coverage] Note: match used loose slug fallback (ranking URL likely redirected or variant slug).', 'warn');
-              }
-              if (pageData.schemaTypes) {
-                const schemaTypes = Array.isArray(pageData.schemaTypes) ? pageData.schemaTypes : [];
-                const typeStrings = schemaTypes.map(t => {
-                  if (typeof t === 'string') return t.toLowerCase();
-                  if (t && typeof t === 'object' && t.type) return String(t.type).toLowerCase();
-                  return String(t).toLowerCase();
-                });
-                const typeDisplay = schemaTypes.map(t => {
-                  if (typeof t === 'string') return t;
-                  if (t && typeof t === 'object' && t.type) return t.type;
-                  return String(t);
-                }).join(', ');
-                debugLog('[Schema Coverage] Schema types found (' + schemaTypes.length + '): ' + typeDisplay, 'info');
-                schemaCoverage = {
-                  hasFAQ: typeStrings.some(t => t.includes('faq') || t === 'faqpage'),
-                  hasHowTo: typeStrings.some(t => t.includes('howto') || t === 'howto'),
-                  hasEvent: typeStrings.some(t => t.includes('event') && !t.includes('product')),
-                  hasProduct: typeStrings.some(t => t.includes('product')),
-                  hasBreadcrumb: typeStrings.some(t => t.includes('breadcrumb') || t === 'breadcrumblist'),
-                  hasImageObject: typeStrings.some(t => t.includes('image') || t === 'imageobject')
-                };
-                debugLog('[Schema Coverage] Coverage result: ' + JSON.stringify(schemaCoverage), 'info');
-              } else {
-                debugLog('[Schema Coverage] ‚ö†Ô∏è Page data found but no schemaTypes property', 'warn');
-                debugLog('[Schema Coverage] Page data keys: ' + Object.keys(pageData).join(', '), 'warn');
-              }
-            } else {
-              debugLog('[Schema Coverage] ‚ùå No page data found for URL: ' + scorecardData.ranking_url, 'warn');
-              debugLog('[Schema Coverage] Normalized search URL: ' + normalizedUrl, 'warn');
-              if (pagesArray && pagesArray.length > 0) {
-                debugLog('[Schema Coverage] Sample URLs in pages array (first 3):', 'warn');
-                pagesArray.slice(0, 3).forEach((p, i) => {
-                  let pNorm = (p.url || '').toLowerCase().trim();
-                  try {
-                    const pUrlObj = p.url ? new URL(p.url) : null;
-                    if (pUrlObj) {
-                      pNorm = pUrlObj.pathname.toLowerCase().replace(/\/$/, '').trim();
-                    }
-                  } catch (e) {}
-                  debugLog(`  ${i + 1}. ${p.url} -> ${pNorm}`, 'warn');
-                });
-              }
-            }
-          } else {
-            debugLog('[Schema Coverage] No pages array available in schemaData', 'warn');
-            debugLog('[Schema Coverage] This usually means the schema audit hasn\'t been run yet, or the data is missing from localStorage/Supabase.', 'info');
-          }
-        } else {
-          debugLog('[Schema Coverage] No schemaAudit.data in saved audit, trying async fetch...', 'warn');
-        }
-        
-        // Always try async fetch to ensure we have the latest schema data
-        // This will update the schema section even if sync data was found
-        if (typeof getSchemaCoverageForUrl === 'function' && scorecardData.ranking_url) {
-          getSchemaCoverageForUrl(scorecardData.ranking_url).then(coverage => {
-            // Re-render just the schema section
-            const schemaSection = contentEl.querySelector('[data-scorecard-section="schema"]');
-            if (schemaSection) {
-              let schemaHtml = '';
-              schemaHtml += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">4. Schema & rich results</h5>`;
-              schemaHtml += `<div style="padding-left: 0.75rem;">`;
-              
-              if (coverage) {
-                schemaHtml += `<div style="margin-bottom: 0.75rem;">`;
-                schemaHtml += `<div style="font-size: 0.875rem; color: #1e293b; margin-bottom: 0.5rem; font-weight: 500;">Schema coverage for this page:</div>`;
-                schemaHtml += `<div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.875rem; color: #1e293b;">`;
-                schemaHtml += `<span>FAQ: ${coverage.hasFAQ ? '‚úÖ' : '‚ùå'}</span>`;
-                schemaHtml += `<span>HowTo: ${coverage.hasHowTo ? '‚úÖ' : '‚ùå'}</span>`;
-                schemaHtml += `<span>Event/Product: ${(coverage.hasEvent || coverage.hasProduct) ? '‚úÖ' : '‚ùå'}</span>`;
-                schemaHtml += `<span>Breadcrumb: ${coverage.hasBreadcrumb ? '‚úÖ' : '‚ùå'}</span>`;
-                schemaHtml += `<span>ImageObject: ${coverage.hasImageObject ? '‚úÖ' : '‚ùå'}</span>`;
-                schemaHtml += `</div></div>`;
-                
-                let schemaInterpretation = '';
-                if (scorecardData.segment && scorecardData.segment.toLowerCase() === 'education' && !coverage.hasFAQ) {
-                  schemaInterpretation = 'This education page has no FAQ schema. Adding an FAQ block could help snippet richness for this keyword.';
-                } else if ((scorecardData.page_type === 'Event' || scorecardData.page_type === 'Product') && !coverage.hasEvent && !coverage.hasProduct) {
-                  schemaInterpretation = 'This looks like a money page but no Event/Product schema was detected. Adding Event or Product schema could improve visibility in commercial results.';
-                } else if (coverage.hasFAQ && (coverage.hasEvent || coverage.hasProduct) && coverage.hasBreadcrumb) {
-                  schemaInterpretation = 'Core schema types are already present for this page. Further gains are more likely to come from authority/behaviour than new schema types.';
-                } else {
-                  schemaInterpretation = 'Some schema types are present. Review the Content/Schema pillar for a complete assessment.';
-                }
-                schemaHtml += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">${schemaInterpretation}</p>`;
-                debugLog('[Schema Coverage] ‚úÖ Updated schema section with async data', 'success');
-              } else {
-                // No coverage data found - show helpful message explaining data coverage gap
-                const rankingUrl = scorecardData.ranking_url || 'unknown';
-                const normalizedUrl = normalizeUrlForMatching(rankingUrl);
-                debugLog(`[Schema Coverage] ‚ùå No schema audit data found for ranking URL: ${rankingUrl} (normalized: ${normalizedUrl})`, 'warn');
-                debugLog(`[Schema Coverage] This usually means the URL wasn't in the last schema crawl. The page may have schema, but it wasn't scanned in the most recent audit.`, 'info');
-                schemaHtml += `<p style="color: #1e293b; font-size: 0.8125rem; line-height: 1.6; font-weight: 400;">Schema coverage data not available for this URL. This usually means the URL wasn't included in the last schema crawl. Check the Content/Schema pillar for a full schema audit, or run a new schema audit to include this page.</p>`;
-              }
-              
-              schemaHtml += `</div></div>`;
-              schemaSection.innerHTML = schemaHtml;
-            }
-          }).catch(err => {
-            const rankingUrl = scorecardData.ranking_url || 'unknown';
-            debugLog(`[Schema Coverage] Async fetch failed for URL ${rankingUrl}: ${err.message}`, 'warn');
-            debugLog(`[Schema Coverage] This usually means the URL wasn't in the last schema crawl. The page may have schema, but it wasn't scanned in the most recent audit.`, 'info');
-            // Update the loading message to show error
-            const schemaSection = contentEl.querySelector('[data-scorecard-section="schema"]');
-            if (schemaSection) {
-              const loadingMsg = schemaSection.querySelector('[id^="schema-coverage-loading-"]');
-              if (loadingMsg) {
-                loadingMsg.textContent = 'Unable to load schema coverage. This usually means the URL wasn\'t included in the last schema crawl. Check the Content/Schema pillar for a full schema audit, or run a new schema audit to include this page.';
-              }
-            }
-          });
-        }
-      } catch (e) {
-        debugLog('[Schema Coverage] Error in sync check: ' + e.message, 'warn');
-      }
-      
-      if (schemaCoverage) {
-        // Show checklist
-        html += `<div style="margin-bottom: 0.75rem;">`;
-        html += `<div style="font-size: 0.875rem; color: #3d3d3d; margin-bottom: 0.5rem; font-weight: 500;">Schema coverage for this page:</div>`;
-        html += `<div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">`;
-        html += `<span>FAQ: ${schemaCoverage.hasFAQ ? '‚úÖ' : '‚ùå'}</span>`;
-        html += `<span>HowTo: ${schemaCoverage.hasHowTo ? '‚úÖ' : '‚ùå'}</span>`;
-        html += `<span>Event/Product: ${(schemaCoverage.hasEvent || schemaCoverage.hasProduct) ? '‚úÖ' : '‚ùå'}</span>`;
-        html += `<span>Breadcrumb: ${schemaCoverage.hasBreadcrumb ? '‚úÖ' : '‚ùå'}</span>`;
-        html += `<span>ImageObject: ${schemaCoverage.hasImageObject ? '‚úÖ' : '‚ùå'}</span>`;
-        html += `</div>`;
-        html += `</div>`;
-        
-        // Interpretation based on schema coverage
-        let schemaInterpretation = '';
-        if (scorecardData.segment && scorecardData.segment.toLowerCase() === 'education' && !schemaCoverage.hasFAQ) {
-          schemaInterpretation = 'This education page has no FAQ schema. Adding an FAQ block could help snippet richness for this keyword.';
-        } else if ((scorecardData.page_type === 'Event' || scorecardData.page_type === 'Product') && !schemaCoverage.hasEvent && !schemaCoverage.hasProduct) {
-          schemaInterpretation = 'This looks like a money page but no Event/Product schema was detected. Adding Event or Product schema could improve visibility in commercial results.';
-        } else if (schemaCoverage.hasFAQ && (schemaCoverage.hasEvent || schemaCoverage.hasProduct) && schemaCoverage.hasBreadcrumb) {
-          schemaInterpretation = 'Core schema types are already present for this page. Further gains are more likely to come from authority/behaviour than new schema types.';
-        } else {
-          schemaInterpretation = 'Some schema types are present. Review the Content/Schema pillar for a complete assessment.';
-        }
-        html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">${schemaInterpretation}</p>`;
-      } else if (schemaSummary && schemaSummary.totalPagesCount > 0) {
-        // We have schema audit snapshot, but no per-URL schemaTypes mapping available for this keyword URL
-        html += `<div style="margin-bottom: 0.75rem;">`;
-        html += `<div style="font-size: 0.875rem; color: #3d3d3d; margin-bottom: 0.5rem; font-weight: 500;">Site-wide schema snapshot (from latest audit):</div>`;
-        html += `<div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">`;
-        html += `<span>Coverage: <strong>${schemaSummary.coveragePct.toFixed(1)}%</strong></span>`;
-        html += `<span>¬∑</span>`;
-        html += `<span>Pages with schema: <strong>${schemaSummary.pagesWithSchemaCount.toLocaleString()}</strong> / ${schemaSummary.totalPagesCount.toLocaleString()}</span>`;
-        if (schemaSummary.uniqueTypesCount > 0) {
-          html += `<span>¬∑</span>`;
-          html += `<span>Types detected: <strong>${schemaSummary.uniqueTypesCount}</strong></span>`;
-        }
-        html += `</div>`;
-        html += `</div>`;
-        html += `<p style="color: #64748b; font-size: 0.875rem; line-height: 1.5;">Per-page schema types aren‚Äôt available for this specific URL in the current snapshot. Run a fresh schema crawl (or include this URL in the crawl set) to get URL-level rich-result flags here.</p>`;
-      } else {
-        // Show loading state if async fetch is in progress, otherwise show fallback
-        // The async fetch will update this section if data is found
-        const rankingUrl = scorecardData.ranking_url || 'unknown';
-        debugLog(`[Schema Coverage] No schema data found in sync check for URL: ${rankingUrl}. Trying async fetch...`, 'info');
-        html += `<p style="color: #64748b; font-size: 0.875rem; line-height: 1.5;" id="schema-coverage-loading-${Date.now()}">Checking schema coverage...</p>`;
-      }
-      html += `</div></div>`;
-
-      // 5. AI usage
-      html += `<div class="scorecard-section">`;
-      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">5. AI usage</h5>`;
-      html += `<div style="padding-left: 0.75rem;">`;
-      
-      // Format AI status with citation details
-      const aiTotal = row.ai_total_citations || 0;
-      const aiOurs = row.ai_alan_citations_count || 0;
-      let aiStatusText = '';
-      if (row.has_ai_overview) {
-        if (aiOurs > 0) {
-          aiStatusText = `AI Overview present, cited in ${aiOurs}/${aiTotal} citation${aiTotal !== 1 ? 's' : ''}`;
-          if (aiOurs / aiTotal < 0.33) {
-            aiStatusText += ' (light)';
-          }
-        } else {
-          aiStatusText = 'AI Overview present, not cited';
-        }
-      } else {
-        aiStatusText = 'AI Overview not present';
-      }
-      
-      html += `<p style="font-size: 0.875rem; color: #3d3d3d; line-height: 1.6; margin-bottom: 0.5rem; font-weight: 400;">${aiStatusText}</p>`;
-      
-      // Show cited pages list
-      if (scorecardData.ai_citations_ours > 0 && scorecardData.ai_alan_citations && scorecardData.ai_alan_citations.length > 0) {
-        html += `<div style="font-size: 0.875rem; color: #3d3d3d; margin-bottom: 0.25rem; font-weight: 500;">Your cited pages:</div>`;
-        html += `<ul style="margin-top: 0.25rem; padding-left: 1.5rem; font-size: 0.875rem; line-height: 1.6; color: #3d3d3d; font-weight: 400;">`;
-        scorecardData.ai_alan_citations.forEach(c => {
-          html += `<li><a href="${c.url}" target="_blank" rel="noopener noreferrer" style="color: #0284c7;">${c.title || c.url}</a></li>`;
-        });
-        html += `</ul>`;
-      }
-      html += `</div></div>`;
-
-      // 6. SERP features
-      html += `<div class="scorecard-section">`;
-      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">6. SERP features</h5>`;
-      html += `<div style="padding-left: 0.75rem;">`;
-      
-      // Get SERP feature presence from scorecardData
-      const hasAiOverview = scorecardData.ai_overview_present_any === true;
-      const hasLocalPack = scorecardData.local_pack_present_any === true;
-      const hasPaa = scorecardData.paa_present_any === true;
-      const hasFeaturedSnippet = scorecardData.featured_snippet_present_any === true;
-      
-      // Count features present
-      const featuresPresent = [hasAiOverview, hasLocalPack, hasPaa, hasFeaturedSnippet].filter(Boolean).length;
-      
-      html += `<div style="margin-bottom: 0.75rem;">`;
-      html += `<div style="font-size: 0.875rem; color: #1e293b; margin-bottom: 0.5rem; font-weight: 500;">SERP features present for this keyword:</div>`;
-      html += `<div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.875rem; color: #1e293b;">`;
-      html += `<span>AI Overview: ${hasAiOverview ? '‚úÖ' : '‚ùå'}</span>`;
-      html += `<span>Local pack: ${hasLocalPack ? '‚úÖ' : '‚ùå'}</span>`;
-      html += `<span>People Also Ask: ${hasPaa ? '‚úÖ' : '‚ùå'}</span>`;
-      html += `<span>Featured snippet: ${hasFeaturedSnippet ? '‚úÖ' : '‚ùå'}</span>`;
-      html += `</div>`;
-      html += `<div style="margin-top: 0.5rem; font-size: 0.875rem; color: #64748b;">${featuresPresent}/4 features present</div>`;
-      html += `</div>`;
-      
-      // Interpretation based on SERP features
-      let serpInterpretation = '';
-      if (featuresPresent === 4) {
-        serpInterpretation = 'All major SERP features are present for this keyword. This indicates strong competition and multiple opportunities for visibility.';
-      } else if (featuresPresent >= 2) {
-        serpInterpretation = 'Multiple SERP features are present. Focus on optimizing for the features where you\'re not yet visible.';
-      } else if (hasAiOverview && !hasLocalPack && !hasPaa && !hasFeaturedSnippet) {
-        serpInterpretation = 'Only AI Overview is present. This keyword may benefit from local optimization (if applicable) or FAQ schema to trigger People Also Ask.';
-      } else if (hasLocalPack && !hasAiOverview) {
-        serpInterpretation = 'Local pack is present but no AI Overview. This suggests local intent; ensure your local entity is optimized.';
-      } else {
-        serpInterpretation = 'Few SERP features are present. This keyword may have lower competition or less rich result potential.';
-      }
-      html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">${serpInterpretation}</p>`;
-      html += `</div></div>`;
-
-      // Summary line is now included in the keyword header section above
-
-      // Update the content element - everything is now in one container
-      const kwEl = document.getElementById("ranking-ai-detail-keyword");
-      if (kwEl) kwEl.innerHTML = html;
-      
-      // Hide the separate summary element since it's now included in the main HTML
-      const sumEl = document.getElementById("ranking-ai-detail-summary");
-      if (sumEl) sumEl.style.display = 'none';
-      
-      // Fetch page totals and query‚Üípages breakdown asynchronously
-      const pageTotalsEl = document.getElementById(`scorecard-page-totals-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}`);
-      const queryPagesEl = document.getElementById(`scorecard-query-pages-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}`);
-      
-      // Fetch page-only totals for best_url
-      if (pageTotalsEl && scorecardData.ranking_url) {
-        (async () => {
-          try {
-            const savedAudit = loadAuditResultsSync();
-            const propertyUrl = savedAudit?.propertyUrl || window.lastAuditPropertyUrl || 'https://www.alanranger.com';
-            
-            // Calculate date range using centralized helper (last 28 days, ending yesterday - matches GSC UI)
-            const { startDate, endDate } = getGscDateRange(GSC_WINDOW_DAYS, 2);
-            
-            // Use canonical targetUrl for GSC page filter
-            const pageUrlForGsc = scorecardData.targetUrl || scorecardData.ranking_url || '';
-            const response = await fetch(apiUrl(`/api/aigeo/gsc-page-totals?property=${encodeURIComponent(propertyUrl)}&pageUrl=${encodeURIComponent(pageUrlForGsc)}&startDate=${startDate}&endDate=${endDate}`));
-            
-            if (response.ok) {
-              const data = await response.json();
-              if (data.status === 'ok' && data.data) {
-                const pageData = data.data;
-                let pageHtml = '';
-                pageHtml += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.5; color: #3d3d3d; font-weight: 400;">`;
-                pageHtml += `<span>Clicks: <strong style="color: #1e293b;">${pageData.clicks.toLocaleString()}</strong></span>`;
-                pageHtml += `</div>`;
-                pageHtml += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.5; color: #3d3d3d; font-weight: 400;">`;
-                pageHtml += `<span>Impressions: <strong style="color: #1e293b;">${pageData.impressions.toLocaleString()}</strong></span>`;
-                pageHtml += `</div>`;
-                pageHtml += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.5; color: #3d3d3d; font-weight: 400;">`;
-                pageHtml += `<span>CTR: <strong style="color: #1e293b;">${(pageData.ctr).toFixed(1)}%</strong></span>`;
-                pageHtml += `</div>`;
-                pageHtml += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.5; color: #3d3d3d; font-weight: 400;">`;
-                pageHtml += `<span>Avg position: <strong style="color: #1e293b;">${Math.round(pageData.position)}</strong></span>`;
-                pageHtml += `</div>`;
-                pageTotalsEl.innerHTML = pageHtml;
-              } else {
-                pageTotalsEl.innerHTML = `<div style="color: #64748b; font-size: 0.875rem;">No page totals returned for this URL in the last 28 days.</div>`;
-              }
-            } else {
-              pageTotalsEl.innerHTML = `<div style="color: #64748b; font-size: 0.875rem;">Unable to load page totals.</div>`;
-            }
-          } catch (err) {
-            console.error('Error fetching page totals:', err);
-            pageTotalsEl.innerHTML = `<div style="color: #64748b; font-size: 0.875rem;">Error loading page totals: ${err.message}</div>`;
-          }
-        })();
-      }
-      
-      // Fetch query‚Üípages breakdown
-      if (queryPagesEl) {
-        (async () => {
-          try {
-            const savedAudit = loadAuditResultsSync();
-            const propertyUrl = savedAudit?.propertyUrl || window.lastAuditPropertyUrl || 'https://www.alanranger.com';
-            
-            // Calculate date range using centralized helper (last 28 days, ending yesterday - matches GSC UI)
-            const { startDate, endDate } = getGscDateRange(GSC_WINDOW_DAYS, 2);
-            
-            const response = await fetch(apiUrl(`/api/aigeo/gsc-query-pages?property=${encodeURIComponent(propertyUrl)}&query=${encodeURIComponent(scorecardData.keyword)}&startDate=${startDate}&endDate=${endDate}`));
-            
-            if (response.ok) {
-              const data = await response.json();
-              if (data.status === 'ok' && data.data && data.data.pages) {
-                const pages = data.data.pages;
-                // Use canonical targetUrl for matching
-                const bestUrl = scorecardData.targetUrl || scorecardData.ranking_url || '';
-                const normalizedBestUrl = bestUrl ? normalizeGscPageUrl(bestUrl) : null;
-                
-                let pagesHtml = '';
-                if (pages.length === 0) {
-                  pagesHtml = `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">No pages found with impressions for this keyword.</div>`;
-                } else {
-                  // Separate best URL from other pages
-                  const bestUrlPage = pages.find(page => {
-                    const normalizedPageUrl = normalizeGscPageUrl(page.page);
-                    return normalizedBestUrl && normalizedPageUrl === normalizedBestUrl;
-                  });
-                  const otherPages = pages.filter(page => {
-                    const normalizedPageUrl = normalizeGscPageUrl(page.page);
-                    return !normalizedBestUrl || normalizedPageUrl !== normalizedBestUrl;
-                  });
-                  
-                  const tableId = `query-pages-table-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}`;
-                  const collapsedRowsId = `query-pages-collapsed-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}`;
-                  
-                  pagesHtml += `<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem; margin-top: 0.5rem;" id="${tableId}">`;
-                  pagesHtml += `<thead><tr style="border-bottom: 1px solid #e5e7eb;">`;
-                  pagesHtml += `<th style="text-align: left; padding: 0.5rem; font-weight: 600; color: #374151;">Page URL</th>`;
-                  pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Clicks</th>`;
-                  pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Impressions</th>`;
-                  pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">CTR</th>`;
-                  pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Position</th>`;
-                  pagesHtml += `</tr></thead><tbody>`;
-                  
-                  // Always show best URL row (yellow highlighted)
-                  if (bestUrlPage) {
-                    pagesHtml += `<tr style="background: #fef3c7; border-left: 3px solid #f59e0b; border-bottom: 1px solid #e5e7eb;">`;
-                    pagesHtml += `<td style="padding: 0.5rem; word-break: break-word;">`;
-                    pagesHtml += `<strong style="color: #92400e;">${bestUrlPage.page}</strong> <span style="font-size: 0.75rem; color: #64748b;">(DataForSEO best URL)</span>`;
-                    pagesHtml += `</td>`;
-                    pagesHtml += `<td style="text-align: right; padding: 0.5rem;">${bestUrlPage.clicks.toLocaleString()}</td>`;
-                    pagesHtml += `<td style="text-align: right; padding: 0.5rem;">${bestUrlPage.impressions.toLocaleString()}</td>`;
-                    pagesHtml += `<td style="text-align: right; padding: 0.5rem;">${(bestUrlPage.ctr).toFixed(1)}%</td>`;
-                    pagesHtml += `<td style="text-align: right; padding: 0.5rem;">${Math.round(bestUrlPage.position)}</td>`;
-                    pagesHtml += `</tr>`;
-                  }
-                  
-                  // Collapsible section for other pages
-                  if (otherPages.length > 0) {
-                    pagesHtml += `</tbody></table>`;
-                    pagesHtml += `<div style="margin-top: 0.5rem;">`;
-                    pagesHtml += `<button onclick="const el = document.getElementById('${collapsedRowsId}'); el.style.display = el.style.display === 'none' ? 'table' : 'none'; this.textContent = el.style.display === 'none' ? 'Show ' + ${otherPages.length} + ' other page' + (${otherPages.length} !== 1 ? 's' : '') : 'Hide other pages';" style="background: #f3f4f6; border: 1px solid #d1d5db; border-radius: 4px; padding: 0.375rem 0.75rem; font-size: 0.875rem; color: #3d3d3d; cursor: pointer; font-weight: 400;">Show ${otherPages.length} other page${otherPages.length !== 1 ? 's' : ''}</button>`;
-                    pagesHtml += `</div>`;
-                    pagesHtml += `<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem; margin-top: 0.5rem; display: none;" id="${collapsedRowsId}">`;
-                    pagesHtml += `<thead><tr style="border-bottom: 1px solid #e5e7eb;">`;
-                    pagesHtml += `<th style="text-align: left; padding: 0.5rem; font-weight: 600; color: #374151;">Page URL</th>`;
-                    pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Clicks</th>`;
-                    pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Impressions</th>`;
-                    pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">CTR</th>`;
-                    pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Position</th>`;
-                    pagesHtml += `</tr></thead><tbody>`;
-                    
-                    otherPages.forEach(page => {
-                      pagesHtml += `<tr style="border-bottom: 1px solid #e5e7eb;">`;
-                      pagesHtml += `<td style="padding: 0.5rem; word-break: break-word; color: #3d3d3d;">${page.page}</td>`;
-                      pagesHtml += `<td style="text-align: right; padding: 0.5rem; color: #3d3d3d;">${page.clicks.toLocaleString()}</td>`;
-                      pagesHtml += `<td style="text-align: right; padding: 0.5rem; color: #3d3d3d;">${page.impressions.toLocaleString()}</td>`;
-                      pagesHtml += `<td style="text-align: right; padding: 0.5rem; color: #3d3d3d;">${(page.ctr).toFixed(1)}%</td>`;
-                      pagesHtml += `<td style="text-align: right; padding: 0.5rem; color: #3d3d3d;">${Math.round(page.position)}</td>`;
-                      pagesHtml += `</tr>`;
-                    });
-                    
-                    pagesHtml += `</tbody></table>`;
-                  } else {
-                    pagesHtml += `</tbody></table>`;
-                  }
-                }
-                queryPagesEl.innerHTML = pagesHtml;
-              } else {
-                queryPagesEl.innerHTML = `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">No pages found with impressions for this keyword.</div>`;
-              }
-            } else {
-              queryPagesEl.innerHTML = `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">Unable to load pages breakdown.</div>`;
-            }
-          } catch (err) {
-            console.error('Error fetching query‚Üípages breakdown:', err);
-            queryPagesEl.innerHTML = `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">Error loading pages breakdown: ${err.message}</div>`;
-          }
-        })();
-      }
-
-      // Update AI citations section in right panel
-      const citationsEmpty = document.getElementById("ranking-ai-citations-empty");
-      const citationsContent = document.getElementById("ranking-ai-citations-content");
-      const ourList = document.getElementById("ranking-ai-detail-our-pages");
-      const compTbody = document.getElementById("ranking-ai-detail-competitors-body");
-
-      if (citationsEmpty && citationsContent) {
-        citationsEmpty.hidden = true;
-        citationsContent.hidden = false;
-
-        if (ourList) {
-          ourList.innerHTML = "";
-          if (!row.ai_alan_citations || !row.ai_alan_citations.length) {
-            const li = document.createElement("li");
-            li.textContent = "No alanranger.com citations found for this AI Overview.";
-            ourList.appendChild(li);
-          } else {
-            row.ai_alan_citations.forEach(c => {
-              const li = document.createElement("li");
-              const a = document.createElement("a");
-              a.href = c.url;
-              a.target = "_blank";
-              a.rel = "noopener noreferrer";
-              a.textContent = c.title || c.url;
-              li.appendChild(a);
-              ourList.appendChild(li);
-            });
-          }
-        }
-
-        if (compTbody) {
-          compTbody.innerHTML = "";
-          const entries = Object.entries(row.competitor_counts || {}).sort((a, b) => b[1] - a[1]);
-          if (!entries.length) {
-            const tr = document.createElement("tr");
-            const td = document.createElement("td");
-            td.colSpan = 5;
-            td.style.padding = "1rem 0.75rem";
-            td.style.color = "#64748b";
-            td.style.fontSize = "0.875rem";
-            td.textContent = "No competing domains recorded from AI citations for this keyword.";
-            tr.appendChild(td);
-            compTbody.appendChild(tr);
-          } else {
-            const makeDomainHref = (domain) => {
-              if (!domain) return null;
-              const d = String(domain).trim();
-              if (!d) return null;
-              if (d.startsWith('http://') || d.startsWith('https://')) return d;
-              return `https://${d}`;
-            };
-            
-            // Fetch domain metadata for all domains
-            const domainsList = entries.map(([d]) => d);
-            (async () => {
-              const domainMetadata = await fetchDomainMetadataForDomains(domainsList);
-              
-              entries.forEach(([domain, count]) => {
-                const tr = document.createElement("tr");
-                tr.style.borderTop = "1px solid #e2e8f0";
-
-                const normalizedDomain = normalizeDomainForStrength(domain);
-                const meta = domainMetadata[normalizedDomain] || { domain_type: 'unmapped', is_competitor: false };
-
-                const tdDomain = document.createElement("td");
-                tdDomain.style.padding = "0.5rem 0.4rem";
-                tdDomain.style.fontSize = "0.8rem";
-                tdDomain.style.wordWrap = "break-word";
-                tdDomain.style.overflowWrap = "break-word";
-                const domainContainer = document.createElement("div");
-                domainContainer.style.display = "flex";
-                domainContainer.style.flexDirection = "column";
-                domainContainer.style.alignItems = "flex-start";
-                domainContainer.style.gap = "0.25rem";
-                
-                const domainLinkWrapper = document.createElement("div");
-                domainLinkWrapper.style.width = "100%";
-                const href = makeDomainHref(domain);
-                if (href) {
-                  const a = document.createElement("a");
-                  a.href = href;
-                  a.target = "_blank";
-                  a.rel = "noopener noreferrer";
-                  a.style.color = "#0284c7";
-                  a.style.textDecoration = "none";
-                  a.style.wordBreak = "break-word";
-                  a.style.overflowWrap = "break-word";
-                  a.textContent = domain;
-                  domainLinkWrapper.appendChild(a);
-                } else {
-                  domainLinkWrapper.appendChild(document.createTextNode(String(domain || '')));
-                }
-                domainContainer.appendChild(domainLinkWrapper);
-
-        // Add competitor badge if is_competitor is true - below the domain
-        if (meta.is_competitor) {
-          const badge = document.createElement("span");
-          badge.textContent = "Competitor";
-          badge.setAttribute('data-competitor-badge', 'true');
-          badge.style.display = "inline-block";
-          badge.style.padding = "0.125rem 0.5rem";
-          badge.style.fontSize = "0.65rem";
-          badge.style.fontWeight = "600";
-          badge.style.color = "#dc2626";
-          badge.style.backgroundColor = "#fee2e2";
-          badge.style.borderRadius = "4px";
-          badge.style.border = "1px solid #fecaca";
-          badge.style.marginTop = "0.125rem";
-          domainContainer.appendChild(badge);
-        }
-
-        tdDomain.appendChild(domainContainer);
-
-                const tdCount = document.createElement("td");
-                tdCount.style.padding = "0.5rem 0.4rem";
-                tdCount.style.textAlign = "center";
-                tdCount.style.fontWeight = "700";
-                tdCount.style.color = "#1e293b";
-                tdCount.style.fontSize = "0.8rem";
-                tdCount.textContent = `${count}`;
-
-                const tdRank = document.createElement("td");
-                tdRank.style.padding = "0.5rem 0.4rem";
-                tdRank.style.textAlign = "right";
-                tdRank.style.color = "#64748b";
-                tdRank.style.fontSize = "0.8rem";
-                tdRank.textContent = "‚Äî";
-                tdRank.dataset.domain = normalizedDomain;
-
-                const tdDomainType = document.createElement("td");
-                tdDomainType.style.padding = "0.5rem 0.4rem";
-                tdDomainType.style.fontSize = "0.8rem";
-                tdDomainType.style.wordWrap = "break-word";
-                tdDomainType.style.overflowWrap = "break-word";
-                // Show domain type, but hide "unmapped" (show blank instead)
-                const displayType = meta.domain_type && meta.domain_type !== 'unmapped' ? meta.domain_type : '';
-                tdDomainType.textContent = displayType;
-                tdDomainType.style.color = displayType ? '#475569' : '#94a3b8';
-
-                const tdCompetitor = document.createElement("td");
-                tdCompetitor.style.padding = "0.5rem 0.4rem";
-                tdCompetitor.style.textAlign = "center";
-                tdCompetitor.style.fontSize = "0.8rem";
-                tdCompetitor.style.minWidth = "80px";
-                const competitorCheckbox = document.createElement("input");
-                competitorCheckbox.type = "checkbox";
-                competitorCheckbox.checked = meta.is_competitor === true;
-                competitorCheckbox.style.cursor = "pointer";
-                competitorCheckbox.dataset.domain = normalizedDomain;
-                
-                competitorCheckbox.addEventListener('change', async (e) => {
-                  const isCompetitor = e.target.checked;
-                  const domain = e.target.dataset.domain;
-                  try {
-                    const resp = await fetch(apiUrl('/api/domain-strength/update-domain'), {
-                      method: 'POST',
-                      headers: { 'Content-Type': 'application/json' },
-                      body: JSON.stringify({ domain, is_competitor: isCompetitor })
-                    });
-                    if (resp.ok) {
-                      // Clear cache
-                      __domainMetadataCache.delete(domain);
-                      // Update badge - find domainContainer first
-                      const domainContainer = tdDomain.querySelector('div[style*="flex-direction: column"]') || tdDomain.querySelector('div');
-                      let badge = tdDomain.querySelector('span[data-competitor-badge]');
-                      if (isCompetitor && !badge && domainContainer) {
-                        badge = document.createElement("span");
-                        badge.textContent = "Competitor";
-                        badge.setAttribute('data-competitor-badge', 'true');
-                        badge.style.display = "inline-block";
-                        badge.style.padding = "0.125rem 0.5rem";
-                        badge.style.fontSize = "0.65rem";
-                        badge.style.fontWeight = "600";
-                        badge.style.color = "#dc2626";
-                        badge.style.backgroundColor = "#fee2e2";
-                        badge.style.borderRadius = "4px";
-                        badge.style.border = "1px solid #fecaca";
-                        badge.style.marginTop = "0.125rem";
-                        domainContainer.appendChild(badge);
-                      } else if (!isCompetitor && badge) {
-                        badge.remove();
-                      }
-                    } else {
-                      // Revert on error
-                      e.target.checked = !isCompetitor;
-                      alert('Failed to update competitor flag. Please try again.');
-                    }
-                  } catch (err) {
-                    e.target.checked = !isCompetitor;
-                    alert('Failed to update competitor flag. Please try again.');
-                  }
-                });
-                
-                tdCompetitor.appendChild(competitorCheckbox);
-
-                tr.appendChild(tdDomain);
-                tr.appendChild(tdCount);
-                tr.appendChild(tdRank);
-                tr.appendChild(tdDomainType);
-                tr.appendChild(tdCompetitor);
-                compTbody.appendChild(tr);
-              });
-              
-              // Fill Domain Rank column AFTER all rows are appended to DOM
-              try {
-                const selfDomain = typeof getSelfDomainForDomainStrength === "function" ? getSelfDomainForDomainStrength() : "alanranger.com";
-                const domains = [
-                  selfDomain,
-                  ...entries.map(([d]) => d),
-                ].map(normalizeDomainForStrength).filter(Boolean);
-                const strengthByDomain = await fetchLatestDomainStrengthForDomains(domains);
-                const rankCells = compTbody.querySelectorAll("td[data-domain]");
-                if (rankCells.length === 0) {
-                  debugLog('‚ö†Ô∏è No Domain Rank cells found with data-domain attribute in AI Citations table', 'warn');
-                } else {
-                  debugLog(`‚úì Filling Domain Rank for ${rankCells.length} domains in AI Citations table`, 'info');
-                }
-                rankCells.forEach((cell) => {
-                  const d = normalizeDomainForStrength(cell.dataset.domain || "");
-                  const strength = strengthByDomain[d] || null;
-                  cell.innerHTML = renderDomainRankCellHtml(strength);
-                });
-              } catch (err) {
-                debugLog(`‚úó Error filling Domain Rank in AI Citations table: ${err.message}`, 'error');
-              }
-            })();
-          }
-        }
-      } else if (citationsEmpty) {
-        citationsEmpty.hidden = false;
-      }
-    }
-
-    // Keep renderRankingAiDetail as alias for backward compatibility
-    async function renderRankingAiDetail(row) {
-      await renderKeywordScorecard(row);
-    }
-
-    // ======================
-    // Domain Rank (Domain Strength snapshots) for Keyword tables
-    // ======================
-    const __domainStrengthLatestCache = new Map(); // domain -> { score, band, snapshotDate }
-    const __domainMetadataCache = new Map(); // domain -> { domain_type, is_competitor }
-
-    function normalizeDomainForStrength(input) {
-      const raw = String(input || "").trim().toLowerCase();
-      if (!raw) return "";
-      try {
-        if (raw.includes("://")) return new URL(raw).hostname.replace(/^www\./, "");
-      } catch {
-        // ignore
-      }
-      return raw.replace(/^www\./, "").split("/")[0];
-    }
-
-    function renderDomainStrengthBandPillOriginal(band) {
-      const label = String(band || "").trim();
-      if (!label) return "";
-      const key = typeof domainStrengthBandKey === "function" ? domainStrengthBandKey(label) : "na";
-      return `<span class="domain-strength-badge domain-strength-badge--${key}">${label}</span>`;
-    }
-
-    function renderDomainRankCellHtml(strength) {
-      if (!strength || typeof strength !== "object") {
-        return `<span title="No domain strength snapshot yet">‚Äî</span>`;
-      }
-      const score = typeof strength.score === "number" && isFinite(strength.score) ? strength.score : null;
-      const band = typeof strength.band === "string" ? strength.band : "";
-      if (score === null) {
-        return `<span title="No domain strength snapshot yet">‚Äî</span>`;
-      }
-      const pill = renderDomainStrengthBandPillOriginal(band);
-      const scoreRounded = Math.round(score);
-      // Left-align numbers in fixed-width container so they line up vertically
-      return `<div style="display:flex; justify-content:flex-start; gap:0.25rem; align-items:center;">
-        <span style="display:inline-block; width:2.5rem; text-align:left; font-weight:800; color:#0f172a; font-size: 0.8rem;">${scoreRounded}</span>
-        ${pill || ""}
-      </div>`;
-    }
-
-    async function fetchLatestDomainStrengthForDomains(domains) {
-      const list = Array.isArray(domains) ? domains.map(normalizeDomainForStrength).filter(Boolean) : [];
-      const unique = Array.from(new Set(list)).slice(0, 30);
-      if (!unique.length) return {};
-
-      // Serve from cache when available
-      const out = {};
-      const missing = [];
-      for (const d of unique) {
-        if (__domainStrengthLatestCache.has(d)) {
-          out[d] = __domainStrengthLatestCache.get(d);
-        } else {
-          missing.push(d);
-        }
-      }
-      if (!missing.length) return out;
-
-      try {
-        const qs = encodeURIComponent(missing.join(","));
-        const resp = await fetch(apiUrl(`/api/domain-strength/history?domains=${qs}`));
-        if (!resp.ok) return out;
-        const json = await resp.json();
-        const rows = json?.status === "ok" ? (json.data || []) : [];
-
-        // Build latest per domain (google engine only)
-        const latestByDomain = {};
-        for (const r of rows) {
-          const d = normalizeDomainForStrength(r?.domain);
-          if (!d) continue;
-          if (String(r?.engine || "google").toLowerCase() !== "google") continue;
-          const date = String(r?.snapshot_date || "");
-          const score = typeof r?.score === "number" ? r.score : parseFloat(r?.score);
-          const band = typeof r?.band === "string" ? r.band : "";
-          if (!date) continue;
-          const prev = latestByDomain[d];
-          if (!prev || String(prev.snapshotDate) < date) {
-            latestByDomain[d] = { score: isFinite(score) ? score : null, band: band || null, snapshotDate: date };
-          }
-        }
-
-        for (const d of missing) {
-          const v = latestByDomain[d] || { score: null, band: null, snapshotDate: null };
-          __domainStrengthLatestCache.set(d, v);
-          out[d] = v;
-        }
-      } catch {
-        // fail silently
-      }
-
-      return out;
-    }
-
-    async function fetchDomainMetadataForDomains(domains) {
-      const list = Array.isArray(domains) ? domains.map(normalizeDomainForStrength).filter(Boolean) : [];
-      const unique = Array.from(new Set(list));
-      if (!unique.length) return {};
-
-      // Serve from cache when available
-      const out = {};
-      const missing = [];
-      for (const d of unique) {
-        if (__domainMetadataCache.has(d)) {
-          out[d] = __domainMetadataCache.get(d);
-        } else {
-          missing.push(d);
-        }
-      }
-      if (!missing.length) return out;
-
-      try {
-        // Fetch metadata from domain_strength_domains via overview API
-        const qs = encodeURIComponent(missing.join(","));
-        const resp = await fetch(apiUrl(`/api/domain-strength/overview?domains=${qs}`));
-        if (!resp.ok) {
-          // If API fails, return defaults
-          for (const d of missing) {
-            out[d] = { domain_type: 'unmapped', is_competitor: false };
-            __domainMetadataCache.set(d, out[d]);
-          }
-          return out;
-        }
-        const json = await resp.json();
-        const items = json?.status === "ok" ? (json.items || []) : [];
-
-        // Build metadata map
-        for (const item of items) {
-          const d = normalizeDomainForStrength(item?.domain);
-          if (!d) continue;
-          const meta = {
-            domain_type: item?.domain_type || item?.segment || 'unmapped',
-            is_competitor: item?.isCompetitor === true || false
-          };
-          __domainMetadataCache.set(d, meta);
-          out[d] = meta;
-        }
-
-        // Fill in missing domains with defaults
-        for (const d of missing) {
-          if (!out[d]) {
-            out[d] = { domain_type: 'unmapped', is_competitor: false };
-            __domainMetadataCache.set(d, out[d]);
-          }
-        }
-      } catch (e) {
-        // If fetch fails, return defaults
-        for (const d of missing) {
-          out[d] = { domain_type: 'unmapped', is_competitor: false };
-          __domainMetadataCache.set(d, out[d]);
-        }
-      }
-
-      return out;
-    }
-
-    /**
-     * Backfill missing Domain Ranks for domains currently showing "‚Äî"
-     * Collects domains from "Other cited domains" table and competitor tables that have missing ranks
-     */
-    async function backfillMissingDomainRanks() {
-      const btn = document.getElementById('backfill-domain-ranks-btn');
-      if (!btn) return;
-      
-      // Disable button and show loading state
-      const originalText = btn.textContent;
-      btn.disabled = true;
-      btn.textContent = 'Backfilling...';
-      btn.style.opacity = '0.6';
-      btn.style.cursor = 'not-allowed';
-      
-      try {
-        // Collect domains with missing ranks from "Other cited domains" table
-        const compTbody = document.getElementById('ranking-ai-detail-competitors-body');
-        const missingDomains = new Set();
-        
-        if (compTbody) {
-          const rankCells = compTbody.querySelectorAll('td[data-domain]');
-          rankCells.forEach(cell => {
-            // Check if cell shows "‚Äî" (missing rank)
-            const cellText = cell.textContent.trim();
-            if (cellText === '‚Äî' || cellText === '') {
-              const domain = cell.dataset.domain;
-              if (domain) {
-                const normalized = normalizeDomainForStrength(domain);
-                if (normalized) {
-                  missingDomains.add(normalized);
-                }
-              }
-            }
-          });
-        }
-        
-        // Also check competitor tables in main ranking view
-        const competitorTbody = document.getElementById('ranking-ai-competitors-body');
-        if (competitorTbody) {
-          const competitorCells = competitorTbody.querySelectorAll('td[data-domain]');
-          competitorCells.forEach(cell => {
-            const cellText = cell.textContent.trim();
-            if (cellText === '‚Äî' || cellText === '') {
-              const domain = cell.dataset.domain;
-              if (domain) {
-                const normalized = normalizeDomainForStrength(domain);
-                if (normalized) {
-                  missingDomains.add(normalized);
-                }
-              }
-            }
-          });
-        }
-        
-        const domainsToBackfill = Array.from(missingDomains);
-        
-        if (domainsToBackfill.length === 0) {
-          alert('No domains with missing ranks found. All domains already have Domain Rank values.');
-          return;
-        }
-        
-        debugLog(`üîÑ Backfilling Domain Rank for ${domainsToBackfill.length} domains: ${domainsToBackfill.slice(0, 10).join(', ')}${domainsToBackfill.length > 10 ? '...' : ''}`, 'info');
-        
-        // Call backfill API
-        const adminToken = localStorage.getItem('admin_token') || '';
-        const response = await fetch(apiUrl('/api/domain-strength/backfill'), {
-          method: 'POST',
-          headers: {
-            'Content-Type': 'application/json',
-            'x-admin-token': adminToken
-          },
-          body: JSON.stringify({
-            mode: 'list',
-            domains: domainsToBackfill,
-            maxNewDomains: domainsToBackfill.length,
-            dryRun: false,
-            source: 'ui-backfill'
-          })
-        });
-        
-        if (!response.ok) {
-          const errorText = await response.text();
-          throw new Error(`Backfill failed: ${errorText}`);
-        }
-        
-        const result = await response.json();
-        
-        if (result.status === 'ok') {
-          debugLog(`‚úÖ Backfill complete: ${result.processed} processed, ${result.skipped_existing} skipped, ${result.errors?.length || 0} errors`, 'success');
-          
-          // Clear domain strength cache for backfilled domains
-          domainsToBackfill.forEach(d => {
-            __domainStrengthLatestCache.delete(d);
-          });
-          
-          // Refresh domain rank cells
-          if (compTbody) {
-            const rankCells = compTbody.querySelectorAll('td[data-domain]');
-            const domains = Array.from(rankCells).map(cell => normalizeDomainForStrength(cell.dataset.domain || '')).filter(Boolean);
-            if (domains.length > 0) {
-              const strengthByDomain = await fetchLatestDomainStrengthForDomains(domains);
-              rankCells.forEach(cell => {
-                const d = normalizeDomainForStrength(cell.dataset.domain || '');
-                const strength = strengthByDomain[d] || null;
-                cell.innerHTML = renderDomainRankCellHtml(strength);
-              });
-            }
-          }
-          
-          // Also refresh competitor table if visible
-          if (competitorTbody) {
-            const competitorCells = competitorTbody.querySelectorAll('td[data-domain]');
-            const competitorDomains = Array.from(competitorCells).map(cell => normalizeDomainForStrength(cell.dataset.domain || '')).filter(Boolean);
-            if (competitorDomains.length > 0) {
-              const strengthByDomain = await fetchLatestDomainStrengthForDomains(competitorDomains);
-              competitorCells.forEach(cell => {
-                const d = normalizeDomainForStrength(cell.dataset.domain || '');
-                const strength = strengthByDomain[d] || null;
-                cell.innerHTML = renderDomainRankCellHtml(strength);
-              });
-            }
-          }
-          
-          alert(`Domain Rank backfill complete!\n\nProcessed: ${result.processed}\nSkipped (already exist): ${result.skipped_existing}\nErrors: ${result.errors?.length || 0}`);
-        } else {
-          throw new Error(result.message || 'Backfill failed');
-        }
-      } catch (err) {
-        debugLog(`‚úó Domain Rank backfill error: ${err.message}`, 'error');
-        alert(`Failed to backfill Domain Ranks: ${err.message}`);
-      } finally {
-        // Restore button state
-        btn.disabled = false;
-        btn.textContent = originalText;
-        btn.style.opacity = '1';
-        btn.style.cursor = 'pointer';
-      }
-    }
-
-    function renderRankingAiCompetitors(rows) {
-      const tbody = document.getElementById("ranking-ai-competitors-body");
-      if (!tbody) return;
-
-      tbody.innerHTML = "";
-      const aggregate = {};
-
-      rows.forEach(row => {
-        Object.entries(row.competitor_counts || {}).forEach(([domain, count]) => {
-          aggregate[domain] = (aggregate[domain] || 0) + count;
-        });
-      });
-
-      const entries = Object.entries(aggregate).sort((a, b) => b[1] - a[1]).slice(0, 8);
-
-        if (!entries.length) {
-          const tr = document.createElement("tr");
-          const td = document.createElement("td");
-            td.colSpan = 5;
-            td.style.padding = "1rem 0.75rem";
-            td.style.color = "#64748b";
-            td.style.fontSize = "0.875rem";
-            td.textContent = "No competitor citations recorded across tracked keywords.";
-          tr.appendChild(td);
-          tbody.appendChild(tr);
-          return;
-        }
-
-      const makeDomainHref = (domain) => {
-        if (!domain) return null;
-        const d = String(domain).trim();
-        if (!d) return null;
-        if (d.startsWith('http://') || d.startsWith('https://')) return d;
-        return `https://${d}`;
-      };
-
-      // Fetch domain metadata for all domains (async)
-      const domainsList = entries.map(([d]) => d);
-      (async () => {
-        const domainMetadata = await fetchDomainMetadataForDomains(domainsList);
-
-        entries.forEach(([domain, count]) => {
-        const tr = document.createElement("tr");
-        tr.style.borderTop = "1px solid #e2e8f0";
-
-        const normalizedDomain = normalizeDomainForStrength(domain);
-        const meta = domainMetadata[normalizedDomain] || { domain_type: 'unmapped', is_competitor: false };
-
-        const tdDomain = document.createElement("td");
-        tdDomain.style.padding = "0.5rem 0.4rem";
-        tdDomain.style.fontSize = "0.8rem";
-        tdDomain.style.wordWrap = "break-word";
-        tdDomain.style.overflowWrap = "break-word";
-        const domainContainer = document.createElement("div");
-        domainContainer.style.display = "flex";
-        domainContainer.style.flexDirection = "column";
-        domainContainer.style.alignItems = "flex-start";
-        domainContainer.style.gap = "0.25rem";
-        
-        const domainLinkWrapper = document.createElement("div");
-        domainLinkWrapper.style.width = "100%";
-        const href = makeDomainHref(domain);
-        if (href) {
-          const a = document.createElement("a");
-          a.href = href;
-          a.target = "_blank";
-          a.rel = "noopener noreferrer";
-          a.style.color = "#0284c7";
-          a.style.textDecoration = "none";
-          a.style.wordBreak = "break-word";
-          a.style.overflowWrap = "break-word";
-          a.textContent = domain;
-          domainLinkWrapper.appendChild(a);
-        } else {
-          domainLinkWrapper.appendChild(document.createTextNode(String(domain || '')));
-        }
-        domainContainer.appendChild(domainLinkWrapper);
-
-        // Add competitor badge if is_competitor is true - below the domain
-        if (meta.is_competitor) {
-          const badge = document.createElement("span");
-          badge.textContent = "Competitor";
-          badge.setAttribute('data-competitor-badge', 'true');
-          badge.style.display = "inline-block";
-          badge.style.padding = "0.125rem 0.5rem";
-          badge.style.fontSize = "0.65rem";
-          badge.style.fontWeight = "600";
-          badge.style.color = "#dc2626";
-          badge.style.backgroundColor = "#fee2e2";
-          badge.style.borderRadius = "4px";
-          badge.style.border = "1px solid #fecaca";
-          badge.style.marginTop = "0.125rem";
-          domainContainer.appendChild(badge);
-        }
-
-        tdDomain.appendChild(domainContainer);
-
-        const tdCount = document.createElement("td");
-        tdCount.style.padding = "0.5rem 0.4rem";
-        tdCount.style.textAlign = "center";
-        tdCount.style.fontWeight = "700";
-        tdCount.style.color = "#1e293b";
-        tdCount.style.fontSize = "0.8rem";
-        tdCount.textContent = `${count}`;
-
-        const tdRank = document.createElement("td");
-        tdRank.style.padding = "0.5rem 0.4rem";
-        tdRank.style.textAlign = "right";
-        tdRank.style.color = "#64748b";
-        tdRank.style.fontSize = "0.8rem";
-        tdRank.textContent = "‚Äî";
-        tdRank.dataset.domain = normalizedDomain;
-
-        const tdDomainType = document.createElement("td");
-        tdDomainType.style.padding = "0.5rem 0.4rem";
-        tdDomainType.style.fontSize = "0.8rem";
-        tdDomainType.style.wordWrap = "break-word";
-        tdDomainType.style.overflowWrap = "break-word";
-        // Show domain type, but hide "unmapped" (show blank instead)
-        const displayType = meta.domain_type && meta.domain_type !== 'unmapped' ? meta.domain_type : '';
-        tdDomainType.textContent = displayType;
-        tdDomainType.style.color = displayType ? '#475569' : '#94a3b8';
-
-        const tdCompetitor = document.createElement("td");
-        tdCompetitor.style.padding = "0.5rem 0.4rem";
-        tdCompetitor.style.textAlign = "center";
-        tdCompetitor.style.fontSize = "0.8rem";
-        tdCompetitor.style.minWidth = "40px";
-        const competitorCheckbox = document.createElement("input");
-        competitorCheckbox.type = "checkbox";
-        competitorCheckbox.checked = meta.is_competitor === true;
-        competitorCheckbox.style.cursor = "pointer";
-        competitorCheckbox.dataset.domain = normalizedDomain;
-        
-        competitorCheckbox.addEventListener('change', async (e) => {
-          const isCompetitor = e.target.checked;
-          const domain = e.target.dataset.domain;
-          try {
-            const resp = await fetch(apiUrl('/api/domain-strength/update-domain'), {
-              method: 'POST',
-              headers: { 'Content-Type': 'application/json' },
-              body: JSON.stringify({ domain, is_competitor: isCompetitor })
-            });
-            if (resp.ok) {
-              // Clear cache
-              __domainMetadataCache.delete(domain);
-              // Update badge - find domainContainer first
-              const domainContainer = tdDomain.querySelector('div[style*="flex-direction: column"]') || tdDomain.querySelector('div');
-              let badge = tdDomain.querySelector('span[data-competitor-badge]');
-              if (isCompetitor && !badge && domainContainer) {
-                badge = document.createElement("span");
-                badge.textContent = "Competitor";
-                badge.setAttribute('data-competitor-badge', 'true');
-                badge.style.display = "inline-block";
-                badge.style.padding = "0.125rem 0.5rem";
-                badge.style.fontSize = "0.65rem";
-                badge.style.fontWeight = "600";
-                badge.style.color = "#dc2626";
-                badge.style.backgroundColor = "#fee2e2";
-                badge.style.borderRadius = "4px";
-                badge.style.border = "1px solid #fecaca";
-                badge.style.marginTop = "0.125rem";
-                domainContainer.appendChild(badge);
-              } else if (!isCompetitor && badge) {
-                badge.remove();
-              }
-            } else {
-              // Revert on error
-              e.target.checked = !isCompetitor;
-              alert('Failed to update competitor flag. Please try again.');
-            }
-          } catch (err) {
-            e.target.checked = !isCompetitor;
-            alert('Failed to update competitor flag. Please try again.');
-          }
-        });
-        
-        tdCompetitor.appendChild(competitorCheckbox);
-
-        tr.appendChild(tdDomain);
-        tr.appendChild(tdCount);
-        tr.appendChild(tdRank);
-        tr.appendChild(tdDomainType);
-        tr.appendChild(tdCompetitor);
-        tbody.appendChild(tr);
-        });
-
-        // Fill Domain Rank column using latest domain_strength snapshots (read-only)
-        try {
-          const selfDomain = typeof getSelfDomainForDomainStrength === "function" ? getSelfDomainForDomainStrength() : "alanranger.com";
-          const domains = [
-            selfDomain,
-            ...entries.map(([d]) => d),
-          ].map(normalizeDomainForStrength).filter(Boolean);
-          const strengthByDomain = await fetchLatestDomainStrengthForDomains(domains);
-          tbody.querySelectorAll("td[data-domain]").forEach((cell) => {
-            const d = normalizeDomainForStrength(cell.dataset.domain || "");
-            const strength = strengthByDomain[d] || null;
-            cell.innerHTML = renderDomainRankCellHtml(strength);
-          });
-        } catch {
-          // fail silently
-        }
-      })();
-    }
-
-
-    function renderRankingAiInsights(rows, summary) {
-      const container = document.getElementById("ranking-ai-insights-list-global");
-      if (!container) return;
-
-      container.innerHTML = "";
-      if (!rows.length) return;
-
-      // Calculate goodRankWithOverviewNoCitation: keywords with good rank (top-10), AI Overview, but no citations
-      const goodRankWithOverviewNoCitation = rows.filter(
-        r => r.best_rank_group != null && r.best_rank_group <= 10 && r.has_ai_overview && r.ai_alan_citations_count === 0
-      ).length;
-
-      // Calculate weakRankWithCitation: keywords with weaker rank (21+), but alanranger.com is cited
-      const weakRankWithCitation = rows.filter(
-        r => (r.best_rank_group == null || r.best_rank_group > 20) && r.ai_alan_citations_count > 0
-      ).length;
-
-      // Create card pills for the two main insights
-      if (goodRankWithOverviewNoCitation > 0) {
-        const pill = document.createElement("div");
-        pill.className = "card-pill";
-        pill.innerHTML = `
-          <p>
-            <strong>[Visibility, Content/Schema]</strong> ${goodRankWithOverviewNoCitation} keyword(s) have strong classic rankings and an AI Overview, but no citations for alanranger.com. Improving snippet-friendly content blocks and structured data on those pages can help convert existing Visibility into AI citations.
-          </p>
-        `;
-        container.appendChild(pill);
-      }
-
-      if (weakRankWithCitation > 0) {
-        const pill = document.createElement("div");
-        pill.className = "card-pill";
-        pill.innerHTML = `
-          <p>
-            <strong>[Authority, Visibility]</strong> ${weakRankWithCitation} keyword(s) already cite your content in AI Overviews despite weaker classic rankings. This indicates strong topical Authority; improving backlinks and on-page optimisation could lift classic Visibility for these terms.
-          </p>
-        `;
-        container.appendChild(pill);
-      }
-
-      // Authority priority insight (v1.4: Domain Strength integration)
-      const authorityPriority = summary?.authorityPriority ?? null;
-      const domainStrength = summary?.domainStrength ?? null;
-      
-      if (authorityPriority !== null) {
-        const pill = document.createElement("div");
-        pill.className = "card-pill";
-        
-        let authorityText = '';
-        if (authorityPriority === 'high') {
-          authorityText = 'Domain authority: Low. Overall domain strength is limiting how far your pages can climb, especially for high-impact keywords. Treat "authority building" (links, citations, brand searches) as a high-priority task over the next few months.';
-        } else if (authorityPriority === 'medium') {
-          authorityText = 'Domain authority: Medium. Authority is "good enough" but still a constraint on some high-impact keywords. Mix authority-building with on-page improvements.';
-        } else {
-          // authorityPriority === 'low'
-          authorityText = 'Domain authority: Strong relative to your current scale. Most gains are likely to come from on-page content, snippets, and conversion rather than more links alone.';
-        }
-        
-        pill.innerHTML = `
-          <p>
-            <strong>[Authority]</strong> ${authorityText}
-          </p>
-        `;
-        container.appendChild(pill);
-      }
-
-      // If no insights, show a general message
-      if (goodRankWithOverviewNoCitation === 0 && weakRankWithCitation === 0 && authorityPriority === null) {
-        const pill = document.createElement("div");
-        pill.className = "card-pill";
-        pill.innerHTML = `
-          <p>
-            Current ranking and AI signals are broadly aligned. Focus on incremental improvements to Money-page CTR, schema coverage, and consolidating reviews to keep Authority and Content/Schema strong.
-          </p>
-        `;
-        container.appendChild(pill);
-      }
-    }
-
-    // Tab switching for sidebar navigation - Optimized for performance (INP)
-    (function() {
-      // Restore tab state on page load (from sessionStorage or URL hash)
-      function restoreTabState() {
-        // Check URL hash first (more reliable)
-        const hash = window.location.hash;
-        if (hash && hash.startsWith('#')) {
-          const panelId = hash.substring(1);
-          const panel = document.querySelector(`[data-panel="${panelId}"]`);
-          if (panel) {
-            setActivePanel(panelId);
-            ensurePanelRendered(panelId);
-            return;
-          }
-        }
-        
-        // Fallback to sessionStorage
-        const savedTab = sessionStorage.getItem('activeTab');
-        if (savedTab) {
-          const panel = document.querySelector(`[data-panel="${savedTab}"]`);
-          if (panel) {
-            setActivePanel(savedTab);
-            ensurePanelRendered(savedTab);
-            // Update URL hash to match
-            window.location.hash = '#' + savedTab;
-            return;
-          }
-        }
-      }
-      
-      // Restore tab state when DOM is ready
-      if (document.readyState === 'loading') {
-        document.addEventListener('DOMContentLoaded', restoreTabState);
-      } else {
-        // DOM already loaded, restore immediately
-        restoreTabState();
-      }
-
-      const navItems = document.querySelectorAll(".aigeo-nav-item");
-
-      navItems.forEach(btn => {
-        btn.addEventListener("click", () => {
-          const panelId = btn.getAttribute("data-panel");
-          if (!panelId) return;
-
-          // Store active tab in sessionStorage
-          sessionStorage.setItem('activeTab', panelId);
-          window.location.hash = '#' + panelId;
-
-          // Fast UI switch first - no heavy work here
-          setActivePanel(panelId);
-
-          // Defer heavy work so the click paints immediately
-          requestAnimationFrame(() => {
-            defer(() => {
-              // Try to refresh audit data from Supabase when switching tabs (if data seems stale or missing)
-              const propertyUrl = localStorage.getItem('gsc_property_url');
-              const savedAudit = loadAuditResultsSync();
-              const savedTimestamp = savedAudit?.timestamp;
-              const hoursSinceLastAudit = savedTimestamp ? (Date.now() - savedTimestamp) / (1000 * 60 * 60) : Infinity;
-              
-              // If no data or data is more than 1 hour old, try to refresh from Supabase
-              if ((!savedAudit || hoursSinceLastAudit > 1) && propertyUrl) {
-                (async () => {
-                  debugLog(`üîÑ Tab switch: Attempting to refresh audit data from Supabase (${hoursSinceLastAudit > 1 ? 'data is stale' : 'no data found'})...`, 'info');
-                  try {
-                    const freshData = await fetchLatestAuditFromSupabase(propertyUrl);
-                    if (freshData && freshData.timestamp) {
-                      const freshTimestamp = freshData.timestamp;
-                      // Only update if fresh data is newer
-                      if (!savedTimestamp || freshTimestamp > savedTimestamp) {
-                        safeSetLocalStorage('last_audit_results', freshData);
-                        updateAuditTimestamp(freshTimestamp);
-                        debugLog(`‚úì Tab switch: Refreshed audit data from Supabase (newer timestamp)`, 'success');
-                      } else {
-                        debugLog(`‚ö† Tab switch: Supabase data is not newer than cached data`, 'info');
-                      }
-                    }
-                  } catch (error) {
-                    debugLog(`‚ö† Tab switch: Failed to refresh from Supabase: ${error.message}`, 'warn');
-                  }
-                })();
-              }
-
-              // Lazy-render panel content (only first time)
-              ensurePanelRendered(panelId);
-            });
-          });
-        });
-      });
-    })();
-
-      // Function to refresh only GSC queryTotals (CTR/Impressions) without running full audit
-      window.refreshGSCDataOnly = async function refreshGSCDataOnly() {
-        try {
-          debugLog('üîÑ Refreshing GSC data only (CTR & Impressions)...', 'info');
-          
-          // Get existing audit data
-          const savedAudit = loadAuditResultsSync();
-          if (!savedAudit || !savedAudit.searchData) {
-            debugLog('‚ö† No audit data found. Please run a full audit first.', 'warn');
-            alert('No audit data found. Please run a full audit first.');
-            return;
-          }
-          
-          // Get keywords from existing ranking data
-          let rankingData = [];
-          
-          // Try to get from RankingAiModule state first
-          if (window.RankingAiModule && typeof window.RankingAiModule.state === 'function') {
-            const state = window.RankingAiModule.state();
-            rankingData = state.combinedRows || [];
-            debugLog(`üìä Found ${rankingData.length} keywords from RankingAiModule state`, 'info');
-          }
-          
-          // Fallback: try to get from localStorage (check both possible keys)
-          if (!rankingData || rankingData.length === 0) {
-            try {
-              let storedData = localStorage.getItem('rankingAiData'); // Primary key
-              if (!storedData) {
-                storedData = localStorage.getItem('ranking_ai_data'); // Alternative key
-              }
-              if (storedData) {
-                const parsed = JSON.parse(storedData);
-                if (parsed && parsed.combinedRows && Array.isArray(parsed.combinedRows)) {
-                  rankingData = parsed.combinedRows;
-                  debugLog(`üìä Found ${rankingData.length} keywords from localStorage`, 'info');
-                }
-              }
-            } catch (e) {
-              debugLog(`‚ö† Failed to parse ranking data from localStorage: ${e.message}`, 'warn');
-            }
-          }
-          
-          // Fallback: try to get from saved audit's keyword_rankings
-          if (!rankingData || rankingData.length === 0) {
-            if (savedAudit.keywordRankings && Array.isArray(savedAudit.keywordRankings)) {
-              rankingData = savedAudit.keywordRankings;
-              debugLog(`üìä Found ${rankingData.length} keywords from saved audit`, 'info');
-            }
-          }
-          
-          // Final fallback: fetch keywords directly from Supabase
-          if (!rankingData || rankingData.length === 0) {
-            debugLog('‚ö† No ranking keywords in UI state, fetching from Supabase...', 'info');
-            try {
-              const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
-              if (propertyUrl) {
-                const supabaseResponse = await fetch(apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`));
-                if (supabaseResponse.ok) {
-                  const supabaseData = await supabaseResponse.json();
-                  if (supabaseData.status === 'ok' && supabaseData.data?.rankingAiData?.combinedRows) {
-                    rankingData = supabaseData.data.rankingAiData.combinedRows;
-                    debugLog(`‚úì Fetched ${rankingData.length} keywords directly from Supabase`, 'success');
-                  }
-                }
-              }
-            } catch (supabaseErr) {
-              debugLog(`‚ö† Failed to fetch keywords from Supabase: ${supabaseErr.message}`, 'warn');
-            }
-          }
-          
-          if (!rankingData || rankingData.length === 0) {
-            debugLog('‚ö† No ranking keywords found. Please run the ranking scan first.', 'warn');
-            alert('No ranking keywords found. Please run the ranking scan first.');
-            return;
-          }
-          
-          const allKeywords = rankingData.map(r => r.keyword).filter(k => k && k.trim());
-          if (allKeywords.length === 0) {
-            debugLog('‚ö† No valid keywords found.', 'warn');
-            alert('No valid keywords found.');
-            return;
-          }
-          
-          debugLog(`üìä Fetching GSC queryTotals for ${allKeywords.length} keywords...`, 'info');
-          
-          const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
-          if (!propertyUrl) {
-            debugLog('‚ö† No property URL found.', 'warn');
-            alert('No property URL found. Please configure GSC settings first.');
-            return;
-          }
-          
-          const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28');
-          
-          // Fetch queryTotals from GSC API
-          const keywordsParam = encodeURIComponent(JSON.stringify(allKeywords));
-          const propertyParam = encodeURIComponent(propertyUrl);
-          const gscResponse = await fetch(apiUrl(`/api/aigeo/gsc-entity-metrics?property=${propertyParam}&keywords=${keywordsParam}&days=${dateRange}`));
-          
-          if (!gscResponse.ok) {
-            const errorText = await gscResponse.text();
-            debugLog(`‚úó Failed to fetch queryTotals from GSC: ${gscResponse.status} - ${errorText}`, 'error');
-            alert(`Failed to fetch GSC data: ${gscResponse.status}`);
-            return;
-          }
-          
-          const gscData = await gscResponse.json();
-          if (gscData.status !== 'ok' || !gscData.data || !Array.isArray(gscData.data.queryTotals)) {
-            debugLog(`‚ö† GSC API did not return queryTotals data`, 'warn');
-            alert('GSC API did not return queryTotals data.');
-            return;
-          }
-          
-          const queryTotals = gscData.data.queryTotals;
-          debugLog(`‚úì Fetched queryTotals for ${queryTotals.length} keywords from GSC`, 'success');
-          
-          // Merge queryTotals into searchData
-          savedAudit.searchData.queryTotals = queryTotals;
-          
-          // Use the SAME audit_date as the existing audit
-          let auditDate = new Date().toISOString().split('T')[0];
-          if (savedAudit.timestamp) {
-            try {
-              auditDate = new Date(savedAudit.timestamp).toISOString().split('T')[0];
-              debugLog(`üìä Using existing audit date for queryTotals: ${auditDate}`, 'info');
-            } catch (e) {
-              debugLog(`‚ö† Failed to parse saved audit timestamp, using today's date`, 'warn');
-            }
-          }
-          
-          // Save to Supabase
-          const saveResponse = await fetch(apiUrl('/api/supabase/save-audit'), {
-            method: 'POST',
-            headers: { 'Content-Type': 'application/json' },
-            body: JSON.stringify({
-              propertyUrl: propertyUrl,
-              auditDate: auditDate,
-              searchData: savedAudit.searchData
-            })
-          });
-          
-          if (!saveResponse.ok) {
-            const errorText = await saveResponse.text();
-            debugLog(`‚úó Failed to save queryTotals to Supabase: ${saveResponse.status} - ${errorText}`, 'error');
-            alert(`Failed to save to Supabase: ${saveResponse.status}`);
-            return;
-          }
-          
-          debugLog(`‚úì Saved queryTotals to Supabase (${queryTotals.length} keywords) for audit_date: ${auditDate}`, 'success');
-          
-          // Update localStorage
-          try {
-            safeSetLocalStorage('last_audit_results', savedAudit);
-            debugLog(`‚úì Updated localStorage with queryTotals`, 'success');
-          } catch (localStorageErr) {
-            debugLog(`‚ö† Failed to update localStorage: ${localStorageErr.message}`, 'warn');
-          }
-          
-          // CRITICAL: Reload ranking data from Supabase to get latest search_volume values
-          // The UI might be showing old localStorage data that doesn't have search_volume
-          debugLog('üîÑ Reloading ranking data from Supabase to get latest search_volume...', 'info');
-          try {
-            const refreshedRankingData = await loadRankingAiDataFromStorage(true); // Force Supabase check
-            if (refreshedRankingData && refreshedRankingData.combinedRows) {
-              const mod = window.RankingAiModule;
-              if (mod && typeof mod.setData === 'function') {
-                const normalizedSummary = normalizeSummaryFields(refreshedRankingData.summary);
-                mod.setData(refreshedRankingData.combinedRows, normalizedSummary);
-                debugLog(`‚úì Reloaded ${refreshedRankingData.combinedRows.length} keywords from Supabase with latest search_volume`, 'success');
-                
-                // Check how many keywords now have search_volume
-                const keywordsWithVolume = refreshedRankingData.combinedRows.filter(r => r.search_volume != null && r.search_volume !== undefined).length;
-                debugLog(`  Keywords with search_volume: ${keywordsWithVolume}/${refreshedRankingData.combinedRows.length}`, 'info');
-              }
-            }
-          } catch (reloadErr) {
-            debugLog(`‚ö† Failed to reload ranking data from Supabase: ${reloadErr.message}`, 'warn');
-            // Continue anyway - at least GSC data was refreshed
-          }
-          
-          // Re-render the table to show updated CTR/Impressions and search_volume
-          if (typeof renderRankingAiTab === 'function') {
-            renderRankingAiTab();
-            debugLog('‚úì Table re-rendered with updated GSC data and search_volume', 'success');
-          }
-          
-          // Update last run timestamp
-          updateAuditTimestamp(new Date().toISOString());
-          
-          debugLog('‚úì GSC data refresh completed successfully!', 'success');
-          alert(`Successfully refreshed GSC data for ${queryTotals.length} keywords!`);
-          
-        } catch (error) {
-          debugLog(`‚úó Error refreshing GSC data: ${error.message}`, 'error');
-          console.error('GSC refresh error:', error);
-          alert(`Error refreshing GSC data: ${error.message}`);
-        }
-      }
-
-      // Manual refresh button for Ranking & AI
-      function wireRankingAiButton() {
-        const refreshBtn = document.getElementById("ranking-ai-refresh");
-        if (refreshBtn) {
-          // Remove existing listener by cloning
-          const newBtn = refreshBtn.cloneNode(true);
-          refreshBtn.parentNode.replaceChild(newBtn, refreshBtn);
-          
-          newBtn.addEventListener("click", async () => {
-            debugLog('üîÑ Ranking & AI button clicked', 'info');
-            
-            // Update UI immediately to show progress
-            const lastRunEl = document.getElementById("ranking-ai-last-run");
-            if (lastRunEl) {
-              lastRunEl.textContent = "Starting...";
-            }
-            newBtn.disabled = true;
-            newBtn.textContent = "Loading‚Ä¶";
-            
-            try {
-              if (typeof loadRankingAiData === 'function') {
-                debugLog('‚úì Calling loadRankingAiData (local)', 'info');
-                await loadRankingAiData(true); // force re-run
-              } else if (typeof window.loadRankingAiData === 'function') {
-                debugLog('‚úì Calling loadRankingAiData (window)', 'info');
-                await window.loadRankingAiData(true); // force re-run
-              } else {
-                debugLog('‚úó loadRankingAiData function not found', 'error');
-                if (lastRunEl) {
-                  lastRunEl.textContent = "Error: loadRankingAiData function not found";
-                }
-                newBtn.disabled = false;
-                newBtn.textContent = "Run ranking & AI check";
-              }
-            } catch (err) {
-              debugLog(`‚úó Error calling loadRankingAiData: ${err.message}`, 'error');
-              console.error('Ranking & AI button error:', err);
-              if (lastRunEl) {
-                lastRunEl.textContent = `Error: ${err.message}`;
-              }
-              newBtn.disabled = false;
-              newBtn.textContent = "Run ranking & AI check";
-            }
-          });
-          debugLog('‚úì Ranking & AI button wired up', 'success');
-        } else {
-          debugLog('‚ö† Ranking & AI button not found', 'warn');
-        }
-        
-        // Wire up GSC refresh button
-        const gscRefreshBtn = document.getElementById("ranking-gsc-refresh");
-        if (gscRefreshBtn) {
-          // Remove existing listener by cloning
-          const newGscBtn = gscRefreshBtn.cloneNode(true);
-          gscRefreshBtn.parentNode.replaceChild(newGscBtn, gscRefreshBtn);
-          
-          newGscBtn.addEventListener("click", async () => {
-            debugLog('üîÑ GSC refresh button clicked', 'info');
-            
-            // Update UI immediately to show progress
-            const lastRunEl = document.getElementById("ranking-ai-last-run");
-            if (lastRunEl) {
-              lastRunEl.textContent = "Refreshing GSC data...";
-            }
-            newGscBtn.disabled = true;
-            newGscBtn.textContent = "Refreshing...";
-            
-            try {
-              await window.refreshGSCDataOnly();
-            } catch (err) {
-              debugLog(`‚úó Error refreshing GSC data: ${err.message}`, 'error');
-              console.error('GSC refresh button error:', err);
-              if (lastRunEl) {
-                lastRunEl.textContent = `Error: ${err.message}`;
-              }
-            } finally {
-              newGscBtn.disabled = false;
-              newGscBtn.textContent = "Refresh GSC Data";
-              if (lastRunEl) {
-                const now = new Date();
-                const day = String(now.getUTCDate()).padStart(2, '0');
-                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
-                const month = monthNames[now.getUTCMonth()];
-                const year = now.getUTCFullYear();
-                const hours = String(now.getUTCHours()).padStart(2, '0');
-                const minutes = String(now.getUTCMinutes()).padStart(2, '0');
-                const seconds = String(now.getUTCSeconds()).padStart(2, '0');
-                lastRunEl.textContent = `Last refreshed: ${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
-              }
-            }
-          });
-          debugLog('‚úì GSC refresh button wired up', 'success');
-        } else {
-          debugLog('‚ö† GSC refresh button not found', 'warn');
-        }
-      }
-
-      // ======================
-      // Domain Strength (manual monthly snapshot)
-      // ======================
-      function getSelfDomainForDomainStrength() {
-        const propertyUrl =
-          document.getElementById('propertyUrl')?.value ||
-          localStorage.getItem('gsc_property_url') ||
-          'https://www.alanranger.com';
-        try {
-          return new URL(propertyUrl).hostname.replace(/^www\./, '');
-        } catch {
-          return String(propertyUrl).replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0];
-        }
-      }
-
-      function domainStrengthBandKey(band) {
-        const b = String(band || '').trim();
-        if (b === 'Very strong') return 'very-strong';
-        if (b === 'Strong') return 'strong';
-        if (b === 'Moderate') return 'moderate';
-        if (b === 'Weak') return 'weak';
-        if (b === 'Very weak') return 'very-weak';
-        return 'na';
-      }
-
-      function renderDomainStrengthBandPill(band) {
-        const original = String(band || '‚Äî');
-        const key = domainStrengthBandKey(original);
-        // v1.3 UI label mapping: Low / Medium / High / Very High (derived from stored band)
-        let label = '‚Äî';
-        if (original === 'Very strong') label = 'Very High';
-        else if (original === 'Strong') label = 'High';
-        else if (original === 'Moderate') label = 'Medium';
-        else if (original === 'Weak' || original === 'Very weak') label = 'Low';
-        else label = original;
-        return `<span class="domain-strength-badge domain-strength-badge--${key}">${label}</span>`;
-      }
-
-      function formatDomainStrengthScore(score) {
-        const n = typeof score === 'number' ? score : parseFloat(score);
-        if (!isFinite(n)) return '‚Äî';
-        return Number(n).toFixed(1);
-      }
-
-      function computeDomainStrengthDelta(sortedAscRows) {
-        const list = Array.isArray(sortedAscRows) ? sortedAscRows : [];
-        if (list.length < 2) return null;
-        const last = list[list.length - 1];
-        const prev = list[list.length - 2];
-        const a = typeof last?.score === 'number' ? last.score : parseFloat(last?.score);
-        const b = typeof prev?.score === 'number' ? prev.score : parseFloat(prev?.score);
-        if (!isFinite(a) || !isFinite(b)) return null;
-        return a - b;
-      }
-
-      function getDomainStrengthDomainList(maxCompetitors = 20) {
-        const domains = [];
-        const seen = new Set();
-        const self = getSelfDomainForDomainStrength();
-        if (self) {
-          seen.add(self);
-          domains.push(self);
-        }
-
-        // Use Ranking AI combined rows as the source of competitor domains
-        const mod = window.RankingAiModule;
-        const combinedRows = mod?.state?.().combinedRows || [];
-        const counts = {};
-
-        for (const row of combinedRows) {
-          const cc = row?.competitor_counts;
-          if (!cc || typeof cc !== 'object') continue;
-          for (const [domain, count] of Object.entries(cc)) {
-            const d = String(domain || '').trim().replace(/^www\./, '');
-            if (!d || seen.has(d)) continue;
-            counts[d] = (counts[d] || 0) + (Number(count) || 0);
-          }
-        }
-
-        const sorted = Object.entries(counts)
-          .sort((a, b) => b[1] - a[1])
-          .slice(0, Math.max(0, maxCompetitors))
-          .map(([d]) => d);
-
-        for (const d of sorted) {
-          if (seen.has(d)) continue;
-          seen.add(d);
-          domains.push(d);
-        }
-
-        return domains;
-      }
-
-      const domainStrengthSparklineCharts = new Map();
-
-      function safeDestroyDomainStrengthSparklines() {
-        for (const ch of domainStrengthSparklineCharts.values()) {
-          try { ch.destroy(); } catch { /* ignore */ }
-        }
-        domainStrengthSparklineCharts.clear();
-      }
-
-      function renderDomainStrengthSparklineChart(canvas, labels, scores) {
-        if (!canvas) return;
-        if (!window.Chart) {
-          canvas.replaceWith(document.createTextNode('‚Äî'));
-          return;
-        }
-        const id = canvas.id || '';
-        const existing = id ? domainStrengthSparklineCharts.get(id) : null;
-        if (existing) {
-          try { existing.destroy(); } catch { /* ignore */ }
-          domainStrengthSparklineCharts.delete(id);
-        }
-
-        const pts = Array.isArray(scores) ? scores.map((v) => (typeof v === 'number' ? v : parseFloat(v))).filter((v) => isFinite(v)) : [];
-        const labs = Array.isArray(labels) ? labels : [];
-        if (pts.length === 0) {
-          canvas.replaceWith(document.createTextNode('‚Äî'));
-          return;
-        }
-
-        const ctx = canvas.getContext('2d');
-        const chart = new Chart(ctx, {
-          type: 'line',
-          data: {
-            labels: labs,
-            datasets: [{
-              data: pts,
-              borderColor: '#0284c7',
-              backgroundColor: 'rgba(2, 132, 199, 0.15)',
-              borderWidth: 2,
-              pointRadius: pts.length === 1 ? 2.5 : 0,
-              pointHoverRadius: 0,
-              fill: false,
-              tension: 0.35,
-            }]
-          },
-          options: {
-            responsive: false,
-            maintainAspectRatio: false,
-            animation: false,
-            plugins: {
-              legend: { display: false },
-              tooltip: { enabled: false },
-            },
-            scales: {
-              x: { display: false },
-              y: { display: false, min: 0, max: 100 }
-            },
-            elements: { point: { hitRadius: 0 } }
-          }
-        });
-
-        if (id) domainStrengthSparklineCharts.set(id, chart);
-      }
-
-      async function fetchDomainStrengthOverview() {
-        const resp = await fetch(apiUrl('/api/domain-strength/overview'));
-        const json = await resp.json();
-        return json?.status === 'ok' ? (json.items || []) : [];
-      }
-
-      function formatIntegerOrDash(v) {
-        const n = typeof v === 'number' ? v : parseFloat(v);
-        if (!isFinite(n)) return '‚Äî';
-        return Math.round(n).toLocaleString();
-      }
-
-      function formatEtvDollars(v) {
-        const n = typeof v === 'number' ? v : parseFloat(v);
-        if (!isFinite(n)) return '‚Äî';
-        return '$' + Math.round(n).toLocaleString();
-      }
-
-      function formatDelta(delta) {
-        if (delta === null || !isFinite(delta)) return '‚Äî';
-        const sign = delta > 0 ? '+' : '';
-        return `${sign}${delta.toFixed(1)}`;
-      }
-
-      // Domain Strength sorting and pagination state
-      let domainStrengthSortState = {
-        column: 'name', // Default sort by name (alphabetical)
-        direction: 'asc'
-      };
-      let domainStrengthPaginationState = {
-        currentPage: 1,
-        rowsPerPage: 10
-      };
-      let domainStrengthFilterState = {
-        segment: null // Show all domains by default
-      };
-      let domainStrengthExpanded = false; // Collapsed by default
-
-      // Sort domain strength rows
-      function sortDomainStrengthRows(rows) {
-        const sorted = [...rows];
-        sorted.sort((a, b) => {
-          let aVal, bVal;
-          switch (domainStrengthSortState.column) {
-            case 'name':
-              aVal = (a?.label || a?.domain || '').toLowerCase();
-              bVal = (b?.label || b?.domain || '').toLowerCase();
-              break;
-            case 'segment':
-              aVal = a?.segment || '';
-              bVal = b?.segment || '';
-              break;
-            case 'score':
-              const as = a?.latest?.score;
-              const bs = b?.latest?.score;
-              aVal = typeof as === 'number' ? as : (isFinite(parseFloat(as)) ? parseFloat(as) : -1);
-              bVal = typeof bs === 'number' ? bs : (isFinite(parseFloat(bs)) ? parseFloat(bs) : -1);
-              break;
-            case 'band':
-              aVal = a?.latest?.band || '';
-              bVal = b?.latest?.band || '';
-              break;
-            case 'etv':
-              aVal = a?.latest?.organicEtv ?? 0;
-              bVal = b?.latest?.organicEtv ?? 0;
-              break;
-            case 'top10':
-              aVal = a?.latest?.top10Keywords ?? 0;
-              bVal = b?.latest?.top10Keywords ?? 0;
-              break;
-            case 'change':
-              aVal = a?.trend?.deltaLatest ?? -999;
-              bVal = b?.trend?.deltaLatest ?? -999;
-              break;
-            default:
-              return 0;
-          }
-          if (aVal < bVal) return domainStrengthSortState.direction === 'asc' ? -1 : 1;
-          if (aVal > bVal) return domainStrengthSortState.direction === 'asc' ? 1 : -1;
-          return 0;
-        });
-        return sorted;
-      }
-
-      async function renderDomainStrengthSection() {
-        debugLog('[DomainStrength] renderDomainStrengthSection() called', 'info');
-        const card = document.getElementById('domain-strength-summary-card');
-        const tbody = document.getElementById('domain-strength-table-body');
-        if (!tbody || !card) {
-          debugLog('[DomainStrength] Missing card or tbody element', 'warn');
-          return;
-        }
-
-        card.innerHTML = `<div style="color:#64748b; font-size:0.95rem;">Loading domain strength‚Ä¶</div>`;
-        tbody.innerHTML = '<tr><td colspan="8" class="ranking-table-empty">Loading‚Ä¶</td></tr>';
-
-        let items = [];
-        try {
-          debugLog('[DomainStrength] Fetching domain strength overview...', 'info');
-          items = await fetchDomainStrengthOverview();
-          debugLog(`[DomainStrength] Fetched ${items.length} items from API`, 'info');
-        } catch (e) {
-          const msg = e?.message || String(e);
-          card.innerHTML = `<div style="color:#b91c1c;">Failed to load: ${msg}</div>`;
-          tbody.innerHTML = `<tr><td colspan="8" class="ranking-table-empty">Failed to load: ${msg}</td></tr>`;
-          return;
-        }
-
-        // v1.3: keep current single-engine view unless you add Bing later
-        const engine = 'google';
-        items = items.filter((it) => String(it?.searchEngine || '').toLowerCase() === engine);
-
-        if (!items.length) {
-          card.innerHTML = `
-            <div style="font-weight:700; color:#0f172a; margin-bottom:0.25rem;">Domain Strength</div>
-            <div style="color:#64748b; font-size:0.95rem;">No domain strength snapshots yet. Run a snapshot to populate this panel.</div>
-          `;
-          tbody.innerHTML = '<tr><td colspan="9" class="ranking-table-empty">No domain strength snapshots yet. Click "Run Domain Strength Snapshot".</td></tr>';
-          return;
-        }
-
-        safeDestroyDomainStrengthSparklines();
-
-        const selfDomain = getSelfDomainForDomainStrength();
-        debugLog(`[DomainStrength] Self domain: ${selfDomain}`, 'info');
-        
-        // Don't filter - show all domains
-        // Separate your site from competitors
-        const selfItem = items.find((it) => String(it?.domain || '') === selfDomain) || null;
-        // Only show domains EXPLICITLY marked as competitors (checkbox checked)
-        // isCompetitor must be explicitly true, not just truthy
-        const competitorItems = items.filter((it) => {
-          const isCompetitor = it?.isCompetitor === true; // Only true, not just truthy
-          const isNotSelf = String(it?.domain || '') !== selfDomain;
-          return isCompetitor && isNotSelf;
-        });
-        
-        console.log('[DomainStrength] Total items:', items.length, 'Competitors found:', competitorItems.length);
-        
-        if (selfItem && selfItem.latest) {
-          debugLog(`[DomainStrength] Self item found: domain=${selfItem.domain}, score=${selfItem.latest.score}, snapshotDate=${selfItem.latest.snapshotDate}, createdAt=${selfItem.latest.createdAt}`, 'info');
-        } else {
-          debugLog(`[DomainStrength] Self item NOT found for domain: ${selfDomain}`, 'warn');
-        }
-
-        // Quick insight summary (your primary domain)
-        if (selfItem && selfItem.latest) {
-          const latest = selfItem.latest;
-          debugLog(`[DomainStrength] Latest data: score=${latest.score}, snapshotDate=${latest.snapshotDate}, createdAt=${latest.createdAt}`, 'info');
-          const delta = selfItem?.trend?.deltaLatest ?? null;
-          const arrow = delta > 0.5 ? '‚Üë' : (delta < -0.5 ? '‚Üì' : '‚Ä¢');
-          const cls = delta > 0.5 ? 'kpi-trend-up' : (delta < -0.5 ? 'kpi-trend-down' : 'kpi-trend-flat');
-          const changeText = delta === null ? '‚Äî' : formatDelta(delta);
-          const bandPill = renderDomainStrengthBandPill(latest.band);
-          const label = selfItem.label || selfDomain;
-
-          // Format last fetched timestamp (prefer createdAt, fallback to snapshotDate) in GMT
-          let lastFetchedText = '‚Äî';
-          const timestampToUse = latest.createdAt || latest.snapshotDate;
-          if (timestampToUse) {
-            try {
-              const timestamp = new Date(timestampToUse);
-              if (!isNaN(timestamp.getTime())) {
-                // Convert to GMT/UTC
-                lastFetchedText = timestamp.toLocaleString('en-GB', {
-                  timeZone: 'UTC',
-                  year: 'numeric',
-                  month: 'short',
-                  day: 'numeric',
-                  hour: '2-digit',
-                  minute: '2-digit',
-                  hour12: false
-                }) + ' GMT';
-              }
-            } catch (e) {
-              // If date parsing fails, use raw string
-              lastFetchedText = String(timestampToUse);
-            }
-          }
-
-          card.innerHTML = `
-            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.35rem;">
-              <div style="font-weight:700; color:#0f172a;">${label}</div>
-              <div style="font-size: 0.75rem; color: #64748b; text-align: right;">
-                <div style="font-weight: 600; color: #475569; margin-bottom: 0.125rem;">Last Fetched</div>
-                <div>${lastFetchedText}</div>
-              </div>
-            </div>
-            <div class="domain-strength-summary-top">
-              <div class="domain-strength-summary-score">${formatDomainStrengthScore(latest.score)}</div>
-              <div>${bandPill}</div>
-            </div>
-            <div style="margin-top:0.35rem; font-size:0.95rem;">
-              <span class="${cls}" title="Change vs last snapshot: ${changeText}">${arrow} ${delta === null ? 'No previous snapshot data yet' : `${changeText} vs last snapshot`}</span>
-            </div>
-            <div class="domain-strength-summary-subtitle">
-              Domain strength ${formatDomainStrengthScore(latest.score)} on Google ‚Äì ${delta === null ? 'no previous snapshot yet' : `${changeText} vs last snapshot`};
-              ${formatIntegerOrDash(latest.top10Keywords)} top‚Äë10 keywords and estimated traffic ${formatEtvDollars(latest.organicEtv)}/month.
-            </div>
-          `;
-        } else {
-          card.innerHTML = `
-            <div style="font-weight:700; color:#0f172a; margin-bottom:0.25rem;">${selfDomain || 'Your site'}</div>
-            <div style="color:#64748b; font-size:0.95rem;">No domain strength snapshots yet. Run a snapshot to populate this card.</div>
-          `;
-        }
-
-        // Sort competitors by strength score (highest to lowest) - ALWAYS by score desc
-        // This ensures competitors are shown in order of strength (highest first)
-        const sortedCompetitors = [...competitorItems].sort((a, b) => {
-          const aScore = typeof a?.latest?.score === 'number' ? a.latest.score : (parseFloat(a?.latest?.score) || 0);
-          const bScore = typeof b?.latest?.score === 'number' ? b.latest.score : (parseFloat(b?.latest?.score) || 0);
-          return bScore - aScore; // Descending - highest score first
-        });
-        
-        console.log('[DomainStrength] Competitors found:', sortedCompetitors.length, 'sorted by strength score (highest first)');
-
-        // Build final sorted array: your site first, then top competitors
-        let sorted = [];
-        if (selfItem) {
-          sorted.push(selfItem);
-        }
-        sorted.push(...sortedCompetitors);
-
-        // Calculate pagination
-        const totalRows = sorted.length;
-        const rowsPerPage = domainStrengthPaginationState.rowsPerPage === 'all' ? totalRows : domainStrengthPaginationState.rowsPerPage;
-        const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
-        const currentPage = Math.min(Math.max(1, domainStrengthPaginationState.currentPage), totalPages);
-        domainStrengthPaginationState.currentPage = currentPage;
-        
-        const startIdx = rowsPerPage === 'all' ? 0 : (currentPage - 1) * rowsPerPage;
-        const endIdx = rowsPerPage === 'all' ? totalRows : Math.min(startIdx + rowsPerPage, totalRows);
-        const paginatedRows = sorted.slice(startIdx, endIdx);
-
-        // Determine visible rows based on expand/collapse state
-        // Always show your site (first row), then top 2 competitors = 3 rows total
-        // If your site is not in paginated rows, show first 3 rows
-        const selfRowIndex = paginatedRows.findIndex((it) => String(it?.domain || '') === selfDomain);
-        let visibleRows;
-        if (domainStrengthExpanded) {
-          visibleRows = paginatedRows;
-        } else {
-          if (selfRowIndex >= 0) {
-            // Your site is in the paginated rows
-            // Show your site + next 2 rows (competitors)
-            visibleRows = paginatedRows.slice(0, Math.min(selfRowIndex + 3, paginatedRows.length));
-          } else {
-            // Your site not in current page, just show first 3
-            visibleRows = paginatedRows.slice(0, 3);
-          }
-        }
-        const hiddenRowsCount = paginatedRows.length - visibleRows.length;
-
-        tbody.innerHTML = '';
-        for (const it of visibleRows) {
-          const latest = it?.latest || null;
-          const delta = it?.trend?.deltaLatest ?? null;
-          const points = Array.isArray(it?.trend?.points) ? it.trend.points : [];
-          const last12 = points.slice(-12);
-          const labels = last12.map((p) => p.date);
-          const scores = last12.map((p) => p.score);
-
-          const safeId = String(it?.domain || '')
-            .toLowerCase()
-            .replace(/[^a-z0-9]+/g, '-')
-            .replace(/(^-|-$)/g, '');
-          const canvasId = `domain-strength-spark-${safeId || Math.random().toString(36).slice(2)}`;
-
-          const arrow = delta > 0.5 ? '‚Üë' : (delta < -0.5 ? '‚Üì' : '‚Ä¢');
-          const cls = delta > 0.5 ? 'kpi-trend-up' : (delta < -0.5 ? 'kpi-trend-down' : 'kpi-trend-flat');
-          const changeTitle = delta === null ? 'No previous snapshot yet' : `Change vs last snapshot: ${formatDelta(delta)}`;
-
-          // Check if this is the self domain row
-          const isSelfDomain = String(it?.domain || '') === selfDomain;
-          const rowStyle = isSelfDomain ? 'font-weight: 700; background-color: #fefce8;' : '';
-
-          const tr = document.createElement('tr');
-          if (isSelfDomain) {
-            tr.id = 'domain-strength-self-row';
-            tr.style.fontWeight = '700';
-            tr.style.backgroundColor = '#fefce8';
-          }
-          // Create clickable domain link
-          const domainName = it?.domain || '';
-          const displayName = it?.label || it?.domain || '‚Äî';
-          const domainLink = domainName ? `<a href="https://${domainName}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none; ${isSelfDomain ? 'font-weight: 700;' : ''}" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${displayName}</a>` : displayName;
-          
-          // Get domain type and competitor flag - use domain_type directly, fallback to segment, only default to 'unmapped' if both are missing
-          const domainType = it?.domain_type || it?.segment || 'unmapped';
-          const isCompetitor = it?.isCompetitor === true;
-          const normalizedDomain = normalizeDomainForStrength(domainName);
-          
-          tr.innerHTML = `
-            <td style="text-align:left; ${isSelfDomain ? 'font-weight: 700;' : ''}">${domainLink}</td>
-            <td style="${isSelfDomain ? 'font-weight: 700;' : ''}"><span data-domain-type-display="${normalizedDomain}">${domainType}</span></td>
-            <td style="text-align:center; ${isSelfDomain ? 'font-weight: 700;' : ''}">${latest ? formatDomainStrengthScore(latest.score) : '‚Äî'}</td>
-            <td style="${isSelfDomain ? 'font-weight: 700;' : ''}">${latest ? renderDomainStrengthBandPill(latest.band) : '‚Äî'}</td>
-            <td style="text-align:right; white-space: nowrap; ${isSelfDomain ? 'font-weight: 700;' : ''}">${latest ? formatEtvDollars(latest.organicEtv) : '‚Äî'}</td>
-            <td style="text-align:right; white-space: nowrap; ${isSelfDomain ? 'font-weight: 700;' : ''}">${latest ? formatIntegerOrDash(latest.top10Keywords) : '‚Äî'}</td>
-            <td style="text-align:center; ${isSelfDomain ? 'font-weight: 700;' : ''}"><span class="${cls}" title="${changeTitle}">${delta === null ? '‚Äî' : `${arrow} ${formatDelta(delta)}`}</span></td>
-            <td style="text-align:center;">
-              <canvas class="domain-strength-sparkline" id="${canvasId}" width="140" height="28" aria-label="12 month score trend"></canvas>
-            </td>
-            <td style="text-align:center;"></td>
-          `;
-          tbody.appendChild(tr);
-          
-          // Add domain type dropdown to the Domain type cell
-          const domainTypeCell = tr.querySelector(`td:nth-child(2)`);
-          const domainTypeDisplay = domainTypeCell.querySelector(`[data-domain-type-display="${normalizedDomain}"]`);
-          if (domainTypeDisplay && domainTypeCell) {
-            domainTypeCell.innerHTML = '';
-            const domainTypeSelect = document.createElement('select');
-            domainTypeSelect.style.padding = '0.4rem 0.6rem';
-            domainTypeSelect.style.border = '1px solid #cbd5e1';
-            domainTypeSelect.style.borderRadius = '4px';
-            domainTypeSelect.style.fontSize = '0.85rem';
-            domainTypeSelect.style.background = 'white';
-            domainTypeSelect.style.cursor = 'pointer';
-            domainTypeSelect.style.minWidth = '120px';
-            domainTypeSelect.dataset.domain = normalizedDomain;
-            
-            const domainTypes = [
-              { value: 'unmapped', label: 'Unmapped' },
-              { value: 'your_site', label: 'Your site' },
-              { value: 'platform', label: 'Platform' },
-              { value: 'directory', label: 'Directory' },
-              { value: 'publisher', label: 'Publisher' },
-              { value: 'vendor', label: 'Vendor' },
-              { value: 'institution', label: 'Institution' },
-              { value: 'government', label: 'Government' },
-              { value: 'site', label: 'Site' }
-            ];
-            
-            // Get the actual domain_type from the data - check both domain_type and segment fields
-            let actualDomainType = 'unmapped';
-            if (it?.domain_type && typeof it.domain_type === 'string' && it.domain_type.trim()) {
-              actualDomainType = it.domain_type.trim();
-            } else if (it?.segment && typeof it.segment === 'string' && it.segment.trim()) {
-              actualDomainType = it.segment.trim();
-            }
-            
-            // Ensure the value matches one of the valid options
-            const validValues = domainTypes.map(dt => dt.value);
-            if (!validValues.includes(actualDomainType)) {
-              actualDomainType = 'unmapped';
-            }
-            
-            // Create options first, then set the value
-            domainTypes.forEach(({ value, label }) => {
-              const option = document.createElement('option');
-              option.value = value;
-              option.textContent = label;
-              if (value === actualDomainType) {
-                option.selected = true;
-              }
-              domainTypeSelect.appendChild(option);
-            });
-            
-            // Explicitly set the value after options are added
-            domainTypeSelect.value = actualDomainType;
-            
-            domainTypeSelect.addEventListener('change', async (e) => {
-              const newType = e.target.value;
-              const domain = e.target.dataset.domain;
-              try {
-                const resp = await fetch(apiUrl('/api/domain-strength/update-domain'), {
-                  method: 'POST',
-                  headers: { 'Content-Type': 'application/json' },
-                  body: JSON.stringify({ domain, domain_type: newType })
-                });
-                if (resp.ok) {
-                  __domainMetadataCache.delete(domain);
-                  // Refresh the table to show updated values
-                  await renderDomainStrengthSection();
-                } else {
-                  e.target.value = domainType;
-                  alert('Failed to update domain type. Please try again.');
-                }
-              } catch (err) {
-                e.target.value = domainType;
-                alert('Error updating domain type: ' + err.message);
-              }
-            });
-            
-            domainTypeCell.appendChild(domainTypeSelect);
-          }
-          
-          // Add competitor checkbox to the Competitor cell
-          const competitorCell = tr.querySelector(`td:nth-child(9)`);
-          if (competitorCell) {
-            const competitorCheckbox = document.createElement('input');
-            competitorCheckbox.type = 'checkbox';
-            competitorCheckbox.checked = isCompetitor;
-            competitorCheckbox.style.cursor = 'pointer';
-            competitorCheckbox.dataset.domain = normalizedDomain;
-            
-            competitorCheckbox.addEventListener('change', async (e) => {
-              const isComp = e.target.checked;
-              const domain = e.target.dataset.domain;
-              try {
-                const resp = await fetch(apiUrl('/api/domain-strength/update-domain'), {
-                  method: 'POST',
-                  headers: { 'Content-Type': 'application/json' },
-                  body: JSON.stringify({ domain, is_competitor: isComp })
-                });
-                if (resp.ok) {
-                  __domainMetadataCache.delete(domain);
-                  // Refresh the table to show updated values
-                  await renderDomainStrengthSection();
-                } else {
-                  e.target.checked = !isComp;
-                  alert('Failed to update competitor flag. Please try again.');
-                }
-              } catch (err) {
-                e.target.checked = !isComp;
-                alert('Error updating competitor flag: ' + err.message);
-              }
-            });
-            
-            competitorCell.appendChild(competitorCheckbox);
-          }
-
-          const canvas = document.getElementById(canvasId);
-          renderDomainStrengthSparklineChart(canvas, labels, scores);
-        }
-
-        // Add expand/collapse row if there are hidden rows
-        if (!domainStrengthExpanded && hiddenRowsCount > 0) {
-          const expandRow = document.createElement('tr');
-          expandRow.id = 'domain-strength-expand-row';
-          expandRow.style.cursor = 'pointer';
-          expandRow.style.backgroundColor = '#f8fafc';
-          expandRow.style.borderTop = '2px solid #e2e8f0';
-          expandRow.innerHTML = `
-            <td colspan="9" style="text-align: center; padding: 1rem; color: #2563eb; font-weight: 600; font-size: 0.95rem;">
-              <span style="display: inline-flex; align-items: center; gap: 0.5rem;">
-                <span style="font-size: 1.1rem;">‚ñº</span>
-                <span>Show ${hiddenRowsCount} more row${hiddenRowsCount !== 1 ? 's' : ''}</span>
-              </span>
-            </td>
-          `;
-          expandRow.addEventListener('click', (e) => {
-            e.preventDefault();
-            e.stopPropagation();
-            domainStrengthExpanded = true;
-            renderDomainStrengthSection();
-          });
-          expandRow.addEventListener('mouseenter', () => {
-            expandRow.style.backgroundColor = '#e0f2fe';
-          });
-          expandRow.addEventListener('mouseleave', () => {
-            expandRow.style.backgroundColor = '#f8fafc';
-          });
-          tbody.appendChild(expandRow);
-        } else if (domainStrengthExpanded && paginatedRows.length > 3) {
-          const collapseRow = document.createElement('tr');
-          collapseRow.id = 'domain-strength-collapse-row';
-          collapseRow.style.cursor = 'pointer';
-          collapseRow.style.backgroundColor = '#f8fafc';
-          collapseRow.style.borderTop = '2px solid #e2e8f0';
-          collapseRow.innerHTML = `
-            <td colspan="9" style="text-align: center; padding: 1rem; color: #2563eb; font-weight: 600; font-size: 0.95rem;">
-              <span style="display: inline-flex; align-items: center; gap: 0.5rem;">
-                <span style="font-size: 1.1rem;">‚ñ≤</span>
-                <span>Show less</span>
-              </span>
-            </td>
-          `;
-          collapseRow.addEventListener('click', (e) => {
-            e.preventDefault();
-            e.stopPropagation();
-            domainStrengthExpanded = false;
-            renderDomainStrengthSection();
-          });
-          collapseRow.addEventListener('mouseenter', () => {
-            collapseRow.style.backgroundColor = '#e0f2fe';
-          });
-          collapseRow.addEventListener('mouseleave', () => {
-            collapseRow.style.backgroundColor = '#f8fafc';
-          });
-          tbody.appendChild(collapseRow);
-        }
-
-        // Update sort indicators
-        document.querySelectorAll('#domain-strength-table th.sortable').forEach(th => {
-          th.classList.remove('sort-asc', 'sort-desc');
-          if (th.dataset.sort === domainStrengthSortState.column) {
-            th.classList.add(`sort-${domainStrengthSortState.direction}`);
-          }
-        });
-
-        // Update pagination controls
-        const paginationInfo = document.getElementById('domain-strength-pagination-info');
-        const prevBtn = document.getElementById('domain-strength-pagination-prev');
-        const nextBtn = document.getElementById('domain-strength-pagination-next');
-        const rowsPerPageSelect = document.getElementById('domain-strength-rows-per-page');
-        
-        if (paginationInfo) {
-          paginationInfo.textContent = totalPages > 1 
-            ? `Page ${currentPage} of ${totalPages} ‚Ä¢ Showing ${startIdx + 1}-${endIdx} of ${totalRows}`
-            : `Total: ${totalRows}`;
-        }
-        
-        if (prevBtn) {
-          prevBtn.disabled = currentPage === 1;
-          prevBtn.style.background = currentPage === 1 ? '#f1f5f9' : 'white';
-          prevBtn.style.cursor = currentPage === 1 ? 'not-allowed' : 'pointer';
-          prevBtn.style.color = currentPage === 1 ? '#94a3b8' : '#475569';
-        }
-        
-        if (nextBtn) {
-          nextBtn.disabled = currentPage === totalPages;
-          nextBtn.style.background = currentPage === totalPages ? '#f1f5f9' : 'white';
-          nextBtn.style.cursor = currentPage === totalPages ? 'not-allowed' : 'pointer';
-          nextBtn.style.color = currentPage === totalPages ? '#94a3b8' : '#475569';
-        }
-        
-        if (rowsPerPageSelect) {
-          rowsPerPageSelect.value = domainStrengthPaginationState.rowsPerPage;
-        }
-
-        // Re-wire sorting and pagination after render
-        wireDomainStrengthSorting();
-        wireDomainStrengthPagination();
-      }
-
-      async function runDomainStrengthSnapshot() {
-        debugLog('[DomainStrength] runDomainStrengthSnapshot() called', 'info');
-        const statusEl = document.getElementById('domain-strength-run-status');
-        const btn = document.getElementById('domain-strength-run-btn');
-        const overlay = document.getElementById('domain-strength-overlay');
-        const overlayStatus = document.getElementById('domain-strength-overlay-status');
-
-        // Don't send core domains - API will handle alanranger.com + pending queue
-        // This ensures cost control: only fetch domains that don't have snapshots this month
-        const domains = [];
-
-        // Show overlay
-        if (overlay) {
-          overlay.classList.add('show');
-        }
-        if (overlayStatus) {
-          overlayStatus.textContent = `Fetching alanranger.com + up to 100 pending domains (skipping domains already processed this month)...`;
-        }
-
-        if (btn) {
-          btn.disabled = true;
-          btn.textContent = 'Running‚Ä¶';
-        }
-        if (statusEl) statusEl.textContent = `Running snapshot (alanranger.com + pending queue)...`;
-
-        try {
-          const apiEndpoint = apiUrl('/api/domain-strength/snapshot');
-          debugLog(`[DomainStrength] Calling API: ${apiEndpoint}`, 'info');
-          debugLog(`[DomainStrength] Request: mode=run, includePending=true`, 'info');
-          
-          if (overlayStatus) {
-            overlayStatus.textContent = `Calling DataForSEO API (alanranger.com + pending domains)...`;
-          }
-          
-          const resp = await fetch(apiEndpoint, {
-            method: 'POST',
-            headers: { 'Content-Type': 'application/json' },
-            body: JSON.stringify({ mode: 'run', domains: [], includePending: true })
-          });
-          
-          debugLog(`[DomainStrength] API response status: ${resp.status} ${resp.statusText}`, 'info');
-          
-          if (overlayStatus) {
-            overlayStatus.textContent = 'Processing response and saving to database...';
-          }
-          
-          let json;
-          try {
-            const responseText = await resp.text();
-            debugLog(`[DomainStrength] API response text (first 200 chars): ${responseText.substring(0, 200)}`, 'info');
-            json = JSON.parse(responseText);
-          } catch (parseError) {
-            debugLog(`[DomainStrength] Failed to parse JSON response: ${parseError.message}`, 'error');
-            throw new Error(`API returned invalid JSON (status ${resp.status}). Response may be an error page.`);
-          }
-          
-          debugLog(`[DomainStrength] API response: status=${json?.status}, inserted=${json?.inserted}, snapshot_date=${json?.snapshot_date}, domains_processed=${json?.domains_processed}`, 'info');
-          debugLog(`[DomainStrength] Debug info: ${JSON.stringify(json?.debug || {})}`, 'info');
-          
-          // Update overlay message with actual domain count from API (includes pending domains)
-          const actualDomainCount = json?.domains_processed || 1;
-          if (overlayStatus) {
-            overlayStatus.textContent = `Calling DataForSEO API for ${actualDomainCount} domains (alanranger.com + ${actualDomainCount - 1} pending)...`;
-          }
-          
-          if (json?.status !== 'ok') {
-            const errorMsg = json?.message || json?.details || 'Snapshot failed';
-            debugLog(`[DomainStrength] API returned error: ${errorMsg}`, 'error');
-            throw new Error(errorMsg);
-          }
-          
-          debugLog(`[DomainStrength] ‚úì Snapshot successful: ${json.inserted || 0} domains saved (date: ${json.snapshot_date})`, 'success');
-          
-          // Fetch remaining pending count
-          let remainingPending = 0;
-          try {
-            const pendingResp = await fetch(apiUrl('/api/domain-strength/pending-count'));
-            if (pendingResp.ok) {
-              const pendingData = await pendingResp.json();
-              remainingPending = pendingData.count || 0;
-            }
-          } catch (e) {
-            debugLog(`[DomainStrength] Could not fetch pending count: ${e.message}`, 'warn');
-          }
-          
-          // Hide progress overlay
-          if (overlay) {
-            overlay.classList.remove('show');
-          }
-          
-          // Show completion modal
-          const completionModal = document.getElementById('domain-strength-completion-modal');
-          const completionStats = document.getElementById('domain-strength-completion-stats');
-          if (completionModal && completionStats) {
-            const domainsProcessed = json.domains_processed || 0;
-            const domainsInserted = json.inserted || 0;
-            const domainsFetched = json.fetched || 0;
-            
-            completionStats.innerHTML = `
-              <div style="margin-bottom: 1rem; padding: 1rem; background: #f0f9ff; border-radius: 8px; border-left: 4px solid #0ea5e9;">
-                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
-                  <span style="font-weight: 600; color: #0c4a6e;">Domains Processed:</span>
-                  <span style="font-size: 1.25rem; font-weight: 700; color: #0284c7;">${domainsProcessed}</span>
-                </div>
-                <div style="font-size: 0.875rem; color: #075985;">
-                  ${domainsFetched} fetched from DataForSEO ‚Ä¢ ${domainsInserted} snapshots saved
-                </div>
-              </div>
-              <div style="padding: 1rem; background: ${remainingPending > 0 ? '#fef3c7' : '#f0fdf4'}; border-radius: 8px; border-left: 4px solid ${remainingPending > 0 ? '#f59e0b' : '#10b981'};">
-                <div style="display: flex; justify-content: space-between; align-items: center;">
-                  <span style="font-weight: 600; color: ${remainingPending > 0 ? '#92400e' : '#065f46'};">Remaining in Queue:</span>
-                  <span style="font-size: 1.25rem; font-weight: 700; color: ${remainingPending > 0 ? '#d97706' : '#059669'};">${remainingPending}</span>
-                </div>
-                ${remainingPending > 0 ? '<div style="font-size: 0.875rem; color: #78350f; margin-top: 0.5rem;">Run snapshot again to process more domains</div>' : '<div style="font-size: 0.875rem; color: #047857; margin-top: 0.5rem;">All domains have been processed!</div>'}
-              </div>
-            `;
-            
-            completionModal.style.display = 'flex';
-            
-            // Wire up close button
-            const closeBtn = document.getElementById('domain-strength-completion-close');
-            if (closeBtn) {
-              closeBtn.onclick = () => {
-                completionModal.style.display = 'none';
-              };
-            }
-          }
-          
-          if (statusEl) statusEl.textContent = `‚úì Snapshot saved for ${json.inserted || 0} domains (date: ${json.snapshot_date}).`;
-          showStatus(`‚úì Domain strength snapshot saved (${json.snapshot_date})`, 'success');
-          
-          debugLog('[DomainStrength] Refreshing domain strength section...', 'info');
-          await renderDomainStrengthSection();
-          debugLog('[DomainStrength] ‚úì Domain strength section refreshed', 'success');
-        } catch (e) {
-          const msg = e?.message || String(e);
-          debugLog(`[DomainStrength] ‚úó Snapshot error: ${msg}`, 'error');
-          if (overlayStatus) {
-            overlayStatus.textContent = `‚úó Error: ${msg}`;
-          }
-          if (statusEl) statusEl.textContent = `‚úó Snapshot failed: ${msg}`;
-          showStatus(`‚úó Domain strength snapshot failed: ${msg}`, 'error');
-          // Keep overlay visible for a moment to show error
-          await new Promise(resolve => setTimeout(resolve, 2000));
-          
-          // Hide overlay on error
-          if (overlay) {
-            overlay.classList.remove('show');
-          }
-        } finally {
-          if (btn) {
-            btn.disabled = false;
-            btn.textContent = 'Run Domain Strength Snapshot (Google)';
-          }
-        }
-      }
-
-      function wireDomainStrengthButton() {
-        const btn = document.getElementById('domain-strength-run-btn');
-        if (!btn) return;
-        const newBtn = btn.cloneNode(true);
-        btn.parentNode.replaceChild(newBtn, btn);
-        newBtn.addEventListener('click', () => {
-          runDomainStrengthSnapshot();
-        });
-
-        // Render current view (if history exists) once the ranking module has data
-        try {
-          renderDomainStrengthSection();
-        } catch {
-          // ignore
-        }
-      }
-
-      function wireDomainStrengthSorting() {
-        const sortableHeaders = document.querySelectorAll('#domain-strength-table th.sortable');
-        if (!sortableHeaders || sortableHeaders.length === 0) return;
-        
-        // Remove existing listeners by cloning (preserve innerHTML structure)
-        sortableHeaders.forEach(th => {
-          if (th.dataset.sortWired === 'true') {
-            const newTh = th.cloneNode(true);
-            th.parentNode.replaceChild(newTh, th);
-          }
-        });
-        
-        // Re-query after cloning to get fresh elements
-        const freshHeaders = document.querySelectorAll('#domain-strength-table th.sortable');
-        
-        freshHeaders.forEach(th => {
-          th.dataset.sortWired = 'true';
-          
-          // Use a named function to make debugging easier
-          const handleSortClick = function(e) {
-            e.stopPropagation();
-            e.preventDefault();
-            const column = this.dataset.sort;
-            if (!column) {
-              console.warn('[DomainStrength] No sort column found on clicked header');
-              return;
-            }
-            
-            console.log('[DomainStrength] Sort clicked:', column, 'Current state:', domainStrengthSortState);
-            
-            if (domainStrengthSortState.column === column) {
-              // Toggle direction if clicking the same column
-              domainStrengthSortState.direction = domainStrengthSortState.direction === 'asc' ? 'desc' : 'asc';
-            } else {
-              // New column, start with ascending
-              domainStrengthSortState.column = column;
-              domainStrengthSortState.direction = 'asc';
-            }
-            
-            console.log('[DomainStrength] New sort state:', domainStrengthSortState);
-            
-            domainStrengthPaginationState.currentPage = 1;
-            renderDomainStrengthSection();
-          };
-          
-          th.addEventListener('click', handleSortClick);
-        });
-        
-        console.log('[DomainStrength] Wired', freshHeaders.length, 'sortable headers');
-      }
-
-      function wireDomainStrengthPagination() {
-        const prevBtn = document.getElementById('domain-strength-pagination-prev');
-        const nextBtn = document.getElementById('domain-strength-pagination-next');
-        const rowsPerPageSelect = document.getElementById('domain-strength-rows-per-page');
-        
-        if (prevBtn) {
-          const newPrevBtn = prevBtn.cloneNode(true);
-          prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
-          newPrevBtn.addEventListener('click', () => {
-            if (domainStrengthPaginationState.currentPage > 1) {
-              domainStrengthPaginationState.currentPage--;
-              renderDomainStrengthSection();
-            }
-          });
-        }
-        
-        if (nextBtn) {
-          const newNextBtn = nextBtn.cloneNode(true);
-          nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
-          newNextBtn.addEventListener('click', () => {
-            // Re-fetch items to get accurate total
-            fetchDomainStrengthOverview().then(items => {
-              const engine = 'google';
-              const filtered = items.filter((it) => String(it?.searchEngine || '').toLowerCase() === engine);
-              const totalRows = filtered.length;
-              const rowsPerPage = domainStrengthPaginationState.rowsPerPage === 'all' ? totalRows : domainStrengthPaginationState.rowsPerPage;
-              const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
-              if (domainStrengthPaginationState.currentPage < totalPages) {
-                domainStrengthPaginationState.currentPage++;
-                renderDomainStrengthSection();
-              }
-            }).catch(() => {
-              // If fetch fails, just increment and re-render
-              domainStrengthPaginationState.currentPage++;
-              renderDomainStrengthSection();
-            });
-          });
-        }
-        
-        if (rowsPerPageSelect) {
-          const newSelect = rowsPerPageSelect.cloneNode(true);
-          rowsPerPageSelect.parentNode.replaceChild(newSelect, rowsPerPageSelect);
-          newSelect.value = domainStrengthPaginationState.rowsPerPage;
-          newSelect.addEventListener('change', (e) => {
-            const value = e.target.value;
-            domainStrengthPaginationState.rowsPerPage = value === 'all' ? 'all' : parseInt(value, 10);
-            domainStrengthPaginationState.currentPage = 1;
-            renderDomainStrengthSection();
-          });
-        }
-      }
-      
-      // Wire button immediately
-      wireRankingAiButton();
-      // Wire domain strength button immediately
-      if (typeof wireDomainStrengthButton === 'function') wireDomainStrengthButton();
-      wireRankingFilters();
-      wireRankingSorting();
-      wireRankingPagination();
-      wireDomainStrengthSorting();
-      wireDomainStrengthPagination();
-      
-      // Make functions globally available for panel switching
-      window.wireRankingAiButton = wireRankingAiButton;
-      window.wireDomainStrengthButton = wireDomainStrengthButton;
-      window.wireRankingFilters = wireRankingFilters;
-      window.wireRankingSorting = wireRankingSorting;
-      window.wireDomainStrengthSorting = wireDomainStrengthSorting;
-      window.wireDomainStrengthPagination = wireDomainStrengthPagination;
-
-      function wireRankingFilters() {
-        const segmentFilter = document.getElementById("ranking-filter-segment");
-        const rankFilter = document.getElementById("ranking-filter-rank");
-        const volumeFilter = document.getElementById("ranking-filter-volume");
-        const ctrFilter = document.getElementById("ranking-filter-ctr");
-        const aiOverviewFilter = document.getElementById("ranking-filter-ai-overview");
-        const aiCitationFilter = document.getElementById("ranking-filter-ai-citation");
-        const opportunityFilter = document.getElementById("ranking-filter-opportunity");
-        const pageTypeFilter = document.getElementById("ranking-filter-page-type");
-        const serpFeaturesFilter = document.getElementById("ranking-filter-serp-features");
-        const optimisationStatusFilter = document.getElementById("ranking-filter-optimisation-status");
-        const keywordFilter = document.getElementById("ranking-filter-keyword");
-        const clearBtn = document.getElementById("ranking-filter-clear");
-
-        // Update active state styling for filters
-        const updateFilterActiveStates = () => {
-          const filterControls = [
-            { el: segmentFilter, value: rankingFilterState.segment },
-            { el: rankFilter, value: rankingFilterState.rank },
-            { el: volumeFilter, value: rankingFilterState.volume },
-            { el: ctrFilter, value: rankingFilterState.ctr },
-            { el: aiOverviewFilter, value: rankingFilterState.aiOverview },
-            { el: aiCitationFilter, value: rankingFilterState.aiCitation },
-            { el: opportunityFilter, value: rankingFilterState.opportunity },
-            { el: pageTypeFilter, value: rankingFilterState.pageType },
-            { el: serpFeaturesFilter, value: rankingFilterState.serpFeatures },
-            { el: optimisationStatusFilter, value: rankingFilterState.optimisationStatus }
-          ];
-
-          filterControls.forEach(({ el, value }) => {
-            if (el) {
-              if (value && value !== 'all') {
-                el.classList.add('filter-active');
-              } else {
-                el.classList.remove('filter-active');
-              }
-            }
-          });
-
-          // Handle keyword filter separately (active if not empty)
-          if (keywordFilter) {
-            if (rankingFilterState.keyword && rankingFilterState.keyword.trim() !== '') {
-              keywordFilter.classList.add('filter-active');
-            } else {
-              keywordFilter.classList.remove('filter-active');
-            }
-          }
-        };
-
-        const minOpportunityInput = document.getElementById("ranking-filter-min-opportunity");
-        const minOpportunityNote = document.getElementById("ranking-filter-min-opportunity-note");
-
-        const updateFilters = () => {
-          if (segmentFilter) rankingFilterState.segment = segmentFilter.value;
-          if (rankFilter) rankingFilterState.rank = rankFilter.value;
-          if (volumeFilter) rankingFilterState.volume = volumeFilter.value;
-          if (ctrFilter) rankingFilterState.ctr = ctrFilter.value;
-          if (aiOverviewFilter) rankingFilterState.aiOverview = aiOverviewFilter.value;
-          if (aiCitationFilter) rankingFilterState.aiCitation = aiCitationFilter.value;
-          if (opportunityFilter) rankingFilterState.opportunity = opportunityFilter.value;
-          if (pageTypeFilter) rankingFilterState.pageType = pageTypeFilter.value;
-          if (serpFeaturesFilter) rankingFilterState.serpFeatures = serpFeaturesFilter.value;
-          if (optimisationStatusFilter) rankingFilterState.optimisationStatus = optimisationStatusFilter.value;
-          if (keywordFilter) rankingFilterState.keyword = keywordFilter.value.trim();
-          
-          // Min opportunity filter
-          if (minOpportunityInput) {
-            const minOppValue = minOpportunityInput.value.trim();
-            if (minOppValue === '') {
-              rankingFilterState.minOpportunity = null;
-              if (minOpportunityNote) minOpportunityNote.style.display = 'none';
-            } else {
-              const numValue = Number(minOppValue);
-              if (Number.isFinite(numValue) && numValue >= 0 && numValue <= 100) {
-                rankingFilterState.minOpportunity = numValue;
-                if (minOpportunityNote) minOpportunityNote.style.display = 'block';
-              } else {
-                rankingFilterState.minOpportunity = null;
-                if (minOpportunityNote) minOpportunityNote.style.display = 'none';
-              }
-            }
-          }
-          
-          // Update active states
-          updateFilterActiveStates();
-          
-          rankingPaginationState.currentPage = 1; // Reset to first page on filter change
-          renderRankingAiTab();
-        };
-
-        // Debounce function for keyword filter to improve performance
-        let keywordFilterTimeout = null;
-        const debouncedUpdateFilters = () => {
-          // Update the keyword value immediately for active state
-          if (keywordFilter) {
-            rankingFilterState.keyword = keywordFilter.value.trim();
-            updateFilterActiveStates();
-          }
-          
-          // Clear existing timeout
-          if (keywordFilterTimeout) {
-            clearTimeout(keywordFilterTimeout);
-          }
-          
-          // Set new timeout to actually apply the filter after user stops typing
-          keywordFilterTimeout = setTimeout(() => {
-            updateFilters();
-            keywordFilterTimeout = null;
-          }, 300); // 300ms delay
-        };
-
-        if (segmentFilter) segmentFilter.addEventListener("change", updateFilters);
-        if (rankFilter) rankFilter.addEventListener("change", updateFilters);
-        if (volumeFilter) volumeFilter.addEventListener("change", updateFilters);
-        if (ctrFilter) ctrFilter.addEventListener("change", updateFilters);
-        if (aiOverviewFilter) aiOverviewFilter.addEventListener("change", updateFilters);
-        if (aiCitationFilter) aiCitationFilter.addEventListener("change", updateFilters);
-        if (opportunityFilter) opportunityFilter.addEventListener("change", updateFilters);
-        if (pageTypeFilter) pageTypeFilter.addEventListener("change", updateFilters);
-        if (serpFeaturesFilter) serpFeaturesFilter.addEventListener("change", updateFilters);
-        if (optimisationStatusFilter) optimisationStatusFilter.addEventListener("change", updateFilters);
-        if (keywordFilter) keywordFilter.addEventListener("input", debouncedUpdateFilters);
-        if (minOpportunityInput) {
-          minOpportunityInput.addEventListener("input", debouncedUpdateFilters);
-          minOpportunityInput.addEventListener("blur", updateFilters);
-        }
-
-        if (clearBtn) {
-          clearBtn.addEventListener("click", () => {
-            // Cancel any pending debounced keyword filter updates
-            if (keywordFilterTimeout) {
-              clearTimeout(keywordFilterTimeout);
-              keywordFilterTimeout = null;
-            }
-            
-            rankingFilterState = {
-              segment: 'all',
-              rank: 'all',
-              volume: 'all',
-              ctr: 'all',
-              opportunity: 'all',
-              aiOverview: 'all',
-              aiCitation: 'all',
-              pageType: 'all',
-              serpFeatures: 'all',
-              optimisationStatus: 'all',
-              keyword: '',
-              minOpportunity: null
-            };
-            activePreset = null; // Clear active preset
-            rankingPriorityFilter = null; // Clear priority matrix filter
-            selectedKeywordId = null; // Clear selected keyword
-            if (segmentFilter) segmentFilter.value = 'all';
-            if (rankFilter) rankFilter.value = 'all';
-            if (volumeFilter) volumeFilter.value = 'all';
-            if (ctrFilter) ctrFilter.value = 'all';
-            if (aiOverviewFilter) aiOverviewFilter.value = 'all';
-            if (aiCitationFilter) aiCitationFilter.value = 'all';
-            if (opportunityFilter) opportunityFilter.value = 'all';
-            if (pageTypeFilter) pageTypeFilter.value = 'all';
-            if (serpFeaturesFilter) serpFeaturesFilter.value = 'all';
-            if (optimisationStatusFilter) optimisationStatusFilter.value = 'all';
-            if (keywordFilter) keywordFilter.value = '';
-            if (minOpportunityInput) {
-              minOpportunityInput.value = '';
-              if (minOpportunityNote) minOpportunityNote.style.display = 'none';
-            }
-            updateFilterActiveStates();
-            if (typeof updatePresetButtonActiveStates === 'function') {
-              updatePresetButtonActiveStates();
-            }
-            if (typeof renderPresetCriteriaChips === 'function') {
-              renderPresetCriteriaChips();
-            }
-            rankingPaginationState.currentPage = 1; // Reset to first page on clear
-            rankingSortState.column = 'opportunityScore'; // Reset sort
-            rankingSortState.direction = 'desc';
-            renderRankingAiTab();
-          });
-        }
-
-        // Default filter state (single source of truth)
-        const DEFAULT_FILTERS = {
-          segment: 'all',
-          rank: 'all',
-          volume: 'all',
-          ctr: 'all',
-          opportunity: 'all',
-          minOpportunity: null,
-          aiOverview: 'all',
-          aiCitation: 'all',
-          pageType: 'all',
-          serpFeatures: 'all',
-          keyword: ''
-        };
-
-        // Default sort state
-        const DEFAULT_SORT = {
-          column: 'opportunityScore',
-          direction: 'desc'
-        };
-
-        // Preset definitions (data-driven)
-        const PRESETS = {
-          'all': {
-            label: 'All keywords',
-            filters: { ...DEFAULT_FILTERS },
-            sort: { ...DEFAULT_SORT }
-          },
-          'high-impact-money': {
-            label: 'High-impact money',
-            filters: {
-              ...DEFAULT_FILTERS,
-              segment: 'money',
-              volume: 'high',
-              rank: '11-20',
-              minOpportunity: 65
-            },
-            sort: {
-              column: 'opportunityScore',
-              direction: 'desc'
-            }
-          },
-          'ai-overview-not-cited': {
-            label: 'AI Overview, not cited',
-            filters: {
-              ...DEFAULT_FILTERS,
-              aiOverview: 'has',
-              aiCitation: 'not-cited',
-              minOpportunity: 50
-            },
-            sort: {
-              column: 'volume',
-              direction: 'desc'
-            }
-          },
-          'brand-safety': {
-            label: 'Brand safety',
-            filters: {
-              ...DEFAULT_FILTERS,
-              segment: 'brand',
-              rank: 'not-top3'
-            },
-            sort: {
-              column: 'rank',
-              direction: 'asc'
-            }
-          },
-          'education-growth': {
-            label: 'Blog opportunities',
-            filters: {
-              ...DEFAULT_FILTERS,
-              pageType: 'Blog',
-              rank: 'not-top3',
-              minOpportunity: 30
-            },
-            sort: {
-              column: 'opportunityScore',
-              direction: 'desc'
-            }
-          },
-          'local-visibility': {
-            label: 'Local visibility',
-            filters: {
-              ...DEFAULT_FILTERS,
-              pageType: 'GBP',
-              rank: 'not-top3',
-              minOpportunity: 30
-            },
-            sort: {
-              column: 'opportunityScore',
-              direction: 'desc'
-            }
-          },
-          'top-10-opportunities': {
-            label: 'Top 10 opportunities',
-            filters: {
-              ...DEFAULT_FILTERS,
-              rank: 'not-top3',
-              minOpportunity: 50
-            },
-            sort: {
-              column: 'opportunityScore',
-              direction: 'desc'
-            },
-            rowsPerPage: 10
-          }
-        };
-
-        // Preset button handlers
-        function applyPreset(presetKey) {
-          // Cancel any pending debounced keyword filter updates
-          if (keywordFilterTimeout) {
-            clearTimeout(keywordFilterTimeout);
-            keywordFilterTimeout = null;
-          }
-
-          // Clear priority matrix filter and selected keyword
-          rankingPriorityFilter = null;
-          selectedKeywordId = null;
-
-          // Get preset definition
-          const preset = PRESETS[presetKey];
-          if (!preset) {
-            console.warn(`Unknown preset: ${presetKey}`);
-            return;
-          }
-
-          // HARD RESET: Apply preset filters (don't merge with existing state)
-          rankingFilterState = { ...preset.filters };
-          rankingSortState = { ...preset.sort };
-
-          // Set rows per page if specified in preset
-          if (preset.rowsPerPage) {
-            const rowsPerPageSelect = document.getElementById('ranking-rows-per-page');
-            if (rowsPerPageSelect) {
-              rowsPerPageSelect.value = preset.rowsPerPage;
-              rankingPaginationState.rowsPerPage = preset.rowsPerPage;
-            }
-          }
-
-          // Set active preset (null for 'all')
-          activePreset = presetKey === 'all' ? null : presetKey;
-
-          // Update UI elements to match filter state
-          if (segmentFilter) segmentFilter.value = rankingFilterState.segment;
-          if (rankFilter) rankFilter.value = rankingFilterState.rank;
-          if (volumeFilter) volumeFilter.value = rankingFilterState.volume;
-          if (ctrFilter) ctrFilter.value = rankingFilterState.ctr;
-          if (aiOverviewFilter) aiOverviewFilter.value = rankingFilterState.aiOverview;
-          if (aiCitationFilter) aiCitationFilter.value = rankingFilterState.aiCitation;
-          if (opportunityFilter) opportunityFilter.value = rankingFilterState.opportunity;
-          if (pageTypeFilter) pageTypeFilter.value = rankingFilterState.pageType;
-          if (serpFeaturesFilter) serpFeaturesFilter.value = rankingFilterState.serpFeatures;
-          if (keywordFilter) keywordFilter.value = rankingFilterState.keyword;
-          
-          // Update minOpportunity input
-          const minOppInput = document.getElementById("ranking-filter-min-opportunity");
-          const minOppNote = document.getElementById("ranking-filter-min-opportunity-note");
-          if (minOppInput) {
-            if (rankingFilterState.minOpportunity != null) {
-              minOppInput.value = String(rankingFilterState.minOpportunity);
-              if (minOppNote) minOppNote.style.display = 'block';
-            } else {
-              minOppInput.value = '';
-              if (minOppNote) minOppNote.style.display = 'none';
-            }
-          }
-
-          updateFilterActiveStates();
-          updatePresetButtonActiveStates();
-          rankingPaginationState.currentPage = 1;
-          renderPresetCriteriaChips();
-          renderRankingAiTab();
-        }
-
-        // Update preset button active states
-        function updatePresetButtonActiveStates() {
-          const presetButtons = document.querySelectorAll('.ranking-preset-btn');
-          presetButtons.forEach(btn => {
-            const presetKey = btn.getAttribute('data-preset');
-            if (activePreset === presetKey || (presetKey === 'all' && activePreset === null)) {
-              btn.classList.add('preset-active');
-              btn.style.background = '#047857'; // Darker green background for active (emerald-800)
-              btn.style.borderColor = '#065f46'; // Darker border
-              btn.style.color = '#ffffff';
-              btn.style.fontWeight = '600';
-            } else {
-              btn.classList.remove('preset-active');
-              btn.style.background = 'rgb(229, 255, 204)';
-              btn.style.borderColor = '#cbd5e1';
-              btn.style.color = '#475569';
-              btn.style.fontWeight = '500';
-            }
-          });
-        }
-
-        // Get active criteria chips based on filter state
-        function getActiveCriteriaChips() {
-          const chips = [];
-          
-          if (rankingFilterState.segment !== 'all') {
-            const segmentLabel = rankingFilterState.segment.charAt(0).toUpperCase() + rankingFilterState.segment.slice(1);
-            chips.push({
-              label: `Segment: ${segmentLabel}`,
-              onRemove: () => {
-                rankingFilterState.segment = 'all';
-                const segmentFilter = document.getElementById("ranking-filter-segment");
-                if (segmentFilter) segmentFilter.value = 'all';
-                activePreset = null;
-                updateFilters();
-              }
-            });
-          }
-          
-          if (rankingFilterState.rank !== 'all') {
-            let rankLabel = '';
-            if (rankingFilterState.rank === 'top3') rankLabel = 'Top 3';
-            else if (rankingFilterState.rank === '4-10') rankLabel = '4‚Äì10';
-            else if (rankingFilterState.rank === '11-20') rankLabel = '11‚Äì20';
-            else if (rankingFilterState.rank === '21+') rankLabel = '21+ / Not ranked';
-            else if (rankingFilterState.rank === 'not-top3') rankLabel = 'Not top 3';
-            chips.push({
-              label: `Best rank: ${rankLabel}`,
-              onRemove: () => {
-                rankingFilterState.rank = 'all';
-                const rankFilter = document.getElementById("ranking-filter-rank");
-                if (rankFilter) rankFilter.value = 'all';
-                activePreset = null;
-                updateFilters();
-              }
-            });
-          }
-          
-          if (rankingFilterState.pageType && rankingFilterState.pageType !== 'all') {
-            chips.push({
-              label: `Page type: ${rankingFilterState.pageType}`,
-              onRemove: () => {
-                rankingFilterState.pageType = 'all';
-                const pageTypeFilter = document.getElementById("ranking-filter-page-type");
-                if (pageTypeFilter) pageTypeFilter.value = 'all';
-                activePreset = null;
-                updateFilters();
-              }
-            });
-          }
-          
-          if (rankingFilterState.volume !== 'all') {
-            const volumeLabel = rankingFilterState.volume.charAt(0).toUpperCase() + rankingFilterState.volume.slice(1);
-            chips.push({
-              label: `Search volume: ${volumeLabel}`,
-              onRemove: () => {
-                rankingFilterState.volume = 'all';
-                const volumeFilter = document.getElementById("ranking-filter-volume");
-                if (volumeFilter) volumeFilter.value = 'all';
-                activePreset = null;
-                updateFilters();
-              }
-            });
-          }
-          
-          if (rankingFilterState.aiOverview !== 'all') {
-            const aiLabel = rankingFilterState.aiOverview === 'has' ? 'On' : 'Off';
-            chips.push({
-              label: `AI Overview: ${aiLabel}`,
-              onRemove: () => {
-                rankingFilterState.aiOverview = 'all';
-                const aiOverviewFilter = document.getElementById("ranking-filter-ai-overview");
-                if (aiOverviewFilter) aiOverviewFilter.value = 'all';
-                activePreset = null;
-                updateFilters();
-              }
-            });
-          }
-          
-          if (rankingFilterState.aiCitation !== 'all') {
-            const citationLabel = rankingFilterState.aiCitation === 'cited' ? 'Cited' : 'Not cited';
-            chips.push({
-              label: `AI citation: ${citationLabel}`,
-              onRemove: () => {
-                rankingFilterState.aiCitation = 'all';
-                const aiCitationFilter = document.getElementById("ranking-filter-ai-citation");
-                if (aiCitationFilter) aiCitationFilter.value = 'all';
-                activePreset = null;
-                updateFilters();
-              }
-            });
-          }
-          
-          if (rankingFilterState.minOpportunity != null) {
-            chips.push({
-              label: `Min opportunity: ‚â• ${rankingFilterState.minOpportunity}`,
-              onRemove: () => {
-                rankingFilterState.minOpportunity = null;
-                const minOppInput = document.getElementById("ranking-filter-min-opportunity");
-                const minOppNote = document.getElementById("ranking-filter-min-opportunity-note");
-                if (minOppInput) minOppInput.value = '';
-                if (minOppNote) minOppNote.style.display = 'none';
-                activePreset = null;
-                updateFilters();
-              }
-            });
-          }
-          
-          // Add sort chip if not default
-          if (rankingSortState.column && (rankingSortState.column !== 'opportunityScore' || rankingSortState.direction !== 'desc')) {
-            const sortLabel = rankingSortState.column === 'rank' ? 'Rank' : 
-                             rankingSortState.column === 'volume' ? 'Volume' : 
-                             rankingSortState.column === 'opportunityScore' ? 'Opportunity' : 
-                             rankingSortState.column;
-            const sortDir = rankingSortState.direction === 'asc' ? '‚Üë' : '‚Üì';
-            chips.push({
-              label: `Sort: ${sortLabel} ${sortDir}`,
-              onRemove: () => {
-                rankingSortState.column = 'opportunityScore';
-                rankingSortState.direction = 'desc';
-                activePreset = null;
-                renderRankingAiTab();
-              }
-            });
-          }
-          
-          return chips;
-        }
-
-        // Render criteria chips
-        function renderPresetCriteriaChips() {
-          const chipsContainer = document.getElementById('ranking-preset-criteria-chips');
-          if (!chipsContainer) return;
-          
-          const chips = getActiveCriteriaChips();
-          
-          if (chips.length === 0 || activePreset === null) {
-            chipsContainer.style.display = 'none';
-            return;
-          }
-          
-          chipsContainer.style.display = 'block';
-          const chipsInner = chipsContainer.querySelector('div');
-          if (!chipsInner) return;
-          
-          chipsInner.innerHTML = chips.map(chip => {
-            // Create a wrapper function to handle the removal and update
-            const removeHandler = () => {
-              chip.onRemove();
-              updatePresetButtonActiveStates();
-              renderPresetCriteriaChips();
-            };
-            return `
-              <span style="display: inline-flex; align-items: center; gap: 0.375rem; padding: 0.375rem 0.75rem; background: #e5e7eb; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.875rem; color: #374151;">
-                ${chip.label}
-                <button type="button" onclick="(${removeHandler.toString()})()" style="background: none; border: none; cursor: pointer; color: #6b7280; font-size: 1rem; line-height: 1; padding: 0; margin-left: 0.25rem;" title="Remove this filter">√ó</button>
-              </span>
-            `;
-          }).join('');
-        }
-
-        // Wire up preset buttons (re-wire on each call to handle DOM updates)
-        function wirePresetButtons() {
-          // Remove existing listeners by cloning buttons
-          const presetButtons = document.querySelectorAll('.ranking-preset-btn');
-          presetButtons.forEach(btn => {
-            const newBtn = btn.cloneNode(true);
-            btn.parentNode.replaceChild(newBtn, btn);
-          });
-          
-          // Re-query to get fresh elements
-          const freshPresetButtons = document.querySelectorAll('.ranking-preset-btn');
-          freshPresetButtons.forEach(btn => {
-            btn.addEventListener('click', () => {
-              const presetKey = btn.getAttribute('data-preset');
-              if (presetKey) {
-                applyPreset(presetKey);
-              }
-            });
-          });
-        }
-        
-        // Wire preset buttons immediately
-        wirePresetButtons();
-        
-        // Make wirePresetButtons globally available
-        window.wirePresetButtons = wirePresetButtons;
-
-        // Initialize active states on page load
-        updateFilterActiveStates();
-      }
-
-      function wireRankingSorting() {
-        // Find all sortable headers
-        const sortableHeaders = document.querySelectorAll('.ranking-table th.sortable');
-        if (!sortableHeaders || sortableHeaders.length === 0) {
-          console.log('[Sort] No sortable headers found');
-          return;
-        }
-        
-        console.log('[Sort] Found', sortableHeaders.length, 'sortable headers');
-        
-        // Remove any existing data attribute markers
-        sortableHeaders.forEach(th => {
-          if (th.dataset.sortWired === 'true') {
-            // Clone to remove all listeners
-            const newTh = th.cloneNode(true);
-            th.parentNode.replaceChild(newTh, th);
-          }
-        });
-        
-        // Re-query after cloning
-        const freshHeaders = document.querySelectorAll('.ranking-table th.sortable');
-        
-        // Attach listeners directly to each header
-        freshHeaders.forEach(th => {
-          th.dataset.sortWired = 'true'; // Mark as wired
-          
-          th.addEventListener('click', function(e) {
-            e.stopPropagation();
-            const column = this.dataset.sort;
-            if (!column) {
-              console.log('[Sort] No sort column found');
-              return;
-            }
-            
-            console.log('[Sort] Clicked column:', column, 'Current:', rankingSortState.column, rankingSortState.direction);
-            
-            if (rankingSortState.column === column) {
-              // Toggle direction if clicking the same column
-              rankingSortState.direction = rankingSortState.direction === 'asc' ? 'desc' : 'asc';
-            } else {
-              // New column, start with ascending
-              rankingSortState.column = column;
-              rankingSortState.direction = 'asc';
-            }
-            
-            console.log('[Sort] New state:', rankingSortState.column, rankingSortState.direction);
-            
-            rankingPaginationState.currentPage = 1;
-            renderRankingAiTab();
-          });
-        });
-        
-        console.log('[Sort] Wired', freshHeaders.length, 'headers');
-      }
-      
-      function wireRankingPagination() {
-        const firstBtn = document.getElementById("ranking-pagination-first");
-        const prevBtn = document.getElementById("ranking-pagination-prev");
-        const nextBtn = document.getElementById("ranking-pagination-next");
-        const lastBtn = document.getElementById("ranking-pagination-last");
-        const rowsPerPageSelect = document.getElementById("ranking-rows-per-page");
-        
-        if (firstBtn) {
-          firstBtn.addEventListener("click", () => {
-            rankingPaginationState.currentPage = 1;
-            renderRankingAiTab();
-          });
-        }
-        
-        if (prevBtn) {
-          prevBtn.addEventListener("click", () => {
-            if (rankingPaginationState.currentPage > 1) {
-              rankingPaginationState.currentPage--;
-              renderRankingAiTab();
-            }
-          });
-        }
-        
-        if (nextBtn) {
-          nextBtn.addEventListener("click", () => {
-            rankingPaginationState.currentPage++;
-            renderRankingAiTab();
-          });
-        }
-        
-        if (lastBtn) {
-          lastBtn.addEventListener("click", () => {
-            // Calculate total pages from current data
-            const { combinedRows } = RankingAiModule.state();
-            if (!combinedRows || !Array.isArray(combinedRows)) return;
-            const filteredRows = applyRankingFilters(combinedRows);
-            const totalRows = filteredRows.length;
-            const rowsPerPage = rankingPaginationState.rowsPerPage === 'all' ? totalRows : rankingPaginationState.rowsPerPage;
-            const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
-            rankingPaginationState.currentPage = totalPages;
-            renderRankingAiTab();
-          });
-        }
-        
-        if (rowsPerPageSelect) {
-          rowsPerPageSelect.addEventListener("change", () => {
-            const value = rowsPerPageSelect.value;
-            rankingPaginationState.rowsPerPage = value === 'all' ? 'all' : parseInt(value, 10);
-            rankingPaginationState.currentPage = 1; // Reset to first page
-            renderRankingAiTab();
-          });
-        }
-      }
-
-      // ============================================
-      // AI Sources & Influence Tab Functions
-      // ============================================
-
-      /**
-       * Classify domain source type based on domain pattern
-       * @param {string} domain - Domain name (e.g., "visualeducation.com")
-       * @returns {string} Source type classification
-       */
-      function classifyDomainSourceType(domain) {
-        if (!domain) return 'Other';
-        const lower = domain.toLowerCase();
-        
-        // Directory patterns
-        if (lower.includes('yell.com') || lower.includes('tripadvisor') || 
-            lower.includes('facebook.com/pages') || lower.includes('thomsonlocal') ||
-            lower.includes('yell.co.uk') || lower.includes('freeindex')) {
-          return 'Directory';
-        }
-        
-        // Review platform patterns
-        if (lower.includes('trustpilot') || lower.includes('google.com/maps') ||
-            lower.includes('reviews.co.uk') || lower.includes('feefo')) {
-          return 'Review platform';
-        }
-        
-        // Course marketplace / education patterns
-        if (lower.includes('udemy') || lower.includes('coursera') ||
-            lower.includes('visualeducation') || lower.includes('skillshare') ||
-            lower.includes('edx') || lower.includes('futurelearn')) {
-          return 'Course marketplace / education';
-        }
-        
-        // Publisher / blog patterns (common content domains)
-        if (lower.includes('blog') || lower.includes('medium.com') ||
-            lower.includes('wordpress.com') || lower.includes('blogger.com')) {
-          return 'Publisher / blog';
-        }
-        
-        return 'Other';
-      }
-
-      /**
-       * Aggregate AI citation data by domain
-       * @param {Array} combinedRows - Array of keyword rows with AI citation data
-       * @param {string} targetDomain - Target domain (e.g., "alanranger.com")
-       * @returns {Array} Array of domain stats objects
-       */
-      function aggregateAiDomainStats(combinedRows, targetDomain = 'alanranger.com') {
-        if (!combinedRows || !Array.isArray(combinedRows)) {
-          debugLog('‚ö† aggregateAiDomainStats: No combinedRows provided', 'warn');
-          return [];
-        }
-
-        const domainMap = new Map();
-        const targetDomainLower = targetDomain.toLowerCase();
-
-        // Track total citations across all keywords
-        let totalAllCitations = 0;
-
-        combinedRows.forEach(row => {
-          // Get AI citations for this keyword
-          const aiCitations = row.ai_alan_citations || [];
-          const competitorCounts = row.competitor_counts || {};
-          const aiTotalCitations = row.ai_total_citations || 0;
-
-          totalAllCitations += aiTotalCitations;
-
-          // Process our own citations
-          if (aiCitations && aiCitations.length > 0) {
-            aiCitations.forEach(citation => {
-              if (!citation || !citation.url) return;
-              
-              try {
-                const urlObj = new URL(citation.url);
-                const domain = urlObj.hostname.toLowerCase();
-                
-                if (!domainMap.has(domain)) {
-                  domainMap.set(domain, {
-                    domain,
-                    is_self: domain.includes(targetDomainLower),
-                    total_citations: 0,
-                    keyword_count: 0,
-                    keywords: new Set(),
-                    example_urls: []
-                  });
-                }
-                
-                const stats = domainMap.get(domain);
-                stats.total_citations += 1;
-                if (!stats.keywords.has(row.keyword)) {
-                  stats.keywords.add(row.keyword);
-                  stats.keyword_count += 1;
-                }
-                if (stats.example_urls.length < 2) {
-                  stats.example_urls.push(citation.url);
-                }
-              } catch (e) {
-                // Invalid URL, skip
-              }
-            });
-          }
-
-          // Process competitor citations from competitor_counts (per keyword)
-          Object.entries(competitorCounts).forEach(([domain, count]) => {
-            if (!domain || !count) return;
-            
-            const domainLower = domain.toLowerCase();
-            
-            if (!domainMap.has(domainLower)) {
-              domainMap.set(domainLower, {
-                domain: domainLower,
-                is_self: domainLower.includes(targetDomainLower),
-                total_citations: 0,
-                keyword_count: 0,
-                keywords: new Set(),
-                example_urls: []
-              });
-            }
-            
-            const stats = domainMap.get(domainLower);
-            stats.total_citations += count;
-            if (!stats.keywords.has(row.keyword)) {
-              stats.keywords.add(row.keyword);
-              stats.keyword_count += 1;
-            }
-          });
-        });
-
-        // Convert to array and calculate share_of_citations
-        const domainStats = Array.from(domainMap.values()).map(stats => {
-          const share_of_citations = totalAllCitations > 0 
-            ? (stats.total_citations / totalAllCitations) * 100 
-            : 0;
-          
-          return {
-            domain: stats.domain,
-            is_self: stats.is_self,
-            total_citations: stats.total_citations,
-            keyword_count: stats.keyword_count,
-            share_of_citations,
-            source_type: classifyDomainSourceType(stats.domain),
-            example_urls: stats.example_urls.slice(0, 2),
-            keywords: Array.from(stats.keywords)
-          };
-        });
-
-        // Sort by total_citations descending
-        domainStats.sort((a, b) => b.total_citations - a.total_citations);
-
-        debugLog(`‚úì Aggregated ${domainStats.length} domains from AI citations`, 'info');
-        return domainStats;
-      }
-
-      /**
-       * Render AI Sources & Influence tab
-       */
-      function renderAiSourcesTab() {
-        debugLog('üìä renderAiSourcesTab() called', 'info');
-        
-        const { combinedRows } = RankingAiModule.state();
-        if (!combinedRows || combinedRows.length === 0) {
-          debugLog('‚ö† renderAiSourcesTab: No keyword data available', 'warn');
-          const tilesContainer = document.getElementById('ai-sources-tiles');
-          const tableBody = document.getElementById('ai-sources-table-body');
-          if (tilesContainer) tilesContainer.innerHTML = '<div class="card"><p style="padding: 2rem; text-align: center; color: #64748b;">No AI citation data available. Run a Ranking & AI check first.</p></div>';
-          if (tableBody) tableBody.innerHTML = '<tr><td colspan="6" class="ranking-table-empty">No data available. Run a Ranking & AI check first.</td></tr>';
-          return;
-        }
-
-        // Get target domain from property URL
-        const propertyUrl = localStorage.getItem('gsc_property_url') || 'https://www.alanranger.com';
-        let targetDomain = 'alanranger.com';
-        try {
-          const urlObj = new URL(propertyUrl);
-          targetDomain = urlObj.hostname.replace('www.', '');
-        } catch (e) {
-          debugLog(`‚ö† Could not parse property URL: ${propertyUrl}, using default domain`, 'warn');
-        }
-
-        // Aggregate domain stats
-        const domainStats = aggregateAiDomainStats(combinedRows, targetDomain);
-        
-        // Store globally for filtering/sorting
-        window.aiSourcesDomainStats = domainStats;
-
-        // Render tiles
-        renderAiSourcesTiles(domainStats, combinedRows.length);
-
-        // Render source types breakdown
-        renderAiSourcesTypesBreakdown(domainStats);
-
-        // Render domain table
-        renderAiSourcesTable(domainStats).catch(err => {
-          console.error('Error rendering AI sources table:', err);
-        });
-      }
-
-      /**
-       * Render summary tiles for AI Sources & Influence
-       */
-      function renderAiSourcesTiles(domainStats, totalKeywords) {
-        const tilesContainer = document.getElementById('ai-sources-tiles');
-        if (!tilesContainer) return;
-
-        // Calculate metrics
-        const selfDomain = domainStats.find(d => d.is_self);
-        const selfCitations = selfDomain ? selfDomain.total_citations : 0;
-        const totalCitations = domainStats.reduce((sum, d) => sum + d.total_citations, 0);
-        const selfShare = totalCitations > 0 ? (selfCitations / totalCitations) * 100 : 0;
-        const keywordsWithSelfCitations = selfDomain ? selfDomain.keyword_count : 0;
-        const externalDomains = domainStats.filter(d => !d.is_self).length;
-
-        const pctKeywordsWithCitations = totalKeywords > 0
-          ? (keywordsWithSelfCitations / totalKeywords) * 100
-          : 0;
-
-        const ragForShare = () => {
-          if (totalCitations <= 0) return 'neutral';
-          if (selfShare >= 20) return 'green';
-          if (selfShare >= 10) return 'amber';
-          return 'red';
-        };
-
-        const ragForKeywordCoverage = () => {
-          if (totalKeywords <= 0) return 'neutral';
-          if (pctKeywordsWithCitations >= 60) return 'green';
-          if (pctKeywordsWithCitations >= 30) return 'amber';
-          return 'red';
-        };
-
-        const statusForRag = (rag) => {
-          if (rag === 'green') return 'Strong';
-          if (rag === 'amber') return 'Moderate';
-          if (rag === 'red') return 'Weak';
-          return 'Info';
-        };
-
-        const makePill = ({ rag, value, label, status, footer }) => `
-          <div class="metric-pill metric-pill--${rag}">
-            <div class="metric-pill-value">${value}</div>
-            <div class="metric-pill-label">${label}</div>
-            <div class="metric-pill-status">${status}</div>
-            <div class="metric-pill-footer">${footer}</div>
-          </div>
-        `;
-
-        const shareRag = ragForShare();
-        const coverageRag = ragForKeywordCoverage();
-
-        const html = `
-          ${makePill({
-            rag: shareRag,
-            value: `${selfCitations}/${totalCitations}`,
-            label: 'Your AI citations',
-            status: statusForRag(shareRag),
-            footer: 'Share of AI citations that reference your site across tracked keywords.'
-          })}
-          ${makePill({
-            rag: 'neutral',
-            value: `${externalDomains}`,
-            label: 'Top external domains',
-            status: 'Info',
-            footer: 'Domains most often cited alongside you in AI answers.'
-          })}
-          ${makePill({
-            rag: coverageRag,
-            value: `${keywordsWithSelfCitations}/${totalKeywords}`,
-            label: 'Keywords with your citations',
-            status: statusForRag(coverageRag),
-            footer: 'How often AI can already see your site as a source for your tracked queries.'
-          })}
-          ${makePill({
-            rag: shareRag,
-            value: `${selfShare.toFixed(1)}%`,
-            label: 'Your share of AI citations',
-            status: statusForRag(shareRag),
-            footer: 'Higher values mean AI relies more on your content instead of competitors or directories.'
-          })}
-        `;
-
-        tilesContainer.innerHTML = html;
-      }
-
-      /**
-       * Render source types breakdown
-       */
-      function renderAiSourcesTypesBreakdown(domainStats) {
-        const container = document.getElementById('ai-sources-types-breakdown');
-        if (!container) return;
-
-        // Group by source type
-        const typeGroups = {};
-        domainStats.forEach(stat => {
-          const type = stat.source_type;
-          if (!typeGroups[type]) {
-            typeGroups[type] = {
-              domains: 0,
-              citations: 0
-            };
-          }
-          typeGroups[type].domains += 1;
-          typeGroups[type].citations += stat.total_citations;
-        });
-
-        const totalCitations = domainStats.reduce((sum, d) => sum + d.total_citations, 0);
-
-        let html = '<ul style="list-style: none; padding: 0; margin: 0;">';
-        Object.entries(typeGroups).forEach(([type, data]) => {
-          const pct = totalCitations > 0 ? (data.citations / totalCitations) * 100 : 0;
-          html += `<li style="padding: 0.75rem 0; border-bottom: 1px solid #e5e7eb;">
-            <strong>${type}:</strong> ${data.domains} domains (${pct.toFixed(1)}% of citations)
-          </li>`;
-        });
-        html += '</ul>';
-
-        container.innerHTML = html;
-      }
-
-      /**
-       * Render domain influence table
-       */
-      async function renderAiSourcesTable(domainStats, filters = {}) {
-        const tableBody = document.getElementById('ai-sources-table-body');
-        if (!tableBody) return;
-
-        // Fetch domain metadata and domain strength for all domains (same as Ranking & AI module)
-        const allDomains = domainStats.map(stat => stat.domain);
-        const domainMetadata = await fetchDomainMetadataForDomains(allDomains);
-        const normalizedDomains = allDomains.map(normalizeDomainForStrength).filter(Boolean);
-        // Fetch domain strength for all domains (not just first 30)
-        // Note: fetchLatestDomainStrengthForDomains has a 30 domain limit, so we need to batch if needed
-        const domainStrength = await fetchLatestDomainStrengthForDomains(normalizedDomains);
-        
-        // If we have more than 30 domains, fetch in batches
-        if (normalizedDomains.length > 30) {
-          const batches = [];
-          for (let i = 0; i < normalizedDomains.length; i += 30) {
-            batches.push(normalizedDomains.slice(i, i + 30));
-          }
-          for (const batch of batches.slice(1)) {
-            const batchStrength = await fetchLatestDomainStrengthForDomains(batch);
-            Object.assign(domainStrength, batchStrength);
-          }
-        }
-
-        // Separate alanranger.com (self) from others
-        // Self domain is always shown regardless of filters (sticky first row)
-        const selfDomain = domainStats.find(stat => stat.is_self);
-        const otherDomains = domainStats.filter(stat => !stat.is_self);
-
-        // Apply filters to other domains (self domain always shown, filtered separately if needed)
-        let filtered = otherDomains.filter(stat => {
-          if (filters.type && filters.type !== 'all' && stat.source_type !== filters.type) {
-            return false;
-          }
-          if (filters.domainType && filters.domainType !== 'all') {
-            const normalizedDomain = normalizeDomainForStrength(stat.domain);
-            const meta = domainMetadata[normalizedDomain] || { domain_type: 'unmapped' };
-            const domainType = meta.domain_type && meta.domain_type !== 'unmapped' ? meta.domain_type : 'unmapped';
-            
-            if (filters.domainType === 'self' || filters.domainType === 'your_site') {
-              // Filter is 'self' or 'your_site', but this is a competitor domain, so exclude it
-              return false;
-            } else if (filters.domainType === 'competitor') {
-              // Filter is 'competitor', show all non-self domains (already filtered)
-              // No additional filtering needed
-            } else {
-              // Filter by specific domain_type value (e.g., 'site', 'platform', 'directory', 'unmapped', etc.)
-              if (domainType !== filters.domainType) {
-                return false;
-              }
-            }
-          }
-          if (filters.domain && !stat.domain.toLowerCase().includes(filters.domain.toLowerCase())) {
-            return false;
-          }
-          return true;
-        });
-
-        // Apply sorting (default: competitor - competitors first)
-        const sortColumn = window.aiSourcesSortState?.column || 'competitor';
-        const sortDirection = window.aiSourcesSortState?.direction || 'desc';
-        filtered.sort((a, b) => {
-          let aVal, bVal;
-          switch (sortColumn) {
-            case 'domain':
-              aVal = a.domain.toLowerCase();
-              bVal = b.domain.toLowerCase();
-              break;
-            case 'domain_type':
-              // Sort by domain_type string value from metadata (using mapped labels for consistent sorting)
-              const aNorm = normalizeDomainForStrength(a.domain);
-              const bNorm = normalizeDomainForStrength(b.domain);
-              const aMeta = domainMetadata[aNorm] || { domain_type: 'unmapped' };
-              const bMeta = domainMetadata[bNorm] || { domain_type: 'unmapped' };
-              // For self domains, use "your_site" if unmapped, otherwise use domain_type
-              if (a.is_self) {
-                const aDomainType = aMeta.domain_type && aMeta.domain_type !== 'unmapped' ? aMeta.domain_type : 'your_site';
-                aVal = getDomainTypeLabel(aDomainType);
-              } else {
-                const aDomainType = aMeta.domain_type && aMeta.domain_type !== 'unmapped' ? aMeta.domain_type : 'zzz_unmapped';
-                aVal = getDomainTypeLabel(aDomainType) || 'zzz_unmapped';
-              }
-              if (b.is_self) {
-                const bDomainType = bMeta.domain_type && bMeta.domain_type !== 'unmapped' ? bMeta.domain_type : 'your_site';
-                bVal = getDomainTypeLabel(bDomainType);
-              } else {
-                const bDomainType = bMeta.domain_type && bMeta.domain_type !== 'unmapped' ? bMeta.domain_type : 'zzz_unmapped';
-                bVal = getDomainTypeLabel(bDomainType) || 'zzz_unmapped';
-              }
-              break;
-            case 'competitor':
-              // Sort by competitor status (competitors first, then non-competitors)
-              const aNormComp = normalizeDomainForStrength(a.domain);
-              const bNormComp = normalizeDomainForStrength(b.domain);
-              const aMetaComp = domainMetadata[aNormComp] || { is_competitor: false };
-              const bMetaComp = domainMetadata[bNormComp] || { is_competitor: false };
-              aVal = aMetaComp.is_competitor ? 1 : 0;
-              bVal = bMetaComp.is_competitor ? 1 : 0;
-              break;
-            case 'rank':
-              // Sort by domain rank score
-              const aNormRank = normalizeDomainForStrength(a.domain);
-              const bNormRank = normalizeDomainForStrength(b.domain);
-              const aStrength = domainStrength[aNormRank] || { score: null };
-              const bStrength = domainStrength[bNormRank] || { score: null };
-              aVal = aStrength.score !== null ? aStrength.score : -1;
-              bVal = bStrength.score !== null ? bStrength.score : -1;
-              break;
-            case 'type':
-              aVal = a.source_type;
-              bVal = b.source_type;
-              break;
-            case 'citations':
-              aVal = a.total_citations;
-              bVal = b.total_citations;
-              break;
-            case 'keywords':
-              aVal = a.keyword_count;
-              bVal = b.keyword_count;
-              break;
-            case 'share':
-              aVal = a.share_of_citations;
-              bVal = b.share_of_citations;
-              break;
-            default:
-              return 0;
-          }
-          if (aVal < bVal) return sortDirection === 'asc' ? -1 : 1;
-          if (aVal > bVal) return sortDirection === 'asc' ? 1 : -1;
-          return 0;
-        });
-
-        if (filtered.length === 0 && !selfDomain) {
-          tableBody.innerHTML = '<tr><td colspan="8" class="ranking-table-empty">No domains match the current filters.</td></tr>';
-          return;
-        }
-
-        tableBody.innerHTML = '';
-        
-        // Always render self domain first with yellow highlight (regardless of filters, but respect domain search and domain type filter)
-        if (selfDomain) {
-          // Check if self domain should be shown based on filters
-          const normalizedDomain = normalizeDomainForStrength(selfDomain.domain);
-          const meta = domainMetadata[normalizedDomain] || { domain_type: 'unmapped', is_competitor: false };
-          const domainType = meta.domain_type && meta.domain_type !== 'unmapped' ? meta.domain_type : 'your_site';
-          
-          let showSelf = true;
-          if (filters.domain && !selfDomain.domain.toLowerCase().includes(filters.domain.toLowerCase())) {
-            showSelf = false;
-          }
-          if (filters.domainType && filters.domainType !== 'all') {
-            if (filters.domainType === 'self' || filters.domainType === 'your_site') {
-              // Show self domain
-              showSelf = showSelf && true;
-            } else if (filters.domainType === 'competitor') {
-              // Hide self domain when filtering for competitors
-              showSelf = false;
-            } else {
-              // Filter by specific domain_type value
-              showSelf = showSelf && (domainType === filters.domainType);
-            }
-          }
-          
-          if (showSelf) {
-            const strength = domainStrength[normalizedDomain] || null;
-            const selfRow = createDomainRow(selfDomain, true, meta, strength);
-            tableBody.appendChild(selfRow);
-          }
-        }
-        
-        // Render filtered other domains
-        filtered.forEach(stat => {
-          const normalizedDomain = normalizeDomainForStrength(stat.domain);
-          const meta = domainMetadata[normalizedDomain] || { domain_type: 'unmapped', is_competitor: false };
-          const strength = domainStrength[normalizedDomain] || null;
-          const row = createDomainRow(stat, false, meta, strength);
-          tableBody.appendChild(row);
-        });
-        
-        // Re-attach sort listeners after table is rendered
-        if (typeof window.attachAiSourcesSortListeners === 'function') {
-          setTimeout(() => {
-            window.attachAiSourcesSortListeners();
-          }, 50);
-        }
-      }
-
-      /**
-       * Map domain_type value to display label (same as Ranking & AI module)
-       */
-      function getDomainTypeLabel(domainType) {
-        const domainTypeMap = {
-          'unmapped': 'Unmapped',
-          'your_site': 'Your site',
-          'platform': 'Platform',
-          'directory': 'Directory',
-          'publisher': 'Publisher',
-          'vendor': 'Vendor',
-          'institution': 'Institution',
-          'government': 'Government',
-          'site': 'Site'
-        };
-        return domainTypeMap[domainType] || domainType || '';
-      }
-
-      /**
-       * Create a table row for a domain stat
-       */
-      function createDomainRow(stat, isSelf, meta, strength) {
-          const tr = document.createElement('tr');
-          tr.dataset.domain = stat.domain;
-        
-        // Make self domain row sticky and highlight in yellow (below header)
-        if (isSelf) {
-          tr.style.position = 'sticky';
-          tr.style.top = '40px'; // Below sticky header (approximate header height)
-          tr.style.zIndex = '15';
-          tr.style.backgroundColor = '#ffffcc';
-          tr.style.fontWeight = '600';
-        }
-          
-          // Domain
-          const tdDomain = document.createElement('td');
-          tdDomain.textContent = stat.domain;
-          if (stat.is_self) {
-            tdDomain.style.fontWeight = '700';
-            tdDomain.style.color = '#166534';
-          tdDomain.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
-          }
-          tr.appendChild(tdDomain);
-
-        // Domain type (use same categorization as Ranking & AI module)
-        const tdDomainType = document.createElement('td');
-        tdDomainType.style.padding = '0.5rem 0.4rem';
-        tdDomainType.style.fontSize = '0.8rem';
-        tdDomainType.style.wordWrap = 'break-word';
-        tdDomainType.style.overflowWrap = 'break-word';
-        if (stat.is_self) {
-          tdDomainType.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
-        }
-        
-        // Map domain_type value to display label (same as Ranking & AI)
-        // Always show domain_type for all rows
-        let displayType = '';
-        if (stat.is_self) {
-          // For self domain, show mapped label or "Your site" if unmapped
-          const domainType = meta.domain_type && meta.domain_type !== 'unmapped' ? meta.domain_type : 'your_site';
-          displayType = getDomainTypeLabel(domainType);
-        } else {
-          // For non-self domains, show mapped label if available, otherwise show "Unmapped"
-          if (meta.domain_type && meta.domain_type !== 'unmapped') {
-            displayType = getDomainTypeLabel(meta.domain_type);
-          } else {
-            // Show "Unmapped" so user knows domain exists but type not assigned yet
-            displayType = 'Unmapped';
-          }
-        }
-        tdDomainType.textContent = displayType;
-        tdDomainType.style.color = displayType ? '#475569' : '#94a3b8';
-        if (stat.is_self) {
-          tdDomainType.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
-        }
-        tr.appendChild(tdDomainType);
-
-        // Competitor column (separate from domain type)
-        const tdCompetitor = document.createElement('td');
-        tdCompetitor.style.padding = '0.5rem 0.4rem';
-        tdCompetitor.style.fontSize = '0.8rem';
-        tdCompetitor.style.textAlign = 'center';
-        if (stat.is_self) {
-          tdCompetitor.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
-        }
-        
-        // Show competitor badge if is_competitor is true (same as Ranking & AI module)
-        if (meta.is_competitor) {
-          const badge = document.createElement('span');
-          badge.textContent = 'Competitor';
-          badge.setAttribute('data-competitor-badge', 'true');
-          badge.style.display = 'inline-block';
-          badge.style.padding = '0.125rem 0.5rem';
-          badge.style.fontSize = '0.65rem';
-          badge.style.fontWeight = '600';
-          badge.style.color = '#dc2626';
-          badge.style.backgroundColor = '#fee2e2';
-          badge.style.borderRadius = '4px';
-          badge.style.border = '1px solid #fecaca';
-          tdCompetitor.appendChild(badge);
-        } else {
-          tdCompetitor.textContent = '‚Äî';
-          tdCompetitor.style.color = '#94a3b8';
-        }
-        tr.appendChild(tdCompetitor);
-
-        // Domain Rank
-        const tdRank = document.createElement('td');
-        tdRank.style.textAlign = 'right';
-        tdRank.style.padding = '0.5rem 0.4rem';
-        tdRank.style.fontSize = '0.8rem';
-        if (stat.is_self) {
-          tdRank.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
-        }
-        tdRank.innerHTML = renderDomainRankCellHtml(strength);
-        tr.appendChild(tdRank);
-
-          // Citations
-          const tdCitations = document.createElement('td');
-          tdCitations.textContent = stat.total_citations;
-        if (stat.is_self) {
-          tdCitations.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
-        }
-          tr.appendChild(tdCitations);
-
-          // Keywords
-          const tdKeywords = document.createElement('td');
-          tdKeywords.textContent = stat.keyword_count;
-        if (stat.is_self) {
-          tdKeywords.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
-        }
-          tr.appendChild(tdKeywords);
-
-          // Citation share
-          const tdShare = document.createElement('td');
-          tdShare.textContent = `${stat.share_of_citations.toFixed(1)}%`;
-        if (stat.is_self) {
-          tdShare.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
-        }
-          tr.appendChild(tdShare);
-
-          // Example page
-          const tdExample = document.createElement('td');
-        if (stat.is_self) {
-          tdExample.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
-        }
-          if (stat.example_urls && stat.example_urls.length > 0) {
-            const a = document.createElement('a');
-            a.href = stat.example_urls[0];
-            a.target = '_blank';
-            a.rel = 'noopener noreferrer';
-            a.textContent = stat.is_self ? new URL(stat.example_urls[0]).pathname : stat.example_urls[0];
-            a.style.color = '#0284c7';
-            a.style.textDecoration = 'none';
-            tdExample.appendChild(a);
-          } else {
-            tdExample.textContent = '‚Äî';
-          }
-          tr.appendChild(tdExample);
-
-          // Click handler
-          tr.style.cursor = 'pointer';
-          tr.addEventListener('click', () => {
-            document.querySelectorAll('#ai-sources-table-body tr').forEach(r => r.classList.remove('ranking-table-row--selected'));
-            tr.classList.add('ranking-table-row--selected');
-            renderAiSourcesDetail(stat);
-          });
-
-        return tr;
-      }
-
-      /**
-       * Render domain detail panel
-       */
-      function renderAiSourcesDetail(stat) {
-        const panel = document.getElementById('ai-sources-detail-panel');
-        const domainEl = document.getElementById('ai-sources-detail-domain');
-        const metaEl = document.getElementById('ai-sources-detail-meta');
-        const contentEl = document.getElementById('ai-sources-detail-content');
-
-        if (!panel || !domainEl || !metaEl || !contentEl) return;
-
-        panel.style.display = 'block';
-        domainEl.textContent = stat.domain;
-        metaEl.textContent = `Cited in ${stat.total_citations} AI answer${stat.total_citations !== 1 ? 's' : ''} across ${stat.keyword_count} tracked keyword${stat.keyword_count !== 1 ? 's' : ''} (${stat.share_of_citations.toFixed(1)}% of all citations).`;
-
-        let html = '';
-
-        // Why this domain matters
-        html += '<div class="scorecard-section">';
-        html += '<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">Why this domain matters</h5>';
-        
-        if (stat.is_self) {
-          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This is your own site. AI is using your content in ' + stat.total_citations + ' answer' + (stat.total_citations !== 1 ? 's' : '') + ' across ' + stat.keyword_count + ' keyword' + (stat.keyword_count !== 1 ? 's' : '') + '. Increasing citations here usually comes from stronger schema, internal linking and coverage on key topics.</p>';
-        } else if (stat.source_type === 'Directory') {
-          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This is a directory / listing site. Repeated citations suggest AI trusts this listing as a key reference in your niche. Ensure your profile, NAP details and reviews are complete and consistent.</p>';
-        } else if (stat.source_type === 'Review platform') {
-          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This is a review platform. AI often surfaces businesses with strong, consistent reviews from here. Make sure your profile is claimed, reviews are encouraged, and descriptions match your positioning.</p>';
-        } else if (stat.source_type === 'Course marketplace / education') {
-          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This is an education or course marketplace. AI is seeing it as an alternative source for photography learning. Consider whether partnering, listing, or differentiating your on-site course pages against this platform makes sense.</p>';
-        } else if (stat.source_type === 'Publisher / blog') {
-          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This is a content publisher. Repeated citations suggest AI trusts their articles for informational queries. Collaborations, guest posts, or references from this domain can help strengthen your topical authority.</p>';
-        } else {
-          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This domain is frequently cited, but doesn\'t fall into a specific category. Review its content and decide if it\'s a directory, partner, competitor or something to monitor.</p>';
-        }
-        html += '</div>';
-
-        // Keywords where this domain appears
-        html += '<div class="scorecard-section">';
-        html += '<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">Keywords where this domain appears</h5>';
-        html += '<ul style="font-size: 0.875rem; color: #1e293b; line-height: 1.8; padding-left: 1.5rem;">';
-        const keywordsToShow = stat.keywords.slice(0, 10);
-        keywordsToShow.forEach(keyword => {
-          html += `<li>${keyword}</li>`;
-        });
-        if (stat.keywords.length > 10) {
-          html += `<li style="color: #64748b; font-style: italic;">... and ${stat.keywords.length - 10} more</li>`;
-        }
-        html += '</ul></div>';
-
-        // Suggested next steps
-        html += '<div class="scorecard-section">';
-        html += '<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">Suggested next steps</h5>';
-        html += '<ul style="font-size: 0.875rem; color: #1e293b; line-height: 1.8; padding-left: 1.5rem;">';
-        
-        if (stat.is_self) {
-          const selfShare = stat.share_of_citations;
-          if (selfShare < 30) {
-            html += '<li>Strengthen schema and content coverage on high-demand keywords where you\'re not cited yet.</li>';
-            html += '<li>Revisit internal linking from money pages to these informational topics to raise their prominence.</li>';
-          }
-        } else if (stat.source_type === 'Directory' || stat.source_type === 'Review platform') {
-          html += '<li>Audit your listing/profile on this domain (NAP details, description, categories).</li>';
-          html += '<li>Encourage satisfied students/clients to leave reviews here to reinforce Authority.</li>';
-        } else if (stat.source_type === 'Course marketplace / education') {
-          html += '<li>Review how your offerings compare to what\'s listed here. Decide whether to list on this platform or create on-site content addressing the same needs.</li>';
-        } else if (stat.source_type === 'Publisher / blog') {
-          html += '<li>Identify relevant articles and consider outreach for mentions, interviews or guest content pointing back to your key pages.</li>';
-        }
-        
-        html += '</ul></div>';
-
-        contentEl.innerHTML = html;
-      }
-
-      // Edit Keywords functionality
-      (function() {
-        // Wait for DOM to be ready
-        function initEditKeywords() {
-          const modal = document.getElementById('edit-keywords-modal');
-          const openBtn = document.getElementById('edit-keywords-btn');
-          const closeBtn = document.getElementById('edit-keywords-close');
-          const cancelBtn = document.getElementById('edit-keywords-cancel');
-          const saveBtn = document.getElementById('edit-keywords-save');
-          const textarea = document.getElementById('edit-keywords-textarea');
-          const statusEl = document.getElementById('edit-keywords-status');
-
-          if (!modal || !openBtn) {
-            // Elements not found yet, try again later
-            setTimeout(initEditKeywords, 100);
-            return;
-          }
-
-          // Ensure modal is hidden initially - use !important to override any other styles
-          modal.style.setProperty('display', 'none', 'important');
-          
-          // Force close on any click outside or escape - emergency close
-          const forceClose = () => {
-            modal.style.setProperty('display', 'none', 'important');
-          };
-          
-          // Make forceClose available globally for emergency
-          window.forceCloseEditKeywordsModal = forceClose;
-
-          function showModal() {
-            if (typeof debugLog === 'function') debugLog('[Edit Keywords] showModal() called', 'info');
-            if (modal) {
-              if (typeof debugLog === 'function') debugLog('[Edit Keywords] Modal found, showing...', 'info');
-              modal.style.setProperty('display', 'flex', 'important');
-              if (typeof debugLog === 'function') debugLog('[Edit Keywords] Calling loadKeywords()...', 'info');
-              loadKeywords();
-            } else {
-              if (typeof debugLog === 'function') debugLog('[Edit Keywords] Modal element not found!', 'error');
-            }
-          }
-
-          function hideModal() {
-            if (modal) {
-              modal.style.display = 'none';
-              modal.style.setProperty('display', 'none', 'important');
-              if (statusEl) statusEl.textContent = '';
-              if (textarea) {
-                textarea.value = '';
-                textarea.disabled = false;
-              }
-            }
-          }
-
-          async function loadKeywords() {
-            if (typeof debugLog === 'function') debugLog('[Edit Keywords] loadKeywords() called', 'info');
-            if (!textarea) {
-              if (typeof debugLog === 'function') debugLog('[Edit Keywords] Textarea not found', 'error');
-              if (statusEl) {
-                statusEl.textContent = 'ERROR: Textarea element not found';
-                statusEl.style.color = '#dc2626';
-                statusEl.style.fontWeight = 'bold';
-              }
-              return;
-            }
-            
-            if (typeof debugLog === 'function') debugLog('[Edit Keywords] Setting loading state...', 'info');
-            textarea.value = 'Loading keywords...';
-            textarea.disabled = true;
-            textarea.style.color = '#1e293b';
-            textarea.style.backgroundColor = '#ffffff';
-            if (statusEl) {
-              statusEl.textContent = 'Loading keywords from server...';
-              statusEl.style.color = '#64748b';
-              statusEl.style.fontWeight = 'normal';
-            }
-            
-            try {
-              // First try to get from localStorage as fallback
-              let keywordsFromStorage = [];
-              try {
-                const storedData = localStorage.getItem('rankingAiData');
-                if (storedData) {
-                  const parsed = JSON.parse(storedData);
-                  if (parsed.combinedRows && Array.isArray(parsed.combinedRows)) {
-                    keywordsFromStorage = [...new Set(parsed.combinedRows.map(r => r?.keyword).filter(Boolean))].sort();
-                    if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Found ${keywordsFromStorage.length} keywords in localStorage`, 'info');
-                  }
-                }
-              } catch (e) {
-                if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Could not read from localStorage: ${e.message}`, 'warn');
-              }
-              
-              const apiEndpoint = apiUrl('/api/keywords/get');
-              if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Fetching from: ${apiEndpoint}`, 'info');
-              
-              const resp = await fetch(apiEndpoint);
-              if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Response status: ${resp.status} ${resp.statusText}`, 'info');
-              
-              if (!resp.ok) {
-                const errorText = await resp.text();
-                if (typeof debugLog === 'function') debugLog(`[Edit Keywords] API error response: ${errorText}`, 'error');
-                // Fallback to localStorage if API fails
-                if (keywordsFromStorage.length > 0) {
-                  if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Using localStorage fallback due to API error`, 'warn');
-                  textarea.value = keywordsFromStorage.join('\n');
-                  textarea.disabled = false;
-                  textarea.style.color = '#1e293b';
-                  textarea.style.backgroundColor = '#ffffff';
-                  if (statusEl) {
-                    statusEl.textContent = `‚ö† Loaded ${keywordsFromStorage.length} keywords from cache (API error: ${resp.status})`;
-                    statusEl.style.color = '#f59e0b';
-                    statusEl.style.fontWeight = '600';
-                  }
-                  return;
-                }
-                throw new Error(`HTTP ${resp.status}: ${errorText.substring(0, 100)}`);
-              }
-              
-              const data = await resp.json();
-              if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Response: status=${data.status}, keywords count=${data.keywords?.length || 0}, reason=${data.meta?.reason || 'none'}`, 'info');
-              
-              if (data.status === 'ok' && Array.isArray(data.keywords)) {
-                if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Found ${data.keywords.length} keywords from API`, 'info');
-                if (data.keywords.length > 0) {
-                  const keywordsText = data.keywords.join('\n');
-                  if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Setting textarea value, length: ${keywordsText.length}`, 'info');
-                  textarea.value = keywordsText;
-                  textarea.disabled = false;
-                  textarea.style.color = '#1e293b';
-                  textarea.style.backgroundColor = '#ffffff';
-                  textarea.focus();
-                  if (statusEl) {
-                    statusEl.textContent = `‚úì Loaded ${data.keywords.length} keywords`;
-                    statusEl.style.color = '#10b981';
-                    statusEl.style.fontWeight = '600';
-                  }
-                  if (typeof debugLog === 'function') debugLog('[Edit Keywords] Keywords loaded successfully', 'success');
-                } else {
-                  if (typeof debugLog === 'function') debugLog('[Edit Keywords] No keywords found in API response', 'warn');
-                  // Try localStorage fallback
-                  if (keywordsFromStorage.length > 0) {
-                    if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Using localStorage fallback (${keywordsFromStorage.length} keywords)`, 'warn');
-                    textarea.value = keywordsFromStorage.join('\n');
-                    textarea.disabled = false;
-                    textarea.style.color = '#1e293b';
-                    textarea.style.backgroundColor = '#ffffff';
-                    if (statusEl) {
-                      statusEl.textContent = `‚ö† Loaded ${keywordsFromStorage.length} keywords from cache (not found in latest audit)`;
-                      statusEl.style.color = '#f59e0b';
-                      statusEl.style.fontWeight = '600';
-                    }
-                  } else {
-                    textarea.value = '';
-                    textarea.disabled = false;
-                    textarea.style.color = '#1e293b';
-                    textarea.style.backgroundColor = '#ffffff';
-                    if (statusEl) {
-                      statusEl.textContent = '‚ö† No keywords found. You can add keywords below (one per line).';
-                      statusEl.style.color = '#f59e0b';
-                      statusEl.style.fontWeight = '600';
-                    }
-                  }
-                }
-              } else {
-                if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Invalid response format. Status: ${data.status}, Keywords type: ${typeof data.keywords}, Is array: ${Array.isArray(data.keywords)}`, 'error');
-                textarea.value = '';
-                textarea.disabled = false;
-                textarea.style.color = '#1e293b';
-                textarea.style.backgroundColor = '#ffffff';
-                if (statusEl) {
-                  statusEl.textContent = '‚ùå Invalid response format from server. Check debug log for details.';
-                  statusEl.style.color = '#dc2626';
-                  statusEl.style.fontWeight = 'bold';
-                }
-              }
-            } catch (err) {
-              if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Exception: ${err.message}`, 'error');
-              textarea.value = '';
-              textarea.disabled = false;
-              textarea.style.color = '#1e293b';
-              textarea.style.backgroundColor = '#ffffff';
-              if (statusEl) {
-                statusEl.textContent = '‚ùå Error loading keywords: ' + err.message + ' (Check debug log for details)';
-                statusEl.style.color = '#dc2626';
-                statusEl.style.fontWeight = 'bold';
-                statusEl.style.fontSize = '0.9rem';
-              }
-            }
-          }
-
-          async function saveKeywords() {
-            if (!textarea || !saveBtn) return;
-            
-            const keywordsText = textarea.value.trim();
-            const keywords = keywordsText.split('\n')
-              .map(k => k.trim())
-              .filter(k => k.length > 0);
-            
-            if (keywords.length === 0) {
-              if (statusEl) {
-                statusEl.textContent = 'Please enter at least one keyword.';
-                statusEl.style.color = '#dc2626';
-              }
-              return;
-            }
-
-            saveBtn.disabled = true;
-            saveBtn.textContent = 'Saving...';
-            if (statusEl) {
-              statusEl.textContent = 'Saving keywords...';
-              statusEl.style.color = '#64748b';
-            }
-
-            try {
-              const resp = await fetch(apiUrl('/api/keywords/save'), {
-                method: 'POST',
-                headers: { 'Content-Type': 'application/json' },
-                body: JSON.stringify({ keywords })
-              });
-
-              // Check if response is JSON before parsing
-              const contentType = resp.headers.get('content-type');
-              let data;
-              
-              if (contentType && contentType.includes('application/json')) {
-                data = await resp.json();
-              } else {
-                // Non-JSON response (likely an error page or plain text)
-                const errorText = await resp.text();
-                throw new Error(`Server returned non-JSON response (${resp.status}): ${errorText.substring(0, 200)}`);
-              }
-              
-              if (resp.ok && data.status === 'ok') {
-                if (statusEl) {
-                  statusEl.textContent = `‚úì Successfully saved ${data.count || keywords.length} keywords. Keywords will be updated on the next Ranking & AI check.`;
-                  statusEl.style.color = '#10b981';
-                }
-                
-                // Close modal after showing success message (don't trigger a new scan)
-                setTimeout(() => {
-                  hideModal();
-                }, 2000);
-              } else {
-                throw new Error(data.message || data.details || 'Failed to save keywords');
-              }
-            } catch (err) {
-              console.error('[Edit Keywords] Save error:', err);
-              if (statusEl) {
-                statusEl.textContent = 'Error saving keywords: ' + err.message;
-                statusEl.style.color = '#dc2626';
-              }
-              saveBtn.disabled = false;
-              saveBtn.textContent = 'Save Keywords';
-            }
-          }
-
-          // CSV upload handler
-          const csvUpload = document.getElementById('csv-upload');
-          if (csvUpload) {
-            csvUpload.addEventListener('change', async (e) => {
-              const file = e.target.files[0];
-              if (!file) return;
-
-              try {
-                const text = await file.text();
-                // Parse CSV and populate textarea
-                const lines = text.split('\n');
-                const keywords = [];
-                for (const line of lines) {
-                  const trimmed = line.trim();
-                  if (!trimmed || trimmed.startsWith('#')) continue;
-                  const firstColumn = trimmed.includes(',') ? trimmed.split(',')[0].trim() : trimmed;
-                  if (firstColumn) keywords.push(firstColumn);
-                }
-
-                if (keywords.length === 0) {
-                  if (statusEl) {
-                    statusEl.textContent = 'No keywords found in CSV file';
-                    statusEl.style.color = '#dc2626';
-                  }
-                  return;
-                }
-
-                textarea.value = keywords.join('\n');
-                if (statusEl) {
-                  statusEl.textContent = `‚úì Loaded ${keywords.length} keywords from CSV`;
-                  statusEl.style.color = '#10b981';
-                }
-
-                // Reset file input
-                e.target.value = '';
-              } catch (err) {
-                console.error('[Edit Keywords] CSV upload error:', err);
-                if (statusEl) {
-                  statusEl.textContent = 'Error reading CSV file: ' + err.message;
-                  statusEl.style.color = '#dc2626';
-                }
-              }
-            });
-          }
-
-          // Only attach event listeners - modal should NOT open automatically
-          openBtn.addEventListener('click', (e) => {
-            e.preventDefault();
-            e.stopPropagation();
-            showModal();
-          });
-          
-          // Close buttons - make sure they work
-          if (closeBtn) {
-            closeBtn.addEventListener('click', (e) => {
-              e.preventDefault();
-              e.stopPropagation();
-              hideModal();
-            });
-          }
-          
-          if (cancelBtn) {
-            cancelBtn.addEventListener('click', (e) => {
-              e.preventDefault();
-              e.stopPropagation();
-              hideModal();
-            });
-          }
-          
-          if (saveBtn) {
-            saveBtn.addEventListener('click', saveKeywords);
-          }
-          
-          // Close modal when clicking outside
-          modal.addEventListener('click', (e) => {
-            if (e.target === modal) {
-              e.preventDefault();
-              e.stopPropagation();
-              hideModal();
-            }
-          });
-
-          // Close modal with Escape key - make it work globally
-          const escapeHandler = (e) => {
-            if (e.key === 'Escape' && modal) {
-              const currentDisplay = window.getComputedStyle(modal).display;
-              if (currentDisplay === 'flex' || currentDisplay === 'block') {
-                e.preventDefault();
-                e.stopPropagation();
-                hideModal();
-              }
-            }
-          };
-          document.addEventListener('keydown', escapeHandler);
-          
-          // Also add a global function to force close
-          window.closeEditKeywordsModal = hideModal;
-        }
-
-        // Initialize when DOM is ready
-        if (document.readyState === 'loading') {
-          document.addEventListener('DOMContentLoaded', initEditKeywords);
-        } else {
-          initEditKeywords();
-        }
-      })();
-
-      // Initialize AI Sources sort state (default: sort by competitor - competitors first)
-      if (!window.aiSourcesSortState) {
-        window.aiSourcesSortState = { column: 'competitor', direction: 'desc' };
-      }
-
-      // Wire up AI Sources tab filters and sorting
-      function wireAiSourcesFilters() {
-        const typeFilter = document.getElementById('ai-sources-filter-type');
-        const domainTypeFilter = document.getElementById('ai-sources-filter-domain-type');
-        const domainFilter = document.getElementById('ai-sources-filter-domain');
-        const clearBtn = document.getElementById('ai-sources-filter-clear');
-
-        const updateFilters = async () => {
-          const filters = {
-            type: typeFilter ? typeFilter.value : 'all',
-            domainType: domainTypeFilter ? domainTypeFilter.value : 'all',
-            domain: domainFilter ? domainFilter.value.trim() : ''
-          };
-          if (window.aiSourcesDomainStats) {
-            await renderAiSourcesTable(window.aiSourcesDomainStats, filters).catch(err => {
-              console.error('Error rendering AI sources table:', err);
-            });
-          }
-        };
-
-        if (typeFilter) typeFilter.addEventListener('change', updateFilters);
-        if (domainTypeFilter) domainTypeFilter.addEventListener('change', updateFilters);
-        if (domainFilter) domainFilter.addEventListener('input', updateFilters);
-        if (clearBtn) {
-          clearBtn.addEventListener('click', () => {
-            if (typeFilter) typeFilter.value = 'all';
-            if (domainTypeFilter) domainTypeFilter.value = 'all';
-            if (domainFilter) domainFilter.value = '';
-            updateFilters();
-          });
-        }
-
-        // Wire up table sorting - attach listeners after table is rendered
-        window.attachAiSourcesSortListeners = function attachSortListeners() {
-          const table = document.getElementById('ai-sources-table');
-          if (!table) return;
-          
-          // Remove any existing listeners by removing and re-adding the event listener
-          // Use a single delegated listener on the table
-          const handleSortClick = (e) => {
-            const th = e.target.closest('th.sortable');
-            if (!th) return;
-            
-            e.preventDefault();
-            e.stopPropagation();
-            
-            const column = th.dataset.sort;
-            if (!column) return;
-
-            if (window.aiSourcesSortState.column === column) {
-              window.aiSourcesSortState.direction = window.aiSourcesSortState.direction === 'asc' ? 'desc' : 'asc';
-            } else {
-              window.aiSourcesSortState.column = column;
-              window.aiSourcesSortState.direction = 'desc';
-            }
-
-            // Update sort indicators
-            const allHeaders = table.querySelectorAll('th.sortable');
-            allHeaders.forEach(h => {
-              h.classList.remove('sort-asc', 'sort-desc');
-              if (h.dataset.sort === window.aiSourcesSortState.column) {
-                h.classList.add(`sort-${window.aiSourcesSortState.direction}`);
-              }
-            });
-
-            // Re-render table with new sort
-            const filters = {
-              type: typeFilter ? typeFilter.value : 'all',
-              domainType: domainTypeFilter ? domainTypeFilter.value : 'all',
-              domain: domainFilter ? domainFilter.value.trim() : ''
-            };
-            if (window.aiSourcesDomainStats) {
-              renderAiSourcesTable(window.aiSourcesDomainStats, filters).then(() => {
-                // Re-attach listeners after re-render
-                if (typeof window.attachAiSourcesSortListeners === 'function') {
-                  window.attachAiSourcesSortListeners();
-                }
-              }).catch(err => {
-                console.error('Error rendering AI sources table:', err);
-              });
-            }
-          };
-          
-          // Remove old listener if it exists
-          if (table._sortHandler) {
-            table.removeEventListener('click', table._sortHandler);
-          }
-          table._sortHandler = handleSortClick;
-          table.addEventListener('click', handleSortClick, true); // Use capture phase to catch events early
-          
-          // Set initial sort indicator on headers and add cursor style
-          const sortableHeaders = table.querySelectorAll('th.sortable');
-          sortableHeaders.forEach(h => {
-            h.style.cursor = 'pointer';
-            h.classList.remove('sort-asc', 'sort-desc');
-            if (h.dataset.sort === window.aiSourcesSortState.column) {
-              h.classList.add(`sort-${window.aiSourcesSortState.direction}`);
-            }
-          });
-        }
-        
-        // Attach sort listeners initially
-        window.attachAiSourcesSortListeners();
-      }
-
-      // Make functions globally available
-      window.renderAiSourcesTab = renderAiSourcesTab;
-      window.wireAiSourcesFilters = wireAiSourcesFilters;
-  </script>
-
-  <!-- Optimisation Tracking Modals (Phase 2) -->
-  <!-- Track Keyword Modal -->
-  <div id="optimisation-track-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
-    <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 1000px; width: 90%; max-height: 90vh; overflow-y: auto;">
-      <h3 style="margin: 0 0 1.5rem 0; font-size: 1.25rem; color: #1e293b;">Track Keyword</h3>
-      
-      <div style="margin-bottom: 1rem;">
-        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Keyword:</label>
-        <div id="track-keyword-text" style="padding: 0.5rem; background: #f8fafc; border-radius: 4px; color: #0284c7; font-weight: 600; font-size: 1rem;"></div>
-      </div>
-      
-      <div style="margin-bottom: 1rem;">
-        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Target URL:</label>
-        <div id="track-url-text" style="padding: 0.5rem; background: #f8fafc; border-radius: 4px; color: #0284c7; font-weight: 600; word-break: break-all; font-size: 0.95rem;"></div>
-      </div>
-      
-      <div style="margin-bottom: 1rem;">
-        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Task type:</label>
-        <select id="track-task-type" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px;">
-          <option value="on_page">On-page</option>
-          <option value="content">Content</option>
-          <option value="internal_links">Internal links</option>
-          <option value="links_pr">Links/PR</option>
-          <option value="technical">Technical</option>
-          <option value="local">Local</option>
-          <option value="other">Other</option>
-        </select>
-      </div>
-      
-      <div style="margin-bottom: 1rem;">
-        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Status: <span title="Status meanings:&#10;‚Ä¢ Planned: Task created but work not started&#10;‚Ä¢ In Progress: Currently being worked on&#10;‚Ä¢ Monitoring: Changes deployed‚Äîmonitor metrics" style="opacity: 0.6; cursor: help; font-size: 0.85rem;">‚Ñπ</span></label>
-        <select id="track-status" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px;">
-          <option value="planned" title="Task created but work not started">Planned</option>
-          <option value="in_progress" title="Currently being worked on">In progress</option>
-          <option value="monitoring" title="Changes deployed‚Äîmonitor metrics">Monitoring</option>
-        </select>
-      </div>
-      
-      <div style="margin-bottom: 1rem;">
-        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Title (optional):</label>
-        <input type="text" id="track-title" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px;" placeholder="e.g. Rewrite title/H1 + FAQ schema">
-      </div>
-      
-      <div style="margin-bottom: 1.5rem;">
-        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Notes (optional):</label>
-        <textarea id="track-notes" rows="3" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-family: inherit;" placeholder="Additional notes..."></textarea>
-      </div>
-
-      <!-- Objective Section (Cycle 1) -->
-      <div style="margin-bottom: 1.5rem; padding: 1rem; background: #f8fafc; border-radius: 4px; border: 1px solid #e2e8f0;">
-        <h4 style="margin: 0 0 1rem 0; font-size: 1rem; color: #1e293b; font-weight: 600;">Objective (Cycle 1)</h4>
-        
-        <div style="margin-bottom: 0.75rem;">
-          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Objective Title:</label>
-          <input type="text" id="track-objective-title" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. Improve CTR by 20%">
-        </div>
-
-        <div style="margin-bottom: 0.75rem;">
-          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Primary KPI:</label>
-          <select id="track-primary-kpi" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
-            <option value="">Select KPI...</option>
-            <option value="ctr_28d">CTR (28d)</option>
-            <option value="rank">Rank</option>
-            <option value="clicks">Clicks</option>
-            <option value="impressions">Impressions</option>
-            <option value="ai_citations">AI Citations</option>
-          </select>
-        </div>
-
-        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
-          <div>
-            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Direction:</label>
-            <select id="track-target-direction" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
-              <option value="">Select...</option>
-              <option value="increase">Increase</option>
-              <option value="decrease">Decrease</option>
-              <option value="at_least">At least</option>
-              <option value="at_most">At most</option>
-            </select>
-          </div>
-          <div>
-            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Value:</label>
-            <input type="number" id="track-target-value" step="0.01" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. 20">
-          </div>
-        </div>
-
-        <div style="margin-bottom: 0.75rem;">
-          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Timeframe (days):</label>
-          <select id="track-timeframe-days" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
-            <option value="">Select timeframe...</option>
-            <option value="30">30 days</option>
-            <option value="60">60 days</option>
-            <option value="90">90 days</option>
-          </select>
-        </div>
-
-        <div style="margin-bottom: 0.75rem;">
-          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Plan / Hypothesis (optional):</label>
-          <textarea id="track-plan" rows="2" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-family: inherit; font-size: 0.875rem;" placeholder="Describe your plan or hypothesis..."></textarea>
-        </div>
-      </div>
-      
-      <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
-        <button type="button" onclick="document.getElementById('optimisation-track-modal').style.display='none'" style="padding: 0.5rem 1rem; border: 1px solid #cbd5e1; border-radius: 4px; background: white; cursor: pointer;">Cancel</button>
-        <button type="button" onclick="window.submitTrackKeyword()" style="padding: 0.5rem 1rem; border: none; border-radius: 4px; background: #2563eb; color: white; cursor: pointer; font-weight: 500;">Create</button>
-      </div>
-    </div>
-  </div>
-
-  <!-- Manage Optimisation Modal -->
-  <div id="optimisation-manage-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
-    <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto;">
-      <h3 style="margin: 0 0 1.5rem 0; font-size: 1.25rem; color: #1e293b;">Manage Optimisation</h3>
-      
-      <div style="margin-bottom: 1rem; padding: 1rem; background: #f8fafc; border-radius: 4px;">
-        <div style="margin-bottom: 0.75rem;">
-          <strong style="color: #475569;">Keyword:</strong>
-          <div id="manage-keyword-text" style="padding: 0.5rem; background: #f8fafc; border-radius: 4px; color: #0284c7; font-weight: 600; font-size: 1rem; margin-top: 0.25rem;"></div>
-        </div>
-        <div style="margin-bottom: 0.75rem;">
-          <strong style="color: #475569;">Target URL:</strong>
-          <div id="manage-url-text" style="padding: 0.5rem; background: #f8fafc; border-radius: 4px; margin-top: 0.25rem; word-break: break-all;"></div>
-        </div>
-        <div style="margin-bottom: 0.75rem;">
-          <strong style="color: #475569;">Task type:</strong>
-          <div id="manage-task-type-text" style="color: #1e293b; margin-top: 0.25rem;"></div>
-        </div>
-        <div style="margin-bottom: 0.75rem;">
-          <strong style="color: #475569;">Current status:</strong>
-          <div id="manage-status-text" style="color: #1e293b; margin-top: 0.25rem;"></div>
-        </div>
-        <div style="margin-bottom: 0.75rem;">
-          <strong style="color: #475569;">Cycle:</strong>
-          <div id="manage-cycle-text" style="color: #1e293b; margin-top: 0.25rem;"></div>
-        </div>
-        <div>
-          <strong style="color: #475569;">Last activity:</strong>
-          <div id="manage-last-activity-text" style="color: #1e293b; margin-top: 0.25rem;"></div>
-        </div>
-      </div>
-      
-      <div style="margin-bottom: 1.5rem;">
-        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Change status:</label>
-        <select id="manage-status-select" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px;">
-          <option value="planned">Planned</option>
-          <option value="in_progress">In progress</option>
-          <option value="monitoring">Monitoring</option>
-          <option value="done">Done</option>
-          <option value="paused">Paused</option>
-          <option value="cancelled">Cancelled</option>
-        </select>
-      </div>
-      
-      <div style="display: flex; flex-direction: column; gap: 0.75rem; margin-bottom: 1.5rem;">
-        <button type="button" onclick="window.submitStatusChange()" style="padding: 0.5rem 1rem; border: none; border-radius: 4px; background: #2563eb; color: white; cursor: pointer; font-weight: 500;">Save Status Change</button>
-        <button type="button" onclick="window.startNewCycle()" style="padding: 0.5rem 1rem; border: 1px solid #2563eb; border-radius: 4px; background: white; color: #2563eb; cursor: pointer; font-weight: 500;">Start New Cycle</button>
-        <button type="button" onclick="window.stopTracking()" style="padding: 0.5rem 1rem; border: 1px solid #ef4444; border-radius: 4px; background: white; color: #ef4444; cursor: pointer; font-weight: 500;">Stop Tracking</button>
-      </div>
-      
-      <div style="display: flex; justify-content: flex-end;">
-        <button type="button" onclick="document.getElementById('optimisation-manage-modal').style.display='none'" style="padding: 0.5rem 1rem; border: 1px solid #cbd5e1; border-radius: 4px; background: white; cursor: pointer;">Close</button>
-      </div>
-    </div>
-  </div>
-
-  <!-- New Cycle Modal -->
-  <div id="optimisation-new-cycle-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10001; align-items: center; justify-content: center;">
-    <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto;">
-      <h3 style="margin: 0 0 1.5rem 0; font-size: 1.25rem; color: #1e293b;">Start New Cycle: <span id="new-cycle-cycle-no">Cycle 2</span></h3>
-      
-      <div style="margin-bottom: 1rem; padding: 0.75rem; background: #f0f9ff; border-radius: 4px; border: 1px solid #bae6fd;">
-        <div style="font-size: 0.875rem; color: #0369a1;">
-          <strong>Tip:</strong> The form is pre-filled with the previous cycle's objective. You can modify it for this new cycle.
-        </div>
-      </div>
-
-      <div style="margin-bottom: 0.75rem;">
-        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Objective Title:</label>
-        <input type="text" id="new-cycle-objective-title" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. Improve CTR by 20%">
-      </div>
-
-      <div style="margin-bottom: 0.75rem;">
-        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Primary KPI:</label>
-        <select id="new-cycle-primary-kpi" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
-          <option value="">Select KPI...</option>
-          <option value="ctr_28d">CTR (28d)</option>
-          <option value="rank">Rank</option>
-          <option value="clicks">Clicks</option>
-          <option value="impressions">Impressions</option>
-          <option value="ai_citations">AI Citations</option>
-        </select>
-      </div>
-
-      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
-        <div>
-          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Direction:</label>
-          <select id="new-cycle-target-direction" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
-            <option value="">Select...</option>
-            <option value="increase">Increase</option>
-            <option value="decrease">Decrease</option>
-            <option value="at_least">At least</option>
-            <option value="at_most">At most</option>
-          </select>
-        </div>
-        <div>
-          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Value:</label>
-          <input type="number" id="new-cycle-target-value" step="0.01" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. 20">
-        </div>
-      </div>
-
-      <div style="margin-bottom: 0.75rem;">
-        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Timeframe (days):</label>
-        <select id="new-cycle-timeframe-days" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
-          <option value="">Select timeframe...</option>
-          <option value="30">30 days</option>
-          <option value="60">60 days</option>
-          <option value="90">90 days</option>
-        </select>
-      </div>
-
-      <div style="margin-bottom: 1.5rem;">
-        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Plan / Hypothesis (optional):</label>
-        <textarea id="new-cycle-plan" rows="3" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-family: inherit; font-size: 0.875rem;" placeholder="Describe your plan or hypothesis..."></textarea>
-      </div>
-      
-      <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
-        <button type="button" onclick="document.getElementById('optimisation-new-cycle-modal').style.display='none'" style="padding: 0.5rem 1rem; border: 1px solid #cbd5e1; border-radius: 4px; background: white; cursor: pointer;">Cancel</button>
-        <button type="button" onclick="window.submitNewCycle()" style="padding: 0.5rem 1rem; border: none; border-radius: 4px; background: #2563eb; color: white; cursor: pointer; font-weight: 500;">Start Cycle</button>
-      </div>
-    </div>
-  </div>
-
-  <!-- Edit Objective Modal -->
-  <div id="optimisation-edit-objective-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10001; align-items: center; justify-content: center;">
-    <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto;">
-      <h3 style="margin: 0 0 1.5rem 0; font-size: 1.25rem; color: #1e293b;">Edit Objective</h3>
-
-      <div style="margin-bottom: 0.75rem;">
-        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Objective Title:</label>
-        <input type="text" id="edit-objective-title" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. Improve CTR by 20%">
-      </div>
-
-      <div style="margin-bottom: 0.75rem;">
-        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Primary KPI:</label>
-        <select id="edit-objective-primary-kpi" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
-          <option value="">Select KPI...</option>
-          <option value="ctr_28d">CTR (28d)</option>
-          <option value="rank">Rank</option>
-          <option value="clicks">Clicks</option>
-          <option value="impressions">Impressions</option>
-          <option value="ai_citations">AI Citations</option>
-        </select>
-      </div>
-
-      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
-        <div>
-          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Direction:</label>
-          <select id="edit-objective-target-direction" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
-            <option value="">Select...</option>
-            <option value="increase">Increase</option>
-            <option value="decrease">Decrease</option>
-            <option value="at_least">At least</option>
-            <option value="at_most">At most</option>
-          </select>
-        </div>
-        <div>
-          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Value:</label>
-          <input type="number" id="edit-objective-target-value" step="0.01" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. 20">
-        </div>
-      </div>
-
-      <div style="margin-bottom: 0.75rem;">
-        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Timeframe (days):</label>
-        <select id="edit-objective-timeframe-days" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
-          <option value="">Select timeframe...</option>
-          <option value="30">30 days</option>
-          <option value="60">60 days</option>
-          <option value="90">90 days</option>
-        </select>
-      </div>
-
-      <div style="margin-bottom: 1.5rem;">
-        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Plan / Hypothesis (optional):</label>
-        <textarea id="edit-objective-plan" rows="3" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-family: inherit; font-size: 0.875rem;" placeholder="Describe your plan or hypothesis..."></textarea>
-      </div>
-      
-      <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
-        <button type="button" onclick="document.getElementById('optimisation-edit-objective-modal').style.display='none'" style="padding: 0.5rem 1rem; border: 1px solid #cbd5e1; border-radius: 4px; background: white; cursor: pointer;">Cancel</button>
-        <button type="button" onclick="window.submitEditObjective()" style="padding: 0.5rem 1rem; border: none; border-radius: 4px; background: #2563eb; color: white; cursor: pointer; font-weight: 500;">Save Objective</button>
-      </div>
-    </div>
-  </div>
-
-</body>
-</html>
-
-
-
