From 529163e2fa9ac882552e3a2f2ecb14d20a7d2bd9 Mon Sep 17 00:00:00 2001
From: alanranger <info@alanranger.com>
Date: Tue, 23 Dec 2025 16:06:51 +0000
Subject: [PATCH] Fix Money Pages KPI Tracker: Use exact same bucketing logic
 as top charts (loadPortfolioData) to ensure same data points

---
 audit-dashboard.html | 92 +++++++++++++++++++++++---------------------
 1 file changed, 49 insertions(+), 43 deletions(-)

diff --git a/audit-dashboard.html b/audit-dashboard.html
index be8cfe6..929639c 100644
--- a/audit-dashboard.html
+++ b/audit-dashboard.html
@@ -16030,16 +16030,12 @@ <h3>üîç Debug Log</h3>
         };
         const dbField = metricFieldMap[selectedMetric] || 'position_28d';
         
-        // Calculate date range (last 28 days for date_end filtering)
+        // Use the same date range logic as loadPortfolioData (last 365 days to ensure enough data for weekly bucketing)
         const toDate = new Date();
         const fromDate = new Date();
-        fromDate.setDate(fromDate.getDate() - 28);
-        
-        debugLog(`üìÖ Money Pages KPI Tracker: Filtering by date_end between ${fromDate.toISOString().split('T')[0]} and ${toDate.toISOString().split('T')[0]}`, 'info');
+        fromDate.setDate(fromDate.getDate() - 365);
         
-        // Fetch a wider range (60 days) to ensure we get all records, then filter by date_end
-        const fetchFromDate = new Date();
-        fetchFromDate.setDate(fetchFromDate.getDate() - 60);
+        debugLog(`üìÖ Money Pages KPI Tracker: Fetching data from ${fromDate.toISOString().split('T')[0]} to ${toDate.toISOString().split('T')[0]} (same as top charts)`, 'info');
         
         // Fetch data for all money page segments
         const segments = ['money', 'landing', 'event', 'product'];
@@ -16058,27 +16054,14 @@ <h3>üîç Debug Log</h3>
           const response = await fetch(apiUrl(`/api/supabase/get-portfolio-segment-metrics?${params}`));
           if (response.ok) {
             const data = await response.json();
-            segmentData[segment] = (data.metrics || []).map(m => {
-              // Use date_end for the date, fallback to created_at
-              const recordDate = m.date_end ? new Date(m.date_end) : new Date(m.created_at);
-              
-              // Filter by date_end: only include records where date_end is within the last 28 days
-              if (m.date_end) {
-                const dateEnd = new Date(m.date_end);
-                if (dateEnd < fromDate || dateEnd > toDate) {
-                  return null; // Exclude this record
-                }
-              }
-              
-              return {
-                date: recordDate,
-                value: dbField === 'ctr_28d' ? parseFloat(m.ctr_28d || 0) :
-                       dbField === 'position_28d' ? (m.position_28d !== null && m.position_28d !== undefined && !isNaN(parseFloat(m.position_28d)) ? parseFloat(m.position_28d) : null) :
-                       dbField === 'clicks_28d' ? parseFloat(m.clicks_28d || 0) :
-                       dbField === 'impressions_28d' ? parseFloat(m.impressions_28d || 0) : null,
-                run_id: m.run_id
-              };
-            }).filter(d => d !== null && d.value !== null && !isNaN(d.value));
+            // Store raw metrics for bucketing (same approach as loadPortfolioData)
+            segmentData[segment] = (data.metrics || []).map(m => ({
+              metric: m,
+              value: dbField === 'ctr_28d' ? parseFloat(m.ctr_28d || 0) :
+                     dbField === 'position_28d' ? (m.position_28d !== null && m.position_28d !== undefined && !isNaN(parseFloat(m.position_28d)) ? parseFloat(m.position_28d) : null) :
+                     dbField === 'clicks_28d' ? parseFloat(m.clicks_28d || 0) :
+                     dbField === 'impressions_28d' ? parseFloat(m.impressions_28d || 0) : null
+            })).filter(d => d.value !== null && !isNaN(d.value));
             
             debugLog(`‚úì Fetched ${segmentData[segment].length} records for segment '${segment}' (filtered by date_end in last 28 days)`, 'info');
           } else {
@@ -16144,7 +16127,10 @@ <h3>üîç Debug Log</h3>
         if (!lastValidGscDate || lastValidGscDate.toISOString().split('T')[0] > '2025-12-21') {
           // Check if Dec 21 data exists in any segment
           const hasDec21Data = segments.some(segment => 
-            segmentData[segment].some(d => d.date.toISOString().split('T')[0] === '2025-12-21')
+            segmentData[segment].some(({ metric: m }) => {
+              const dateEnd = m.date_end ? new Date(m.date_end).toISOString().split('T')[0] : null;
+              return dateEnd === '2025-12-21';
+            })
           );
           if (hasDec21Data) {
             lastValidGscDate = new Date('2025-12-21');
@@ -16158,22 +16144,41 @@ <h3>üîç Debug Log</h3>
         const weeklyBuckets = new Map(); // key: Monday date (YYYY-MM-DD), value: Map<segment, {value, date_end}>
         
         segments.forEach(segment => {
-          segmentData[segment].forEach(d => {
+          segmentData[segment].forEach(({ metric: m, value }) => {
+            // Use the same date logic as loadPortfolioData for weekly bucketing
+            // For weekly: only use actual weekly snapshots (run_id in YYYY-MM-DD format)
+            if (m.run_id && m.run_id.match(/^\d{4}-\d{2}$/)) {
+              // Skip monthly backfilled data in weekly view (same as loadPortfolioData)
+              return;
+            }
+            
+            // Determine date for bucketing (same logic as loadPortfolioData)
+            let dateForBucket = null;
+            if (m.run_id && m.run_id.match(/^\d{4}-\d{2}-\d{2}$/)) {
+              dateForBucket = new Date(m.run_id);
+            } else if (m.created_at) {
+              dateForBucket = new Date(m.created_at);
+            } else if (m.date_end) {
+              dateForBucket = new Date(m.date_end);
+            } else {
+              return; // Skip if no valid date
+            }
+            
+            if (!dateForBucket || isNaN(dateForBucket.getTime())) {
+              return; // Skip invalid dates
+            }
+            
             // Filter out data beyond the last valid GSC date
-            // Compare dates as strings (YYYY-MM-DD) to avoid timezone issues
-            const dateStr = d.date.toISOString().split('T')[0];
+            const dateStr = dateForBucket.toISOString().split('T')[0];
             const lastValidDateStr = lastValidGscDate ? lastValidGscDate.toISOString().split('T')[0] : null;
-            
             if (lastValidDateStr && dateStr > lastValidDateStr) {
-              debugLog(`üìÖ Filtering out ${dateStr} for segment ${segment} (beyond lastValidGscDate: ${lastValidDateStr})`, 'info');
               return; // Skip this record
             }
             
-            // Calculate Monday of the week for this date_end
-            const dateEnd = new Date(d.date);
-            const dayOfWeek = dateEnd.getDay();
-            const diff = dateEnd.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1);
-            const monday = new Date(dateEnd);
+            // Calculate Monday of the week (same as loadPortfolioData)
+            const dayOfWeek = dateForBucket.getDay();
+            const diff = dateForBucket.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1);
+            const monday = new Date(dateForBucket);
             monday.setDate(diff);
             const mondayKey = monday.toISOString().split('T')[0];
             
@@ -16182,11 +16187,12 @@ <h3>üîç Debug Log</h3>
             }
             
             const bucket = weeklyBuckets.get(mondayKey);
-            // Keep the LAST snapshot in each week (by date_end)
-            if (!bucket.has(segment) || d.date > bucket.get(segment).date_end) {
+            // Keep the LAST snapshot in each week (by created_at, same as loadPortfolioData)
+            const comparisonDate = m.created_at ? new Date(m.created_at) : (m.date_end ? new Date(m.date_end) : dateForBucket);
+            if (!bucket.has(segment) || comparisonDate > bucket.get(segment).date) {
               bucket.set(segment, {
-                value: d.value,
-                date_end: d.date
+                value: value,
+                date: comparisonDate
               });
             }
           });
