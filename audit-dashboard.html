<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>GAIO (Generative AI Optimization) Audit Dashboard - Automated GAIO Performance Tracking</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script>
    // Try to load config.js if it exists (for local development)
    // Note: config.js is gitignored and won't be deployed to Vercel
    // Silently fail if config.js doesn't exist (expected on Vercel)
    try {
      // First check if file exists via fetch to avoid syntax errors
      fetch('config.js')
        .then(response => {
          if (response.ok && response.headers.get('content-type') && response.headers.get('content-type').includes('javascript')) {
      const configScript = document.createElement('script');
      configScript.src = 'config.js';
            configScript.type = 'text/javascript';
      configScript.onerror = function() {
              // Silently ignore
      };
      document.head.appendChild(configScript);
          }
        })
        .catch(() => {
          // Silently ignore - config.js is optional
        });
    } catch (e) {
      // Silently ignore - config.js is optional
    }
  </script>
  <style>
    :root {
      --brand-orange: #E57200;
      --brand-dark: #222222;
      --brand-grey: #555555;
      --bg-page: #f2f2f2;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      
      /* Dark theme variables (from admin.html) */
      --dark-bg: #0f1419;
      --dark-panel: #1a1f2e;
      --dark-text: #e2e8f0;
      --dark-text-muted: #9ca3af;
      --dark-brand: #f59e0b;
      --dark-border: #374151;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg-page);
      color: var(--brand-dark);
      line-height: 1.5;
    }
    .header {
      background: linear-gradient(135deg, var(--brand-orange) 0%, #ff8c42 100%);
      color: white;
      padding: 2rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .header h1 {
      margin: 0 0 0.5rem 0;
      font-size: 2rem;
    }
    .header p {
      margin: 0;
      opacity: 0.9;
    }
    .container {
      max-width: 1800px;
      margin: 0 auto;
      padding: 2rem;
      padding-bottom: 60px; /* Space for debug panel */
    }
    .config-panel {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      margin-bottom: 2rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .config-panel h2 {
      margin: 0 0 1rem 0;
      color: var(--brand-dark);
      font-size: 1.25rem;
    }
    .form-group {
      margin-bottom: 1rem;
    }
    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      color: var(--brand-grey);
    }
    .form-group input {
      width: 100%;
      padding: 0.75rem;
      border: 2px solid #e2e8f0;
      border-radius: 6px;
      font-size: 1rem;
    }
    .form-group input:focus {
      outline: none;
      border-color: var(--brand-orange);
    }
    .btn {
      background: var(--brand-orange);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    .btn:hover {
      background: #d46200;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    .btn-secondary {
      background: var(--brand-grey);
    }
    .btn-secondary:hover {
      background: #444;
    }
    .status {
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      display: none;
    }
    .status.success {
      background: #d1fae5;
      color: #065f46;
      border-left: 4px solid var(--success);
    }
    .status.error {
      background: #fee2e2;
      color: #991b1b;
      border-left: 4px solid var(--danger);
    }
    .status.info {
      background: #dbeafe;
      color: #1e40af;
      border-left: 4px solid #3b82f6;
    }
    .status.show {
      display: block;
    }
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    .pillar-card {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: relative;
      display: flex;
      flex-direction: column;
      min-height: 100%; /* Ensure all cards have same minimum height */
    }
    .pillar-card h3 {
      margin: 0 0 0.75rem 0;
      color: var(--brand-dark);
      font-size: 1.1rem;
    }
    .pillar-score {
      font-size: 3rem;
      font-weight: 700;
      margin: 0.5rem 0;
      line-height: 1;
    }
    .pillar-score.rag-red {
      color: var(--danger);
    }
    .pillar-score.rag-amber {
      color: var(--warning);
    }
    .pillar-score.rag-green {
      color: var(--success);
    }
    .rag-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.875rem;
      font-weight: 600;
      margin-top: 0.75rem;
      margin-bottom: 0.5rem;
    }
    .rag-badge.red {
      background: #fee2e2;
      color: #991b1b;
    }
    .rag-badge.amber {
      background: #fef3c7;
      color: #92400e;
    }
    .rag-badge.green {
      background: #d1fae5;
      color: #065f46;
    }
    .chart-container {
      background: linear-gradient(135deg, #f0f4f8 0%, #e2e8f0 100%);
      padding: 1.5rem;
      padding-bottom: 12rem; /* Extra padding at bottom for rotated 45-degree axis labels - need significant space for diagonal labels */
      padding-right: 3rem; /* Extra padding on right for Y-axis labels */
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 6rem; /* extra breathing room below charts */
      height: 1000px; /* Doubled from 500px to 1000px for better chart visibility and less bunching */
      min-height: 1000px; /* Ensure minimum height */
      border: 1px solid rgba(100, 116, 139, 0.2);
      overflow: hidden; /* Change to hidden to clip content that extends beyond container */
    }
    .chart-container.large {
      height: 1200px;
      min-height: 1200px;
      padding: 2rem;
    }
    .dashboard-two-column {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-three-column {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-four-column {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    @media (max-width: 1200px) {
      .dashboard-four-column {
        grid-template-columns: repeat(2, 1fr);
      }
      .dashboard-three-column {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    @media (max-width: 768px) {
      .dashboard-two-column,
      .dashboard-three-column,
      .dashboard-four-column {
        grid-template-columns: 1fr;
      }
    }
    .chart-container h3 {
      margin: 0 0 0.5rem 0;
      color: var(--brand-dark);
    }
    .chart-container p {
      margin: 0 0 1rem 0;
    }
    .trend-summary-row {
      display: flex;
      gap: 1.5rem;
      font-size: 0.9rem;
      margin-bottom: 0.75rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .trend-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.7);
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.06);
      border: 1px solid rgba(148, 163, 184, 0.3);
    }
    .trend-pill span.label {
      font-weight: 600;
      color: #374151;
    }
    .trend-pill span.value.up {
      font-weight: 700;
      color: #10b981; /* green */
    }
    .trend-pill span.value.down {
      font-weight: 700;
      color: #ef4444; /* red */
    }
    .trend-pill span.value.neutral {
      font-weight: 700;
      color: #1f2937; /* black/dark gray for no change */
    }
    .metrics-section {
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border: 1px solid rgba(59, 130, 246, 0.1);
    }
    .scorecard-section {
      margin-top: 4rem;  /* push scorecard further below charts */
      margin-bottom: 3rem;
    }
    
    /* Override for scorecard sections inside ranking-ai-detail-content */
    .ranking-ai-detail-content .scorecard-section {
      margin-top: 0;
      margin-bottom: 1.0rem !important;
    }
    
    .ranking-ai-detail-content .scorecard-section:last-child {
      margin-bottom: 0 !important;
    }
    .scorecard-section h3 {
      margin-bottom: 1.5rem;
    }
    .metrics-section {
      margin-top: 3rem;
      margin-bottom: 3rem;
    }
    .metrics-section h3 {
      margin-bottom: 1.5rem;
    }
    .section-break {
      margin-top: 4rem;
      margin-bottom: 4rem;
      border-top: 2px solid #e2e8f0;
      padding-top: 2rem;
    }
    .calculation-explanation {
      background: #f8f9fa;
      border: 2px solid var(--brand-orange);
      border-radius: 8px;
      margin-bottom: 2rem;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(229, 114, 0, 0.15);
    }
    .calculation-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: linear-gradient(135deg, #fff5f0 0%, #ffe8d6 100%);
      border-bottom: 2px solid var(--brand-orange);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    .calculation-explanation.collapsed .calculation-header {
      border-bottom: none;
    }
    .calculation-header:hover {
      background: linear-gradient(135deg, #ffe8d6 0%, #ffd9b3 100%);
    }
    .calculation-header h4 {
      margin: 0;
      color: var(--brand-orange);
      font-size: 1.1rem;
      font-weight: 600;
    }
    .calculation-toggle {
      font-size: 1.2rem;
      color: var(--brand-orange);
      font-weight: bold;
      transition: transform 0.3s;
    }
    .calculation-explanation.collapsed .calculation-toggle {
      transform: rotate(-90deg);
    }
    .calculation-content {
      padding: 1.5rem;
      color: #555;
      line-height: 1.8;
    }
    .calculation-content.collapsed {
      display: none;
    }
    .csv-upload-section {
      background: #f8f9fa;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      margin-bottom: 1rem;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .csv-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: #f8f9fa;
      border-bottom: 2px solid #e2e8f0;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    .csv-upload-section.collapsed .csv-section-header {
      border-bottom: none;
    }
    .csv-section-header:hover {
      background: #f0f0f0;
    }
    .csv-section-header h3 {
      margin: 0;
      color: #1e293b;
      font-size: 1rem;
      font-weight: 600;
    }
    .csv-section-toggle {
      font-size: 1rem;
      color: #64748b;
      font-weight: bold;
      transition: transform 0.3s;
    }
    .csv-upload-section.collapsed .csv-section-toggle {
      transform: rotate(-90deg);
    }
    .csv-section-content {
      padding: 1rem;
    }
    .csv-section-content.collapsed {
      display: none;
    }
    .calculation-content h5 {
      color: var(--brand-dark);
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-size: 1rem;
      font-weight: 600;
      border-bottom: 2px solid var(--brand-orange);
      padding-bottom: 0.5rem;
    }
    .calculation-content h5:first-child {
      margin-top: 0;
    }
    .calculation-content ul {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
    }
    .calculation-content li {
      margin: 0.5rem 0;
    }
    .calculation-content code {
      background: #e2e8f0;
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #c53030;
    }
    .calculation-content .formula {
      background: #f0f4f8;
      padding: 0.75rem;
      border-left: 3px solid var(--brand-orange);
      margin: 0.75rem 0;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
    }
    .calculation-content .note {
      background: #fff3cd;
      border-left: 3px solid #f59e0b;
      padding: 0.75rem;
      margin: 1rem 0;
      font-size: 0.9rem;
    }
    .date-range-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .date-range-btn {
      padding: 0.5rem 1rem;
      border: 2px solid #e2e8f0;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    .date-range-btn:hover {
      border-color: var(--brand-orange);
      background: #fff5f0;
    }
    .date-range-btn.active {
      background: var(--brand-orange);
      color: white;
      border-color: var(--brand-orange);
    }
    .snippet-readiness-gauge {
      background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 3rem;
      border: 1px solid rgba(16, 185, 129, 0.1);
    }
    .gauge-container {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      flex: 1;
      position: relative;
    }
    .gauge-wrapper {
      position: relative;
      width: 300px;
      height: 300px;
    }
    .gauge-svg {
      transform: rotate(-90deg);
      width: 100%;
      height: 100%;
    }
    .gauge-background {
      fill: none;
      stroke: #e2e8f0;
      stroke-width: 20;
    }
    .gauge-fill {
      fill: none;
      stroke-width: 20;
      stroke-linecap: round;
      transition: stroke-dashoffset 1s ease-in-out;
    }
    .gauge-fill.green {
      stroke: #10b981;
    }
    .gauge-fill.amber {
      stroke: #f59e0b;
    }
    .gauge-fill.red {
      stroke: #ef4444;
    }
    .gauge-value {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      font-weight: 700;
      text-align: center;
      z-index: 10;
    }
    .gauge-value.green {
      color: #10b981;
    }
    .gauge-value.amber {
      color: #f59e0b;
    }
    .gauge-value.red {
      color: #ef4444;
    }
    .gauge-label {
      text-align: center;
      color: var(--brand-grey);
      margin-top: 1rem;
      font-size: 1rem;
      font-weight: 600;
    }
    .gauge-status {
      text-align: center;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      font-weight: 500;
    }
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }
    .metric-card {
      background: white;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
    }
    .metric-card .value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--brand-orange);
      margin: 0.5rem 0;
    }
    .metric-card .label {
      color: var(--brand-grey);
      font-size: 0.875rem;
    }
    .metric-label {
      color: var(--brand-grey);
      font-size: 0.875rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    .metric-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--brand-orange);
      margin: 0.5rem 0;
    }
    .metric-sub {
      color: var(--brand-grey);
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }
    .url-cell {
      max-width: 300px;
    }
    .url-main {
      font-weight: 600;
      color: #333;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .url-sub {
      font-size: 0.75rem;
      color: #666;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-top: 0.25rem;
    }
    .money-recommendation {
      font-size: 0.875rem;
      line-height: 1.5;
      color: #555;
      max-width: 400px;
    }
    .loading {
      display: none;
      text-align: center;
      padding: 2rem;
    }
    .loading.show {
      display: block;
    }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--brand-orange);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .progress-container {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1rem 0;
    }
    .progress-bar-wrapper {
      width: 100%;
      background: #e2e8f0;
      border-radius: 10px;
      height: 24px;
      overflow: hidden;
      margin: 1rem 0;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--brand-orange), #ff8c42);
      border-radius: 10px;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 0.85rem;
      min-width: 0;
    }
    .progress-status {
      font-size: 0.95rem;
      color: #555;
      margin-top: 0.5rem;
      font-weight: 500;
    }
    /* Full-page overlay for domain strength snapshot */
    .domain-strength-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      z-index: 9999;
      display: none;
      align-items: center;
      justify-content: center;
    }
    .domain-strength-overlay.show {
      display: flex;
    }
    .domain-strength-overlay-content {
      background: white;
      border-radius: 12px;
      padding: 2.5rem 3rem;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      text-align: center;
      max-width: 400px;
    }
    .domain-strength-overlay-content .spinner {
      width: 48px;
      height: 48px;
      border-width: 5px;
      margin: 0 auto 1.5rem;
    }
    .domain-strength-overlay-content h3 {
      margin: 0 0 0.75rem 0;
      font-size: 1.25rem;
      font-weight: 700;
      color: #1e293b;
    }
    .domain-strength-overlay-content p {
      margin: 0;
      font-size: 0.95rem;
      color: #64748b;
      line-height: 1.6;
    }
    /* Sticky positioning for domain strength table */
    #domain-strength-table thead {
      position: sticky;
      top: 0;
      z-index: 10;
      background: #f8fafc;
    }
    #domain-strength-table thead th {
      background: #f8fafc;
    }
    #domain-strength-self-row {
      position: sticky;
      top: 40px; /* Adjust based on header height */
      z-index: 9;
      background: #fefce8 !important;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      overflow: auto;
    }
    .modal-content {
      background-color: white;
      margin: 5% auto;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      animation: modalSlideIn 0.3s ease;
    }
    @keyframes modalSlideIn {
      from {
        transform: translateY(-50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    .ranking-ai-step-item {
      display: flex;
      align-items: center;
      padding: 0.75rem;
      border-radius: 6px;
      background-color: #f9fafb;
      transition: all 0.2s ease;
    }
    .ranking-ai-step-item.active {
      background-color: #fef3c7;
      border-left: 4px solid var(--brand-orange);
    }
    .ranking-ai-step-item.completed {
      background-color: #d1fae5;
      border-left: 4px solid #10b981;
    }
    .ranking-ai-step-item.pending {
      opacity: 0.5;
    }
    .ranking-ai-step-icon {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 0.75rem;
      font-weight: bold;
      font-size: 0.85rem;
    }
    .ranking-ai-step-item.pending .ranking-ai-step-icon {
      background-color: #e5e7eb;
      color: #9ca3af;
    }
    .ranking-ai-step-item.active .ranking-ai-step-icon {
      background-color: var(--brand-orange);
      color: white;
      animation: pulse 1.5s ease-in-out infinite;
    }
    .ranking-ai-step-item.completed .ranking-ai-step-icon {
      background-color: #10b981;
      color: white;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    .ranking-ai-step-label {
      flex: 1;
      font-size: 0.9rem;
      color: #374151;
    }
    .ranking-ai-step-item.completed .ranking-ai-step-label {
      color: #059669;
    }
    .ranking-ai-step-item.active .ranking-ai-step-label {
      color: #92400e;
      font-weight: 600;
    }
    .help-text {
      font-size: 0.875rem;
      color: var(--brand-grey);
      margin-top: 0.25rem;
    }

    .debug-panel-bottom {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1a1a1a;
      border-top: 3px solid #E57200;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      z-index: 1000;
      box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.5);
      max-height: 50vh;
      display: flex;
      flex-direction: column;
    }

    .debug-panel-bottom.collapsed {
      max-height: 50px;
    }

    .debug-panel-bottom.collapsed .debug-content {
      display: none !important;
    }

    .debug-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #333;
      background: #252525;
      user-select: none;
    }

    .debug-header h3 {
      margin: 0;
      color: #fff;
      font-size: 1rem;
    }

    .debug-actions {
      display: flex;
      gap: 0.5rem;
    }

    .btn-small {
      padding: 0.25rem 0.75rem;
      font-size: 0.75rem;
      background: #333;
      color: #fff;
      border: 1px solid #555;
    }

    .btn-small:hover {
      background: #444;
    }

    .debug-content {
      color: #fff;
      line-height: 1.6;
      padding: 1rem;
      overflow-y: auto;
      flex: 1;
      max-height: calc(50vh - 60px);
    }

    .debug-log-entry {
      margin-bottom: 0.25rem;
      padding: 0.25rem 0;
      border-left: 2px solid transparent;
      padding-left: 0.5rem;
    }

    .debug-log-entry.error {
      color: #f44;
      border-left-color: #f44;
    }

    .debug-log-entry.warn {
      color: #fa4;
      border-left-color: #fa4;
    }

    .debug-log-entry.info {
      color: #9cf;
      border-left-color: #4af;
    }

    .debug-log-entry.success {
      color: #9f9;
      border-left-color: #4f4;
    }

    .debug-timestamp {
      color: #aaa;
      margin-right: 0.5rem;
    }

    /* Sidebar Layout */
    .aigeo-layout {
      display: flex;
      min-height: calc(100vh - 120px); /* Account for header */
    }

    .aigeo-sidebar {
      width: 260px;
      background: linear-gradient(180deg, #ffffff 0%, #f8f9fa 100%);
      border-right: 2px solid #e2e8f0;
      padding: 1.5rem 0;
      position: sticky;
      top: 0;
      height: calc(100vh - 120px);
      overflow-y: auto;
      flex-shrink: 0;
      box-shadow: 2px 0 8px rgba(0,0,0,0.05);
    }

    .aigeo-nav-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      width: 100%;
      padding: 0.875rem 1.5rem;
      background: none;
      border: none;
      text-align: left;
      font-size: 0.95rem;
      font-weight: 500;
      color: #64748b;
      cursor: pointer;
      transition: all 0.2s ease;
      border-left: 4px solid transparent;
      position: relative;
    }

    .aigeo-nav-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0;
      background: var(--brand-orange);
      transition: width 0.2s ease;
    }

    .aigeo-nav-item:hover {
      background: linear-gradient(90deg, #fff5f0 0%, #ffffff 100%);
      color: var(--brand-dark);
      padding-left: 1.75rem;
    }

    .aigeo-nav-item.is-active {
      background: linear-gradient(90deg, #fff5f0 0%, #ffffff 100%);
      color: var(--brand-orange);
      border-left-color: var(--brand-orange);
      font-weight: 600;
      box-shadow: inset 0 0 0 1px rgba(229, 114, 0, 0.1);
    }

    .aigeo-nav-item.is-active::before {
      width: 4px;
    }

    .aigeo-nav-icon {
      font-size: 1.25rem;
      width: 24px;
      text-align: center;
      flex-shrink: 0;
    }

    .aigeo-main {
      flex: 1;
      overflow-y: auto;
      padding: 2rem;
      padding-bottom: 60px; /* Space for debug panel */
    }

    .aigeo-panel {
      display: none;
    }

    .aigeo-panel.is-active {
      display: block;
    }

    /* Ensure ranking panel uses block layout when active, not flex */
    .aigeo-panel[data-panel="ranking"].is-active {
      display: block !important;
    }

    /* Ensure ranking panel children stack vertically, but allow metric pills, side-by-side cards, and details grid to use their layouts */
    .aigeo-panel[data-panel="ranking"] > .ranking-metric-pills {
      display: grid !important;
    }

    .aigeo-panel[data-panel="ranking"] > .ranking-details-grid {
      display: grid !important;
    }

    .aigeo-panel[data-panel="ranking"] > .ranking-cards-side-by-side {
      display: flex !important;
    }

    .aigeo-panel[data-panel="ranking"] > *:not(.ranking-metric-pills):not(.ranking-cards-side-by-side):not(.ranking-priority-matrix-section):not(.ranking-table-section):not(.ranking-details-grid) {
      width: 100% !important;
      display: block !important;
      clear: both !important;
      float: none !important;
    }

    /* Ranking & AI Tab Styles */
    .ranking-pillars-note {
      font-size: 0.9rem;
      color: #64748b;
      margin: 0.75rem 0;
      line-height: 1.6;
    }

    .ranking-intro {
      margin-top: 0.25rem;
      font-size: 1rem;
      color: #4b5563;
      max-width: 56rem;
    }

    .ranking-intro-bullets {
      margin: 0.25rem 0 0.5rem;
      padding-left: 1.25rem;
      font-size: 0.95rem;
      color: #6b7280;
    }

    .ranking-intro-bullets li {
      margin-bottom: 0.1rem;
    }

    .ranking-header-actions {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-top: 0.4rem;
    }

    /* Section B: Metric pills - all 5 on one row */
    .ranking-metric-pills {
      display: grid !important;
      grid-template-columns: repeat(5, 1fr) !important;
      gap: 1rem;
      margin-top: 1rem;
      margin-bottom: 1.5rem;
      width: 100%;
      grid-auto-flow: row;
    }

    .ranking-metric-pills > .metric-pill {
      display: block;
      width: 100%;
      min-width: 0;
    }

    /* For medium screens, reduce gap but keep all 5 in one row */
    @media (min-width: 769px) and (max-width: 1400px) {
      .ranking-metric-pills {
        grid-template-columns: repeat(5, 1fr);
        gap: 0.75rem;
      }
    }

    /* Only wrap on very small screens */
    @media (max-width: 768px) {
      .ranking-metric-pills {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    .metric-pill {
      background: #ffffff;
      border-radius: 8px;
      padding: 1rem 1.25rem;
      box-shadow: 0 1px 3px rgba(15, 23, 42, 0.06);
      transition: all 0.2s ease;
      border-left: 4px solid transparent;
    }
    
    .metric-pill--active {
      background: #1e40af !important;
      color: #ffffff !important;
      box-shadow: 0 2px 6px rgba(30, 64, 175, 0.3);
      border-left-color: #1e3a8a;
      font-weight: 600;
    }
    
    .metric-pill--active span,
    .metric-pill--active .optimisation-tab-count {
      color: #ffffff !important;
    }
    
    .metric-pill--active:hover {
      background: #1e3a8a !important;
    }

    .metric-pill--green {
      background: #f0fdf4;
      border-left-color: #16a34a;
    }

    .metric-pill--amber {
      background: #fffbeb;
      border-left-color: #f59e0b;
    }

    .metric-pill--red {
      background: #fef2f2;
      border-left-color: #dc2626;
    }

    .metric-pill--neutral {
      background: #f9fafb;
      border-left-color: #6b7280;
    }

    .metric-pill-value {
      font-size: 2rem;
      font-weight: 700;
      margin: 0.25rem 0;
      color: #1e293b;
    }

    .metric-pill-label {
      font-size: 1rem;
      font-weight: 600;
      color: #374151;
      margin-bottom: 0.25rem;
    }

    .metric-pill-status {
      font-size: 0.85rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.7rem;
      border-radius: 999px;
      margin: 0.25rem 0;
    }

    /* ============================================
       OPTIMISATION MODULE - DARK THEME
       ============================================ */
    
    /* Dark background for entire optimisation section - fill full width of main content area */
    section[data-panel="optimisation"] {
      background: var(--dark-bg) !important;
      min-height: calc(100vh - 4rem);
      position: relative;
      color: var(--dark-text) !important;
      width: calc(100vw - 260px); /* Full viewport width minus sidebar */
      margin-left: calc(-50vw + 50% + 130px); /* Position to start after sidebar */
      margin-right: calc(-50vw + 50% - 130px);
      padding: 2rem;
      box-sizing: border-box;
    }
    
    section[data-panel="optimisation"] * {
      color: inherit;
    }
    
    /* Section header */
    section[data-panel="optimisation"] .card--section-header {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
    }
    
    section[data-panel="optimisation"] .card--section-header h2 {
      color: var(--dark-brand) !important;
      margin: 0 0 0.5rem 0;
    }
    
    section[data-panel="optimisation"] .card--section-header p {
      color: var(--dark-text-muted) !important;
      margin: 0;
    }
    
    /* Buttons */
    section[data-panel="optimisation"] .btn {
      background: var(--dark-brand) !important;
      color: #000 !important;
      border: none !important;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    section[data-panel="optimisation"] .btn:hover {
      background: #d97706 !important;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
    }
    
    /* Optimisation module tiles - dark theme with green centered counts and orange hover animation */
    .optimisation-summary-cards .card,
    .optimisation-kpi-tiles .card {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px;
      padding: 1.5rem;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    /* Bronze/Silver/Gold backgrounds for Potential Extra Clicks tile */
    #impact-potential-clicks-card.impact-bronze {
      background: linear-gradient(135deg, #cd7f32 0%, #b87333 100%) !important;
      border: 1px solid #a0652a !important;
      color: #ffffff !important;
    }
    
    #impact-potential-clicks-card.impact-bronze * {
      color: #ffffff !important;
    }
    
    #impact-potential-clicks-card.impact-silver {
      background: linear-gradient(135deg, #c0c0c0 0%, #a8a8a8 100%) !important;
      border: 1px solid #909090 !important;
      color: #1a1a1a !important;
    }
    
    #impact-potential-clicks-card.impact-silver * {
      color: #1a1a1a !important;
    }
    
    #impact-potential-clicks-card.impact-gold {
      background: linear-gradient(135deg, #ffd700 0%, #ffb700 100%) !important;
      border: 1px solid #e6a600 !important;
      color: #1a1a1a !important;
    }
    
    #impact-potential-clicks-card.impact-gold * {
      color: #1a1a1a !important;
    }
    
    .optimisation-impact-tiles .card:not(.impact-bronze):not(.impact-silver):not(.impact-gold) {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px;
      padding: 1.5rem;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    /* Task Details Modal/Drawer - Dark Theme */
    #optimisation-task-drawer {
      background: var(--dark-panel) !important;
      color: var(--dark-text) !important;
    }
    
    #optimisation-task-drawer * {
      color: var(--dark-text) !important;
    }
    
    #optimisation-drawer-header-bar {
      background: var(--dark-panel) !important;
      border-bottom: 1px solid var(--dark-border) !important;
    }
    
    #optimisation-drawer-header-bar h3 {
      color: var(--dark-text) !important;
    }
    
    #optimisation-drawer-header-bar button {
      color: var(--dark-text-muted) !important;
    }
    
    #optimisation-drawer-header-bar button:hover {
      color: var(--dark-text) !important;
    }
    
    /* Modal sections with light backgrounds */
    #optimisation-task-drawer div[style*="background: #fff5f5"],
    #optimisation-task-drawer div[style*="background: #f8f9fa"],
    #optimisation-task-drawer div[style*="background: white"] {
      background: var(--dark-panel) !important;
      border-color: var(--dark-border) !important;
    }
    
    /* Input fields */
    #optimisation-task-drawer input,
    #optimisation-task-drawer select,
    #optimisation-task-drawer textarea {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    #optimisation-task-drawer input::placeholder,
    #optimisation-task-drawer textarea::placeholder {
      color: var(--dark-text-muted) !important;
    }
    
    /* Labels and strong text */
    #optimisation-task-drawer strong,
    #optimisation-task-drawer label {
      color: var(--dark-text) !important;
    }
    
    /* Divs with muted colors */
    #optimisation-task-drawer div[style*="color: #666"],
    #optimisation-task-drawer div[style*="color: #475569"] {
      color: var(--dark-text-muted) !important;
    }
    
    /* Links */
    #optimisation-task-drawer a {
      color: var(--dark-brand) !important;
    }
    
    /* Buttons - use proper dark backgrounds with white text for readability */
    #optimisation-task-drawer .btn,
    #optimisation-task-drawer button.btn {
      background: var(--dark-brand) !important;
      color: #ffffff !important;
      border: 1px solid var(--dark-brand) !important;
      font-weight: 700 !important;
    }
    
    #optimisation-task-drawer .btn:hover,
    #optimisation-task-drawer button.btn:hover {
      background: #f59e0b !important;
      color: #ffffff !important;
      border-color: #f59e0b !important;
    }
    
    #optimisation-task-drawer .btn-secondary,
    #optimisation-task-drawer button.btn-secondary {
      background: #4b5563 !important;
      color: #ffffff !important;
      border: 1px solid #4b5563 !important;
      font-weight: 700 !important;
    }
    
    #optimisation-task-drawer .btn-secondary:hover,
    #optimisation-task-drawer button.btn-secondary:hover {
      background: #6b7280 !important;
      color: #ffffff !important;
      border-color: #6b7280 !important;
    }
    
    /* Specific button IDs - dark backgrounds with white text */
    #optimisation-cancel-task-btn,
    #optimisation-delete-task-btn {
      background: #dc2626 !important;
      color: #ffffff !important;
      border: 1px solid #dc2626 !important;
      font-weight: 700 !important;
    }
    
    #optimisation-cancel-task-btn:hover,
    #optimisation-delete-task-btn:hover {
      background: #b91c1c !important;
      color: #ffffff !important;
      border-color: #b91c1c !important;
    }
    
    #optimisation-complete-cycle-btn {
      background: #059669 !important;
      color: #ffffff !important;
      border: 1px solid #059669 !important;
      font-weight: 700 !important;
    }
    
    #optimisation-complete-cycle-btn:hover {
      background: #047857 !important;
      color: #ffffff !important;
      border-color: #047857 !important;
    }
    
    #optimisation-archive-cycle-btn {
      background: #4b5563 !important;
      color: #ffffff !important;
      border: 1px solid #4b5563 !important;
      font-weight: 700 !important;
    }
    
    #optimisation-archive-cycle-btn:hover {
      background: #6b7280 !important;
      color: #ffffff !important;
      border-color: #6b7280 !important;
    }
    
    #optimisation-add-event-btn,
    #optimisation-save-status-btn {
      background: var(--dark-brand) !important;
      color: #ffffff !important;
      border: 1px solid var(--dark-brand) !important;
      font-weight: 700 !important;
    }
    
    #optimisation-add-event-btn:hover,
    #optimisation-save-status-btn:hover {
      background: #f59e0b !important;
      color: #ffffff !important;
      border-color: #f59e0b !important;
    }
    
    /* Buttons with orange/yellow backgrounds need BLACK text for readability */
    #optimisation-edit-objective-btn,
    #optimisation-add-measurement-btn,
    #optimisation-save-objective-btn {
      background: var(--dark-brand) !important;
      color: #000000 !important;
      border: 1px solid var(--dark-brand) !important;
      font-weight: 700 !important;
    }
    
    #optimisation-edit-objective-btn:hover,
    #optimisation-add-measurement-btn:hover,
    #optimisation-save-objective-btn:hover {
      background: #f59e0b !important;
      color: #000000 !important;
      border-color: #f59e0b !important;
    }
    
    /* Status badges and pills */
    #optimisation-task-drawer span[style*="background: #f0f0f0"] {
      background: rgba(156, 163, 175, 0.2) !important;
      color: var(--dark-text) !important;
    }
    
    /* Table borders and backgrounds */
    #optimisation-task-drawer table,
    #optimisation-task-drawer th,
    #optimisation-task-drawer td {
      border-color: var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    #optimisation-task-drawer th {
      background: var(--dark-bg) !important;
    }
    
    /* Timeline border */
    #optimisation-drawer-events-container div[style*="border-left"] {
      border-left-color: var(--dark-border) !important;
    }

    .optimisation-summary-cards .card::before,
    .optimisation-kpi-tiles .card::before,
    .optimisation-impact-tiles .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--dark-brand);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }

    .optimisation-summary-cards .card:hover,
    .optimisation-kpi-tiles .card:hover,
    .optimisation-impact-tiles .card:not(.impact-bronze):not(.impact-silver):not(.impact-gold):hover {
      border-color: var(--dark-brand) !important;
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(245, 158, 11, 0.2);
      animation: wobble 0.5s ease-in-out;
    }

    @keyframes wobble {
      0%, 100% { transform: translateY(-4px) rotate(0deg); }
      25% { transform: translateY(-4px) rotate(-1deg); }
      75% { transform: translateY(-4px) rotate(1deg); }
    }

    .optimisation-summary-cards .card:hover::before,
    .optimisation-kpi-tiles .card:hover::before,
    .optimisation-impact-tiles .card:not(.impact-bronze):not(.impact-silver):not(.impact-gold):hover::before {
      transform: scaleX(1);
    }
    
    /* Traffic light pills - same styling as other cards */
    .traffic-light-pill {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px !important;
      padding: 1rem !important;
      transition: all 0.3s ease !important;
      position: relative !important;
      overflow: visible !important;
      text-align: center !important;
      cursor: pointer !important;
      z-index: 1 !important;
    }
    
    .traffic-light-pill::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--dark-brand);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }
    
    .traffic-light-pill:hover {
      border-color: var(--dark-brand) !important;
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(245, 158, 11, 0.2);
      animation: wobble 0.5s ease-in-out;
    }
    
    .traffic-light-pill:hover::before {
      transform: scaleX(1);
    }
    
    /* Restore background colors on hover based on bucket */
    .traffic-light-pill[data-bucket="worse"]:hover {
      background: rgba(239, 68, 68, 0.3) !important;
    }
    
    .traffic-light-pill[data-bucket="same"]:hover {
      background: rgba(245, 158, 11, 0.3) !important;
    }
    
    .traffic-light-pill[data-bucket="better"]:hover {
      background: rgba(16, 185, 129, 0.3) !important;
    }

    /* Green centered count values (like analytics.html) - no background */
    .optimisation-summary-cards .card > div:first-child,
    .optimisation-kpi-tiles .card > div:first-child,
    .optimisation-impact-tiles .card > div:first-child {
      font-size: 2.5rem !important;
      font-weight: 700 !important;
      color: var(--success) !important;
      margin-bottom: 0.5rem;
      text-align: center;
      background: transparent !important;
      padding: 0 !important;
    }

    /* Labels - no background */
    .optimisation-summary-cards .card > div:last-child,
    .optimisation-kpi-tiles .card > div:last-child,
    .optimisation-impact-tiles .card > div:last-child {
      color: var(--dark-text-muted) !important;
      font-size: 0.9rem;
      text-align: center;
      background: transparent !important;
      padding: 0 !important;
    }

    /* Goal rollup badges */
    section[data-panel="optimisation"] .optimisation-goal-rollups {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      border-radius: 8px;
      padding: 1rem;
      margin: 1.5rem 0;
    }
    
    section[data-panel="optimisation"] .optimisation-goal-rollups > div:first-child {
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .ranking-badge {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
      transition: all 0.2s;
    }
    
    section[data-panel="optimisation"] .ranking-badge:hover {
      border-color: var(--dark-brand) !important;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.2);
    }
    
    /* Scope toggle */
    section[data-panel="optimisation"] .optimisation-scope-toggle {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-scope-toggle label {
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-scope-toggle select {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-scope-toggle span {
      color: var(--dark-text-muted) !important;
    }
    
    /* Tab pills */
    section[data-panel="optimisation"] .optimisation-tab-pills {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      border-radius: 8px;
      padding: 1rem;
      margin: 1.5rem 0;
    }
    
    section[data-panel="optimisation"] .optimisation-tab-btn {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-tab-btn:hover {
      border-color: var(--dark-brand) !important;
      background: rgba(245, 158, 11, 0.1) !important;
    }
    
    section[data-panel="optimisation"] .metric-pill--active {
      background: var(--dark-brand) !important;
      border-color: var(--dark-brand) !important;
      color: #000 !important;
      animation: wobble 0.5s ease-in-out;
    }
    
    /* Tables */
    section[data-panel="optimisation"] .ranking-table-wrapper {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      border-radius: 8px;
      overflow: hidden;
    }
    
    section[data-panel="optimisation"] .ranking-table {
      background: var(--dark-panel) !important;
    }
    
    section[data-panel="optimisation"] .ranking-table thead th {
      background: var(--dark-bg) !important;
      color: #ffffff !important;
      border-bottom: 1px solid var(--dark-border) !important;
      font-weight: 600;
    }
    
    /* Sort indicators and info icons - white */
    section[data-panel="optimisation"] .ranking-table thead th .sort-indicator,
    section[data-panel="optimisation"] .ranking-table thead th i,
    section[data-panel="optimisation"] .ranking-table thead th [class*="icon"],
    section[data-panel="optimisation"] .ranking-table thead th::after {
      color: #ffffff !important;
      opacity: 0.8;
    }
    
    section[data-panel="optimisation"] .ranking-table thead th:hover .sort-indicator,
    section[data-panel="optimisation"] .ranking-table thead th:hover i {
      opacity: 1;
    }
    
    /* Table cells - no darker background, transparent */
    section[data-panel="optimisation"] .ranking-table tbody td {
      background: transparent !important;
      color: var(--dark-text) !important;
      border-bottom: 1px solid var(--dark-border) !important;
    }
    
    /* Remove any background from text/spans inside cells */
    section[data-panel="optimisation"] .ranking-table tbody td *,
    section[data-panel="optimisation"] .ranking-table tbody td span,
    section[data-panel="optimisation"] .ranking-table tbody td strong,
    section[data-panel="optimisation"] .ranking-table tbody td div {
      background: transparent !important;
    }
    
    /* Ensure all text in table cells is readable */
    section[data-panel="optimisation"] .ranking-table tbody td {
      background: transparent !important;
    }
    
    section[data-panel="optimisation"] .ranking-table tbody td strong {
      color: var(--dark-text) !important;
      background: transparent !important;
    }
    
    section[data-panel="optimisation"] .ranking-table tbody tr:hover {
      background: rgba(255, 255, 255, 0.05) !important;
    }
    
    section[data-panel="optimisation"] .ranking-table tbody tr:hover td {
      background: rgba(255, 255, 255, 0.05) !important;
    }
    
    section[data-panel="optimisation"] .ranking-table-empty {
      color: var(--dark-text-muted) !important;
      background: transparent !important;
    }
    
    /* Pagination */
    section[data-panel="optimisation"] #optimisation-pagination-controls {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      border-radius: 8px;
      padding: 1rem;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] #optimisation-pagination-controls button,
    section[data-panel="optimisation"] #optimisation-pagination-controls select {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] #optimisation-pagination-controls button:hover {
      border-color: var(--dark-brand) !important;
      background: rgba(245, 158, 11, 0.1) !important;
    }
    
    /* Charts container */
    section[data-panel="optimisation"] .optimisation-timeseries-charts .card {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-timeseries-charts h3 {
      color: #ffffff !important;
      font-size: 1.2rem !important;
      font-weight: 600;
    }
    
    /* Chart text - bright white and larger */
    section[data-panel="optimisation"] canvas {
      color: #ffffff !important;
    }
    
    /* Chart axis labels and text - white and larger */
    section[data-panel="optimisation"] #chart-measurements-per-week,
    section[data-panel="optimisation"] #chart-median-delta {
      color: #ffffff !important;
    }
    
    /* Filters and inputs */
    section[data-panel="optimisation"] input[type="text"],
    section[data-panel="optimisation"] input[type="checkbox"],
    section[data-panel="optimisation"] select {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] input[type="text"]:focus,
    section[data-panel="optimisation"] select:focus {
      border-color: var(--dark-brand) !important;
      outline: none;
    }
    
    /* Portfolio Tab Styling - Match Optimisation tab dark theme */
    section[data-panel="portfolio"] .portfolio-container {
      background: var(--dark-bg) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="portfolio"] .portfolio-container h1 {
      color: var(--dark-text) !important;
      font-size: 2rem !important;
      font-weight: 700;
    }
    
    section[data-panel="portfolio"] .portfolio-chart-section .card,
    section[data-panel="portfolio"] .portfolio-table-section .card {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3) !important;
    }
    
    section[data-panel="portfolio"] .portfolio-chart-section h2,
    section[data-panel="portfolio"] .portfolio-table-section h2 {
      color: #ffffff !important;
      font-size: 1.3rem !important;
      font-weight: 600;
    }
    
    section[data-panel="portfolio"] .portfolio-chart-section p,
    section[data-panel="portfolio"] .portfolio-table-section p {
      color: var(--dark-text-muted) !important;
    }
    
    section[data-panel="portfolio"] .portfolio-controls label {
      color: var(--dark-text) !important;
    }
    
    section[data-panel="portfolio"] .portfolio-controls select,
    section[data-panel="portfolio"] #portfolio-table-kpi-select {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
      padding: 0.5rem 0.75rem !important;
      border-radius: 6px !important;
      font-size: 0.875rem !important;
    }
    
    section[data-panel="portfolio"] .portfolio-controls select:focus,
    section[data-panel="portfolio"] #portfolio-table-kpi-select:focus {
      border-color: var(--dark-brand) !important;
      outline: none;
      box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.1) !important;
    }
    
    section[data-panel="portfolio"] .portfolio-controls select:hover,
    section[data-panel="portfolio"] #portfolio-table-kpi-select:hover {
      border-color: var(--dark-brand) !important;
    }
    
    section[data-panel="portfolio"] #portfolio-monthly-table {
      background: var(--dark-panel) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="portfolio"] #portfolio-monthly-table thead th {
      background: rgba(55, 65, 81, 0.5) !important;
      color: var(--dark-text) !important;
      border-bottom: 2px solid var(--dark-border) !important;
      font-weight: 600;
    }
    
    section[data-panel="portfolio"] #portfolio-monthly-table tbody td {
      color: var(--dark-text) !important;
      border-bottom: 1px solid var(--dark-border) !important;
    }
    
    section[data-panel="portfolio"] #portfolio-monthly-table tbody tr:hover {
      background: rgba(245, 158, 11, 0.05) !important;
    }
    
    section[data-panel="portfolio"] #portfolio-delta-chart {
      color: #ffffff !important;
    }
    
    /* Remove border-left from inline styles */
    .optimisation-summary-cards .card[style*="border-left"],
    .optimisation-kpi-tiles .card[style*="border-left"],
    .optimisation-impact-tiles .card[style*="border-left"] {
      border-left: 2px solid var(--dark-border) !important;
    }

    .metric-pill--green .metric-pill-status {
      background: #dcfce7;
      color: #166534;
    }

    .metric-pill--amber .metric-pill-status {
      background: #fef3c7;
      color: #92400e;
    }

    .metric-pill--red .metric-pill-status {
      background: #fee2e2;
      color: #b91c1c;
    }

    .metric-pill--neutral .metric-pill-status {
      background: #e5e7eb;
      color: #4b5563;
    }

    .metric-pill-footer {
      font-size: 0.85rem;
      color: #6b7280;
      margin-top: 0.5rem;
      line-height: 1.4;
    }

    .metric-pill-toggle {
      font-size: 0.85rem;
      color: #0284c7;
      cursor: pointer;
      margin-top: 0.5rem;
      text-decoration: underline;
      user-select: none;
    }

    .metric-pill-toggle:hover {
      color: #0369a1;
    }

    .metric-pill-details {
      display: none;
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid #e5e7eb;
    }

    .metric-pill-details.expanded {
      display: block;
    }

    /* ============================================
       AI Sources & Influence tab: layout styling
       ============================================ */
    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer {
      background: #fffbeb;
      border-left: 4px solid #f59e0b;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer .card-header {
      padding: 1.25rem 1.5rem 0.75rem 1.5rem;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer .card-header h3 {
      color: #92400e;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer .card-body {
      padding: 1.25rem 1.5rem;
      color: #78350f;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer ul {
      padding-left: 1.5rem;
      margin: 0.25rem 0;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-domain-table-card {
      background: rgba(204, 255, 255, 0.15);
      border-left: 4px solid #CCFFFF;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-domain-table-card .card-header {
      background: transparent;
    }

    /* AI sources table: alignment + hover highlight */
    #ai-sources-table th:nth-child(1),
    #ai-sources-table td:nth-child(1),
    #ai-sources-table th:nth-child(2),
    #ai-sources-table td:nth-child(2),
    #ai-sources-table th:nth-child(6),
    #ai-sources-table td:nth-child(6) {
      text-align: left !important;
    }

    #ai-sources-table th:nth-child(3),
    #ai-sources-table td:nth-child(3),
    #ai-sources-table th:nth-child(4),
    #ai-sources-table td:nth-child(4),
    #ai-sources-table th:nth-child(5),
    #ai-sources-table td:nth-child(5) {
      text-align: right !important;
    }

    #ai-sources-table tbody tr:hover td {
      background: #eff6ff !important;
    }

    /* Tile details styling */
    .tile-details-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: #374151;
      margin: 0 0 0.75rem 0;
      line-height: 1.5;
    }

    .tile-details-list {
      list-style: none;
      padding: 0;
      margin: 0 0 0.75rem 0;
    }

    .tile-details-list li {
      font-size: 0.875rem;
      color: #4b5563;
      line-height: 1.8;
      margin-bottom: 0.5rem;
    }

    .tile-details-list li strong {
      color: #1f2937;
      font-weight: 600;
    }

    .tile-details-footnote {
      font-size: 0.8rem;
      color: #6b7280;
      margin: 0.75rem 0 0 0;
      font-style: italic;
      line-height: 1.5;
    }

    /* Insights card styling */
    /* Side-by-side container for insights and visibility cards - 50% each */
    .ranking-cards-side-by-side {
      display: flex !important;
      flex-direction: row !important;
      gap: 1.5rem;
      margin: 1.5rem 0;
      align-items: flex-start;
      flex-wrap: wrap !important;
      width: 100%;
      overflow: visible;
    }

    .ranking-cards-side-by-side > *:first-child,
    .ranking-cards-side-by-side > *:nth-child(2) {
      flex: 0 0 calc(50% - 0.75rem) !important;
      min-width: 0;
      max-width: calc(50% - 0.75rem) !important;
      width: calc(50% - 0.75rem) !important;
      display: block !important;
    }

    /* Force all other children to be full width and on new rows */
    .ranking-cards-side-by-side > *:nth-child(n+3) {
      flex: 0 0 100% !important;
      width: 100% !important;
      max-width: 100% !important;
      clear: both !important;
      display: block !important;
      margin-top: 1.5rem;
    }

    .ranking-visibility-metrics-section {
      display: block !important;
    }

    /* Ensure sections after side-by-side cards are full width and stacked on new row */
    .ranking-cards-side-by-side ~ .ranking-priority-matrix-section,
    .ranking-cards-side-by-side ~ .ranking-table-section {
      width: 100% !important;
      display: block !important;
      clear: both !important;
      flex: none !important;
      margin-left: 0 !important;
      margin-right: 0 !important;
      float: none !important;
      position: relative !important;
    }

    @media (max-width: 1024px) {
      .ranking-cards-side-by-side {
        flex-direction: column;
      }
    }

    .card--insights {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin: 0;
      padding: 1.25rem 1.5rem;
    }

    .card--insights h2 {
      font-weight: 600;
      color: #92400e;
      margin: 0 0 0.5rem 0;
      font-size: 0.95rem;
    }

    .card--insights .card-subtitle {
      font-weight: 400;
      color: #78350f;
      margin: 0 0 1rem 0;
      font-size: 0.8rem;
      line-height: 1.5;
    }

    .card-pill-container {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .card-pill {
      background: #fffbeb;
      border: 1px solid #fde68a;
      border-radius: 6px;
      padding: 0.875rem;
      margin-bottom: 0.75rem;
    }

    .card-pill p {
      margin: 0;
      font-size: 0.8rem;
      line-height: 1.5;
      color: #78350f;
    }

    .card-pill strong {
      color: #92400e;
      font-weight: 600;
    }

    /* Visibility metrics card styling */
    .ranking-visibility-metrics-section .card {
      padding: 1.25rem 1.5rem;
    }

    .ranking-visibility-metrics-section h4 {
      font-size: 0.95rem !important;
      font-weight: 600 !important;
      margin-bottom: 0.5rem !important;
    }

    .ranking-visibility-metrics-section p,
    .ranking-visibility-metrics-section ul,
    .ranking-visibility-metrics-section li {
      font-size: 0.8rem !important;
    }

    .ranking-visibility-metrics-section strong {
      font-weight: 600 !important;
    }

    /* Section C: Filters */
    .ranking-filters-section {
      margin-bottom: 1rem;
      background: rgba(204, 255, 255, 0.15) !important;
      border-left: 4px solid #CCFFFF !important;
      border-radius: 8px;
      padding: 1rem 1.25rem;
      font-size: 0.75rem !important;
    }

    .ranking-filter-bar {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 0.75rem 1rem;
      align-items: end;
      padding: 0;
      background: transparent;
    }

    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 0.375rem;
      min-width: 0;
    }

    .filter-group label {
      font-size: 0.65rem !important;
      font-weight: 600;
      color: #374151;
      white-space: nowrap;
      margin: 0;
      line-height: 1.2;
    }

    .filter-control {
      padding: 0.35rem 0.55rem;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.85rem !important;
      background: #ffffff;
      width: 100%;
      min-width: 110px;
      transition: all 0.2s ease;
    }
    
    .filter-control option {
      font-size: 0.85rem;
    }

    /* Active filter state - when value is not "all" */
    .filter-control.filter-active {
      background: #eff6ff !important;
      border-color: #3b82f6 !important;
      color: #1e40af !important;
      font-weight: 600;
    }

    .filter-control:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.15);
    }

    #ranking-filter-keyword {
      min-width: 300px;
    }

    /* Search filter group should be wider */
    .filter-group-search {
      grid-column: span 2;
      min-width: 300px;
    }

    /* Clear filters button */
    #ranking-filter-clear {
      font-size: 0.7rem !important;
      padding: 0.4rem 0.75rem;
      align-self: end;
    }

    /* Keyword Priority Matrix section - full width, stacked layout */
    .ranking-priority-matrix-section {
      width: 100% !important;
      clear: both !important;
      display: block !important;
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
      flex: none !important;
      flex-basis: 100% !important;
      max-width: 100% !important;
      float: none !important;
      position: relative !important;
      box-sizing: border-box !important;
      order: 999 !important;
    }

    /* Section C: Table section - separate card */
    .ranking-table-section {
      margin: 2rem 0;
      width: 100% !important;
      clear: both !important;
      display: block !important;
      flex: none !important;
      max-width: 100% !important;
      float: none !important;
      position: relative !important;
      box-sizing: border-box !important;
      background: rgba(204, 255, 255, 0.2) !important;
      border-left: 4px solid #CCFFFF !important;
      border-radius: 8px;
      padding: 1.5rem;
      font-size: 14pt !important;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .ranking-table-section .card {
      background: transparent;
      box-shadow: none;
      padding: 0;
    }
    
    /* Apply 14pt to section elements but exclude table */
    .ranking-table-section .card-header,
    .ranking-table-section .card-subtitle,
    .ranking-table-section .filter-group,
    .ranking-table-section .filter-control,
    .ranking-table-section .btn {
      font-size: 14pt !important;
    }
    
    /* Table font size - must come after to override any universal selectors */
    .ranking-table-section .ranking-table,
    .ranking-table-section .ranking-table th,
    .ranking-table-section .ranking-table td,
    .ranking-table-section .ranking-table-wrapper .ranking-table,
    .ranking-table-section .ranking-table-wrapper .ranking-table th,
    .ranking-table-section .ranking-table-wrapper .ranking-table td {
      font-size: 0.875rem !important;
    }
    
    /* Pagination controls */
    .ranking-pagination-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #e5e7eb;
      flex-wrap: wrap;
      gap: 1rem;
    }
    
    .ranking-pagination-info {
      font-size: 14pt !important;
      color: #374151;
    }
    
    .ranking-pagination-buttons {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    
    .ranking-pagination-buttons button {
      padding: 0.5rem 1rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      background: #ffffff;
      font-size: 14pt !important;
      cursor: pointer;
      color: #374151;
    }
    
    .ranking-pagination-buttons button:hover:not(:disabled) {
      background: #f3f4f6;
      border-color: #9ca3af;
    }
    
    .ranking-pagination-buttons button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .ranking-rows-per-page {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .ranking-rows-per-page label {
      font-size: 14pt !important;
      color: #374151;
      white-space: nowrap;
    }
    
    .ranking-rows-per-page select {
      padding: 0.5rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 14pt !important;
      background: #ffffff;
    }

    /* Section D: Details grid - three columns (33% each) */
    .ranking-details-grid {
      display: grid !important;
      grid-template-columns: repeat(3, 1fr) !important;
      gap: 1rem;
      margin-top: 2rem;
      background: rgba(204, 255, 255, 0.15) !important;
      border-left: 4px solid #CCFFFF !important;
      border-radius: 8px;
      padding: 1.5rem;
    }
    
    .ranking-details-grid .card {
      min-width: 0;
      overflow: hidden;
    }
    
    .ranking-details-grid table {
      width: 100%;
      table-layout: fixed;
      font-size: 0.8rem;
    }
    
    .ranking-details-grid table th,
    .ranking-details-grid table td {
      padding: 0.5rem 0.4rem;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    .ranking-details-grid table th:first-child,
    .ranking-details-grid table td:first-child {
      width: 35%;
      max-width: 35%;
    }
    
    .ranking-details-grid table th:nth-child(2),
    .ranking-details-grid table td:nth-child(2) {
      width: 15%;
      max-width: 15%;
    }
    
    .ranking-details-grid table th:nth-child(3),
    .ranking-details-grid table td:nth-child(3) {
      width: 20%;
      max-width: 20%;
    }
    
    .ranking-details-grid table th:nth-child(4),
    .ranking-details-grid table td:nth-child(4) {
      width: 20%;
      max-width: 20%;
    }
    
    .ranking-details-grid table th:nth-child(5),
    .ranking-details-grid table td:nth-child(5) {
      width: 10%;
      max-width: 10%;
    }

    .ranking-details-grid .card {
      background: #ffffff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 0;
      margin-bottom: 0.75rem;
      border-radius: 6px;
      border: 1px solid #e5e7eb;
    }

    .ranking-details-grid .card:last-child {
      margin-bottom: 0;
    }

    /* Card header and body padding for consistent spacing */
    .ranking-details-grid .card-header {
      padding: 1.25rem 1.25rem 0.75rem 1.25rem;
    }

    .ranking-details-grid .card-body,
    .ranking-details-grid .ranking-ai-detail-body {
      padding: 0 1.25rem 1.25rem 1.25rem;
      font-size: 0.95rem;
      font-weight: 400;
      color: #1e293b;
      line-height: 1.6;
    }

    /* Typography hierarchy for cards */
    .ranking-details-grid .card-header h3 {
      font-size: 1.25rem;
      font-weight: 700;
      color: #1e293b;
      margin: 0 0 0.5rem 0;
      line-height: 1.4;
    }

    .ranking-details-grid .card-header h2 {
      font-size: 1.1rem;
      font-weight: 600;
      color: #374151;
      margin: 0 0 0.5rem 0;
      line-height: 1.4;
    }

    .ranking-details-grid .card-header p,
    .ranking-details-grid .card-subtitle {
      font-size: 0.9rem;
      font-weight: 400;
      color: #64748b;
      line-height: 1.5;
      margin: 0;
    }

    .ranking-details-grid .card-header h5 {
      font-size: 1rem;
      font-weight: 600;
      color: #374151;
      margin: 1rem 0 0.5rem 0;
    }

    /* List padding to match card body */
    .ranking-details-grid .ranking-ai-detail-list {
      padding: 0 1.25rem 1.25rem 1.25rem;
      margin: 0;
    }

    @media (max-width: 1200px) {
      .ranking-details-grid {
        grid-template-columns: 1fr;
      }
    }


    .ranking-table-wrapper {
      max-height: 540px;
      overflow: auto;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
    }

    .ranking-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.875rem !important;
    }

    /* Table header styling */
    .ranking-table th {
      text-align: center !important;
      vertical-align: middle;
      position: relative;
    }

    .ranking-table th > div:first-child {
      font-weight: 700 !important;
      text-align: center;
      margin-bottom: 0.25rem;
    }

    .ranking-table th > div:last-child {
      text-align: center !important;
      color: #2563eb !important;
      opacity: 1 !important;
    }

    .ranking-table th .sort-indicator {
      color: #1e40af !important;
      font-weight: 700 !important;
      margin-left: 0.25rem;
      opacity: 1 !important;
    }

    .ranking-table th.sortable {
      cursor: pointer;
    }

    .ranking-table th.sortable:hover {
      background-color: #f3f4f6;
    }

    /* Dynamic column widths - adjust based on content */
    .ranking-table {
      table-layout: auto;
      width: 100%;
    }

    .ranking-table th,
    .ranking-table td {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #e5e7eb;
      text-align: center;
      font-size: 0.875rem !important;
    }

    .ranking-table th {
      position: sticky;
      top: 0;
      background: #f3f4f6;
      z-index: 10;
      font-weight: 600;
      font-size: 0.875rem !important;
      vertical-align: top;
    }

    .ranking-table th > div:first-child {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
    }

    .ranking-table th.sortable {
      cursor: pointer;
      user-select: none;
      position: sticky;
      top: 0;
    }

    .ranking-table th.sortable:hover {
      background: #e5e7eb;
      position: sticky;
      top: 0;
    }

    .sort-indicator {
      display: inline-block;
      margin-left: 0.25rem;
      font-size: 0.85rem;
      opacity: 0.5;
    }

    .sort-indicator::after {
      content: "";
    }

    .ranking-table th.sort-asc .sort-indicator::after {
      content: "";
      opacity: 1;
    }

    .ranking-table th.sort-desc .sort-indicator::after {
      content: "";
      opacity: 1;
    }

    .ranking-table tr:nth-child(even) td {
      background: #f9fafb;
    }

    .ranking-table tr:hover {
      cursor: pointer;
    }

    .ranking-table-row--selected td {
      background: #eef2ff !important;
    }

    .ranking-row-good td {
      box-shadow: inset 3px 0 0 #16a34a;
    }

    .ranking-row-ok td {
      box-shadow: inset 3px 0 0 #f59e0b;
    }

    .ranking-row-weak td {
      box-shadow: inset 3px 0 0 #dc2626;
    }

    .ranking-table-empty {
      text-align: center;
      padding: 1rem;
      color: #6b7280;
    }


    .ranking-subtitle-tight {
      font-size: 0.875rem !important;
      max-width: 48rem;
    }

    /* RAG badges in table */
    .ranking-badge-rank {
      display: inline-flex;
      align-items: center;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .ranking-badge-rank--good {
      background: #dcfce7;
      color: #166534;
    }

    .ranking-badge-rank--ok {
      background: #fef3c7;
      color: #92400e;
    }

    .ranking-badge-rank--weak {
      background: #fee2e2;
      color: #b91c1c;
    }

    .ranking-badge-volume {
      display: inline-flex;
      align-items: center;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }
    
    .ranking-badge-volume--high {
      background: #dcfce7;
      color: #166534;
    }
    
    .ranking-badge-volume--med {
      background: #fef3c7;
      color: #92400e;
    }
    
    .ranking-badge-volume--low {
      background: #fee2e2;
      color: #b91c1c;
    }
    
    .ranking-badge-volume--none {
      background: #f3f4f6;
      color: #6b7280;
    }

    .ranking-badge-citation {
      display: inline-flex;
      align-items: center;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .ranking-badge-citation--good {
      background: #dcfce7;
      color: #166534;
    }

    .ranking-badge-citation--weak {
      background: #fee2e2;
      color: #b91c1c;
    }

    .ranking-ai-detail-body {
      padding: 1rem 0;
    }

    .ranking-ai-detail-content {
      /* Make scorecard stand out as separate object */
      margin: 0.75rem 0;
      padding: 1.5rem 1.5rem;
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      border-top: 1px solid #e5e7eb;
      border-right: 1px solid #e5e7eb;
      border-bottom: 1px solid #e5e7eb;
      /* Left border will be set dynamically based on priority */
    }

    .ranking-ai-detail-content.scorecard-priority-high {
      border-left: 6px solid #ef4444; /* Red for High priority */
      background: #fef2f2;
    }

    .ranking-ai-detail-content.scorecard-priority-medium {
      border-left: 6px solid #f59e0b; /* Amber for Medium priority */
      background: #fffbeb;
    }

    .ranking-ai-detail-content.scorecard-priority-low {
      border-left: 6px solid #10b981; /* Green for Low priority */
      background: #f0fdf4;
    }

    .ranking-ai-detail-content h4 {
      margin: 0 0 0.5rem 0;
      font-size: 1.25rem;
      font-weight: 700;
      color: #1e293b;
    }

    .ranking-ai-detail-content h5 {
      margin: 1rem 0 0.5rem 0;
      font-size: 1rem;
      font-weight: 600;
      color: #374151;
    }

    /* Section breaks for scorecard components */
    .ranking-ai-detail-content .scorecard-section {
      padding: 1rem 1.25rem;
      margin-bottom: 1.0rem !important;
      background: #f5f5f5;
      border-left: 3px solid #cbd5e1;
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .ranking-ai-detail-content .scorecard-section:last-child {
      margin-bottom: 0 !important;
    }

    .ranking-ai-detail-list {
      list-style: none;
      padding-left: 0;
      margin: 0.5rem 0 0;
    }

    .ranking-ai-detail-list li {
      margin-bottom: 0.4rem;
      padding: 0.5rem 0.75rem;
      background: #f9fafb;
      border-radius: 4px;
      font-size: 0.95rem;
    }

    .ranking-ai-detail-list li a {
      color: #2563eb;
      text-decoration: none;
    }

    .ranking-ai-detail-list li a:hover {
      text-decoration: underline;
    }

    .ranking-ai-last-run {
      margin-left: 0.75rem;
      font-size: 0.95rem;
      color: #6b7280;
    }

    .ranking-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 500;
    }

    .ranking-badge--ai-on { background: #ecfdf5; color: #059669; }
    .ranking-badge--ai-off { background: #f9fafb; color: #6b7280; }
    .ranking-badge--cited { background: #eff6ff; color: #1d4ed8; }
    .ranking-badge--not-cited { background: #fef2f2; color: #b91c1c; }
    .ranking-badge--segment-money { background: #fef3c7; color: #92400e; }
    .ranking-badge--segment-education { background: #e0f2fe; color: #075985; }
    .ranking-badge--segment-brand { background: #f5f3ff; color: #6d28d9; }
    .ranking-badge--segment-general { background: #f9fafb; color: #4b5563; }
    .ranking-badge--rank-good { background: #dcfce7; color: #166534; }
    .ranking-badge--rank-mid { background: #fef3c7; color: #92400e; }
    .ranking-badge--rank-weak { background: #fee2e2; color: #b91c1c; }
    
    /* Demand share styling */
    .ranking-badge-demand-share--high { color: #059669; font-weight: 600; }
    .ranking-badge-demand-share--med { color: #d97706; font-weight: 500; }
    .ranking-badge-demand-share--low { color: #6b7280; font-weight: 400; }
    .ranking-badge-demand-share--none { color: #9ca3af; }
    
    /* Opportunity score styling (RAG colors matching Money Pages priority matrix) */
    .ranking-badge-opportunity {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.9rem;
      font-weight: 600;
    }
    .ranking-badge-opportunity--high { background: #dcfce7; color: #166534; } /* Green - High */
    .ranking-badge-opportunity--medium { background: #fef3c7; color: #92400e; } /* Amber - Medium */
    .ranking-badge-opportunity--low { background: #fee2e2; color: #b91c1c; } /* Red - Low */
    
    /* Page type badge styling (matching Money Pages matrix) */
    .ranking-badge-page-type {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 500;
    }
    .ranking-badge-page-type--landing { background: #fef3c7; color: #92400e; }
    .ranking-badge-page-type--event { background: #dbeafe; color: #1e40af; }
    .ranking-badge-page-type--product { background: #fce7f3; color: #9f1239; }
    .ranking-badge-page-type--blog { background: #e0f2fe; color: #075985; }
    .ranking-badge-page-type--gbp { background: #f5f3ff; color: #6d28d9; }

    /* Money Pages KPI trend arrow colors */
    .kpi-trend-up { color: #10b981; font-weight: 700; }
    .kpi-trend-down { color: #ef4444; font-weight: 700; }
    .kpi-trend-flat { color: #64748b; font-weight: 700; }

    /* Domain Strength (Ranking & AI) */
    .domain-strength-badge {
      display: inline-flex;
      padding: 0.125rem 0.375rem !important;
      font-size: 0.65rem !important;
      line-height: 1.2 !important;
      align-items: center;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 600;
      white-space: nowrap;
    }
    .domain-strength-badge--very-strong { background: #dcfce7; color: #166534; }
    .domain-strength-badge--strong { background: #ecfdf5; color: #059669; }
    .domain-strength-badge--moderate { background: #fef3c7; color: #92400e; }
    .domain-strength-badge--weak { background: #fde68a; color: #92400e; }
    .domain-strength-badge--very-weak { background: #fee2e2; color: #b91c1c; }
    .domain-strength-badge--na { background: #f9fafb; color: #6b7280; }

    .domain-strength-summary-row {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      align-items: stretch;
      margin-top: 1rem;
    }
    .domain-strength-summary-card {
      flex: 1 1 280px;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 1rem 1.25rem;
      min-width: 280px;
    }
    .domain-strength-summary-top {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .domain-strength-summary-score {
      font-size: 2rem;
      font-weight: 800;
      letter-spacing: -0.02em;
      color: #0f172a;
      line-height: 1;
    }
    .domain-strength-summary-subtitle {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #64748b;
      line-height: 1.45;
    }
    .domain-strength-legend {
      flex: 1 1 320px;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      align-content: flex-start;
      padding: 1rem 1.25rem;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      min-width: 280px;
    }
    .domain-strength-help {
      margin-left: 0.4rem;
      opacity: 0.7;
      cursor: help;
      font-size: 0.95rem;
      border: 1px solid rgba(100, 116, 139, 0.35);
      border-radius: 999px;
      width: 20px;
      height: 20px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      background: rgba(248, 250, 252, 0.8);
    }
    .domain-strength-sparkline {
      display: inline-block;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>GAIO (Generative AI Optimization) Audit Dashboard</h1>
    <p>Automated GAIO Performance Tracking & Optimisation</p>
    <p style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 1; background: rgba(0,0,0,0.3); padding: 0.25rem 0.5rem; border-radius: 4px; display: inline-block;">
      <strong>Version: <span id="gitVersion">37685db</span></strong> | Built: <span id="buildDate"></span> | 
      <span id="loadTime" style="color: #4f4;">Loaded: <span id="loadTimeValue"></span></span>
    </p>
    <script>
      // Set build date to today in GMT
      const now = new Date();
      const gmtDate = now.toISOString().split('T')[0]; // YYYY-MM-DD
      const gmtTime = now.toISOString().split('T')[1].split('.')[0]; // HH:MM:SS
      document.getElementById('buildDate').textContent = gmtDate + ' ' + gmtTime + ' GMT';
      document.getElementById('loadTimeValue').textContent = now.toLocaleTimeString();
    </script>
  </div>

  <div class="aigeo-layout">
    <aside class="aigeo-sidebar">
      <button class="aigeo-nav-item" data-panel="config">
        <span class="aigeo-nav-icon"></span>
        <span>Configuration & Reporting</span>
      </button>
      <button class="aigeo-nav-item is-active" data-panel="overview">
        <span class="aigeo-nav-icon"></span>
        <span>Overview</span>
      </button>
      <button class="aigeo-nav-item" data-panel="portfolio">
        <span class="aigeo-nav-icon"></span>
        <span>Portfolio</span>
      </button>
      <button class="aigeo-nav-item" data-panel="authority">
        <span class="aigeo-nav-icon"></span>
        <span>Authority</span>
      </button>
      <button class="aigeo-nav-item" data-panel="money">
        <span class="aigeo-nav-icon"></span>
        <span>Money Pages</span>
      </button>
      <button class="aigeo-nav-item" data-panel="ranking">
        <span class="aigeo-nav-icon"></span>
        <span>Ranking & AI</span>
      </button>
      <button class="aigeo-nav-item" data-panel="optimisation">
        <span class="aigeo-nav-icon"></span>
        <span>Optimisation Tracking</span>
      </button>
      <button class="aigeo-nav-item" data-panel="ai-sources">
        <span class="aigeo-nav-icon"></span>
        <span>AI Sources & Influence</span>
      </button>
      <button class="aigeo-nav-item" data-panel="local">
        <span class="aigeo-nav-icon"></span>
        <span>Local & Reviews</span>
      </button>
      <button class="aigeo-nav-item" data-panel="history">
        <span class="aigeo-nav-icon"></span>
        <span>History</span>
      </button>
    </aside>
    <main class="aigeo-main">
  <div class="container">

    <div class="status" id="status"></div>

    <div class="loading" id="loading">
      <div class="progress-container">
        <div class="spinner"></div>
        <div class="progress-bar-wrapper">
          <div class="progress-bar" id="progressBar" style="width: 0%;">0%</div>
        </div>
        <div class="progress-status" id="progressStatus">Initializing audit scan...</div>
      </div>
    </div>

    <!-- Completion Summary Modal -->
    <div id="completionModal" class="modal" style="display: none;">
      <div class="modal-content" style="max-width: 600px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Audit Complete</h2>
          <button onclick="closeCompletionModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;" title="Close the audit completion summary modal">&times;</button>
        </div>
        <div id="completionSummaryContent"></div>
        <div style="margin-top: 1.5rem; text-align: right;">
          <button class="btn" onclick="closeCompletionModal()" style="background: var(--brand-orange); color: white; border-color: var(--brand-orange);" title="Close the audit completion summary modal and return to the dashboard">Close</button>
        </div>
      </div>
    </div>

    <!-- Bulk Update Results Modal -->
    <div id="optimisation-bulk-update-results-modal" class="modal" style="display: none;">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Bulk Update Complete</h2>
          <button onclick="closeBulkUpdateResultsModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;" title="Close">&times;</button>
        </div>
        <div id="bulk-update-results-content">
          <!-- Content will be populated by JavaScript -->
        </div>
        <div style="margin-top: 1.5rem; text-align: right;">
          <button class="btn" onclick="closeBulkUpdateResultsModal()" style="background: var(--brand-orange); color: white; border-color: var(--brand-orange);">Close</button>
        </div>
      </div>
    </div>

    <!-- Ranking & AI Progress Modal -->
    <div id="rankingAiProgressModal" class="modal" style="display: none;">
      <div class="modal-content" style="max-width: 700px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Running Ranking & AI Check</h2>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <button id="rankingAiProgressStop" style="display: none; padding: 0.5rem 1rem; background: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 600;" title="Stop the scan">Stop Scan</button>
            <button id="rankingAiProgressClose" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666; opacity: 0.5;" disabled title="Cannot close during processing">&times;</button>
          </div>
        </div>
        
        <!-- Keyword Count Display (shown before scan starts) -->
        <div id="rankingAiKeywordCount" style="display: none; margin-bottom: 1rem; padding: 1rem; background: #fef3c7; border: 1px solid #fbbf24; border-radius: 6px;">
          <div style="font-weight: 600; color: #92400e; margin-bottom: 0.5rem;">Ready to scan:</div>
          <div style="font-size: 1.2rem; font-weight: 700; color: #78350f;" id="rankingAiKeywordCountValue">0 keywords</div>
          <div style="font-size: 0.85rem; color: #78350f; margin-top: 0.5rem;">Click "Start Scan" below to begin, or close this modal to cancel.</div>
        </div>
        
        <!-- Progress Bar -->
        <div style="margin-bottom: 2rem;">
          <div id="rankingAiProgressBar" style="width: 100%; height: 24px; background-color: #e5e7eb; border-radius: 12px; overflow: hidden; position: relative;">
            <div id="rankingAiProgressFill" style="width: 0%; height: 100%; background: linear-gradient(90deg, var(--brand-orange), #ff8c42); transition: width 0.3s ease; border-radius: 12px;"></div>
          </div>
          <div id="rankingAiProgressText" style="margin-top: 0.5rem; text-align: center; font-size: 0.9rem; color: #6b7280; font-weight: 500;">0%</div>
        </div>

        <!-- Step Details -->
        <div id="rankingAiStepDetails" style="margin-bottom: 1.5rem;">
          <div id="rankingAiCurrentStep" style="font-size: 1.1rem; font-weight: 600; color: #1f2937; margin-bottom: 0.75rem;">
            Initializing...
          </div>
          <div id="rankingAiStepNarrative" style="font-size: 0.95rem; color: #6b7280; line-height: 1.6; margin-bottom: 1rem;">
            Preparing to fetch ranking and AI data...
          </div>
          <div id="rankingAiStepCounts" style="font-size: 0.9rem; color: #9ca3af; font-style: italic;">
            <!-- Counts will be populated here -->
          </div>
        </div>

        <!-- Step List -->
        <div style="border-top: 1px solid #e5e7eb; padding-top: 1rem;">
          <div style="font-size: 0.85rem; font-weight: 600; color: #6b7280; margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Progress Steps</div>
          <div id="rankingAiStepsList" style="display: flex; flex-direction: column; gap: 0.5rem;">
            <!-- Steps will be populated here -->
          </div>
        </div>

        <!-- Completion Summary (hidden by default) -->
        <div id="rankingAiSummary" style="display: none; border-top: 2px solid #10b981; padding-top: 1.5rem; margin-top: 1.5rem;">
          <h3 style="margin: 0 0 1rem 0; color: #10b981; font-size: 1.2rem; font-weight: 600;"> Scan Complete</h3>
          <div id="rankingAiSummaryContent" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; font-size: 0.95rem;">
            <!-- Summary content will be populated here -->
          </div>
        </div>
      </div>
    </div>

    <div id="dashboard" style="display: none;">
      <div id="auditTimestamp" style="background: #e8f5e9; padding: 0.75rem 1rem; border-radius: 6px; margin-bottom: 1rem; border-left: 4px solid #10b981; font-size: 0.9rem; color: #555;">
        <strong>Last Audit:</strong> <span id="lastAuditTime">Not yet run</span>
      </div>

      <!-- Configuration & Reporting Panel -->
      <section class="aigeo-panel" data-panel="config">
    <div class="config-panel">
      <h2>Configuration</h2>
      <div class="info-box" style="background: #e8f4f8; border-left: 4px solid #2196F3; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #1565C0;"><strong>Entity-Level Audit:</strong> This dashboard analyzes <strong>www.alanranger.com</strong> as a global entity, tracking AI-powered search visibility, entity recognition, and SERP behavior across the entire domain.</p>
      </div>
      <div class="form-group">
        <label for="propertyUrl">Property URL</label>
        <input type="text" id="propertyUrl" placeholder="https://yourwebsite.com" value="https://www.alanranger.com">
        <div class="help-text">The domain being audited (entity-level analysis)</div>
      </div>
      <div style="background: #f0f0f0; padding: 0.75rem; border-radius: 4px; margin-bottom: 1rem; font-size: 0.85rem; color: #555;">
        <strong>API Key:</strong> Loaded automatically from Vercel environment variables. No manual entry required.
      </div>
      <!-- Manual URL List Section (Collapsible) -->
      <div class="csv-upload-section collapsed" id="urlListSection">
        <div class="csv-section-header" onclick="toggleCsvSection('urlListSection')">
          <h3>Manual URL List (Optional)</h3>
          <span class="csv-section-toggle" id="urlListToggle"></span>
        </div>
        <div class="csv-section-content collapsed" id="urlListContent">
          <div class="form-group" style="margin-bottom: 0;">
        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">
          Load list of site URLs from a CSV file
        </div>
        <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
          <input type="file" id="urlListFile" accept=".csv" style="flex: 1; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem;">
              <button class="btn btn-small" onclick="loadUrlListFromFile()" style="padding: 0.5rem 1rem;" title="Load a CSV file containing site URLs. The CSV must have a 'url' column in the header row. URLs will be used for schema audit instead of the default CSV source.">Load CSV</button>
              <button class="btn btn-small" onclick="clearManualUrlList()" style="padding: 0.5rem 1rem; background: #ef4444; color: white; border-color: #ef4444;" title="Clear the manually loaded URL list and revert to using the default CSV source for schema audit">Clear</button>
        </div>
        <textarea id="manualUrlList" placeholder="Or paste CSV content here (must include 'url' column in header row)..." style="width: 100%; min-height: 100px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace; resize: vertical;"></textarea>
        <div class="help-text">
          <strong>Required column:</strong> <code>url</code> (case-insensitive). CSV must have a header row. URLs will be extracted from the 'url' column.
        </div>
        <div id="urlListStatus" style="margin-top: 0.5rem; font-size: 0.85rem;"></div>
          </div>
        </div>
      </div>
      
      <!-- Backlink CSV Upload Section (Collapsible) -->
      <div class="csv-upload-section collapsed" id="backlinkCsvSection">
        <div class="csv-section-header" onclick="toggleCsvSection('backlinkCsvSection')">
          <h3>Backlink CSV Upload (Optional)</h3>
          <span class="csv-section-toggle" id="backlinkCsvToggle"></span>
        </div>
        <div class="csv-section-content collapsed" id="backlinkCsvContentWrapper">
          <div class="form-group" style="margin-bottom: 0;">
            <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">
              Upload backlink data CSV file for Authority score calculation. Can be uploaded independently of site URLs CSV.
            </div>
            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
              <input type="file" id="backlinkCsvFile" accept=".csv" style="flex: 1; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem;">
                  <button class="btn btn-small" onclick="loadBacklinkCsvFromFile()" style="padding: 0.5rem 1rem;" title="Load a CSV file containing backlink data. The CSV must have 'source_url' and 'target_url' columns in the header row. Backlinks will be used for Authority score calculation.">Load CSV</button>
                  <button class="btn btn-small" onclick="clearBacklinkCsv()" style="padding: 0.5rem 1rem; background: #ef4444; color: white; border-color: #ef4444;" title="Clear the backlink CSV data">Clear</button>
            </div>
                <textarea id="backlinkCsvContent" placeholder="Or paste CSV content here (must include 'source_url' and 'target_url' columns in header row)..." style="width: 100%; min-height: 100px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace; resize: vertical;"></textarea>
            <div class="help-text">
                  <strong>Required columns:</strong> <code>source_url</code> and <code>target_url</code> (case-insensitive). CSV must have a header row. Backlinks will be extracted from these columns.
            </div>
            <div id="backlinkCsvStatus" style="margin-top: 0.5rem; font-size: 0.85rem;"></div>
          </div>
        </div>
      </div>
          
          <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-top: 1.5rem;">
        <button class="btn" onclick="runAudit()" title="Start a comprehensive audit scan. Fetches Google Search Console data, performs schema audit (if site URLs CSV loaded), and uses backlink data (if backlink CSV uploaded). Results will appear in the dashboard below.">Run Audit Scan</button>
            <button class="btn btn-secondary" onclick="shareAudit()" title="Generate a shareable link to your current audit results. The link will allow others to view your audit data without running a new scan.">Share Audit</button>
        <button class="btn btn-secondary" onclick="saveConfig()" title="Save your current configuration (property URL and date range) to browser localStorage. Settings will be restored when you reload the page.">Save Configuration</button>
            <button class="btn btn-success" onclick="syncCsv()" title="Sync CSV data from the configured source. This will update your URL list and backlink data from the remote CSV file.">Sync CSV</button>
      </div>
    </div>

    <!-- Share Mode Banner (read-only) -->
    <div id="share-mode-banner" class="config-panel" style="margin-top: 2rem; display: none; background: #fef3c7; border-left: 4px solid #f59e0b; padding: 1rem; border-radius: 4px;">
      <div style="display: flex; align-items: center; gap: 0.5rem;">
        <span style="font-size: 1.25rem;"></span>
        <strong style="color: #92400e;">Shared view (read-only)</strong>
        <span style="color: #92400e; font-size: 0.9rem;"> You can view all data but cannot make changes</span>
      </div>
    </div>

    <!-- Admin Key Configuration (Phase A - Security) -->
    <div id="admin-key-panel" class="config-panel" style="margin-top: 2rem;">
      <h2>Optimisation Tracking Security</h2>
      <div class="info-box" style="background: #e0f2fe; border-left: 4px solid #0284c7; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #0c4a6e;">
          <strong>Admin Key Required:</strong> Set your admin key to enable optimisation tracking actions (Track, Manage, Cycle). 
          The key is stored in your browser session and sent with API requests.
        </p>
      </div>
      <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-bottom: 1rem;">
        <input 
          type="password" 
          id="admin-key-input" 
          placeholder="Enter admin key (32+ characters)" 
          style="flex: 1; min-width: 300px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace;"
          value=""
        />
        <button 
          class="btn" 
          onclick="saveAdminKey()" 
          title="Save admin key to session storage. Required for optimisation tracking actions."
        >
          Save Admin Key
        </button>
        <button 
          class="btn btn-secondary" 
          onclick="clearAdminKeyUI()" 
          title="Clear admin key from session storage."
        >
          Clear
        </button>
      </div>
      <div id="admin-key-status" style="font-size: 0.85rem; color: #64748b; margin-top: 0.5rem;"></div>
      <script>
        // Share mode initialization
        (function() {
          const urlParams = new URLSearchParams(window.location.search);
          const isShare = urlParams.get('share') === '1';
          const shareToken = urlParams.get('st') || '';
          
          if (isShare) {
            // Hide admin key panel
            const adminPanel = document.getElementById('admin-key-panel');
            if (adminPanel) adminPanel.style.display = 'none';
            
            // Show share mode banner
            const shareBanner = document.getElementById('share-mode-banner');
            if (shareBanner) shareBanner.style.display = 'block';
            
            // Disable write buttons
            window.addEventListener('DOMContentLoaded', function() {
              // Disable audit scan, sync CSV, save config buttons
              const writeButtons = document.querySelectorAll('[onclick="runAudit()"], [onclick="syncCsv()"], [onclick="saveConfig()"]');
              writeButtons.forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
                btn.title = 'Not available in share mode (read-only)';
              });
              
              // Disable Optimisation Tracking write buttons
              const bulkUpdateBtn = document.getElementById('optimisation-bulk-update-btn');
              if (bulkUpdateBtn) {
                bulkUpdateBtn.disabled = true;
                bulkUpdateBtn.style.opacity = '0.5';
                bulkUpdateBtn.style.cursor = 'not-allowed';
                bulkUpdateBtn.title = 'Not available in share mode (read-only)';
              }
            });
          }
        })();
        
        // Admin key UI functions
        function saveAdminKey() {
          const input = document.getElementById('admin-key-input');
          const key = input.value.trim();
          if (!key) {
            alert('Please enter an admin key');
            return;
          }
          if (key.length < 32) {
            if (!confirm('Admin key should be at least 32 characters. Save anyway?')) {
              return;
            }
          }
          window.setAdminKey(key);
          updateAdminKeyStatus();
          input.value = ''; // Clear input for security
          
          // Clear auth error and reload optimisation tasks if on that tab
          if (window.optimisationModuleState) {
            window.optimisationModuleState.authError = null;
            const optimisationTab = document.querySelector('[data-panel="optimisation"]');
            if (optimisationTab && optimisationTab.classList.contains('is-active')) {
              if (typeof window.loadAllOptimisationTasks === 'function') {
                window.loadAllOptimisationTasks();
              }
            }
          }
          
          // Re-render Ranking & AI table to enable Track buttons
          // Check if Ranking & AI tab is active
          const rankingTab = document.querySelector('[data-panel="ranking"]');
          if (rankingTab && rankingTab.classList.contains('is-active')) {
            // Tab is active, try to refresh the table
            if (typeof renderRankingAiTab === 'function') {
              renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
            } else if (typeof window.renderRankingAiTab === 'function') {
              window.renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
            } else {
              // Fallback: reload the page
              if (confirm('Admin key saved! Refresh the page to enable Track buttons?')) {
                // Preserve current tab state before reload
                const currentPanel = document.querySelector('.aigeo-panel.is-active');
                if (currentPanel) {
                  const panelId = currentPanel.dataset.panel;
                  sessionStorage.setItem('activeTab', panelId);
                  window.location.hash = '#' + panelId;
                }
                location.reload();
              }
            }
          } else {
            alert('Admin key saved! Switch to the "Ranking & AI" tab to see enabled Track buttons.');
          }
        }

        function clearAdminKeyUI() {
          if (confirm('Clear admin key? Optimisation tracking actions will be disabled.')) {
            window.clearAdminKey();
            document.getElementById('admin-key-input').value = '';
            updateAdminKeyStatus();
            
            // Re-render Ranking & AI table to disable Track buttons
            const rankingTab = document.querySelector('[data-panel="ranking"]');
            if (rankingTab && rankingTab.classList.contains('is-active')) {
              if (typeof renderRankingAiTab === 'function') {
                renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
              } else if (typeof window.renderRankingAiTab === 'function') {
                window.renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
              }
            }
          }
        }

        function updateAdminKeyStatus() {
          const statusEl = document.getElementById('admin-key-status');
          if (!statusEl) return;
          
          // Safety check: ensure hasAdminKey function is loaded
          if (typeof window.hasAdminKey !== 'function') {
            // Retry after a short delay if function not yet loaded
            setTimeout(() => {
              if (typeof window.hasAdminKey === 'function') {
                updateAdminKeyStatus();
              } else {
                // If still not loaded after retry, show warning
                statusEl.innerHTML = '<span style="color: #f59e0b;"> Loading admin key functions...</span>';
                // Try one more time after longer delay
                setTimeout(() => {
                  if (typeof window.hasAdminKey === 'function') {
                    updateAdminKeyStatus();
                  } else {
                    statusEl.innerHTML = '<span style="color: #ef4444;"> Admin key functions not loaded  please refresh the page</span>';
                  }
                }, 1000);
              }
            }, 100);
            return;
          }
          
          const hasKey = window.hasAdminKey();
          if (hasKey) {
            const key = window.getAdminKey();
            statusEl.innerHTML = `<span style="color: #10b981;"> Admin key set</span> (${key.length} characters, stored in session)`;
          } else {
            statusEl.innerHTML = '<span style="color: #ef4444;"> Admin key not set  tracking actions disabled</span>';
          }
        }

        // Update status on load
        if (typeof window !== 'undefined' && document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', updateAdminKeyStatus);
        } else {
          updateAdminKeyStatus();
        }
      </script>
    </div>

    <div class="config-panel" style="margin-top: 2rem;">
      <h2>Reporting</h2>
      <div class="info-box" style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #856404;"><strong>Generate Reports:</strong> Create comprehensive PDF reports containing all audit data, charts, and pillar score definitions.</p>
      </div>
      <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
        <button class="btn" onclick="try { console.log('[PDF] Button clicked!'); generatePDFReport(); } catch(e) { console.error('[PDF] Error in onclick:', e); alert('Error generating PDF: ' + e.message); }" id="generatePdfBtn" style="background: #dc2626; color: white; border-color: #dc2626;" title="Generate a comprehensive PDF report containing all audit data, charts, pillar scores, definitions, and metrics. The report will include all sections from the dashboard.">
           Generate PDF Report
        </button>
        <div id="pdfStatus" style="font-size: 0.85rem; color: #666; margin-left: 0.5rem;"></div>
      </div>
    </div>
      </section>

      <!-- Authority Panel -->
      <section class="aigeo-panel" data-panel="authority">
        <!-- Authority - Behaviour & Ranking section will be inserted here by JS -->
      </section>

      <!-- Portfolio Panel -->
      <section class="aigeo-panel" data-panel="portfolio">
        <div class="portfolio-container" style="padding: 2rem;">
          <h1 style="margin-bottom: 2rem;">Portfolio Optimisation Trends</h1>
          
          <!-- Chart A: Median Delta Over Time -->
          <div class="portfolio-chart-section" style="margin-bottom: 3rem;">
            <div class="card" style="padding: 1.5rem;">
              <h2 style="margin-top: 0; margin-bottom: 1rem;" title="Median Delta Over Time: Shows the change (delta) in selected KPI between consecutive time periods. Each point shows how much the metric changed compared to the previous period.">Median Delta Over Time</h2>
              <p style="color: #666; margin-bottom: 1.5rem;" title="Shows the change (delta) in selected KPI over time. Each data point represents the difference between consecutive time periods (weekly or monthly). Positive values (above zero) indicate improvement, negative values indicate decline.">Portfolio movement over time using rolling 28d snapshots</p>
              
              <!-- Controls -->
              <div class="portfolio-controls" style="display: flex; gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap; align-items: center;">
                <div>
                  <label for="portfolio-kpi-select" style="display: block; margin-bottom: 0.25rem; font-weight: 600;" title="Key Performance Indicator: Select which metric to track over time">KPI:</label>
                  <select id="portfolio-kpi-select" style="padding: 0.5rem; min-width: 180px;">
                    <option value="ctr_28d" title="Click-Through Rate: Percentage of impressions that resulted in clicks (rolling 28 days)">CTR (28d)</option>
                    <option value="clicks_28d" title="Total clicks from Google Search (rolling 28 days)">Clicks (28d)</option>
                    <option value="impressions_28d" title="Total impressions in Google Search results (rolling 28 days)">Impressions (28d)</option>
                    <option value="avg_position" title="Average ranking position in Google Search results (lower is better)">Avg Position</option>
                    <option value="ai_citations" title="Total number of citations from your domain (alanranger.com) in Google AI Overviews">AI Citations</option>
                    <option value="ai_overview" title="Number of keywords that have an AI Overview present in search results">AI Overview</option>
                  </select>
                </div>
                <div>
                  <label for="portfolio-segment-select" style="display: block; margin-bottom: 0.25rem; font-weight: 600;" title="Page segment: Filter metrics by page type">Segment:</label>
                  <select id="portfolio-segment-select" style="padding: 0.5rem; min-width: 150px;">
                    <option value="all_tracked" title="All pages that have active optimisation tasks tracking them">All tracked</option>
                    <option value="money" title="All commercial pages: landing pages, event pages, and product pages combined">Money Pages</option>
                    <option value="landing" title="Landing pages: general commercial landing pages (not events or products)">Landing</option>
                    <option value="event" title="Event pages: photography workshop and course event pages">Event</option>
                    <option value="product" title="Product pages: photography service and product pages">Product</option>
                  </select>
                </div>
                <div>
                  <label for="portfolio-scope-toggle" style="display: block; margin-bottom: 0.25rem; font-weight: 600;" title="Data scope: Filter by optimisation task status">Scope:</label>
                  <select id="portfolio-scope-toggle" style="padding: 0.5rem; min-width: 150px;">
                    <option value="active_only" title="Only include pages with active optimisation task cycles (excludes completed, cancelled, or deleted tasks)">Active cycles only</option>
                    <option value="all" title="Include all pages in the segment, regardless of optimisation task status">All</option>
                  </select>
                </div>
                <div>
                  <label for="portfolio-time-grain" style="display: block; margin-bottom: 0.25rem; font-weight: 600;" title="Time aggregation: How to group data points on the chart">Time Grain:</label>
                  <select id="portfolio-time-grain" style="padding: 0.5rem; min-width: 120px;">
                    <option value="weekly" title="Group data by week: Shows the last snapshot from each week">Weekly</option>
                    <option value="monthly" title="Group data by month: Shows the last snapshot from each month">Monthly</option>
                  </select>
                </div>
                <div style="margin-top: 1.5rem;">
                  <button id="portfolio-diagnose-btn" onclick="diagnosePortfolioData()" style="padding: 0.5rem 1rem; background: #6366f1; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem;" title="Check database for portfolio segment metrics and position data"> Diagnose Data</button>
                </div>
              </div>
              
              <!-- Chart Canvas -->
              <div style="position: relative; height: 400px;">
                <canvas id="portfolio-delta-chart"></canvas>
              </div>
            </div>
          </div>
          
          <!-- Table B: Monthly KPI Tracker -->
          <div class="portfolio-table-section">
            <div class="card" style="padding: 1.5rem;">
              <h2 style="margin-top: 0; margin-bottom: 1rem;" title="Monthly KPI Tracker: View actual metric values (not deltas) for each segment across the last 12 months">Monthly KPI Tracker</h2>
              <p style="color: #666; margin-bottom: 1.5rem;" title="Shows the actual KPI value (not delta) for each segment across the last 12 months. Each cell shows the last snapshot from that month. The Trend column shows month-over-month change.">Executive summary by segment over time (rolling 12 months)</p>
              
              <!-- KPI Selector for Table -->
              <div style="margin-bottom: 1.5rem;">
                <label for="portfolio-table-kpi-select" style="display: block; margin-bottom: 0.25rem; font-weight: 600;" title="Key Performance Indicator: Select which metric to display in the monthly table">KPI:</label>
                <select id="portfolio-table-kpi-select" style="padding: 0.5rem; min-width: 180px;">
                  <option value="ctr_28d" title="Click-Through Rate: Percentage of impressions that resulted in clicks (rolling 28 days)">CTR (28d)</option>
                  <option value="clicks_28d" title="Total clicks from Google Search (rolling 28 days)">Clicks (28d)</option>
                  <option value="impressions_28d" title="Total impressions in Google Search results (rolling 28 days)">Impressions (28d)</option>
                  <option value="avg_position" title="Average ranking position in Google Search results (lower is better)">Avg Position</option>
                  <option value="ai_citations" title="Total number of citations from your domain (alanranger.com) in Google AI Overviews">AI Citations</option>
                  <option value="ai_overview" title="Number of keywords that have an AI Overview present in search results">AI Overview</option>
                </select>
              </div>
              
              <!-- Table Container -->
              <div style="overflow-x: auto;">
                <table id="portfolio-monthly-table" class="portfolio-table" style="width: 100%; border-collapse: collapse;">
                  <thead>
                    <tr>
                      <th style="text-align: left; padding: 0.75rem; border-bottom: 2px solid #ddd; font-weight: 600;">Segment</th>
                      <!-- Month columns will be inserted here by JS -->
                    </tr>
                  </thead>
                  <tbody>
                    <!-- Rows will be inserted here by JS -->
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Overview Panel -->
      <section class="aigeo-panel is-active" data-panel="overview">

      <!-- Five-Pillar Framework (collapsed by default) -->
      <div class="calculation-explanation collapsed" id="frameworkExplanation">
        <div class="calculation-header" onclick="toggleFrameworkExplanation()">
          <h4> Five-Pillar Framework</h4>
          <span class="calculation-toggle" id="frameworkToggle"></span>
        </div>
        <div class="calculation-content collapsed" id="frameworkContent">
          <p style="margin-top: 0; color: #555; line-height: 1.6; margin-bottom: 1rem;">
            This audit analyzes <strong>www.alanranger.com</strong> as a global entity using a five-pillar framework to assess AI-powered search visibility, entity recognition, and SERP behavior. Each pillar is scored 0-100 and assigned a RAG (Red/Amber/Green) status based on performance thresholds.
          </p>
          <p style="color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
            <strong>Data Sources:</strong> Scores are calculated using data from Google Search Console API (impressions, clicks, position, queries), Google Business Profile API (ratings, reviews, locations, service areas), schema markup validation, backlink CSV upload, and Trustpilot reviews snapshot.
          </p>
          <p style="color: #555; line-height: 1.6; margin-bottom: 0;">
            <strong>Score Calculation:</strong> The GAIO score combines five weighted pillars: Authority (30%: Behaviour 40% + Ranking 20% + Backlinks 20% + Reviews 20%), Content/Schema (25%: Foundation schemas 30% + Rich Results 35% + Coverage 20% + Diversity 15%), Visibility (20%: average position mapping), Local Entity (15%: NAP consistency + knowledge panel + locations), and Service Area (10%: service areas count with NAP multiplier). Brand & Entity Overlay and AI Summary Likelihood are overlay metrics that do not affect the GAIO score but provide additional insights. Scores are normalized to 0-100 scale with thresholds: Green (70), Amber (40-69), Red (&lt;40). Money pages behaviour is tracked separately and stored per audit, so you can see whether Authority improvements are coming from better CTR on commercial pages or from broader site-wide changes.
          </p>
        </div>
      </div>

      <div class="calculation-explanation collapsed" id="calculationExplanation">
        <div class="calculation-header" onclick="toggleCalculationExplanation()">
          <h4> Detailed Calculation Explanation</h4>
          <span class="calculation-toggle" id="calculationToggle"></span>
        </div>
        <div class="calculation-content collapsed" id="calculationContent">
          <h5>1. Visibility</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Primary: Average position from Google Search Console (1-40 mapped to 100-10)</li>
            <li>Formula: <code>posScore = 100 - ((clampedPosition - 1) / 39) * 90</code> where clampedPosition is constrained to 1-40</li>
            <li>Visibility score = clamped posScore (0-100)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: impressions, clicks, average position, CTR</li>
            <li>Real-time data from GSC API for the selected date range</li>
          </ul>
          <p><strong>Data Checked:</strong> Search Console impressions/clicks, average position, CTR, ranking distribution.</p>

          <h5>2. Authority (E-E-A-T)</h5>
          <p><strong>What Authority Represents:</strong></p>
          <p>Authority is not "how good the content is", it's "how much the outside world and searchers trust and choose you". It approximates E-E-A-T using four ingredients:</p>
          <ul>
            <li><strong>Behavioural signals</strong>  do people click your results when they see them?</li>
            <li><strong>Ranking strength</strong>  how often do you show near the top of organic results?</li>
            <li><strong>Off-site credibility</strong>  backlinks from other domains (Phase 3)</li>
            <li><strong>Reputation & reviews</strong>  ratings and review volume across GBP + website</li>
          </ul>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Four-component model: Behaviour (40%), Ranking (20%), Backlinks (20%), Reviews (20%)</li>
            <li>Formula: <code>authority = 0.4 * behaviourScore + 0.2 * rankingScore + 0.2 * backlinkScore + 0.2 * reviewScore</code></li>
            <li>Each sub-score is normalized to 0-100, then combined with weights above</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>2.1 Behaviour Score (40%):</strong></p>
          <ul>
            <li>From Google Search Console: Only uses queries where average position  20</li>
            <li>Computes: ctrAll = CTR for all ranking queries, ctrTop10 = CTR for impressions where position  10</li>
            <li>Maps: ctrAll 0-5%  0-100 (values >5% capped at 100), ctrTop10 0-10%  0-100</li>
            <li>Combines: <code>BehaviourScore = 0.5 * score(ctrAll) + 0.5 * score(ctrTop10)</code></li>
            <li>This stops long-tail / low-rank pages dragging the whole site down</li>
          </ul>
          <p><strong>2.2 Ranking Score (20%):</strong></p>
          <ul>
            <li>From GSC, again only for position  20</li>
            <li>avgPos = impression-weighted average position</li>
            <li>top10Share = % of impressions where position  10</li>
            <li>posScore = map(avgPos, 1  100, 20  0) (clamped)</li>
            <li>top10Score = top10Share as a % (0-100)</li>
            <li>Combines: <code>RankingScore = 0.5 * posScore + 0.5 * top10Score</code></li>
          </ul>
          <p><strong>2.3 Review Score (20%):</strong></p>
          <ul>
            <li>Inputs: From GBP API (gbpRating 0-5, gbpReviewCount) and Trustpilot snapshot (siteRating 4.6, siteReviewCount 610)</li>
            <li>Per source: ratingScore = (rating/5)*100, countScore = min(reviewCount, 500)/500*100</li>
            <li>sourceScore = 0.6 * ratingScore + 0.4 * countScore</li>
            <li>Final: <code>ReviewScore = 0.6 * gbpSourceScore + 0.4 * siteSourceScore</code></li>
            <li>If one source missing, falls back to the other; if both missing, uses neutral default (50)</li>
          </ul>
          <p><strong>2.4 Backlink Score (20%):</strong></p>
          <ul>
            <li>Phase 3  using CSVs: refDomainCount, qualityDomains, qualityRatio</li>
            <li>countScore = map(refDomainCount, 0  0, N  100) where N is cap (e.g. 150-200)</li>
            <li>qualityScore = qualityRatio * 100</li>
            <li>Combines: <code>BacklinkScore = 0.5 * countScore + 0.5 * qualityScore</code></li>
            <li>Currently placeholder (50) until Phase 3 is implemented</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API (CTR, position, impressions by position bucket)</li>
            <li>Google Business Profile API (ratings, review count)</li>
            <li>Trustpilot reviews (historic snapshot: rating 4.6, count 610)</li>
            <li>Backlink CSV upload (referring domains, quality metrics) - Phase 3</li>
          </ul>
          <p><strong>How to Improve Authority:</strong></p>
          <ul>
            <li><strong>Behaviour:</strong> Improve titles/meta descriptions on pages already in top 10-20. Focus on high-impression queries in GSC.</li>
            <li><strong>Ranking:</strong> Push more core pages into top 10 (content refreshes, internal links, stronger schema).</li>
            <li><strong>Reviews:</strong> Keep growing GBP and Trustpilot reviews; higher rating and more volume both help.</li>
            <li><strong>Backlinks:</strong> Acquire more distinct linking domains, favouring sites with real traffic/authority (Phase 3).</li>
          </ul>

          <h5>3. Local Entity</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li><strong>Primary method (when Business Profile data available):</strong> Base score from NAP consistency (0-100), with bonuses:
              <ul>
                <li>Knowledge panel detected: +10 points</li>
                <li>At least one location: +5 points</li>
                <li>Final score capped at 100</li>
              </ul>
            </li>
            <li><strong>Fallback method (no Business Profile data):</strong> Derived from search performance:
              <ul>
            <li>Formula: <code>localEntity = 60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50)</code></li>
                <li>Uses position score and CTR score from GSC</li>
              </ul>
            </li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li> <strong>Primary:</strong> Google Business Profile API: NAP consistency score, knowledge panel detection, locations count</li>
            <li> <strong>Fallback:</strong> Google Search Console API: position, CTR (when Business Profile data unavailable)</li>
          </ul>
          <p><strong>Data Checked:</strong> NAP consistency percentage, knowledge panel presence, locations count, LocalBusiness schema presence, entity recognition signals.</p>

          <h5>4. Service Area</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li><strong>Primary method (when Business Profile data available):</strong>
              <ul>
                <li>Base score from service areas count: 0 areas = 0, 1 area = 12.5, 2 areas = 25, ..., 8+ areas = 100</li>
                <li>Formula: <code>baseScore = min(serviceAreasCount * 12.5, 100)</code></li>
                <li>NAP consistency multiplier applied: <code>serviceArea = baseScore * (napConsistencyScore / 100)</code></li>
                <li>If NAP consistency is low, service area score is reduced proportionally</li>
              </ul>
            </li>
            <li><strong>Fallback method (no Business Profile data):</strong> Derived from Local Entity score (when Business Profile unavailable)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li> <strong>Primary:</strong> Google Business Profile API: service areas count, NAP consistency score</li>
            <li> <strong>Fallback:</strong> Derived from Local Entity (when Business Profile data unavailable)</li>
          </ul>
          <p><strong>Data Checked:</strong> Service areas count from Business Profile, NAP consistency percentage, geographic coverage signals.</p>

          <h5>5. Content/Schema</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Weighted calculation based on four components: Foundation schemas, Rich Results, Coverage, and Diversity</li>
            <li>Formula: <code>contentSchema = (Foundation  30%) + (Rich Results  35%) + (Coverage  20%) + (Diversity  15%)</code></li>
            <li><strong>Foundation Schemas (30%):</strong> Organization, Person, WebSite, BreadcrumbList presence. Score = (types present / 4)  100</li>
            <li><strong>Rich Results (35%):</strong> Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList eligibility. Score = (eligible types / 11)  100</li>
            <li><strong>Coverage (20%):</strong> Pages with schema / total pages. Score = coverage percentage</li>
            <li><strong>Diversity (15%):</strong> Number of unique schema types across site. Score = min((unique types / 15)  100, 100)</li>
            <li><strong>Data Source:</strong> Schema audit API (crawls actual pages for JSON-LD markup)</li>
            <li>Uses real schema coverage from CSV-based audit (when available)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Schema Audit API: CSV-based domain crawl of all site URLs</li>
            <li>Schema markup detection and type counting</li>
            <li>Foundation schema presence detection (Organization, Person, WebSite, BreadcrumbList)</li>
            <li>Rich result eligibility detection (Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList)</li>
          </ul>
          <p><strong>Data Checked:</strong> Total pages scanned, pages with schema, schema coverage percentage, schema types present (Organization, Person, LocalBusiness, Article, Course, Event, FAQ, HowTo, etc.), missing schema types, rich result eligibility (Article, Event, FAQ, Product, LocalBusiness, Course, Review, HowTo).</p>

          <h5>6. Brand & Entity Overlay</h5>
          <p><strong>What Brand Overlay Represents:</strong></p>
          <p>Brand & Entity Overlay measures how strongly your brand is recognized in search and how well entity signals support AI understanding. It combines branded search performance, review signals, and entity recognition. <strong>Note:</strong> This is an overlay metric and does not directly affect the GAIO score calculation.</p>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li><strong>Brand Search Component (40% of brand search score):</strong>
              <ul>
                <li>Brand Query Share: % of impressions that are branded queries (30%+ share = 100 points)</li>
                <li>Brand CTR: Click-through rate on branded queries (40%+ CTR = 100 points)</li>
                <li>Brand Avg Position: Average position for branded queries (normalized 1-10  100-0)</li>
                <li>Formula: <code>brandSearchScore = 0.4 * shareScore + 0.3 * ctrScore + 0.3 * posScore</code></li>
              </ul>
            </li>
            <li><strong>Combined Score:</strong>
              <ul>
                <li>Formula: <code>brandOverlay = 0.4 * brandSearchScore + 0.3 * reviewScore + 0.3 * entityScore</code></li>
                <li>Label thresholds: &lt;40 = Weak, 40-69 = Developing, 70 = Strong</li>
              </ul>
            </li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: Branded query identification, brand impressions, brand clicks, brand CTR, brand average position</li>
            <li>Google Business Profile API: Review score (reused from Authority pillar)</li>
            <li>Local Entity score: Entity recognition signals (reused from Local Entity pillar)</li>
          </ul>
          <p><strong>Data Checked:</strong> Brand query share (% of total impressions), branded CTR, average brand position, review signals, entity recognition strength.</p>

          <h5>7. AI Summary Likelihood</h5>
          <p><strong>What AI Summary Likelihood Represents:</strong></p>
          <p>AI Summary Likelihood indicates how likely AI systems (like Google's AI Overviews) are to provide accurate, comprehensive summaries about your brand and content. It combines snippet readiness, visibility, and brand strength signals.</p>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Three-component model: Snippet Readiness (50%), Visibility (30%), Brand & Entity (20%)</li>
            <li>Formula: <code>aiSummary = 0.5 * snippetReadinessScore + 0.3 * visibilityScore + 0.2 * brandScore</code></li>
            <li>Label thresholds: &lt;50 = Low, 50-69 = Medium, 70 = High</li>
            <li>Uses same RAG bands as GAIO Score (70 green, 50 amber, &lt;50 red)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Snippet Readiness score: From snippet readiness gauge (FAQ/HowTo/Article blocks, schema, rich results)</li>
            <li>Visibility score: Current Visibility pillar score (average position from GSC)</li>
            <li>Brand score: Brand & Entity Overlay score</li>
          </ul>
          <p><strong>Data Checked:</strong> Snippet-friendly content blocks, schema markup for rich results, average search position, branded search performance, entity recognition.</p>

          <div class="note">
            <strong>Current Implementation Status:</strong><br>
            <strong> Fully Implemented:</strong><br>
             Google Search Console API integration (real-time data) - Total clicks, Total impressions, Average position, CTR calculation, Top queries, Brand query classification<br>
             Schema markup validation and analysis - Full site crawl, coverage analysis, type diversity, rich result eligibility (11 types), foundation schema detection<br>
             Backlink quality/quantity analysis - CSV upload support, domain rating, referring domains tracking<br>
             Review aggregation - Trustpilot integration (snapshot), Google Business Profile reviews, review score calculation<br>
             Knowledge panel tracking - Detection and scoring (part of Local Entity pillar)<br>
             Local pack visibility metrics - Service Area pillar with NAP consistency, location coverage<br>
             SERP feature detection - Rich result eligibility checks, snippet readiness scoring<br>
             Brand overlay metrics - Brand query share, branded CTR, brand position, entity strength<br>
             AI Summary Likelihood - Composite score based on snippet readiness, visibility, and brand signals<br>
             Historical trend tracking - Supabase integration for all pillars, trend charts with segmented Authority data<br>
             Shareable audit links - Public sharing with 30-day expiration<br><br>
            <strong>Future Enhancements:</strong><br>
             Real-time SERP feature monitoring and alerts<br>
             Advanced backlink analysis with automated discovery<br>
             Competitive analysis and benchmarking<br>
             Automated action recommendations engine<br>
             Export capabilities (PDF, CSV reports)<br><br>
            <strong>Note:</strong> All five core pillars (Authority, Content/Schema, Visibility, Local Entity, Service Area) are fully implemented with real data sources. Brand & Entity and AI Summary Likelihood are overlay metrics that enhance the core scoring without changing the GAIO score calculation.
          </div>
        </div>
      </div>

      <!-- Date Range Selector -->
      <div class="config-panel" style="margin-bottom: 2rem; background: #f8f9fa; padding: 1.5rem; border-radius: 8px; border: 1px solid #e2e8f0;">
        <div class="form-group">
          <label for="dateRange">Date Range</label>
          <div class="date-range-selector">
            <button class="date-range-btn active" onclick="setDateRange(30)" data-days="30" title="Analyze search performance data from the last 30 days">Last 30 Days</button>
            <button class="date-range-btn" onclick="setDateRange(60)" data-days="60" title="Analyze search performance data from the last 60 days">Last 60 Days</button>
            <button class="date-range-btn" onclick="setDateRange(90)" data-days="90" title="Analyze search performance data from the last 90 days">Last 90 Days</button>
            <button class="date-range-btn" onclick="setDateRange(120)" data-days="120" title="Analyze search performance data from the last 120 days">Last 120 Days</button>
            <button class="date-range-btn" onclick="setDateRange(180)" data-days="180" title="Analyze search performance data from the last 6 months (180 days)">Last 6 Months</button>
            <button class="date-range-btn" onclick="setDateRange(365)" data-days="365" title="Analyze search performance data from the last 12 months (365 days)">Last 12 Months</button>
            <button class="date-range-btn" onclick="setDateRange(540)" data-days="540" title="Analyze search performance data from the last 18 months (540 days)">Last 18 Months</button>
            <button class="date-range-btn" onclick="showCustomDateRange()" id="customDateBtn" title="Set a custom date range for analysis (enter number of days)">Custom</button>
        </div>
          <input type="number" id="dateRange" value="30" min="1" style="display: none;">
          <div id="customDateRange" style="display: none; margin-top: 0.5rem;">
            <input type="number" id="customDays" placeholder="Enter days" min="1" style="width: 150px; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px;">
            <button class="btn btn-small" onclick="applyCustomDateRange()" style="margin-left: 0.5rem; padding: 0.5rem 1rem;" title="Apply the custom date range you entered">Apply</button>
      </div>
          <div class="help-text">Analysis period for historical data</div>
      </div>
    </div>

      <div class="dashboard-grid" id="pillarCards"></div>

      <div class="section-break"></div>

      <div class="metrics-section">
        <h3 style="color: var(--brand-orange); margin-bottom: 0.5rem;">Key Performance Indicators</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Core metrics from Google Search Console showing overall search performance for the entity. <strong>Note:</strong> Small differences from live GSC may occur due to data processing delays (up to 48 hours) and exact date range calculations.</p>
        <div class="metrics-grid" id="metricsGrid"></div>
      </div>

      <div class="section-break"></div>

      <div class="dashboard-two-column">
        <div class="chart-container large">
          <h3>Pillar Scores Overview</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Radar chart showing current performance across all five pillars. The larger the area, the stronger your overall entity recognition.</p>
          
          <!-- Audit Timestamp for Radar Chart -->
          <div id="radarChartTimestamp" style="background: #fff3cd; padding: 0.5rem 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #f59e0b; font-size: 0.8rem; color: #856404; display: none;">
            <strong>Current data as of:</strong> <span id="radarChartAuditTime">-</span> <span style="color: #666; font-size: 0.75rem;">(Not historical - reflects last audit scan)</span>
          </div>
          
          <canvas id="radarChart"></canvas>
        </div>

        <div class="snippet-readiness-gauge">
          <h3 style="margin-top: 0; color: var(--brand-orange);">Snippet Readiness Gauge</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Snippet readiness summarises how likely your content is to be lifted into featured snippets and AI answers. It reflects three ingredients: snippet-friendly answer blocks, suitable schema (FAQ/HowTo/Article/Course/Event) and existing rich-result behaviour.</p>
          
          <!-- Audit Timestamp for Snippet Readiness -->
          <div id="snippetReadinessTimestamp" style="background: #fff3cd; padding: 0.5rem 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #f59e0b; font-size: 0.8rem; color: #856404; display: none;">
            <strong>Current data as of:</strong> <span id="snippetReadinessAuditTime">-</span> <span style="color: #666; font-size: 0.75rem;">(Not historical - reflects last audit scan)</span>
            </div>
          
          <div id="snippetReadinessExplanation" style="display: none; background: #fde68a; border-left: 4px solid #f59e0b; padding: 1rem; margin-bottom: 1rem; border-radius: 4px; font-size: 0.85rem; color: #78350f;">
            <strong id="explanationTitle" style="color: #78350f;">Top 5 Actions to Improve Snippet Readiness</strong>
            <p style="margin: 0.5rem 0; color: #78350f;">Prioritized actions based on your current scores and their impact on overall snippet readiness:</p>
            <ol id="topActionsList" style="margin: 0.5rem 0 0 1.5rem; padding: 0; list-style-type: decimal;">
              <!-- Top 5 actions will be populated dynamically -->
            </ol>
            </div>
          
          <!-- Overall Combined Score -->
          <div style="text-align: center; margin-bottom: 1.5rem;">
            <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">Overall Snippet Readiness</div>
            <div id="snippetReadinessScore" style="font-size: 3rem; font-weight: 700; color: var(--brand-orange); line-height: 1;">0</div>
            <div id="gaugeStatus" style="font-size: 0.9rem; color: #666; margin-top: 0.25rem;">Calculating...</div>
          </div>
          
          <!-- Pie Chart Container -->
          <div style="display: flex; align-items: center; justify-content: center; gap: 1.5rem; flex-wrap: wrap;">
            <div style="flex: 2; min-width: 400px; max-width: 500px;">
              <canvas id="snippetReadinessPieChart"></canvas>
            </div>
            <div style="flex: 1; min-width: 180px; max-width: 250px;">
              <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--brand-dark);">Component Breakdown:</div>
              <div id="snippetReadinessLegend" style="display: flex; flex-direction: column; gap: 0.5rem;">
                <!-- Legend will be populated by JavaScript -->
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="section-break"></div>

      <div class="chart-container">
        <h3>Score Trends</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Historical performance tracking for all five pillars (Local Entity, Service Area, Authority, Visibility, Content/Schema) over the selected date range.</p>
        <div id="trendAuthorityModeToggle" class="authority-mode-toggle" style="margin-bottom: 1rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; display: none;">
          <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
            <span style="font-weight: 600; color: #666;">Authority Mode:</span>
            <button id="trend-mode-all" class="authority-mode-btn" data-mode="all" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: #10b981; color: white; cursor: pointer; font-size: 0.75rem;">
              All pages
            </button>
            <button id="trend-mode-nonEducation" class="authority-mode-btn" data-mode="nonEducation" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
              Exclude education
            </button>
            <button id="trend-mode-money" class="authority-mode-btn" data-mode="money" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
              Money pages only
            </button>
          </div>
        </div>
        <div id="trendSummaryRow" class="trend-summary-row"></div>
        <canvas id="trendChart"></canvas>
      </div>
      </section>

      <!-- Money Pages Panel -->
      <section class="aigeo-panel" data-panel="money">
        <!-- Money Pages content will be inserted here by JS -->
      </section>

      <!-- Ranking & AI Panel -->
      <section class="aigeo-panel" data-panel="ranking">
        <div class="card card--section-header">
          <h2>Ranking &amp; AI Visibility</h2>
          <p class="ranking-intro">
            Keyword-level view of how search engines and AI systems see you. This is an overlay on the
            <strong>Visibility</strong>, <strong>Authority</strong>, <strong>Content/Schema</strong> and
            <strong>Local Entity</strong> pillars  it does not change their weights or scores.
          </p>

          <ul class="ranking-intro-bullets">
            <li><strong>Classic rankings</strong>  Visibility + Authority (Ranking component).</li>
            <li><strong>AI Overviews &amp; citations</strong>  Content/Schema + Authority.</li>
            <li><strong>Local packs</strong>  Local Entity + Service Area.</li>
          </ul>

          <div class="ranking-header-actions" style="display: flex; align-items: center; gap: 1rem;">
            <button id="ranking-ai-refresh" class="btn btn-secondary" type="button">
              Run ranking &amp; AI check
            </button>
            <button id="ranking-gsc-refresh" class="btn btn-secondary" type="button" style="background: #10b981; color: white; border: 1px solid #10b981; font-weight: 600; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;" title="Refresh CTR & Impressions from Google Search Console (no API costs)">
              Refresh GSC Data
            </button>
            <button id="edit-keywords-btn" class="btn btn-secondary" type="button" style="background: #2563eb; color: white; border: 1px solid #2563eb; font-weight: 600; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">
              Edit Keywords
            </button>
            <span id="ranking-ai-last-run" class="ranking-ai-last-run"></span>
          </div>
        </div>

        <!-- Edit Keywords Modal -->
        <div id="edit-keywords-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 10000; align-items: center; justify-content: center;">
          <div style="background: white; border-radius: 8px; padding: 2rem; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
              <h3 style="margin: 0; font-size: 1.5rem; color: #1e293b;">Edit Keywords</h3>
              <button id="edit-keywords-close" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #64748b; padding: 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;">&times;</button>
            </div>
            
            <!-- Warning and Instructions Box -->
            <div style="background: #fef3c7; border: 1px solid #fbbf24; border-radius: 6px; padding: 1rem; margin-bottom: 1.5rem;">
              <div style="display: flex; align-items: start; gap: 0.75rem;">
                <div style="color: #d97706; font-size: 1.25rem; line-height: 1; margin-top: 0.125rem;"></div>
                <div style="flex: 1;">
                  <div style="font-weight: 600; color: #92400e; font-size: 0.9rem; margin-bottom: 0.5rem;">Important: Data Loss Warning</div>
                  <ul style="margin: 0; padding-left: 1.25rem; color: #78350f; font-size: 0.85rem; line-height: 1.6;">
                    <li><strong>Removing keywords:</strong> All historical data (rankings, AI citations, SERP features) will be permanently deleted.</li>
                    <li><strong>Changing/renaming keywords:</strong> Treated as removing the old keyword and adding a new one. All data is lost and cannot be recovered.</li>
                    <li><strong>New keywords:</strong> Will appear in the list but won't have data until you run a "Ranking & AI check".</li>
                  </ul>
                  <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #fbbf24; color: #78350f; font-size: 0.85rem;">
                    <strong>Instructions:</strong> Enter one keyword per line. Changes will be saved immediately. Keywords will be updated on the next Ranking & AI check.
                    <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                      <label for="csv-upload" style="display: inline-flex; align-items: center; padding: 0.375rem 0.75rem; background: #3b82f6; color: white; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                         Upload CSV
                        <input type="file" id="csv-upload" accept=".csv,.txt" style="display: none;" />
                      </label>
                      <span style="color: #78350f; font-size: 0.8rem;">Upload a CSV file (one keyword per line, first column)</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <textarea id="edit-keywords-textarea" style="width: 100%; min-height: 300px; padding: 0.75rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.9rem; font-family: inherit; resize: vertical; box-sizing: border-box; color: #1e293b; background: white;"></textarea>
            <div style="display: flex; justify-content: flex-end; gap: 0.75rem; margin-top: 1.5rem;">
              <button id="edit-keywords-cancel" style="padding: 0.5rem 1rem; background: #f1f5f9; color: #475569; border: 1px solid #cbd5e1; border-radius: 4px; cursor: pointer; font-size: 0.9rem;">Cancel</button>
              <button id="edit-keywords-save" style="padding: 0.5rem 1rem; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; font-weight: 600;">Save Keywords</button>
            </div>
            <div id="edit-keywords-status" style="margin-top: 1rem; font-size: 0.85rem; color: #475569; min-height: 1.5rem;"></div>
          </div>
        </div>

        <!-- Section B: Metric pills row -->
        <div class="ranking-metric-pills">
          <div class="metric-pill metric-pill--neutral" id="ranking-card-tracked">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">Tracked keywords</div>
            <div class="metric-pill-status" data-field="status">Info only</div>
            <div class="metric-pill-footer">Used across Visibility &amp; Authority behaviour/ranking.</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-tracked')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-tracked-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-ai-coverage">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">AI Overview coverage</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Pillars: Visibility, Content/Schema</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-ai-coverage')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-ai-coverage-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-ai-citations">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">AI citations (alanranger.com)</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Pillars: Authority (Reviews), Content/Schema</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-ai-citations')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-ai-citations-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-top10">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">Top-10 rank coverage</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Pillars: Visibility, Authority (Ranking)</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-top10')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-top10-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-serp-features">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">SERP feature coverage</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Pillars: Content/Schema, Local Entity</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-serp-features')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-serp-features-details"></div>
          </div>
        </div>

        <!-- Global Insights & actions and Visibility metrics side by side (underneath summary tiles) -->
        <div class="ranking-cards-side-by-side">
          <!-- Global Insights & actions (all tracked keywords) -->
          <section class="card card--insights" id="ranking-ai-insights-card-global">
            <div class="card-header">
              <h2>Insights &amp; actions (all tracked keywords)</h2>
              <p class="card-subtitle">
                Recommendations based on how your tracked keywords currently rank in classic search and appear in AI Overviews.
                These insights are global, not tied to the selected keyword.
              </p>
            </div>
            <div class="card-pill-container" id="ranking-ai-insights-list-global">
              <!-- Content populated by renderRankingAiInsights -->
            </div>
          </section>

          <!-- Tracked keyword visibility metrics (DataForSEO only - not part of GAIO pillars) -->
          <div class="ranking-visibility-metrics-section" id="ranking-visibility-metrics">
            <div class="card" style="background: rgba(204, 255, 255, 0.15); border-left: 4px solid #CCFFFF;">
            <div class="card-header">
              <h4 style="font-size: 14pt !important; margin-bottom: 0.5rem;">Tracked keyword visibility (DataForSEO)</h4>
              <div style="font-size: 12pt !important; color: #666; margin-bottom: 0.75rem; line-height: 1.5;">
                <p style="margin-bottom: 0.5rem;">
                  These metrics use DataForSEO live rankings and Google Ads search volume for your tracked keyword set only.
                </p>
                <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                  <li><strong>Demand-weighted avg position</strong>  average Google rank where each keyword is weighted by its monthly search volume (high-demand terms pull this number more).</li>
                  <li><strong>Unweighted avg position</strong>  simple average rank across all tracked keywords, with each keyword counted equally.</li>
                </ul>
                <p style="margin-top: 0.5rem; margin-bottom: 0;">
                  These are diagnostic metrics for your tracked set; the main Visibility and Authority pillar scores are still calculated from full Google Search Console data across all queries and pages.
                </p>
              </div>
              <div style="display: flex; gap: 2rem; flex-wrap: wrap; font-size: 14pt !important; align-items: baseline;">
                <div>
                  <strong style="font-size: 13pt !important;">Demand-weighted avg position:</strong>
                  <span id="ranking-avg-position-weighted" style="font-weight: bold; color: #0284c7; font-size: 16pt !important; margin-left: 0.5rem;"></span>
                  <span title="Average rank for tracked keywords where each rank is weighted by the keyword's monthly search volume from DataForSEO." style="margin-left: 0.25rem; opacity: 0.6; cursor: help; font-size: 12pt !important;"></span>
                </div>
                <div style="font-size: 12pt !important; color: #666;">
                  <strong>Unweighted avg position:</strong>
                  <span id="ranking-avg-position-unweighted" style="font-weight: normal; margin-left: 0.5rem;"></span>
                  <span title="Simple average rank for all tracked keywords from DataForSEO, each keyword counted once." style="margin-left: 0.25rem; opacity: 0.6; cursor: help;"></span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Keyword Priority Matrix (Impact  Difficulty) - Full width below side-by-side cards -->
        <div class="ranking-priority-matrix-section" id="ranking-priority-matrix-section" style="display: none; width: 100%; clear: both; float: none;">
          <div class="card" style="background: rgba(204, 255, 255, 0.15); border-left: 4px solid #CCFFFF; padding: 1.5rem;">
            <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Keyword Priority  Impact & Difficulty</h3>
            <p style="margin: 0 0 1rem 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
              Uses search volume share and current rank to surface the highest-impact keywords to work on.
              Impact is driven mainly by search volume share (global, not filter-relative) and opportunity score. Difficulty reflects current rank bucket (page 1 vs page 2+).
            </p>
            <div id="ranking-keyword-priority-matrix" style="background: #f8fafc; padding: 1rem; border-radius: 8px;">
              <!-- 3x3 grid rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Domain Strength (manual monthly snapshots) -->
        <div class="ranking-domain-strength-section" id="ranking-domain-strength-section" style="width: 100%; clear: both; float: none; margin: 1.5rem 0;">
          <div class="card" style="background: rgba(204, 255, 255, 0.15); border-left: 4px solid #CCFFFF; padding: 1.5rem;">
            <div style="display: flex; align-items: center; justify-content: space-between; gap: 1rem; flex-wrap: wrap;">
              <div>
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">
                  Domain Strength (Google  DataForSEO Labs)
                  <span
                    class="domain-strength-help"
                    title="Domain Strength (0100) is a composite score based on DataForSEO Labs. It combines:&#10; Estimated organic traffic value (visibility)&#10; Total organic keywords (breadth)&#10; Share of keywords ranking in Googles top 10 (quality)&#10;We calculate it monthly and store history so you can see trends over time."
                  >?</span>
                </h3>
                <p style="margin: 0; font-size: 0.9rem; color: #64748b; line-height: 1.6;">
                  Manual monthly snapshots based on DataForSEO Labs <code style="font-size: 0.85rem;">domain_rank_overview</code>.
                  Uses visibility (ETV), breadth (ranking keywords), and top10 share to produce a 0100 score.
                </p>
              </div>
              <div style="display: flex; gap: 0.75rem; align-items: center;">
                <button id="domain-strength-run-btn" class="btn btn-secondary" type="button">
                  Run Domain Strength Snapshot (Google)
                </button>
              </div>
            </div>

            <!-- Full-page progress overlay -->
            <div id="domain-strength-overlay" class="domain-strength-overlay">
              <div class="domain-strength-overlay-content">
                <div class="spinner"></div>
                <h3>Running Domain Strength Snapshot</h3>
                <p id="domain-strength-overlay-status">Fetching domain data from DataForSEO...</p>
              </div>
            </div>

            <!-- Completion modal -->
            <div id="domain-strength-completion-modal" class="domain-strength-overlay" style="display: none;">
              <div class="domain-strength-overlay-content" style="max-width: 500px;">
                <h3 style="margin: 0 0 1rem 0; font-size: 1.5rem; font-weight: 700; color: #1e293b;"> Snapshot Complete</h3>
                <div id="domain-strength-completion-stats" style="text-align: left; margin: 1.5rem 0;">
                  <!-- Stats will be inserted here -->
                </div>
                <button id="domain-strength-completion-close" class="btn btn-primary" style="margin-top: 1rem; width: 100%;">Close</button>
              </div>
            </div>

            <div class="domain-strength-summary-row">
              <div class="domain-strength-summary-card" id="domain-strength-summary-card">
                <div style="color:#64748b; font-size:0.95rem;">Loading domain strength</div>
              </div>
              <div style="font-size: 0.875rem; color: #64748b; line-height: 1.6;">
                <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #475569;">Understanding Domain Strength:</p>
                <ul style="margin: 0; padding-left: 1.25rem; list-style-type: disc;">
                  <li style="margin-bottom: 0.25rem;"><strong>Strength score (0-100):</strong> Composite metric combining estimated organic traffic value (visibility), total organic keywords (breadth), and share of keywords ranking in Google's top 10 (quality).</li>
                  <li style="margin-bottom: 0.25rem;"><strong>Band:</strong> Qualitative classification: Very weak (0-19), Weak (20-39), Moderate (40-59), Strong (60-79), Very strong (80-100).</li>
                  <li style="margin-bottom: 0.25rem;"><strong>ETV:</strong> Estimated Traffic Value in USD. DataForSEO's estimate of monthly organic traffic value based on keyword rankings and search volume.</li>
                  <li style="margin-bottom: 0.25rem;"><strong>Top-10 keywords:</strong> Number of keywords ranking in Google's top 10 positions. Higher counts indicate broader keyword coverage.</li>
                  <li style="margin-bottom: 0.25rem;"><strong>Change:</strong> Change in Strength score compared to the previous snapshot. Positive values (green ) indicate improvement.</li>
                  <li><strong>12-month trend:</strong> Visual graph showing Strength score over the last 12 months. Each point represents a monthly snapshot.</li>
                </ul>
              </div>
            </div>

            <div id="domain-strength-run-status" style="margin-top: 0.75rem; font-size: 0.875rem; color: #64748b;"></div>
            <h3 style="margin-top: 1.5rem; margin-bottom: 1rem; font-size: 1.25rem; font-weight: 600; color: #1e293b;">Competitors</h3>
            <div class="ranking-table-wrapper" style="margin-top: 1rem; max-height: none;">
              <div style="position: relative; overflow: visible; max-height: 80vh; overflow-y: auto;">
                <table class="ranking-table" id="domain-strength-table" style="position: relative;">
                  <thead id="domain-strength-thead" style="position: sticky; top: 0; z-index: 10; background: #f8fafc;">
                  <tr>
                    <th data-sort="name" class="sortable" title="Domain name or label for this site">
                      <div>Name <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Domain name or label for this site"></div>
                    </th>
                    <th data-sort="segment" class="sortable" title="Category or ownership segment (e.g., 'Your site' for your primary domain, or competitor segment)">
                      <div>Domain type <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Category or ownership segment (e.g., 'Your site' for your primary domain, or competitor segment)"></div>
                    </th>
                    <th data-sort="score" class="sortable" title="Domain Strength score (0-100). Composite metric combining: Estimated organic traffic value (visibility), Total organic keywords (breadth), and Share of keywords ranking in Google's top 10 (quality). Higher scores indicate stronger domain authority.">
                      <div>Strength score <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Domain Strength score (0-100). Composite metric combining: Estimated organic traffic value (visibility), Total organic keywords (breadth), and Share of keywords ranking in Google's top 10 (quality). Higher scores indicate stronger domain authority."></div>
                    </th>
                    <th data-sort="band" class="sortable" title="Qualitative band based on Strength score: Very weak (0-19), Weak (20-39), Moderate (40-59), Strong (60-79), Very strong (80-100)">
                      <div>Band <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Qualitative band based on Strength score: Very weak (0-19), Weak (20-39), Moderate (40-59), Strong (60-79), Very strong (80-100)"></div>
                    </th>
                    <th data-sort="etv" class="sortable" style="text-align:right;" title="Estimated Traffic Value (ETV). DataForSEO's estimate of monthly organic traffic value in USD based on keyword rankings and search volume. Higher values indicate more valuable organic traffic potential.">
                      <div style="text-align:right;">ETV <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Estimated Traffic Value (ETV). DataForSEO's estimate of monthly organic traffic value in USD based on keyword rankings and search volume. Higher values indicate more valuable organic traffic potential."></div>
                    </th>
                    <th data-sort="top10" class="sortable" style="text-align:right;" title="Number of keywords ranking in Google's top 10 positions. Higher counts indicate broader keyword coverage and stronger domain authority across multiple search terms.">
                      <div style="text-align:right; line-height: 1.2;">Top10<br>keywords <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Number of keywords ranking in Google's top 10 positions. Higher counts indicate broader keyword coverage and stronger domain authority across multiple search terms."></div>
                    </th>
                    <th data-sort="change" class="sortable" style="text-align:center;" title="Change in Strength score compared to the previous snapshot. Positive values (green ) indicate improvement, negative values (red ) indicate decline. Shows how domain strength is trending between snapshots.">
                      <div>Change <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Change in Strength score compared to the previous snapshot. Positive values (green ) indicate improvement, negative values (red ) indicate decline. Shows how domain strength is trending between snapshots."></div>
                    </th>
                    <th style="text-align:center;" title="Visual trend graph showing Strength score over the last 12 months. Each point represents a monthly snapshot. Helps identify long-term trends and patterns in domain authority changes.">
                      <div>12month trend</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Visual trend graph showing Strength score over the last 12 months. Each point represents a monthly snapshot. Helps identify long-term trends and patterns in domain authority changes."></div>
                    </th>
                    <th style="text-align:center;" title="Mark this domain as a competitor">
                      <div>Competitor</div>
                    </th>
                  </tr>
                  </tr>
                </thead>
                <tbody id="domain-strength-table-body">
                  <tr><td colspan="9" class="ranking-table-empty">No domain strength snapshots yet. Click "Run Domain Strength Snapshot".</td></tr>
                </tbody>
              </table>
              </div>
            </div>
            <div id="domain-strength-pagination-controls" style="margin-top: 1rem; display: flex; justify-content: space-between; align-items: center; padding-top: 1rem; border-top: 1px solid #e2e8f0; flex-wrap: wrap; gap: 1rem;">
              <div style="font-size: 0.85rem; color: #64748b;">
                <span id="domain-strength-pagination-info">Page 1 of 1  Total: 0</span>
              </div>
              <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  Rows per page:
                  <select id="domain-strength-rows-per-page" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; background: white; cursor: pointer;">
                    <option value="10" selected>10</option>
                    <option value="25">25</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                    <option value="all">All</option>
                  </select>
                </label>
                <button id="domain-strength-pagination-prev" type="button" disabled style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cbd5e1; background: #f1f5f9; cursor: not-allowed; color: #94a3b8; font-weight: 600;">
                  Previous
                </button>
                <button id="domain-strength-pagination-next" type="button" disabled style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cbd5e1; background: #f1f5f9; cursor: not-allowed; color: #94a3b8; font-weight: 600;">
                  Next
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Section C: Filters + full-width table -->
        <div class="ranking-table-section" style="width: 100%; clear: both; float: none;">
          <div class="card">
            <div class="card-header">
              <h3>Keyword rankings &amp; AI usage</h3>
              <p class="card-subtitle ranking-subtitle-tight" style="max-width: 100%; width: 100%;">
                Keyword-level inputs to <strong>Visibility</strong> and the <strong>Authority  Behaviour / Ranking</strong> components. Search volume shows demand for each tracked keyword (Visibility pillar). Combined with AI citations, it also highlights topics where you have strong or weak Authority. AI columns show where <strong>Content/Schema</strong> helps make you a source.
              </p>
            </div>
            <!-- Preset buttons -->
            <div class="ranking-presets-section" style="padding: 1rem 1.5rem; border-bottom: 1px solid #e2e8f0; background: #f8fafc;">
              <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center;">
                <span style="font-size: 0.875rem; font-weight: 600; color: #475569; margin-right: 0.5rem;">Presets:</span>
                <button type="button" class="ranking-preset-btn" data-preset="all" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Reset all filters and restore default sort">
                  All keywords
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="high-impact-money" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Segment: Money | Best rank: 1120 | Search volume: High | Min opportunity:  65 | Sort: Opportunity ">
                  High-impact money
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="ai-overview-not-cited" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="AI Overview: On | AI citation: Not cited | Min opportunity:  50 | Sort: Volume ">
                  AI Overview, not cited
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="brand-safety" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Segment: Brand | Best rank: Not top 3 | Sort: Rank  (worst first)">
                  Brand safety
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="education-growth" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Page type: Blog | Best rank: Not top 3 | Min opportunity:  30 | Sort: Opportunity ">
                  Blog opportunities
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="local-visibility" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Page type: GBP | Best rank: Not top 3 | Min opportunity:  30 | Sort: Opportunity ">
                  Local visibility
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="top-10-opportunities" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Best rank: Not top 3 | Min opportunity:  50 | Sort: Opportunity  | Shows top 10 results">
                  Top 10 opportunities
                </button>
              </div>
              <!-- Criteria chips (shown when preset is active) -->
              <div id="ranking-preset-criteria-chips" style="display: none; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0;">
                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center;">
                  <!-- Chips will be inserted here by JavaScript -->
                </div>
              </div>
            </div>
            <div class="ranking-filters-section" style="padding: 1rem 1.5rem; border-bottom: 1px solid #e2e8f0;">
              <div class="ranking-filter-bar" style="display: flex; flex-wrap: nowrap; gap: 0.75rem; align-items: flex-end; margin-bottom: 0.75rem;">
                <div class="filter-group">
                  <label>Segment:</label>
                  <select id="ranking-filter-segment" class="filter-control">
                    <option value="all">All</option>
                    <option value="brand">Brand</option>
                    <option value="money">Money</option>
                    <option value="education">Education</option>
                    <option value="other">Other</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Best rank:</label>
                  <select id="ranking-filter-rank" class="filter-control">
                    <option value="all">All</option>
                    <option value="top3">Top 3</option>
                    <option value="4-10">410</option>
                    <option value="11-20">1120</option>
                    <option value="21+">21+ / Not ranked</option>
                    <option value="not-top3">Not top 3</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Search volume:</label>
                  <select id="ranking-filter-volume" class="filter-control">
                    <option value="all">All</option>
                    <option value="high">High (200+)</option>
                    <option value="medium">Medium (50-199)</option>
                    <option value="low">Low (1-49)</option>
                    <option value="none">None</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>CTR:</label>
                  <select id="ranking-filter-ctr" class="filter-control">
                    <option value="all">All</option>
                    <option value="high">High (5%)</option>
                    <option value="medium">Medium (2-4.9%)</option>
                    <option value="low">Low (<2%)</option>
                    <option value="none">No data</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Opportunity score: <span title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10; Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10; Classic ranking strength (page 1 vs page 2+ and current position).&#10; AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first.&#10;&#10;Bands: Low <40  Medium 4069  High 70" style="opacity: 0.6; cursor: help;"></span></label>
                  <select id="ranking-filter-opportunity" class="filter-control">
                    <option value="all">All</option>
                    <option value="high">High ( 70)</option>
                    <option value="medium">Medium (4069)</option>
                    <option value="low">Low (< 40)</option>
                  </select>
                </div>
                <div class="filter-group">
                  <label>Min opportunity:</label>
                  <input type="number" id="ranking-filter-min-opportunity" class="filter-control" placeholder="e.g. 65" min="0" max="100" step="1" style="width: 80px;">
                  <div id="ranking-filter-min-opportunity-note" style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem; display: none;">
                    Min opportunity overrides band selection.
                  </div>
                </div>

                <div class="filter-group">
                  <label>AI Overview:</label>
                  <select id="ranking-filter-ai-overview" class="filter-control">
                    <option value="all">All</option>
                    <option value="has">Has AI Overview</option>
                    <option value="no">No AI Overview</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>AI citation:</label>
                  <select id="ranking-filter-ai-citation" class="filter-control">
                    <option value="all">All</option>
                    <option value="cited">Cited in AI</option>
                    <option value="not-cited">Not cited</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Page type:</label>
                  <select id="ranking-filter-page-type" class="filter-control">
                    <option value="all">All</option>
                    <option value="GBP">GBP</option>
                    <option value="Blog">Blog</option>
                    <option value="Landing">Landing</option>
                    <option value="Event">Event</option>
                    <option value="Product">Product</option>
                    <option value="Other">Other</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>SERP features:</label>
                  <select id="ranking-filter-serp-features" class="filter-control">
                    <option value="all">All</option>
                    <option value="ai-overview">AI Overview</option>
                    <option value="local-pack">Local pack</option>
                    <option value="paa">People Also Ask</option>
                    <option value="featured-snippet">Featured snippet</option>
                    <option value="none">None</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Optimisation status: <span title="Filter keywords by their optimisation tracking status. Shows whether optimisation work is planned, in progress, being monitored, completed, paused, cancelled, or not yet tracked." style="opacity: 0.6; cursor: help;"></span></label>
                  <select id="ranking-filter-optimisation-status" class="filter-control">
                    <option value="all">All</option>
                    <option value="not-tracked">Not tracked</option>
                    <option value="planned">Planned</option>
                    <option value="in_progress">In progress</option>
                    <option value="monitoring">Monitoring</option>
                    <option value="done">Done</option>
                    <option value="paused">Paused</option>
                    <option value="cancelled">Cancelled</option>
                  </select>
                </div>
              </div>

              <div style="display: flex; gap: 0.75rem; align-items: flex-end;">
                <div class="filter-group filter-group-search" style="flex: 1; min-width: 300px;">
                  <label>Search:</label>
                  <input type="text" id="ranking-filter-keyword" class="filter-control" placeholder="Filter by keyword...">
                </div>

                <div class="filter-group filter-group-button" style="align-items: end;">
                  <button id="ranking-filter-clear" class="btn btn-small" style="width: 100%;">Clear filters</button>
                </div>
              </div>
            </div>
            <div class="ranking-table-wrapper" style="max-height: none;">
              <table class="ranking-table" id="ranking-ai-table">
                <thead>
                  <tr>
                    <th data-sort="keyword" class="sortable" title="The tracked keyword or search query.">
                      <div>Keyword <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="The tracked keyword or search query."></div>
                    </th>
                    <th data-sort="segment" class="sortable" title="Keyword intent segment: Brand (branded queries), Money (commercial intent), Education (informational), or Other.">
                      <div>Segment <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Keyword intent segment: Brand (branded queries), Money (commercial intent), Education (informational), or Other."></div>
                    </th>
                    <th data-sort="rank" class="sortable" title="Current organic search ranking position for this keyword. Lower numbers are better (1 is the top position).">
                      <div>Current organic rank <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Current organic search ranking position for this keyword. Lower numbers are better (1 is the top position)."></div>
                    </th>
                    <th data-sort="volume" class="sortable" title="Average monthly Google search volume for this keyword in the UK. Source: DataForSEO Labs  Keyword Overview.">
                      <div>Search volume <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Average monthly Google search volume for this keyword in the UK. Source: DataForSEO Labs  Keyword Overview."></div>
                    </th>
                    <th data-sort="ctr" class="sortable" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days.">
                      <div>CTR (28d) <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days (matches GSC UI)."></div>
                    </th>
                    <th data-sort="impressions30d" class="sortable" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days.">
                      <div>Impressions (28d) <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days (matches GSC UI)."></div>
                    </th>
                    <th data-sort="opportunityScore" class="sortable" title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10; Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10; Classic ranking strength (page 1 vs page 2+ and current position).&#10; AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first.">
                      <div>Opportunity score <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10; Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10; Classic ranking strength (page 1 vs page 2+ and current position).&#10; AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first."></div>
                    </th>
                    <th title="Whether Google AI Overview is present in SERP results for this keyword.">
                      <div>AI Overview</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Whether Google AI Overview is present in SERP results for this keyword."></div>
                    </th>
                    <th data-sort="citations" class="sortable" title="Number of citations from your domain (alanranger.com) out of total citations in AI Overview for this keyword.">
                      <div>AI citations <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Number of citations from your domain (alanranger.com) out of total citations in AI Overview for this keyword."></div>
                    </th>
                    <th title="This is the traditional blue link in SERP results.">
                      <div>Classic Ranking URL</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="This is the traditional blue link in SERP results."></div>
                    </th>
                    <th data-sort="pageType" class="sortable" title="Type of page that ranks for this keyword: GBP (Google Business Profile), Landing (landing page), Event (event/workshop page), Product (product/service page), or Other.">
                      <div>Page type <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Type of page that ranks for this keyword: GBP (Google Business Profile), Landing (landing page), Event (event/workshop page), Product (product/service page), or Other."></div>
                    </th>
                    <th title="Optimisation tracking status for this keyword and target URL. Shows whether optimisation work is planned, in progress, being monitored, or completed.">
                      <div>Optimisation</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Optimisation tracking status for this keyword and target URL. Shows whether optimisation work is planned, in progress, being monitored, or completed."></div>
                    </th>
                  </tr>
                </thead>
                <tbody id="ranking-ai-table-body">
                  <tr><td colspan="12" class="ranking-table-empty">Click "Run ranking &amp; AI check" to load data.</td></tr>
                </tbody>
              </table>
            </div>
            <div class="ranking-pagination-controls" id="ranking-pagination-controls" style="display: none;">
              <div class="ranking-pagination-info" id="ranking-pagination-info">
                Showing 0-0 of 0
              </div>
              <div class="ranking-pagination-buttons">
                <button id="ranking-pagination-first" type="button">First</button>
                <button id="ranking-pagination-prev" type="button">Previous</button>
                <span id="ranking-pagination-page-info" style="padding: 0 0.5rem; font-size: 0.875rem;">Page 1 of 1</span>
                <button id="ranking-pagination-next" type="button">Next</button>
                <button id="ranking-pagination-last" type="button">Last</button>
              </div>
              <div class="ranking-rows-per-page">
                <label>Rows per page:</label>
                <select id="ranking-rows-per-page">
                  <option value="10" selected>10</option>
                  <option value="25">25</option>
                  <option value="50">50</option>
                  <option value="100">100</option>
                  <option value="all">All</option>
                </select>
              </div>
            </div>
          </div>
        </div>

        <!-- Section D: Keyword details & insights (three columns: 33% each) -->
        <div class="ranking-details-grid">
          <div class="card" id="ranking-ai-detail-card">
            <div class="card-header">
              <h3>Keyword Scorecard</h3>
              <p class="card-subtitle ranking-subtitle-tight">
                Detailed analysis of the selected keyword's impact, difficulty, and recommended actions. Shows demand, ranking strength, AI usage, and priority.
              </p>
            </div>
            <div class="ranking-ai-detail-body">
              <p id="ranking-ai-detail-empty">
                Select a keyword in the table or a cell in the priority grid to see a detailed scorecard.
              </p>
              <div id="ranking-ai-detail-content" class="ranking-ai-detail-content" hidden>
                <h4 id="ranking-ai-detail-keyword"></h4>
                <p id="ranking-ai-detail-summary"></p>
              </div>
            </div>
          </div>

          <div class="card" id="ranking-ai-competitors-card">
            <div class="card-header">
              <h3>Competitors in AI &amp; SERPs</h3>
              <p class="card-subtitle ranking-subtitle-tight">
                Domains that appear repeatedly in AI citations and/or classic top-10 rankings. Competitive backdrop for <strong>Authority</strong> and <strong>Visibility</strong>.
              </p>
            </div>
            <div style="padding: 0 1.25rem 1.25rem 1.25rem;">
              <div style="overflow-x: auto; max-width: 100%;">
                <table id="ranking-ai-competitors-table" style="width: 100%; border-collapse: collapse; table-layout: fixed; font-size: 0.8rem;">
                  <thead>
                    <tr style="background: #f1f5f9;">
                      <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 35%; word-wrap: break-word;">Domain</th>
                      <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 20%;">AI citations</th>
                      <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 25%;">Domain Rank</th>
                      <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 15%; word-wrap: break-word; line-height: 1.2;">
                        <div style="display: flex; flex-direction: column; align-items: flex-start;">
                          <span>Domain</span>
                          <span>type</span>
                        </div>
                      </th>
                      <th style="text-align: center; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 5%;">C</th>
                    </tr>
                  </thead>
                  <tbody id="ranking-ai-competitors-body"></tbody>
                </table>
              </div>
              <p style="margin: 0.75rem 0 0 0; font-size: 0.8rem; color: #64748b;">
                Domain Rank is sourced from your latest Domain Strength snapshot (0100).
              </p>
            </div>
          </div>

          <div class="card" id="ranking-ai-citations-card">
            <div class="card-header">
              <h3>AI Citations for Selected Keyword</h3>
              <p class="card-subtitle ranking-subtitle-tight">
                Pages from alanranger.com and other domains cited in AI Overviews for the selected keyword.
              </p>
            </div>
            <div class="ranking-ai-detail-body">
              <p id="ranking-ai-citations-empty">
                Select a keyword in the table to see AI citations.
              </p>
              <div id="ranking-ai-citations-content" hidden>
                <p class="card-subtitle ranking-subtitle-tight" style="margin-bottom: 1rem;">
                  Pages from alanranger.com and other domains cited in AI Overviews for the selected keyword.
                </p>
                <h5>Your cited pages</h5>
                <ul id="ranking-ai-detail-our-pages" class="ranking-ai-detail-list"></ul>

                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                  <h5 style="margin: 0;">Other cited domains</h5>
                  <button id="backfill-domain-ranks-btn" onclick="backfillMissingDomainRanks()" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;" title="Fetch Domain Rank for domains currently showing ''">Backfill Missing Ranks</button>
                </div>
                <div style="overflow-x: auto; margin-top: 0.5rem; max-width: 100%;">
                  <table id="ranking-ai-detail-competitors-table" style="width: 100%; border-collapse: collapse; table-layout: fixed; font-size: 0.8rem;">
                    <thead>
                      <tr style="background: #f1f5f9;">
                        <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 28%; word-wrap: break-word;">Domain</th>
                        <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 12%;">Citations</th>
                        <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 18%;">Domain Rank</th>
                        <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 16%; word-wrap: break-word; line-height: 1.2;">
                          <div style="display: flex; flex-direction: column; align-items: flex-start;">
                            <span>Domain</span>
                            <span>type</span>
                          </div>
                        </th>
                        <th style="text-align: center; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 26%;">Competitor</th>
                      </tr>
                    </thead>
                    <tbody id="ranking-ai-detail-competitors-body"></tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- AI Sources & Influence Panel -->
      <section class="aigeo-panel" data-panel="ai-sources">
        <div class="container" style="max-width: 1400px; margin: 0 auto; padding: 2rem;">
          <div class="card" style="margin-bottom: 2rem;">
            <div class="card-header">
              <h2>AI Sources & Influence</h2>
              <p class="card-subtitle">
                Domains that AI relies on most often when answering your tracked keywords. Identify which external sources you should strengthen or join so AI is more confident recommending you.
              </p>
            </div>
          </div>

          <!-- Summary Tiles -->
          <div id="ai-sources-tiles" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
            <!-- Tiles will be populated by JS -->
          </div>

          <!-- Source Types & Quick Insights -->
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 2rem;">
            <!-- Left: Source Types Overview -->
            <div class="card">
              <div class="card-header">
                <h3>Source Types Overview</h3>
              </div>
              <div class="card-body" id="ai-sources-types-breakdown">
                <p style="color: #64748b; text-align: center; padding: 2rem;">Loading source types...</p>
              </div>
            </div>

            <!-- Right: AI Influence Summary -->
            <div class="card ai-sources-explainer">
              <div class="card-header">
                <h3>How to read this tab</h3>
              </div>
              <div class="card-body">
                <p style="line-height: 1.6; margin-bottom: 0.75rem;">
                  This view shows the domains AI relies on most often when answering your tracked keywords.
                </p>
                <ul style="line-height: 1.8;">
                  <li>Repeated citations from the same domain signal trusted sources in your niche.</li>
                  <li>Directories and review platforms highlight places where you need consistent NAP, reviews and listings.</li>
                  <li>Course marketplaces and education sites show where learners are discovering alternatives to your workshops and lessons.</li>
                </ul>
                <p style="line-height: 1.6; margin-top: 0.75rem; font-weight: 600;">
                  The goal is to identify which external sources you should strengthen or join so AI is more confident recommending you.
                </p>
              </div>
            </div>
          </div>
        </div>

          <!-- Domain Influence Table -->
          <div class="card ai-sources-domain-table-card">
            <div class="card-header">
              <h3>Domain Influence Table</h3>
              <div style="display: flex; gap: 1rem; margin-top: 1rem; flex-wrap: wrap;">
                <div class="filter-group">
                  <label>Source type:</label>
                  <select id="ai-sources-filter-type" class="filter-control">
                    <option value="all">All</option>
                    <option value="Directory">Directory</option>
                    <option value="Review platform">Review platform</option>
                    <option value="Course marketplace / education">Course marketplace / education</option>
                    <option value="Publisher / blog">Publisher / blog</option>
                    <option value="Other">Other</option>
                  </select>
                </div>
                <div class="filter-group">
                  <label>Domain type:</label>
                  <select id="ai-sources-filter-domain-type" class="filter-control">
                    <option value="all">All</option>
                    <option value="self">Your site</option>
                    <option value="competitor">Competitor</option>
                    <option value="site">Site</option>
                    <option value="platform">Platform</option>
                    <option value="directory">Directory</option>
                    <option value="publisher">Publisher</option>
                    <option value="vendor">Vendor</option>
                    <option value="institution">Institution</option>
                    <option value="government">Government</option>
                    <option value="unmapped">Unmapped</option>
                  </select>
                </div>
                <div class="filter-group">
                  <label>Search:</label>
                  <input type="text" id="ai-sources-filter-domain" class="filter-control" placeholder="Filter by domain...">
                </div>
                <button id="ai-sources-filter-clear" class="btn btn-small">Clear filters</button>
              </div>
            </div>
            <div class="ranking-table-wrapper">
              <table class="ranking-table" id="ai-sources-table">
                <thead style="position: sticky; top: 0; z-index: 20; background: white;">
                  <tr>
                    <th data-sort="domain" class="sortable" style="background: white;">Domain <span class="sort-indicator"></span></th>
                    <th data-sort="domain_type" class="sortable" style="background: white;">Domain type <span class="sort-indicator"></span></th>
                    <th data-sort="competitor" class="sortable" style="background: white;">Competitor <span class="sort-indicator"></span></th>
                    <th data-sort="rank" class="sortable" style="background: white;">Domain Rank <span class="sort-indicator"></span></th>
                    <th data-sort="citations" class="sortable" style="background: white;">AI citations <span class="sort-indicator"></span></th>
                    <th data-sort="keywords" class="sortable" style="background: white;">Keywords <span class="sort-indicator"></span></th>
                    <th data-sort="share" class="sortable" style="background: white;">Citation share <span class="sort-indicator"></span></th>
                    <th style="background: white;">Example page</th>
                  </tr>
                </thead>
                <tbody id="ai-sources-table-body">
                  <tr><td colspan="8" class="ranking-table-empty">Loading domain data...</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- Domain Detail Panel (Right Side) -->
          <div id="ai-sources-detail-panel" style="display: none; margin-top: 2rem;">
            <div class="card">
              <div class="card-header">
                <h3 id="ai-sources-detail-domain">Domain Details</h3>
                <p id="ai-sources-detail-meta" class="card-subtitle"></p>
              </div>
              <div class="card-body" id="ai-sources-detail-content">
                <!-- Content populated by JS -->
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Local & Reviews Panel -->
      <section class="aigeo-panel" data-panel="local">
        <!-- Local entity, GBP, reviews content will be inserted here by JS -->
      </section>

      <!-- Optimisation Tracking Panel -->
      <section class="aigeo-panel" data-panel="optimisation" hidden>
        <div class="card card--section-header" style="display: flex; justify-content: space-between; align-items: center;">
          <div>
            <h2>Optimisation Tracking</h2>
            <p>Track and manage keyword optimisation tasks across your site. Monitor progress, cycles, and outcomes.</p>
          </div>
          <button id="optimisation-bulk-update-btn" class="btn" style="padding: 0.75rem 1.5rem; font-size: 0.95rem; white-space: nowrap;" title="Captures the latest metrics for every active task (creates a measurement entry).">
             Update All Tasks with Latest Data
          </button>
        </div>

        <!-- Summary Cards (B6) -->
        <h2 style="color: var(--dark-text) !important; font-size: 1.5rem; font-weight: 600; margin: 2rem 0 1rem 0;">Task Counts</h2>
        <div class="optimisation-summary-cards" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1.5rem 0;">
          <div class="card" title="Tasks with status: planned, in_progress, or monitoring (not done, cancelled, or deleted).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-active"></div>
            <div style="margin-top: 0.5rem;">Active Tasks</div>
          </div>
          <div class="card" title="Tasks with status: planned (task created but work not started).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-planned"></div>
            <div style="margin-top: 0.5rem;">Planned</div>
          </div>
          <div class="card" title="Tasks with status: in_progress (actively being worked on).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-in-progress"></div>
            <div style="margin-top: 0.5rem;">In Progress</div>
          </div>
          <div class="card" title="Tasks with status: monitoring (changes deployed, tracking results).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-monitoring"></div>
            <div style="margin-top: 0.5rem;">Monitoring</div>
          </div>
          <div class="card" title="Tasks with status: done (cycle completed; start a new cycle if optimising again).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-done"></div>
            <div style="margin-top: 0.5rem;">Done</div>
          </div>
          <div class="card" title="Tasks with status: paused (tracking stopped; you can start a new cycle later).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-paused"></div>
            <div style="margin-top: 0.5rem;">Paused</div>
          </div>
          <div class="card" title="Tasks with status: cancelled (tracking stopped; you can start a new cycle later).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-cancelled"></div>
            <div style="margin-top: 0.5rem;">Cancelled</div>
          </div>
          <div class="card" title="Tasks that have had a measurement event created in the last 30 days.">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-recent"></div>
            <div style="margin-top: 0.5rem;">Updated (30d)</div>
          </div>
        </div>

        <!-- Divider line between Task Counts and Objectives -->
        <hr style="border: none; border-top: 1px solid rgba(156, 163, 175, 0.3); margin: 2rem 0;">

        <!-- Goal Rollup Badges (Phase B) -->
        <h2 style="color: var(--dark-text) !important; font-size: 1.5rem; font-weight: 600; margin: 2rem 0 1rem 0;">Objectives</h2>
        <div class="optimisation-goal-rollups" style="display: flex; gap: 0.75rem; margin: 1rem 0; flex-wrap: wrap; align-items: center;">
          <div style="font-weight: 600; color: #475569; margin-right: 0.5rem;">Objectives:</div>
          <span id="optimisation-goal-filter-not-set" class="ranking-badge ranking-badge--segment-general" style="padding: 0.5rem 1rem; cursor: pointer;" title="Tasks with no objective set (no KPI, target, or timeframe defined). Click to filter.">
            Not set: <span id="optimisation-goal-not-set">0</span>
          </span>
          <span id="optimisation-goal-filter-on-track" class="ranking-badge ranking-badge--segment-education" style="padding: 0.5rem 1rem; cursor: pointer;" title="Objective set and not yet due, or delta is moving in the right direction but hasn't met target yet. Click to filter.">
            On track: <span id="optimisation-goal-on-track">0</span>
          </span>
          <span id="optimisation-goal-filter-overdue" class="ranking-badge ranking-badge--segment-money" style="padding: 0.5rem 1rem; background: #fee2e2; color: #991b1b; cursor: pointer;" title="Due date has passed and target has not been met. Click to filter.">
            Overdue: <span id="optimisation-goal-overdue">0</span>
          </span>
          <span id="optimisation-goal-filter-met" class="ranking-badge ranking-badge--segment-brand" style="padding: 0.5rem 1rem; background: #d1fae5; color: #065f46; cursor: pointer;" title="Target has been met (delta meets or exceeds target value). Click to filter.">
            Met: <span id="optimisation-goal-met">0</span>
          </span>
        </div>

        <!-- Objective Metrics Traffic Lights (7 columns: All Metrics aggregated + 6 individual metrics) -->
        <div class="optimisation-objective-metrics" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 1rem; margin: 2rem 0;">
          <!-- All Metrics (Aggregated) -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">All Metrics</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div class="traffic-light-pill" data-metric="all_metrics" data-bucket="worse" style="background: rgba(239, 68, 68, 0.2);" onclick="handleTrafficLightClick('all_metrics', 'worse')">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-all-metrics-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div class="traffic-light-pill" data-metric="all_metrics" data-bucket="same" style="background: rgba(245, 158, 11, 0.2);" onclick="handleTrafficLightClick('all_metrics', 'same')">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-all-metrics-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div class="traffic-light-pill" data-metric="all_metrics" data-bucket="better" style="background: rgba(16, 185, 129, 0.2);" onclick="handleTrafficLightClick('all_metrics', 'better')">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-all-metrics-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- CTR (28d) -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">CTR (28d)</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div class="traffic-light-pill" data-metric="ctr_28d" data-bucket="worse" style="background: rgba(239, 68, 68, 0.2);" onclick="handleTrafficLightClick('ctr_28d', 'worse')">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-ctr-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div class="traffic-light-pill" data-metric="ctr_28d" data-bucket="same" style="background: rgba(245, 158, 11, 0.2);" onclick="handleTrafficLightClick('ctr_28d', 'same')">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-ctr-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div class="traffic-light-pill" data-metric="ctr_28d" data-bucket="better" style="background: rgba(16, 185, 129, 0.2);" onclick="handleTrafficLightClick('ctr_28d', 'better')">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-ctr-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- Impressions (28d) -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">Impressions (28d)</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-impressions-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-impressions-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-impressions-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- Clicks (28d) -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">Clicks (28d)</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-clicks-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-clicks-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-clicks-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- Rank -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">Rank</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-rank-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-rank-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-rank-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- AI Citations -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">AI Citations</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-ai-citations-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-ai-citations-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-ai-citations-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- AI Overview -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">AI Overview</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-ai-overview-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-ai-overview-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-ai-overview-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

        </div>

        <!-- Faint gray line separator after traffic lights -->
        <div style="height: 1px; background: rgba(156, 163, 175, 0.3); margin: 2rem 0;"></div>

        <!-- Phase 9: KPI Tiles (RAG) -->
        <div class="optimisation-kpi-tiles" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 1rem; margin: 1.5rem 0;">
          <div class="card" style="cursor: pointer;" id="kpi-tile-ctr-on-track" onclick="filterByKPIRAG('ctr', 'on_track')" title="CTR objectives that are on track. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-ctr-on-track">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">CTR: On track</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-ctr-at-risk" onclick="filterByKPIRAG('ctr', 'at_risk')" title="CTR objectives at risk (due within 7 days). Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-ctr-at-risk">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">CTR: At risk</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-ctr-overdue" onclick="filterByKPIRAG('ctr', 'overdue')" title="CTR objectives that are overdue. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-ctr-overdue">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">CTR: Overdue</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-rank-improved" onclick="filterByRankDelta('improved')" title="Rank objectives with improved rank (lower is better). Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-rank-improved">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Rank: Improved</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-rank-worse" onclick="filterByRankDelta('worse')" title="Rank objectives with worsened rank. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-rank-worse">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Rank: Worse</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-rank-flat" onclick="filterByRankDelta('flat')" title="Rank objectives with no change. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-rank-flat">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Rank: Flat</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-ai-gap" onclick="filterByAIGap()" title="Tasks with AI Overview on but citations = 0. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-ai-gap">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">AI Citation Gap</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-needs-measurement" onclick="filterByNeedsMeasurement()" title="Tasks needing measurement update (>30 days or missing). Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-needs-measurement">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Needs Measurement</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-overdue-cycles" onclick="filterByOverdueCycles()" title="Tasks with overdue cycles (past due date and target not met). Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-overdue-cycles">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Overdue Cycles</div>
          </div>
        </div>

        <!-- Phase 9: Estimated Impact Tiles - Split into Potential and Actual -->
        <div class="optimisation-impact-tiles" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1.5rem 0;">
          <!-- Left Tile: Potential Extra Clicks -->
          <div class="card" id="impact-potential-clicks-card" style="cursor: pointer; position: relative; text-align: center;" title="Projection: assumes objectives met for CTR/Impressions/Clicks tasks. Uses latest measurements. Excludes Rank/AI metrics. Click to filter table to traffic KPI tasks.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="impact-potential-clicks">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Potential Extra Clicks (28d)</div>
            <div style="margin-top: 0.125rem; font-size: 0.75rem; color: rgba(255, 255, 255, 0.7);">If all CTR/Impressions/Clicks objectives are met</div>
            <div id="impact-potential-clicks-clear" style="display: none; position: absolute; top: 0.5rem; right: 0.5rem; font-size: 0.75rem; color: rgba(255, 255, 255, 0.8); cursor: pointer; padding: 0.25rem 0.5rem; background: rgba(0, 0, 0, 0.2); border-radius: 4px;" title="Clear filter"> Clear</div>
          </div>
          <!-- Right Tile: Actual Click Change -->
          <div class="card" id="impact-actual-clicks-card" style="cursor: pointer; position: relative; text-align: center;" title="Observed: baseline  latest click change across traffic KPI tasks. Uses measured clicks (or CTRImpressions fallback). Click to filter table to click-related tasks.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="impact-actual-clicks">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Actual Click Change (28d)</div>
            <div style="margin-top: 0.125rem; font-size: 0.75rem; color: rgba(255, 255, 255, 0.7);">Measured baseline  latest across click-related tasks</div>
            <div id="impact-actual-clicks-clear" style="display: none; position: absolute; top: 0.5rem; right: 0.5rem; font-size: 0.75rem; color: rgba(255, 255, 255, 0.8); cursor: pointer; padding: 0.25rem 0.5rem; background: rgba(0, 0, 0, 0.2); border-radius: 4px;" title="Clear filter"> Clear</div>
          </div>
        </div>
        
        <!-- Context strip showing task counts -->
        <div id="impact-tiles-context" style="margin-top: 0.5rem; margin-bottom: 1rem; font-size: 0.75rem; color: rgba(255, 255, 255, 0.6); text-align: center;">
          <span id="traffic-kpi-count">Traffic KPI tasks included: 0</span>
          <span style="margin: 0 1rem;">|</span>
          <span id="click-related-count">Click-related tasks included: 0</span>
        </div>

        <!-- Phase 9: Scope Toggle -->
        <div class="optimisation-scope-toggle" style="display: flex; align-items: center; gap: 1rem; margin: 1.5rem 0; padding: 1rem; background: #f9fafb; border-radius: 8px;">
          <label style="font-weight: 600; color: #374151;">Scope:</label>
          <select id="optimisation-scope-select" style="padding: 0.5rem 1rem; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer; font-size: 0.875rem;">
            <option value="active_cycle">Active Cycle Only</option>
            <option value="all_tasks">All Tasks</option>
          </select>
          <span style="font-size: 0.875rem; color: #6b7280;" id="optimisation-scope-description">Showing metrics for tasks with active cycles only</span>
        </div>

        <!-- Phase 9: Time-based Charts -->
        <div class="optimisation-timeseries-charts" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 1.5rem; margin: 1.5rem 0;">
          <div class="card" style="padding: 1.5rem;">
            <div id="chart-left-title-container" style="margin-bottom: 0.75rem;">
              <h3 id="chart-left-title" style="margin: 0 0 0.25rem 0; font-size: 1.1rem; font-weight: 600; color: var(--dark-text);">Estimated Gap to Target (28d)  Clicks Potential</h3>
              <p id="chart-left-subtitle" style="margin: 0; font-size: 0.75rem; color: rgba(255, 255, 255, 0.7); line-height: 1.3;">Sum of remaining click-equivalent gap to targets (traffic KPIs only).</p>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <button id="chart-left-toggle-clicks" class="chart-toggle-btn active" data-chart="clicks" style="padding: 0.5rem 1rem; background: var(--dark-brand); color: #000; border: 1px solid var(--dark-brand); border-radius: 4px; font-weight: 600; cursor: pointer;">Gap to Target</button>
                <button id="chart-left-toggle-trend" class="chart-toggle-btn" data-chart="trend" style="padding: 0.5rem 1rem; background: var(--dark-panel); color: var(--dark-text); border: 1px solid var(--dark-border); border-radius: 4px; font-weight: 600; cursor: pointer;">Weekly Trend</button>
                <span id="chart-trend-kpi-label" style="display: none; font-size: 0.875rem; color: var(--dark-text); margin-left: 0.5rem;">KPI: <strong id="chart-trend-kpi-label-value"></strong></span>
              </div>
              <select id="chart-trend-kpi-select" style="display: none; padding: 0.5rem; background: var(--dark-panel); color: var(--dark-text); border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem;">
                <option value="ctr_28d">CTR (pp)</option>
                <option value="impressions_28d">Impressions</option>
                <option value="clicks_28d">Clicks</option>
                <option value="current_rank">Rank</option>
                <option value="ai_citations">AI Citations</option>
              </select>
            </div>
            <div id="chart-left-container" style="position: relative; height: 280px;">
              <canvas id="chart-estimated-clicks-by-kpi" style="width: 100%; height: 280px;"></canvas>
              <canvas id="chart-median-delta-trend" style="width: 100%; height: 280px; display: none;"></canvas>
            </div>
          </div>
          <div class="card" style="padding: 1.5rem;">
            <h3 style="margin: 0 0 0.25rem 0; font-size: 1.1rem; font-weight: 600; color: var(--dark-text);">Median Delta by KPI (Last 30d)</h3>
            <p style="margin: 0 0 1rem 0; font-size: 0.75rem; color: rgba(255, 255, 255, 0.7); line-height: 1.3;">Median baseline  latest change per KPI across filtered tasks. (Median  net change.) CTR shown in pp. Negative for Rank can be good (lower rank).</p>
            <div style="position: relative; height: 280px;">
              <canvas id="chart-median-delta" style="width: 100%; height: 280px;"></canvas>
            </div>
          </div>
        </div>

        <!-- Tab Pills (B2) -->
        <div class="optimisation-tab-pills" style="display: flex; gap: 0.5rem; margin: 1.5rem 0; flex-wrap: wrap;">
          <button class="metric-pill metric-pill--neutral optimisation-tab-btn" data-tab="active" style="cursor: pointer; padding: 0.75rem 1.5rem;">
            <span>Active</span>
            <span class="optimisation-tab-count" data-tab="active">0</span>
          </button>
          <button class="metric-pill metric-pill--neutral optimisation-tab-btn" data-tab="done" style="cursor: pointer; padding: 0.75rem 1.5rem;">
            <span>Done</span>
            <span class="optimisation-tab-count" data-tab="done">0</span>
          </button>
          <button class="metric-pill metric-pill--neutral optimisation-tab-btn" data-tab="paused-cancelled" style="cursor: pointer; padding: 0.75rem 1.5rem;">
            <span>Paused/Cancelled</span>
            <span class="optimisation-tab-count" data-tab="paused-cancelled">0</span>
          </button>
        </div>

        <!-- Filters (B6) -->
        <div class="optimisation-filters" style="display: flex; gap: 1rem; margin: 1rem 0; flex-wrap: wrap; align-items: center;">
          <select id="optimisation-filter-status" style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">All Statuses</option>
            <option value="planned">Planned</option>
            <option value="in_progress">In Progress</option>
            <option value="monitoring">Monitoring</option>
            <option value="done">Done</option>
            <option value="paused">Paused</option>
            <option value="cancelled">Cancelled</option>
          </select>
          <select id="optimisation-filter-type" style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">All Types</option>
            <option value="on_page">On Page</option>
            <option value="content">Content</option>
            <option value="internal_links">Internal Links</option>
            <option value="links_pr">Links/PR</option>
            <option value="technical">Technical</option>
            <option value="local">Local</option>
            <option value="other">Other</option>
          </select>
          <input type="text" id="optimisation-filter-keyword" placeholder="Filter by keyword..." style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; flex: 1; min-width: 200px;">
          <input type="text" id="optimisation-filter-url" placeholder="Filter by URL..." style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; flex: 1; min-width: 200px;">
          <button id="optimisation-filter-needs-update" class="btn btn-secondary" style="padding: 0.5rem 1rem;" title="Show tasks that need measurement update (no measurement or older than 30 days).">Needs Update</button>
          <button id="optimisation-filter-active-cycle" class="btn btn-secondary" style="padding: 0.5rem 1rem;" title="Show only tasks with an active cycle (current cycle not completed or archived).">Active Cycle Only</button>
          <button id="optimisation-filter-overdue-cycle" class="btn btn-secondary" style="padding: 0.5rem 1rem;" title="Show tasks with overdue current cycle (past due date and target not met).">Overdue Cycle</button>
          <label style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; cursor: pointer;" title="Include test tasks in the view (test tasks are excluded from bulk updates).">
            <input type="checkbox" id="optimisation-filter-include-test" style="cursor: pointer;">
            <span>Include Test Tasks</span>
          </label>
          <button id="optimisation-clear-filters" class="btn btn-secondary" style="padding: 0.5rem 1rem;">Clear Filters</button>
        </div>

        <!-- Tasks Table (B2) -->
        <div class="ranking-table-section" style="margin-top: 1.5rem;">
          <div class="card">
            <div class="ranking-table-wrapper" id="optimisation-tasks-table-container" style="overflow: visible; max-height: none;">
            <table id="optimisation-tasks-table" class="ranking-table">
              <thead>
                <tr>
                  <th data-sort="keyword" class="sortable" title="The tracked keyword, search query, or page URL (for page-level tasks).">
                    <div>Keyword or Page <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="The tracked keyword, search query, or page URL (for page-level tasks)."></div>
                  </th>
                  <th data-sort="url" class="sortable" title="The target URL being optimised for this keyword." style="max-width: 150px;">
                    <div>Target URL <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="The target URL being optimised for this keyword."></div>
                  </th>
                  <th data-sort="type" class="sortable" title="Type of optimisation task: on_page (content/SEO changes), technical (site structure), or other.">
                    <div>Task Type <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Type of optimisation task: on_page (content/SEO changes), technical (site structure), or other."></div>
                  </th>
                  <th data-sort="status" class="sortable" title="Current status: planned (not started), in_progress (actively working), monitoring (tracking results), done (completed), paused (temporarily stopped), or cancelled.">
                    <div>Status <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Current status: planned (not started), in_progress (actively working), monitoring (tracking results), done (completed), paused (temporarily stopped), or cancelled."></div>
                  </th>
                  <th data-sort="cycle" class="sortable" title="Current cycle number. Each cycle represents a new optimisation attempt for the same keyword.">
                    <div>Cycle <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Current cycle number. Each cycle represents a new optimisation attempt for the same keyword."></div>
                  </th>
                  <th data-sort="baselineCaptured" class="sortable" title="Date when baseline metrics snapshot was captured (when task was created).">
                    <div>Baseline Captured <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Date when baseline metrics snapshot was captured (when task was created)."></div>
                  </th>
                  <th data-sort="latestCaptured" class="sortable" title="Date when latest measurement snapshot was captured, with 'Needs update' indicator if >30 days.">
                    <div>Latest Captured <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Date when latest measurement snapshot was captured, with 'Needs update' indicator if >30 days."></div>
                  </th>
                  <th data-sort="title" class="sortable" title="Optional title or label for this optimisation task.">
                    <div>Title <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Optional title or label for this optimisation task."></div>
                  </th>
                  <th data-sort="objectiveKpi" class="sortable" title="Objective KPI type (e.g., CTR, Rank, AI Citations).">
                    <div>Objective KPI <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Objective KPI type (e.g., CTR, Rank, AI Citations)."></div>
                  </th>
                  <th data-sort="baselineLatest" class="sortable" title="Baseline  Latest values for the objective KPI.">
                    <div>Baseline  Latest <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Baseline  Latest values for the objective KPI."></div>
                  </th>
                  <th data-sort="delta" class="sortable" title="Change (delta) from baseline to latest for the objective KPI.">
                    <div> vs Baseline <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Change (delta) from baseline to latest for the objective KPI."></div>
                  </th>
                  <th data-sort="dueIn" class="sortable" title="Days remaining until due date, or 'Overdue Xd' if past due.">
                    <div>Due In <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Days remaining until due date, or 'Overdue Xd' if past due."></div>
                  </th>
                  <th title="Mini trend line (sparkline) showing last ~10 measurements for the objective KPI.">
                    <div>Trend</div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Mini trend line (sparkline) showing last ~10 measurements for the objective KPI."></div>
                  </th>
                  <th title="Goal status and progress for the current cycle objective.">
                    <div>Goal</div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Goal status and progress for the current cycle objective."></div>
                  </th>
                  <th style="text-align: center;" title="Actions available for this task.">
                    <div>Actions</div>
                  </th>
                </tr>
              </thead>
              <tbody id="optimisation-tasks-tbody">
                <tr>
                  <td colspan="13" style="padding: 2rem; text-align: center; color: #666;">Loading tasks...</td>
                </tr>
              </tbody>
            </table>
            </div>
            <div class="ranking-pagination-controls" id="optimisation-pagination-controls" style="display: none;">
            <div class="ranking-pagination-info" id="optimisation-pagination-info">
              Showing 0-0 of 0
            </div>
            <div class="ranking-pagination-buttons">
              <button id="optimisation-pagination-first" type="button">First</button>
              <button id="optimisation-pagination-prev" type="button">Previous</button>
              <span id="optimisation-pagination-page-info" style="padding: 0 0.5rem; font-size: 0.875rem;">Page 1 of 1</span>
              <button id="optimisation-pagination-next" type="button">Next</button>
              <button id="optimisation-pagination-last" type="button">Last</button>
            </div>
            <div class="ranking-rows-per-page">
              <label>Rows per page:</label>
              <select id="optimisation-rows-per-page">
                <option value="10" selected>10</option>
                <option value="25">25</option>
                <option value="50">50</option>
                <option value="100">100</option>
                <option value="all">All</option>
              </select>
            </div>
          </div>
          </div>
        </div>

        <!-- Task Detail Drawer (B3) -->
        <!-- Backdrop -->
        <div id="optimisation-task-drawer-backdrop" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 999;"></div>
        
        <!-- Draggable Modal Window -->
        <div id="optimisation-task-drawer" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 1200px; max-width: 95vw; max-height: 95vh; background: var(--dark-panel); box-shadow: 0 10px 40px rgba(0,0,0,0.5); z-index: 1000; border-radius: 8px; overflow: hidden; flex-direction: column; color: var(--dark-text);">
          <!-- Draggable Header -->
          <div id="optimisation-drawer-header-bar" style="padding: 1rem 1.5rem; border-bottom: 1px solid var(--dark-border); display: flex; justify-content: space-between; align-items: center; background: var(--dark-panel); cursor: move; user-select: none;">
            <h3 id="optimisation-drawer-header-title" style="margin: 0; flex: 1; color: var(--dark-text);">Task Details</h3>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
              <button id="optimisation-drawer-minimize" style="background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0.25rem 0.5rem; color: var(--dark-text-muted);" title="Minimize"></button>
              <button id="optimisation-drawer-maximize" style="background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0.25rem 0.5rem; color: var(--dark-text-muted);" title="Maximize"></button>
              <button id="optimisation-drawer-close" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; padding: 0.25rem 0.5rem; color: var(--dark-text-muted);" title="Close">&times;</button>
            </div>
          </div>
          
          <!-- Cancel Task, Delete Task, and Title (moved to header area) -->
          <div style="padding: 0.75rem 1.5rem; border-bottom: 1px solid var(--dark-border); background: var(--dark-panel); display: flex; gap: 0.5rem; align-items: center;">
            <button id="optimisation-cancel-task-btn" class="btn" style="background: #dc2626; border: 1px solid #dc2626; padding: 0.5rem 1rem; font-size: 0.875rem; color: #ffffff; font-weight: 700;" title="Stop tracking (keeps history).">Cancel Task</button>
            <button id="optimisation-delete-task-btn" class="btn" style="background: #991b1b; border: 1px solid #991b1b; padding: 0.5rem 1rem; font-size: 0.875rem; color: #ffffff; font-weight: 700;" title="Permanently remove task and events (cannot be undone).">Delete Task</button>
            <div style="flex: 1; display: flex; align-items: center; gap: 0.5rem; margin-left: 1rem;">
              <strong style="white-space: nowrap; color: var(--dark-text);">Title:</strong>
              <input type="text" id="optimisation-drawer-title" style="flex: 1; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="Enter task title...">
            </div>
          </div>
          
          <!-- Scrollable Content -->
          <div id="optimisation-drawer-content" style="padding: 1.5rem; overflow-y: auto; flex: 1;">
          <div>
            <!-- Task Header (Full Width) -->
            <div id="optimisation-drawer-header" style="margin-bottom: 1.5rem; display: grid; grid-template-columns: 1fr 2fr 1.5fr; gap: 1.5rem;">
              <div>
                <strong>Keyword:</strong>
                <div id="optimisation-drawer-keyword" style="margin-top: 0.25rem; font-size: 1.1rem; color: #2563eb;"></div>
              </div>
              <div>
                <strong>Target URL:</strong>
                <div id="optimisation-drawer-url" style="margin-top: 0.25rem; word-break: break-all;"></div>
              </div>
              <div style="text-align: right;">
                <div style="margin-bottom: 0.5rem;">
                  <strong style="color: var(--dark-text);">Task Type:</strong>
                  <span id="optimisation-drawer-type" style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; background: rgba(156, 163, 175, 0.2); border-radius: 4px; color: var(--dark-text);"></span>
                </div>
                <div style="margin-bottom: 0.5rem;">
                  <strong>Status:</strong>
                  <span id="optimisation-drawer-status" style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; border-radius: 4px;"></span>
                </div>
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                  <strong>Cycle:</strong>
                  <span id="optimisation-drawer-cycle" style="margin-left: 0;"></span>
                  <select id="optimisation-drawer-cycle-selector" style="padding: 0.25rem 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text); cursor: pointer; display: none; min-width: 100px;" title="Select a cycle to view its objective, measurements, and events">
                    <!-- Options will be populated by JavaScript -->
                  </select>
                </div>
              </div>
            </div>

            <!-- Objective Section (Full Width) -->
            <div id="optimisation-drawer-objective" style="margin-bottom: 1.5rem; padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                  <h4 style="margin: 0; font-size: 0.95rem; font-weight: 600;">Objective <span id="optimisation-drawer-objective-cycle">(Cycle 1)</span></h4>
                  <span id="optimisation-drawer-objective-badge" style="padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; display: none;"></span>
                </div>
                <button id="optimisation-edit-objective-btn" class="btn btn-small" style="padding: 0.25rem 0.75rem; font-size: 0.875rem; background: var(--dark-brand); color: #000000; font-weight: 700; border: 1px solid var(--dark-brand);" title="Set target KPI and timeframe for this cycle.">Edit</button>
              </div>
              <div id="optimisation-drawer-objective-content" style="font-size: 0.875rem; color: var(--dark-text);">
                <div style="color: var(--dark-text-muted); font-style: italic;">Loading objective...</div>
              </div>
              <!-- Edit Objective Form (Hidden by default) -->
              <div id="optimisation-edit-objective-form" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--dark-border);">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Title</label>
                    <input type="text" id="optimisation-edit-objective-title" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="Objective title">
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">KPI Label</label>
                    <input type="text" id="optimisation-edit-objective-kpi" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="e.g., AI citations increase by 1">
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Metric</label>
                    <select id="optimisation-edit-objective-metric" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);">
                      <option value="">Select metric</option>
                      <option value="ai_citations">AI Citations</option>
                      <option value="ai_overview">AI Overview</option>
                      <option value="ctr_28d">CTR (28d)</option>
                      <option value="impressions_28d">Impressions (28d)</option>
                      <option value="clicks_28d">Clicks (28d)</option>
                      <option value="rank">Rank</option>
                    </select>
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Direction</label>
                    <select id="optimisation-edit-objective-direction" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);">
                      <option value="">Select direction</option>
                      <option value="increase">Increase</option>
                      <option value="decrease">Decrease</option>
                      <option value="at_least">At least</option>
                      <option value="at_most">At most</option>
                    </select>
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Target Value</label>
                    <input type="number" id="optimisation-edit-objective-target-value" step="0.01" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="0">
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Timeframe (days)</label>
                    <input type="number" id="optimisation-edit-objective-timeframe" min="1" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="30">
                  </div>
                  <div style="display: flex; align-items: flex-end;">
                    <div id="optimisation-edit-objective-due-date" style="padding: 0.5rem; font-size: 0.875rem; color: var(--dark-text-muted);"></div>
                  </div>
                </div>
                <div style="margin-bottom: 1rem;">
                  <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Plan</label>
                  <textarea id="optimisation-edit-objective-plan" rows="3" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; resize: vertical; background: var(--dark-bg); color: var(--dark-text);" placeholder="Describe your plan..."></textarea>
                </div>
                <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                  <button id="optimisation-cancel-edit-objective-btn" class="btn btn-secondary" style="padding: 0.5rem 1rem; font-size: 0.875rem;">Cancel</button>
                  <button id="optimisation-save-objective-btn" class="btn" style="padding: 0.5rem 1rem; font-size: 0.875rem;">Save</button>
                </div>
              </div>
            </div>

            <!-- Two Column Layout -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;">
              <!-- Left Column -->
              <div style="display: flex; flex-direction: column; gap: 1.5rem;">
                <!-- Performance Snapshot -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center; font-size: 0.95rem; color: var(--dark-text);">
                    <span>Performance Snapshot <span title="Shows current metrics compared to baseline measurement. Baseline is captured when the cycle starts, and latest shows the most recent measurement. Use 'Add Measurement' to capture new snapshots." style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></span>
                    <button id="optimisation-add-measurement-btn" class="btn btn-small" style="padding: 0.25rem 0.75rem; font-size: 0.875rem; background: var(--dark-brand); color: #000000; font-weight: 700; border: 1px solid var(--dark-brand);" title="Capture the latest metrics and compare to baseline.">Add Measurement</button>
                  </h4>
                  <div id="optimisation-metrics-snapshot" style="display: grid; grid-template-columns: 1.5fr 1fr 1fr; gap: 0.75rem; font-size: 0.9rem; color: var(--dark-text);">
                    <!-- Metrics will be populated by JavaScript -->
                    <div style="color: var(--dark-text-muted); font-style: italic; grid-column: 1 / -1;">Loading metrics...</div>
                  </div>
                </div>

                <!-- Measurement History -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; font-size: 0.95rem; display: flex; justify-content: space-between; align-items: center; color: var(--dark-text);">
                    <span>Measurement History <span title="Recent measurement snapshots for this cycle. Shows captured date, key metrics, and delta vs previous measurement." style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></span>
                    <button id="optimisation-measurement-history-toggle" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; background: rgba(156, 163, 175, 0.6); border: 1px solid var(--dark-border); border-radius: 4px; cursor: pointer;">Show</button>
                  </h4>
                  <div id="optimisation-measurement-history" style="display: none; max-height: 400px; overflow-y: auto;">
                    <div style="color: var(--dark-text-muted); font-style: italic;">Loading measurement history...</div>
                  </div>
                </div>

                <!-- Close Button -->
                <div style="padding-top: 1rem;">
                  <button id="optimisation-drawer-close-bottom" class="btn btn-secondary" style="width: 100%; padding: 0.5rem 1rem;">Close</button>
                </div>

              </div>

              <!-- Right Column -->
              <div style="display: flex; flex-direction: column; gap: 1.5rem;">
                <!-- Timeline/Events (Collapsible) -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center; cursor: pointer; font-size: 0.95rem; color: var(--dark-text);" id="optimisation-timeline-header">
                    <span>Timeline <span title="Chronological history of all events for this task: measurements, notes, status changes, and deployed changes. Click to expand or collapse the timeline view." style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></span>
                    <span id="optimisation-timeline-toggle" style="font-size: 1.2rem; user-select: none; color: var(--dark-text);"></span>
                  </h4>
                  <div id="optimisation-drawer-events-container" style="display: none;">
                    <div id="optimisation-drawer-events" style="border-left: 2px solid var(--dark-border); padding-left: 1rem; max-height: 400px; overflow-y: auto;">
                      <div style="color: var(--dark-text-muted); font-style: italic;">Loading events...</div>
                    </div>
                  </div>
                </div>

                <!-- Cycle Management -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; font-size: 0.95rem; color: var(--dark-text);">Cycle Management</h4>
                  <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                    <button id="optimisation-complete-cycle-btn" class="btn" style="width: 100%; padding: 0.5rem; font-size: 0.875rem; background: #059669; border-color: #059669; color: #ffffff; font-weight: 700;" title="Mark the current cycle as completed. This closes the cycle and makes it viewable in history.">Complete Cycle</button>
                    <button id="optimisation-archive-cycle-btn" class="btn btn-secondary" style="width: 100%; padding: 0.5rem; font-size: 0.875rem; background: #4b5563; color: #ffffff; font-weight: 700; border: 1px solid #4b5563;" title="Archive the current cycle (for abandoned work). The cycle remains in history but is marked as archived.">Archive Cycle</button>
                    <button id="optimisation-start-cycle-btn" class="btn btn-secondary" style="width: 100%; padding: 0.5rem; font-size: 0.875rem; background: rgba(156, 163, 175, 0.6); color: #000000; font-weight: 700; border: 1px solid var(--dark-border);" title="Begins a new optimisation attempt while preserving history from previous cycles.">Start New Cycle</button>
                  </div>
                </div>

                <!-- Add Event Form -->
                <div style="padding: 0.5rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.5rem; font-size: 0.95rem; color: var(--dark-text);">Add Event <span title="Record activities and milestones: Notes for observations, Change Deployed for updates, Measurement for metric snapshots, or Status Changed for workflow updates. All events appear in the Timeline." style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></h4>
                  <div style="margin-bottom: 0.5rem;">
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Event Type:</label>
                    <select id="optimisation-event-type" style="width: 100%; padding: 0.4rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);">
                      <option value="note">Note</option>
                      <option value="change_deployed">Change Deployed</option>
                      <option value="measurement">Measurement</option>
                      <option value="status_changed">Status Changed</option>
                    </select>
                  </div>
                  <div style="margin-bottom: 0.5rem;">
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Note:</label>
                    <textarea id="optimisation-event-note" rows="2" style="width: 100%; padding: 0.4rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);"></textarea>
                  </div>
                  <button id="optimisation-add-event-btn" class="btn btn-primary" style="width: 100%; padding: 0.5rem; font-size: 0.875rem; background: var(--dark-brand); color: #000000; font-weight: 700; border: 1px solid var(--dark-brand);" title="Adds the event to the timeline. Select the event type and add any notes, then click to record it.">Add Event</button>
                </div>

                <!-- Change Status -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; font-size: 0.95rem; color: var(--dark-text);">Change Status <span title="Status meanings:&#10; Planned: Task created but work not started&#10; In Progress: Currently being worked on&#10; Monitoring: Changes deployedmonitor metrics&#10; Done: Cycle completed; start a new cycle if optimising again&#10; Paused: Tracking stopped; you can start a new cycle later&#10; Cancelled: Tracking stopped; you can start a new cycle later&#10; Deleted: Task permanently removed" style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></h4>
                  <div style="display: flex; gap: 0.5rem;">
                    <select id="optimisation-change-status" style="flex: 1; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; background: var(--dark-bg); color: var(--dark-text);" title="Updates task workflow stage; adds a timeline event.">
                      <option value="">Change Status...</option>
                      <option value="planned" title="Task created but work not started">Planned</option>
                      <option value="in_progress" title="Currently being worked on">In Progress</option>
                      <option value="monitoring" title="Changes deployedmonitor metrics">Monitoring</option>
                      <option value="done" title="Cycle completed; start a new cycle if optimising again">Done</option>
                      <option value="paused" title="Tracking stopped; you can start a new cycle later">Paused</option>
                      <option value="cancelled" title="Tracking stopped; you can start a new cycle later">Cancelled</option>
                      <option value="deleted" title="Task permanently removed">Deleted</option>
                    </select>
                    <button id="optimisation-save-status-btn" class="btn btn-primary" title="Save the selected status change.">Save</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- History Panel -->
      <section class="aigeo-panel" data-panel="history">
        <!-- Supabase history charts / trend lines / previous audits will be inserted here by JS -->
      </section>

    </div>
      </div>
    </main>
    </div>

    <!-- Debug Panel - Fixed at bottom, collapsible -->
    <div class="debug-panel-bottom" id="debugPanel">
      <div class="debug-header" onclick="toggleDebugPanel()" style="cursor: pointer;">
        <h3> Debug Log</h3>
        <div class="debug-actions">
          <button class="btn btn-small" onclick="event.stopPropagation(); clearDebugLog();" title="Clear all debug log entries. Useful for starting fresh during troubleshooting.">Clear</button>
          <button class="btn btn-small" onclick="event.stopPropagation(); copyDebugLog();" title="Copy the entire debug log to your clipboard. Useful for sharing logs or troubleshooting issues.">Copy Log</button>
          <button class="btn btn-small" onclick="event.stopPropagation(); loadDebugLogFromSupabase();" title="Load the latest debug log from Supabase (saved after audit completion)">Load from Supabase</button>
          <button class="btn btn-small" id="debugFilterBtn" onclick="event.stopPropagation(); toggleDebugLogFilter();" title="Filter to show only warnings and errors">Filter: All</button>
          <span id="debugToggleIcon" style="color: #fff; font-size: 1.2rem;"></span>
        </div>
      </div>
      <div class="debug-content" id="debugLog" style="display: block;">
        <div class="debug-log-entry info">
          <span class="debug-timestamp">[Initializing...]</span>Debug panel loaded. Waiting for page initialization...
        </div>
      </div>
    </div>
  </div>

  <script>
    // Immediate console log to verify script is running
    console.log('%c=== GAIO AUDIT DASHBOARD LOADED ===', 'color: #E57200; font-size: 16px; font-weight: bold;');
    console.log('%cDebug panel should be visible at bottom with orange border', 'color: #E57200; font-size: 14px;');
    console.log('Current time:', new Date().toISOString());
    console.log('Page URL:', window.location.href);
    
    // Phase 4: Define helper functions IMMEDIATELY at script start
    // These are needed by renderMoneyPagesSuggestedTop10
    
    // Compute impact scores (0-100) based on CTR gap and click upside
    function computeImpactScores(pages, targetCtr = 0.025) {
      if (!pages || pages.length === 0) return;
      
      // Step 1: Compute upside_clicks for each page
      const upsideData = [];
      for (const p of pages) {
        const impressions = p.impressions || 0;
        const ctr = p.ctr || 0;
        
        // Edge case: impressions < 10 => impact = 0
        if (impressions < 10) {
          p.upside_clicks = 0;
          p.impact_score = 0;
          upsideData.push({ upside_clicks: 0 });
          continue;
        }
        
        // Calculate click upside: max(0, impressions * (target_ctr - ctr))
        const upside_clicks = Math.max(0, impressions * (targetCtr - ctr));
        p.upside_clicks = upside_clicks;
        upsideData.push({ upside_clicks });
      }
      
      // Step 2: Find max upside in the set
      const maxUpside = Math.max(...upsideData.map(d => d.upside_clicks), 0);
      
      // Step 3: Normalize to 0-100
      if (maxUpside <= 0) {
        // All pages flat  impact = 0 for all
        for (const p of pages) {
          p.impact_score = 0;
        }
        return;
      }
      
      // Normalize: impact = round(100 * upside_clicks / max_upside_clicks_in_set)
      for (let i = 0; i < pages.length; i++) {
        pages[i].impact_score = Math.round(100 * upsideData[i].upside_clicks / maxUpside);
      }
    }
    
    // Compute difficulty score (LOW/MED/HIGH) based on position
    function computeDifficultyScore(page) {
      const pos = page.avgPosition || page.position || 99;
      if (pos <= 3) return 'LOW';
      if (pos <= 10) return 'MED';
      return 'HIGH';
    }
    
    // Compute priority (LOW/MED/HIGH) combining impact and difficulty
    function computePriority(impactScore, difficulty) {
      let impactBucket;
      if (impactScore >= 70) impactBucket = 'HIGH';
      else if (impactScore >= 30) impactBucket = 'MED';
      else impactBucket = 'LOW';
      
      if (impactBucket === 'HIGH' && (difficulty === 'LOW' || difficulty === 'MED')) {
        return 'HIGH';
      }
      if (impactBucket === 'HIGH' && difficulty === 'HIGH') {
        return 'MED';
      }
      if (impactBucket === 'MED' && difficulty === 'LOW') {
        return 'MED';
      }
      return 'LOW';
    }
    
    // Get recommended action and task type based on page metrics
    function getRecommendedAction(page) {
      const ctr = (page.ctr || 0) * 100; // Convert to percentage
      const pos = page.avgPosition || page.position || 99;
      const impressions = page.impressions || 0;
      const clicks = page.clicks || 0;
      const targetCtr = 2.5;
      
      if (ctr < targetCtr && pos <= 10) {
        return {
          action: 'Improve CTR (title/meta/snippet) + strengthen content',
          taskType: 'on_page'
        };
      }
      if (ctr < targetCtr && pos > 10) {
        return {
          action: 'Improve relevance + internal links to lift rank',
          taskType: 'internal_links'
        };
      }
      if (impressions > 100 && clicks < 5 && ctr < 0.5) {
        return {
          action: 'Rewrite snippet + add intent-matching sections',
          taskType: 'content'
        };
      }
      return {
        action: 'Review page manually',
        taskType: 'on_page'
      };
    }
    
    // Phase 4: Define renderMoneyPagesSuggestedTop10 function IMMEDIATELY at script start
    // This ensures it's available before any code tries to call it
    window.renderMoneyPagesSuggestedTop10 = function(moneyPagesRows) {
      // Helper functions are now defined above, so we can use them directly
      try {
        // Helper functions are available, use full implementation
        console.log('[Money Pages Suggested Top 10] Full implementation executing');
        try {
          const container = document.getElementById('money-pages-suggested-top10-content');
          if (!container) {
            console.warn('[Money Pages Suggested Top 10] Container not found, retrying in 500ms...');
            // Retry after a delay in case DOM isn't ready yet
            setTimeout(() => {
              if (typeof window.renderMoneyPagesSuggestedTop10 === 'function') {
                window.renderMoneyPagesSuggestedTop10(moneyPagesRows);
              }
            }, 500);
            return;
          }
          
          if (!moneyPagesRows || moneyPagesRows.length === 0) {
            container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b; font-size: 0.9rem;">No money pages data available.</div>';
            return;
          }
          
          // Create a copy of rows to avoid mutating original
          const pages = moneyPagesRows.map(row => ({
            url: row.url || row.page_url || '',
            title: row.title || row.page_title || row.url || '',
            clicks: row.clicks || row.clicks_28d || 0,
            impressions: row.impressions || row.impressions_28d || 0,
            ctr: row.ctr || row.ctr_28d || 0,
            avgPosition: row.avgPosition || row.position || row.position_28d || null,
            subSegment: row.subSegment || row.segmentType || 'Landing'
          }));
          
          // Compute Phase 4 scores
          computeImpactScores(pages, 0.025);
          for (const page of pages) {
            page.difficulty = computeDifficultyScore(page);
            page.priority = computePriority(page.impact_score || 0, page.difficulty);
            const { action, taskType } = getRecommendedAction(page);
            page.recommended_action = action;
            page.recommended_task_type = taskType;
          }
          
          // Sort by priority (HIGH > MED > LOW) then by upside_clicks desc
          const priorityOrder = { HIGH: 0, MED: 1, LOW: 2 };
          pages.sort((a, b) => {
            const priorityDiff = (priorityOrder[a.priority] ?? 99) - (priorityOrder[b.priority] ?? 99);
            if (priorityDiff !== 0) return priorityDiff;
            return (b.upside_clicks || 0) - (a.upside_clicks || 0);
          });
          
          // Take top 10
          const top10 = pages.slice(0, 10);
          
          if (top10.length === 0) {
            container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b; font-size: 0.9rem;">No pages meet the criteria for suggested optimization.</div>';
            return;
          }
          
          // Render as a grid of cards
          const html = `
            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem;">
              ${top10.map((page, idx) => {
                const priority = page.priority || 'LOW';
                const priorityColor = priority === 'HIGH' ? '#10b981' : priority === 'MED' ? '#f59e0b' : '#64748b';
                const priorityBg = priority === 'HIGH' ? '#dcfce7' : priority === 'MED' ? '#fef3c7' : '#f1f5f9';
                const difficulty = page.difficulty || 'MED';
                const difficultyColor = difficulty === 'LOW' ? '#10b981' : difficulty === 'MED' ? '#f59e0b' : '#ef4444';
                const ctrPct = ((page.ctr || 0) * 100).toFixed(1);
                
                return `
                  <div style="padding: 1rem; background: white; border: 1px solid #e2e8f0; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.75rem;">
                      <div style="flex: 1; min-width: 0;">
                        <div style="font-weight: 600; color: #1e293b; margin-bottom: 0.25rem; font-size: 0.9rem; line-height: 1.4; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;" title="${page.title}">${page.title}</div>
                        <div style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">${page.subSegment}</div>
                      </div>
                      <span style="display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.7rem; font-weight: 600; background: ${priorityBg}; color: ${priorityColor}; border: 1px solid ${priorityColor}40; white-space: nowrap; margin-left: 0.5rem;">${priority}</span>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; margin-bottom: 0.75rem; font-size: 0.8rem;">
                      <div><span style="color: #64748b;">Pos:</span> <strong>${page.avgPosition ? page.avgPosition.toFixed(1) : ''}</strong></div>
                      <div><span style="color: #64748b;">CTR:</span> <strong>${ctrPct}%</strong></div>
                      <div><span style="color: #64748b;">Impr:</span> <strong>${(page.impressions || 0).toLocaleString()}</strong></div>
                      <div><span style="color: #64748b;">Upside:</span> <strong>${(page.upside_clicks || 0).toFixed(0)}</strong></div>
                      <div><span style="color: #64748b;">Impact:</span> <strong>${page.impact_score != null ? page.impact_score : ''}</strong></div>
                      <div><span style="color: #64748b;">Difficulty:</span> <strong style="color: ${difficultyColor};">${difficulty}</strong></div>
                    </div>
                    <div style="font-size: 0.75rem; color: #475569; margin-bottom: 0.75rem; line-height: 1.4; min-height: 2.5rem;">${page.recommended_action || 'Review page manually'}</div>
                    <button onclick="window.createMoneyPageTask && window.createMoneyPageTask('${page.url.replace(/'/g, "\\'")}', '${(page.recommended_task_type || 'on_page').replace(/'/g, "\\'")}', ${JSON.stringify({
                      clicks: page.clicks || 0,
                      impressions: page.impressions || 0,
                      ctr: page.ctr || 0,
                      position: page.avgPosition || null
                    }).replace(/'/g, "\\'")})" style="width: 100%; padding: 0.6rem; background: #2563eb; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85rem; font-weight: 600; transition: background 0.2s;" onmouseover="this.style.background='#1d4ed8';" onmouseout="this.style.background='#2563eb';" title="Create optimisation task for this page">Create Task</button>
                  </div>
                `;
              }).join('')}
            </div>
          `;
          
          container.innerHTML = html;
          console.log(`[Money Pages Suggested Top 10]  Rendered ${top10.length} pages`);
          if (typeof debugLog === 'function') {
            debugLog(` Suggested Top 10 rendered with ${top10.length} pages`, 'success');
          }
        } catch (error) {
          console.error('[Money Pages Suggested Top 10] Error rendering:', error);
          const container = document.getElementById('money-pages-suggested-top10-content');
          if (container) {
            container.innerHTML = `<div style="padding: 2rem; text-align: center; color: #ef4444; font-size: 0.9rem;">Error rendering suggested pages: ${error.message}</div>`;
          }
        }
      } catch (error) {
        console.error('[Money Pages Suggested Top 10] Error rendering:', error);
        const container = document.getElementById('money-pages-suggested-top10-content');
        if (container) {
          container.innerHTML = `<div style="padding: 2rem; text-align: center; color: #ef4444; font-size: 0.9rem;">Error rendering suggested pages: ${error.message}</div>`;
        }
      }
    };
    
    // Helper function to safely save to localStorage (handles quota errors gracefully)
    // Define apiUrl helper IMMEDIATELY at the top level so it's available to all functions
    // This must be defined before any functions that use it
    (function() {
      const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
        ? 'https://ai-geo-audit.vercel.app' // Change this to your Vercel deployment URL
        : '';
      
      window.apiUrl = function apiUrl(path) {
        if (!API_BASE_URL) {
          // When deployed on Vercel, use relative paths
          return path.startsWith('/') ? path : `/${path}`;
        }
        // When running locally, prepend the Vercel URL
        // Handle paths with or without leading slash
        const cleanPath = path.startsWith('/') ? path : `/${path}`;
        return `${API_BASE_URL}${cleanPath}`;
      };
    })();
    
    // ======================
    // Optimisation Tracking Utilities (Phase 2)
    // ======================
    // Normalization functions matching DB helpers (arp_keyword_key, arp_clean_url)
    window.keywordKey = function keywordKey(keyword) {
      if (!keyword || typeof keyword !== 'string') return null;
      return keyword.trim().replace(/\s+/g, ' ').toLowerCase();
    };

    window.cleanUrlForKey = function cleanUrlForKey(url) {
      if (!url || typeof url !== 'string') return null;
      // Remove fragment (#)
      let cleaned = url.split('#')[0];
      // Remove query string (?)
      cleaned = cleaned.split('?')[0];
      // Remove protocol (http:// or https://)
      cleaned = cleaned.replace(/^https?:\/\//, '');
      // Remove trailing slashes
      cleaned = cleaned.replace(/\/+$/, '');
      return cleaned;
    };

    // Clean URL but keep protocol (for display in modals)
    window.cleanUrlForDisplay = function cleanUrlForDisplay(url) {
      if (!url || typeof url !== 'string') return '';
      // Remove fragment (#)
      let cleaned = url.split('#')[0];
      // Remove query string (?)
      cleaned = cleaned.split('?')[0];
      // Remove trailing slashes
      cleaned = cleaned.replace(/\/+$/, '');
      return cleaned;
    };

    // Admin key utilities (Phase A - Security)
    window.getAdminKey = function getAdminKey() {
      if (typeof window === "undefined") return "";
      return sessionStorage.getItem("arp_admin_key") || "";
    };

    window.setAdminKey = function setAdminKey(key) {
      if (typeof window === "undefined") return;
      sessionStorage.setItem("arp_admin_key", key);
    };

    window.hasAdminKey = function hasAdminKey() {
      return window.getAdminKey().length > 0;
    };

    window.clearAdminKey = function clearAdminKey() {
      if (typeof window === "undefined") return;
      sessionStorage.removeItem("arp_admin_key");
    };

    // Share mode detection
    const urlParams = new URLSearchParams(window.location.search);
    window.isShareMode = urlParams.get('share') === '1';
    window.shareToken = urlParams.get('st') || '';

    // Helper to build headers with admin key or share token
    window.getOptimisationHeaders = function getOptimisationHeaders() {
      const headers = { 'Content-Type': 'application/json' };
      if (window.isShareMode && window.shareToken) {
        headers['x-arp-share-token'] = window.shareToken;
      } else {
      const adminKey = window.getAdminKey();
      if (adminKey) {
        headers['x-arp-admin-key'] = adminKey;
        }
      }
      return headers;
    };

    // Cache for optimisation status (keyed by keyword_key::target_url_clean::task_type)
    window.optimisationStatusCache = new Map();

    // Fetch optimisation statuses in bulk
    window.fetchOptimisationStatuses = async function fetchOptimisationStatuses(rows) {
      if (!rows || rows.length === 0) {
        window.optimisationStatusCache.clear();
        return;
      }

      try {
        // Build unique set of keyword keys and URL keys
        const keywordKeys = new Set();
        const urlKeys = new Set();
        rows.forEach(row => {
          const kwKey = window.keywordKey ? window.keywordKey(row.keyword || '') : (row.keyword || '').toLowerCase().trim();
          const url = row.best_url || row.targetUrl || row.ranking_url || '';
          const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(url) : url.toLowerCase().trim();
          // Add keyword key (can be empty string for page-level tasks)
          keywordKeys.add(kwKey || '');
          if (urlKey) urlKeys.add(urlKey);
        });
        
        // DEBUG: Log what we're sending to the API
        if (Array.from(urlKeys).some(u => u.includes('landscape-photography-workshops'))) {
          console.log('[Optimisation] Sending to API:', {
            urlKeys: Array.from(urlKeys).filter(u => u.includes('landscape')),
            keywordKeys: Array.from(keywordKeys),
            totalUrlKeys: urlKeys.size,
            totalKeywordKeys: keywordKeys.size
          });
        }

        // Don't require keywordKeys - page-level tasks have empty keyword keys
        if (urlKeys.size === 0) {
          window.optimisationStatusCache.clear();
          return;
        }

        // Fetch from API endpoint (we'll create this)
        const response = await fetch(apiUrl('/api/optimisation/status'), {
          method: 'POST',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            keyword_keys: Array.from(keywordKeys),
            url_keys: Array.from(urlKeys)
          })
        });

        if (!response.ok) {
          console.warn('[Optimisation] Failed to fetch statuses:', response.status);
          window.optimisationStatusCache.clear();
          return;
        }

        const data = await response.json();
        
        // DEBUG: Log raw API response structure with full details
        console.log('[Optimisation] API response received:', {
          statusCount: data.statuses?.length || 0,
          sampleStatus: data.statuses?.[0] || null,
          sampleStatusKeys: data.statuses?.[0] ? Object.keys(data.statuses[0]) : [],
          allStatusesWithId: (data.statuses || []).map(s => ({
            id: s.id,
            task_id: s.task_id,
            hasId: 'id' in s,
            hasTaskId: 'task_id' in s,
            keyword_key: s.keyword_key,
            target_url_clean: s.target_url_clean,
            status: s.status
          }))
        });
        
        // CRITICAL: Preserve ALL existing cache entries BEFORE clearing
        // We'll restore any that aren't returned by the API
        const now = Date.now();
        const immediateEntryAgeLimit = 10000; // 10 seconds
        const preservedEntries = new Map();
        
        // Build set of keys we're about to fetch
        const keysBeingFetched = new Set();
        rows.forEach(row => {
          const kwKey = window.keywordKey ? window.keywordKey(row.keyword || '') : (row.keyword || '').toLowerCase().trim();
          const url = row.best_url || row.targetUrl || row.ranking_url || '';
          const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(url) : url.toLowerCase().trim();
          // Build all possible cache keys for this row (different task types)
          // 'on_page' for page-level tasks, 'content' for keyword-level tasks from Ranking & AI
          ['on_page', 'content'].forEach(taskType => {
            const cacheKey = kwKey ? `${kwKey}::${urlKey}::${taskType}` : `::${urlKey}::${taskType}`;
            keysBeingFetched.add(cacheKey);
          });
        });
        
        // CRITICAL: Preserve ALL existing entries for keys we're fetching
        // This way, if the API doesn't return them, we keep the existing cache entry
        if (window.optimisationStatusCache && window.optimisationStatusCache.size > 0) {
          window.optimisationStatusCache.forEach((value, key) => {
            // Always preserve entries for keys we're fetching (in case API doesn't return them)
            if (keysBeingFetched.has(key)) {
              preservedEntries.set(key, value);
              console.log(`[Optimisation] Preserving existing cache entry for key being fetched: key="${key}", id="${value.id || value.task_id || 'null'}"`);
            }
            // Also preserve entries that are NOT being fetched in this call
            // This prevents clearing cache for other rows that aren't part of this fetch
            if (!keysBeingFetched.has(key)) {
              preservedEntries.set(key, value);
            }
          });
        }
        
        // CRITICAL: Clear entries for keys we're fetching (we'll restore them if API doesn't return them)
        keysBeingFetched.forEach(key => {
          window.optimisationStatusCache.delete(key);
        });
        console.log(`[Optimisation] Cleared ${keysBeingFetched.size} keys from cache, preserved ${preservedEntries.size} entries (${Array.from(preservedEntries.keys()).filter(k => keysBeingFetched.has(k)).length} for keys being fetched)`);

        // Build cache map: key = keyword_key::target_url_clean::task_type
        // For page-level tasks, keyword_key is null or empty string - use empty string for consistency
        (data.statuses || []).forEach(status => {
          // CRITICAL: Ensure id field is always present - use task_id as fallback if needed
          if (!status.id) {
            if (status.task_id) {
              status.id = status.task_id;
              console.warn('[Optimisation] API response missing id field, using task_id as fallback:', {
                task_id: status.task_id,
                url: status.target_url_clean,
                status: status.status,
                allKeys: Object.keys(status)
              });
            } else {
              console.error('[Optimisation] Status object missing both id and task_id fields - skipping:', {
                status,
                keys: Object.keys(status),
                keyword_key: status.keyword_key,
                target_url_clean: status.target_url_clean
              });
              return; // Skip this status entry
            }
          }
          
          // CRITICAL: Also ensure task_id is set if missing (for backward compatibility)
          if (!status.task_id && status.id) {
            status.task_id = status.id;
          }
          
          // Normalize keyword_key: convert null/undefined to empty string, trim whitespace
          const keywordKey = (status.keyword_key || '').trim();
          // Normalize target_url_clean using cleanUrlForKey to ensure consistent lookup
          // The API returns target_url_clean, but we need to normalize it the same way we normalize URLs in getOptimisationStatus
          const normalizedUrl = window.cleanUrlForKey ? window.cleanUrlForKey(status.target_url_clean || status.target_url || '') : (status.target_url_clean || status.target_url || '').toLowerCase().trim();
          
          // DEBUG: Log every status being cached (especially page-level tasks)
          if (!status.keyword_key || status.keyword_key.trim() === '') {
            console.log('[Optimisation] Caching page-level task:', {
              key: `::${normalizedUrl}::${status.task_type || 'on_page'}`,
              id: status.id,
              task_id: status.task_id,
              url: status.target_url_clean,
              normalizedUrl: normalizedUrl,
              status: status.status,
              hasId: 'id' in status,
              hasTaskId: 'task_id' in status
            });
          }
          // For page-level tasks (empty keyword_key), use :: prefix to match getOptimisationStatus format
          // For keyword-level tasks, use keyword_key:: prefix
          const key = keywordKey ? `${keywordKey}::${normalizedUrl}::${status.task_type || 'on_page'}` : `::${normalizedUrl}::${status.task_type || 'on_page'}`;
          // Always update/overwrite with API data (API is source of truth for existing tasks)
          window.optimisationStatusCache.set(key, status);
          // Debug: Log page-level tasks with id verification
          if (!keywordKey) {
            debugLog(`[Optimisation] Cached page-level task: key="${key}", id="${status.id}", url="${status.target_url_clean}", normalized="${normalizedUrl}", status="${status.status}"`, 'info');
            // Special debug for landscape page
            if (normalizedUrl.includes('landscape-photography-workshops') || status.target_url_clean?.includes('landscape-photography-workshops')) {
              debugLog(`[Optimisation]  Landscape page task cached: key="${key}", id="${status.id}", status="${status.status}"`, 'success');
            }
          }
        });
        
        // CRITICAL: Restore preserved entries that weren't returned by the API
        // This includes both immediate cache entries AND existing entries that the API didn't return
        const keysReturnedByApi = new Set();
        (data.statuses || []).forEach(status => {
          const keywordKey = (status.keyword_key || '').trim();
          const normalizedUrl = window.cleanUrlForKey ? window.cleanUrlForKey(status.target_url_clean || status.target_url || '') : (status.target_url_clean || status.target_url || '').toLowerCase().trim();
          const key = keywordKey ? `${keywordKey}::${normalizedUrl}::${status.task_type || 'on_page'}` : `::${normalizedUrl}::${status.task_type || 'on_page'}`;
          keysReturnedByApi.add(key);
        });
        
        preservedEntries.forEach((value, key) => {
          if (!keysReturnedByApi.has(key)) {
            // API didn't return this entry - restore the preserved one
            window.optimisationStatusCache.set(key, value);
            console.log(`[Optimisation] Restored preserved entry (not returned by API): key="${key}", id="${value.id || value.task_id || 'null'}", status="${value.status || 'null'}"`);
          } else {
            // API returned this entry - verify it has id field
            const apiStatus = window.optimisationStatusCache.get(key);
            if (apiStatus) {
              console.log(`[Optimisation] Entry returned by API: key="${key}", apiId="${apiStatus.id || apiStatus.task_id || 'null'}", preservedId="${value.id || value.task_id || 'null'}"`);
              // Ensure API status has id field - if not, keep the preserved entry
              if (!apiStatus.id && !apiStatus.task_id && (value.id || value.task_id)) {
                console.warn(`[Optimisation] API status missing id field, keeping preserved entry: key="${key}"`);
                window.optimisationStatusCache.set(key, value);
              }
            }
          }
        });
        
        console.log(`[Optimisation] Cache refreshed: ${window.optimisationStatusCache.size} entries (${preservedEntries.size} preserved immediate entries)`);

        console.log(`[Optimisation] Loaded ${window.optimisationStatusCache.size} status records (${(data.statuses || []).filter(s => !s.keyword_key || s.keyword_key.trim() === '').length} page-level)`);
      } catch (error) {
        console.error('[Optimisation] Error fetching statuses:', error);
        window.optimisationStatusCache.clear();
      }
    };

    // Get optimisation status for a row
    window.getOptimisationStatus = function getOptimisationStatus(row, taskType = 'on_page') {
      const kwKey = window.keywordKey ? window.keywordKey(row.keyword || '') : (row.keyword || '').toLowerCase().trim();
      const url = row.best_url || row.targetUrl || row.ranking_url || '';
      const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(url) : url.toLowerCase().trim();
      
      // For page-level tasks (on_page), keyword can be empty - only require urlKey
      // For keyword-level tasks (content, keyword, etc.), require both kwKey and urlKey
      if (taskType === 'on_page') {
        if (!urlKey) return null;
        // For page-level tasks, use empty string for keyword_key
        const key = `::${urlKey}::${taskType}`;
        const status = window.optimisationStatusCache.get(key) || null;
        
        // CRITICAL: Ensure status object has id field (use task_id as fallback)
        if (status && !status.id) {
          if (status.task_id) {
            status.id = status.task_id;
            console.warn('[Optimisation] Status object missing id field, using task_id as fallback:', {
              task_id: status.task_id,
              url: status.target_url_clean || url,
              key
            });
          } else {
            console.error('[Optimisation] Status object missing both id and task_id fields:', {
              status,
              url,
              key
            });
            return null; // Return null if no id available
          }
        }
        
        // Debug logging for landscape page
        if (url && url.includes('landscape-photography-workshops')) {
          console.log(`[Optimisation] getOptimisationStatus lookup: key="${key}", found=${!!status}, cacheSize=${window.optimisationStatusCache.size}, id="${status?.id || 'null'}", task_id="${status?.task_id || 'null'}"`);
          if (status) {
            console.log(`[Optimisation] Status object retrieved:`, {
              id: status.id,
              task_id: status.task_id,
              hasId: 'id' in status,
              hasTaskId: 'task_id' in status,
              status: status.status,
              allKeys: Object.keys(status).slice(0, 15)
            });
          } else {
            // Log all keys in cache for debugging
            const allKeys = Array.from(window.optimisationStatusCache.keys());
            console.log(`[Optimisation] Cache keys (first 10):`, allKeys.slice(0, 10));
            const matchingKeys = allKeys.filter(k => k.includes('landscape') || k.includes(urlKey));
            console.log(`[Optimisation] Matching keys:`, matchingKeys);
            // Also log what's in the cache for matching keys
            matchingKeys.forEach(mk => {
              const cached = window.optimisationStatusCache.get(mk);
              console.log(`[Optimisation] Cached entry for "${mk}":`, {
                id: cached?.id,
                task_id: cached?.task_id,
                status: cached?.status,
                hasId: cached ? ('id' in cached) : false
              });
            });
          }
        }
        return status;
      } else {
        // Keyword-level tasks require both
      if (!kwKey || !urlKey) return null;
      const key = `${kwKey}::${urlKey}::${taskType}`;
      return window.optimisationStatusCache.get(key) || null;
      }
    };

    // ======================
    // Optimisation Tracking Modals (Phase 2)
    // ======================
    
    // Open Track Keyword modal
    window.openTrackKeywordModal = function openTrackKeywordModal(row, taskType = 'on_page') {
      console.log('[Optimisation] openTrackKeywordModal called', { row, taskType });
      const modal = document.getElementById('optimisation-track-modal');
      if (!modal) {
        console.error('[Optimisation] Track modal not found');
        alert('Track modal not found. Please refresh the page.');
        return;
      }

      // Get and clean URL (remove query strings and fragments)
      const rawUrl = row.best_url || row.targetUrl || row.ranking_url || '';
      console.log('[Optimisation] Raw URL:', rawUrl);
      if (!window.cleanUrlForDisplay) {
        console.error('[Optimisation] cleanUrlForDisplay function not found');
        alert('Error: cleanUrlForDisplay function not found. Please refresh the page.');
        return;
      }
      const cleanedUrl = window.cleanUrlForDisplay(rawUrl);
      console.log('[Optimisation] Cleaned URL:', cleanedUrl);

      // Populate fields
      document.getElementById('track-keyword-text').textContent = row.keyword;
      
      // Make URL clickable in Track modal
      const trackUrlContainer = document.getElementById('track-url-text');
      trackUrlContainer.innerHTML = ''; // Clear existing content
      if (cleanedUrl) {
        // Ensure URL has protocol
        let fullUrl = cleanedUrl;
        if (!fullUrl.startsWith('http://') && !fullUrl.startsWith('https://')) {
          fullUrl = 'https://' + fullUrl;
        }
        const urlLink = document.createElement('a');
        urlLink.href = fullUrl;
        urlLink.target = '_blank';
        urlLink.rel = 'noopener noreferrer';
        urlLink.textContent = cleanedUrl;
        urlLink.style.color = '#0284c7';
        urlLink.style.textDecoration = 'none';
        urlLink.style.fontWeight = '600';
        urlLink.style.wordBreak = 'break-all';
        urlLink.addEventListener('mouseenter', () => {
          urlLink.style.textDecoration = 'underline';
        });
        urlLink.addEventListener('mouseleave', () => {
          urlLink.style.textDecoration = 'none';
        });
        trackUrlContainer.appendChild(urlLink);
      } else {
        trackUrlContainer.textContent = 'No URL available';
      }
      
      document.getElementById('track-task-type').value = taskType;
      document.getElementById('track-status').value = 'planned';
      // For keyword-level tasks, suggest keyword as title; for page-level, leave empty
      const suggestedTitle = (taskType !== 'on_page' && row.keyword) ? row.keyword : '';
      document.getElementById('track-title').value = suggestedTitle;
      document.getElementById('track-notes').value = '';
      // Reset objective fields
      document.getElementById('track-objective-title').value = '';
      document.getElementById('track-primary-kpi').value = '';
      document.getElementById('track-target-direction').value = '';
      document.getElementById('track-target-value').value = '';
      document.getElementById('track-timeframe-days').value = '';
      
      // Populate Plan / Hypothesis from Priority & Next Actions
      let planText = '';
      try {
        const scorecardData = buildKeywordScorecardData(row);
        if (scorecardData) {
          const actions = generateActionBullets(scorecardData);
          if (actions && actions.length > 0) {
            planText = actions.join('\n');
          }
        }
      } catch (e) {
        console.warn('[Optimisation] Error generating plan from scorecard:', e);
      }
      document.getElementById('track-plan').value = planText;

      // Store cleaned URL and row data for submit (row data needed for baseline metrics)
      modal.dataset.rowKeyword = row.keyword;
      modal.dataset.rowUrl = cleanedUrl;
      modal.dataset.taskType = taskType;
      // Store row data as JSON string for baseline metrics
      modal.dataset.rowData = JSON.stringify(row);

      modal.style.display = 'flex';
    };

    // Submit Track Keyword
    window.submitTrackKeyword = async function submitTrackKeyword() {
      const modal = document.getElementById('optimisation-track-modal');
      if (!modal) return;

      const keyword = modal.dataset.rowKeyword;
      // Get cleaned URL from dataset (already cleaned when modal opened)
      let targetUrl = modal.dataset.rowUrl || '';
      // Double-check it's cleaned (in case it was modified elsewhere)
      targetUrl = window.cleanUrlForDisplay(targetUrl);
      const taskType = modal.dataset.taskType || document.getElementById('track-task-type').value;
      const status = document.getElementById('track-status').value;
      const title = document.getElementById('track-title').value.trim();
      const notes = document.getElementById('track-notes').value.trim();
      
      // Get objective fields (Phase B)
      const objective_title = document.getElementById('track-objective-title').value.trim();
      const primary_kpi = document.getElementById('track-primary-kpi').value.trim();
      // Map primary_kpi to objective_kpi (ctr_28d is the only CTR option now)
      const objective_kpi = primary_kpi === 'ctr_28d' ? 'ctr_28d' : primary_kpi;
      const objective_metric = objective_kpi; // Use same value for metric
      const objective_direction = document.getElementById('track-target-direction').value.trim();
      const objective_target_delta = document.getElementById('track-target-value').value.trim() ? parseFloat(document.getElementById('track-target-value').value) : null;
      const objective_timeframe_days = document.getElementById('track-timeframe-days').value.trim() ? parseInt(document.getElementById('track-timeframe-days').value) : null;
      const objective_plan = document.getElementById('track-plan').value.trim();
      
      // Calculate objective_due_at if timeframe is set
      let objective_due_at = null;
      if (objective_timeframe_days) {
        const startDate = new Date();
        objective_due_at = new Date(startDate.getTime() + objective_timeframe_days * 24 * 60 * 60 * 1000).toISOString();
      }

      // For Money Pages (page-level tasks), keyword is empty - only require targetUrl
      // For Ranking & AI (keyword-level tasks), both keyword and targetUrl are required
      const source = modal.dataset.source || '';
      if (source === 'money_pages') {
        // Money Pages: only require targetUrl (keyword is empty for page-level tasks)
        if (!targetUrl) {
          alert('Missing target URL');
          return;
        }
      } else {
        // Ranking & AI: require both keyword and targetUrl
      if (!keyword || !targetUrl) {
        alert('Missing keyword or URL');
        return;
        }
      }

      // Build baseline metrics from row data (stored in modal dataset)
      const rowDataStr = modal.dataset.rowData;
      // source is already declared above (line 5556)
      let baselineMetrics = null;
      if (rowDataStr) {
        try {
          const rowData = JSON.parse(rowDataStr);
          
          // Check if this is a Money Pages task (page-level)
          if (source === 'money_pages' || !keyword) {
            // Money Pages: use page-level metrics directly from row data
            // Debug: Log row data to see what we're working with
            console.log('[Money Pages] Building baseline metrics from row data:', {
              clicks: rowData.clicks,
              impressions: rowData.impressions,
              ctr: rowData.ctr,
              avgPosition: rowData.avgPosition,
              position: rowData.position,
              url: rowData.url
            });
            
            baselineMetrics = {
              gsc_clicks_28d: rowData.clicks != null ? rowData.clicks : (rowData.clicks_28d || 0),
              gsc_impressions_28d: rowData.impressions != null ? rowData.impressions : (rowData.impressions_28d || 0),
              // rowData.ctr is already a ratio (0-1) from pageTotalsByKey
              gsc_ctr_28d: rowData.ctr != null ? rowData.ctr : (rowData.ctr_28d != null ? rowData.ctr_28d : 0),
              gsc_position_28d: rowData.avgPosition != null ? rowData.avgPosition : (rowData.position != null ? rowData.position : (rowData.position_28d || null)),
              classic_ranking_url: rowData.url || rowData.targetUrl || targetUrl || null,
              segment: rowData.segment || 'money_pages',
              captured_at: new Date().toISOString()
            };
            
            console.log('[Money Pages] Built baseline metrics:', baselineMetrics);
          } else {
            // Ranking & AI: use keyword-based metrics
          // Get queryTotal data for clicks, impressions, and CTR
          let queryTotal = null;
          if (typeof getQueryTotalForKeyword === 'function') {
            queryTotal = getQueryTotalForKeyword(keyword);
          }
          
          baselineMetrics = {
            gsc_clicks_28d: (queryTotal && queryTotal.clicks) || rowData.gsc_clicks_28d || rowData.clicks_28d || null,
            gsc_impressions_28d: (queryTotal && queryTotal.impressions) || rowData.gsc_impressions_28d || rowData.impressions_28d || null,
            // queryTotal.ctr is a percentage (0-100), convert to decimal for storage
            gsc_ctr_28d: (queryTotal && queryTotal.ctr != null) ? (queryTotal.ctr / 100) : (rowData.gsc_ctr_28d || rowData.ctr_28d || null),
            current_rank: rowData.best_rank_group || rowData.current_rank || null,
            opportunity_score: rowData.opportunityScore || null,
            ai_overview: rowData.has_ai_overview || false,
            ai_citations: rowData.ai_alan_citations_count || 0,
            ai_citations_total: rowData.ai_total_citations || 0,
            classic_ranking_url: rowData.best_url || rowData.targetUrl || rowData.ranking_url || null,
            page_type: rowData.pageType || null,
            segment: rowData.segment || null,
            captured_at: new Date().toISOString()
          };
          }
        } catch (e) {
          console.error('[Optimisation] Failed to parse row data for baseline metrics:', e);
        }
      }

      try {
        const source = modal.dataset.source || '';
        console.log('[Money Pages] Source from modal:', source, 'modal.dataset:', modal.dataset);
        // Debug: Log what we're sending to API
        console.log('[Money Pages] Sending task creation request with baselineMetrics:', baselineMetrics);
        debugLog(` Creating task with baseline: clicks=${baselineMetrics?.gsc_clicks_28d || 0}, impressions=${baselineMetrics?.gsc_impressions_28d || 0}, CTR=${((baselineMetrics?.gsc_ctr_28d || 0) * 100).toFixed(2)}%`, 'info');
        
        // Debug: Log what we're sending
        const requestBody = {
          keyword_text: keyword || '', // Empty for page-level tasks
            target_url: targetUrl,
            task_type: taskType,
            status: status,
            title: title || null,
            notes: notes || null,
          source: source, // Pass source to API
            baselineMetrics: baselineMetrics,
            // Phase B objective fields
            objective_title: objective_title || null,
            objective_kpi: objective_kpi || null,
            objective_metric: objective_metric || null,
            objective_direction: objective_direction || null,
            objective_target_delta: objective_target_delta,
            objective_timeframe_days: objective_timeframe_days,
            objective_due_at: objective_due_at,
            objective_plan: objective_plan || null,
            // Also set cycle_started_at when creating task
            cycle_started_at: new Date().toISOString()
        };
        
        console.log('[Money Pages] Sending task creation request:', {
          target_url: requestBody.target_url,
          source: requestBody.source,
          hasBaselineMetrics: !!requestBody.baselineMetrics,
          baselineMetrics: requestBody.baselineMetrics
        });
        
        const response = await fetch(apiUrl('/api/optimisation/task'), {
          method: 'POST',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
          if (response.status === 401) {
            throw new Error('Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.');
          }
          
          // Handle duplicate task error (409 Conflict)
          if (response.status === 409) {
            try {
              const errorData = await response.json();
              if (errorData.existingTaskId) {
                // Task already exists - open it instead
                alert(`A task already exists for this page. Opening existing task...`);
                if (typeof window.openOptimisationTaskDrawer === 'function') {
                  window.openOptimisationTaskDrawer(errorData.existingTaskId);
                }
                modal.style.display = 'none';
                return;
              }
              throw new Error(errorData.error || 'A task already exists for this keyword/URL combination');
            } catch (e) {
              throw new Error('A task already exists for this keyword/URL combination. Please use the "Manage" button instead.');
            }
          }
          
          const error = await response.text();
          throw new Error(error || 'Failed to create task');
        }

        const result = await response.json();
        console.log('[Money Pages] Task creation response:', {
          success: response.ok,
          taskId: result.task?.id,
          hasBaselineMeasurement: result.baselineMeasurementCreated || false
        });
        
        if (!response.ok) {
          console.error('[Money Pages] Task creation failed:', result);
        }
        
        const createdTask = result.task;
        const createdTaskId = createdTask?.id;
        const createdTaskUrl = createdTask?.target_url || targetUrl;
        
        // Validate task was created successfully
        if (!createdTaskId) {
          console.error('[Money Pages] Task creation failed: no task ID returned', {
            result,
            createdTask,
            response: result
          });
          throw new Error('Task creation failed: no task ID returned. Please try again.');
        }
        
        // Re-read source from modal (in case it was lost)
        const currentSource = modal.dataset.source || source || '';

        console.log('[Money Pages] Task created successfully:', {
          taskId: createdTaskId,
          url: createdTaskUrl,
          source: currentSource,
          originalSource: source,
          task: createdTask,
          taskKeys: createdTask ? Object.keys(createdTask) : []
        });

        // Close modal
        modal.style.display = 'none';
        
        // Handle Money Pages vs Ranking & AI differently
        if (currentSource === 'money_pages' && createdTask && createdTaskUrl) {
          console.log('[Money Pages] Processing Money Pages task creation...');
          
          // CRITICAL: Immediately add the created task to the cache so the table can find it
          // This avoids waiting for the database view to refresh
          const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(createdTaskUrl) : createdTaskUrl.toLowerCase().trim();
          const cacheKey = `::${urlKey}::on_page`;
          
          console.log('[Money Pages] URL normalization:', {
            original: createdTaskUrl,
            normalized: urlKey,
            cacheKey
          });
          
          // Build a status object that matches what the API would return
          // CRITICAL: Ensure id field is set (API uses 'id', not 'task_id')
          const immediateStatus = {
            id: createdTaskId, // This is the primary key field used by the API
            task_id: createdTaskId, // Also include task_id for compatibility
            keyword_key: null,
            target_url: createdTaskUrl,
            target_url_clean: urlKey, // Use normalized URL
            task_type: 'on_page',
            status: createdTask.status || 'planned',
            objective_state: 'on_track', // Default for new tasks with baseline
            cycle_id: createdTask.current_cycle_id || null,
            cycle_number: 1,
            cycle_active: 1, // Active cycle number
            due_at: createdTask.due_at || null,
            days_remaining: null,
            last_activity_at: new Date().toISOString() // Set to now for immediate entries
          };
          
          console.log('[Money Pages] Immediate status object created:', {
            id: immediateStatus.id,
            task_id: immediateStatus.task_id,
            hasId: 'id' in immediateStatus,
            hasTaskId: 'task_id' in immediateStatus,
            status: immediateStatus.status
          });
          
          // Ensure cache exists
          if (!window.optimisationStatusCache) {
            window.optimisationStatusCache = new Map();
            console.log('[Money Pages] Created new optimisationStatusCache');
          }
          
          // Add to cache immediately with a timestamp flag so we can preserve it during cache refresh
          immediateStatus._immediateCache = true;
          immediateStatus._cacheTimestamp = Date.now();
          window.optimisationStatusCache.set(cacheKey, immediateStatus);
          console.log('[Money Pages]  Immediately cached created task:', {
            cacheKey,
            taskId: createdTaskId,
            url: createdTaskUrl,
            urlKey,
            status: immediateStatus.status,
            cacheSize: window.optimisationStatusCache.size
          });
          
          // Verify it's in the cache
          const verifyCache = window.optimisationStatusCache.get(cacheKey);
          console.log('[Money Pages] Cache verification:', {
            cacheKey,
            found: !!verifyCache,
            cachedStatus: verifyCache?.status
          });
          
          // Also add to temporary cache for immediate UI update
          if (!window.moneyPagesTaskCache) {
            window.moneyPagesTaskCache = new Map();
            console.log('[Money Pages] Created new moneyPagesTaskCache');
          }
          window.moneyPagesTaskCache.set(urlKey, {
            id: createdTaskId,
            status: immediateStatus.status,
            cycle_number: 1
          });
          console.log('[Money Pages] Added to temporary cache:', {
            urlKey,
            taskId: createdTaskId,
            tempCacheSize: window.moneyPagesTaskCache.size
          });
        }
        
        // Reload all tasks so the new task is available for the drawer
        if (typeof window.loadAllOptimisationTasks === 'function') {
          await window.loadAllOptimisationTasks();
        }
        
        // Handle Money Pages vs Ranking & AI differently
        // Use currentSource (re-read from modal) to ensure we have the correct value
        const finalSource = currentSource || source || '';
        if (finalSource === 'money_pages') {
          // FIRST: Re-render table immediately with immediate cache entry
          // This ensures the UI updates right away, even before the API refreshes
          console.log('[Money Pages] Re-rendering table immediately with immediate cache entry...');
          if (typeof renderMoneyPagesTable === 'function' && window.moneyPagesMetrics) {
            const moneyPagesContainer = document.getElementById('money-pages-table-container');
            if (moneyPagesContainer) {
              const currentPage = window.moneyPagesCurrentPage || 1;
              const rowsPerPage = window.moneyPagesRowsPerPage || 10;
              const tableHtml = await renderMoneyPagesTable(window.moneyPagesMetrics.rows, currentPage, rowsPerPage);
              if (tableHtml && typeof tableHtml === 'string' && tableHtml.trim().length > 0) {
                moneyPagesContainer.innerHTML = tableHtml;
                console.log('[Money Pages]  Table re-rendered immediately with immediate cache');
              }
            }
          }
          
          // THEN: Small delay to ensure database is updated and view is refreshed
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Refresh optimisation statuses cache (same as Ranking & AI)
          // This will update the cache with the latest from the database
          if (typeof window.fetchOptimisationStatuses === 'function' && window.moneyPagesMetrics && window.moneyPagesMetrics.rows) {
            // Create row-like objects for fetchOptimisationStatuses
            const statusRows = window.moneyPagesMetrics.rows.map(row => ({
              keyword: '', // Empty for page-level tasks
              best_url: row.url,
              targetUrl: row.url,
              ranking_url: row.url
            }));
            console.log('[Money Pages] Fetching statuses for', statusRows.length, 'rows after task creation');
            await window.fetchOptimisationStatuses(statusRows);
            console.log('[Money Pages] Status cache size after fetch:', window.optimisationStatusCache ? window.optimisationStatusCache.size : 0);
            
            // Verify the created task is in the cache
            if (createdTaskUrl) {
              const testRow = { keyword: '', best_url: createdTaskUrl, targetUrl: createdTaskUrl, ranking_url: createdTaskUrl };
              const testStatus = window.getOptimisationStatus ? window.getOptimisationStatus(testRow, 'on_page') : null;
              const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(createdTaskUrl) : createdTaskUrl.toLowerCase().trim();
              const expectedKey = `::${urlKey}::on_page`;
              const cacheHasKey = window.optimisationStatusCache ? window.optimisationStatusCache.has(expectedKey) : false;
              const cachedValue = window.optimisationStatusCache ? window.optimisationStatusCache.get(expectedKey) : null;
              
              console.log('[Money Pages] Status lookup test for created task:', {
                url: createdTaskUrl,
                urlKey,
                expectedKey,
                found: !!testStatus,
                status: testStatus?.status,
                taskId: testStatus?.id,
                cacheHasKey,
                cachedValueStatus: cachedValue?.status,
                cachedValueId: cachedValue?.id
              });
              
              // If not found, log all cache keys for debugging
              if (!testStatus && window.optimisationStatusCache) {
                const allKeys = Array.from(window.optimisationStatusCache.keys());
                const matchingKeys = allKeys.filter(k => k.includes(urlKey) || k.includes('landscape'));
                console.log('[Money Pages] Cache keys containing URL:', matchingKeys);
                console.log('[Money Pages] All cache keys (first 20):', allKeys.slice(0, 20));
              }
            }
          }
          
          // Refresh Money Pages table to show updated Track/Manage status
          console.log('[Money Pages] About to re-render table...', {
            hasRenderFunction: typeof renderMoneyPagesTable === 'function',
            hasMetrics: !!window.moneyPagesMetrics,
            metricsRows: window.moneyPagesMetrics?.rows?.length || 0,
            containerExists: !!document.getElementById('money-pages-table-container')
          });
          
          if (typeof renderMoneyPagesTable === 'function' && window.moneyPagesMetrics) {
            const moneyPagesContainer = document.getElementById('money-pages-table-container');
            if (moneyPagesContainer) {
              const currentPage = window.moneyPagesCurrentPage || 1;
              const rowsPerPage = window.moneyPagesRowsPerPage || 10;
              console.log('[Money Pages] Re-rendering table after task creation...', {
                currentPage,
                rowsPerPage,
                totalRows: window.moneyPagesMetrics.rows.length,
                cacheSize: window.optimisationStatusCache?.size || 0,
                tempCacheSize: window.moneyPagesTaskCache?.size || 0
              });
              
              const tableHtml = await renderMoneyPagesTable(window.moneyPagesMetrics.rows, currentPage, rowsPerPage);
              console.log('[Money Pages] Table HTML generated, length:', tableHtml?.length || 0);
              moneyPagesContainer.innerHTML = tableHtml;
              console.log('[Money Pages]  Opportunity table re-rendered successfully');
              // Re-attach event handlers (they're set up in the render function)
              // Note: renderMoneyPagesTable already calls these handlers, but we need to ensure they're attached after re-render
              if (typeof attachMoneyPagesSortHandlers === 'function') {
                attachMoneyPagesSortHandlers();
              }
              if (typeof attachMoneyPagesPaginationHandlers === 'function') {
                attachMoneyPagesPaginationHandlers(window.moneyPagesMetrics.rows);
              }
              if (typeof attachMoneyPagesCopyHandler === 'function') {
                attachMoneyPagesCopyHandler(window.moneyPagesMetrics.rows);
              }
              if (typeof attachMoneyPagesFilterHandlers === 'function') {
                attachMoneyPagesFilterHandlers(window.moneyPagesMetrics.rows, async () => {
                  // Re-apply filters and re-render
                  const currentPage = window.moneyPagesCurrentPage || 1;
                  const rowsPerPage = window.moneyPagesRowsPerPage || 10;
                  if (moneyPagesContainer && typeof renderMoneyPagesTable === 'function') {
                    moneyPagesContainer.innerHTML = await renderMoneyPagesTable(window.moneyPagesMetrics.rows, currentPage, rowsPerPage);
                  }
                });
              }
            }
          }
          
          // ALSO: Re-render Priority table if it exists
          if (window.moneyPagePriorityData && window.moneyPagePriorityData.length > 0) {
            console.log('[Money Pages] Re-rendering Priority table after task creation...');
            if (typeof renderMoneyPagesTable === 'function') {
              const filters = {
                typeFilter: window.moneyPagesTypeFilter || 'all',
                minImpr: window.moneyPagesMinImpr || 0,
                matrixFilter: window.moneyPagesMatrixFilter || null
              };
              try {
                await renderMoneyPagesTable(null, filters);
                console.log('[Money Pages]  Priority table re-rendered successfully');
              } catch (err) {
                console.error('[Money Pages] Error re-rendering Priority table:', err);
              }
            }
          }
          
          // Show success message
          const pageTitle = title ? title.replace(/^MP: /, '') : targetUrl;
          showStatus(` Created optimisation task for ${pageTitle} with baseline snapshot`, 'success');
        } else {
          // Ranking & AI: refresh Ranking & AI table
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        if (rankingTab) {
          // Use setActivePanel to properly show the panel
          if (typeof setActivePanel === 'function') {
            setActivePanel('ranking');
          } else {
            // Fallback: manually set active state
            document.querySelectorAll('.aigeo-panel').forEach(panel => {
              panel.classList.remove('is-active');
              panel.hidden = true;
            });
          rankingTab.classList.add('is-active');
            rankingTab.hidden = false;
          }
          
          // Update nav button states
          document.querySelectorAll('.aigeo-nav-item').forEach(btn => btn.classList.remove('is-active'));
          const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav-item')).find(btn => 
            btn.getAttribute('data-panel') === 'ranking'
          );
          if (rankingNavBtn) rankingNavBtn.classList.add('is-active');
          
          // Ensure panel is rendered
          if (typeof ensurePanelRendered === 'function') {
            ensurePanelRendered('ranking');
          }
        }
        
        // Trigger table re-render
        if (typeof renderRankingAiTab === 'function') {
          await renderRankingAiTab();
        } else if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        } else {
          console.warn('[Optimisation] renderRankingAiTab not found, refreshing page');
          // Preserve Ranking & AI tab state before reload
          sessionStorage.setItem('activeTab', 'ranking');
          window.location.hash = '#ranking';
          location.reload();
          }
        }
      } catch (error) {
        console.error('[Optimisation] Error creating task:', error);
        alert('Failed to create task: ' + error.message);
      }
    };

    // Open Manage Optimisation modal
    window.openManageOptimisationModal = function openManageOptimisationModal(row, status, taskType = 'on_page') {
      const modal = document.getElementById('optimisation-manage-modal');
      if (!modal) {
        console.error('[Optimisation] Manage modal not found');
        return;
      }

      // Populate read-only fields
      document.getElementById('manage-keyword-text').textContent = row.keyword;
      
      // Make URL clickable in Manage modal
      const manageUrlContainer = document.getElementById('manage-url-text');
      const rawUrl = row.best_url || row.targetUrl || row.ranking_url || '';
      const urlText = window.cleanUrlForDisplay ? window.cleanUrlForDisplay(rawUrl) : window.cleanUrlForKey(rawUrl);
      manageUrlContainer.innerHTML = ''; // Clear existing content
      if (urlText) {
        // Ensure URL has protocol
        let fullUrl = urlText;
        if (!fullUrl.startsWith('http://') && !fullUrl.startsWith('https://')) {
          fullUrl = 'https://' + fullUrl;
        }
        const urlLink = document.createElement('a');
        urlLink.href = fullUrl;
        urlLink.target = '_blank';
        urlLink.rel = 'noopener noreferrer';
        urlLink.textContent = urlText;
        urlLink.style.color = '#0284c7';
        urlLink.style.textDecoration = 'none';
        urlLink.style.wordBreak = 'break-all';
        urlLink.addEventListener('mouseenter', () => {
          urlLink.style.textDecoration = 'underline';
        });
        urlLink.addEventListener('mouseleave', () => {
          urlLink.style.textDecoration = 'none';
        });
        manageUrlContainer.appendChild(urlLink);
      } else {
        manageUrlContainer.textContent = 'No URL available';
      }
      
      document.getElementById('manage-task-type-text').textContent = taskType;
      document.getElementById('manage-status-text').textContent = status.status;
      document.getElementById('manage-cycle-text').textContent = status.cycle_active || 1;
      document.getElementById('manage-last-activity-text').textContent = status.last_activity_at 
        ? new Date(status.last_activity_at).toLocaleDateString()
        : 'Never';

      // Set current status in dropdown
      document.getElementById('manage-status-select').value = status.status;

      // Store data for submit
      modal.dataset.taskId = status.id;
      modal.dataset.rowKeyword = row.keyword;
      modal.dataset.rowUrl = row.best_url || row.targetUrl || row.ranking_url || '';
      modal.dataset.taskType = taskType;
      modal.dataset.currentCycle = status.cycle_active || 1;
      modal.dataset.currentStatus = status.status; // Store actual status value for comparison

      modal.style.display = 'flex';
    };

    // Submit status change
    window.submitStatusChange = async function submitStatusChange(newStatusParam, taskIdParam) {
      // B5: Support both modal and drawer - accept optional parameters
      const modal = document.getElementById('optimisation-manage-modal');
      const drawerTaskId = (window.optimisationModuleState && window.optimisationModuleState.currentTaskId);
      const modalTaskId = (modal && modal.dataset.taskId);
      const taskId = taskIdParam || drawerTaskId || modalTaskId;
      
      if (!taskId) {
        console.warn('[Optimisation] No task ID found');
        return;
      }

      // Get status from parameter, modal select, or drawer select
      const newStatus = newStatusParam || 
        (modal ? (document.getElementById('manage-status-select') && document.getElementById('manage-status-select').value) : null) ||
        (document.getElementById('optimisation-change-status') && document.getElementById('optimisation-change-status').value);
      
      if (!newStatus) {
        alert('Please select a status');
        return;
      }

      const oldStatus = (modal && modal.dataset.currentStatus) || 
        (document.getElementById('manage-status-text') && document.getElementById('manage-status-text').textContent) ||
        (document.getElementById('optimisation-drawer-status') && document.getElementById('optimisation-drawer-status').textContent);

      if (oldStatus === newStatus) {
        alert('Status unchanged');
        return;
      }

      try {
        const headers = window.getOptimisationHeaders();
        console.log('[Optimisation] Updating status:', { taskId, newStatus, oldStatus, hasAdminKey: !!headers['x-arp-admin-key'] });
        
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'PATCH',
          headers: headers,
          body: JSON.stringify({
            status: newStatus
          })
        });

        console.log('[Optimisation] Response status:', response.status, response.statusText);
        console.log('[Optimisation] Response headers:', Object.fromEntries(response.headers.entries()));

        if (!response.ok) {
          // Clone response BEFORE reading to allow multiple reads
          const responseClone = response.clone();
          let errorMessage = 'Failed to update status';
          let errorDetails = null;
          
          try {
            // Try to read as JSON first (most APIs return JSON)
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
            errorDetails = errorData;
            console.error('[Optimisation] API error response:', errorData);
          } catch (e) {
            // If JSON parsing fails, try text from clone
            console.error('[Optimisation] JSON parse failed, trying text:', e);
            try {
              const errorText = await responseClone.text();
              console.error('[Optimisation] Error response text (length):', errorText ? errorText.length : 0);
              if (errorText && errorText.trim()) {
                // Try to parse as JSON if it looks like JSON
                try {
                  const parsed = JSON.parse(errorText);
                  errorMessage = parsed.error || parsed.message || errorText;
                  errorDetails = parsed;
                } catch (parseError) {
                  errorMessage = errorText.substring(0, 200); // Limit length
                  errorDetails = { rawText: errorText.substring(0, 500) };
                }
                console.error('[Optimisation] API error text:', errorText.substring(0, 200));
              } else {
                console.error('[Optimisation] Error response body is empty');
                errorDetails = { empty: true };
              }
            } catch (e2) {
              console.error('[Optimisation] Failed to read error response:', e2);
              errorDetails = { readError: e2.message };
            }
          }
          
          // Enhance error message based on status code
          if (response.status === 401) {
            errorMessage = 'Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.';
          } else if (response.status === 404) {
            errorMessage = 'Task not found. It may have been deleted.';
          } else if (response.status === 403) {
            errorMessage = 'Forbidden - you do not have permission to update this task.';
          } else if (response.status === 500) {
            errorMessage = `Server error (${response.status}): ${errorMessage}`;
          } else {
            errorMessage = `HTTP ${response.status}: ${errorMessage}`;
          }
          
          console.error('[Optimisation] Full error details:', {
            status: response.status,
            statusText: response.statusText,
            errorMessage,
            errorDetails
          });
          
          throw new Error(errorMessage);
        }

        // Read successful response
        const result = await response.json();
        console.log('[Optimisation] Status update successful:', result);

        // Refresh data
        if (modal && modal.dataset.rowKeyword) {
        await window.fetchOptimisationStatuses([{
          keyword: modal.dataset.rowKeyword,
          best_url: modal.dataset.rowUrl
        }]);
        }
        
        // Refresh all tasks if drawer is open
        if (window.optimisationModuleState && window.optimisationModuleState.currentTaskId) {
          await window.loadAllOptimisationTasks();
        }
        
        // Close modal if open
        if (modal) {
        modal.style.display = 'none';
        }
        
        // Ensure Ranking & AI tab stays active and refresh table (only if modal was used)
        if (modal && modal.dataset.rowKeyword) {
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        if (rankingTab) {
          // Use setActivePanel to properly show the panel
          if (typeof setActivePanel === 'function') {
            setActivePanel('ranking');
          } else {
            // Fallback: manually set active state
            document.querySelectorAll('.aigeo-panel').forEach(panel => {
              panel.classList.remove('is-active');
              panel.hidden = true;
            });
          rankingTab.classList.add('is-active');
            rankingTab.hidden = false;
          }
          
          // Update nav button states
          document.querySelectorAll('.aigeo-nav-item').forEach(btn => btn.classList.remove('is-active'));
          const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav-item')).find(btn => 
            btn.getAttribute('data-panel') === 'ranking'
          );
          if (rankingNavBtn) rankingNavBtn.classList.add('is-active');
          
          // Ensure panel is rendered
          if (typeof ensurePanelRendered === 'function') {
            ensurePanelRendered('ranking');
          }
        }
        }
        
        // Trigger table re-render
        if (typeof renderRankingAiTab === 'function') {
          await renderRankingAiTab();
        } else if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        } else {
          console.warn('[Optimisation] renderRankingAiTab not found, refreshing page');
          // Preserve Ranking & AI tab state before reload
          sessionStorage.setItem('activeTab', 'ranking');
          window.location.hash = '#ranking';
          location.reload();
        }
      } catch (error) {
        console.error('[Optimisation] Error updating status:', error);
        alert('Failed to update status: ' + error.message);
      }
    };

    // Start new cycle
    window.startNewCycle = async function startNewCycle() {
      const taskId = (window.optimisationModuleState && window.optimisationModuleState.currentTaskId);
      
      if (!taskId) {
        console.warn('[Optimisation] No task ID found');
        return;
      }

      // Get current task to get cycle info
      const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      if (!task) {
        alert('Task not found. Please refresh the page.');
        return;
      }

      const currentCycleNo = task.cycle_no || task.cycle_active || 1;
      const newCycleNo = currentCycleNo + 1;

      // Show modal for editing new cycle objective
      const modal = document.getElementById('optimisation-new-cycle-modal');
      if (!modal) {
        alert('New cycle modal not found. Please refresh the page.');
        return;
      }

      // Populate with previous cycle's objective if it exists (for copying)
      if (task.objective_title) {
        document.getElementById('new-cycle-objective-title').value = task.objective_title;
      }
      if (task.primary_kpi) {
        document.getElementById('new-cycle-primary-kpi').value = task.primary_kpi;
      }
      if (task.target_direction) {
        document.getElementById('new-cycle-target-direction').value = task.target_direction;
      }
      if (task.target_value != null) {
        document.getElementById('new-cycle-target-value').value = task.target_value;
      }
      if (task.timeframe_days) {
        document.getElementById('new-cycle-timeframe-days').value = task.timeframe_days;
      }
      if (task.plan) {
        document.getElementById('new-cycle-plan').value = task.plan;
      }

      document.getElementById('new-cycle-cycle-no').textContent = `Cycle ${newCycleNo}`;
      modal.dataset.taskId = taskId;
      modal.style.display = 'flex';
    };

    window.submitNewCycle = async function submitNewCycle() {
      const modal = document.getElementById('optimisation-new-cycle-modal');
      if (!modal) return;

      const taskId = modal.dataset.taskId;
      if (!taskId) {
        alert('Task ID not found');
        return;
      }

      // Get objective fields
      const objective_title = document.getElementById('new-cycle-objective-title').value.trim();
      const primary_kpi = document.getElementById('new-cycle-primary-kpi').value.trim();
      const target_direction = document.getElementById('new-cycle-target-direction').value.trim();
      const target_value = document.getElementById('new-cycle-target-value').value.trim();
      const timeframe_days = document.getElementById('new-cycle-timeframe-days').value.trim();
      const plan = document.getElementById('new-cycle-plan').value.trim();

      try {
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/cycle`), {
          method: 'POST',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            objective_title: objective_title || null,
            primary_kpi: primary_kpi || null,
            target_direction: target_direction || null,
            target_value: target_value ? parseFloat(target_value) : null,
            timeframe_days: timeframe_days ? parseInt(timeframe_days) : null,
            plan: plan || null
          })
        });

        if (!response.ok) {
          if (response.status === 401) {
            throw new Error('Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.');
          }
          const errorData = await response.json();
          throw new Error(errorData.error || 'Failed to start new cycle');
        }

        const result = await response.json();
        
        // Update task in state immediately with returned task data (includes new cycle objective)
        if (result.task && window.optimisationModuleState && window.optimisationModuleState.allTasks) {
          const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
          if (taskIndex >= 0) {
            window.optimisationModuleState.allTasks[taskIndex] = result.task;
            console.log('[Optimisation] Updated task in state with new cycle data:', result.task);
          } else {
            window.optimisationModuleState.allTasks.push(result.task);
          }
          // Also update filtered tasks if it exists there
          if (window.optimisationModuleState.filteredTasks) {
            const filteredIndex = window.optimisationModuleState.filteredTasks.findIndex(t => t.id === taskId);
            if (filteredIndex >= 0) {
              window.optimisationModuleState.filteredTasks[filteredIndex] = result.task;
            }
          }
        }
        
        // Small delay to ensure view has updated with new cycle
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Refresh tasks to ensure all data is up to date
        await window.loadAllOptimisationTasks();
        
        // Reload drawer if it's open (will use updated task data)
        if (window.optimisationModuleState.currentTaskId === taskId) {
          // Force reload by closing and reopening
          const currentTaskId = window.optimisationModuleState.currentTaskId;
          window.optimisationModuleState.currentTaskId = null;
          await new Promise(resolve => setTimeout(resolve, 100));
          await window.openOptimisationTaskDrawer(currentTaskId);
        }
        
        modal.style.display = 'none';
        
        // Show success message with cycle info
        const cycleNo = (result.cycle && result.cycle.cycle_no) || (result.task && result.task.cycle_active) || 'new';
        alert(`Cycle ${cycleNo} started successfully!${result.baseline_from_audit ? ' Baseline set from latest audit.' : (result.baseline_from_measurement ? ' Baseline set from previous latest measurement.' : '')}`);
      } catch (error) {
        console.error('[Optimisation] Error starting new cycle:', error);
        alert('Failed to start new cycle: ' + error.message);
      }
    };

    // Edit Objective function
    // Edit objective (inline form)
    window.editObjective = async function editObjective() {
      const taskId = (window.optimisationModuleState && window.optimisationModuleState.currentTaskId);
      if (!taskId) return;

      const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      if (!task) return;

      const form = document.getElementById('optimisation-edit-objective-form');
      const content = document.getElementById('optimisation-drawer-objective-content');
      if (!form || !content) return;

      // Populate form with current values (Phase 5: use objective from cycle, fallback to legacy)
      const objective = task.objective || task.cycle?.objective || null;
      
      if (objective) {
        // Phase 5 format
        document.getElementById('optimisation-edit-objective-title').value = objective.title || '';
        document.getElementById('optimisation-edit-objective-kpi').value = ''; // KPI label not used in Phase 5
        document.getElementById('optimisation-edit-objective-metric').value = objective.kpi || '';
        document.getElementById('optimisation-edit-objective-direction').value = objective.target_type === 'absolute' ? 'at_least' : 'increase'; // Default
        // For CTR, convert from ratio (0-1) to percentage for display in input field
        let displayTarget = objective.target;
        if (objective.kpi === 'ctr_28d' && displayTarget != null) {
          // If target is stored as ratio (0-1), multiply by 100 for display
          if (displayTarget < 1 && displayTarget > 0) {
            displayTarget = displayTarget * 100;
          }
        }
        document.getElementById('optimisation-edit-objective-target-value').value = displayTarget != null ? displayTarget : '';
        document.getElementById('optimisation-edit-objective-plan').value = objective.plan || '';
        
        // Calculate timeframe from due_at if available
        if (objective.due_at) {
          const dueDate = new Date(objective.due_at);
          const taskStart = task.cycle_started_at || task.cycle_start_date || new Date();
          const startDate = new Date(taskStart);
          const daysDiff = Math.round((dueDate - startDate) / (1000 * 60 * 60 * 24));
          document.getElementById('optimisation-edit-objective-timeframe').value = daysDiff > 0 ? daysDiff : '';
          
          const dueDateEl = document.getElementById('optimisation-edit-objective-due-date');
          if (dueDateEl) {
            dueDateEl.textContent = `Due: ${dueDate.toLocaleDateString('en-GB')}`;
          }
        } else {
          document.getElementById('optimisation-edit-objective-timeframe').value = '';
        }
      } else {
        // Legacy format fallback
        document.getElementById('optimisation-edit-objective-title').value = task.objective_title || '';
        document.getElementById('optimisation-edit-objective-kpi').value = task.objective_kpi || task.objective_metric || '';
        document.getElementById('optimisation-edit-objective-metric').value = task.objective_metric || task.objective_kpi || '';
        document.getElementById('optimisation-edit-objective-direction').value = task.objective_direction || '';
        document.getElementById('optimisation-edit-objective-target-value').value = task.objective_target_delta != null ? task.objective_target_delta : (task.objective_target_value != null ? task.objective_target_value : '');
        document.getElementById('optimisation-edit-objective-timeframe').value = task.objective_timeframe_days != null ? task.objective_timeframe_days : '';
        document.getElementById('optimisation-edit-objective-plan').value = task.objective_plan || '';
        
        // If objective_due_at exists, calculate and display it
        if (task.objective_due_at) {
          const dueDateEl = document.getElementById('optimisation-edit-objective-due-date');
          if (dueDateEl) {
            const dueDate = new Date(task.objective_due_at);
            dueDateEl.textContent = `Due: ${dueDate.toLocaleDateString('en-GB')}`;
          }
        }
      }

      // Calculate and show due date
      updateObjectiveDueDate();

      // Show form, hide content
      form.style.display = 'block';
      content.style.display = 'none';
    };

    // Update due date display when timeframe changes
    function updateObjectiveDueDate() {
      const timeframeInput = document.getElementById('optimisation-edit-objective-timeframe');
      const dueDateEl = document.getElementById('optimisation-edit-objective-due-date');
      if (!timeframeInput || !dueDateEl) return;

      const timeframe = parseInt(timeframeInput.value);
      if (timeframe > 0) {
        const taskId = (window.optimisationModuleState && window.optimisationModuleState.currentTaskId);
        const task = window.optimisationModuleState?.allTasks?.find(t => t.id === taskId);
        const startDate = (task && task.cycle_started_at) || (task && task.cycle_start_date) || new Date();
        const dueDate = new Date(new Date(startDate).getTime() + timeframe * 24 * 60 * 60 * 1000);
        dueDateEl.textContent = `Due: ${dueDate.toLocaleDateString('en-GB')}`;
      } else {
        dueDateEl.textContent = '';
      }
    }

    // Save objective
    window.saveObjective = async function saveObjective() {
      const taskId = (window.optimisationModuleState && window.optimisationModuleState.currentTaskId);
      if (!taskId) {
        alert('Task ID not found');
        return;
      }

      // Get form values (Phase 5 format)
      const title = document.getElementById('optimisation-edit-objective-title').value.trim();
      const kpi = document.getElementById('optimisation-edit-objective-metric').value || null;
      const targetValue = document.getElementById('optimisation-edit-objective-target-value').value;
      let target = targetValue ? (kpi === 'ai_overview' ? targetValue === 'true' : parseFloat(targetValue)) : null;
      // For CTR, convert from percentage to ratio (0-1) for storage
      if (kpi === 'ctr_28d' && target != null) {
        // If value is >= 1, assume it's a percentage and convert to ratio
        if (target >= 1) {
          target = target / 100;
        }
        // If value is < 1, assume it's already a ratio (but warn if it seems wrong)
        if (target < 0.01 && target > 0) {
          console.warn('[Optimisation] CTR target value seems very small. Expected percentage (e.g., 2.5 for 2.5%) or ratio (e.g., 0.025). Got:', target);
        }
      }
      const direction = document.getElementById('optimisation-edit-objective-direction').value || null;
      
      // Determine target_type based on KPI
      let target_type = 'delta';
      if (kpi === 'ai_overview' || kpi === 'current_rank') {
        target_type = 'absolute';
      } else if (direction === 'at_least' || direction === 'at_most') {
        target_type = 'absolute';
      }

      const timeframeDays = document.getElementById('optimisation-edit-objective-timeframe').value;
      const plan = document.getElementById('optimisation-edit-objective-plan').value.trim() || null;

      // Calculate due_at if timeframe is set
      let due_at = null;
      if (timeframeDays) {
        const task = window.optimisationModuleState?.allTasks?.find(t => t.id === taskId);
        const startDate = (task && task.cycle_started_at) || (task && task.cycle_start_date) ? new Date((task && task.cycle_started_at) || (task && task.cycle_start_date)) : new Date();
        due_at = new Date(startDate.getTime() + parseInt(timeframeDays) * 24 * 60 * 60 * 1000).toISOString();
      }

      // Phase 5: Send new format
      const objectiveData = {
        title: title || null,
        kpi: kpi || null,
        target: target,
        target_type: target_type,
        due_at: due_at,
        plan: plan
      };

      try {
        const headers = window.getOptimisationHeaders();
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/objective`), {
          method: 'PATCH',
          headers: { ...headers, 'Content-Type': 'application/json' },
          body: JSON.stringify(objectiveData)
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || (error.errors && error.errors.join(', ')) || 'Failed to save objective');
        }

        const data = await response.json();

        // Hide edit form
        document.getElementById('optimisation-edit-objective-form').style.display = 'none';
        document.getElementById('optimisation-drawer-objective-content').style.display = 'block';

        // Reload tasks and refresh drawer
        if (typeof window.loadAllOptimisationTasks === 'function') {
          await window.loadAllOptimisationTasks();
        }
        await window.openOptimisationTaskDrawer(taskId);
      } catch (error) {
        console.error('[Optimisation] Error saving objective:', error);
        alert('Failed to save objective: ' + error.message);
      }
    };

    // Cancel edit objective
    window.cancelEditObjective = function cancelEditObjective() {
      const form = document.getElementById('optimisation-edit-objective-form');
      const content = document.getElementById('optimisation-drawer-objective-content');
      if (form) form.style.display = 'none';
      if (content) content.style.display = 'block';
    };

    // Old modal-based edit (keeping for backward compatibility but not used)
    window.editObjectiveOld = async function editObjectiveOld() {
      const taskId = (window.optimisationModuleState && window.optimisationModuleState.currentTaskId);
      if (!taskId) return;

      const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      if (!task) return;

      // Show edit modal (reuse new cycle modal structure)
      const modal = document.getElementById('optimisation-edit-objective-modal');
      if (!modal) {
        alert('Edit objective modal not found. Please refresh the page.');
        return;
      }

      // Populate with current objective
      document.getElementById('edit-objective-title').value = task.objective_title || '';
      document.getElementById('edit-objective-primary-kpi').value = task.primary_kpi || '';
      document.getElementById('edit-objective-target-direction').value = task.target_direction || '';
      document.getElementById('edit-objective-target-value').value = task.target_value || '';
      document.getElementById('edit-objective-timeframe-days').value = task.timeframe_days || '';
      document.getElementById('edit-objective-plan').value = task.plan || '';

      modal.dataset.taskId = taskId;
      modal.style.display = 'flex';
    };

    window.submitEditObjective = async function submitEditObjective() {
      const modal = document.getElementById('optimisation-edit-objective-modal');
      if (!modal) return;

      const taskId = modal.dataset.taskId;
      if (!taskId) {
        alert('Task ID not found');
        return;
      }

      // Get objective fields
      const objective_title = document.getElementById('edit-objective-title').value.trim();
      const primary_kpi = document.getElementById('edit-objective-primary-kpi').value.trim();
      const target_direction = document.getElementById('edit-objective-target-direction').value.trim();
      const target_value = document.getElementById('edit-objective-target-value').value.trim();
      const timeframe_days = document.getElementById('edit-objective-timeframe-days').value.trim();
      const plan = document.getElementById('edit-objective-plan').value.trim();

      try {
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'PATCH',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            objective_title: objective_title || null,
            primary_kpi: primary_kpi || null,
            target_direction: target_direction || null,
            target_value: target_value ? parseFloat(target_value) : null,
            timeframe_days: timeframe_days ? parseInt(timeframe_days) : null,
            plan: plan || null
          })
        });

        if (!response.ok) {
          if (response.status === 401) {
            throw new Error('Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.');
          }
          const errorData = await response.json();
          throw new Error(errorData.error || 'Failed to update objective');
        }

        // Refresh tasks and reload drawer
        await window.loadAllOptimisationTasks();
        
        // Reload drawer if it's open
        if (window.optimisationModuleState.currentTaskId === taskId) {
          await window.openOptimisationTaskDrawer(taskId);
        }
        
        modal.style.display = 'none';
        
        alert('Objective updated successfully!');
      } catch (error) {
        console.error('[Optimisation] Error updating objective:', error);
        alert('Failed to update objective: ' + error.message);
      }
    };

    // Helper function to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Stop tracking
    window.stopTracking = async function stopTracking() {
      // B5: Support both modal and drawer
      const modal = document.getElementById('optimisation-manage-modal');
      const drawerTaskId = (window.optimisationModuleState && window.optimisationModuleState.currentTaskId);
      const modalTaskId = (modal && modal.dataset.taskId);
      const taskId = drawerTaskId || modalTaskId;
      
      if (!taskId) {
        console.warn('[Optimisation] No task ID found in modal or drawer');
        return;
      }

      if (!confirm('Stop tracking this keyword? The task will be marked as cancelled but history will be preserved.')) {
        return;
      }

      try {
        const headers = window.getOptimisationHeaders();
        console.log('[Optimisation] Stopping tracking:', { taskId, hasAdminKey: !!headers['x-arp-admin-key'] });
        
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'PATCH',
          headers: headers,
          body: JSON.stringify({
            status: 'cancelled'
          })
        });

        console.log('[Optimisation] Response status:', response.status, response.statusText);

        if (!response.ok) {
          // Clone response BEFORE reading to allow multiple reads
          const responseClone = response.clone();
          let errorMessage = 'Failed to stop tracking';
          let errorDetails = null;
          
          try {
            // Try to read as JSON first (most APIs return JSON)
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
            errorDetails = errorData;
            console.error('[Optimisation] API error response:', errorData);
          } catch (e) {
            // If JSON parsing fails, try text from clone
            console.error('[Optimisation] JSON parse failed, trying text:', e);
            try {
              const errorText = await responseClone.text();
              console.error('[Optimisation] Error response text (length):', errorText ? errorText.length : 0);
              if (errorText && errorText.trim()) {
                // Try to parse as JSON if it looks like JSON
                try {
                  const parsed = JSON.parse(errorText);
                  errorMessage = parsed.error || parsed.message || errorText;
                  errorDetails = parsed;
                } catch (parseError) {
                  errorMessage = errorText.substring(0, 200); // Limit length
                  errorDetails = { rawText: errorText.substring(0, 500) };
                }
                console.error('[Optimisation] API error text:', errorText.substring(0, 200));
              } else {
                console.error('[Optimisation] Error response body is empty');
                errorDetails = { empty: true };
              }
            } catch (e2) {
              console.error('[Optimisation] Failed to read error response:', e2);
              errorDetails = { readError: e2.message };
            }
          }
          
          // Enhance error message based on status code
          if (response.status === 401) {
            errorMessage = 'Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.';
          } else if (response.status === 404) {
            errorMessage = 'Task not found. It may have been deleted.';
          } else if (response.status === 403) {
            errorMessage = 'Forbidden - you do not have permission to update this task.';
          } else if (response.status === 500) {
            errorMessage = `Server error (${response.status}): ${errorMessage}`;
          } else {
            errorMessage = `HTTP ${response.status}: ${errorMessage}`;
          }
          
          console.error('[Optimisation] Full error details:', {
            status: response.status,
            statusText: response.statusText,
            errorMessage,
            errorDetails
          });
          
          throw new Error(errorMessage);
        }
        
        // Read successful response
        const result = await response.json();
        console.log('[Optimisation] Stop tracking successful:', result);

        // Refresh data
        if (modal && modal.dataset.rowKeyword) {
        await window.fetchOptimisationStatuses([{
          keyword: modal.dataset.rowKeyword,
          best_url: modal.dataset.rowUrl
        }]);
        }
        
        // Refresh all tasks if drawer is open
        if (window.optimisationModuleState && window.optimisationModuleState.currentTaskId) {
          await window.loadAllOptimisationTasks();
        }
        
        // Close modal if open, drawer if open
        if (modal) {
        modal.style.display = 'none';
        }
        if (window.optimisationModuleState && window.optimisationModuleState.currentTaskId) {
          closeOptimisationTaskDrawer();
        }
        
        // Ensure Ranking & AI tab stays active and refresh table
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        if (rankingTab) {
          // Use setActivePanel to properly show the panel
          if (typeof setActivePanel === 'function') {
            setActivePanel('ranking');
          } else {
            // Fallback: manually set active state
            document.querySelectorAll('.aigeo-panel').forEach(panel => {
              panel.classList.remove('is-active');
              panel.hidden = true;
            });
          rankingTab.classList.add('is-active');
            rankingTab.hidden = false;
          }
          
          // Update nav button states
          document.querySelectorAll('.aigeo-nav-item').forEach(btn => btn.classList.remove('is-active'));
          const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav-item')).find(btn => 
            btn.getAttribute('data-panel') === 'ranking'
          );
          if (rankingNavBtn) rankingNavBtn.classList.add('is-active');
          
          // Ensure panel is rendered
          if (typeof ensurePanelRendered === 'function') {
            ensurePanelRendered('ranking');
          }
        }
        
        // Trigger table re-render
        if (typeof renderRankingAiTab === 'function') {
          await renderRankingAiTab();
        } else if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        } else {
          console.warn('[Optimisation] renderRankingAiTab not found, refreshing page');
          // Preserve Ranking & AI tab state before reload
          sessionStorage.setItem('activeTab', 'ranking');
          window.location.hash = '#ranking';
          location.reload();
        }
      } catch (error) {
        console.error('[Optimisation] Error stopping tracking:', error);
        alert('Failed to stop tracking: ' + error.message);
      }
    };

    // Delete task (hard delete - removes task and all events)
    window.deleteTask = async function deleteTask() {
      const taskId = (window.optimisationModuleState && window.optimisationModuleState.currentTaskId);
      
      if (!taskId) {
        console.warn('[Optimisation] No task ID found');
        return;
      }

      if (!confirm('Permanently delete this task and all its events? This cannot be undone.')) {
        return;
      }

      try {
        const headers = window.getOptimisationHeaders();
        console.log('[Optimisation] Deleting task:', { taskId, hasAdminKey: !!headers['x-arp-admin-key'] });
        
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'DELETE',
          headers: headers
        });

        console.log('[Optimisation] Response status:', response.status, response.statusText);

        if (!response.ok) {
          const responseClone = response.clone();
          let errorMessage = 'Failed to delete task';
          
          try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
            console.error('[Optimisation] API error response:', errorData);
          } catch (e) {
            try {
              const errorText = await responseClone.text();
              if (errorText && errorText.trim()) {
                try {
                  const parsed = JSON.parse(errorText);
                  errorMessage = parsed.error || parsed.message || errorText;
                } catch (parseError) {
                  errorMessage = errorText.substring(0, 200);
                }
              }
            } catch (e2) {
              console.error('[Optimisation] Failed to read error response:', e2);
            }
          }
          
          if (response.status === 401) {
            errorMessage = 'Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.';
          } else if (response.status === 404) {
            errorMessage = 'Task not found. It may have been deleted.';
          } else if (response.status === 403) {
            errorMessage = 'Forbidden - you do not have permission to update this task.';
          } else if (response.status === 500) {
            errorMessage = `Server error (${response.status}): ${errorMessage}`;
          } else {
            errorMessage = `HTTP ${response.status}: ${errorMessage}`;
          }
          
          throw new Error(errorMessage);
        }
        
        const result = await response.json();
        console.log('[Optimisation] Delete task successful:', result);

        // Close the modal/drawer
        const drawer = document.getElementById('optimisation-task-drawer');
        if (drawer) {
          drawer.style.display = 'none';
        }

        // Clear the cache to force refresh
        if (window.optimisationStatusCache) {
          window.optimisationStatusCache.clear();
        }

        // Refresh Optimisation Tracking table
        await window.loadAllOptimisationTasks();

        // Refresh Ranking & AI table to show "Not tracked"
        if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        }
      } catch (error) {
        console.error('[Optimisation] Error deleting task:', error);
        throw error; // Re-throw so caller can handle
      }
    };

    // ======================
    // Optimisation Tracking Module (Phase B)
    // ======================
    
    // State
    window.optimisationModuleState = {
      allTasks: [],
      dashboardTiles: null,
      dashboardImpact: null,
      dashboardTimeseries: null,
      filteredTasks: [],
      activeTab: 'active',
      currentTaskId: null,
      authError: null,
      activeObjectiveFilter: null, // 'not_set' | 'on_track' | 'overdue' | 'met' | null
      scope: 'active_cycle', // 'active_cycle' | 'all_tasks'
      metricTrafficFilter: null, // { metricKey: string, bucket: 'better'|'same'|'worse' } | null
      trafficKpiOnly: false, // Filter to tasks with CTR/Impressions/Clicks objectives
      clickRelatedOnly: false, // Filter to tasks where clicks delta is computable
      selectedKpiForTrend: 'ctr_28d', // KPI selected for trend chart
      leftChartView: 'clicks' // 'clicks' | 'trend'
    };
    
    // Traffic Light Utility Functions (inline from lib/optimisation/metricTraffic.js)
    function isActiveStatus(status) {
      return ['planned', 'in_progress', 'monitoring'].includes(status);
    }

    function getBaselineLatest(measurements, scope, activeCycle = null) {
      if (!measurements || measurements.length === 0) {
        return null;
      }

      let eligibleMeasurements = [...measurements];

      // Filter by scope
      if (scope === 'active_cycle' && activeCycle) {
        const cycleStartDate = activeCycle.start_date ? new Date(activeCycle.start_date) : 
                              (activeCycle.started_at ? new Date(activeCycle.started_at) : null);
        if (cycleStartDate) {
          const filtered = eligibleMeasurements.filter(m => {
            const mDate = m.captured_at ? new Date(m.captured_at) : null;
            return mDate && mDate >= cycleStartDate;
          });
          // If filtering by cycle date results in no measurements, but we only have 1 measurement total,
          // use that measurement anyway (it's likely the baseline captured at task creation)
          if (filtered.length > 0) {
            eligibleMeasurements = filtered;
          } else if (eligibleMeasurements.length === 1) {
            // Keep the single measurement even if it's before cycle start (baseline case)
            // Don't filter it out
          } else {
            eligibleMeasurements = filtered;
          }
        }
      }

      // Need at least 1 measurement (baseline) to compute baseline/latest
      // If only 1 measurement, use it as both baseline and latest
      if (eligibleMeasurements.length < 1) {
        return null;
      }

      // Sort by date (oldest first)
      eligibleMeasurements.sort((a, b) => {
        const dateA = a.captured_at ? new Date(a.captured_at) : new Date(0);
        const dateB = b.captured_at ? new Date(b.captured_at) : new Date(0);
        return dateA - dateB;
      });

      const baseline = eligibleMeasurements[0];
      // If only 1 measurement, use it as both baseline and latest
      const latest = eligibleMeasurements.length > 1 ? eligibleMeasurements[eligibleMeasurements.length - 1] : baseline;

      return { baseline, latest };
    }

    function getMetricValue(measurement, metricKey) {
      if (!measurement) return null;

      const extractors = {
        ctr_28d: (m) => {
          // Handle both gsc_ prefixed fields (from baseline) and regular fields
          if (m && (m.gsc_ctr_28d != null || m.ctr_28d != null)) {
            return m.gsc_ctr_28d != null ? m.gsc_ctr_28d : m.ctr_28d;
          }
          return null;
        },
        impressions_28d: (m) => {
          if (m && (m.gsc_impressions_28d != null || m.impressions_28d != null)) {
            return m.gsc_impressions_28d != null ? m.gsc_impressions_28d : m.impressions_28d;
          }
          return null;
        },
        clicks_28d: (m) => {
          if (m && (m.gsc_clicks_28d != null || m.clicks_28d != null)) {
            return m.gsc_clicks_28d != null ? m.gsc_clicks_28d : m.clicks_28d;
          }
          return null;
        },
        current_rank: (m) => {
          if (m && (m.gsc_position_28d != null || m.current_rank != null || m.rank != null)) {
            return m.gsc_position_28d != null ? m.gsc_position_28d : (m.current_rank != null ? m.current_rank : m.rank);
          }
          return null;
        },
        opportunity_score: (m) => (m && m.opportunity_score) != null ? m.opportunity_score : null,
        ai_overview: (m) => (m && m.ai_overview) != null ? m.ai_overview : null,
        ai_citations: (m) => (m && m.ai_citations) != null ? m.ai_citations : null,
      };

      const extractor = extractors[metricKey];
      if (!extractor) return null;

      return extractor(measurement);
    }

    function classifyMetric(metricKey, baseline, latest) {
      if (!baseline || !latest) {
        return null;
      }

      const baselineValue = getMetricValue(baseline, metricKey);
      const latestValue = getMetricValue(latest, metricKey);

      // If either value is null/undefined, cannot classify
      if (baselineValue == null || latestValue == null) {
        return null;
      }

      // CTR (28d) - stored as ratio (0-1), compare as percentage points
      if (metricKey === 'ctr_28d') {
        const deltaPp = (latestValue - baselineValue) * 100;
        if (Math.abs(deltaPp) < 0.10) {
          return 'same';
        }
        return deltaPp >= 0.10 ? 'better' : 'worse';
      }

      // Impressions (28d)
      if (metricKey === 'impressions_28d') {
        const delta = latestValue - baselineValue;
        const tol = Math.max(20, Math.round(baselineValue * 0.02));
        if (Math.abs(delta) < tol) {
          return 'same';
        }
        return delta >= tol ? 'better' : 'worse';
      }

      // Clicks (28d)
      if (metricKey === 'clicks_28d') {
        const delta = latestValue - baselineValue;
        const tol = Math.max(5, Math.round(baselineValue * 0.05));
        if (Math.abs(delta) < tol) {
          return 'same';
        }
        return delta >= tol ? 'better' : 'worse';
      }

      // Rank (lower is better)
      if (metricKey === 'current_rank') {
        const delta = latestValue - baselineValue; // positive means rank got worse (increased)
        if (Math.abs(delta) < 0.5) {
          return 'same';
        }
        return delta <= -0.5 ? 'better' : 'worse';
      }

      // AI Citations
      if (metricKey === 'ai_citations') {
        const delta = latestValue - baselineValue;
        if (delta === 0) {
          return 'same';
        }
        return delta > 0 ? 'better' : 'worse';
      }

      // AI Overview (boolean)
      if (metricKey === 'ai_overview') {
        const baselineBool = baselineValue === true || baselineValue === 'On' || baselineValue === 1;
        const latestBool = latestValue === true || latestValue === 'On' || latestValue === 1;
        
        if (baselineBool === latestBool) {
          return 'same';
        }
        // Better: Off -> On, Worse: On -> Off
        return (!baselineBool && latestBool) ? 'better' : 'worse';
      }

      // Opportunity Score
      if (metricKey === 'opportunity_score') {
        const delta = latestValue - baselineValue;
        if (Math.abs(delta) < 2) {
          return 'same';
        }
        return delta >= 2 ? 'better' : 'worse';
      }

      // Unknown metric
      return null;
    }

    // Helper: Get latest measurement in scope for a task
    function getLatestMeasurementInScope(task, scope) {
      const measurements = task.measurements || [];
      if (measurements.length === 0) {
        return null;
      }

      let eligibleMeasurements = [...measurements];

      // Filter by scope
      if (scope === 'active_cycle') {
        const activeCycle = (task.cycles && task.cycles.find(c => c.is_active || c.id === task.active_cycle_id)) || null;
        if (activeCycle) {
          const cycleStartDate = activeCycle.start_date ? new Date(activeCycle.start_date) : 
                                (activeCycle.started_at ? new Date(activeCycle.started_at) : null);
          if (cycleStartDate) {
            eligibleMeasurements = eligibleMeasurements.filter(m => {
              const mDate = m.captured_at ? new Date(m.captured_at) : null;
              return mDate && mDate >= cycleStartDate;
            });
          }
        }
      }
      // For 'all_tasks' scope, use all measurements

      if (eligibleMeasurements.length === 0) {
        return null;
      }

      // Sort by date (newest first) and return the latest
      eligibleMeasurements.sort((a, b) => {
        const dateA = a.captured_at ? new Date(a.captured_at) : new Date(0);
        const dateB = b.captured_at ? new Date(b.captured_at) : new Date(0);
        return dateB - dateA; // Descending (newest first)
      });

      return eligibleMeasurements[0];
    }

    // Helper: Get Monday-start week key (YYYY-MM-DD)
    function weekStartISO(date) {
      const d = new Date(date);
      d.setHours(0, 0, 0, 0);
      // Get day of week (0 = Sunday, 1 = Monday, etc.)
      const day = d.getDay();
      // Calculate days to subtract to get to Monday
      const diff = day === 0 ? 6 : day - 1; // If Sunday, go back 6 days; otherwise go back (day-1) days
      d.setDate(d.getDate() - diff);
      // Return YYYY-MM-DD format
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, '0');
      const dayOfMonth = String(d.getDate()).padStart(2, '0');
      return `${year}-${month}-${dayOfMonth}`;
    }

    // Helper: Compute delta for a KPI with correct units
    function computeDeltaForKPI(kpi, baseline, latest) {
      if (!baseline || !latest) {
        return null;
      }

      const baselineValue = getMetricValue(baseline, kpi);
      const latestValue = getMetricValue(latest, kpi);

      if (baselineValue == null || latestValue == null) {
        return null;
      }

      // CTR: return as percentage points
      if (kpi === 'ctr_28d') {
        // TEMP: Log raw values to debug scaling issue
        console.log("[computeDeltaForKPI] CTR baselineValue:", baselineValue, "latestValue:", latestValue);
        
        // Normalize: CTR should be stored as ratio (0-1), but check if it's in percentage format (0-100)
        // If value > 1, assume it's already in percentage format and convert to ratio
        let baselineRatio = baselineValue;
        let latestRatio = latestValue;
        if (Math.abs(baselineValue) > 1) {
          console.warn("[computeDeltaForKPI] CTR baselineValue appears to be in percentage format, converting:", baselineValue, "->", baselineValue / 100);
          baselineRatio = baselineValue / 100;
        }
        if (Math.abs(latestValue) > 1) {
          console.warn("[computeDeltaForKPI] CTR latestValue appears to be in percentage format, converting:", latestValue, "->", latestValue / 100);
          latestRatio = latestValue / 100;
        }
        
        console.log("[computeDeltaForKPI] CTR normalized ratios - baseline:", baselineRatio, "latest:", latestRatio);
        const rawDelta = latestRatio - baselineRatio;
        console.log("[computeDeltaForKPI] CTR raw delta (ratio):", rawDelta);
        const deltaPp = rawDelta * 100; // Convert ratio delta to percentage points
        console.log("[computeDeltaForKPI] CTR delta in pp (FINAL):", deltaPp);
        
        // Sanity check: CTR deltas should typically be small (a few percentage points)
        if (Math.abs(deltaPp) > 20) {
          console.error("[computeDeltaForKPI] CTR delta seems too large:", deltaPp, "pp. Check if values are in correct format.");
        }
        
        return deltaPp;
      }

      // Rank: lower is better, so invert the delta (baseline - latest)
      // Positive delta = improvement (rank decreased)
      if (kpi === 'current_rank') {
        return baselineValue - latestValue;
      }

      // All others: absolute delta (higher is better)
      return latestValue - baselineValue;
    }

    // Helper: Compute median of an array
    function median(values) {
      if (values.length === 0) return null;
      const sorted = [...values].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2 === 0
        ? (sorted[mid - 1] + sorted[mid]) / 2
        : sorted[mid];
    }

    function computeTrafficLightCounts(tasks, scope) {
      const counts = {
        ctr_28d: { worse: 0, same: 0, better: 0 },
        impressions_28d: { worse: 0, same: 0, better: 0 },
        clicks_28d: { worse: 0, same: 0, better: 0 },
        current_rank: { worse: 0, same: 0, better: 0 },
        ai_citations: { worse: 0, same: 0, better: 0 },
        ai_overview: { worse: 0, same: 0, better: 0 },
        all_metrics: { worse: 0, same: 0, better: 0 }, // Aggregated counts
      };

      const metricKeys = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];

      for (const task of tasks) {
        // Only count active tasks
        if (!isActiveStatus(task.status)) {
          continue;
        }

        // Get active cycle if scope is 'active_cycle'
        const activeCycle = scope === 'active_cycle' 
          ? ((task.cycles && task.cycles.find(c => c.is_active || c.id === task.active_cycle_id)) || null)
          : null;

        // Get measurements
        const measurements = task.measurements || [];
        const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);

        // DEBUG: Log task details for troubleshooting
        if (task.title && (task.title.includes('Landscape') || task.title.includes('photography-courses'))) {
          if (typeof debugLog === 'function') {
            debugLog(`[Traffic Lights] Task: id=${task.id}, title="${task.title}", status=${task.status}, objectiveKpiKey=${task.objectiveKpiKey}, measurementsCount=${measurements.length}, hasBaselineLatest=${!!baselineLatest}`, 'info');
          }
        }

        // Track classifications for all metrics to compute aggregated count
        const taskClassifications = [];

        if (baselineLatest) {
          // DEBUG: Log measurement structure for all tasks with objectives
          if (typeof debugLog === 'function' && task.objectiveKpiKey) {
            const baselineKeys = Object.keys(baselineLatest.baseline || {}).filter(k => k.includes('ctr') || k.includes('citation') || k.includes('clicks') || k.includes('impression') || k.includes('rank') || k.includes('overview'));
            const latestKeys = Object.keys(baselineLatest.latest || {}).filter(k => k.includes('ctr') || k.includes('citation') || k.includes('clicks') || k.includes('impression') || k.includes('rank') || k.includes('overview'));
            debugLog(`[Traffic Lights] Task "${task.title || task.id}": objectiveKpiKey=${task.objectiveKpiKey}, baselineFields=[${baselineKeys.join(', ')}], latestFields=[${latestKeys.join(', ')}]`, 'info');
          }
          
          // Classify each metric - but only count tasks that have this metric as their objective
          // Map objective KPI keys to metric keys for matching
          const objectiveKpiToMetricKey = {
            'ctr_28d': 'ctr_28d',
            'impressions_28d': 'impressions_28d',
            'clicks_28d': 'clicks_28d',
            'current_rank': 'current_rank',
            'rank': 'current_rank',
            'ai_citations': 'ai_citations',
            'ai_overview': 'ai_overview'
          };
          
          const taskObjectiveMetricKey = task.objectiveKpiKey ? objectiveKpiToMetricKey[task.objectiveKpiKey] : null;
          
          for (const metricKey of metricKeys) {
            // Only classify metrics that match the task's objective KPI
            if (taskObjectiveMetricKey && metricKey !== taskObjectiveMetricKey) {
              continue; // Skip metrics that don't match the task's objective
            }
            
            const baselineValue = getMetricValue(baselineLatest.baseline, metricKey);
            const latestValue = getMetricValue(baselineLatest.latest, metricKey);
            const classification = classifyMetric(
              metricKey,
              baselineLatest.baseline,
              baselineLatest.latest
            );

            // DEBUG: Log classification for all tasks with objectives
            if (typeof debugLog === 'function' && task.objectiveKpiKey) {
              debugLog(`[Traffic Lights] ${metricKey}: baselineValue=${baselineValue}, latestValue=${latestValue}, classification=${classification || 'null'}, taskObjectiveMetricKey=${taskObjectiveMetricKey}`, 'info');
            }

            if (classification) {
              counts[metricKey][classification]++;
              taskClassifications.push(classification);
            }
          }
        } else if (typeof debugLog === 'function' && task.objectiveKpiKey) {
          debugLog(`[Traffic Lights] Task "${task.title || task.id}": No baselineLatest (measurementsCount=${measurements.length}, scope=${scope})`, 'warn');
        } else if (task.title && (task.title.includes('Landscape') || task.title.includes('photography-courses'))) {
          if (typeof debugLog === 'function') {
            debugLog(`[Traffic Lights] No baselineLatest for task: id=${task.id}, title="${task.title}", measurementsCount=${measurements.length}, scope=${scope}, hasActiveCycle=${!!activeCycle}`, 'warn');
          }
        }

        // For aggregated "all_metrics": count ALL active tasks
        // If task has classifications, use majority vote (at least 3 out of 6 metrics)
        // If no classifications or tie, default to 'same'
        if (taskClassifications.length > 0) {
          // Count occurrences of each classification
          const classCounts = { worse: 0, same: 0, better: 0 };
          taskClassifications.forEach(cls => {
            if (cls) classCounts[cls]++;
          });
          
          // Find the majority classification
          const total = classCounts.worse + classCounts.same + classCounts.better;
          const majority = Math.max(classCounts.worse, classCounts.same, classCounts.better);
          
          let majorityClass = null;
          if (classCounts.better === majority && majority > 0) {
            majorityClass = 'better';
          } else if (classCounts.worse === majority && majority > 0) {
            majorityClass = 'worse';
          } else if (classCounts.same === majority && majority > 0) {
            majorityClass = 'same';
          }
          
          // If there's a clear majority (more than half), use it
          // Otherwise default to 'same'
          if (majorityClass && majority > total / 2) {
            counts.all_metrics[majorityClass]++;
          } else {
            // No clear majority or no classifications - default to 'same'
            counts.all_metrics.same++;
          }
        } else {
          // Task has no metric classifications (insufficient data) - count as 'same'
          counts.all_metrics.same++;
        }
      }

      return counts;
    }

    // Sorting state
    let optimisationSortState = {
      column: 'latestCaptured',
      direction: 'desc'
    };
    
    // Pagination state
    let optimisationPaginationState = {
      currentPage: 1,
      rowsPerPage: 10
    };

    // Load all optimisation tasks (Phase 9: use dashboard API)
    window.loadAllOptimisationTasks = async function loadAllOptimisationTasks() {
      try {
        // Check if admin key is set
        if (!window.hasAdminKey || !window.hasAdminKey()) {
          window.optimisationModuleState.allTasks = [];
          window.optimisationModuleState.filteredTasks = [];
          window.optimisationModuleState.authError = 'Admin key not set. Please set your admin key in the Configuration section.';
          updateOptimisationSummaryCards();
          renderOptimisationTasksTable();
          return [];
        }

        const headers = window.getOptimisationHeaders();
        const scope = window.optimisationModuleState.scope || 'active_cycle';
        const response = await fetch(apiUrl(`/api/optimisation/dashboard?scope=${scope}`), {
          method: 'GET',
          headers: headers
        });

        if (!response.ok) {
          if (response.status === 401) {
            window.optimisationModuleState.authError = 'Unauthorized - admin key missing or invalid. Please check your admin key in the Configuration section.';
          } else {
            window.optimisationModuleState.authError = `Failed to load dashboard (${response.status}). Please try refreshing the page.`;
          }
          window.optimisationModuleState.allTasks = [];
          window.optimisationModuleState.filteredTasks = [];
          window.optimisationModuleState.dashboardTiles = null;
          window.optimisationModuleState.dashboardImpact = null;
          window.optimisationModuleState.dashboardTimeseries = null;
          updateOptimisationSummaryCards();
          renderOptimisationTasksTable();
          return [];
        }

        // Clear any previous auth errors
        window.optimisationModuleState.authError = null;

        const data = await response.json();
        window.optimisationModuleState.allTasks = data.tasks || [];
        window.optimisationModuleState.filteredTasks = [...window.optimisationModuleState.allTasks];
        window.optimisationModuleState.dashboardTiles = data.tiles || null;
        window.optimisationModuleState.dashboardImpact = data.impact || null;
        window.optimisationModuleState.dashboardTimeseries = data.timeseries || null;
        
        updateOptimisationSummaryCards();
        updateKPITiles();
        updateImpactTiles();
        updateTimeseriesCharts();
        updateTrafficLights();
        applyOptimisationFilters();
        renderOptimisationTasksTable();
        
        return window.optimisationModuleState.allTasks;
      } catch (error) {
        console.error('[Optimisation Module] Error loading dashboard:', error);
        window.optimisationModuleState.allTasks = [];
        window.optimisationModuleState.filteredTasks = [];
        window.optimisationModuleState.dashboardTiles = null;
        window.optimisationModuleState.dashboardImpact = null;
        window.optimisationModuleState.dashboardTimeseries = null;
        window.optimisationModuleState.authError = error.message || 'Failed to load dashboard. Please try refreshing the page.';
        updateOptimisationSummaryCards();
        renderOptimisationTasksTable();
        return [];
      }
    };

    // Update summary cards (B6)
    function updateOptimisationSummaryCards() {
      let tasks = window.optimisationModuleState.allTasks;
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      const active = tasks.filter(t => ['planned', 'in_progress', 'monitoring'].includes(t.status));
      const planned = tasks.filter(t => t.status === 'planned');
      const inProgress = tasks.filter(t => t.status === 'in_progress');
      const monitoring = tasks.filter(t => t.status === 'monitoring');
      const done = tasks.filter(t => t.status === 'done');
      const paused = tasks.filter(t => t.status === 'paused');
      const cancelled = tasks.filter(t => t.status === 'cancelled');
      
      // Updated (30d): Count distinct tasks with latest measurement in last 30 days
      // Must use the same task set and scope as other status tiles
      const scope = window.optimisationModuleState.scope || 'active_cycle';
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      const updatedTaskIds = new Set();
      for (const task of tasks) {
        const latestMeasurement = getLatestMeasurementInScope(task, scope);
        if (latestMeasurement && latestMeasurement.captured_at) {
          const latestDate = new Date(latestMeasurement.captured_at);
          if (latestDate >= thirtyDaysAgo) {
            updatedTaskIds.add(task.id);
          }
        }
      }
      const recent = Array.from(updatedTaskIds).length;

      document.getElementById('optimisation-summary-active').textContent = active.length;
      document.getElementById('optimisation-summary-planned').textContent = planned.length;
      document.getElementById('optimisation-summary-in-progress').textContent = inProgress.length;
      document.getElementById('optimisation-summary-monitoring').textContent = monitoring.length;
      document.getElementById('optimisation-summary-done').textContent = done.length;
      document.getElementById('optimisation-summary-paused').textContent = paused.length;
      document.getElementById('optimisation-summary-cancelled').textContent = cancelled.length;
      document.getElementById('optimisation-summary-recent').textContent = recent.length;

      // Update tab counts
      const pausedCancelled = paused.length + cancelled.length;
      
      document.querySelectorAll('.optimisation-tab-count[data-tab="active"]').forEach(el => {
        el.textContent = `(${active.length})`;
      });
      document.querySelectorAll('.optimisation-tab-count[data-tab="done"]').forEach(el => {
        el.textContent = `(${done.length})`;
      });
      document.querySelectorAll('.optimisation-tab-count[data-tab="paused-cancelled"]').forEach(el => {
        el.textContent = `(${pausedCancelled})`;
      });

      // Update goal rollups (Phase B) - only count active tasks (not cancelled/deleted)
      const activeTasks = tasks.filter(t => !['done', 'cancelled', 'deleted'].includes(t.status));
      // Use objective_status from cycle (Phase 5) or fallback to goal_state
      const goalNotSet = activeTasks.filter(t => {
        const status = t.objective_status || t.goal_state;
        return !status || status === 'not_set';
      }).length;
      const goalOnTrack = activeTasks.filter(t => {
        const status = t.objective_status || t.goal_state;
        return status === 'on_track';
      }).length;
      const goalOverdue = activeTasks.filter(t => {
        const status = t.objective_status || t.goal_state;
        return status === 'overdue';
      }).length;
      const goalMet = activeTasks.filter(t => {
        const status = t.objective_status || t.goal_state;
        return status === 'met';
      }).length;

      const notSetEl = document.getElementById('optimisation-goal-not-set');
      const onTrackEl = document.getElementById('optimisation-goal-on-track');
      const overdueEl = document.getElementById('optimisation-goal-overdue');
      const metEl = document.getElementById('optimisation-goal-met');
      
      if (notSetEl) notSetEl.textContent = goalNotSet;
      if (onTrackEl) onTrackEl.textContent = goalOnTrack;
      if (overdueEl) overdueEl.textContent = goalOverdue;
      if (metEl) metEl.textContent = goalMet;
    }

    // Update timeseries charts
    // OLD updateTimeseriesCharts function removed - see new implementation below

    // Sort optimisation tasks
    function sortOptimisationTasks(tasks) {
      const sorted = [...tasks];
      sorted.sort((a, b) => {
        let aVal, bVal;
        switch (optimisationSortState.column) {
          case 'keyword':
            aVal = (a.keyword_text || '').toLowerCase();
            bVal = (b.keyword_text || '').toLowerCase();
            break;
          case 'url':
            aVal = (a.target_url_clean || '').toLowerCase();
            bVal = (b.target_url_clean || '').toLowerCase();
            break;
          case 'type':
            aVal = (a.task_type || 'on_page').toLowerCase();
            bVal = (b.task_type || 'on_page').toLowerCase();
            break;
          case 'status':
            aVal = (a.status || 'planned').toLowerCase();
            bVal = (b.status || 'planned').toLowerCase();
            break;
          case 'cycle':
            aVal = a.cycle_active || 1;
            bVal = b.cycle_active || 1;
            break;
          case 'lastActivity':
            aVal = a.last_activity_at ? new Date(a.last_activity_at).getTime() : (a.updated_at ? new Date(a.updated_at).getTime() : 0);
            bVal = b.last_activity_at ? new Date(b.last_activity_at).getTime() : (b.updated_at ? new Date(b.updated_at).getTime() : 0);
            break;
          case 'baselineCaptured':
            aVal = ((a.baseline_metrics && a.baseline_metrics.captured_at) || (a.baseline_metrics && a.baseline_metrics.created_at)) ? new Date((a.baseline_metrics && a.baseline_metrics.captured_at) || (a.baseline_metrics && a.baseline_metrics.created_at)).getTime() : 0;
            bVal = ((b.baseline_metrics && b.baseline_metrics.captured_at) || (b.baseline_metrics && b.baseline_metrics.created_at)) ? new Date((b.baseline_metrics && b.baseline_metrics.captured_at) || (b.baseline_metrics && b.baseline_metrics.created_at)).getTime() : 0;
            break;
          case 'latestCaptured':
            aVal = (a.latest_metrics?.captured_at || a.latest_metrics?.created_at) ? new Date(a.latest_metrics.captured_at || a.latest_metrics.created_at).getTime() : 0;
            bVal = (b.latest_metrics?.captured_at || b.latest_metrics?.created_at) ? new Date(b.latest_metrics.captured_at || b.latest_metrics.created_at).getTime() : 0;
            break;
          case 'title':
            aVal = (a.title || '').toLowerCase();
            bVal = (b.title || '').toLowerCase();
            break;
          default:
            return 0;
        }
        
        if (aVal < bVal) return optimisationSortState.direction === 'asc' ? -1 : 1;
        if (aVal > bVal) return optimisationSortState.direction === 'asc' ? 1 : -1;
        return 0;
      });
      return sorted;
    }

    // Render tasks table (B2)
    function renderOptimisationTasksTable() {
      const tbody = document.getElementById('optimisation-tasks-tbody');
      if (!tbody) return;

      let tasks = window.optimisationModuleState.filteredTasks;

      // Apply tab filter
      if (window.optimisationModuleState.activeTab === 'active') {
        tasks = tasks.filter(t => ['planned', 'in_progress', 'monitoring'].includes(t.status));
      } else if (window.optimisationModuleState.activeTab === 'done') {
        tasks = tasks.filter(t => t.status === 'done');
      } else if (window.optimisationModuleState.activeTab === 'paused-cancelled') {
        tasks = tasks.filter(t => ['paused', 'cancelled'].includes(t.status));
      }

      // Sort tasks
      tasks = sortOptimisationTasks(tasks);
      
      // Calculate pagination
      const totalRows = tasks.length;
      const rowsPerPage = optimisationPaginationState.rowsPerPage === 'all' ? totalRows : optimisationPaginationState.rowsPerPage;
      const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
      const currentPage = Math.min(Math.max(1, optimisationPaginationState.currentPage), totalPages);
      optimisationPaginationState.currentPage = currentPage;
      
      const startIdx = rowsPerPage === 'all' ? 0 : (currentPage - 1) * rowsPerPage;
      const endIdx = rowsPerPage === 'all' ? totalRows : Math.min(startIdx + rowsPerPage, totalRows);
      const paginatedTasks = tasks.slice(startIdx, endIdx);

      tbody.innerHTML = '';

        // Check for authentication error
      if (window.optimisationModuleState.authError) {
        const errorMessage = window.optimisationModuleState.authError;
        tbody.innerHTML = `<tr><td colspan="13" style="padding: 2rem; text-align: center;">
          <div style="color: #ef4444; margin-bottom: 0.5rem; font-weight: 600;"> Authentication Error</div>
          <div style="color: #666; margin-bottom: 1rem;">${escapeHtml(errorMessage)}</div>
          <a href="#configuration" onclick="if(typeof setActivePanel === 'function') setActivePanel('configuration');" style="color: #2563eb; text-decoration: underline;">Go to Configuration to set your admin key</a>
        </td></tr>`;
        updateOptimisationPaginationControls(0, 1, 1, 0, 0);
        return;
      }

      if (tasks.length === 0) {
        tbody.innerHTML = '<tr><td colspan="13" class="ranking-table-empty">No tasks found</td></tr>';
        updateOptimisationPaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx);
        return;
      }

      paginatedTasks.forEach((task, index) => {
        const tr = document.createElement('tr');
        tr.onclick = () => openOptimisationTaskDrawer(task.id);

        const statusColors = {
          planned: { bg: 'rgba(245, 158, 11, 0.3)', color: '#fbbf24' }, // Brighter amber
          in_progress: { bg: 'rgba(16, 185, 129, 0.3)', color: '#34d399' }, // Brighter green
          monitoring: { bg: 'rgba(59, 130, 246, 0.3)', color: '#60a5fa' }, // Brighter blue
          done: { bg: 'rgba(156, 163, 175, 0.3)', color: '#d1d5db' }, // Brighter grey
          paused: { bg: 'rgba(245, 158, 11, 0.3)', color: '#fbbf24' }, // Brighter amber
          cancelled: { bg: 'rgba(239, 68, 68, 0.3)', color: '#f87171' } // Brighter red
        };

        const statusStyle = statusColors[task.status] || statusColors.planned;
        const lastActivity = task.last_activity_at 
          ? new Date(task.last_activity_at).toLocaleDateString('en-GB')
          : new Date(task.updated_at).toLocaleDateString('en-GB');

        // Format baseline and latest captured dates
        // Use captured_at from metrics (set by view from event.created_at) or fallback to created_at
        const baselineCaptured = (task.baseline_metrics?.captured_at || task.baseline_metrics?.created_at)
          ? new Date(task.baseline_metrics.captured_at || task.baseline_metrics.created_at).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' })
          : '';
        const latestCapturedDate = (task.latest_metrics?.captured_at || task.latest_metrics?.created_at)
          ? new Date(task.latest_metrics.captured_at || task.latest_metrics.created_at)
          : null;
        const latestCaptured = latestCapturedDate 
          ? latestCapturedDate.toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' })
          : null;
        
        // "Needs update" indicator: blank or older than 30 days
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const needsUpdate = !latestCapturedDate || latestCapturedDate < thirtyDaysAgo;
        const needsUpdateBadge = needsUpdate 
          ? '<span style="padding: 0.125rem 0.375rem; background: #fee2e2; color: #991b1b; border-radius: 4px; font-size: 0.7rem; font-weight: 600; margin-left: 0.25rem;">Needs update</span>'
          : '';
        
        // "No measurement yet" indicator
        const measurementIndicator = !latestCaptured 
          ? '<span style="padding: 0.25rem 0.5rem; background: #fef3c7; color: #92400e; border-radius: 4px; font-size: 0.75rem;">No measurement yet</span>'
          : '';

        // Extract path from URL for display
        let urlPath = '';
        let fullUrl = '';
        const urlText = task.target_url_clean || task.target_url || '';
        if (urlText) {
          try {
            // If URL contains domain, extract just the path
            if (urlText.includes('alanranger.com')) {
              const urlObj = new URL(urlText.startsWith('http') ? urlText : 'https://' + urlText);
              urlPath = urlObj.pathname || '/';
              fullUrl = urlObj.href;
            } else if (urlText.startsWith('/')) {
              // Already a path
              urlPath = urlText;
              fullUrl = 'https://www.alanranger.com' + urlText;
            } else {
              // Assume it's a path without leading slash
              urlPath = '/' + urlText;
              fullUrl = 'https://www.alanranger.com/' + urlText;
            }
          } catch (e) {
            // Fallback: treat as path
            urlPath = urlText.startsWith('/') ? urlText : '/' + urlText;
            fullUrl = 'https://www.alanranger.com' + urlPath;
          }
        }

        // Build goal status display (Phase 5: use objective_status from cycle)
        let goalHtml = '';
        const objectiveStatus = task.objective_status || task.goal_state || 'not_set';
        
        if (objectiveStatus && objectiveStatus !== 'not_set') {
          const goalConfig = {
            'on_track': { text: 'On track', bg: 'rgba(59, 130, 246, 0.3)', color: '#60a5fa' }, // Brighter blue
            'overdue': { text: 'Overdue', bg: 'rgba(239, 68, 68, 0.3)', color: '#f87171' }, // Brighter red
            'met': { text: 'Met', bg: 'rgba(16, 185, 129, 0.3)', color: '#34d399' }, // Brighter green
            'at_risk': { text: 'At risk', bg: 'rgba(245, 158, 11, 0.3)', color: '#fbbf24' } // Brighter amber
          };
          const config = goalConfig[objectiveStatus] || goalConfig['on_track'];
          let goalText = `<span style="padding: 0.25rem 0.5rem; border-radius: 4px; background: ${config.bg}; color: ${config.color}; font-size: 0.75rem; font-weight: 700; display: inline-block; margin-bottom: 0.25rem;">${config.text}</span>`;
          
          // Add progress info from objective_progress (Phase 8: use computeGoalProgress)
          if (task.objective_progress) {
            const progress = task.objective_progress;
            if (progress.baseline_value != null && progress.latest_value != null && progress.target != null) {
              const taskKpi = task.objective_kpi || task.primary_kpi || task.objective_metric || null;
              const targetType = (task.objective && task.objective.target_type) || 'delta';
              
              if (taskKpi) {
                // Use Phase 8 helper for proper formatting
                const goalProgress = computeGoalProgress({
                  kpiKey: taskKpi,
                  baseline: progress.baseline_value,
                  latest: progress.latest_value,
                  targetValue: progress.target,
                  targetType: targetType
                });
                
                const delta = progress.delta != null ? progress.delta : 0;
                let deltaColor = '#f59e0b'; // Amber for no change (default)
                if (delta > 0) deltaColor = '#10b981'; // Green for positive/improvement
                else if (delta < 0) deltaColor = '#ef4444'; // Red for negative/worsening
                goalText += `<div style="font-size: 0.7rem; color: ${deltaColor} !important; margin-top: 0.125rem; font-weight: 600;">${goalProgress.deltaLabel} vs target ${goalProgress.targetLabel}</div>`;
                if (goalProgress.remainingToTarget != null && goalProgress.remainingToTarget > 0) {
                  const displayMeta = KPI_DISPLAY_METADATA[taskKpi];
                  const remainingLabel = displayMeta ? displayMeta.formatDelta(goalProgress.remainingToTarget) : String(goalProgress.remainingToTarget);
                  goalText += `<div style="font-size: 0.65rem; color: #d1d5db; margin-top: 0.125rem; font-weight: 500;">Remaining: ${remainingLabel}</div>`;
                }
              }
            }
          } else if (task.objective && task.objective.kpi && task.objective.target != null) {
            // Use objective from cycle
            const kpiLabel = task.objective.kpi.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            // Format target value: for CTR KPIs, convert ratio to percentage
            let formattedTarget = task.objective.target;
            const isCtrKpi = task.objective.kpi === 'ctr_28d' || task.objective.kpi === 'ctr';
            if (isCtrKpi && task.objective.target_type === 'absolute' && formattedTarget < 1 && formattedTarget > 0) {
              // Convert ratio (0.025) to percentage (2.5%)
              formattedTarget = (formattedTarget * 100).toFixed(1) + '%';
            } else if (isCtrKpi && task.objective.target_type === 'delta') {
              // For delta targets, also format as percentage if it's a small value
              if (Math.abs(formattedTarget) < 1 && Math.abs(formattedTarget) > 0) {
                formattedTarget = (formattedTarget * 100).toFixed(1) + '%';
              }
            }
            const targetText = task.objective.target_type === 'delta' 
              ? `${kpiLabel} ${task.objective.target >= 0 ? '+' : ''}${formattedTarget}`
              : `${kpiLabel}  ${formattedTarget}`;
            let dueText = '';
            if (task.objective.due_at || task.objective_due_at) {
              const dueDate = new Date(task.objective.due_at || task.objective_due_at).toLocaleDateString('en-GB');
              dueText = ` by ${dueDate}`;
            }
            goalText += `<div style="font-size: 0.7rem; color: #d1d5db; margin-top: 0.25rem; font-weight: 500;">${targetText}${dueText}</div>`;
          } else if (task.objective_kpi && task.objective_target_delta != null) {
            // Legacy fallback
            const kpiLabel = task.objective_kpi.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            // Format target value: for CTR KPIs, convert ratio to percentage
            let formattedTarget = Math.abs(task.objective_target_delta);
            const isCtrKpi = task.objective_kpi === 'ctr_28d' || task.objective_kpi === 'ctr';
            if (isCtrKpi && formattedTarget < 1 && formattedTarget > 0) {
              // Convert ratio (0.025) to percentage (2.5%)
              formattedTarget = (formattedTarget * 100).toFixed(1) + '%';
            }
            const direction = task.objective_direction === 'decrease' ? '-' : '+';
            const targetText = `${kpiLabel} ${direction}${formattedTarget}`;
            let dueText = '';
            if (task.objective_due_at) {
              const dueDate = new Date(task.objective_due_at).toLocaleDateString('en-GB');
              dueText = ` by ${dueDate}`;
            }
            goalText += `<div style="font-size: 0.7rem; color: #d1d5db; margin-top: 0.25rem; font-weight: 500;">${targetText}${dueText}</div>`;
          }
          
          // Add delta if available (from progress or legacy)
          if (task.objective_progress && task.objective_progress.delta != null) {
            const delta = task.objective_progress.delta;
            const deltaColor = delta >= 0 ? '#34d399' : '#f87171'; // Brighter colors
            const deltaSign = delta >= 0 ? '+' : '';
            goalText += `<div style="font-size: 0.7rem; color: ${deltaColor}; margin-top: 0.125rem; font-weight: 700;"> ${deltaSign}${delta}</div>`;
          } else if (task.objective_delta != null) {
            // Legacy fallback
            const deltaColor = task.objective_delta >= 0 ? '#34d399' : '#f87171'; // Brighter colors
            const deltaSign = task.objective_delta >= 0 ? '+' : '';
            goalText += `<div style="font-size: 0.7rem; color: ${deltaColor}; margin-top: 0.125rem; font-weight: 700;"> ${deltaSign}${task.objective_delta}</div>`;
          }
          
          goalHtml = goalText;
        }

        // Phase 9: Format new columns
        const objectiveKpiKey = task.objectiveKpiKey || (task.objective && task.objective.kpi) || null;
        let objectiveKpiLabel = '';
        let baselineLatestHtml = '';
        let deltaHtml = '';
        let sparklineHtml = '';
        
        if (objectiveKpiKey && KPI_DISPLAY_METADATA[objectiveKpiKey]) {
          const kpiMeta = KPI_DISPLAY_METADATA[objectiveKpiKey];
          objectiveKpiLabel = kpiMeta.label || objectiveKpiKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          
          // Baseline  Latest
          const baselineValue = task.baselineValue != null ? task.baselineValue : (task.baseline_metrics ? kpiMeta.get ? kpiMeta.get(task.baseline_metrics) : null : null);
          const latestValue = task.latestValue != null ? task.latestValue : (task.latest_metrics ? kpiMeta.get ? kpiMeta.get(task.latest_metrics) : null : null);
          
          if (baselineValue != null && latestValue != null) {
            const baselineFormatted = kpiMeta.formatValue ? kpiMeta.formatValue(baselineValue) : String(baselineValue);
            const latestFormatted = kpiMeta.formatValue ? kpiMeta.formatValue(latestValue) : String(latestValue);
            baselineLatestHtml = `${baselineFormatted}  ${latestFormatted}`;
          } else if (baselineValue != null) {
            baselineLatestHtml = `${kpiMeta.formatValue ? kpiMeta.formatValue(baselineValue) : String(baselineValue)}  `;
          } else if (latestValue != null) {
            baselineLatestHtml = `  ${kpiMeta.formatValue ? kpiMeta.formatValue(latestValue) : String(latestValue)}`;
          }
          
          //  vs Baseline
          const delta = task.delta != null ? task.delta : (baselineValue != null && latestValue != null ? (objectiveKpiKey === 'current_rank' ? baselineValue - latestValue : latestValue - baselineValue) : null);
          if (delta != null) {
            const deltaFormatted = kpiMeta.formatDelta ? kpiMeta.formatDelta(delta) : (delta >= 0 ? `+${delta}` : String(delta));
            const deltaColor = delta >= 0 ? '#10b981' : '#ef4444';
            deltaHtml = `<span style="color: ${deltaColor}; font-weight: 600;">${deltaFormatted}</span>`;
          }
          
          // Sparkline
          const sparklinePoints = task.sparklinePoints || [];
          if (sparklinePoints.length > 1) {
            sparklineHtml = renderSparkline(sparklinePoints, 80, 24);
          }
        }
        
        // Due In
        const dueIn = task.dueIn || (task.dueAt ? (() => {
          const dueDate = new Date(task.dueAt);
          const now = new Date();
          const daysUntilDue = Math.ceil((dueDate - now) / (1000 * 60 * 60 * 24));
          if (daysUntilDue < 0) {
            return `Overdue ${Math.abs(daysUntilDue)}d`;
          } else {
            return `${daysUntilDue}d`;
          }
        })() : null);
        const dueInHtml = dueIn ? (dueIn.startsWith('Overdue') ? `<span style="color: #dc2626; font-weight: 600;">${dueIn}</span>` : dueIn) : '';

        tr.innerHTML = `
          <td style="text-align: left;"><strong>${escapeHtml(task.keyword_text || '')}</strong></td>
          <td style="max-width: 150px; word-wrap: break-word; word-break: break-all;">
            ${urlPath ? `<a href="${fullUrl}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${escapeHtml(urlPath)}</a>` : ''}
          </td>
          <td><span style="padding: 0.25rem 0.5rem; background: #f0f0f0; border-radius: 4px;">${escapeHtml(task.task_type || 'on_page')}</span></td>
          <td><span style="padding: 0.25rem 0.5rem; border-radius: 4px; background: ${statusStyle.bg}; color: ${statusStyle.color}; font-weight: 600; font-size: 0.85rem;">${escapeHtml(task.status || 'planned')}</span></td>
          <td>Cycle ${task.cycle_no || task.cycle_active || 1}</td>
          <td>${baselineCaptured}</td>
          <td>${latestCaptured || measurementIndicator}${needsUpdateBadge}</td>
          <td>${escapeHtml(task.title || '')}</td>
          <td style="font-size: 0.85rem;">${objectiveKpiLabel}</td>
          <td style="font-size: 0.85rem;">${baselineLatestHtml}</td>
          <td style="font-size: 0.85rem;">${deltaHtml}</td>
          <td style="font-size: 0.85rem;">${dueInHtml}</td>
          <td style="font-size: 0.75rem; text-align: center;">${sparklineHtml}</td>
          <td style="font-size: 0.85rem;">${goalHtml}</td>
          <td style="display: flex; flex-direction: column; gap: 1rem; align-items: center; min-width: 60px;">
            <button class="btn btn-secondary" onclick="event.stopPropagation(); openOptimisationTaskDrawer('${task.id}');" style="padding: 0.04rem 0.1rem; font-size: 0.5rem; width: 100%; background: var(--dark-brand) !important; color: #000 !important; border: 1px solid var(--dark-brand) !important; font-weight: 600;">Open</button>
            <button class="btn btn-small" onclick="event.stopPropagation(); updateTaskLatest('${task.id}');" style="padding: 0.04rem 0.1rem; font-size: 0.5rem; width: 100%; background: rgba(59, 130, 246, 0.2) !important; color: #60a5fa !important; border: 1px solid #60a5fa !important; font-weight: 600;" title="Capture latest metrics for this task.">Update</button>
          </td>
        `;

        tbody.appendChild(tr);
      });
      
      // Update sort indicators
      document.querySelectorAll('#optimisation-tasks-table th.sortable').forEach(th => {
        th.classList.remove('sort-asc', 'sort-desc');
        if (th.dataset.sort === optimisationSortState.column) {
          th.classList.add(`sort-${optimisationSortState.direction}`);
        }
      });
      
      // Update pagination controls
      updateOptimisationPaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx);
      
      // Wire sorting handlers
      wireOptimisationSorting();
      
      // Wire pagination handlers
      wireOptimisationPagination();
      
      // Wire pagination on initial load if not already done
      setTimeout(() => {
        wireOptimisationPagination();
      }, 100);
    }
    
    // Update pagination controls
    function updateOptimisationPaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx) {
      const paginationControls = document.getElementById('optimisation-pagination-controls');
      const paginationInfo = document.getElementById('optimisation-pagination-info');
      const pageInfo = document.getElementById('optimisation-pagination-page-info');
      const firstBtn = document.getElementById('optimisation-pagination-first');
      const prevBtn = document.getElementById('optimisation-pagination-prev');
      const nextBtn = document.getElementById('optimisation-pagination-next');
      const lastBtn = document.getElementById('optimisation-pagination-last');
      const rowsPerPageSelect = document.getElementById('optimisation-rows-per-page');
      
      if (!paginationControls) return;
      
      if (totalRows === 0) {
        paginationControls.style.display = 'none';
        return;
      }
      
      paginationControls.style.display = 'flex';
      
      if (paginationInfo) {
        paginationInfo.textContent = `Showing ${startIdx + 1}-${endIdx} of ${totalRows}`;
      }
      
      if (pageInfo) {
        pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
      }
      
      if (firstBtn) {
        firstBtn.disabled = currentPage === 1;
      }
      
      if (prevBtn) {
        prevBtn.disabled = currentPage === 1;
      }
      
      if (nextBtn) {
        nextBtn.disabled = currentPage === totalPages;
      }
      
      if (lastBtn) {
        lastBtn.disabled = currentPage === totalPages;
      }
      
      if (rowsPerPageSelect) {
        rowsPerPageSelect.value = optimisationPaginationState.rowsPerPage === 'all' ? 'all' : String(optimisationPaginationState.rowsPerPage);
      }
    }
    
    // Wire pagination handlers
    function wireOptimisationPagination() {
      const firstBtn = document.getElementById('optimisation-pagination-first');
      const prevBtn = document.getElementById('optimisation-pagination-prev');
      const nextBtn = document.getElementById('optimisation-pagination-next');
      const lastBtn = document.getElementById('optimisation-pagination-last');
      const rowsPerPageSelect = document.getElementById('optimisation-rows-per-page');
      
      if (firstBtn) {
        const newFirstBtn = firstBtn.cloneNode(true);
        firstBtn.parentNode.replaceChild(newFirstBtn, firstBtn);
        newFirstBtn.addEventListener('click', () => {
          optimisationPaginationState.currentPage = 1;
          renderOptimisationTasksTable();
        });
      }
      
      if (prevBtn) {
        const newPrevBtn = prevBtn.cloneNode(true);
        prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
        newPrevBtn.addEventListener('click', () => {
          if (optimisationPaginationState.currentPage > 1) {
            optimisationPaginationState.currentPage--;
            renderOptimisationTasksTable();
          }
        });
      }
      
      if (nextBtn) {
        const newNextBtn = nextBtn.cloneNode(true);
        nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
        newNextBtn.addEventListener('click', () => {
          const totalRows = window.optimisationModuleState.filteredTasks.length;
          const rowsPerPage = optimisationPaginationState.rowsPerPage === 'all' ? totalRows : optimisationPaginationState.rowsPerPage;
          const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
          if (optimisationPaginationState.currentPage < totalPages) {
            optimisationPaginationState.currentPage++;
            renderOptimisationTasksTable();
          }
        });
      }
      
      if (lastBtn) {
        const newLastBtn = lastBtn.cloneNode(true);
        lastBtn.parentNode.replaceChild(newLastBtn, lastBtn);
        newLastBtn.addEventListener('click', () => {
          const totalRows = window.optimisationModuleState.filteredTasks.length;
          const rowsPerPage = optimisationPaginationState.rowsPerPage === 'all' ? totalRows : optimisationPaginationState.rowsPerPage;
          const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
          optimisationPaginationState.currentPage = totalPages;
          renderOptimisationTasksTable();
        });
      }
      
      if (rowsPerPageSelect) {
        const newSelect = rowsPerPageSelect.cloneNode(true);
        rowsPerPageSelect.parentNode.replaceChild(newSelect, rowsPerPageSelect);
        newSelect.addEventListener('change', () => {
          optimisationPaginationState.rowsPerPage = newSelect.value === 'all' ? 'all' : parseInt(newSelect.value, 10);
          optimisationPaginationState.currentPage = 1; // Reset to first page
          renderOptimisationTasksTable();
        });
      }
    }
    
    // Wire sorting handlers
    function wireOptimisationSorting() {
      const sortableHeaders = document.querySelectorAll('#optimisation-tasks-table th.sortable');
      sortableHeaders.forEach(th => {
        // Remove existing listeners by cloning
        const newTh = th.cloneNode(true);
        th.parentNode.replaceChild(newTh, th);
        
        newTh.addEventListener('click', function(e) {
          e.stopPropagation();
          const column = this.dataset.sort;
          if (!column) return;
          
          if (optimisationSortState.column === column) {
            optimisationSortState.direction = optimisationSortState.direction === 'asc' ? 'desc' : 'asc';
          } else {
            optimisationSortState.column = column;
            optimisationSortState.direction = 'asc';
          }
          
          renderOptimisationTasksTable();
        });
      });
    }

    // Helper to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Tab switching (B2)
    function switchOptimisationTab(tabName) {
      window.optimisationModuleState.activeTab = tabName;
      
      // Reset pagination when switching tabs
      optimisationPaginationState.currentPage = 1;
      
      // Update tab button states
      document.querySelectorAll('.optimisation-tab-btn').forEach(btn => {
        btn.classList.toggle('metric-pill--active', btn.dataset.tab === tabName);
      });

      renderOptimisationTasksTable();
    }

    // Dragging state
    let optimisationDrawerDragState = {
      isDragging: false,
      startX: 0,
      startY: 0,
      startLeft: 0,
      startTop: 0
    };
    
    let optimisationDrawerState = {
      isMinimized: false,
      isMaximized: false,
      originalWidth: '1200px',
      originalHeight: 'auto',
      originalTop: '50%',
      originalLeft: '50%'
    };

    // Helper to disable write buttons in share mode
    function disableWriteButtonsInShareMode() {
      if (!window.isShareMode) return;
      
      const writeButtonIds = [
        'optimisation-cancel-task-btn',
        'optimisation-delete-task-btn',
        'optimisation-edit-objective-btn',
        'optimisation-add-measurement-btn',
        'optimisation-start-cycle-btn',
        'optimisation-complete-cycle-btn',
        'optimisation-archive-cycle-btn',
        'optimisation-add-event-btn',
        'optimisation-save-status-btn',
        'optimisation-save-objective-btn',
        'optimisation-update-latest-btn'
      ];
      
      writeButtonIds.forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
          btn.disabled = true;
          btn.style.opacity = '0.5';
          btn.style.cursor = 'not-allowed';
          btn.title = (btn.title || '') + ' (Not available in share mode)';
        }
      });
      
      // Disable inputs
      const titleInput = document.getElementById('optimisation-drawer-title');
      if (titleInput) {
        titleInput.disabled = true;
        titleInput.style.opacity = '0.5';
      }
      
      const statusSelect = document.getElementById('optimisation-change-status');
      if (statusSelect) {
        statusSelect.disabled = true;
        statusSelect.style.opacity = '0.5';
      }
      
      // Hide edit objective form
      const editForm = document.getElementById('optimisation-edit-objective-form');
      if (editForm) editForm.style.display = 'none';
    }

    // Open task drawer (B3, B4)
    window.openOptimisationTaskDrawer = async function openOptimisationTaskDrawer(taskId) {
      // DEBUG: Log what we received
      console.log('[Optimisation Drawer] openOptimisationTaskDrawer called with:', {
        taskId: taskId,
        taskIdType: typeof taskId,
        taskIdLength: taskId ? String(taskId).length : 0,
        taskIdValue: String(taskId),
        isUndefined: taskId === undefined,
        isNull: taskId === null,
        isEmptyString: taskId === '',
        isFalsy: !taskId
      });
      
      // Validate taskId
      if (!taskId) {
        console.error('[Optimisation Drawer] Task ID is missing or invalid:', {
          taskId: taskId,
          type: typeof taskId,
          value: String(taskId),
          stack: new Error().stack
        });
        alert('Task ID not found. Please try refreshing the page or creating the task again.');
        return;
      }
      
      // CRITICAL: Switch to Optimisation tab first, otherwise drawer will be hidden
      if (typeof setActivePanel === 'function') {
        setActivePanel('optimisation');
        ensurePanelRendered('optimisation');
        // Wait a moment for panel to become visible
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      const drawer = document.getElementById('optimisation-task-drawer');
      const backdrop = document.getElementById('optimisation-task-drawer-backdrop');
      
      if (!drawer) {
        console.error('[Optimisation Drawer] Drawer element not found');
        alert('Drawer element not found. Please refresh the page.');
        return;
      }
      
      if (!backdrop) {
        console.error('[Optimisation Drawer] Backdrop element not found');
        alert('Backdrop element not found. Please refresh the page.');
        return;
      }

      if (!window.optimisationModuleState) {
        window.optimisationModuleState = { allTasks: [], filteredTasks: [], activeTab: 'active', currentTaskId: null };
      }

      window.optimisationModuleState.currentTaskId = taskId;
      
      // Always reload tasks to ensure we have latest goal_state from the view
      // This ensures the badge uses the correct state even if migrations haven't been run
      if (typeof window.loadAllOptimisationTasks === 'function') {
        await window.loadAllOptimisationTasks();
      }
      
      // Find task (after reload to ensure fresh data)
      let task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      
      // If task still not found, error
      if (!task) {
        console.error('[Optimisation Drawer] Task not found after reload:', taskId);
        alert(`Task not found (ID: ${taskId}). Please try refreshing the page.`);
        return;
      }

      // Phase 6: Fetch full task details including cycles
      try {
        const headers = window.getOptimisationHeaders();
        const taskResponse = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'GET',
          headers: headers
        });
        if (taskResponse.ok) {
          const taskData = await taskResponse.json();
          console.log('[Optimisation Drawer] Task data from API:', taskData);
          // Merge cycles and other detailed fields into task
          task = {
            ...task,
            ...taskData.task,
            cycles: taskData.cycles || [],
            events: taskData.events || []
          };
          console.log('[Optimisation Drawer] Merged task with cycles:', task.cycles);
        }
      } catch (error) {
        console.error('[Optimisation Drawer] Error fetching task details:', error);
        // Continue with task from state if fetch fails
      }

      // Populate header
      document.getElementById('optimisation-drawer-keyword').textContent = task.keyword_text || '';
      const titleInput = document.getElementById('optimisation-drawer-title');
      if (titleInput) {
        titleInput.value = task.title || '';
      }
      
      // Make Target URL clickable
      const urlEl = document.getElementById('optimisation-drawer-url');
      const targetUrl = task.target_url_clean || task.target_url || '';
      let fullUrl = '';
      if (targetUrl) {
        try {
          if (targetUrl.includes('alanranger.com')) {
            fullUrl = targetUrl.startsWith('http') ? targetUrl : 'https://' + targetUrl;
          } else if (targetUrl.startsWith('/')) {
            fullUrl = 'https://www.alanranger.com' + targetUrl;
          } else {
            fullUrl = 'https://www.alanranger.com/' + targetUrl;
          }
        } catch (e) {
          fullUrl = 'https://www.alanranger.com/' + (targetUrl.startsWith('/') ? targetUrl : '/' + targetUrl);
        }
      }
      if (fullUrl) {
        urlEl.innerHTML = `<a href="${fullUrl}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${escapeHtml(targetUrl)}</a>`;
      } else {
        urlEl.textContent = targetUrl;
      }
      
      document.getElementById('optimisation-drawer-type').textContent = task.task_type || 'on_page';
      
      const statusColors = {
        planned: { bg: '#4b5563', color: '#ffffff' },
        in_progress: { bg: '#059669', color: '#ffffff' },
        monitoring: { bg: '#2563eb', color: '#ffffff' },
        done: { bg: '#6b7280', color: '#ffffff' },
        paused: { bg: '#d97706', color: '#ffffff' },
        cancelled: { bg: '#dc2626', color: '#ffffff' }
      };
      const statusStyle = statusColors[task.status] || statusColors.planned;
      const statusEl = document.getElementById('optimisation-drawer-status');
      statusEl.textContent = task.status || 'planned';
      statusEl.style.background = statusStyle.bg;
      statusEl.style.color = statusStyle.color;
      
      // Update cycle display with cycle info
      const cycleEl = document.getElementById('optimisation-drawer-cycle');
      const cycleSelector = document.getElementById('optimisation-drawer-cycle-selector');
      const cycleNo = task.cycle_no || task.cycle_active || 1;
      const cycleText = `Cycle ${cycleNo}`;
      if (task.cycle_start_date) {
        const startDate = new Date(task.cycle_start_date).toLocaleDateString('en-GB');
        cycleEl.textContent = `${cycleText} (Started: ${startDate})`;
      } else if (task.created_at) {
        const createdDate = new Date(task.created_at).toLocaleDateString('en-GB');
        cycleEl.textContent = `${cycleText} (Created: ${createdDate})`;
      } else {
        cycleEl.textContent = cycleText;
      }

      // Phase 6: Populate cycle selector dropdown
      // Debug: Log cycles data
      console.log('[Optimisation Drawer] Cycles data:', task.cycles, 'Length:', task.cycles?.length, 'Active cycle ID:', task.active_cycle_id);
      
      if (cycleSelector) {
        if (task.cycles && Array.isArray(task.cycles) && task.cycles.length > 0) {
          cycleSelector.innerHTML = '';
          // Sort cycles by cycle_no descending (newest first)
          const sortedCycles = [...task.cycles].sort((a, b) => (b.cycle_no || 0) - (a.cycle_no || 0));
          sortedCycles.forEach(c => {
            const option = document.createElement('option');
            option.value = c.id;
            option.textContent = `Cycle ${c.cycle_no}`;
            if (c.id === task.active_cycle_id) {
              option.selected = true;
            }
            cycleSelector.appendChild(option);
          });
          // Show selector if there are multiple cycles
          if (task.cycles.length > 1) {
            cycleSelector.style.display = 'inline-block';
            console.log('[Optimisation Drawer] Cycle selector shown with', task.cycles.length, 'cycles');
          } else {
            cycleSelector.style.display = 'none';
            console.log('[Optimisation Drawer] Cycle selector hidden (only 1 cycle)');
          }
          
          // Store cycles in state for later use
          if (!window.optimisationModuleState) {
            window.optimisationModuleState = {};
          }
          window.optimisationModuleState.taskCycles = task.cycles;
          window.optimisationModuleState.selectedCycleId = task.active_cycle_id;
          
          // Handle cycle selection change (remove old listener first to avoid duplicates)
          const oldHandler = cycleSelector.dataset.handler;
          if (oldHandler) {
            cycleSelector.removeEventListener('change', window[oldHandler]);
          }
          const handlerName = `cycleSelectorHandler_${taskId}`;
          const handler = async (e) => {
            const selectedCycleId = e.target.value;
            window.optimisationModuleState.selectedCycleId = selectedCycleId;
            const selectedCycle = task.cycles.find(c => c.id === selectedCycleId);
            const selectedCycleNo = selectedCycle?.cycle_no || 1;
            await loadCycleData(taskId, selectedCycleId, task.cycles, selectedCycle, selectedCycleNo, task);
          };
          window[handlerName] = handler;
          cycleSelector.dataset.handler = handlerName;
          cycleSelector.addEventListener('change', handler);
        } else {
          cycleSelector.style.display = 'none';
          console.log('[Optimisation Drawer] Cycle selector hidden (no cycles data)');
        }
      } else {
        console.error('[Optimisation Drawer] Cycle selector element not found!');
      }

      // Load progress data
      let progress = null;
      try {
        const headers = window.getOptimisationHeaders();
        const progressResponse = await fetch(apiUrl(`/api/optimisation/task/${taskId}/progress`), {
          method: 'GET',
          headers: headers
        });
        if (progressResponse.ok) {
          const progressData = await progressResponse.json();
          progress = progressData.progress || null;
        }
      } catch (error) {
        console.error('[Optimisation Drawer] Error loading progress:', error);
      }

      // Update objective display
      const objectiveCycleEl = document.getElementById('optimisation-drawer-objective-cycle');
      if (objectiveCycleEl) {
        objectiveCycleEl.textContent = `(Cycle ${cycleNo})`;
      }

      // Update progress badge - Use objective_status from cycle (Phase 5) or fallback to goal_state
      const objectiveBadgeEl = document.getElementById('optimisation-drawer-objective-badge');
      if (objectiveBadgeEl) {
        // Phase 5: Use objective_status from cycle (server-computed), fallback to goal_state
        let state = task.objective_status || task.goal_state;
        
        // Debug logging to understand what's happening
        if (typeof debugLog === 'function') {
          debugLog(`[Optimisation Badge] Task ${task.id}: goal_state="${task.goal_state}", objective_delta=${task.objective_delta}, target=${task.objective_target_delta || task.objective_target_value}, direction=${task.objective_direction}, progress.objective_state="${progress?.objective_state}"`, 'info');
        }
        
        // If goal_state is not available, determine from objective fields
        if (!state && (task.objective_metric || task.objective_kpi)) {
          // Check if baseline_metrics exists (from view) or if we have any measurement
          const hasBaseline = task.baseline_metrics || (progress && progress.baseline_value != null);
          state = hasBaseline ? 'on_track' : 'no_measurement';
          if (typeof debugLog === 'function') {
            debugLog(`[Optimisation Badge] goal_state was null, determined state="${state}" from objective fields`, 'warn');
          }
        } else if (!state) {
          state = 'not_set';
        }
        
        // NEVER use progress.objective_state - it's from a different (buggy) view
        // If we're seeing 'achieved' here, it means task.goal_state is wrong or missing
        if (typeof debugLog === 'function' && progress?.objective_state && progress.objective_state !== state) {
          debugLog(`[Optimisation Badge] WARNING: progress.objective_state="${progress.objective_state}" differs from goal_state="${state}". Using goal_state.`, 'warn');
        }
        
        // ALWAYS validate state using actual delta vs target - don't trust database views
        // This ensures badge matches reality regardless of which view is used
        const target = task.objective_target_delta != null ? task.objective_target_delta : 
          (task.objective_target_value != null ? task.objective_target_value : null);
        
        if (target != null && target > 0 && (task.objective_metric || task.objective_kpi)) {
          // Get delta from task (from goal status view) or calculate from progress
          let delta = task.objective_delta;
          if (delta === null || delta === undefined) {
            if (progress && progress.latest_value != null && progress.baseline_value != null) {
              delta = progress.latest_value - progress.baseline_value;
            }
          }
          
          // If we have delta, validate it against target
          if (delta !== null && delta !== undefined) {
            const direction = task.objective_direction || 'increase';
            const meetsTarget = direction === 'decrease' 
              ? delta <= (target * -1)
              : delta >= target;
            
            // Override state based on actual delta, not database view
            if (meetsTarget) {
              if (state !== 'met' && state !== 'achieved') {
                if (typeof debugLog === 'function') {
                  debugLog(`[Optimisation Badge] Overriding state "${state}" to 'met': delta=${delta} meets target=${target}`, 'info');
                }
                state = 'met';
              }
            } else {
              // Delta doesn't meet target - can't be 'met' or 'achieved'
              if (state === 'met' || state === 'achieved') {
                if (typeof debugLog === 'function') {
                  debugLog(`[Optimisation Badge] Overriding '${state}' to 'on_track': delta=${delta} does NOT meet target=${target} (direction=${direction})`, 'warn');
                }
                state = 'on_track';
              }
            }
          } else if (progress && progress.baseline_value != null && progress.latest_value != null) {
            // If baseline equals latest, delta is 0 - can't be met
            if (progress.baseline_value === progress.latest_value) {
              if (state === 'met' || state === 'achieved') {
                if (typeof debugLog === 'function') {
                  debugLog(`[Optimisation Badge] Overriding '${state}' to 'on_track': baseline equals latest (delta=0)`, 'warn');
                }
                state = 'on_track';
              }
            }
          }
        }
        
        const badgeConfig = {
          'achieved': { text: 'Achieved', bg: '#10b981', color: '#ffffff' },
          'met': { text: 'Met', bg: '#10b981', color: '#ffffff' },
          'on_track': { text: 'On track', bg: '#3b82f6', color: '#ffffff' },
          'at_risk': { text: 'At risk', bg: '#f59e0b', color: '#ffffff' },
          'overdue': { text: 'Overdue', bg: '#ef4444', color: '#ffffff' },
          'not_set': { text: 'Not set', bg: '#9ca3af', color: '#ffffff' },
          'no_measurement': { text: 'No measurement', bg: '#9ca3af', color: '#ffffff' }
        };
        const config = badgeConfig[state] || badgeConfig['not_set'];
        
        if (typeof debugLog === 'function') {
          debugLog(`[Optimisation Badge] Setting badge: state="${state}", text="${config.text}"`, 'info');
        }
        
        objectiveBadgeEl.textContent = config.text;
        objectiveBadgeEl.style.background = config.bg;
        objectiveBadgeEl.style.color = config.color;
        objectiveBadgeEl.style.display = 'inline-block';
      }

      const objectiveContentEl = document.getElementById('optimisation-drawer-objective-content');
      if (objectiveContentEl) {
        // Phase 5: Use objective from cycle (jsonb) or fallback to legacy task fields
        const objective = task.objective || task.cycle?.objective || null;
        const objectiveProgress = task.objective_progress || task.cycle?.objective_progress || null;
        const objectiveStatus = task.objective_status || task.cycle?.objective_status || task.goal_state || 'not_set';
        const objectiveDueAt = task.objective_due_at || task.cycle?.due_at || null;

        // Legacy fallback fields - read from cycle fields (via view) or task fields
        const objectiveTitle = objective?.title || task.objective_title || null;
        const objectiveKpi = objective?.kpi || task.primary_kpi || task.objective_kpi || task.objective_metric || null;
        const objectiveMetric = objective?.kpi || task.primary_kpi || task.objective_metric || task.objective_kpi || null;
        // target_direction comes from cycle, objective_direction is legacy task field
        const objectiveDirection = objective?.target_type === 'delta' ? 'increase' : (task.target_direction || task.objective_direction || null);
        const objectiveTargetValue = objective?.target != null ? objective.target : (task.target_value != null ? task.target_value : (task.objective_target_delta != null ? task.objective_target_delta : (task.objective_target_value != null ? task.objective_target_value : null)));
        const objectiveTimeframe = objective?.due_at ? null : (task.timeframe_days != null ? task.timeframe_days : (task.objective_timeframe_days != null ? task.objective_timeframe_days : null));
        const objectivePlan = objective?.plan || task.plan || task.objective_plan || null;
        const cycleStartedAt = task.cycle_started_at || task.cycle_start_date || null;

        if (objective || objectiveTitle || objectiveKpi || objectiveMetric || objectiveDirection) {
          // Use two-column layout for objective details
          let leftColumn = '';
          let rightColumn = '';
          
          if (objectiveTitle) {
            leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Title:</strong> ${escapeHtml(objectiveTitle)}</div>`;
          }
            if (objectiveKpi) {
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>KPI:</strong> ${escapeHtml(objectiveKpi)}</div>`;
            }
            // Show target if we have a target value (direction is optional)
            if (objectiveTargetValue != null) {
              const directionLabels = {
                'increase': 'Increase by',
                'decrease': 'Decrease by',
                'at_least': 'At least',
                'at_most': 'At most'
              };
              let targetText = '';
              // For CTR, convert from ratio (0-1) to percentage for display
              if (objectiveMetric === 'ctr_28d' || (objectiveKpi && objectiveKpi.includes('ctr'))) {
                // If target is stored as ratio (0-1), multiply by 100 for display
                // Check if value is likely a ratio (< 1) vs percentage (>= 1)
                let displayTargetValue = objectiveTargetValue;
                if (objectiveTargetValue != null && objectiveTargetValue < 1 && objectiveTargetValue > 0) {
                  displayTargetValue = objectiveTargetValue * 100;
                }
                if (objectiveDirection) {
                  targetText = `${directionLabels[objectiveDirection] || objectiveDirection} ${displayTargetValue.toFixed(1)}%`;
                } else {
                  targetText = `${displayTargetValue.toFixed(1)}%`;
                }
              } else {
              if (objectiveDirection) {
                targetText = `${directionLabels[objectiveDirection] || objectiveDirection} ${objectiveTargetValue}`;
              } else {
                // If no direction specified, just show the target value
                targetText = `${objectiveTargetValue}`;
              }
              }
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Target:</strong> ${escapeHtml(targetText)}</div>`;
            } else if (objectiveDirection) {
              // Show direction even if no target value
              const directionLabels = {
                'increase': 'Increase',
                'decrease': 'Decrease',
                'at_least': 'At least',
                'at_most': 'At most'
              };
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Direction:</strong> ${escapeHtml(directionLabels[objectiveDirection] || objectiveDirection)}</div>`;
            }
          
          if (objectiveTimeframe || task.objective_due_at) {
            let timeframeText = '';
            const dueAt = task.objective_due_at || (progress && progress.due_at) || null;
            if (dueAt) {
              const dueDate = new Date(dueAt).toLocaleDateString('en-GB');
              timeframeText = `Due: ${dueDate}`;
              if (progress && progress.days_remaining != null) {
                const daysRemaining = Math.round(progress.days_remaining);
                timeframeText += ` (${daysRemaining} days remaining)`;
              }
            } else if (objectiveTimeframe) {
              timeframeText = `${objectiveTimeframe} days`;
              if (cycleStartedAt) {
                const startDate = new Date(cycleStartedAt);
                const dueDate = new Date(startDate.getTime() + objectiveTimeframe * 24 * 60 * 60 * 1000);
                timeframeText += ` (Due: ${dueDate.toLocaleDateString('en-GB')})`;
              }
            }
            if (timeframeText) {
              rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>Timeframe:</strong> ${timeframeText}</div>`;
            }
          }
          
          // Show progress: baseline  latest () vs target (using single source of truth helper)
          if (objectiveProgress && objectiveProgress.baseline_value != null && objectiveProgress.latest_value != null) {
            const baselineVal = objectiveProgress.baseline_value;
            const latestVal = objectiveProgress.latest_value;
            const target = objectiveProgress.target != null ? objectiveProgress.target : objectiveTargetValue;
            const targetType = (objective && objective.target_type) || 'delta';
            const kpiKey = objectiveKpi || objectiveMetric;
            
            if (kpiKey) {
              // Use single source of truth helper for correct delta math
              const progressLine = computeObjectiveProgressLine({
                kpiKey: kpiKey,
                baselineValue: baselineVal,
                latestValue: latestVal,
                targetValue: target,
                direction: targetType
              });
              
              rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>${progressLine.text}</strong></div>`;
              
              // Show remaining to target if applicable
              if (target != null && targetType === 'delta' && progressLine.delta != null) {
                const remaining = Math.max(0, target - progressLine.delta);
                if (remaining > 0) {
                  const displayMeta = KPI_DISPLAY_METADATA[kpiKey];
                  const remainingLabel = displayMeta ? displayMeta.formatDelta(remaining) : String(remaining);
                  rightColumn += `<div style="font-size: 0.85rem; color: #666; margin-top: 0.25rem;">Remaining: ${remainingLabel}</div>`;
                }
              }
            }
          } else if (progress && progress.baseline_value != null && progress.latest_value != null && objectiveMetric) {
            // Legacy fallback - use helper function for consistency
            const baselineVal = progress.baseline_value;
            const latestVal = progress.latest_value;
            const targetDelta = task.objective_target_delta != null ? task.objective_target_delta : (task.objective_target_value != null ? task.objective_target_value : null);
            const targetType = task.objective_target_type || 'delta';
            
            if (objectiveMetric) {
              const progressLine = computeObjectiveProgressLine({
                kpiKey: objectiveMetric,
                baselineValue: baselineVal,
                latestValue: latestVal,
                targetValue: targetDelta,
                direction: targetType
              });
              
              rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>${progressLine.text}</strong></div>`;
            }
          }
          
          // Build two-column layout
          let objectiveHtml = `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
            <div>${leftColumn || '<div style="color: #999; font-style: italic;"></div>'}</div>
            <div>${rightColumn || '<div style="color: #999; font-style: italic;"></div>'}</div>
          </div>`;
          
          if (objectivePlan) {
            objectiveHtml += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #e2e8f0;"><strong>Plan:</strong> ${escapeHtml(objectivePlan)}</div>`;
          }
          objectiveContentEl.innerHTML = objectiveHtml || '<div style="color: #666; font-style: italic;">No objective set</div>';
        } else {
          objectiveContentEl.innerHTML = '<div style="color: #666; font-style: italic;">No objective set</div>';
        }
      }
      
      document.getElementById('optimisation-change-status').value = task.status || '';

      // Phase 6: Load data for selected cycle (defaults to active cycle)
      const selectedCycleId = window.optimisationModuleState?.selectedCycleId || task.active_cycle_id;
      const selectedCycle = (task.cycles && task.cycles.find(c => c.id === selectedCycleId)) || null;
      const selectedCycleNo = selectedCycle?.cycle_no || task.cycle_no || task.cycle_active || 1;
      
      await loadCycleData(taskId, selectedCycleId, task.cycles, selectedCycle, selectedCycleNo, task);

      // Reset timeline to collapsed state
      const timelineContainer = document.getElementById('optimisation-drawer-events-container');
      const timelineToggle = document.getElementById('optimisation-timeline-toggle');
      if (timelineContainer && timelineToggle) {
        timelineContainer.style.display = 'none';
        timelineToggle.textContent = '';
      }

      // Reset state
      optimisationDrawerState.isMinimized = false;
      optimisationDrawerState.isMaximized = false;
      
      // Show backdrop and drawer (centered)
      backdrop.style.display = 'block';
      drawer.style.display = 'flex';
      drawer.style.top = '50%';
      drawer.style.left = '50%';
      drawer.style.transform = 'translate(-50%, -50%)';
      drawer.style.width = optimisationDrawerState.originalWidth;
      drawer.style.height = optimisationDrawerState.originalHeight;
      
      // Disable write buttons in share mode
      disableWriteButtonsInShareMode();
      drawer.style.maxHeight = '90vh';
      
      // Ensure content is visible
      const content = document.getElementById('optimisation-drawer-content');
      if (content) {
        content.style.display = 'block';
      }
      
      // Update button states
      document.getElementById('optimisation-drawer-minimize').textContent = '';
      document.getElementById('optimisation-drawer-maximize').textContent = '';
      
      // Phase 7: Show/hide Complete/Archive buttons based on active cycle
      const completeCycleBtn = document.getElementById('optimisation-complete-cycle-btn');
      const archiveCycleBtn = document.getElementById('optimisation-archive-cycle-btn');
      const hasActiveCycle = task.active_cycle_id != null;
      
      if (completeCycleBtn) {
        completeCycleBtn.style.display = hasActiveCycle ? 'block' : 'none';
        completeCycleBtn.disabled = !hasActiveCycle || window.isShareMode;
      }
      if (archiveCycleBtn) {
        archiveCycleBtn.style.display = hasActiveCycle ? 'block' : 'none';
        archiveCycleBtn.disabled = !hasActiveCycle || window.isShareMode;
      }
    };

    // Close task drawer
    window.closeOptimisationTaskDrawer = function closeOptimisationTaskDrawer() {
      const drawer = document.getElementById('optimisation-task-drawer');
      const backdrop = document.getElementById('optimisation-task-drawer-backdrop');
      if (!drawer || !backdrop) return;
      
      backdrop.style.display = 'none';
      drawer.style.display = 'none';
      window.optimisationModuleState.currentTaskId = null;
      optimisationDrawerState.isMinimized = false;
      optimisationDrawerState.isMaximized = false;
    };
    
    // Minimize drawer
    function minimizeOptimisationDrawer() {
      const drawer = document.getElementById('optimisation-task-drawer');
      if (!drawer) return;
      
      if (optimisationDrawerState.isMinimized) {
        // Restore
        drawer.style.height = optimisationDrawerState.originalHeight;
        drawer.style.maxHeight = '90vh';
        document.getElementById('optimisation-drawer-content').style.display = 'block';
        optimisationDrawerState.isMinimized = false;
        document.getElementById('optimisation-drawer-minimize').textContent = '';
      } else {
        // Minimize
        optimisationDrawerState.originalHeight = drawer.style.height || 'auto';
        drawer.style.height = '60px';
        drawer.style.maxHeight = '60px';
        document.getElementById('optimisation-drawer-content').style.display = 'none';
        optimisationDrawerState.isMinimized = true;
        document.getElementById('optimisation-drawer-minimize').textContent = '+';
      }
    }
    
    // Maximize drawer
    function maximizeOptimisationDrawer() {
      const drawer = document.getElementById('optimisation-task-drawer');
      if (!drawer) return;
      
      if (optimisationDrawerState.isMaximized) {
        // Restore
        drawer.style.top = optimisationDrawerState.originalTop;
        drawer.style.left = optimisationDrawerState.originalLeft;
        drawer.style.transform = 'translate(-50%, -50%)';
        drawer.style.width = optimisationDrawerState.originalWidth;
        drawer.style.height = optimisationDrawerState.originalHeight;
        drawer.style.maxHeight = '90vh';
        optimisationDrawerState.isMaximized = false;
        document.getElementById('optimisation-drawer-maximize').textContent = '';
      } else {
        // Maximize
        optimisationDrawerState.originalTop = drawer.style.top;
        optimisationDrawerState.originalLeft = drawer.style.left;
        optimisationDrawerState.originalWidth = drawer.style.width;
        optimisationDrawerState.originalHeight = drawer.style.height || 'auto';
        
        drawer.style.top = '0';
        drawer.style.left = '0';
        drawer.style.transform = 'none';
        drawer.style.width = '100vw';
        drawer.style.height = '100vh';
        drawer.style.maxHeight = '100vh';
        optimisationDrawerState.isMaximized = true;
        document.getElementById('optimisation-drawer-maximize').textContent = '';
      }
    }
    
    // Make drawer draggable
    function initOptimisationDrawerDragging() {
      const drawer = document.getElementById('optimisation-task-drawer');
      const headerBar = document.getElementById('optimisation-drawer-header-bar');
      if (!drawer || !headerBar) return;
      
      headerBar.addEventListener('mousedown', (e) => {
        if (optimisationDrawerState.isMaximized) return; // Don't drag when maximized
        
        optimisationDrawerDragState.isDragging = true;
        const rect = drawer.getBoundingClientRect();
        optimisationDrawerDragState.startX = e.clientX;
        optimisationDrawerDragState.startY = e.clientY;
        optimisationDrawerDragState.startLeft = rect.left;
        optimisationDrawerDragState.startTop = rect.top;
        
        drawer.style.transition = 'none';
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!optimisationDrawerDragState.isDragging) return;
        
        const deltaX = e.clientX - optimisationDrawerDragState.startX;
        const deltaY = e.clientY - optimisationDrawerDragState.startY;
        
        drawer.style.left = (optimisationDrawerDragState.startLeft + deltaX) + 'px';
        drawer.style.top = (optimisationDrawerDragState.startTop + deltaY) + 'px';
        drawer.style.transform = 'none';
      });
      
      document.addEventListener('mouseup', () => {
        if (optimisationDrawerDragState.isDragging) {
          optimisationDrawerDragState.isDragging = false;
          drawer.style.transition = '';
        }
      });
    }

    // Phase 6: Load cycle-specific data (objective, measurements, events)
    async function loadCycleData(taskId, cycleId, allCycles, selectedCycle, cycleNo, task) {
      // Update objective display for selected cycle
      const objectiveCycleEl = document.getElementById('optimisation-drawer-objective-cycle');
      if (objectiveCycleEl) {
        objectiveCycleEl.textContent = `(Cycle ${cycleNo})`;
      }

      // Get cycle data (use selected cycle if provided, otherwise fetch from task)
      let cycleData = selectedCycle;
      if (!cycleData && cycleId && allCycles) {
        cycleData = allCycles.find(c => c.id === cycleId);
      }

      // Update objective display with selected cycle's objective
      if (cycleData) {
        // Merge cycle data into task for rendering
        const cycleTask = {
          ...task,
          objective: cycleData.objective || null,
          objective_status: cycleData.objective_status || 'not_set',
          objective_progress: cycleData.objective_progress || null,
          objective_due_at: cycleData.due_at || null,
          objective_title: cycleData.objective_title || null,
          primary_kpi: cycleData.primary_kpi || null,
          target_value: cycleData.target_value != null ? parseFloat(cycleData.target_value) : null,
          target_direction: cycleData.target_direction || null,
          timeframe_days: cycleData.timeframe_days != null ? parseInt(cycleData.timeframe_days) : null,
          plan: cycleData.plan || null,
          cycle_start_date: cycleData.start_date || null
        };
        
        // Re-render objective badge and content for selected cycle
        const objectiveBadgeEl = document.getElementById('optimisation-drawer-objective-badge');
        if (objectiveBadgeEl) {
          const status = cycleTask.objective_status || 'not_set';
          const badgeConfig = {
            'met': { text: 'Met', bg: '#10b981', color: '#ffffff' },
            'on_track': { text: 'On track', bg: '#3b82f6', color: '#ffffff' },
            'overdue': { text: 'Overdue', bg: '#ef4444', color: '#ffffff' },
            'not_set': { text: 'Not set', bg: '#9ca3af', color: '#ffffff' }
          };
          const config = badgeConfig[status] || badgeConfig['not_set'];
          objectiveBadgeEl.textContent = config.text;
          objectiveBadgeEl.style.background = config.bg;
          objectiveBadgeEl.style.color = config.color;
          objectiveBadgeEl.style.display = 'inline-block';
        }
        
        // Re-render objective content (reuse existing logic from earlier in the file)
        const objectiveContentEl = document.getElementById('optimisation-drawer-objective-content');
        if (objectiveContentEl) {
          const objective = cycleTask.objective || null;
          const objectiveProgress = cycleTask.objective_progress || null;
          const objectiveTitle = objective?.title || cycleTask.objective_title || null;
          const objectiveKpi = objective?.kpi || cycleTask.primary_kpi || null;
          const objectiveMetric = objective?.kpi || cycleTask.primary_kpi || null;
          // Handle target_type: 'delta' means increase/decrease, 'absolute' means at_least/at_most
          let objectiveDirection = null;
          if (objective?.target_type === 'delta') {
            // For delta, check if target is positive (increase) or negative (decrease)
            const targetVal = objective?.target != null ? objective.target : (cycleTask.target_value != null ? cycleTask.target_value : null);
            objectiveDirection = targetVal != null && targetVal >= 0 ? 'increase' : 'decrease';
          } else if (objective?.target_type === 'absolute') {
            // For absolute, we need to determine from KPI direction (higher_better vs lower_better)
            // For now, default to 'at_least' for most KPIs, 'at_most' for rank
            objectiveDirection = (objectiveKpi && objectiveKpi.includes('rank')) ? 'at_most' : 'at_least';
          } else {
            // Fallback to legacy target_direction
            objectiveDirection = cycleTask.target_direction || null;
          }
          const objectiveTargetValue = objective?.target != null ? objective.target : (cycleTask.target_value != null ? cycleTask.target_value : null);
          const objectiveTimeframe = objective?.due_at ? null : (cycleTask.timeframe_days != null ? cycleTask.timeframe_days : null);
          const objectivePlan = objective?.plan || cycleTask.plan || null;
          const cycleStartedAt = cycleTask.cycle_start_date || null;

          // Debug logging
          console.log('[loadCycleData] Cycle objective data:', {
            objective,
            objectiveTitle,
            objectiveKpi,
            objectiveMetric,
            objectiveDirection,
            objectiveTargetValue,
            cycleTask
          });

          if (objective || objectiveTitle || objectiveKpi || objectiveMetric || objectiveDirection || objectiveTargetValue != null) {
            let leftColumn = '';
            let rightColumn = '';
            
            if (objectiveTitle) {
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Title:</strong> ${escapeHtml(objectiveTitle)}</div>`;
            }
            if (objectiveKpi) {
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>KPI:</strong> ${escapeHtml(objectiveKpi)}</div>`;
            }
            // Show target if we have a target value (direction is optional)
            if (objectiveTargetValue != null) {
              const directionLabels = {
                'increase': 'Increase by',
                'decrease': 'Decrease by',
                'at_least': 'At least',
                'at_most': 'At most'
              };
              let targetText = '';
              // For CTR, convert from ratio (0-1) to percentage for display
              if (objectiveMetric === 'ctr_28d' || (objectiveKpi && objectiveKpi.includes('ctr'))) {
                // If target is stored as ratio (0-1), multiply by 100 for display
                // Check if value is likely a ratio (< 1) vs percentage (>= 1)
                let displayTargetValue = objectiveTargetValue;
                if (objectiveTargetValue != null && objectiveTargetValue < 1 && objectiveTargetValue > 0) {
                  displayTargetValue = objectiveTargetValue * 100;
                }
                if (objectiveDirection) {
                  targetText = `${directionLabels[objectiveDirection] || objectiveDirection} ${displayTargetValue.toFixed(1)}%`;
                } else {
                  targetText = `${displayTargetValue.toFixed(1)}%`;
                }
              } else {
              if (objectiveDirection) {
                targetText = `${directionLabels[objectiveDirection] || objectiveDirection} ${objectiveTargetValue}`;
              } else {
                // If no direction specified, just show the target value
                targetText = `${objectiveTargetValue}`;
              }
              }
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Target:</strong> ${escapeHtml(targetText)}</div>`;
            } else if (objectiveDirection) {
              // Show direction even if no target value
              const directionLabels = {
                'increase': 'Increase',
                'decrease': 'Decrease',
                'at_least': 'At least',
                'at_most': 'At most'
              };
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Direction:</strong> ${escapeHtml(directionLabels[objectiveDirection] || objectiveDirection)}</div>`;
            }
            
            if (objectiveTimeframe || cycleTask.objective_due_at) {
              let timeframeText = '';
              const dueAt = cycleTask.objective_due_at || null;
              if (dueAt) {
                const dueDate = new Date(dueAt).toLocaleDateString('en-GB');
                timeframeText = `Due: ${dueDate}`;
              } else if (objectiveTimeframe && cycleStartedAt) {
                timeframeText = `${objectiveTimeframe} days`;
                const startDate = new Date(cycleStartedAt);
                const dueDate = new Date(startDate.getTime() + objectiveTimeframe * 24 * 60 * 60 * 1000);
                timeframeText += ` (Due: ${dueDate.toLocaleDateString('en-GB')})`;
              }
              if (timeframeText) {
                rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>Timeframe:</strong> ${timeframeText}</div>`;
              }
            }
            
            if (objectiveProgress && objectiveProgress.baseline_value != null && objectiveProgress.latest_value != null) {
              const baselineVal = objectiveProgress.baseline_value;
              const latestVal = objectiveProgress.latest_value;
              const target = objectiveProgress.target != null ? objectiveProgress.target : objectiveTargetValue;
              const targetType = (objective && objective.target_type) || 'delta';
              const kpiKey = objectiveKpi || objectiveMetric;
              
              if (kpiKey) {
                // Use single source of truth helper for correct delta math
                const progressLine = computeObjectiveProgressLine({
                  kpiKey: kpiKey,
                  baselineValue: baselineVal,
                  latestValue: latestVal,
                  targetValue: target,
                  direction: targetType
                });
                
                rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>Progress:</strong> ${progressLine.baselineDisp}  ${progressLine.latestDisp} (<span style="color: ${progressLine.deltaColor} !important; font-weight: 600;">${progressLine.deltaDisp}</span>) vs target ${progressLine.targetDisp}</div>`;
              }
            }
            
            let objectiveHtml = `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
              <div>${leftColumn || '<div style="color: #999; font-style: italic;"></div>'}</div>
              <div>${rightColumn || '<div style="color: #999; font-style: italic;"></div>'}</div>
            </div>`;
            
            if (objectivePlan) {
              objectiveHtml += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #e2e8f0;"><strong>Plan:</strong> ${escapeHtml(objectivePlan)}</div>`;
            }
            objectiveContentEl.innerHTML = objectiveHtml || '<div style="color: #666; font-style: italic;">No objective set</div>';
          } else {
            objectiveContentEl.innerHTML = '<div style="color: #666; font-style: italic;">No objective set</div>';
          }
        }
      }

      // Fetch baseline and latest metrics for selected cycle
      await renderOptimisationMetricsSnapshotForCycle(taskId, cycleId, cycleNo);

      // Load measurement history (for selected cycle)
      await loadOptimisationMeasurementHistory(taskId, cycleId, cycleNo);

      // Load events (filtered to selected cycle)
      await loadOptimisationTaskEventsForCycle(taskId, cycleId, cycleNo);
    }

    // Phase 6: Render metrics snapshot for a specific cycle
    async function renderOptimisationMetricsSnapshotForCycle(taskId, cycleId, cycleNo) {
      // Fetch events for this cycle to get baseline and latest
      const headers = window.getOptimisationHeaders();
      const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/events?cycle_id=${cycleId || ''}&cycle_number=${cycleNo || ''}&event_type=measurement`), {
        headers: headers
      });

      let baselineMetrics = null;
      let latestMetrics = null;

      if (response.ok) {
        const data = await response.json();
        const measurements = data.events || [];
        
        if (measurements.length > 0) {
          // First, try to find baseline measurement explicitly marked with is_baseline: true
          const baselineEvent = measurements.find(m => m.is_baseline === true);
          
          if (baselineEvent && baselineEvent.metrics) {
            baselineMetrics = { ...baselineEvent.metrics };
            if (baselineEvent.created_at) {
              baselineMetrics.captured_at = baselineEvent.created_at;
            }
            console.log('[Performance Snapshot] Found baseline measurement with is_baseline=true:', baselineMetrics);
          } else {
            // Fallback: Use first measurement chronologically if no explicit baseline found
          const sorted = [...measurements].sort((a, b) => {
            const dateA = new Date(a.created_at || a.event_at || 0);
            const dateB = new Date(b.created_at || b.event_at || 0);
            return dateA - dateB;
          });
          
            if (sorted[0] && sorted[0].metrics) {
              baselineMetrics = { ...sorted[0].metrics };
              if (sorted[0].created_at) {
            baselineMetrics.captured_at = sorted[0].created_at;
          }
              console.log('[Performance Snapshot] Using first measurement as baseline (no is_baseline flag found):', baselineMetrics);
            }
          }
          
          // Latest is always the most recent measurement
          const sorted = [...measurements].sort((a, b) => {
            const dateA = new Date(a.created_at || a.event_at || 0);
            const dateB = new Date(b.created_at || b.event_at || 0);
            return dateA - dateB;
          });
          
          if (sorted[sorted.length - 1] && sorted[sorted.length - 1].metrics) {
            latestMetrics = { ...sorted[sorted.length - 1].metrics };
            if (sorted[sorted.length - 1].created_at) {
            latestMetrics.captured_at = sorted[sorted.length - 1].created_at;
          }
          }
          
          // Debug logging
          console.log('[Performance Snapshot] Measurements found:', measurements.length);
          console.log('[Performance Snapshot] Baseline metrics:', baselineMetrics);
          console.log('[Performance Snapshot] Latest metrics:', latestMetrics);
        } else {
          console.warn('[Performance Snapshot] No measurements found for cycle', cycleId || cycleNo);
        }
      }

      // Render with cycle-specific metrics
      const cycleTask = {
        baseline_metrics: baselineMetrics,
        latest_metrics: latestMetrics
      };
      renderOptimisationMetricsSnapshot(cycleTask);
    }

    // Phase 6: Load events filtered to selected cycle
    async function loadOptimisationTaskEventsForCycle(taskId, cycleId, cycleNo) {
      const eventsContainer = document.getElementById('optimisation-drawer-events');
      if (!eventsContainer) return;

      try {
        const headers = window.getOptimisationHeaders();
        let url = apiUrl(`/api/optimisation/task/${taskId}/events`);
        if (cycleId) {
          url += `?cycle_id=${cycleId}`;
        } else if (cycleNo) {
          url += `?cycle_number=${cycleNo}`;
        }
        
        const response = await fetch(url, {
          method: 'GET',
          headers: headers
        });

        if (!response.ok) {
          throw new Error(`Failed to load events: ${response.status}`);
        }

        const data = await response.json();
        let events = data.events || [];

        // Filter to selected cycle if not already filtered by API
        if (cycleId || cycleNo) {
          events = events.filter(e => {
            if (cycleId) return e.cycle_id === cycleId;
            if (cycleNo) return e.cycle_number === cycleNo;
            return true;
          });
        }

        if (events.length === 0) {
          eventsContainer.innerHTML = `<div style="color: #666; font-style: italic;">No events for Cycle ${cycleNo || 'this cycle'}</div>`;
          return;
        }

        // Group events by cycle for display
        const eventsByCycle = {};
        events.forEach(event => {
          const cycleKey = event.cycle_number || 'unknown';
          if (!eventsByCycle[cycleKey]) {
            eventsByCycle[cycleKey] = [];
          }
          eventsByCycle[cycleKey].push(event);
        });

        eventsContainer.innerHTML = Object.keys(eventsByCycle).sort((a, b) => {
          if (a === 'unknown') return 1;
          if (b === 'unknown') return -1;
          return parseInt(b) - parseInt(a);
        }).map(cycleKey => {
          const cycleEvents = eventsByCycle[cycleKey];
          const cycleLabel = cycleKey === 'unknown' ? 'Other' : `Cycle ${cycleKey}`;
          return `
            <div style="margin-bottom: 1.5rem;">
              <div style="font-weight: 700; color: #1e293b; margin-bottom: 0.5rem; padding-bottom: 0.25rem; border-bottom: 2px solid #e2e8f0;">${cycleLabel}</div>
              ${cycleEvents.map(event => {
                const date = new Date(event.event_at || event.created_at).toLocaleString('en-GB', { timeZone: 'UTC' });
                return `
                  <div style="margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid #eee;">
                    <div style="font-weight: 600; color: #2563eb;">${escapeHtml(event.event_type || 'note')}</div>
                    <div style="color: #666; font-size: 0.875rem; margin-top: 0.25rem;">${date}</div>
                    ${event.note ? `<div style="margin-top: 0.5rem;">${escapeHtml(event.note)}</div>` : ''}
                  </div>
                `;
              }).join('')}
            </div>
          `;
        }).join('');
      } catch (error) {
        console.error('[Optimisation Module] Error loading events:', error);
        eventsContainer.innerHTML = '<div style="color: #ef4444;">Error loading events</div>';
      }
    }

    // Phase 8: KPI-specific formatting metadata (Phase 9: add get methods)
    const KPI_DISPLAY_METADATA = {
      clicks_28d: {
        label: 'Clicks (28d)',
        get: (m) => (m && m.clicks_28d) != null ? m.clicks_28d : ((m && m.gsc_clicks_28d) != null ? m.gsc_clicks_28d : null),
        formatValue: (val) => val != null ? Math.round(val).toLocaleString('en-GB') : '',
        formatDelta: (delta) => {
          if (delta == null) return '';
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Math.round(delta).toLocaleString('en-GB')}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toLocaleString('en-GB');
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target).toLocaleString('en-GB')}`;
        }
      },
      impressions_28d: {
        label: 'Impressions (28d)',
        get: (m) => (m && m.impressions_28d) != null ? m.impressions_28d : ((m && m.gsc_impressions_28d) != null ? m.gsc_impressions_28d : null),
        formatValue: (val) => {
          if (val == null) return '';
          if (val >= 1000) {
            return (val / 1000).toFixed(1) + 'k';
          }
          return Math.round(val).toLocaleString('en-GB');
        },
        formatDelta: (delta) => {
          if (delta == null) return '';
          const sign = delta >= 0 ? '+' : '';
          if (Math.abs(delta) >= 1000) {
            return `${sign}${(delta / 1000).toFixed(1)}k`;
          }
          return `${sign}${Math.round(delta).toLocaleString('en-GB')}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            if (target >= 1000) {
              return (target / 1000).toFixed(1) + 'k';
            }
            return Math.round(target).toLocaleString('en-GB');
          }
          const sign = target >= 0 ? '+' : '';
          if (Math.abs(target) >= 1000) {
            return `${sign}${(target / 1000).toFixed(1)}k`;
          }
          return `${sign}${Math.round(target).toLocaleString('en-GB')}`;
        }
      },
      ctr_28d: {
        formatValue: (val) => {
          if (val == null) return '';
          return (val * 100).toFixed(2) + '%';
        },
        formatDelta: (delta) => {
          if (delta == null) return '';
          // Delta is in decimal (0-1), convert to percentage points (pp)
          const deltaPp = delta * 100;
          const sign = deltaPp >= 0 ? '+' : '';
          return `${sign}${deltaPp.toFixed(2)}pp`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            // Absolute target is stored as decimal (0-1), display as %
            return (target * 100).toFixed(2) + '%';
          }
          // Delta target: for CTR, show as percentage points
          // The target is the absolute delta in decimal units
          const targetPp = target * 100;
          const sign = target >= 0 ? '+' : '';
          return `${sign}${targetPp.toFixed(2)}pp`;
        }
      },
      current_rank: {
        label: 'Current Rank',
        get: (m) => (m && m.current_rank) != null ? m.current_rank : ((m && m.rank) != null ? m.rank : null),
        formatValue: (val) => val != null ? Math.round(val).toString() : '',
        formatDelta: (delta) => {
          if (delta == null) return '';
          // For rank, positive delta means improvement (rank went down)
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Math.round(delta)}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toString();
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target)}`;
        }
      },
      opportunity_score: {
        label: 'Opportunity Score',
        get: (m) => (m && m.opportunity_score) != null ? m.opportunity_score : null,
        formatValue: (val) => val != null ? Math.round(val).toString() : '',
        formatDelta: (delta) => {
          if (delta == null) return '';
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Math.round(delta)}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toString();
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target)}`;
        }
      },
      ai_overview: {
        label: 'AI Overview',
        get: (m) => (m && m.ai_overview) != null ? m.ai_overview : false,
        formatValue: (val) => val === true ? 'On' : (val === false ? 'Off' : ''),
        formatDelta: (delta) => {
          if (delta == null) return '';
          if (delta > 0) return '+1';
          if (delta < 0) return '-1';
          return '0';
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          return target === true ? 'On' : 'Off';
        }
      },
      ai_citations: {
        label: 'AI Citations',
        get: (m) => (m && m.ai_citations) != null ? m.ai_citations : null,
        formatValue: (val) => val != null ? Math.round(val).toString() : '',
        formatDelta: (delta) => {
          if (delta == null) return '';
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Math.round(delta)}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toString();
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target)}`;
        }
      }
    };

    // Helper: Compute objective progress line with correct delta math (single source of truth)
    // Always calculates delta as latest - baseline (or baseline - latest for rank)
    function computeObjectiveProgressLine({ kpiKey, baselineValue, latestValue, targetValue, direction }) {
      // If baseline/latest missing, return placeholder
      if (baselineValue == null || latestValue == null) {
        return { text: 'Progress: ', delta: null, deltaColor: '#666' };
      }
      
      // Calculate raw delta (always from baseline to latest)
      let deltaRaw = latestValue - baselineValue;
      
      // For rank, lower is better, so invert: improvement = baseline - latest (positive when rank decreases)
      if (kpiKey === 'current_rank') {
        deltaRaw = baselineValue - latestValue;
      }
      
      // Format values based on KPI type
      let baselineDisp, latestDisp, deltaDisp;
      
      if (kpiKey === 'ctr_28d') {
        baselineDisp = (baselineValue * 100).toFixed(2) + '%';
        latestDisp = (latestValue * 100).toFixed(2) + '%';
        const deltaPp = (latestValue - baselineValue) * 100;
        deltaDisp = (deltaPp >= 0 ? '+' : '') + deltaPp.toFixed(2) + 'pp';
      } else if (kpiKey === 'current_rank') {
        baselineDisp = baselineValue.toFixed(1);
        latestDisp = latestValue.toFixed(1);
        // For rank, deltaRaw is already inverted (baseline - latest), so positive = improvement
        deltaDisp = (deltaRaw >= 0 ? '+' : '') + deltaRaw.toFixed(1);
      } else {
        // For other metrics, use number formatting
        const displayMeta = KPI_DISPLAY_METADATA[kpiKey];
        if (displayMeta) {
          baselineDisp = displayMeta.formatValue(baselineValue);
          latestDisp = displayMeta.formatValue(latestValue);
          deltaDisp = displayMeta.formatDelta(deltaRaw);
        } else {
          baselineDisp = baselineValue.toLocaleString('en-GB');
          latestDisp = latestValue.toLocaleString('en-GB');
          deltaDisp = (deltaRaw >= 0 ? '+' : '') + deltaRaw.toLocaleString('en-GB');
        }
      }
      
      // Determine color: green for positive, red for negative, amber for zero
      let deltaColor = '#f59e0b'; // Amber for no change
      if (deltaRaw > 0) deltaColor = '#10b981'; // Green for positive/improvement
      else if (deltaRaw < 0) deltaColor = '#ef4444'; // Red for negative/worsening
      
      // Format target display
      let targetDisp = '';
      if (targetValue != null) {
        const displayMeta = KPI_DISPLAY_METADATA[kpiKey];
        if (displayMeta && displayMeta.formatTarget) {
          targetDisp = displayMeta.formatTarget(targetValue, direction || 'delta', baselineValue);
        } else {
          // Fallback formatting
          if (direction === 'delta') {
            targetDisp = (targetValue >= 0 ? '+' : '') + targetValue.toLocaleString('en-GB');
          } else {
            targetDisp = targetValue.toLocaleString('en-GB');
          }
        }
      }
      
      // Build progress line text with colored delta
      const text = `Progress: ${baselineDisp}  ${latestDisp} (<span style="color: ${deltaColor} !important; font-weight: 600;">${deltaDisp}</span>) vs target ${targetDisp}`;
      
      return {
        text,
        delta: deltaRaw,
        deltaColor,
        baselineDisp,
        latestDisp,
        deltaDisp,
        targetDisp
      };
    }
    
    // Legacy formatProgressValue function (kept for backward compatibility)
    function formatProgressValue(value, kpi) {
      if (value == null || value === undefined) return '';
      
      const displayMeta = kpi ? KPI_DISPLAY_METADATA[kpi] : null;
      if (displayMeta) {
        return displayMeta.formatValue(value);
      }
      
      // Fallback for unknown KPIs
      if (typeof value === 'number') {
        if (Math.abs(value) < 1 && value !== 0) {
          return value.toFixed(2);
        }
        if (Number.isInteger(value) || Math.abs(value) >= 1) {
          return value.toLocaleString('en-GB', { maximumFractionDigits: 2 });
        }
        return value.toFixed(2);
      }
      
      return String(value);
    }
    
    // Phase 8: Compute goal progress with proper formatting
    function computeGoalProgress({ kpiKey, baseline, latest, targetValue, targetType }) {
      const displayMeta = KPI_DISPLAY_METADATA[kpiKey];
      if (!displayMeta) {
        return {
          baselineLabel: baseline != null ? String(baseline) : '',
          latestLabel: latest != null ? String(latest) : '',
          deltaLabel: '',
          targetLabel: targetValue != null ? String(targetValue) : '',
          progressLabel: ''
        };
      }

      // Calculate delta
      let delta = null;
      if (baseline != null && latest != null) {
        // For rank, improvement is positive when rank decreases
        if (kpiKey === 'current_rank') {
          delta = baseline - latest;
        } else {
          delta = latest - baseline;
        }
      }

      // Format labels
      const baselineLabel = displayMeta.formatValue(baseline);
      const latestLabel = displayMeta.formatValue(latest);
      const deltaLabel = displayMeta.formatDelta(delta);
      const targetLabel = displayMeta.formatTarget(targetValue, targetType, baseline);
      
      // Calculate remaining to target
      let remainingToTarget = null;
      if (targetType === 'delta' && delta != null && targetValue != null) {
        remainingToTarget = Math.max(0, targetValue - delta);
      } else if (targetType === 'absolute' && latest != null && targetValue != null) {
        if (kpiKey === 'current_rank') {
          remainingToTarget = Math.max(0, latest - targetValue);
        } else {
          remainingToTarget = Math.max(0, targetValue - latest);
        }
      }

      // Build progress label
      let progressLabel = '';
      if (baseline != null && latest != null && targetValue != null) {
        if (targetType === 'delta') {
          if (remainingToTarget != null && remainingToTarget > 0) {
            progressLabel = `${deltaLabel}/${targetLabel} (${displayMeta.formatDelta(remainingToTarget)} remaining)`;
          } else if (delta != null && delta >= targetValue) {
            progressLabel = `${deltaLabel}/${targetLabel} (Met)`;
          } else {
            progressLabel = `${deltaLabel}/${targetLabel}`;
          }
        } else {
          if (remainingToTarget != null && remainingToTarget > 0) {
            progressLabel = `${latestLabel}/${targetLabel} (${displayMeta.formatValue(remainingToTarget)} remaining)`;
          } else if (latest != null && ((kpiKey === 'current_rank' && latest <= targetValue) || (kpiKey !== 'current_rank' && latest >= targetValue))) {
            progressLabel = `${latestLabel}/${targetLabel} (Met)`;
          } else {
            progressLabel = `${latestLabel}/${targetLabel}`;
          }
        }
      }

      return {
        baselineLabel,
        latestLabel,
        deltaLabel,
        targetLabel,
        progressLabel,
        remainingToTarget
      };
    }

    // Phase 9: Helper functions for dashboard features
    
    // Render sparkline SVG
    function renderSparkline(points, width = 80, height = 24) {
      if (!points || points.length < 2) return '';
      
      const filtered = points.filter(p => p != null);
      if (filtered.length < 2) return '';
      
      const min = Math.min(...filtered);
      const max = Math.max(...filtered);
      const range = max - min || 1; // Avoid division by zero
      
      const padding = 2;
      const plotWidth = width - padding * 2;
      const plotHeight = height - padding * 2;
      
      const path = filtered.map((val, idx) => {
        const x = padding + (idx / (filtered.length - 1)) * plotWidth;
        const y = padding + plotHeight - ((val - min) / range) * plotHeight;
        return `${x},${y}`;
      }).join(' ');
      
      const color = filtered[filtered.length - 1] >= filtered[0] ? '#10b981' : '#ef4444';
      
      return `<svg width="${width}" height="${height}" style="display: block;">
        <polyline points="${path}" fill="none" stroke="${color}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>`;
    }
    
    // Update KPI tiles
    function updateKPITiles() {
      let tasks = window.optimisationModuleState.allTasks || [];
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      // Recalculate tiles from filtered tasks
      const tiles = {
        ctr: { on_track: 0, at_risk: 0, overdue: 0 },
        rank: { improved: 0, worse: 0, flat: 0 },
        ai_gap: 0,
        needs_measurement: 0,
        overdue_cycles: 0,
      };
      
      for (const task of tasks) {
        const objectiveRag = task.objectiveRag || task.objective_status || 'no_data';
        const objectiveKpiKey = task.objectiveKpiKey || (task.objective && task.objective.kpi);
        const delta = task.delta != null ? task.delta : 0;
        
        // CTR tiles
        if (objectiveKpiKey === 'ctr_28d' && objectiveRag !== 'no_data') {
          if (objectiveRag === 'on_track') tiles.ctr.on_track++;
          else if (objectiveRag === 'at_risk') tiles.ctr.at_risk++;
          else if (objectiveRag === 'overdue') tiles.ctr.overdue++;
        }
        
        // Rank tiles
        if (objectiveKpiKey === 'current_rank' && delta != null) {
          if (delta > 0) tiles.rank.improved++;
          else if (delta < 0) tiles.rank.worse++;
          else tiles.rank.flat++;
        }
        
        // AI Gap
        if (task.latestValue != null && objectiveKpiKey === 'ai_citations') {
          // Check if AI overview is on but citations = 0
          const latestMetrics = task.latest_metrics || {};
          if (latestMetrics.ai_overview === true && (latestMetrics.ai_citations === 0 || latestMetrics.ai_citations == null)) {
            tiles.ai_gap++;
          }
        }
        
        // Needs Measurement
        if (task.needsMeasurement) {
          tiles.needs_measurement++;
        }
        
        // Overdue Cycles
        if (objectiveRag === 'overdue') {
          tiles.overdue_cycles++;
        }
      }
      
      if (tiles.ctr) {
        const onTrackEl = document.getElementById('kpi-ctr-on-track');
        const atRiskEl = document.getElementById('kpi-ctr-at-risk');
        const overdueEl = document.getElementById('kpi-ctr-overdue');
        if (onTrackEl) onTrackEl.textContent = tiles.ctr.on_track || 0;
        if (atRiskEl) atRiskEl.textContent = tiles.ctr.at_risk || 0;
        if (overdueEl) overdueEl.textContent = tiles.ctr.overdue || 0;
      }
      
      if (tiles.rank) {
        const improvedEl = document.getElementById('kpi-rank-improved');
        const worseEl = document.getElementById('kpi-rank-worse');
        const flatEl = document.getElementById('kpi-rank-flat');
        if (improvedEl) improvedEl.textContent = tiles.rank.improved || 0;
        if (worseEl) worseEl.textContent = tiles.rank.worse || 0;
        if (flatEl) flatEl.textContent = tiles.rank.flat || 0;
      }
      
      const aiGapEl = document.getElementById('kpi-ai-gap');
      const needsMeasEl = document.getElementById('kpi-needs-measurement');
      const overdueCyclesEl = document.getElementById('kpi-overdue-cycles');
      if (aiGapEl) aiGapEl.textContent = tiles.ai_gap || 0;
      if (needsMeasEl) needsMeasEl.textContent = tiles.needs_measurement || 0;
      if (overdueCyclesEl) overdueCyclesEl.textContent = tiles.overdue_cycles || 0;
    }
    
    // Update impact tiles
    function updateImpactTiles() {
      let tasks = window.optimisationModuleState.allTasks || [];
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      // Get current scope (respects the scope filter)
      const scope = window.optimisationModuleState.scope || 'active_cycle';
      
      // Compute potential and actual clicks with deduplication
      const { potential, actual, includedTasksCount } = computePotentialAndActualClicks28d(tasks, scope);
      
      // Count traffic KPI tasks and click-related tasks for context strip
      const trafficKpis = new Set(['ctr_28d', 'impressions_28d', 'clicks_28d']);
      let trafficKpiCount = 0;
      let clickRelatedCount = 0;
      
      for (const task of tasks) {
        const objectiveKpiKey = task.objectiveKpiKey || (task.objective && task.objective.kpi) || 
                                (task.cycle && task.cycle.objective && task.cycle.objective.kpi);
        
        // Count traffic KPI tasks
        if (objectiveKpiKey && trafficKpis.has(objectiveKpiKey)) {
          trafficKpiCount++;
          
          // Check if click-related (can compute clicks delta)
          const activeCycle = scope === 'active_cycle' 
            ? ((task.cycles && task.cycles.find(c => c.is_active || c.id === task.active_cycle_id)) || null)
            : null;
          const measurements = task.measurements || [];
          const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);
          
          if (baselineLatest && baselineLatest.baseline && baselineLatest.latest) {
            const delta = computeActualClickDeltaForTask(task, baselineLatest.baseline, baselineLatest.latest);
            if (delta != null) {
              clickRelatedCount++;
            }
          } else if (task.baseline_metrics && task.latest_metrics) {
            const delta = computeActualClickDeltaForTask(task, task.baseline_metrics, task.latest_metrics);
            if (delta != null) {
              clickRelatedCount++;
            }
          } else if (task.baselineValue != null && task.latestValue != null && objectiveKpiKey === 'clicks_28d') {
            clickRelatedCount++;
          }
        }
      }
      
      // Also compute per-task values for chart aggregation (still needed for charts)
      let aiCitationGapCount = 0;
      for (const task of tasks) {
        // Store per-task value for chart aggregation
        const extraClicks = computeEstimatedExtraClicks28d(task);
        task.estimated_extra_clicks_28d = extraClicks;
        
        // AI Citation Gap
        const latestMetrics = task.latest_metrics || {};
        if (latestMetrics.ai_overview === true && (latestMetrics.ai_citations === 0 || latestMetrics.ai_citations == null)) {
          aiCitationGapCount++;
        }
      }
      
      // Update Potential Extra Clicks tile
      const potentialClicksEl = document.getElementById('impact-potential-clicks');
      const potentialClicksCard = document.getElementById('impact-potential-clicks-card');
      const potentialClicksClear = document.getElementById('impact-potential-clicks-clear');
      if (potentialClicksEl) {
        potentialClicksEl.textContent = potential >= 1000 
          ? (potential / 1000).toFixed(1) + 'k' 
          : Math.round(potential).toLocaleString('en-GB');
      }
      
      // Show/hide clear button for potential tile
      if (potentialClicksClear) {
        potentialClicksClear.style.display = window.optimisationModuleState.trafficKpiOnly ? 'block' : 'none';
      }
      
      // Set bronze/silver/gold background for potential tile
      if (potentialClicksCard) {
        potentialClicksCard.classList.remove('impact-bronze', 'impact-silver', 'impact-gold');
        if (potential < 50) {
          potentialClicksCard.classList.add('impact-bronze');
        } else if (potential >= 50 && potential < 200) {
          potentialClicksCard.classList.add('impact-silver');
        } else {
          potentialClicksCard.classList.add('impact-gold');
        }
      }
      
      // Update Actual Click Change tile
      const actualClicksEl = document.getElementById('impact-actual-clicks');
      const actualClicksClear = document.getElementById('impact-actual-clicks-clear');
      if (actualClicksEl) {
        // Format with sign (+ or -)
        const sign = actual >= 0 ? '+' : '';
        actualClicksEl.textContent = sign + (Math.abs(actual) >= 1000 
          ? (Math.abs(actual) / 1000).toFixed(1) + 'k' 
          : Math.round(Math.abs(actual)).toLocaleString('en-GB'));
        
        // Color code: green for positive, red for negative
        actualClicksEl.style.color = actual >= 0 ? '#10b981' : '#ef4444';
      }
      
      // Show/hide clear button for actual tile
      if (actualClicksClear) {
        actualClicksClear.style.display = window.optimisationModuleState.clickRelatedOnly ? 'block' : 'none';
      }
      
      // Update context strip
      const trafficKpiCountEl = document.getElementById('traffic-kpi-count');
      const clickRelatedCountEl = document.getElementById('click-related-count');
      if (trafficKpiCountEl) {
        trafficKpiCountEl.textContent = `Traffic KPI tasks included: ${trafficKpiCount}`;
      }
      if (clickRelatedCountEl) {
        clickRelatedCountEl.textContent = `Click-related tasks included: ${clickRelatedCount}`;
      }
      
      const aiGapEl = document.getElementById('impact-ai-gap');
      if (aiGapEl) aiGapEl.textContent = aiCitationGapCount || 0;
    }
    
    // Handle traffic light pill click
    window.handleTrafficLightClick = function(metricKey, bucket) {
      const currentFilter = window.optimisationModuleState.metricTrafficFilter;
      
      // Toggle: if clicking the same pill, clear filter
      if (currentFilter && currentFilter.metricKey === metricKey && currentFilter.bucket === bucket) {
        window.optimisationModuleState.metricTrafficFilter = null;
      } else {
        window.optimisationModuleState.metricTrafficFilter = { metricKey, bucket };
      }
      
      // Update visual state (highlighting)
      updateTrafficLightVisuals();
      
      // Apply filters (this will update filteredTasks)
      applyOptimisationFilters();
      
      // Update charts with new filtered data
      updateTimeseriesCharts();
      
      // Only sort if there's an active filter
      if (window.optimisationModuleState.metricTrafficFilter) {
        const filter = window.optimisationModuleState.metricTrafficFilter;
        let tasks = [...window.optimisationModuleState.filteredTasks];
        const scope = window.optimisationModuleState.scope || 'active_cycle';
        const metricKeys = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
        
        // Sort tasks by their classification for this metric
        tasks.sort((a, b) => {
          // Get classifications for both tasks
          const aActiveCycle = scope === 'active_cycle' 
            ? (a.cycles?.find(c => c.is_active || c.id === a.active_cycle_id) || null)
            : null;
          const bActiveCycle = scope === 'active_cycle' 
            ? (b.cycles?.find(c => c.is_active || c.id === b.active_cycle_id) || null)
            : null;
          
          const aMeasurements = a.measurements || [];
          const bMeasurements = b.measurements || [];
          
          const aBaselineLatest = getBaselineLatest(aMeasurements, scope, aActiveCycle);
          const bBaselineLatest = getBaselineLatest(bMeasurements, scope, bActiveCycle);
          
          let aClass, bClass;
          
          if (filter.metricKey === 'all_metrics') {
            // For all_metrics, find majority classification (at least 3 out of 6)
            const aClasses = [];
            const bClasses = [];
            
            if (aBaselineLatest) {
              for (const mk of metricKeys) {
                const cls = classifyMetric(mk, aBaselineLatest.baseline, aBaselineLatest.latest);
                if (cls) aClasses.push(cls);
              }
            }
            
            if (bBaselineLatest) {
              for (const mk of metricKeys) {
                const cls = classifyMetric(mk, bBaselineLatest.baseline, bBaselineLatest.latest);
                if (cls) bClasses.push(cls);
              }
            }
            
            // Find majority classification for task A
            if (aClasses.length >= 4) {
              const aCounts = { worse: 0, same: 0, better: 0 };
              aClasses.forEach(c => aCounts[c]++);
              const aMajority = Math.max(aCounts.worse, aCounts.same, aCounts.better);
              aClass = aCounts.worse === aMajority ? 'worse' :
                       aCounts.same === aMajority ? 'same' :
                       aCounts.better === aMajority ? 'better' : null;
              // Only use if majority is at least 4
              if (aMajority < 4) aClass = null;
            } else {
              aClass = null;
            }
            
            // Find majority classification for task B
            if (bClasses.length >= 4) {
              const bCounts = { worse: 0, same: 0, better: 0 };
              bClasses.forEach(c => bCounts[c]++);
              const bMajority = Math.max(bCounts.worse, bCounts.same, bCounts.better);
              bClass = bCounts.worse === bMajority ? 'worse' :
                       bCounts.same === bMajority ? 'same' :
                       bCounts.better === bMajority ? 'better' : null;
              // Only use if majority is at least 4
              if (bMajority < 4) bClass = null;
            } else {
              bClass = null;
            }
          } else {
            // Single metric
            aClass = aBaselineLatest ? classifyMetric(filter.metricKey, aBaselineLatest.baseline, aBaselineLatest.latest) : null;
            bClass = bBaselineLatest ? classifyMetric(filter.metricKey, bBaselineLatest.baseline, bBaselineLatest.latest) : null;
          }
          
          // Priority: better (2) > same (1) > worse (0) > null (-1)
          const getPriority = (cls) => {
            if (cls === 'better') return 2;
            if (cls === 'same') return 1;
            if (cls === 'worse') return 0;
            return -1;
          };
          
          const aPriority = getPriority(aClass);
          const bPriority = getPriority(bClass);
          
          // Sort descending (better first)
          return bPriority - aPriority;
        });
        
        window.optimisationModuleState.filteredTasks = tasks;
      }
      
      // Re-render table with new filter and sort
      renderOptimisationTasksTable();
    };
    
    // Update visual state of traffic light pills (selected/not selected)
    function updateTrafficLightVisuals() {
      const filter = window.optimisationModuleState.metricTrafficFilter;
      const pills = document.querySelectorAll('.traffic-light-pill');
      
      pills.forEach(pill => {
        const metricKey = pill.dataset.metric;
        const bucket = pill.dataset.bucket;
        const isSelected = filter && filter.metricKey === metricKey && filter.bucket === bucket;
        
        if (isSelected) {
          // Active state: bright orange border, strong glow, and brighter background
          pill.style.border = '3px solid var(--dark-brand)';
          pill.style.boxShadow = '0 0 16px rgba(245, 158, 11, 0.8), 0 0 8px rgba(245, 158, 11, 0.6)';
          pill.style.transform = 'scale(1.05)';
          pill.style.zIndex = '10';
          // Make background brighter when selected
          if (bucket === 'worse') {
            pill.style.background = 'rgba(239, 68, 68, 0.4) !important';
          } else if (bucket === 'same') {
            pill.style.background = 'rgba(245, 158, 11, 0.4) !important';
          } else {
            pill.style.background = 'rgba(16, 185, 129, 0.4) !important';
          }
        } else {
          // Inactive state: normal border, no glow, normal size
          pill.style.border = '2px solid var(--dark-border)';
          pill.style.boxShadow = 'none';
          pill.style.transform = 'scale(1)';
          pill.style.zIndex = '1';
          // Restore default background
          if (bucket === 'worse') {
            pill.style.background = 'rgba(239, 68, 68, 0.2)';
          } else if (bucket === 'same') {
            pill.style.background = 'rgba(245, 158, 11, 0.2)';
          } else {
            pill.style.background = 'rgba(16, 185, 129, 0.2)';
          }
        }
      });
    }
    
    // Helper to restore hover state (considering selection) - no longer needed with CSS hover
    window.updateTrafficLightHover = function(element) {
      // CSS handles hover now, but keep for compatibility
    };
    
    // Update traffic light counts and display
    function updateTrafficLights() {
      let tasks = window.optimisationModuleState.allTasks || [];
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      // Apply other existing filters (keyword, url, type, status) - same as table uses
      // Get filter values
      const keywordFilter = document.getElementById('optimisation-filter-keyword')?.value?.toLowerCase().trim() || '';
      const urlFilter = document.getElementById('optimisation-filter-url')?.value?.toLowerCase().trim() || '';
      const typeFilter = document.getElementById('optimisation-filter-type')?.value || '';
      const statusFilter = document.getElementById('optimisation-filter-status')?.value || '';
      
      // Apply filters
      if (keywordFilter) {
        tasks = tasks.filter(t => (t.keyword || '').toLowerCase().includes(keywordFilter));
      }
      if (urlFilter) {
        tasks = tasks.filter(t => (t.target_url || '').toLowerCase().includes(urlFilter));
      }
      if (typeFilter) {
        tasks = tasks.filter(t => t.task_type === typeFilter);
      }
      if (statusFilter) {
        tasks = tasks.filter(t => t.status === statusFilter);
      }
      
      // Get scope
      const scope = window.optimisationModuleState.scope || 'active_cycle';
      
      // Compute traffic light counts
      const counts = computeTrafficLightCounts(tasks, scope);
      
      // Update display
      const metricMap = {
        all_metrics: 'all-metrics',
        ctr_28d: 'ctr',
        impressions_28d: 'impressions',
        clicks_28d: 'clicks',
        current_rank: 'rank',
        ai_citations: 'ai-citations',
        ai_overview: 'ai-overview',
        opportunity_score: 'opportunity-score'
      };
      
      for (const [metricKey, displayKey] of Object.entries(metricMap)) {
        const worseEl = document.getElementById(`objective-${displayKey}-red`);
        const sameEl = document.getElementById(`objective-${displayKey}-amber`);
        const betterEl = document.getElementById(`objective-${displayKey}-green`);
        
        if (worseEl) worseEl.textContent = counts[metricKey].worse || 0;
        if (sameEl) sameEl.textContent = counts[metricKey].same || 0;
        if (betterEl) betterEl.textContent = counts[metricKey].better || 0;
      }
    }
    
    // Apply all filters to filteredTasks (including metric traffic filter)
    function applyOptimisationFilters() {
      let tasks = [...window.optimisationModuleState.allTasks];
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      // Apply keyword filter
      const keywordFilter = document.getElementById('optimisation-filter-keyword')?.value?.toLowerCase().trim() || '';
      if (keywordFilter) {
        tasks = tasks.filter(t => (t.keyword || '').toLowerCase().includes(keywordFilter));
      }
      
      // Apply URL filter
      const urlFilter = document.getElementById('optimisation-filter-url')?.value?.toLowerCase().trim() || '';
      if (urlFilter) {
        tasks = tasks.filter(t => (t.target_url || '').toLowerCase().includes(urlFilter));
      }
      
      // Apply type filter
      const typeFilter = document.getElementById('optimisation-filter-type')?.value || '';
      if (typeFilter) {
        tasks = tasks.filter(t => t.task_type === typeFilter);
      }
      
      // Apply status filter
      const statusFilter = document.getElementById('optimisation-filter-status')?.value || '';
      if (statusFilter) {
        tasks = tasks.filter(t => t.status === statusFilter);
      }
      
      // Apply trafficKpiOnly filter (CTR/Impressions/Clicks objectives only)
      if (window.optimisationModuleState.trafficKpiOnly) {
        const trafficKpis = new Set(['ctr_28d', 'impressions_28d', 'clicks_28d']);
        tasks = tasks.filter(task => {
          const objectiveKpiKey = task.objectiveKpiKey || (task.objective && task.objective.kpi) || 
                                  (task.cycle && task.cycle.objective && task.cycle.objective.kpi);
          return objectiveKpiKey && trafficKpis.has(objectiveKpiKey);
        });
      }
      
      // Apply clickRelatedOnly filter (tasks where clicks delta is computable)
      if (window.optimisationModuleState.clickRelatedOnly) {
        const scope = window.optimisationModuleState.scope || 'active_cycle';
        const trafficKpis = new Set(['ctr_28d', 'impressions_28d', 'clicks_28d']);
        tasks = tasks.filter(task => {
          // Must have traffic KPI objective
          const objectiveKpiKey = task.objectiveKpiKey || (task.objective && task.objective.kpi) || 
                                  (task.cycle && task.cycle.objective && task.cycle.objective.kpi);
          if (!objectiveKpiKey || !trafficKpis.has(objectiveKpiKey)) {
            return false;
          }
          
          // Must be able to compute clicks delta
          const activeCycle = scope === 'active_cycle' 
            ? ((task.cycles && task.cycles.find(c => c.is_active || c.id === task.active_cycle_id)) || null)
            : null;
          const measurements = task.measurements || [];
          const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);
          
          if (baselineLatest && baselineLatest.baseline && baselineLatest.latest) {
            // Check if clicks can be computed
            const baselineClicks = getMetricValue(baselineLatest.baseline, 'clicks_28d');
            const latestClicks = getMetricValue(baselineLatest.latest, 'clicks_28d');
            if (baselineClicks != null && latestClicks != null) {
              return true; // Direct clicks available
            }
            
            // Check CTR  Impressions fallback
            const baselineCtr = getMetricValue(baselineLatest.baseline, 'ctr_28d');
            const latestCtr = getMetricValue(baselineLatest.latest, 'ctr_28d');
            const baselineImpr = getMetricValue(baselineLatest.baseline, 'impressions_28d');
            const latestImpr = getMetricValue(baselineLatest.latest, 'impressions_28d');
            if (baselineCtr != null && baselineImpr != null && latestCtr != null && latestImpr != null) {
              return true; // Can compute from CTR  Impressions
            }
          }
          
          // Fallback: check task.baseline_metrics/latest_metrics
          if (task.baseline_metrics && task.latest_metrics) {
            const baselineClicks = getMetricValue(task.baseline_metrics, 'clicks_28d');
            const latestClicks = getMetricValue(task.latest_metrics, 'clicks_28d');
            if (baselineClicks != null && latestClicks != null) {
              return true;
            }
            
            const baselineCtr = getMetricValue(task.baseline_metrics, 'ctr_28d');
            const latestCtr = getMetricValue(task.latest_metrics, 'ctr_28d');
            const baselineImpr = getMetricValue(task.baseline_metrics, 'impressions_28d');
            const latestImpr = getMetricValue(task.latest_metrics, 'impressions_28d');
            if (baselineCtr != null && baselineImpr != null && latestCtr != null && latestImpr != null) {
              return true;
            }
          }
          
          return false; // Cannot compute clicks delta
        });
      }
      
      // Apply metric traffic filter
      const metricTrafficFilter = window.optimisationModuleState.metricTrafficFilter;
      if (metricTrafficFilter) {
        const scope = window.optimisationModuleState.scope || 'active_cycle';
        const metricKeys = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
        
        tasks = tasks.filter(task => {
          // Only active tasks can match
          if (!isActiveStatus(task.status)) {
            return false;
          }
          
          // Get active cycle if scope is 'active_cycle'
          const activeCycle = scope === 'active_cycle' 
            ? ((task.cycles && task.cycles.find(c => c.is_active || c.id === task.active_cycle_id)) || null)
            : null;
          
          // Get measurements
          const measurements = task.measurements || [];
          const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);
          
          if (!baselineLatest) {
            // Task doesn't have enough measurements, exclude
            return false;
          }
          
          // Handle "all_metrics" filter: check that majority of metrics (at least 3 out of 6) match the bucket
          if (metricTrafficFilter.metricKey === 'all_metrics') {
            const classifications = [];
            for (const metricKey of metricKeys) {
              const classification = classifyMetric(
                metricKey,
                baselineLatest.baseline,
                baselineLatest.latest
              );
              if (classification) {
                classifications.push(classification);
              }
            }
            
            // Count occurrences of the filter bucket
            const bucketCount = classifications.filter(cls => cls === metricTrafficFilter.bucket).length;
            
            // At least 4 metrics must match the bucket (majority)
            return bucketCount >= 4;
          } else {
            // Single metric filter
            const classification = classifyMetric(
              metricTrafficFilter.metricKey,
              baselineLatest.baseline,
              baselineLatest.latest
            );
            
            // Include only if classification matches the filter bucket
            return classification === metricTrafficFilter.bucket;
          }
        });
      }
      
      window.optimisationModuleState.filteredTasks = tasks;
    }
    
    // Helper: Compute estimated extra clicks (28d) for a single task
    // Supports traffic KPIs: ctr_28d, impressions_28d, clicks_28d
    function computeEstimatedExtraClicks28d(task) {
      // Try multiple sources for objective
      const objective = task.objective || (task.cycle && task.cycle.objective) || null;
      const objectiveKpiKey = task.objectiveKpiKey || (objective && objective.kpi);
      const baselineValue = task.baselineValue;
      const latestValue = task.latestValue;
      const latestMetrics = task.latest_metrics || {};
      
      // Must have objective and latest value
      if (!objectiveKpiKey || !objective || latestValue == null) {
        return 0;
      }
      
      // Calculate target value (normalize delta vs absolute)
      let targetValue = null;
      if (objective.target_type === 'delta') {
        // Delta: target = baseline + delta
        if (baselineValue != null) {
          targetValue = baselineValue + objective.target;
        }
      } else {
        // Absolute: target = target value directly
        targetValue = objective.target;
      }
      
      if (targetValue == null) {
        return 0;
      }
      
      // Compute based on KPI type
      switch (objectiveKpiKey) {
        case 'ctr_28d': {
          // CTR: extra clicks = impressions * (target_ctr - latest_ctr)
          // Handle both gsc_ prefixed fields (from baseline) and regular fields
          const impressions = latestMetrics.gsc_impressions_28d ?? latestMetrics.impressions_28d ?? 0;
          if (impressions > 0 && targetValue > latestValue) {
            const deltaCtr = targetValue - latestValue;
            if (deltaCtr > 0) {
              return Math.round(impressions * deltaCtr);
            }
          }
          return 0;
        }
        
        case 'impressions_28d': {
          // Impressions: extra clicks = (target_impressions - latest_impressions) * latest_ctr
          // Handle both gsc_ prefixed fields (from baseline) and regular fields
          const latestCtr = latestMetrics.gsc_ctr_28d ?? latestMetrics.ctr_28d ?? 0;
          if (targetValue > latestValue && latestCtr > 0) {
            const deltaImpr = targetValue - latestValue;
            if (deltaImpr > 0) {
              return Math.round(deltaImpr * latestCtr);
            }
          }
          return 0;
        }
        
        case 'clicks_28d': {
          // Clicks: extra clicks = target_clicks - latest_clicks (direct delta)
          if (targetValue > latestValue) {
            const deltaClicks = targetValue - latestValue;
            if (deltaClicks > 0) {
              return Math.round(deltaClicks);
            }
          }
          return 0;
        }
        
        default:
          return 0;
      }
    }

    // Compute potential extra clicks (28d) with deduplication
    // Groups by target_url to prevent double-counting when multiple tasks target the same page
    // Returns: { potential: number, actual: number }
    function computePotentialAndActualClicks28d(tasks, scope) {
      const trafficKpis = new Set(['ctr_28d', 'impressions_28d', 'clicks_28d']);
      
      // Group tasks by target_url for deduplication
      // Deduplication strategy:
      // - Potential: MAX per URL (avoids fantasy stacking when multiple tasks target same page)
      // - Actual: SUM per URL (measured changes can legitimately stack across tasks)
      const tasksByUrl = {};
      for (const task of tasks) {
        const objectiveKpiKey = task.objectiveKpiKey || (task.objective && task.objective.kpi) || 
                                (task.cycle && task.cycle.objective && task.cycle.objective.kpi);
        if (!objectiveKpiKey || !trafficKpis.has(objectiveKpiKey)) {
          continue; // Skip non-traffic KPIs
        }
        
        const targetUrl = task.target_url_clean || task.target_url || 'unknown';
        if (!tasksByUrl[targetUrl]) {
          tasksByUrl[targetUrl] = [];
        }
        tasksByUrl[targetUrl].push(task);
      }
      
      let totalPotential = 0;
      let totalActual = 0;
      
      // Debug: count included tasks for Actual calculation
      let includedTasksCount = 0;
      
      // Process each URL group
      for (const [url, urlTasks] of Object.entries(tasksByUrl)) {
        // For potential: take MAX per URL (avoid fantasy stacking)
        // For actual: sum within group (it's measured, so multiple tasks can contribute)
        let maxPotential = 0;
        let sumActual = 0;
        
        for (const task of urlTasks) {
          // Get active cycle if scope is 'active_cycle'
          const activeCycle = scope === 'active_cycle' 
            ? ((task.cycles && task.cycles.find(c => c.is_active || c.id === task.active_cycle_id)) || null)
            : null;
          const measurements = task.measurements || [];
          const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);
          
          // Potential: compute estimated extra clicks (uses task.objective and task.baselineValue/latestValue)
          const potential = computeEstimatedExtraClicks28d(task);
          maxPotential = Math.max(maxPotential, potential);
          
          // Actual: compute measured click delta
          // Only include if clicks can be computed (exclude if neither clicks nor CTRImpressions available)
          let actual = null; // null means cannot compute
          
          if (baselineLatest && baselineLatest.baseline && baselineLatest.latest) {
            // Use measurements if available
            actual = computeActualClickDeltaForTask(task, baselineLatest.baseline, baselineLatest.latest);
          } else if (task.baseline_metrics && task.latest_metrics) {
            // Fallback to task's baseline_metrics/latest_metrics
            actual = computeActualClickDeltaForTask(task, task.baseline_metrics, task.latest_metrics);
          } else if (task.baselineValue != null && task.latestValue != null) {
            // Last resort: use task's baselineValue/latestValue if this is for clicks_28d KPI
            const objectiveKpiKey = task.objectiveKpiKey || (task.objective && task.objective.kpi) || 
                                    (task.cycle && task.cycle.objective && task.cycle.objective.kpi);
            if (objectiveKpiKey === 'clicks_28d') {
              actual = task.latestValue - task.baselineValue;
            }
            // For CTR/Impressions, we can't compute clicks from just baselineValue/latestValue
            // (we'd need impressions or CTR separately), so actual remains null
          }
          
          // Only include if actual is not null (clicks can be computed)
          if (actual != null) {
            sumActual += actual;
            includedTasksCount++;
          }
          // If actual is null, exclude this task (don't treat as 0)
        }
        
        totalPotential += maxPotential;
        totalActual += sumActual;
      }
      
      // Debug log (not shown in UI, but available in console)
      console.log('[computePotentialAndActualClicks28d] Included tasks for Actual:', includedTasksCount);
      
      return {
        potential: Math.round(totalPotential),
        actual: Math.round(totalActual),
        includedTasksCount // For debugging
      };
    }
    
    // Compute actual click delta for a single task
    // Returns click change from baseline  latest (can be negative)
    // Returns null if clicks cannot be computed (neither clicks nor CTRImpressions available)
    // Accepts either measurement objects or metric objects
    function computeActualClickDeltaForTask(task, baseline, latest) {
      // Prefer direct clicks_28d if available
      const baselineClicks = getMetricValue(baseline, 'clicks_28d');
      const latestClicks = getMetricValue(latest, 'clicks_28d');
      
      if (baselineClicks != null && latestClicks != null) {
        return latestClicks - baselineClicks;
      }
      
      // Fallback: compute from CTR  Impressions
      const baselineCtr = getMetricValue(baseline, 'ctr_28d');
      const latestCtr = getMetricValue(latest, 'ctr_28d');
      const baselineImpr = getMetricValue(baseline, 'impressions_28d');
      const latestImpr = getMetricValue(latest, 'impressions_28d');
      
      if (baselineCtr != null && baselineImpr != null && latestCtr != null && latestImpr != null) {
        // CTR is stored as ratio (0-1), so multiply by impressions to get clicks
        const baselineComputedClicks = baselineImpr * baselineCtr;
        const latestComputedClicks = latestImpr * latestCtr;
        return latestComputedClicks - baselineComputedClicks;
      }
      
      return null; // Cannot compute clicks delta (exclude from sum)
    }

    // Build Chart 1: Estimated Extra Clicks (28d) by KPI
    // Only include traffic KPIs where "extra clicks" is meaningful: CTR, Impressions, Clicks
    function buildEstimatedClicksByKpi(filteredTasks) {
      // Define allowed traffic KPIs only
      const allowedTrafficKpis = new Set(['ctr_28d', 'impressions_28d', 'clicks_28d']);
      
      const kpiBuckets = {
        'ctr_28d': { label: 'CTR (28d)', sum: 0, count: 0 },
        'impressions_28d': { label: 'Impressions (28d)', sum: 0, count: 0 },
        'clicks_28d': { label: 'Clicks (28d)', sum: 0, count: 0 },
        'no_objective': { label: 'No Traffic Objective', sum: 0, count: 0 }
      };
      
      for (const task of filteredTasks) {
        const extraClicks = computeEstimatedExtraClicks28d(task);
        const objectiveKpiKey = task.objectiveKpiKey || (task.objective && task.objective.kpi) ||
                                (task.cycle && task.cycle.objective && task.cycle.objective.kpi);
        
        // Only include if objective KPI is a traffic KPI
        if (objectiveKpiKey && allowedTrafficKpis.has(objectiveKpiKey) && kpiBuckets[objectiveKpiKey]) {
          kpiBuckets[objectiveKpiKey].sum += extraClicks;
          kpiBuckets[objectiveKpiKey].count += 1;
        } else {
          // Tasks with no objective, or non-traffic KPIs (Rank, AI Citations, AI Overview, etc.) go to "No Traffic Objective"
          kpiBuckets['no_objective'].sum += extraClicks;
          kpiBuckets['no_objective'].count += 1;
        }
      }
      
      // Filter out buckets with zero sum (remove "No Traffic Objective" if always 0)
      const result = [];
      for (const [kpi, data] of Object.entries(kpiBuckets)) {
        // Only include if sum > 0 (exclude zero-sum buckets)
        if (data.sum > 0) {
          result.push({ kpi, label: data.label, sum: data.sum, count: data.count });
        }
      }
      
      return result;
    }

    // Build Chart 2: Median Delta Over Time for Selected KPI
    function buildMedianDeltaTrend(filteredTasks, selectedKpi, scope, weeks = 12) {
      if (!selectedKpi) return { weeks: [], medians: [], sampleSizes: [] };
      
      // Get measurements for all tasks in scope
      const weekDeltas = new Map(); // weekKey -> [deltas from all tasks]
      
      for (const task of filteredTasks) {
        const activeCycle = scope === 'active_cycle' 
          ? ((task.cycles && task.cycles.find(c => c.is_active || c.id === task.active_cycle_id)) || null)
          : null;
        const measurements = task.measurements || [];
        
        // Filter measurements by scope
        let eligibleMeasurements = [...measurements];
        if (scope === 'active_cycle' && activeCycle) {
          const cycleStartDate = activeCycle.start_date ? new Date(activeCycle.start_date) : 
                                (activeCycle.started_at ? new Date(activeCycle.started_at) : null);
          if (cycleStartDate) {
            eligibleMeasurements = eligibleMeasurements.filter(m => {
              const mDate = m.captured_at ? new Date(m.captured_at) : null;
              return mDate && mDate >= cycleStartDate;
            });
          }
        }
        
        if (eligibleMeasurements.length < 2) continue;
        
        // Sort by date
        eligibleMeasurements.sort((a, b) => {
          const dateA = a.captured_at ? new Date(a.captured_at) : new Date(0);
          const dateB = b.captured_at ? new Date(b.captured_at) : new Date(0);
          return dateA - dateB;
        });
        
        // Group measurements by week
        const measurementsByWeek = new Map();
        for (const m of eligibleMeasurements) {
          if (!m.captured_at) continue;
          const weekKey = weekStartISO(m.captured_at);
          if (!measurementsByWeek.has(weekKey)) {
            measurementsByWeek.set(weekKey, []);
          }
          measurementsByWeek.get(weekKey).push(m);
        }
        
        // For each week, compute delta if we have at least 2 measurements
        for (const [weekKey, weekMeasurements] of measurementsByWeek.entries()) {
          if (weekMeasurements.length < 2) continue;
          
          // Sort by date within week
          weekMeasurements.sort((a, b) => {
            const dateA = a.captured_at ? new Date(a.captured_at) : new Date(0);
            const dateB = b.captured_at ? new Date(b.captured_at) : new Date(0);
            return dateA - dateB;
          });
          
          const startValue = getMetricValue(weekMeasurements[0], selectedKpi);
          const endValue = getMetricValue(weekMeasurements[weekMeasurements.length - 1], selectedKpi);
          
          if (startValue == null || endValue == null) continue;
          
          // Compute delta with correct units
          let delta;
          if (selectedKpi === 'ctr_28d') {
            delta = (endValue - startValue) * 100; // percentage points
          } else if (selectedKpi === 'current_rank') {
            delta = startValue - endValue; // lower is better, so invert
          } else {
            delta = endValue - startValue;
          }
          
          if (!weekDeltas.has(weekKey)) {
            weekDeltas.set(weekKey, []);
          }
          weekDeltas.get(weekKey).push(delta);
        }
      }
      
      // Get last N weeks
      const now = new Date();
      const weekKeys = [];
      for (let i = weeks - 1; i >= 0; i--) {
        const weekDate = new Date(now);
        weekDate.setDate(weekDate.getDate() - (i * 7));
        weekKeys.push(weekStartISO(weekDate));
      }
      
      // Compute medians for each week
      const result = {
        weeks: [],
        medians: [],
        sampleSizes: []
      };
      
      for (const weekKey of weekKeys) {
        const deltas = weekDeltas.get(weekKey) || [];
        result.weeks.push(weekKey);
        if (deltas.length > 0) {
          result.medians.push(median(deltas));
          result.sampleSizes.push(deltas.length);
        } else {
          result.medians.push(null);
          result.sampleSizes.push(0);
        }
      }
      
      return result;
    }

    // Update timeseries charts
    function updateTimeseriesCharts() {
      // Use the SAME filteredTasks as the table (includes all filters + scope + traffic-pill filter)
      let filteredTasks = window.optimisationModuleState.filteredTasks || [];
      
      // Filter out test tasks if checkbox is unchecked (same as table)
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        filteredTasks = filteredTasks.filter(t => !t.is_test_task);
      }
      
      const scope = window.optimisationModuleState.scope || 'active_cycle';
      
      // PART 1: Estimated Extra Clicks (28d) by KPI
      const estimatedClicksByKpi = buildEstimatedClicksByKpi(filteredTasks);
      
      // PART 1B: Median Delta Over Time for Selected KPI
      const selectedKpiForTrend = (window.optimisationModuleState && window.optimisationModuleState.selectedKpiForTrend) || 'ctr_28d';
      const medianDeltaTrend = buildMedianDeltaTrend(filteredTasks, selectedKpiForTrend, scope, 12);
      
      // PART 2: Median Delta by KPI (Last 30d) - only tasks with latest measurement in last 30 days
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      
      const eligibleTasks = filteredTasks.filter(task => {
        const latestMeasurement = getLatestMeasurementInScope(task, scope);
        if (!latestMeasurement || !latestMeasurement.captured_at) {
          return false;
        }
        const latestDate = new Date(latestMeasurement.captured_at);
        return latestDate >= thirtyDaysAgo;
      });
      
      // Compute deltas for each KPI
      const deltasByKpi = {};
      const kpiList = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
      
      for (const task of eligibleTasks) {
        const activeCycle = scope === 'active_cycle' 
          ? ((task.cycles && task.cycles.find(c => c.is_active || c.id === task.active_cycle_id)) || null)
          : null;
        const measurements = task.measurements || [];
        const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);
        
        if (!baselineLatest) {
          continue;
        }
        
        // Compute delta for each KPI
        for (const kpi of kpiList) {
          const delta = computeDeltaForKPI(kpi, baselineLatest.baseline, baselineLatest.latest);
          if (delta != null) {
            if (!deltasByKpi[kpi]) {
              deltasByKpi[kpi] = [];
            }
            deltasByKpi[kpi].push(delta);
          }
        }
      }
      
      // TEMP: Log raw CTR deltas for debugging
      if (deltasByKpi.ctr_28d && deltasByKpi.ctr_28d.length > 0) {
        console.log("[KPI MEDIAN] CTR raw deltas (from computeDeltaForKPI):", deltasByKpi.ctr_28d);
        console.log("[KPI MEDIAN] CTR raw deltas sample (first 5):", deltasByKpi.ctr_28d.slice(0, 5));
      }
      
      // Compute medians and include task counts
      const medianDeltaByKpi = [];
      for (const [kpi, deltas] of Object.entries(deltasByKpi)) {
        if (deltas.length > 0) {
          const med = median(deltas);
          if (med != null) {
            medianDeltaByKpi.push({ kpi, value: med, count: deltas.length });
            // TEMP: Log CTR median before formatting
            if (kpi === 'ctr_28d') {
              console.log("[KPI MEDIAN] CTR median BEFORE format:", med);
              console.log("[KPI MEDIAN] CTR median absolute value:", Math.abs(med));
              if (Math.abs(med) > 20) {
                console.warn("[KPI MEDIAN] CTR delta seems too large:", med, "pp. Contributing deltas:", deltas.slice(0, 10));
              }
            }
          }
        }
      }
      
      // Sort to match traffic light order: CTR, Impressions, Clicks, Rank, AI Citations, AI Overview
      const kpiOrder = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
      medianDeltaByKpi.sort((a, b) => {
        const indexA = kpiOrder.indexOf(a.kpi);
        const indexB = kpiOrder.indexOf(b.kpi);
        // If KPI not in order list, put it at the end
        if (indexA === -1 && indexB === -1) return a.kpi.localeCompare(b.kpi);
        if (indexA === -1) return 1;
        if (indexB === -1) return -1;
        return indexA - indexB;
      });
      
      const timeseries = {
        estimatedClicksByKpi,
        medianDeltaTrend,
        selectedKpiForTrend,
        medianDeltaByKpi
      };
      
      // Render Chart 1: Estimated Extra Clicks (28d) by KPI
      const clicksCanvas = document.getElementById('chart-estimated-clicks-by-kpi');
      if (clicksCanvas && timeseries.estimatedClicksByKpi) {
        const ctx = clicksCanvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        // Get width from container to ensure it fills properly
        const container = document.getElementById('chart-left-container');
        const displayWidth = (container ? container.offsetWidth : clicksCanvas.offsetWidth) || 400;
        const displayHeight = 280;
        
        clicksCanvas.width = displayWidth * dpr;
        clicksCanvas.height = displayHeight * dpr;
        clicksCanvas.style.width = displayWidth + 'px';
        clicksCanvas.style.height = displayHeight + 'px';
        ctx.scale(dpr, dpr);
        
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        
        const data = timeseries.estimatedClicksByKpi;
        if (!data || data.length === 0) {
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No data', displayWidth / 2, displayHeight / 2);
        } else {
          const maxSum = Math.max(...data.map(d => d.sum), 1);
          const padding = { top: 20, right: 20, bottom: 70, left: 60 };
          const chartWidth = displayWidth - padding.left - padding.right;
          const chartHeight = displayHeight - padding.top - padding.bottom;
          const barWidth = chartWidth / data.length * 0.7;
          const barSpacing = chartWidth / data.length * 0.3;
          
          // Draw axes
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(padding.left, padding.top);
          ctx.lineTo(padding.left, displayHeight - padding.bottom);
          ctx.lineTo(displayWidth - padding.right, displayHeight - padding.bottom);
          ctx.stroke();
          
          // Draw y-axis label
          ctx.save();
          ctx.translate(15, displayHeight / 2);
          ctx.rotate(-Math.PI / 2);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 18px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Estimated Remaining Clicks (28d)', 0, 0);
          ctx.restore();
          
          // Draw y-axis ticks and labels
          const yTicks = 5;
          for (let i = 0; i <= yTicks; i++) {
            const value = (maxSum / yTicks) * i;
            const y = displayHeight - padding.bottom - (i / yTicks) * chartHeight;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(padding.left, y);
            ctx.lineTo(displayWidth - padding.right, y);
            ctx.stroke();
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'right';
            const labelText = value >= 1000 ? (value / 1000).toFixed(1) + 'k' : Math.round(value).toString();
            ctx.fillText(labelText, padding.left - 10, y + 4);
          }
          
          // Draw bars
          data.forEach((d, i) => {
            const x = padding.left + i * (barWidth + barSpacing) + barSpacing / 2;
            const barHeight = (d.sum / maxSum) * chartHeight;
            const y = displayHeight - padding.bottom - barHeight;
            
            // Green bars
            ctx.fillStyle = '#10b981';
            ctx.fillRect(x, y, barWidth, barHeight);
            
            // Value label on top of bar
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            const valueText = d.sum >= 1000 ? (d.sum / 1000).toFixed(1) + 'k' : Math.round(d.sum).toString();
            ctx.fillText(valueText, x + barWidth / 2, y - 5);
            
            // Label below bar
            ctx.font = 'bold 11px sans-serif';
            const labelLines = d.label.split(' ');
            labelLines.forEach((line, lineIdx) => {
              ctx.fillText(line, x + barWidth / 2, displayHeight - padding.bottom + 12 + (lineIdx * 12));
            });
          });
        }
      }
      
      // Render Chart 2: Median Delta Over Time for Selected KPI
      const trendCanvas = document.getElementById('chart-median-delta-trend');
      if (trendCanvas && timeseries.medianDeltaTrend) {
        const ctx = trendCanvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        // Get width from container to ensure it fills properly
        const container = document.getElementById('chart-left-container');
        const displayWidth = (container ? container.offsetWidth : trendCanvas.offsetWidth) || 400;
        const displayHeight = 280;
        
        trendCanvas.width = displayWidth * dpr;
        trendCanvas.height = displayHeight * dpr;
        trendCanvas.style.width = displayWidth + 'px';
        trendCanvas.style.height = displayHeight + 'px';
        ctx.scale(dpr, dpr);
        
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        
        const trend = timeseries.medianDeltaTrend;
        const kpiLabels = {
          'ctr_28d': 'CTR (pp)',
          'impressions_28d': 'Impressions',
          'clicks_28d': 'Clicks',
          'current_rank': 'Rank  (lower better)',
          'ai_citations': 'AI Citations',
          'opportunity_score': 'Opportunity Score'
        };
        
        if (!trend.weeks || trend.weeks.length === 0 || trend.medians.every(m => m == null)) {
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Not enough history', displayWidth / 2, displayHeight / 2);
        } else {
          const validMedians = trend.medians.filter(m => m != null);
          if (validMedians.length === 0) {
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Not enough history', displayWidth / 2, displayHeight / 2);
          } else {
            const maxAbs = Math.max(...validMedians.map(m => Math.abs(m)), 1);
            const padding = { top: 20, right: 20, bottom: 70, left: 60 };
            const chartWidth = displayWidth - padding.left - padding.right;
            const chartHeight = displayHeight - padding.top - padding.bottom;
            const zeroY = displayHeight - padding.bottom - (maxAbs / (maxAbs * 2)) * chartHeight;
            
            // Draw axes
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, displayHeight - padding.bottom);
            ctx.lineTo(displayWidth - padding.right, displayHeight - padding.bottom);
            ctx.stroke();
            
            // Draw zero line
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, zeroY);
            ctx.lineTo(displayWidth - padding.right, zeroY);
            ctx.stroke();
            
            // Draw y-axis label based on KPI unit
            ctx.save();
            ctx.translate(15, displayHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'center';
            const selectedKpi = timeseries.selectedKpiForTrend;
            let yAxisLabel = 'Median Delta';
            if (selectedKpi === 'ctr_28d') {
              yAxisLabel = ' CTR (pp)';
            } else if (selectedKpi === 'current_rank') {
              yAxisLabel = ' Rank (lower is better)';
            } else if (selectedKpi === 'impressions_28d') {
              yAxisLabel = ' Impressions';
            } else if (selectedKpi === 'clicks_28d') {
              yAxisLabel = ' Clicks';
            } else if (selectedKpi === 'ai_citations') {
              yAxisLabel = ' AI Citations';
            } else if (selectedKpi === 'opportunity_score') {
              yAxisLabel = ' Opportunity Score';
            }
            ctx.fillText(yAxisLabel, 0, 0);
            ctx.restore();
            
            // Draw y-axis ticks and labels
            const yTicks = 5;
            for (let i = 0; i <= yTicks; i++) {
              const value = (maxAbs * 2 / yTicks) * i - maxAbs;
              const y = displayHeight - padding.bottom - (i / yTicks) * chartHeight;
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
              ctx.lineWidth = 0.5;
              ctx.beginPath();
              ctx.moveTo(padding.left, y);
              ctx.lineTo(displayWidth - padding.right, y);
              ctx.stroke();
              
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 14px sans-serif';
              ctx.textAlign = 'right';
              ctx.fillText(value.toFixed(1), padding.left - 10, y + 4);
            }
            
            // Draw x-axis week labels
            trend.weeks.forEach((weekKey, i) => {
              const x = padding.left + (i / (trend.weeks.length - 1 || 1)) * chartWidth;
              const weekDate = new Date(weekKey);
              const day = weekDate.getDate();
              const month = weekDate.getMonth() + 1;
              const weekLabel = `${day}/${month}`;
              
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 11px sans-serif';
              ctx.textAlign = 'center';
              ctx.fillText(weekLabel, x, displayHeight - padding.bottom + 18);
            });
            
            // Draw line
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            let hasMoved = false;
            trend.medians.forEach((med, i) => {
              if (med != null) {
                const x = padding.left + (i / (trend.weeks.length - 1 || 1)) * chartWidth;
                const y = displayHeight - padding.bottom - ((med + maxAbs) / (maxAbs * 2)) * chartHeight;
                if (!hasMoved) {
                  ctx.moveTo(x, y);
                  hasMoved = true;
                } else {
                  ctx.lineTo(x, y);
                }
              }
            });
            ctx.stroke();
            
            // Draw points with value labels
            ctx.fillStyle = '#3b82f6';
            trend.medians.forEach((med, i) => {
              if (med != null) {
                const x = padding.left + (i / (trend.weeks.length - 1 || 1)) * chartWidth;
                const y = displayHeight - padding.bottom - ((med + maxAbs) / (maxAbs * 2)) * chartHeight;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Show value label on last point, or all points if not too many
                const showLabel = (i === trend.medians.length - 1) || (trend.medians.length <= 8);
                if (showLabel) {
                  ctx.fillStyle = '#ffffff';
                  ctx.font = 'bold 10px sans-serif';
                  ctx.textAlign = 'center';
                  const valueText = med >= 0 ? `+${med.toFixed(1)}` : med.toFixed(1);
                  ctx.fillText(valueText, x, y - 10);
                  ctx.fillStyle = '#3b82f6'; // Reset for next point
                }
              }
            });
          }
        }
      }

      // Render Median Delta by KPI chart (with device pixel ratio for crisp rendering)
      const deltaCanvas = document.getElementById('chart-median-delta');
      if (deltaCanvas && timeseries.medianDeltaByKpi) {
        const ctx = deltaCanvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const displayWidth = deltaCanvas.offsetWidth || 400;
        const displayHeight = 280;
        
        // Set canvas internal size accounting for device pixel ratio for crisp rendering
        deltaCanvas.width = displayWidth * dpr;
        deltaCanvas.height = displayHeight * dpr;
        
        // Scale canvas CSS size to display size
        deltaCanvas.style.width = displayWidth + 'px';
        deltaCanvas.style.height = displayHeight + 'px';
        
        // Scale context to match device pixel ratio
        ctx.scale(dpr, dpr);
        
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        
        const data = timeseries.medianDeltaByKpi;
        if (data.length === 0) {
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No data', displayWidth / 2, displayHeight / 2);
        } else {
          const maxAbs = Math.max(...data.map(d => Math.abs(d.value)), 1);
          const padding = { top: 20, right: 20, bottom: 70, left: 60 };
          const chartWidth = displayWidth - padding.left - padding.right;
          const chartHeight = displayHeight - padding.top - padding.bottom;
          const barWidth = chartWidth / data.length * 0.7;
          const barSpacing = chartWidth / data.length * 0.3;
          const zeroY = displayHeight - padding.bottom - (maxAbs / (maxAbs * 2)) * chartHeight;
          
          // KPI label mapping
          const kpiLabels = {
            'ctr_28d': 'CTR (pp)',
            'impressions_28d': 'Impressions',
            'clicks_28d': 'Clicks',
            'current_rank': 'Rank (, lower better)',
            'ai_citations': 'AI Citations',
            'ai_overview': 'AI Overview'
          };
          
          // Draw y-axis label - bright white and much larger
          ctx.save();
          ctx.translate(15, displayHeight / 2);
          ctx.rotate(-Math.PI / 2);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 18px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Median Delta', 0, 0);
          ctx.restore();
          
          // Draw zero line - white
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(padding.left, zeroY);
          ctx.lineTo(displayWidth - padding.right, zeroY);
          ctx.stroke();
          
          // Draw y-axis ticks and labels - white and larger
          const yTicks = 5;
          for (let i = 0; i <= yTicks; i++) {
            const value = (maxAbs * 2 / yTicks) * i - maxAbs;
            const y = displayHeight - padding.bottom - (i / yTicks) * chartHeight;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(padding.left, y);
            ctx.lineTo(displayWidth - padding.right, y);
            ctx.stroke();
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'right';
            const label = value >= 0 ? `+${value.toFixed(1)}` : value.toFixed(1);
            ctx.fillText(label, padding.left - 10, y + 4);
          }
          
          // Draw bars
          data.forEach((d, i) => {
            const x = padding.left + i * (barWidth + barSpacing) + barSpacing / 2;
            // For rank, the delta is already inverted (baseline - latest), so positive = improvement
            // For other metrics, positive = improvement
            const isRank = d.kpi === 'current_rank';
            const barHeight = (Math.abs(d.value) / maxAbs) * chartHeight;
            const y = d.value >= 0 ? zeroY - barHeight : zeroY;
            
            // Rank: positive delta (lower rank = better) is green, negative (higher rank = worse) is red
            // Other metrics: positive delta (higher = better) is green, negative (lower = worse) is red
            ctx.fillStyle = d.value >= 0 ? '#10b981' : '#ef4444';
            ctx.fillRect(x, y, barWidth, barHeight);
            
            // Value label on bar
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            let valueText = '';
            if (d.kpi === 'ctr_28d') {
              // CTR delta is already in percentage points from computeDeltaForKPI
              // computeDeltaForKPI returns: (latestRatio - baselineRatio) * 100
              // So d.value is already in pp, NO further multiplication needed
              // TEMP: Log the value being formatted
              console.log("[KPI MEDIAN] CTR dataset value for bar label:", d.value);
              if (Math.abs(d.value) > 20) {
                console.error("[KPI MEDIAN] CTR delta seems too large - possible double scaling bug:", d.value, "pp");
              }
              const deltaPp = d.value; // Already in pp, use directly - NO multiplication
              valueText = (deltaPp >= 0 ? '+' : '') + deltaPp.toFixed(2) + 'pp';
              console.log("[KPI MEDIAN] CTR formatted label:", valueText);
            } else if (d.kpi === 'current_rank') {
              valueText = (d.value >= 0 ? '+' : '') + d.value.toFixed(1);
            } else {
              valueText = (d.value >= 0 ? '+' : '') + Math.round(d.value).toString();
            }
            // Position label above or below bar depending on direction
            const labelY = d.value >= 0 ? y - 5 : y + barHeight + 15;
            ctx.fillText(valueText, x + barWidth / 2, labelY);
            
            // Draw KPI label (horizontal, wrapped) - white and much larger
            const label = kpiLabels[d.kpi] || d.kpi.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            const labelX = x + barWidth / 2;
            const labelMaxWidth = barWidth * 0.95;
            
            ctx.font = 'bold 11px sans-serif';
            
            // Simple word wrapping: split on spaces if needed
            const words = label.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (const word of words) {
              const testLine = currentLine ? `${currentLine} ${word}` : word;
              const metrics = ctx.measureText(testLine);
              if (metrics.width > labelMaxWidth && currentLine) {
                lines.push(currentLine);
                currentLine = word;
              } else {
                currentLine = testLine;
              }
            }
            if (currentLine) lines.push(currentLine);
            
            // Draw lines centered under the bar
            const lineHeight = 12;
            const startY = displayHeight - padding.bottom + 15;
            lines.forEach((line, lineIdx) => {
              ctx.fillText(line, labelX, startY + (lineIdx * lineHeight));
            });
          });
        }
      }
      
      // Setup toggle buttons for left chart
      const clicksToggle = document.getElementById('chart-left-toggle-clicks');
      const trendToggle = document.getElementById('chart-left-toggle-trend');
      const kpiSelect = document.getElementById('chart-trend-kpi-select');
      const clicksCanvasEl = document.getElementById('chart-estimated-clicks-by-kpi');
      const trendCanvasEl = document.getElementById('chart-median-delta-trend');
      
      if (clicksToggle && trendToggle) {
        // Set initial state
        const currentView = window.optimisationModuleState.leftChartView || 'clicks';
        if (currentView === 'clicks') {
          if (clicksCanvasEl) clicksCanvasEl.style.display = 'block';
          if (trendCanvasEl) trendCanvasEl.style.display = 'none';
          if (kpiSelect) kpiSelect.style.display = 'none';
          const kpiLabelEl = document.getElementById('chart-trend-kpi-label');
          if (kpiLabelEl) kpiLabelEl.style.display = 'none';
          clicksToggle.classList.add('active');
          clicksToggle.style.background = 'var(--dark-brand)';
          clicksToggle.style.color = '#000';
          trendToggle.classList.remove('active');
          trendToggle.style.background = 'var(--dark-panel)';
          trendToggle.style.color = 'var(--dark-text)';
        } else {
          if (clicksCanvasEl) clicksCanvasEl.style.display = 'none';
          if (trendCanvasEl) trendCanvasEl.style.display = 'block';
          if (kpiSelect) kpiSelect.style.display = 'block';
          const kpiLabelEl = document.getElementById('chart-trend-kpi-label');
          if (kpiLabelEl) kpiLabelEl.style.display = 'inline';
          trendToggle.classList.add('active');
          trendToggle.style.background = 'var(--dark-brand)';
          trendToggle.style.color = '#000';
          clicksToggle.classList.remove('active');
          clicksToggle.style.background = 'var(--dark-panel)';
          clicksToggle.style.color = 'var(--dark-text)';
        }
        
        // Handle clicks toggle
        clicksToggle.addEventListener('click', () => {
          window.optimisationModuleState.leftChartView = 'clicks';
          if (clicksCanvasEl) {
            clicksCanvasEl.style.display = 'block';
            // Force resize after display change to fix canvas sizing
            setTimeout(() => updateTimeseriesCharts(), 10);
          }
          if (trendCanvasEl) trendCanvasEl.style.display = 'none';
          if (kpiSelect) kpiSelect.style.display = 'none';
          const kpiLabelEl = document.getElementById('chart-trend-kpi-label');
          if (kpiLabelEl) kpiLabelEl.style.display = 'none';
          clicksToggle.classList.add('active');
          clicksToggle.style.background = 'var(--dark-brand)';
          clicksToggle.style.color = '#000';
          trendToggle.classList.remove('active');
          trendToggle.style.background = 'var(--dark-panel)';
          trendToggle.style.color = 'var(--dark-text)';
          
          // Update title and subtitle
          const titleEl = document.getElementById('chart-left-title');
          const subtitleEl = document.getElementById('chart-left-subtitle');
          if (titleEl) titleEl.textContent = 'Estimated Gap to Target (28d)  Clicks Potential';
          if (subtitleEl) subtitleEl.textContent = 'Sum of remaining clicks needed to hit each task\'s objective (traffic KPIs only). This is a target gap, not last-30d performance.';
        });
        
        // Handle trend toggle
        trendToggle.addEventListener('click', () => {
          window.optimisationModuleState.leftChartView = 'trend';
          if (clicksCanvasEl) clicksCanvasEl.style.display = 'none';
          if (trendCanvasEl) {
            trendCanvasEl.style.display = 'block';
            // Force resize after display change to fix canvas sizing
            setTimeout(() => updateTimeseriesCharts(), 10);
          }
          if (kpiSelect) kpiSelect.style.display = 'block';
          const kpiLabelEl = document.getElementById('chart-trend-kpi-label');
          if (kpiLabelEl) kpiLabelEl.style.display = 'inline';
          trendToggle.classList.add('active');
          trendToggle.style.background = 'var(--dark-brand)';
          trendToggle.style.color = '#000';
          clicksToggle.classList.remove('active');
          clicksToggle.style.background = 'var(--dark-panel)';
          clicksToggle.style.color = 'var(--dark-text)';
          
          // Update title and subtitle
          const titleEl = document.getElementById('chart-left-title');
          const subtitleEl = document.getElementById('chart-left-subtitle');
          if (titleEl) titleEl.textContent = 'Weekly Median Change  Selected KPI';
          if (subtitleEl) subtitleEl.textContent = 'Median week-to-week delta across tasks with measurements in that week (scope + filters apply).';
          
          // Update KPI label
          updateKpiLabel();
        });
      }
      
      // Function to update KPI label
      function updateKpiLabel() {
        const kpiLabelValueEl = document.getElementById('chart-trend-kpi-label-value');
        const selectedKpi = window.optimisationModuleState.selectedKpiForTrend || 'ctr_28d';
        const kpiLabelMap = {
          'ctr_28d': 'CTR (pp)',
          'impressions_28d': 'Impressions',
          'clicks_28d': 'Clicks',
          'current_rank': 'Rank',
          'ai_citations': 'AI Citations',
          'opportunity_score': 'Opportunity Score'
        };
        if (kpiLabelValueEl) {
          kpiLabelValueEl.textContent = kpiLabelMap[selectedKpi] || selectedKpi;
        }
      }
      
      // Handle KPI select change
      if (kpiSelect) {
        kpiSelect.value = window.optimisationModuleState.selectedKpiForTrend || 'ctr_28d';
        updateKpiLabel();
        kpiSelect.addEventListener('change', (e) => {
          window.optimisationModuleState.selectedKpiForTrend = e.target.value;
          updateKpiLabel();
          updateTimeseriesCharts();
        });
      }
      
      // Set initial title/subtitle based on current view
      const currentView = window.optimisationModuleState.leftChartView || 'clicks';
      const titleEl = document.getElementById('chart-left-title');
      const subtitleEl = document.getElementById('chart-left-subtitle');
      if (currentView === 'clicks') {
        if (titleEl) titleEl.textContent = 'Estimated Gap to Target (28d)  Clicks Potential';
        if (subtitleEl) subtitleEl.textContent = 'Sum of remaining clicks needed to hit each task\'s objective (traffic KPIs only). This is a target gap, not last-30d performance.';
      } else {
        if (titleEl) titleEl.textContent = 'Weekly Median Change  Selected KPI';
        if (subtitleEl) subtitleEl.textContent = 'Median week-to-week delta across tasks with measurements in that week (scope + filters apply).';
        updateKpiLabel();
      }
    }
    
    // Simple line chart renderer
    function renderLineChart(canvas, data, valueKey, label) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width || canvas.offsetWidth || 400;
      const height = canvas.height || canvas.offsetHeight || 200;
      canvas.width = width;
      canvas.height = height;
      
      ctx.clearRect(0, 0, width, height);
      
      if (!data || data.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No data', width / 2, height / 2);
        return;
      }
      
      const padding = 40;
      const plotWidth = width - padding * 2;
      const plotHeight = height - padding * 2;
      
      const values = data.map(d => d[valueKey] || 0);
      const max = Math.max(...values, 1);
      
      ctx.strokeStyle = '#3b82f6';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      data.forEach((d, idx) => {
        const x = padding + (idx / (data.length - 1 || 1)) * plotWidth;
        const y = padding + plotHeight - ((d[valueKey] || 0) / max) * plotHeight;
        if (idx === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      
      ctx.stroke();
      
      // Draw points
      ctx.fillStyle = '#3b82f6';
      data.forEach((d, idx) => {
        const x = padding + (idx / (data.length - 1 || 1)) * plotWidth;
        const y = padding + plotHeight - ((d[valueKey] || 0) / max) * plotHeight;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      });
    }
    
    // Simple bar chart renderer
    function renderBarChart(canvas, data, valueKey, label) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width || canvas.offsetWidth || 400;
      const height = canvas.height || canvas.offsetHeight || 200;
      canvas.width = width;
      canvas.height = height;
      
      ctx.clearRect(0, 0, width, height);
      
      if (!data || data.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No data', width / 2, height / 2);
        return;
      }
      
      const padding = 40;
      const plotWidth = width - padding * 2;
      const plotHeight = height - padding * 2;
      const barWidth = plotWidth / data.length;
      
      const values = data.map(d => d[valueKey] || 0);
      const max = Math.max(...values.map(Math.abs), 1);
      
      data.forEach((d, idx) => {
        const value = d[valueKey] || 0;
        const barHeight = (Math.abs(value) / max) * plotHeight;
        const x = padding + idx * barWidth;
        const y = padding + plotHeight - barHeight;
        
        ctx.fillStyle = value >= 0 ? '#10b981' : '#ef4444';
        ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
        
        // Label
        ctx.fillStyle = '#333';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        const kpiLabel = d.kpi ? d.kpi.replace(/_/g, ' ').substring(0, 10) : '';
        ctx.fillText(kpiLabel, x + barWidth / 2, height - 5);
      });
    }
    
    // Filter functions for KPI tiles
    window.filterByKPIRAG = function(kpi, rag) {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        return t.objectiveKpiKey === (kpi === 'ctr' ? 'ctr_28d' : null) && t.objectiveRag === rag;
      });
      renderOptimisationTasksTable();
    };
    
    window.filterByRankDelta = function(direction) {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        if (t.objectiveKpiKey !== 'current_rank' || t.delta == null) return false;
        if (direction === 'improved') return t.delta > 0;
        if (direction === 'worse') return t.delta < 0;
        if (direction === 'flat') return t.delta === 0;
        return false;
      });
      renderOptimisationTasksTable();
    };
    
    window.filterByAIGap = function() {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        return t.objectiveKpiKey === 'ai_citations' && t.latestValue === 0;
      });
      renderOptimisationTasksTable();
    };
    
    window.filterByNeedsMeasurement = function() {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        return t.needsMeasurement === true;
      });
      renderOptimisationTasksTable();
    };
    
    window.filterByOverdueCycles = function() {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        return t.objectiveRag === 'overdue';
      });
      renderOptimisationTasksTable();
    };

    // Load task events (B3)

    // Load task events (B3)
    // Render metrics snapshot (baseline + latest + deltas)
    function renderOptimisationMetricsSnapshot(task) {
      const container = document.getElementById('optimisation-metrics-snapshot');
      if (!container) return;

      const baseline = task.baseline_metrics || null;
      const latest = task.latest_metrics || null;

      if (!baseline && !latest) {
        container.innerHTML = '<div style="color: #666; font-style: italic; grid-column: 1 / -1;">No metrics snapshot available yet.</div>';
        return;
      }

      // Helper to format numbers
      const formatNum = (val) => {
        if (val == null) return '';
        if (typeof val === 'number') {
          if (val >= 1000) return (val / 1000).toFixed(1) + 'k';
          return val.toLocaleString();
        }
        return val;
      };

      // Helper to calculate delta
      const calcDelta = (latestVal, baselineVal) => {
        if (latestVal == null || baselineVal == null) return null;
        if (typeof latestVal === 'number' && typeof baselineVal === 'number') {
          return latestVal - baselineVal;
        }
        return null;
      };

      // Helper to format delta with color (handles rank where lower is better)
      const formatDelta = (delta, metricKey) => {
        if (delta == null) return { text: '', color: '#666' };
        // For rank, lower is better (negative delta means improved rank = good)
        if (metricKey === 'current_rank') {
          const absDelta = Math.abs(delta);
          const roundedDelta = Math.round(absDelta * 10) / 10; // Round to 1 decimal place
          if (delta < 0) return { text: `${roundedDelta}`, color: '#10b981' }; // Improved (rank went down = better) - green with up arrow
          if (delta > 0) return { text: `${roundedDelta}`, color: '#ef4444' }; // Worsened (rank went up = worse) - red with down arrow
          return { text: '0', color: '#f59e0b' }; // No change - amber
        }
        // For other metrics, higher is typically better
        if (delta > 0) return { text: `+${formatNum(delta)}`, color: '#10b981' }; // Up - green
        if (delta < 0) return { text: formatNum(delta), color: '#ef4444' }; // Down - red
        return { text: '0', color: '#f59e0b' }; // No change - amber
      };

      // Build metrics table
      const metrics = [
        { label: 'Clicks (28d)', baselineKey: 'gsc_clicks_28d', latestKey: 'gsc_clicks_28d', higherIsBetter: true },
        { label: 'Impressions (28d)', baselineKey: 'gsc_impressions_28d', latestKey: 'gsc_impressions_28d', higherIsBetter: true },
        { label: 'CTR (28d)', baselineKey: 'gsc_ctr_28d', latestKey: 'gsc_ctr_28d', higherIsBetter: true, format: (v) => v != null ? (v * 100).toFixed(2) + '%' : '' },
        { label: 'Current Rank', baselineKey: 'current_rank', latestKey: 'current_rank', higherIsBetter: false },
        { label: 'AI Overview', baselineKey: 'ai_overview', latestKey: 'ai_overview', format: (v) => v ? 'On' : 'Off' },
        { label: 'AI Citations', baselineKey: 'ai_citations', latestKey: 'ai_citations', higherIsBetter: true }
      ];

      let html = `
        <div style="font-weight: 700; padding: 0.5rem; background: var(--dark-panel); border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.9rem; color: var(--dark-text);">Metric</div>
        <div style="font-weight: 700; padding: 0.5rem; background: var(--dark-panel); border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.9rem; color: var(--dark-text);">Baseline</div>
        <div style="font-weight: 700; padding: 0.5rem; background: var(--dark-panel); border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.9rem; color: var(--dark-text);">Latest</div>
      `;

      metrics.forEach(metric => {
        const baselineVal = baseline?.[metric.baselineKey];
        const latestVal = latest?.[metric.latestKey];
        const delta = calcDelta(latestVal, baselineVal);
        const deltaFormatted = formatDelta(delta, metric.latestKey);

        const formatValue = (val) => {
          if (metric.format) return metric.format(val);
          return formatNum(val);
        };

        html += `
          <div style="padding: 0.5rem; border-bottom: 1px solid #e5e7eb; font-weight: 600; font-size: 0.9rem; color: #1e293b;">${metric.label}</div>
          <div style="padding: 0.5rem; border-bottom: 1px solid #e5e7eb; font-weight: 700; font-size: 1rem; color: #1e293b;">${formatValue(baselineVal)}</div>
          <div style="padding: 0.5rem; border-bottom: 1px solid #e5e7eb; font-weight: 700; font-size: 1rem; color: #1e293b;">
            ${formatValue(latestVal)}
            ${delta != null ? `<span style="margin-left: 0.5rem; color: ${deltaFormatted.color} !important; font-weight: 700;">(${deltaFormatted.text})</span>` : ''}
          </div>
        `;
      });

      // Add captured_at timestamps (use created_at from event if captured_at not in metrics)
      const baselineDate = baseline?.captured_at || baseline?.created_at;
      const latestDate = latest?.captured_at || latest?.created_at;
      if (baselineDate || latestDate) {
        html += `
          <div style="padding: 0.5rem; border-top: 2px solid #e5e7eb; font-size: 0.85rem; color: #1e293b; font-weight: 600;">Captured</div>
          <div style="padding: 0.5rem; border-top: 2px solid #e5e7eb; font-size: 0.85rem; color: #1e293b; font-weight: 700;">
            ${baselineDate ? new Date(baselineDate).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' }) : ''}
          </div>
          <div style="padding: 0.5rem; border-top: 2px solid #e5e7eb; font-size: 0.85rem; color: #1e293b; font-weight: 700;">
            ${latestDate ? new Date(latestDate).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' }) : ''}
          </div>
        `;
      }

      container.innerHTML = html;
    }

    // Load and render measurement history for a task
    async function loadOptimisationMeasurementHistory(taskId, cycleId, cycleNo) {
      const container = document.getElementById('optimisation-measurement-history');
      if (!container) return;

      try {
        // Fetch last 10 measurement events for this task (current cycle only)
        const cycleFilter = cycleId ? `&cycle_id=${cycleId}` : (cycleNo ? `&cycle_number=${cycleNo}` : '');
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/events?event_type=measurement&limit=10${cycleFilter}`), {
          headers: window.getOptimisationHeaders()
        });

        if (!response.ok) {
          container.innerHTML = '<div style="color: #ef4444; font-size: 0.875rem;">Failed to load measurement history</div>';
          return;
        }

        const data = await response.json();
        const events = data.events || [];
        
        if (!events || events.length === 0) {
          container.innerHTML = '<div style="color: #666; font-style: italic; font-size: 0.875rem;">No measurements captured yet for this cycle</div>';
          return;
        }

        // Filter to current cycle and sort by created_at descending (most recent first)
        const cycleEvents = events.filter(e => {
          if (cycleId) return e.cycle_id === cycleId;
          if (cycleNo) return e.cycle_number === cycleNo;
          return true;
        }).sort((a, b) => {
          const dateA = new Date(a.created_at || a.event_at || 0);
          const dateB = new Date(b.created_at || b.event_at || 0);
          return dateB - dateA;
        });

        if (cycleEvents.length === 0) {
          container.innerHTML = '<div style="color: #666; font-style: italic; font-size: 0.875rem;">No measurements captured yet for this cycle</div>';
          return;
        }

        // Build history table
        let html = `
          <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
            <thead>
              <tr style="background: #f3f4f6; border-bottom: 2px solid #d1d5db;">
                <th style="padding: 0.5rem; text-align: left; font-weight: 600;">Date</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">Clicks</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">Impr.</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">CTR</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">Rank</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">AI Cit.</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;"> vs Prev</th>
              </tr>
            </thead>
            <tbody>
        `;

        cycleEvents.forEach((event, idx) => {
          const metrics = event.metrics || {};
          const capturedAt = event.created_at || event.event_at || event.metrics?.captured_at;
          const prevEvent = idx < cycleEvents.length - 1 ? cycleEvents[idx + 1] : null;
          const prevMetrics = prevEvent?.metrics || {};

          // Calculate deltas vs previous measurement
          const deltaClicks = metrics.gsc_clicks_28d != null && prevMetrics.gsc_clicks_28d != null 
            ? metrics.gsc_clicks_28d - prevMetrics.gsc_clicks_28d : null;
          const deltaImpr = metrics.gsc_impressions_28d != null && prevMetrics.gsc_impressions_28d != null
            ? metrics.gsc_impressions_28d - prevMetrics.gsc_impressions_28d : null;
          const deltaCTR = metrics.gsc_ctr_28d != null && prevMetrics.gsc_ctr_28d != null
            ? ((metrics.gsc_ctr_28d - prevMetrics.gsc_ctr_28d) * 100).toFixed(2) : null;
          const deltaRank = metrics.current_rank != null && prevMetrics.current_rank != null
            ? metrics.current_rank - prevMetrics.current_rank : null;
          const deltaAICit = metrics.ai_citations != null && prevMetrics.ai_citations != null
            ? metrics.ai_citations - prevMetrics.ai_citations : null;

          const formatDelta = (val, isRank = false) => {
            if (val == null) return '';
            if (isRank) {
              if (val < 0) return `<span style="color: #10b981;">${Math.abs(val)}</span>`;
              if (val > 0) return `<span style="color: #ef4444;">${val}</span>`;
              return '0';
            }
            if (val > 0) return `<span style="color: #10b981;">+${val}</span>`;
            if (val < 0) return `<span style="color: #ef4444;">${val}</span>`;
            return '0';
          };

          html += `
            <tr style="border-bottom: 1px solid #e5e7eb;">
              <td style="padding: 0.5rem; white-space: nowrap;">
                ${capturedAt ? new Date(capturedAt).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' }) : ''}
              </td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.gsc_clicks_28d != null ? metrics.gsc_clicks_28d.toLocaleString() : ''}</td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.gsc_impressions_28d != null ? metrics.gsc_impressions_28d.toLocaleString() : ''}</td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.gsc_ctr_28d != null ? (metrics.gsc_ctr_28d * 100).toFixed(2) + '%' : ''}</td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.current_rank != null ? metrics.current_rank : ''}</td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.ai_citations != null ? metrics.ai_citations : ''}</td>
              <td style="padding: 0.5rem; text-align: right; font-size: 0.8rem;">
                ${prevEvent ? `
                  <div>${formatDelta(deltaClicks)}</div>
                  <div>${formatDelta(deltaImpr)}</div>
                  <div>${formatDelta(deltaCTR)}</div>
                  <div>${formatDelta(deltaRank, true)}</div>
                  <div>${formatDelta(deltaAICit)}</div>
                ` : '<span style="color: #9ca3af;">Baseline</span>'}
              </td>
            </tr>
          `;
        });

        html += `
            </tbody>
          </table>
        `;

        container.innerHTML = html;
      } catch (error) {
        console.error('[Optimisation] Error loading measurement history:', error);
        container.innerHTML = '<div style="color: #ef4444; font-size: 0.875rem;">Error loading measurement history</div>';
      }
    }

    async function loadOptimisationTaskEvents(taskId) {
      const eventsContainer = document.getElementById('optimisation-drawer-events');
      if (!eventsContainer) return;

      try {
        const headers = window.getOptimisationHeaders();
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/events`), {
          method: 'GET',
          headers: headers
        });

        if (!response.ok) {
          throw new Error(`Failed to load events: ${response.status}`);
        }

        const data = await response.json();
        const events = data.events || [];

        if (events.length === 0) {
          eventsContainer.innerHTML = '<div style="color: #666; font-style: italic;">No events yet</div>';
          return;
        }

        eventsContainer.innerHTML = events.map(event => {
          const date = new Date(event.event_at || event.created_at).toLocaleString('en-GB');
          // Format event type for display (replace underscores with spaces, capitalize)
          const eventTypeDisplay = (event.event_type || 'note')
            .replace(/_/g, ' ')
            .replace(/\b\w/g, l => l.toUpperCase());
          // Use different colors for different event types
          let eventColor = '#2563eb'; // Default blue
          if (event.event_type === 'cycle_completed') eventColor = '#10b981'; // Green
          if (event.event_type === 'cycle_archived') eventColor = '#6b7280'; // Grey
          if (event.event_type === 'cycle_start') eventColor = '#3b82f6'; // Blue
          if (event.event_type === 'measurement') eventColor = '#8b5cf6'; // Purple
          if (event.event_type === 'status_changed') eventColor = '#f59e0b'; // Orange
          
          return `
            <div style="margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid #eee;">
              <div style="font-weight: 600; color: ${eventColor};">${escapeHtml(eventTypeDisplay)}</div>
              <div style="color: #666; font-size: 0.875rem; margin-top: 0.25rem;">${date}</div>
              ${event.note ? `<div style="margin-top: 0.5rem;">${escapeHtml(event.note)}</div>` : ''}
            </div>
          `;
        }).join('');
      } catch (error) {
        console.error('[Optimisation Module] Error loading events:', error);
        eventsContainer.innerHTML = '<div style="color: #ef4444;">Error loading events</div>';
      }
    }

    // Initialize Optimisation Tracking module
    function initOptimisationTrackingModule() {
      // Set initial active tab
      if (!window.optimisationModuleState.activeTab) {
        window.optimisationModuleState.activeTab = 'active';
      }
      
      // Update tab button states on init
      document.querySelectorAll('.optimisation-tab-btn').forEach(btn => {
        btn.classList.toggle('metric-pill--active', btn.dataset.tab === window.optimisationModuleState.activeTab);
      });
      
      // Tab button handlers
      document.querySelectorAll('.optimisation-tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          switchOptimisationTab(btn.dataset.tab);
        });
      });

      // Drawer buttons
      const closeBtn = document.getElementById('optimisation-drawer-close');
      if (closeBtn) {
        closeBtn.addEventListener('click', closeOptimisationTaskDrawer);
      }
      
      const closeBottomBtn = document.getElementById('optimisation-drawer-close-bottom');
      if (closeBottomBtn) {
        closeBottomBtn.addEventListener('click', closeOptimisationTaskDrawer);
      }
      
      const minimizeBtn = document.getElementById('optimisation-drawer-minimize');
      if (minimizeBtn) {
        minimizeBtn.addEventListener('click', minimizeOptimisationDrawer);
      }
      
      const maximizeBtn = document.getElementById('optimisation-drawer-maximize');
      if (maximizeBtn) {
        maximizeBtn.addEventListener('click', maximizeOptimisationDrawer);
      }
      
      // Edit Objective button
      const editObjectiveBtn = document.getElementById('optimisation-edit-objective-btn');
      if (editObjectiveBtn) {
        editObjectiveBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (typeof window.editObjective === 'function') {
            window.editObjective();
          }
        });
      }

      // Save Objective button
      const saveObjectiveBtn = document.getElementById('optimisation-save-objective-btn');
      if (saveObjectiveBtn) {
        saveObjectiveBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (typeof window.saveObjective === 'function') {
            window.saveObjective();
          }
        });
      }

      // Cancel Edit Objective button
      const cancelEditObjectiveBtn = document.getElementById('optimisation-cancel-edit-objective-btn');
      if (cancelEditObjectiveBtn) {
        cancelEditObjectiveBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (typeof window.cancelEditObjective === 'function') {
            window.cancelEditObjective();
          }
        });
      }

      // Measurement history toggle
      const measurementHistoryToggle = document.getElementById('optimisation-measurement-history-toggle');
      const measurementHistoryContainer = document.getElementById('optimisation-measurement-history');
      if (measurementHistoryToggle && measurementHistoryContainer) {
        measurementHistoryToggle.addEventListener('click', () => {
          const isVisible = measurementHistoryContainer.style.display !== 'none';
          measurementHistoryContainer.style.display = isVisible ? 'none' : 'block';
          measurementHistoryToggle.textContent = isVisible ? 'Show' : 'Hide';
        });
      }

      // Update due date when timeframe changes
      const timeframeInput = document.getElementById('optimisation-edit-objective-timeframe');
      if (timeframeInput) {
        timeframeInput.addEventListener('input', updateObjectiveDueDate);
      }

      // Backdrop click to close (but not when clicking on drawer)
      const backdrop = document.getElementById('optimisation-task-drawer-backdrop');
      if (backdrop) {
        backdrop.addEventListener('click', (e) => {
          if (e.target === backdrop) {
            closeOptimisationTaskDrawer();
          }
        });
      }
      
      // Initialize dragging
      initOptimisationDrawerDragging();

      // Bulk update button
      const bulkUpdateBtn = document.getElementById('optimisation-bulk-update-btn');
      if (bulkUpdateBtn) {
        bulkUpdateBtn.addEventListener('click', async () => {
          if (typeof window.bulkUpdateAllTasks === 'function') {
            await window.bulkUpdateAllTasks();
          }
        });
      }

      // Timeline toggle (collapsed by default)
      const timelineHeader = document.getElementById('optimisation-timeline-header');
      const timelineToggle = document.getElementById('optimisation-timeline-toggle');
      const timelineContainer = document.getElementById('optimisation-drawer-events-container');
      if (timelineHeader && timelineToggle && timelineContainer) {
        timelineHeader.addEventListener('click', () => {
          const isCollapsed = timelineContainer.style.display === 'none';
          timelineContainer.style.display = isCollapsed ? 'block' : 'none';
          timelineToggle.textContent = isCollapsed ? '' : '';
        });
        // Ensure it starts collapsed
        timelineContainer.style.display = 'none';
        timelineToggle.textContent = '';
      }

      // Filter handlers
      const filterStatus = document.getElementById('optimisation-filter-status');
      const filterType = document.getElementById('optimisation-filter-type');
      const filterKeyword = document.getElementById('optimisation-filter-keyword');
      const filterUrl = document.getElementById('optimisation-filter-url');
      const clearFilters = document.getElementById('optimisation-clear-filters');

      const applyFilters = () => {
        // Apply base filters (test tasks, keyword, url, type, status, metric traffic)
        applyOptimisationFilters();
        
        // Apply additional button filters on top of base filters
        let filtered = [...window.optimisationModuleState.filteredTasks];
        
        // Apply status/type/keyword/url filters (using field name variations)
        if (filterStatus && filterStatus.value) {
          filtered = filtered.filter(t => t.status === filterStatus.value);
        }
        if (filterType && filterType.value) {
          filtered = filtered.filter(t => t.task_type === filterType.value);
        }
        if (filterKeyword && filterKeyword.value) {
          const keyword = filterKeyword.value.toLowerCase();
          filtered = filtered.filter(t => 
            (t.keyword_text || t.keyword || '').toLowerCase().includes(keyword)
          );
        }
        if (filterUrl && filterUrl.value) {
          const url = filterUrl.value.toLowerCase();
          filtered = filtered.filter(t => 
            (t.target_url_clean || t.target_url || '').toLowerCase().includes(url)
          );
        }
        
        // "Needs Update" filter: tasks with no measurement or measurement older than 30 days
        const needsUpdateBtn = document.getElementById('optimisation-filter-needs-update');
        if (needsUpdateBtn && needsUpdateBtn.classList.contains('active')) {
          const thirtyDaysAgo = new Date();
          thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
          
          filtered = filtered.filter(t => {
            // Check if task has latest_metrics
            if (!t.latest_metrics) {
              return true; // No measurement = needs update
            }
            
            // Check captured_at from latest_metrics
            const capturedAt = t.latest_metrics.captured_at;
            if (!capturedAt) {
              return true; // No capture date = needs update
            }
            
            const latestCapturedDate = new Date(capturedAt);
            return latestCapturedDate < thirtyDaysAgo; // Older than 30 days = needs update
          });
        }
        
        // "Active Cycle Only" filter: tasks with an active cycle (not completed/archived)
        const activeCycleBtn = document.getElementById('optimisation-filter-active-cycle');
        if (activeCycleBtn && activeCycleBtn.classList.contains('active')) {
          filtered = filtered.filter(t => {
            return t.active_cycle_id != null; // Has an active cycle
          });
        }
        
        // "Overdue Cycle" filter: tasks with overdue current cycle
        const overdueCycleBtn = document.getElementById('optimisation-filter-overdue-cycle');
        if (overdueCycleBtn && overdueCycleBtn.classList.contains('active')) {
          filtered = filtered.filter(t => {
            // Check if current cycle is overdue
            const status = t.objective_status || t.goal_state;
            return status === 'overdue';
          });
        }

        window.optimisationModuleState.filteredTasks = filtered;
        // Reset pagination when filters change
        optimisationPaginationState.currentPage = 1;
        updateTrafficLights(); // Update traffic lights when filters change
        updateTrafficLightVisuals(); // Update visual state of pills
        updateTimeseriesCharts(); // Update charts with filtered data
        renderOptimisationTasksTable();
      };

      if (filterStatus) filterStatus.addEventListener('change', applyFilters);
      if (filterType) filterType.addEventListener('change', applyFilters);
      if (filterKeyword) filterKeyword.addEventListener('input', applyFilters);
      if (filterUrl) filterUrl.addEventListener('input', applyFilters);
      
      // Attach click handlers to all traffic light pills (for pills that don't have onclick yet)
      setTimeout(() => {
        const metricMap = {
          'objective-impressions': 'impressions_28d',
          'objective-clicks': 'clicks_28d',
          'objective-rank': 'current_rank',
          'objective-ai-citations': 'ai_citations',
          'objective-ai-overview': 'ai_overview'
        };
        
        for (const [prefix, metricKey] of Object.entries(metricMap)) {
          const worseEl = document.getElementById(`${prefix}-red`);
          const sameEl = document.getElementById(`${prefix}-amber`);
          const betterEl = document.getElementById(`${prefix}-green`);
          
          if (worseEl && !worseEl.closest('.traffic-light-pill')) {
            const pill = worseEl.closest('div[style*="background"]');
            if (pill) {
              pill.classList.add('traffic-light-pill');
              pill.dataset.metric = metricKey;
              pill.dataset.bucket = 'worse';
              pill.style.background = 'rgba(239, 68, 68, 0.2)';
              pill.onclick = () => handleTrafficLightClick(metricKey, 'worse');
              // Remove any inline hover handlers - CSS handles it now
              pill.removeAttribute('onmouseover');
              pill.removeAttribute('onmouseout');
            }
          }
          
          if (sameEl && !sameEl.closest('.traffic-light-pill')) {
            const pill = sameEl.closest('div[style*="background"]');
            if (pill) {
              pill.classList.add('traffic-light-pill');
              pill.dataset.metric = metricKey;
              pill.dataset.bucket = 'same';
              pill.style.background = 'rgba(245, 158, 11, 0.2)';
              pill.onclick = () => handleTrafficLightClick(metricKey, 'same');
              // Remove any inline hover handlers - CSS handles it now
              pill.removeAttribute('onmouseover');
              pill.removeAttribute('onmouseout');
            }
          }
          
          if (betterEl && !betterEl.closest('.traffic-light-pill')) {
            const pill = betterEl.closest('div[style*="background"]');
            if (pill) {
              pill.classList.add('traffic-light-pill');
              pill.dataset.metric = metricKey;
              pill.dataset.bucket = 'better';
              pill.style.background = 'rgba(16, 185, 129, 0.2)';
              pill.onclick = () => handleTrafficLightClick(metricKey, 'better');
              // Remove any inline hover handlers - CSS handles it now
              pill.removeAttribute('onmouseover');
              pill.removeAttribute('onmouseout');
            }
          }
        }
        
        // Update visual state on initial load
        updateTrafficLightVisuals();
      }, 100);
      
      const needsUpdateBtn = document.getElementById('optimisation-filter-needs-update');
      if (needsUpdateBtn) {
        needsUpdateBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('[Optimisation] Needs Update button clicked');
          needsUpdateBtn.classList.toggle('active');
          if (needsUpdateBtn.classList.contains('active')) {
            needsUpdateBtn.style.background = '#3b82f6';
            needsUpdateBtn.style.color = '#ffffff';
          } else {
            needsUpdateBtn.style.background = '';
            needsUpdateBtn.style.color = '';
          }
          console.log('[Optimisation] Needs Update filter active:', needsUpdateBtn.classList.contains('active'));
          applyFilters();
        });
      } else {
        console.error('[Optimisation] Needs Update button not found!');
      }
      
      // Active Cycle Only filter button
      const activeCycleBtn = document.getElementById('optimisation-filter-active-cycle');
      if (activeCycleBtn) {
        activeCycleBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          activeCycleBtn.classList.toggle('active');
          if (activeCycleBtn.classList.contains('active')) {
            activeCycleBtn.style.background = '#3b82f6';
            activeCycleBtn.style.color = '#ffffff';
          } else {
            activeCycleBtn.style.background = '';
            activeCycleBtn.style.color = '';
          }
          applyFilters();
        });
      }
      
      // Overdue Cycle filter button
      const overdueCycleBtn = document.getElementById('optimisation-filter-overdue-cycle');
      if (overdueCycleBtn) {
        overdueCycleBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          overdueCycleBtn.classList.toggle('active');
          if (overdueCycleBtn.classList.contains('active')) {
            overdueCycleBtn.style.background = '#ef4444';
            overdueCycleBtn.style.color = '#ffffff';
          } else {
            overdueCycleBtn.style.background = '';
            overdueCycleBtn.style.color = '';
          }
          applyFilters();
        });
      }
      
      // Objective filter pills
      const goalNotSet = document.getElementById('optimisation-goal-filter-not-set');
      const goalOnTrack = document.getElementById('optimisation-goal-filter-on-track');
      const goalOverdue = document.getElementById('optimisation-goal-filter-overdue');
      const goalMet = document.getElementById('optimisation-goal-filter-met');
      
      const updateObjectiveFilterUI = () => {
        const active = window.optimisationModuleState.activeObjectiveFilter;
        [goalNotSet, goalOnTrack, goalOverdue, goalMet].forEach((el, idx) => {
          if (!el) return;
          const states = ['not_set', 'on_track', 'overdue', 'met'];
          if (active === states[idx]) {
            el.style.opacity = '1';
            el.style.fontWeight = '600';
            el.style.border = '2px solid #3b82f6';
          } else {
            el.style.opacity = active ? '0.6' : '1';
            el.style.fontWeight = '';
            el.style.border = '';
          }
        });
      };
      
      if (goalNotSet) {
        goalNotSet.addEventListener('click', () => {
          if (window.optimisationModuleState.activeObjectiveFilter === 'not_set') {
            window.optimisationModuleState.activeObjectiveFilter = null;
          } else {
            window.optimisationModuleState.activeObjectiveFilter = 'not_set';
          }
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      if (goalOnTrack) {
        goalOnTrack.addEventListener('click', () => {
          if (window.optimisationModuleState.activeObjectiveFilter === 'on_track') {
            window.optimisationModuleState.activeObjectiveFilter = null;
          } else {
            window.optimisationModuleState.activeObjectiveFilter = 'on_track';
          }
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      if (goalOverdue) {
        goalOverdue.addEventListener('click', () => {
          if (window.optimisationModuleState.activeObjectiveFilter === 'overdue') {
            window.optimisationModuleState.activeObjectiveFilter = null;
          } else {
            window.optimisationModuleState.activeObjectiveFilter = 'overdue';
          }
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      if (goalMet) {
        goalMet.addEventListener('click', () => {
          if (window.optimisationModuleState.activeObjectiveFilter === 'met') {
            window.optimisationModuleState.activeObjectiveFilter = null;
          } else {
            window.optimisationModuleState.activeObjectiveFilter = 'met';
          }
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      
      if (clearFilters) {
        clearFilters.addEventListener('click', () => {
          if (filterStatus) filterStatus.value = '';
          if (filterType) filterType.value = '';
          if (filterKeyword) filterKeyword.value = '';
          if (filterUrl) filterUrl.value = '';
          // Clear metric traffic filter
          window.optimisationModuleState.metricTrafficFilter = null;
          updateTrafficLightVisuals();
          if (needsUpdateBtn) {
            needsUpdateBtn.classList.remove('active');
            needsUpdateBtn.style.background = '';
            needsUpdateBtn.style.color = '';
          }
          const activeCycleBtn = document.getElementById('optimisation-filter-active-cycle');
          if (activeCycleBtn) {
            activeCycleBtn.classList.remove('active');
            activeCycleBtn.style.background = '';
            activeCycleBtn.style.color = '';
          }
          const overdueCycleBtn = document.getElementById('optimisation-filter-overdue-cycle');
          if (overdueCycleBtn) {
            overdueCycleBtn.classList.remove('active');
            overdueCycleBtn.style.background = '';
            overdueCycleBtn.style.color = '';
          }
          const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
          if (includeTestCheckbox) {
            includeTestCheckbox.checked = false;
          }
          window.optimisationModuleState.activeObjectiveFilter = null;
          window.optimisationModuleState.trafficKpiOnly = false;
          window.optimisationModuleState.clickRelatedOnly = false;
          updateObjectiveFilterUI();
          applyFilters();
          updateImpactTiles();
        });
      }
      
      // Include test tasks checkbox
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (includeTestCheckbox) {
        includeTestCheckbox.addEventListener('change', () => {
          applyFilters();
          updateOptimisationSummaryCards();
          updateKPITiles();
          updateImpactTiles();
          updateTimeseriesCharts();
        });
      }
      
      // Hero tile click handlers
      const potentialClicksCard = document.getElementById('impact-potential-clicks-card');
      const potentialClicksClear = document.getElementById('impact-potential-clicks-clear');
      if (potentialClicksCard) {
        potentialClicksCard.addEventListener('click', (e) => {
          // Don't trigger if clicking the clear button
          if (e.target === potentialClicksClear || e.target.closest('#impact-potential-clicks-clear')) {
            return;
          }
          
          // Toggle trafficKpiOnly filter
          window.optimisationModuleState.trafficKpiOnly = !window.optimisationModuleState.trafficKpiOnly;
          window.optimisationModuleState.clickRelatedOnly = false; // Clear the other filter
          
          // Clear metric traffic filter (conflicting)
          window.optimisationModuleState.metricTrafficFilter = null;
          
          updateImpactTiles();
          applyOptimisationFilters();
          renderOptimisationTasksTable();
          updateTimeseriesCharts();
        });
      }
      
      if (potentialClicksClear) {
        potentialClicksClear.addEventListener('click', (e) => {
          e.stopPropagation();
          window.optimisationModuleState.trafficKpiOnly = false;
          updateImpactTiles();
          applyOptimisationFilters();
          renderOptimisationTasksTable();
          updateTimeseriesCharts();
        });
      }
      
      const actualClicksCard = document.getElementById('impact-actual-clicks-card');
      const actualClicksClear = document.getElementById('impact-actual-clicks-clear');
      if (actualClicksCard) {
        actualClicksCard.addEventListener('click', (e) => {
          // Don't trigger if clicking the clear button
          if (e.target === actualClicksClear || e.target.closest('#impact-actual-clicks-clear')) {
            return;
          }
          
          // Toggle clickRelatedOnly filter
          window.optimisationModuleState.clickRelatedOnly = !window.optimisationModuleState.clickRelatedOnly;
          window.optimisationModuleState.trafficKpiOnly = false; // Clear the other filter
          
          // Clear metric traffic filter (conflicting)
          window.optimisationModuleState.metricTrafficFilter = null;
          
          updateImpactTiles();
          applyOptimisationFilters();
          renderOptimisationTasksTable();
          updateTimeseriesCharts();
        });
      }
      
      if (actualClicksClear) {
        actualClicksClear.addEventListener('click', (e) => {
          e.stopPropagation();
          window.optimisationModuleState.clickRelatedOnly = false;
          updateImpactTiles();
          applyOptimisationFilters();
          renderOptimisationTasksTable();
          updateTimeseriesCharts();
        });
      }
      
      // Scope toggle
      const scopeSelect = document.getElementById('optimisation-scope-select');
      const scopeDescription = document.getElementById('optimisation-scope-description');
      if (scopeSelect) {
        scopeSelect.value = window.optimisationModuleState.scope || 'active_cycle';
        scopeSelect.addEventListener('change', () => {
          window.optimisationModuleState.scope = scopeSelect.value;
          if (scopeDescription) {
            scopeDescription.textContent = scopeSelect.value === 'active_cycle' 
              ? 'Showing metrics for tasks with active cycles only'
              : 'Showing metrics for all tasks';
          }
          // Update impact tiles immediately (they depend on scope)
          updateImpactTiles();
          // Then reload all tasks (which will also call updateImpactTiles, but this ensures immediate update)
          window.loadAllOptimisationTasks();
        });
        if (scopeDescription) {
          scopeDescription.textContent = scopeSelect.value === 'active_cycle' 
            ? 'Showing metrics for tasks with active cycles only'
            : 'Showing metrics for all tasks';
        }
      }

      // Drawer action handlers
      const addEventBtn = document.getElementById('optimisation-add-event-btn');
      if (addEventBtn) {
        addEventBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          const eventType = document.getElementById('optimisation-event-type').value;
          const note = document.getElementById('optimisation-event-note').value;

          if (!note.trim()) {
            alert('Please enter a note');
            return;
          }

          try {
            const headers = window.getOptimisationHeaders();
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/event`), {
              method: 'POST',
              headers: headers,
              body: JSON.stringify({ event_type: eventType, note })
            });

            if (!response.ok) throw new Error('Failed to add event');

            document.getElementById('optimisation-event-note').value = '';
            await loadOptimisationTaskEvents(taskId);
            await window.loadAllOptimisationTasks();
            
            // If it was a measurement event, refresh the modal to update badge with fresh goal_state
            if (eventType === 'measurement') {
              if (typeof debugLog === 'function') {
                debugLog(`[Optimisation] Measurement added, refreshing modal to update badge state`, 'info');
              }
              await openOptimisationTaskDrawer(taskId);
            }
          } catch (error) {
            if (typeof debugLog === 'function') {
              debugLog(`[Optimisation] Error adding event: ${error.message}`, 'error');
            }
            console.error('[Optimisation Module] Error adding event:', error);
            alert('Failed to add event: ' + error.message);
          }
        });
      }

      const saveStatusBtn = document.getElementById('optimisation-save-status-btn');
      if (saveStatusBtn) {
        saveStatusBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          const newStatus = document.getElementById('optimisation-change-status').value;
          if (!newStatus) {
            alert('Please select a status');
            return;
          }

          try {
            await window.submitStatusChange(newStatus, taskId);
            await window.loadAllOptimisationTasks();
            await openOptimisationTaskDrawer(taskId);
          } catch (error) {
            console.error('[Optimisation Module] Error changing status:', error);
            alert('Failed to change status: ' + error.message);
          }
        });
      }

      // Complete Cycle button
      const completeCycleBtn = document.getElementById('optimisation-complete-cycle-btn');
      if (completeCycleBtn) {
        completeCycleBtn.addEventListener('click', async () => {
          // Get task ID from state
          let taskId = window.optimisationModuleState?.currentTaskId;
          
          // If not in state, try to get from the drawer's displayed content
          if (!taskId && window.optimisationModuleState?.allTasks?.length > 0) {
            // Find the task that has an active cycle (most likely the one being viewed)
            const taskWithActiveCycle = window.optimisationModuleState.allTasks.find(t => t.active_cycle_id);
            if (taskWithActiveCycle) {
              taskId = taskWithActiveCycle.id;
            }
          }
          
          if (!taskId) {
            alert('No task selected. Please open a task first.');
            return;
          }

          const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
          if (!task) {
            alert('Task not found. Please refresh the page.');
            return;
          }
          
          if (!task.active_cycle_id) {
            alert('No active cycle to complete');
            return;
          }

          if (!confirm(`Complete Cycle ${task.cycle_no || task.cycle_active || 'current'}? This will close the cycle and mark it as completed.`)) {
            return;
          }

          try {
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/cycle/complete`), {
              method: 'POST',
              headers: { ...window.getOptimisationHeaders(), 'Content-Type': 'application/json' },
              body: JSON.stringify({
                action: 'complete',
                cycle_id: task.active_cycle_id
              })
            });

            if (!response.ok) {
              const error = await response.json().catch(() => ({ error: 'Unknown error' }));
              throw new Error(error.error || 'Failed to complete cycle');
            }

            const result = await response.json();
            console.log('[Optimisation] Cycle completed successfully:', result);
            
            // Update task in state
            const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
            if (taskIndex >= 0 && result.task) {
              window.optimisationModuleState.allTasks[taskIndex] = result.task;
            }

            // Reload tasks to get fresh data
            if (typeof window.loadAllOptimisationTasks === 'function') {
              await window.loadAllOptimisationTasks();
            }
            
            // Refresh drawer if it's still open for this task
            if (window.optimisationModuleState.currentTaskId === taskId) {
              if (typeof window.openOptimisationTaskDrawer === 'function') {
                await window.openOptimisationTaskDrawer(taskId);
              }
            }

            // Refresh table
            if (typeof renderOptimisationTasksTable === 'function') {
              renderOptimisationTasksTable();
            }
            
            // Show success message
            alert(`Cycle ${task.cycle_no || task.cycle_active || 'current'} has been completed successfully.`);
          } catch (error) {
            console.error('[Optimisation] Error completing cycle:', error);
            alert('Failed to complete cycle: ' + error.message);
          }
        });
      }

      // Archive Cycle button
      const archiveCycleBtn = document.getElementById('optimisation-archive-cycle-btn');
      if (archiveCycleBtn) {
        archiveCycleBtn.addEventListener('click', async () => {
          // Get task ID from state
          let taskId = window.optimisationModuleState?.currentTaskId;
          
          // If not in state, try to get from the drawer's displayed content
          if (!taskId && window.optimisationModuleState?.allTasks?.length > 0) {
            // Find the task that has an active cycle (most likely the one being viewed)
            const taskWithActiveCycle = window.optimisationModuleState.allTasks.find(t => t.active_cycle_id);
            if (taskWithActiveCycle) {
              taskId = taskWithActiveCycle.id;
            }
          }
          
          if (!taskId) {
            alert('No task selected. Please open a task first.');
            return;
          }

          const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
          if (!task) {
            alert('Task not found. Please refresh the page.');
            return;
          }
          
          if (!task.active_cycle_id) {
            alert('No active cycle to archive');
            return;
          }

          if (!confirm(`Archive Cycle ${task.cycle_no || task.cycle_active || 'current'}? This will mark the cycle as archived (for abandoned work).`)) {
            return;
          }

          try {
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/cycle/complete`), {
              method: 'POST',
              headers: { ...window.getOptimisationHeaders(), 'Content-Type': 'application/json' },
              body: JSON.stringify({
                action: 'archive',
                cycle_id: task.active_cycle_id
              })
            });

            if (!response.ok) {
              const error = await response.json().catch(() => ({ error: 'Unknown error' }));
              throw new Error(error.error || 'Failed to archive cycle');
            }

            const result = await response.json();
            console.log('[Optimisation] Cycle archived successfully:', result);
            
            // Update task in state
            const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
            if (taskIndex >= 0 && result.task) {
              window.optimisationModuleState.allTasks[taskIndex] = result.task;
            }

            // Reload tasks to get fresh data
            if (typeof window.loadAllOptimisationTasks === 'function') {
              await window.loadAllOptimisationTasks();
            }
            
            // Refresh drawer if it's still open for this task
            if (window.optimisationModuleState.currentTaskId === taskId) {
              if (typeof window.openOptimisationTaskDrawer === 'function') {
                await window.openOptimisationTaskDrawer(taskId);
              }
            }

            // Refresh table
            if (typeof renderOptimisationTasksTable === 'function') {
              renderOptimisationTasksTable();
            }
            
            // Show success message
            alert(`Cycle ${task.cycle_no || task.cycle_active || 'current'} has been archived successfully.`);
          } catch (error) {
            console.error('[Optimisation] Error archiving cycle:', error);
            alert('Failed to archive cycle: ' + error.message);
          }
        });
      }

      const startCycleBtn = document.getElementById('optimisation-start-cycle-btn');
      if (startCycleBtn) {
        startCycleBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          try {
            await window.startNewCycle();
            await window.loadAllOptimisationTasks();
            await openOptimisationTaskDrawer(taskId);
          } catch (error) {
            console.error('[Optimisation Module] Error starting cycle:', error);
            alert('Failed to start cycle: ' + error.message);
          }
        });
      }

      const cancelTaskBtn = document.getElementById('optimisation-cancel-task-btn');
      if (cancelTaskBtn) {
        cancelTaskBtn.addEventListener('click', async () => {
          if (!confirm('Cancel this task? It will be marked as cancelled but history will be preserved.')) {
            return;
          }

          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          try {
            await window.stopTracking();
            await window.loadAllOptimisationTasks();
            closeOptimisationTaskDrawer();
          } catch (error) {
            console.error('[Optimisation Module] Error cancelling task:', error);
            alert('Failed to cancel task: ' + error.message);
          }
        });
      }

      const deleteTaskBtn = document.getElementById('optimisation-delete-task-btn');
      if (deleteTaskBtn) {
        deleteTaskBtn.addEventListener('click', async () => {
          try {
            await window.deleteTask();
          } catch (error) {
            alert('Failed to delete task: ' + error.message);
          }

          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          try {
            await window.deleteTask();
            await window.loadAllOptimisationTasks();
            // Refresh Ranking & AI table if it's visible
            if (typeof window.renderRankingAiTab === 'function') {
              await window.renderRankingAiTab();
            }
            closeOptimisationTaskDrawer();
          } catch (error) {
            console.error('[Optimisation Module] Error deleting task:', error);
            alert('Failed to delete task: ' + error.message);
          }
        });
      }

      const addMeasurementBtn = document.getElementById('optimisation-add-measurement-btn');
      if (addMeasurementBtn) {
        addMeasurementBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          // Try to get current row data from Ranking & AI table if available
          const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
          if (!task) {
            alert('Task not found. Please refresh the page.');
            return;
          }

          // Try to ensure Ranking & AI data is loaded
          if (typeof window.renderRankingAiTab === 'function') {
            try {
              await window.renderRankingAiTab();
              // Small delay to let data load
              await new Promise(resolve => setTimeout(resolve, 500));
            } catch (e) {
              console.warn('[Optimisation] Could not refresh Ranking & AI data:', e);
            }
          }

          // Try to find matching row in Ranking & AI data
          let currentMetrics = null;
          let matchingRow = null;
          
          // First try RankingAiModule state
          if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
            const { combinedRows } = RankingAiModule.state();
            console.log('[Optimisation] Searching in combinedRows:', combinedRows?.length, 'rows');
            
            // Normalize URLs for comparison
            const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
            const taskUrlPath = taskUrlClean.includes('/') ? taskUrlClean.split('/').slice(1).join('/') : '';
            
            matchingRow = combinedRows?.find(r => {
              const keywordMatch = (r.keyword || '').toLowerCase() === (task.keyword_text || '').toLowerCase();
              if (!keywordMatch) return false;
              
              // Try multiple URL matching strategies
              const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
              const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
              const rowUrlPath = rowUrlClean.includes('/') ? rowUrlClean.split('/').slice(1).join('/') : '';
              
              return rowUrl === taskUrlClean || 
                     rowUrlClean === taskUrlClean ||
                     rowUrlPath === taskUrlPath ||
                     rowUrl.includes(taskUrlClean) ||
                     taskUrlClean.includes(rowUrlClean);
            });
            
            console.log('[Optimisation] Found matching row:', matchingRow ? 'YES' : 'NO', { 
              taskKeyword: task.keyword_text, 
              taskUrl: task.target_url_clean || task.target_url,
              matchingRowKeyword: matchingRow?.keyword,
              matchingRowUrl: matchingRow?.best_url || matchingRow?.targetUrl
            });
            
            if (matchingRow) {
              // Get queryTotal data for clicks, impressions, and CTR (same as submitTrackKeyword)
              let queryTotal = null;
              if (typeof getQueryTotalForKeyword === 'function') {
                queryTotal = getQueryTotalForKeyword(task.keyword_text);
              }
              
              currentMetrics = {
                gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
                gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
                // queryTotal.ctr is a percentage (0-100), convert to decimal for storage
                gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
                current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
                opportunity_score: matchingRow.opportunityScore || null,
                ai_overview: matchingRow.has_ai_overview || false,
                ai_citations: matchingRow.ai_alan_citations_count || 0,
                ai_citations_total: matchingRow.ai_total_citations || 0,
                classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
                page_type: matchingRow.pageType || null,
                segment: matchingRow.segment || null,
                captured_at: new Date().toISOString()
              };
            }
          }
          
          // If still no data, try to get from window.rankingAiData
          if (!matchingRow && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
            console.log('[Optimisation] Searching in window.rankingAiData:', window.rankingAiData.length, 'rows');
            
            const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
            const taskUrlPath = taskUrlClean.includes('/') ? taskUrlClean.split('/').slice(1).join('/') : '';
            
            matchingRow = window.rankingAiData.find(r => {
              const keywordMatch = (r.keyword || '').toLowerCase() === (task.keyword_text || '').toLowerCase();
              if (!keywordMatch) return false;
              
              const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
              const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
              const rowUrlPath = rowUrlClean.includes('/') ? rowUrlClean.split('/').slice(1).join('/') : '';
              
              return rowUrl === taskUrlClean || 
                     rowUrlClean === taskUrlClean ||
                     rowUrlPath === taskUrlPath ||
                     rowUrl.includes(taskUrlClean) ||
                     taskUrlClean.includes(rowUrlClean);
            });
            
            console.log('[Optimisation] Found matching row in window.rankingAiData:', matchingRow ? 'YES' : 'NO');
            
          }
          
          // Build metrics from matching row if found
          if (matchingRow) {
            // Get queryTotal data for clicks, impressions, and CTR (same as submitTrackKeyword)
            let queryTotal = null;
            if (typeof getQueryTotalForKeyword === 'function') {
              queryTotal = getQueryTotalForKeyword(task.keyword_text);
              console.log('[Optimisation] QueryTotal for keyword:', queryTotal);
            }
            
            currentMetrics = {
              gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
              gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
              // queryTotal.ctr is a percentage (0-100), convert to decimal for storage
              gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
              current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
              opportunity_score: matchingRow.opportunityScore || null,
              ai_overview: matchingRow.has_ai_overview || false,
              ai_citations: matchingRow.ai_alan_citations_count || 0,
              ai_citations_total: matchingRow.ai_total_citations || 0,
              classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
              page_type: matchingRow.pageType || null,
              segment: matchingRow.segment || null,
              captured_at: new Date().toISOString()
            };
            
            console.log('[Optimisation] Built currentMetrics from matching row:', currentMetrics);
          }

          // If no current data from Ranking & AI, try Money Pages data
          if (!currentMetrics) {
            console.log('[Optimisation] No Ranking & AI data found, checking Money Pages data...');
            const taskUrl = task.target_url_clean || task.target_url || '';
            const taskKeyword = task.keyword_text || '';
            const normalizedTaskUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(taskUrl) : taskUrl.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
            
            // Check window.moneyPagesMetrics
            if (window.moneyPagesMetrics && window.moneyPagesMetrics.rows) {
              const moneyPageRow = window.moneyPagesMetrics.rows.find(row => {
                const rowUrl = row.url || row.page_url || '';
                const normalizedRowUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(rowUrl) : rowUrl.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                return normalizedRowUrl === normalizedTaskUrl || 
                       normalizedRowUrl.includes(normalizedTaskUrl) ||
                       normalizedTaskUrl.includes(normalizedRowUrl);
              });
              
              if (moneyPageRow) {
                console.log('[Optimisation] Found matching Money Page row:', moneyPageRow);
                // Normalize CTR: Money Pages stores CTR as ratio (0-1), but check if it's actually a percentage
                let ctrValue = moneyPageRow.ctr || moneyPageRow.ctr_28d || null;
                if (ctrValue != null) {
                  // If CTR is > 1, assume it's a percentage and convert to ratio
                  if (ctrValue > 1 && ctrValue <= 100) {
                    console.warn('[Optimisation] Money Pages CTR appears to be percentage, converting to ratio:', ctrValue, '->', ctrValue / 100);
                    ctrValue = ctrValue / 100;
                  } else if (ctrValue > 100) {
                    console.error('[Optimisation] Money Pages CTR value seems invalid (>100%):', ctrValue);
                    ctrValue = null;
                  }
                  // If CTR is <= 1, assume it's already a ratio (0-1)
                }
                currentMetrics = {
                  gsc_clicks_28d: moneyPageRow.clicks || moneyPageRow.clicks_28d || null,
                  gsc_impressions_28d: moneyPageRow.impressions || moneyPageRow.impressions_28d || null,
                  gsc_ctr_28d: ctrValue, // Normalized to ratio (0-1)
                  current_rank: moneyPageRow.avg_position || moneyPageRow.position || null,
                  opportunity_score: null,
                  ai_overview: false,
                  ai_citations: 0,
                  ai_citations_total: 0,
                  classic_ranking_url: moneyPageRow.url || moneyPageRow.page_url || taskUrl,
                  page_type: moneyPageRow.page_type || moneyPageRow.type || null,
                  segment: 'money_pages',
                  captured_at: new Date().toISOString()
                };
                console.log('[Optimisation] Built currentMetrics from Money Page row:', currentMetrics);
              }
            }
            
            // If still no data, check localStorage/Supabase audit results
            if (!currentMetrics) {
              console.log('[Optimisation] Checking localStorage/Supabase audit results...');
              try {
                const savedAudit = localStorage.getItem('aigeo_audit_data');
                if (savedAudit) {
                  const parsed = JSON.parse(savedAudit);
                  const moneyPagesData = parsed.scores?.moneyPagesMetrics || parsed.moneyPagesMetrics;
                  
                  if (moneyPagesData && moneyPagesData.rows) {
                    const moneyPageRow = moneyPagesData.rows.find(row => {
                      const rowUrl = row.url || row.page_url || '';
                      const normalizedRowUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(rowUrl) : rowUrl.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                      return normalizedRowUrl === normalizedTaskUrl || 
                             normalizedRowUrl.includes(normalizedTaskUrl) ||
                             normalizedTaskUrl.includes(normalizedRowUrl);
                    });
                    
                    if (moneyPageRow) {
                      console.log('[Optimisation] Found matching Money Page row in localStorage:', moneyPageRow);
                      // Normalize CTR: Money Pages stores CTR as ratio (0-1), but check if it's actually a percentage
                      let ctrValue = moneyPageRow.ctr || moneyPageRow.ctr_28d || null;
                      if (ctrValue != null) {
                        // If CTR is > 1, assume it's a percentage and convert to ratio
                        if (ctrValue > 1 && ctrValue <= 100) {
                          console.warn('[Optimisation] Money Pages CTR appears to be percentage, converting to ratio:', ctrValue, '->', ctrValue / 100);
                          ctrValue = ctrValue / 100;
                        } else if (ctrValue > 100) {
                          console.error('[Optimisation] Money Pages CTR value seems invalid (>100%):', ctrValue);
                          ctrValue = null;
                        }
                        // If CTR is <= 1, assume it's already a ratio (0-1)
                      }
                      currentMetrics = {
                        gsc_clicks_28d: moneyPageRow.clicks || moneyPageRow.clicks_28d || null,
                        gsc_impressions_28d: moneyPageRow.impressions || moneyPageRow.impressions_28d || null,
                        gsc_ctr_28d: ctrValue, // Normalized to ratio (0-1)
                        current_rank: moneyPageRow.avg_position || moneyPageRow.position || null,
                        opportunity_score: null,
                        ai_overview: false,
                        ai_citations: 0,
                        ai_citations_total: 0,
                        classic_ranking_url: moneyPageRow.url || moneyPageRow.page_url || taskUrl,
                        page_type: moneyPageRow.page_type || moneyPageRow.type || null,
                        segment: 'money_pages',
                        captured_at: new Date().toISOString()
                      };
                      console.log('[Optimisation] Built currentMetrics from localStorage Money Page row:', currentMetrics);
                    }
                  }
                  
                  // Also check searchData.queryTotals for URL-based matching
                  if (!currentMetrics && parsed.searchData && parsed.searchData.queryTotals) {
                    // Find query totals that match the URL (for page-level tasks) OR keyword (for keyword-based tasks)
                    const matchingQueries = parsed.searchData.queryTotals.filter(qt => {
                      // URL-based matching (for page-level tasks)
                      if (normalizedTaskUrl && normalizedTaskUrl.length > 0) {
                        const qtUrl = (qt.best_url || qt.targetUrl || '').toLowerCase();
                        const normalizedQtUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(qtUrl) : qtUrl.replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                        if (normalizedQtUrl === normalizedTaskUrl || 
                            normalizedQtUrl.includes(normalizedTaskUrl) ||
                            normalizedTaskUrl.includes(normalizedQtUrl)) {
                          return true;
                        }
                      }
                      // Keyword-based matching (for keyword-based tasks)
                      if (taskKeyword && taskKeyword.length > 0) {
                        const qtKeyword = (qt.query || qt.keyword || '').toLowerCase();
                        if (qtKeyword === taskKeyword.toLowerCase()) {
                          return true;
                        }
                      }
                      return false;
                    });
                    
                    if (matchingQueries.length > 0) {
                      // For URL-based matching, aggregate all queries for that URL (page-level data)
                      // For keyword-based matching, use the first match (query-level data)
                      if (normalizedTaskUrl && normalizedTaskUrl.length > 0 && matchingQueries.length > 1) {
                        // URL-based: aggregate all queries for this URL
                        const totalClicks = matchingQueries.reduce((sum, qt) => sum + (qt.clicks || 0), 0);
                        const totalImpressions = matchingQueries.reduce((sum, qt) => sum + (qt.impressions || 0), 0);
                        const weightedCtr = totalImpressions > 0 ? totalClicks / totalImpressions : null;
                        // Use best rank from the query with highest clicks
                        const bestQuery = matchingQueries.reduce((best, qt) => 
                          (qt.clicks || 0) > (best.clicks || 0) ? qt : best, matchingQueries[0]);
                        console.log(`[Optimisation] Aggregated ${matchingQueries.length} queries for URL: ${totalClicks} clicks, ${totalImpressions} impressions`);
                        currentMetrics = {
                          gsc_clicks_28d: totalClicks || null,
                          gsc_impressions_28d: totalImpressions || null,
                          gsc_ctr_28d: weightedCtr, // Already a ratio (0-1)
                          current_rank: bestQuery.best_rank || bestQuery.avg_position || null,
                          opportunity_score: bestQuery.opportunityScore || null,
                          ai_overview: matchingQueries.some(qt => qt.has_ai_overview) || false,
                          ai_citations: matchingQueries.reduce((sum, qt) => sum + (qt.ai_alan_citations_count || 0), 0),
                          ai_citations_total: matchingQueries.reduce((sum, qt) => sum + (qt.ai_total_citations || 0), 0),
                          classic_ranking_url: bestQuery.best_url || bestQuery.targetUrl || taskUrl,
                          page_type: bestQuery.pageType || null,
                          segment: bestQuery.segment || null,
                          captured_at: new Date().toISOString()
                        };
                      } else {
                        // Keyword-based or single match: use first query
                        const qt = matchingQueries[0];
                        console.log('[Optimisation] Found matching query totals:', qt);
                        currentMetrics = {
                          gsc_clicks_28d: qt.clicks || null,
                          gsc_impressions_28d: qt.impressions || null,
                          gsc_ctr_28d: qt.ctr != null ? (qt.ctr / 100) : null, // Convert percentage to ratio
                          current_rank: qt.best_rank || qt.avg_position || null,
                          opportunity_score: qt.opportunityScore || null,
                          ai_overview: qt.has_ai_overview || false,
                          ai_citations: qt.ai_alan_citations_count || 0,
                          ai_citations_total: qt.ai_total_citations || 0,
                          classic_ranking_url: qt.best_url || qt.targetUrl || taskUrl,
                          page_type: qt.pageType || null,
                          segment: qt.segment || null,
                          captured_at: new Date().toISOString()
                        };
                      }
                      console.log('[Optimisation] Built currentMetrics from query totals:', currentMetrics);
                    }
                  }
                  
                  // Also check query_pages for URL-based matching (query+page level data)
                  if (!currentMetrics && parsed.scores && parsed.scores.query_pages) {
                    const queryPages = Array.isArray(parsed.scores.query_pages) ? parsed.scores.query_pages : [];
                    const matchingQueryPage = queryPages.find(qp => {
                      const qpUrl = (qp.page || qp.url || '').toLowerCase();
                      const normalizedQpUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(qpUrl) : qpUrl.replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                      return normalizedQpUrl === normalizedTaskUrl || 
                             normalizedQpUrl.includes(normalizedTaskUrl) ||
                             normalizedTaskUrl.includes(normalizedQpUrl);
                    });
                    
                    if (matchingQueryPage) {
                      console.log('[Optimisation] Found matching query_pages entry:', matchingQueryPage);
                      currentMetrics = {
                        gsc_clicks_28d: matchingQueryPage.clicks || null,
                        gsc_impressions_28d: matchingQueryPage.impressions || null,
                        gsc_ctr_28d: matchingQueryPage.ctr != null ? (matchingQueryPage.ctr / 100) : null,
                        current_rank: matchingQueryPage.position || matchingQueryPage.avg_position || null,
                        opportunity_score: null,
                        ai_overview: false,
                        ai_citations: 0,
                        ai_citations_total: 0,
                        classic_ranking_url: matchingQueryPage.page || matchingQueryPage.url || taskUrl,
                        page_type: null,
                        segment: null,
                        captured_at: new Date().toISOString()
                      };
                      console.log('[Optimisation] Built currentMetrics from query_pages:', currentMetrics);
                    }
                  }
                }
              } catch (e) {
                console.warn('[Optimisation] Error checking localStorage:', e);
              }
            }
            
            // If still no data, query Supabase directly for latest audit data
            if (!currentMetrics) {
              console.log('[Optimisation] Querying Supabase for latest audit data...');
              try {
                const propertyUrl = document.getElementById('propertyUrl')?.value || localStorage.getItem('gsc_property_url') || 'https://www.alanranger.com';
                if (typeof fetchLatestAuditFromSupabase === 'function') {
                  const supabaseData = await fetchLatestAuditFromSupabase(propertyUrl);
                  if (supabaseData) {
                    console.log('[Optimisation] Fetched latest audit from Supabase, searching for URL/keyword match...');
                    
                    // Check Money Pages data from Supabase
                    const moneyPagesData = supabaseData.scores?.moneyPagesMetrics || supabaseData.moneyPagesMetrics;
                    if (moneyPagesData && moneyPagesData.rows) {
                      const moneyPageRow = moneyPagesData.rows.find(row => {
                        const rowUrl = row.url || row.page_url || '';
                        const normalizedRowUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(rowUrl) : rowUrl.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                        return normalizedRowUrl === normalizedTaskUrl || 
                               normalizedRowUrl.includes(normalizedTaskUrl) ||
                               normalizedTaskUrl.includes(normalizedRowUrl);
                      });
                      
                      if (moneyPageRow) {
                        console.log('[Optimisation] Found matching Money Page row in Supabase:', moneyPageRow);
                        // Normalize CTR: Money Pages stores CTR as ratio (0-1), but check if it's actually a percentage
                        let ctrValue = moneyPageRow.ctr || moneyPageRow.ctr_28d || null;
                        if (ctrValue != null) {
                          // If CTR is > 1, assume it's a percentage and convert to ratio
                          if (ctrValue > 1 && ctrValue <= 100) {
                            console.warn('[Optimisation] Money Pages CTR appears to be percentage, converting to ratio:', ctrValue, '->', ctrValue / 100);
                            ctrValue = ctrValue / 100;
                          } else if (ctrValue > 100) {
                            console.error('[Optimisation] Money Pages CTR value seems invalid (>100%):', ctrValue);
                            ctrValue = null;
                          }
                          // If CTR is <= 1, assume it's already a ratio (0-1)
                        }
                        currentMetrics = {
                          gsc_clicks_28d: moneyPageRow.clicks || moneyPageRow.clicks_28d || null,
                          gsc_impressions_28d: moneyPageRow.impressions || moneyPageRow.impressions_28d || null,
                          gsc_ctr_28d: ctrValue, // Normalized to ratio (0-1)
                          current_rank: moneyPageRow.avg_position || moneyPageRow.position || null,
                          opportunity_score: null,
                          ai_overview: false,
                          ai_citations: 0,
                          ai_citations_total: 0,
                          classic_ranking_url: moneyPageRow.url || moneyPageRow.page_url || taskUrl,
                          page_type: moneyPageRow.page_type || moneyPageRow.type || null,
                          segment: 'money_pages',
                          captured_at: new Date().toISOString()
                        };
                        console.log('[Optimisation] Built currentMetrics from Supabase Money Page row:', currentMetrics);
                      }
                    }
                    
                    // Check queryTotals from Supabase (supports both keyword and URL matching)
                    if (!currentMetrics && supabaseData.searchData && supabaseData.searchData.queryTotals) {
                      const matchingQueries = supabaseData.searchData.queryTotals.filter(qt => {
                        // URL-based matching (for page-level tasks)
                        if (normalizedTaskUrl && normalizedTaskUrl.length > 0) {
                          const qtUrl = (qt.best_url || qt.targetUrl || '').toLowerCase();
                          const normalizedQtUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(qtUrl) : qtUrl.replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                          if (normalizedQtUrl === normalizedTaskUrl || 
                              normalizedQtUrl.includes(normalizedTaskUrl) ||
                              normalizedTaskUrl.includes(normalizedQtUrl)) {
                            return true;
                          }
                        }
                        // Keyword-based matching (for keyword-based tasks)
                        if (taskKeyword && taskKeyword.length > 0) {
                          const qtKeyword = (qt.query || qt.keyword || '').toLowerCase();
                          if (qtKeyword === taskKeyword.toLowerCase()) {
                            return true;
                          }
                        }
                        return false;
                      });
                      
                      if (matchingQueries.length > 0) {
                        // For URL-based matching, aggregate all queries for that URL (page-level data)
                        // For keyword-based matching, use the first match (query-level data)
                        if (normalizedTaskUrl && normalizedTaskUrl.length > 0 && matchingQueries.length > 1) {
                          // URL-based: aggregate all queries for this URL
                          const totalClicks = matchingQueries.reduce((sum, qt) => sum + (qt.clicks || 0), 0);
                          const totalImpressions = matchingQueries.reduce((sum, qt) => sum + (qt.impressions || 0), 0);
                          const weightedCtr = totalImpressions > 0 ? totalClicks / totalImpressions : null;
                          // Use best rank from the query with highest clicks
                          const bestQuery = matchingQueries.reduce((best, qt) => 
                            (qt.clicks || 0) > (best.clicks || 0) ? qt : best, matchingQueries[0]);
                          console.log(`[Optimisation] Aggregated ${matchingQueries.length} queries from Supabase for URL: ${totalClicks} clicks, ${totalImpressions} impressions`);
                          currentMetrics = {
                            gsc_clicks_28d: totalClicks || null,
                            gsc_impressions_28d: totalImpressions || null,
                            gsc_ctr_28d: weightedCtr, // Already a ratio (0-1)
                            current_rank: bestQuery.best_rank || bestQuery.avg_position || null,
                            opportunity_score: bestQuery.opportunityScore || null,
                            ai_overview: matchingQueries.some(qt => qt.has_ai_overview) || false,
                            ai_citations: matchingQueries.reduce((sum, qt) => sum + (qt.ai_alan_citations_count || 0), 0),
                            ai_citations_total: matchingQueries.reduce((sum, qt) => sum + (qt.ai_total_citations || 0), 0),
                            classic_ranking_url: bestQuery.best_url || bestQuery.targetUrl || taskUrl,
                            page_type: bestQuery.pageType || null,
                            segment: bestQuery.segment || null,
                            captured_at: new Date().toISOString()
                          };
                        } else {
                          // Keyword-based or single match: use first query
                          const qt = matchingQueries[0];
                          console.log('[Optimisation] Found matching query totals in Supabase:', qt);
                          currentMetrics = {
                            gsc_clicks_28d: qt.clicks || null,
                            gsc_impressions_28d: qt.impressions || null,
                            gsc_ctr_28d: qt.ctr != null ? (qt.ctr / 100) : null,
                            current_rank: qt.best_rank || qt.avg_position || null,
                            opportunity_score: qt.opportunityScore || null,
                            ai_overview: qt.has_ai_overview || false,
                            ai_citations: qt.ai_alan_citations_count || 0,
                            ai_citations_total: qt.ai_total_citations || 0,
                            classic_ranking_url: qt.best_url || qt.targetUrl || taskUrl,
                            page_type: qt.pageType || null,
                            segment: qt.segment || null,
                            captured_at: new Date().toISOString()
                          };
                        }
                        console.log('[Optimisation] Built currentMetrics from Supabase query totals:', currentMetrics);
                      }
                    }
                    
                    // Check query_pages from Supabase (query+page level data)
                    if (!currentMetrics && supabaseData.scores && supabaseData.scores.query_pages) {
                      const queryPages = Array.isArray(supabaseData.scores.query_pages) ? supabaseData.scores.query_pages : [];
                      const matchingQueryPage = queryPages.find(qp => {
                        const qpUrl = (qp.page || qp.url || '').toLowerCase();
                        const normalizedQpUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(qpUrl) : qpUrl.replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                        return normalizedQpUrl === normalizedTaskUrl || 
                               normalizedQpUrl.includes(normalizedTaskUrl) ||
                               normalizedTaskUrl.includes(normalizedQpUrl);
                      });
                      
                      if (matchingQueryPage) {
                        console.log('[Optimisation] Found matching query_pages in Supabase:', matchingQueryPage);
                        currentMetrics = {
                          gsc_clicks_28d: matchingQueryPage.clicks || null,
                          gsc_impressions_28d: matchingQueryPage.impressions || null,
                          gsc_ctr_28d: matchingQueryPage.ctr != null ? (matchingQueryPage.ctr / 100) : null,
                          current_rank: matchingQueryPage.position || matchingQueryPage.avg_position || null,
                          opportunity_score: null,
                          ai_overview: false,
                          ai_citations: 0,
                          ai_citations_total: 0,
                          classic_ranking_url: matchingQueryPage.page || matchingQueryPage.url || taskUrl,
                          page_type: null,
                          segment: null,
                          captured_at: new Date().toISOString()
                        };
                        console.log('[Optimisation] Built currentMetrics from Supabase query_pages:', currentMetrics);
                      }
                    }
                  }
                }
              } catch (e) {
                console.warn('[Optimisation] Error querying Supabase:', e);
              }
            }
          }

          // If no current data, try to use baseline metrics (if no new audit, current = baseline)
          if (!currentMetrics) {
            console.warn('[Optimisation] No matching row found in Ranking & AI, Money Pages, or audit data for:', {
              keyword: task.keyword_text,
              url: task.target_url_clean || task.target_url
            });
            
            // Check if we have baseline metrics to reuse
            const baselineMetrics = task.baseline_metrics;
            if (baselineMetrics && typeof baselineMetrics === 'object') {
              console.log('[Optimisation] Using baseline metrics as current (no new audit data found)');
              // Reuse baseline metrics but update captured_at to current timestamp
              currentMetrics = {
                ...baselineMetrics,
                captured_at: new Date().toISOString()
              };
            } else {
              // No baseline either, ask user
              const proceed = confirm('Could not find current ranking data for this keyword/URL. Create measurement with current timestamp only?');
              if (!proceed) return;
              
              // Create minimal metrics with just captured_at
              currentMetrics = {
                captured_at: new Date().toISOString()
              };
            }
          }

          try {
            const headers = window.getOptimisationHeaders();
            console.log('[Optimisation] Adding measurement with metrics:', currentMetrics);
            
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/measurement`), {
              method: 'POST',
              headers: headers,
              body: JSON.stringify({
                metrics: currentMetrics,
                note: 'Measurement snapshot'
              })
            });

            if (!response.ok) {
              const errorText = await response.text();
              console.error('[Optimisation] Measurement error response:', errorText);
              throw new Error(errorText || 'Failed to add measurement');
            }

            const responseData = await response.json();
            console.log('[Optimisation] Measurement response:', responseData);

            // Reload tasks to get fresh data from view
            await window.loadAllOptimisationTasks();
            
            // If the response includes updated task data, use it to update state immediately
            if (responseData.task) {
              const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
              if (taskIndex >= 0) {
                window.optimisationModuleState.allTasks[taskIndex] = responseData.task;
                console.log('[Optimisation] Updated task in state with latest_metrics:', responseData.task.latest_metrics);
              } else {
                // Task not in state yet, add it
                window.optimisationModuleState.allTasks.push(responseData.task);
              }
            }
            
            // Refresh drawer with updated data
            await openOptimisationTaskDrawer(taskId);
            
            alert('Measurement added successfully!');
          } catch (error) {
            console.error('[Optimisation Module] Error adding measurement:', error);
            alert('Failed to add measurement: ' + error.message);
          }
        });
      }
    }

    // Bulk update all tasks with latest data
    window.bulkUpdateAllTasks = async function bulkUpdateAllTasks() {
      if (!window.optimisationModuleState || !window.optimisationModuleState.allTasks) {
        alert('No tasks loaded. Please wait for tasks to load first.');
        return;
      }

      // Get active tasks (not done/cancelled/deleted)
      let activeTasks = window.optimisationModuleState.allTasks.filter(
        t => !['done', 'cancelled', 'deleted'].includes(t.status)
      );

      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        activeTasks = activeTasks.filter(t => !t.is_test_task);
      }

      if (activeTasks.length === 0) {
        alert('No active tasks to update.');
        return;
      }

      const confirmMsg = `Update ${activeTasks.length} task(s) with latest ranking data? This will create a new measurement for each task.`;
      if (!confirm(confirmMsg)) {
        return;
      }

      // Ensure Ranking & AI data is loaded
      if (typeof window.renderRankingAiTab === 'function') {
        try {
          await window.renderRankingAiTab();
          await new Promise(resolve => setTimeout(resolve, 1000)); // Give time for data to load
        } catch (e) {
          console.warn('[Optimisation] Could not refresh Ranking & AI data:', e);
        }
      }

      // Get ranking data sources
      let combinedRows = [];
      if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
        const state = RankingAiModule.state();
        combinedRows = state.combinedRows || [];
      }
      if (combinedRows.length === 0 && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
        combinedRows = window.rankingAiData;
      }

      if (combinedRows.length === 0) {
        alert('No ranking data available. Please run a Ranking & AI check first.');
        return;
      }

      const bulkUpdateBtn = document.getElementById('optimisation-bulk-update-btn');
      const originalText = bulkUpdateBtn ? bulkUpdateBtn.textContent : '';
      if (bulkUpdateBtn) {
        bulkUpdateBtn.disabled = true;
        bulkUpdateBtn.textContent = 'Updating...';
      }

      let successCount = 0;
      let skippedCount = 0;
      let failCount = 0;
      const errors = [];

      try {
        // Process sequentially to avoid rate limits (max 3 concurrent)
        const maxConcurrent = 3;
        for (let i = 0; i < activeTasks.length; i += maxConcurrent) {
          const batch = activeTasks.slice(i, i + maxConcurrent);
          
          await Promise.all(batch.map(async (task, batchIdx) => {
            const taskNum = i + batchIdx + 1;
            if (bulkUpdateBtn) {
              bulkUpdateBtn.textContent = `Updating ${taskNum}/${activeTasks.length}...`;
            }

          // Find matching row - search by both keyword AND URL
          const taskUrl = task.target_url_clean || task.target_url || '';
          const taskKeyword = task.keyword_text || '';
          const normalizedTaskUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(taskUrl) : taskUrl.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
          
          let matchingRow = null;
          let currentMetrics = null;
          
          // First try Ranking & AI data (keyword-based matching)
          if (taskKeyword && taskKeyword.length > 0) {
            matchingRow = combinedRows.find(r => {
              const keywordMatch = (r.keyword || '').toLowerCase() === taskKeyword.toLowerCase();
            if (!keywordMatch) return false;
            
              // Also check URL match if URL is provided
              if (normalizedTaskUrl && normalizedTaskUrl.length > 0) {
            const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
                const normalizedRowUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(rowUrl) : rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                return normalizedRowUrl === normalizedTaskUrl || 
                       normalizedRowUrl.includes(normalizedTaskUrl) ||
                       normalizedTaskUrl.includes(normalizedRowUrl);
              }
              return true; // Keyword match is enough if no URL
            });
          }
          
          // If no keyword match, try URL-based matching in Money Pages data
          if (!matchingRow && normalizedTaskUrl && normalizedTaskUrl.length > 0) {
            // Check window.moneyPagesMetrics
            if (window.moneyPagesMetrics && window.moneyPagesMetrics.rows) {
              const moneyPageRow = window.moneyPagesMetrics.rows.find(row => {
                const rowUrl = row.url || row.page_url || '';
                const normalizedRowUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(rowUrl) : rowUrl.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                return normalizedRowUrl === normalizedTaskUrl || 
                       normalizedRowUrl.includes(normalizedTaskUrl) ||
                       normalizedTaskUrl.includes(normalizedRowUrl);
              });
              
              if (moneyPageRow) {
                // Normalize CTR: Money Pages stores CTR as ratio (0-1), but check if it's actually a percentage
                let ctrValue = moneyPageRow.ctr || moneyPageRow.ctr_28d || null;
                if (ctrValue != null) {
                  // If CTR is > 1, assume it's a percentage and convert to ratio
                  if (ctrValue > 1 && ctrValue <= 100) {
                    console.warn('[Optimisation] Money Pages CTR appears to be percentage, converting to ratio:', ctrValue, '->', ctrValue / 100);
                    ctrValue = ctrValue / 100;
                  } else if (ctrValue > 100) {
                    console.error('[Optimisation] Money Pages CTR value seems invalid (>100%):', ctrValue);
                    ctrValue = null;
                  }
                  // If CTR is <= 1, assume it's already a ratio (0-1)
                }
                currentMetrics = {
                  gsc_clicks_28d: moneyPageRow.clicks || moneyPageRow.clicks_28d || null,
                  gsc_impressions_28d: moneyPageRow.impressions || moneyPageRow.impressions_28d || null,
                  gsc_ctr_28d: ctrValue, // Normalized to ratio (0-1)
                  current_rank: moneyPageRow.avg_position || moneyPageRow.position || null,
                  opportunity_score: null,
                  ai_overview: false,
                  ai_citations: 0,
                  ai_citations_total: 0,
                  classic_ranking_url: moneyPageRow.url || moneyPageRow.page_url || taskUrl,
                  page_type: moneyPageRow.page_type || moneyPageRow.type || null,
                  segment: 'money_pages',
                  captured_at: new Date().toISOString()
                };
              }
            }
            
            // If still no data, check localStorage/Supabase audit results
            if (!currentMetrics) {
              try {
                const savedAudit = localStorage.getItem('aigeo_audit_data');
                if (savedAudit) {
                  const parsed = JSON.parse(savedAudit);
                  const moneyPagesData = parsed.scores?.moneyPagesMetrics || parsed.moneyPagesMetrics;
                  
                  if (moneyPagesData && moneyPagesData.rows) {
                    const moneyPageRow = moneyPagesData.rows.find(row => {
                      const rowUrl = row.url || row.page_url || '';
                      const normalizedRowUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(rowUrl) : rowUrl.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                      return normalizedRowUrl === normalizedTaskUrl || 
                             normalizedRowUrl.includes(normalizedTaskUrl) ||
                             normalizedTaskUrl.includes(normalizedRowUrl);
                    });
                    
                    if (moneyPageRow) {
                      // Normalize CTR: Money Pages stores CTR as ratio (0-1), but check if it's actually a percentage
                      let ctrValue = moneyPageRow.ctr || moneyPageRow.ctr_28d || null;
                      if (ctrValue != null) {
                        // If CTR is > 1, assume it's a percentage and convert to ratio
                        if (ctrValue > 1 && ctrValue <= 100) {
                          console.warn('[Optimisation] Money Pages CTR appears to be percentage, converting to ratio:', ctrValue, '->', ctrValue / 100);
                          ctrValue = ctrValue / 100;
                        } else if (ctrValue > 100) {
                          console.error('[Optimisation] Money Pages CTR value seems invalid (>100%):', ctrValue);
                          ctrValue = null;
                        }
                        // If CTR is <= 1, assume it's already a ratio (0-1)
                      }
                      currentMetrics = {
                        gsc_clicks_28d: moneyPageRow.clicks || moneyPageRow.clicks_28d || null,
                        gsc_impressions_28d: moneyPageRow.impressions || moneyPageRow.impressions_28d || null,
                        gsc_ctr_28d: ctrValue, // Normalized to ratio (0-1)
                        current_rank: moneyPageRow.avg_position || moneyPageRow.position || null,
                        opportunity_score: null,
                        ai_overview: false,
                        ai_citations: 0,
                        ai_citations_total: 0,
                        classic_ranking_url: moneyPageRow.url || moneyPageRow.page_url || taskUrl,
                        page_type: moneyPageRow.page_type || moneyPageRow.type || null,
                        segment: 'money_pages',
                        captured_at: new Date().toISOString()
                      };
                    }
                  }
                  
                  // Check queryTotals for URL-based matching
                  if (!currentMetrics && parsed.searchData && parsed.searchData.queryTotals) {
                    const matchingQueries = parsed.searchData.queryTotals.filter(qt => {
                      const qtUrl = (qt.best_url || qt.targetUrl || '').toLowerCase();
                      const normalizedQtUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(qtUrl) : qtUrl.replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                      return normalizedQtUrl === normalizedTaskUrl || 
                             normalizedQtUrl.includes(normalizedTaskUrl) ||
                             normalizedTaskUrl.includes(normalizedQtUrl);
                    });
                    
                    if (matchingQueries.length > 0) {
                      // For URL-based matching, aggregate all queries for that URL (page-level data)
                      if (matchingQueries.length > 1) {
                        // Aggregate all queries for this URL
                        const totalClicks = matchingQueries.reduce((sum, qt) => sum + (qt.clicks || 0), 0);
                        const totalImpressions = matchingQueries.reduce((sum, qt) => sum + (qt.impressions || 0), 0);
                        const weightedCtr = totalImpressions > 0 ? totalClicks / totalImpressions : null;
                        // Use best rank from the query with highest clicks
                        const bestQuery = matchingQueries.reduce((best, qt) => 
                          (qt.clicks || 0) > (best.clicks || 0) ? qt : best, matchingQueries[0]);
                        console.log(`[Optimisation] Aggregated ${matchingQueries.length} queries for URL in bulk update: ${totalClicks} clicks, ${totalImpressions} impressions`);
                        currentMetrics = {
                          gsc_clicks_28d: totalClicks || null,
                          gsc_impressions_28d: totalImpressions || null,
                          gsc_ctr_28d: weightedCtr, // Already a ratio (0-1)
                          current_rank: bestQuery.best_rank || bestQuery.avg_position || null,
                          opportunity_score: bestQuery.opportunityScore || null,
                          ai_overview: matchingQueries.some(qt => qt.has_ai_overview) || false,
                          ai_citations: matchingQueries.reduce((sum, qt) => sum + (qt.ai_alan_citations_count || 0), 0),
                          ai_citations_total: matchingQueries.reduce((sum, qt) => sum + (qt.ai_total_citations || 0), 0),
                          classic_ranking_url: bestQuery.best_url || bestQuery.targetUrl || taskUrl,
                          page_type: bestQuery.pageType || null,
                          segment: bestQuery.segment || null,
                          captured_at: new Date().toISOString()
                        };
                      } else {
                        // Single match: use first query
                        const qt = matchingQueries[0];
                        currentMetrics = {
                          gsc_clicks_28d: qt.clicks || null,
                          gsc_impressions_28d: qt.impressions || null,
                          gsc_ctr_28d: qt.ctr != null ? (qt.ctr / 100) : null,
                          current_rank: qt.best_rank || qt.avg_position || null,
                          opportunity_score: qt.opportunityScore || null,
                          ai_overview: qt.has_ai_overview || false,
                          ai_citations: qt.ai_alan_citations_count || 0,
                          ai_citations_total: qt.ai_total_citations || 0,
                          classic_ranking_url: qt.best_url || qt.targetUrl || taskUrl,
                          page_type: qt.pageType || null,
                          segment: qt.segment || null,
                          captured_at: new Date().toISOString()
                        };
                      }
                    }
                  }
                }
              } catch (e) {
                console.warn(`[Optimisation] Error checking localStorage for task ${task.id}:`, e);
              }
            }
          }

          // If found matching row in Ranking & AI, use that data
          if (matchingRow && !currentMetrics) {
            // Get queryTotal data for clicks, impressions, and CTR
            let queryTotal = null;
            if (typeof getQueryTotalForKeyword === 'function') {
              queryTotal = getQueryTotalForKeyword(task.keyword_text);
            }
            
            currentMetrics = {
              gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
              gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
              gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
              current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
              opportunity_score: matchingRow.opportunityScore || null,
              ai_overview: matchingRow.has_ai_overview || false,
              ai_citations: matchingRow.ai_alan_citations_count || 0,
              ai_citations_total: matchingRow.ai_total_citations || 0,
              classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
              page_type: matchingRow.pageType || null,
              segment: matchingRow.segment || null,
              captured_at: new Date().toISOString()
            };
          }
          
            // Fallback to baseline if no current data found
          if (!currentMetrics && task.baseline_metrics) {
            console.log(`[Optimisation] No current data for ${task.keyword_text || taskUrl}, using baseline`);
            currentMetrics = { ...task.baseline_metrics, captured_at: new Date().toISOString() };
            // Remove null GSC metrics to avoid stale nulls
            if (currentMetrics.gsc_clicks_28d === null) delete currentMetrics.gsc_clicks_28d;
            if (currentMetrics.gsc_impressions_28d === null) delete currentMetrics.gsc_impressions_28d;
            if (currentMetrics.gsc_ctr_28d === null) delete currentMetrics.gsc_ctr_28d;
          }

          if (!currentMetrics) {
            failCount++;
            errors.push(`${task.keyword_text || taskUrl}: No data found in Ranking & AI, Money Pages, or audit results`);
            return;
          }

            // Create measurement
            try {
              const headers = window.getOptimisationHeaders();
              const response = await fetch(apiUrl(`/api/optimisation/task/${task.id}/measurement`), {
                method: 'POST',
                headers: { ...headers, 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  metrics: currentMetrics,
                  note: 'Bulk update - latest data snapshot'
                })
              });

              if (!response.ok) {
                const error = await response.json().catch(() => ({ error: 'Unknown error' }));
                throw new Error(error.error || 'Failed to create measurement');
              }

              const result = await response.json();
              if (result.skipped) {
                skippedCount++;
              } else {
                successCount++;
              }
            } catch (error) {
              failCount++;
              errors.push(`${task.keyword_text}: ${error.message}`);
              console.error(`[Optimisation] Error updating task ${task.id}:`, error);
            }
          }));
        }

        // Reload tasks to show updated data
        await window.loadAllOptimisationTasks();

        // Show results in modal
        showBulkUpdateResultsModal(successCount, skippedCount, failCount, errors, activeTasks.length);

      } catch (error) {
        console.error('[Optimisation] Bulk update error:', error);
        showBulkUpdateResultsModal(0, 0, activeTasks.length, [`Bulk update failed: ${error.message}`], activeTasks.length);
      } finally {
        if (bulkUpdateBtn) {
          bulkUpdateBtn.disabled = false;
          bulkUpdateBtn.textContent = originalText;
        }
      }
    };

    // Show bulk update results modal
    function showBulkUpdateResultsModal(successCount, skippedCount, failCount, errors, totalTasks) {
      const modal = document.getElementById('optimisation-bulk-update-results-modal');
      const content = document.getElementById('bulk-update-results-content');
      
      if (!modal || !content) {
        // Fallback to alert if modal not found
        let message = `Updated ${successCount} task(s) successfully.`;
        if (skippedCount > 0) {
          message += ` Skipped ${skippedCount} (recent measurement within 5 minutes).`;
        }
        if (failCount > 0) {
          message += `\n\nFailed to update ${failCount} task(s):\n${errors.slice(0, 5).join('\n')}`;
          if (errors.length > 5) {
            message += `\n... and ${errors.length - 5} more.`;
          }
        }
        alert(message);
        return;
      }

      // Build summary HTML
      let html = '<div style="margin-bottom: 1.5rem;">';
      
      // Summary stats
      html += '<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 1.5rem;">';
      html += `<div style="padding: 1rem; background: #f0fdf4; border-left: 4px solid #10b981; border-radius: 4px;">
        <div style="font-size: 2rem; font-weight: 700; color: #10b981;">${successCount}</div>
        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">Successfully Updated</div>
      </div>`;
      html += `<div style="padding: 1rem; background: #fef3c7; border-left: 4px solid #f59e0b; border-radius: 4px;">
        <div style="font-size: 2rem; font-weight: 700; color: #f59e0b;">${skippedCount}</div>
        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">Skipped</div>
      </div>`;
      html += `<div style="padding: 1rem; background: #fee2e2; border-left: 4px solid #ef4444; border-radius: 4px;">
        <div style="font-size: 2rem; font-weight: 700; color: #ef4444;">${failCount}</div>
        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">Failed</div>
      </div>`;
      html += `<div style="padding: 1rem; background: #f3f4f6; border-left: 4px solid #6b7280; border-radius: 4px;">
        <div style="font-size: 2rem; font-weight: 700; color: #6b7280;">${totalTasks}</div>
        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">Total Tasks</div>
      </div>`;
      html += '</div>';

      // Skipped tasks explanation
      if (skippedCount > 0) {
        html += '<div style="padding: 1rem; background: #fef3c7; border-left: 4px solid #f59e0b; border-radius: 4px; margin-bottom: 1rem;">';
        html += '<div style="font-weight: 600; color: #92400e; margin-bottom: 0.5rem;">Why were tasks skipped?</div>';
        html += '<div style="font-size: 0.875rem; color: #78350f;">Tasks were skipped because they already have a recent measurement (within the last 5 minutes). This prevents duplicate measurements if you click the update button multiple times.</div>';
        html += '</div>';
      }

      // Failed tasks details
      if (failCount > 0 && errors.length > 0) {
        html += '<div style="padding: 1rem; background: #fee2e2; border-left: 4px solid #ef4444; border-radius: 4px; margin-bottom: 1rem;">';
        html += '<div style="font-weight: 600; color: #991b1b; margin-bottom: 0.75rem;">Failed Tasks:</div>';
        html += '<div style="max-height: 300px; overflow-y: auto; font-size: 0.875rem;">';
        html += '<ul style="margin: 0; padding-left: 1.5rem; color: #7f1d1d;">';
        errors.forEach(error => {
          html += `<li style="margin-bottom: 0.5rem;">${escapeHtml(error)}</li>`;
        });
        html += '</ul>';
        html += '</div>';
        html += '<div style="margin-top: 0.75rem; font-size: 0.875rem; color: #7f1d1d;">';
        html += '<strong>Common reasons for failures:</strong><ul style="margin-top: 0.5rem; padding-left: 1.5rem;">';
        html += '<li>No matching data found in Ranking & AI results</li>';
        html += '<li>Task keyword or URL doesn\'t match any ranking data</li>';
        html += '<li>Network or server error during update</li>';
        html += '<li>Task is missing required fields</li>';
        html += '</ul>';
        html += '</div>';
        html += '</div>';
      }

      // Success message
      if (successCount > 0) {
        html += '<div style="padding: 1rem; background: #f0fdf4; border-left: 4px solid #10b981; border-radius: 4px;">';
        html += '<div style="font-weight: 600; color: #065f46; margin-bottom: 0.5rem;"> Update Complete</div>';
        html += '<div style="font-size: 0.875rem; color: #047857;">Successfully updated measurements for ' + successCount + ' task(s). The table has been refreshed to show the latest data.</div>';
        html += '</div>';
      }

      html += '</div>';

      content.innerHTML = html;
      modal.style.display = 'flex';
    }

    // Close bulk update results modal
    window.closeBulkUpdateResultsModal = function closeBulkUpdateResultsModal() {
      const modal = document.getElementById('optimisation-bulk-update-results-modal');
      if (modal) {
        modal.style.display = 'none';
      }
    };

    // Update latest metrics for a single task
    window.updateTaskLatest = async function updateTaskLatest(taskId) {
      const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      if (!task) {
        alert('Task not found. Please refresh the page.');
        return;
      }

      // Ensure Ranking & AI data is loaded
      if (typeof window.renderRankingAiTab === 'function') {
        try {
          await window.renderRankingAiTab();
          await new Promise(resolve => setTimeout(resolve, 500));
        } catch (e) {
          console.warn('[Optimisation] Could not refresh Ranking & AI data:', e);
        }
      }

      // Get ranking data sources
      let combinedRows = [];
      if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
        const state = RankingAiModule.state();
        combinedRows = state.combinedRows || [];
      }
      if (combinedRows.length === 0 && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
        combinedRows = window.rankingAiData;
      }

      // Find matching row
      const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
      const taskUrlPath = taskUrlClean.includes('/') ? taskUrlClean.split('/').slice(1).join('/') : '';
      
      const matchingRow = combinedRows.find(r => {
        const keywordMatch = (r.keyword || '').toLowerCase() === (task.keyword_text || '').toLowerCase();
        if (!keywordMatch) return false;
        
        const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
        const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
        const rowUrlPath = rowUrlClean.includes('/') ? rowUrlClean.split('/').slice(1).join('/') : '';
        
        return rowUrl === taskUrlClean || 
               rowUrlClean === taskUrlClean ||
               rowUrlPath === taskUrlPath ||
               rowUrl.includes(taskUrlClean) ||
               taskUrlClean.includes(rowUrlClean);
      });

      let currentMetrics = null;

      if (matchingRow) {
        // Get queryTotal data for clicks, impressions, and CTR
        let queryTotal = null;
        if (typeof getQueryTotalForKeyword === 'function') {
          queryTotal = getQueryTotalForKeyword(task.keyword_text);
        }
        
        currentMetrics = {
          gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
          gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
          gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
          current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
          opportunity_score: matchingRow.opportunityScore || null,
          ai_overview: matchingRow.has_ai_overview || false,
          ai_citations: matchingRow.ai_alan_citations_count || 0,
          ai_citations_total: matchingRow.ai_total_citations || 0,
          classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
          page_type: matchingRow.pageType || null,
          segment: matchingRow.segment || null,
          captured_at: new Date().toISOString()
        };
      } else if (task.baseline_metrics) {
        // Fallback to baseline if no current data found
        currentMetrics = { ...task.baseline_metrics, captured_at: new Date().toISOString() };
        if (currentMetrics.gsc_clicks_28d === null) delete currentMetrics.gsc_clicks_28d;
        if (currentMetrics.gsc_impressions_28d === null) delete currentMetrics.gsc_impressions_28d;
        if (currentMetrics.gsc_ctr_28d === null) delete currentMetrics.gsc_ctr_28d;
      }

      if (!currentMetrics) {
        alert('No ranking data available for this task. Please run a Ranking & AI check first.');
        return;
      }

      // Find the Update button to show loading state
      const updateBtn = event?.target;
      const originalText = updateBtn?.textContent || 'Update';
      if (updateBtn) {
        updateBtn.disabled = true;
        updateBtn.textContent = 'Updating...';
      }

      try {
        const headers = window.getOptimisationHeaders();
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/measurement`), {
          method: 'POST',
          headers: { ...headers, 'Content-Type': 'application/json' },
          body: JSON.stringify({
            metrics: currentMetrics,
            note: 'Latest measurement captured'
          })
        });

        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: 'Unknown error' }));
          throw new Error(error.error || 'Failed to create measurement');
        }

        const result = await response.json();
        
        // Reload tasks to show updated data
        await window.loadAllOptimisationTasks();
        
        // Show success message
        if (result.skipped) {
          if (typeof debugLog === 'function') {
            debugLog(`[Optimisation] Measurement skipped (recent): ${task.keyword_text}`, 'info');
          }
          // Show brief feedback
          if (updateBtn) {
            updateBtn.textContent = 'Skipped';
            setTimeout(() => {
              if (updateBtn) {
                updateBtn.disabled = false;
                updateBtn.textContent = originalText;
              }
            }, 2000);
          }
        } else {
          if (typeof debugLog === 'function') {
            debugLog(`[Optimisation] Measurement updated: ${task.keyword_text}`, 'success');
          }
          // Show brief success feedback
          if (updateBtn) {
            updateBtn.textContent = '';
            setTimeout(() => {
              if (updateBtn) {
                updateBtn.disabled = false;
                updateBtn.textContent = originalText;
              }
            }, 2000);
          }
        }
      } catch (error) {
        console.error(`[Optimisation] Error updating task ${taskId}:`, error);
        alert(`Failed to update task: ${error.message}`);
        if (updateBtn) {
          updateBtn.disabled = false;
          updateBtn.textContent = originalText;
        }
      }
    };

    // Add to ensurePanelRendered
    const originalEnsurePanelRendered = ensurePanelRendered;
    ensurePanelRendered = function(panelId) {
      originalEnsurePanelRendered(panelId);
      
      if (panelId === 'optimisation') {
        if (!window.optimisationModuleInitialized) {
          initOptimisationTrackingModule();
          window.optimisationModuleInitialized = true;
        }
        window.loadAllOptimisationTasks();
      }
      
      if (panelId === 'portfolio') {
        setTimeout(() => {
          wirePortfolioControls();
          if (typeof window.renderPortfolioTab === 'function') {
            window.renderPortfolioTab();
          }
        }, 100);
      }
    };

    // ======================
    // GSC Date Range Configuration
    // ======================
    // Centralized constant for GSC window (matches GSC UI default)
    const GSC_WINDOW_DAYS = 28;
    
    /**
     * Get GSC date range helper (matches backend utils.js getGscDateRange)
     * @param {number} daysBack - Number of days to look back (default: GSC_WINDOW_DAYS)
     * @param {number} endOffsetDays - Days to subtract from today for end date (default: 1 = yesterday)
     * @returns {Object} { startDate, endDate } as ISO strings (YYYY-MM-DD)
     */
    function getGscDateRange(daysBack = GSC_WINDOW_DAYS, endOffsetDays = 2) {
      // End date = 2 days ago (GSC data is typically 2-3 days behind today)
      const end = new Date();
      end.setDate(end.getDate() - endOffsetDays);
      end.setHours(0, 0, 0, 0);
      
      // Start date = end date - (daysBack - 1) days (inclusive range)
      const start = new Date(end);
      start.setDate(start.getDate() - (daysBack - 1));
      start.setHours(0, 0, 0, 0);
      
      // Format as YYYY-MM-DD
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      return {
        startDate: formatDate(start),
        endDate: formatDate(end)
      };
    }
    
    function safeSetLocalStorage(key, value) {
      try {
        const valueString = typeof value === 'string' ? value : JSON.stringify(value);
        // Check size before saving (localStorage limit is typically 5-10MB)
        if (valueString.length > 4 * 1024 * 1024) {
          debugLog(` Data too large for localStorage (${Math.round(valueString.length / 1024)}KB), skipping save. Supabase is source of truth.`, 'warn');
          return false;
        }
        localStorage.setItem(key, valueString);
        return true;
      } catch (error) {
        if (error.name === 'QuotaExceededError' || error.message.includes('quota')) {
          debugLog(` localStorage quota exceeded for ${key}, skipping save. Supabase is source of truth.`, 'warn');
          return false;
        } else {
          debugLog(` Error saving to localStorage (${key}): ${error.message}`, 'error');
          return false;
        }
      }
    }
    
    // ======================
    // CRITICAL: Define buildMoneyPageMetrics at GLOBAL SCOPE first
    // This ensures it's available when displayDashboard runs
    // ======================
    console.log('[Money Pages] Defining buildMoneyPageMetrics at global scope...');
    
    // Define helper functions that buildMoneyPageMetrics depends on (if not already defined)
    // These will be defined later in the script, but we need to ensure buildMoneyPageMetrics
    // can be called even if these helpers aren't ready yet
    
    // Placeholder - will be replaced by actual function when script loads
    // This is a fallback used only if no external Money Pages module is wired.
    // It returns empty metrics so the UI can show "No data" rather than crash.
    // Diagnostic function to check keyword matching issues AND missing search volume
    window.diagnoseKeywordMatching = function() {
      try {
        const savedAudit = loadAuditResultsSync();
        if (!savedAudit || !savedAudit.searchData) {
          debugLog(' No audit data found. Cannot diagnose keyword matching.', 'warn');
          return;
        }
        
        // Get keywords from ranking data
        let rankingData = [];
        if (window.RankingAiModule && typeof window.RankingAiModule.state === 'function') {
          const state = window.RankingAiModule.state();
          rankingData = state.combinedRows || [];
        }
        
        if (!rankingData || rankingData.length === 0) {
          debugLog(' No ranking keywords found. Cannot diagnose.', 'warn');
          return;
        }
        
        const allKeywords = rankingData.map(r => r.keyword).filter(k => k && k.trim());
        const queryTotals = savedAudit.searchData.queryTotals || [];
        
        debugLog(` Diagnostic: Checking ${allKeywords.length} keywords`, 'info');
        
        // CRITICAL: Check for missing search_volume (this is what the UI shows as "")
        const missingSearchVolume = [];
        const hasSearchVolume = [];
        
        rankingData.forEach(row => {
          const searchVolume = row.search_volume;
          // IMPORTANT: Only treat as missing if null/undefined, not if 0 (0 is a valid value)
          if (searchVolume == null || searchVolume === undefined) {
            missingSearchVolume.push({ keyword: row.keyword, search_volume: searchVolume });
          } else {
            hasSearchVolume.push({ keyword: row.keyword, search_volume: searchVolume });
          }
        });
        
        debugLog(` Search Volume Analysis:`, 'info');
        debugLog(`   Has search volume: ${hasSearchVolume.length} keywords`, 'success');
        debugLog(`   Missing search volume: ${missingSearchVolume.length} keywords`, missingSearchVolume.length > 0 ? 'warn' : 'success');
        if (missingSearchVolume.length > 0) {
          const missingList = missingSearchVolume.slice(0, 20).map(m => m.keyword).join(', ');
          debugLog(`  Missing search volume keywords: ${missingList}${missingSearchVolume.length > 20 ? ` ... (${missingSearchVolume.length - 20} more)` : ''}`, 'warn');
        }
        
        // Also check queryTotals matching (for impressions/CTR)
        const missingQueryTotals = [];
        const matchedQueryTotals = [];
        const zeroImpressionKeywords = [];
        
        allKeywords.forEach(keyword => {
          const normalizedKeyword = normalizeKeywordForMatching(keyword);
          const queryTotal = queryTotals.find(
            qt => {
              if (!qt.query) return false;
              const normalizedQuery = normalizeKeywordForMatching(qt.query);
              return normalizedQuery === normalizedKeyword || 
                     normalizedQuery.includes(normalizedKeyword) || 
                     normalizedKeyword.includes(normalizedQuery);
            }
          );
          
          if (!queryTotal) {
            missingQueryTotals.push(keyword);
          } else {
            matchedQueryTotals.push(keyword);
            if (queryTotal.impressions === 0 || queryTotal.impressions == null) {
              zeroImpressionKeywords.push({ keyword, query: queryTotal.query, impressions: queryTotal.impressions });
            }
          }
        });
        
        debugLog(` QueryTotals Analysis (for impressions/CTR):`, 'info');
        debugLog(`   Matched: ${matchedQueryTotals.length} keywords`, 'success');
        debugLog(`   Missing: ${missingQueryTotals.length} keywords`, missingQueryTotals.length > 0 ? 'warn' : 'info');
        if (missingQueryTotals.length > 0) {
          debugLog(`  Missing queryTotals: ${missingQueryTotals.slice(0, 20).join(', ')}${missingQueryTotals.length > 20 ? ` ... (${missingQueryTotals.length - 20} more)` : ''}`, 'warn');
        }
        
        debugLog(` Zero impressions: ${zeroImpressionKeywords.length} keywords`, zeroImpressionKeywords.length > 0 ? 'info' : 'success');
        if (zeroImpressionKeywords.length > 0) {
          const sample = zeroImpressionKeywords.slice(0, 10).map(z => `${z.keyword} (query: "${z.query}", impressions: ${z.impressions})`).join(', ');
          debugLog(`Sample zero-impression keywords: ${sample}${zeroImpressionKeywords.length > 10 ? '...' : ''}`, 'info');
        }
        
        // Check for queries in queryTotals that don't match any keywords (orphaned queries)
        const orphanedQueries = queryTotals.filter(qt => {
          const normalizedQuery = normalizeKeywordForMatching(qt.query || '');
          return !allKeywords.some(k => {
            const normalizedKeyword = normalizeKeywordForMatching(k);
            return normalizedQuery === normalizedKeyword || 
                   normalizedQuery.includes(normalizedKeyword) || 
                   normalizedKeyword.includes(normalizedQuery);
          });
        });
        
        if (orphanedQueries.length > 0) {
          debugLog(` Found ${orphanedQueries.length} orphaned queries in queryTotals (don't match any keywords)`, 'warn');
          const sample = orphanedQueries.slice(0, 10).map(qt => qt.query || '(no query)').join(', ');
          debugLog(`Sample orphaned queries: ${sample}${orphanedQueries.length > 10 ? '...' : ''}`, 'warn');
        }
        
        return {
          totalKeywords: allKeywords.length,
          totalQueryTotals: queryTotals.length,
          // Search volume analysis (what UI shows as "")
          missingSearchVolume: missingSearchVolume.length,
          missingSearchVolumeKeywords: missingSearchVolume,
          hasSearchVolume: hasSearchVolume.length,
          // QueryTotals analysis (for impressions/CTR)
          matched: matchedQueryTotals.length,
          missing: missingQueryTotals.length,
          missingKeywords: missingQueryTotals,
          zeroImpression: zeroImpressionKeywords.length,
          zeroImpressionKeywords: zeroImpressionKeywords,
          orphaned: orphanedQueries.length,
          orphanedQueries: orphanedQueries
        };
      } catch (error) {
        debugLog(` Error diagnosing keyword matching: ${error.message}`, 'error');
        return null;
      }
    };
    
    // Function to check Supabase database for missing search volume
    window.checkSupabaseSearchVolume = async function() {
      try {
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (!propertyUrl) {
          debugLog(' No property URL found. Cannot query Supabase.', 'warn');
          return;
        }
        
        debugLog(` Querying Supabase for missing search volume...`, 'info');
        
        const response = await fetch(apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`));
        if (!response.ok) {
          const errorText = await response.text();
          debugLog(` Failed to fetch from Supabase: ${response.status} - ${errorText}`, 'warn');
          return;
        }
        
        const data = await response.json();
        if (data.status !== 'ok' || !data.data || !data.data.rankingAiData || !data.data.rankingAiData.combinedRows) {
          debugLog(' No ranking data found in Supabase response', 'warn');
          return;
        }
        
        const keywords = data.data.rankingAiData.combinedRows || [];
        const missingSearchVolume = keywords.filter(k => k.search_volume == null || k.search_volume === undefined);
        const hasSearchVolume = keywords.filter(k => k.search_volume != null && k.search_volume !== undefined);
        
        debugLog(` Supabase Search Volume Analysis:`, 'info');
        debugLog(`  Total keywords in DB: ${keywords.length}`, 'info');
        debugLog(`   Has search volume: ${hasSearchVolume.length} keywords`, 'success');
        debugLog(`   Missing search volume: ${missingSearchVolume.length} keywords`, missingSearchVolume.length > 0 ? 'warn' : 'success');
        
        if (missingSearchVolume.length > 0) {
          const missingList = missingSearchVolume.slice(0, 30).map(k => k.keyword).join(', ');
          debugLog(`  Missing search volume keywords: ${missingList}${missingSearchVolume.length > 30 ? ` ... (${missingSearchVolume.length - 30} more)` : ''}`, 'warn');
        }
        
        return {
          total: keywords.length,
          hasSearchVolume: hasSearchVolume.length,
          missingSearchVolume: missingSearchVolume.length,
          missingKeywords: missingSearchVolume.map(k => k.keyword)
        };
      } catch (error) {
        debugLog(` Error checking Supabase: ${error.message}`, 'error');
        return null;
      }
    };
    
    // Manual function to fetch and save queryTotals (for debugging/fixing missing data)
    window.fetchQueryTotalsManually = async function() {
      try {
        const savedAudit = loadAuditResultsSync();
        if (!savedAudit || !savedAudit.searchData) {
          debugLog(' No audit data found in localStorage. Please run a full audit first.', 'warn');
          return;
        }
        
        // Get keywords from ranking data
        let rankingData = [];
        
        // Try to get from RankingAiModule state first
        if (window.RankingAiModule && typeof window.RankingAiModule.state === 'function') {
          const state = window.RankingAiModule.state();
          rankingData = state.combinedRows || [];
          debugLog(` Found ${rankingData.length} keywords from RankingAiModule state`, 'info');
        }
        
        // Fallback: try to get from localStorage
        if (!rankingData || rankingData.length === 0) {
          try {
            const storedData = localStorage.getItem('ranking_ai_data');
            if (storedData) {
              const parsed = JSON.parse(storedData);
              if (parsed && parsed.combinedRows && Array.isArray(parsed.combinedRows)) {
                rankingData = parsed.combinedRows;
                debugLog(` Found ${rankingData.length} keywords from localStorage`, 'info');
              }
            }
          } catch (e) {
            debugLog(` Failed to parse ranking data from localStorage: ${e.message}`, 'warn');
          }
        }
        
        // Fallback: try to get from saved audit's keyword_rankings
        if (!rankingData || rankingData.length === 0) {
          if (savedAudit.keywordRankings && Array.isArray(savedAudit.keywordRankings)) {
            rankingData = savedAudit.keywordRankings;
            debugLog(` Found ${rankingData.length} keywords from saved audit`, 'info');
          }
        }
        
        if (!rankingData || rankingData.length === 0) {
          debugLog(' No ranking keywords found. Please run the ranking scan first.', 'warn');
          return;
        }
        
        const allKeywords = rankingData.map(r => r.keyword).filter(k => k && k.trim());
        if (allKeywords.length === 0) {
          debugLog(' No valid keywords found in ranking data.', 'warn');
          return;
        }
        
        debugLog(` Manually fetching queryTotals for ${allKeywords.length} keywords...`, 'info');
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28');
        
        // Fetch queryTotals from GSC API
        const keywordsParam = encodeURIComponent(JSON.stringify(allKeywords));
        const propertyParam = encodeURIComponent(propertyUrl);
        const gscResponse = await fetch(apiUrl(`/api/aigeo/gsc-entity-metrics?property=${propertyParam}&keywords=${keywordsParam}&days=${dateRange}`));
        
        if (gscResponse.ok) {
          const gscData = await gscResponse.json();
          if (gscData.status === 'ok' && gscData.data && Array.isArray(gscData.data.queryTotals)) {
            const queryTotals = gscData.data.queryTotals;
            debugLog(` Fetched queryTotals for ${queryTotals.length} keywords from GSC`, 'success');
            
            // Merge queryTotals into searchData
            savedAudit.searchData.queryTotals = queryTotals;
            
            // Use the SAME audit_date as the existing audit
            let auditDate = new Date().toISOString().split('T')[0];
            if (savedAudit.timestamp) {
              try {
                auditDate = new Date(savedAudit.timestamp).toISOString().split('T')[0];
              } catch (e) {
                // Use today as fallback
              }
            }
            
            // Save to Supabase
            const saveResponse = await fetch(apiUrl('/api/supabase/save-audit'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                propertyUrl: propertyUrl,
                auditDate: auditDate,
                searchData: savedAudit.searchData
              })
            });
            
            if (saveResponse.ok) {
              debugLog(` Saved queryTotals to Supabase (${queryTotals.length} keywords)`, 'success');
              
              // Update localStorage
              try {
                safeSetLocalStorage('last_audit_results', savedAudit);
                debugLog(` Updated localStorage with queryTotals`, 'success');
              } catch (localStorageErr) {
                debugLog(` Failed to update localStorage: ${localStorageErr.message}`, 'warn');
              }
              
              // Re-render the table to show the new data
              renderRankingAiTab();
              debugLog(' Table re-rendered with queryTotals data', 'success');
            } else {
              const errorText = await saveResponse.text();
              debugLog(` Failed to save queryTotals to Supabase: ${saveResponse.status} - ${errorText}`, 'warn');
            }
          } else {
            debugLog(` GSC API did not return queryTotals data`, 'warn');
          }
        } else {
          const errorText = await gscResponse.text();
          debugLog(` Failed to fetch queryTotals from GSC: ${gscResponse.status} - ${errorText}`, 'warn');
        }
      } catch (error) {
        debugLog(` Error manually fetching queryTotals: ${error.message}`, 'error');
      }
    };
    
    window.buildMoneyPageMetrics = function(topPages, schemaAudit) {
      console.warn('[Money Pages]  buildMoneyPageMetrics placeholder called - full implementation not loaded yet. This is a fallback to prevent crashes. The UI will show "No data" until the full implementation loads.');
      // Return empty array as fallback so UI can gracefully handle missing data
      return [];
    };
    
    console.log('[Money Pages]  buildMoneyPageMetrics placeholder assigned to window');
    
    // ======================
    // Ranking & AI module - DEFINE FIRST to ensure it's available
    // ======================
    console.log('[RankingAiModule] Starting module definition at top of script...');
    window.RankingAiModule = (function () {
      console.log('[RankingAiModule] IIFE executing...');
      // Core tracked keywords. Real queries, no mock values.
      // Include both Money and Education terms.
      const TRACKED_KEYWORDS = [
        "alan ranger",
        "beginner photography classes",
        "beginner photography courses",
        "beginners photography course near me",
        "beginning photography lessons",
        "best photography classes",
        "best photography course",
        "best photography workshops",
        "camera courses for beginners",
        "commercial photographer",
        "commercial photography services",
        "corporate photography",
        "free online photography course",
        "hire a photographer",
        "hire a professional photographer",
        "landscape photography courses",
        "landscape photography workshop",
        "Landscape Photography Workshops",
        "landscape photography workshops uk",
        "landscape workshops",
        "lightroom courses",
        "one day photography workshops",
        "online photography courses",
        "online photography lesson",
        "photo editing course",
        "photo workshops",
        "photographer coventry",
        "photographer in coventry",
        "photographic workshops",
        "photography classes",
        "photography classes near me",
        "photography classes online",
        "photography course online",
        "photography courses",
        "photography courses coventry",
        "photography courses for beginners",
        "photography courses near me",
        "photography evening classes",
        "photography gift card",
        "photography gift voucher",
        "photography holidays uk",
        "photography lessons",
        "photography lessons near me",
        "photography lessons online",
        "photography masterclasses",
        "photography mentor",
        "photography presents",
        "photography training",
        "photography tuition",
        "photography tutor",
        "photography vouchers",
        "photography workshops",
        "photography workshops near me",
        "photography workshops uk",
        "private photography lessons",
        "private photography tuition",
        "professional commercial photography",
        "professional photographer",
        "professional photographer coventry",
        "professional photographer near me",
        "rps courses",
        "rps distinctions",
        "uk photography workshops"
      ];

      // API endpoints  adjust if the deployed paths differ.
      // window.apiUrl is already defined at the top level, so we can use it here
      // Also create a local const for use within this scope
      const apiUrl = window.apiUrl;
      
      const SERP_RANK_ENDPOINT = apiUrl('/api/aigeo/serp-rank-test');
      const AI_MODE_ENDPOINT = apiUrl('/api/aigeo/ai-mode-serp-batch-test'); // Using batch endpoint

      let hasLoadedOnce = false;
      let isLoading = false;
      let combinedRows = [];
      let summary = null;

      function normaliseKeyword(k) {
        return (k || "").trim().toLowerCase();
      }

      // Intent-based keyword segment classifier (client-side version)
      function classifyKeywordSegment(keyword, bestUrl) {
        if (!keyword || typeof keyword !== 'string') {
          return 'other';
        }
        
        const normalizedKeyword = keyword.trim().toLowerCase();
        
        // Priority 1: Brand (highest priority)
        const brandTerms = ['alan ranger', 'alanranger', 'alan ranger photography', 'photography academy', 'alan ranger academy'];
        if (brandTerms.some(term => normalizedKeyword.includes(term.toLowerCase()))) {
          return 'brand';
        }
        
        // Priority 2: Money (transactional OR local intent)
        const moneyTerms = ['lesson', 'lessons', 'class', 'classes', 'course', 'courses', 'training', 'workshop', 'workshops', 'mentoring', 'mentor', '1-2-1', '1:1', 'private', 'hire', 'service', 'services', 'photographer', 'booking', 'book', 'price', 'cost', 'voucher', 'gift'];
        const localModifiers = ['near me', 'in coventry', 'coventry', 'birmingham', 'warwick', 'leamington', 'solihull', 'rugby'];
        const hasMoneyTerm = moneyTerms.some(term => normalizedKeyword.includes(term.toLowerCase()));
        const hasLocalModifier = localModifiers.some(term => normalizedKeyword.includes(term.toLowerCase()));
        const hasPostcode = /\b([A-Z]{1,2}\d{1,2}\s?\d?[A-Z]{0,2})\b/i.test(normalizedKeyword);
        
        if (hasMoneyTerm || hasLocalModifier || hasPostcode) {
          return 'money';
        }
        
        // Priority 3: Education (informational/learning intent)
        const educationTerms = ['how to', 'what is', 'guide', 'tutorial', 'tips', 'settings', 'meaning', 'vs', 'difference', 'examples', 'best way to'];
        const techniqueTopics = ['aperture', 'shutter speed', 'iso', 'depth of field', 'histogram', 'dynamic range', 'composition'];
        const hasEducationTerm = educationTerms.some(term => normalizedKeyword.includes(term.toLowerCase()));
        const hasTechniqueTopic = techniqueTopics.some(term => normalizedKeyword.includes(term.toLowerCase()));
        
        if (hasEducationTerm || hasTechniqueTopic) {
          return 'education';
        }
        
        // Priority 4: Other (fallback)
        return 'other';
      }
      
      function classifyPageTypeForKeyword(bestUrl) {
        // Use shared classification function
        if (typeof window.classifyUrlForRankingAi === 'function') {
          const classification = window.classifyUrlForRankingAi(bestUrl || '');
          return classification.pageType;
        }
        return "Landing"; // Default fallback
      }

        const module = {
        TRACKED_KEYWORDS,
        SERP_RANK_ENDPOINT,
        AI_MODE_ENDPOINT,
        normaliseKeyword,
        classifyKeywordSegment,
        classifyPageTypeForKeyword,
        state: () => ({ hasLoadedOnce, isLoading, combinedRows, summary }),
        setLoadedOnce: (value) => { hasLoadedOnce = value; },
        setLoading: (value) => { isLoading = value; },
        setData: (rows, sum) => { 
          // Normalize rows: add segment_norm, segment_display, page_type_norm, page_type_display, impressions30d
          // Use window references since functions may be defined later
          const normSeg = window.normalizeSegment || ((input) => {
            const s = (input ?? "").trim().toLowerCase();
            return s.charAt(0).toUpperCase() + s.slice(1);
          });
          const segLabel = window.segmentLabel || ((s) => s);
          const normPageType = window.normalizePageType || ((pt) => {
            const k = (pt ?? "").trim().toLowerCase();
            return k.charAt(0).toUpperCase() + k.slice(1);
          });
          const pageTypeLab = window.pageTypeLabel || ((pt) => {
            const k = normPageType(pt);
            return k.charAt(0).toUpperCase() + k.slice(1);
          });
          // Get impressions30d for each row using getGscMetricsForKeywordRow (which returns impressions)
          const getGscMetrics = window.getGscMetricsForKeywordRow || (() => null);
          combinedRows = rows.map(r => {
            const segNorm = normSeg(r.segment);
            const segDisplay = segLabel(r.segment);
            const ptNorm = normPageType(r.pageType);
            const ptDisplay = pageTypeLab(r.pageType);
            // Get impressions30d from GSC data - use canonical targetUrl
            const pageUrlForGsc = r.targetUrl || r.ranking_url || r.best_url || '';
            const gscMetrics = getGscMetrics({ query: r.keyword, pageUrl: pageUrlForGsc });
            const impressions30d = gscMetrics && gscMetrics.impressions != null ? gscMetrics.impressions : null;
            return {
              ...r,
              segment_norm: segNorm,
              segment_display: segDisplay,
              page_type_norm: ptNorm,
              page_type_display: ptDisplay,
              impressions30d: impressions30d
            };
          });
          summary = sum; 
        }
      };
      console.log('[RankingAiModule] Module object created:', Object.keys(module));
      return module;
    })();
    
    console.log('[RankingAiModule] Assignment complete. window.RankingAiModule exists:', typeof window.RankingAiModule !== 'undefined');
    console.log('[RankingAiModule] window.RankingAiModule:', window.RankingAiModule);
    
    if (typeof window.RankingAiModule !== 'undefined') {
      console.log('[RankingAiModule]  Successfully assigned to window');
      console.log('[RankingAiModule] TRACKED_KEYWORDS:', window.RankingAiModule.TRACKED_KEYWORDS);
    } else {
      console.error('[RankingAiModule]  FAILED to assign to window');
    }
    
    // Debug logging system
    const debugLogEntries = [];
    let debugLogFilter = 'all'; // 'all', 'warnings-errors'
    
    function debugLog(message, type = 'info') {
      const timestamp = new Date().toISOString();
      const entry = {
        timestamp,
        message,
        type
      };
      debugLogEntries.push(entry);
      
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        // Check if entry should be displayed based on filter
        const shouldShow = debugLogFilter === 'all' || (debugLogFilter === 'warnings-errors' && (type === 'warn' || type === 'error'));
        
        if (shouldShow) {
        const entryDiv = document.createElement('div');
        entryDiv.className = `debug-log-entry ${type}`;
        entryDiv.innerHTML = `<span class="debug-timestamp">[${new Date(timestamp).toLocaleTimeString()}]</span>${message}`;
        logElement.appendChild(entryDiv);
        logElement.scrollTop = logElement.scrollHeight;
        }
      }
      
      // Only log critical errors to browser console (for debugging production issues)
      // All other logs go to UI debug console only
      if (type === 'error') {
        console.error(`[DEBUG ERROR]`, message);
      }
    }
    
    function toggleDebugLogFilter() {
      debugLogFilter = debugLogFilter === 'all' ? 'warnings-errors' : 'all';
      const filterBtn = document.getElementById('debugFilterBtn');
      if (filterBtn) {
        filterBtn.textContent = `Filter: ${debugLogFilter === 'all' ? 'All' : 'Warnings/Errors'}`;
      }
      
      // Re-render all log entries with current filter
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        logElement.innerHTML = '';
        debugLogEntries.forEach(entry => {
          const shouldShow = debugLogFilter === 'all' || (debugLogFilter === 'warnings-errors' && (entry.type === 'warn' || entry.type === 'error'));
          if (shouldShow) {
            const entryDiv = document.createElement('div');
            entryDiv.className = `debug-log-entry ${entry.type}`;
            entryDiv.innerHTML = `<span class="debug-timestamp">[${new Date(entry.timestamp).toLocaleTimeString()}]</span>${entry.message}`;
            logElement.appendChild(entryDiv);
          }
        });
        logElement.scrollTop = logElement.scrollHeight;
      }
    }

    function clearDebugLog() {
      debugLogEntries.length = 0;
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        logElement.innerHTML = '';
      }
      debugLog('Debug log cleared', 'info');
    }
    
    // Initialize filter button text on page load
    window.addEventListener('DOMContentLoaded', () => {
      const filterBtn = document.getElementById('debugFilterBtn');
      if (filterBtn) {
        filterBtn.textContent = `Filter: ${debugLogFilter === 'all' ? 'All' : 'Warnings/Errors'}`;
      }
    });

    function copyDebugLog() {
      // Filter entries based on current filter state
      const filteredEntries = debugLogEntries.filter(entry => {
        return debugLogFilter === 'all' || (debugLogFilter === 'warnings-errors' && (entry.type === 'warn' || entry.type === 'error'));
      });
      
      const logText = filteredEntries.map(entry => 
        `[${entry.timestamp}] [${entry.type.toUpperCase()}] ${entry.message}`
      ).join('\n');
      
      navigator.clipboard.writeText(logText).then(() => {
        debugLog(`Debug log copied to clipboard (${filteredEntries.length} ${debugLogFilter === 'all' ? 'entries' : 'warnings/errors'})`, 'success');
        showStatus(`Debug log copied! (${filteredEntries.length} ${debugLogFilter === 'all' ? 'entries' : 'warnings/errors'})`, 'success');
      }).catch(err => {
        debugLog('Failed to copy log: ' + err.message, 'error');
        showStatus('Failed to copy log', 'error');
      });
    }

    async function loadDebugLogFromSupabase() {
      try {
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (!propertyUrl) {
          debugLog(' Cannot load debug log: Property URL not set', 'warn');
          showStatus('Property URL not set', 'error');
          return;
        }

        debugLog(' Loading debug log from Supabase...', 'info');
        showStatus('Loading debug log from Supabase...', 'info');

        const response = await fetch(apiUrl(`/api/supabase/get-debug-log?propertyUrl=${encodeURIComponent(propertyUrl)}`));
        
        if (!response.ok) {
          const errorText = await response.text();
          debugLog(` Failed to load debug log: ${response.status} - ${errorText}`, 'error');
          showStatus(`Failed to load debug log: ${response.status}`, 'error');
          return;
        }

        const data = await response.json();
        
        if (data.error || !data.logText) {
          debugLog(` ${data.message || 'No debug log found in Supabase'}`, 'warn');
          showStatus(data.message || 'No debug log found', 'warn');
          return;
        }

        // Clear existing log entries
        debugLogEntries.length = 0;
        const logElement = document.getElementById('debugLog');
        if (logElement) {
          logElement.innerHTML = '';
        }

        // Parse log text and populate debugLogEntries
        const lines = data.logText.split('\n');
        let entryCount = 0;
        
        lines.forEach(line => {
          // Match log format: [timestamp] [TYPE] message
          const match = line.match(/^\[([^\]]+)\]\s+\[([^\]]+)\]\s+(.+)$/);
          if (match) {
            const [, timestamp, type, message] = match;
            const normalizedType = type.toLowerCase();
            debugLogEntries.push({
              timestamp,
              message,
              type: normalizedType === 'warn' ? 'warn' : normalizedType === 'error' ? 'error' : normalizedType === 'success' ? 'success' : 'info'
            });
            entryCount++;
          }
        });

        // Re-render with current filter
        if (logElement) {
          logElement.innerHTML = '';
          debugLogEntries.forEach(entry => {
            const shouldShow = debugLogFilter === 'all' || (debugLogFilter === 'warnings-errors' && (entry.type === 'warn' || entry.type === 'error'));
            if (shouldShow) {
              const entryDiv = document.createElement('div');
              entryDiv.className = `debug-log-entry ${entry.type}`;
              entryDiv.innerHTML = `<span class="debug-timestamp">[${new Date(entry.timestamp).toLocaleTimeString()}]</span>${entry.message}`;
              logElement.appendChild(entryDiv);
            }
          });
          logElement.scrollTop = logElement.scrollHeight;
        }

        debugLog(` Loaded ${entryCount} debug log entries from Supabase (audit: ${data.auditDate})`, 'success');
        showStatus(`Loaded ${entryCount} entries from Supabase`, 'success');

      } catch (err) {
        debugLog(` Error loading debug log: ${err.message}`, 'error');
        showStatus(`Error: ${err.message}`, 'error');
      }
    }

    function toggleDebugPanel() {
      const panel = document.getElementById('debugPanel');
      const icon = document.getElementById('debugToggleIcon');
      if (panel.classList.contains('collapsed')) {
        panel.classList.remove('collapsed');
        if (icon) icon.textContent = '';
      } else {
        panel.classList.add('collapsed');
        if (icon) icon.textContent = '';
      }
    }

    // Performance optimization: Defer heavy work to improve INP
    function defer(fn) {
      if (window.requestIdleCallback) {
        requestIdleCallback(fn, { timeout: 800 });
      } else {
        setTimeout(fn, 0);
      }
    }

    const panelInitDone = new Set();

    function setActivePanel(panelId) {
      // 1) fast: toggle active nav styles
      document.querySelectorAll('.aigeo-nav-item').forEach(btn => {
        btn.classList.toggle('is-active', btn.dataset.panel === panelId);
        btn.setAttribute('aria-selected', btn.dataset.panel === panelId ? 'true' : 'false');
      });

      // 2) fast: show/hide panels only (NO rendering work here)
      document.querySelectorAll('.aigeo-panel').forEach(p => {
        const isActive = p.dataset.panel === panelId;
        p.classList.toggle('is-active', isActive);
        
        // CRITICAL: When Portfolio tab becomes active, initialize charts
        if (isActive && panelId === 'portfolio') {
          setTimeout(() => {
            if (typeof window.renderPortfolioTab === 'function') {
              window.renderPortfolioTab();
            }
          }, 100);
        }
        
        // CRITICAL: When Money Pages tab becomes active, re-fetch statuses from database
        if (isActive && panelId === 'money') {
          console.log('[Money Pages] Tab activated - checking if re-fetch needed...', {
            hasMetrics: !!window.moneyPagesMetrics,
            hasRows: !!(window.moneyPagesMetrics && window.moneyPagesMetrics.rows),
            rowCount: window.moneyPagesMetrics?.rows?.length || 0,
            hasPriorityData: !!window.moneyPagePriorityData,
            priorityDataCount: window.moneyPagePriorityData?.length || 0
          });
          
          // Use setTimeout to ensure panel is fully visible before fetching
          setTimeout(async () => {
            // CRITICAL: Fetch statuses for BOTH tables at once to avoid clearing cache multiple times
            // Build combined list of all rows from both tables
            const allStatusRows = [];
            
            // Add Opportunity table rows
            if (window.moneyPagesMetrics && window.moneyPagesMetrics.rows && window.moneyPagesMetrics.rows.length > 0) {
              window.moneyPagesMetrics.rows.forEach(row => {
                allStatusRows.push({
                  keyword: '', // Empty for page-level tasks
                  best_url: row.url,
                  targetUrl: row.url,
                  ranking_url: row.url
                });
              });
            }
            
            // Add Priority table rows
            if (window.moneyPagePriorityData && window.moneyPagePriorityData.length > 0) {
              window.moneyPagePriorityData.forEach(p => {
                allStatusRows.push({
                  keyword: '', // Empty for page-level tasks
                  best_url: p.url,
                  targetUrl: p.url,
                  ranking_url: p.url
                });
              });
            }
            
            // Fetch statuses for ALL rows at once (prevents multiple cache clears)
            if (allStatusRows.length > 0 && typeof window.fetchOptimisationStatuses === 'function') {
              const testUrl = 'https://www.alanranger.com/landscape-photography-workshops';
              const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(testUrl) : testUrl.toLowerCase().trim();
              const key = `::${urlKey}::on_page`;
              const cacheBefore = {
                size: window.optimisationStatusCache?.size || 0,
                hasLandscape: window.optimisationStatusCache?.has(key),
                landscapeValue: window.optimisationStatusCache?.get(key) ? {
                  id: window.optimisationStatusCache.get(key).id,
                  status: window.optimisationStatusCache.get(key).status
                } : null
              };
              
              debugLog(`[Money Pages] Tab switch: Fetching statuses for ${allStatusRows.length} rows (combined from both tables). Cache BEFORE: size=${cacheBefore.size}, hasLandscape=${cacheBefore.hasLandscape}, landscapeId=${cacheBefore.landscapeValue?.id || 'null'}`, 'info');
              
              try {
                await window.fetchOptimisationStatuses(allStatusRows);
                
                const cacheAfter = {
                  size: window.optimisationStatusCache?.size || 0,
                  hasLandscape: window.optimisationStatusCache?.has(key),
                  landscapeValue: window.optimisationStatusCache?.get(key) ? {
                    id: window.optimisationStatusCache.get(key).id,
                    status: window.optimisationStatusCache.get(key).status
                  } : null
                };
                
                debugLog(`[Money Pages] Tab switch: Cache AFTER fetch: size=${cacheAfter.size}, hasLandscape=${cacheAfter.hasLandscape}, landscapeId=${cacheAfter.landscapeValue?.id || 'null'}, status=${cacheAfter.landscapeValue?.status || 'null'}`, cacheAfter.hasLandscape ? 'success' : 'warn');
              } catch (err) {
                debugLog(`[Money Pages] Error re-fetching statuses: ${err.message}`, 'error');
              }
            }
            
            // NOW re-render both tables (statuses are already fetched)
            // Re-render Opportunity table
            if (window.moneyPagesMetrics && window.moneyPagesMetrics.rows && window.moneyPagesMetrics.rows.length > 0) {
              const tableContainer = document.getElementById('money-pages-table-container');
              if (tableContainer && typeof renderMoneyPagesTable === 'function') {
                const currentPage = window.moneyPagesCurrentPage || 1;
                const rowsPerPage = window.moneyPagesRowsPerPage || 10;
                const tableHtml = await renderMoneyPagesTable(window.moneyPagesMetrics.rows, currentPage, rowsPerPage);
                if (tableHtml && typeof tableHtml === 'string' && tableHtml.trim().length > 0) {
                  tableContainer.innerHTML = tableHtml;
                  console.log('[Money Pages]  Opportunity table re-rendered after tab switch');
                }
              }
            }
            
            // Re-render Priority table
            if (window.moneyPagePriorityData && window.moneyPagePriorityData.length > 0) {
              if (typeof renderMoneyPagesTable === 'function') {
                const filters = {
                  typeFilter: window.moneyPagesTypeFilter || 'all',
                  minImpr: window.moneyPagesMinImpr || 0,
                  matrixFilter: window.moneyPagesMatrixFilter || null
                };
                await renderMoneyPagesTable(null, filters);
                console.log('[Money Pages]  Priority table re-rendered after tab switch');
              }
            }
          }, 100); // Small delay to ensure panel is visible
        }
        p.hidden = !isActive; // Explicitly set hidden attribute
      });
    }

    function ensurePanelRendered(panelId) {
      if (panelInitDone.has(panelId)) return;

      // IMPORTANT: only do heavy first-time render here
      // e.g. build big tables, compute summaries, populate dropdowns
      if (panelId === 'ranking') {
        // Fix DOM structure first
        fixRankingPanelStructure();
        // Load data and render ranking panel
        (async () => {
          debugLog(' Ranking panel: Loading data from storage...', 'info');
          const storedData = await loadRankingAiDataFromStorage(false);
          if (storedData && storedData.combinedRows && storedData.summary) {
            const mod = window.RankingAiModule;
            if (mod) {
              const normalizedSummary = normalizeSummaryFields(storedData.summary);
              mod.setData(storedData.combinedRows, normalizedSummary);
              mod.setLoadedOnce(true);
              renderRankingAiTab();
              const lastRunEl = document.getElementById("ranking-ai-last-run");
              if (lastRunEl && storedData.timestamp) {
                const date = new Date(storedData.timestamp);
                // Format in GMT/UTC: "DD MMM YYYY, HH:MM:SS GMT"
                const day = String(date.getUTCDate()).padStart(2, '0');
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const month = monthNames[date.getUTCMonth()];
                const year = date.getUTCFullYear();
                const hours = String(date.getUTCHours()).padStart(2, '0');
                const minutes = String(date.getUTCMinutes()).padStart(2, '0');
                const seconds = String(date.getUTCSeconds()).padStart(2, '0');
                const formatted = `${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
                lastRunEl.textContent = `Last run: ${formatted}`;
              }
            }
          } else {
            const mod = window.RankingAiModule;
            if (mod) {
              mod.setData([], { total_keywords: 0, keywords_with_rank: 0, keywords_with_ai_overview: 0, keywords_with_ai_citations: 0, top10: 0, top3: 0 });
              renderRankingAiTab();
            }
          }
          
          // CRITICAL: After initial render, check if queryTotals are available and re-render if needed
          // This ensures CTR/Impressions columns are populated even if loadAuditResults() completes after initial render
          (async () => {
            try {
              debugLog(` Checking for queryTotals after initial render...`, 'info');
              const savedAudit = await loadAuditResults();
              debugLog(` loadAuditResults() completed - savedAudit=${!!savedAudit}, searchData=${!!savedAudit?.searchData}, queryTotals=${savedAudit?.searchData?.queryTotals?.length || 0}`, savedAudit?.searchData?.queryTotals?.length > 0 ? 'success' : 'warn');
              if (savedAudit && savedAudit.searchData && Array.isArray(savedAudit.searchData.queryTotals) && savedAudit.searchData.queryTotals.length > 0) {
                debugLog(` queryTotals loaded (${savedAudit.searchData.queryTotals.length} keywords), re-rendering table to show CTR/Impressions`, 'success');
                // Re-render the table to show CTR/Impressions data
                if (typeof renderRankingAiTab === 'function') {
                  renderRankingAiTab();
                  debugLog(` Table re-rendered with queryTotals data`, 'success');
                } else {
                  debugLog(` renderRankingAiTab function not found`, 'warn');
                }
              } else {
                debugLog(` No queryTotals found in savedAudit - searchData=${!!savedAudit?.searchData}, queryTotals type=${typeof savedAudit?.searchData?.queryTotals}, length=${savedAudit?.searchData?.queryTotals?.length || 0}`, 'warn');
                if (savedAudit && savedAudit.searchData) {
                  debugLog(` searchData keys: ${Object.keys(savedAudit.searchData).join(', ')}`, 'warn');
                }
              }
            } catch (err) {
              debugLog(` Error loading queryTotals for re-render: ${err.message}`, 'error');
              debugLog(` Error stack: ${err.stack}`, 'error');
            }
          })();
          
          // Wire up filters and sorting after render
          setTimeout(() => {
            // Fix DOM structure after render
            fixRankingPanelStructure();
            if (typeof wireRankingAiButton === 'function') wireRankingAiButton();
            if (typeof wireRankingFilters === 'function') wireRankingFilters();
            if (typeof wireRankingSorting === 'function') wireRankingSorting();
            if (typeof wireRankingPagination === 'function') wireRankingPagination();
          }, 100);
        })();
      } else if (panelId === 'ai-sources') {
        setTimeout(() => {
          if (typeof wireAiSourcesFilters === 'function') wireAiSourcesFilters();
        }, 100);
        (async () => {
          debugLog(' AI Sources & Influence tab clicked - loading data...', 'info');
          const storedData = await loadRankingAiDataFromStorage(false);
          if (storedData && storedData.combinedRows && storedData.combinedRows.length > 0) {
            const mod = window.RankingAiModule;
            if (mod) {
              const normalizedSummary = normalizeSummaryFields(storedData.summary);
              mod.setData(storedData.combinedRows, normalizedSummary);
              debugLog(` AI Sources tab: Rendering with ${storedData.combinedRows.length} keywords`, 'success');
              if (typeof renderAiSourcesTab === 'function') {
                renderAiSourcesTab();
              }
            }
          } else {
            debugLog(' AI Sources tab: No keyword data available. Run a Ranking & AI check first.', 'warn');
            if (typeof renderAiSourcesTab === 'function') {
              renderAiSourcesTab(); // Will show empty state
            }
          }
        })();
      } else if (panelId === 'overview') {
        setTimeout(async () => {
          // Use async loadAuditResults to ensure we get latest data from Supabase (including localSignals with locations)
          const saved = await loadAuditResults();
          if (saved && saved.scores && saved.searchData) {
            const trendCanvas = document.getElementById('trendChart');
            if (trendCanvas && typeof displayDashboard === 'function') {
              debugLog('Re-rendering Score Trends chart for Overview tab', 'info');
              // DEBUG: Log localSignals structure when loading Overview tab
              if (saved.localSignals) {
                debugLog(`[Overview Tab] localSignals structure: status=${saved.localSignals.status}, hasData=${!!saved.localSignals.data}, hasLocations=${!!saved.localSignals.data?.locations}, locationsCount=${saved.localSignals.data?.locations?.length || 0}`, 'info');
              } else {
                debugLog(`[Overview Tab]  localSignals is missing from saved audit data`, 'warn');
              }
              try {
                await displayDashboard(saved.scores, saved.searchData, saved.snippetReadiness || 0, saved.schemaAudit || null, saved.localSignals || null);
              } catch (err) {
                debugLog(`Error re-rendering trend chart: ${err.message}`, 'warn');
              }
            }
          }
        }, 200);
      } else if (panelId === 'money') {
        setTimeout(async () => {
          const saved = loadAuditResultsSync();
          
          if (typeof renderMoneyPagesTable === 'function') {
            const priorityData = window.moneyPagePriorityData || (saved && saved.moneyPagePriorityData) || [];
            if (priorityData && priorityData.length > 0) {
              debugLog('Re-rendering Money Pages Priority Matrix table', 'info');
              await renderMoneyPagesTable(priorityData);
            }
          }
          
          if (typeof renderMoneyPagesSection === 'function' && saved && saved.scores && saved.scores.moneyPagesMetrics) {
            debugLog('Re-rendering Money Pages section', 'info');
            await renderMoneyPagesSection(saved.scores.moneyPagesMetrics);
            
            // Wait for HTML structure to be created before rendering charts
            setTimeout(() => {
              // Opportunity Mix: render after layout settles (Money tab activation can report 0x0)
              if (saved && saved.scores && saved.scores.moneyPagesMetrics && typeof renderMoneyPagesCategoryChart === 'function') {
                requestAnimationFrame(() => {
                  requestAnimationFrame(() => {
                    renderMoneyPagesCategoryChart(saved.scores.moneyPagesMetrics, 0);
                  });
                });
              }
            }, 200); // Give renderMoneyPagesSection time to create HTML structure
          } else if (saved && saved.scores && saved.scores.moneyPagesMetrics && typeof renderMoneyPagesCategoryChart === 'function') {
            // If renderMoneyPagesSection wasn't called, still try to render charts (structure might already exist)
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                renderMoneyPagesCategoryChart(saved.scores.moneyPagesMetrics, 0);
              });
            });
          }
          
          // Render charts only when panel is visible and canvas has dimensions
          // Wait a bit longer to ensure HTML structure is created
          setTimeout(() => {
            const renderMoneyCharts = () => {
            const moneyPanel = document.querySelector('.aigeo-panel[data-panel="money"]');
            const isPanelVisible = moneyPanel && moneyPanel.classList.contains('is-active') && 
                                   window.getComputedStyle(moneyPanel).display !== 'none';
            
            if (!isPanelVisible) {
              debugLog(' Money Pages charts: Panel not visible yet, will retry', 'warn');
              setTimeout(renderMoneyCharts, 200);
              return;
            }
            
            const volumeCanvas = document.getElementById('moneyPagesVolumeChart');
            const rateCanvas = document.getElementById('moneyPagesRateChart');
            if ((volumeCanvas || rateCanvas) && typeof renderMoneyPagesTrendChart === 'function') {
              const volumeRect = volumeCanvas ? volumeCanvas.getBoundingClientRect() : { width: 0, height: 0 };
              const rateRect = rateCanvas ? rateCanvas.getBoundingClientRect() : { width: 0, height: 0 };
              if ((volumeRect.width === 0 || volumeRect.height === 0) && (rateRect.width === 0 || rateRect.height === 0)) {
                debugLog(' Money Pages trend charts: Canvases have zero dimensions, will retry', 'warn');
                setTimeout(renderMoneyCharts, 200);
                return;
              }
              
              const propertyUrl = document.getElementById('propertyUrl')?.value;
              if (propertyUrl) {
                const endDate = new Date();
                const startDate = new Date();
                startDate.setFullYear(startDate.getFullYear() - 1);
                const startDateStr = startDate.toISOString().split('T')[0];
                const endDateStr = endDate.toISOString().split('T')[0];
                
                // Use apiUrl helper so this works both on Vercel and when opened locally (file://)
                const urlHelper = window.apiUrl || ((path) => {
                  const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || !window.location.hostname;
                  const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
                  const cleanPath = path.startsWith('/') ? path : `/${path}`;
                  return `${baseUrl}${cleanPath}`;
                });
                fetch(urlHelper(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDateStr}`))
                  .then(res => res.json())
                  .then(json => {
                    if (json.status === 'ok' && json.data) {
                      // Extract last GSC timeseries date from API response if available
                      if (json.timeseries && Array.isArray(json.timeseries) && json.timeseries.length > 0) {
                        const timeseriesDates = json.timeseries
                          .map(ts => ts.date)
                          .filter(date => date)
                          .sort()
                          .reverse();
                        if (timeseriesDates.length > 0) {
                          window.lastGscTimeseriesDate = timeseriesDates[0];
                          debugLog(`Money Pages Trend: Set last GSC timeseries date from API: ${window.lastGscTimeseriesDate}`, 'info');
                        }
                      } else {
                        debugLog(`Money Pages Trend: No timeseries data in API response`, 'warn');
                      }
                      
                      debugLog(`Money Pages Trend: About to render chart with ${json.data ? json.data.length : 0} history records`, 'info');
                      
                      requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                          const volumeCanvas = document.getElementById('moneyPagesVolumeChart');
                          const rateCanvas = document.getElementById('moneyPagesRateChart');
                          if (volumeCanvas && rateCanvas) {
                            const volumeRect = volumeCanvas.getBoundingClientRect();
                            const rateRect = rateCanvas.getBoundingClientRect();
                            debugLog(`Money Pages Trend: Canvas dimensions - Volume: ${volumeRect.width}x${volumeRect.height}, Rate: ${rateRect.width}x${rateRect.height}`, 'info');
                            if (volumeRect.width > 0 && volumeRect.height > 0 && rateRect.width > 0 && rateRect.height > 0) {
                              debugLog(`Money Pages Trend: Calling renderMoneyPagesTrendChart with ${json.data.length} records`, 'info');
                              renderMoneyPagesTrendChart(json.data);
                            } else {
                              debugLog(' Money Pages trend charts: Canvases still have zero dimensions, retrying...', 'warn');
                              // Set explicit dimensions and retry
                              [volumeCanvas, rateCanvas].forEach(canvas => {
                                canvas.width = canvas.offsetWidth || canvas.parentElement?.clientWidth || 800;
                                canvas.height = canvas.offsetHeight || 300;
                              });
                              setTimeout(() => {
                                const volumeRect2 = volumeCanvas.getBoundingClientRect();
                                const rateRect2 = rateCanvas.getBoundingClientRect();
                                if (volumeRect2.width > 0 && volumeRect2.height > 0 && rateRect2.width > 0 && rateRect2.height > 0) {
                                  renderMoneyPagesTrendChart(json.data);
                                } else {
                                  setTimeout(() => renderMoneyCharts(), 200);
                                }
                              }, 100);
                            }
                          } else {
                            debugLog(' Money Pages trend charts: Canvas elements not found', 'warn');
                          }
                        });
                      });
                    } else {
                      debugLog(` Money Pages trend chart: API returned error or no data. Status: ${json.status}`, 'warn');
                    }
                  })
                  .catch(err => {
                    debugLog(` Error fetching history for trend chart: ${err.message}`, 'error');
                    debugLog(`Money Pages trend chart fetch error details: ${err.stack || err.toString()}`, 'error');
                  });
              }
            }
            
            const sparklineCanvas = document.getElementById('money-kpi-sparkline');
            if (sparklineCanvas && typeof loadAuditHistoryAndRenderKpis === 'function') {
              const rect = sparklineCanvas.getBoundingClientRect();
              if (rect.width === 0 || rect.height === 0) {
                debugLog(' Money KPI sparkline: Canvas has zero dimensions, will retry', 'warn');
                setTimeout(renderMoneyCharts, 200);
                return;
              }
              
              const propertyUrl = document.getElementById('propertyUrl')?.value;
              if (propertyUrl) {
                requestAnimationFrame(() => {
                  requestAnimationFrame(() => {
                    const canvas = document.getElementById('money-kpi-sparkline');
                    if (canvas) {
                      const rect = canvas.getBoundingClientRect();
                      if (rect.width > 0 && rect.height > 0) {
                        loadAuditHistoryAndRenderKpis(propertyUrl);
                      } else {
                        debugLog(' Money KPI sparkline: Canvas still has zero dimensions, retrying...', 'warn');
                        setTimeout(() => renderMoneyCharts(), 200);
                      }
                    }
                  });
                });
              }
            }
            };
            
            // Start rendering charts with retry logic
            renderMoneyCharts();
          }, 300); // Wait 300ms to ensure HTML structure is created
          
          // Wire up KPI metric selector
          if (typeof window.wireMoneyKpiMetricSelector === 'function') {
            window.wireMoneyKpiMetricSelector();
          }
          
          if (typeof window.wireTopLevelFilter === 'function') {
            window.wireTopLevelFilter();
          }
          if (typeof window.wirePriorityActionsFilters === 'function') {
            window.wirePriorityActionsFilters();
          }
        }, 100);
      }

      // Mark panel as initialized
      panelInitDone.add(panelId);
    }

    // Portfolio Tab Functions
    let portfolioDeltaChart = null;
    
    window.renderPortfolioTab = async function() {
      debugLog(' Rendering Portfolio tab...', 'info');
      
      // Initialize chart if not already done
      if (!portfolioDeltaChart) {
        await initializePortfolioChart();
      }
      
      // Load and render data
      await loadPortfolioData();
      await renderPortfolioTable();
    };

    async function initializePortfolioChart() {
      const canvas = document.getElementById('portfolio-delta-chart');
      if (!canvas) {
        debugLog(' Portfolio chart canvas not found', 'warn');
        return;
      }

      const ctx = canvas.getContext('2d');
      
      // Destroy existing chart if it exists
      if (portfolioDeltaChart) {
        portfolioDeltaChart.destroy();
      }

      portfolioDeltaChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Delta',
            data: [],
            borderColor: '#E57200',
            backgroundColor: 'rgba(229, 114, 0, 0.15)',
            borderWidth: 2,
            tension: 0.4,
            fill: true,
            pointRadius: 4,
            pointHoverRadius: 6,
            pointBackgroundColor: '#E57200',
            pointBorderColor: '#ffffff',
            pointBorderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                color: 'var(--dark-text)',
                font: { size: 12, weight: '600' },
                padding: 15
              }
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              backgroundColor: 'rgba(26, 31, 46, 0.95)',
              titleColor: '#ffffff',
              bodyColor: 'var(--dark-text)',
              borderColor: 'var(--dark-border)',
              borderWidth: 1,
              padding: 12,
              displayColors: true,
              callbacks: {
                label: function(context) {
                  const value = context.parsed.y;
                  if (value === null) return 'No data';
                  const kpi = document.getElementById('portfolio-kpi-select')?.value || 'ctr_28d';
                  if (kpi === 'ctr_28d') {
                    return `${value >= 0 ? '+' : ''}${value.toFixed(2)}pp`;
                  } else if (kpi === 'avg_position') {
                    return `${value >= 0 ? '+' : ''}${value.toFixed(1)} (${value < 0 ? 'improved' : 'worsened'})`;
                  } else {
                    return `${value >= 0 ? '+' : ''}${value.toLocaleString()}`;
                  }
                }
              }
            }
          },
          scales: {
            x: {
              display: true,
              title: {
                display: true,
                text: 'Date',
                color: '#ffffff',
                font: { size: 13, weight: '600' }
              },
              ticks: {
                color: '#ffffff',
                font: { size: 11, weight: '500' }
              },
              grid: {
                color: 'rgba(55, 65, 81, 0.3)',
                drawBorder: false
              }
            },
            y: {
              display: true,
              title: {
                display: true,
                text: 'Delta',
                color: '#ffffff',
                font: { size: 13, weight: '600' }
              },
              ticks: {
                color: '#ffffff',
                font: { size: 11, weight: '500' },
                callback: function(value) {
                  const kpi = document.getElementById('portfolio-kpi-select')?.value || 'ctr_28d';
                  if (kpi === 'ctr_28d') {
                    return value.toFixed(1) + 'pp';
                  }
                  return value;
                }
              },
              grid: {
                color: 'rgba(55, 65, 81, 0.3)',
                drawBorder: false
              },
              zeroLine: {
                color: 'var(--dark-border)',
                width: 2
              }
            }
          }
        }
      });
    }

    async function loadPortfolioData() {
      const kpiSelect = document.getElementById('portfolio-kpi-select')?.value || 'ctr_28d';
      const segment = document.getElementById('portfolio-segment-select')?.value || 'all_tracked';
      const scope = document.getElementById('portfolio-scope-toggle')?.value || 'active_only';
      const timeGrain = document.getElementById('portfolio-time-grain')?.value || 'weekly';

      // Map UI KPI to portfolio_segment_metrics_28d field
      const kpiFieldMap = {
        'ctr_28d': 'ctr_28d',
        'clicks_28d': 'clicks_28d',
        'impressions_28d': 'impressions_28d',
        'avg_position': 'position_28d',
        'ai_citations': 'ai_citations_28d',
        'ai_overview': 'ai_overview_present_count'
      };
      
      const kpiField = kpiFieldMap[kpiSelect];
      if (!kpiField && kpiSelect !== 'ai_citations' && kpiSelect !== 'ai_overview') {
        debugLog(` KPI ${kpiSelect} not supported in segment metrics`, 'warn');
        return;
      }
      
      // Map scope
      const scopeMap = {
        'active_only': 'active_cycles_only',
        'all': 'all_tracked'
      };
      const mappedScope = scopeMap[scope] || scope;

      try {
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (!propertyUrl) {
          debugLog(' No property URL found for portfolio data', 'warn');
          return;
        }
        
        // Calculate date range (last ~180 days for chart)
        const toDate = new Date();
        const fromDate = new Date();
        fromDate.setDate(fromDate.getDate() - 180);
        
        const params = new URLSearchParams({ 
          siteUrl: propertyUrl,
          segment,
          scope: mappedScope,
          from: fromDate.toISOString(),
          to: toDate.toISOString(),
          order: 'asc' // Chronological for chart
        });
        
        const response = await fetch(apiUrl(`/api/supabase/get-portfolio-segment-metrics?${params}`));
        
        if (!response.ok) {
          const errorText = await response.text();
          debugLog(` Portfolio API error: ${response.status} - ${errorText}`, 'error');
          throw new Error(`API error: ${response.status}`);
        }
        
        const data = await response.json();
        const metrics = data.metrics || [];
        
        debugLog(` Portfolio data loaded: ${metrics.length} metrics for segment=${segment}, scope=${mappedScope}, kpi=${kpiSelect}`, 'info');
        
        if (metrics.length === 0) {
          debugLog(' No portfolio metrics found - check segment and scope filters', 'warn');
          if (portfolioDeltaChart) {
            portfolioDeltaChart.data.labels = [];
            portfolioDeltaChart.data.datasets[0].data = [];
            portfolioDeltaChart.update();
          }
          return;
        }
        
        // Bucket by time grain and compute deltas
        // Use created_at (when the audit was run) as the primary date for bucketing
        // This ensures audits run on different days get different buckets, even if they share the same date_end
        // For monthly bucketing, also check run_id if it's in YYYY-MM format
        const buckets = new Map(); // key: bucket label, value: { value, date }
        
        metrics.forEach(m => {
          // Determine the date to use for bucketing:
          // Priority order:
          // 1. If run_id is in YYYY-MM format, use that for monthly bucketing (historical backfill)
          // 2. If run_id is in YYYY-MM-DD format, use that (most reliable for distinguishing different audit runs)
          // 3. Otherwise, use created_at (when the record was inserted)
          // 4. Fallback to date_end if nothing else is available
          let dateForBucket = null;
          let bucketKey = null;
          
          if (timeGrain === 'monthly' && m.run_id) {
            if (m.run_id.match(/^\d{4}-\d{2}$/)) {
              // Monthly: use run_id directly if it's in YYYY-MM format (for historical backfill)
              bucketKey = m.run_id;
              dateForBucket = new Date(m.run_id + '-01');
            } else if (m.run_id.match(/^\d{4}-\d{2}-\d{2}$/)) {
              // If run_id is in YYYY-MM-DD format, extract YYYY-MM for monthly bucketing
              dateForBucket = new Date(m.run_id);
              // For monthly bucketing, use the month from the date-based run_id
              bucketKey = `${dateForBucket.getFullYear()}-${String(dateForBucket.getMonth() + 1).padStart(2, '0')}`;
            }
          } else if (m.run_id && m.run_id.match(/^\d{4}-\d{2}-\d{2}$/)) {
            // If run_id is in YYYY-MM-DD format, use that (most reliable - represents when audit was actually run)
            dateForBucket = new Date(m.run_id);
          } else if (m.created_at) {
            // Use created_at (when the record was inserted) - less ideal since multiple records might share same created_at
            dateForBucket = new Date(m.created_at);
          } else if (m.date_end) {
            // Fallback to date_end (least ideal since all audits may share the same date_end)
            dateForBucket = new Date(m.date_end);
          } else {
            debugLog(` No valid date found for metric: run_id=${m.run_id}, date_end=${m.date_end}, created_at=${m.created_at}`, 'warn');
            return; // Skip this metric
          }
          
          if (!dateForBucket || isNaN(dateForBucket.getTime())) {
            debugLog(` Invalid date for metric: run_id=${m.run_id}, date_end=${m.date_end}, created_at=${m.created_at}`, 'warn');
            return; // Skip this metric
          }
          
          if (!bucketKey) {
            // Calculate bucket key from date
            if (timeGrain === 'weekly') {
              // ISO week: get Monday of the week
              const dayOfWeek = dateForBucket.getDay();
              const diff = dateForBucket.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1);
              const monday = new Date(dateForBucket);
              monday.setDate(diff);
              bucketKey = monday.toISOString().split('T')[0]; // Use Monday date as key
            } else {
              // Monthly: YYYY-MM
              bucketKey = `${dateForBucket.getFullYear()}-${String(dateForBucket.getMonth() + 1).padStart(2, '0')}`;
            }
          }
          
          // Keep the LAST snapshot in each bucket (by created_at, which represents when the audit was run)
          const comparisonDate = m.created_at ? new Date(m.created_at) : (m.date_end ? new Date(m.date_end) : dateForBucket);
          if (!buckets.has(bucketKey) || comparisonDate > buckets.get(bucketKey).date) {
            const value = kpiField === 'ctr_28d' ? parseFloat(m.ctr_28d || 0) :
                          kpiField === 'clicks_28d' ? parseFloat(m.clicks_28d || 0) :
                          kpiField === 'impressions_28d' ? parseFloat(m.impressions_28d || 0) :
                          kpiField === 'position_28d' ? (m.position_28d !== null && m.position_28d !== undefined && !isNaN(parseFloat(m.position_28d)) ? parseFloat(m.position_28d) : null) :
                          kpiField === 'ai_citations_28d' ? (m.ai_citations_28d ? parseInt(m.ai_citations_28d) : 0) :
                          kpiField === 'ai_overview_present_count' ? (m.ai_overview_present_count ? parseInt(m.ai_overview_present_count) : 0) : null;
            
            buckets.set(bucketKey, { value, date: comparisonDate });
          }
        });
        
        debugLog(` Bucketed into ${buckets.size} time buckets (${timeGrain}) from ${metrics.length} metrics`, 'info');
        
        // Sort buckets by date
        let sortedBuckets = Array.from(buckets.entries())
          .sort((a, b) => a[1].date - b[1].date);
        
        // If we only have 1 bucket, try daily bucketing instead (if weekly was selected)
        if (sortedBuckets.length < 2 && timeGrain === 'weekly' && metrics.length >= 2) {
          debugLog(` Only 1 weekly bucket from ${metrics.length} metrics - falling back to daily bucketing`, 'warn');
          
          // Re-bucket by day instead
          const dailyBuckets = new Map();
          metrics.forEach(m => {
            let dateForBucket = null;
            if (m.run_id && m.run_id.match(/^\d{4}-\d{2}-\d{2}$/)) {
              dateForBucket = new Date(m.run_id);
            } else if (m.created_at) {
              dateForBucket = new Date(m.created_at);
            } else if (m.date_end) {
              dateForBucket = new Date(m.date_end);
            }
            
            if (dateForBucket && !isNaN(dateForBucket.getTime())) {
              const dayKey = dateForBucket.toISOString().split('T')[0]; // YYYY-MM-DD
              const comparisonDate = m.created_at ? new Date(m.created_at) : (m.date_end ? new Date(m.date_end) : dateForBucket);
              
              if (!dailyBuckets.has(dayKey) || comparisonDate > dailyBuckets.get(dayKey).date) {
                const value = kpiField === 'ctr_28d' ? parseFloat(m.ctr_28d || 0) :
                              kpiField === 'clicks_28d' ? parseFloat(m.clicks_28d || 0) :
                              kpiField === 'impressions_28d' ? parseFloat(m.impressions_28d || 0) :
                              kpiField === 'position_28d' ? (m.position_28d !== null && m.position_28d !== undefined && !isNaN(parseFloat(m.position_28d)) ? parseFloat(m.position_28d) : null) :
                              kpiField === 'ai_citations_28d' ? (m.ai_citations_28d ? parseInt(m.ai_citations_28d) : 0) :
                              kpiField === 'ai_overview_present_count' ? (m.ai_overview_present_count ? parseInt(m.ai_overview_present_count) : 0) : null;
                
                dailyBuckets.set(dayKey, { value, date: comparisonDate });
              }
            }
          });
          
          const sortedDailyBuckets = Array.from(dailyBuckets.entries())
            .sort((a, b) => a[1].date - b[1].date);
          
          if (sortedDailyBuckets.length >= 2) {
            debugLog(` Daily bucketing: ${sortedDailyBuckets.length} buckets from ${metrics.length} metrics`, 'success');
            // Use daily buckets instead
            sortedBuckets = sortedDailyBuckets;
            timeGrain = 'daily'; // Update for label formatting
          }
        }
        
        // If we still only have 1 bucket, we can't show deltas
        if (sortedBuckets.length < 2) {
          if (portfolioDeltaChart) {
            portfolioDeltaChart.data.labels = [];
            portfolioDeltaChart.data.datasets[0].data = [];
            portfolioDeltaChart.update();
          }
          
          // Show empty state message with clear explanation
          const canvas = document.getElementById('portfolio-delta-chart');
          if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'var(--dark-text)';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            
            let message = '';
            if (timeGrain === 'weekly') {
              message = 'Weekly deltas require audits from different weeks.\nRun audits on different weeks to see weekly trends.';
            } else if (timeGrain === 'monthly') {
              message = 'Monthly deltas require audits from different months.\nRun audits across multiple months to see monthly trends.';
            } else {
              message = 'Need at least 2 different time periods to show deltas.\nRun another audit to see changes over time.';
            }
            
            const lines = message.split('\n');
            const lineHeight = 20;
            const startY = canvas.height / 2 - (lines.length - 1) * lineHeight / 2;
            lines.forEach((line, i) => {
              ctx.fillText(line, canvas.width / 2, startY + i * lineHeight);
            });
          }
          return;
        }
        
        // Compute deltas
        const labels = [];
        const deltas = [];
        
        sortedBuckets.forEach(([bucketKey, bucket], index) => {
          let label;
          if (timeGrain === 'daily') {
            // Daily: show date as "DD MMM"
            label = new Date(bucketKey).toLocaleDateString('en-GB', { day: '2-digit', month: 'short' });
          } else if (timeGrain === 'weekly') {
            // Weekly: show Monday date as "DD MMM"
            label = new Date(bucketKey).toLocaleDateString('en-GB', { day: '2-digit', month: 'short' });
          } else {
            // Monthly: show as "MMM-YY" (e.g., "Jan 25")
            const monthDate = new Date(bucketKey + '-01');
            const monthName = monthDate.toLocaleDateString('en-GB', { month: 'short' });
            const yearShort = bucketKey.split('-')[0].slice(2);
            label = `${monthName} ${yearShort}`;
          }
          
          if (index === 0) {
            // First bucket: no delta
            labels.push(label);
            deltas.push(null); // No previous value to compare
          } else {
            const prevBucket = sortedBuckets[index - 1][1];
            const delta = bucket.value !== null && prevBucket.value !== null 
              ? bucket.value - prevBucket.value 
              : null;
            
            labels.push(label);
            deltas.push(delta);
          }
        });
        
        // Reverse arrays so latest is on the right
        labels.reverse();
        deltas.reverse();

        if (portfolioDeltaChart) {
          // Format deltas for display
          const formattedDeltas = deltas.map(d => {
            if (d === null) return null;
            // CTR delta: convert ratio to percentage points
            if (kpiSelect === 'ctr_28d') {
              return d * 100; // Convert ratio delta to percentage points
            }
            // AI citations and AI overview are already integers, no conversion needed
            return d;
          });
          
          portfolioDeltaChart.data.labels = labels;
          portfolioDeltaChart.data.datasets[0].data = formattedDeltas;
          portfolioDeltaChart.data.datasets[0].label = `Delta (${kpiSelect})`;
          // Use brand orange (#E57200) for line and points - use hex directly, not CSS variable
          portfolioDeltaChart.data.datasets[0].borderColor = '#E57200';
          portfolioDeltaChart.data.datasets[0].pointBackgroundColor = '#E57200';
          portfolioDeltaChart.data.datasets[0].pointBorderColor = '#ffffff';
          portfolioDeltaChart.data.datasets[0].pointBorderWidth = 2;
          // Simple brand orange fill (no gradient function - Chart.js can have issues with functions)
          portfolioDeltaChart.data.datasets[0].backgroundColor = 'rgba(229, 114, 0, 0.15)';
          
          // Update Y-axis label
          if (kpiSelect === 'ctr_28d') {
            portfolioDeltaChart.options.scales.y.title.text = 'Delta (percentage points)';
          } else if (kpiSelect === 'avg_position') {
            portfolioDeltaChart.options.scales.y.title.text = 'Delta (negative is improvement)';
          } else {
            portfolioDeltaChart.options.scales.y.title.text = `Delta (${kpiSelect})`;
          }
          
          portfolioDeltaChart.update('none'); // Use 'none' animation mode for faster updates
          debugLog(' Portfolio chart updated', 'success');
        } else {
          debugLog(' Portfolio chart not initialized', 'warn');
        }
      } catch (err) {
        debugLog(`Error loading portfolio data: ${err.message}`, 'error');
      }
    }

    async function renderPortfolioTable() {
      const kpi = document.getElementById('portfolio-table-kpi-select')?.value || 'ctr_28d';
      const segments = ['money', 'landing', 'event', 'product', 'all_tracked'];
      const segmentLabels = {
        'money': 'Money Pages',
        'landing': 'Landing',
        'event': 'Event',
        'product': 'Product',
        'all_tracked': 'All tracked'
      };
      
      // Map UI KPI to portfolio_segment_metrics_28d field
      const kpiFieldMap = {
        'ctr_28d': 'ctr_28d',
        'clicks_28d': 'clicks_28d',
        'impressions_28d': 'impressions_28d',
        'avg_position': 'position_28d',
        'ai_citations': 'ai_citations_28d',
        'ai_overview': 'ai_overview_present_count'
      };
      
      const kpiField = kpiFieldMap[kpi];
      if (!kpiField && kpi !== 'ai_citations' && kpi !== 'ai_overview') {
        debugLog(` KPI ${kpi} not supported in segment metrics`, 'warn');
        return;
      }
      
      try {
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (!propertyUrl) {
          debugLog(' No property URL found for portfolio table', 'warn');
          return;
        }
        
        // Calculate date range (last 13 months to get previous month for trend)
        const toDate = new Date();
        const fromDate = new Date();
        fromDate.setMonth(fromDate.getMonth() - 13);
        
        // Fetch data for all segments
        const allData = {};
        for (const segment of segments) {
          const params = new URLSearchParams({ 
            siteUrl: propertyUrl,
            segment,
            scope: 'active_cycles_only',
            from: fromDate.toISOString(),
            to: toDate.toISOString(),
            order: 'desc' // Latest first
          });
          const response = await fetch(apiUrl(`/api/supabase/get-portfolio-segment-metrics?${params}`));
          
          if (response.ok) {
            const data = await response.json();
            allData[segment] = data.metrics || [];
          } else {
            allData[segment] = [];
          }
        }

        // Generate last 12 months (always shows all 12 months, even if no data exists)
        // This ensures consistent table structure regardless of data availability
        const months = [];
        const today = new Date();
        const currentYear = today.getFullYear();
        const currentMonth = today.getMonth(); // 0-indexed (0=Jan, 11=Dec)
        
        // Generate 12 months going backwards from current month
        // Calculate explicitly to avoid Date arithmetic issues
        for (let i = 11; i >= 0; i--) {
          let targetMonth = currentMonth - i;
          let targetYear = currentYear;
          
          // Handle negative months (roll back to previous year)
          if (targetMonth < 0) {
            targetMonth += 12;
            targetYear -= 1;
          }
          
          // Format as YYYY-MM
          const monthStr = `${targetYear}-${String(targetMonth + 1).padStart(2, '0')}`;
          months.push(monthStr);
        }
        
        // Ensure we have exactly 12 unique months (no duplicates)
        const uniqueMonths = [...new Set(months)];
        if (uniqueMonths.length !== 12) {
          debugLog(` Expected 12 unique months but got ${uniqueMonths.length}: ${months.join(', ')}`, 'warn');
        }
        // Use unique months to avoid duplicates, maintain original order
        months.length = 0;
        months.push(...uniqueMonths);

        // Build table
        const table = document.getElementById('portfolio-monthly-table');
        if (!table) return;

        // Clear existing content
        const thead = table.querySelector('thead tr');
        const tbody = table.querySelector('tbody');
        const segmentTh = document.createElement('th');
        segmentTh.style.cssText = 'text-align: left; padding: 0.75rem; border-bottom: 2px solid var(--dark-border); font-weight: 600; background: rgba(55, 65, 81, 0.5); color: var(--dark-text);';
        segmentTh.textContent = 'Segment';
        segmentTh.title = 'Page segment: Filter metrics by page type';
        thead.innerHTML = '';
        thead.appendChild(segmentTh);
        tbody.innerHTML = '';

        // Add month headers
        months.forEach(month => {
          const th = document.createElement('th');
          th.style.cssText = 'text-align: center; padding: 0.75rem; border-bottom: 2px solid var(--dark-border); font-weight: 600; background: rgba(55, 65, 81, 0.5); color: var(--dark-text);';
          const monthDate = new Date(month + '-01');
          // Format as "MMM-YY" (e.g., "Jan 25")
          const monthName = monthDate.toLocaleDateString('en-GB', { month: 'short' });
          const yearShort = month.split('-')[0].slice(2);
          th.textContent = `${monthName} ${yearShort}`;
          th.title = `Value for ${monthDate.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' })}: Last snapshot from this month (rolling 28-day window)`;
          thead.appendChild(th);
        });

        // Add sparkline column
        const sparklineTh = document.createElement('th');
        sparklineTh.style.cssText = 'text-align: center; padding: 0.75rem; border-bottom: 2px solid var(--dark-border); font-weight: 600; background: rgba(55, 65, 81, 0.5); color: var(--dark-text);';
        sparklineTh.textContent = 'Trend';
        sparklineTh.title = 'Month-over-month change: Shows the difference between this month and the previous month ( = increase,  = decrease)';
        thead.appendChild(sparklineTh);

        // Format value based on KPI
        const formatValue = (value, kpiKey) => {
          if (value === null || value === undefined) return '';
          
          if (kpiKey === 'ctr_28d') {
            // CTR is stored as ratio (0-1), display as percentage
            return (parseFloat(value) * 100).toFixed(1) + '%';
          } else if (kpiKey === 'clicks_28d' || kpiKey === 'impressions_28d' || kpiKey === 'ai_citations' || kpiKey === 'ai_overview') {
            // Counts - format with separators
            return parseInt(value).toLocaleString();
          } else if (kpiKey === 'avg_position') {
            // Position - 1 decimal
            return parseFloat(value).toFixed(1);
          } else {
            return parseFloat(value).toFixed(2);
          }
        };

        // Add rows for each segment
        segments.forEach(segment => {
          const row = document.createElement('tr');
          row.style.cursor = 'help';
          
          // Segment name
          const segmentCell = document.createElement('td');
          segmentCell.style.cssText = 'padding: 0.75rem; border-bottom: 1px solid var(--dark-border); font-weight: 600; color: var(--dark-text);';
          segmentCell.textContent = segmentLabels[segment] || segment;
          // Add tooltip based on segment
          const segmentTooltips = {
            'money': 'All commercial pages: landing pages, event pages, and product pages combined',
            'landing': 'Landing pages: general commercial landing pages (not events or products)',
            'event': 'Event pages: photography workshop and course event pages',
            'product': 'Product pages: photography service and product pages',
            'all_tracked': 'All pages that have active optimisation tasks tracking them'
          };
          segmentCell.title = segmentTooltips[segment] || segment;
          row.appendChild(segmentCell);

          // Month values
          const monthValues = [];
          months.forEach(month => {
            const cell = document.createElement('td');
            cell.style.cssText = 'text-align: center; padding: 0.75rem; border-bottom: 1px solid var(--dark-border); color: var(--dark-text);';
            
            // Find the LAST snapshot in this month (bucket by date_end month or run_id)
            // run_id format can be YYYY-MM (month-based) or YYYY-MM-DD (date-based)
            const monthSnapshots = allData[segment]?.filter(s => {
              // Try to match by run_id first
              if (s.run_id) {
                // If run_id is in YYYY-MM format, match directly
                if (s.run_id.match(/^\d{4}-\d{2}$/)) {
                  return s.run_id === month;
                }
                // If run_id is in YYYY-MM-DD format, extract YYYY-MM and match
                if (s.run_id.match(/^\d{4}-\d{2}-\d{2}$/)) {
                  const runDate = new Date(s.run_id);
                  const runMonth = `${runDate.getFullYear()}-${String(runDate.getMonth() + 1).padStart(2, '0')}`;
                  return runMonth === month;
                }
              }
              // Otherwise match by date_end month (the actual date range the data represents)
              if (s.date_end) {
                const dateEnd = new Date(s.date_end);
                const dateEndMonth = `${dateEnd.getFullYear()}-${String(dateEnd.getMonth() + 1).padStart(2, '0')}`;
                return dateEndMonth === month;
              }
              // Fallback to created_at month (for backwards compatibility)
              const snapshotDate = new Date(s.created_at);
              const snapshotMonth = `${snapshotDate.getFullYear()}-${String(snapshotDate.getMonth() + 1).padStart(2, '0')}`;
              return snapshotMonth === month;
            });
            
            // Get the latest snapshot in this month
            const snapshot = monthSnapshots?.length > 0 
              ? monthSnapshots.sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0]
              : null;
            
            if (snapshot) {
              // Extract value based on KPI field
              let value = null;
              if (kpiField === 'ctr_28d') {
                value = parseFloat(snapshot.ctr_28d || 0);
              } else if (kpiField === 'clicks_28d') {
                value = parseFloat(snapshot.clicks_28d || 0);
              } else if (kpiField === 'impressions_28d') {
                value = parseFloat(snapshot.impressions_28d || 0);
              } else if (kpiField === 'position_28d') {
                // Handle position: can be string or number from database
                const posValue = snapshot.position_28d;
                if (posValue != null && posValue !== '' && posValue !== 0) {
                  const parsed = typeof posValue === 'string' ? parseFloat(posValue) : Number(posValue);
                  if (!isNaN(parsed) && isFinite(parsed) && parsed > 0) {
                    value = parsed;
                  }
                }
              } else if (kpiField === 'ai_citations_28d') {
                value = snapshot.ai_citations_28d ? parseInt(snapshot.ai_citations_28d) : 0;
              } else if (kpiField === 'ai_overview_present_count') {
                value = snapshot.ai_overview_present_count ? parseInt(snapshot.ai_overview_present_count) : 0;
              }
              
              if (value !== null && value !== undefined) {
                const formatted = formatValue(value, kpi);
                monthValues.push(value);
                
                // Build tooltip text
                const monthDate = new Date(month + '-01');
                const monthName = monthDate.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' });
                let tooltipText = `${segmentLabels[segment]}: ${formatted} for ${monthName}`;
                
                // Find previous month snapshot for trend
                const prevMonth = new Date(month + '-01');
                prevMonth.setMonth(prevMonth.getMonth() - 1);
                const prevMonthStr = `${prevMonth.getFullYear()}-${String(prevMonth.getMonth() + 1).padStart(2, '0')}`;
                
                const prevMonthSnapshots = allData[segment]?.filter(s => {
                  // Try to match by run_id first (if it's in YYYY-MM format)
                  if (s.run_id && s.run_id.match(/^\d{4}-\d{2}$/)) {
                    return s.run_id === prevMonthStr;
                  }
                  // Otherwise match by date_end month
                  if (s.date_end) {
                    const dateEnd = new Date(s.date_end);
                    const dateEndMonth = `${dateEnd.getFullYear()}-${String(dateEnd.getMonth() + 1).padStart(2, '0')}`;
                    return dateEndMonth === prevMonthStr;
                  }
                  // Fallback to created_at month
                  const snapshotDate = new Date(s.created_at);
                  const snapshotMonth = `${snapshotDate.getFullYear()}-${String(snapshotDate.getMonth() + 1).padStart(2, '0')}`;
                  return snapshotMonth === prevMonthStr;
                });
                
                const prevSnapshot = prevMonthSnapshots?.length > 0
                  ? prevMonthSnapshots.sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0]
                  : null;
                
                if (prevSnapshot) {
                  let prevValue = null;
                  if (kpiField === 'ctr_28d') {
                    prevValue = parseFloat(prevSnapshot.ctr_28d || 0);
                  } else if (kpiField === 'clicks_28d') {
                    prevValue = parseFloat(prevSnapshot.clicks_28d || 0);
                  } else if (kpiField === 'impressions_28d') {
                    prevValue = parseFloat(prevSnapshot.impressions_28d || 0);
                  } else if (kpiField === 'position_28d') {
                    // Handle position: can be string or number from database
                    const posValue = prevSnapshot.position_28d;
                    if (posValue != null && posValue !== '' && posValue !== 0) {
                      const parsed = typeof posValue === 'string' ? parseFloat(posValue) : Number(posValue);
                      if (!isNaN(parsed) && isFinite(parsed) && parsed > 0) {
                        prevValue = parsed;
                      }
                    }
                  } else if (kpiField === 'ai_citations_28d') {
                    prevValue = prevSnapshot.ai_citations_28d ? parseInt(prevSnapshot.ai_citations_28d) : 0;
                  } else if (kpiField === 'ai_overview_present_count') {
                    prevValue = prevSnapshot.ai_overview_present_count ? parseInt(prevSnapshot.ai_overview_present_count) : 0;
                  }
                  
                  if (prevValue !== null && prevValue !== undefined) {
                    const delta = value - prevValue;
                    const indicator = delta >= 0 ? '' : '';
                    // Use colors that work well on dark background
                    const color = delta >= 0 ? '#10b981' : '#ef4444';
                    
                    // Format delta based on KPI
                    let deltaFormatted;
                    if (kpi === 'ctr_28d') {
                      deltaFormatted = (delta * 100).toFixed(1) + 'pp'; // Convert ratio delta to percentage points
                      cell.innerHTML = `${formatted} <span style="color: ${color};">${indicator} ${deltaFormatted}</span>`;
                      tooltipText += ` | Change from previous month: ${indicator} ${deltaFormatted}`;
                    } else if (kpi === 'avg_position') {
                      deltaFormatted = Math.abs(delta).toFixed(1);
                      // For position, lower is better, so flip the indicator (negative delta = improvement)
                      const posIndicator = delta < 0 ? '' : '';
                      const posColor = delta < 0 ? '#10b981' : '#ef4444';
                      cell.innerHTML = `${formatted} <span style="color: ${posColor};">${posIndicator} ${deltaFormatted}</span>`;
                      tooltipText += ` | Change from previous month: ${posIndicator} ${deltaFormatted} (${delta < 0 ? 'improved' : 'worsened'})`;
                    } else if (kpi === 'ai_citations' || kpi === 'ai_overview') {
                      // AI metrics are integers, show absolute change
                      deltaFormatted = Math.abs(delta).toString();
                      const actualIndicator = delta < 0 ? '' : '';
                      const actualColor = delta < 0 ? '#10b981' : '#ef4444';
                      cell.innerHTML = `${formatted} <span style="color: ${actualColor};">${actualIndicator} ${deltaFormatted}</span>`;
                      tooltipText += ` | Change from previous month: ${actualIndicator} ${deltaFormatted}`;
                    } else {
                      deltaFormatted = Math.abs(delta).toLocaleString();
                      cell.innerHTML = `${formatted} <span style="color: ${color};">${indicator} ${deltaFormatted}</span>`;
                      tooltipText += ` | Change from previous month: ${indicator} ${deltaFormatted}`;
                    }
                  } else {
                    cell.textContent = formatted;
                  }
                } else {
                  cell.textContent = formatted;
                }
                
                // Add tooltip to cell
                cell.title = tooltipText;
              } else {
                cell.textContent = '';
                monthValues.push(null);
                const monthDate = new Date(month + '-01');
                const monthName = monthDate.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' });
                cell.title = `${segmentLabels[segment]}: No data for ${monthName}`;
              }
            } else {
              cell.textContent = '';
              monthValues.push(null);
              const monthDate = new Date(month + '-01');
              const monthName = monthDate.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' });
              cell.title = `${segmentLabels[segment]}: No data for ${monthName}`;
            }
            row.appendChild(cell);
          });

          // Sparkline (simple text representation)
          const sparklineCell = document.createElement('td');
          sparklineCell.style.cssText = 'text-align: center; padding: 0.75rem; border-bottom: 1px solid var(--dark-border); color: var(--dark-text); font-family: monospace;';
          const validValues = monthValues.filter(v => v !== null);
          if (validValues.length > 0) {
            const min = Math.min(...validValues);
            const max = Math.max(...validValues);
            const range = max - min || 1;
            const sparkline = monthValues.map(v => {
              if (v === null) return ' ';
              const height = Math.round(((v - min) / range) * 7);
              return ''[Math.min(height, 7)] || '';
            }).join('');
            sparklineCell.textContent = sparkline;
            sparklineCell.title = `${segmentLabels[segment]}: Trend visualization across 12 months. Higher bars indicate higher values.`;
          } else {
            sparklineCell.textContent = '';
            sparklineCell.title = `${segmentLabels[segment]}: No trend data available`;
          }
          row.appendChild(sparklineCell);

          tbody.appendChild(row);
        });

      } catch (err) {
        debugLog(`Error rendering portfolio table: ${err.message}`, 'error');
      }
    }


    // Wire up Portfolio controls
    function wirePortfolioControls() {
      const kpiSelect = document.getElementById('portfolio-kpi-select');
      const segmentSelect = document.getElementById('portfolio-segment-select');
      const scopeToggle = document.getElementById('portfolio-scope-toggle');
      const timeGrain = document.getElementById('portfolio-time-grain');
      const tableKpiSelect = document.getElementById('portfolio-table-kpi-select');

      const updateChart = () => {
        if (typeof loadPortfolioData === 'function') {
          loadPortfolioData();
        }
      };

      if (kpiSelect) kpiSelect.addEventListener('change', updateChart);
      if (segmentSelect) segmentSelect.addEventListener('change', updateChart);
      if (scopeToggle) scopeToggle.addEventListener('change', updateChart);
      if (timeGrain) timeGrain.addEventListener('change', updateChart);
      if (tableKpiSelect) {
        tableKpiSelect.addEventListener('change', () => {
          if (typeof renderPortfolioTable === 'function') {
            renderPortfolioTable();
          }
        });
      }
    }

    // Diagnose portfolio data in database
    async function diagnosePortfolioData() {
      try {
        const siteUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || 'https://www.alanranger.com';
        debugLog(' Querying Supabase for portfolio segment records...', 'info');
        
        // Query Supabase directly using the existing get-portfolio-segment-metrics endpoint
        const params = new URLSearchParams({
          siteUrl: siteUrl,
          from: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString(), // Last year
          to: new Date().toISOString(),
          order: 'desc'
        });
        
        const response = await fetch(apiUrl(`/api/supabase/get-portfolio-segment-metrics?${params}`));
        
        if (!response.ok) {
          const errorText = await response.text();
          debugLog(` Query failed: ${response.status} - ${errorText}`, 'error');
          alert(`Query failed: ${response.status}\n${errorText}`);
          return;
        }
        
        const data = await response.json();
        const metrics = data.metrics || [];
        
        // Analyze the records
        const bySegment = {};
        const byRunId = {};
        
        metrics.forEach(m => {
          // Group by segment
          if (!bySegment[m.segment]) {
            bySegment[m.segment] = [];
          }
          bySegment[m.segment].push(m);
          
          // Group by run_id
          if (!byRunId[m.run_id]) {
            byRunId[m.run_id] = [];
          }
          byRunId[m.run_id].push(m);
        });
        
        // Log summary
        debugLog(` Portfolio Records from Supabase:`, 'info');
        debugLog(`  Total records: ${metrics.length}`, 'info');
        debugLog(`  Unique run_ids: ${Object.keys(byRunId).length}`, 'info');
        debugLog(`  Unique segments: ${Object.keys(bySegment).length} (${Object.keys(bySegment).join(', ')})`, 'info');
        
        // Position analysis by segment
        debugLog(`  Position analysis by segment:`, 'info');
        Object.keys(bySegment).forEach(seg => {
          const segRecords = bySegment[seg];
          const withPosition = segRecords.filter(r => {
            const pos = r.position_28d;
            if (pos === null || pos === undefined) return false;
            const parsed = parseFloat(pos);
            return !isNaN(parsed) && isFinite(parsed) && parsed > 0;
          });
          const withNull = segRecords.filter(r => r.position_28d === null || r.position_28d === undefined);
          
          debugLog(`    ${seg}: ${withPosition.length} with position, ${withNull.length} null (out of ${segRecords.length} total)`, 'info');
          
          if (withPosition.length > 0) {
            const samplePositions = withPosition.slice(0, 3).map(r => 
              `pos=${parseFloat(r.position_28d).toFixed(1)} (run=${r.run_id}, imps=${r.impressions_28d})`
            ).join('; ');
            debugLog(`      Sample positions: ${samplePositions}`, 'info');
          }
          
          if (withNull.length > 0) {
            const sampleNulls = withNull.slice(0, 3).map(r => 
              `run=${r.run_id}, imps=${r.impressions_28d}, pos=${r.position_28d}`
            ).join('; ');
            debugLog(`      Sample null records: ${sampleNulls}`, 'warn');
          }
        });
        
        // Show run_id breakdown
        debugLog(`  Run IDs (latest 10):`, 'info');
        Object.keys(byRunId).slice(0, 10).forEach(runId => {
          const records = byRunId[runId];
          const firstRecord = records[0];
          debugLog(`    ${runId}: ${records.length} records, created ${firstRecord.created_at}, date range ${firstRecord.date_start} to ${firstRecord.date_end}`, 'info');
        });
        
        // Show sample records
        if (metrics.length > 0) {
          debugLog(`  Sample records (latest 5):`, 'info');
          metrics.slice(0, 5).forEach((rec, idx) => {
            debugLog(`    [${idx + 1}] ${rec.segment}/${rec.scope}: clicks=${rec.clicks_28d}, impr=${rec.impressions_28d}, ctr=${(rec.ctr_28d * 100).toFixed(2)}%, pos=${rec.position_28d !== null ? parseFloat(rec.position_28d).toFixed(2) : 'null'}, pages=${rec.pages_count}`, 'info');
          });
        }
        
        // Alert summary
        const positionSummary = Object.keys(bySegment).map(seg => {
          const segRecords = bySegment[seg];
          const withPosition = segRecords.filter(r => {
            const pos = r.position_28d;
            if (pos === null || pos === undefined) return false;
            const parsed = parseFloat(pos);
            return !isNaN(parsed) && isFinite(parsed) && parsed > 0;
          });
          return `${seg}: ${withPosition.length}/${segRecords.length} with position`;
        }).join(', ');
        
        const summary = `Portfolio Records from Supabase:
Total: ${metrics.length} records
Run IDs: ${Object.keys(byRunId).length}
Position data: ${positionSummary || 'N/A'}
Check debug panel for details.
Also check "Load from Supabase" for audit debug logs.`;
        
        alert(summary);
        
      } catch (err) {
        debugLog(` Diagnostic error: ${err.message}`, 'error');
        alert(`Diagnostic error: ${err.message}`);
      }
    }

    // Calculate and save portfolio segment snapshots (Phase 3a - Using gsc_page_metrics_28d)
    async function calculateAndSavePortfolioSegmentSnapshots(runId, siteUrl, dateStart, dateEnd, pageTotalsByKey) {
      try {
        debugLog(' Calculating portfolio segment snapshots...', 'info');
        
        // If pageTotalsByKey is not available, fetch from Supabase
        let pageMetrics = new Map();
        if (!pageTotalsByKey || pageTotalsByKey.size === 0) {
          debugLog(' pageTotalsByKey not available, fetching from Supabase...', 'info');
          try {
            const response = await fetch(apiUrl(`/api/supabase/get-gsc-page-metrics?runId=${encodeURIComponent(runId)}&siteUrl=${encodeURIComponent(siteUrl)}&dateStart=${dateStart}&dateEnd=${dateEnd}`));
            if (response.ok) {
              const data = await response.json();
              if (data.pages && data.pages.length > 0) {
                let positionCount = 0;
                let positionSum = 0;
                data.pages.forEach(page => {
                  const key = normalizeGscPageKey(page.page_url);
                  // Handle position: check if it's null, undefined, NaN, or 0 (positions start at 1)
                  let position = null;
                  if (page.position_28d !== null && page.position_28d !== undefined) {
                    const parsed = parseFloat(page.position_28d);
                    if (!isNaN(parsed) && isFinite(parsed) && parsed > 0) {
                      position = parsed;
                    }
                  }
                  if (position !== null) {
                    positionCount++;
                    positionSum += position;
                  }
                  pageMetrics.set(key, {
                    url: page.page_url,
                    clicks: parseFloat(page.clicks_28d) || 0,
                    impressions: parseFloat(page.impressions_28d) || 0,
                    ctr: parseFloat(page.ctr_28d) || 0,
                    position: position
                  });
                });
                debugLog(` Fetched ${pageMetrics.size} pages from Supabase (${positionCount} with position, avg=${positionCount > 0 ? (positionSum / positionCount).toFixed(2) : 'N/A'})`, 'success');
              }
            }
          } catch (fetchError) {
            debugLog(` Error fetching page metrics from Supabase: ${fetchError.message}`, 'warn');
          }
        } else {
          pageMetrics = pageTotalsByKey;
        }
        
        if (pageMetrics.size === 0) {
          debugLog(' No page metrics available for segment snapshots', 'warn');
          return;
        }
        
        // Get tracked tasks for all_tracked segment
        const trackedTaskUrls = new Set();
        try {
          const tasksResponse = await fetch(apiUrl('/api/optimisation/status?includeDeleted=false'));
          if (tasksResponse.ok) {
            const { tasks } = await tasksResponse.json();
            if (tasks && tasks.length > 0) {
              tasks.forEach(task => {
                if (task.target_url) {
                  const normalizedUrl = normalizeGscPageKey(task.target_url);
                  trackedTaskUrls.add(normalizedUrl);
                }
              });
              debugLog(` all_tracked: Found ${trackedTaskUrls.size} tracked task URLs (from ${tasks.length} tasks)`, 'info');
              if (trackedTaskUrls.size > 0) {
                const sampleUrls = Array.from(trackedTaskUrls).slice(0, 3);
                debugLog(` all_tracked: Sample tracked URLs: ${sampleUrls.join(', ')}`, 'info');
              }
            } else {
              debugLog(` all_tracked: No tasks found`, 'warn');
            }
          }
        } catch (taskError) {
          debugLog(` Error fetching tasks for all_tracked segment: ${taskError.message}`, 'warn');
        }
        
        // Classify pages by segment
        const segmentPages = {
          money: [],
          landing: [],
          event: [],
          product: [],
          all_tracked: []
        };
        
        pageMetrics.forEach((metrics, normalizedKey) => {
          const pageUrl = metrics.url;
          if (!pageUrl) return;
          
          // Classify segment using Money Pages logic
          // Use direct classification to avoid dependency on window.classifyUrlForRankingAi
          let subSegment = 'LANDING'; // Default
          const urlLower = (pageUrl || '').toLowerCase();
          
          // Event Pages: Use same pattern as Ranking & AI (substring match for consistency)
          if (urlLower.includes('/beginners-photography-lessons') ||
              urlLower.includes('/photographic-workshops-near-me')) {
            subSegment = 'EVENT';
          }
          // Product Pages: Use same pattern as Ranking & AI (substring match for consistency)
          else if (urlLower.includes('/photo-workshops-uk') ||
                   urlLower.includes('/photography-services-near-me')) {
            subSegment = 'PRODUCT';
          }
          // Landing Pages (default - anything not matching above)
          else {
            subSegment = 'LANDING';
          }
          
          // Map subSegment to specific segment
          let specificSegment = 'landing'; // Default
          if (subSegment === 'EVENT') {
            specificSegment = 'event';
          } else if (subSegment === 'PRODUCT') {
            specificSegment = 'product';
          } else if (subSegment === 'LANDING') {
            specificSegment = 'landing';
          }
          
          // Add to specific segment (event, product, or landing)
          if (segmentPages[specificSegment]) {
            segmentPages[specificSegment].push(metrics);
          }
          
          // ALSO add to 'money' segment (aggregate of all money pages)
          if (segmentPages.money) {
            segmentPages.money.push(metrics);
          }
          
          // Add to all_tracked if it's a tracked task URL
          if (trackedTaskUrls.has(normalizedKey)) {
            segmentPages.all_tracked.push(metrics);
          }
        });
        
        // Debug logging for all_tracked segment
        debugLog(` all_tracked: Found ${segmentPages.all_tracked.length} pages matching tracked task URLs (out of ${pageMetrics.size} total pages)`, 'info');
        if (segmentPages.all_tracked.length > 0) {
          const totalImpressions = segmentPages.all_tracked.reduce((sum, p) => sum + (parseFloat(p.impressions) || 0), 0);
          const totalClicks = segmentPages.all_tracked.reduce((sum, p) => sum + (parseFloat(p.clicks) || 0), 0);
          const pagesWithPosition = segmentPages.all_tracked.filter(p => {
            const pos = p.position !== null && p.position !== undefined ? parseFloat(p.position) : 
                        (p.position_28d !== null && p.position_28d !== undefined ? parseFloat(p.position_28d) : 
                         (p.avgPosition !== null && p.avgPosition !== undefined ? parseFloat(p.avgPosition) : null));
            return pos !== null && !isNaN(pos) && pos > 0;
          }).length;
          debugLog(` all_tracked: Total impressions=${totalImpressions}, clicks=${totalClicks}, pages with position=${pagesWithPosition}`, 'info');
          if (totalImpressions === 0) {
            const samplePages = segmentPages.all_tracked.slice(0, 3).map(p => {
              const url = p.url || 'unknown';
              const imps = parseFloat(p.impressions) || 0;
              const pos = p.position !== null && p.position !== undefined ? parseFloat(p.position) : 
                          (p.position_28d !== null && p.position_28d !== undefined ? parseFloat(p.position_28d) : 
                           (p.avgPosition !== null && p.avgPosition !== undefined ? parseFloat(p.avgPosition) : null));
              return `${url.substring(0, 50)}: imps=${imps}, pos=${pos !== null ? pos.toFixed(1) : 'null'}`;
            }).join('; ');
            debugLog(` all_tracked: Sample pages (why imps=0?): ${samplePages}`, 'warn');
          }
        } else if (trackedTaskUrls.size > 0) {
          // No pages matched, but we have tracked URLs - this is a mismatch issue
          const samplePageKeys = Array.from(pageMetrics.keys()).slice(0, 3);
          const sampleTrackedUrls = Array.from(trackedTaskUrls).slice(0, 3);
          debugLog(` all_tracked: WARNING - No pages matched tracked URLs. Sample page keys: ${samplePageKeys.join(', ')}, Sample tracked URLs: ${sampleTrackedUrls.join(', ')}`, 'warn');
        }
        
        // Fetch AI citations and AI overview data from keyword_rankings for this audit date
        let aiMetricsBySegment = {
          money: { citations: 0, overviewCount: 0 },
          landing: { citations: 0, overviewCount: 0 },
          event: { citations: 0, overviewCount: 0 },
          product: { citations: 0, overviewCount: 0 },
          all_tracked: { citations: 0, overviewCount: 0 }
        };
        
        try {
          const auditDate = dateEnd; // Use dateEnd as audit_date (most recent date in the 28d window)
          const keywordsResponse = await fetch(apiUrl(`/api/supabase/get-keyword-rankings?auditDate=${auditDate}&propertyUrl=${encodeURIComponent(siteUrl)}`));
          if (keywordsResponse.ok) {
            const keywordsData = await keywordsResponse.json();
            if (keywordsData.keywords && keywordsData.keywords.length > 0) {
              // Group keywords by segment and aggregate AI metrics
              keywordsData.keywords.forEach(keyword => {
                const segment = (keyword.segment || '').toLowerCase();
                const citations = parseInt(keyword.ai_alan_citations_count) || 0;
                const hasOverview = keyword.has_ai_overview === true || keyword.ai_overview_present_any === true;
                
                // Add to specific segment
                if (aiMetricsBySegment[segment]) {
                  aiMetricsBySegment[segment].citations += citations;
                  if (hasOverview) {
                    aiMetricsBySegment[segment].overviewCount += 1;
                  }
                }
                
                // Also add to 'money' if it's a commercial segment
                if (segment === 'event' || segment === 'product' || segment === 'landing') {
                  aiMetricsBySegment.money.citations += citations;
                  if (hasOverview) {
                    aiMetricsBySegment.money.overviewCount += 1;
                  }
                }
                
                // Add to all_tracked if URL matches a tracked task
                if (keyword.best_url && trackedTaskUrls.has(normalizeGscPageKey(keyword.best_url))) {
                  aiMetricsBySegment.all_tracked.citations += citations;
                  if (hasOverview) {
                    aiMetricsBySegment.all_tracked.overviewCount += 1;
                  }
                }
              });
              debugLog(` Aggregated AI metrics from ${keywordsData.keywords.length} keywords`, 'success');
            }
          }
        } catch (aiError) {
          debugLog(` Error fetching AI metrics from keyword_rankings: ${aiError.message}`, 'warn');
        }
        
        // Aggregate metrics per segment
        const segmentRows = [];
        const scope = 'active_cycles_only'; // Match UI default
        
        ['money', 'landing', 'event', 'product', 'all_tracked'].forEach(segment => {
          const pages = segmentPages[segment];
          const aiMetrics = aiMetricsBySegment[segment] || { citations: 0, overviewCount: 0 };
          
          if (pages.length === 0) {
            // Still create a row with zeros (but include AI metrics if available)
            segmentRows.push({
              segment,
              pages_count: 0,
              clicks_28d: 0,
              impressions_28d: 0,
              ctr_28d: 0,
              position_28d: null,
              ai_citations_28d: aiMetrics.citations,
              ai_overview_present_count: aiMetrics.overviewCount
            });
            return;
          }
          
          // Aggregate: sum clicks and impressions
          const totalClicks = pages.reduce((sum, p) => sum + (parseFloat(p.clicks) || 0), 0);
          const totalImpressions = pages.reduce((sum, p) => sum + (parseFloat(p.impressions) || 0), 0);
          
          // Calculate CTR (weighted by impressions): clicks / impressions
          const ctr = totalImpressions > 0 ? totalClicks / totalImpressions : 0;
          
          // Calculate weighted average position
          let totalPositionWeight = 0;
          let totalPositionImpressions = 0;
          let positionCount = 0;
          let nullPositionCount = 0;
          let zeroPositionCount = 0;
          pages.forEach(p => {
            const impressions = parseFloat(p.impressions) || 0;
            // Try multiple position field names (position, position_28d, avgPosition)
            // Note: When fetched from Supabase, position is stored in p.position (set from position_28d)
            // When from pageTotalsByKey, it might be in p.position or p.avgPosition
            // IMPORTANT: Check p.position first (set from position_28d when fetching from Supabase)
            let position = null;
            if (p.position !== null && p.position !== undefined) {
              const parsed = parseFloat(p.position);
              if (!isNaN(parsed) && isFinite(parsed) && parsed > 0) {
                position = parsed;
              } else {
                nullPositionCount++;
              }
            } else if (p.position_28d !== null && p.position_28d !== undefined) {
              const parsed = parseFloat(p.position_28d);
              if (!isNaN(parsed) && isFinite(parsed) && parsed > 0) {
                position = parsed;
              } else {
                nullPositionCount++;
              }
            } else if (p.avgPosition !== null && p.avgPosition !== undefined) {
              const parsed = parseFloat(p.avgPosition);
              if (!isNaN(parsed) && isFinite(parsed) && parsed > 0) {
                position = parsed;
              } else {
                nullPositionCount++;
              }
            } else {
              nullPositionCount++;
            }
            
            if (position !== null && position > 0 && impressions > 0) {
              totalPositionWeight += position * impressions;
              totalPositionImpressions += impressions;
              positionCount++;
            } else if (impressions > 0) {
              zeroPositionCount++;
            }
          });
          const avgPosition = totalPositionImpressions > 0 ? totalPositionWeight / totalPositionImpressions : null;
          
          // Enhanced debug logging for position calculation
          debugLog(` Position calc for ${segment}: ${positionCount} pages with valid position (out of ${pages.length} total), ${nullPositionCount} with null/invalid position, ${zeroPositionCount} with zero impressions, total impressions=${totalPositionImpressions}, avgPosition=${avgPosition !== null ? avgPosition.toFixed(2) : 'N/A'}`, 'info');
          
          // Debug logging for position calculation
          debugLog(` Position calc for ${segment}: ${positionCount} pages with position (out of ${pages.length} total), total impressions=${totalPositionImpressions}, avgPosition=${avgPosition !== null ? avgPosition.toFixed(2) : 'N/A'}`, 'info');
          
          // Additional debug: log sample positions for first few pages (for all segments, not just money)
          if (pages.length > 0) {
            const samplePositions = pages.slice(0, 5).map(p => {
              const pos = p.position !== null && p.position !== undefined ? parseFloat(p.position) : 
                          (p.position_28d !== null && p.position_28d !== undefined ? parseFloat(p.position_28d) : 
                           (p.avgPosition !== null && p.avgPosition !== undefined ? parseFloat(p.avgPosition) : null));
              const imps = parseFloat(p.impressions) || 0;
              return `pos=${pos !== null ? pos.toFixed(1) : 'null'}, imps=${imps}`;
            }).join('; ');
            debugLog(` Sample positions for ${segment}: ${samplePositions}`, 'info');
            
            // Also log how many pages have null position
            const nullPositionCount = pages.filter(p => {
              const pos = p.position !== null && p.position !== undefined ? parseFloat(p.position) : 
                          (p.position_28d !== null && p.position_28d !== undefined ? parseFloat(p.position_28d) : 
                           (p.avgPosition !== null && p.avgPosition !== undefined ? parseFloat(p.avgPosition) : null));
              return pos === null || isNaN(pos) || pos <= 0;
            }).length;
            if (nullPositionCount > 0) {
              debugLog(` ${segment}: ${nullPositionCount} out of ${pages.length} pages have null/invalid position`, 'warn');
            }
          }
          
          segmentRows.push({
            segment,
            pages_count: pages.length,
            clicks_28d: totalClicks,
            impressions_28d: totalImpressions,
            ctr_28d: ctr, // Ratio (0-1)
            position_28d: avgPosition,
            ai_citations_28d: aiMetrics.citations,
            ai_overview_present_count: aiMetrics.overviewCount
          });
        });
        
        // Save to Supabase
        debugLog(` Saving ${segmentRows.length} segment snapshots to Supabase...`, 'info');
        debugLog(` Save params: runId=${runId}, siteUrl=${siteUrl}, dateStart=${dateStart}, dateEnd=${dateEnd}, scope=${scope}`, 'info');
        debugLog(` Segment rows to save: ${JSON.stringify(segmentRows.map(r => ({ segment: r.segment, pages: r.pages_count, clicks: r.clicks_28d, impressions: r.impressions_28d, ctr: r.ctr_28d, position: r.position_28d })))}`, 'info');
        
        const saveResponse = await fetch(apiUrl('/api/supabase/save-portfolio-segment-metrics'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            siteUrl,
            runId,
            dateStart,
            dateEnd,
            scope,
            rows: segmentRows
          })
        });
        
        if (!saveResponse.ok) {
          const errorText = await saveResponse.text();
          debugLog(` Failed to save segment snapshots: ${saveResponse.status} - ${errorText}`, 'error');
          throw new Error(`Failed to save segment snapshots: ${saveResponse.status} - ${errorText}`);
        }
        
        const saveResult = await saveResponse.json();
        debugLog(` Saved ${saveResult.inserted} portfolio segment snapshots to Supabase (runId=${runId})`, 'success');
        if (saveResult.warning) {
          debugLog(` Warning from save: ${saveResult.message}`, 'warn');
        }
        
      } catch (err) {
        debugLog(`Error calculating portfolio segment snapshots: ${err.message}`, 'error');
        throw err;
      }
    }

    // Calculate and save portfolio snapshots (Phase 3 - Using gsc_page_metrics_28d)
    async function calculateAndSavePortfolioSnapshots(auditDate, windowDays = 28) {
      try {
        debugLog(' Calculating portfolio snapshots from gsc_page_metrics_28d...', 'info');
        
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (!propertyUrl) {
          debugLog(' No property URL found, skipping portfolio snapshots', 'warn');
          return;
        }
        
        // Calculate window dates (rolling 28d ending yesterday)
        const endDate = new Date();
        endDate.setDate(endDate.getDate() - 1); // Yesterday
        endDate.setHours(0, 0, 0, 0);
        const startDate = new Date(endDate);
        startDate.setDate(startDate.getDate() - 27); // 27 days back = 28 days total (inclusive)
        startDate.setHours(0, 0, 0, 0);
        
        const dateStartStr = startDate.toISOString().split('T')[0];
        const dateEndStr = endDate.toISOString().split('T')[0];
        
        // Aggregate page metrics by segment from Supabase
        debugLog(` Aggregating page metrics for run_id: ${auditDate}, date range: ${dateStartStr} to ${dateEndStr}`, 'info');
        
        const aggregateResponse = await fetch(apiUrl('/api/portfolio/aggregate-page-metrics'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            runId: auditDate,
            siteUrl: propertyUrl,
            dateStart: dateStartStr,
            dateEnd: dateEndStr
          })
        });
        
        if (!aggregateResponse.ok) {
          const errorText = await aggregateResponse.text();
          throw new Error(`Failed to aggregate page metrics: ${aggregateResponse.status} - ${errorText}`);
        }
        
        const aggregateData = await aggregateResponse.json();
        const segmentAggregates = aggregateData.segments || {};
        
        debugLog(` Aggregated ${aggregateData.pageCount || 0} pages into segments`, 'success');
        
        // Build snapshots array
        const snapshots = [];
        
        // Level KPIs (for Monthly KPI Tracker) - from aggregated page metrics
        const levelKpis = ['ctr_28d', 'clicks_28d', 'impressions_28d', 'avg_position'];
        const segments = ['money', 'landing', 'event', 'product', 'all_tracked'];
        const scopes = ['active_only']; // Start with active_only only
        
        for (const segment of segments) {
          const segmentData = segmentAggregates[segment];
          if (!segmentData) continue;
          
          for (const kpi of levelKpis) {
            let value = null;
            let unit = null;
            
            if (kpi === 'ctr_28d') {
              value = segmentData.ctr_28d || 0; // Already a ratio (0-1)
              unit = 'ratio';
            } else if (kpi === 'clicks_28d') {
              value = segmentData.clicks_28d || 0;
              unit = 'count';
            } else if (kpi === 'impressions_28d') {
              value = segmentData.impressions_28d || 0;
              unit = 'count';
            } else if (kpi === 'avg_position') {
              value = segmentData.avg_position || null;
              unit = 'position';
            }
            
            if (value !== null) {
              for (const scope of scopes) {
                snapshots.push({
                  segment,
                  scope,
                  kpi,
                  value,
                  unit,
                  meta: { pageCount: segmentData.page_count || 0 }
                });
              }
            }
          }
        }
        
        // Median Delta KPIs (for Median Delta Over Time chart) - from tasks
        try {
          const tasksResponse = await fetch(apiUrl('/api/optimisation/status?includeDeleted=false'));
          if (tasksResponse.ok) {
            const { tasks } = await tasksResponse.json();
            
            if (tasks && tasks.length > 0) {
              // Filter to active tasks only
              const activeTasks = tasks.filter(t => 
                t.status && !['done', 'cancelled', 'deleted'].includes(t.status)
              );
              
              const medianDeltaKpis = ['ctr_28d', 'clicks_28d', 'impressions_28d', 'avg_position', 'ai_citations', 'ai_overview'];
              
              for (const kpi of medianDeltaKpis) {
                const deltas = [];
                
                activeTasks.forEach(task => {
                  if (!task.baseline_metrics || !task.latest_metrics) return;
                  
                  let baselineValue = null;
                  let latestValue = null;
                  
                  if (kpi === 'ctr_28d') {
                    baselineValue = task.baseline_metrics.ctr_28d;
                    latestValue = task.latest_metrics.ctr_28d;
                  } else if (kpi === 'clicks_28d') {
                    baselineValue = task.baseline_metrics.clicks_28d;
                    latestValue = task.latest_metrics.clicks_28d;
                  } else if (kpi === 'impressions_28d') {
                    baselineValue = task.baseline_metrics.impressions_28d;
                    latestValue = task.latest_metrics.impressions_28d;
                  } else if (kpi === 'avg_position') {
                    baselineValue = task.baseline_metrics.avg_position;
                    latestValue = task.latest_metrics.avg_position;
                  } else if (kpi === 'ai_citations') {
                    baselineValue = task.baseline_metrics.ai_citations;
                    latestValue = task.latest_metrics.ai_citations;
                  } else if (kpi === 'ai_overview') {
                    baselineValue = task.baseline_metrics.ai_overview ? 1 : 0;
                    latestValue = task.latest_metrics.ai_overview ? 1 : 0;
                  }
                  
                  if (baselineValue !== null && latestValue !== null) {
                    deltas.push(latestValue - baselineValue);
                  }
                });
                
                if (deltas.length > 0) {
                  const sortedDeltas = [...deltas].sort((a, b) => a - b);
                  const medianDelta = sortedDeltas[Math.floor(sortedDeltas.length / 2)];
                  
                  snapshots.push({
                    segment: 'all_tracked',
                    scope: 'active_only',
                    kpi: `median_delta_${kpi}`,
                    value: medianDelta,
                    unit: kpi === 'ctr_28d' ? 'pp' : (kpi === 'avg_position' ? 'position' : 'count'),
                    meta: { taskCount: activeTasks.length }
                  });
                }
              }
            }
          }
        } catch (taskError) {
          debugLog(` Error fetching tasks for median deltas: ${taskError.message}`, 'warn');
        }
        
        // Save audit run and snapshots in one API call
        const saveResponse = await fetch(apiUrl('/api/portfolio/save-run'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            windowDays,
            windowStart: startDate.toISOString().split('T')[0],
            windowEnd: endDate.toISOString().split('T')[0],
            note: `Audit run for ${auditDate}`,
            snapshots
          })
        });
        
        if (!saveResponse.ok) {
          const errorText = await saveResponse.text();
          throw new Error(`Failed to save portfolio run: ${saveResponse.status} - ${errorText}`);
        }
        
        const result = await saveResponse.json();
        debugLog(` Created portfolio audit run: ${result.run.id} with ${result.snapshotsCount} snapshots`, 'success');

        debugLog(' Portfolio snapshots calculated and saved', 'success');
      } catch (err) {
        debugLog(`Error calculating portfolio snapshots: ${err.message}`, 'error');
        throw err;
      }
    }

    // Fix ranking panel DOM structure - ensure sections are siblings, not nested
    function fixRankingPanelStructure() {
      const rankingPanel = document.querySelector('.aigeo-panel[data-panel="ranking"]');
      if (!rankingPanel) return;

      const sideBySide = rankingPanel.querySelector('.ranking-cards-side-by-side');
      const priority = rankingPanel.querySelector('#ranking-priority-matrix-section');
      const table = rankingPanel.querySelector('.ranking-table-section');
      const details = rankingPanel.querySelector('.ranking-details-grid');

      if (!sideBySide) return;

      // Check if sections are incorrectly nested inside side-by-side container
      const sideBySideChildren = Array.from(sideBySide.children);
      const needsFix = sideBySideChildren.includes(priority) || 
                       sideBySideChildren.includes(table) || 
                       sideBySideChildren.includes(details);

      if (needsFix) {
        // Move sections out of side-by-side container to be siblings
        if (priority && sideBySide.contains(priority)) {
          sideBySide.parentElement.insertBefore(priority, sideBySide.nextSibling);
        }
        if (table && sideBySide.contains(table)) {
          sideBySide.parentElement.insertBefore(table, priority?.nextSibling || sideBySide.nextSibling);
        }
        if (details && sideBySide.contains(details)) {
          sideBySide.parentElement.insertBefore(details, table?.nextSibling || priority?.nextSibling || sideBySide.nextSibling);
        }
      }

      // Ensure correct order: side-by-side, priority, table, details
      const allSections = [sideBySide, priority, table, details].filter(Boolean);
      allSections.forEach((section, index) => {
        if (section.parentElement === rankingPanel) {
          const currentIndex = Array.from(rankingPanel.children).indexOf(section);
          const expectedIndex = Array.from(rankingPanel.children).indexOf(allSections[0]) + index;
          if (currentIndex !== expectedIndex && expectedIndex >= 0) {
            rankingPanel.insertBefore(section, rankingPanel.children[expectedIndex] || null);
          }
        }
      });
    }

    function toggleCalculationExplanation() {
      const explanation = document.getElementById('calculationExplanation');
      const content = document.getElementById('calculationContent');
      const toggle = document.getElementById('calculationToggle');
      if (explanation.classList.contains('collapsed')) {
        explanation.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '';
      } else {
        explanation.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '';
      }
    }

    function toggleFrameworkExplanation() {
      const explanation = document.getElementById('frameworkExplanation');
      const content = document.getElementById('frameworkContent');
      const toggle = document.getElementById('frameworkToggle');
      if (!explanation || !content) return;
      if (explanation.classList.contains('collapsed')) {
        explanation.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '';
      } else {
        explanation.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '';
      }
    }
    
    window.toggleCsvSection = function(sectionId) {
      const section = document.getElementById(sectionId);
      const contentId = sectionId === 'urlListSection' ? 'urlListContent' : 'backlinkCsvContentWrapper';
      const toggleId = sectionId === 'urlListSection' ? 'urlListToggle' : 'backlinkCsvToggle';
      const content = document.getElementById(contentId);
      const toggle = document.getElementById(toggleId);
      
      if (section.classList.contains('collapsed')) {
        section.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '';
      } else {
        section.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '';
      }
    }

    // Debug panel is always visible at bottom, start collapsed by default
    window.addEventListener('DOMContentLoaded', () => {
      const debugPanel = document.getElementById('debugPanel');
      const debugToggleIcon = document.getElementById('debugToggleIcon');
      if (debugPanel) {
        debugPanel.style.display = 'flex';
        // Start collapsed by default
        debugPanel.classList.add('collapsed');
        if (debugToggleIcon) {
          debugToggleIcon.textContent = '';
        }
      }
    });

    // Initialize Money Pages Priority Matrix global state early
    window.moneyPagePriorityData = window.moneyPagePriorityData || [];
    window.moneySegmentMetrics = window.moneySegmentMetrics || null;
    window.moneyMatrixFilterState = window.moneyMatrixFilterState || { impact: null, diff: null };
    
    // Verify RankingAiModule is available
    if (typeof window.RankingAiModule === 'undefined') {
      debugLog(' RankingAiModule not found in window on page load', 'warn');
    } else {
      debugLog(' RankingAiModule verified on page load', 'success');
    }

    // Fix ranking panel structure on page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(fixRankingPanelStructure, 100);
      });
    } else {
      setTimeout(fixRankingPanelStructure, 100);
    }

    // Load saved configuration
    async function loadConfig() {
      debugLog('=== PAGE LOAD: Starting configuration load ===', 'info');
      
      // Check if Chart.js is loaded
      debugLog('Checking Chart.js library...', 'info');
      if (typeof Chart !== 'undefined') {
        debugLog(' Chart.js library loaded successfully', 'success');
      } else {
        debugLog(' Chart.js library NOT loaded', 'error');
      }
      
      // Try to fetch API key from Vercel environment variable (via API endpoint)
      let vercelApiKey = null;
      try {
        debugLog('Checking Vercel environment variable...', 'info');
        const response = await fetch(apiUrl('/api/get-api-key'));
        if (response.ok) {
          const data = await response.json();
          if (data.apiKey) {
            vercelApiKey = data.apiKey;
            debugLog(' API key loaded from Vercel environment variable', 'success');
          }
        }
      } catch (e) {
        debugLog('Vercel env var endpoint not available (expected for static site)', 'info');
      }
      
      // Check config.js
      debugLog('Checking for config.js...', 'info');
      if (window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey) {
        debugLog(' config.js found with API key', 'success');
      } else {
        debugLog(' config.js not found or no API key', 'warn');
      }
      
      // Check localStorage
      debugLog('Checking localStorage...', 'info');
      const configApiKey = window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey;
      const apiKey = vercelApiKey || configApiKey || localStorage.getItem('gsc_api_key');
      const propertyUrl = localStorage.getItem('gsc_property_url');
      const dateRange = localStorage.getItem('gsc_date_range');
      
      const apiKeySource = vercelApiKey ? 'Vercel env var' : configApiKey ? 'config.js' : localStorage.getItem('gsc_api_key') ? 'localStorage' : 'none';
      debugLog(`API Key source: ${apiKeySource}`, 'info');
      debugLog(`Property URL: ${propertyUrl || 'not set'}`, 'info');
      debugLog(`Date Range: ${dateRange || 'not set'}`, 'info');
      
      if (apiKey) {
        debugLog(' API key loaded from environment', 'success');
        // Store in a hidden variable for use in runAudit
        window._loadedApiKey = apiKey;
      } else {
        debugLog(' No API key found', 'warn');
      }
      
      if (propertyUrl) {
        document.getElementById('propertyUrl').value = propertyUrl;
        debugLog(' Property URL loaded', 'success');
      }
      if (dateRange) {
        document.getElementById('dateRange').value = dateRange;
        // Set active button based on saved date range
        const savedDays = parseInt(dateRange);
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          btn.classList.remove('active');
          const btnDays = parseInt(btn.getAttribute('data-days'));
          if (btnDays === savedDays) {
            btn.classList.add('active');
          }
        });
        // If no preset matches, show custom
        const presetDays = [7, 30, 90, 180, 365];
        if (!presetDays.includes(savedDays)) {
          document.getElementById('customDateBtn').classList.add('active');
          document.getElementById('customDays').value = savedDays;
          document.getElementById('customDateRange').style.display = 'block';
        }
        debugLog(' Date range loaded', 'success');
      }
      
      // Load manual URL list if saved
      const savedUrlList = localStorage.getItem('manual_url_list');
      if (savedUrlList) {
        try {
          const urls = JSON.parse(savedUrlList);
          const statusDiv = document.getElementById('urlListStatus');
          if (statusDiv) {
            statusDiv.innerHTML = `<span style="color: #10b981;"> ${urls.length} URLs loaded from saved list</span>`;
          }
          debugLog(` Manual URL list loaded: ${urls.length} URLs`, 'success');
        } catch (e) {
          debugLog(' Failed to load saved URL list', 'warn');
        }
      }
      
      // Load backlink CSV content if saved
      const savedBacklinkCsv = localStorage.getItem('backlink_csv_content');
      if (savedBacklinkCsv) {
        const textarea = document.getElementById('backlinkCsvContent');
        if (textarea) {
          textarea.value = savedBacklinkCsv;
        }
        // Check if backlink metrics are already uploaded
        try {
          const backlinkResponse = await fetch(apiUrl('/api/aigeo/backlink-metrics'));
          if (backlinkResponse.ok) {
            const backlinkData = await backlinkResponse.json();
            if (backlinkData.status === 'ok' && backlinkData.data && backlinkData.data.totalBacklinks > 0) {
              const metrics = backlinkData.data;
              const statusDiv = document.getElementById('backlinkCsvStatus');
              if (statusDiv) {
                statusDiv.innerHTML = `<span style="color: #10b981;"> Backlink CSV loaded: ${metrics.referringDomains} domains, ${metrics.totalBacklinks} links</span>`;
              }
              debugLog(` Backlink CSV already uploaded: ${metrics.referringDomains} domains`, 'success');
            }
          }
        } catch (e) {
          // Ignore errors - backlink metrics may not be uploaded yet
        }
      }
      
      debugLog('=== Configuration load complete ===', 'info');
    }

    // Save configuration
    // Date range selector functions
    function setDateRange(days) {
      const oldDateRange = parseInt(document.getElementById('dateRange').value) || 30;
      document.getElementById('dateRange').value = days;
      localStorage.setItem('gsc_date_range', days);
      
      // Update active button
      document.querySelectorAll('.date-range-btn').forEach(btn => {
        btn.classList.remove('active');
        const btnDays = parseInt(btn.getAttribute('data-days'));
        if (btnDays === days) {
          btn.classList.add('active');
        }
      });
      
      // Hide custom input if showing
      document.getElementById('customDateRange').style.display = 'none';
      document.getElementById('customDateBtn').classList.remove('active');
      
      debugLog(`Date range set to ${days} days`, 'info');
      
      // Check if saved audit exists and if its date range matches
      const savedAudit = loadAuditResultsSync();
      if (savedAudit && savedAudit.scores) {
        const savedDateRange = savedAudit.dateRange || oldDateRange;
        // Always update if date range changed (even if going back to a previous range)
        // This ensures charts refresh properly when switching between ranges
        if (savedDateRange !== days) {
          // Date range changed - update GSC data and recalculate scores
          debugLog(`Date range changed from ${savedDateRange} to ${days} days. Updating metrics...`, 'info');
          updateAuditForNewDateRange(days, savedAudit);
        } else {
          // Date range matches, but force refresh to ensure charts are updated
          // This handles the case where user switches back to the same range
          debugLog(`Date range is already ${days} days, but refreshing charts to ensure they're up to date...`, 'info');
          // Force a refresh by calling displayDashboard with current data
          if (savedAudit.scores && savedAudit.searchData) {
            displayDashboard(savedAudit.scores, savedAudit.searchData, savedAudit.snippetReadiness, savedAudit.schemaAudit, savedAudit.localSignals);
          }
        }
      }
    }

    function showCustomDateRange() {
      const customDiv = document.getElementById('customDateRange');
      const customBtn = document.getElementById('customDateBtn');
      
      if (customDiv.style.display === 'none') {
        customDiv.style.display = 'block';
        customBtn.classList.add('active');
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          if (btn !== customBtn) btn.classList.remove('active');
        });
      } else {
        customDiv.style.display = 'none';
        customBtn.classList.remove('active');
      }
    }

    function applyCustomDateRange() {
      const customDays = parseInt(document.getElementById('customDays').value);
      if (customDays && customDays > 0) {
        const oldDateRange = parseInt(document.getElementById('dateRange').value) || 30;
        document.getElementById('dateRange').value = customDays;
        localStorage.setItem('gsc_date_range', customDays);
        document.getElementById('customDateRange').style.display = 'none';
        document.getElementById('customDateBtn').classList.remove('active');
        debugLog(`Custom date range set to ${customDays} days`, 'info');
        
        // Check if saved audit exists and if its date range matches
        const savedAudit = loadAuditResultsSync();
        if (savedAudit && savedAudit.scores) {
          const savedDateRange = savedAudit.dateRange || oldDateRange;
          if (savedDateRange !== customDays) {
            // Date range changed - update GSC data and recalculate scores
            debugLog(`Date range changed from ${savedDateRange} to ${customDays} days. Updating metrics...`, 'info');
            updateAuditForNewDateRange(customDays, savedAudit);
          }
        }
      } else {
        showStatus('Please enter a valid number of days', 'error');
      }
    }

    function saveConfig() {
      localStorage.setItem('gsc_api_key', document.getElementById('apiKey').value);
      localStorage.setItem('gsc_property_url', document.getElementById('propertyUrl').value);
      localStorage.setItem('gsc_date_range', document.getElementById('dateRange').value);
      showStatus('Configuration saved!', 'success');
    }

    window.shareAudit = async function shareAudit() {
      // Check if admin key is set
      const adminKey = window.getAdminKey();
      if (!adminKey) {
        alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
        return;
      }

      try {
        // Call share create endpoint
        const response = await fetch(apiUrl('/api/share/create'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-arp-admin-key': adminKey
          },
          body: JSON.stringify({
            expiryDays: 30 // Default to 30 days
          })
        });

        if (!response.ok) {
          let errorMessage = `HTTP ${response.status}`;
          try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorMessage;
          } catch (e) {
            // If JSON parsing fails, try to get text
            try {
              const text = await response.text();
              errorMessage = text || errorMessage;
            } catch (e2) {
              // If that fails too, use status
              errorMessage = `HTTP ${response.status}: ${response.statusText || 'Unknown error'}`;
            }
          }
          throw new Error(errorMessage);
        }

        const data = await response.json();
        const shareUrl = data.shareUrl;
        const expiresAt = data.expiresAt ? new Date(data.expiresAt).toLocaleDateString('en-GB') : 'Unknown';

        // Show share URL in a prompt for easy copying
        const message = `Share URL created!\n\nExpires: ${expiresAt}\n\nShare URL:\n${shareUrl}\n\nClick OK to copy to clipboard.`;
        if (confirm(message)) {
          // Copy to clipboard
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(shareUrl);
            showStatus('Share URL copied to clipboard!', 'success');
          } else {
            // Fallback: select text
            const textarea = document.createElement('textarea');
            textarea.value = shareUrl;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
              document.execCommand('copy');
              showStatus('Share URL copied to clipboard!', 'success');
            } catch (e) {
              showStatus('Share URL created. Please copy it manually.', 'info');
            }
            document.body.removeChild(textarea);
          }
        }
      } catch (error) {
        console.error('[Share Audit] Error:', error);
        alert(`Failed to create share URL: ${error.message}`);
      }
    }

    // Parse CSV and validate column names
    function parseUrlListCsv(csvText) {
      const lines = csvText.split('\n').filter(line => line.trim());
      if (lines.length === 0) {
        throw new Error('CSV is empty');
      }
      
      // Parse header row
      const headerLine = lines[0].trim();
      const headers = headerLine.split(',').map(h => h.trim().replace(/^"|"$/g, '').toLowerCase());
      
      // Check for required 'url' column
      const urlColumnIndex = headers.findIndex(h => h === 'url');
      if (urlColumnIndex === -1) {
        throw new Error(`Required column 'url' not found. Found columns: ${headers.join(', ')}`);
      }
      
      // Extract URLs from the 'url' column
      const urls = [];
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        // Parse CSV line (handle quoted values)
        const columns = [];
        let current = '';
        let inQuotes = false;
        
        for (let j = 0; j < line.length; j++) {
          const char = line[j];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            columns.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        columns.push(current.trim()); // Add last column
        
        // Extract URL from the url column
        if (columns[urlColumnIndex]) {
          const url = columns[urlColumnIndex].replace(/^"|"$/g, '').trim();
          if (url && url.startsWith('http')) {
            urls.push(url);
          }
        }
      }
      
      return {
        headers,
        urls,
        totalRows: lines.length - 1,
        validUrls: urls.length
      };
    }

    // Load URL list from file input
    async function loadUrlListFromFile() {
      const fileInput = document.getElementById('urlListFile');
      const statusDiv = document.getElementById('urlListStatus');
      const textarea = document.getElementById('manualUrlList');
      
      if (!fileInput.files || fileInput.files.length === 0) {
        // If no file, try to parse from textarea
        const csvText = textarea.value.trim();
        if (!csvText) {
          statusDiv.innerHTML = '<span style="color: #ef4444;"> Please select a CSV file or paste CSV content</span>';
          return;
        }
        
        try {
          const result = parseUrlListCsv(csvText);
          localStorage.setItem('manual_url_list', JSON.stringify(result.urls));
          statusDiv.innerHTML = `<span style="color: #10b981;"> Loaded ${result.validUrls} URLs from ${result.totalRows} rows</span>`;
          debugLog(` Manual URL list loaded: ${result.validUrls} URLs from CSV`, 'success');
          showStatus(`URL list loaded! Found ${result.validUrls} URLs.`, 'success');
        } catch (error) {
          statusDiv.innerHTML = `<span style="color: #ef4444;"> ${error.message}</span>`;
          debugLog(` URL list parse error: ${error.message}`, 'error');
          showStatus(`URL list error: ${error.message}`, 'error');
        }
        return;
      }
      
      const file = fileInput.files[0];
      debugLog(`Loading URL list from file: ${file.name} (${file.size} bytes)`, 'info');
      
      try {
        const fileText = await file.text();
        const result = parseUrlListCsv(fileText);
        
        // Store URLs in localStorage
        localStorage.setItem('manual_url_list', JSON.stringify(result.urls));
        
        // Also populate textarea with the CSV content
        textarea.value = fileText;
        
        statusDiv.innerHTML = `<span style="color: #10b981;"> Loaded ${result.validUrls} URLs from ${result.totalRows} rows. Columns: ${result.headers.join(', ')}</span>`;
        debugLog(` URL list loaded from file: ${result.validUrls} URLs`, 'success');
        debugLog(`  File: ${file.name}, Columns: ${result.headers.join(', ')}`, 'info');
        showStatus(`URL list loaded! Found ${result.validUrls} URLs from ${file.name}.`, 'success');
        
        // Clear file input
        fileInput.value = '';
      } catch (error) {
        statusDiv.innerHTML = `<span style="color: #ef4444;"> ${error.message}</span>`;
        debugLog(` URL list file error: ${error.message}`, 'error');
        showStatus(`URL list error: ${error.message}`, 'error');
      }
    }

    // Clear manual URL list
    function clearManualUrlList() {
      const textarea = document.getElementById('manualUrlList');
      const fileInput = document.getElementById('urlListFile');
      const statusDiv = document.getElementById('urlListStatus');
      
      textarea.value = '';
      fileInput.value = '';
      localStorage.removeItem('manual_url_list');
      statusDiv.innerHTML = '<span style="color: #666;">Manual URL list cleared</span>';
      debugLog('Manual URL list cleared', 'info');
      showStatus('Manual URL list cleared', 'success');
    }

    // Load backlink CSV from file (wrapper for uploadBacklinkCsv)
    async function loadBacklinkCsvFromFile() {
      return await uploadBacklinkCsv();
    }

    // Upload backlink CSV file
    async function uploadBacklinkCsv() {
      const fileInput = document.getElementById('backlinkCsvFile');
      const statusDiv = document.getElementById('backlinkCsvStatus');
      const textarea = document.getElementById('backlinkCsvContent');
      
      let csvContent = '';
      
      if (fileInput.files && fileInput.files.length > 0) {
        const file = fileInput.files[0];
        debugLog(`Uploading backlink CSV from file: ${file.name} (${file.size} bytes)`, 'info');
        
        try {
          csvContent = await file.text();
          // Also populate textarea with the CSV content
          textarea.value = csvContent;
        } catch (error) {
          statusDiv.innerHTML = `<span style="color: #ef4444;"> Error reading file: ${error.message}</span>`;
          debugLog(` Backlink CSV file read error: ${error.message}`, 'error');
          showStatus(`Backlink CSV error: ${error.message}`, 'error');
          return;
        }
      } else {
        // If no file, try to get from textarea
        csvContent = textarea.value.trim();
        if (!csvContent) {
          statusDiv.innerHTML = '<span style="color: #ef4444;"> Please select a CSV file or paste CSV content</span>';
          return;
        }
      }

      if (!csvContent) {
        statusDiv.innerHTML = '<span style="color: #ef4444;"> No CSV content to upload</span>';
        return;
      }

      // Validate CSV has required columns
      const lines = csvContent.split('\n').filter(line => line.trim());
      if (lines.length === 0) {
        statusDiv.innerHTML = '<span style="color: #ef4444;"> CSV is empty</span>';
        return;
      }

      const headerLine = lines[0].trim();
      const headers = headerLine.split(',').map(h => h.trim().replace(/^"|"$/g, ''));
      
      // More flexible column matching - check for URL column (required) and Link Type (optional)
      const hasUrlColumn = headers.some(h => {
        const lower = h.toLowerCase();
        return (lower.includes('linking') && lower.includes('url')) ||
               lower.includes('url') ||
               lower.includes('source url') ||
               lower.includes('page url');
      });
      
      const hasLinkType = headers.some(h => {
        const lower = h.toLowerCase();
        return lower.includes('link type') ||
               lower.includes('type') ||
               lower.includes('follow');
      });
      
      if (!hasUrlColumn) {
        statusDiv.innerHTML = `<span style="color: #ef4444;"> Missing URL column. Found columns: ${headers.join(', ')}. Need a column containing 'URL' or 'Linking Page + URL'</span>`;
        debugLog(` Backlink CSV missing URL column. Found: ${headers.join(', ')}`, 'error');
        return;
      }
      
      if (!hasLinkType) {
        statusDiv.innerHTML = `<span style="color: #ef4444;"> Missing Link Type column. Found columns: ${headers.join(', ')}. The Link Type column is required to calculate the follow ratio for the Authority score.</span>`;
        debugLog(` Backlink CSV missing Link Type column. Found: ${headers.join(', ')}`, 'error');
        return;
      }

      // Upload to API
      try {
        statusDiv.innerHTML = '<span style="color: #666;"> Uploading and processing backlink CSV...</span>';
        debugLog('Uploading backlink CSV to API...', 'info');
        
        // Send CSV as JSON since Vercel doesn't parse text/csv automatically
        const response = await fetch(apiUrl('/api/aigeo/backlink-metrics'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ csv: csvContent })
        });

        if (!response.ok) {
          let errorMessage = `HTTP ${response.status}`;
          try {
            const errorData = await response.json();
            errorMessage = errorData.message || errorData.error || errorMessage;
            debugLog(`API error response: ${JSON.stringify(errorData)}`, 'error');
          } catch (e) {
            // If response is not JSON, try to get text
            try {
              const errorText = await response.text();
              if (errorText) {
                errorMessage = errorText.substring(0, 200);
              }
            } catch (e2) {
              // Ignore
            }
          }
          throw new Error(errorMessage);
        }

        const result = await response.json();
        debugLog(`API response: ${JSON.stringify(result).substring(0, 200)}...`, 'info');
        
        if (result.status === 'ok' && result.data) {
          const metrics = result.data;
          statusDiv.innerHTML = `<span style="color: #10b981;"> Backlink CSV uploaded successfully! Found ${metrics.referringDomains} referring domains, ${metrics.totalBacklinks} backlinks, ${Math.round(metrics.followRatio * 100)}% follow ratio</span>`;
          debugLog(` Backlink CSV uploaded: ${metrics.referringDomains} domains, ${metrics.totalBacklinks} links, ${(metrics.followRatio * 100).toFixed(1)}% follow`, 'success');
          showStatus(`Backlink CSV uploaded! ${metrics.referringDomains} referring domains found.`, 'success');
          
          // Store in localStorage for persistence
          localStorage.setItem('backlink_csv_content', csvContent);
          localStorage.setItem('backlink_metrics', JSON.stringify(metrics));
          debugLog(` Backlink metrics stored in localStorage`, 'success');
        } else {
          // Error response - log debug info to UI
          const errorMsg = result.message || result.error || 'Upload failed - invalid response format';
          statusDiv.innerHTML = `<span style="color: #ef4444;"> ${errorMsg}</span>`;
          debugLog(` Backlink CSV upload error: ${errorMsg}`, 'error');
          
          // Log debug info if available
          if (result.debug) {
            debugLog(`[DEBUG] CSV Length: ${result.debug.csvLength || 'N/A'}`, 'info');
            debugLog(`[DEBUG] Logical Lines: ${result.debug.logicalLines || 'N/A'}`, 'info');
            debugLog(`[DEBUG] Headers Found: ${result.debug.headers ? result.debug.headers.join(', ') : 'N/A'}`, 'info');
            if (result.debug.firstChars) {
              debugLog(`[DEBUG] First 500 chars: ${result.debug.firstChars}`, 'info');
            }
            if (result.debug.rowCount !== undefined) {
              debugLog(`[DEBUG] Rows parsed: ${result.debug.rowCount}`, 'info');
            }
            if (result.debug.firstRowKeys) {
              debugLog(`[DEBUG] First row keys: ${result.debug.firstRowKeys.join(', ')}`, 'info');
            }
            if (result.debug.error) {
              debugLog(`[DEBUG] Error details: ${result.debug.error}`, 'error');
            }
          }
          
          // Also log full error response for debugging
          debugLog(`[DEBUG] Full error response: ${JSON.stringify(result, null, 2)}`, 'error');
          showStatus(`Backlink CSV error: ${errorMsg}`, 'error');
        }
      } catch (error) {
        const errorMsg = error.message || error.toString() || 'Unknown error';
        statusDiv.innerHTML = `<span style="color: #ef4444;"> ${errorMsg}</span>`;
        debugLog(` Backlink CSV upload error: ${errorMsg}`, 'error');
        debugLog(`Error stack: ${error.stack || 'No stack trace'}`, 'error');
        showStatus(`Backlink CSV error: ${errorMsg}`, 'error');
      }
    }

    // Clear backlink CSV
    function clearBacklinkCsv() {
      const textarea = document.getElementById('backlinkCsvContent');
      const fileInput = document.getElementById('backlinkCsvFile');
      const statusDiv = document.getElementById('backlinkCsvStatus');
      
      textarea.value = '';
      fileInput.value = '';
      localStorage.removeItem('backlink_csv_content');
      statusDiv.innerHTML = '<span style="color: #666;">Backlink CSV cleared</span>';
      debugLog('Backlink CSV cleared', 'info');
      showStatus('Backlink CSV cleared', 'success');
    }

    // Sync CSV from alan-shared-resources
    async function syncCSV() {
      const btn = document.getElementById('syncCsvBtn');
      const btnText = document.getElementById('syncCsvBtnText');
      const originalText = btnText.textContent;
      
      debugLog('=== CSV SYNC: Starting CSV sync verification ===', 'info');
      debugLog('Button clicked - initiating CSV sync check...', 'info');
      
      // Disable button and show loading state
      btn.disabled = true;
      btnText.textContent = ' Syncing...';
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      debugLog('Button state: disabled, showing loading indicator', 'info');
      
      try {
        debugLog('Fetching /api/sync-csv endpoint...', 'info');
        const response = await fetch(apiUrl('/api/sync-csv'), {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
        });
        
        debugLog(`API response status: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
        
        const data = await response.json();
        debugLog(`API response data: ${JSON.stringify(data).substring(0, 200)}...`, 'info');
        
        if (response.ok && data.status === 'ok') {
          const urlCount = data.data.totalUrls || 0;
          const source = data.source || 'unknown';
          
          debugLog(` CSV fetched successfully from ${source}`, 'success');
          debugLog(`  CSV URL: ${data.csvUrl || 'not provided'}`, 'info');
          debugLog(`  Total URLs fetched: ${urlCount}`, 'success');
          debugLog(`  CSV size: ${data.data.csvSize} bytes`, 'info');
          debugLog(`  Lines processed: ${data.data.linesProcessed || 'N/A'}`, 'info');
          debugLog(`  Fetched at: ${data.data.fetchedAt}`, 'info');
          
          // Show toast with URL count
          showStatus(` CSV synced from ${source}! Fetched ${urlCount} URLs.`, 'success');
          btnText.textContent = ` ${urlCount} URLs`;
          
          // Reset button after 3 seconds
          setTimeout(() => {
            btnText.textContent = originalText;
            btn.style.opacity = '1';
            debugLog('Button reset to original state', 'info');
          }, 3000);
        } else {
          debugLog(` CSV sync failed`, 'error');
          debugLog(`  Error message: ${data.message || 'Unknown error'}`, 'error');
          debugLog(`  CSV URL attempted: ${data.csvUrl || 'not provided'}`, 'error');
          if (data.suggestion) {
            debugLog(`  Suggestion: ${data.suggestion}`, 'warn');
          }
          showStatus(`CSV sync failed: ${data.message}. ${data.suggestion || ''}`, 'error');
          btnText.textContent = ' Sync Failed';
          
          // Reset button after 5 seconds
          setTimeout(() => {
            btnText.textContent = originalText;
            btn.style.opacity = '1';
            debugLog('Button reset to original state after error', 'info');
          }, 5000);
        }
      } catch (error) {
        debugLog(` CSV sync error occurred`, 'error');
        debugLog(`  Error type: ${error.name || 'Unknown'}`, 'error');
        debugLog(`  Error message: ${error.message}`, 'error');
        if (error.stack) {
          debugLog(`  Stack trace: ${error.stack.substring(0, 300)}...`, 'error');
        }
        showStatus(`CSV sync error: ${error.message}. Please run "npm run sync:csv" locally.`, 'error');
        btnText.textContent = ' Error';
        
        // Reset button after 5 seconds
        setTimeout(() => {
          btnText.textContent = originalText;
          btn.style.opacity = '1';
          debugLog('Button reset to original state after exception', 'info');
        }, 5000);
      } finally {
        btn.disabled = false;
        btn.style.cursor = 'pointer';
        debugLog('=== CSV SYNC: Complete ===', 'info');
      }
    }

    // Update progress bar
    function updateProgress(percent, statusText) {
      const progressBar = document.getElementById('progressBar');
      const progressStatus = document.getElementById('progressStatus');
      if (progressBar) {
        progressBar.style.width = Math.min(100, Math.max(0, percent)) + '%';
        progressBar.textContent = Math.round(percent) + '%';
      }
      if (progressStatus) {
        progressStatus.textContent = statusText || 'Processing...';
      }
    }

    // Show status message
    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = `status ${type} show`;
      setTimeout(() => {
        status.classList.remove('show');
      }, 5000);
    }

    // Show completion summary modal
    function showCompletionModal(schemaAudit) {
      debugLog('showCompletionModal called', 'info');
      const modal = document.getElementById('completionModal');
      const content = document.getElementById('completionSummaryContent');
      
      debugLog(`Modal element found: ${modal ? 'yes' : 'no'}`, 'info');
      debugLog(`Content element found: ${content ? 'yes' : 'no'}`, 'info');
      
      if (!modal || !content) {
        debugLog(' Modal or content element not found, cannot show modal', 'error');
        return;
      }
      
      let html = '';
      
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const data = schemaAudit.data;
        const meta = schemaAudit.meta || {};
        const diag = meta.diagnostic || {};
        
        const totalPages = data.totalPages || diag.totalPages || 0;
        const successfulPages = diag.successfulPages || (totalPages - (data.missingSchemaCount || 0));
        const failedPages = diag.failedPages || data.missingSchemaCount || 0;
        const isComplete = failedPages === 0;
        
        html += `<div style="margin-bottom: 1.5rem;">`;
        html += `<div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">`;
        html += `<span style="font-size: 2rem;">${isComplete ? '' : ''}</span>`;
        html += `<h3 style="margin: 0; color: ${isComplete ? '#10b981' : '#f59e0b'};">
          ${isComplete ? 'Complete' : 'Incomplete'} Data
        </h3>`;
        html += `</div>`;
        
        html += `<div style="background: ${isComplete ? '#f0fdf4' : '#fffbeb'}; border-left: 4px solid ${isComplete ? '#10b981' : '#f59e0b'}; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">`;
        html += `<p style="margin: 0; color: #555; line-height: 1.6;">`;
        if (isComplete) {
          html += `All pages were successfully crawled. Dashboard data is complete and accurate.`;
        } else {
          html += `<strong>Warning:</strong> ${failedPages} page${failedPages !== 1 ? 's' : ''} failed to crawl. Dashboard data may be incomplete. Failed pages are counted as missing schema.`;
        }
        html += `</p>`;
        html += `</div>`;
        
        html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">`;
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Total URLs Scanned</div>`;
        html += `<div style="font-size: 1.5rem; font-weight: 600; color: #333;">${totalPages}</div>`;
        html += `</div>`;
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Successful Crawls</div>`;
        html += `<div style="font-size: 1.5rem; font-weight: 600; color: #10b981;">${successfulPages}</div>`;
        html += `</div>`;
        html += `</div>`;
        
        if (failedPages > 0) {
          // Get failed URLs from missingSchemaPages that have errors
          const failedUrls = (data.missingSchemaPages || []).filter(p => p.error).map(p => p.url);
          
          html += `<div style="background: #fef2f2; border-left: 4px solid #ef4444; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">`;
          html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Failed Crawls</div>`;
          html += `<div style="font-size: 1.5rem; font-weight: 600; color: #ef4444;">${failedPages}</div>`;
          
          if (diag.errorTypes && Object.keys(diag.errorTypes).length > 0) {
            html += `<div style="margin-top: 0.75rem; font-size: 0.85rem; color: #666;">`;
            html += `<strong>Error Breakdown:</strong><br>`;
            Object.entries(diag.errorTypes).forEach(([type, count]) => {
              html += `${type}: ${count}<br>`;
            });
            html += `</div>`;
          }
          
          // Add retry button if there are failed URLs
          if (failedUrls.length > 0) {
            html += `<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #fee2e2;">`;
            html += `<button id="retryFailedUrls" class="btn" style="background: #10b981; color: white; border-color: #10b981; width: 100%;" title="Retry crawling the ${failedUrls.length} failed URLs. This will rescan only the URLs that failed during the initial audit.">`;
            html += ` Retry Failed URLs (${failedUrls.length})`;
            html += `</button>`;
            html += `<div style="font-size: 0.8rem; color: #666; margin-top: 0.5rem; text-align: center;">Click to rescan only the failed URLs</div>`;
            html += `</div>`;
          }
          
          html += `</div>`;
        }
        
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px; margin-top: 1rem;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;"><strong>Schema Coverage</strong></div>`;
        // Ensure coverage is a number, not an object
        const coverageValue = typeof data.coverage === 'number' && !isNaN(data.coverage) 
          ? data.coverage 
          : (() => {
              // Calculate from pagesWithSchema and totalPages if coverage is not a number
              const pagesWithSchemaCount = Array.isArray(data.pagesWithSchema) 
                ? data.pagesWithSchema.length 
                : (typeof data.pagesWithSchema === 'number' ? data.pagesWithSchema : 0);
              const totalPagesCount = typeof data.totalPages === 'number' ? data.totalPages : totalPages;
              return totalPagesCount > 0 ? ((pagesWithSchemaCount / totalPagesCount) * 100) : 0;
            })();
        html += `<div style="font-size: 1.25rem; font-weight: 600; color: #333;">${coverageValue.toFixed(1)}%</div>`;
        const pagesWithSchemaCount = Array.isArray(data.pagesWithSchema) 
          ? data.pagesWithSchema.length 
          : (typeof data.pagesWithSchema === 'number' ? data.pagesWithSchema : 0);
        html += `<div style="font-size: 0.85rem; color: #666; margin-top: 0.25rem;">${pagesWithSchemaCount} pages with inline schema</div>`;
        
        // Display schema types if available, properly formatted
        if (data.schemaTypes && Array.isArray(data.schemaTypes) && data.schemaTypes.length > 0) {
          const formattedTypes = data.schemaTypes
            .filter(t => t !== null && t !== undefined)
            .map(t => {
              if (typeof t === 'string') return t;
              if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type;
              return null;
            })
            .filter(t => t !== null && typeof t === 'string')
            .slice(0, 10)
            .join(', ');
          if (formattedTypes) {
            html += `<div style="font-size: 0.75rem; color: #666; margin-top: 0.5rem; line-height: 1.4;">Schema types: ${formattedTypes}${data.schemaTypes.length > 10 ? '...' : ''}</div>`;
          }
        }
        html += `</div>`;
        
        html += `</div>`;
      } else {
        // Provide more helpful error message
        let errorMsg = 'Unable to load audit summary data.';
        if (!schemaAudit) {
          errorMsg = 'Schema audit data is missing. The audit may have failed or data was not saved properly.';
        } else if (schemaAudit.status !== 'ok') {
          errorMsg = `Schema audit failed with status: ${schemaAudit.status}. ${schemaAudit.error || schemaAudit.message || ''}`;
        } else if (!schemaAudit.data) {
          errorMsg = 'Schema audit completed but data is missing. Please check the console for errors.';
        }
        html += `<div style="background: #fef2f2; border-left: 4px solid #ef4444; padding: 1rem; border-radius: 4px;">`;
        html += `<p style="margin: 0; color: #991b1b; line-height: 1.6;">${errorMsg}</p>`;
        html += `<p style="margin: 0.5rem 0 0 0; font-size: 0.85rem; color: #666;">Check the debug log at the bottom of the page for more details.</p>`;
        html += `</div>`;
        debugLog(` Completion modal error: schemaAudit=${!!schemaAudit}, status=${schemaAudit?.status}, hasData=${!!schemaAudit?.data}, hasMeta=${!!schemaAudit?.meta}`, 'warn');
      }
      
      content.innerHTML = html;
      modal.style.display = 'block';
      debugLog('Modal display set to block', 'info');
      debugLog(`Modal is now visible: ${modal.style.display}`, 'info');
      
      // Attach retry button handler if it exists
      const retryButton = document.getElementById('retryFailedUrls');
      if (retryButton) {
        retryButton.onclick = function() {
          retryFailedUrls(schemaAudit);
        };
      }
    }
    
    // Retry failed URLs from schema audit
    async function retryFailedUrls(schemaAudit) {
      if (!schemaAudit || !schemaAudit.data || !schemaAudit.data.missingSchemaPages) {
        debugLog(' No failed URLs to retry', 'error');
        showStatus('No failed URLs found to retry', 'error');
        return;
      }
      
      // Extract failed URLs (those with errors)
      const failedUrls = schemaAudit.data.missingSchemaPages
        .filter(p => p.error)
        .map(p => p.url);
      
      if (failedUrls.length === 0) {
        debugLog(' No failed URLs to retry', 'error');
        showStatus('No failed URLs found to retry', 'error');
        return;
      }
      
      debugLog(` Retrying ${failedUrls.length} failed URLs...`, 'info');
      showStatus(`Retrying ${failedUrls.length} failed URLs...`, 'info');
      
      // Close the modal
      closeCompletionModal();
      
      // Show loading indicator
      document.getElementById('loading').classList.add('show');
      document.getElementById('dashboard').style.display = 'none';
      updateProgress(0, `Retrying ${failedUrls.length} failed URLs...`);
      
      try {
        updateProgress(20, 'Scanning failed URLs for schema markup...');
        debugLog(`Sending retry request for ${failedUrls.length} URLs`, 'info');
        
        // Call schema-audit API with only the failed URLs
        const schemaResponse = await fetch(apiUrl('/api/schema-audit'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ urls: failedUrls })
        });
        
        if (!schemaResponse.ok) {
          throw new Error(`Schema audit API returned error: ${schemaResponse.status}`);
        }
        
        const retrySchemaAudit = await schemaResponse.json();
        
        if (retrySchemaAudit.status !== 'ok') {
          throw new Error(retrySchemaAudit.message || 'Schema audit failed');
        }
        
        const retryData = retrySchemaAudit.data;
        const retrySuccessful = retryData.pagesWithSchema || 0;
        const retryStillFailed = (retryData.missingSchemaCount || 0);
        
        debugLog(` Retry completed: ${retrySuccessful} pages now have schema, ${retryStillFailed} still failed`, 'success');
        updateProgress(60, 'Merging retry results with original audit...');
        
        // Load original audit results from localStorage or Supabase
        const savedAudit = await loadAuditResults();
        if (savedAudit && savedAudit.schemaAudit && savedAudit.schemaAudit.data) {
          // Merge retry results with original schema audit
          const originalData = savedAudit.schemaAudit.data;
          const originalPages = originalData.pagesWithSchema || 0;
          const originalFailed = originalData.missingSchemaCount || 0;
          
          // Create merged schema audit data
          const mergedSchemaAudit = {
            ...savedAudit.schemaAudit,
            data: {
              ...originalData,
              // Update counts: add retry successful pages, remove retry successful from failed
              pagesWithSchema: originalPages + retrySuccessful,
              missingSchemaCount: Math.max(0, originalFailed - retrySuccessful),
              // Update missingSchemaPages: remove successfully retried URLs
              missingSchemaPages: (originalData.missingSchemaPages || []).filter(p => {
                // Keep only pages that weren't in the retry list or still failed
                return !failedUrls.includes(p.url) || (retryData.missingSchemaPages || []).some(rp => rp.url === p.url);
              }),
              // Update coverage
              coverage: ((originalPages + retrySuccessful) / originalData.totalPages) * 100
            }
          };
          
          // Update saved audit with merged results
          const mergedAudit = {
            ...savedAudit,
            schemaAudit: mergedSchemaAudit
          };
          
          // Recalculate scores with merged data (use saved localSignals if available)
          // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
          const normalizedSiteReviews = getTrustpilotSnapshot(savedAudit.siteReviews || null);
          const mergedScores = await calculatePillarScores(savedAudit.searchData, mergedSchemaAudit, savedAudit.localSignals || null, normalizedSiteReviews, savedAudit.backlinkMetrics || null);
          const mergedSnippetReadiness = calculateSnippetReadiness(mergedScores, savedAudit.searchData);
          
          // Save merged results (preserve localSignals, siteReviews, and backlinkMetrics)
          saveAuditResults(mergedScores, savedAudit.searchData, mergedSnippetReadiness, mergedSchemaAudit, savedAudit.localSignals || null, normalizedSiteReviews, savedAudit.backlinkMetrics || null);
          
          // Update retry button visibility
          updateRetryButtonVisibility(mergedSchemaAudit);
          
          // Refresh dashboard with merged results
          updateProgress(80, 'Refreshing dashboard with merged results...');
          displayDashboard(mergedScores, savedAudit.searchData, mergedSnippetReadiness, mergedSchemaAudit, savedAudit.localSignals || null);
          
          updateProgress(100, 'Retry completed and dashboard updated!');
          showStatus(`Retry completed: ${retrySuccessful} URLs now have schema. Dashboard updated with merged results.`, 'success');
          
          // Show completion modal with merged results
          showCompletionModal(mergedSchemaAudit);
        } else {
          // No saved audit found, just show retry results
          updateProgress(80, 'Retry completed!');
          showCompletionModal(retrySchemaAudit);
          updateProgress(100, 'Retry completed!');
          showStatus(`Retry completed: ${retrySuccessful} URLs now have schema, ${retryStillFailed} still failed`, 'success');
          debugLog(' No saved audit found to merge with. Run full audit to see complete results.', 'warn');
        }
        
      } catch (error) {
        debugLog(` Retry error: ${error.message}`, 'error');
        showStatus(`Error retrying failed URLs: ${error.message}`, 'error');
      } finally {
        document.getElementById('loading').classList.remove('show');
        setTimeout(() => {
          updateProgress(0, 'Initializing audit scan...');
        }, 500);
      }
    }

    // Save audit results to localStorage
    function saveAuditResults(scores, searchData, snippetReadiness, schemaAudit, localSignals = null, siteReviews = null, backlinkMetrics = null, preserveTimestamp = false) {
      try {
        const dateRange = parseInt(document.getElementById('dateRange')?.value) || 30;
        // Get property URL from input field or from searchData
        const propertyUrl = document.getElementById('propertyUrl')?.value || 
                           searchData?.propertyUrl || 
                           searchData?.property_url ||
                           localStorage.getItem('gsc_property_url') ||
                           'https://www.alanranger.com'; // Fallback default
        
        // Get existing audit data to preserve timestamp if requested
        let existingTimestamp = null;
        if (preserveTimestamp) {
          try {
            const existing = localStorage.getItem('last_audit_results');
            if (existing) {
              const parsed = JSON.parse(existing);
              existingTimestamp = parsed.timestamp;
            }
          } catch (e) {
            // Ignore errors when reading existing data
          }
        }
        
        const auditData = {
          scores,
          searchData,
          snippetReadiness,
          schemaAudit,
          localSignals, // Store local signals data for future use
          siteReviews, // Store site reviews data for future use (preserve on retry)
          backlinkMetrics, // Store backlink metrics data
          dateRange, // Store the date range used for this audit
          propertyUrl, // CRITICAL: Save property URL so we can fetch from Supabase later
          timestamp: preserveTimestamp && existingTimestamp ? existingTimestamp : new Date().toISOString(),
          // Save Money Pages Priority Matrix data for persistence
          moneyPagePriorityData: window.moneyPagePriorityData || null,
          moneySegmentMetrics: window.moneySegmentMetrics || null
        };
        
        // Try to save to localStorage, but don't fail if quota exceeded (Supabase is source of truth)
        if (safeSetLocalStorage('last_audit_results', auditData)) {
          debugLog(` Audit results saved to localStorage (propertyUrl: ${propertyUrl})`, 'success');
        }
        // Also save property URL separately for easy access
        if (propertyUrl) {
          localStorage.setItem('gsc_property_url', propertyUrl);
        }
        debugLog(` Audit results saved to localStorage (propertyUrl: ${propertyUrl})`, 'success');
        
        // Update timestamp display
        updateAuditTimestamp(auditData.timestamp);
      } catch (error) {
        debugLog(` Error saving audit results: ${error.message}`, 'error');
      }
    }
    
    // Show full-screen loading overlay
    function showFullScreenLoading(message = 'Loading...') {
      // Remove any existing overlay
      const existing = document.getElementById('fullScreenLoadingOverlay');
      if (existing) existing.remove();
      
      // Create overlay
      const overlay = document.createElement('div');
      overlay.id = 'fullScreenLoadingOverlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(4px);
      `;
      
      // Create spinner container
      const spinnerContainer = document.createElement('div');
      spinnerContainer.style.cssText = `
        background: white;
        padding: 3rem 4rem;
        border-radius: 12px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        text-align: center;
        min-width: 300px;
      `;
      
      // Create spinner
      const spinner = document.createElement('div');
      spinner.style.cssText = `
        width: 60px;
        height: 60px;
        border: 6px solid #e2e8f0;
        border-top-color: #3b82f6;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 1.5rem;
      `;
      
      // Create message
      const messageDiv = document.createElement('div');
      messageDiv.style.cssText = 'font-size: 1.1rem; color: #1f2937; font-weight: 500;';
      messageDiv.textContent = message;
      
      // Add spin animation if not already in stylesheet
      if (!document.getElementById('full-screen-spin-style')) {
        const style = document.createElement('style');
        style.id = 'full-screen-spin-style';
        style.textContent = '@keyframes spin { to { transform: rotate(360deg); } }';
        document.head.appendChild(style);
      }
      
      spinnerContainer.appendChild(spinner);
      spinnerContainer.appendChild(messageDiv);
      overlay.appendChild(spinnerContainer);
      document.body.appendChild(overlay);
    }
    
    // Hide full-screen loading overlay
    function hideFullScreenLoading() {
      const overlay = document.getElementById('fullScreenLoadingOverlay');
      if (overlay) overlay.remove();
    }
    
    // Update audit results for new date range without full rescan
    async function updateAuditForNewDateRange(newDateRange, savedAudit) {
      // Show full-screen loading overlay
      showFullScreenLoading(`Updating metrics for ${newDateRange} day period...`);
      
      try {
        showStatus(`Updating metrics for ${newDateRange} day period...`, 'info');
        
        const propertyUrl = document.getElementById('propertyUrl')?.value || savedAudit.propertyUrl || '';
        if (!propertyUrl) {
          // Remove loading spinner
          if (trendCanvas && trendCanvas.parentElement) {
            const loadingDiv = trendCanvas.parentElement.querySelector('.trend-chart-loading');
            if (loadingDiv) loadingDiv.remove();
          }
          clearDashboard();
          showStatus(`Date range changed to ${newDateRange} days. Please run a new audit to see updated metrics.`, 'info');
          return;
        }
        
        // Get API key (needed for fetchSearchConsoleData signature, but not actually used)
        let apiKey = window._loadedApiKey || '';
        
        // Fetch new GSC data for the new date range (will use Supabase cache)
        debugLog(`Fetching GSC data for ${newDateRange} day period...`, 'info');
        const searchData = await fetchSearchConsoleData(apiKey, propertyUrl, newDateRange);
        
        // Fetch local signals (Business Profile data doesn't change with date range, but fetch to ensure it's fresh)
        let localSignals = savedAudit.localSignals || null;
        
        // Normalize cached localSignals structure if needed (handle old format where it might just be {data: {...}})
        if (localSignals && localSignals.data && !localSignals.status) {
          debugLog(`[Local Signals] Normalizing cached data structure - wrapping in status/data format`, 'info');
          localSignals = { status: 'ok', data: localSignals.data || localSignals };
        }
        
        try {
          const localSignalsResponse = await fetch(apiUrl(`/api/aigeo/local-signals?property=${encodeURIComponent(propertyUrl)}`));
          if (localSignalsResponse.ok) {
            const freshLocalSignals = await localSignalsResponse.json();
            debugLog(`[Local Signals API] Response received - status: ${freshLocalSignals.status}, has data: ${!!freshLocalSignals.data}, locations count: ${freshLocalSignals.data?.locations?.length || 0}, structure keys: ${Object.keys(freshLocalSignals).join(', ')}`, 'info');
            
            // Use fresh data if API returned successfully
            if (freshLocalSignals.status === 'ok' && freshLocalSignals.data) {
              // Always use fresh data if API returned successfully, even if locations is 0
              // (API might return 0 locations legitimately, or we want to update cached data)
              localSignals = freshLocalSignals;
              debugLog(` Local signals data fetched successfully - Locations: ${freshLocalSignals.data.locations?.length || 0}, Service Areas: ${freshLocalSignals.data.serviceAreas?.length || 0}, NAP: ${freshLocalSignals.data.napConsistencyScore}`, 'success');
            } else if (freshLocalSignals.status === 'error') {
              debugLog(` Local signals API error: ${freshLocalSignals.error?.message || 'Unknown error'}, keeping cached data`, 'warn');
              // Keep using cached data - don't overwrite with error response
            } else {
              debugLog(` Local signals API returned unexpected status (status: ${freshLocalSignals.status}, has data: ${!!freshLocalSignals.data}, locations: ${freshLocalSignals.data?.locations?.length || 0}), keeping cached data`, 'warn');
              // Keep using cached data - don't overwrite with unexpected response
            }
          }
        } catch (localSignalsError) {
          debugLog(` Local signals error: ${localSignalsError.message}, using cached data if available`, 'warn');
        }
        
        // Final normalization - ensure localSignals always has the correct structure
        if (localSignals && localSignals.data && !localSignals.status) {
          localSignals = { status: 'ok', data: localSignals.data || localSignals };
        }
        
        // Recalculate pillar scores based on new GSC data
        // Keep existing schema audit data (doesn't change with date range)
        // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
        const normalizedSiteReviews = getTrustpilotSnapshot(savedAudit.siteReviews || null);
        // Get backlinkMetrics from savedAudit (it should be there from the last audit)
        const backlinkMetrics = savedAudit.backlinkMetrics || null;
        const scores = await calculatePillarScores(searchData, savedAudit.schemaAudit, localSignals, normalizedSiteReviews, backlinkMetrics);
        const snippetReadiness = calculateSnippetReadiness(scores, searchData);
        
        debugLog(`Recalculated scores for ${newDateRange} days: ${JSON.stringify(scores)}`, 'info');
        
        // Update saved audit with new data
        // Preserve the original audit timestamp - don't update it when changing date range
        const updatedAudit = {
          ...savedAudit,
          dateRange: newDateRange,
          searchData: searchData,
          scores: scores,
          snippetReadiness: snippetReadiness,
          localSignals: localSignals, // Store local signals for future use
          timestamp: savedAudit.timestamp || new Date().toISOString(), // Preserve original timestamp
          // Preserve Money Pages Priority Matrix data if it exists
          moneyPagePriorityData: window.moneyPagePriorityData || savedAudit.moneyPagePriorityData || null,
          moneySegmentMetrics: window.moneySegmentMetrics || savedAudit.moneySegmentMetrics || null
        };
        
        // Save updated audit
        // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
        const normalizedSiteReviewsForLoad = getTrustpilotSnapshot(savedAudit.siteReviews || null);
        // Use backlinkMetrics from savedAudit (preserved from last audit)
        const preservedBacklinkMetrics = backlinkMetrics;
        // Pass preserveTimestamp=true to keep the original audit timestamp
        saveAuditResults(scores, searchData, snippetReadiness, savedAudit.schemaAudit, localSignals, normalizedSiteReviewsForLoad, preservedBacklinkMetrics, true);
        safeSetLocalStorage('last_audit_results', updatedAudit);
        
        // Do NOT save to Supabase here.
        // This "metrics refresh" (date range change) is not a full audit run, and saving it
        // can incorrectly update today's audit_results row and the "Last Audit" time.
        
        // Update dashboard with new data - ensure scores object has all required properties
        debugLog(`Updating dashboard with scores: ${JSON.stringify(scores)}`, 'info');
        displayDashboard(scores, searchData, snippetReadiness, savedAudit.schemaAudit, localSignals);
        
        showStatus(`Metrics updated for ${newDateRange} day period.`, 'success');
        debugLog(` Audit updated for ${newDateRange} day period`, 'success');
        
      } catch (error) {
        debugLog(` Error updating audit for new date range: ${error.message}`, 'error');
        
        // Remove loading spinner and show error
        // Hide full-screen loading overlay
        hideFullScreenLoading();
        
        // Show error message in trend chart area
        const trendCanvas = document.getElementById('trendChart');
        if (trendCanvas && trendCanvas.parentElement) {
          // Remove any existing error messages
          const existingError = trendCanvas.parentElement.querySelector('.trend-chart-error');
          if (existingError) existingError.remove();
          
          // Show error message to user
          const errorDiv = document.createElement('div');
          errorDiv.className = 'trend-chart-error';
          errorDiv.style.cssText = 'background: #fee2e2; padding: 1rem; border-radius: 4px; border-left: 3px solid #ef4444; margin-bottom: 1rem; font-size: 0.9rem; color: #991b1b;';
          errorDiv.innerHTML = `<strong>Error updating trend chart:</strong> ${error.message}. Please refresh the page or run a new audit.`;
          trendCanvas.parentElement.insertBefore(errorDiv, trendCanvas);
        }
        
        clearDashboard();
        showStatus(`Date range changed to ${newDateRange} days. Please run a new audit to see updated metrics.`, 'info');
      }
    }
    
    // Clear dashboard and show message that new audit is needed
    function clearDashboard() {
      const dashboard = document.getElementById('dashboard');
      if (dashboard) {
        dashboard.style.display = 'none';
      }
      // Clear any charts
      if (window.radarChart) {
        window.radarChart.destroy();
        window.radarChart = null;
      }
      if (window.trendChart) {
        window.trendChart.destroy();
        window.trendChart = null;
      }
      if (window.snippetReadinessChart) {
        window.snippetReadinessChart.destroy();
        window.snippetReadinessChart = null;
      }
    }
    
    // Load audit results from localStorage
    async function loadAuditResults() {
      let auditData = null;
      let localStorageData = null;
      let hasMoneyPagesData = false;
      let hasQueryTotals = false;
      
      // First, try localStorage
      try {
        const saved = localStorage.getItem('last_audit_results');
        if (saved) {
          localStorageData = JSON.parse(saved);
          debugLog(' Audit results loaded from localStorage', 'success');
          
          // Check if localStorage data has critical Money Pages data
          hasMoneyPagesData = !!(localStorageData?.scores?.moneyPagesMetrics || localStorageData?.moneyPagesMetrics);
          // Also check if queryTotals are present (needed for CTR/Impressions columns)
          hasQueryTotals = !!(localStorageData?.searchData?.queryTotals && Array.isArray(localStorageData.searchData.queryTotals) && localStorageData.searchData.queryTotals.length > 0);
          
          if (hasMoneyPagesData) {
            debugLog(` localStorage has moneyPagesMetrics: ${localStorageData?.scores?.moneyPagesMetrics?.rows?.length || localStorageData?.moneyPagesMetrics?.rows?.length || 0} rows`, 'success');
            if (!hasQueryTotals) {
              debugLog(` localStorage missing queryTotals (${localStorageData?.searchData?.queryTotals?.length || 0} items), will try Supabase...`, 'warn');
            } else {
              debugLog(` localStorage has queryTotals: ${localStorageData.searchData.queryTotals.length} keywords`, 'success');
            }
            // Don't return yet: we still want to confirm "Last Audit" against Supabase
            auditData = localStorageData;
          } else {
            debugLog(' localStorage data missing moneyPagesMetrics, will try Supabase...', 'warn');
            // Keep localStorageData as fallback
            auditData = localStorageData;
          }
        }
      } catch (error) {
        debugLog(` Error loading audit results from localStorage: ${error.message}`, 'error');
      }
      
      // If localStorage is empty or missing critical data, try fetching from Supabase
      // Try multiple sources for property URL - prioritize saved audit data
      let propertyUrl = (localStorageData && localStorageData.propertyUrl) || // First check: saved in auditData
                        localStorage.getItem('gsc_property_url') || 
                        localStorage.getItem('last_property_url') ||
                        (localStorageData && localStorageData.searchData && localStorageData.searchData.propertyUrl) ||
                        (localStorageData && localStorageData.searchData && localStorageData.searchData.property_url);
      
      // If still no property URL, try to extract from saved audit data structure
      if (!propertyUrl && localStorageData) {
        // Check if there's a property URL embedded in the saved data
        if (localStorageData.searchData && typeof localStorageData.searchData === 'object') {
          propertyUrl = localStorageData.searchData.propertyUrl || localStorageData.searchData.property_url;
        }
      }
      
      // Last resort: try to get from input field
      if (!propertyUrl) {
        const propertyUrlInput = document.getElementById('propertyUrl');
        if (propertyUrlInput && propertyUrlInput.value) {
          propertyUrl = propertyUrlInput.value;
        }
      }
      
      debugLog(`Property URL for Supabase fetch: ${propertyUrl || 'NOT SET'}`, propertyUrl ? 'info' : 'warn');
      
      if (propertyUrl) {
        // Always do a quick minimal check so "Last Audit" reflects the latest *full* audit,
        // even when we can serve the rest of the page from localStorage.
        try {
          const minimalResponse = await fetch(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}&minimal=true`);
          if (minimalResponse.ok) {
            const minimalJson = await minimalResponse.json();
            const minimalData = minimalJson?.data;
            if (minimalJson?.status === 'ok' && minimalData?.timestamp) {
              updateAuditTimestamp(minimalData.timestamp);
              // IMPORTANT: also update cached local data, otherwise displayDashboard() will
              // overwrite the UI with stale localStorageData.timestamp.
              const normalizedTs = typeof minimalData.timestamp === 'number'
                ? new Date(minimalData.timestamp).toISOString()
                : minimalData.timestamp;
              if (localStorageData && normalizedTs) {
                localStorageData.timestamp = normalizedTs;
                try {
                  safeSetLocalStorage('last_audit_results', localStorageData);
                } catch (e) {
                  // Non-fatal
                }
              }
              if (auditData && normalizedTs) {
                auditData.timestamp = normalizedTs;
              }
            }
          }
        } catch (e) {
          // Non-fatal
        }

        // ALWAYS fetch from Supabase as the source of truth
        debugLog(` Always fetching from Supabase (source of truth)...`, 'info');
        debugLog(` Calling fetchLatestAuditFromSupabase(${propertyUrl})...`, 'info');
        const supabaseData = await fetchLatestAuditFromSupabase(propertyUrl);
        debugLog(` fetchLatestAuditFromSupabase returned: ${supabaseData ? 'data' : 'null/undefined'}`, supabaseData ? 'success' : 'warn');
        
        if (supabaseData) {
          debugLog(' Audit results loaded from Supabase', 'success');
          debugLog(` Supabase data structure: scores.moneyPagesMetrics=${!!supabaseData?.scores?.moneyPagesMetrics}, moneyPagesMetrics=${!!supabaseData?.moneyPagesMetrics}, searchData=${!!supabaseData?.searchData}, queryTotals=${supabaseData?.searchData?.queryTotals?.length || 0} keywords`, 'info');
          if (supabaseData.searchData) {
            debugLog(` Supabase searchData keys: ${Object.keys(supabaseData.searchData).join(', ')}`, 'info');
            if (supabaseData.searchData.queryTotals) {
              debugLog(` Supabase queryTotals type: ${Array.isArray(supabaseData.searchData.queryTotals) ? 'array' : typeof supabaseData.searchData.queryTotals}, length: ${Array.isArray(supabaseData.searchData.queryTotals) ? supabaseData.searchData.queryTotals.length : 'N/A'}`, 'success');
            } else {
              debugLog(` Supabase searchData exists but queryTotals is missing/null`, 'warn');
            }
          } else {
            debugLog(` Supabase data exists but searchData is missing/null`, 'warn');
          }
          
          // Store in localStorage for offline/cache purposes (but Supabase is always source of truth)
          try {
            safeSetLocalStorage('last_audit_results', supabaseData);
            debugLog(' Stored Supabase data in localStorage for caching', 'success');
            // Update timestamp display
            if (supabaseData.timestamp) {
              updateAuditTimestamp(supabaseData.timestamp);
            }
          } catch (storageError) {
            debugLog(` Could not store Supabase data in localStorage: ${storageError.message}`, 'warn');
          }
          return supabaseData;
        } else {
          debugLog(' No audit data found in Supabase (fetchLatestAuditFromSupabase returned null/undefined), using localStorage data as fallback', 'warn');
          debugLog(` This could mean: 1) No audit exists in Supabase for ${propertyUrl}, 2) API call failed, 3) API returned error status`, 'warn');
        }
      } else {
        debugLog(' Cannot fetch from Supabase: property URL not set, using localStorage data as fallback', 'warn');
      }
      
      // Return localStorage data as fallback (even if incomplete) rather than null
      // This ensures the page still loads with whatever data we have
      if (localStorageData) {
        debugLog(' Returning localStorage data as fallback (may be incomplete)', 'info');
        return localStorageData;
      }
      
      return null;
    }
    
    // Synchronous version for callers that can't be async (returns localStorage only)
    function loadAuditResultsSync() {
      try {
        const saved = localStorage.getItem('last_audit_results');
        if (saved) {
          return JSON.parse(saved);
        }
      } catch (error) {
        // Silent fail for sync version
      }
      return null;
    }
    
    // Update audit timestamp display
    function updateAuditTimestamp(timestamp) {
      const timestampElement = document.getElementById('lastAuditTime');
      const snippetTimestampElement = document.getElementById('snippetReadinessAuditTime');
      const snippetTimestampContainer = document.getElementById('snippetReadinessTimestamp');
      const radarTimestampElement = document.getElementById('radarChartAuditTime');
      const radarTimestampContainer = document.getElementById('radarChartTimestamp');
      
      if (timestamp) {
        const date = new Date(timestamp);
        // Format in GMT/UTC: "DD MMM YYYY, HH:MM:SS GMT"
        const day = String(date.getUTCDate()).padStart(2, '0');
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const month = monthNames[date.getUTCMonth()];
        const year = date.getUTCFullYear();
        const hours = String(date.getUTCHours()).padStart(2, '0');
        const minutes = String(date.getUTCMinutes()).padStart(2, '0');
        const seconds = String(date.getUTCSeconds()).padStart(2, '0');
        const formatted = `${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
        
        if (timestampElement) {
          timestampElement.textContent = formatted;
        }
        
        // Update snippet readiness timestamp
        if (snippetTimestampElement) {
          snippetTimestampElement.textContent = formatted;
        }
        if (snippetTimestampContainer) {
          snippetTimestampContainer.style.display = 'block';
        }
        
        // Update radar chart timestamp
        if (radarTimestampElement) {
          radarTimestampElement.textContent = formatted;
        }
        if (radarTimestampContainer) {
          radarTimestampContainer.style.display = 'block';
        }
      } else {
        if (timestampElement) {
          timestampElement.textContent = 'Not yet run';
        }
        if (snippetTimestampContainer) {
          snippetTimestampContainer.style.display = 'none';
        }
        if (radarTimestampContainer) {
          radarTimestampContainer.style.display = 'none';
        }
      }
    }
    
    // Save audit results to Supabase for historical tracking
    async function saveAuditToSupabase(propertyUrl, scores, searchData, snippetReadiness, schemaAudit, localSignals = null, auditDateOverride = null) {
      try {
        // IMPORTANT: Only full audits should write a new audit_date.
        // If auditDateOverride is provided, use it; otherwise try to derive from the saved audit timestamp.
        let auditDate = auditDateOverride;
        if (!auditDate) {
          try {
            const saved = loadAuditResultsSync();
            if (saved && saved.timestamp) {
              auditDate = new Date(saved.timestamp).toISOString().split('T')[0];
            }
          } catch (e) {
            // Ignore
          }
        }
        if (!auditDate) {
          auditDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD fallback
        }
        
        // Ensure searchData has overview object with siteTotalImpressions and siteTotalClicks
        // These are needed for calculating shareOfImpressions in buildMoneyPagesSummary
        let overview = null;
        
        if (searchData) {
          // Create overview object if it doesn't exist
          if (!searchData.overview) {
            searchData.overview = {};
          }
          
          // Populate overview with siteTotalImpressions and siteTotalClicks
          // Priority: searchData.overview.siteTotalImpressions > searchData.totalImpressions > searchData.overview.totalImpressions
          if (!searchData.overview.siteTotalImpressions || searchData.overview.siteTotalImpressions === 0) {
            if (searchData.totalImpressions != null && searchData.totalImpressions > 0) {
              searchData.overview.siteTotalImpressions = searchData.totalImpressions;
            } else if (searchData.overview.totalImpressions != null && searchData.overview.totalImpressions > 0) {
              searchData.overview.siteTotalImpressions = searchData.overview.totalImpressions;
            } else {
              // Fallback: set to 0 if all else fails
              searchData.overview.siteTotalImpressions = 0;
            }
          }
          
          if (!searchData.overview.siteTotalClicks || searchData.overview.siteTotalClicks === 0) {
            if (searchData.totalClicks != null && searchData.totalClicks > 0) {
              searchData.overview.siteTotalClicks = searchData.totalClicks;
            } else if (searchData.overview.totalClicks != null && searchData.overview.totalClicks > 0) {
              searchData.overview.siteTotalClicks = searchData.overview.totalClicks;
            } else {
              // Fallback: set to 0 if all else fails
              searchData.overview.siteTotalClicks = 0;
            }
          }
          
          // Also ensure totalImpressions and totalClicks are set in overview for compatibility
          if (!searchData.overview.totalImpressions) {
            searchData.overview.totalImpressions = searchData.overview.siteTotalImpressions;
          }
          if (!searchData.overview.totalClicks) {
            searchData.overview.totalClicks = searchData.overview.siteTotalClicks;
          }
          
          overview = searchData.overview;
          
          // Debug logging
          debugLog(`saveAuditToSupabase: searchData.totalImpressions=${searchData.totalImpressions}, overview.siteTotalImpressions=${overview.siteTotalImpressions || 'missing'}, overview.totalImpressions=${overview.totalImpressions || 'missing'}`, 'info');
        } else {
          debugLog(` saveAuditToSupabase: searchData is null or undefined`, 'warn');
          // Create empty overview as fallback
          overview = { siteTotalImpressions: 0, siteTotalClicks: 0, totalImpressions: 0, totalClicks: 0 };
        }
        
        // Build Money Pages summary for trend tracking (Phase 3)
        // CRITICAL: Ensure moneyPagesMetrics exists in scores - check multiple sources
        debugLog(`saveAuditToSupabase: Checking for moneyPagesMetrics - scores.moneyPagesMetrics=${!!scores?.moneyPagesMetrics}, window.moneyPagesMetrics=${!!window.moneyPagesMetrics}`, 'info');
        
        if (!scores.moneyPagesMetrics) {
          debugLog(` saveAuditToSupabase: scores.moneyPagesMetrics is missing, checking window.moneyPagesMetrics`, 'warn');
          // Try to get from global state if available
          if (window.moneyPagesMetrics) {
            scores.moneyPagesMetrics = window.moneyPagesMetrics;
            debugLog(` saveAuditToSupabase: Using moneyPagesMetrics from window (${window.moneyPagesMetrics.rows?.length || 0} rows)`, 'info');
          } else {
            debugLog(` saveAuditToSupabase: No moneyPagesMetrics available anywhere - this means money pages data was not generated during audit`, 'warn');
            debugLog(` saveAuditToSupabase: This could be because: 1) No queryPages data from GSC, 2) CSV fetch failed, 3) No money pages found in CSV`, 'warn');
            // Set to null explicitly so it's saved (even if empty)
            scores.moneyPagesMetrics = null;
          }
        } else {
          debugLog(` saveAuditToSupabase: moneyPagesMetrics found in scores (${scores.moneyPagesMetrics.rows?.length || 0} rows)`, 'info');
        }
        
        // CRITICAL: Log what we're about to save
        debugLog(`saveAuditToSupabase: Final moneyPagesMetrics to save: ${scores.moneyPagesMetrics ? (scores.moneyPagesMetrics.rows?.length || 0) + ' rows' : 'NULL'}`, 'info');
        
        // Ensure overview is never null - create fallback if needed
        if (!overview) {
          debugLog(` saveAuditToSupabase: overview is null, creating fallback`, 'warn');
          overview = { 
            siteTotalImpressions: searchData?.totalImpressions || 0, 
            siteTotalClicks: searchData?.totalClicks || 0,
            totalImpressions: searchData?.totalImpressions || 0,
            totalClicks: searchData?.totalClicks || 0
          };
        }
        
        debugLog(`saveAuditToSupabase: About to call buildMoneyPagesSummary - overview exists=${!!overview}, overview.siteTotalImpressions=${overview?.siteTotalImpressions || 'missing'}, searchData.totalImpressions=${searchData?.totalImpressions || 'missing'}, moneyPagesMetrics=${!!scores?.moneyPagesMetrics}`, 'info');
        const moneyPagesSummary = window.buildMoneyPagesSummary ? window.buildMoneyPagesSummary(
          scores?.moneyPagesMetrics || null,
          overview || { siteTotalImpressions: 0, siteTotalClicks: 0, totalImpressions: 0, totalClicks: 0 }
        ) : null;
        if (moneyPagesSummary) {
          debugLog(`saveAuditToSupabase: moneyPagesSummary created - shareOfImpressions=${moneyPagesSummary.shareOfImpressions || 'null'}`, 'info');
        } else {
          debugLog(`saveAuditToSupabase: moneyPagesSummary is null`, 'warn');
        }
        
        // Get money segment metrics for 12-month KPI tracking
        // Ensure it's never null - build empty structure if missing
        let moneySegmentMetrics = window.moneySegmentMetrics;
        if (!moneySegmentMetrics) {
          debugLog(` saveAuditToSupabase: moneySegmentMetrics is null, building empty structure`, 'warn');
          // Build empty structure to ensure it's always saved (even if empty)
          if (typeof buildMoneySegmentSummary === 'function') {
            // Try to rebuild from moneyPagePriorityData if available
            const priorityData = window.moneyPagePriorityData || [];
            if (priorityData.length > 0) {
              debugLog(` saveAuditToSupabase: Rebuilding moneySegmentMetrics from priority data (${priorityData.length} pages)`, 'info');
              moneySegmentMetrics = buildMoneySegmentSummary(priorityData, {});
            } else {
              moneySegmentMetrics = buildMoneySegmentSummary([], {});
            }
          } else {
            // Fallback structure if function not available
            moneySegmentMetrics = {
              allMoney: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
              landingPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
              eventPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
              productPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 }
            };
          }
        }
        
        // Also ensure moneyPagePriorityData is available for saving
        if (!window.moneyPagePriorityData || window.moneyPagePriorityData.length === 0) {
          debugLog(` saveAuditToSupabase: moneyPagePriorityData is missing or empty`, 'warn');
          // Try to rebuild from moneyPagesMetrics if available
          if (scores?.moneyPagesMetrics?.rows && scores.moneyPagesMetrics.rows.length > 0) {
            debugLog(` saveAuditToSupabase: Rebuilding moneyPagePriorityData from moneyPagesMetrics (${scores.moneyPagesMetrics.rows.length} rows)`, 'info');
            const topPagesForPriority = scores.moneyPagesMetrics.rows.map(row => ({
              page: row.url,
              url: row.url,
              clicks: row.clicks || 0,
              impressions: row.impressions || 0,
              ctr: (row.ctr || 0) * 100,
              position: row.avgPosition || 0,
              avgPosition: row.avgPosition || 0,
              title: row.title || row.url
            }));
            // Use window.buildMoneyPageMetrics if available, otherwise use local function
            if (typeof window.buildMoneyPageMetrics === 'function') {
              window.moneyPagePriorityData = window.buildMoneyPageMetrics(topPagesForPriority, schemaAudit);
            } else if (typeof buildMoneyPageMetrics === 'function') {
              window.moneyPagePriorityData = buildMoneyPageMetrics(topPagesForPriority, schemaAudit);
            } else {
              debugLog(` buildMoneyPageMetrics not available in saveAuditToSupabase, cannot rebuild`, 'error');
              window.moneyPagePriorityData = [];
            }
            debugLog(` saveAuditToSupabase: Rebuilt ${window.moneyPagePriorityData.length} priority entries`, 'info');
          }
        }
        debugLog(`saveAuditToSupabase: moneySegmentMetrics ready with ${Object.keys(moneySegmentMetrics).length} segments`, 'info');
        debugLog(`saveAuditToSupabase: moneySegmentMetrics.allMoney clicks=${moneySegmentMetrics.allMoney?.clicks || 0}, impressions=${moneySegmentMetrics.allMoney?.impressions || 0}`, 'info');
        
        // Get rankingAiData from localStorage or window if available
        let rankingAiData = null;
        try {
          const localRankingData = localStorage.getItem('rankingAiData');
          if (localRankingData) {
            rankingAiData = JSON.parse(localRankingData);
            debugLog(` saveAuditToSupabase: Loaded rankingAiData from localStorage (${rankingAiData.combinedRows?.length || 0} keywords)`, 'info');
          } else if (window.rankingAiData) {
            rankingAiData = window.rankingAiData;
            debugLog(` saveAuditToSupabase: Using rankingAiData from window (${rankingAiData.combinedRows?.length || 0} keywords)`, 'info');
          } else {
            debugLog(` saveAuditToSupabase: No rankingAiData available`, 'warn');
          }
        } catch (rankingErr) {
          debugLog(` saveAuditToSupabase: Error loading rankingAiData: ${rankingErr.message}`, 'warn');
        }
        
        // Ensure scores.moneyPages namespace exists and includes GSC page totals
        scores.moneyPages = scores.moneyPages || {};
        if (scores.moneyPagesMetrics) {
          // Add GSC range and page totals for persistence (if available)
          if (scores.moneyPagesMetrics.gscRange) {
            scores.moneyPages.gscRange = scores.moneyPagesMetrics.gscRange;
          }
          if (scores.moneyPagesMetrics.gscPageTotals28d) {
            scores.moneyPages.gscPageTotals28d = scores.moneyPagesMetrics.gscPageTotals28d;
          }
        }
        
        // Prepare payload
        const payload = {
          propertyUrl,
          auditDate,
          schemaAudit,
          scores,
          searchData,
          snippetReadiness,
          localSignals, // Pass Business Profile data for storage
          moneyPagesSummary, // Phase 3: Money Pages summary for trend tracking
          moneySegmentMetrics, // Phase: Money Pages Priority Matrix - segment metrics for KPI tracker
          moneyPagePriorityData: window.moneyPagePriorityData || null, // CRITICAL: Save Priority Matrix data to Supabase
          rankingAiData // Ranking & AI data (SERP rankings + AI Overview citations)
        };
        
        // Check payload size before sending (Vercel limit is ~4.5MB)
        const payloadJson = JSON.stringify(payload);
        const payloadSizeKB = Math.round(payloadJson.length / 1024);
        debugLog(`saveAuditToSupabase: Payload size: ${payloadSizeKB}KB`, 'info');
        
        if (payloadSizeKB > 4000) {
          debugLog(` Payload size (${payloadSizeKB}KB) exceeds 4MB - truncating large fields...`, 'warn');
          // Truncate queryPages if too large
          if (searchData?.queryPages && Array.isArray(searchData.queryPages) && searchData.queryPages.length > 2000) {
            debugLog(` Truncating queryPages from ${searchData.queryPages.length} to 2000 items`, 'warn');
            searchData.queryPages = searchData.queryPages.slice(0, 2000);
          }
          // Truncate topQueries if too large
          if (searchData?.topQueries && Array.isArray(searchData.topQueries) && searchData.topQueries.length > 500) {
            debugLog(` Truncating topQueries from ${searchData.topQueries.length} to 500 items`, 'warn');
            searchData.topQueries = searchData.topQueries.slice(0, 500);
          }
          // Recalculate payload size after truncation
          const truncatedPayload = {
            ...payload,
            searchData: { ...searchData }
          };
          const truncatedJson = JSON.stringify(truncatedPayload);
          const truncatedSizeKB = Math.round(truncatedJson.length / 1024);
          debugLog(`saveAuditToSupabase: Payload size after truncation: ${truncatedSizeKB}KB`, 'info');
          payload.searchData = truncatedPayload.searchData;
        }
        
        const response = await fetch(apiUrl('/api/supabase/save-audit'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload)
        });
        
        if (response.ok) {
          const result = await response.json();
          debugLog(` Audit results saved to Supabase successfully (audit_date: ${auditDate})`, 'success');
          debugLog(` Saved data: schema_total_pages=${schemaAudit?.data?.totalPages || 'N/A'}, scores=${JSON.stringify(Object.keys(scores || {}))}`, 'info');
          
          // Verify the save by checking Supabase
          try {
            debugLog('Verifying audit save in Supabase...', 'info');
            const verifyResponse = await fetch(apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}&minimal=true`));
            if (verifyResponse.ok) {
              const verifyResult = await verifyResponse.json();
              if (verifyResult.status === 'ok' && verifyResult.data && verifyResult.data.auditDate === auditDate) {
                debugLog(` Verified: Audit ${auditDate} exists in Supabase with schema_total_pages=${verifyResult.data.scores?.contentSchema !== null ? 'present' : 'null'}`, 'success');
                showStatus(` Audit saved and verified in Supabase (${auditDate})`, 'success');
              } else {
                debugLog(` Verification failed: Audit ${auditDate} not found in Supabase yet`, 'warn');
                showStatus(` Audit save reported success but verification pending (${auditDate})`, 'warn');
              }
            } else {
              debugLog(` Could not verify audit save: ${verifyResponse.status}`, 'warn');
              showStatus(` Audit saved to Supabase (${auditDate}) - verification skipped`, 'success');
            }
          } catch (verifyError) {
            debugLog(` Verification error (non-critical): ${verifyError.message}`, 'warn');
            showStatus(` Audit saved to Supabase (${auditDate})`, 'success');
          }
          
          // Save GSC page-level 28d metrics to Supabase
          let pageMetricsSaved = false;
          let pageMetricsData = null;
          try {
            if (window._pendingPageMetrics && window._pendingPageMetrics.pages && window._pendingPageMetrics.pages.length > 0) {
              pageMetricsData = window._pendingPageMetrics;
              debugLog(` Saving ${window._pendingPageMetrics.pages.length} page metrics to Supabase (run_id: ${auditDate})...`, 'info');
              
              const saveResponse = await fetch(apiUrl('/api/supabase/save-gsc-page-metrics'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  runId: auditDate,
                  siteUrl: window._pendingPageMetrics.propertyUrl,
                  dateStart: window._pendingPageMetrics.gscRange.startDate,
                  dateEnd: window._pendingPageMetrics.gscRange.endDate,
                  pages: window._pendingPageMetrics.pages
                })
              });
              
              if (saveResponse.ok) {
                const saveResult = await saveResponse.json();
                debugLog(` Saved ${saveResult.inserted} page metrics to Supabase`, 'success');
                pageMetricsSaved = true;
                
                // Clear pending metrics
                window._pendingPageMetrics = null;
              } else {
                const errorText = await saveResponse.text();
                debugLog(` Failed to save page metrics to Supabase: ${saveResponse.status} - ${errorText}`, 'warn');
              }
            } else {
              debugLog(` No pending page metrics to save (window._pendingPageMetrics=${!!window._pendingPageMetrics}, pages=${window._pendingPageMetrics?.pages?.length || 0})`, 'warn');
            }
          } catch (pageMetricsError) {
            debugLog(` Error saving page metrics to Supabase (non-critical): ${pageMetricsError.message}`, 'warn');
          }
          
          // Calculate and save portfolio segment snapshots (Phase 3a)
          // Run this even if page metrics save failed, as long as we have the data
          try {
            if (pageMetricsData || (window.pageTotalsByKey && window.pageTotalsByKey.size > 0)) {
              const propertyUrl = pageMetricsData?.propertyUrl || localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
              const dateStart = pageMetricsData?.gscRange?.startDate || (() => {
                const end = new Date();
                end.setDate(end.getDate() - 1);
                const start = new Date(end);
                start.setDate(start.getDate() - 27);
                return start.toISOString().split('T')[0];
              })();
              const dateEnd = pageMetricsData?.gscRange?.endDate || (() => {
                const end = new Date();
                end.setDate(end.getDate() - 1);
                return end.toISOString().split('T')[0];
              })();
              
              debugLog(` Starting portfolio segment snapshot calculation (runId=${auditDate}, propertyUrl=${propertyUrl}, dateStart=${dateStart}, dateEnd=${dateEnd})...`, 'info');
              await calculateAndSavePortfolioSegmentSnapshots(
                auditDate,
                propertyUrl,
                dateStart,
                dateEnd,
                window.pageTotalsByKey || new Map()
              );
              debugLog(` Portfolio segment snapshot calculation completed (runId=${auditDate})`, 'success');
            } else {
              debugLog(` Cannot calculate portfolio segment snapshots: no page metrics data available (pageMetricsData=${!!pageMetricsData}, pageTotalsByKey=${!!window.pageTotalsByKey && window.pageTotalsByKey.size > 0})`, 'warn');
            }
          } catch (segmentError) {
            debugLog(` Error saving portfolio segment snapshots (non-critical): ${segmentError.message}`, 'error');
            debugLog(` Error stack: ${segmentError.stack}`, 'error');
          }
          
          // Calculate and save portfolio snapshots (Phase 3)
          try {
            await calculateAndSavePortfolioSnapshots(auditDate);
          } catch (portfolioError) {
            debugLog(` Error saving portfolio snapshots (non-critical): ${portfolioError.message}`, 'warn');
          }
          
          // After saving, refresh Money Pages charts with updated history
          // This ensures the trend chart and KPI tracker show the new audit data
          try {
            debugLog('Refreshing Money Pages charts with updated history...', 'info');
            
            // Fetch updated history for Money Pages trend chart
            const endDate = new Date().toISOString().split('T')[0];
            const startDate = new Date();
            startDate.setFullYear(startDate.getFullYear() - 1);
            const startDateStr = startDate.toISOString().split('T')[0];
            
            const historyResponse = await fetch(apiUrl(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDate}`));
            if (historyResponse.ok) {
              const historyJson = await historyResponse.json();
              if (historyJson.status === 'ok' && historyJson.data) {
                // Render Money Pages trend chart with updated history
                if (typeof renderMoneyPagesTrendChart === 'function') {
                  setTimeout(() => {
                    renderMoneyPagesTrendChart(historyJson.data);
                    debugLog(' Money Pages trend chart refreshed', 'success');
                  }, 500); // Small delay to ensure DOM is ready
                }
                
                // Refresh KPI tracker
                if (typeof loadAuditHistoryAndRenderKpis === 'function') {
                  setTimeout(() => {
                    loadAuditHistoryAndRenderKpis(propertyUrl);
                    debugLog(' Money Pages KPI tracker refreshed', 'success');
                  }, 500);
                }
              }
            }
          } catch (refreshError) {
            debugLog(` Error refreshing Money Pages charts: ${refreshError.message}`, 'warn');
            // Don't fail the save operation if refresh fails
          }
        } else {
          // Read response body once as text, then try to parse as JSON to avoid "body stream already read" error
          let errorMessage = 'Unknown error';
          let errorDetails = null;
          try {
            const responseText = await response.text();
            // Try to parse as JSON
            try {
              const error = JSON.parse(responseText);
              errorMessage = error.message || error.details || responseText;
              errorDetails = error;
            } catch (parseError) {
              // Not JSON, use text as-is
              errorMessage = responseText || `HTTP ${response.status}: ${response.statusText}`;
            }
          } catch (textError) {
            errorMessage = `HTTP ${response.status}: ${response.statusText}`;
          }
          // Log detailed error for debugging
          console.error('[Supabase Save] Failed to save audit results to Supabase');
          console.error('[Supabase Save] Status:', response.status, response.statusText);
          console.error('[Supabase Save] Error message:', errorMessage);
          if (errorDetails) {
            console.error('[Supabase Save] Full error details:', JSON.stringify(errorDetails, null, 2));
          }
          // Show error to user - this is critical for data persistence
          debugLog(` FAILED to save audit to Supabase: ${errorMessage}`, 'error');
          showStatus(` Audit completed but failed to save to Supabase: ${errorMessage}. Check console for details.`, 'error');
        }
      } catch (error) {
        // Show error to user - this is critical for data persistence
        debugLog(` Supabase save exception: ${error.message}`, 'error');
        console.error('[Supabase Save] Exception:', error);
        showStatus(` Failed to save audit to Supabase: ${error.message}. Check console for details.`, 'error');
      }
    }
    
    // Fetch historical Content/Schema data from Supabase
    // Forward-fill missing audit dates in history data (exclude last 3 days due to GSC lag)
    function forwardFillHistoryData(history, excludeLastDays = 3) {
      if (!history || history.length === 0) return history;
      
      // Sort by date
      const sorted = [...history].sort((a, b) => new Date(a.date) - new Date(b.date));
      
      // Calculate cutoff date (exclude last N days)
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - excludeLastDays);
      
      // Track last known values for each metric
      const lastValues = {};
      
      // Forward-fill missing values (but not for dates in the last N days)
      return sorted.map(entry => {
        const entryDate = new Date(entry.date);
        const isRecent = entryDate >= cutoffDate;
        
        // List of metric keys to forward-fill
        const metricKeys = [
          'contentSchemaScore', 'visibilityScore', 'authorityScore', 'localEntityScore', 'serviceAreaScore',
          'brandScore', 'moneyPagesBehaviourScore', 'shareOfImpressions', 'shareOfClicks', 'ctr',
          'authorityBehaviourScore', 'authorityRankingScore', 'authorityBacklinkScore', 'authorityReviewScore'
        ];
        
        const filled = { ...entry };
        
        for (const key of metricKeys) {
          const value = entry[key];
          
          // Only forward-fill if:
          // 1. Value is null/undefined (NOT 0, as 0 is a valid score) AND
          // 2. We have a last known value AND
          // 3. This is NOT a recent date (within last N days)
          if ((value == null || value === undefined) && lastValues[key] != null && !isRecent) {
            filled[key] = lastValues[key];
          } else if (value != null && value !== undefined) {
            // Update last known value (including 0, as it's a valid score)
            lastValues[key] = value;
          }
        }
        
        // Handle nested objects (e.g., moneyPagesSummary)
        if (entry.moneyPagesSummary) {
          filled.moneyPagesSummary = { ...entry.moneyPagesSummary };
          const summaryKeys = ['shareOfImpressions', 'shareOfClicks', 'ctr'];
          for (const key of summaryKeys) {
            const value = entry.moneyPagesSummary[key];
            if ((value == null || value === undefined) && lastValues[`summary_${key}`] != null && !isRecent) {
              filled.moneyPagesSummary[key] = lastValues[`summary_${key}`];
            } else if (value != null && value !== undefined) {
              lastValues[`summary_${key}`] = value;
            }
          }
        }
        
        return filled;
      });
    }
    
    async function fetchContentSchemaHistory(propertyUrl, startDate, endDate) {
      try {
        // Use window.apiUrl if available (for functions outside the main scope)
        const urlHelper = window.apiUrl || ((path) => {
          // Fallback: check if running locally and prepend Vercel URL
          const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
          const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
          if (!baseUrl) {
            return path.startsWith('/') ? path : `/${path}`;
          }
          const cleanPath = path.startsWith('/') ? path : `/${path}`;
          return `${baseUrl}${cleanPath}`;
        });
        const response = await fetch(urlHelper(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDate}&endDate=${endDate}`));
        
        if (response.ok) {
          const result = await response.json();
          if (result.status === 'ok' && result.data) {
            debugLog(` Fetched ${result.count} historical Content/Schema records from Supabase`, 'success');
            // Forward-fill missing audit dates (exclude last 3 days for GSC lag)
            const filledData = forwardFillHistoryData(result.data, 3);
            return filledData;
          }
          } else {
            // Read response body once as text, then try to parse as JSON to avoid "body stream already read" error
            debugLog(` Supabase API returned non-OK status: ${response.status} ${response.statusText}`, 'warn');
            try {
              const responseText = await response.text();
              try {
                const error = JSON.parse(responseText);
                debugLog(` Supabase API error: ${error.message || 'Unknown error'}`, 'warn');
              } catch (parseError) {
                debugLog(` Supabase API error (non-JSON): ${responseText || 'Unknown error'}`, 'warn');
              }
            } catch (textError) {
              debugLog(` Could not read Supabase error response: ${textError.message}`, 'warn');
            }
          }
      } catch (error) {
        debugLog(` Supabase fetch error: ${error.message}`, 'warn');
      }
      return [];
    }
    
    // Fetch the latest audit from Supabase
    async function fetchLatestAuditFromSupabase(propertyUrl, minimalOnly = false) {
      try {
        if (!propertyUrl) {
          debugLog(' Cannot fetch from Supabase: property URL not set', 'warn');
          return null;
        }
        
        // Use window.apiUrl if available (for functions outside the main scope)
        const urlHelper = window.apiUrl || ((path) => {
          // Fallback: check if running locally and prepend Vercel URL
          const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
          const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
          if (!baseUrl) {
            return path.startsWith('/') ? path : `/${path}`;
          }
          const cleanPath = path.startsWith('/') ? path : `/${path}`;
          return `${baseUrl}${cleanPath}`;
        });
        
        // Step 1: Try minimal request first to get timestamp (fast, unlikely to timeout)
        let minimalData = null;
        if (!minimalOnly) {
          debugLog(`Fetching minimal audit data (timestamp + scores) from Supabase for ${propertyUrl}...`, 'info');
          try {
            const minimalController = new AbortController();
            const minimalTimeout = setTimeout(() => minimalController.abort(), 10000); // 10 second timeout
            
            const minimalResponse = await fetch(urlHelper(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}&minimal=true`), {
              signal: minimalController.signal
            });
            clearTimeout(minimalTimeout);
            
            if (minimalResponse.ok) {
              const minimalResult = await minimalResponse.json();
              if (minimalResult.status === 'ok' && minimalResult.data && minimalResult.data.timestamp) {
                minimalData = minimalResult.data; // Store minimal data for fallback
                // Update timestamp immediately, even if full data fetch fails
                updateAuditTimestamp(minimalResult.data.timestamp);
                debugLog(` Updated audit timestamp from minimal Supabase response: ${new Date(minimalResult.data.timestamp).toLocaleString()}`, 'success');
              }
            }
          } catch (minimalError) {
            if (minimalError.name === 'AbortError') {
              debugLog(` Minimal request timed out (non-critical)`, 'warn');
            } else {
              debugLog(` Minimal request failed (non-critical): ${minimalError.message}`, 'warn');
            }
            // Continue to try full request
          }
        }
        
        // Step 2: Try full request (may timeout, but we already have timestamp)
        debugLog(`Fetching full audit data from Supabase for ${propertyUrl}...`, 'info');
        try {
          const fullController = new AbortController();
          const fullTimeout = setTimeout(() => fullController.abort(), 30000); // 30 second timeout
          
          const response = await fetch(urlHelper(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`), {
            signal: fullController.signal
          });
          clearTimeout(fullTimeout);
          
          if (response.ok) {
            const result = await response.json();
            debugLog(` Supabase API response: status=${result.status}, hasData=${!!result.data}`, result.status === 'ok' && result.data ? 'success' : 'warn');
            if (result.status === 'ok' && result.data) {
              debugLog(` Found latest audit from Supabase: ${result.data.auditDate || 'unknown date'}`, 'success');
              // Debug: Check what moneyPagesMetrics structure we got
              const hasMoneyPages = !!(result.data?.scores?.moneyPagesMetrics || result.data?.moneyPagesMetrics);
              debugLog(` Supabase data check: hasMoneyPagesMetrics=${hasMoneyPages}, structure=${result.data?.scores?.moneyPagesMetrics ? 'scores.moneyPagesMetrics' : result.data?.moneyPagesMetrics ? 'moneyPagesMetrics' : 'none'}`, 'info');
              if (hasMoneyPages) {
                const rows = result.data?.scores?.moneyPagesMetrics?.rows || result.data?.moneyPagesMetrics?.rows || [];
                debugLog(` Supabase moneyPagesMetrics has ${rows.length} rows`, 'success');
                // CRITICAL: Reconstruct scores.moneyPages from moneyPagesMetrics if gscPageTotals28d exists
                const moneyPagesMetrics = result.data?.scores?.moneyPagesMetrics || result.data?.moneyPagesMetrics;
                if (moneyPagesMetrics && (moneyPagesMetrics.gscPageTotals28d || moneyPagesMetrics.gscRange)) {
                  if (!result.data.scores) result.data.scores = {};
                  if (!result.data.scores.moneyPages) result.data.scores.moneyPages = {};
                  if (moneyPagesMetrics.gscRange) {
                    result.data.scores.moneyPages.gscRange = moneyPagesMetrics.gscRange;
                  }
                  if (moneyPagesMetrics.gscPageTotals28d) {
                    result.data.scores.moneyPages.gscPageTotals28d = moneyPagesMetrics.gscPageTotals28d;
                    debugLog(` Reconstructed scores.moneyPages.gscPageTotals28d from moneyPagesMetrics (${moneyPagesMetrics.gscPageTotals28d.length} pages)`, 'success');
                  }
                }
              } else {
                debugLog(` Supabase data missing moneyPagesMetrics!`, 'warn');
              }
              // Debug: Check queryTotals in response
              const hasQueryTotals = !!(result.data?.searchData?.queryTotals && Array.isArray(result.data.searchData.queryTotals));
              debugLog(` Supabase queryTotals check: hasSearchData=${!!result.data?.searchData}, hasQueryTotals=${hasQueryTotals}, length=${result.data?.searchData?.queryTotals?.length || 0}`, hasQueryTotals ? 'success' : 'warn');
              if (result.data.searchData) {
                debugLog(` Supabase searchData keys: ${Object.keys(result.data.searchData).join(', ')}`, 'info');
              } else {
                debugLog(` Supabase data missing searchData!`, 'warn');
              }
              // Ensure timestamp is set from Supabase data (use timestamp if available, otherwise construct from auditDate)
              if (result.data.timestamp) {
                // Convert to ISO string if it's a number (milliseconds since epoch)
                if (typeof result.data.timestamp === 'number') {
                  result.data.timestamp = new Date(result.data.timestamp).toISOString();
                }
                // Timestamp is already set (and now in ISO string format)
              } else if (result.data.auditDate) {
                // Construct timestamp from auditDate (use noon as default time to avoid timezone issues)
                const auditDateStr = result.data.auditDate;
                result.data.timestamp = new Date(auditDateStr + 'T12:00:00').toISOString();
                debugLog(` Constructed timestamp from auditDate: ${auditDateStr}`, 'info');
              }
              // Update timestamp display immediately when Supabase data is loaded
              if (result.data.timestamp) {
                updateAuditTimestamp(result.data.timestamp);
                debugLog(` Updated audit timestamp display from Supabase data`, 'success');
              }
              return result.data;
            } else {
              debugLog(` No audit found in Supabase - result.status=${result.status}, hasData=${!!result.data}, error=${result.message || 'none'}`, 'warn');
              // Return minimal data if available, otherwise null
              if (minimalData) {
                debugLog(` Returning minimal data (timestamp + scores) as fallback`, 'info');
                return minimalData;
              }
              return null;
            }
          } else {
            const responseText = await response.text();
            try {
              const error = JSON.parse(responseText);
              debugLog(` Could not fetch latest audit from Supabase: ${error.message || 'Unknown error'}`, 'warn');
              if (error.message && error.message.includes('FUNCTION_INVOCATION_FAILED')) {
                debugLog(` Full data fetch failed due to timeout/size. Returning minimal data (timestamp + scores) as fallback.`, 'warn');
                if (minimalData) {
                  return minimalData;
                }
              }
            } catch (parseError) {
              debugLog(` Could not fetch latest audit from Supabase: ${responseText || 'Unknown error'}`, 'warn');
            }
            // Return minimal data if available, otherwise null
            if (minimalData) {
              debugLog(` Returning minimal data (timestamp + scores) as fallback after full request failure`, 'info');
              return minimalData;
            }
            return null;
          }
        } catch (error) {
          if (error.name === 'AbortError' || error.name === 'TimeoutError' || error.message.includes('timeout')) {
            debugLog(` Supabase fetch timed out. Returning minimal data (timestamp + scores) as fallback.`, 'warn');
            if (minimalData) {
              return minimalData;
            }
          } else {
            debugLog(` Supabase fetch error: ${error.message}`, 'warn');
          }
          // Return minimal data if available, otherwise null
          if (minimalData) {
            debugLog(` Returning minimal data (timestamp + scores) as fallback after error`, 'info');
            return minimalData;
          }
          return null;
        }
      } catch (outerError) {
        // Catch any errors in the outer try block (shouldn't happen, but just in case)
        debugLog(` Outer error in fetchLatestAuditFromSupabase: ${outerError.message}`, 'warn');
        if (minimalData) {
          return minimalData;
        }
        return null;
      }
    }
    
    // Update retry button visibility based on failed URLs
    function updateRetryButtonVisibility(schemaAudit) {
      const retryBtn = document.getElementById('retryFailedUrlsBtn');
      if (!retryBtn) return;
      
      if (schemaAudit && schemaAudit.data && schemaAudit.data.missingSchemaPages) {
        const failedUrls = schemaAudit.data.missingSchemaPages.filter(p => p.error);
        if (failedUrls.length > 0) {
          retryBtn.style.display = 'inline-block';
          retryBtn.textContent = ` Retry Failed URLs (${failedUrls.length})`;
        } else {
          retryBtn.style.display = 'none';
        }
      } else {
        retryBtn.style.display = 'none';
      }
    }

    // Close completion modal
    function closeCompletionModal() {
      const modal = document.getElementById('completionModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    // Close modal when clicking outside
    window.onclick = function(event) {
      const modal = document.getElementById('completionModal');
      if (event.target === modal) {
        closeCompletionModal();
      }
    }

    // Calculate RAG status from score
    function getRAGStatus(score) {
      if (score >= 70) return { status: 'green', label: 'Green' };
      if (score >= 40) return { status: 'amber', label: 'Amber' };
      return { status: 'red', label: 'Red' };
    }

    // Helper: clamp score to 0-100 and round
    function clampScore(value) {
      return Math.max(0, Math.min(100, Math.round(value)));
    }

    // Calculate pillar scores (deterministic, based on GSC data and schema audit)
    
    // Page Segment Classifier
    // NOTE: PageSegment classification is derived from the canonical site-urls CSV.
    // GSC page URLs are matched by path against this inventory and then classified by
    // classifyPageSegment(...) to keep behaviour/ranking segments aligned with the UI.
    const PageSegment = {
      EDUCATION: 'education',
      MONEY: 'money',
      SUPPORT: 'support',
      SYSTEM: 'system'
    };
    
    /**
     * Canonicalize URL - removes query params, fragments, normalizes trailing slashes
     * Returns full URL with origin and path only (no query/hash)
     * @param {string} raw - Raw URL (may contain query params, fragments)
     * @returns {string} Canonical URL
     */
    function canonicalizeUrl(raw) {
      if (!raw) return "";
      
      try {
        const u = raw.startsWith("http") ? new URL(raw) : new URL(raw, "https://www.alanranger.com");
        let path = u.pathname || "/";
        if (path.length > 1) path = path.replace(/\/+$/, "");
        return `${u.origin}${path}`;
      } catch {
        const noHash = raw.split("#")[0];
        const noQuery = noHash.split("?")[0];
        return (noQuery.replace(/\/+$/, "") || raw).trim();
      }
    }
    
    function normalisePath(rawUrlOrPath) {
      try {
        let url;
        if (rawUrlOrPath && rawUrlOrPath.startsWith('http')) {
          url = new URL(rawUrlOrPath);
        } else {
          url = new URL(rawUrlOrPath || '/', 'https://www.alanranger.com');
        }
        let p = url.pathname.toLowerCase();
        if (p.length > 1 && p.endsWith('/')) p = p.slice(0, -1);
        return p;
      } catch {
        return '/';
      }
    }
    
    function isFineArtGalleryPage(path) {
      const p = path.toLowerCase();
      // Explicit known fine-art URLs from 06-site-urls.csv
      if (
        p === '/fine-art-prints' ||
        p === '/photography-services-near-me/fine-art-photography-prints-unframed' ||
        p === '/photography-services-near-me/framed-fine-art-photography-prints' ||
        p === '/photography-services-near-me/fine-art-photography-prints-canvas'
      ) {
        return true;
      }
      // Safety net: treat any future fine-art print variants as gallery/info too
      return (
        p.includes('fine-art-prints') ||
        p.includes('fine-art-photography-prints')
      );
    }
    
    function classifyPageSegment(rawUrlOrPath, title = null, kindOverride = null) {
      const path = normalisePath(rawUrlOrPath);
      
      // Manual overrides via CSV column
      if (kindOverride) {
        const v = kindOverride.toLowerCase().trim();
        if (v === 'education' || v === 'educational') return PageSegment.EDUCATION;
        if (v === 'money' || v === 'commercial') return PageSegment.MONEY;
        if (v === 'support') return PageSegment.SUPPORT;
        if (v === 'system') return PageSegment.SYSTEM;
      }
      
      // Education  all blogs + free course + calculator + tips hub
      // EXCLUDE blog posts from money pages (check both /blog-on-photography/ and /blogs/)
      if (path.startsWith('/blog-on-photography/') || path.startsWith('/blogs/')) return PageSegment.EDUCATION;
      if (
        path === '/blog-on-photography' ||
        path === '/blogs' ||
        path === '/free-online-photography-course' ||
        path === '/outdoor-photography-exposure-calculator' ||
        path === '/free-photography-tips' ||
        path === '/photography-news-blog'
      ) {
        return PageSegment.EDUCATION;
      }
      
      // Fine-art gallery pages  portfolio/informational, NOT money pages
      // These must be checked BEFORE money classification
      if (isFineArtGalleryPage(path)) return PageSegment.SYSTEM;
      
      // Support pages (must be checked before money classification)
      const SUPPORT_EXACT = new Set([
        '/', '/about-alan-ranger', '/testimonials-customer-reviews', '/awards-and-qualifications',
        '/gallery-image-portfolios', '/help-site-map', '/help-portrait-uk-coventry',
        '/photography-equipment-recommendations', '/newsletter-signup-form',
        '/which-photography-style-is-right-for-you', '/contact-us',
      ]);
      if (SUPPORT_EXACT.has(path)) return PageSegment.SUPPORT;
      
      // Money pages = Events + Products + Landing pages (excluding blog posts)
      // Events: URLs starting with specific paths (check both with and without trailing slash)
      if (path.startsWith('/beginners-photography-lessons/') || 
          path.startsWith('/beginners-photography-lessons') ||
          path.startsWith('/photographic-workshops-near-me/') ||
          path.startsWith('/photographic-workshops-near-me')) {
        return PageSegment.MONEY;
      }
      
      // Products: URLs starting with specific paths (check both with and without trailing slash)
      if (path.startsWith('/photo-workshops-uk/') || 
          path.startsWith('/photo-workshops-uk') ||
          path.startsWith('/photography-services-near-me/') ||
          path.startsWith('/photography-services-near-me')) {
        return PageSegment.MONEY;
      }
      
      // Legacy exact matches for money pages (keep for backward compatibility)
      const MONEY_EXACT = new Set([
        '/photography-workshops', '/photography-workshops-near-me', '/photography-workshops-uk',
        '/landscape-photography-workshops', '/outdoor-photography-workshops',
        '/photographic-workshops-near-me', '/photographic-workshops-uk',
        '/photography-courses-coventry', '/course-finder-photography-classes-near-me',
        '/photography-tuition-services', '/photography-services-near-me', '/photography-shop-services',
        '/rps-courses-mentoring-distinctions', '/hire-a-professional-photographer-in-coventry',
        '/professional-commercial-photographer-coventry', '/professional-photographer-near-me',
        '/coventry-photographer', '/photographer-in-coventry', '/photography-mentoring-programme',
        '/photography-academy-membership', '/photography-academy', '/photography-session-vouchers',
        '/photography-gift-vouchers', '/photography-presents-for-photographers',
        '/batsford-arboretum-photography', '/bluebell-woods-near-me',
      ]);
      if (MONEY_EXACT.has(path)) return PageSegment.MONEY;
      
      // Landing pages: Everything else that's NOT blog posts, education, support, or system
      // Default to MONEY (landing page) if it's not a blog post and doesn't match other categories
      // This ensures all non-blog pages are treated as money pages (landing pages) by default
      // Only exclude fine-art gallery pages from being money pages
      if (!isFineArtGalleryPage(path)) {
        // If we've gotten here, it's not education, support, system, or fine-art
        // So it must be a money page (landing page)
        return PageSegment.MONEY;
      }
      
      // Everything else = system (only fine-art gallery pages should reach here)
      return PageSegment.SYSTEM;
    }
    
    /**
     * Shared classification function for Ranking & AI tab
     * Returns both segment (Brand/Education/Money/Other) and pageType (Landing/Blog/Event/Product/GBP)
     * Uses canonical classification from Money Pages logic
     * @param {string} rawUrlOrPath - URL or path to classify
     * @param {string} keyword - Optional keyword for brand detection
     * @returns {{segment: string, pageType: string}}
     */
    function classifyUrlForRankingAi(rawUrlOrPath, keyword = null) {
      // Normalize URL to lowercase for consistent matching
      const urlLower = (rawUrlOrPath || "").toLowerCase();
      const path = normalisePath(rawUrlOrPath);
      
      // Brand detection: check keyword first
      if (keyword) {
        const kw = (keyword || "").toLowerCase();
        if (kw.includes("alan ranger") || kw.includes("alanranger")) {
          return { segment: "Brand", pageType: "GBP" };
        }
      }
      
      // If URL is missing/blank, return Other
      if (!rawUrlOrPath || !path) {
        return { segment: "Other", pageType: "Other" };
      }
      
      // STEP 1: Check Event pages FIRST (before Blog/GBP/Landing)
      // Event if URL contains:
      // - alanranger.com/beginners-photography-lessons/
      // - alanranger.com/photographic-workshops-near-me
      if (urlLower.includes('/beginners-photography-lessons') ||
          urlLower.includes('/photographic-workshops-near-me')) {
        return { segment: "Money", pageType: "Event" };
      }
      
      // STEP 2: Check Product pages (before Blog/GBP/Landing)
      // Product if URL contains:
      // - alanranger.com/photo-workshops-uk/
      // - alanranger.com/photography-services-near-me/
      if (urlLower.includes('/photo-workshops-uk') ||
          urlLower.includes('/photography-services-near-me')) {
        return { segment: "Money", pageType: "Product" };
      }
      
      // STEP 3: Check for Blog pages (Education segment)
      if (path.startsWith('/blog-on-photography/') || path.startsWith('/blogs/')) {
        return { segment: "Education", pageType: "Blog" };
      }
      
      // STEP 4: Check for GBP/Home/About pages (Brand segment)
      if (path === '/' ||
          path === '/about-alan-ranger' ||
          path.includes('/contact') ||
          path.includes('/reviews')) {
        return { segment: "Brand", pageType: "GBP" };
      }
      
      // STEP 5: Use canonical page classification for remaining pages
      // Try window.classifyMoneyPage first (if available), then fallback to local scope
      let isMoney = false;
      let segmentType = null;
      
      const classifyMoneyPageFn = (typeof window !== 'undefined' && window.classifyMoneyPage)
        ? window.classifyMoneyPage
        : (typeof classifyMoneyPage !== 'undefined' ? classifyMoneyPage : null);
      
      if (classifyMoneyPageFn) {
        try {
          const result = classifyMoneyPageFn(rawUrlOrPath);
          isMoney = result.isMoney;
          segmentType = result.segmentType;
        } catch (e) {
          const segment = classifyPageSegment(rawUrlOrPath);
          isMoney = segment === PageSegment.MONEY;
          segmentType = isMoney ? 'landing' : null;
        }
      } else {
        const segment = classifyPageSegment(rawUrlOrPath);
        isMoney = segment === PageSegment.MONEY;
        segmentType = isMoney ? 'landing' : null;
        if (window.DEBUG_MODE) {
          debugLog(' classifyMoneyPage not available, using fallback classification', 'warn');
        }
      }
      
      // Determine pageType from canonical segmentType (for remaining pages)
      let pageType = "Landing"; // Default
      if (segmentType === "event") {
        pageType = "Event";
      } else if (segmentType === "product") {
        pageType = "Product";
      } else if (segmentType === "landing" || segmentType === "all") {
        pageType = "Landing";
      } else if (isMoney) {
        pageType = "Landing";
      } else {
        pageType = "Other";
      }
      
      // Determine segment from pageType and canonical classification
      let segment = "Other"; // Default
      
      // Brand: home page, about, contact, reviews, or brand keywords
      if (pageType === "GBP" || path === '/' || path === '/about-alan-ranger') {
        segment = "Brand";
      }
      // Money: Landing, Event, or Product page types
      else if (pageType === "Landing" || pageType === "Event" || pageType === "Product") {
        segment = "Money";
      }
      // Education: Blog pages or free course/educational content
      else if (pageType === "Blog" || 
               path === '/free-online-photography-course' ||
               path === '/outdoor-photography-exposure-calculator' ||
               path === '/free-photography-tips') {
        segment = "Education";
      }
      // Everything else is Other
      
      return { segment, pageType };
    }
    
    // Make available globally for RankingAiModule
    if (typeof window !== 'undefined') {
      window.classifyUrlForRankingAi = classifyUrlForRankingAi;
    }
    
    // Helper functions for Authority score calculation
    function normalisePct(value, max) {
      // value in 0-1 range; scale to 0-100 and cap
      const pct = Math.max(0, Math.min(1, value / max));
      return pct * 100;
    }

    function normalisePosition(pos, minPos, maxPos) {
      // map [minPos..maxPos] -> [100..10], clamp outside range
      const clamped = Math.max(minPos, Math.min(maxPos, pos));
      const t = (clamped - minPos) / (maxPos - minPos); // 0..1
      return 100 - t * 90; // 100 at best, 10 at worst
    }

    // Raw Behaviour score calculation (internal, used by segmented version)
    // ============================================================================
    // PHASE 1: Brand Overlay Metrics
    // ============================================================================
    
    /**
     * @typedef {Object} BrandOverlay
     * @property {number} score - 0-100
     * @property {'Weak'|'Developing'|'Strong'} label
     * @property {number} brandQueryShare - 0-1, impressions share
     * @property {number} brandCtr - 0-1
     * @property {number} brandAvgPosition - numeric position
     * @property {number} reviewScore - 0-100, from existing review metrics
     * @property {number} entityScore - 0-100, based on knowledge panel / GBP presence
     * @property {string[]} notes - short machine-generated reasons for the label
     */
    
    /**
     * @typedef {Object} AiSummaryLikelihood
     * @property {number} score - 0-100 composite
     * @property {'Low'|'Medium'|'High'} label
     * @property {string[]} reasons - short bullets used in UI tooltip / priorities
     */
    
    /**
     * @typedef {"LOW" | "MEDIUM" | "HIGH"} PriorityLevel
     */
    
    /**
     * @typedef {"LOW" | "MEDIUM" | "HIGH"} ImpactLevel
     */
    
    /**
     * @typedef {"LOW" | "MEDIUM" | "HIGH"} DifficultyLevel
     */
    
    /**
     * @typedef {"all" | "landing" | "event" | "product"} MoneySegmentKey
     */
    
    /**
     * @typedef {Object} MoneyPageMetrics
     * @property {string} url
     * @property {string} title
     * @property {MoneySegmentKey} segmentType       // landing / event / product / (fallback "all")
     * @property {number} clicks
     * @property {number} impressions
     * @property {number} ctr                        // 01 decimal
     * @property {number} avgPosition
     * @property {ImpactLevel} impactLevel
     * @property {DifficultyLevel} difficultyLevel
     * @property {PriorityLevel} priorityLevel
     * @property {number} [_lostClicks]              // Internal: calculated lost clicks
     */
    
    /**
     * Per audit, stored for history in Supabase.
     *
     * @typedef {Object} MoneySegmentSummary
     * @property {number} clicks
     * @property {number} impressions
     * @property {number} ctr           // 01 decimal
     * @property {number} avgPosition
     * @property {number} behaviourScore
     */
    
    /**
     * @typedef {Object} MoneySegmentMetricsByAudit
     * @property {MoneySegmentSummary} allMoney
     * @property {MoneySegmentSummary} landingPages
     * @property {MoneySegmentSummary} eventPages
     * @property {MoneySegmentSummary} productPages
     */
    
    // Brand query classification
    const BRAND_TERMS = ['alan ranger', 'alanranger', 'alan ranger photography'];
    
    /**
     * Check if a query is a brand query
     * @param {string} query - Search query text
     * @returns {boolean}
     */
    function isBrandQuery(query) {
      if (!query || typeof query !== 'string') return false;
      const q = query.toLowerCase();
      return BRAND_TERMS.some(term => q.includes(term));
    }
    
    /**
     * Calculate brand metrics from GSC query data
     * @param {Array} queries - Array of query objects with {query, clicks, impressions, position}
     * @returns {Object} Brand metrics {brandQueryShare, brandCtr, brandAvgPosition}
     */
    function calculateBrandMetrics(queries) {
      if (!queries || !Array.isArray(queries) || queries.length === 0) {
        return {
          brandQueryShare: 0,
          brandCtr: 0,
          brandAvgPosition: null
        };
      }
      
      // Filter to ranking queries (position 1-20, with impressions)
      const ranking = queries.filter(q => {
        const pos = q.position || 0;
        const impr = q.impressions || 0;
        return pos > 0 && pos <= 20 && impr > 0;
      });
      
      if (ranking.length === 0) {
        return {
          brandQueryShare: 0,
          brandCtr: 0,
          brandAvgPosition: null
        };
      }
      
      // Split into brand vs non-brand
      const brandQueries = ranking.filter(q => isBrandQuery(q.query || ''));
      const nonBrandQueries = ranking.filter(q => !isBrandQuery(q.query || ''));
      
      // Calculate totals
      const totalImpressions = ranking.reduce((s, q) => s + (q.impressions || 0), 0);
      const brandImpressions = brandQueries.reduce((s, q) => s + (q.impressions || 0), 0);
      const brandClicks = brandQueries.reduce((s, q) => s + (q.clicks || 0), 0);
      
      // Brand query share (0-1)
      const brandQueryShare = totalImpressions > 0 ? brandImpressions / totalImpressions : 0;
      
      // Brand CTR (0-1)
      const brandCtr = brandImpressions > 0 ? brandClicks / brandImpressions : 0;
      
      // Brand average position (weighted by impressions)
      const brandAvgPosition = brandImpressions > 0
        ? brandQueries.reduce((s, q) => s + (q.position || 0) * (q.impressions || 0), 0) / brandImpressions
        : null;
      
      return {
        brandQueryShare,
        brandCtr,
        brandAvgPosition
      };
    }
    
    /**
     * Normalize position to 0-100 score (for brand overlay)
     * @param {number|null} pos - Position value
     * @param {number} minPos - Minimum position (default 1)
     * @param {number} maxPos - Maximum position (default 10)
     * @returns {number} Score 0-100
     */
    function normalisePositionForBrand(pos, minPos = 1, maxPos = 10) {
      if (pos == null) return 0;
      const clamped = Math.max(minPos, Math.min(maxPos, pos));
      const t = (clamped - minPos) / (maxPos - minPos); // 0..1
      return 100 - t * 100;
    }
    
    /**
     * Compute Brand Overlay score
     * @param {Object} args - Brand overlay parameters
     * @param {number} args.brandQueryShare - 0-1, impressions share
     * @param {number} args.brandCtr - 0-1
     * @param {number|null} args.brandAvgPosition - numeric position
     * @param {number} args.reviewScore - 0-100, from existing Authority review score
     * @param {number} args.entityScore - 0-100, from Local Entity pillar
     * @returns {BrandOverlay}
     */
    function computeBrandOverlay(args) {
      const {
        brandQueryShare = 0,
        brandCtr = 0,
        brandAvgPosition = null,
        reviewScore = 0,
        entityScore = 0
      } = args;
      
      // Brand search component
      const shareScore = Math.min(brandQueryShare / 0.30, 1) * 100; // 30%+ share = 100
      const ctrScore = Math.min(brandCtr / 0.40, 1) * 100; // 40%+ CTR = 100
      const posScore = normalisePositionForBrand(brandAvgPosition, 1, 10);
      
      const brandSearchScore =
        0.4 * shareScore +
        0.3 * ctrScore +
        0.3 * posScore;
      
      // Combine with review + entity strength
      const combined =
        0.4 * brandSearchScore +
        0.3 * reviewScore +
        0.3 * entityScore;
      
      let label;
      if (combined < 40) label = 'Weak';
      else if (combined < 70) label = 'Developing';
      else label = 'Strong';
      
      const notes = [];
      if (brandQueryShare < 0.1) notes.push('Low share of branded searches in GSC.');
      if (brandCtr < 0.25) notes.push('Branded CTR is below 25%.');
      if (brandAvgPosition == null || brandAvgPosition > 5)
        notes.push('Branded queries do not consistently rank in top-5.');
      if (reviewScore < 70) notes.push('Review rating / volume is still maturing.');
      if (entityScore < 70) notes.push('Knowledge-panel / entity coverage could be stronger.');
      
      return {
        score: Math.round(combined),
        label,
        brandQueryShare,
        brandCtr,
        brandAvgPosition: brandAvgPosition ?? 0,
        reviewScore,
        entityScore,
        notes
      };
    }
    
    /**
     * Compute AI Summary Likelihood
     * @param {number} snippetReadinessScore - Existing donut score
     * @param {number} visibilityScore - Current Visibility pillar score
     * @param {number} brandScore - Brand overlay score
     * @returns {AiSummaryLikelihood}
     */
    function computeAiSummaryLikelihood(snippetReadinessScore, visibilityScore, brandScore) {
      const composite =
        0.5 * snippetReadinessScore +
        0.3 * visibilityScore +
        0.2 * brandScore;
      
      // Use same RAG bands as GAIO Score: 70 High (green), 50 Medium (amber), <50 Low (red)
      let label;
      if (composite < 50) label = 'Low';
      else if (composite < 70) label = 'Medium';
      else label = 'High';
      
      const reasons = [];
      
      if (snippetReadinessScore < 70)
        reasons.push('Improve FAQ/HowTo/Article blocks and schema to raise snippet readiness.');
      if (visibilityScore < 70)
        reasons.push('Improve average position and top-10 impression share.');
      if (brandScore < 70)
        reasons.push('Strengthen branded search and entity signals.');
      
      return {
        score: Math.round(composite),
        label,
        reasons
      };
    }
    
    // ============================================================================
    // End Phase 1: Brand Overlay Metrics
    // ============================================================================

    function computeBehaviourScoreRaw(queries) {
      if (!queries || !Array.isArray(queries) || queries.length === 0) {
        return 50; // neutral fallback
      }

      // Filter to ranking queries (position > 0, <= 20, with impressions)
      const ranking = queries.filter(q => q.position > 0 && q.position <= 20 && q.impressions > 0);

      if (ranking.length === 0) {
        return 50; // neutral fallback
      }

      // Calculate CTR for all ranking queries
      const totalClicks = ranking.reduce((s, q) => s + q.clicks, 0);
      const totalImpr = ranking.reduce((s, q) => s + q.impressions, 0);
      const ctrAll = totalImpr > 0 ? totalClicks / totalImpr : 0; // 0-1

      // Calculate CTR for top-10 queries
      const top10 = ranking.filter(q => q.position <= 10);
      const top10Clicks = top10.reduce((s, q) => s + q.clicks, 0);
      const top10Impr = top10.reduce((s, q) => s + q.impressions, 0);
      const ctrTop10 = top10Impr > 0 ? top10Clicks / top10Impr : ctrAll;

      // Normalize CTR scores: 5% CTR = 100 for all ranking, 10% CTR = 100 for top-10
      // ctrAll 0-5%  0-100 (values >5% capped at 100)
      // ctrTop10 0-10%  0-100 (values >10% capped at 100)
      const ctrScoreAll = normalisePct(ctrAll, 0.05); // 5% overall CTR -> 100
      const ctrScoreTop10 = normalisePct(ctrTop10, 0.10); // 10% top-10 CTR -> 100

      // Combine: 50% ctrAll + 50% ctrTop10
      return 0.5 * ctrScoreAll + 0.5 * ctrScoreTop10; // 0-100
    }
    
    // Public Behaviour score (backward compatible, uses all queries)
    function computeBehaviourScore(queries) {
      return computeBehaviourScoreRaw(queries);
    }
    
    // Segmented Behaviour score calculation
    // queryPages: Array of {query, page, clicks, impressions, ctr, position}
    // Returns: {all, nonBlog, money}
    function computeBehaviourScoreWithSegment(queryPages) {
      if (!queryPages || !Array.isArray(queryPages) || queryPages.length === 0) {
        return { all: 50, nonBlog: 50, money: 50 };
      }
      
      // Classify each query+page row by page segment
      const withSegment = queryPages.map(row => {
        const segment = classifyPageSegment(row.page || row.url || '/');
        return { ...row, __segment: segment };
      });
      
      // Convert to format expected by computeBehaviourScoreRaw
      const toQueryFormat = (rows) => rows.map(r => ({
        clicks: r.clicks || 0,
        impressions: r.impressions || 0,
        ctr: (r.ctr || 0) / 100, // Convert percentage to decimal
        position: r.position || 0
      }));
      
      // All queries
      const all = computeBehaviourScoreRaw(toQueryFormat(withSegment));
      
      // Non-blog (exclude education)
      const nonBlog = computeBehaviourScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment !== PageSegment.EDUCATION))
      );
      
      // Money pages only
      const money = computeBehaviourScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment === PageSegment.MONEY))
      );
      
      return { all, nonBlog, money };
    }

    // Raw Ranking score calculation (internal, used by segmented version)
    function computeRankingScoreRaw(queries) {
      if (!queries || !Array.isArray(queries) || queries.length === 0) {
        return 50; // neutral fallback
      }

      // Filter to ranking queries (position > 0, <= 20, with impressions)
      const ranking = queries.filter(q => q.position > 0 && q.position <= 20 && q.impressions > 0);

      if (ranking.length === 0) {
        return 50; // neutral fallback
      }

      // Calculate impression-weighted average position
      const totalImpr = ranking.reduce((s, q) => s + q.impressions, 0);
      const avgPos = totalImpr > 0
        ? ranking.reduce((s, q) => s + q.position * q.impressions, 0) / totalImpr
        : 0;

      // Map position: 1  100, 20  0 (clamped)
      const clampedPos = Math.max(1, Math.min(20, avgPos));
      const posScore = normalisePosition(clampedPos, 1, 20); // 0-100

      // Calculate top-10 impression share (% of impressions where position  10)
      const top10Impr = ranking
        .filter(q => q.position <= 10)
        .reduce((s, q) => s + q.impressions, 0);
      const top10Share = totalImpr > 0 ? top10Impr / totalImpr : 0; // 0-1
      const top10Score = top10Share * 100; // 0-100 (as a percentage)

      // Combine: 50% posScore + 50% top10Score
      return 0.5 * posScore + 0.5 * top10Score; // 0-100
    }
    
    // Public Ranking score (backward compatible, uses all queries)
    function computeRankingScore(queries) {
      return computeRankingScoreRaw(queries);
    }
    
    // Segmented Ranking score calculation
    // queryPages: Array of {query, page, clicks, impressions, ctr, position}
    // Returns: {all, nonBlog, money}
    function computeRankingScoreWithSegment(queryPages) {
      if (!queryPages || !Array.isArray(queryPages) || queryPages.length === 0) {
        return { all: 50, nonBlog: 50, money: 50 };
      }
      
      // Classify each query+page row by page segment
      const withSegment = queryPages.map(row => {
        const segment = classifyPageSegment(row.page || row.url || '/');
        return { ...row, __segment: segment };
      });
      
      // Convert to format expected by computeRankingScoreRaw
      const toQueryFormat = (rows) => rows.map(r => ({
        clicks: r.clicks || 0,
        impressions: r.impressions || 0,
        ctr: (r.ctr || 0) / 100, // Convert percentage to decimal
        position: r.position || 0
      }));
      
      // All queries
      const all = computeRankingScoreRaw(toQueryFormat(withSegment));
      
      // Non-blog (exclude education)
      const nonBlog = computeRankingScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment !== PageSegment.EDUCATION))
      );
      
      // Money pages only
      const money = computeRankingScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment === PageSegment.MONEY))
      );
      
      return { all, nonBlog, money };
    }

    function computeReviewScore(opts) {
      const {
        gbpRating = null,
        gbpCount = null,
        siteRating = null,
        siteCount = null
      } = opts || {};

      // Check if sources have valid data (not null, not 0, not undefined)
      const hasGBP = (gbpRating !== null && gbpRating !== undefined && gbpRating > 0) || 
                     (gbpCount !== null && gbpCount !== undefined && gbpCount > 0);
      const hasSite = (siteRating !== null && siteRating !== undefined && siteRating > 0) || 
                      (siteCount !== null && siteCount !== undefined && siteCount > 0);

      // If neither source exists, return neutral default
      if (!hasGBP && !hasSite) {
        debugLog('Review Score: No review data available (GBP or site), using neutral default (50)', 'warn');
        return 50;
      }

      const maxCount = 500; // cap so a few extra reviews don't blow up score

      let reviewScore;

      if (hasGBP && hasSite) {
        // Both sources exist: 60% GBP + 40% site
        const gbpRatingScore = ((gbpRating || 0) / 5) * 100;
        const gbpCountScore = Math.min((gbpCount || 0) / maxCount, 1) * 100;
        const gbpScore = 0.6 * gbpRatingScore + 0.4 * gbpCountScore;

        const siteRatingScore = ((siteRating || 0) / 5) * 100;
        const siteCountScore = Math.min((siteCount || 0) / maxCount, 1) * 100;
        const siteScore = 0.6 * siteRatingScore + 0.4 * siteCountScore;

        reviewScore = 0.6 * gbpScore + 0.4 * siteScore;
      } else if (hasGBP) {
        // Only GBP exists: 100% GBP
        const gbpRatingScore = ((gbpRating || 0) / 5) * 100;
        const gbpCountScore = Math.min((gbpCount || 0) / maxCount, 1) * 100;
        reviewScore = 0.6 * gbpRatingScore + 0.4 * gbpCountScore;
      } else {
        // Only site reviews exist: 100% site
        const siteRatingScore = ((siteRating || 0) / 5) * 100;
        const siteCountScore = Math.min((siteCount || 0) / maxCount, 1) * 100;
        reviewScore = 0.6 * siteRatingScore + 0.4 * siteCountScore;
      }

      return clampScore(reviewScore);
    }

    /**
     * Compute Backlink Score from backlink metrics
     * @param {Object|undefined} m - Backlink metrics object with referringDomains, totalBacklinks, followRatio
     * @returns {number} Score 0-100
     */
    function computeBacklinkScore(m) {
      if (!m) {
        // If metrics not present at all, return 0 (no backlink data)
        return 0;
      }

      const rd = m.referringDomains ?? 0;
      // If followRatio is missing, it means data integrity issue - log warning and use 0
      const fb = m.followRatio ?? (() => {
        debugLog(' Backlink metrics missing followRatio - data integrity issue', 'warn');
        return 0;
      })();

      // If no backlinks at all, score is 0
      if (rd === 0 && (m.totalBacklinks ?? 0) === 0) {
        return 0;
      }

      // Referring domains score: 100+ domains = max score (100)
      const rdScore = Math.min(rd / 100, 1) * 100;
      
      // Follow ratio score: clamp 0-1  0-100
      const followScore = Math.max(0, Math.min(fb, 1)) * 100;

      // Combined: 70% referring domains, 30% follow ratio
      const score = 0.7 * rdScore + 0.3 * followScore;
      
      return Math.round(clampScore(score));
    }

    // Helper function to always return correct Trustpilot snapshot values
    // This ensures we never use old cached values (4.80, 127) - always use (4.6, 610)
    function getTrustpilotSnapshot(siteReviews = null) {
      const TRUSTPILOT_SNAPSHOT = {
        siteRating: 4.6,
        siteReviewCount: 610,
        lastUpdated: '2025-12-07',
        notes: 'Fixed Trustpilot snapshot for Authority score calculation. Update manually when Trustpilot metrics change significantly.'
      };
      
      // Always return the correct snapshot, regardless of input
      if (!siteReviews || siteReviews.siteRating !== 4.6 || siteReviews.siteReviewCount !== 610) {
        return TRUSTPILOT_SNAPSHOT;
      }
      return siteReviews;
    }

    // Helper function to get color for score (same thresholds as main pillars)
    function getScoreColor(score) {
      if (score >= 70) return { color: '#10b981', label: 'Green', bg: '#d1fae5' }; // Green
      if (score >= 40) return { color: '#f59e0b', label: 'Amber', bg: '#fef3c7' }; // Amber
      return { color: '#ef4444', label: 'Red', bg: '#fee2e2' }; // Red
    }

    // Helper function to get tooltip text for each component
    function getComponentTooltip(label) {
      const tooltips = {
        // Authority components
        'Behaviour': 'Overall CTR Score (50% weight) + Top-10 Ranked Search Terms CTR Score (50% weight). Measures CTR for all ranking search terms vs. search terms ranking in positions 1-10. Indicates how well your titles/descriptions convert impressions to clicks.',
        'Ranking': 'Average Position Score (50% weight) + Top-10 Impression Share (50% weight). Measures how high you rank on average and what percentage of impressions appear in positions 1-10.',
        'Backlinks': 'Referring Domains Score (70% weight) + Follow Ratio Score (30% weight). Measures domain authority from external links.',
        'Reviews': 'Google Business Profile Reviews (60% weight if both exist) + Trustpilot Reviews (40% weight if both exist). Each source combines rating (60%) and count (40%). Measures trust signals from customer reviews.',
        // Content/Schema components
        'Foundation': 'Foundation Schemas (30% weight): Presence of Organization, Person, WebSite, and BreadcrumbList schemas. These core schemas establish your entity identity and site structure for AI systems.',
        'Rich Results': 'Rich Result Eligibility (35% weight): Count of eligible rich result types (Article, Event, FAQPage, Product, LocalBusiness, Course, Review, HowTo, VideoObject, ImageObject, ItemList). More types = better AI understanding.',
        'Coverage': 'Schema Coverage (20% weight): Percentage of pages with structured data markup. Higher coverage means more pages are machine-readable.',
        'Diversity': 'Type Diversity (15% weight): Number of unique schema types detected across your domain. More diverse types indicate richer structured data.',
        // Visibility components
        'Position': 'Average Position Score: Derived from Google Search Console average position (1-40 scale). Better positions (lower numbers) = higher score. Measures how prominently your content appears in search results.',
        'CTR': 'Click-Through Rate Score: Derived from Google Search Console CTR percentage. Higher CTR indicates better title/description effectiveness and user engagement.',
        // Local Entity components
        'NAP Consistency': 'Name, Address, Phone consistency score (0-100%). Measures how consistently your business information appears across Google Business Profile. Higher consistency improves entity recognition.',
        'Knowledge Panel': 'Knowledge Panel Detection: Whether Google has detected and displays a knowledge panel for your entity. Indicates strong entity recognition by AI systems.',
        'Locations': 'Location Count: Number of physical locations listed in Google Business Profile. Having at least one location improves local entity recognition.',
        // Service Area components
        'Service Areas': 'Service Area Count: Number of service areas defined in Google Business Profile. More service areas (8+) indicate broader geographic coverage and better AI understanding of your operational regions.',
        'NAP Consistency': 'Name, Address, Phone consistency score (0-100%). Measures how consistently your business information appears across Google Business Profile. Higher consistency improves service area recognition.'
      };
      return tooltips[label] || '';
    }

    // Helper function to format component score with color, scale indicator, and tooltip
    function formatComponentScore(label, score) {
      const rounded = Math.round(score);
      const colorInfo = getScoreColor(rounded);
      const tooltip = getComponentTooltip(label);
      return `
        <div style="display: flex; align-items: center; gap: 0.5rem;">
          <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background-color: ${colorInfo.color};"></span>
          <span style="color: #666; position: relative; cursor: help; border-bottom: 1px dotted #999;" title="${tooltip}">${label}:</span>
          <strong style="color: ${colorInfo.color};">${rounded}</strong>
          <span style="color: #999; font-size: 0.75em;">/100</span>
        </div>
      `;
    }

    async function calculatePillarScores(data, schemaAudit = null, localSignals = null, siteReviews = null, backlinkMetrics = null) {
      // Use new API response format - get values from GSC overview
      const position = data.averagePosition || 40; // 1 (best) - 100 (worst)
      const ctr = data.ctr || 0; // 0-100 percentage from API (e.g., 10 = 10%)
      const topQueries = data.topQueries || []; // Array of query objects with clicks, impressions, ctr, position
      const queryPages = data.queryPages || []; // Array of query+page objects for segmentation

      // Map average position (1-40) -> 100-10 (better position => higher score)
      const posScore = (() => {
        const clampedPos = Math.max(1, Math.min(40, position));
        const scale = (clampedPos - 1) / 39; // 0 to 1
        return 100 - scale * 90; // 100 to 10
      })();

      // Visibility is primarily driven by position
      const visibility = clampScore(posScore);

      // Authority: New 4-component model with segmentation support
      let behaviourScore, rankingScore;
      let behaviourScoresSegmented = null;
      let rankingScoresSegmented = null;
      
      // If we have queryPages data, use segmented calculation
      if (queryPages && queryPages.length > 0) {
        debugLog(` Segmentation: Received ${queryPages.length} query+page combinations from GSC API`, 'info');
        
        // Classify all pages and show distribution
        const segmentCounts = {};
        queryPages.forEach(row => {
          const segment = classifyPageSegment(row.page || row.url || '/');
          segmentCounts[segment] = (segmentCounts[segment] || 0) + 1;
        });
        
        debugLog(` Segmentation: Page distribution - Education: ${segmentCounts[PageSegment.EDUCATION] || 0}, Money: ${segmentCounts[PageSegment.MONEY] || 0}, Support: ${segmentCounts[PageSegment.SUPPORT] || 0}, System: ${segmentCounts[PageSegment.SYSTEM] || 0}`, 'info');
        
        // Use segmented calculation
        debugLog(' Segmentation: Calculating Behaviour scores for all segments...', 'info');
        behaviourScoresSegmented = computeBehaviourScoreWithSegment(queryPages);
        debugLog(` Segmentation: Behaviour scores - All: ${behaviourScoresSegmented.all.toFixed(1)}, Non-blog: ${behaviourScoresSegmented.nonBlog.toFixed(1)}, Money: ${behaviourScoresSegmented.money.toFixed(1)}`, 'success');
        
        debugLog(' Segmentation: Calculating Ranking scores for all segments...', 'info');
        rankingScoresSegmented = computeRankingScoreWithSegment(queryPages);
        debugLog(` Segmentation: Ranking scores - All: ${rankingScoresSegmented.all.toFixed(1)}, Non-blog: ${rankingScoresSegmented.nonBlog.toFixed(1)}, Money: ${rankingScoresSegmented.money.toFixed(1)}`, 'success');
        
        // Use 'all' segment for main Authority score (backward compatible)
        behaviourScore = behaviourScoresSegmented.all;
        rankingScore = rankingScoresSegmented.all;
        
        debugLog(` Using segmented calculation (queryPages available). Main scores use 'all' segment.`, 'success');
      } else {
        // Fallback to non-segmented calculation (backward compatible)
        debugLog(' Segmentation: queryPages not available, using non-segmented calculation (backward compatible)', 'warn');
        const queriesForCalculation = topQueries.map(q => ({
          clicks: q.clicks || 0,
          impressions: q.impressions || 0,
          ctr: (q.ctr || 0) / 100, // Convert percentage to decimal
          position: q.position || 0
        }));
        behaviourScore = computeBehaviourScore(queriesForCalculation);
        rankingScore = computeRankingScore(queriesForCalculation);
        debugLog(` Non-segmented scores: Behaviour=${behaviourScore.toFixed(1)}, Ranking=${rankingScore.toFixed(1)}`, 'warn');
      }

      // Review Score: Phase 2 - Use real review data if available
      // Get GBP data (may be null if not available, don't default to 0)
      const gbpRating = (localSignals && localSignals.status === 'ok' && localSignals.data) 
        ? (localSignals.data.gbpRating !== null && localSignals.data.gbpRating !== undefined ? localSignals.data.gbpRating : null)
        : null;
      const gbpCount = (localSignals && localSignals.status === 'ok' && localSignals.data) 
        ? (localSignals.data.gbpReviewCount !== null && localSignals.data.gbpReviewCount !== undefined ? localSignals.data.gbpReviewCount : null)
        : null;
      
      // Get site review data - ALWAYS use correct Trustpilot snapshot (4.6, 610)
      const normalizedSiteReviews = getTrustpilotSnapshot(siteReviews);
      const siteRating = normalizedSiteReviews?.siteRating !== null && normalizedSiteReviews?.siteRating !== undefined ? normalizedSiteReviews.siteRating : null;
      const siteCount = normalizedSiteReviews?.siteReviewCount !== null && normalizedSiteReviews?.siteReviewCount !== undefined ? normalizedSiteReviews.siteReviewCount : null;
      
      // Calculate review score (handles optional sources internally)
      const reviewScore = computeReviewScore({
        gbpRating,
        gbpCount,
        siteRating,
        siteCount
      });
      
      // Log the calculation details
      const gbpInfo = gbpRating !== null || gbpCount !== null 
        ? `GBP (rating=${gbpRating !== null ? gbpRating : 'N/A'}, count=${gbpCount !== null ? gbpCount : 'N/A'})`
        : 'GBP (no data)';
      const siteInfo = siteRating !== null || siteCount !== null
        ? `Trustpilot snapshot (rating=${siteRating !== null ? siteRating : 'N/A'}, count=${siteCount !== null ? siteCount : 'N/A'})`
        : 'Trustpilot snapshot (no data)';
      debugLog(`Review Score: ${gbpInfo}, ${siteInfo}, Final=${reviewScore.toFixed(1)}`, 'info');

      // Backlink Score: Phase 3 - Use real backlink metrics if available
      // backlinkMetrics is passed as a parameter (fetched from API)
      const backlinkScore = computeBacklinkScore(backlinkMetrics);

      // Authority weights (constant across all segments)
      const AUTHORITY_WEIGHTS = {
        behaviour: 0.4,
        ranking: 0.2,
        backlinks: 0.2,
        reviews: 0.2
      };
      
      // Helper to compute Authority from component scores
      function computeAuthorityFromComponents(components) {
        const total = clampScore(
          AUTHORITY_WEIGHTS.behaviour * components.behaviour +
          AUTHORITY_WEIGHTS.ranking * components.ranking +
          AUTHORITY_WEIGHTS.backlinks * components.backlinks +
          AUTHORITY_WEIGHTS.reviews * components.reviews
        );
        return {
          behaviour: clampScore(components.behaviour),
          ranking: clampScore(components.ranking),
          backlinks: clampScore(components.backlinks),
          reviews: clampScore(components.reviews),
          total: total
        };
      }
      
      // Base Authority (all pages) - current behaviour
      const authorityAll = computeAuthorityFromComponents({
        behaviour: behaviourScore,
        ranking: rankingScore,
        backlinks: backlinkScore,
        reviews: reviewScore
      });
      
      // Per-segment Authority scores (if segmentation available)
      // Helper function to compute top pages for a segment
      function computeTopPagesForSegment(pageRows, max = 10) {
        if (!pageRows || !Array.isArray(pageRows) || pageRows.length === 0) {
          return [];
        }
        
        // Aggregate by page URL (sum clicks, impressions, weighted position)
        const pageMap = new Map();
        
        pageRows.forEach(row => {
          const url = row.page || row.url || '';
          if (!url) return;
          
          if (!pageMap.has(url)) {
            pageMap.set(url, {
              url: url,
              clicks: 0,
              impressions: 0,
              totalPositionWeight: 0,
              count: 0
            });
          }
          
          const page = pageMap.get(url);
          page.clicks += row.clicks || 0;
          page.impressions += row.impressions || 0;
          page.totalPositionWeight += (row.position || 0) * (row.impressions || 0);
          page.count += 1;
        });
        
        // Convert to top pages format
        const topPages = Array.from(pageMap.values())
          .map(page => ({
            url: page.url,
            clicks: page.clicks,
            impressions: page.impressions,
            ctr: page.impressions > 0 ? (page.clicks / page.impressions) * 100 : 0,
            avgPosition: page.impressions > 0 ? page.totalPositionWeight / page.impressions : 0
          }))
          .filter(page => page.impressions > 0) // Only pages with impressions
          .sort((a, b) => b.impressions - a.impressions) // Sort by impressions descending
          .slice(0, max);
        
        return topPages;
      }
      
      // Compute all pages including zero impressions (for money pages segmentation validation)
      function computeAllPagesForSegment(pageRows) {
        if (!pageRows || !Array.isArray(pageRows) || pageRows.length === 0) {
          return [];
        }
        
        // Aggregate by page URL (sum clicks, impressions, weighted position)
        const pageMap = new Map();
        
        pageRows.forEach(row => {
          const url = row.page || row.url || '';
          if (!url) return;
          
          if (!pageMap.has(url)) {
            pageMap.set(url, {
              url: url,
              clicks: 0,
              impressions: 0,
              totalPositionWeight: 0,
              count: 0
            });
          }
          
          const page = pageMap.get(url);
          page.clicks += row.clicks || 0;
          page.impressions += row.impressions || 0;
          page.totalPositionWeight += (row.position || 0) * (row.impressions || 0);
          page.count += 1;
        });
        
        // Convert to pages format (include zero impressions)
        const allPages = Array.from(pageMap.values())
          .map(page => ({
            url: page.url,
            clicks: page.clicks,
            impressions: page.impressions,
            ctr: page.impressions > 0 ? (page.clicks / page.impressions) * 100 : 0,
            avgPosition: page.impressions > 0 ? page.totalPositionWeight / page.impressions : null,
            position: page.impressions > 0 ? page.totalPositionWeight / page.impressions : null
          }))
          .sort((a, b) => {
            // Sort by impressions descending, but put zero impressions at the end
            if (a.impressions === 0 && b.impressions > 0) return 1;
            if (b.impressions === 0 && a.impressions > 0) return -1;
            return b.impressions - a.impressions;
          });
        
        return allPages;
      }
      
      let authorityBySegment = null;
      if (behaviourScoresSegmented && rankingScoresSegmented) {
        // Get page-level data for top pages computation
        const queryPagesData = data.queryPages || [];
        
        // Filter to ranking pages (position 1-20, with impressions)
        const rankingPages = queryPagesData.filter(row => {
          const pos = row.position || 0;
          const impr = row.impressions || 0;
          return pos > 0 && pos <= 20 && impr > 0;
        });
        
        // Classify pages by segment
        const allPages = rankingPages;
        const excludeEduPages = rankingPages.filter(row => {
          const segment = classifyPageSegment(row.page || row.url || '/');
          return segment !== PageSegment.EDUCATION;
        });
        const moneyPages = rankingPages.filter(row => {
          const segment = classifyPageSegment(row.page || row.url || '/');
          return segment === PageSegment.MONEY;
        });
        
        // Compute top pages for each segment
        const allTopPages = computeTopPagesForSegment(allPages, 10);
        const excludeEduTopPages = computeTopPagesForSegment(excludeEduPages, 10);
        const moneyTopPages = computeTopPagesForSegment(moneyPages, 10);
        
        // Non-education (exclude education pages)
        const authorityNonEducation = computeAuthorityFromComponents({
          behaviour: behaviourScoresSegmented.nonBlog,
          ranking: rankingScoresSegmented.nonBlog,
          backlinks: backlinkScore, // Same across all segments
          reviews: reviewScore      // Same across all segments
        });
        
        // Money pages only
        const authorityMoney = computeAuthorityFromComponents({
          behaviour: behaviourScoresSegmented.money,
          ranking: rankingScoresSegmented.money,
          backlinks: backlinkScore, // Same across all segments
          reviews: reviewScore      // Same across all segments
        });
        
        // Helper to compute GSC metrics for a segment from queryPages data
        const computeGSCMetricsForSegment = (queryPagesData, segmentFilter) => {
          if (!queryPagesData || queryPagesData.length === 0) {
            return { siteCtr: 0, top10Ctr: 0, avgPosition: 0, top10Share: 0 };
          }
          
          // Filter by segment if filter function provided
          let filteredData = queryPagesData;
          if (segmentFilter) {
            filteredData = queryPagesData.filter(row => {
              const segment = classifyPageSegment(row.page || row.url || '/');
              return segmentFilter(segment);
            });
          }
          
          // Filter to ranking queries (position 1-20, with impressions)
          const rankingQueries = filteredData.filter(q => {
            const pos = q.position || 0;
            const impr = q.impressions || 0;
            return pos > 0 && pos <= 20 && impr > 0;
          });
          const top10Queries = rankingQueries.filter(q => (q.position || 0) <= 10);
          
          let siteCtr = 0;
          let top10Ctr = 0;
          let avgPosition = 0;
          let top10Share = 0;
          
          if (rankingQueries.length > 0) {
            const totalClicks = rankingQueries.reduce((s, q) => s + (q.clicks || 0), 0);
            const totalImpr = rankingQueries.reduce((s, q) => s + (q.impressions || 0), 0);
            siteCtr = totalImpr > 0 ? (totalClicks / totalImpr) * 100 : 0;
            
            const top10Clicks = top10Queries.reduce((s, q) => s + (q.clicks || 0), 0);
            const top10Impr = top10Queries.reduce((s, q) => s + (q.impressions || 0), 0);
            top10Ctr = top10Impr > 0 ? (top10Clicks / top10Impr) * 100 : 0;
            
            avgPosition = totalImpr > 0
              ? rankingQueries.reduce((s, q) => s + (q.position || 0) * (q.impressions || 0), 0) / totalImpr
              : 0;
            
            top10Share = totalImpr > 0 ? (top10Impr / totalImpr) : 0; // Store as 0-1 fraction
          }
          
          return { siteCtr, top10Ctr, avgPosition, top10Share };
        };
        
        // Compute GSC metrics for each segment using full queryPages data (not pre-filtered rankingPages)
        const allGSCMetrics = computeGSCMetricsForSegment(queryPagesData, null); // All pages
        const excludeEduGSCMetrics = computeGSCMetricsForSegment(queryPagesData, (seg) => seg !== PageSegment.EDUCATION);
        const moneyGSCMetrics = computeGSCMetricsForSegment(queryPagesData, (seg) => seg === PageSegment.MONEY);
        
        debugLog(` GSC Metrics - All: CTR=${allGSCMetrics.siteCtr != null ? allGSCMetrics.siteCtr.toFixed(2) : 'N/A'}%, Pos=${allGSCMetrics.avgPosition != null ? allGSCMetrics.avgPosition.toFixed(1) : 'N/A'}`, 'info');
        debugLog(` GSC Metrics - ExcludeEdu: CTR=${excludeEduGSCMetrics.siteCtr != null ? excludeEduGSCMetrics.siteCtr.toFixed(2) : 'N/A'}%, Pos=${excludeEduGSCMetrics.avgPosition != null ? excludeEduGSCMetrics.avgPosition.toFixed(1) : 'N/A'}`, 'info');
        debugLog(` GSC Metrics - Money: CTR=${moneyGSCMetrics.siteCtr != null ? moneyGSCMetrics.siteCtr.toFixed(2) : 'N/A'}%, Pos=${moneyGSCMetrics.avgPosition != null ? moneyGSCMetrics.avgPosition.toFixed(1) : 'N/A'}`, 'info');
        
        authorityBySegment = {
          all: { 
            ...authorityAll, 
            topPages: allTopPages,
            siteCtr: allGSCMetrics.siteCtr,
            top10Ctr: allGSCMetrics.top10Ctr,
            avgPosition: allGSCMetrics.avgPosition,
            top10Share: allGSCMetrics.top10Share
          },
          nonEducation: { 
            ...authorityNonEducation, 
            topPages: excludeEduTopPages,
            siteCtr: excludeEduGSCMetrics.siteCtr,
            top10Ctr: excludeEduGSCMetrics.top10Ctr,
            avgPosition: excludeEduGSCMetrics.avgPosition,
            top10Share: excludeEduGSCMetrics.top10Share
          },
          money: { 
            ...authorityMoney, 
            topPages: moneyTopPages,
            siteCtr: moneyGSCMetrics.siteCtr,
            top10Ctr: moneyGSCMetrics.top10Ctr,
            avgPosition: moneyGSCMetrics.avgPosition,
            top10Share: moneyGSCMetrics.top10Share
          }
        };
        
        debugLog(` Authority by segment - All: ${authorityAll.total.toFixed(1)}, Non-education: ${authorityNonEducation.total.toFixed(1)}, Money: ${authorityMoney.total.toFixed(1)}`, 'info');
      }
      
      // Main Authority score (default: all pages)
      const authority = authorityAll.total;
      
      debugLog(`Authority calculation: Behaviour=${behaviourScore.toFixed(1)}, Ranking=${rankingScore.toFixed(1)}, Backlinks=${backlinkScore}, Reviews=${reviewScore}, Final=${authority}`, 'info');
      
      // Store component scores for historical tracking (backward compatible)
      const authorityComponents = {
        behaviour: authorityAll.behaviour,
        ranking: authorityAll.ranking,
        backlinks: authorityAll.backlinks,
        reviews: authorityAll.reviews,
        // Segmented scores (if available) - for backward compatibility
        behaviourScoreAll: behaviourScoresSegmented ? clampScore(behaviourScoresSegmented.all) : clampScore(behaviourScore),
        behaviourScoreNonBlog: behaviourScoresSegmented ? clampScore(behaviourScoresSegmented.nonBlog) : null,
        behaviourScoreMoney: behaviourScoresSegmented ? clampScore(behaviourScoresSegmented.money) : null,
        rankingScoreAll: rankingScoresSegmented ? clampScore(rankingScoresSegmented.all) : clampScore(rankingScore),
        rankingScoreNonBlog: rankingScoresSegmented ? clampScore(rankingScoresSegmented.nonBlog) : null,
        rankingScoreMoney: rankingScoresSegmented ? clampScore(rankingScoresSegmented.money) : null
      };
      
      // Log final segmented scores stored
      if (behaviourScoresSegmented) {
        debugLog(` Segmentation: Final stored scores - Behaviour: All=${authorityComponents.behaviourScoreAll}, NonBlog=${authorityComponents.behaviourScoreNonBlog}, Money=${authorityComponents.behaviourScoreMoney}`, 'info');
        debugLog(` Segmentation: Final stored scores - Ranking: All=${authorityComponents.rankingScoreAll}, NonBlog=${authorityComponents.rankingScoreNonBlog}, Money=${authorityComponents.rankingScoreMoney}`, 'info');
      }

      // Local Entity: Use real Business Profile data if available, otherwise fallback to derived calculation
      let localEntity;
      if (localSignals && localSignals.status === 'ok' && localSignals.data) {
        const localData = localSignals.data;
        // Base score from NAP consistency (0-100)
        let baseScore = localData.napConsistencyScore || 0;
        
        // Bonus for knowledge panel detection (+10 points)
        if (localData.knowledgePanelDetected) {
          baseScore = Math.min(100, baseScore + 10);
        }
        
        // Bonus for having at least one location (+5 points)
        if (localData.locations && localData.locations.length > 0) {
          baseScore = Math.min(100, baseScore + 5);
        }
        
        localEntity = clampScore(baseScore);
        debugLog(`Local Entity: NAP=${localData.napConsistencyScore || 0}, Knowledge Panel=${localData.knowledgePanelDetected}, Locations=${localData.locations?.length || 0}, Final=${localEntity}`, 'info');
      } else {
        // Fallback: derived calculation (old method)
        // Calculate ctrScore from ctr (which is 0-100 percentage)
      const ctrDecimal = ctr / 100; // Convert percentage to decimal (e.g., 10% -> 0.10)
      const ctrScore = Math.min((ctrDecimal / 0.10) * 100, 100);
        localEntity = clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
        debugLog('Local Entity: Using fallback calculation (no Business Profile data)', 'warn');
      }

      // Service Area: Use real Business Profile service areas count if available, otherwise fallback
      let serviceArea;
      if (localSignals && localSignals.status === 'ok' && localSignals.data) {
        const localData = localSignals.data;
        const serviceAreasCount = localData.serviceAreas?.length || 0;
        
        // Normalize service areas count to 0-100 score
        // 0 areas = 0, 8+ areas = 100 (more reasonable threshold)
        // Linear scale: 1 area = 12.5 points (8 areas = 100)
        if (serviceAreasCount === 0) {
          serviceArea = 0;
        } else if (serviceAreasCount >= 8) {
          serviceArea = 100;
        } else {
          // Linear scale: 1 area = 12.5 points, 2 = 25, ..., 8 = 100
          serviceArea = Math.min(100, serviceAreasCount * 12.5);
        }
        
        // Apply NAP consistency as a multiplier (if NAP is low, reduce service area score)
        if (localData.napConsistencyScore !== null && localData.napConsistencyScore < 100) {
          const napMultiplier = localData.napConsistencyScore / 100;
          serviceArea = Math.round(serviceArea * napMultiplier);
        }
        
        serviceArea = clampScore(serviceArea);
        debugLog(`Service Area: Count=${serviceAreasCount}, NAP Multiplier=${localData.napConsistencyScore !== null ? (localData.napConsistencyScore / 100).toFixed(2) : 'N/A'}, Final=${serviceArea}`, 'info');
      } else {
        // Fallback: derived from Local Entity (old method)
        serviceArea = clampScore(localEntity - 5);
        debugLog('Service Area: Using fallback calculation (no Business Profile data)', 'warn');
      }

      // Content/Schema: weighted calculation based on foundation schemas, rich results, coverage, and diversity
      let contentSchema;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        const allTypes = new Set();
        
        // Use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
        if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
          // Use all detected types for accurate calculation
          schemaData.allDetectedTypes.forEach(type => {
            if (type) allTypes.add(type);
          });
        } else if (schemaData.foundation && typeof schemaData.foundation === 'object') {
          // Use foundation object to get foundation types (most reliable)
          Object.keys(schemaData.foundation).forEach(type => {
            if (schemaData.foundation[type] === true) {
              allTypes.add(type);
            }
          });
          // Also add from richEligible for complete type list
          if (schemaData.richEligible && typeof schemaData.richEligible === 'object') {
            Object.keys(schemaData.richEligible).forEach(type => {
              if (schemaData.richEligible[type] === true) {
                allTypes.add(type);
              }
            });
          }
        } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          // Fallback: collect from schemaTypes array (contains all types, sorted by count)
          // Handle both object format {type, count} and string format
          schemaData.schemaTypes.forEach(item => {
            if (typeof item === 'string') {
              allTypes.add(item);
            } else if (item && typeof item === 'object' && item.type) {
              allTypes.add(item.type);
            }
          });
        }
        
        // 1. Foundation Schemas Score (30% weight): Organization, Person, WebSite, BreadcrumbList
        const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
        const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
        const foundationScore = (foundationPresent / foundationTypes.length) * 100;
        
        // 2. Rich Result Eligibility Score (35% weight): Count eligible rich result types
        // Note: This list must match RICH_RESULT_TYPES in api/schema-audit.js
        const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
        const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
        const richResultScore = (richEligibleCount / richResultTypes.length) * 100;
        
        // 3. Coverage Score (20% weight): Pages with schema / total pages
        // Calculate coverage from pagesWithSchema and totalPages if coverage is not available
        let coverageScore = 0;
        if (typeof schemaData.coverage === 'number' && !isNaN(schemaData.coverage)) {
          coverageScore = schemaData.coverage;
        } else {
          // Calculate from pagesWithSchema and totalPages
          const pagesWithSchemaCount = Array.isArray(schemaData.pagesWithSchema) 
            ? schemaData.pagesWithSchema.length 
            : (typeof schemaData.pagesWithSchema === 'number' ? schemaData.pagesWithSchema : 0);
          const totalPagesCount = typeof schemaData.totalPages === 'number' 
            ? schemaData.totalPages 
            : (Array.isArray(schemaData.pages) ? schemaData.pages.length : 0);
          if (totalPagesCount > 0) {
            coverageScore = (pagesWithSchemaCount / totalPagesCount) * 100;
          }
        }
        
        // 4. Type Diversity Score (15% weight): Number of unique schema types (normalized to 15 types)
        const uniqueTypesCount = allTypes.size;
        const diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
        
        // Weighted calculation: 30% foundation + 35% rich results + 20% coverage + 15% diversity
        contentSchema = clampScore(
          foundationScore * 0.30 +
          richResultScore * 0.35 +
          coverageScore * 0.20 +
          diversityScore * 0.15
        );
        
        debugLog(`Content/Schema calculation: Foundation=${foundationScore != null ? foundationScore.toFixed(1) : 'N/A'}% (${foundationPresent}/4), Rich Results=${richResultScore != null ? richResultScore.toFixed(1) : 'N/A'}% (${richEligibleCount}/${richResultTypes.length}), Coverage=${coverageScore != null ? coverageScore.toFixed(1) : 'N/A'}%, Diversity=${diversityScore != null ? diversityScore.toFixed(1) : 'N/A'}% (${uniqueTypesCount} types)`, 'info');
      } else {
        // Fallback: if no schema audit data, return 0 (can't calculate without data)
        contentSchema = 0;
        debugLog(' No schema audit data available, Content/Schema score set to 0', 'warn');
      }

      // Extract coverage and diversity scores from contentSchema calculation for GAIO health
      let coverageScore = 0;
      let diversityScore = 0;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        // Coverage: Pages with schema / total pages (0-100)
        coverageScore = schemaData.coverage || 0;
        
        // Diversity: Number of unique schema types (normalized to 15 types, 0-100)
        const allTypes = new Set();
        if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
          schemaData.allDetectedTypes.forEach(type => {
            if (type) allTypes.add(type);
          });
        } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          schemaData.schemaTypes.forEach(item => {
            if (item.type) allTypes.add(item.type);
          });
        }
        const uniqueTypesCount = allTypes.size;
        diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
      }

      // ============================================================================
      // PHASE 1: Brand Overlay Calculation
      // ============================================================================
      
      // Calculate brand metrics from GSC query data
      // Use queryPages if available (more accurate), otherwise fall back to topQueries
      let brandMetrics;
      if (queryPages && queryPages.length > 0) {
        // Convert queryPages to query format for brand metrics calculation
        const queriesForBrand = queryPages.map(row => ({
          query: row.query || '',
          clicks: row.clicks || 0,
          impressions: row.impressions || 0,
          position: row.position || 0
        }));
        brandMetrics = calculateBrandMetrics(queriesForBrand);
      } else {
        // Fallback to topQueries
        brandMetrics = calculateBrandMetrics(topQueries);
      }
      debugLog(`Brand Metrics: Share=${(brandMetrics.brandQueryShare * 100).toFixed(2)}%, CTR=${(brandMetrics.brandCtr * 100).toFixed(2)}%, AvgPos=${brandMetrics.brandAvgPosition?.toFixed(1) || 'N/A'}`, 'info');
      
      // Compute brand overlay score
      const brandOverlay = computeBrandOverlay({
        brandQueryShare: brandMetrics.brandQueryShare,
        brandCtr: brandMetrics.brandCtr,
        brandAvgPosition: brandMetrics.brandAvgPosition,
        reviewScore: reviewScore,
        entityScore: localEntity
      });
      debugLog(`Brand Overlay: Score=${brandOverlay.score}, Label=${brandOverlay.label}, Notes=${brandOverlay.notes.length}`, 'info');
      
      // ============================================================================
      // End Phase 1: Brand Overlay Calculation
      // ============================================================================

      // ============================================================================
      // Money Pages Performance Metrics
      // ============================================================================
      
      /**
       * Compute site-wide aggregates from topPages data
       * @param {Array} topPages - Array of page objects with clicks, impressions, position
       * @returns {Object} Site aggregates
       */
      function computeSiteAggregateFromTopPages(topPages) {
        if (!topPages || !Array.isArray(topPages) || topPages.length === 0) {
          return {
            totalClicks: 0,
            totalImpressions: 0,
            avgCtr: 0,
            avgPosition: null
          };
        }
        
        let totalClicks = 0;
        let totalImpressions = 0;
        let weightedPosSum = 0;
        
        topPages.forEach(page => {
          const clicks = page.clicks || 0;
          const impressions = page.impressions || 0;
          const position = page.position || page.avgPosition || 0;
          
          totalClicks += clicks;
          totalImpressions += impressions;
          if (impressions > 0 && position > 0) {
            weightedPosSum += position * impressions;
          }
        });
        
        const avgCtr = totalImpressions > 0 ? totalClicks / totalImpressions : 0;
        const avgPosition = totalImpressions > 0 ? weightedPosSum / totalImpressions : null;
        
        return {
          totalClicks,
          totalImpressions,
          avgCtr,
          avgPosition
        };
      }
      
      /**
       * Classify a money page into an opportunity category and return a short recommendation.
       * @param {Object} metrics - { ctr (01), avgPosition, impressions }
       * @param {Object} siteAgg - { avgCtr, avgPosition }
       * @returns {Object} { category, categoryLabel, categoryColor, recommendation }
       */
      function classifyMoneyPageOpportunity(metrics, siteAgg, hasSchema = null, schemaTypes = []) {
        const { ctr, avgPosition, impressions } = metrics;
        const siteCtr = siteAgg.avgCtr || 0;
        const sitePos = siteAgg.avgPosition || 0;
        
        // Sensible defaults
        const safePos = avgPosition || 99;
        const safeCtr = ctr || 0;
        const imp = impressions || 0;
        
        // Thresholds (tune later)
        const MIN_IMPRESSIONS = 100;
        const HIGH_OPP_MAX_POS = 15;
        const MAINTAIN_MAX_POS = 8;
        
        const targetCtrHigh = 0.05;   // 5% for strong
        const targetCtrMid = 0.03;    // 3% mid range
        const lowCtrThreshold = 0.02;  // 2%
        
        let category = 'VISIBILITY_FIX';
        let categoryLabel = 'Visibility fix';
        let categoryColor = 'red';
        let recommendation = '';
        
        // Check which schema types are missing (for money pages, we typically want Product, Event, FAQPage)
        const desiredSchemaTypes = ['Product', 'Event', 'FAQPage'];
        // Normalize present types to lowercase for case-insensitive comparison
        const presentTypes = Array.isArray(schemaTypes) && schemaTypes.length > 0 
          ? schemaTypes.map(t => {
              if (typeof t === 'string') return t.trim().toLowerCase();
              if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type.trim().toLowerCase();
              return String(t).trim().toLowerCase();
            }).filter(t => t && t !== '[object object]')
          : [];
        // Check for missing types (case-insensitive comparison)
        const missingTypes = desiredSchemaTypes.filter(type => {
          const typeLower = type.toLowerCase();
          return !presentTypes.includes(typeLower);
        });
        
        // Build schema recommendation based on what's actually missing
        // Only recommend schema types that are NOT already present
        let schemaRecommendation = '';
        if (hasSchema === false) {
          // No schema at all - generic recommendation
          schemaRecommendation = 'ensure Product/Event/FAQ schema is present, and ';
        } else if (missingTypes.length > 0) {
          // Has schema but missing some or all desired types
          if (missingTypes.length === desiredSchemaTypes.length) {
            // Has schema but none of the desired types (Product, Event, FAQPage) - generic
            schemaRecommendation = 'ensure Product/Event/FAQ schema is present, and ';
          } else {
            // Missing specific types - only recommend what's actually missing (e.g., "add Product/Event schema")
            const missingTypesText = missingTypes.join('/');
            schemaRecommendation = `add ${missingTypesText} schema, and `;
          }
        }
        // If hasSchema === true AND missingTypes.length === 0, no schema recommendation (all desired types present)
        
        // 1) High opportunity: decent position, impressions, but weak CTR
        const hasDecentPosition = safePos >= 3 && safePos <= HIGH_OPP_MAX_POS;
        const hasVolume = imp >= MIN_IMPRESSIONS;
        const ctrBelowTargetForBand =
          (safePos <= 6 && safeCtr < targetCtrHigh) ||
          (safePos > 6 && safePos <= 10 && safeCtr < targetCtrMid) ||
          (safePos > 10 && safePos <= HIGH_OPP_MAX_POS && safeCtr < lowCtrThreshold);
        
        if (hasDecentPosition && hasVolume && ctrBelowTargetForBand) {
          category = 'HIGH_OPPORTUNITY';
          categoryLabel = 'High opportunity (improve CTR)';
          categoryColor = 'amber';
          // Add schema recommendation if missing (use same logic as visibility fix)
          let schemaNote = '';
          if (hasSchema === false) {
            // No schema at all
            schemaNote = ' Add Product/Event/FAQ schema to improve rich result eligibility. ';
          } else if (missingTypes.length > 0) {
            // Has schema but missing some or all desired types
            if (missingTypes.length === desiredSchemaTypes.length) {
              // Has schema but none of the desired types
              schemaNote = ' Add Product/Event/FAQ schema to improve rich result eligibility. ';
            } else {
              // Missing specific types - only recommend what's actually missing
              schemaNote = ` Add ${missingTypes.join('/')} schema to improve rich result eligibility. `;
            }
          }
          // If missingTypes.length === 0, no schema recommendation (all desired types present)
          recommendation =
            `Good visibility (avg position ${safePos.toFixed(1)}) and ` +
            `${imp.toLocaleString()} impressions, but low CTR (${(safeCtr * 100).toFixed(1)}%). ` +
            `Prioritise title/meta improvements, "best" phrasing for this offer, ` +
            `${schemaNote}` +
            `and adding FAQs that address objections for this money page.`;
        }
        // 2) Maintain: strong position + CTR above target
        else if (safePos <= MAINTAIN_MAX_POS && safeCtr >= targetCtrMid && imp >= MIN_IMPRESSIONS) {
          category = 'MAINTAIN';
          categoryLabel = 'Maintain (performing well)';
          categoryColor = 'green';
          recommendation =
            `Strong performer with avg position ${safePos.toFixed(1)} and ` +
            `CTR ${(safeCtr * 100).toFixed(1)}%. Maintain current messaging and ` +
            `internal links; focus optimisation efforts on weaker money pages first.`;
        }
        // 3) Visibility fix: fallback
        else {
          category = 'VISIBILITY_FIX';
          categoryLabel = 'Visibility fix (low impressions/rank)';
          categoryColor = 'red';
          recommendation =
            `Limited visibility (avg position ${Number.isFinite(safePos) ? safePos.toFixed(1) : ''} ` +
            `and ${imp.toLocaleString()} impressions). Strengthen internal links from high-traffic ` +
            `educational posts, ${schemaRecommendation}` +
            `consider a clearer "best [topic]" section to signal value to searchers and AI.`;
        }
        
        return { category, categoryLabel, categoryColor, recommendation };
      }
      
      /**
       * Compute aggregate and per-URL metrics for money pages.
       * @param {Array} topPages - Array from GSC (page/url, clicks, impressions, position)
       * @param {Function} classifySegment - function(url) -> 'money' | 'education' | 'general' | ...
       * @param {Object} siteAgg - { totalClicks, totalImpressions, avgCtr, avgPosition }
       * @param {Map|Object} pageTitleLookup - Optional Map/object url->title
       * @param {Object} schemaAudit - Optional schema audit data with pages array
       * @returns {Object} { overview, rows }
       */
      // Ranking & AI module - MOVED TO TOP OF SCRIPT (see line ~1820)

      // Classify money page sub-segment (Product, Event, Landing)
      function classifyMoneyPageSubSegment(url) {
        if (!url) return 'LANDING';
        
        // Use the same classification logic as Ranking & AI for consistency
        // This ensures Event/Product pages are classified the same way in both tabs
        if (typeof window.classifyUrlForRankingAi === 'function') {
          const classification = window.classifyUrlForRankingAi(url);
          const pageType = classification.pageType;
          
          // Map Ranking & AI pageType to Money Pages segmentType
          if (pageType === 'Event') return 'EVENT';
          if (pageType === 'Product') return 'PRODUCT';
          if (pageType === 'Landing') return 'LANDING';
          // For non-money pages (GBP, Blog, Other), return LANDING as fallback
          // (Money Pages only shows money pages, so these shouldn't appear anyway)
          return 'LANDING';
        }
        
        // Fallback: Use original logic if classifyUrlForRankingAi not available
        const path = normalisePath(url);
        const urlLower = url.toLowerCase();
        
        // Event Pages: Use same pattern as Ranking & AI (substring match for consistency)
        if (urlLower.includes('/beginners-photography-lessons') ||
            urlLower.includes('/photographic-workshops-near-me')) {
          return 'EVENT';
        }
        
        // Product Pages: Use same pattern as Ranking & AI (substring match for consistency)
        if (urlLower.includes('/photo-workshops-uk') ||
            urlLower.includes('/photography-services-near-me')) {
          return 'PRODUCT';
        }
        
        // Landing Pages (default - anything not matching above)
        return 'LANDING';
      }
      
      function computeMoneyPagesMetrics(topPages, classifySegment, siteAgg, pageTitleLookup = null, schemaAudit = null) {
        // Initialize summary by category (Phase 2)
        const summaryByCategory = {
          HIGH_OPPORTUNITY: { count: 0, impressions: 0, clicks: 0 },
          VISIBILITY_FIX: { count: 0, impressions: 0, clicks: 0 },
          MAINTAIN: { count: 0, impressions: 0, clicks: 0 }
        };
        
        // Initialize summary by sub-segment
        const summaryBySubSegment = {
          PRODUCT: { count: 0, impressions: 0, clicks: 0 },
          EVENT: { count: 0, impressions: 0, clicks: 0 },
          LANDING: { count: 0, impressions: 0, clicks: 0 }
        };
        
        if (!topPages || !Array.isArray(topPages) || topPages.length === 0) {
          return {
            overview: {
              moneyClicks: 0,
              moneyImpressions: 0,
              moneyCtr: 0,
              moneyAvgPosition: null,
              moneyCoverageCount: 0,
              moneyTotalKnown: null,
              moneyCoveragePct: null,
              siteCtr: siteAgg.avgCtr || 0,
              siteAvgPosition: siteAgg.avgPosition || null,
              siteTotalClicks: siteAgg.totalClicks || 0,
              siteTotalImpressions: siteAgg.totalImpressions || 0
            },
            rows: [],
            summaryByCategory
          };
        }
        
        const moneyRows = [];
        let moneyClicks = 0;
        let moneyImpressions = 0;
        let weightedPosSum = 0;
        const moneyActiveUrls = new Set();
        
        // Convert pageTitleLookup to Map if it's an object (for backward compatibility)
        // If it's already a Map with metadata objects, use it directly
        let metadataMap = null;
        if (pageTitleLookup instanceof Map) {
          // Check if it contains metadata objects or just titles
          const firstValue = pageTitleLookup.values().next().value;
          if (firstValue && typeof firstValue === 'object' && (firstValue.title !== undefined || firstValue.metaDescription !== undefined)) {
            metadataMap = pageTitleLookup; // It's already a metadata map
          } else {
            // Convert title-only map to metadata map
            metadataMap = new Map();
            pageTitleLookup.forEach((title, url) => {
              metadataMap.set(url, { title: title, metaDescription: null });
            });
          }
        } else if (pageTitleLookup) {
          // Convert object to metadata map
          metadataMap = new Map();
          Object.entries(pageTitleLookup).forEach(([url, value]) => {
            if (typeof value === 'object' && value !== null) {
              metadataMap.set(url, { title: value.title || null, metaDescription: value.metaDescription || null });
            } else {
              metadataMap.set(url, { title: value || null, metaDescription: null });
            }
          });
        }
        
        // Build schema lookup map from schema audit data
        const schemaLookup = new Map();
        const schemaTypesLookup = new Map();
        if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data && schemaAudit.data.pages) {
          schemaAudit.data.pages.forEach(page => {
            if (page.url) {
              // Normalize URL for matching (handles trailing slashes, query params, etc.)
              const normalizedUrl = normalizeUrlForMatching(page.url);
              // Store both original and normalized for lookup flexibility
              const hasSchema = page.hasSchema || page.hasInheritedSchema || false;
              schemaLookup.set(page.url, hasSchema);
              schemaLookup.set(normalizedUrl, hasSchema); // Also store normalized version
              // Store schema types array
              schemaTypesLookup.set(page.url, page.schemaTypes || []);
              schemaTypesLookup.set(normalizedUrl, page.schemaTypes || []); // Also store normalized version
            }
          });
        }
        
        // Iterate over topPages
        // Note: topPages is already aggregated by page from queryPages
        // The Segment Overview uses query+page level data filtered to position 1-20
        // Money Pages uses page-level GSC totals (unfiltered, all positions) to match GSC "Pages" tab exactly
        // to give a complete view of money page performance
        topPages.forEach(page => {
          const url = page.page || page.url || '';
          if (!url) return;
          
          const segment = classifyPageSegment(url);
          if (segment !== PageSegment.MONEY) return;
          
          const clicks = page.clicks || 0;
          const impressions = page.impressions || 0;
          const position = page.position || page.avgPosition || 0;
          
          if (impressions > 0) {
            moneyClicks += clicks;
            moneyImpressions += impressions;
            weightedPosSum += position * impressions;
            moneyActiveUrls.add(url);
          }
          
          // Compute row-level metrics
          const ctr = impressions > 0 ? clicks / impressions : 0;
          const avgPosition = position || null;
          
          // Get title and meta description from metadata lookup
          const metadata = metadataMap?.get(url) || {};
          const title = metadata.title || null;
          const metaDescription = metadata.metaDescription || null;
          
          // Check if schema exists for this page (normalize URL for matching)
          const normalizedUrl = normalizeUrlForMatching(url);
          const hasSchema = schemaLookup.has(url) ? schemaLookup.get(url) : 
                          schemaLookup.has(normalizedUrl) ? schemaLookup.get(normalizedUrl) : null;
          const schemaTypes = schemaTypesLookup.get(url) || schemaTypesLookup.get(normalizedUrl) || [];
          
          // Classify opportunity
          const { category, categoryLabel, categoryColor, recommendation } =
            classifyMoneyPageOpportunity({ ctr, avgPosition, impressions }, siteAgg, hasSchema, schemaTypes);
          
          // Classify sub-segment
          const subSegment = classifyMoneyPageSubSegment(url);
          
          // Update category summary (Phase 2)
          const bucket = summaryByCategory[category];
          if (bucket) {
            bucket.count += 1;
            bucket.impressions += impressions;
            bucket.clicks += clicks;
          }
          
          // Update sub-segment summary
          const subBucket = summaryBySubSegment[subSegment];
          if (subBucket) {
            subBucket.count += 1;
            subBucket.impressions += impressions;
            subBucket.clicks += clicks;
          }
          
          // Push row
          moneyRows.push({
            url,
            title,
            metaDescription,
            clicks,
            impressions,
            ctr,
            avgPosition,
            category,
            categoryLabel,
            categoryColor,
            recommendation,
            schemaTypes,
            subSegment // Add sub-segment to each row
          });
        });
        
        // Compute money overview
        const moneyCtr = moneyImpressions > 0 ? moneyClicks / moneyImpressions : 0;
        const moneyAvgPosition = moneyImpressions > 0 ? weightedPosSum / moneyImpressions : null;
        
        const overview = {
          moneyClicks,
          moneyImpressions,
          moneyCtr,
          moneyAvgPosition,
          moneyCoverageCount: moneyActiveUrls.size,
          moneyTotalKnown: null, // Can be populated if we have a known money URLs list
          moneyCoveragePct: null,
          siteCtr: siteAgg.avgCtr || 0,
          siteAvgPosition: siteAgg.avgPosition || null,
          siteTotalClicks: siteAgg.totalClicks || 0,
          siteTotalImpressions: siteAgg.totalImpressions || 0
        };
        
        // Sort by category then impressions desc
        const categoryOrder = { HIGH_OPPORTUNITY: 0, VISIBILITY_FIX: 1, MAINTAIN: 2 };
        moneyRows.sort((a, b) => {
          const ca = categoryOrder[a.category] ?? 99;
          const cb = categoryOrder[b.category] ?? 99;
          if (ca !== cb) return ca - cb;
          return (b.impressions || 0) - (a.impressions || 0);
        });
        
        return { overview, rows: moneyRows, summaryByCategory, summaryBySubSegment };
      }
      
      /**
       * Phase 4: Scoring functions for priority matrix
       * These functions compute impact, difficulty, priority, and recommended actions
       * based on page-level metrics from gsc_page_metrics_28d (28d rolling window)
       */
      
      /**
       * Compute impact scores (0-100) based on CTR gap and click upside
       * @param {Array} pages - Array of page objects with clicks, impressions, ctr, position
       * @param {number} targetCtr - Target CTR (default 0.025 = 2.5%)
       */
      function computeImpactScores(pages, targetCtr = 0.025) {
        if (!pages || pages.length === 0) return;
        
        // Step 1: Compute upside_clicks for each page
        const upsideData = [];
        for (const p of pages) {
          const impressions = p.impressions || 0;
          const ctr = p.ctr || 0;
          
          // Edge case: impressions < 10 => impact = 0
          if (impressions < 10) {
            p.upside_clicks = 0;
            p.impact_score = 0;
            upsideData.push({ upside_clicks: 0 });
            continue;
          }
          
          // Calculate click upside: max(0, impressions * (target_ctr - ctr))
          const upside_clicks = Math.max(0, impressions * (targetCtr - ctr));
          p.upside_clicks = upside_clicks;
          upsideData.push({ upside_clicks });
        }
        
        // Step 2: Find max upside in the set
        const maxUpside = Math.max(...upsideData.map(d => d.upside_clicks), 0);
        
        // Step 3: Normalize to 0-100
        if (maxUpside <= 0) {
          // All pages flat  impact = 0 for all
          for (const p of pages) {
            p.impact_score = 0;
          }
          return;
        }
        
        // Normalize: impact = round(100 * upside_clicks / max_upside_clicks_in_set)
        for (let i = 0; i < pages.length; i++) {
          pages[i].impact_score = Math.round(100 * upsideData[i].upside_clicks / maxUpside);
        }
      }
      
      /**
       * Compute difficulty score (LOW/MED/HIGH) based on position
       * @param {Object} page - Page object with avgPosition
       * @returns {string} 'LOW', 'MED', or 'HIGH'
       */
      function computeDifficultyScore(page) {
        const pos = page.avgPosition || page.position || 99;
        
        // Based primarily on position:
        // pos <= 3      => LOW
        // 3 < pos <=10  => MED
        // pos > 10      => HIGH
        if (pos <= 3) return 'LOW';
        if (pos <= 10) return 'MED';
        return 'HIGH';
      }
      
      /**
       * Compute priority (LOW/MED/HIGH) combining impact and difficulty
       * @param {number} impactScore - Impact score (0-100)
       * @param {string} difficulty - Difficulty level ('LOW', 'MED', 'HIGH')
       * @returns {string} 'LOW', 'MED', or 'HIGH'
       */
      function computePriority(impactScore, difficulty) {
        // Convert impact (0-100) to buckets
        let impactBucket;
        if (impactScore >= 70) impactBucket = 'HIGH';
        else if (impactScore >= 30) impactBucket = 'MED';
        else impactBucket = 'LOW';
        
        // Priority rules:
        // HIGH priority if impactBucket=HIGH and difficulty in {LOW,MED}
        // MED priority if impactBucket=HIGH and difficulty=HIGH
        // MED priority if impactBucket=MED and difficulty=LOW
        // LOW otherwise
        if (impactBucket === 'HIGH' && (difficulty === 'LOW' || difficulty === 'MED')) {
          return 'HIGH';
        }
        if (impactBucket === 'HIGH' && difficulty === 'HIGH') {
          return 'MED';
        }
        if (impactBucket === 'MED' && difficulty === 'LOW') {
          return 'MED';
        }
        return 'LOW';
      }
      
      /**
       * Get recommended action and task type based on page metrics
       * @param {Object} page - Page object with ctr, avgPosition, impressions, clicks
       * @returns {Object} { action: string, taskType: string }
       */
      function getRecommendedAction(page) {
        const ctr = (page.ctr || 0) * 100; // Convert to percentage
        const pos = page.avgPosition || page.position || 99;
        const impressions = page.impressions || 0;
        const clicks = page.clicks || 0;
        const targetCtr = 2.5;
        
        // If ctr < 2.5% and pos <= 10:
        if (ctr < targetCtr && pos <= 10) {
          return {
            action: 'Improve CTR (title/meta/snippet) + strengthen content',
            taskType: 'on_page'
          };
        }
        
        // If ctr < 2.5% and pos > 10:
        if (ctr < targetCtr && pos > 10) {
          return {
            action: 'Improve relevance + internal links to lift rank',
            taskType: 'internal_links'
          };
        }
        
        // If impressions are high but clicks are low AND ctr is near 0:
        if (impressions > 100 && clicks < 5 && ctr < 0.5) {
          return {
            action: 'Rewrite snippet + add intent-matching sections',
            taskType: 'content'
          };
        }
        
        // Default: on_page optimization
        return {
          action: 'Review page manually',
          taskType: 'on_page'
        };
      }
      
      /**
       * Phase 4: Render Suggested (Top 10) priority pages table
       * @param {Array} moneyPagesRows - Array of money page row objects
       */
      // Phase 4: Define function (already initialized at script start, now assign implementation)
      if (!window.renderMoneyPagesSuggestedTop10) {
        console.log('[Money Pages Phase 4] Defining renderMoneyPagesSuggestedTop10 function...');
      }
      window.renderMoneyPagesSuggestedTop10 = function renderMoneyPagesSuggestedTop10(moneyPagesRows) {
        console.log('[Money Pages Suggested Top 10] Function called with', moneyPagesRows?.length || 0, 'rows');
        try {
          const container = document.getElementById('money-pages-suggested-top10-content');
          if (!container) {
            console.warn('[Money Pages Suggested Top 10] Container not found, will retry...');
            // Retry after a short delay in case DOM isn't ready
            setTimeout(() => {
              if (typeof window.renderMoneyPagesSuggestedTop10 === 'function') {
                window.renderMoneyPagesSuggestedTop10(moneyPagesRows);
              }
            }, 500);
            return;
          }
          
          if (!moneyPagesRows || moneyPagesRows.length === 0) {
            container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b; font-size: 0.9rem;">No money pages data available.</div>';
            console.log('[Money Pages Suggested Top 10] No rows provided');
            return;
          }
          
          console.log('[Money Pages Suggested Top 10] Rendering with', moneyPagesRows.length, 'rows');
        
        // Create a copy of rows to avoid mutating original
        // Handle both moneyPagesMetrics.rows format and moneyPagePriorityData format
        const pages = moneyPagesRows.map(row => ({
          url: row.url || row.page_url || '',
          title: row.title || row.page_title || row.url || '',
          clicks: row.clicks || row.clicks_28d || 0,
          impressions: row.impressions || row.impressions_28d || 0,
          ctr: row.ctr || row.ctr_28d || 0,
          avgPosition: row.avgPosition || row.position || row.position_28d || null,
          subSegment: row.subSegment || row.segmentType || 'Landing'
        }));
        
        // Compute Phase 4 scores
        computeImpactScores(pages, 0.025);
        for (const page of pages) {
          page.difficulty = computeDifficultyScore(page);
          page.priority = computePriority(page.impact_score || 0, page.difficulty);
          const { action, taskType } = getRecommendedAction(page);
          page.recommended_action = action;
          page.recommended_task_type = taskType;
        }
        
        // Sort by priority (HIGH > MED > LOW) then by upside_clicks desc
        const priorityOrder = { HIGH: 0, MED: 1, LOW: 2 };
        pages.sort((a, b) => {
          const priorityDiff = (priorityOrder[a.priority] ?? 99) - (priorityOrder[b.priority] ?? 99);
          if (priorityDiff !== 0) return priorityDiff;
          return (b.upside_clicks || 0) - (a.upside_clicks || 0);
        });
        
        // Take top 10
        const top10 = pages.slice(0, 10);
        
        if (top10.length === 0) {
          container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b; font-size: 0.9rem;">No pages meet the criteria for suggested optimization.</div>';
          return;
        }
        
        // Render as a grid of cards
        const html = `
          <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem;">
            ${top10.map((page, idx) => {
              const priority = page.priority || 'LOW';
              const priorityColor = priority === 'HIGH' ? '#10b981' : priority === 'MED' ? '#f59e0b' : '#64748b';
              const priorityBg = priority === 'HIGH' ? '#dcfce7' : priority === 'MED' ? '#fef3c7' : '#f1f5f9';
              const difficulty = page.difficulty || 'MED';
              const difficultyColor = difficulty === 'LOW' ? '#10b981' : difficulty === 'MED' ? '#f59e0b' : '#ef4444';
              const ctrPct = ((page.ctr || 0) * 100).toFixed(1);
              
              return `
                <div style="padding: 1rem; background: white; border: 1px solid #e2e8f0; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                  <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.75rem;">
                    <div style="flex: 1; min-width: 0;">
                      <div style="font-weight: 600; color: #1e293b; margin-bottom: 0.25rem; font-size: 0.9rem; line-height: 1.4; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;" title="${page.title}">${page.title}</div>
                      <div style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">${page.subSegment}</div>
                    </div>
                    <span style="display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.7rem; font-weight: 600; background: ${priorityBg}; color: ${priorityColor}; border: 1px solid ${priorityColor}40; white-space: nowrap; margin-left: 0.5rem;">${priority}</span>
                  </div>
                  <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; margin-bottom: 0.75rem; font-size: 0.8rem;">
                    <div><span style="color: #64748b;">Pos:</span> <strong>${page.avgPosition ? page.avgPosition.toFixed(1) : ''}</strong></div>
                    <div><span style="color: #64748b;">CTR:</span> <strong>${ctrPct}%</strong></div>
                    <div><span style="color: #64748b;">Impr:</span> <strong>${(page.impressions || 0).toLocaleString()}</strong></div>
                    <div><span style="color: #64748b;">Upside:</span> <strong>${(page.upside_clicks || 0).toFixed(0)}</strong></div>
                    <div><span style="color: #64748b;">Impact:</span> <strong>${page.impact_score != null ? page.impact_score : ''}</strong></div>
                    <div><span style="color: #64748b;">Difficulty:</span> <strong style="color: ${difficultyColor};">${difficulty}</strong></div>
                  </div>
                  <div style="font-size: 0.75rem; color: #475569; margin-bottom: 0.75rem; line-height: 1.4; min-height: 2.5rem;">${page.recommended_action || 'Review page manually'}</div>
                  <button onclick="window.createMoneyPageTask && window.createMoneyPageTask('${page.url.replace(/'/g, "\\'")}', '${(page.recommended_task_type || 'on_page').replace(/'/g, "\\'")}', ${JSON.stringify({
                    clicks: page.clicks || 0,
                    impressions: page.impressions || 0,
                    ctr: page.ctr || 0,
                    position: page.avgPosition || null
                  }).replace(/'/g, "\\'")})" style="width: 100%; padding: 0.6rem; background: #2563eb; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85rem; font-weight: 600; transition: background 0.2s;" onmouseover="this.style.background='#1d4ed8';" onmouseout="this.style.background='#2563eb';" title="Create optimisation task for this page">Create Task</button>
                </div>
              `;
            }).join('')}
          </div>
        `;
        
        container.innerHTML = html;
        console.log(`[Money Pages Suggested Top 10]  Rendered ${top10.length} pages`);
        debugLog(` Suggested Top 10 rendered with ${top10.length} pages`, 'success');
        } catch (error) {
          console.error('[Money Pages Suggested Top 10] Error rendering:', error);
          const container = document.getElementById('money-pages-suggested-top10-content');
          if (container) {
            container.innerHTML = `<div style="padding: 2rem; text-align: center; color: #ef4444; font-size: 0.9rem;">Error rendering suggested pages: ${error.message}</div>`;
          }
        }
      };
      
      // Verify function is defined - this should execute immediately when script loads
      console.log('[Money Pages Phase 4] renderMoneyPagesSuggestedTop10 defined:', typeof window.renderMoneyPagesSuggestedTop10);
      if (typeof window.renderMoneyPagesSuggestedTop10 !== 'function') {
        console.error('[Money Pages Phase 4] ERROR: Function was not assigned to window!');
      }
      
      /**
       * Phase 4: Create optimisation task for Money Page from Suggested panel
       * @param {string} pageUrl - The page URL
       * @param {string} taskType - Recommended task type (on_page, internal_links, content, technical)
       * @param {Object} baselineMetrics - Baseline metrics { clicks, impressions, ctr, position }
       */
      window.createMoneyPageTask = async function createMoneyPageTask(pageUrl, taskType = 'on_page', baselineMetrics = {}) {
        try {
          // Use existing trackMoneyPage function if available
          if (window.trackMoneyPage) {
            const pageTitle = baselineMetrics.title || pageUrl;
            await window.trackMoneyPage(pageUrl, pageTitle);
            return;
          }
          
          // Fallback: open track keyword modal
          if (window.openTrackKeywordModal) {
            const row = {
              keyword: '',
              best_url: pageUrl,
              targetUrl: pageUrl,
              ranking_url: pageUrl,
              title: baselineMetrics.title || pageUrl,
              clicks: baselineMetrics.clicks || 0,
              impressions: baselineMetrics.impressions || 0,
              ctr: baselineMetrics.ctr || 0,
              avgPosition: baselineMetrics.position || baselineMetrics.avgPosition || null
            };
            window.openTrackKeywordModal(row);
            return;
          }
          
          console.error('[Money Pages] No task creation function available');
        } catch (error) {
          console.error('[Money Pages] Error creating task:', error);
        }
      };
      
      // Build compact Money Pages summary for trend tracking (Phase 3)
      // Make buildMoneyPagesSummary globally accessible
      window.buildMoneyPagesSummary = function buildMoneyPagesSummary(moneyPagesMetrics, overview) {
        if (!moneyPagesMetrics || !moneyPagesMetrics.rows || !moneyPagesMetrics.rows.length) {
          return null;
        }

        const pages = moneyPagesMetrics.rows;
        const impressions = pages.reduce((sum, p) => sum + (p.impressions || 0), 0);
        const clicks = pages.reduce((sum, p) => sum + (p.clicks || 0), 0);
        const avgPosWeightedSum = pages.reduce((sum, p) =>
          sum + ((p.avgPosition || p.position || 0) * (p.impressions || 0)), 0
        );

        if (!impressions) return null;

        const avgPosition = avgPosWeightedSum / impressions;
        const ctr = clicks / impressions;

        // Use siteTotalImpressions and siteTotalClicks from overview
        const totalImpressions = overview?.siteTotalImpressions || overview?.totalImpressions || null;
        const totalClicks = overview?.siteTotalClicks || overview?.totalClicks || null;
        
        const shareOfImpressions = totalImpressions && totalImpressions > 0
          ? impressions / totalImpressions
          : null;

        const shareOfClicks = totalClicks && totalClicks > 0
          ? clicks / totalClicks
          : null;

        // Debug logging (only log if we have impressions but no overview - expected when overview is missing)
        if (shareOfImpressions == null && impressions > 0) {
          // Only log if this is unexpected (we have impressions but no overview data)
          // This is expected when overview data is not available, so reduce log level
          debugLog(` buildMoneyPagesSummary: shareOfImpressions is null (overview data not available) - impressions=${impressions}`, 'info');
        } else if (shareOfImpressions != null) {
          debugLog(` buildMoneyPagesSummary: shareOfImpressions=${shareOfImpressions} (${impressions}/${totalImpressions})`, 'info');
        }

        return {
          count: pages.length,
          impressions,
          clicks,
          ctr,
          avgPosition,
          shareOfImpressions,
          shareOfClicks,
          behaviourScore: moneyPagesMetrics.behaviour
            ? moneyPagesMetrics.behaviour.score
            : null
        };
      };
      
      // ============================================================================
      // PHASE: Money Pages Priority Matrix + 12-Month KPI Tracker
      // ============================================================================
      
      /**
       * Unified money page classification - returns both isMoney flag and segmentType
       * @param {string} url
       * @returns {{ isMoney: boolean, segmentType: MoneySegmentKey | null }}
       */
      function classifyMoneyPage(url) {
        if (!url) return { isMoney: false, segmentType: null };
        
        const path = normalisePath(url);
        
        // Check if it's a money page using existing logic
        const segment = classifyPageSegment(url);
        const isMoney = segment === PageSegment.MONEY;
        
        if (!isMoney) {
          return { isMoney: false, segmentType: null };
        }
        
        // Get sub-segment type (normalize to lowercase for consistency)
        const subSegment = classifyMoneyPageSubSegment(url);
        let segmentType = /** @type {MoneySegmentKey} */ ("all");
        
        if (subSegment === 'PRODUCT') {
          segmentType = "product";
        } else if (subSegment === 'EVENT') {
          segmentType = "event";
        } else if (subSegment === 'LANDING') {
          segmentType = "landing";
        }
        
        return { isMoney: true, segmentType };
      }
      
      // Make available globally for classifyUrlForRankingAi
      if (typeof window !== 'undefined') {
        window.classifyMoneyPage = classifyMoneyPage;
      }
      
      /**
       * Naive expected CTR curve by average position.
       * Returns decimal (01).
       * @param {number} pos - Average position
       * @returns {number}
       */
      function expectedCtrForPosition(pos) {
        if (!isFinite(pos) || pos <= 0) return 0.10;     // fallback
        if (pos <= 3) return 0.10;                       // 10% ideal for top 3
        if (pos <= 6) return 0.07;                       // 7% for 46
        if (pos <= 10) return 0.05;                      // 5% for 710
        if (pos <= 20) return 0.03;                      // 3% for 1120
        return 0.02;                                     // long tail
      }
      
      /**
       * Compute impact levels based on lost clicks (expected CTR - actual CTR)
       * @param {Array<MoneyPageMetrics>} pages
       */
      function computeImpactLevels(pages) {
        // Step 1: compute lostClicks for each page
        let maxLost = 0;
        for (const p of pages) {
          const expectedCtr = expectedCtrForPosition(p.avgPosition);
          const gap = Math.max(0, expectedCtr - (p.ctr || 0));
          const lostClicks = (p.impressions || 0) * gap;
          p._lostClicks = lostClicks;
          if (lostClicks > maxLost) maxLost = lostClicks;
        }

        if (maxLost <= 0) {
          // All pages flat  mark all as LOW impact
          for (const p of pages) {
            p.impactLevel = "LOW";
          }
          return;
        }

        // Step 2: thresholds relative to max (no magic numbers baked into data)
        const highThreshold = 0.75 * maxLost;
        const medThreshold = 0.35 * maxLost;

        for (const p of pages) {
          const lost = p._lostClicks || 0;
          if (lost >= highThreshold) p.impactLevel = "HIGH";
          else if (lost >= medThreshold) p.impactLevel = "MEDIUM";
          else p.impactLevel = "LOW";
        }
      }
      
      /**
       * Check if a page has the "key schema" for its segment type
       * @param {string} url
       * @param {MoneySegmentKey} segmentType
       * @param {Object} schemaAudit - Schema audit data with pages array
       * @returns {boolean}
       */
      function pageHasKeySchema(url, segmentType, schemaAudit) {
        if (!schemaAudit || !schemaAudit.data || !schemaAudit.data.pages) {
          return false;
        }
        
        const page = schemaAudit.data.pages.find(p => p.url === url);
        if (!page) return false;
        
        const schemaTypes = page.schemaTypes || [];
        const typesLower = schemaTypes.map(t => {
          if (typeof t === 'string') return t.toLowerCase();
          if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type.toLowerCase();
          return String(t).toLowerCase();
        }).filter(t => t && t !== '[object object]');
        
        if (segmentType === "event") {
          return typesLower.includes("event") || typesLower.includes("course");
        } else if (segmentType === "product") {
          return typesLower.includes("product") || typesLower.includes("offer");
        } else if (segmentType === "landing") {
          return typesLower.includes("itemlist") || typesLower.includes("faqpage") || typesLower.includes("article");
        }
        
        return false;
      }
      
      /**
       * Compute difficulty level based on position + schema effort
       * @param {MoneyPageMetrics} p
       * @param {boolean} hasKeySchema   // true if this page already has the main rich type it "should"
       * @returns {DifficultyLevel}
       */
      function computeDifficultyLevel(p, hasKeySchema) {
        const pos = p.avgPosition || 0;
        let base;
        if (pos > 0 && pos <= 5) base = "LOW";          // already ranking well  "easy" CTR fixes
        else if (pos <= 10) base = "MEDIUM";
        else base = "HIGH";

        // If no key schema yet for an event/product, bump difficulty by one
        if (!hasKeySchema && (p.segmentType === "event" || p.segmentType === "product")) {
          if (base === "LOW") base = "MEDIUM";
          else if (base === "MEDIUM") base = "HIGH";
        }

        return /** @type {DifficultyLevel} */ (base);
      }
      
      /**
       * Derive priority level from Impact + Difficulty
       * @param {ImpactLevel} impact
       * @param {DifficultyLevel} difficulty
       * @returns {PriorityLevel}
       */
      function derivePriorityLevel(impact, difficulty) {
        // High impact & easy/medium difficulty  HIGH priority
        if (impact === "HIGH" && (difficulty === "LOW" || difficulty === "MEDIUM")) {
          return "HIGH";
        }

        // Medium cases or high impact but high difficulty  MEDIUM
        if (
          impact === "HIGH" && difficulty === "HIGH" ||
          impact === "MEDIUM" && (difficulty === "LOW" || difficulty === "MEDIUM")
        ) {
          return "MEDIUM";
        }

        // Everything else  LOW
        return "LOW";
      }
      
      /**
       * Build MoneyPageMetrics array from topPages data
       * @param {Array<{page: string, clicks: number, impressions: number, ctr: number, position: number, title?: string}>} topPages
       * @param {Object} schemaAudit - Optional schema audit data
       * @returns {Array<MoneyPageMetrics>}
       */
      function buildMoneyPageMetrics(topPages, schemaAudit = null) {
        const result = [];

        for (const row of topPages) {
          const url = row.page || row.url;
          const { isMoney, segmentType } = classifyMoneyPage(url);
          if (!isMoney) continue;

          // CTR might be percentage (0-100) or decimal (0-1), normalize to decimal
          let ctr = row.ctr || 0;
          if (ctr > 1) ctr = ctr / 100; // Convert percentage to decimal
          
          const m = /** @type {MoneyPageMetrics} */ ({
            url,
            title: row.title || url,
            segmentType: segmentType || "all",
            clicks: row.clicks || 0,
            impressions: row.impressions || 0,
            ctr: ctr,
            avgPosition: row.position || row.avgPosition || 0,
            impactLevel: "LOW",
            difficultyLevel: "MEDIUM",
            priorityLevel: "LOW"
          });

          const hasKeySchema = pageHasKeySchema(url, m.segmentType, schemaAudit);
          m.difficultyLevel = computeDifficultyLevel(m, hasKeySchema);
          result.push(m);
        }

        computeImpactLevels(result);

        for (const p of result) {
          p.priorityLevel = derivePriorityLevel(p.impactLevel, p.difficultyLevel);
        }

        return result;
      }
      
      // Make function globally accessible immediately after definition
      // CRITICAL: Assign to window immediately so it's available when displayDashboard runs
      // This REPLACES the placeholder we defined at the top of the script
      if (typeof window !== 'undefined') {
        window.buildMoneyPageMetrics = buildMoneyPageMetrics;
        // Also assign to global scope as fallback
        if (typeof globalThis !== 'undefined') {
          globalThis.buildMoneyPageMetrics = buildMoneyPageMetrics;
        }
        // Debug: Log that function is now available
        console.log('[Money Pages]  buildMoneyPageMetrics FULL IMPLEMENTATION assigned to window (replaced placeholder)');
      }
      
      /**
       * Build per-segment summaries for Money Pages (for 12-month KPI tracking)
       * @param {Array<MoneyPageMetrics>} moneyPages
       * @param {Object} behaviourScores - Optional behaviour scores by segment
       * @returns {MoneySegmentMetricsByAudit}
       */
      function buildMoneySegmentSummary(moneyPages, behaviourScores = {}) {
        // Ensure moneyPages is an array (default to empty array)
        const pages = Array.isArray(moneyPages) ? moneyPages : [];
        
        const segments = {
          allMoney: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
          landingPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
          eventPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
          productPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 }
        };

        const groups = {
          allMoney: pages,
          landingPages: pages.filter(p => p.segmentType === "landing"),
          eventPages: pages.filter(p => p.segmentType === "event"),
          productPages: pages.filter(p => p.segmentType === "product")
        };

        for (const [key, groupPages] of Object.entries(groups)) {
          if (!groupPages || !groupPages.length) continue;
          const clicks = groupPages.reduce((s, p) => s + (p.clicks || 0), 0);
          const impressions = groupPages.reduce((s, p) => s + (p.impressions || 0), 0);
          const ctr = impressions > 0 ? clicks / impressions : 0;
          const avgPosition = groupPages.length > 0
            ? groupPages.reduce((s, p) => s + (p.avgPosition || 0), 0) / groupPages.length
            : 0;

          segments[key].clicks = clicks;
          segments[key].impressions = impressions;
          segments[key].ctr = ctr;
          segments[key].avgPosition = avgPosition;
          // Use behaviour score from parameter if available, otherwise 0
          segments[key].behaviourScore = behaviourScores[key] || behaviourScores[key.toLowerCase()] || 0;
        }

        // Always return a valid structure (never null)
        return segments;
      }
      
      // Compute money pages behaviour score (for Authority overlay)
      // Define globally to ensure accessibility from event handlers
      window.computeMoneyPagesBehaviour = function(gscQueries, moneyPages, useAllPositions = false) {
        if (!gscQueries || !gscQueries.length || !moneyPages || !moneyPages.length) {
          debugLog(` computeMoneyPagesBehaviour: Missing data - gscQueries=${!!gscQueries}(${gscQueries?.length || 0}), moneyPages=${!!moneyPages}(${moneyPages?.length || 0})`, 'warn');
          return null;
        }

        // Normalize URLs: remove trailing slash, convert to lowercase, remove protocol if present
        const normalizeUrl = (url) => {
          if (!url) return '';
          let normalized = url.toString().trim().toLowerCase();
          // Remove protocol (http:// or https://)
          normalized = normalized.replace(/^https?:\/\//, '');
          // Remove trailing slash
          normalized = normalized.replace(/\/$/, '');
          return normalized;
        };

        const moneySet = new Set(
          moneyPages.map(p => {
            const url = normalizeUrl(p.url || p.page || '');
            return url;
          })
        );

        debugLog(` computeMoneyPagesBehaviour: Created moneySet with ${moneySet.size} URLs. useAllPositions=${useAllPositions}. Sample URLs: ${Array.from(moneySet).slice(0, 3).join(', ')}`, 'info');

        let clicks = 0;
        let impressions = 0;
        let top10Clicks = 0;
        let top10Impressions = 0;
        let weightedPosSum = 0;
        let weightedPosImps = 0;
        let matchedUrls = 0;
        let unmatchedUrls = 0;
        let filteredOutByPosition = 0;

        gscQueries.forEach(row => {
          const url = normalizeUrl(row.page || row.url || '');
          if (!moneySet.has(url)) {
            unmatchedUrls++;
            return;
          }
          matchedUrls++;

          const pos = typeof row.position === 'number'
            ? row.position
            : (row.avgPosition || null);
          const imps = row.impressions || 0;
          const cls = row.clicks || 0;

          // For filtered calculations, include all positions; otherwise only 1-20 to match Authority
          if (!imps || !pos || pos <= 0) return;
          if (!useAllPositions && pos > 20) {
            filteredOutByPosition++;
            return;
          }

          clicks += cls;
          impressions += imps;

          weightedPosSum += pos * imps;
          weightedPosImps += imps;
          if (pos <= 10) {
            top10Clicks += cls;
            top10Impressions += imps;
          }
        });

        debugLog(` computeMoneyPagesBehaviour: Matched ${matchedUrls} URLs, unmatched ${unmatchedUrls} URLs, filtered by position ${filteredOutByPosition}. Total impressions: ${impressions}, clicks: ${clicks}`, 'info');

        if (!impressions || !weightedPosImps) {
          debugLog(` computeMoneyPagesBehaviour: No valid impressions (${impressions}) or weighted positions (${weightedPosImps}), returning null`, 'warn');
          return null;
        }

        const siteCtr = clicks / impressions;
        const top10Ctr = top10Impressions > 0 ? (top10Clicks / top10Impressions) : 0;
        const avgPos = weightedPosSum / weightedPosImps;
        const top10Share = impressions > 0 ? (top10Impressions / impressions) : 0;

        // Reuse existing Behaviour score calculation (same as Authority)
        // For filtered calculations, include all positions; otherwise only 1-20
        const rankingQueries = gscQueries.filter(row => {
          const url = normalizeUrl(row.page || row.url || '');
          if (!moneySet.has(url)) return false;
          const pos = typeof row.position === 'number' ? row.position : (row.avgPosition || null);
          if (!pos || pos <= 0 || !(row.impressions || 0)) return false;
          if (!useAllPositions && pos > 20) return false;
          return true;
        });

        const behaviourScore = computeBehaviourScoreRaw(rankingQueries);

        return {
          score: behaviourScore,
          siteCtr,
          top10Ctr,
          avgPos,
          top10Share,
          clicks,
          impressions
        };
      };

      // Fallback: compute Money Pages behaviour from page-level aggregates (no queryPages required)
      // Used when queryPages is missing/truncated or URLs don't match.
      function computeMoneyPagesBehaviourFromPageAggregates(moneyPages) {
        if (!Array.isArray(moneyPages) || moneyPages.length === 0) return null;

        let clicks = 0;
        let impressions = 0;
        let weightedPosSum = 0;
        let weightedPosImps = 0;
        let top10Clicks = 0;
        let top10Impressions = 0;

        moneyPages.forEach(p => {
          const imps = p.impressions || 0;
          const cls = p.clicks || 0;
          const pos = typeof p.avgPosition === 'number' ? p.avgPosition : (p.avgPosition ? parseFloat(p.avgPosition) : null);
          if (!imps || !pos || pos <= 0) return;

          clicks += cls;
          impressions += imps;
          weightedPosSum += pos * imps;
          weightedPosImps += imps;

          // Approximate top-10 using avgPosition (best available without query-level data)
          if (pos <= 10) {
            top10Clicks += cls;
            top10Impressions += imps;
          }
        });

        if (!impressions || !weightedPosImps) return null;

        const siteCtr = clicks / impressions;
        const top10Ctr = top10Impressions > 0 ? (top10Clicks / top10Impressions) : 0;
        const avgPos = weightedPosSum / weightedPosImps;
        const top10Share = impressions > 0 ? (top10Impressions / impressions) : 0;

        // Map CTR to score using same bands as Authority behaviour
        const scoreCtrAll = Math.min(siteCtr / 0.05, 1) * 100;    // 05% => 0100
        const scoreCtrTop10 = Math.min(top10Ctr / 0.10, 1) * 100; // 010% => 0100
        const behaviourScore = 0.5 * scoreCtrAll + 0.5 * scoreCtrTop10;

        return {
          score: behaviourScore,
          siteCtr,
          top10Ctr,
          avgPos,
          top10Share,
          clicks,
          impressions
        };
      }
      
      // ============================================
      // STEP 1: Build pageTotalsByKey (single source of truth for page-level GSC data)
      // ============================================
      // Fetch page-level data from GSC API (unfiltered, all positions)
      // This matches GSC "Pages" tab totals exactly
      // Always uses rolling "last 28d" range for consistency
      // CRITICAL: During a fresh audit run, ALWAYS fetch fresh data from GSC API
      // Only use persisted data when explicitly loading a historical audit from Supabase
      let pageTotalsByKey = new Map();
      let pageLevelDataFetched = false;
      let gscRange = null;
      
      // CRITICAL: During a fresh audit run, ALWAYS fetch fresh data from GSC API
      // Only use persisted data when loading historical audits from Supabase
      // Check global flag set by runAudit() to determine if we're in a fresh audit
      const isFreshAudit = window._isFreshAuditRun === true;
      
      // Try to load from Supabase first (preferred source)
      if (!isFreshAudit) {
        try {
          const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
          if (propertyUrl) {
            debugLog(` Loading page metrics from Supabase...`, 'info');
            const supabaseResponse = await fetch(apiUrl(`/api/supabase/get-gsc-page-metrics?siteUrl=${encodeURIComponent(propertyUrl)}`));
            
            if (supabaseResponse.ok) {
              const supabaseData = await supabaseResponse.json();
              if (supabaseData.pages && supabaseData.pages.length > 0) {
                debugLog(` Loaded ${supabaseData.pages.length} page metrics from Supabase`, 'success');
                
                // Use the date range from the first page (all should have same range)
                const firstPage = supabaseData.pages[0];
                gscRange = {
                  startDate: firstPage.date_start,
                  endDate: firstPage.date_end
                };
                
                supabaseData.pages.forEach(page => {
                  // page.page_url is stored as full normalized URL (e.g., "https://www.alanranger.com/path")
                  // Use it directly with normalizeGscPageKey for consistency
                  const key = normalizeGscPageKey(page.page_url);
                  
                  pageTotalsByKey.set(key, {
                    url: page.page_url,
                    clicks: parseFloat(page.clicks_28d) || 0,
                    impressions: parseFloat(page.impressions_28d) || 0,
                    ctr: parseFloat(page.ctr_28d) || 0,
                    position: page.position_28d ? parseFloat(page.position_28d) : null
                  });
                });
                pageLevelDataFetched = true;
              }
            }
          }
        } catch (supabaseError) {
          debugLog(` Error loading from Supabase: ${supabaseError.message}, will try localStorage fallback`, 'warn');
        }
        
        // Fallback to localStorage if Supabase didn't have data
        if (!pageLevelDataFetched) {
          try {
            const saved = loadAuditResultsSync();
            if (saved && saved.scores) {
              // Check scores.moneyPages namespace first (new format)
              const moneyPagesData = saved.scores.moneyPages || {};
              if (moneyPagesData.gscPageTotals28d && Array.isArray(moneyPagesData.gscPageTotals28d) && moneyPagesData.gscPageTotals28d.length > 0) {
                debugLog(` Using persisted page totals from saved audit (${moneyPagesData.gscPageTotals28d.length} pages)`, 'success');
                gscRange = moneyPagesData.gscRange || getGscDateRange(28, 2);
                moneyPagesData.gscPageTotals28d.forEach(pageData => {
                  const key = normalizeGscPageKey(pageData.url);
                  const position = (pageData.position != null && pageData.position !== undefined && !isNaN(parseFloat(pageData.position)) && parseFloat(pageData.position) > 0) 
                    ? parseFloat(pageData.position) 
                    : null;
                  pageTotalsByKey.set(key, {
                    url: pageData.url,
                    clicks: pageData.clicks || 0,
                    impressions: pageData.impressions || 0,
                    ctr: pageData.ctr || 0,
                    position: position
                  });
                });
                pageLevelDataFetched = true;
              } else if (saved.scores.moneyPagesMetrics && saved.scores.moneyPagesMetrics.gscPageTotals28d && Array.isArray(saved.scores.moneyPagesMetrics.gscPageTotals28d)) {
                // Fallback: check moneyPagesMetrics directly (backwards compatibility)
                debugLog(` Using persisted page totals from moneyPagesMetrics (${saved.scores.moneyPagesMetrics.gscPageTotals28d.length} pages)`, 'success');
                gscRange = saved.scores.moneyPagesMetrics.gscRange || getGscDateRange(28, 2);
                saved.scores.moneyPagesMetrics.gscPageTotals28d.forEach(pageData => {
                  const key = normalizeGscPageKey(pageData.url);
                  const position = (pageData.position != null && pageData.position !== undefined && !isNaN(parseFloat(pageData.position)) && parseFloat(pageData.position) > 0) 
                    ? parseFloat(pageData.position) 
                    : null;
                  pageTotalsByKey.set(key, {
                    url: pageData.url,
                    clicks: pageData.clicks || 0,
                    impressions: pageData.impressions || 0,
                    ctr: pageData.ctr || 0,
                    position: position
                  });
                });
                pageLevelDataFetched = true;
              }
            }
          } catch (persistError) {
            debugLog(` Error loading persisted page totals: ${persistError.message}, will fetch fresh data`, 'warn');
          }
        }
      } else {
        debugLog(` Fresh audit run detected - will fetch fresh page-level data from GSC API`, 'info');
      }
      
      // If persisted data not available (or we're in a fresh audit), fetch from GSC API
      if (!pageLevelDataFetched) {
        try {
          const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
          
          if (propertyUrl) {
          // Force Money Pages to always use a rolling "last 28d" range for page totals
          // Rolling 28d: endDate = yesterday, startDate = endDate - 27 days (inclusive = 28 days total)
          // Use endOffsetDays=1 for yesterday (GSC UI uses yesterday as end date)
          const endDate = new Date();
          endDate.setDate(endDate.getDate() - 1); // Yesterday
          endDate.setHours(0, 0, 0, 0);
          const startDate = new Date(endDate);
          startDate.setDate(startDate.getDate() - 27); // 27 days back = 28 days total (inclusive)
          startDate.setHours(0, 0, 0, 0);
          
          gscRange = {
            startDate: startDate.toISOString().split('T')[0],
            endDate: endDate.toISOString().split('T')[0]
          };
          debugLog(` Fetching page-level GSC data (unfiltered, all positions) for last 28d: ${gscRange.startDate} to ${gscRange.endDate}...`, 'info');
          
          debugLog(` Calling GSC page-level API: ${apiUrl('/api/aigeo/gsc-page-level')}`, 'info');
          debugLog(` Request body: propertyUrl=${propertyUrl}, startDate=${gscRange.startDate}, endDate=${gscRange.endDate}`, 'info');
          
          const pageLevelResponse = await fetch(apiUrl('/api/aigeo/gsc-page-level'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              propertyUrl,
              startDate: gscRange.startDate,
              endDate: gscRange.endDate,
              dimensions: ['page'],
              rowLimit: 25000
            })
          });
          
          debugLog(` GSC page-level API response status: ${pageLevelResponse.status} ${pageLevelResponse.statusText}`, 'info');
          
          if (pageLevelResponse.ok) {
            const pageLevelData = await pageLevelResponse.json();
            debugLog(` GSC page-level API response: status=${pageLevelData.status}, hasData=${!!pageLevelData.data}, rowsCount=${pageLevelData.data?.rows?.length || 0}`, 'info');
            
            if (pageLevelData.status !== 'ok') {
              debugLog(` GSC page-level API returned error status: ${JSON.stringify(pageLevelData)}`, 'warn');
            }
            
            if (pageLevelData.status === 'ok' && pageLevelData.data && Array.isArray(pageLevelData.data.rows)) {
              // Build pageTotalsByKey map from page-level data using normalized page key
              let landscapePageFound = false;
              for (const row of (pageLevelData.data.rows || [])) {
                const rawPageUrl = row.keys?.[0];
                if (!rawPageUrl) continue;

                const key = normalizeGscPageKey(rawPageUrl);
                const clicks = row.clicks || 0;
                const impressions = row.impressions || 0;
                const ctr = row.ctr != null ? (row.ctr > 1 ? row.ctr / 100 : row.ctr) : (impressions > 0 ? clicks / impressions : 0);
                // Position: use null if not provided (0 is not a valid position, positions start at 1)
                const position = (row.position != null && row.position !== undefined && !isNaN(parseFloat(row.position)) && parseFloat(row.position) > 0) 
                  ? parseFloat(row.position) 
                  : null;

                // Debug: Log specific URL if it matches the one we're looking for
                if (rawPageUrl.includes('landscape-photography-workshops') || key.includes('landscape-photography-workshops')) {
                  debugLog(` Found landscape-photography-workshops in page-level API: rawUrl=${rawPageUrl}, normalizedKey=${key}, clicks=${clicks}, impressions=${impressions}, ctr=${(ctr * 100).toFixed(2)}%, position=${position}`, 'info');
                  landscapePageFound = true;
                }

                pageTotalsByKey.set(key, {
                  url: rawPageUrl,
                  clicks: clicks,
                  impressions: impressions,
                  ctr: ctr, // Store as ratio (0-1)
                  position: position
                });
              }
              
              if (!landscapePageFound) {
                debugLog(` landscape-photography-workshops NOT found in page-level API response. Total pages fetched: ${pageLevelData.data.rows?.length || 0}`, 'warn');
                // Log first 5 URLs for debugging
                const sampleUrls = (pageLevelData.data.rows || []).slice(0, 5).map(r => r.keys?.[0] || 'N/A');
                debugLog(` Sample URLs from API: ${sampleUrls.join(', ')}`, 'info');
              }
              
              // Count pages with valid position data
              let pagesWithPosition = 0;
              let totalPositionSum = 0;
              pageTotalsByKey.forEach((metrics, key) => {
                if (metrics.position !== null && metrics.position !== undefined && !isNaN(metrics.position) && metrics.position > 0) {
                  pagesWithPosition++;
                  totalPositionSum += metrics.position;
                }
              });
              const avgPosition = pagesWithPosition > 0 ? (totalPositionSum / pagesWithPosition).toFixed(2) : 'N/A';
              debugLog(` Built pageTotalsByKey from GSC page-level API: ${pageTotalsByKey.size} pages (${pagesWithPosition} with position data, avg=${avgPosition})`, 'success');
              
              // Save to Supabase for persistence
              // This will be called after audit is saved, using the audit_date as run_id
              // Store the data temporarily for later saving
              window._pendingPageMetrics = {
                pages: Array.from(pageTotalsByKey.values()).map(metrics => ({
                  url: metrics.url,
                  page_url: metrics.url, // Will be normalized in API
                  clicks: metrics.clicks,
                  impressions: metrics.impressions,
                  ctr: metrics.ctr,
                  position: metrics.position // Can be null if not available
                })),
                gscRange: gscRange,
                propertyUrl: propertyUrl
              };
              const pagesWithPositionInPending = window._pendingPageMetrics.pages.filter(p => p.position !== null && p.position !== undefined && !isNaN(p.position) && p.position > 0).length;
              debugLog(` Prepared ${window._pendingPageMetrics.pages.length} page metrics for Supabase save (${pagesWithPositionInPending} with position data, will save after audit completes)`, 'info');
              
              pageLevelDataFetched = true;
            } else if (pageLevelData.status === 'ok' && pageLevelData.data && Array.isArray(pageLevelData.data.pages)) {
              // Fallback: handle old API response format
              pageLevelData.data.pages.forEach(page => {
                const rawPageUrl = page.page || page.url || '';
                if (!rawPageUrl) return;

                const key = normalizeGscPageKey(rawPageUrl);
                const clicks = page.clicks || 0;
                const impressions = page.impressions || 0;
                const ctr = page.ctr != null ? (page.ctr > 1 ? page.ctr / 100 : page.ctr) : (impressions > 0 ? clicks / impressions : 0);
                // Position: use null if not provided (0 is not a valid position, positions start at 1)
                const rawPosition = page.position || page.avgPosition;
                const position = (rawPosition != null && rawPosition !== undefined && !isNaN(parseFloat(rawPosition)) && parseFloat(rawPosition) > 0) 
                  ? parseFloat(rawPosition) 
                  : null;

                pageTotalsByKey.set(key, {
                  url: rawPageUrl,
                  clicks: clicks,
                  impressions: impressions,
                  ctr: ctr,
                  position: position
                });
              });
              
              debugLog(` Built pageTotalsByKey from GSC page-level API (legacy format): ${pageTotalsByKey.size} pages`, 'success');
              pageLevelDataFetched = true;
            } else {
              debugLog(` GSC page-level API did not return page data in expected format. Response structure: ${JSON.stringify(Object.keys(pageLevelData.data || {}))}`, 'error');
              debugLog(` CRITICAL: Cannot use queryPages fallback for Money Pages - it's filtered to position 1-20 and will show incorrect totals!`, 'error');
            }
          } else {
            const errorText = await pageLevelResponse.text().catch(() => 'Unknown error');
            debugLog(` Failed to fetch page-level data from GSC API (${pageLevelResponse.status}): ${errorText}`, 'error');
            debugLog(` CRITICAL: Cannot use queryPages fallback for Money Pages - it's filtered to position 1-20 and will show incorrect totals!`, 'error');
          }
          } else {
            debugLog(` No property URL available, cannot fetch page-level GSC data`, 'warn');
          }
        } catch (pageLevelError) {
          debugLog(` Error fetching page-level GSC data: ${pageLevelError.message}`, 'error');
          debugLog(` CRITICAL: Cannot use queryPages fallback for Money Pages - it's filtered to position 1-20 and will show incorrect totals!`, 'error');
        }
      }
      
      // CRITICAL: Do NOT fall back to queryPages aggregation for Money Pages
      // queryPages is filtered to position 1-20 and will give incorrect page totals
      // If page-level API failed, we must log an error and use empty data rather than wrong data
      if (!pageLevelDataFetched) {
        debugLog(` CRITICAL: Page-level GSC data not available. Money Pages metrics will be incomplete.`, 'error');
        debugLog(` This means the /api/aigeo/gsc-page-level API either failed or returned no data.`, 'error');
        debugLog(` Money Pages will show zero/incorrect metrics until page-level data is available.`, 'error');
        debugLog(` Check Vercel function logs for /api/aigeo/gsc-page-level to diagnose the issue.`, 'error');
      }
      
      // REMOVED: Fallback to queryPages aggregation (this was causing incorrect data)
      // The old fallback code has been removed to prevent showing filtered (position 1-20) data as page totals
      
      // Store pageTotalsByKey globally for use in Money Pages and other modules
      window.pageTotalsByKey = pageTotalsByKey;
      // Also store as pageTotalsByUrl for backwards compatibility
      window.pageTotalsByUrl = pageTotalsByKey;
      
      // Compute money pages metrics if we have queryPages data
      let moneyPagesMetrics = null;
      if (queryPages && queryPages.length > 0) {
          // Aggregate all pages from queryPages (not just top 10) - KEEP for secondary analytics only (pos 1-20 filtered, not used for Money Pages totals)
        const pageMap = new Map();
        queryPages.forEach(row => {
          const url = row.page || row.url || '';
          if (!url) return;
          
          if (!pageMap.has(url)) {
            pageMap.set(url, {
              url: url,
              clicks: 0,
              impressions: 0,
              totalPositionWeight: 0
            });
          }
          
          const page = pageMap.get(url);
          page.clicks += row.clicks || 0;
          page.impressions += row.impressions || 0;
          page.totalPositionWeight += (row.position || 0) * (row.impressions || 0);
        });
        
          // Convert to topPages format (for secondary analytics only - pos 1-20 filtered, not used for Money Pages totals)
        const allTopPages = Array.from(pageMap.values())
          .map(page => ({
            url: page.url,
            clicks: page.clicks,
            impressions: page.impressions,
            ctr: page.impressions > 0 ? (page.clicks / page.impressions) : 0,
            avgPosition: page.impressions > 0 ? page.totalPositionWeight / page.impressions : 0,
            position: page.impressions > 0 ? page.totalPositionWeight / page.impressions : 0,
            _source: 'queryPages_pos1_20' // Flag to indicate this is filtered data
          }))
          .filter(page => page.impressions > 0); // Only pages with impressions
        
        // Compute site aggregates
        const siteAgg = computeSiteAggregateFromTopPages(allTopPages);
        
        // Build page metadata lookup from schema audit if available
        const pageMetadataLookup = new Map();
        if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
          const schemaData = schemaAudit.data;
          // Use the new pages array with metadata (title, metaDescription)
          if (schemaData.pages && Array.isArray(schemaData.pages)) {
            schemaData.pages.forEach(page => {
              if (page.url) {
                pageMetadataLookup.set(page.url, {
                  title: page.title || null,
                  metaDescription: page.metaDescription || null
                });
              }
            });
          }
          // Fallback to old structure for backwards compatibility
          if (schemaData.pagesWithSchema && Array.isArray(schemaData.pagesWithSchema) && pageMetadataLookup.size === 0) {
            schemaData.pagesWithSchema.forEach(page => {
              if (page.url) {
                pageMetadataLookup.set(page.url, {
                  title: page.title || null,
                  metaDescription: page.metaDescription || page.description || null
                });
              }
            });
          }
          // Also check missing pages (fallback)
          if (schemaData.missingSchemaPages && Array.isArray(schemaData.missingSchemaPages)) {
            schemaData.missingSchemaPages.forEach(page => {
              const url = typeof page === 'string' ? page : page.url;
              if (url && !pageMetadataLookup.has(url)) {
                pageMetadataLookup.set(url, {
                  title: typeof page === 'object' ? (page.title || null) : null,
                  metaDescription: typeof page === 'object' ? (page.metaDescription || page.description || null) : null
                });
              }
            });
          }
        }
        
        // ============================================
        // STEP 2: Update Money Pages to use pageTotalsByUrl (page-level totals, not filtered)
        // ============================================
        // Compute money pages metrics
        // Use CSV as source of truth for all pages, then match GSC page-level data to CSV URLs
        // This ensures we segment ALL pages (433 URLs) not just those in GSC data (78 pages)
          // Use page-level totals (unfiltered, all positions) from pageTotalsByKey to match GSC "Pages" tab exactly
        
        // Fetch CSV and segment all URLs
        // First check for manually loaded URL list, then try GitHub/fallback
        let csvUrls = [];
        try {
          // Check for manually loaded URL list first
          const manualUrlList = localStorage.getItem('manual_url_list');
          if (manualUrlList) {
            try {
              csvUrls = JSON.parse(manualUrlList);
              debugLog(` Using manual URL list: ${csvUrls.length} URLs`, 'info');
            } catch (parseErr) {
              debugLog(` Failed to parse manual URL list: ${parseErr.message}`, 'warn');
            }
          }
          
          // If no manual list, try fetching from GitHub/fallback
          if (csvUrls.length === 0) {
            csvUrls = await fetchAndParseSiteUrlsCsv();
            debugLog(` Fetched ${csvUrls.length} URLs from CSV (GitHub/fallback)`, 'info');
          }
          
          // Debug: Check if landscape page is in CSV
          const landscapeInCsv = csvUrls.find(u => u.includes('landscape-photography-workshops'));
          if (landscapeInCsv) {
            debugLog(` Landscape page found in CSV: "${landscapeInCsv}"`, 'info');
          } else {
            debugLog(` Landscape page NOT found in CSV! Total CSV URLs: ${csvUrls.length}`, 'warn');
            // Log sample CSV URLs for debugging
            const sampleCsvUrls = csvUrls.slice(0, 10);
            debugLog(` Sample CSV URLs: ${sampleCsvUrls.join(', ')}`, 'info');
          }
          
          // Segment all CSV URLs and match with pageTotalsByKey (page-level totals)
          const allCsvPages = csvUrls.map(url => {
            const segment = classifyPageSegment(url);
            const pageKey = normalizeGscPageKey(url);
            
            // Get page-level totals from pageTotalsByKey (unfiltered, matches GSC page totals)
            const gscMetrics = pageTotalsByKey.get(pageKey) || {
              clicks: 0,
              impressions: 0,
              ctr: 0,
              position: 0
            };
            
            // Debug: Log if this is the URL we're looking for
            if (url.includes('landscape-photography-workshops') || pageKey.includes('landscape-photography-workshops')) {
              debugLog(` Money Pages CSV lookup: csvUrl=${url}, normalizedKey=${pageKey}, found=${pageTotalsByKey.has(pageKey)}, clicks=${gscMetrics.clicks}, impressions=${gscMetrics.impressions}, ctr=${(gscMetrics.ctr * 100).toFixed(2)}%, position=${gscMetrics.position}`, 'info');
              debugLog(` CSV URL format: "${url}", normalized to: "${pageKey}"`, 'info');
              
              // Also log all keys in pageTotalsByKey that contain 'landscape' for debugging
              const matchingKeys = Array.from(pageTotalsByKey.keys()).filter(k => k.includes('landscape') || k.includes('workshop'));
              if (matchingKeys.length > 0) {
                debugLog(` Available keys containing 'landscape' or 'workshop': ${matchingKeys.join(', ')}`, 'info');
                // Also log the actual data for these keys
                matchingKeys.forEach(k => {
                  const data = pageTotalsByKey.get(k);
                  if (data) {
                    debugLog(` Key "${k}": clicks=${data.clicks}, impressions=${data.impressions}, ctr=${(data.ctr * 100).toFixed(2)}%, position=${data.position}, rawUrl=${data.url}`, 'info');
                  }
                });
              } else {
                debugLog(` No keys found containing 'landscape' or 'workshop'. Total keys in pageTotalsByKey: ${pageTotalsByKey.size}`, 'warn');
                // Log first 20 keys for debugging
                const firstKeys = Array.from(pageTotalsByKey.keys()).slice(0, 20);
                debugLog(` First 20 keys in pageTotalsByKey: ${firstKeys.join(', ')}`, 'info');
              }
            }
            
            if (gscMetrics.impressions > 0 || gscMetrics.clicks > 0) {
              // Use page-level totals (matches GSC "Pages" tab exactly)
              return {
                url: url,
                page: url, // Also set page property for compatibility
                segment: segment,
                clicks: gscMetrics.clicks || 0,
                impressions: gscMetrics.impressions || 0,
                ctr: gscMetrics.ctr || 0, // Already a ratio (0-1)
                avgPosition: gscMetrics.position || null,
                position: gscMetrics.position || null,
                _source: 'pageTotalsByKey' // Flag to indicate this is from page-level data
              };
            } else {
              // No GSC data for this URL (zero impressions or never appeared in search)
              return {
                url: url,
                page: url, // Also set page property for compatibility
                segment: segment,
                clicks: 0,
                impressions: 0,
                ctr: 0,
                avgPosition: null,
                position: null,
                _source: 'no_data'
              };
            }
          });
          
          // Filter to money pages only and compute metrics
          const moneyPagesFromCsv = allCsvPages.filter(page => page.segment === PageSegment.MONEY);
          debugLog(` Segmented ${moneyPagesFromCsv.length} money pages from CSV (out of ${csvUrls.length} total URLs)`, 'info');
          debugLog(` Using pageTotalsByUrl for Money Pages metrics (matches GSC page-level totals)`, 'success');
          
          // Recompute site aggregates from pageTotalsByKey (all pages, not just money pages)
          let siteAggFromPageTotals = { totalClicks: 0, totalImpressions: 0, avgCtr: 0, avgPosition: null };
          let totalPositionWeight = 0;
          pageTotalsByKey.forEach(gscMetrics => {
            siteAggFromPageTotals.totalClicks += gscMetrics.clicks || 0;
            siteAggFromPageTotals.totalImpressions += gscMetrics.impressions || 0;
            if (gscMetrics.position != null && gscMetrics.impressions > 0) {
              totalPositionWeight += gscMetrics.position * gscMetrics.impressions;
            }
          });
          siteAggFromPageTotals.avgCtr = siteAggFromPageTotals.totalImpressions > 0 
            ? siteAggFromPageTotals.totalClicks / siteAggFromPageTotals.totalImpressions 
            : 0;
          siteAggFromPageTotals.avgPosition = siteAggFromPageTotals.totalImpressions > 0
            ? totalPositionWeight / siteAggFromPageTotals.totalImpressions
            : null;
          
          moneyPagesMetrics = computeMoneyPagesMetrics(
            moneyPagesFromCsv, // Use CSV URLs with page-level GSC data from pageTotalsByUrl
            classifyPageSegment,
            siteAggFromPageTotals, // Use site aggregates from page-level data
            pageMetadataLookup, // Pass metadata lookup
            schemaAudit // Pass schema audit data to check for schema presence
          );
        } catch (csvError) {
          debugLog(` Failed to fetch CSV, falling back to pageTotalsByKey only: ${csvError.message}`, 'warn');
          // Fallback: Build pages from pageTotalsByKey directly (no CSV)
          const pagesFromPageTotals = Array.from(pageTotalsByKey.entries()).map(([pageKey, gscMetrics]) => {
            // Use the stored URL from gscMetrics, or reconstruct from pageKey
            let fullUrl = gscMetrics.url || pageKey;
            if (!fullUrl.startsWith('http')) {
              const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || 'https://www.alanranger.com';
              fullUrl = propertyUrl.replace(/\/$/, '') + (pageKey.startsWith('/') ? pageKey : '/' + pageKey);
            }
            
            return {
              url: fullUrl,
              page: fullUrl,
              segment: classifyPageSegment(fullUrl),
              clicks: gscMetrics.clicks || 0,
              impressions: gscMetrics.impressions || 0,
              ctr: gscMetrics.ctr || 0,
              avgPosition: gscMetrics.position || null,
              position: gscMetrics.position || null,
              _source: 'pageTotalsByKey_fallback'
            };
          }).filter(page => page.segment === PageSegment.MONEY);
          
          // Recompute site aggregates from pageTotalsByKey
          let siteAggFromPageTotals = { totalClicks: 0, totalImpressions: 0, avgCtr: 0, avgPosition: null };
          let totalPositionWeight = 0;
          pageTotalsByKey.forEach(gscMetrics => {
            siteAggFromPageTotals.totalClicks += gscMetrics.clicks || 0;
            siteAggFromPageTotals.totalImpressions += gscMetrics.impressions || 0;
            if (gscMetrics.position != null && gscMetrics.impressions > 0) {
              totalPositionWeight += gscMetrics.position * gscMetrics.impressions;
            }
          });
          siteAggFromPageTotals.avgCtr = siteAggFromPageTotals.totalImpressions > 0 
            ? siteAggFromPageTotals.totalClicks / siteAggFromPageTotals.totalImpressions 
            : 0;
          siteAggFromPageTotals.avgPosition = siteAggFromPageTotals.totalImpressions > 0
            ? totalPositionWeight / siteAggFromPageTotals.totalImpressions
            : null;
          
          moneyPagesMetrics = computeMoneyPagesMetrics(
            pagesFromPageTotals,
            classifyPageSegment,
            siteAggFromPageTotals,
            pageMetadataLookup,
            schemaAudit
          );
        }
        
        // Compute money pages behaviour score
        const moneyPagesList = moneyPagesMetrics.rows || [];
        // Use queryPages for behaviour calculation (all GSC query+page data)
        const allGSCPages = queryPages || [];
        const moneyBehaviour = window.computeMoneyPagesBehaviour(
          allGSCPages, // Use all GSC pages for behaviour calculation
          moneyPagesList
        );
        moneyPagesMetrics.behaviour = moneyBehaviour;
        
        // Add page-level GSC totals (filtered to money pages) for persistence
        // This ensures Money Pages metrics remain consistent when loading from history
        const moneyPagesGscTotals28d = moneyPagesList.map(mp => {
          const k = normalizeGscPageKey(mp.url);
          const m = pageTotalsByKey.get(k);
          
          // Debug: Log if this is the landscape page
          if (mp.url.includes('landscape-photography-workshops') || k.includes('landscape-photography-workshops')) {
            debugLog(` Saving landscape page to DB: mp.url=${mp.url}, normalizedKey=${k}, foundInPageTotals=${!!m}, clicks=${m?.clicks ?? 0}, impressions=${m?.impressions ?? 0}, ctr=${m?.ctr ? (m.ctr * 100).toFixed(2) : 0}%, position=${m?.position ?? 0}`, 'info');
            if (!m) {
              debugLog(` landscape page NOT found in pageTotalsByKey! Total keys: ${pageTotalsByKey.size}`, 'warn');
              // Log similar keys
              const similarKeys = Array.from(pageTotalsByKey.keys()).filter(key => key.includes('landscape') || key.includes('workshop'));
              if (similarKeys.length > 0) {
                debugLog(` Similar keys in pageTotalsByKey: ${similarKeys.join(', ')}`, 'info');
              }
            }
          }
          
          return {
            url: mp.url,
            clicks: m?.clicks ?? 0,
            impressions: m?.impressions ?? 0,
            ctr: m?.ctr ?? 0,
            position: m?.position ?? 0
          };
        });
        
        // Store GSC range and page totals in moneyPagesMetrics for persistence
        moneyPagesMetrics.gscRange = gscRange || getGscDateRange(28, 2);
        moneyPagesMetrics.gscPageTotals28d = moneyPagesGscTotals28d;
        
        debugLog(`Money Pages Metrics: ${moneyPagesMetrics.rows.length} money pages found, ${moneyPagesMetrics.overview.moneyClicks} clicks, ${moneyPagesMetrics.overview.moneyImpressions} impressions`, 'info');
        if (moneyBehaviour) {
          debugLog(`Money Pages Behaviour: score=${moneyBehaviour.score != null ? moneyBehaviour.score.toFixed(1) : 'N/A'}, CTR=${moneyBehaviour.siteCtr != null ? (moneyBehaviour.siteCtr * 100).toFixed(2) : 'N/A'}%, Top-10 CTR=${moneyBehaviour.top10Ctr != null ? (moneyBehaviour.top10Ctr * 100).toFixed(2) : 'N/A'}%`, 'info');
        }
        
        // Build Money Page Priority Matrix data
        // Convert moneyPagesMetrics.rows to format expected by buildMoneyPageMetrics
        const topPagesForPriority = moneyPagesMetrics.rows.map(row => ({
          page: row.url,
          url: row.url,
          clicks: row.clicks || 0,
          impressions: row.impressions || 0,
          ctr: (row.ctr || 0) * 100, // Convert to percentage for buildMoneyPageMetrics
          position: row.avgPosition || 0,
          avgPosition: row.avgPosition || 0,
          title: row.title || row.url
        }));
        
        // Store priority matrix data globally
        window.moneyPagePriorityData = buildMoneyPageMetrics(topPagesForPriority, schemaAudit);
        debugLog(`Money Pages Priority: Built ${window.moneyPagePriorityData.length} priority entries`, 'info');
        
        // Build segment summary for Supabase storage
        // CRITICAL: Use moneyPagesMetrics.rows (has clicks/impressions/avgPosition/segmentType) not moneyPagePriorityData
        const behaviourScoresBySegment = {};
        if (moneyBehaviour && moneyBehaviour.bySegment) {
          behaviourScoresBySegment.allMoney = moneyBehaviour.bySegment.money?.behaviour?.score || 0;
          behaviourScoresBySegment.landingPages = 0; // Will be calculated per segment if needed
          behaviourScoresBySegment.eventPages = 0;
          behaviourScoresBySegment.productPages = 0;
        }
        // Build segment metrics from moneyPagesMetrics.rows (has the actual GSC data)
        // Map subSegment (PRODUCT/EVENT/LANDING) to segmentType (product/event/landing)
        const moneyPagesForSegments = (moneyPagesMetrics?.rows || []).map(row => {
          const subSegment = row.subSegment || 'LANDING';
          let segmentType = 'landing'; // Default
          if (subSegment === 'PRODUCT') segmentType = 'product';
          else if (subSegment === 'EVENT') segmentType = 'event';
          else if (subSegment === 'LANDING') segmentType = 'landing';
          
          return {
            clicks: row.clicks || 0,
            impressions: row.impressions || 0,
            ctr: row.ctr || 0,
            avgPosition: row.avgPosition || 0,
            segmentType: segmentType
          };
        });
        window.moneySegmentMetrics = buildMoneySegmentSummary(moneyPagesForSegments, behaviourScoresBySegment);
        debugLog(`Money Pages Segments: Built segment summary from ${moneyPagesForSegments.length} pages`, 'info');
        debugLog(`Money Pages Segments: allMoney clicks=${window.moneySegmentMetrics.allMoney.clicks}, impressions=${window.moneySegmentMetrics.allMoney.impressions}`, 'info');
      } else {
        debugLog(' Money Pages Metrics: No queryPages data available - building empty structure', 'warn');
        window.moneyPagePriorityData = [];
        // Always build empty segment metrics structure (never null) so it can be saved to Supabase
        window.moneySegmentMetrics = buildMoneySegmentSummary([], {});
        debugLog(`Money Pages Segments: Built empty segment summary (no data available) - allMoney clicks=${window.moneySegmentMetrics.allMoney.clicks}, impressions=${window.moneySegmentMetrics.allMoney.impressions}`, 'info');
      }
      
      // Ensure moneySegmentMetrics is never null (always a valid structure)
      if (!window.moneySegmentMetrics) {
        debugLog(' Money Pages Segments: moneySegmentMetrics was null, building empty structure', 'warn');
        window.moneySegmentMetrics = buildMoneySegmentSummary([], {});
      }

      const scores = {
        localEntity,
        serviceArea,
        authority: {
          score: authority, // Main score (default: all pages)
          bySegment: authorityBySegment // Per-segment Authority scores (if available)
        },
        visibility,
        contentSchema,
        // Authority component scores for historical tracking (backward compatible)
        authorityComponents: authorityComponents,
        // GAIO health components (extracted from contentSchema)
        coverage: coverageScore,
        diversity: diversityScore,
        // Phase 1: Brand overlay (overlay only, not weighted in GAIO score)
        brandOverlay: brandOverlay,
        // Money Pages Performance metrics (overlay only, not weighted in GAIO score)
        // Always include moneyPagesMetrics, even if null (ensures it's saved to Supabase)
        moneyPagesMetrics: moneyPagesMetrics || null
      };
      
      // Store moneyPagesMetrics globally for saveAuditToSupabase to access
      if (moneyPagesMetrics) {
        window.moneyPagesMetrics = moneyPagesMetrics;
        debugLog(` Stored moneyPagesMetrics globally: ${moneyPagesMetrics.rows?.length || 0} rows`, 'info');
      } else {
        debugLog(` moneyPagesMetrics is null - will be saved as null to Supabase`, 'warn');
      }

      debugLog(`Deterministic pillar scores: ${JSON.stringify(scores)}`, 'info');
      return scores;
    }
    
    // Calculate GAIO Health Score
    // IMPORTANT: GAIO score uses ONLY the 5 pillars - brandOverlay and aiSummary are overlay metrics only
    function calculateAiGeoScore(scores, schemaAudit = null, snippetReadiness = null) {
      // GAIO weights - ONLY the 5 pillars
      const AIGEO_WEIGHTS = {
        authority: 0.30,
        content: 0.25,
        visibility: 0.20,
        localEntity: 0.15,
        serviceArea: 0.10
      };
      
      // Extract scores from the 5 pillars ONLY
      const authorityScore = (typeof scores.authority === 'object' && scores.authority !== null) 
        ? scores.authority.score 
        : scores.authority || 0;
      const contentScore = scores.contentSchema || 0;
      const visibilityScore = scores.visibility || 0;
      const localEntityScore = scores.localEntity || 0;
      const serviceAreaScore = scores.serviceArea || 0;
      
      // Calculate weighted score using ONLY the 5 pillars
      const aiGeoScore = Math.round(
        authorityScore * AIGEO_WEIGHTS.authority +
        contentScore * AIGEO_WEIGHTS.content +
        visibilityScore * AIGEO_WEIGHTS.visibility +
        localEntityScore * AIGEO_WEIGHTS.localEntity +
        serviceAreaScore * AIGEO_WEIGHTS.serviceArea
      );
      
      // Phase 1: Calculate AI Summary Likelihood using new method (overlay only, not part of GAIO score)
      // Handle both number format (legacy) and object format (if it exists)
      const snippetReadinessScore = typeof snippetReadiness === 'number' 
        ? snippetReadiness 
        : (snippetReadiness?.overallScore || 0);
      const brandScore = scores.brandOverlay?.score || 0;
      
      // Use new computeAiSummaryLikelihood if we have snippet readiness data (brandScore can be 0)
      let aiSummary;
      if (snippetReadinessScore > 0) {
        aiSummary = computeAiSummaryLikelihood(snippetReadinessScore, visibilityScore, brandScore);
      } else {
        // Fallback to old method for backward compatibility
        aiSummary = {
          label: calculateAiSummaryLikelihood({
            aiGeoScore,
            authority: authorityScore,
            content: contentScore,
            coverage: 0 // Not used in new calculation
          }),
          score: aiGeoScore, // Use aiGeoScore as fallback
          reasons: []
        };
      }
      
      return {
        aiGeoScore, // Calculated from 5 pillars ONLY
        aiGeoStatus: aiGeoScore >= 70 ? 'green' : aiGeoScore >= 50 ? 'amber' : 'red',
        aiSummaryLikelihood: aiSummary.label, // Keep backward compatibility
        aiSummary: aiSummary // New Phase 1 field (overlay only)
      };
    }
    
    // Calculate AI Summary Likelihood (OLD - kept for backward compatibility, but will be replaced)
    // NOTE: This is being replaced by computeAiSummaryLikelihood which uses snippetReadiness, visibility, and brand
    function calculateAiSummaryLikelihood({ aiGeoScore, authority, content, coverage }) {
      const strongAuthority = authority >= 65;
      const strongContent = content >= 70;
      const strongCoverage = coverage >= 80;
      
      if (aiGeoScore >= 75 && strongAuthority && strongContent && strongCoverage) {
        return 'high';
      }
      if (aiGeoScore >= 55) {
        return 'medium';
      }
      return 'low';
    }

    function calculateSnippetReadiness(scores, data) {
      // Snippet readiness combines:
      // 1. Content/Schema score (structured data quality)
      // 2. Visibility score (SERP feature presence)
      // 3. Authority score (content depth and trust)
      // Weighted average: 40% Content/Schema, 35% Visibility, 25% Authority
      // Handle both old format (number) and new format (object with score)
      const authorityScore = typeof scores.authority === 'object' ? scores.authority.score : scores.authority;
      const readiness = (
        scores.contentSchema * 0.4 +
        scores.visibility * 0.35 +
        authorityScore * 0.25
      );
      return Math.round(Math.min(100, Math.max(0, readiness)));
    }

    // Fetch real data from Google Search Console API using unified endpoint
    // Note: apiKey parameter kept for compatibility but not used (endpoint uses OAuth2)
    async function fetchSearchConsoleData(apiKey, propertyUrl, days) {
      debugLog(`Fetching real GSC data for ${days} days...`, 'info');
      
      // Calculate date range
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);
      
      // Format dates as YYYY-MM-DD
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      const startDateStr = formatDate(startDate);
      const endDateStr = formatDate(endDate);
      
      debugLog(`Date range: ${startDateStr} to ${endDateStr}`, 'info');
      
      try {
        // Get tracked keywords for queryTotals fetching
        const trackedKeywords = window.RankingAiModule?.TRACKED_KEYWORDS || [];
        const keywordsParam = trackedKeywords.length > 0 
          ? `&keywords=${encodeURIComponent(JSON.stringify(trackedKeywords))}`
          : '';
        
        // Call unified GSC entity metrics endpoint
        const response = await fetch(apiUrl(`/api/aigeo/gsc-entity-metrics?property=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDateStr}${keywordsParam}`));

        if (!response.ok) {
          // Try to parse as JSON, but handle non-JSON error responses
          let errorData = null;
          const contentType = response.headers.get('content-type') || '';
          try {
            if (contentType.includes('application/json')) {
              errorData = await response.json();
            } else {
              // Response is not JSON (likely HTML error page)
              const errorText = await response.text();
              debugLog(` GSC API returned non-JSON error (HTTP ${response.status}): ${errorText.substring(0, 200)}`, 'error');
              throw new Error(`Server error (HTTP ${response.status}): ${errorText.substring(0, 100)}...`);
            }
          } catch (parseError) {
            // If JSON parsing fails, use the parse error or create a generic error
            if (parseError.message && !parseError.message.includes('Server error')) {
              debugLog(` Failed to parse error response: ${parseError.message}`, 'error');
              throw new Error(`Server error (HTTP ${response.status}): Unable to parse error response. The API may be experiencing issues.`);
            }
            throw parseError;
          }
          
          debugLog(` GSC API error: ${errorData.message || errorData.error}`, 'error');
          if (errorData.details) {
            debugLog(`Details: ${errorData.details}`, 'error');
          }
          
          // If OAuth not configured, show helpful message
          if (errorData.message && errorData.message.includes('OAuth2 credentials not configured')) {
            throw new Error('Google Search Console OAuth2 credentials not configured. Please set GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, and GOOGLE_REFRESH_TOKEN in Vercel environment variables.');
          }
          
          throw new Error(errorData.message || errorData.error || 'Failed to fetch Search Console data');
        }

        const gsc = await response.json();
        
        if (gsc.status !== 'ok') {
          throw new Error(gsc.message || 'Failed to fetch Search Console data');
        }
        
        debugLog(` Real GSC data fetched: ${gsc.data.overview.totalClicks} clicks, ${gsc.data.overview.totalImpressions} impressions`, 'success');
        
        // Log segmentation data availability
        if (gsc.data.queryPages && gsc.data.queryPages.length > 0) {
          debugLog(` GSC API returned ${gsc.data.queryPages.length} query+page combinations for segmentation`, 'success');
        } else {
          debugLog(' GSC API did not return queryPages data. Segmentation will use fallback calculation.', 'warn');
        }
        
        // Log queryTotals availability
        if (gsc.data.queryTotals && gsc.data.queryTotals.length > 0) {
          debugLog(` GSC API returned ${gsc.data.queryTotals.length} query-only totals for tracked keywords`, 'success');
        } else {
          debugLog(' GSC API did not return queryTotals data. Table will show  for missing keywords.', 'warn');
        }
        
        // Return data in format expected by existing code
        const searchData = {
          totalClicks: gsc.data.overview.totalClicks || 0,
          totalImpressions: gsc.data.overview.totalImpressions || 0,
          averagePosition: gsc.data.overview.avgPosition || 0,
          ctr: gsc.data.overview.ctr || 0, // Already 0-100 from API
          topQueries: gsc.data.topQueries || [],
          queryPages: gsc.data.queryPages || [], // Query+page combinations for segmentation
          queryTotals: gsc.data.queryTotals || [], // Query-only totals for tracked keywords (for table)
          timeseries: gsc.data.timeseries || [], // For trend chart
          dateRange: days,
          // Store full GSC response for trend chart access
          _gscResponse: gsc,
          // Create overview object with siteTotalImpressions and siteTotalClicks for buildMoneyPagesSummary
          overview: {
            siteTotalImpressions: gsc.data.overview.totalImpressions || 0,
            siteTotalClicks: gsc.data.overview.totalClicks || 0,
            totalImpressions: gsc.data.overview.totalImpressions || 0,
            totalClicks: gsc.data.overview.totalClicks || 0
          }
        };
        return searchData;
      } catch (error) {
        debugLog(` Error fetching GSC data: ${error.message}`, 'error');
        throw error;
      }
    }

    // Run the audit
    async function runAudit() {
      // CRITICAL: Set flag to indicate we're in a fresh audit run
      // This ensures page-level GSC data is always fetched fresh, not from stale localStorage
      window._isFreshAuditRun = true;
      debugLog('=== AUDIT START: Beginning audit scan ===', 'info');
      
      // Get API key - prioritize Vercel env var, then loaded key, then localStorage
      let apiKey = window._loadedApiKey;
      
      // Try Vercel environment variable first
      if (!apiKey) {
        try {
          debugLog('Fetching API key from Vercel environment variable...', 'info');
          const response = await fetch(apiUrl('/api/get-api-key'));
          if (response.ok) {
            const data = await response.json();
            if (data.apiKey) {
              apiKey = data.apiKey;
              debugLog(' Using API key from Vercel environment variable', 'success');
              window._loadedApiKey = apiKey;
            }
          }
        } catch (e) {
          debugLog('Vercel env var endpoint not available', 'info');
        }
      }
      
      // Fall back to config.js
      if (!apiKey && window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey) {
        apiKey = window.API_CONFIG.googleSearchConsoleApiKey;
        debugLog(' Using API key from config.js', 'success');
        window._loadedApiKey = apiKey;
      }
      
      // Fall back to localStorage
      if (!apiKey) {
        apiKey = localStorage.getItem('gsc_api_key');
        if (apiKey) {
          debugLog(' Using API key from localStorage', 'success');
          window._loadedApiKey = apiKey;
        }
      }
      
      const propertyUrl = document.getElementById('propertyUrl').value;
      const dateRange = parseInt(document.getElementById('dateRange').value);
      
      debugLog(`Property URL: ${propertyUrl}`, 'info');
      debugLog(`Date Range: ${dateRange} days`, 'info');

      // Note: API key no longer required - new endpoint uses OAuth2 from env vars
      if (!propertyUrl) {
        debugLog(' No property URL provided', 'error');
        showStatus('Please enter your property URL', 'error');
        return;
      }

      debugLog('Showing loading indicator...', 'info');
      document.getElementById('loading').classList.add('show');
      document.getElementById('dashboard').style.display = 'none';
      updateProgress(0, 'Initializing audit scan...');

      // Load saved audit data first to use as defaults (preserve data when sources unavailable)
      let savedAudit = null;
      try {
        const saved = localStorage.getItem('last_audit_results');
        if (saved) {
          savedAudit = JSON.parse(saved);
          debugLog(' Loaded previous audit data for fallback', 'info');
        }
      } catch (e) {
        debugLog(` Could not load previous audit data: ${e.message}`, 'warn');
      }

      // Declare schemaAudit outside try block so it's accessible in finally
      // Initialize with saved data if available (preserves Content/Schema when endpoint unavailable)
      let schemaAudit = savedAudit?.schemaAudit || null;
      let localSignals = savedAudit?.localSignals || null;
      // Don't use cached siteReviews - always fetch fresh Trustpilot snapshot
      // Old cached values (4.8, 127) should be replaced with new snapshot (4.6, 610)
      let siteReviews = null; // Always fetch fresh
      let backlinkMetrics = savedAudit?.backlinkMetrics || null;

      try {
        updateProgress(10, 'Fetching Search Console data...');
        debugLog('Fetching Search Console data...', 'info');
        // Fetch data
        const searchData = await fetchSearchConsoleData(apiKey, propertyUrl, dateRange);
        debugLog(' Search Console data fetched successfully', 'success');
        debugLog(`Data: ${JSON.stringify(searchData).substring(0, 200)}...`, 'info');
        
        updateProgress(35, 'Fetching local signals data...');
        debugLog('Fetching local signals data...', 'info');
        // Fetch local signals (Business Profile) data
        // Only fetch if we don't have saved data, or always fetch fresh (Business Profile can change)
        try {
          const localSignalsResponse = await fetch(apiUrl(`/api/aigeo/local-signals?property=${encodeURIComponent(propertyUrl)}`));
          if (localSignalsResponse.ok) {
            const freshLocalSignals = await localSignalsResponse.json();
            if (freshLocalSignals.status === 'ok') {
              localSignals = freshLocalSignals;
              debugLog(' Local signals data fetched successfully', 'success');
              debugLog(`Service areas: ${localSignals.data.serviceAreas?.length || 0}, NAP score: ${localSignals.data.napConsistencyScore || 'N/A'}`, 'info');
            } else {
              debugLog(' Local signals returned error, using saved data if available', 'warn');
            }
          } else {
            debugLog(' Local signals endpoint not available, using saved data if available', 'warn');
          }
        } catch (localSignalsError) {
          debugLog(` Local signals error: ${localSignalsError.message}, using saved data if available`, 'warn');
        }
        
        // If fetch failed but we have saved data, keep using it
        if (!localSignals && savedAudit?.localSignals) {
          localSignals = savedAudit.localSignals;
          debugLog(' Using saved local signals data', 'info');
        }
        
        updateProgress(37, 'Fetching Trustpilot snapshot data...');
        debugLog('Fetching Trustpilot snapshot data...', 'info');
        // Always fetch fresh Trustpilot snapshot data (it's a fixed snapshot, so should always work)
        try {
          const siteReviewsResponse = await fetch(apiUrl('/api/reviews/site-reviews'));
          if (siteReviewsResponse.ok) {
            const siteReviewsData = await siteReviewsResponse.json();
            if (siteReviewsData.status === 'ok' && siteReviewsData.data) {
              siteReviews = siteReviewsData.data;
              debugLog(' Trustpilot snapshot data fetched successfully', 'success');
              debugLog(`Trustpilot snapshot: rating=${siteReviews.siteRating}, count=${siteReviews.siteReviewCount}`, 'info');
            } else {
              debugLog(' Trustpilot snapshot returned error, using saved data if available', 'warn');
              // Fallback to saved data only if API completely fails
              if (savedAudit?.siteReviews) {
                siteReviews = savedAudit.siteReviews;
                debugLog(' Using saved Trustpilot data as fallback (will override with correct values)', 'warn');
              }
            }
          } else {
            debugLog(' Trustpilot snapshot endpoint not available, using saved data if available', 'warn');
            // Fallback to saved data only if API completely fails
            if (savedAudit?.siteReviews) {
              siteReviews = savedAudit.siteReviews;
              debugLog(' Using saved Trustpilot data as fallback (will override with correct values)', 'warn');
            }
          }
        } catch (siteReviewsError) {
          debugLog(` Trustpilot snapshot error: ${siteReviewsError.message}, using saved data if available`, 'warn');
          // Fallback to saved data only if API completely fails
          if (savedAudit?.siteReviews) {
            siteReviews = savedAudit.siteReviews;
            debugLog(' Using saved Trustpilot data as fallback (will override with correct values)', 'warn');
          }
        }
        
        // ALWAYS force correct Trustpilot snapshot values (4.6, 610) - override ANY old values
        // This ensures we always use the correct snapshot regardless of API response or cached data
        const TRUSTPILOT_SNAPSHOT = {
          siteRating: 4.6,
          siteReviewCount: 610,
          lastUpdated: '2025-12-07',
          notes: 'Fixed Trustpilot snapshot for Authority score calculation. Update manually when Trustpilot metrics change significantly.'
        };
        
        if (!siteReviews || siteReviews.siteRating !== 4.6 || siteReviews.siteReviewCount !== 610) {
          if (siteReviews) {
            debugLog(` Overriding old Trustpilot values (${siteReviews.siteRating}, ${siteReviews.siteReviewCount}) with correct snapshot (4.6, 610)`, 'warn');
          } else {
            debugLog(' Using default Trustpilot snapshot values (4.6, 610)', 'warn');
          }
          siteReviews = TRUSTPILOT_SNAPSHOT;
        } else {
          debugLog(' Trustpilot snapshot verified (4.6, 610)', 'success');
        }
        
        updateProgress(38, 'Fetching backlink metrics data...');
        debugLog('Fetching backlink metrics data...', 'info');
        // Fetch backlink metrics - try localStorage first (from CSV upload), then API
        let backlinkMetrics = null;
        
        // First, try to get from localStorage (stored when CSV was uploaded)
        try {
          const storedMetrics = localStorage.getItem('backlink_metrics');
          if (storedMetrics) {
            backlinkMetrics = JSON.parse(storedMetrics);
            debugLog(' Backlink metrics loaded from localStorage', 'success');
            debugLog(`Backlink metrics: domains=${backlinkMetrics.referringDomains}, links=${backlinkMetrics.totalBacklinks}, followRatio=${(backlinkMetrics.followRatio * 100).toFixed(1)}%`, 'info');
          }
        } catch (e) {
          debugLog(` Error reading backlink metrics from localStorage: ${e.message}`, 'warn');
        }
        
        // If not in localStorage, try API (for cases where metrics were uploaded via API directly)
        if (!backlinkMetrics) {
          try {
            const backlinkResponse = await fetch(apiUrl('/api/aigeo/backlink-metrics'));
            if (backlinkResponse.ok) {
              const backlinkData = await backlinkResponse.json();
              if (backlinkData.status === 'ok' && backlinkData.data && backlinkData.data.totalBacklinks > 0) {
                backlinkMetrics = backlinkData.data;
                // Store in localStorage for next time
                localStorage.setItem('backlink_metrics', JSON.stringify(backlinkMetrics));
                debugLog(' Backlink metrics data fetched from API and stored', 'success');
                debugLog(`Backlink metrics: domains=${backlinkMetrics.referringDomains}, links=${backlinkMetrics.totalBacklinks}, followRatio=${(backlinkMetrics.followRatio * 100).toFixed(1)}%`, 'info');
              } else {
                debugLog(' Backlink metrics returned empty/zero, using saved data if available', 'warn');
              }
            } else {
              debugLog(' Backlink metrics endpoint not available, using saved data if available', 'warn');
            }
          } catch (backlinkError) {
            debugLog(` Backlink metrics error: ${backlinkError.message}, using saved data if available`, 'warn');
          }
        }
        
        // If fetch failed but we have saved data, keep using it
        if (!backlinkMetrics && savedAudit?.backlinkMetrics) {
          backlinkMetrics = savedAudit.backlinkMetrics;
          debugLog(' Using saved backlink metrics data', 'info');
        }
        
        updateProgress(40, 'Fetching schema audit data...');
        debugLog('Fetching schema audit data...', 'info');
        // Fetch schema audit data
        try {
          // Check if manual URL list is available
          const manualUrlList = localStorage.getItem('manual_url_list');
          let schemaRequest;
          
          if (manualUrlList) {
            try {
              const urls = JSON.parse(manualUrlList);
              debugLog(`Using manual URL list: ${urls.length} URLs`, 'info');
              updateProgress(45, `Crawling ${urls.length} URLs for schema markup...`);
              schemaRequest = fetch(apiUrl('/api/schema-audit'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ urls })
              });
            } catch (e) {
              debugLog(' Failed to parse manual URL list, using default CSV', 'warn');
              updateProgress(45, 'Loading URLs from CSV and crawling for schema markup...');
              schemaRequest = fetch(apiUrl('/api/schema-audit'));
            }
          } else {
            debugLog('No manual URL list, using default CSV source', 'info');
            updateProgress(45, 'Loading URLs from CSV and crawling for schema markup...');
            schemaRequest = fetch(apiUrl('/api/schema-audit'));
          }
          
          const schemaResponse = await schemaRequest;
          if (schemaResponse.ok) {
            schemaAudit = await schemaResponse.json();
            if (schemaAudit.status === 'ok') {
              debugLog(' Schema audit data fetched successfully', 'success');
              debugLog(`Schema coverage: ${schemaAudit.data.coverage}%`, 'info');
              if (manualUrlList) {
                debugLog('  Source: Manual URL list', 'info');
              } else {
                debugLog('  Source: CSV (GitHub/hosted)', 'info');
              }
              
              // Log comprehensive diagnostic info if available
              if (schemaAudit.meta && schemaAudit.meta.diagnostic) {
                const diag = schemaAudit.meta.diagnostic;
                debugLog('', 'info');
                debugLog(' SCHEMA AUDIT DIAGNOSTICS', 'info');
                debugLog('', 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                debugLog(' PAGE COUNTS:', 'info');
                debugLog(`   Total pages scanned: ${diag.totalPages}`, 'info');
                debugLog(`   Successful crawls: ${diag.successfulPages || diag.totalPages}`, 'info');
                debugLog(`   Failed crawls: ${diag.failedPages || 0}`, diag.failedPages > 0 ? 'warn' : 'info');
                if (diag.failedPages > 0) {
                  debugLog(`     Failed crawls are counted as pages without schema`, 'warn');
                  
                  // Show error breakdown if available
                  if (diag.errorTypes && Object.keys(diag.errorTypes).length > 0) {
                    debugLog('', 'info'); // Empty line
                    debugLog('   ERROR BREAKDOWN:', 'warn');
                    Object.entries(diag.errorTypes).forEach(([type, count]) => {
                      debugLog(`     ${type}: ${count} pages`, 'warn');
                      if (diag.errorExamples && diag.errorExamples[type]) {
                        const example = diag.errorExamples[type];
                        debugLog(`      Example: ${example.url}`, 'info');
                        debugLog(`      Error: ${example.error}`, 'info');
                      }
                    });
                  }
                }
                debugLog(`   Pages with inline schema: ${diag.pagesWithInlineSchema}`, 'info');
                debugLog(`   Pages without inline schema: ${diag.pagesWithoutInlineSchema}`, 'info');
                if (diag.failedPages > 0) {
                  debugLog(`    (includes ${diag.failedPages} failed crawls)`, 'info');
                }
                debugLog(`   Pages with inherited schema: ${diag.pagesWithInheritedSchema}`, 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                if (diag.urlsWithoutSchemas && diag.urlsWithoutSchemas.length > 0) {
                  debugLog(' URLs WITHOUT SCHEMAS:', 'info');
                  diag.urlsWithoutSchemas.forEach(url => {
                    debugLog(`   ${url}`, 'info');
                  });
                  if (diag.pagesWithoutInlineSchema > diag.urlsWithoutSchemas.length) {
                    debugLog(`  ... and ${diag.pagesWithoutInlineSchema - diag.urlsWithoutSchemas.length} more`, 'info');
                  }
                  debugLog('', 'info'); // Empty line for spacing
                }
                
                debugLog(' MISSING SCHEMA BREAKDOWN:', 'info');
                debugLog(`   Pages with parent but no inherited: ${diag.pagesWithParentButNoInherited}`, 'info');
                debugLog(`   Pages with parent but not checked: ${diag.pagesWithParentButNotChecked}`, diag.pagesWithParentButNotChecked > 0 ? 'warn' : 'info');
                debugLog(`   Pages without parent page: ${diag.pagesWithoutParent}`, 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                debugLog(' VALIDATION:', 'info');
                debugLog(`   Total missing pages (calculated): ${diag.totalMissing}`, 'info');
                debugLog(`   Expected missing (total - inline - inherited): ${diag.expectedMissing}`, 'info');
                
                if (diag.mismatch) {
                  debugLog('', 'info'); // Empty line for spacing
                  debugLog(`   MISMATCH DETECTED!`, 'error');
                  debugLog(`  ${diag.mismatchDetails}`, 'error');
                  debugLog(`  This indicates pages are being double-counted or missed in the calculation.`, 'error');
                } else {
                  debugLog(`   Counts match correctly`, 'success');
                }
                
                debugLog('', 'info'); // Empty line for spacing
                debugLog('', 'info');
              }
            } else {
              debugLog(` Schema audit returned error status: ${schemaAudit.status}`, 'warn');
              if (schemaAudit.message) {
                debugLog(`  Error message: ${schemaAudit.message}`, 'warn');
              }
            }
          } else {
            const errorText = await schemaResponse.text();
            debugLog(` Schema audit endpoint returned ${schemaResponse.status}: ${schemaResponse.statusText}`, 'warn');
            if (errorText) {
              debugLog(`  Response: ${errorText.substring(0, 200)}`, 'warn');
            }
            // schemaAudit already initialized with saved data at start, so it's preserved
            if (schemaAudit) {
              debugLog(' Using saved schema audit data from previous audit', 'success');
              debugLog(`Schema coverage: ${schemaAudit.data?.coverage || 'N/A'}%`, 'info');
            } else {
              debugLog(' No saved schema audit data available', 'warn');
            }
          }
        } catch (schemaError) {
          debugLog(` Schema audit error: ${schemaError.message}, using saved data`, 'warn');
          // schemaAudit already initialized with saved data at start, so it's preserved
          if (schemaAudit) {
            debugLog(' Using saved schema audit data from previous audit (fallback)', 'success');
            debugLog(`Schema coverage: ${schemaAudit.data?.coverage || 'N/A'}%`, 'info');
          } else {
            debugLog(' No saved schema audit data available', 'warn');
          }
        }
        
        updateProgress(70, 'Calculating pillar scores...');
        debugLog('Calculating pillar scores...', 'info');
        // Calculate scores (pass schema audit data, local signals, site reviews, and backlink metrics)
        const scores = await calculatePillarScores(searchData, schemaAudit, localSignals, siteReviews, backlinkMetrics);
        debugLog(' Pillar scores calculated', 'success');
        debugLog(`Scores: ${JSON.stringify(scores)}`, 'info');

        updateProgress(85, 'Calculating snippet readiness...');
        debugLog('Calculating snippet readiness...', 'info');
        const snippetReadiness = calculateSnippetReadiness(scores, searchData);
        debugLog(`Snippet readiness: ${snippetReadiness}`, 'info');

        updateProgress(95, 'Generating dashboard...');
        debugLog('Displaying dashboard...', 'info');
        // Display results (pass current audit data including localSignals)
        displayDashboard(scores, searchData, snippetReadiness, schemaAudit, localSignals);
        
        updateProgress(100, 'Audit completed successfully!');
        debugLog('=== AUDIT COMPLETE: Success ===', 'success');
        
        // Save audit results to localStorage
        saveAuditResults(scores, searchData, snippetReadiness, schemaAudit, localSignals, siteReviews, backlinkMetrics);
        
        // Save audit results to Supabase for historical tracking
        // Note: saveAuditToSupabase is async, so we can await it or use .then()
        (async () => {
          try {
            // Save GSC timeseries data to database (for last 28 days, updated each audit)
            if (searchData.timeseries && Array.isArray(searchData.timeseries) && searchData.timeseries.length > 0) {
              try {
                debugLog(`Saving ${searchData.timeseries.length} GSC timeseries records to database...`, 'info');
                const timeseriesResponse = await fetch(apiUrl('/api/supabase/save-gsc-timeseries'), {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    propertyUrl: propertyUrl,
                    timeseries: searchData.timeseries
                  })
                });
                if (timeseriesResponse.ok) {
                  const timeseriesResult = await timeseriesResponse.json();
                  debugLog(` Saved ${timeseriesResult.saved || searchData.timeseries.length} GSC timeseries records to database`, 'success');
                } else {
                  const errorText = await timeseriesResponse.text();
                  debugLog(` Failed to save timeseries data: ${timeseriesResponse.status} - ${errorText.substring(0, 200)}`, 'warn');
                }
              } catch (timeseriesError) {
                debugLog(` Error saving timeseries data (non-critical): ${timeseriesError.message}`, 'warn');
              }
            } else {
              debugLog(' No timeseries data to save (searchData.timeseries is missing or empty)', 'warn');
            }
            
            await saveAuditToSupabase(propertyUrl, scores, searchData, snippetReadiness, schemaAudit, localSignals, new Date().toISOString().split('T')[0]);
            // After saving to Supabase, refresh the trend chart to show the latest audit
            debugLog('Refreshing Score Trends chart after saving audit...', 'info');
            // Re-render the dashboard to update the trend chart with new data
            setTimeout(async () => {
              const saved = loadAuditResultsSync();
              if (saved && saved.scores && saved.searchData) {
                try {
                  await displayDashboard(saved.scores, saved.searchData, saved.snippetReadiness || 0, saved.schemaAudit || null, saved.localSignals || null);
                  debugLog(' Score Trends chart refreshed after saving audit', 'success');
                } catch (err) {
                  debugLog(` Error refreshing trend chart: ${err.message}`, 'warn');
                }
              }
            }, 1000); // Delay to ensure Supabase save is complete
          } catch (err) {
            debugLog(` Error saving to Supabase (chart refresh skipped): ${err.message}`, 'warn');
          }
        })();
        
        showStatus('Audit completed successfully!', 'success');
      } catch (error) {
        debugLog(` AUDIT ERROR: ${error.message}`, 'error');
        debugLog(`Stack trace: ${error.stack}`, 'error');
        showStatus('Error running audit: ' + error.message, 'error');
        console.error(error);
      } finally {
        // Clear the fresh audit flag after audit completes (success or error)
        window._isFreshAuditRun = false;
        debugLog('Hiding loading indicator...', 'info');
        document.getElementById('loading').classList.remove('show');
        
        // Show completion summary modal
        debugLog(`Schema audit available for modal: ${schemaAudit ? 'yes' : 'no'}`, 'info');
        if (schemaAudit) {
          debugLog('Showing completion modal...', 'info');
          setTimeout(() => {
            showCompletionModal(schemaAudit);
          }, 500);
        } else {
          debugLog(' No schema audit data available for modal', 'warn');
        }
        
        // Reset progress bar for next run
        setTimeout(() => {
          updateProgress(0, 'Initializing audit scan...');
        }, 500);
        
        // Save debug log to repo after audit completes
        try {
          const auditDate = new Date().toISOString().split('T')[0];
          const currentPropertyUrl = propertyUrl || document.getElementById('propertyUrl')?.value || '';
          
          if (debugLogEntries && debugLogEntries.length > 0) {
            debugLog('Saving debug log to repo...', 'info');
            
            fetch(apiUrl('/api/save-debug-log'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                propertyUrl: currentPropertyUrl,
                auditDate: auditDate,
                debugLogEntries: debugLogEntries
              })
            }).then(response => {
              if (response.ok) {
                return response.json();
              } else {
                throw new Error(`HTTP ${response.status}`);
              }
            }).then(result => {
              if (result.status === 'ok') {
                debugLog(` Debug log saved to repo: ${result.data.filename} (${result.data.entriesCount} entries)`, 'success');
              } else {
                debugLog(` Failed to save debug log: ${result.message}`, 'warn');
              }
            }).catch(err => {
              debugLog(` Error saving debug log to repo (non-critical): ${err.message}`, 'warn');
            });
          } else {
            debugLog(' No debug log entries to save', 'warn');
          }
        } catch (saveLogError) {
          debugLog(` Error preparing debug log save (non-critical): ${saveLogError.message}`, 'warn');
        }
      }
    }

    // Fetch and parse site-urls.csv from GitHub
    async function fetchAndParseSiteUrlsCsv() {
      const GITHUB_CSV_URL = "https://raw.githubusercontent.com/alanranger/alan-shared-resources/main/csv/06-site-urls.csv";
      const FALLBACK_CSV_URL = "https://schema-tools-six.vercel.app/06-site-urls.csv";
      
      try {
        // Try GitHub first
        const res = await fetch(GITHUB_CSV_URL);
        if (!res.ok) throw new Error(`GitHub fetch failed: HTTP ${res.status}`);
        const csvText = await res.text();
        
        // Parse CSV - extract URLs from url column
        const lines = csvText.split('\n').filter(line => line.trim());
        const urls = [];
        
        // Parse header row to find URL column index
        let urlColumnIndex = 0;
        if (lines.length > 0) {
          const headerLine = lines[0].trim();
          const headers = parseCsvLine(headerLine);
          const urlHeaderIndex = headers.findIndex(h => h.toLowerCase() === 'url');
          if (urlHeaderIndex !== -1) {
            urlColumnIndex = urlHeaderIndex;
          }
        }
        
        // Helper function to parse CSV line with proper quote handling
        function parseCsvLine(line) {
          const columns = [];
          let current = '';
          let inQuotes = false;
          
          for (let i = 0; i < line.length; i++) {
            const char = line[i];
            const nextChar = line[i + 1];
            
            if (char === '"') {
              if (inQuotes && nextChar === '"') {
                current += '"';
                i++;
              } else {
                inQuotes = !inQuotes;
              }
            } else if (char === ',' && !inQuotes) {
              columns.push(current.trim());
              current = '';
            } else {
              current += char;
            }
          }
          columns.push(current.trim());
          return columns;
        }
        
        // Parse data rows (skip header)
        for (let i = 1; i < lines.length; i++) {
          const columns = parseCsvLine(lines[i]);
          if (columns[urlColumnIndex]) {
            const url = columns[urlColumnIndex].trim();
            if (url) {
              // Accept URLs starting with http/https, or relative URLs starting with /
              // Also accept full URLs without protocol (will be normalized)
              if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('/')) {
                urls.push(url);
              } else if (url.includes('.') && !url.includes(' ')) {
                // Likely a URL without protocol - add https://
                urls.push(url.startsWith('//') ? `https:${url}` : `https://${url}`);
              }
            }
          }
        }
        
        return urls;
      } catch (githubErr) {
        // Try fallback
        try {
          const fallbackRes = await fetch(FALLBACK_CSV_URL);
          if (!fallbackRes.ok) throw new Error(`Fallback fetch failed: HTTP ${fallbackRes.status}`);
          const csvText = await fallbackRes.text();
          
          // Same parsing logic as above
          const lines = csvText.split('\n').filter(line => line.trim());
          const urls = [];
          let urlColumnIndex = 0;
          
          if (lines.length > 0) {
            const headerLine = lines[0].trim();
            const headers = parseCsvLine(headerLine);
            const urlHeaderIndex = headers.findIndex(h => h.toLowerCase() === 'url');
            if (urlHeaderIndex !== -1) {
              urlColumnIndex = urlHeaderIndex;
            }
          }
          
          function parseCsvLine(line) {
            const columns = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
              const char = line[i];
              const nextChar = line[i + 1];
              if (char === '"') {
                if (inQuotes && nextChar === '"') {
                  current += '"';
                  i++;
                } else {
                  inQuotes = !inQuotes;
                }
              } else if (char === ',' && !inQuotes) {
                columns.push(current.trim());
                current = '';
              } else {
                current += char;
              }
            }
            columns.push(current.trim());
            return columns;
          }
          
          for (let i = 1; i < lines.length; i++) {
            const columns = parseCsvLine(lines[i]);
            if (columns[urlColumnIndex]) {
              const url = columns[urlColumnIndex].trim();
              if (url) {
                // Accept URLs starting with http/https, or relative URLs starting with /
                // Also accept full URLs without protocol (will be normalized)
                if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('/')) {
                  urls.push(url);
                } else if (url.includes('.') && !url.includes(' ')) {
                  // Likely a URL without protocol - add https://
                  urls.push(url.startsWith('//') ? `https:${url}` : `https://${url}`);
                }
              }
            }
          }
          
          return urls;
        } catch (fallbackErr) {
          throw new Error(`Unable to load site URLs CSV: ${githubErr.message}`);
        }
      }
    }
    
    // Display dashboard
    async function displayDashboard(scores, data, snippetReadiness = 0, schemaAudit = null, localSignals = null) {
      // Normalize localSignals structure if needed (handle old format where it might just be {data: {...}})
      if (localSignals && localSignals.data && !localSignals.status) {
        debugLog(`[displayDashboard] Normalizing localSignals structure - wrapping in status/data format`, 'info');
        localSignals = { status: 'ok', data: localSignals.data || localSignals };
      }
      // Update timestamp if this is a fresh display
      const saved = await loadAuditResults();
      if (saved && saved.timestamp) {
        updateAuditTimestamp(saved.timestamp);
      }
      
      // CRITICAL: Ensure Money Pages data is in scores object
      // If scores.moneyPagesMetrics is missing, get it from saved data
      // Check explicitly for null/undefined/false (not just falsy)
      debugLog(`DEBUG: Checking moneyPagesMetrics - scores.moneyPagesMetrics=${scores?.moneyPagesMetrics}, type=${typeof scores?.moneyPagesMetrics}, saved.scores.moneyPagesMetrics=${saved?.scores?.moneyPagesMetrics}, type=${typeof saved?.scores?.moneyPagesMetrics}, saved.moneyPagesMetrics=${saved?.moneyPagesMetrics}, type=${typeof saved?.moneyPagesMetrics}`, 'info');
      
      if (!scores.moneyPagesMetrics || scores.moneyPagesMetrics === null || scores.moneyPagesMetrics === false) {
        if (saved && saved.scores && saved.scores.moneyPagesMetrics !== null && saved.scores.moneyPagesMetrics !== undefined && saved.scores.moneyPagesMetrics !== false) {
          scores.moneyPagesMetrics = saved.scores.moneyPagesMetrics;
          debugLog(` Restored moneyPagesMetrics from saved.scores (${saved.scores.moneyPagesMetrics.rows?.length || 0} rows)`, 'success');
        } else if (saved && saved.moneyPagesMetrics !== null && saved.moneyPagesMetrics !== undefined && saved.moneyPagesMetrics !== false) {
          scores.moneyPagesMetrics = saved.moneyPagesMetrics;
          debugLog(` Restored moneyPagesMetrics from saved.moneyPagesMetrics (${saved.moneyPagesMetrics.rows?.length || 0} rows)`, 'success');
        } else {
          debugLog(` No moneyPagesMetrics found in saved data: saved.scores.moneyPagesMetrics=${saved?.scores?.moneyPagesMetrics} (type: ${typeof saved?.scores?.moneyPagesMetrics}), saved.moneyPagesMetrics=${saved?.moneyPagesMetrics} (type: ${typeof saved?.moneyPagesMetrics})`, 'warn');
        }
      }
      
      // Store globally for Money Pages sections
      if (scores.moneyPagesMetrics) {
        window.currentMoneyPagesMetrics = scores.moneyPagesMetrics;
        window.moneyPagesMetrics = scores.moneyPagesMetrics;
        debugLog(` Stored moneyPagesMetrics globally: ${scores.moneyPagesMetrics.rows?.length || 0} rows`, 'success');
      }
      
      // Use current audit data (passed as parameter) or fallback to saved data
      // This ensures we always use the most recent audit run data, not stale localStorage
      // Check both localSignals and localSignalsSnapshot (different storage formats)
      const currentLocalSignals = localSignals || (saved && (saved.localSignals || saved.localSignalsSnapshot)) || null;
      
      // DEBUG: Log currentLocalSignals structure
      if (currentLocalSignals) {
        debugLog(`[displayDashboard] currentLocalSignals structure: status=${currentLocalSignals.status}, hasData=${!!currentLocalSignals.data}, hasLocations=${!!currentLocalSignals.data?.locations}, locationsCount=${currentLocalSignals.data?.locations?.length || 0}`, 'info');
        if (currentLocalSignals.data && currentLocalSignals.data.locations) {
          debugLog(`[displayDashboard] currentLocalSignals.data.locations type: ${typeof currentLocalSignals.data.locations}, isArray: ${Array.isArray(currentLocalSignals.data.locations)}, length: ${currentLocalSignals.data.locations.length}`, 'info');
        } else {
          debugLog(`[displayDashboard]  currentLocalSignals.data.locations is missing!`, 'warn');
        }
      } else {
        debugLog(`[displayDashboard]  currentLocalSignals is null!`, 'warn');
      }
      
      // Restore Money Pages Priority Matrix data from localStorage
      // If not available, try to rebuild from saved data
      if (saved && saved.moneyPagePriorityData && Array.isArray(saved.moneyPagePriorityData) && saved.moneyPagePriorityData.length > 0) {
        window.moneyPagePriorityData = saved.moneyPagePriorityData;
        // Use saved moneySegmentMetrics if available, otherwise rebuild
        if (saved.moneySegmentMetrics) {
          window.moneySegmentMetrics = saved.moneySegmentMetrics;
          debugLog(` Restored Money Pages Priority data and segment metrics from localStorage: ${window.moneyPagePriorityData.length} pages`, 'success');
        } else {
          window.moneySegmentMetrics = null;
          debugLog(` Restored Money Pages Priority data from localStorage: ${window.moneyPagePriorityData.length} pages (no segment metrics)`, 'success');
        }
      } else {
        // Try to rebuild from saved data - check multiple locations
        // IMPORTANT: Check for null/undefined explicitly, not just truthy (null is falsy but we need to distinguish it from missing)
        let savedMetrics = null;
        if (saved && saved.scores && saved.scores.moneyPagesMetrics !== null && saved.scores.moneyPagesMetrics !== undefined && saved.scores.moneyPagesMetrics !== false) {
          savedMetrics = saved.scores.moneyPagesMetrics;
          debugLog(` Found moneyPagesMetrics in saved.scores.moneyPagesMetrics`, 'success');
        } else if (saved && saved.moneyPagesMetrics !== null && saved.moneyPagesMetrics !== undefined && saved.moneyPagesMetrics !== false) {
          savedMetrics = saved.moneyPagesMetrics;
          debugLog(` Found moneyPagesMetrics in saved.moneyPagesMetrics`, 'success');
        } else if (scores && scores.moneyPagesMetrics !== null && scores.moneyPagesMetrics !== undefined && scores.moneyPagesMetrics !== false) {
          savedMetrics = scores.moneyPagesMetrics;
          debugLog(` Found moneyPagesMetrics in scores.moneyPagesMetrics`, 'success');
        } else {
          debugLog(` moneyPagesMetrics not found in any location: saved.scores.moneyPagesMetrics=${saved?.scores?.moneyPagesMetrics}, saved.moneyPagesMetrics=${saved?.moneyPagesMetrics}, scores.moneyPagesMetrics=${scores?.moneyPagesMetrics}`, 'warn');
        }
        
        const savedSearchData = data || (saved && saved.searchData);
        
        if (savedMetrics && savedMetrics.rows && Array.isArray(savedMetrics.rows) && savedMetrics.rows.length > 0 && savedSearchData) {
          // Rebuild from saved data if priority data is missing but we have the source data
          // schemaAudit is optional - buildMoneyPageMetrics can work without it
          try {
            debugLog(`Rebuilding Money Pages Priority data from ${savedMetrics.rows.length} rows`, 'info');
            const topPagesForPriority = savedMetrics.rows.map(row => ({
              page: row.url,
              url: row.url,
              clicks: row.clicks || 0,
              impressions: row.impressions || 0,
              ctr: (row.ctr || 0) * 100, // Convert to percentage for buildMoneyPageMetrics
              position: row.avgPosition || 0,
              avgPosition: row.avgPosition || 0,
              title: row.title || row.url
            }));
            
            // Use schemaAudit if available, otherwise pass null (function handles it)
            const auditSchema = schemaAudit || (saved && saved.schemaAudit) || null;
            // Use global function - it should be available after the function is defined
            // If not available, try to wait a bit for it to load
            if (typeof window.buildMoneyPageMetrics !== 'function') {
              debugLog(' buildMoneyPageMetrics not available, waiting 100ms...', 'warn');
              // Wait a bit for function to be defined (in case script hasn't finished loading)
              await new Promise(resolve => setTimeout(resolve, 100));
              
              if (typeof window.buildMoneyPageMetrics !== 'function') {
                debugLog(' buildMoneyPageMetrics still not available after wait, cannot rebuild Priority data', 'warn');
                // Function should be defined earlier in the script, but if not, we can't rebuild
                // Don't throw - just skip rebuilding and show empty state
                window.moneyPagePriorityData = [];
                window.moneySegmentMetrics = null;
              } else {
                debugLog(' buildMoneyPageMetrics now available after wait', 'success');
                // Function is now available, proceed with rebuild
                window.moneyPagePriorityData = window.buildMoneyPageMetrics(topPagesForPriority, auditSchema);
                
                // Use saved moneySegmentMetrics if available (from Supabase), otherwise rebuild
                if (saved && saved.moneySegmentMetrics) {
                  window.moneySegmentMetrics = saved.moneySegmentMetrics;
                  debugLog(` Using moneySegmentMetrics from saved data (Supabase)`, 'success');
                } else {
                  // Rebuild segment metrics
                  const behaviourScoresBySegment = {};
                  if (savedMetrics.behaviour) {
                    behaviourScoresBySegment.allMoney = savedMetrics.behaviour.score || 0;
                  }
                  if (typeof buildMoneySegmentSummary === 'function') {
                    window.moneySegmentMetrics = buildMoneySegmentSummary(window.moneyPagePriorityData, behaviourScoresBySegment);
                    debugLog(` Rebuilt moneySegmentMetrics from moneyPagePriorityData`, 'success');
                  } else {
                    debugLog(` buildMoneySegmentSummary is not available, cannot rebuild moneySegmentMetrics`, 'warn');
                    window.moneySegmentMetrics = null;
                  }
                }
                
                debugLog(` Rebuilt Money Pages Priority data from saved metrics: ${window.moneyPagePriorityData.length} pages`, 'success');
                
                // Save the rebuilt data back to localStorage
                if (window.moneyPagePriorityData && window.moneyPagePriorityData.length > 0) {
                  const updatedAudit = { ...saved, moneyPagePriorityData: window.moneyPagePriorityData, moneySegmentMetrics: window.moneySegmentMetrics };
                  safeSetLocalStorage('last_audit_results', updatedAudit);
                }
              }
            } else {
              // Function is available, proceed with rebuild
              window.moneyPagePriorityData = window.buildMoneyPageMetrics(topPagesForPriority, auditSchema);
              
              // Use saved moneySegmentMetrics if available (from Supabase), otherwise rebuild
              if (saved && saved.moneySegmentMetrics) {
                window.moneySegmentMetrics = saved.moneySegmentMetrics;
                debugLog(` Using moneySegmentMetrics from saved data (Supabase)`, 'success');
              } else {
                // Rebuild segment metrics
                const behaviourScoresBySegment = {};
                if (savedMetrics.behaviour) {
                  behaviourScoresBySegment.allMoney = savedMetrics.behaviour.score || 0;
                }
                if (typeof buildMoneySegmentSummary === 'function') {
                  window.moneySegmentMetrics = buildMoneySegmentSummary(window.moneyPagePriorityData, behaviourScoresBySegment);
                  debugLog(` Rebuilt moneySegmentMetrics from moneyPagePriorityData`, 'success');
                } else {
                  debugLog(` buildMoneySegmentSummary is not available, cannot rebuild moneySegmentMetrics`, 'warn');
                  window.moneySegmentMetrics = null;
                }
              }
              
              debugLog(` Rebuilt Money Pages Priority data from saved metrics: ${window.moneyPagePriorityData.length} pages`, 'success');
              
              // Save the rebuilt data back to localStorage
              if (window.moneyPagePriorityData && window.moneyPagePriorityData.length > 0) {
                const updatedAudit = { ...saved, moneyPagePriorityData: window.moneyPagePriorityData, moneySegmentMetrics: window.moneySegmentMetrics };
                safeSetLocalStorage('last_audit_results', updatedAudit);
              }
            }
          } catch (error) {
            debugLog(` Failed to rebuild Money Pages Priority data: ${error.message}`, 'warn');
            debugLog(`Error stack: ${error.stack}`, 'error');
            window.moneyPagePriorityData = [];
            window.moneySegmentMetrics = null;
          }
        } else {
          // No saved data available
          window.moneyPagePriorityData = window.moneyPagePriorityData || [];
          window.moneySegmentMetrics = window.moneySegmentMetrics || null;
          debugLog(' No Money Pages Priority data available (will be empty until next audit)', 'warn');
          debugLog(`Debug: saved=${!!saved}, savedMetrics=${!!savedMetrics}, savedMetrics.rows=${savedMetrics?.rows?.length || 0}, searchData=${!!(saved && saved.searchData || data)}`, 'warn');
        }
      }
      
      // Update retry button visibility
      updateRetryButtonVisibility(schemaAudit);
      
      debugLog('=== DISPLAY DASHBOARD: Starting ===', 'info');
      debugLog(`Using current audit data: schemaAudit=${schemaAudit ? 'yes' : 'no'}, localSignals=${currentLocalSignals ? 'yes' : 'no'}`, 'info');
      debugLog(`Scores object keys: ${scores ? Object.keys(scores).join(', ') : 'null'}`, 'info');
      debugLog(`Money Pages Metrics in scores: ${scores?.moneyPagesMetrics ? 'yes' : 'no'}`, 'info');
      if (saved && saved.scores) {
        debugLog(`Saved scores keys: ${Object.keys(saved.scores).join(', ')}`, 'info');
        debugLog(`Money Pages Metrics in saved scores: ${saved.scores.moneyPagesMetrics ? 'yes' : 'no'}`, 'info');
      }
      
      // Show dashboard first (canvas elements need to be visible for Chart.js)
      const dashboardDiv = document.getElementById('dashboard');
      if (!dashboardDiv) {
        debugLog(' Dashboard div not found', 'error');
        console.error('Dashboard div not found');
        return;
      }
      debugLog(' Dashboard div found', 'success');
      dashboardDiv.style.display = 'block';
      debugLog('Dashboard div displayed', 'info');
      
      // Update trend chart description with date range
      const dateRange = parseInt(document.getElementById('dateRange').value) || 30;
      const trendDesc = document.getElementById('trendChartDescription');
      if (trendDesc) {
        let rangeText = '';
        if (dateRange === 30) rangeText = 'Last 30 Days';
        else if (dateRange === 60) rangeText = 'Last 60 Days';
        else if (dateRange === 90) rangeText = 'Last 90 Days';
        else if (dateRange === 120) rangeText = 'Last 120 Days';
        else if (dateRange === 180) rangeText = 'Last 6 Months';
        else if (dateRange === 365) rangeText = 'Last 12 Months';
        else if (dateRange === 540) rangeText = 'Last 18 Months';
        else rangeText = `Last ${dateRange} Days`;
        trendDesc.textContent = `Historical performance tracking for Local Entity, Visibility, and Authority pillars over ${rangeText.toLowerCase()}.`;
      }
      
      const pillarNames = {
        localEntity: 'Local Entity',
        serviceArea: 'Service Area',
        authority: 'Authority',
        visibility: 'Visibility',
        contentSchema: 'Content / Schema'
      };
      
      // Define pillar weightings and order by weight (highest to lowest)
      const pillarWeights = {
        authority: 0.30,        // 30% - E-A-T is crucial for AI trust
        contentSchema: 0.25,     // 25% - Structured data is key for AI understanding
        visibility: 0.20,        // 20% - How AI surfaces your content
        localEntity: 0.15,       // 15% - Entity recognition important but not critical
        serviceArea: 0.10         // 10% - Less critical for AI search
      };
      
      // Sort pillars by weight (highest to lowest) for consistent ordering
      const getOrderedPillars = (scoresObj) => {
        // Filter out non-pillar keys (like authorityComponents)
        const validPillars = ['localEntity', 'serviceArea', 'authority', 'visibility', 'contentSchema'];
        return Object.entries(scoresObj)
          .filter(([key]) => validPillars.includes(key))
          .map(([key, scoreValue]) => {
            // Handle new Authority structure (object with score) or legacy (number)
            let score = scoreValue;
            if (key === 'authority' && typeof scoreValue === 'object' && scoreValue !== null) {
              score = scoreValue.score || 0;
            }
            return [key, score];
          })
          .sort((a, b) => {
          return (pillarWeights[b[0]] || 0) - (pillarWeights[a[0]] || 0);
        });
      };

      // Use current audit data (passed as parameter) for health dashboard
      // This ensures we use the most recent audit run data, not stale localStorage
      // Handle both status/data structure and direct data structure
      const hasLocalSignals = currentLocalSignals && (
        (currentLocalSignals.status === 'ok' && currentLocalSignals.data) ||
        (currentLocalSignals.data && (currentLocalSignals.data.napConsistencyScore !== undefined || currentLocalSignals.data.locationsScore !== undefined))
      );
      const localSignalsData = hasLocalSignals 
        ? (currentLocalSignals.data || currentLocalSignals)
        : null;
      
      // DEBUG: Log local signals status for health dashboard
      debugLog(`[Health Dashboard] Local signals: hasLocalSignals=${hasLocalSignals}, currentLocalSignals=${JSON.stringify(currentLocalSignals ? {status: currentLocalSignals.status, hasData: !!currentLocalSignals.data} : null)}`, 'info');
      
      // DEBUG: Verify brandOverlay is populated
      console.log('DEBUG brandOverlay', scores.brandOverlay);
      debugLog(`DEBUG brandOverlay: ${JSON.stringify(scores.brandOverlay)}`, 'info');
      
      // Calculate GAIO Health Score
      const aiGeoHealth = calculateAiGeoScore(scores, schemaAudit, snippetReadiness);
      debugLog(`GAIO Health: Score=${aiGeoHealth.aiGeoScore}, Status=${aiGeoHealth.aiGeoStatus}, Likelihood=${aiGeoHealth.aiSummaryLikelihood}`, 'info');
      
      // Extract component scores for health dashboard
      const authorityScore = (typeof scores.authority === 'object' && scores.authority !== null) 
        ? scores.authority.score 
        : scores.authority || 0;
      const contentScore = scores.contentSchema || 0;
      
      // Extract coverage and diversity from schema audit (same logic as calculateAiGeoScore)
      let coverageScore = scores.coverage || 0;
      let diversityScore = scores.diversity || 0;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        coverageScore = schemaData.coverage || 0;
        const allTypes = new Set();
        if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
          schemaData.allDetectedTypes.forEach(type => {
            if (type) allTypes.add(type);
          });
        } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          schemaData.schemaTypes.forEach(item => {
            if (item.type) allTypes.add(item.type);
          });
        }
        const uniqueTypesCount = allTypes.size;
        diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
      }
      
      const locationsScore = ((scores.localEntity || 0) + (scores.serviceArea || 0)) / 2;
      
      // Create GAIO Health Dashboard (insert before pillar cards)
      const healthDashboard = document.createElement('div');
      healthDashboard.id = 'ai-geo-health-dashboard';
      healthDashboard.style.marginBottom = '2rem';
      
      // Get pillar hints/comments for the comparison table
      const getPillarHint = (pillarKey, score, scoresObj, schemaAuditData, localSignalsData) => {
        switch(pillarKey) {
          case 'authority':
            const authComponents = scoresObj?.authorityComponents;
            if (authComponents) {
              if (authComponents.behaviour < 30 && authComponents.backlinks >= 50 && authComponents.reviews >= 50) {
                return 'Backlinks and reviews strong; CTR weak';
              } else if (authComponents.behaviour >= 50 && authComponents.ranking < 30) {
                return 'CTR strong; ranking needs improvement';
              } else if (authComponents.behaviour < 30) {
                return 'Behaviour is weak; backlinks/reviews strong';
              }
            }
            return 'E-A-T signals balanced';
          case 'content':
            if (score >= 90) return 'Fully structured, rich schema';
            if (score >= 70) return 'Good schema coverage';
            return 'Schema needs improvement';
          case 'coverage':
            if (score >= 90) return 'All priority pages ingested';
            if (score >= 70) return 'Most pages covered';
            return 'Coverage gaps present';
          case 'diversity':
            if (score >= 80) return 'Good mix of topics and formats';
            if (score >= 60) return 'Moderate diversity';
            return 'Limited schema diversity';
          case 'locations':
            if (score >= 85) return 'GBP + core locations covered well';
            if (score >= 70) return 'Local entity and service areas solid';
            return 'Location signals need strengthening';
          default:
            return '';
        }
      };
      
      // Phase 2: Get brand priority
      const getBrandPriority = (summary) => {
        const b = summary.brandOverlay;
        if (!b) return null;
        if (b.score >= 70) return null; // only suggest actions if score is below "Strong"
        
        const share = b.brandQueryShare || 0;
        const ctr = b.brandCtr || 0;
        const entity = b.entityScore ?? 0;
        const review = b.reviewScore ?? 0;
        
        // Decide the most important brand-related action
        if (share < 0.10) {
          return {
            pillar: 'Brand & Entity',
            severity: 'medium',
            message: 'Increase the share of branded searches (e.g. "Alan Ranger Photography") by using your full brand name consistently in campaigns, key landing pages and off-site mentions.',
            link: '#pillarCards',
            score: b.score
          };
        }
        
        if (ctr < 0.25) {
          return {
            pillar: 'Brand & Entity',
            severity: 'medium',
            message: 'Improve titles and meta descriptions on core brand pages (home, about, tuition, workshops) to raise CTR on branded queries above 25%.',
            link: '#pillarCards',
            score: b.score
          };
        }
        
        if (entity < 70) {
          return {
            pillar: 'Brand & Entity',
            severity: 'medium',
            message: 'Strengthen entity signals by maintaining NAP consistency, adding more detail to GBP and About/Press pages, and earning mentions on relevant third-party sites.',
            link: '#pillarCards',
            score: b.score
          };
        }
        
        if (review < 70) {
          return {
            pillar: 'Brand & Entity',
            severity: 'medium',
            message: 'Boost review signals with a steady flow of new Google reviews and clear calls-to-review after workshops and lessons.',
            link: '#pillarCards',
            score: b.score
          };
        }
        
        // Fallback for mid-range scores
        return {
          pillar: 'Brand & Entity',
          severity: 'low',
          message: 'Continue building branded visibility by consolidating strong informational content into clear "hub" pages that use your brand name and service area.',
          link: '#pillarCards',
          score: b.score
        };
      };
      
      // Generate priorities list from pillar diagnostics
      // Helper to generate money pages priority (Phase 2)
      function getMoneyPagesPriority(moneyPagesMetrics) {
        if (!moneyPagesMetrics || !moneyPagesMetrics.rows || !moneyPagesMetrics.rows.length) {
          debugLog('getMoneyPagesPriority: No rows data', 'warn');
          return null;
        }
        
        const { rows, summaryByCategory, overview } = moneyPagesMetrics;
        const moneyImpressions = overview.moneyImpressions || 0;
        if (moneyImpressions === 0) {
          debugLog('getMoneyPagesPriority: No money impressions', 'warn');
          return null;
        }
        
        const high = summaryByCategory?.HIGH_OPPORTUNITY || { count: 0, impressions: 0 };
        const vis = summaryByCategory?.VISIBILITY_FIX || { count: 0, impressions: 0 };
        
        const highCount = high.count || 0;
        const highImps = high.impressions || 0;
        const visCount = vis.count || 0;
        const visImps = vis.impressions || 0;
        
        debugLog(`getMoneyPagesPriority: high=${highCount} pages/${highImps} imps, vis=${visCount} pages/${visImps} imps, total=${moneyImpressions}`, 'info');
        
        const totalFocusImps = highImps + visImps;
        if (totalFocusImps === 0) {
          debugLog('getMoneyPagesPriority: No focus impressions (high+vis)', 'warn');
          return null;
        }
        
        const sharePct = (totalFocusImps / moneyImpressions) * 100;
        
        let severity = 'medium';
        if (sharePct >= 60) severity = 'high';
        else if (sharePct <= 25) severity = 'low';
        
        const topExamples = rows
          .filter((r) => r.category === 'HIGH_OPPORTUNITY' || r.category === 'VISIBILITY_FIX')
          .slice(0, 3)
          .map((r) => {
            try {
              const urlObj = new URL(r.url);
              return urlObj.pathname.split('/').filter(p => p).pop() || r.url;
            } catch (e) {
              return r.url;
            }
          });
        
        const description =
          `Money pages: ${highCount} high-opportunity and ${visCount} visibility-fix URLs ` +
          `account for ${sharePct.toFixed(1)}% of money-page impressions. ` +
          `Prioritise improving titles/meta, "best" framing, and FAQs on these pages.`;
        
        const detail =
          topExamples.length
            ? `Examples: ${topExamples.join(', ')}`
            : '';
        
        const priority = {
          pillar: 'Money Pages',
          severity, // 'high' | 'medium' | 'low'
          message: description,
          detail: detail,
          link: '#money-pages-section'
        };
        
        debugLog(` Money pages priority created: ${JSON.stringify(priority)}`, 'success');
        return priority;
      }
      
      const getPriorities = (scoresObj, schemaAuditData, localSignalsData, authorityComponents) => {
        const priorities = [];
        
        // Authority priorities
        if (authorityComponents) {
          if (authorityComponents.behaviour < 30) {
            priorities.push({
              pillar: 'Authority',
              severity: 'high',
              message: 'Improve Top-10 CTR on money pages (Authority  Behaviour table, status = Poor)',
              link: '#authority-top-pages-section'
            });
          }
          if (authorityComponents.ranking < 30) {
            priorities.push({
              pillar: 'Authority',
              severity: 'medium',
              message: 'Improve average position and top-10 impression share',
              link: '#authority-top-pages-section'
            });
          }
        }
        
        // Content/Schema priorities
        if (schemaAuditData && schemaAuditData.status === 'ok' && schemaAuditData.data) {
          const schemaData = schemaAuditData.data;
          if (schemaData.coverage < 100) {
            // Use missingSchemaCount if available, otherwise calculate from coverage
            const missingCount = schemaData.missingSchemaCount || 
              (schemaData.totalPages ? Math.round((100 - schemaData.coverage) / 100 * schemaData.totalPages) : 0);
            priorities.push({
              pillar: 'Content',
              severity: 'medium',
              message: `Add schema to ${missingCount > 0 ? missingCount : 'remaining'} pages (Content/Schema  coverage ${schemaData.coverage != null ? schemaData.coverage.toFixed(0) : 'N/A'}%)`,
              link: '#pillarCards'
            });
          }
          const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
          // PRIORITY: Use foundation object first (most reliable source) - same logic as Content/Schema card
          let foundationPresent = 0;
          if (schemaData.foundation && typeof schemaData.foundation === 'object') {
            // Use foundation object directly - count how many are true (same as Content/Schema card)
            foundationPresent = foundationTypes.filter(type => schemaData.foundation[type] === true).length;
          } else {
            // Fallback: check allDetectedTypes or schemaTypes
            const allTypes = new Set();
            if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
              schemaData.allDetectedTypes.forEach(type => {
                if (type) allTypes.add(type);
              });
            } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
              schemaData.schemaTypes.forEach(item => {
                if (item && typeof item === 'object' && item.type) {
                  allTypes.add(item.type);
                } else if (typeof item === 'string') {
                  allTypes.add(item);
                }
              });
            }
            foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
          }
          
          if (foundationPresent < 4) {
            // Determine missing types based on which data structure was used
            const missingTypes = schemaData.foundation && typeof schemaData.foundation === 'object'
              ? foundationTypes.filter(t => schemaData.foundation[t] !== true)
              : foundationTypes.filter(t => {
                  // Fallback: check allTypes set if foundation object not available
                  const allTypes = new Set();
                  if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
                    schemaData.allDetectedTypes.forEach(type => { if (type) allTypes.add(type); });
                  } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
                    schemaData.schemaTypes.forEach(item => {
                      if (item && typeof item === 'object' && item.type) allTypes.add(item.type);
                      else if (typeof item === 'string') allTypes.add(item);
                    });
                  }
                  return !allTypes.has(t);
                });
            
            priorities.push({
              pillar: 'Content',
              severity: 'high',
              message: `Add missing foundation schemas: ${missingTypes.join(', ')}`,
              link: '#pillarCards'
            });
          }
        }
        
        // Locations priorities
        if (localSignalsData) {
          if (localSignalsData.napConsistencyScore < 100) {
            priorities.push({
              pillar: 'Locations',
              severity: 'medium',
              message: `Improve NAP consistency (currently ${localSignalsData.napConsistencyScore}%)`,
              link: '#pillarCards'
            });
          }
          const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
          if (serviceAreasCount < 5) {
            priorities.push({
              pillar: 'Locations',
              severity: 'low',
              message: `Add more service areas to Google Business Profile (currently ${serviceAreasCount}, target: 5+)`,
              link: '#pillarCards'
            });
          }
        }
        
        // Phase 2: Add brand priority if applicable
        const brandPriority = getBrandPriority ? getBrandPriority({ brandOverlay: scoresObj.brandOverlay }) : null;
        if (brandPriority) {
          priorities.push(brandPriority);
        }
        
        // Phase 2: Add money pages priority if applicable
        debugLog(`Checking for money pages priority - moneyPagesMetrics exists: ${!!scoresObj.moneyPagesMetrics}`, 'info');
        if (scoresObj.moneyPagesMetrics) {
          debugLog(`Money pages metrics: rows=${scoresObj.moneyPagesMetrics.rows?.length || 0}, summaryByCategory=${!!scoresObj.moneyPagesMetrics.summaryByCategory}`, 'info');
        }
        const moneyPriority = getMoneyPagesPriority(scoresObj.moneyPagesMetrics);
        if (moneyPriority) {
          debugLog(` Adding money pages priority: ${moneyPriority.message}`, 'success');
          priorities.push(moneyPriority);
        } else {
          debugLog(' No money pages priority generated', 'warn');
        }
        
        // Sort by severity (high > medium > low) and limit to top items
        const severityOrder = { high: 3, medium: 2, low: 1 };
        const sorted = priorities.sort((a, b) => severityOrder[b.severity] - severityOrder[a.severity]);
        
        // Allow up to 4 items when brand or money pages priorities are present, or 5 otherwise
        const hasOverlayPriorities = brandPriority || moneyPriority;
        const maxItems = hasOverlayPriorities ? 4 : 5;
        return sorted.slice(0, maxItems);
      };
      
      const priorities = getPriorities(scores, schemaAudit, localSignalsData, scores.authorityComponents);
      
      healthDashboard.innerHTML = `
        <!-- Updated: 2024 - Site AI Health title, 0% marker removed -->
        <div style="background: white; padding: 2rem; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-bottom: 2rem;">
          <!-- GAIO Health Top Card -->
          <div style="text-align: center; margin-bottom: 3rem; padding: 2rem 0; border-bottom: 2px solid #e2e8f0;">
            <div style="display: flex; align-items: flex-start; justify-content: center; gap: 4rem; margin-bottom: 2rem; flex-wrap: wrap;">
              <!-- Dial Section with Title -->
              <div style="display: flex; flex-direction: column; align-items: center;">
                <!-- Section Title - Centered over dial -->
                <h2 style="font-size: 2rem; font-weight: 700; color: #1e293b; margin-bottom: 1.5rem; letter-spacing: -0.02em; text-align: center; width: 100%;">
                  Site AI Health
                </h2>
                <!-- Circular Progress Ring - Speedometer Style -->
                <div style="position: relative; width: 520px; height: 520px; margin: 0 auto; overflow: visible;">
                ${(() => {
                  const score = aiGeoHealth.aiGeoScore;
                  const center = 260;
                  const radius = 195;
                  const strokeWidth = 26;
                  const normalizedRadius = radius - strokeWidth / 2;
                  
                  // Determine colors based on status
                  const color = aiGeoHealth.aiGeoStatus === 'green' ? '#10b981' : 
                               aiGeoHealth.aiGeoStatus === 'amber' ? '#f59e0b' : '#ef4444';
                  const bgColor = aiGeoHealth.aiGeoStatus === 'green' ? '#d1fae5' : 
                                 aiGeoHealth.aiGeoStatus === 'amber' ? '#fef3c7' : '#fee2e2';
                  
                  // Angle calculations: 0% at 12:05 (-85), 50% at 6pm (90), 100% at 12pm (-90)
                  const startAngle = -85; // 12:05 position
                  const endAngle = -90;   // 12pm position
                  const angleRange = 360 - 5; // Full circle minus 5 gap
                  
                  // Helper function to create arc path
                  const createArc = (start, end, r) => {
                    const startRad = (start * Math.PI) / 180;
                    const endRad = (end * Math.PI) / 180;
                    const largeArc = Math.abs(end - start) > 180 ? 1 : 0;
                    const x1 = center + r * Math.cos(startRad);
                    const y1 = center + r * Math.sin(startRad);
                    const x2 = center + r * Math.cos(endRad);
                    const y2 = center + r * Math.sin(endRad);
                    return `M ${x1} ${y1} A ${r} ${r} 0 ${largeArc} 1 ${x2} ${y2}`;
                  };
                  
                  // Calculate segment angles
                  const angle0 = startAngle;
                  const angle50 = startAngle + angleRange * 0.5;
                  const angle70 = startAngle + angleRange * 0.7;
                  const angle100 = startAngle + angleRange;
                  
                  // Calculate current score angle
                  const scoreAngle = startAngle + (score / 100) * angleRange;
                  const scoreRad = (scoreAngle * Math.PI) / 180;
                  
                  return `
                    <svg width="520" height="520" style="filter: drop-shadow(0 4px 12px rgba(0,0,0,0.08)); overflow: visible;">
                      <!-- Background circle -->
                      <circle
                        cx="${center}"
                        cy="${center}"
                        r="${normalizedRadius}"
                        fill="none"
                        stroke="#f1f5f9"
                        stroke-width="${strokeWidth}"
                      />
                      
                      <!-- Red segment: 0-50% -->
                      <path
                        d="${createArc(angle0, angle50, normalizedRadius)}"
                        fill="none"
                        stroke="#ef4444"
                        stroke-width="${strokeWidth}"
                        stroke-linecap="round"
                      />
                      
                      <!-- Amber segment: 50-70% -->
                      <path
                        d="${createArc(angle50, angle70, normalizedRadius)}"
                        fill="none"
                        stroke="#f59e0b"
                        stroke-width="${strokeWidth}"
                        stroke-linecap="round"
                      />
                      
                      <!-- Green segment: 70-100% -->
                      <path
                        d="${createArc(angle70, angle100, normalizedRadius)}"
                        fill="none"
                        stroke="#10b981"
                        stroke-width="${strokeWidth}"
                        stroke-linecap="round"
                      />
                      
                      <!-- Tick marks for GAIO Score, AI Summary Likelihood, and Brand & Entity -->
                      <g>
                        ${(() => {
                          // Get all three scores
                          const aiGeoScoreValue = score; // Already calculated
                          const brandScore = scores?.brandOverlay?.score || 0;
                          const aiSummaryScore = aiGeoHealth?.aiSummary?.score || 0;
                          
                          // Calculate angles for each score
                          const aiGeoAngle = startAngle + (aiGeoScoreValue / 100) * angleRange;
                          const brandAngle = startAngle + (brandScore / 100) * angleRange;
                          const aiSummaryAngle = startAngle + (aiSummaryScore / 100) * angleRange;
                          
                          const aiGeoRad = (aiGeoAngle * Math.PI) / 180;
                          const brandRad = (brandAngle * Math.PI) / 180;
                          const aiSummaryRad = (aiSummaryAngle * Math.PI) / 180;
                          
                          // GAIO Score tick mark (solid, thick) - scaled 30% larger
                          const aiGeoTickLength = 31.2;
                          const aiGeoTickWidth = 5.2;
                          const aiGeoTickX1 = center + (normalizedRadius - aiGeoTickLength) * Math.cos(aiGeoRad);
                          const aiGeoTickY1 = center + (normalizedRadius - aiGeoTickLength) * Math.sin(aiGeoRad);
                          const aiGeoTickX2 = center + (normalizedRadius + aiGeoTickLength) * Math.cos(aiGeoRad);
                          const aiGeoTickY2 = center + (normalizedRadius + aiGeoTickLength) * Math.sin(aiGeoRad);
                          
                          // AI Summary Likelihood tick mark (solid, medium) - scaled 30% larger
                          const aiSummaryTickLength = 26;
                          const aiSummaryTickWidth = 3.9;
                          const aiSummaryTickX1 = center + (normalizedRadius - aiSummaryTickLength) * Math.cos(aiSummaryRad);
                          const aiSummaryTickY1 = center + (normalizedRadius - aiSummaryTickLength) * Math.sin(aiSummaryRad);
                          const aiSummaryTickX2 = center + (normalizedRadius + aiSummaryTickLength) * Math.cos(aiSummaryRad);
                          const aiSummaryTickY2 = center + (normalizedRadius + aiSummaryTickLength) * Math.sin(aiSummaryRad);
                          
                          // Brand & Entity tick mark (dashed, medium) - scaled 30% larger
                          const brandTickLength = 23.4;
                          const brandTickWidth = 3.9;
                          const brandTickX1 = center + (normalizedRadius - brandTickLength) * Math.cos(brandRad);
                          const brandTickY1 = center + (normalizedRadius - brandTickLength) * Math.sin(brandRad);
                          const brandTickX2 = center + (normalizedRadius + brandTickLength) * Math.cos(brandRad);
                          const brandTickY2 = center + (normalizedRadius + brandTickLength) * Math.sin(brandRad);
                          
                          // Colors based on scores (consistent with badge logic)
                          // AI Summary uses same RAG bands as GAIO: 70 green, 50 amber, <50 red
                          const aiSummaryColor = aiSummaryScore >= 70 ? '#10b981' : aiSummaryScore >= 50 ? '#f59e0b' : '#ef4444';
                          const brandColor = brandScore >= 70 ? '#10b981' : brandScore >= 40 ? '#f59e0b' : '#ef4444';
                          
                          return `
                            <!-- GAIO Score tick mark (main score) -->
                            <line x1="${aiGeoTickX1}" y1="${aiGeoTickY1}" 
                                  x2="${aiGeoTickX2}" y2="${aiGeoTickY2}" 
                                  stroke="${color}" 
                                  stroke-width="${aiGeoTickWidth}" 
                                  stroke-linecap="round"
                                  style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));"/>
                            
                            <!-- AI Summary Likelihood tick mark -->
                            ${aiSummaryScore > 0 ? `
                            <line x1="${aiSummaryTickX1}" y1="${aiSummaryTickY1}" 
                                  x2="${aiSummaryTickX2}" y2="${aiSummaryTickY2}" 
                                  stroke="${aiSummaryColor}" 
                                  stroke-width="${aiSummaryTickWidth}" 
                                  stroke-linecap="round"
                                  style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));"/>
                            ` : ''}
                            
                            <!-- Brand & Entity score tick mark -->
                            ${brandScore > 0 ? `
                            <line x1="${brandTickX1}" y1="${brandTickY1}" 
                                  x2="${brandTickX2}" y2="${brandTickY2}" 
                                  stroke="${brandColor}" 
                                  stroke-width="${brandTickWidth}" 
                                  stroke-linecap="round"
                                  stroke-dasharray="4,2"
                                  style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));"/>
                            ` : ''}
                          `;
                        })()}
                      </g>
                      
                      <!-- Needle indicator for current score -->
                      <g>
                        <line
                          x1="${center}"
                          y1="${center}"
                          x2="${center + (normalizedRadius + 19.5) * Math.cos(scoreRad)}"
                          y2="${center + (normalizedRadius + 19.5) * Math.sin(scoreRad)}"
                          stroke="${color}"
                          stroke-width="5.2"
                          stroke-linecap="round"
                          style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2)); transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1);"
                        />
                        <!-- Needle center dot -->
                        <circle
                          cx="${center}"
                          cy="${center}"
                          r="10.4"
                          fill="${color}"
                          style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));"
                        />
                      </g>
                      
                      <!-- Labels: 50%, 100%, and all three score indicators -->
                      <g>
                        ${(() => {
                          // Get all three scores
                          const aiGeoScoreValue = score;
                          const brandScore = scores?.brandOverlay?.score || 0;
                          const aiSummaryScore = aiGeoHealth?.aiSummary?.score || 0;
                          
                          // Calculate angles
                          const aiGeoAngle = startAngle + (aiGeoScoreValue / 100) * angleRange;
                          const brandAngle = startAngle + (brandScore / 100) * angleRange;
                          const aiSummaryAngle = startAngle + (aiSummaryScore / 100) * angleRange;
                          
                          // Colors - AI Summary uses same RAG bands as GAIO: 70 green, 50 amber, <50 red
                          const aiSummaryColor = aiSummaryScore >= 70 ? '#10b981' : aiSummaryScore >= 50 ? '#f59e0b' : '#ef4444';
                          const brandColor = brandScore >= 70 ? '#10b981' : brandScore >= 40 ? '#f59e0b' : '#ef4444';
                          
                          const labels = [
                            { value: 100, angle: angle100, color: '#10b981' },  // Scale marker
                            { value: aiGeoScoreValue, angle: aiGeoAngle, color: color, label: 'GAIO' },  // Main score
                            ...(aiSummaryScore > 0 ? [{ value: aiSummaryScore, angle: aiSummaryAngle, color: aiSummaryColor, label: 'AI Summary' }] : []),
                            ...(brandScore > 0 ? [{ value: brandScore, angle: brandAngle, color: brandColor, label: 'Brand' }] : [])
                          ];
                          
                          return labels.map(m => {
                            const rad = (m.angle * Math.PI) / 180;
                            const labelOffset = 65;
                            const labelX = center + (normalizedRadius + labelOffset) * Math.cos(rad);
                            const labelY = center + (normalizedRadius + labelOffset) * Math.sin(rad);
                            
                            // For scores, show value with label below
                            if (m.label) {
                              return `
                                <g>
                                  <text x="${labelX}" y="${labelY - 10}" 
                                        text-anchor="middle" dominant-baseline="middle"
                                        fill="${m.color}" 
                                        font-size="18" font-weight="700"
                                        style="text-shadow: 0 1px 2px rgba(255,255,255,0.8);">${m.value}</text>
                                  <text x="${labelX}" y="${labelY + 13}" 
                                        text-anchor="middle" dominant-baseline="middle"
                                        fill="#64748b" 
                                        font-size="13" font-weight="500"
                                        style="text-shadow: 0 1px 2px rgba(255,255,255,0.8);">${m.label}</text>
                                </g>
                              `;
                            } else {
                              // Scale markers (50, 100)
                              return `
                                <text x="${labelX}" y="${labelY}" 
                                      text-anchor="middle" dominant-baseline="middle"
                                      fill="${m.color}" 
                                      font-size="21" font-weight="700"
                                      style="text-shadow: 0 1px 2px rgba(255,255,255,0.8);">${m.value}</text>
                              `;
                            }
                          }).join('');
                        })()}
                      </g>
                    </svg>
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; width: 100%; pointer-events: none;">
                      <div style="font-size: 5.5rem; font-weight: 800; color: ${color}; line-height: 1; margin-bottom: 0.5rem; letter-spacing: -0.03em; text-shadow: 0 2px 12px ${color}25;">
                        ${score}
                      </div>
                      <div style="font-size: 0.9rem; color: #64748b; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; margin-bottom: 0.75rem;">
                        GAIO Score
                      </div>
                      <div style="padding: 0.5rem 1rem; background: ${bgColor}; border-radius: 24px; display: inline-block;">
                        <span style="font-size: 0.875rem; color: ${color}; font-weight: 700;">
                          ${aiGeoHealth.aiGeoStatus === 'green' ? ' Excellent' : aiGeoHealth.aiGeoStatus === 'amber' ? ' Good' : ' Needs Work'}
                        </span>
                      </div>
                    </div>
                  `;
                })()}
                </div>
              </div>
              <div style="display: flex; flex-direction: column; align-items: center; gap: 1.5rem; justify-content: center;">
                <div style="text-align: center;">
                  <div style="font-size: 0.9rem; color: #64748b; margin-bottom: 0.5rem; font-weight: 500;">GAIO Status:</div>
                  ${(() => {
                    // Build GAIO score breakdown summary
                    const authorityScore = (typeof scores.authority === 'object' && scores.authority !== null) 
                      ? scores.authority.score 
                      : scores.authority || 0;
                    const contentScore = scores.contentSchema || 0;
                    const visibilityScore = scores.visibility || 0;
                    const localEntityScore = scores.localEntity || 0;
                    const serviceAreaScore = scores.serviceArea || 0;
                    
                    const aiGeoBreakdown = `GAIO Score Breakdown:
 Authority: ${Math.round(authorityScore)} (30% weight)
 Content/Schema: ${Math.round(contentScore)} (25% weight)
 Visibility: ${Math.round(visibilityScore)} (20% weight)
 Local Entity: ${Math.round(localEntityScore)} (15% weight)
 Service Area: ${Math.round(serviceAreaScore)} (10% weight)
Final Score: ${aiGeoHealth.aiGeoScore}/100`;
                    
                    return `
                      <div style="display: flex; align-items: flex-start; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                        <span class="rag-badge ${aiGeoHealth.aiGeoStatus}" style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: help; width: 170px; justify-content: center; flex-shrink: 0;" title="${aiGeoBreakdown}">
                          ${aiGeoHealth.aiGeoStatus === 'green' ? 'Green' : aiGeoHealth.aiGeoStatus === 'amber' ? 'Amber' : 'Red'} (${aiGeoHealth.aiGeoScore}/100)
                          <span style="display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 50%; background: #3b82f6; color: white; font-size: 0.75rem; font-weight: 700; cursor: help; flex-shrink: 0;" title="${aiGeoBreakdown}">i</span>
                        </span>
                        <div style="background: white; border: 1px solid #e2e8f0; border-radius: 6px; padding: 0.75rem 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 0.85rem; color: #1e293b; line-height: 1.6; width: 320px; min-height: 140px;">
                          <div style="font-weight: 600; margin-bottom: 0.5rem; color: #1e293b;">GAIO Score Breakdown:</div>
                          <div style="color: #64748b;">
                            <div> Authority: ${Math.round(authorityScore)} (30% weight)</div>
                            <div> Content/Schema: ${Math.round(contentScore)} (25% weight)</div>
                            <div> Visibility: ${Math.round(visibilityScore)} (20% weight)</div>
                            <div> Local Entity: ${Math.round(localEntityScore)} (15% weight)</div>
                            <div> Service Area: ${Math.round(serviceAreaScore)} (10% weight)</div>
                            <div style="margin-top: 0.5rem; font-weight: 600; color: #1e293b;">Final Score: ${aiGeoHealth.aiGeoScore}/100</div>
                          </div>
                        </div>
                      </div>
                    `;
                  })()}
                </div>
                <div style="text-align: center;">
                  <div style="display: flex; flex-direction: column; gap: 1rem;">
                    <div>
                      <div style="font-size: 0.9rem; color: #64748b; margin-bottom: 0.5rem; font-weight: 500;">AI summary likelihood:</div>
                      ${(() => {
                        // Phase 2: Use aiSummary.label if available, otherwise fallback to aiSummaryLikelihood
                        const aiSummary = aiGeoHealth.aiSummary || { label: aiGeoHealth.aiSummaryLikelihood || 'Low', score: 0 };
                        // Ensure label is capitalized correctly
                        let label = aiSummary.label || 'Low';
                        if (typeof label === 'string') {
                          label = label.charAt(0).toUpperCase() + label.slice(1).toLowerCase();
                        }
                        const score = aiSummary.score || 0;
                        // Use same RAG bands as GAIO Score: 70 green, 50 amber, <50 red
                        const bgColor = score >= 70 ? '#d1fae5' : score >= 50 ? '#fef3c7' : '#fee2e2';
                        const textColor = score >= 70 ? '#065f46' : score >= 50 ? '#92400e' : '#991b1b';
                        
                        // Build AI Summary breakdown
                        // Handle both number format (legacy) and object format (if it exists)
                        const snippetReadinessScore = typeof snippetReadiness === 'number' 
                          ? snippetReadiness 
                          : (snippetReadiness?.overallScore || 0);
                        const visibilityScore = scores.visibility || 0;
                        const brandScore = scores.brandOverlay?.score || 0;
                        
                        const aiSummaryBreakdown = `AI Summary Likelihood Breakdown:
 Snippet Readiness: ${Math.round(snippetReadinessScore)}/100 (50% weight)
 Visibility: ${Math.round(visibilityScore)}/100 (30% weight)
 Brand & Entity: ${Math.round(brandScore)}/100 (20% weight)
Final Score: ${score}/100

Based on snippet-friendly content (FAQ / HowTo / Article / Event blocks), how often your content appears in rich results, and the strength of your brand & entity signals (branded searches, reviews, knowledge panel).`;
                        
                        return `
                          <div style="display: flex; align-items: flex-start; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                            <span style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 6px; font-size: 1rem; font-weight: 600; background: ${bgColor}; color: ${textColor}; cursor: help; width: 170px; justify-content: center; flex-shrink: 0;" title="${aiSummaryBreakdown}">
                              ${label} (${score}/100)
                              <span style="display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 50%; background: #3b82f6; color: white; font-size: 0.75rem; font-weight: 700; cursor: help; flex-shrink: 0;" title="${aiSummaryBreakdown}">i</span>
                            </span>
                            <div style="background: white; border: 1px solid #e2e8f0; border-radius: 6px; padding: 0.75rem 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 0.85rem; color: #1e293b; line-height: 1.6; width: 320px; min-height: 140px;">
                              <div style="font-weight: 600; margin-bottom: 0.5rem; color: #1e293b;">AI Summary Likelihood Breakdown:</div>
                              <div style="color: #64748b;">
                                <div> Snippet Readiness: ${Math.round(snippetReadinessScore)}/100 (50% weight)</div>
                                <div> Visibility: ${Math.round(visibilityScore)}/100 (30% weight)</div>
                                <div> Brand & Entity: ${Math.round(brandScore)}/100 (20% weight)</div>
                                <div style="margin-top: 0.5rem; font-weight: 600; color: #1e293b;">Final Score: ${score}/100</div>
                              </div>
                            </div>
                          </div>
                        `;
                      })()}
                    </div>
                    <div>
                      <div style="font-size: 0.9rem; color: #64748b; margin-bottom: 0.5rem; font-weight: 500;">Brand & entity:</div>
                      ${(() => {
                        // Brand & Entity chip - show even if missing (with N/A)
                        const brandOverlay = scores.brandOverlay;
                        if (brandOverlay) {
                          const score = brandOverlay.score || 0;
                          const label = brandOverlay.label || 'Weak';
                          const bgColor = score >= 70 ? '#d1fae5' : score >= 40 ? '#fef3c7' : '#fee2e2';
                          const textColor = score >= 70 ? '#065f46' : score >= 40 ? '#92400e' : '#991b1b';
                          const brandQueryShare = brandOverlay.brandQueryShare != null ? (brandOverlay.brandQueryShare * 100).toFixed(1) : 'N/A';
                          const brandCtr = brandOverlay.brandCtr != null ? (brandOverlay.brandCtr * 100).toFixed(1) : 'N/A';
                          const brandAvgPos = brandOverlay.brandAvgPosition != null ? brandOverlay.brandAvgPosition.toFixed(1) : 'N/A';
                          const reviewScore = brandOverlay.reviewScore != null ? brandOverlay.reviewScore : 'N/A';
                          const entityScore = brandOverlay.entityScore != null ? brandOverlay.entityScore : 'N/A';
                          const brandTooltip = `Brand & Entity Overlay Breakdown:
 Brand Query Share: ${brandQueryShare}% of impressions
 Brand CTR: ${brandCtr}%
 Avg Brand Position: ${brandAvgPos}
 Review Score: ${reviewScore}/100
 Entity Score: ${entityScore}/100
Final Score: ${score}/100`;
                          return `
                            <div style="display: flex; align-items: flex-start; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                              <span style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 6px; font-size: 1rem; font-weight: 600; background: ${bgColor}; color: ${textColor}; cursor: help; width: 170px; justify-content: center; flex-shrink: 0;" title="${brandTooltip}">
                                ${label} (${score}/100)
                                <span style="display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 50%; background: #3b82f6; color: white; font-size: 0.75rem; font-weight: 700; cursor: help; flex-shrink: 0;" title="${brandTooltip}">i</span>
                              </span>
                              <div style="background: white; border: 1px solid #e2e8f0; border-radius: 6px; padding: 0.75rem 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 0.85rem; color: #1e293b; line-height: 1.6; width: 320px; min-height: 140px;">
                                <div style="font-weight: 600; margin-bottom: 0.5rem; color: #1e293b;">Brand & Entity Overlay Breakdown:</div>
                                <div style="color: #64748b;">
                                  <div> Brand Query Share: ${brandQueryShare}% of impressions</div>
                                  <div> Brand CTR: ${brandCtr}%</div>
                                  <div> Avg Brand Position: ${brandAvgPos}</div>
                                  <div> Review Score: ${reviewScore}/100</div>
                                  <div> Entity Score: ${entityScore}/100</div>
                                  <div style="margin-top: 0.5rem; font-weight: 600; color: #1e293b;">Final Score: ${score}/100</div>
                                </div>
                              </div>
                            </div>
                          `;
                        } else {
                          // Show N/A if brandOverlay is missing
                          const brandTooltip = 'No brand overlay data available  run an audit with access to query data.';
                          return `
                            <div style="display: flex; align-items: flex-start; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                              <span style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 6px; font-size: 1rem; font-weight: 600; background: #e5e7eb; color: #6b7280; cursor: help; width: 170px; justify-content: center; flex-shrink: 0;" title="${brandTooltip}">
                                N/A
                                <span style="display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 50%; background: #3b82f6; color: white; font-size: 0.75rem; font-weight: 700; cursor: help; flex-shrink: 0;" title="${brandTooltip}">i</span>
                              </span>
                              <div style="background: white; border: 1px solid #e2e8f0; border-radius: 6px; padding: 0.75rem 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 0.85rem; color: #64748b; width: 320px; min-height: 140px; display: flex; align-items: center;">
                                No brand overlay data available  run an audit with access to query data.
                              </div>
                            </div>
                          `;
                        }
                      })()}
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <p style="margin: 0; font-size: 0.95rem; color: #475569; font-weight: 500;">
              Based on Authority, Content & Schema, Coverage, Diversity, Locations and Brand & entity signals.
            </p>
          </div>
          
          <!-- This Month's Priorities -->
          ${priorities.length > 0 ? `
          <div>
            <h3 style="margin: 0 0 1rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">This Month's Priorities</h3>
            <div style="background: #f8f9fa; border-radius: 8px; padding: 1rem; border-left: 4px solid #ef4444;">
              <ul style="margin: 0; padding-left: 1.5rem; list-style: none;">
                ${priorities.map((p, idx) => {
                  // Phase 2: For brand priorities, use brandOverlay score for color
                  let severityColor;
                  if (p.pillar === 'Brand & Entity' && p.score !== undefined) {
                    severityColor = p.score >= 70 ? '#10b981' : p.score >= 40 ? '#f59e0b' : '#ef4444';
                  } else {
                    severityColor = p.severity === 'high' ? '#ef4444' : p.severity === 'medium' ? '#f59e0b' : '#10b981';
                  }
                  return `
                    <li style="margin-bottom: ${idx < priorities.length - 1 ? '0.75rem' : '0'}; padding-left: 0.5rem; position: relative;">
                      <span style="position: absolute; left: -1.5rem; color: ${severityColor}; font-weight: 700;"></span>
                      <a href="${p.link}" style="color: #1e293b; text-decoration: none; font-weight: 500; border-bottom: 1px solid transparent; transition: border-color 0.2s;" onmouseover="this.style.borderBottomColor='#1e293b';" onmouseout="this.style.borderBottomColor='transparent';">
                        ${p.message}
                      </a>
                    </li>
                  `;
                }).join('')}
              </ul>
            </div>
          </div>
          ` : ''}
        </div>
      `;
      
      // Insert health dashboard before pillar cards
      const pillarCards = document.getElementById('pillarCards');
      if (!pillarCards) {
        debugLog(' Pillar cards container not found', 'error');
        console.error('Pillar cards container (id="pillarCards") not found in DOM');
        return;
      }
      debugLog(' Pillar cards container found', 'success');
      
      // Remove existing health dashboard if present
      const existingHealth = document.getElementById('ai-geo-health-dashboard');
      if (existingHealth) {
        existingHealth.remove();
      }
      
      // Insert health dashboard before pillar cards
      pillarCards.parentNode.insertBefore(healthDashboard, pillarCards);
      debugLog(' GAIO Health Dashboard created', 'success');
      
      // Circular progress ring is SVG-based, no additional drawing needed
      
      // Clear pillar cards for fresh render
      pillarCards.innerHTML = '';

      const orderedPillars = getOrderedPillars(scores);
      debugLog(`Creating ${orderedPillars.length} pillar cards from scores: ${JSON.stringify(scores)}`, 'info');
      
      if (orderedPillars.length === 0) {
        debugLog(' No pillars found in scores object!', 'warn');
        console.warn('No pillars found in scores:', scores);
      }
      
      orderedPillars.forEach(([key, scoreValue]) => {
        // Handle new Authority structure (object with score and bySegment) or legacy (number)
        // Note: getOrderedPillars extracts the score, so we need to get bySegment from original scores object
        let score = scoreValue;
        let authorityBySegment = null;
        if (key === 'authority') {
          // Get the original Authority object from scores (not from getOrderedPillars result)
          const authorityObj = scores.authority;
          if (typeof authorityObj === 'object' && authorityObj !== null) {
            score = authorityObj.score || 0;
            authorityBySegment = authorityObj.bySegment || null;
          }
        }
        
        const rag = getRAGStatus(score);
        const card = document.createElement('div');
        card.className = 'pillar-card';
        
        // Get pillar description with data source info (dynamic based on whether we have real data)
        // Use currentLocalSignals (from displayDashboard parameter) for pillar cards, not just health dashboard
        // Check both localSignals and localSignalsSnapshot (different storage formats)
        const pillarLocalSignals = currentLocalSignals || (saved && (saved.localSignals || saved.localSignalsSnapshot)) || null;
        // Handle both status/data structure and direct data structure
        const pillarHasLocalSignals = pillarLocalSignals && (
          (pillarLocalSignals.status === 'ok' && pillarLocalSignals.data) ||
          (pillarLocalSignals.data && (pillarLocalSignals.data.napConsistencyScore !== undefined || pillarLocalSignals.data.locationsScore !== undefined))
        );
        const pillarLocalSignalsData = pillarHasLocalSignals 
          ? (pillarLocalSignals.data || pillarLocalSignals)
          : null;
        
        // DEBUG: Log local signals status for pillar cards
        debugLog(`[Pillar Cards] Local signals in definitions: hasLocalSignals=${pillarHasLocalSignals}, currentLocalSignals=${JSON.stringify(pillarLocalSignals ? {status: pillarLocalSignals.status, hasData: !!pillarLocalSignals.data, hasLocations: !!pillarLocalSignals.data?.locations, locationsCount: pillarLocalSignals.data?.locations?.length || 0} : null)}`, 'info');
        if (pillarLocalSignals && pillarLocalSignals.data) {
          debugLog(`[Pillar Cards] pillarLocalSignals.data keys: ${Object.keys(pillarLocalSignals.data).join(', ')}`, 'info');
          debugLog(`[Pillar Cards] pillarLocalSignals.data.locations type: ${typeof pillarLocalSignals.data.locations}, isArray: ${Array.isArray(pillarLocalSignals.data.locations)}, length: ${pillarLocalSignals.data.locations?.length || 0}`, 'info');
        }
        
        let localEntityDesc, serviceAreaDesc;
        if (pillarHasLocalSignals && pillarLocalSignalsData) {
          const napScore = pillarLocalSignalsData.napConsistencyScore !== null ? pillarLocalSignalsData.napConsistencyScore : 'N/A';
          const serviceAreasCount = pillarLocalSignalsData.serviceAreas?.length || 0;
          const locationsCount = pillarLocalSignalsData.locations?.length || 0;
          localEntityDesc = `How clearly your business and you as a person are recognised as entities by AI search systems. <strong>Data Source:</strong>  Live data from Google Business Profile API. <strong>Data Checked:</strong> NAP consistency (${napScore}%), knowledge panel (${pillarLocalSignalsData.knowledgePanelDetected ? 'detected' : 'not detected'}), locations (${locationsCount}).`;
          serviceAreaDesc = `How well AI understands where you operate and which regions you serve. <strong>Data Source:</strong>  Live data from Google Business Profile API. <strong>Data Checked:</strong> Service areas (${serviceAreasCount}), NAP consistency (${napScore}%).`;
        } else {
          localEntityDesc = 'How clearly your business and you as a person are recognised as entities by AI search systems. <strong>Data Source:</strong>  Currently derived from search performance (GSC position/CTR). Real local signals API integration pending.';
          serviceAreaDesc = 'How well AI understands where you operate and which regions you serve. <strong>Data Source:</strong>  Currently derived from Local Entity score. Real service area data from Google Business Profile pending.';
        }
        
        const descriptions = {
          localEntity: localEntityDesc,
          serviceArea: serviceAreaDesc,
          authority: 'E-A-T (Experience, Expertise, Authoritativeness, Trustworthiness): Perceived expertise and trust in the topic space. <strong>Calculation:</strong> Behaviour (40%) + Ranking (20%) + Backlinks (20%) + Reviews (20%). <strong>Data Source:</strong>  Live data from Google Search Console, Google Business Profile API, historic Trustpilot reviews snapshot, and backlink CSV upload.',
          visibility: 'How prominently your content appears in AI-powered search results and featured snippets. <strong>Data Source:</strong>  Live data from Google Search Console (impressions, clicks, position, SERP features).',
          contentSchema: 'Quality and completeness of structured data markup across your domain. <strong>Data Source:</strong>  Live data from schema audit. <strong>Calculation:</strong> Foundation schemas (30%) + Rich Results (35%) + Coverage (20%) + Diversity (15%).'
        };
        
        // Build breakdown and details sections for all pillars (for consistency)
        let pillarBreakdown = '';
        let pillarDetails = '';
        let authorityBreakdown = '';
        let authorityDetails = '';
        let authorityModeToggle = '';
        
        // Get saved audit data for breakdown calculations (reuse saved from function start to avoid redeclaration)
        // Use schemaAudit parameter if available, otherwise fall back to saved
        const schemaAuditData = schemaAudit || saved?.schemaAudit;
        const searchDataForBreakdown = data || saved?.searchData;
        // Note: hasLocalSignals and localSignalsData are already defined at function level (line 3688-3689), reuse them
        
        if (key === 'authority') {
          const savedAudit = loadAuditResultsSync();
          // Try multiple sources for backlinkMetrics: savedAudit, then localStorage
          // Note: API call removed from here since forEach doesn't support async properly
          // Backlink metrics should be loaded during audit run and saved to savedAudit
          let backlinkMetrics = savedAudit?.backlinkMetrics || null;
          if (!backlinkMetrics) {
            try {
              const storedMetrics = localStorage.getItem('backlink_metrics');
              if (storedMetrics) {
                backlinkMetrics = JSON.parse(storedMetrics);
                debugLog(' Backlink metrics loaded from localStorage for Authority card', 'info');
              }
            } catch (e) {
              debugLog(` Error reading backlink metrics from localStorage: ${e.message}`, 'warn');
            }
          }
          // Use currentLocalSignals from displayDashboard parameter, or fallback to savedAudit
          const localSignals = currentLocalSignals || savedAudit?.localSignals || null;
          // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
          const siteReviews = getTrustpilotSnapshot(savedAudit?.siteReviews);
          const searchData = savedAudit?.searchData;
          
          // Authority mode state (stored per card instance)
          const modeId = `authority-mode-${Date.now()}`;
          let currentMode = 'all'; // Default mode
          
          // Get selected Authority scores based on mode
          const getAuthorityForMode = (mode) => {
            if (authorityBySegment && authorityBySegment[mode]) {
              return authorityBySegment[mode];
            }
            // Fallback to all or legacy structure
            if (authorityBySegment && authorityBySegment.all) {
              return authorityBySegment.all;
            }
            // Legacy fallback
            const components = scores.authorityComponents || {};
            return {
              total: score,
              behaviour: components.behaviour || 0,
              ranking: components.ranking || 0,
              backlinks: components.backlinks || 0,
              reviews: components.reviews || 0
            };
          };
          
          // Get current Authority data
          let selectedAuthority = getAuthorityForMode(currentMode);
          
          // DEBUG: Log authority components and backlink metrics
          debugLog(`[Authority Card] Current authority components: ${JSON.stringify(selectedAuthority)}`, 'info');
          debugLog(`[Authority Card] Scores authorityComponents: ${JSON.stringify(scores.authorityComponents)}`, 'info');
          
          // Build mode toggle UI (only if bySegment is available)
          if (authorityBySegment) {
            authorityModeToggle = `
              <div class="authority-mode-toggle" style="margin-top: 0.5rem; margin-bottom: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem;">
                <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                  <span style="font-weight: 600; color: #666;">Mode:</span>
                  <button id="${modeId}-all" class="authority-mode-btn" data-mode="all" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: #10b981; color: white; cursor: pointer; font-size: 0.75rem;">
                    All pages
                  </button>
                  <button id="${modeId}-nonEducation" class="authority-mode-btn" data-mode="nonEducation" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
                    Exclude education
                  </button>
                  <button id="${modeId}-money" class="authority-mode-btn" data-mode="money" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
                    Money pages only
                  </button>
                </div>
              </div>
            `;
          }
          
          // Build breakdown display with color-coded scores (will be updated by mode toggle)
          const updateAuthorityDisplay = () => {
            const mode = card._authorityMode || currentMode;
            selectedAuthority = getAuthorityForMode(mode);
            const breakdownDiv = document.getElementById(`${modeId}-breakdown`);
            const scoreDiv = document.getElementById(`${modeId}-score`);
            if (breakdownDiv) {
              breakdownDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('Behaviour', selectedAuthority.behaviour)}
                  ${formatComponentScore('Ranking', selectedAuthority.ranking)}
                  ${formatComponentScore('Backlinks', selectedAuthority.backlinks)}
                  ${formatComponentScore('Reviews', selectedAuthority.reviews)}
                </div>
              `;
            }
            if (scoreDiv) {
              scoreDiv.textContent = Math.round(selectedAuthority.total);
              const newRag = getRAGStatus(selectedAuthority.total);
              scoreDiv.className = `pillar-score rag-${newRag.status}`;
            }
          };
          
          // Initial breakdown (with consistent spacing for alignment)
          authorityBreakdown = `
            <div id="${modeId}-breakdown" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                ${formatComponentScore('Behaviour', selectedAuthority.behaviour)}
                ${formatComponentScore('Ranking', selectedAuthority.ranking)}
                ${formatComponentScore('Backlinks', selectedAuthority.backlinks)}
                ${formatComponentScore('Reviews', selectedAuthority.reviews)}
              </div>
            </div>
          `;
          
          // Store update function for mode toggle handlers
          card._updateAuthorityDisplay = updateAuthorityDisplay;
          card._authorityMode = currentMode;
          card._authorityBySegment = authorityBySegment;
          card._modeId = modeId;
          
          // Build details panel (hidden by default, toggled by button)
          const detailsId = `authority-details-${Date.now()}`;
          const buttonId = `authority-details-btn-${Date.now()}`;
          
          // Get GSC metrics for details (segment-aware)
          // Store queryPages and searchData on card for access in update functions
          card._queryPages = searchData?.queryPages || [];
          card._topQueries = searchData?.topQueries || [];
          const queryPages = card._queryPages;
          const topQueries = card._topQueries;
          
          // Function to calculate GSC metrics for a specific segment
          const getGSCMetricsForSegment = (mode, queryPagesData, topQueriesData) => {
            let dataToUse = [];
            
            // Use the passed data (from card storage) to ensure we have latest
            const qp = queryPagesData || queryPages;
            const tq = topQueriesData || topQueries;
            
            if (qp && qp.length > 0) {
              // Use queryPages with segmentation
              let filtered = qp;
              if (mode === 'nonEducation') {
                filtered = qp.filter(row => {
                  const segment = classifyPageSegment(row.page || row.url || '/');
                  return segment !== PageSegment.EDUCATION;
                });
              } else if (mode === 'money') {
                filtered = qp.filter(row => {
                  const segment = classifyPageSegment(row.page || row.url || '/');
                  return segment === PageSegment.MONEY;
                });
              }
              
              debugLog(` GSC Metrics for ${mode}: Filtered ${filtered.length} rows from ${qp.length} total queryPages`, 'info');
              
              // Convert to query format for calculation
              dataToUse = filtered.map(row => ({
                query: row.query || '',
                clicks: row.clicks || 0,
                impressions: row.impressions || 0,
                ctr: (row.ctr || 0) / 100,
                position: row.position || 0
              }));
            } else {
              // Fallback to topQueries (all pages)
              dataToUse = tq.map(q => ({
                query: q.query || '',
                clicks: q.clicks || 0,
                impressions: q.impressions || 0,
                ctr: (q.ctr || 0) / 100,
                position: q.position || 0
              }));
            }
            
            const rankingQueries = dataToUse.filter(q => q.position > 0 && q.position <= 20 && q.impressions > 0);
            const top10Queries = rankingQueries.filter(q => q.position <= 10);
            
            let siteCtr = 0;
            let top10Ctr = 0;
            let avgPosition = 0;
            let top10ImpressionShare = 0;
            
            if (rankingQueries.length > 0) {
              const totalClicks = rankingQueries.reduce((s, q) => s + (q.clicks || 0), 0);
              const totalImpr = rankingQueries.reduce((s, q) => s + (q.impressions || 0), 0);
              siteCtr = totalImpr > 0 ? (totalClicks / totalImpr) * 100 : 0;
              
              const top10Clicks = top10Queries.reduce((s, q) => s + (q.clicks || 0), 0);
              const top10Impr = top10Queries.reduce((s, q) => s + (q.impressions || 0), 0);
              top10Ctr = top10Impr > 0 ? (top10Clicks / top10Impr) * 100 : 0;
              
              avgPosition = totalImpr > 0
                ? rankingQueries.reduce((s, q) => s + (q.position || 0) * (q.impressions || 0), 0) / totalImpr
                : 0;
              
              top10ImpressionShare = totalImpr > 0 ? (top10Impr / totalImpr) * 100 : 0;
            }
            
            return { siteCtr, top10Ctr, avgPosition, top10ImpressionShare };
          };
          
          // Get initial metrics (all pages)
          let gscMetrics = getGSCMetricsForSegment(currentMode, queryPages, topQueries);
          let siteCtr = gscMetrics.siteCtr;
          let top10Ctr = gscMetrics.top10Ctr;
          let avgPosition = gscMetrics.avgPosition;
          let top10ImpressionShare = gscMetrics.top10ImpressionShare;
          
          // Function to update GSC metrics display
          const updateGSCMetrics = (mode) => {
            // Get fresh data from card storage
            const qp = card._queryPages || [];
            const tq = card._topQueries || [];
            const metrics = getGSCMetricsForSegment(mode, qp, tq);
            const metricsDiv = document.getElementById(`${modeId}-gsc-metrics`);
            if (metricsDiv) {
              const siteCtrStr = metrics.siteCtr != null ? metrics.siteCtr.toFixed(2) : 'N/A';
              const avgPosStr = metrics.avgPosition != null ? metrics.avgPosition.toFixed(1) : 'N/A';
              debugLog(` Updating GSC metrics for mode ${mode}: CTR=${siteCtrStr}%, Position=${avgPosStr}`, 'info');
              const top10CtrStr = metrics.top10Ctr != null ? metrics.top10Ctr.toFixed(2) : 'N/A';
              const top10ShareStr = metrics.top10ImpressionShare != null ? metrics.top10ImpressionShare.toFixed(1) : 'N/A';
              metricsDiv.innerHTML = `
                <div style="margin-bottom: 0.5rem;"><strong>Behaviour & Ranking:</strong></div>
                <div style="margin-bottom: 0.25rem; font-size: 0.7rem; color: #999;">Segment: ${mode === 'all' ? 'All pages' : mode === 'nonEducation' ? 'Exclude education (blogs / free course)' : 'Money pages only'}</div>
                <div>Site CTR (ranking queries): ${siteCtrStr}%</div>
                <div>Top-10 CTR: ${top10CtrStr}%</div>
                <div>Avg position (ranking): ${avgPosStr}</div>
                <div>Top-10 impression share: ${top10ShareStr}%</div>
              `;
            } else {
              debugLog(` GSC metrics div not found: ${modeId}-gsc-metrics`, 'warn');
            }
          };
          
          // Store update function and data
          card._updateGSCMetrics = updateGSCMetrics;
          card._getGSCMetricsForSegment = getGSCMetricsForSegment;
          
          // Get review data - check multiple possible data structures
          let gbpRating = null;
          let gbpReviewCount = null;
          
          if (localSignals) {
            // Handle both direct data structure and wrapped response structure
            const signalsStatus = localSignals.status;
            const signalsData = localSignals.data || (localSignals.locations !== undefined ? localSignals : null);
            
            debugLog(`[Authority Card] Local signals status: ${signalsStatus}, has data: ${!!signalsData}, structure: ${JSON.stringify(Object.keys(localSignals))}`, 'info');
            
            if (signalsStatus === 'ok' && signalsData) {
              // Enhanced logging for GBP data
              debugLog(`[Authority Card] signalsData keys: ${Object.keys(signalsData).join(', ')}`, 'info');
              debugLog(`[Authority Card] signalsData.gbpRating raw: ${JSON.stringify(signalsData.gbpRating)} (type: ${typeof signalsData.gbpRating})`, 'info');
              debugLog(`[Authority Card] signalsData.gbpReviewCount raw: ${JSON.stringify(signalsData.gbpReviewCount)} (type: ${typeof signalsData.gbpReviewCount})`, 'info');
              
              gbpRating = signalsData.gbpRating !== null && signalsData.gbpRating !== undefined 
                ? signalsData.gbpRating 
                : null;
              gbpReviewCount = signalsData.gbpReviewCount !== null && signalsData.gbpReviewCount !== undefined 
                ? signalsData.gbpReviewCount 
                : null;
              debugLog(`[Authority Card] GBP data extracted: rating=${gbpRating}, count=${gbpReviewCount}`, gbpRating !== null ? 'info' : 'warn');
            } else {
              debugLog(`[Authority Card] Local signals not OK or missing data. Status: ${signalsStatus}, data keys: ${signalsData ? Object.keys(signalsData).join(', ') : 'no data'}, full object keys: ${Object.keys(localSignals).join(', ')}`, 'warn');
            }
          } else {
            debugLog(`[Authority Card] No localSignals available`, 'warn');
          }
          const siteRating = siteReviews?.siteRating !== null ? siteReviews?.siteRating : null;
          const siteReviewCount = siteReviews?.siteReviewCount !== null ? siteReviews?.siteReviewCount : null;
          
          authorityDetails = `
            <div style="margin-top: 0.5rem;">
              <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                Show details
              </button>
              <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                <div id="${modeId}-gsc-metrics">
                  <div style="margin-bottom: 0.5rem;"><strong>Behaviour & Ranking:</strong></div>
                  <div style="margin-bottom: 0.25rem; font-size: 0.7rem; color: #999;">Segment: ${currentMode === 'all' ? 'All pages' : currentMode === 'nonEducation' ? 'Exclude education (blogs / free course)' : 'Money pages only'}</div>
                  <div>Site CTR (ranking queries): ${siteCtr != null ? siteCtr.toFixed(1) : 'N/A'}%</div>
                  <div>Top-10 CTR: ${top10Ctr != null ? top10Ctr.toFixed(1) : 'N/A'}%</div>
                  <div>Avg position (ranking): ${avgPosition != null ? avgPosition.toFixed(1) : 'N/A'}</div>
                  <div>Top-10 impression share: ${top10ImpressionShare != null ? top10ImpressionShare.toFixed(1) : 'N/A'}%</div>
                </div>
                ${(() => {
                  // Use authorityComponents.backlinks to determine if backlinks exist
                  // Also try to get backlinkMetrics for detailed display if available
                  const hasBacklinkScore = selectedAuthority.backlinks > 0 || (scores.authorityComponents && scores.authorityComponents.backlinks > 0);
                  const hasBacklinkMetrics = backlinkMetrics && (backlinkMetrics.referringDomains > 0 || backlinkMetrics.totalBacklinks > 0);
                  
                  // Only show "No backlink data uploaded" if both score and metrics are missing
                  if (!hasBacklinkScore && !hasBacklinkMetrics) {
                    return `
                      <div style="margin-top: 0.75rem; margin-bottom: 0.5rem;"><strong>Backlink Metrics:</strong></div>
                      <div>No backlink data uploaded</div>
                    `;
                  }
                  
                  // Show backlink metrics if available, otherwise show score-based info
                  if (hasBacklinkMetrics) {
                    return `
                      <div style="margin-top: 0.75rem; margin-bottom: 0.5rem;"><strong>Backlink Metrics:</strong></div>
                      <div>Referring domains: ${backlinkMetrics.referringDomains || 0}</div>
                      <div>Total backlinks: ${backlinkMetrics.totalBacklinks || 0}</div>
                      <div>Follow ratio: ${backlinkMetrics.followRatio ? Math.round(backlinkMetrics.followRatio * 100) : 50}%</div>
                      <div style="margin-top: 0.25rem; font-size: 0.7rem; color: #999;">Backlink score: ${selectedAuthority.backlinks.toFixed(0)}</div>
                    `;
                  } else {
                    return `
                      <div style="margin-top: 0.75rem; margin-bottom: 0.5rem;"><strong>Backlink Metrics:</strong></div>
                      <div>Backlink score: ${selectedAuthority.backlinks.toFixed(0)}</div>
                      <div style="font-size: 0.7rem; color: #999;">Detailed metrics not available</div>
                    `;
                  }
                })()}
                <div style="margin-top: 0.75rem; margin-bottom: 0.5rem;"><strong>Review Metrics:</strong></div>
                <div>GBP rating: ${gbpRating !== null ? gbpRating.toFixed(2) : 'N/A'} (${gbpReviewCount !== null ? gbpReviewCount : 'N/A'} reviews)</div>
                <div>Trustpilot (snapshot): ${siteRating !== null ? siteRating.toFixed(2) : 'N/A'} (${siteReviewCount !== null ? siteReviewCount : 'N/A'} reviews)</div>
              </div>
            </div>
          `;
          
          // Store topPages data on card for access in update functions
          card._topPages = {
            all: authorityBySegment?.all?.topPages || [],
            nonEducation: authorityBySegment?.nonEducation?.topPages || [],
            money: authorityBySegment?.money?.topPages || []
          };
          
          // Function to render top pages table
          function renderTopPagesTable(mode, authorityBySegment) {
            const topPages = mode === 'all' 
              ? (authorityBySegment?.all?.topPages || [])
              : mode === 'nonEducation'
              ? (authorityBySegment?.nonEducation?.topPages || [])
              : (authorityBySegment?.money?.topPages || []);
            
            if (!topPages || topPages.length === 0) {
              return '<div style="font-size: 0.75rem; color: #999;">No page data available for this segment.</div>';
            }
            
            const segmentLabel = mode === 'all' 
              ? 'All pages'
              : mode === 'nonEducation'
              ? 'Exclude education (blogs / free course)'
              : 'Money pages only';
            
            const copyButtonId = `${modeId}-copy-urls`;
            
            let tableHtml = `
              <div style="margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                <h4 style="margin: 0; font-size: 0.95rem; font-weight: 600;">Top pages in this segment (by impressions)</h4>
                <button id="${copyButtonId}" type="button" style="font-size: 0.8rem; padding: 0.35rem 0.6rem; border-radius: 4px; border: 1px solid #ddd; background: white; cursor: pointer; color: #666;">
                  Copy URLs
                </button>
              </div>
              <p style="margin: 0 0 0.5rem 0; font-size: 0.75rem; color: #999;">Segment: ${segmentLabel}</p>
              <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse; font-size: 0.75rem;">
                  <thead>
                    <tr style="border-bottom: 1px solid #e2e8f0;">
                      <th style="text-align: left; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">#</th>
                      <th style="text-align: left; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">URL</th>
                      <th style="text-align: right; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">CTR</th>
                      <th style="text-align: right; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">Impr.</th>
                      <th style="text-align: right; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">Clicks</th>
                      <th style="text-align: right; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">Avg pos.</th>
                    </tr>
                  </thead>
                  <tbody>
            `;
            
            topPages.forEach((page, idx) => {
              const ctrStr = page.ctr != null ? page.ctr.toFixed(1) : 'N/A';
              const posStr = page.avgPosition != null ? page.avgPosition.toFixed(1) : 'N/A';
              const impressionsStr = page.impressions != null ? page.impressions.toLocaleString() : 'N/A';
              const clicksStr = page.clicks != null ? page.clicks.toLocaleString() : 'N/A';
              tableHtml += `
                <tr style="border-bottom: 1px solid #f1f5f9;">
                  <td style="padding: 0.25rem 0.4rem; color: #666;">${idx + 1}</td>
                  <td style="padding: 0.25rem 0.4rem; word-break: break-all; color: #333;">${page.url || 'N/A'}</td>
                  <td style="padding: 0.25rem 0.4rem; text-align: right; color: #666;">${ctrStr}%</td>
                  <td style="padding: 0.25rem 0.4rem; text-align: right; color: #666;">${impressionsStr}</td>
                  <td style="padding: 0.25rem 0.4rem; text-align: right; color: #666;">${clicksStr}</td>
                  <td style="padding: 0.25rem 0.4rem; text-align: right; color: #666;">${posStr}</td>
                </tr>
              `;
            });
            
            tableHtml += `
                  </tbody>
                </table>
              </div>
            `;
            
            // Store copy button ID and current mode for later event handler attachment
            card._copyButtonId = copyButtonId;
            card._topPagesForCopy = topPages;
            card._currentTopPagesMode = mode;
            
            return tableHtml;
          }
          
          // Function to update top pages table when mode changes
          const updateTopPagesTable = (mode) => {
            const topPagesDiv = document.getElementById(`${modeId}-top-pages`);
            if (topPagesDiv && authorityBySegment) {
              topPagesDiv.innerHTML = renderTopPagesTable(mode, authorityBySegment);
              
              // Re-attach copy button handler
              setTimeout(() => {
                const copyBtn = document.getElementById(card._copyButtonId);
                if (copyBtn) {
                  // Remove existing listener if any
                  const newCopyBtn = copyBtn.cloneNode(true);
                  copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
                  
                  newCopyBtn.addEventListener('click', async () => {
                    const currentTopPages = mode === 'all'
                      ? (authorityBySegment?.all?.topPages || [])
                      : mode === 'nonEducation'
                      ? (authorityBySegment?.nonEducation?.topPages || [])
                      : (authorityBySegment?.money?.topPages || []);
                    
                    const text = currentTopPages.map(p => p.url).join('\n');
                    try {
                      await navigator.clipboard.writeText(text);
                      newCopyBtn.textContent = 'Copied!';
                      newCopyBtn.style.color = '#10b981';
                      setTimeout(() => {
                        newCopyBtn.textContent = 'Copy URLs';
                        newCopyBtn.style.color = '#666';
                      }, 2000);
                    } catch (err) {
                      console.error('Failed to copy URLs:', err);
                      newCopyBtn.textContent = 'Copy failed';
                      setTimeout(() => {
                        newCopyBtn.textContent = 'Copy URLs';
                      }, 2000);
                    }
                  });
                }
              }, 0);
            }
          };
          
          // Store update function
          card._updateTopPagesTable = updateTopPagesTable;
          
          // Add click handlers for details toggle and mode toggle
          setTimeout(() => {
            const btn = document.getElementById(buttonId);
            const details = document.getElementById(detailsId);
            if (btn && details) {
              btn.addEventListener('click', () => {
                const isVisible = details.style.display !== 'none';
                details.style.display = isVisible ? 'none' : 'block';
                btn.textContent = isVisible ? 'Show details' : 'Hide details';
              });
            }
            
            // Add initial copy button handler
            const copyBtn = document.getElementById(card._copyButtonId);
            if (copyBtn) {
              copyBtn.addEventListener('click', async () => {
                const currentTopPages = currentMode === 'all'
                  ? (authorityBySegment?.all?.topPages || [])
                  : currentMode === 'nonEducation'
                  ? (authorityBySegment?.nonEducation?.topPages || [])
                  : (authorityBySegment?.money?.topPages || []);
                
                const text = currentTopPages.map(p => p.url).join('\n');
                try {
                  await navigator.clipboard.writeText(text);
                  copyBtn.textContent = 'Copied!';
                  copyBtn.style.color = '#10b981';
                  setTimeout(() => {
                    copyBtn.textContent = 'Copy URLs';
                    copyBtn.style.color = '#666';
                  }, 2000);
                } catch (err) {
                  console.error('Failed to copy URLs:', err);
                  copyBtn.textContent = 'Copy failed';
                  setTimeout(() => {
                    copyBtn.textContent = 'Copy URLs';
                  }, 2000);
                }
              });
            }
            
            // Add mode toggle handlers
            if (authorityBySegment) {
              ['all', 'nonEducation', 'money'].forEach(mode => {
                const modeBtn = document.getElementById(`${modeId}-${mode}`);
                if (modeBtn) {
                  modeBtn.addEventListener('click', () => {
                    // Update current mode
                    currentMode = mode;
                    card._authorityMode = mode;
                    
                    // Update button styles
                    ['all', 'nonEducation', 'money'].forEach(m => {
                      const btn = document.getElementById(`${modeId}-${m}`);
                      if (btn) {
                        if (m === mode) {
                          btn.style.background = '#10b981';
                          btn.style.color = 'white';
                        } else {
                          btn.style.background = 'white';
                          btn.style.color = '#666';
                        }
                      }
                    });
                    
                    // Update Authority score and breakdown
                    if (card._updateAuthorityDisplay) {
                      card._updateAuthorityDisplay();
                    }
                    
                    // Update GSC metrics
                    if (card._updateGSCMetrics) {
                      card._updateGSCMetrics(mode);
                    }
                    
                    // Update top pages section (full width, below pillars)
                    window.currentAuthorityMode = mode;
                    if (window.updateTopPagesSection) {
                      window.updateTopPagesSection(mode);
                    }
                    
                    debugLog(` Authority mode changed to: ${mode === 'all' ? 'All pages' : mode === 'nonEducation' ? 'Exclude education' : 'Money pages only'}`, 'info');
                  });
                }
              });
            }
          }, 0);
        }
        
        // Build breakdown and details for other pillars (Content/Schema, Visibility, Local Entity, Service Area)
        if (key !== 'authority') {
          const breakdownId = `${key}-breakdown-${Date.now()}`;
          const detailsId = `${key}-details-${Date.now()}`;
          const buttonId = `${key}-details-btn-${Date.now()}`;
          
          if (key === 'contentSchema' && schemaAuditData && schemaAuditData.status === 'ok' && schemaAuditData.data) {
            const schemaData = schemaAuditData.data;
            const allTypes = new Set();
            
            // PRIORITY: Use foundation object first (most reliable source)
            if (schemaData.foundation && typeof schemaData.foundation === 'object') {
              Object.keys(schemaData.foundation).forEach(type => {
                if (schemaData.foundation[type] === true) {
                  allTypes.add(type);
                }
              });
            }
            
            // Also add types from allDetectedTypes if available (for complete type list)
            if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
              schemaData.allDetectedTypes.forEach(type => { if (type) allTypes.add(type); });
            }
            
            // Also add from richEligible for complete type list
            if (schemaData.richEligible && typeof schemaData.richEligible === 'object') {
              Object.keys(schemaData.richEligible).forEach(type => {
                if (schemaData.richEligible[type] === true) {
                  allTypes.add(type);
                }
              });
            }
            
            // Fallback: collect from schemaTypes array (but filter out page objects)
            if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
              schemaData.schemaTypes.forEach(item => {
                // Skip page objects (have 'url' property) - these are NOT schema types
                if (item && typeof item === 'object' && item.url) {
                  return; // Skip page objects
                }
                // Only process valid schema type objects or strings
                if (typeof item === 'string') {
                  allTypes.add(item);
                } else if (item && typeof item === 'object' && item.type && typeof item.type === 'string' && !item.url) {
                  allTypes.add(item.type);
                }
              });
            }
            
            // Foundation detection: Use foundation object directly (most reliable)
            const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
            let foundationPresent = 0;
            if (schemaData.foundation && typeof schemaData.foundation === 'object') {
              // Use foundation object directly - count how many are true
              foundationPresent = foundationTypes.filter(type => schemaData.foundation[type] === true).length;
            } else {
              // Fallback: check allTypes set
              foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
            }
            const foundationScore = (foundationPresent / foundationTypes.length) * 100;
            
            const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
            const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
            const richResultScore = (richEligibleCount / richResultTypes.length) * 100;
            
            const coverageScore = schemaData.coverage || 0;
            const uniqueTypesCount = allTypes.size;
            const diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
            
            // Get schema types list for display (properly formatted to avoid [object Object])
            let schemaTypesList = [];
            if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
              schemaTypesList = schemaData.allDetectedTypes.slice(0, 20).filter(t => t && typeof t === 'string');
            } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
              schemaTypesList = schemaData.schemaTypes
                .filter(t => {
                  // Skip null/undefined
                  if (!t) return false;
                  // Skip page objects (have 'url' property) - these are pages, not types!
                  if (typeof t === 'object' && ('url' in t || ('title' in t && 'metaDescription' in t))) return false;
                  // Only keep valid type objects or strings
                  return typeof t === 'string' || (typeof t === 'object' && t.type && typeof t.type === 'string' && !t.url);
                })
                .map(t => {
                  if (typeof t === 'string') return t.trim();
                  if (t && typeof t === 'object' && t.type && typeof t.type === 'string') {
                    return `${t.type}${t.count ? ` (${t.count})` : ''}`;
                  }
                  return null;
                })
                .filter(t => t !== null && t !== undefined && t !== '' && typeof t === 'string')
                .slice(0, 20);
            }
            const schemaTypesDisplay = schemaTypesList.length > 0 ? schemaTypesList.join(', ') : 'None detected';
            
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('Foundation', foundationScore)}
                  ${formatComponentScore('Rich Results', richResultScore)}
                  ${formatComponentScore('Coverage', coverageScore)}
                  ${formatComponentScore('Diversity', diversityScore)}
                </div>
              </div>
            `;
            
            pillarDetails = `
              <div style="margin-top: 0.5rem;">
                <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                  Show details
                </button>
                <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                  <div style="margin-bottom: 0.5rem;"><strong>Schema Details:</strong></div>
                  <div>Foundation schemas: ${foundationPresent}/4 (${foundationTypes.filter(t => (schemaData.foundation && schemaData.foundation[t] === true) || allTypes.has(t)).join(', ') || 'none'})</div>
                  <div>Rich result types: ${richEligibleCount}/${richResultTypes.length} eligible</div>
                  <div>Coverage: ${coverageScore != null ? coverageScore.toFixed(1) : 'N/A'}% (${Array.isArray(schemaData.pagesWithSchema) ? schemaData.pagesWithSchema.length : (typeof schemaData.pagesWithSchema === 'number' ? schemaData.pagesWithSchema : 0)}/${Array.isArray(schemaData.pages) ? schemaData.pages.length : (typeof schemaData.totalPages === 'number' ? schemaData.totalPages : (Array.isArray(schemaData.pages) ? schemaData.pages.length : 0))} pages)</div>
                  <div>Type diversity: ${uniqueTypesCount} unique types</div>
                  <div style="margin-top: 0.5rem;"><strong>Schema types found:</strong> ${schemaTypesDisplay}${schemaTypesList.length >= 20 ? '...' : ''}</div>
                </div>
              </div>
            `;
            
            setTimeout(() => {
              const btn = document.getElementById(buttonId);
              const details = document.getElementById(detailsId);
              if (btn && details) {
                btn.addEventListener('click', () => {
                  const isVisible = details.style.display !== 'none';
                  details.style.display = isVisible ? 'none' : 'block';
                  btn.textContent = isVisible ? 'Show details' : 'Hide details';
                });
              }
            }, 0);
          } else if (key === 'visibility' && searchDataForBreakdown) {
            const avgPos = searchDataForBreakdown.averagePosition || 40;
            const clampedPos = Math.max(1, Math.min(40, avgPos));
            const scale = (clampedPos - 1) / 39;
            const posScore = 100 - scale * 90;
            
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('Position', clampScore(posScore))}
                  ${formatComponentScore('CTR', Math.min((searchDataForBreakdown.ctr || 0) / 0.10 * 100, 100))}
                </div>
              </div>
            `;
            
            pillarDetails = `
              <div style="margin-top: 0.5rem;">
                <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                  Show details
                </button>
                <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                  <div style="margin-bottom: 0.5rem;"><strong>GSC Metrics:</strong></div>
                  <div>Average position: ${avgPos != null ? avgPos.toFixed(1) : 'N/A'}</div>
                  <div>CTR: ${(searchDataForBreakdown.ctr || 0).toFixed(1)}%</div>
                  <div>Total clicks: ${(searchDataForBreakdown.totalClicks || 0).toLocaleString()}</div>
                  <div>Total impressions: ${(searchDataForBreakdown.totalImpressions || 0).toLocaleString()}</div>
                </div>
              </div>
            `;
            
            setTimeout(() => {
              const btn = document.getElementById(buttonId);
              const details = document.getElementById(detailsId);
              if (btn && details) {
                btn.addEventListener('click', () => {
                  const isVisible = details.style.display !== 'none';
                  details.style.display = isVisible ? 'none' : 'block';
                  btn.textContent = isVisible ? 'Show details' : 'Hide details';
                });
              }
            }, 0);
          } else if (key === 'localEntity' && pillarHasLocalSignals && pillarLocalSignalsData) {
            // DEBUG: Log locations data structure
            debugLog(`[Local Entity Card] pillarLocalSignalsData keys: ${Object.keys(pillarLocalSignalsData).join(', ')}`, 'info');
            debugLog(`[Local Entity Card] locations type: ${typeof pillarLocalSignalsData.locations}, isArray: ${Array.isArray(pillarLocalSignalsData.locations)}, length: ${pillarLocalSignalsData.locations?.length || 0}`, 'info');
            if (pillarLocalSignalsData.locations && pillarLocalSignalsData.locations.length > 0) {
              debugLog(`[Local Entity Card] First location: ${JSON.stringify(pillarLocalSignalsData.locations[0]).substring(0, 200)}`, 'info');
            } else {
              debugLog(`[Local Entity Card]  locations is missing or empty!`, 'warn');
            }
            const napScore = pillarLocalSignalsData.napConsistencyScore || 0;
            const knowledgePanelScore = pillarLocalSignalsData.knowledgePanelDetected ? 100 : 0;
            const locationsScore = (pillarLocalSignalsData.locations?.length || 0) > 0 ? 100 : 0;
            
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('NAP Consistency', napScore)}
                  ${formatComponentScore('Knowledge Panel', knowledgePanelScore)}
                  ${formatComponentScore('Locations', locationsScore)}
                </div>
              </div>
            `;
            
            pillarDetails = `
              <div style="margin-top: 0.5rem;">
                <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                  Show details
                </button>
                <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                  <div style="margin-bottom: 0.5rem;"><strong>Business Profile Data:</strong></div>
                  <div>NAP consistency: ${napScore}%</div>
                  <div>Knowledge panel: ${pillarLocalSignalsData.knowledgePanelDetected ? 'detected' : 'not detected'}</div>
                  <div>Locations: ${pillarLocalSignalsData.locations?.length || 0}</div>
                </div>
              </div>
            `;
            
            setTimeout(() => {
              const btn = document.getElementById(buttonId);
              const details = document.getElementById(detailsId);
              if (btn && details) {
                btn.addEventListener('click', () => {
                  const isVisible = details.style.display !== 'none';
                  details.style.display = isVisible ? 'none' : 'block';
                  btn.textContent = isVisible ? 'Show details' : 'Hide details';
                });
              }
            }, 0);
          } else if (key === 'serviceArea' && pillarHasLocalSignals && pillarLocalSignalsData) {
            const serviceAreasCount = pillarLocalSignalsData.serviceAreas?.length || 0;
            const serviceAreasScore = serviceAreasCount >= 8 ? 100 : Math.min(100, serviceAreasCount * 12.5);
            const napScore = pillarLocalSignalsData.napConsistencyScore || 0;
            
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('Service Areas', serviceAreasScore)}
                  ${formatComponentScore('NAP Consistency', napScore)}
                </div>
              </div>
            `;
            
            pillarDetails = `
              <div style="margin-top: 0.5rem;">
                <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                  Show details
                </button>
                <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                  <div style="margin-bottom: 0.5rem;"><strong>Service Area Data:</strong></div>
                  <div>Service areas: ${serviceAreasCount}</div>
                  <div>NAP consistency: ${napScore}%</div>
                </div>
              </div>
            `;
            
            setTimeout(() => {
              const btn = document.getElementById(buttonId);
              const details = document.getElementById(detailsId);
              if (btn && details) {
                btn.addEventListener('click', () => {
                  const isVisible = details.style.display !== 'none';
                  details.style.display = isVisible ? 'none' : 'block';
                  btn.textContent = isVisible ? 'Show details' : 'Hide details';
                });
              }
            }, 0);
          } else {
            // No breakdown available - add empty section for consistent spacing
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
              </div>
            `;
            pillarDetails = `
              <div style="margin-top: 0.5rem; min-height: 1.5rem;">
              </div>
            `;
          }
        }
        
        // Define pillar colors for consistency across all reports
        const pillarColors = {
          localEntity: 'rgba(147, 51, 234, 1)', // Purple
          serviceArea: '#00FFFF', // Cyan (not RAG color)
          authority: '#99004C', // Dark pink/magenta
          visibility: 'rgba(37, 99, 235, 1)', // Blue
          contentSchema: 'rgba(107, 114, 128, 1)' // Grey
        };
        
        const pillarColor = pillarColors[key] || '#666';
        
        card.innerHTML = `
          <div style="flex: 1; display: flex; flex-direction: column; position: relative;">
            <div style="position: absolute; top: 0; right: 0; width: 20px; height: 20px; background: ${pillarColor}; border-radius: 3px; border: 1px solid rgba(0,0,0,0.1);" title="Color key for ${pillarNames[key]} in all reports"></div>
          <h3>${pillarNames[key]}</h3>
            <div id="${key === 'authority' ? card._modeId + '-score' : ''}" class="pillar-score rag-${rag.status}">${Math.round(score)}</div>
          <div class="rag-badge ${rag.status}">${rag.label}</div>
          <p style="font-size: 0.85rem; color: #666; margin-top: 0.5rem; line-height: 1.5; flex-grow: 1;">${descriptions[key] || ''}</p>
            ${key === 'authority' ? authorityModeToggle : '<div style="min-height: 2.5rem;"></div>'}
            ${key === 'authority' ? authorityBreakdown : pillarBreakdown}
          </div>
          <div style="margin-top: auto;">
            ${key === 'authority' ? authorityDetails : pillarDetails}
          </div>
        `;
        pillarCards.appendChild(card);
        debugLog(` Added pillar card for ${key} (score: ${score})`, 'info');
      });
      
      debugLog(` Created ${orderedPillars.length} pillar cards total`, 'success');
      
      // Shared functions for Top Pages section (used by both createTopPagesSection functions)
      
      // Classification functions for metric status
      function classifySiteCtr(v) {
        // v is already a percentage (0-100), not a decimal
        if (v < 1) return 'poor';      // <1%
        if (v < 3) return 'ok';        // 1-3%
        return 'strong';                  // 3%+
      }
      
      function classifyTop10Ctr(v) {
        // v is already a percentage (0-100), not a decimal
        if (v < 2) return 'poor';      // <2%
        if (v < 5) return 'ok';        // 2-5%
        return 'strong';                  // 5%+
      }
      
      function classifyAvgPos(p) {
        if (p > 10) return 'poor';        // mostly bottom of page 1 / page 2
        if (p > 5) return 'ok';           // mid-page 1
        return 'strong';                  // positions 1-5
      }
      
      function classifyTop10Share(v) {
        // v is stored as decimal (0-1), needs to be converted to percentage for comparison
        const pct = v * 100;
        if (pct < 60) return 'poor';       // <60% of impressions in top 10
        if (pct < 80) return 'ok';         // 60-80%
        return 'strong';                  // 80%+
      }
      
      // Helper to format percentage
      // For CTR values: already percentages (0-100), just format
      // For top10Share: stored as decimal (0-1), convert to percentage
      function pct(v, isDecimal = false) {
        if (isDecimal) {
          return `${(v * 100).toFixed(2)}%`;
        }
        return `${v.toFixed(2)}%`;
      }
      
      // Helper to extract target value from target text
      function extractTargetValue(targetText, metricType) {
        if (metricType === 'ctr' || metricType === 'percentage') {
          // Extract range like "23%+" or "7585%+"
          const match = targetText.match(/(\d+(?:\.\d+)?)[-](\d+(?:\.\d+)?)%/);
          if (match) {
            const min = parseFloat(match[1]);
            const max = parseFloat(match[2]);
            return (min + max) / 2; // Return midpoint
          }
        } else if (metricType === 'position') {
          // Extract range like "36"
          const match = targetText.match(/(\d+(?:\.\d+)?)[-](\d+(?:\.\d+)?)/);
          if (match) {
            const min = parseFloat(match[1]);
            const max = parseFloat(match[2]);
            return (min + max) / 2; // Return midpoint
          }
        }
        return null;
      }
      
      // Build recommendation rows from segment metrics
      function buildBehaviourRankingRecommendations(segment, m) {
        const rows = [];
        
        // Site CTR recommendation
        const siteStatus = classifySiteCtr(m.siteCtr);
        const siteCurrent = m.siteCtr;
        const siteTargetText = 'Aim for 23%+ overall CTR';
        const siteTargetValue = extractTargetValue(siteTargetText, 'ctr'); // 2.5%
        const siteDiff = siteTargetValue ? (siteCurrent - siteTargetValue) : null; // Keep sign for display
        rows.push({
          metric: 'Overall CTR (all ranking queries)',
          status: siteStatus,
          value: pct(m.siteCtr),
          currentValue: siteCurrent,
          target: siteTargetText,
          targetValue: siteTargetValue,
          difference: siteDiff,
          action: siteStatus === 'poor'
            ? (segment === 'money'
                ? 'Rewrite titles and descriptions on the top money pages (table above). Add intent phrases ("workshop", "course", "near me") and stronger benefits to lift clicks for your money pages.'
                : 'Focus on high-impression pages with weak CTR in this segment. Tighten titles and descriptions so they clearly answer the search intent and highlight the benefit.')
            : siteStatus === 'ok'
            ? (segment === 'money'
                ? 'CTR is reasonable for your money pages. Prioritise the worst pages in the table above for A/B-style tests on titles and descriptions.'
                : 'CTR is reasonable for this segment. Prioritise the worst pages in the table above for A/B-style tests on titles and descriptions.')
            : 'CTR is strong for this segment. Keep monitoring but prioritise ranking and impression share improvements.'
        });
        
        // Top-10 CTR recommendation
        const top10Status = classifyTop10Ctr(m.top10Ctr);
        const top10Current = m.top10Ctr;
        const top10TargetText = 'Aim for 35%+ in top-10';
        const top10TargetValue = extractTargetValue(top10TargetText, 'ctr'); // 4%
        const top10Diff = top10TargetValue ? (top10Current - top10TargetValue) : null; // Keep sign for display
        rows.push({
          metric: 'Top-10 CTR (positions 110)',
          status: top10Status,
          value: pct(m.top10Ctr),
          currentValue: top10Current,
          target: top10TargetText,
          targetValue: top10TargetValue,
          difference: top10Diff,
          action: top10Status === 'poor'
            ? (segment === 'money'
                ? 'When your money pages are already in positions 110 but clicks are low, re-write titles/meta to be more specific: include location, level (beginner/advanced), and outcome ("learn to", "master").'
                : 'When you are already in positions 110 but clicks are low, re-write titles/meta to be more specific: include location, level (beginner/advanced), and outcome ("learn to", "master").')
            : top10Status === 'ok'
            ? (segment === 'money'
                ? 'Identify top-10 money pages with below-average CTR and iterate on their SERP snippet (titles, descriptions, rich results where available).'
                : 'Identify top-10 pages with below-average CTR and iterate on their SERP snippet (titles, descriptions, rich results where available).')
            : 'Top-10 CTR is healthy. Focus on pushing more queries into the top-10 (see avg position & top-10 share).'
        });
        
        // Average position recommendation
        const posStatus = classifyAvgPos(m.avgPosition);
        const posCurrent = m.avgPosition;
        const posTargetText = 'Aim for average position 36 on core queries';
        const posTargetValue = extractTargetValue(posTargetText, 'position'); // 4.5
        const posDiff = posTargetValue ? (posCurrent - posTargetValue) : null; // Keep sign for display (positive = worse)
        rows.push({
          metric: 'Average position (ranking queries)',
          status: posStatus,
          value: m.avgPosition != null ? m.avgPosition.toFixed(1) : 'N/A',
          currentValue: posCurrent,
          target: posTargetText,
          targetValue: posTargetValue,
          difference: posDiff,
          action: posStatus === 'poor'
            ? (segment === 'money'
                ? 'Most impressions for money pages are coming from low positions. Strengthen internal links to money pages, add more supporting content, and build links from relevant blogs/assignments into these URLs.'
                : 'Most impressions are coming from low positions. Strengthen internal links to key pages, add more supporting content, and build links from relevant blogs/assignments into these URLs.')
            : posStatus === 'ok'
            ? (segment === 'money'
                ? 'Your money pages are mid-page 1 on average. Use on-page tuning (H1, sub-heads, FAQs) and internal links from strong blogs to nudge key money URLs into positions 13.'
                : 'You are mid-page 1 on average. Use on-page tuning (H1, sub-heads, FAQs) and internal links from strong blogs to nudge key URLs into positions 13.')
            : 'Positions are strong overall. Concentrate on CTR and expanding coverage to more relevant queries.'
        });
        
        // Top-10 share recommendation
        const shareStatus = classifyTop10Share(m.top10Share);
        const shareCurrent = m.top10Share * 100; // Convert to percentage
        const shareTargetText = 'Aim for 7585%+ of impressions in top-10';
        const shareTargetValue = extractTargetValue(shareTargetText, 'percentage'); // 80%
        const shareDiff = shareTargetValue ? (shareCurrent - shareTargetValue) : null; // Keep sign for display
        rows.push({
          metric: 'Top-10 impression share',
          status: shareStatus,
          value: pct(m.top10Share, true), // top10Share is stored as decimal (0-1)
          currentValue: shareCurrent,
          target: shareTargetText,
          targetValue: shareTargetValue,
          difference: shareDiff,
          action: shareStatus === 'poor'
            ? (segment === 'money'
                ? 'Large share of impressions for money pages are outside the top-10. Review which queries are generating impressions but no clicks and decide: improve those money pages or deliberately de-optimise low-value queries.'
                : 'Large share of impressions are outside the top-10. Review which queries are generating impressions but no clicks and decide: improve those pages or deliberately de-optimise low-value queries.')
            : shareStatus === 'ok'
            ? (segment === 'money'
                ? 'Gradually push more money page impressions into the top-10 by strengthening key hub pages (workshops, courses, tuition) and consolidating thin or overlapping content.'
                : 'Gradually push more impressions into the top-10 by strengthening key hub pages (workshops, courses, tuition) and consolidating thin or overlapping content.')
            : 'Most impressions are already top-10. Shift effort to CTR and conversion on the URLs listed above.'
        });
        
        return rows;
      }
      
      // Render recommendations table
      function renderRecommendationsTable(segment, metrics, segmentLabel, dateRangeText = '30 days') {
        if (!metrics) {
          return '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">No metrics available for recommendations.</div>';
        }
        
        const recommendations = buildBehaviourRankingRecommendations(segment, metrics);
        
        // Determine priority row: poor status first, or largest gap if no poor
        let priorityIdx = -1;
        const poorRows = recommendations.map((r, i) => ({ idx: i, row: r })).filter(({ row }) => row.status === 'poor');
        if (poorRows.length > 0) {
          // Find poor row with largest gap (use absolute value for comparison)
          priorityIdx = poorRows.reduce((max, curr) => {
            const currGap = Math.abs(curr.row.difference || 0);
            const maxGap = Math.abs(max.row.difference || 0);
            return currGap > maxGap ? curr : max;
          }, poorRows[0]).idx;
        } else {
          // No poor rows, find row with largest gap (use absolute value)
          priorityIdx = recommendations.reduce((maxIdx, row, idx) => {
            const currGap = Math.abs(row.difference || 0);
            const maxGap = Math.abs(recommendations[maxIdx]?.difference || 0);
            return currGap > maxGap ? idx : maxIdx;
          }, 0);
        }
        
        const getStatusPill = (status) => {
          const colors = {
            poor: { bg: '#fee2e2', text: '#991b1b', label: 'Poor' },
            ok: { bg: '#fef3c7', text: '#92400e', label: 'OK' },
            strong: { bg: '#d1fae5', text: '#065f46', label: 'Strong' }
          };
          const color = colors[status] || colors.ok;
          return `<span style="display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; background: ${color.bg}; color: ${color.text}; font-size: 0.75rem; font-weight: 600;">${color.label}</span>`;
        };
        
        // Get segment display name
        const segmentDisplayName = segmentLabel || (segment === 'all' ? 'All pages' : segment === 'nonEducation' ? 'Exclude education (blogs / free course)' : 'Money pages only');
        
        let tableHtml = `
          <div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
            <h4 style="margin: 0 0 0.25rem 0; font-size: 1.2rem; font-weight: 700; color: #1e293b;">Recommended actions for this segment</h4>
            <p style="margin: 0 0 0.5rem 0; font-size: 0.9rem; color: #334155; font-weight: 500;">Segment: <strong>${segmentDisplayName}</strong> (last ${dateRangeText})</p>
            <p style="margin: 0; font-size: 0.9rem; color: #334155; font-weight: 400;">Based on last ${dateRangeText} of Google Search Console data for the currently selected segment.</p>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 1rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">Metric</th>
                  <th style="text-align: center; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">Status</th>
                  <th style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">Current</th>
                  <th style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">Target</th>
                  <th style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">To Target</th>
                  <th style="text-align: left; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">Suggested action</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        recommendations.forEach((row, idx) => {
          const isEven = idx % 2 === 0;
          const isPriority = idx === priorityIdx;
          
          // Determine metric type and format accordingly
          let currentDisplay = row.value;
          let targetDisplay = row.target;
          let diffDisplay = '';
          
          if (row.metric.includes('CTR')) {
            // CTR metrics: show as percentages (1 decimal)
            currentDisplay = `${row.currentValue.toFixed(1)}%`;
            if (row.targetValue !== null && row.targetValue !== undefined) {
              targetDisplay = `${row.targetValue.toFixed(1)}%`;
              if (row.difference !== null && row.difference !== undefined) {
                // Show sign and color based on status
                const gap = row.difference; // Already calculated as current - target
                if (gap >= 0) {
                  // At or above target
                  diffDisplay = '<span style="color: #10b981; font-weight: 600;"> On target</span>';
                } else {
                  // Below target - show with sign
                  const gapColor = row.status === 'poor' ? '#ef4444' : row.status === 'ok' ? '#f59e0b' : '#10b981';
                  diffDisplay = `<span style="color: ${gapColor}; font-weight: 600;">${gap.toFixed(2)}%</span>`;
                }
              }
            }
          } else if (row.metric.includes('position')) {
            // Position metrics: show as numbers (1 decimal)
            currentDisplay = row.currentValue.toFixed(1);
            if (row.targetValue !== null && row.targetValue !== undefined) {
              targetDisplay = row.targetValue.toFixed(1);
              if (row.difference !== null && row.difference !== undefined) {
                // For position, lower is better, so if current <= target, we're good
                const gap = row.difference; // Already calculated as current - target
                if (gap <= 0) {
                  // At or better than target
                  diffDisplay = '<span style="color: #10b981; font-weight: 600;"> On target</span>';
                } else {
                  // Above target (worse position) - show with sign
                  const gapColor = row.status === 'poor' ? '#ef4444' : row.status === 'ok' ? '#f59e0b' : '#10b981';
                  diffDisplay = `<span style="color: ${gapColor}; font-weight: 600;">+${gap.toFixed(1)}</span>`;
                }
              }
            }
          } else if (row.metric.includes('impression share')) {
            // Share metrics: show as percentages (1 decimal)
            currentDisplay = `${row.currentValue.toFixed(1)}%`;
            if (row.targetValue !== null && row.targetValue !== undefined) {
              targetDisplay = `${row.targetValue.toFixed(1)}%`;
              if (row.difference !== null && row.difference !== undefined) {
                // For share, higher is better
                const gap = row.difference; // Already calculated as current - target
                if (gap >= 0) {
                  // At or above target
                  diffDisplay = '<span style="color: #10b981; font-weight: 600;"> On target</span>';
                } else {
                  // Below target - show with sign
                  const gapColor = row.status === 'poor' ? '#ef4444' : row.status === 'ok' ? '#f59e0b' : '#10b981';
                  diffDisplay = `<span style="color: ${gapColor}; font-weight: 600;">${gap.toFixed(2)}%</span>`;
                }
              }
            }
          }
          
          // Priority row styling: left border and optional priority badge
          const priorityStyle = isPriority ? 'border-left: 4px solid #ef4444; background: #fef2f2;' : '';
          const priorityBadge = isPriority ? '<span style="display: inline-block; margin-left: 0.5rem; padding: 0.15rem 0.4rem; background: #ef4444; color: white; border-radius: 4px; font-size: 0.8rem; font-weight: 600;">Priority</span>' : '';
          
          tableHtml += `
            <tr style="border-bottom: 1px solid #f1f5f9; background: ${isEven ? '#ffffff' : '#fafafa'}; ${priorityStyle} transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa';" onmouseout="this.style.background='${isEven ? '#ffffff' : '#fafafa'}';">
              <td style="padding: 0.9rem; color: #0f172a; font-weight: 600; font-size: 1rem;">${row.metric}${priorityBadge}</td>
              <td style="padding: 0.9rem; text-align: center; font-size: 1rem;">${getStatusPill(row.status)}</td>
              <td style="padding: 0.9rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 1rem;">${currentDisplay}</td>
              <td style="padding: 0.9rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 1rem;">${targetDisplay}</td>
              <td style="padding: 0.9rem; text-align: right; font-weight: 600; font-size: 1rem;">${diffDisplay}</td>
              <td style="padding: 0.9rem; color: #0f172a; font-weight: 400; line-height: 1.5; font-size: 1rem;">${row.action}</td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        return tableHtml;
      }
      
      // Function to render full-width top pages table (shared by both createTopPagesSection functions)
      function renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText = '30 days') {
        if (!topPages || topPages.length === 0) {
          return '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">No page data available for this segment. This table shows the latest snapshot from your most recent audit (static data, not affected by time period selections). If you see this message, the data may not have been computed during the last audit. Make sure your audit includes Google Search Console query+page metrics (queryPages dimension) and that you have uploaded site-urls.csv for segmentation.</div>';
        }
        
        // Store original data for sorting
        if (!window.topPagesData) {
          window.topPagesData = topPages;
          window.topPagesSortColumn = null;
          window.topPagesSortDirection = 'desc';
        }
        
        // Sort data if needed
        let sortedPages = [...topPages];
        if (window.topPagesSortColumn) {
          sortedPages.sort((a, b) => {
            let aVal, bVal;
            switch(window.topPagesSortColumn) {
              case 'ctr':
                aVal = a.ctr || 0;
                bVal = b.ctr || 0;
                break;
              case 'impressions':
                aVal = a.impressions || 0;
                bVal = b.impressions || 0;
                break;
              case 'clicks':
                aVal = a.clicks || 0;
                bVal = b.clicks || 0;
                break;
              case 'position':
                aVal = a.avgPosition || 0;
                bVal = b.avgPosition || 0;
                break;
              default:
                return 0;
            }
            const diff = aVal - bVal;
            return window.topPagesSortDirection === 'asc' ? diff : -diff;
          });
        }
        
        // Helper function to get sort icon (must be defined before use in template)
        const getSortIcon = (column) => {
          if (!window.topPagesSortColumn || window.topPagesSortColumn !== column) {
            return '<span style="color: #475569; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 600;"></span>';
          }
          return window.topPagesSortDirection === 'asc' 
            ? '<span style="color: #99004C; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 700;"></span>'
            : '<span style="color: #99004C; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 700;"></span>';
        };
        
        let tableHtml = `
          <div style="margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
            <div>
              <h4 style="margin: 0 0 0.25rem 0; font-size: 1.2rem; font-weight: 700; color: #1e293b;">Top 10 pages by impressions</h4>
              <span style="font-size: 0.9rem; color: #334155; font-weight: 500;">Data period: Last ${dateRangeText}</span>
            </div>
            <button id="top-pages-copy-urls" type="button" style="font-size: 0.95rem; padding: 0.6rem 0.9rem; border-radius: 6px; border: 1px solid #2563eb; background: #2563eb; cursor: pointer; color: white; font-weight: 600; transition: all 0.2s; box-shadow: 0 1px 2px rgba(0,0,0,0.1);" onmouseover="this.style.background='#1d4ed8'; this.style.borderColor='#1d4ed8';" onmouseout="this.style.background='#2563eb'; this.style.borderColor='#2563eb';">
              Copy URLs
            </button>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 1rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">#</th>
                  <th style="text-align: left; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">URL</th>
                  <th id="sort-ctr" style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by CTR">
                    CTR${getSortIcon('ctr')}
                  </th>
                  <th id="sort-impressions" style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Impressions">
                    Impressions${getSortIcon('impressions')}
                  </th>
                  <th id="sort-clicks" style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Clicks">
                    Clicks${getSortIcon('clicks')}
                  </th>
                  <th id="sort-position" style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Avg Position">
                    Avg Position${getSortIcon('position')}
                  </th>
                </tr>
              </thead>
              <tbody>
        `;
        
        sortedPages.forEach((page, idx) => {
          const isEven = idx % 2 === 0;
          const safeCtr = page.ctr != null ? page.ctr : 0;
          const safePos = page.avgPosition != null ? page.avgPosition : 0;
          const ctrColor = safeCtr >= 2 ? '#10b981' : safeCtr >= 1 ? '#f59e0b' : '#ef4444';
          const posColor = safePos <= 5 ? '#10b981' : safePos <= 10 ? '#f59e0b' : '#ef4444';
          const ctrStr = page.ctr != null ? page.ctr.toFixed(1) : 'N/A';
          const posStr = page.avgPosition != null ? page.avgPosition.toFixed(1) : 'N/A';
          tableHtml += `
            <tr style="border-bottom: 1px solid #f1f5f9; background: ${isEven ? '#ffffff' : '#fafafa'}; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa';" onmouseout="this.style.background='${isEven ? '#ffffff' : '#fafafa'}';">
              <td style="padding: 0.9rem; color: #0f172a; font-weight: 600; font-size: 1rem;">${idx + 1}</td>
              <td style="padding: 0.9rem; word-break: break-all; font-size: 1rem;">
                <a href="${page.url}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none; font-weight: 500; border-bottom: 1px solid transparent; transition: all 0.2s;" onmouseover="this.style.color='#1d4ed8'; this.style.borderBottomColor='#1d4ed8';" onmouseout="this.style.color='#2563eb'; this.style.borderBottomColor='transparent';" title="Open ${page.url} in new tab">${page.url}</a>
              </td>
              <td style="padding: 0.9rem; text-align: right; color: ${ctrColor}; font-weight: 600; font-size: 1rem;">${ctrStr}%</td>
              <td style="padding: 0.9rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 1rem;">${page.impressions.toLocaleString()}</td>
              <td style="padding: 0.9rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 1rem;">${page.clicks.toLocaleString()}</td>
              <td style="padding: 0.9rem; text-align: right; color: ${posColor}; font-weight: 600; font-size: 1rem;">${page.avgPosition != null ? page.avgPosition.toFixed(1) : 'N/A'}</td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        return tableHtml;
      }
      
      // Helper to attach sort handlers after table is in DOM (shared by both createTopPagesSection functions)
      function attachSortHandlers() {
        setTimeout(() => {
          ['ctr', 'impressions', 'clicks', 'position'].forEach(col => {
            const th = document.getElementById(`sort-${col}`);
            if (th) {
              // Remove existing listeners by cloning
              const newTh = th.cloneNode(true);
              th.parentNode.replaceChild(newTh, th);
              newTh.addEventListener('click', () => {
                if (window.handleSort) {
                  window.handleSort(col);
                } else {
                  console.error('window.handleSort is not defined');
                }
              });
            } else {
              console.warn(`Sort header not found: sort-${col}`);
            }
          });
        }, 50);
      }
      
      // Make handleSort available globally (shared by both createTopPagesSection functions)
      if (!window.handleSort) {
        window.handleSort = function(column) {
          console.log('handleSort called with column:', column);
          if (window.topPagesSortColumn === column) {
            window.topPagesSortDirection = window.topPagesSortDirection === 'asc' ? 'desc' : 'asc';
          } else {
            window.topPagesSortColumn = column;
            window.topPagesSortDirection = 'desc';
          }
          
          // Get current data from stored source
          const currentMode = window.currentAuthorityMode || 'all';
          let topPages = window.topPagesData || [];
          
          // If no stored data, try to get from authorityBySegment
          if (!topPages || topPages.length === 0) {
            const segData = window.authorityBySegment;
            if (segData) {
              topPages = currentMode === 'all'
                ? (segData.all?.topPages || [])
                : currentMode === 'nonEducation'
                ? (segData.nonEducation?.topPages || [])
                : (segData.money?.topPages || []);
              window.topPagesData = topPages;
            }
          }
          
          const segmentLabel = currentMode === 'all'
            ? 'All pages'
            : currentMode === 'nonEducation'
            ? 'Exclude education (blogs / free course)'
            : 'Money pages only';
          
          // Get date range for display
          const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
          const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
          
          const tableContainer = document.getElementById('top-pages-table-container');
          if (tableContainer) {
            tableContainer.innerHTML = renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText);
            // attachCopyButtonHandler and attachSortHandlers are in shared scope, so they're accessible
            attachSortHandlers();
            // attachCopyButtonHandler is defined inside createTopPagesSection, so we need to find it or define it globally
            // For now, attach the copy button handler directly
            setTimeout(() => {
              const copyBtn = document.getElementById('top-pages-copy-urls');
              if (copyBtn) {
                const newCopyBtn = copyBtn.cloneNode(true);
                copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
                newCopyBtn.addEventListener('click', async () => {
                  const currentMode = window.currentAuthorityMode || 'all';
                  const segData = window.authorityBySegment;
                  const currentTopPages = currentMode === 'all'
                    ? (segData?.all?.topPages || [])
                    : currentMode === 'nonEducation'
                    ? (segData?.nonEducation?.topPages || [])
                    : (segData?.money?.topPages || []);
                  const text = currentTopPages.map(p => p.url).join('\n');
                  try {
                    await navigator.clipboard.writeText(text);
                    newCopyBtn.textContent = 'Copied!';
                    newCopyBtn.style.color = '#10b981';
                    setTimeout(() => {
                      newCopyBtn.textContent = 'Copy URLs';
                      newCopyBtn.style.color = '#666';
                    }, 2000);
                  } catch (err) {
                    console.error('Failed to copy URLs:', err);
                    newCopyBtn.textContent = 'Copy failed';
                    setTimeout(() => {
                      newCopyBtn.textContent = 'Copy URLs';
                    }, 2000);
                  }
                });
              }
            }, 50);
          } else {
            console.error('top-pages-table-container not found');
          }
        };
      }
      
      // Function to render segment comparison table (shared by both createTopPagesSection functions)
      function renderSegmentComparisonTable(authorityBySegment, currentMode) {
        const segments = [
          { key: 'all', label: 'All pages', data: authorityBySegment.all },
          { key: 'nonEducation', label: 'Exclude education (blogs / free course)', data: authorityBySegment.nonEducation },
          { key: 'money', label: 'Money pages only', data: authorityBySegment.money }
        ];
        
        let tableHtml = `
          <div style="margin-bottom: 0.5rem;">
            <h4 style="margin: 0 0 0.5rem 0; font-size: 1.15rem; font-weight: 700; color: #1e293b;">Segment overview (CTR & ranking)</h4>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.95rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Segment</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Site CTR</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Top-10 CTR</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Avg pos.</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Top-10 share</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Behaviour</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Ranking</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        segments.forEach(({ key, label, data }, idx) => {
          const isActive = key === currentMode;
          const siteCtr = data?.siteCtr || 0;
          const top10Ctr = data?.top10Ctr || 0;
          const avgPosition = data?.avgPosition || 0;
          const top10Share = (data?.top10Share || 0) * 100;
          const behaviourScore = data?.behaviour || 0;
          const rankingScore = data?.ranking || 0;
          
          tableHtml += `
            <tr 
              onclick="window.currentAuthorityMode = '${key}'; if(window.updateTopPagesSection) window.updateTopPagesSection('${key}');"
              style="
                cursor: pointer;
                border-bottom: 1px solid #f1f5f9;
                background: ${isActive ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : (idx % 2 === 0 ? '#ffffff' : '#fafafa')};
                transition: all 0.2s;
              "
              onmouseover="this.style.background='${isActive ? 'linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%)' : '#f8f9fa'}';"
              onmouseout="this.style.background='${isActive ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : (idx % 2 === 0 ? '#ffffff' : '#fafafa')}';"
            >
              <td style="padding: 0.75rem 1rem; font-weight: ${isActive ? '600' : '500'}; color: #0f172a; font-size: 0.95rem;">
                ${label}
                ${isActive ? '<span style="margin-left: 0.5rem; font-size: 0.8rem; padding: 0.15rem 0.5rem; border-radius: 999px; background: #10b981; color: white; font-weight: 600;">current</span>' : ''}
              </td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${siteCtr != null ? siteCtr.toFixed(1) : 'N/A'}%</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${top10Ctr != null ? top10Ctr.toFixed(1) : 'N/A'}%</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${avgPosition != null ? avgPosition.toFixed(1) : 'N/A'}</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${top10Share != null ? top10Share.toFixed(1) : 'N/A'}%</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 0.95rem;">${behaviourScore != null ? Math.round(behaviourScore) : 'N/A'}</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 0.95rem;">${rankingScore != null ? Math.round(rankingScore) : 'N/A'}</td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        return tableHtml;
      }
      
      // Function to create Top Pages section (full width, below pillar cards)
      function createTopPagesSection(scores, saved) {
        // Get Authority segment data from current scores (latest snapshot, not historical)
        // This uses the most recent audit data, not historical Supabase data
        const authorityObj = scores?.authority;
        let authorityBySegment = (typeof authorityObj === 'object' && authorityObj !== null) 
          ? authorityObj.bySegment 
          : null;
        
        // If no segment data in scores, try to get from saved audit (latest audit data from localStorage)
        if (!authorityBySegment && saved) {
          const savedScores = saved.scores;
          if (savedScores && savedScores.authority) {
            const savedAuthorityObj = savedScores.authority;
            if (typeof savedAuthorityObj === 'object' && savedAuthorityObj !== null) {
              authorityBySegment = savedAuthorityObj.bySegment || null;
              debugLog(' Top Pages: Using Authority segment data from saved audit (latest snapshot)', 'info');
            }
          }
        }
        
        if (!authorityBySegment) {
          debugLog(' No Authority segment data available for Top Pages table. This requires GSC queryPages data from your most recent audit.', 'warn');
          // Still create the section but show a helpful message - don't return early
        }
        
        // Remove existing top pages section if it exists
        const existingTopPages = document.getElementById('authority-top-pages-section');
        if (existingTopPages) {
          existingTopPages.remove();
        }
        
        // Create new section
        const topPagesSection = document.createElement('div');
        topPagesSection.id = 'authority-top-pages-section';
        topPagesSection.className = 'section-break';
        topPagesSection.style.marginTop = '2rem';
        topPagesSection.style.marginBottom = '2rem';
        
        // Get current mode from Authority card toggle (default to 'all')
        let currentMode = 'all';
        const authorityCard = Array.from(document.querySelectorAll('.pillar-card')).find(card => {
          const h3 = card.querySelector('h3');
          return h3 && h3.textContent === 'Authority';
        });
        
        if (authorityCard && authorityCard._authorityMode) {
          currentMode = authorityCard._authorityMode;
        }
        
        // Get top pages for current mode
        const topPages = currentMode === 'all'
          ? (authorityBySegment?.all?.topPages || [])
          : currentMode === 'nonEducation'
          ? (authorityBySegment?.nonEducation?.topPages || [])
          : (authorityBySegment?.money?.topPages || []);
        
        const segmentLabel = currentMode === 'all'
          ? 'All pages'
          : currentMode === 'nonEducation'
          ? 'Exclude education (blogs / free course)'
          : 'Money pages only';
        
        debugLog(` Top Pages: Found ${topPages.length} pages for segment "${currentMode}"`, 'info');
        if (topPages.length > 0) {
          debugLog(` Top Pages: First page URL: ${topPages[0].url}, Impressions: ${topPages[0].impressions}`, 'info');
        }
        
        // Get brand queries for mini-table
        const topQueries = saved?.searchData?.topQueries || [];
        const brandQueries = topQueries
          .filter(q => isBrandQuery(q.query || ''))
          .sort((a, b) => (b.impressions || 0) - (a.impressions || 0))
          .slice(0, 10);
        
        // Create section HTML
        topPagesSection.innerHTML = `
          <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 1rem 0; color: var(--brand-dark); font-size: 1.5rem;">Authority - Behaviour & Ranking</h3>
            <div style="margin-bottom: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 4px; font-size: 1rem; line-height: 1.6; color: #666;">
              <p style="margin: 0 0 0.75rem 0;"><strong>Behaviour:</strong> Measures click-through rate (CTR) performance. Combines Overall CTR (50% weight) for all ranking search terms and Top-10 Ranked Search Terms CTR (50% weight) for queries ranking in positions 1-10. Indicates how well your titles and descriptions convert impressions to clicks. Data source: Google Search Console query+page metrics.</p>
              <p style="margin: 0;"><strong>Ranking:</strong> Measures search visibility and position quality. Combines Average Position Score (50% weight) and Top-10 Impression Share (50% weight). Shows how high you rank on average and what percentage of impressions appear in positions 1-10. Data source: Google Search Console query+page metrics.</p>
            </div>
            <div style="margin-bottom: 1rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; font-size: 0.9rem;">
              <span style="font-weight: 600; color: #666;">Current Segment:</span>
              <span id="top-pages-segment-label" style="color: #333; margin-left: 0.5rem;">${segmentLabel}</span>
            </div>
            <div id="top-pages-table-container">
              ${renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText)}
            </div>
            
            ${authorityBySegment && authorityBySegment[currentMode] ? `
            <div id="top-pages-recommendations-container" style="margin-top: 2rem;">
              ${renderRecommendationsTable(currentMode, {
                siteCtr: authorityBySegment[currentMode].siteCtr || 0,
                top10Ctr: authorityBySegment[currentMode].top10Ctr || 0,
                avgPosition: authorityBySegment[currentMode].avgPosition || 0,
                top10Share: authorityBySegment[currentMode].top10Share || 0,
                behaviourScore: authorityBySegment[currentMode].behaviour || 0,
                rankingScore: authorityBySegment[currentMode].ranking || 0
              }, segmentLabel, dateRangeText)}
            </div>
            ` : ''}
            
            ${brandQueries.length > 0 ? `
            <div style="margin-top: 2rem; padding: 1rem; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #f59e0b;">
              <h4 style="margin: 0 0 0.75rem 0; color: #92400e; font-size: 1rem; font-weight: 600;">Top Branded Queries</h4>
              <p style="margin: 0 0 1rem 0; font-size: 0.85rem; color: #666; line-height: 1.5;">Branded search queries (e.g., "Alan Ranger Photography") with CTR and position metrics.</p>
              <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                  <thead>
                    <tr style="background: #e5e7eb; border-bottom: 2px solid #d1d5db;">
                      <th style="padding: 0.5rem; text-align: left; font-weight: 600; color: #374151;">Query</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Impressions</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Clicks</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">CTR</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Position</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${brandQueries.map((q, idx) => {
                      const ctr = q.impressions > 0 ? ((q.clicks || 0) / q.impressions * 100) : 0;
                      const ctrColor = ctr >= 25 ? '#10b981' : ctr >= 10 ? '#f59e0b' : '#ef4444';
                      const posColor = (q.position || 0) <= 3 ? '#10b981' : (q.position || 0) <= 5 ? '#f59e0b' : '#ef4444';
                      return `
                      <tr style="border-bottom: 1px solid #e5e7eb; ${idx % 2 === 0 ? 'background: #ffffff;' : 'background: #f9fafb;'}">
                        <td style="padding: 0.5rem; color: #1f2937; font-weight: 500;">${(q.query || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</td>
                        <td style="padding: 0.5rem; text-align: right; color: #6b7280;">${(q.impressions || 0).toLocaleString()}</td>
                        <td style="padding: 0.5rem; text-align: right; color: #6b7280;">${(q.clicks || 0).toLocaleString()}</td>
                        <td style="padding: 0.5rem; text-align: right; color: ${ctrColor}; font-weight: 600;">${ctr.toFixed(1)}%</td>
                        <td style="padding: 0.5rem; text-align: right; color: ${posColor}; font-weight: 600;">${(q.position || 0).toFixed(1)}</td>
                      </tr>
                    `;
                    }).join('')}
                  </tbody>
                </table>
              </div>
            </div>
            ` : ''}
          </div>
        `;
        
        // Insert into Authority panel instead of Overview
        const authorityPanel = document.querySelector('.aigeo-panel[data-panel="authority"]');
        if (authorityPanel) {
          // Clear any existing content
          const existing = document.getElementById('authority-top-pages-section');
          if (existing) existing.remove();
          authorityPanel.appendChild(topPagesSection);
          debugLog(' Authority section inserted into Authority panel', 'success');
        } else {
          // Fallback: insert after pillar cards (old behavior)
        pillarCards.parentNode.insertBefore(topPagesSection, pillarCards.nextSibling);
          debugLog(' Authority section inserted after pillar cards (fallback)', 'info');
        }
        
        // Store authorityBySegment globally so updateTopPagesSection can access it
        window.authorityBySegment = authorityBySegment;
        
        // Store update function globally so Authority mode toggle can call it
        window.updateTopPagesSection = function(mode) {
          const topPages = mode === 'all'
            ? (authorityBySegment?.all?.topPages || [])
            : mode === 'nonEducation'
            ? (authorityBySegment?.nonEducation?.topPages || [])
            : (authorityBySegment?.money?.topPages || []);
          
          const segmentLabel = mode === 'all'
            ? 'All pages'
            : mode === 'nonEducation'
            ? 'Exclude education (blogs / free course)'
            : 'Money pages only';
          
          debugLog(` Top Pages: Updating to segment "${mode}", found ${topPages.length} pages`, 'info');
          
          // Update segment label
          const labelEl = document.getElementById('top-pages-segment-label');
          if (labelEl) labelEl.textContent = segmentLabel;
          
          // Update summary if available
          const getSegmentSummary = (m) => {
            if (!authorityBySegment || !authorityBySegment[m]) return null;
            const segmentData = authorityBySegment[m];
            return {
              behaviour: segmentData.behaviour || 0,
              ranking: segmentData.ranking || 0,
              total: segmentData.total || segmentData.score || 0
            };
          };
          
          const summary = getSegmentSummary(mode);
          const summaryDiv = document.getElementById('top-pages-segment-summary');
          if (summary && summaryDiv) {
            const rag = getRAGStatus(summary.total);
            summaryDiv.innerHTML = `
              ${formatComponentScore('Behaviour', summary.behaviour)}
              ${formatComponentScore('Ranking', summary.ranking)}
            `;
            // Update RAG badge and score
            const ragBadge = summaryDiv.parentElement.querySelector('.rag-badge');
            const scoreSpan = summaryDiv.parentElement.querySelector('span[style*="font-size: 1.5rem"]');
            if (ragBadge) {
              ragBadge.className = `rag-badge ${rag.status}`;
              ragBadge.textContent = rag.label;
            }
            if (scoreSpan) {
              scoreSpan.textContent = Math.round(summary.total);
              scoreSpan.style.color = rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444';
            }
          }
          
          // Update toggle buttons
          ['all', 'nonEducation', 'money'].forEach(m => {
            const btn = document.getElementById(`top-pages-mode-${m}`);
            if (btn) {
              if (m === mode) {
                btn.style.background = '#10b981';
                btn.style.color = 'white';
                btn.style.fontWeight = '600';
              } else {
                btn.style.background = 'white';
                btn.style.color = '#666';
                btn.style.fontWeight = '400';
              }
            }
          });
          
          // Update comparison table
          const comparisonDiv = document.getElementById('top-pages-comparison-table');
          if (comparisonDiv && authorityBySegment) {
            comparisonDiv.innerHTML = renderSegmentComparisonTable(authorityBySegment, mode);
          }
          
          // Get date range for display
          const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
          const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
          
          // Update table (reset sort when switching segments)
          window.topPagesData = topPages;
          window.topPagesSortColumn = null;
          window.topPagesSortDirection = 'desc';
          const tableContainer = document.getElementById('top-pages-table-container');
          if (tableContainer) {
            tableContainer.innerHTML = renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText);
            attachCopyButtonHandler();
            attachSortHandlers();
          }
          
          // Update recommendations table
          const recommendationsContainer = document.getElementById('top-pages-recommendations-container');
          if (recommendationsContainer && authorityBySegment && authorityBySegment[mode]) {
            const segmentLabel = mode === 'all'
              ? 'All pages'
              : mode === 'nonEducation'
              ? 'Exclude education (blogs / free course)'
              : 'Money pages only';
            const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
            const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
            recommendationsContainer.innerHTML = renderRecommendationsTable(mode, {
              siteCtr: authorityBySegment[mode].siteCtr || 0,
              top10Ctr: authorityBySegment[mode].top10Ctr || 0,
              avgPosition: authorityBySegment[mode].avgPosition || 0,
              top10Share: authorityBySegment[mode].top10Share || 0,
              behaviourScore: authorityBySegment[mode].behaviour || 0,
              rankingScore: authorityBySegment[mode].ranking || 0
            }, segmentLabel, dateRangeText);
          }
        };
        
        // window.handleSort is now defined in shared scope above
        
        // Attach toggle button handlers
        setTimeout(() => {
          ['all', 'nonEducation', 'money'].forEach(mode => {
            const btn = document.getElementById(`top-pages-mode-${mode}`);
            if (btn) {
              btn.addEventListener('click', () => {
                window.currentAuthorityMode = mode;
                window.updateTopPagesSection(mode);
                // Also update Authority pillar card if it exists
                const authorityCard = Array.from(document.querySelectorAll('.pillar-card')).find(card => {
                  const h3 = card.querySelector('h3');
                  return h3 && h3.textContent === 'Authority';
                });
                if (authorityCard && authorityCard._updateAuthorityDisplay) {
                  authorityCard._authorityMode = mode;
                  authorityCard._updateAuthorityDisplay();
                  // Update Authority pillar toggle buttons
                  const modeId = authorityCard._modeId;
                  ['all', 'nonEducation', 'money'].forEach(m => {
                    const authBtn = document.getElementById(`${modeId}-${m}`);
                    if (authBtn) {
                      if (m === mode) {
                        authBtn.style.background = '#10b981';
                        authBtn.style.color = 'white';
                      } else {
                        authBtn.style.background = 'white';
                        authBtn.style.color = '#666';
                      }
                    }
                  });
                }
              });
            }
          });
        }, 0);
        
        // Attach initial copy button handler
        attachCopyButtonHandler();
        
        function attachCopyButtonHandler() {
          setTimeout(() => {
            const copyBtn = document.getElementById('top-pages-copy-urls');
            if (copyBtn) {
              // Remove existing listener
              const newCopyBtn = copyBtn.cloneNode(true);
              copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
              
              newCopyBtn.addEventListener('click', async () => {
                const currentMode = window.currentAuthorityMode || 'all';
                const currentTopPages = currentMode === 'all'
                  ? (authorityBySegment?.all?.topPages || [])
                  : currentMode === 'nonEducation'
                  ? (authorityBySegment?.nonEducation?.topPages || [])
                  : (authorityBySegment?.money?.topPages || []);
                
                const text = currentTopPages.map(p => p.url).join('\n');
                try {
                  await navigator.clipboard.writeText(text);
                  newCopyBtn.textContent = 'Copied!';
                  newCopyBtn.style.color = '#10b981';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                    newCopyBtn.style.color = '#666';
                  }, 2000);
                } catch (err) {
                  console.error('Failed to copy URLs:', err);
                  newCopyBtn.textContent = 'Copy failed';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                  }, 2000);
                }
              });
            }
          }, 0);
        }
        // renderFullWidthTopPagesTable is now defined in shared scope above
      }
      
      // Function to render Money Pages table (with pagination and sorting, matching Top Pages format)
      async function renderMoneyPagesTable(moneyRows, currentPage = 1, rowsPerPage = 10) {
        try {
          if (!moneyRows || moneyRows.length === 0) {
            return '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">No money-page data available for this audit period. Check that your money pages have impressions in the selected date range.</div>';
          }
        
        // Store original data for sorting (across all pages) - update if new data provided
        window.moneyPagesData = moneyRows;
        if (window.moneyPagesSortColumn === undefined) {
          window.moneyPagesSortColumn = null;
          window.moneyPagesSortDirection = 'desc';
        }
        
        // Sort data if needed (sort ALL rows, not just current page)
        let sortedRows = [...moneyRows];
        if (window.moneyPagesSortColumn) {
          sortedRows.sort((a, b) => {
            let aVal, bVal;
            switch(window.moneyPagesSortColumn) {
              case 'ctr':
                aVal = (a.ctr || 0) * 100;
                bVal = (b.ctr || 0) * 100;
                break;
              case 'impressions':
                aVal = a.impressions || 0;
                bVal = b.impressions || 0;
                break;
              case 'clicks':
                aVal = a.clicks || 0;
                bVal = b.clicks || 0;
                break;
              case 'position':
                aVal = a.avgPosition || 99;
                bVal = b.avgPosition || 99;
                break;
              case 'opportunity':
                // Sort by category priority: HIGH_OPPORTUNITY=0, VISIBILITY_FIX=1, MAINTAIN=2
                const categoryOrder = { HIGH_OPPORTUNITY: 0, VISIBILITY_FIX: 1, MAINTAIN: 2 };
                aVal = categoryOrder[a.category] ?? 99;
                bVal = categoryOrder[b.category] ?? 99;
                break;
              default:
                return 0;
            }
            const diff = aVal - bVal;
            return window.moneyPagesSortDirection === 'asc' ? diff : -diff;
          });
        }
        
        // Update stored sorted data
        window.moneyPagesData = sortedRows;
        
        // Helper function to get sort icon
        const getSortIcon = (column) => {
          if (!window.moneyPagesSortColumn || window.moneyPagesSortColumn !== column) {
            return '<span style="color: #475569; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 600;"></span>';
          }
          return window.moneyPagesSortDirection === 'asc' 
            ? '<span style="color: #99004C; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 700;"></span>'
            : '<span style="color: #99004C; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 700;"></span>';
        };
        
        // Get date range for display
        const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
        const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
        
        // Get current filter values (stored globally)
        const currentCategoryFilter = window.moneyPagesCategoryFilter || 'ALL';
        const currentSubSegmentFilter = window.moneyPagesSubSegmentFilter || 'ALL';
        const currentMinImpressions = window.moneyPagesMinImpressions || 0;
        
        // Get zero impressions filter (default to true - include zero impressions)
        const includeZero = window.moneyPagesIncludeZero !== false;
        
        // Apply filters before sorting/pagination
        let filteredRows = sortedRows.filter(row => {
          const matchCat = currentCategoryFilter === 'ALL' || row.category === currentCategoryFilter;
          const matchSubSeg = currentSubSegmentFilter === 'ALL' || row.subSegment === currentSubSegmentFilter;
          const matchImp = (row.impressions || 0) >= currentMinImpressions;
          const matchZero = includeZero || (row.impressions || 0) > 0; // Include zero impressions if checkbox is checked
          return matchCat && matchSubSeg && matchImp && matchZero;
        });
        
        // Update pagination based on filtered rows
        const filteredTotalPages = Math.ceil(filteredRows.length / rowsPerPage);
        const filteredStartIdx = (currentPage - 1) * rowsPerPage;
        const filteredEndIdx = filteredStartIdx + rowsPerPage;
        const pageRows = filteredRows.slice(filteredStartIdx, filteredEndIdx);
        
        let tableHtml = `
          <div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem;">
              <div>
                <h4 style="margin: 0 0 0.25rem 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Money Pages Opportunity Table</h4>
                <p class="table-subtitle" style="margin: 0 0 0.5rem 0; font-size: 0.75rem; color: #64748b;">
                  Filter by opportunity type and impressions to focus optimisation work.
                </p>
                <span style="font-size: 0.75rem; color: #334155; font-weight: 500;">Data period: Last ${dateRangeText}  Showing ${filteredStartIdx + 1}-${Math.min(filteredEndIdx, filteredRows.length)} of ${filteredRows.length}</span>
              </div>
              <div class="table-controls" style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  Category:
                  <select id="money-pages-filter-category" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; background: white; cursor: pointer;">
                    <option value="ALL" ${currentCategoryFilter === 'ALL' ? 'selected' : ''}>All categories</option>
                    <option value="HIGH_OPPORTUNITY" ${currentCategoryFilter === 'HIGH_OPPORTUNITY' ? 'selected' : ''}>High opportunity</option>
                    <option value="VISIBILITY_FIX" ${currentCategoryFilter === 'VISIBILITY_FIX' ? 'selected' : ''}>Visibility fix</option>
                    <option value="MAINTAIN" ${currentCategoryFilter === 'MAINTAIN' ? 'selected' : ''}>Maintain</option>
                  </select>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  Sub-segment:
                  <select id="money-pages-filter-subsegment" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; background: white; cursor: pointer;">
                    <option value="ALL" ${currentSubSegmentFilter === 'ALL' ? 'selected' : ''} id="money-subsegment-all">All sub-segments</option>
                    <option value="PRODUCT" ${currentSubSegmentFilter === 'PRODUCT' ? 'selected' : ''} id="money-subsegment-product">Product Pages</option>
                    <option value="EVENT" ${currentSubSegmentFilter === 'EVENT' ? 'selected' : ''} id="money-subsegment-event">Event Pages</option>
                    <option value="LANDING" ${currentSubSegmentFilter === 'LANDING' ? 'selected' : ''} id="money-subsegment-landing">Landing Pages</option>
                  </select>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  Min impressions:
                  <input type="number" id="money-pages-min-impressions" min="0" step="50" value="${currentMinImpressions}" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; width: 100px;" />
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  <input type="checkbox" id="money-pages-include-zero" ${window.moneyPagesIncludeZero !== false ? 'checked' : ''} style="cursor: pointer;" />
                  Include zero impressions
                </label>
                <button id="money-pages-copy-urls" type="button" style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #2563eb; background: #2563eb; cursor: pointer; color: white; font-weight: 600; transition: all 0.2s; box-shadow: 0 1px 2px rgba(0,0,0,0.1);" onmouseover="this.style.background='#1d4ed8'; this.style.borderColor='#1d4ed8';" onmouseout="this.style.background='#2563eb'; this.style.borderColor='#2563eb';">
                  Copy current URLs
                </button>
              </div>
            </div>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; width: 40px;">#</th>
                  <th style="text-align: left; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; width: 500px; min-width: 500px;">URL / Title / Meta</th>
                  <th id="money-sort-clicks" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; white-space: nowrap;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Clicks">
                    Clicks${getSortIcon('clicks')}
                  </th>
                  <th id="money-sort-impressions" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; white-space: nowrap;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Impressions">
                    Impressions${getSortIcon('impressions')}
                  </th>
                  <th id="money-sort-ctr" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; white-space: nowrap;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by CTR">
                    CTR${getSortIcon('ctr')}
                  </th>
                  <th id="money-sort-position" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; line-height: 1.2;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Avg Position">
                    <div>Avg</div><div>Position</div>${getSortIcon('position')}
                  </th>
                  <th id="money-sort-opportunity" style="text-align: center; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; white-space: nowrap;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Opportunity">
                    Opportunity${getSortIcon('opportunity')}
                  </th>
                  <th style="text-align: left; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; width: 200px; min-width: 200px;">Schema Types</th>
                  <th style="text-align: left; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px;">Recommended action</th>
                  <th style="text-align: center; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; width: 120px; min-width: 120px;">Track / Manage</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        // ============================================
        // STEP 3: Fetch optimisation statuses from database (ALWAYS fetch, don't rely on cache)
        // ============================================
        // Store row data by normalized URL for Track button access
        // Always initialize the map if it doesn't exist
        if (!window.moneyPagesRowDataByUrl) {
          window.moneyPagesRowDataByUrl = new Map();
        }
        
        // CRITICAL: DO NOT fetch statuses here - the caller should fetch before calling renderMoneyPagesTable
        // Fetching here causes the cache to be cleared every time the table renders, losing status information
        // Instead, we rely on the cache that was populated by the caller
        debugLog(`[Money Pages Opportunity] Rendering table using existing cache: cacheSize=${window.optimisationStatusCache?.size || 0}, rowsCount=${moneyRows.length}`, 'info');
        
        pageRows.forEach((row, idx) => {
          const isEven = idx % 2 === 0;
          const rowBg = isEven ? '#ffffff' : '#fafafa';
          const ctrPct = (row.ctr || 0) * 100;
          const ctrColor = ctrPct >= 2 ? '#10b981' : ctrPct >= 1 ? '#f59e0b' : '#ef4444';
          const posColor = row.avgPosition <= 5 ? '#10b981' : row.avgPosition <= 10 ? '#f59e0b' : '#ef4444';
          const categoryColor = row.categoryColor === 'green' ? '#10b981' : row.categoryColor === 'amber' ? '#f59e0b' : '#ef4444';
          
          // Extract title from row data or generate from URL
          const pageTitle = row.title || (() => {
            try {
              const urlObj = new URL(row.url);
              const pathParts = urlObj.pathname.split('/').filter(p => p);
              if (pathParts.length > 0) {
                // Convert last path segment to title case
                const lastPart = pathParts[pathParts.length - 1];
                return lastPart.split('-').map(word => 
                  word.charAt(0).toUpperCase() + word.slice(1)
                ).join(' ');
              }
            } catch (e) {}
            return null; // Will show URL if no title
          })();
          
          // Meta description from row data
          const metaDescription = row.metaDescription || null;
          
          // Store row data by normalized URL for Track button access
          // Ensure we store a complete copy with all metrics
          const normalizedRowUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(row.url) : row.url.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
          const rowDataToStore = {
            url: row.url,
            title: row.title,
            clicks: row.clicks || 0,
            impressions: row.impressions || 0,
            ctr: row.ctr || 0,
            avgPosition: row.avgPosition != null ? row.avgPosition : (row.position || null),
            position: row.position || row.avgPosition || null,
            segment: row.segment || 'money_pages',
            metaDescription: row.metaDescription || null,
            category: row.category,
            categoryLabel: row.categoryLabel,
            categoryColor: row.categoryColor,
            recommendation: row.recommendation,
            schemaTypes: row.schemaTypes || []
          };
          window.moneyPagesRowDataByUrl.set(normalizedRowUrl, rowDataToStore);
          // Debug: Log if this is the landscape page
          if (row.url && row.url.includes('landscape-photography-workshops')) {
            console.log('[Money Pages] Stored row data for landscape page:', rowDataToStore);
          }
          
          tableHtml += `
            <tr style="border-bottom: 1px solid #f1f5f9; background: ${rowBg}; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa';" onmouseout="this.style.background='${rowBg}';">
              <td style="padding: 0.75rem; color: #0f172a; font-weight: 600; vertical-align: top; width: 40px;">${filteredStartIdx + idx + 1}</td>
              <td style="padding: 0.75rem; vertical-align: top; width: 500px; min-width: 500px;">
                <a href="${row.url}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none; font-weight: 500; border-bottom: 1px solid transparent; transition: all 0.2s;" onmouseover="this.style.color='#1d4ed8'; this.style.borderBottomColor='#1d4ed8';" onmouseout="this.style.color='#2563eb'; this.style.borderBottomColor='transparent';" title="Open ${row.url} in new tab">
                  <div style="font-size: 0.85rem; color: #64748b; margin-bottom: 0.25rem; word-break: break-all;">${row.url}</div>
                </a>
                ${pageTitle ? `<div style="font-weight: 600; color: #1e293b; font-size: 0.9rem; margin-top: 0.5rem; margin-bottom: 0.25rem; white-space: nowrap;">${pageTitle}</div>` : ''}
                ${metaDescription ? `<div style="font-size: 0.8rem; color: #64748b; line-height: 1.4; margin-top: ${pageTitle ? '0.25rem' : '0.5rem'}; word-wrap: break-word;">${metaDescription}</div>` : '<div style="font-size: 0.8rem; color: #94a3b8; font-style: italic; margin-top: 0.5rem;">No meta description available</div>'}
              </td>
              <td style="padding: 0.75rem; text-align: right; color: #0f172a; font-weight: 500; vertical-align: top; white-space: nowrap;">${(row.clicks || 0).toLocaleString()}</td>
              <td style="padding: 0.75rem; text-align: right; color: #0f172a; font-weight: 500; vertical-align: top; white-space: nowrap;">${(row.impressions || 0).toLocaleString()}</td>
              <td style="padding: 0.75rem; text-align: right; color: ${ctrColor}; font-weight: 600; vertical-align: top; white-space: nowrap;">${ctrPct.toFixed(1)}%</td>
              <td style="padding: 0.75rem; text-align: right; color: ${posColor}; font-weight: 600; vertical-align: top; white-space: nowrap;">${row.avgPosition ? row.avgPosition.toFixed(1) : ''}</td>
              <td style="padding: 0.75rem; text-align: center; vertical-align: top;">
                ${(() => {
                  // Split categoryLabel into main part and bracketed part
                  const label = row.categoryLabel || '';
                  const bracketMatch = label.match(/^(.+?)\s*\((.+?)\)$/);
                  if (bracketMatch) {
                    const mainPart = bracketMatch[1].trim();
                    const bracketPart = bracketMatch[2].trim();
                    return `<span style="display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; background: ${categoryColor}20; color: ${categoryColor}; border: 1px solid ${categoryColor}40; line-height: 1.3;">
                      <div>${mainPart}</div>
                      <div style="font-size: 0.7rem; font-weight: 500; opacity: 0.9;">(${bracketPart})</div>
                    </span>`;
                  }
                  // If no brackets, just show the label
                  return `<span style="display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; background: ${categoryColor}20; color: ${categoryColor}; border: 1px solid ${categoryColor}40;">
                    ${label}
                  </span>`;
                })()}
              </td>
              <td style="padding: 0.75rem; vertical-align: top; width: 200px; min-width: 200px;">
                ${(() => {
                  const schemaTypes = row.schemaTypes || [];
                  if (schemaTypes.length === 0) {
                    return '<span style="color: #94a3b8; font-style: italic; font-size: 0.8rem;">None</span>';
                  }
                  // Ensure schemaTypes are strings (handle both string arrays and object arrays)
                  const typeStrings = schemaTypes.map(t => {
                    if (typeof t === 'string') return t;
                    if (typeof t === 'object' && t !== null) {
                      // Handle objects like {type: 'FAQPage', count: 5}
                      return t.type || String(t);
                    }
                    return String(t);
                  }).filter(Boolean);
                  
                  if (typeStrings.length === 0) {
                    return '<span style="color: #94a3b8; font-style: italic; font-size: 0.8rem;">None</span>';
                  }
                  
                  // Show first 5 types, then "+X more" if there are more
                  const displayTypes = typeStrings.slice(0, 5);
                  const remaining = typeStrings.length - 5;
                  const typesText = displayTypes.join(', ');
                  const moreText = remaining > 0 ? ` <span style="color: #64748b; font-size: 0.75rem;">+${remaining} more</span>` : '';
                  return `<span style="color: #475569; font-size: 0.8rem; line-height: 1.4;" title="${typeStrings.join(', ')}">${typesText}${moreText}</span>`;
                })()}
              </td>
              <td style="padding: 0.75rem; color: #475569; font-size: 0.8rem; line-height: 1.5; vertical-align: top;">${row.recommendation}</td>
              <td style="padding: 0.75rem; text-align: center; vertical-align: top;">
                ${(() => {
                  // Use the same status lookup as Ranking & AI for consistency
                  const taskType = 'on_page';
                  // Create a row-like object for getOptimisationStatus (it expects keyword and best_url/targetUrl)
                  const statusRow = {
                    keyword: '', // Empty for page-level tasks
                    best_url: row.url,
                    targetUrl: row.url,
                    ranking_url: row.url
                  };
                  
                  // First check the main cache
                  let status = window.getOptimisationStatus ? window.getOptimisationStatus(statusRow, taskType) : null;
                  
                  // Debug: Log status lookup for ALL pages (not just landscape) to trace the issue
                  if (status) {
                    console.log('[Money Pages] Status lookup result:', {
                      url: row.url,
                      hasId: 'id' in status,
                      hasTaskId: 'task_id' in status,
                      id: status.id,
                      task_id: status.task_id,
                      status: status.status,
                      allKeys: Object.keys(status).slice(0, 10) // First 10 keys
                    });
                    
                    // CRITICAL: Ensure id field exists - if not, try to get it from task_id or log error
                    if (!status.id) {
                      console.error('[Money Pages] Status object missing id field:', {
                        url: row.url,
                        status,
                        hasTaskId: 'task_id' in status,
                        task_id: status.task_id
                      });
                      // Try to use task_id as fallback
                      if (status.task_id) {
                        status.id = status.task_id;
                        console.warn('[Money Pages] Using task_id as fallback for id');
                      }
                    }
                  } else {
                    // Log when status is not found
                    const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(row.url) : row.url.toLowerCase().trim();
                    const expectedKey = `::${urlKey}::on_page`;
                    const cacheHasKey = window.optimisationStatusCache ? window.optimisationStatusCache.has(expectedKey) : false;
                    console.log('[Money Pages] Status not found for:', {
                      url: row.url,
                      urlKey,
                      expectedKey,
                      cacheHasKey,
                      cacheSize: window.optimisationStatusCache?.size || 0
                    });
                  }
                  
                  // If not found, check temporary cache (for newly created tasks)
                  if (!status && window.moneyPagesTaskCache) {
                    const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(row.url) : row.url.toLowerCase().trim();
                    const tempTask = window.moneyPagesTaskCache.get(urlKey);
                    if (tempTask) {
                      // Build a status object from the temporary cache
                      status = {
                        id: tempTask.id,
                        status: tempTask.status || 'planned',
                        cycle_number: tempTask.cycle_number || 1,
                        cycle_id: tempTask.cycle_id || null,
                        objective_state: 'on_track'
                      };
                      console.log('[Money Pages] Using temporary cache for:', row.url, status);
                    }
                  }
                  
                  // Debug logging for landscape page
                  if (row.url && row.url.includes('landscape-photography-workshops')) {
                    const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(row.url) : row.url.toLowerCase().trim();
                    const expectedKey = `::${urlKey}::on_page`;
                    const cacheHasKey = window.optimisationStatusCache ? window.optimisationStatusCache.has(expectedKey) : false;
                    const allKeys = window.optimisationStatusCache ? Array.from(window.optimisationStatusCache.keys()) : [];
                    const matchingKeys = allKeys.filter(k => k.includes(urlKey) || k.includes('landscape'));
                    
                    console.log('[Money Pages] Status lookup for landscape page:', {
                      url: row.url,
                      urlKey,
                      expectedKey,
                      found: !!status,
                      status: status?.status,
                      taskId: status?.id,
                      cacheSize: window.optimisationStatusCache ? window.optimisationStatusCache.size : 0,
                      tempCacheSize: window.moneyPagesTaskCache ? window.moneyPagesTaskCache.size : 0,
                      cacheHasKey,
                      matchingKeys: matchingKeys.slice(0, 5)
                    });
                  }
                  
                  if (!status || typeof status !== 'object' || !status.status) {
                    // Not tracked - show Track button
                    return `
                      <div style="display: flex; flex-direction: column; gap: 0.25rem; align-items: center;">
                        <span style="display: inline-block; padding: 0.125rem 0.5rem; border-radius: 4px; font-size: 0.7rem; font-weight: 600; background: #94a3b820; color: #94a3b8; border: 1px solid #94a3b840;">
                          Not tracked
                        </span>
                        <button 
                          onclick="window.trackMoneyPage('${row.url.replace(/'/g, "\\'")}', '${(row.title || row.url).replace(/'/g, "\\'")}')"
                          data-row-url="${row.url.replace(/"/g, '&quot;')}"
                          style="font-size: 0.75rem; padding: 0.375rem 0.75rem; border-radius: 4px; border: 1px solid #10b981; background: #10b981; cursor: pointer; color: white; font-weight: 600; transition: all 0.2s; white-space: nowrap;"
                          onmouseover="this.style.background='#059669'; this.style.borderColor='#059669';"
                          onmouseout="this.style.background='#10b981'; this.style.borderColor='#10b981';"
                          title="Create optimisation task for ${row.url} (CTR  2.5%)">
                          Track
                        </button>
                      </div>
                    `;
                  }
                  
                  // Tracked - show status pill + cycle info + Manage button (same as Ranking & AI)
                  const statusText = {
                    'planned': 'Planned',
                    'in_progress': 'In progress',
                    'monitoring': 'Monitoring',
                    'done': 'Done',
                    'paused': 'Paused',
                    'cancelled': 'Cancelled'
                  }[status.status] || status.status;
                  
                  // Status colors (matching Ranking & AI)
                  let statusBg, statusColor;
                  if (status.status === 'planned') {
                    statusBg = '#e9d5ff';
                    statusColor = '#6b21a8';
                  } else if (status.status === 'in_progress') {
                    statusBg = '#fed7aa';
                    statusColor = '#9a3412';
                  } else if (status.status === 'monitoring') {
                    statusBg = '#a7f3d0';
                    statusColor = '#065f46';
                  } else if (status.status === 'done') {
                    statusBg = '#dcfce7';
                    statusColor = '#166534';
                  } else if (status.status === 'paused') {
                    statusBg = '#e5e7eb';
                    statusColor = '#374151';
                  } else if (status.status === 'cancelled') {
                    statusBg = '#fee2e2';
                    statusColor = '#991b1b';
                  } else {
                    statusBg = '#f9fafb';
                    statusColor = '#4b5563';
                  }
                  
                  // Cycle info
                  const cycleNo = status.cycle_active || 1;
                  let cycleText = 'Cycle ' + cycleNo;
                  if (status.last_activity_at) {
                    const lastActivity = new Date(status.last_activity_at);
                    const now = new Date();
                    const daysAgo = Math.floor((now - lastActivity) / (1000 * 60 * 60 * 24));
                    const timeText = daysAgo === 0 ? 'Today' : daysAgo === 1 ? '1 day ago' : daysAgo + ' days ago';
                    cycleText += ' ' + timeText;
                  }
                  
                  const taskId = status.id || status.task_id;
                  
                  // Validate taskId exists
                  if (!taskId) {
                    console.error('[Money Pages] Task ID missing in status object:', {
                      status,
                      hasId: 'id' in status,
                      hasTaskId: 'task_id' in status,
                      statusKeys: Object.keys(status),
                      url: row.url
                    });
                    return '<div style="display: flex; flex-direction: column; gap: 0.25rem; align-items: center;"><span style="color: #ef4444; font-size: 0.7rem;">Error: Task ID missing</span></div>';
                  }
                  
                  // Debug: Log taskId extraction for landscape page
                  if (row.url && row.url.includes('landscape-photography-workshops')) {
                    console.log('[Money Pages] TaskId extraction for landscape page:', {
                      url: row.url,
                      statusId: status.id,
                      statusTaskId: status.task_id,
                      extractedTaskId: taskId,
                      statusType: typeof taskId,
                      statusObject: {
                        id: status.id,
                        task_id: status.task_id,
                        hasId: 'id' in status,
                        hasTaskId: 'task_id' in status,
                        allKeys: Object.keys(status).slice(0, 15)
                      }
                    });
                  }
                  
                  // Escape taskId for use in onclick attribute (it's a UUID string, so needs quotes)
                  const taskIdEscaped = String(taskId).replace(/'/g, "\\'").replace(/"/g, '&quot;');
                  
                  // DEBUG: Log the onclick handler that will be generated
                  if (row.url && row.url.includes('landscape-photography-workshops')) {
                    const onclickHandler = `window.openOptimisationTaskDrawer('${taskIdEscaped}')`;
                    console.log('[Money Pages] Generated onclick handler for landscape page:', {
                      taskId: taskId,
                      taskIdEscaped: taskIdEscaped,
                      onclickHandler: onclickHandler,
                      onclickLength: onclickHandler.length
                    });
                  }
                  return '<div style="display: flex; flex-direction: column; gap: 0.25rem; align-items: center;">' +
                    '<span style="display: inline-block; padding: 0.125rem 0.5rem; border-radius: 4px; font-size: 0.7rem; font-weight: 600; background: ' + statusBg + '; color: ' + statusColor + '; border: 1px solid ' + statusColor + '40; text-transform: capitalize;">' +
                      escapeHtml(statusText) +
                    '</span>' +
                    '<div style="font-size: 0.65rem; color: #64748b; margin: 0.125rem 0;">' +
                      escapeHtml(cycleText) +
                    '</div>' +
                    '<button ' +
                      'onclick="window.openOptimisationTaskDrawer(\'' + taskIdEscaped + '\')" ' +
                      'style="font-size: 0.75rem; padding: 0.375rem 0.75rem; border-radius: 4px; border: 1px solid #a3d977; background: #E5FFCC; cursor: pointer; color: #000000; font-weight: 600; transition: all 0.2s; white-space: nowrap;" ' +
                      'onmouseover="this.style.background=\'#d4f5a8\'; this.style.borderColor=\'#8bc34a\';" ' +
                      'onmouseout="this.style.background=\'#E5FFCC\'; this.style.borderColor=\'#a3d977\';" ' +
                      'title="Open task details, update status, add notes, record measurements, start new cycle.">' +
                      'Manage' +
                    '</button>' +
                  '</div>';
                })()}
              </td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        // Pagination controls and total count (using filtered data)
        tableHtml += `
          <div style="margin-top: 1rem; display: flex; justify-content: space-between; align-items: center; padding-top: 1rem; border-top: 1px solid #e2e8f0; flex-wrap: wrap; gap: 1rem;">
            <div style="font-size: 0.85rem; color: #64748b;">
              ${filteredTotalPages > 1 ? `Page ${currentPage} of ${filteredTotalPages}  ` : ''}Total URLs: ${filteredRows.length}${filteredRows.length !== sortedRows.length ? ` (filtered from ${sortedRows.length})` : ''}
            </div>
            <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
              <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                Rows per page:
                <select id="money-pages-rows-per-page" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; background: white; cursor: pointer;">
                  <option value="10" ${rowsPerPage === 10 ? 'selected' : ''}>10</option>
                  <option value="25" ${rowsPerPage === 25 ? 'selected' : ''}>25</option>
                  <option value="50" ${rowsPerPage === 50 ? 'selected' : ''}>50</option>
                  <option value="100" ${rowsPerPage === 100 ? 'selected' : ''}>100</option>
                  <option value="200" ${rowsPerPage === 200 ? 'selected' : ''}>200</option>
                </select>
              </label>
              ${filteredTotalPages > 1 ? `
              <button id="money-pages-prev" type="button" ${currentPage === 1 ? 'disabled' : ''} style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cbd5e1; background: ${currentPage === 1 ? '#f1f5f9' : 'white'}; cursor: ${currentPage === 1 ? 'not-allowed' : 'pointer'}; color: ${currentPage === 1 ? '#94a3b8' : '#475569'}; font-weight: 600; transition: all 0.2s;" ${currentPage === 1 ? '' : 'onmouseover="this.style.background=\'#f8f9fa\'; this.style.borderColor=\'#94a3b8\';" onmouseout="this.style.background=\'white\'; this.style.borderColor=\'#cbd5e1\';"'}>
                Previous
              </button>
              <button id="money-pages-next" type="button" ${currentPage === filteredTotalPages ? 'disabled' : ''} style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cbd5e1; background: ${currentPage === filteredTotalPages ? '#f1f5f9' : 'white'}; cursor: ${currentPage === filteredTotalPages ? 'not-allowed' : 'pointer'}; color: ${currentPage === filteredTotalPages ? '#94a3b8' : '#475569'}; font-weight: 600; transition: all 0.2s;" ${currentPage === filteredTotalPages ? '' : 'onmouseover="this.style.background=\'#f8f9fa\'; this.style.borderColor=\'#94a3b8\';" onmouseout="this.style.background=\'white\'; this.style.borderColor=\'#cbd5e1\';"'}>
                Next
              </button>
              ` : ''}
            </div>
          </div>
        `;
        
        return tableHtml;
        } catch (error) {
          debugLog(`Error in renderMoneyPagesTable: ${error.message}`, 'error');
          return '<div style="font-size: 0.85rem; color: #ef4444; padding: 1rem; text-align: center; border: 1px solid #fecaca; border-radius: 4px; background: #fef2f2;">Error rendering table. Please refresh the page.</div>';
        }
      }
      
      // Get filtered money pages metrics based on current filter state
      function getFilteredMoneyPagesMetrics(moneyPagesMetrics) {
        if (!moneyPagesMetrics || !moneyPagesMetrics.rows) {
          return null;
        }
        
        // Get current filter state from global variables
        const subSegmentFilter = window.moneyPagesSubSegmentFilter || 'ALL';
        
        // Filter rows by sub-segment
        let filteredRows = moneyPagesMetrics.rows || [];
        if (subSegmentFilter !== 'ALL') {
          // Map filter values to segment types
          const segmentMap = {
            'PRODUCT': 'product',
            'EVENT': 'event',
            'LANDING': 'landing'
          };
          const targetSegment = segmentMap[subSegmentFilter];
          if (targetSegment) {
            filteredRows = filteredRows.filter(row => {
              // Check subSegment field first, then fallback to segmentType
              const rowSegment = row.subSegment || row.segmentType || 'all';
              return rowSegment.toLowerCase() === targetSegment.toLowerCase();
            });
          }
        }
        
        // Recalculate overview from filtered rows
        const filteredClicks = filteredRows.reduce((sum, r) => sum + (r.clicks || 0), 0);
        const filteredImpressions = filteredRows.reduce((sum, r) => sum + (r.impressions || 0), 0);
        const filteredCtr = filteredImpressions > 0 ? filteredClicks / filteredImpressions : 0;
        const filteredAvgPosition = filteredRows.length > 0
          ? filteredRows.reduce((sum, r) => sum + (r.avgPosition || 0), 0) / filteredRows.length
          : 0;
        
        // Recalculate summaryByCategory from filtered rows
        const filteredSummaryByCategory = {
          HIGH_OPPORTUNITY: { count: 0, impressions: 0, clicks: 0 },
          VISIBILITY_FIX: { count: 0, impressions: 0, clicks: 0 },
          MAINTAIN: { count: 0, impressions: 0, clicks: 0 }
        };
        
        filteredRows.forEach(row => {
          const category = row.category || 'MAINTAIN';
          if (filteredSummaryByCategory[category]) {
            filteredSummaryByCategory[category].count++;
            filteredSummaryByCategory[category].impressions += (row.impressions || 0);
            filteredSummaryByCategory[category].clicks += (row.clicks || 0);
          }
        });
        
        // Build filtered overview
        const originalOverview = moneyPagesMetrics.overview || {};
        const filteredOverview = {
          ...originalOverview,
          moneyClicks: filteredClicks,
          moneyImpressions: filteredImpressions,
          moneyCtr: filteredCtr,
          moneyAvgPosition: filteredAvgPosition,
          moneyCoverageCount: filteredRows.length,
          siteTotalClicks: originalOverview.siteTotalClicks || 0,
          siteTotalImpressions: originalOverview.siteTotalImpressions || 0,
          siteCtr: originalOverview.siteCtr || 0,
          siteAvgPosition: originalOverview.siteAvgPosition || 0
        };
        
        return {
          rows: filteredRows,
          overview: filteredOverview,
          summaryByCategory: filteredSummaryByCategory
        };
      }
      
      // Make function globally available
      window.getFilteredMoneyPagesMetrics = getFilteredMoneyPagesMetrics;
      
      // Update summary metrics with sub-segment filtering
      function updateMoneyPagesSummaryMetrics(moneyPagesMetrics) {
        if (!moneyPagesMetrics) return;
        
        // Use the new function that applies all filters
        const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
        if (!filteredMetrics) return;
        
        const { overview } = filteredMetrics;
        const summaryClickEl = document.getElementById('money-summary-click-share');
        const summaryCtrEl = document.getElementById('money-summary-ctr');
        const summaryPosEl = document.getElementById('money-summary-position');
        const summaryCovEl = document.getElementById('money-summary-coverage');
        
        if (!overview || !summaryClickEl || !summaryCtrEl || !summaryPosEl || !summaryCovEl) {
          return;
        }
        
        const moneyClicks = overview.moneyClicks || 0;
        const moneyImpressions = overview.moneyImpressions || 0;
        const siteClicks = overview.siteTotalClicks || 0;
        const siteImpressions = overview.siteTotalImpressions || 0;
        
        // Summary metrics
        const clickSharePct = siteClicks && siteClicks > 0 ? (moneyClicks / siteClicks) * 100 : null;
        const moneyCtrPct = (overview.moneyCtr || 0) * 100;
        const siteCtrPct = (overview.siteCtr || 0) * 100;
        const moneyPos = overview.moneyAvgPosition;
        const sitePos = overview.siteAvgPosition;
        const coverageCount = overview.moneyCoverageCount || 0;
        
        // Helper for RAG label class
        function labelClass(score) {
          if (score == null) return 'pill pill-muted';
          if (score >= 70) return 'pill pill-success';
          if (score >= 40) return 'pill pill-warning';
          return 'pill pill-danger';
        }
        
        // Update cards
        summaryClickEl.innerHTML =
          `<div class="metric-label">Share of site clicks</div>
           <div class="metric-value">
             ${clickSharePct != null ? clickSharePct.toFixed(1) + '%' : ''}
           </div>
           <div class="metric-sub">
             Money pages clicks: ${moneyClicks.toLocaleString()}
             ${siteClicks ? ` of ${siteClicks.toLocaleString()} total` : ''}
           </div>`;
        
        let ctrScore = null;
        if (siteCtrPct > 0) {
          ctrScore = moneyCtrPct >= siteCtrPct ? 75 : 30;
        }
        summaryCtrEl.innerHTML =
          `<div class="metric-label">CTR vs site</div>
           <div class="metric-value">
             ${moneyCtrPct.toFixed(2)}%
             <span class="metric-sub">vs ${siteCtrPct.toFixed(1)}% site</span>
           </div>`;
        summaryCtrEl.className = 'metric-card ' + labelClass(ctrScore);
        
        let posScore = null;
        if (moneyPos && sitePos) {
          posScore = moneyPos <= sitePos ? 70 : 30;
        }
        summaryPosEl.innerHTML =
          `<div class="metric-label">Average position</div>
           <div class="metric-value">
             ${moneyPos ? moneyPos.toFixed(1) : ''}
             <span class="metric-sub">vs ${sitePos ? sitePos.toFixed(1) : ''} site</span>
           </div>`;
        summaryPosEl.className = 'metric-card ' + labelClass(posScore);
        
        summaryCovEl.innerHTML =
          `<div class="metric-label">Money pages with impressions</div>
           <div class="metric-value">
             ${coverageCount}
           </div>
           <div class="metric-sub">
             Based on GSC pages only
           </div>`;
      }
      
      // Update sub-segment dropdown counts
      function updateMoneyPagesSubSegmentCounts(moneyPagesMetrics) {
        if (!moneyPagesMetrics || !moneyPagesMetrics.rows) return;
        
        const rows = moneyPagesMetrics.rows || [];
        
        // Count by sub-segment
        const counts = {
          ALL: rows.length,
          PRODUCT: 0,
          EVENT: 0,
          LANDING: 0
        };
        
        rows.forEach(row => {
          const subSegment = row.subSegment || row.segmentType || 'LANDING';
          if (subSegment === 'PRODUCT' || subSegment === 'product') {
            counts.PRODUCT++;
          } else if (subSegment === 'EVENT' || subSegment === 'event') {
            counts.EVENT++;
          } else if (subSegment === 'LANDING' || subSegment === 'landing') {
            counts.LANDING++;
          }
        });
        
        // Update dropdown options with counts
        const allOption = document.getElementById('money-subsegment-all');
        const productOption = document.getElementById('money-subsegment-product');
        const eventOption = document.getElementById('money-subsegment-event');
        const landingOption = document.getElementById('money-subsegment-landing');
        
        if (allOption) allOption.textContent = `All sub-segments (${counts.ALL})`;
        if (productOption) productOption.textContent = `Product Pages (${counts.PRODUCT})`;
        if (eventOption) eventOption.textContent = `Event Pages (${counts.EVENT})`;
        if (landingOption) landingOption.textContent = `Landing Pages (${counts.LANDING})`;
      }
      
      // Update type filter dropdown counts (for Priority & Actions)
      function updateMoneyPagesTypeFilterCounts(sourcePages) {
        if (!sourcePages || !Array.isArray(sourcePages)) return;
        
        // Count by segment type
        const counts = {
          all: sourcePages.length,
          authority: 0,
          landing: 0,
          event: 0,
          product: 0
        };
        
        sourcePages.forEach(page => {
          const segmentType = page.segmentType || 'landing';
          if (segmentType === 'authority') {
            counts.authority++;
          } else if (segmentType === 'landing') {
            counts.landing++;
          } else if (segmentType === 'event') {
            counts.event++;
          } else if (segmentType === 'product') {
            counts.product++;
          }
        });
        
        // Update dropdown options with counts
        const typeFilterEl = document.getElementById('money-pages-type-filter');
        if (typeFilterEl) {
          const options = typeFilterEl.querySelectorAll('option');
          options.forEach(opt => {
            const value = opt.value;
            if (value === 'all') {
              opt.textContent = `All money pages (${counts.all})`;
            } else if (value === 'authority') {
              opt.textContent = `Authority (${counts.authority})`;
            } else if (value === 'landing') {
              opt.textContent = `Landing pages (${counts.landing})`;
            } else if (value === 'event') {
              opt.textContent = `Event pages (${counts.event})`;
            } else if (value === 'product') {
              opt.textContent = `Product pages (${counts.product})`;
            }
          });
        }
      }
      
      // Function to render Money Pages Performance section
      async function renderMoneyPagesSection(moneyPagesMetrics) {
        // CRITICAL: Fetch optimisation statuses BEFORE rendering tables to ensure cache is populated
        if (typeof window.fetchOptimisationStatuses === 'function') {
          const allStatusRows = [];
          
          // Add Opportunity table rows
          if (moneyPagesMetrics && moneyPagesMetrics.rows && moneyPagesMetrics.rows.length > 0) {
            moneyPagesMetrics.rows.forEach(row => {
              allStatusRows.push({
                keyword: '', // Empty for page-level tasks
                best_url: row.url,
                targetUrl: row.url,
                ranking_url: row.url
              });
            });
          }
          
          // Add Priority table rows
          if (window.moneyPagePriorityData && window.moneyPagePriorityData.length > 0) {
            window.moneyPagePriorityData.forEach(p => {
              allStatusRows.push({
                keyword: '', // Empty for page-level tasks
                best_url: p.url,
                targetUrl: p.url,
                ranking_url: p.url
              });
            });
          }
          
          if (allStatusRows.length > 0) {
            debugLog(`[Money Pages] Fetching statuses for ${allStatusRows.length} rows before initial render`, 'info');
            try {
              await window.fetchOptimisationStatuses(allStatusRows);
              debugLog(`[Money Pages] Status cache populated: ${window.optimisationStatusCache?.size || 0} entries`, 'success');
            } catch (err) {
              debugLog(`[Money Pages] Error fetching statuses before render: ${err.message}`, 'error');
            }
          }
        }
        
        // Get or create the Money Pages panel
        const moneyPanel = document.querySelector('.aigeo-panel[data-panel="money"]');
        if (!moneyPanel) {
          debugLog(' Money Pages panel not found', 'warn');
          return;
        }
        
        // Get or create the money-pages-section element
        let section = document.getElementById('money-pages-section');
        if (!section) {
          debugLog(' Money Pages section element not found, creating it...', 'warn');
          // Create the Money Pages HTML structure if it doesn't exist
          section = document.createElement('div');
          section.id = 'money-pages-section';
          section.style.display = 'block';
          moneyPanel.appendChild(section);
        }
        
        // Check if full structure already exists (created by displayDashboard)
        const existingHeader = section.querySelector('h3[style*="color: var(--brand-dark)"]');
        if (existingHeader && existingHeader.textContent.includes('Money Pages Performance & Actions')) {
          debugLog(' Money Pages full structure already exists, skipping HTML recreation', 'info');
          // Don't overwrite - just ensure section is visible
          section.style.display = 'block';
        } else {
          // Always update the HTML structure to ensure it has the latest canvas IDs
          // Create the full Money Pages HTML structure with all sections
          section.innerHTML = `
          <div style="padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); background: rgba(204, 255, 229, 0.3); border-left: 4px solid #10b981;">
            <h3 style="margin: 0 0 1rem 0; color: var(--brand-dark);">Money Pages Performance & Actions</h3>
            <p style="margin: 0 0 1.5rem 0; font-size: 0.9rem; color: #666; line-height: 1.6;">
              Focused view of your money pages: how much traffic they capture,
              how they convert clicks, and which URLs to improve first.
              This section uses 30-day Google Search Console data and historical audits to show how your commercial pages perform over time and how much they contribute to your overall Authority behaviour score.
            </p>
            
            <!-- Top-level filter for Performance Metrics, Behaviour, and Opportunity Mix -->
            <div style="display: flex; justify-content: flex-start; align-items: center; margin-bottom: 1.5rem; padding: 1rem 1.25rem; background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%); border-radius: 8px; border: 2px solid #0ea5e9; box-shadow: 0 2px 4px rgba(14, 165, 233, 0.2);">
              <label style="display: flex; align-items: center; gap: 0.75rem; font-size: 0.95rem; color: #0c4a6e; font-weight: 700;" title="Filter Performance Metrics, Behaviour, and Opportunity Mix by sub-segment type">
                <span style="font-weight: 700;">Sub-segment Filter:</span>
                <select id="money-top-level-filter-subsegment" style="padding: 0.6rem 1rem; border: 2px solid #0ea5e9; border-radius: 6px; font-size: 0.95rem; background: white; cursor: pointer; font-weight: 600; color: #0c4a6e; min-width: 150px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);" title="Filter money pages by sub-segment type. Landing pages are collection/category pages, Event pages are workshop/event listings, Product pages are service/product offerings. This filter controls Performance Metrics, Behaviour, and Opportunity Mix sections.">
                  <option value="ALL">All</option>
                  <option value="PRODUCT">Product</option>
                  <option value="EVENT">Event</option>
                  <option value="LANDING">Landing</option>
                </select>
              </label>
            </div>
            
            <!-- Performance Metrics -->
            <div style="margin-bottom: 1.5rem;">
              <h4 style="margin: 0 0 1rem 0; font-size: 0.95rem; font-weight: 600; color: #1e293b;">Performance Metrics</h4>
            </div>
            <div id="money-pages-summary" class="metrics-row" style="display: flex; gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap;">
              <div class="metric-card" id="money-summary-click-share" style="flex: 1; min-width: 200px; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
              <div class="metric-card" id="money-summary-ctr" style="flex: 1; min-width: 200px; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
              <div class="metric-card" id="money-summary-position" style="flex: 1; min-width: 200px; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
              <div class="metric-card" id="money-summary-coverage" style="flex: 1; min-width: 200px; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
            </div>
            
            <!-- Explanation text -->
            <div style="margin-bottom: 1.5rem; padding: 1rem; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #64748b; font-size: 0.85rem; line-height: 1.6; color: #475569;">
              <p style="margin: 0 0 0.5rem 0;"><strong>Note:</strong> These metrics include <strong>all money pages</strong> regardless of ranking position (positions 1-20 and beyond). This provides a complete view of your money page performance, including pages that need improvement.</p>
              <p style="margin: 0;"><strong>Difference from Segment Overview:</strong> The "Segment overview (CTR & ranking)" table above shows metrics for money pages ranking in <strong>positions 1-20 only</strong> (used for Authority scoring). The Money Pages Performance section shows <strong>all money pages</strong> to help identify opportunities across your entire money page portfolio.</p>
            </div>
            
            <!-- Money Pages Behaviour KPIs -->
            <div style="margin-bottom: 1rem;">
              <h3 style="margin: 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Money Pages Behaviour</h3>
            </div>
            <div class="money-behaviour-kpis" id="money-behaviour-kpis" style="display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 1.5rem;">
              <div class="kpi-card" id="money-behaviour-card" style="flex: 1 1 180px; background: #fff; border-radius: 6px; padding: 8px 12px; box-shadow: 0 0 0 1px rgba(0,0,0,0.04);">
                <div class="kpi-label" style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">Money pages behaviour</div>
                <div class="kpi-value" id="money-behaviour-score" style="font-size: 1.5rem; font-weight: 700; color: #1e293b;"></div>
                <div class="kpi-sub" id="money-behaviour-status" style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;">CTR and ranking for money pages only.</div>
              </div>
              <div class="kpi-card" style="flex: 1 1 180px; background: #fff; border-radius: 6px; padding: 8px 12px; box-shadow: 0 0 0 1px rgba(0,0,0,0.04);">
                <div class="kpi-label" style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">CTR (ranking queries)</div>
                <div class="kpi-value" id="money-ctr-value" style="font-size: 1.5rem; font-weight: 700; color: #1e293b;"></div>
                <div class="kpi-sub" style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;">Target 2.5%</div>
              </div>
              <div class="kpi-card" style="flex: 1 1 180px; background: #fff; border-radius: 6px; padding: 8px 12px; box-shadow: 0 0 0 1px rgba(0,0,0,0.04);">
                <div class="kpi-label" style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">Top-10 CTR</div>
                <div class="kpi-value" id="money-top10-ctr-value" style="font-size: 1.5rem; font-weight: 700; color: #1e293b;"></div>
                <div class="kpi-sub" style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;">Target 4.0%</div>
              </div>
            </div>
            <p class="chart-subtitle" style="margin: 0 0 1.5rem 0; font-size: 0.85rem; color: #64748b; padding: 0 0.5rem;">
              Behaviour score here is calculated the same way as <strong>Authority  Behaviour</strong>,
              but only for money pages. Improvements you make on these URLs will move both this score
              and the Authority pillar.
            </p>
            
            <!-- Chart row (Phase 2) -->
            <div class="chart-row" id="money-pages-chart-row" style="margin-bottom: 1.5rem; display: block; visibility: visible;">
              <div class="chart-card" style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: flex; gap: 1.5rem; align-items: flex-start;">
                <div style="flex: 1;">
                  <div style="margin-bottom: 0.5rem;">
                  <h3 id="money-pages-chart-title" style="margin: 0 0 0.5rem 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Money Pages Opportunity Mix</h3>
                  <p class="chart-subtitle" style="margin: 0 0 1rem 0; font-size: 0.85rem; color: #64748b;">
                    How your money pages are distributed across improvement categories in this audit window.
                  </p>
                  </div>
                  <div style="position: relative; width: 500px; height: 300px; margin: 0 auto; overflow: hidden;">
                    <canvas id="money-pages-category-chart" width="500" height="300" style="display: block; max-width: 500px; max-height: 300px;"></canvas>
                  </div>
                  <div id="money-pages-category-summary" class="chart-summary" style="margin-top: 8px; font-size: 0.9rem; color: #1e293b; font-weight: 500; text-align: center;"></div>
                  <div id="money-pages-category-breakdown" class="chart-breakdown-row" style="margin-top: 4px; display: flex; flex-wrap: wrap; gap: 0.5rem; font-size: 0.85rem; justify-content: center;"></div>
                </div>
                <div id="money-pages-chart-summary-box" style="flex: 0 0 320px; background: #f8fafc; padding: 1.5rem; border-radius: 8px; border: 1px solid #e2e8f0; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                  <h4 style="margin: 0 0 1rem 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Filtered Summary</h4>
                  <div style="display: flex; flex-direction: column; gap: 0.75rem; font-size: 0.9rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span style="color: #64748b; font-size: 0.9rem;">Pages:</span>
                      <span id="summary-pages-count" style="font-weight: 700; color: #1e293b; font-size: 1rem;">-</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span style="color: #64748b; font-size: 0.9rem;">Impressions:</span>
                      <span id="summary-impressions" style="font-weight: 700; color: #1e293b; font-size: 1rem;">-</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span style="color: #64748b; font-size: 0.9rem;">Clicks:</span>
                      <span id="summary-clicks" style="font-weight: 700; color: #1e293b; font-size: 1rem;">-</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span style="color: #64748b; font-size: 0.9rem;">CTR:</span>
                      <span id="summary-ctr" style="font-weight: 700; font-size: 1rem;">-</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0.5rem; padding-top: 0.75rem; border-top: 2px solid #e2e8f0;">
                      <span style="color: #64748b; font-size: 0.9rem;">Behaviour Score:</span>
                      <span id="summary-behaviour" style="font-weight: 700; font-size: 1.1rem;">-</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Table container (will be populated by renderMoneyPagesTable) -->
            <div id="money-pages-table-container">
              <!-- Table will be rendered here -->
            </div>
            
            <!-- Phase 3: Money Pages Trend Chart -->
            <section id="money-pages-trend" class="card card--full" style="margin-top: 2rem; background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div class="card-header" style="margin-bottom: 1rem;">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Money Pages Performance Trends (last 28 days)</h3>
                <p class="card-subtitle" style="margin: 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
                  Weekly trends calculated from actual Google Search Console data for the last 28 days. Shows money pages clicks, impressions, CTR, and behaviour score over time.
                </p>
              </div>
              <div class="card-body" style="min-height: 300px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                  <div>
                    <h4 style="font-size: 0.95rem; font-weight: 600; color: #1e293b; margin-bottom: 0.5rem;">Volume Metrics</h4>
                    <div style="position: relative; height: 300px;">
                      <canvas id="moneyPagesVolumeChart"></canvas>
                    </div>
                  </div>
                  <div>
                    <h4 style="font-size: 0.95rem; font-weight: 600; color: #1e293b; margin-bottom: 0.5rem;">Rate & Score Metrics</h4>
                    <div style="position: relative; height: 300px;">
                      <canvas id="moneyPagesRateChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              <div class="card-footer small" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e2e8f0; font-size: 0.85rem; color: #64748b;">
                Data calculated from Google Search Console timeseries for the last 28 days, displayed as 8 weekly data points. Metrics are calculated using money page proportions from the latest audit.
              </div>
            </section>
            
            <!-- Phase: 12-Month KPI Tracker -->
            <section id="money-pages-kpi-card" class="card card--full" style="margin-top: 2rem; background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div class="card-header" style="margin-bottom: 1rem;">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Money Pages KPI Tracker (last 28 days)</h3>
                <p class="card-subtitle" style="margin: 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
                  Weekly KPI trends by money-page segment (All, Landing, Event, Product) calculated from actual Google Search Console data for the last 28 days.
                </p>
              </div>

              <div class="controls-row" style="margin-bottom: 1.5rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem;" title="Select which metric to display in the KPI tracker chart and table. CTR shows click-through rate, Impressions shows search visibility, Clicks shows actual traffic, and Avg position shows average ranking.">
                  Metric:
                  <select id="money-kpi-metric-select" style="padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px;" title="Select which metric to display in the KPI tracker chart and table. CTR shows click-through rate, Impressions shows search visibility, Clicks shows actual traffic, and Avg position shows average ranking.">
                    <option value="ctr">CTR</option>
                    <option value="impressions">Impressions</option>
                    <option value="clicks">Clicks</option>
                    <option value="avgPosition">Avg position</option>
                  </select>
                </label>
              </div>

              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                <div class="sparkline-wrapper" style="height: 400px; width: 100%;">
                  <canvas id="money-kpi-sparkline" style="width: 100% !important;"></canvas>
                </div>

                <div class="table-wrapper" style="overflow-x: auto; max-width: 100%; width: 100%;">
                  <table id="money-kpi-table" style="width: max-content; min-width: 100%; border-collapse: collapse; table-layout: fixed;">
                    <thead>
                      <tr id="money-kpi-header-row" style="background: #f1f5f9;">
                        <!-- Filled by JS -->
                      </tr>
                    </thead>
                    <tbody>
                      <!-- JS rows -->
                    </tbody>
                  </table>
                </div>
              </div>
            </section>
            
            <!-- Phase: Money Pages Priority Matrix + Action List -->
            <section id="money-pages-priority-card" class="card card--full" style="margin-top: 2rem; background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div class="card-header" style="margin-bottom: 1rem;">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Money Pages  Priority & Actions</h3>
                <p class="card-subtitle" style="margin: 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
                  Landing, event and product pages that drive revenue. Triaged by impact, difficulty and priority.
                </p>
              </div>

              <!-- Summary strip -->
              <div class="summary-strip" id="money-pages-summary-strip" style="display: flex; gap: 2rem; padding: 1rem; background: #f8fafc; border-radius: 4px; margin-bottom: 1.5rem;">
                <!-- Filled by JS -->
              </div>

              <!-- Controls -->
              <div class="controls-row" style="display: flex; gap: 1.5rem; margin-bottom: 1.5rem; align-items: center;">
                <label style="display: flex; align-items: center; gap: 0.5rem;" title="Filter money pages by segment type. Landing pages are collection/category pages, Event pages are workshop/event listings, Product pages are service/product offerings.">
                  Page type:
                  <select id="money-pages-type-filter" style="padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px;" title="Filter money pages by segment type. Landing pages are collection/category pages, Event pages are workshop/event listings, Product pages are service/product offerings.">
                    <option value="all" id="money-pages-type-all">All money pages</option>
                    <option value="authority" id="money-pages-type-authority">Authority</option>
                    <option value="landing" id="money-pages-type-landing">Landing pages</option>
                    <option value="event" id="money-pages-type-event">Event pages</option>
                    <option value="product" id="money-pages-type-product">Product pages</option>
                  </select>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem;" title="Filter out pages with fewer impressions than this threshold. Helps focus on pages with meaningful search visibility.">
                  Min impressions:
                  <input type="number" id="money-pages-min-impr" value="0" min="0" step="10" style="padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px; width: 120px;" title="Filter out pages with fewer impressions than this threshold. Helps focus on pages with meaningful search visibility.">
                </label>
              </div>

              <div class="matrix-and-table" style="display: grid; grid-template-columns: 1fr 2fr; gap: 2rem;">
                <div class="priority-matrix" id="money-pages-matrix" style="background: #f8fafc; padding: 1rem; border-radius: 8px;">
                  <!-- 3x3 grid rendered by JS -->
                </div>

                <div class="priority-table-wrapper" style="overflow-x: auto;">
                  <table id="money-pages-priority-table" style="width: 100%; border-collapse: collapse;">
                    <thead>
                      <tr style="background: #f1f5f9;">
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="The URL or page title of the money page. Click to open in a new tab.">Keyword or Page</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Segment type: Landing (collection/category pages), Event (workshop/event listings), or Product (service/product offerings).">Type</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Priority level (HIGH/MEDIUM/LOW) based on impact and difficulty. HIGH priority = high impact + low/medium difficulty. Click column header to sort.">Priority</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Impact level based on lost clicks (expected CTR minus actual CTR). HIGH = significant opportunity to improve clicks. Click column header to sort.">Impact</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Difficulty level based on current ranking position and schema effort required. LOW = easy to improve, HIGH = requires more work. Click column header to sort.">Difficulty</th>
                        <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;" title="Click-through rate: percentage of impressions that resulted in clicks. Higher is better. Click column header to sort.">CTR</th>
                        <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;" title="Total impressions: number of times this page appeared in search results. Click column header to sort.">Impr.</th>
                        <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;" title="Average position: average ranking position in search results (1 = best, lower numbers are better). Click column header to sort.">Avg pos.</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Recommended action based on priority level. HIGH = Fix CTR & strengthen content, MEDIUM = Improve SERP snippet & schema, LOW = Monitor & maintain.">Action</th>
                      </tr>
                    </thead>
                    <tbody>
                      <!-- JS rows -->
                    </tbody>
                  </table>
                  <div id="money-pages-priority-pagination"></div>
                  <button id="money-pages-copy-urls-btn" type="button" class="btn btn-small" style="margin-top: 1rem;" title="Copy all filtered page URLs to clipboard. URLs are copied one per line, ready to paste into spreadsheets or other tools.">Copy URLs</button>
                </div>
              </div>
            </section>
            
            <!-- Phase 4: Suggested (Top 10) Priority Pages -->
            <section id="money-pages-suggested-top10" class="card card--full" style="margin-top: 2rem; background: #f0f9ff; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border: 1px solid #0ea5e9;">
              <div class="card-header" style="margin-bottom: 1rem;">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #0c4a6e;">Suggested (Top 10)</h3>
                <p class="card-subtitle" style="margin: 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
                  Top priority pages ranked by impact and difficulty. Click "Create Task" to start optimization tracking.
                </p>
              </div>
              
              <div id="money-pages-suggested-top10-content" style="min-height: 200px;">
                <!-- Filled by JavaScript -->
                <div style="padding: 2rem; text-align: center; color: #64748b; font-size: 0.9rem;">
                  Loading suggested pages...
                </div>
              </div>
            </section>
            
            <p class="card-footnote" style="margin-top: 1rem; font-size: 0.85rem; color: #666;">
              Based on the current audit date range and money-page segment only.
              Categories and actions are data-driven and will update each time you run a new audit.
            </p>
          </div>
        `;
        }
          
        debugLog(' Money Pages section HTML structure created/updated', 'success');
        
        // Add Create Tasks button to Priority & Actions header if not already present
        const priorityCard = document.getElementById('money-pages-priority-card');
        if (priorityCard) {
          const cardHeader = priorityCard.querySelector('.card-header');
          if (cardHeader && !document.getElementById('money-pages-create-tasks-btn')) {
            // Check if header already has flex layout
            if (!cardHeader.style.display || cardHeader.style.display !== 'flex') {
              cardHeader.style.display = 'flex';
              cardHeader.style.justifyContent = 'space-between';
              cardHeader.style.alignItems = 'flex-start';
            }
            
            // Wrap existing content in a div
            const existingContent = Array.from(cardHeader.childNodes);
            const contentWrapper = document.createElement('div');
            contentWrapper.style.flex = '1';
            existingContent.forEach(node => {
              if (node.nodeType === Node.ELEMENT_NODE || node.nodeType === Node.TEXT_NODE) {
                contentWrapper.appendChild(node.cloneNode(true));
              }
            });
            cardHeader.innerHTML = '';
            cardHeader.appendChild(contentWrapper);
            
            // Add bulk create button (secondary/advanced)
            const createBtn = document.createElement('button');
            createBtn.id = 'money-pages-create-tasks-btn';
            createBtn.type = 'button';
            createBtn.className = 'btn btn-secondary';
            createBtn.textContent = 'Bulk create';
            createBtn.title = ' BULK OPERATION: Creates optimisation tasks for ALL money pages (CTR  2.5%). This will create hundreds of tasks. Use row-level Track buttons for individual pages instead.';
            createBtn.style.cssText = 'margin-left: 1rem; padding: 0.5rem 1rem; background: #f59e0b; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; white-space: nowrap; font-size: 0.875rem;';
            cardHeader.appendChild(createBtn);
            
            // Wire up button
            wireMoneyPagesCreateTasksButton();
          } else if (document.getElementById('money-pages-create-tasks-btn')) {
            // Button exists, just wire it up
            wireMoneyPagesCreateTasksButton();
          }
        }
        
        // Always show section, even if no data (will show "No data" message)
        section.style.display = 'block';
        
        if (!moneyPagesMetrics) {
          debugLog(' Money Pages Metrics: No data provided', 'warn');
          // Show "No data" message in table and summary cards
          const tableContainer = document.getElementById('money-pages-table-container');
          if (tableContainer) {
            tableContainer.innerHTML = '<div style="font-size: 0.85rem; color: #999; padding: 2rem; text-align: center;">No money-page data available. Run an audit with GSC data to see money pages performance.</div>';
          }
          // Populate summary cards with ""
          const summaryClickEl = document.getElementById('money-summary-click-share');
          const summaryCtrEl = document.getElementById('money-summary-ctr');
          const summaryPosEl = document.getElementById('money-summary-position');
          const summaryCovEl = document.getElementById('money-summary-coverage');
          if (summaryClickEl) summaryClickEl.innerHTML = `<div class="metric-label">Share of site clicks</div><div class="metric-value"></div><div class="metric-sub">No data</div>`;
          if (summaryCtrEl) summaryCtrEl.innerHTML = `<div class="metric-label">CTR vs site</div><div class="metric-value"></div><div class="metric-sub">No data</div>`;
          if (summaryPosEl) summaryPosEl.innerHTML = `<div class="metric-label">Average position</div><div class="metric-value"></div><div class="metric-sub">No data</div>`;
          if (summaryCovEl) summaryCovEl.innerHTML = `<div class="metric-label">Money pages with impressions</div><div class="metric-value">0</div><div class="metric-sub">No data</div>`;
          return;
        }
        
        const { rows } = moneyPagesMetrics;
        const tableContainer = document.getElementById('money-pages-table-container');
        
        if (!tableContainer) {
          return;
        }
        
        // Store data globally for sorting/pagination
        // Ensure we're using the most up-to-date metrics
        window.currentMoneyPagesMetrics = moneyPagesMetrics || window.currentMoneyPagesMetrics;
        
        // Initialize pagination state if not set
        if (window.moneyPagesCurrentPage === undefined) {
          window.moneyPagesCurrentPage = 1;
        }
        if (window.moneyPagesRowsPerPage === undefined) {
          window.moneyPagesRowsPerPage = 10;
        }
        
        // Store full rows array for filtering
        window.moneyPagesAllRows = rows;
        
        // Initialize filter state if not set
        if (window.moneyPagesCategoryFilter === undefined) {
          window.moneyPagesCategoryFilter = 'ALL';
        }
        if (window.moneyPagesSubSegmentFilter === undefined) {
          window.moneyPagesSubSegmentFilter = 'ALL';
        }
        
        // Update summary metrics with current filters
        updateMoneyPagesSummaryMetrics(moneyPagesMetrics);
        if (window.moneyPagesMinImpressions === undefined) {
          window.moneyPagesMinImpressions = 0;
        }
        
        // Update sub-segment dropdown counts
        updateMoneyPagesSubSegmentCounts(moneyPagesMetrics);
        
        // Phase 4: Render Suggested (Top 10) table (delay to ensure DOM is ready)
        // Use moneyPagePriorityData if available (same data as Priority & Actions table), otherwise use rows
        // Wait for the section to be fully rendered before calling the function
        const renderSuggestedTop10 = () => {
          const container = document.getElementById('money-pages-suggested-top10-content');
          if (!container) {
            console.warn('[Money Pages] Container not found yet, retrying...');
            setTimeout(renderSuggestedTop10, 200);
            return;
          }
          
          const dataSource = window.moneyPagePriorityData && window.moneyPagePriorityData.length > 0 
            ? window.moneyPagePriorityData 
            : rows;
          console.log('[Money Pages] Rendering Suggested Top 10 with data source:', {
            hasPriorityData: !!window.moneyPagePriorityData,
            priorityDataCount: window.moneyPagePriorityData?.length || 0,
            rowsCount: rows?.length || 0,
            usingDataSource: dataSource === window.moneyPagePriorityData ? 'moneyPagePriorityData' : 'rows',
            hasFunction: typeof window.renderMoneyPagesSuggestedTop10 === 'function',
            functionType: typeof window.renderMoneyPagesSuggestedTop10,
            containerFound: !!container
          });
          if (typeof window.renderMoneyPagesSuggestedTop10 === 'function') {
            window.renderMoneyPagesSuggestedTop10(dataSource);
          } else {
            console.error('[Money Pages] renderMoneyPagesSuggestedTop10 function not found. Available on window:', {
              hasFunction: typeof window.renderMoneyPagesSuggestedTop10,
              windowKeys: Object.keys(window).filter(k => k.includes('Money') || k.includes('render'))
            });
          }
        };
        
        // Start checking after a short delay
        setTimeout(renderSuggestedTop10, 500);
        
        // Function to apply filters and re-render ALL sections (table, chart, KPIs, summaries)
        const applyFiltersAndRender = async () => {
          const moneyPagesMetrics = window.currentMoneyPagesMetrics;
          const queryPages = window.currentQueryPages || null;
          
          if (!moneyPagesMetrics) return;
          
          // Get filtered metrics based on current filters FIRST
          const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
          if (!filteredMetrics) return;
          
          const filteredRows = filteredMetrics.rows || [];
          
          // Update table with FILTERED rows
          const currentPage = window.moneyPagesCurrentPage || 1;
          const rowsPerPage = window.moneyPagesRowsPerPage || 10;
          const tableHtml = await renderMoneyPagesTable(filteredRows, currentPage, rowsPerPage);
          if (tableHtml && typeof tableHtml === 'string' && tableHtml.trim().length > 0) {
            tableContainer.innerHTML = tableHtml;
          } else {
            debugLog(` renderMoneyPagesTable returned invalid value: ${typeof tableHtml}, length: ${tableHtml?.length || 0}`, 'warn');
            tableContainer.innerHTML = '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">Error rendering table. Please refresh the page.</div>';
          }
          
          // Re-attach all handlers after re-render
          // Use filtered rows for pagination/copy, but use original rows for filter handlers
          // (filter handlers need the full dataset to filter from)
          attachMoneyPagesSortHandlers();
          attachMoneyPagesPaginationHandlers(filteredRows);
          attachMoneyPagesCopyHandler(filteredRows);
          attachMoneyPagesFilterHandlers(rows, applyFiltersAndRender);
          
          // Wire up Create Tasks button if it exists
          if (typeof wireMoneyPagesCreateTasksButton === 'function') {
            wireMoneyPagesCreateTasksButton();
          }
          
          // Update all other sections with filtered data
          setTimeout(() => {
            // Update doughnut chart with filtered data
            renderMoneyPagesCategoryChart(moneyPagesMetrics, 0);
            
            // Recalculate behaviour for filtered pages
            debugLog(` Filter change: Recalculating behaviour for ${filteredRows.length} filtered rows`, 'info');
            debugLog(` Filter change: queryPages available: ${!!queryPages}, length: ${queryPages?.length || 0}`, 'info');
            
            const filteredBehaviour = window.computeMoneyPagesBehaviour ? 
              window.computeMoneyPagesBehaviour(queryPages, filteredRows, true) : null;
            
            debugLog(` Filter change: filteredBehaviour calculated: ${!!filteredBehaviour}, impressions: ${filteredBehaviour?.impressions || 0}`, 'info');
            
          // Update all sections
          renderMoneyPagesBehaviourKpis(filteredBehaviour, filteredMetrics, queryPages);
          updateMoneyPagesSummaryMetrics(moneyPagesMetrics); // Pass original metrics so function can apply filters internally
          updateMoneyPagesChartSummary(filteredMetrics);
          
          // Update dropdown counts after filtering (both table and top-level)
          updateMoneyPagesSubSegmentCounts(moneyPagesMetrics);
          }, 100);
        };
        
        // CRITICAL: Fetch optimisation statuses for ALL rows before initial render
        // This ensures the cache is populated on page load/refresh
        if (typeof window.fetchOptimisationStatuses === 'function' && rows.length > 0) {
          console.log('[Money Pages] Fetching optimisation statuses for all rows on page load...', rows.length);
          const allStatusRows = rows.map(row => ({
            keyword: '', // Empty for page-level tasks
            best_url: row.url,
            targetUrl: row.url,
            ranking_url: row.url
          }));
          await window.fetchOptimisationStatuses(allStatusRows);
          console.log('[Money Pages]  Status cache populated on page load:', window.optimisationStatusCache?.size || 0, 'entries');
        }
        
        // Initial render
        const currentPage = window.moneyPagesCurrentPage || 1;
        const rowsPerPage = window.moneyPagesRowsPerPage || 10;
        const tableHtml = await renderMoneyPagesTable(rows, currentPage, rowsPerPage);
        if (tableHtml && typeof tableHtml === 'string' && tableHtml.trim().length > 0) {
          tableContainer.innerHTML = tableHtml;
        } else {
          debugLog(` renderMoneyPagesTable returned invalid value: ${typeof tableHtml}, length: ${tableHtml?.length || 0}`, 'warn');
          tableContainer.innerHTML = '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">Error rendering table. Please refresh the page.</div>';
        }
        
        // Attach sort handlers
        attachMoneyPagesSortHandlers();
        
        // Attach pagination handlers
        attachMoneyPagesPaginationHandlers(rows);
        
        // Attach copy button handler
        attachMoneyPagesCopyHandler(rows);
        
        // Attach filter handlers (Phase 2)
        attachMoneyPagesFilterHandlers(rows, applyFiltersAndRender);
        
        // Show section
        section.style.display = 'block';
      }
      
      // Attach sort handlers for Money Pages table
      function attachMoneyPagesSortHandlers() {
        setTimeout(() => {
          ['clicks', 'impressions', 'ctr', 'position', 'opportunity'].forEach(col => {
            const th = document.getElementById(`money-sort-${col}`);
            if (th) {
              const newTh = th.cloneNode(true);
              th.parentNode.replaceChild(newTh, th);
              newTh.addEventListener('click', () => {
                handleMoneyPagesSort(col);
              });
            }
          });
        }, 50);
      }
      
      // Handle sorting for Money Pages table
      async function handleMoneyPagesSort(column) {
        if (window.moneyPagesSortColumn === column) {
          window.moneyPagesSortDirection = window.moneyPagesSortDirection === 'asc' ? 'desc' : 'asc';
        } else {
          window.moneyPagesSortColumn = column;
          window.moneyPagesSortDirection = 'desc';
        }
        
        // Reset to page 1 when sorting
        window.moneyPagesCurrentPage = 1;
        
        // Get current data from stored source
        const allRows = window.moneyPagesData || [];
        if (allRows.length > 0) {
          const tableContainer = document.getElementById('money-pages-table-container');
          if (tableContainer) {
            const rowsPerPage = window.moneyPagesRowsPerPage || 10;
            tableContainer.innerHTML = await renderMoneyPagesTable(allRows, 1, rowsPerPage);
            attachMoneyPagesSortHandlers();
            attachMoneyPagesPaginationHandlers(allRows);
            attachMoneyPagesCopyHandler(allRows);
          }
        }
      }
      
      // Attach pagination handlers
      function attachMoneyPagesPaginationHandlers(allRows) {
        setTimeout(() => {
          const prevBtn = document.getElementById('money-pages-prev');
          const nextBtn = document.getElementById('money-pages-next');
          const rowsPerPageSelect = document.getElementById('money-pages-rows-per-page');
          
          // Use stored sorted data for pagination
          const sortedRows = window.moneyPagesData || allRows || [];
          const rowsPerPage = window.moneyPagesRowsPerPage || 10;
          
          // Handle rows-per-page change
          if (rowsPerPageSelect) {
            const newSelect = rowsPerPageSelect.cloneNode(true);
            rowsPerPageSelect.parentNode.replaceChild(newSelect, rowsPerPageSelect);
            newSelect.addEventListener('change', async () => {
              const newRowsPerPage = parseInt(newSelect.value, 10);
              window.moneyPagesRowsPerPage = newRowsPerPage;
              window.moneyPagesCurrentPage = 1; // Reset to first page when changing rows per page
              const tableContainer = document.getElementById('money-pages-table-container');
              if (tableContainer) {
                tableContainer.innerHTML = await renderMoneyPagesTable(sortedRows, 1, newRowsPerPage);
                attachMoneyPagesSortHandlers();
                attachMoneyPagesPaginationHandlers(sortedRows);
                attachMoneyPagesCopyHandler(sortedRows);
              }
            });
          }
          
          if (prevBtn) {
            const newPrevBtn = prevBtn.cloneNode(true);
            prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
              newPrevBtn.addEventListener('click', async () => {
              if (window.moneyPagesCurrentPage > 1) {
                window.moneyPagesCurrentPage--;
                const tableContainer = document.getElementById('money-pages-table-container');
                if (tableContainer) {
                  const currentRowsPerPage = window.moneyPagesRowsPerPage || 10;
                  tableContainer.innerHTML = await renderMoneyPagesTable(sortedRows, window.moneyPagesCurrentPage, currentRowsPerPage);
                  attachMoneyPagesSortHandlers();
                  attachMoneyPagesPaginationHandlers(sortedRows);
                  attachMoneyPagesCopyHandler(sortedRows);
                }
              }
            });
          }
          
          if (nextBtn) {
            const newNextBtn = nextBtn.cloneNode(true);
            nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
            newNextBtn.addEventListener('click', async () => {
              const currentRowsPerPage = window.moneyPagesRowsPerPage || 10;
              const totalPages = Math.ceil(sortedRows.length / currentRowsPerPage);
              if (window.moneyPagesCurrentPage < totalPages) {
                window.moneyPagesCurrentPage++;
                const tableContainer = document.getElementById('money-pages-table-container');
                if (tableContainer) {
                  tableContainer.innerHTML = await renderMoneyPagesTable(sortedRows, window.moneyPagesCurrentPage, currentRowsPerPage);
                  attachMoneyPagesSortHandlers();
                  attachMoneyPagesPaginationHandlers(sortedRows);
                  attachMoneyPagesCopyHandler(sortedRows);
                }
              }
            });
          }
        }, 50);
      }
      
      // Attach copy button handler
      function attachMoneyPagesCopyHandler(allRows) {
        setTimeout(() => {
          const copyBtn = document.getElementById('money-pages-copy-urls');
          if (copyBtn) {
            const newCopyBtn = copyBtn.cloneNode(true);
            copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
            newCopyBtn.addEventListener('click', async () => {
              const urls = (allRows || []).slice(0, 10).map((r) => r.url).join('\n');
              if (urls) {
                try {
                  await navigator.clipboard.writeText(urls);
                  newCopyBtn.textContent = 'Copied!';
                  newCopyBtn.style.color = '#10b981';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                    newCopyBtn.style.color = 'white';
                  }, 2000);
                } catch (err) {
                  newCopyBtn.textContent = 'Copy failed';
                  newCopyBtn.style.color = '#ef4444';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                    newCopyBtn.style.color = 'white';
                  }, 2000);
                }
              }
            });
          }
        }, 50);
      }
      
      // Attach filter handlers for Money Pages table (Phase 2)
      function attachMoneyPagesFilterHandlers(allRows, onFilterChange) {
        setTimeout(() => {
          const categoryFilterEl = document.getElementById('money-pages-filter-category');
          const subSegmentFilterEl = document.getElementById('money-pages-filter-subsegment');
          const minImpressionsEl = document.getElementById('money-pages-min-impressions');
          const copyBtn = document.getElementById('money-pages-copy-urls');
          const tableContainer = document.getElementById('money-pages-table-container');
          
          if (!categoryFilterEl || !subSegmentFilterEl || !minImpressionsEl || !tableContainer) return;
          
          // Get zero impressions checkbox
          const includeZeroEl = document.getElementById('money-pages-include-zero');
          
          // Function to apply filters and re-render
          const applyFilters = async () => {
            // Re-read checkbox state from DOM (it might have changed)
            const currentIncludeZeroEl = document.getElementById('money-pages-include-zero');
            const filterCat = categoryFilterEl.value || 'ALL';
            const filterSubSeg = subSegmentFilterEl.value || 'ALL';
            const minImp = parseInt(minImpressionsEl.value, 10) || 0;
            const includeZero = currentIncludeZeroEl ? currentIncludeZeroEl.checked : (includeZeroEl ? includeZeroEl.checked : true);
            
            debugLog(` applyFilters: includeZero=${includeZero}, filterCat=${filterCat}, filterSubSeg=${filterSubSeg}, minImp=${minImp}`, 'info');
            
            // Store filter state globally
            window.moneyPagesCategoryFilter = filterCat;
            window.moneyPagesSubSegmentFilter = filterSubSeg;
            window.moneyPagesMinImpressions = minImp;
            window.moneyPagesIncludeZero = includeZero;
            
            // Reset to page 1 when filters change
            window.moneyPagesCurrentPage = 1;
            
            // Re-render everything with filters (table, chart, KPIs, summary)
            if (onFilterChange) {
              await onFilterChange();
            } else {
              // Fallback: re-render directly with filtered data
              const moneyPagesMetrics = window.currentMoneyPagesMetrics;
              const queryPages = window.currentQueryPages || null;
              
              if (!moneyPagesMetrics) return;
              
              // Get filtered metrics FIRST
              const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
              if (!filteredMetrics) return;
              
              const filteredRows = filteredMetrics.rows || [];
              
              // Update table with FILTERED rows
              const currentPage = 1;
              const rowsPerPage = window.moneyPagesRowsPerPage || 10;
              tableContainer.innerHTML = await renderMoneyPagesTable(filteredRows, currentPage, rowsPerPage);
              attachMoneyPagesSortHandlers();
              attachMoneyPagesPaginationHandlers(filteredRows);
              attachMoneyPagesCopyHandler(filteredRows);
              // Use original allRows for filter handlers (they need full dataset to filter from)
              // Get original rows from moneyPagesMetrics
              const originalRows = moneyPagesMetrics?.rows || allRows;
              attachMoneyPagesFilterHandlers(originalRows, onFilterChange);
              
              // Re-render chart and KPIs with filters
              setTimeout(() => {
                // Get queryPages from global storage
                const queryPages = window.currentQueryPages || null;
                
                debugLog(` Fallback filter change: Recalculating behaviour for ${filteredRows.length} filtered rows`, 'info');
                debugLog(` Fallback filter change: queryPages available: ${!!queryPages}, length: ${queryPages?.length || 0}`, 'info');
                
                // Update doughnut chart with filtered data
                renderMoneyPagesCategoryChart(moneyPagesMetrics, 0);
                
                // Recalculate behaviour for filtered pages (use all positions for filtered calculations)
                const filteredBehaviour = window.computeMoneyPagesBehaviour ? 
                  window.computeMoneyPagesBehaviour(queryPages, filteredRows, true) : null;
                
                debugLog(` Fallback filter change: filteredBehaviour calculated: ${!!filteredBehaviour}, impressions: ${filteredBehaviour?.impressions || 0}`, 'info');
                
                // Update all sections
                renderMoneyPagesBehaviourKpis(filteredBehaviour, filteredMetrics, queryPages);
                updateMoneyPagesSummaryMetrics(moneyPagesMetrics); // Pass original metrics so function can apply filters internally
                updateMoneyPagesChartSummary(filteredMetrics);
                
                // Update dropdown counts after filtering
                updateMoneyPagesSubSegmentCounts(moneyPagesMetrics);
              }, 100);
            }
          };
          
          // Attach filter change handlers
          categoryFilterEl.addEventListener('change', applyFilters);
          subSegmentFilterEl.addEventListener('change', applyFilters);
          minImpressionsEl.addEventListener('change', applyFilters);
          if (includeZeroEl) {
            includeZeroEl.addEventListener('change', applyFilters);
          }
          
          // When table filter changes, update top-level filter (if user changes table filter directly)
          subSegmentFilterEl.addEventListener('change', () => {
            const value = subSegmentFilterEl.value;
            const topLevelFilterEl = document.getElementById('money-top-level-filter-subsegment');
            if (topLevelFilterEl && topLevelFilterEl.value !== value) {
              topLevelFilterEl.value = value;
              window.moneyPagesSubSegmentFilter = value;
            }
            // Update summary metrics when filter changes
            const moneyPagesMetrics = window.currentMoneyPagesMetrics || window.moneyPagesMetrics;
            if (moneyPagesMetrics && typeof updateMoneyPagesSummaryMetrics === 'function') {
              updateMoneyPagesSummaryMetrics(moneyPagesMetrics);
            }
          });
          
          // Update copy button to use filtered data
          if (copyBtn) {
            const newCopyBtn = copyBtn.cloneNode(true);
            copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
            newCopyBtn.addEventListener('click', async () => {
              const filterCat = categoryFilterEl.value || 'ALL';
              const filterSubSeg = subSegmentFilterEl.value || 'ALL';
              const minImp = parseInt(minImpressionsEl.value, 10) || 0;
              const includeZero = includeZeroEl ? includeZeroEl.checked : true;
              
              const filtered = (allRows || []).filter(row => {
                const matchCat = filterCat === 'ALL' || row.category === filterCat;
                const matchSubSeg = filterSubSeg === 'ALL' || row.subSegment === filterSubSeg;
                const matchImp = (row.impressions || 0) >= minImp;
                const matchZero = includeZero || (row.impressions || 0) > 0;
                return matchCat && matchSubSeg && matchImp && matchZero;
              });
              
              const urls = filtered.map(r => r.url).join('\n');
              if (urls) {
                try {
                  await navigator.clipboard.writeText(urls);
                  newCopyBtn.textContent = 'Copied!';
                  newCopyBtn.style.color = '#10b981';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy current URLs';
                    newCopyBtn.style.color = 'white';
                  }, 2000);
                } catch (err) {
                  newCopyBtn.textContent = 'Copy failed';
                  newCopyBtn.style.color = '#ef4444';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy current URLs';
                    newCopyBtn.style.color = 'white';
                  }, 2000);
                }
              }
            });
          }
        }, 50);
        
        // Wire up Create Tasks button after rendering completes
        setTimeout(() => {
          if (typeof wireMoneyPagesCreateTasksButton === 'function') {
            wireMoneyPagesCreateTasksButton();
          }
        }, 100);
      }
      
      // Make renderMoneyPagesSection globally available
      window.renderMoneyPagesSection = renderMoneyPagesSection;
      
      // ========================================
      // Money Pages  Create Optimisation Tasks Feature
      // ========================================
      
      // Step 2: Fetch all Money Pages segment (ignores current UI filters)
      // Returns array of rows with: url, page_type, ctr, impressions, clicks, avg_position
      async function fetchMoneyPagesSegmentAll() {
        // Money Pages data is stored in window.moneyPagesMetrics or from localStorage/Supabase
        // Get the raw data source (before any filtering)
        let moneyPagesData = null;
        
        // Try window.moneyPagesMetrics first (if already loaded)
        if (window.moneyPagesMetrics && window.moneyPagesMetrics.rows) {
          moneyPagesData = window.moneyPagesMetrics;
        } else {
          // Try localStorage
          const savedAudit = localStorage.getItem('aigeo_audit_data');
          if (savedAudit) {
            try {
              const parsed = JSON.parse(savedAudit);
              moneyPagesData = parsed.scores?.moneyPagesMetrics || parsed.moneyPagesMetrics || null;
            } catch (e) {
              console.error('[Money Pages Tasks] Error parsing localStorage:', e);
            }
          }
        }
        
        if (!moneyPagesData || !moneyPagesData.rows || moneyPagesData.rows.length === 0) {
          console.warn('[Money Pages Tasks] No money pages data available');
          return [];
        }
        
        // Return all rows (ignoring filters)
        return moneyPagesData.rows.map(row => ({
          url: row.url || row.page_url || '',
          page_type: row.page_type || row.type || '',
          ctr: row.ctr || row.ctr_28d || null,
          impressions: row.impressions || row.impressions_28d || null,
          clicks: row.clicks || row.clicks_28d || null,
          avg_position: row.avg_position || row.position || null,
          page_title: row.page_title || row.title || row.slug || null
        }));
      }
      
      // Step 4: Fetch existing optimisation task URLs for de-dupe
      async function fetchExistingOptimizationTaskUrls() {
        try {
          const adminKey = window.getAdminKey ? window.getAdminKey() : (sessionStorage.getItem('arp_admin_key') || localStorage.getItem('arp_admin_key') || '');
          if (!adminKey) {
            throw new Error('Admin key required');
          }
          
          const response = await fetch('/api/optimisation/tasks', {
            headers: {
              'x-arp-admin-key': adminKey
            }
          });
          
          if (!response.ok) {
            throw new Error(`Failed to fetch tasks: ${response.statusText}`);
          }
          
          const data = await response.json();
          const tasks = data.tasks || [];
          
          // Normalize URLs and return as Set
          const urlSet = new Set();
          for (const task of tasks) {
            if (task.target_url) {
              const normalized = normalizeUrlForDedupe(task.target_url);
              urlSet.add(normalized);
            }
          }
          
          return urlSet;
        } catch (error) {
          console.error('[Money Pages Tasks] Error fetching existing tasks:', error);
          return new Set(); // Return empty set on error
        }
      }
      
      // Normalize URL for de-dupe matching (reusable helper)
      function normalizeUrlForDedupe(url) {
        if (!url) return '';
        
        let normalized = url.trim();
        
        // Ensure leading https://www.alanranger.com if stored as path
        if (normalized.startsWith('/')) {
          normalized = 'https://www.alanranger.com' + normalized;
        } else if (!normalized.startsWith('http')) {
          normalized = 'https://www.alanranger.com/' + normalized;
        }
        
        // Remove trailing slash (except root)
        if (normalized.endsWith('/') && normalized !== 'https://www.alanranger.com/') {
          normalized = normalized.slice(0, -1);
        }
        
        // Lowercase hostname only (keep path case as-is)
        try {
          const urlObj = new URL(normalized);
          normalized = urlObj.origin.toLowerCase() + urlObj.pathname + urlObj.search + urlObj.hash;
        } catch (e) {
          // If URL parsing fails, just lowercase the whole thing
          normalized = normalized.toLowerCase();
        }
        
        return normalized;
      }
      
      // Normalize GSC page URL for page key matching (dedicated helper for page-level totals)
      // This avoids mismatches caused by full URL vs path-only, trailing slashes, query strings/fragments
      function normalizeGscPageKey(inputUrl) {
        if (!inputUrl) return "";

        let u = ("" + inputUrl).trim();

        // Accept path-only
        if (u.startsWith("/")) u = "https://www.alanranger.com" + u;
        else if (!u.startsWith("http")) u = "https://www.alanranger.com/" + u.replace(/^\/+/, "");

        try {
          const urlObj = new URL(u);
          let path = urlObj.pathname || "/";
          // remove trailing slash (except root)
          if (path.length > 1) path = path.replace(/\/+$/, "");
          return urlObj.origin.toLowerCase() + path;
        } catch {
          // fallback: best-effort normalise
          return u.toLowerCase().replace(/\/+$/, "");
        }
      }
      
      // Get task identity key for Money Page (reusable helper)
      function getMoneyPageTaskKey(pageUrl) {
        return normalizeUrlForDedupe(pageUrl);
      }
      
      // Find existing optimisation task for URL (reusable helper)
      function findExistingOptimisationTaskForUrl(tasks, pageUrl) {
        if (!tasks || !Array.isArray(tasks)) return null;
        const normalizedUrl = normalizeUrlForDedupe(pageUrl);
        return tasks.find(task => {
          if (!task.target_url) return false;
          return normalizeUrlForDedupe(task.target_url) === normalizedUrl;
        }) || null;
      }
      
      // Make helper functions globally available (reusable by Ranking & AI and Money Pages)
      window.getMoneyPageTaskKey = getMoneyPageTaskKey;
      window.findExistingOptimisationTaskForUrl = findExistingOptimisationTaskForUrl;
      window.normalizeUrlForDedupe = normalizeUrlForDedupe;
      window.normalizeGscPageKey = normalizeGscPageKey;
      
      // Create optimisation task for URL (reusable helper - used by both Money Pages and Ranking & AI)
      async function createOptimisationTaskForUrl(pageUrl, pageTitle, source = 'money_pages') {
        const adminKey = window.getAdminKey ? window.getAdminKey() : (sessionStorage.getItem('arp_admin_key') || localStorage.getItem('arp_admin_key') || '');
        if (!adminKey) {
          throw new Error('Admin key required');
        }
        
        const normalizedUrl = normalizeUrlForDedupe(pageUrl);
        const title = pageTitle || normalizedUrl;
        
        // Build task payload
        const taskPayload = {
          keyword_text: normalizedUrl, // API requires non-empty, use URL as placeholder for page-level tasks
          target_url: normalizedUrl,
          task_type: 'on_page',
          status: 'planned',
          title: source === 'money_pages' ? `MP: ${title}` : title,
          source: source,
          is_test: false
        };
        
        // Create task
        const taskResponse = await fetch('/api/optimisation/task', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-arp-admin-key': adminKey
          },
          body: JSON.stringify(taskPayload)
        });
        
        if (!taskResponse.ok) {
          const errorText = await taskResponse.text();
          throw new Error(`Failed to create task: ${errorText}`);
        }
        
        const taskData = await taskResponse.json();
        const taskId = taskData.task?.id || taskData.id;
        
        if (!taskId) {
          throw new Error('Task created but no ID returned');
        }
        
        // Create Cycle 1 with absolute CTR objective (2.5% = 0.025 ratio)
        await createCycleWithAbsoluteCtrObjective(taskId, adminKey);
        
        return taskData;
      }
      
      // Make createOptimisationTaskForUrl globally available
      window.createOptimisationTaskForUrl = createOptimisationTaskForUrl;
      
      // Open Track Money Page Modal (reuses Ranking & AI modal pattern)
      window.openTrackMoneyPageModal = function openTrackMoneyPageModal(row) {
        const modal = document.getElementById('optimisation-track-modal');
        if (!modal) {
          console.error('[Money Pages] Track modal not found');
          alert('Track modal not found. Please refresh the page.');
          return;
        }

        // Get and clean URL
        const rawUrl = row.url || '';
        const cleanedUrl = window.cleanUrlForDisplay ? window.cleanUrlForDisplay(rawUrl) : rawUrl;
        
        // For Money Pages, keyword is empty (page-level task)
        document.getElementById('track-keyword-text').textContent = '(Page-level task)';
        
        // Make URL clickable in Track modal
        const trackUrlContainer = document.getElementById('track-url-text');
        trackUrlContainer.innerHTML = '';
        if (cleanedUrl) {
          let fullUrl = cleanedUrl;
          if (!fullUrl.startsWith('http://') && !fullUrl.startsWith('https://')) {
            fullUrl = 'https://' + fullUrl;
          }
          const urlLink = document.createElement('a');
          urlLink.href = fullUrl;
          urlLink.target = '_blank';
          urlLink.rel = 'noopener noreferrer';
          urlLink.textContent = cleanedUrl;
          urlLink.style.color = '#0284c7';
          urlLink.style.textDecoration = 'none';
          urlLink.style.fontWeight = '600';
          urlLink.style.wordBreak = 'break-all';
          urlLink.addEventListener('mouseenter', () => {
            urlLink.style.textDecoration = 'underline';
          });
          urlLink.addEventListener('mouseleave', () => {
            urlLink.style.textDecoration = 'none';
          });
          trackUrlContainer.appendChild(urlLink);
        } else {
          trackUrlContainer.textContent = 'No URL available';
        }
        
        // Set task type to on_page
        document.getElementById('track-task-type').value = 'on_page';
        document.getElementById('track-status').value = 'planned';
        
        // Prefill title
        const pageTitle = row.title || cleanedUrl;
        document.getElementById('track-title').value = `MP: ${pageTitle}`;
        document.getElementById('track-notes').value = '';
        
        // Prefill objective for Money Pages (CTR  2.5%)
        document.getElementById('track-objective-title').value = 'CTR  2.5%';
        document.getElementById('track-primary-kpi').value = 'ctr_28d';
        document.getElementById('track-target-direction').value = 'at_least';
        document.getElementById('track-target-value').value = '2.5';
        document.getElementById('track-timeframe-days').value = '';
        document.getElementById('track-plan').value = 'Created from Money Pages segment (CTR target:  2.5%).';
        
        // Store row data for baseline metrics (needed in submitTrackKeyword)
        modal.dataset.rowKeyword = ''; // Empty for page-level tasks
        modal.dataset.rowUrl = cleanedUrl;
        modal.dataset.taskType = 'on_page';
        modal.dataset.source = 'money_pages';
        modal.dataset.rowData = JSON.stringify(row);
        
        // Update modal title and subtitle to indicate Money Pages
        const modalTitle = modal.querySelector('h3');
        if (modalTitle) {
          modalTitle.textContent = 'Create optimisation task';
          // Add subtitle if it doesn't exist
          let subtitle = modal.querySelector('#money-pages-modal-subtitle');
          if (!subtitle) {
            subtitle = document.createElement('div');
            subtitle.id = 'money-pages-modal-subtitle';
            subtitle.style.cssText = 'margin: -0.5rem 0 1rem 0; font-size: 0.875rem; color: #64748b; font-weight: 400;';
            modalTitle.insertAdjacentElement('afterend', subtitle);
          }
          subtitle.textContent = 'Money Pages  CTR target (absolute):  2.5%';
        }
        
        // Add baseline preview section if it doesn't exist
        let baselinePreview = modal.querySelector('#money-pages-baseline-preview');
        if (!baselinePreview) {
          baselinePreview = document.createElement('div');
          baselinePreview.id = 'money-pages-baseline-preview';
          baselinePreview.style.cssText = 'margin-bottom: 1.5rem; padding: 1rem; background: #fef3c7; border-radius: 4px; border: 1px solid #fbbf24;';
          const objectiveSection = modal.querySelector('#track-objective-title').closest('div').parentElement;
          objectiveSection.insertAdjacentElement('beforebegin', baselinePreview);
        }
        
        // Populate baseline preview
        // Debug: Log row data to see what we have
        console.log('[Money Pages Modal] Row data for baseline:', {
          clicks: row.clicks,
          impressions: row.impressions,
          ctr: row.ctr,
          avgPosition: row.avgPosition,
          position: row.position,
          url: row.url
        });
        
        const ctrPct = (row.ctr || 0) * 100;
        const clicks = row.clicks || row.clicks_28d || 0;
        const impressions = row.impressions || row.impressions_28d || 0;
        const ctr = row.ctr != null ? row.ctr : (row.ctr_28d || 0);
        const position = row.avgPosition != null ? row.avgPosition : (row.position || row.position_28d || null);
        
        baselinePreview.innerHTML = `
          <div style="font-weight: 600; color: #92400e; margin-bottom: 0.5rem; font-size: 0.875rem;">Baseline that will be captured on create:</div>
          <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.75rem; font-size: 0.875rem; color: #78350f;">
            <div><strong>Clicks (28d):</strong> ${clicks.toLocaleString()}</div>
            <div><strong>Impressions (28d):</strong> ${impressions.toLocaleString()}</div>
            <div><strong>CTR (28d):</strong> ${(ctr * 100).toFixed(2)}%</div>
            <div><strong>Avg position (28d):</strong> ${position ? position.toFixed(1) : 'N/A'}</div>
          </div>
        `;
        
        modal.style.display = 'flex';
      };
      
      // Track Money Page - per-row function (opens modal instead of auto-creating)
      window.trackMoneyPage = function(pageUrl, pageTitle) {
   