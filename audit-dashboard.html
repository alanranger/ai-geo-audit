<!DOCTYPE html>
<!-- Cache-busting: 2026-01-13T23:45:00Z - CRITICAL: Fixed all toFixed() calls with proper type checks, fixed template literal issues -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>GAIO (Generative AI Optimization) Audit Dashboard - Automated GAIO Performance Tracking</title>

  <script>
    // Diagnostic build marker (helps correlate UI with deployment)
    // Get current deployment's commit hash - fetched dynamically from Vercel API or env
    // Function to update version pill with retry logic
    async function updateVersionPill(retryCount = 0) {
      const maxRetries = 3;
      const retryDelay = 1000; // 1 second
      
      try {
        // Try to get current commit hash from API endpoint (if available)
        const response = await fetch('/api/git/previous-commit', {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        if (response.ok) {
          const data = await response.json();
          window.__GAIO_DIAG_BUILD__ = data.commitHash || 'unknown';
          console.log('[Version Pill] Loaded from API:', data.commitHash, 'source:', data.source);
          
          // Update build date with deployment timestamp if available
          if (data.deploymentTimestamp) {
            try {
              const deploymentDate = new Date(data.deploymentTimestamp);
              if (!isNaN(deploymentDate.getTime())) {
                const gmtDate = deploymentDate.toISOString().split('T')[0]; // YYYY-MM-DD
                const gmtTime = deploymentDate.toISOString().split('T')[1].split('.')[0]; // HH:MM:SS
                const buildDateEl = document.getElementById('buildDate');
                if (buildDateEl) {
                  buildDateEl.textContent = gmtDate + ' ' + gmtTime + ' GMT';
                  console.log('[Version Pill] Updated build date from deployment timestamp:', gmtDate + ' ' + gmtTime + ' GMT');
                }
              }
            } catch (dateError) {
              console.warn('[Version Pill] Error parsing deployment timestamp:', dateError);
            }
          }
        } else {
          // If API returns error, retry if we haven't exceeded max retries
          if (retryCount < maxRetries) {
            console.log(`[Version Pill] API returned ${response.status}, retrying in ${retryDelay}ms... (attempt ${retryCount + 1}/${maxRetries})`);
            setTimeout(() => updateVersionPill(retryCount + 1), retryDelay);
            return;
          }
          // Fallback: show unknown if API fails
          window.__GAIO_DIAG_BUILD__ = 'unknown';
          console.log('[Version Pill] API failed after retries, using fallback:', window.__GAIO_DIAG_BUILD__);
          // Set build date to current time as fallback (better than showing "Loading...")
          const buildDateEl = document.getElementById('buildDate');
          if (buildDateEl && buildDateEl.textContent === 'Loading...') {
            const now = new Date();
            const gmtDate = now.toISOString().split('T')[0];
            const gmtTime = now.toISOString().split('T')[1].split('.')[0];
            buildDateEl.textContent = gmtDate + ' ' + gmtTime + ' GMT (approx)';
          }
        }
      } catch (e) {
        // If fetch fails, retry if we haven't exceeded max retries
        if (retryCount < maxRetries) {
          console.log(`[Version Pill] Fetch error: ${e.message}, retrying in ${retryDelay}ms... (attempt ${retryCount + 1}/${maxRetries})`);
          setTimeout(() => updateVersionPill(retryCount + 1), retryDelay);
          return;
        }
        // Fallback: show unknown if all retries fail
        window.__GAIO_DIAG_BUILD__ = 'unknown';
        console.warn('[Version Pill] Error fetching from API after retries:', e.message, 'using fallback:', window.__GAIO_DIAG_BUILD__);
        // Set build date to current time as fallback
        const buildDateEl = document.getElementById('buildDate');
        if (buildDateEl && buildDateEl.textContent === 'Loading...') {
          const now = new Date();
          const gmtDate = now.toISOString().split('T')[0];
          const gmtTime = now.toISOString().split('T')[1].split('.')[0];
          buildDateEl.textContent = gmtDate + ' ' + gmtTime + ' GMT (approx)';
        }
      }
      
      // Update the version pill element
      const verEl = document.getElementById('gitVersion');
      if (verEl) {
        verEl.textContent = window.__GAIO_DIAG_BUILD__ || 'unknown';
        console.log('[DIAG-LINECHECK] build=', window.__GAIO_DIAG_BUILD__, 'src=', location.href);
      } else if (document.readyState === 'loading') {
        // If element doesn't exist yet, wait for DOM
        document.addEventListener('DOMContentLoaded', () => {
          const verEl = document.getElementById('gitVersion');
          if (verEl) verEl.textContent = window.__GAIO_DIAG_BUILD__ || 'unknown';
        });
      }
    }
    
    // Log build id once the debug logger exists
    if (window.__BUILD_ID__) {
      window.debugLog(`[Build] ${window.__BUILD_ID__}`, 'info');
    }
    
    // Update version pill - will retry if it fails
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => updateVersionPill());
    } else {
      updateVersionPill();
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script>
    // CRITICAL: Set up error capture IMMEDIATELY, before any other code runs
    // This must be the very first script to execute
    (function() {
      'use strict';
      
      // Initialize error storage arrays immediately
      window._capturedErrors = window._capturedErrors || [];
      window._capturedWarnings = window._capturedWarnings || [];
      
      // Store original console methods globally so debugLog can use them
      window._originalConsoleError = console.error;
      window._originalConsoleWarn = console.warn;
      const originalConsoleError = window._originalConsoleError;
      const originalConsoleWarn = window._originalConsoleWarn;
      
      // Flag to prevent infinite recursion
      let isCapturingError = false;
      let isCapturingWarn = false;
      
      // Override console.error IMMEDIATELY
      console.error = function(...args) {
        // Prevent infinite recursion
        if (isCapturingError) {
          // If we're already capturing, just use original console.error
          originalConsoleError.apply(console, args);
          return;
        }
        
        isCapturingError = true;
        try {
          // Call original first
          originalConsoleError.apply(console, args);
          
          // Capture error immediately
          const errorMessage = args.map(arg => {
            if (arg instanceof Error) {
              return `${arg.message}\n${arg.stack || ''}`;
            }
            return String(arg);
          }).join(' ');
          
          const errorEntry = {
            timestamp: new Date().toISOString(),
            message: `[CONSOLE ERROR] ${errorMessage}`,
            type: 'error',
            args: args.map(a => String(a))
          };
          window._capturedErrors.push(errorEntry);
          
          // Persist to localStorage so errors don't disappear on refresh
          try {
            const stored = JSON.parse(localStorage.getItem('_capturedErrors') || '[]');
            stored.push(errorEntry);
            // Keep only last 100 errors to avoid quota issues
            if (stored.length > 100) stored.shift();
            localStorage.setItem('_capturedErrors', JSON.stringify(stored));
          } catch (e) {
            // Ignore localStorage errors
          }
          
          // Try to log to debugLog if available (will be set up later)
          // CRITICAL: Use originalConsoleError to avoid recursion
          if (typeof window.debugLog === 'function') {
            try {
              // Temporarily restore original to prevent recursion
              const tempError = console.error;
              console.error = originalConsoleError;
              window.debugLog(errorEntry.message, 'error');
              console.error = tempError;
            } catch (e) {
              // Ignore if debugLog fails
            }
          }
        } finally {
          isCapturingError = false;
        }
      };
      
      // Override console.warn IMMEDIATELY
      console.warn = function(...args) {
        // Prevent infinite recursion
        if (isCapturingWarn) {
          originalConsoleWarn.apply(console, args);
          return;
        }
        
        isCapturingWarn = true;
        try {
          originalConsoleWarn.apply(console, args);
          
          const warnMessage = args.map(arg => String(arg)).join(' ');
          const warnEntry = {
            timestamp: new Date().toISOString(),
            message: `[CONSOLE WARN] ${warnMessage}`,
            type: 'warn',
            args: args.map(a => String(a))
          };
          window._capturedWarnings.push(warnEntry);
          
          if (typeof window.debugLog === 'function') {
            try {
              // Use original console methods to prevent recursion
              const tempWarn = console.warn;
              console.warn = originalConsoleWarn;
              window.debugLog(warnEntry.message, 'warn');
              console.warn = tempWarn;
            } catch (e) {
              // Ignore
            }
          }
        } finally {
          isCapturingWarn = false;
        }
      };
      
      // Global error handler - set up immediately
      window.addEventListener('error', function(event) {
        const errorMsg = `[UNCAUGHT ERROR] ${event.message} at ${event.filename}:${event.lineno}:${event.colno}`;
        const fullError = event.error && event.error.stack 
          ? `${errorMsg}\nStack: ${event.error.stack}`
          : errorMsg;
        
        const errorEntry = {
          timestamp: new Date().toISOString(),
          message: fullError,
          type: 'error',
          filename: event.filename,
          lineno: event.lineno,
          colno: event.colno,
          error: event.error ? event.error.message : null
        };
        window._capturedErrors.push(errorEntry);
        
        // Persist to localStorage so errors don't disappear on refresh
        try {
          const stored = JSON.parse(localStorage.getItem('_capturedErrors') || '[]');
          stored.push(errorEntry);
          // Keep only last 100 errors to avoid quota issues
          if (stored.length > 100) stored.shift();
          localStorage.setItem('_capturedErrors', JSON.stringify(stored));
        } catch (e) {
          // Ignore localStorage errors
        }
        
        if (typeof window.debugLog === 'function') {
          try {
            window.debugLog(fullError, 'error');
          } catch (e) {
            // Ignore
          }
        }
      }, true);
      
      // Unhandled promise rejection handler - set up immediately
      window.addEventListener('unhandledrejection', function(event) {
        const reason = event.reason;
        let errorMsg = '[UNHANDLED PROMISE REJECTION] ';
        if (reason instanceof Error) {
          errorMsg += `${reason.message}\nStack: ${reason.stack || ''}`;
        } else {
          errorMsg += String(reason);
        }
        
        const errorEntry = {
          timestamp: new Date().toISOString(),
          message: errorMsg,
          type: 'error',
          reason: reason instanceof Error ? reason.message : String(reason)
        };
        window._capturedErrors.push(errorEntry);
        
        // Persist to localStorage so errors don't disappear on refresh
        try {
          const stored = JSON.parse(localStorage.getItem('_capturedErrors') || '[]');
          stored.push(errorEntry);
          // Keep only last 100 errors to avoid quota issues
          if (stored.length > 100) stored.shift();
          localStorage.setItem('_capturedErrors', JSON.stringify(stored));
        } catch (e) {
          // Ignore localStorage errors
        }
        
        if (typeof window.debugLog === 'function') {
          try {
            window.debugLog(errorMsg, 'error');
          } catch (e) {
            // Ignore
          }
        }
      }, true);
      
      if (window.DEBUG_LOG_TO_CONSOLE === true) {
        console.log('[Error Capture] Global error handlers installed immediately');
      }
      
      // Restore errors from localStorage only when explicitly enabled (avoids stale logs)
      try {
        const restoreDebugErrors = localStorage.getItem('_restore_debug_errors') === 'true';
        if (!restoreDebugErrors) {
          localStorage.removeItem('_capturedErrors');
          localStorage.removeItem('_capturedWarnings');
        } else {
          const stored = JSON.parse(localStorage.getItem('_capturedErrors') || '[]');
          if (stored.length > 0) {
            window._capturedErrors = stored;
            if (window.DEBUG_LOG_TO_CONSOLE === true) {
              console.log(`[Error Capture] Restored ${stored.length} errors from localStorage`);
            }
          }
        }
      } catch (e) {
        // Ignore parse errors
      }
    })();
    
    // Try to load config.js if it exists (for local development)
    // Note: config.js is gitignored and won't be deployed to Vercel
    // Silently fail if config.js doesn't exist (expected on Vercel)
    try {
      // First check if file exists via fetch to avoid syntax errors
      fetch('config.js')
        .then(response => {
          if (response.ok && response.headers.get('content-type') && response.headers.get('content-type').includes('javascript')) {
      const configScript = document.createElement('script');
      configScript.src = 'config.js';
            configScript.type = 'text/javascript';
      configScript.onerror = function() {
              // Silently ignore
      };
      document.head.appendChild(configScript);
          }
        })
        .catch(() => {
          // Silently ignore - config.js is optional
        });
    } catch (e) {
      // Silently ignore - config.js is optional
    }
  </script>
  <style>
    :root {
      --brand-orange: #E57200;
      --brand-dark: #222222;
      --brand-grey: #555555;
      --bg-page: #f2f2f2;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      
      /* Dark theme variables (from admin.html) */
      --dark-bg: #0f1419;
      --dark-panel: #1a1f2e;
      --dark-text: #e2e8f0;
      --dark-text-muted: #9ca3af;
      --dark-brand: #f59e0b;
      --dark-border: #374151;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg-page);
      color: var(--brand-dark);
      line-height: 1.5;
    }
    .header {
      background: linear-gradient(135deg, var(--brand-orange) 0%, #ff8c42 100%);
      color: white;
      padding: 2rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .header h1 {
      margin: 0 0 0.5rem 0;
      font-size: 2rem;
    }
    .header p {
      margin: 0;
      opacity: 0.9;
    }
    .container {
      max-width: 1800px;
      margin: 0 auto;
      padding: 2rem;
      padding-bottom: 60px; /* Space for debug panel */
    }
    .config-panel {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      margin-bottom: 2rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .config-panel h2 {
      margin: 0 0 1rem 0;
      color: var(--brand-dark);
      font-size: 1.25rem;
    }
    .form-group {
      margin-bottom: 1rem;
    }
    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      color: var(--brand-grey);
    }
    .form-group input {
      width: 100%;
      padding: 0.75rem;
      border: 2px solid #e2e8f0;
      border-radius: 6px;
      font-size: 1rem;
    }
    .form-group input:focus {
      outline: none;
      border-color: var(--brand-orange);
    }
    .btn {
      background: var(--brand-orange);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    .btn:hover {
      background: #d46200;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    .btn-secondary {
      background: var(--brand-grey);
    }
    .btn-secondary:hover {
      background: #444;
    }
    .status {
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      display: none;
    }
    .status.success {
      background: #d1fae5;
      color: #065f46;
      border-left: 4px solid var(--success);
    }
    .status.error {
      background: #fee2e2;
      color: #991b1b;
      border-left: 4px solid var(--danger);
    }
    .status.info {
      background: #dbeafe;
      color: #1e40af;
      border-left: 4px solid #3b82f6;
    }
    .status.show {
      display: block;
    }
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    .pillar-card {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: relative;
      display: flex;
      flex-direction: column;
      min-height: 100%; /* Ensure all cards have same minimum height */
    }
    .pillar-card h3 {
      margin: 0 0 0.75rem 0;
      color: var(--brand-dark);
      font-size: 1.1rem;
    }
    .pillar-score {
      font-size: 3rem;
      font-weight: 700;
      margin: 0.5rem 0;
      line-height: 1;
    }
    .pillar-score.rag-red {
      color: var(--danger);
    }
    .pillar-score.rag-amber {
      color: var(--warning);
    }
    .pillar-score.rag-green {
      color: var(--success);
    }
    .rag-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.875rem;
      font-weight: 600;
      margin-top: 0.75rem;
      margin-bottom: 0.5rem;
    }
    .rag-badge.red {
      background: #fee2e2;
      color: #991b1b;
    }
    .rag-badge.amber {
      background: #fef3c7;
      color: #92400e;
    }
    .rag-badge.green {
      background: #d1fae5;
      color: #065f46;
    }
    .chart-container {
      background: linear-gradient(135deg, #f0f4f8 0%, #e2e8f0 100%);
      padding: 1.5rem;
      padding-bottom: 12rem; /* Extra padding at bottom for rotated 45-degree axis labels - need significant space for diagonal labels */
      padding-right: 3rem; /* Extra padding on right for Y-axis labels */
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 6rem; /* extra breathing room below charts */
      height: 1000px; /* Doubled from 500px to 1000px for better chart visibility and less bunching */
      min-height: 1000px; /* Ensure minimum height */
      border: 1px solid rgba(100, 116, 139, 0.2);
      overflow: hidden; /* Change to hidden to clip content that extends beyond container */
    }
    .chart-container.large {
      height: 1200px;
      min-height: 1200px;
      padding: 2rem;
    }
    .dashboard-two-column {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-three-column {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-four-column {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    @media (max-width: 1200px) {
      .dashboard-four-column {
        grid-template-columns: repeat(2, 1fr);
      }
      .dashboard-three-column {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    @media (max-width: 768px) {
      .dashboard-two-column,
      .dashboard-three-column,
      .dashboard-four-column {
        grid-template-columns: 1fr;
      }
    }
    .chart-container h3 {
      margin: 0 0 0.5rem 0;
      color: var(--brand-dark);
    }
    .chart-container p {
      margin: 0 0 1rem 0;
    }
    .trend-summary-row {
      display: flex;
      gap: 1.5rem;
      font-size: 0.9rem;
      margin-bottom: 0.75rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .trend-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.7);
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.06);
      border: 1px solid rgba(148, 163, 184, 0.3);
    }
    .trend-pill span.label {
      font-weight: 600;
      color: #374151;
    }
    .trend-pill span.value.up {
      font-weight: 700;
      color: #10b981; /* green */
    }
    .trend-pill span.value.down {
      font-weight: 700;
      color: #ef4444; /* red */
    }
    .trend-pill span.value.neutral {
      font-weight: 700;
      color: #1f2937; /* black/dark gray for no change */
    }
    .metrics-section {
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border: 1px solid rgba(59, 130, 246, 0.1);
    }
    .scorecard-section {
      margin-top: 4rem;  /* push scorecard further below charts */
      margin-bottom: 3rem;
    }
    
    /* Override for scorecard sections inside ranking-ai-detail-content */
    .ranking-ai-detail-content .scorecard-section {
      margin-top: 0;
      margin-bottom: 1.0rem !important;
    }
    
    .ranking-ai-detail-content .scorecard-section:last-child {
      margin-bottom: 0 !important;
    }
    .scorecard-section h3 {
      margin-bottom: 1.5rem;
    }
    .metrics-section {
      margin-top: 3rem;
      margin-bottom: 3rem;
    }
    .metrics-section h3 {
      margin-bottom: 1.5rem;
    }
    .section-break {
      margin-top: 4rem;
      margin-bottom: 4rem;
      border-top: 2px solid #e2e8f0;
      padding-top: 2rem;
    }
    .calculation-explanation {
      background: #f8f9fa;
      border: 2px solid var(--brand-orange);
      border-radius: 8px;
      margin-bottom: 2rem;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(229, 114, 0, 0.15);
    }
    .calculation-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: linear-gradient(135deg, #fff5f0 0%, #ffe8d6 100%);
      border-bottom: 2px solid var(--brand-orange);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    .calculation-explanation.collapsed .calculation-header {
      border-bottom: none;
    }
    .calculation-header:hover {
      background: linear-gradient(135deg, #ffe8d6 0%, #ffd9b3 100%);
    }
    .calculation-header h4 {
      margin: 0;
      color: var(--brand-orange);
      font-size: 1.1rem;
      font-weight: 600;
    }
    .calculation-toggle {
      font-size: 1.2rem;
      color: var(--brand-orange);
      font-weight: bold;
      transition: transform 0.3s;
    }
    .calculation-explanation.collapsed .calculation-toggle {
      transform: rotate(-90deg);
    }
    .calculation-content {
      padding: 1.5rem;
      color: #555;
      line-height: 1.8;
    }
    .calculation-content.collapsed {
      display: none;
    }
    .csv-upload-section {
      background: #f8f9fa;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      margin-bottom: 1rem;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .csv-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: #f8f9fa;
      border-bottom: 2px solid #e2e8f0;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    .csv-upload-section.collapsed .csv-section-header {
      border-bottom: none;
    }
    .csv-section-header:hover {
      background: #f0f0f0;
    }
    .csv-section-header h3 {
      margin: 0;
      color: #1e293b;
      font-size: 1rem;
      font-weight: 600;
    }
    .csv-section-toggle {
      font-size: 1rem;
      color: #64748b;
      font-weight: bold;
      transition: transform 0.3s;
    }
    .csv-upload-section.collapsed .csv-section-toggle {
      transform: rotate(-90deg);
    }
    .csv-section-content {
      padding: 1rem;
    }
    .csv-section-content.collapsed {
      display: none;
    }
    .calculation-content h5 {
      color: var(--brand-dark);
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-size: 1rem;
      font-weight: 600;
      border-bottom: 2px solid var(--brand-orange);
      padding-bottom: 0.5rem;
    }
    .calculation-content h5:first-child {
      margin-top: 0;
    }
    .calculation-content ul {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
    }
    .calculation-content li {
      margin: 0.5rem 0;
    }
    .calculation-content code {
      background: #e2e8f0;
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #c53030;
    }
    .calculation-content .formula {
      background: #f0f4f8;
      padding: 0.75rem;
      border-left: 3px solid var(--brand-orange);
      margin: 0.75rem 0;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
    }
    .calculation-content .note {
      background: #fff3cd;
      border-left: 3px solid #f59e0b;
      padding: 0.75rem;
      margin: 1rem 0;
      font-size: 0.9rem;
    }
    .date-range-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .date-range-btn {
      padding: 0.5rem 1rem;
      border: 2px solid #e2e8f0;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    .date-range-btn:hover {
      border-color: var(--brand-orange);
      background: #fff5f0;
    }
    .date-range-btn.active {
      background: var(--brand-orange);
      color: white;
      border-color: var(--brand-orange);
    }
    .snippet-readiness-gauge {
      background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 3rem;
      border: 1px solid rgba(16, 185, 129, 0.1);
    }
    .gauge-container {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      flex: 1;
      position: relative;
    }
    .gauge-wrapper {
      position: relative;
      width: 300px;
      height: 300px;
    }
    .gauge-svg {
      transform: rotate(-90deg);
      width: 100%;
      height: 100%;
    }
    .gauge-background {
      fill: none;
      stroke: #e2e8f0;
      stroke-width: 20;
    }
    .gauge-fill {
      fill: none;
      stroke-width: 20;
      stroke-linecap: round;
      transition: stroke-dashoffset 1s ease-in-out;
    }
    .gauge-fill.green {
      stroke: #10b981;
    }
    .gauge-fill.amber {
      stroke: #f59e0b;
    }
    .gauge-fill.red {
      stroke: #ef4444;
    }
    .gauge-value {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      font-weight: 700;
      text-align: center;
      z-index: 10;
    }
    .gauge-value.green {
      color: #10b981;
    }
    .gauge-value.amber {
      color: #f59e0b;
    }
    .gauge-value.red {
      color: #ef4444;
    }
    .gauge-label {
      text-align: center;
      color: var(--brand-grey);
      margin-top: 1rem;
      font-size: 1rem;
      font-weight: 600;
    }
    .gauge-status {
      text-align: center;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      font-weight: 500;
    }
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }
    .metric-card {
      background: white;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
    }
    .metric-card .value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--brand-orange);
      margin: 0.5rem 0;
    }
    .metric-card .label {
      color: var(--brand-grey);
      font-size: 0.875rem;
    }
    .metric-label {
      color: var(--brand-grey);
      font-size: 0.875rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    .metric-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--brand-orange);
      margin: 0.5rem 0;
    }
    .metric-sub {
      color: var(--brand-grey);
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }
    .url-cell {
      max-width: 300px;
    }
    .url-main {
      font-weight: 600;
      color: #333;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .url-sub {
      font-size: 0.75rem;
      color: #666;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-top: 0.25rem;
    }
    .money-recommendation {
      font-size: 0.875rem;
      line-height: 1.5;
      color: #555;
      max-width: 400px;
    }
    .loading {
      display: none;
      text-align: center;
      padding: 2rem;
    }
    .loading.show {
      display: block;
    }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--brand-orange);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .progress-container {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1rem 0;
    }
    .progress-bar-wrapper {
      width: 100%;
      background: #e2e8f0;
      border-radius: 10px;
      height: 24px;
      overflow: hidden;
      margin: 1rem 0;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--brand-orange), #ff8c42);
      border-radius: 10px;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 0.85rem;
      min-width: 0;
    }
    .progress-status {
      font-size: 0.95rem;
      color: #555;
      margin-top: 0.5rem;
      font-weight: 500;
    }
    /* Full-page overlay for domain strength snapshot */
    .domain-strength-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      z-index: 9999;
      display: none;
      align-items: center;
      justify-content: center;
    }
    .domain-strength-overlay.show {
      display: flex;
    }
    .domain-strength-overlay-content {
      background: white;
      border-radius: 12px;
      padding: 2.5rem 3rem;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      text-align: center;
      max-width: 400px;
    }
    .domain-strength-overlay-content .spinner {
      width: 48px;
      height: 48px;
      border-width: 5px;
      margin: 0 auto 1.5rem;
    }
    .domain-strength-overlay-content h3 {
      margin: 0 0 0.75rem 0;
      font-size: 1.25rem;
      font-weight: 700;
      color: #1e293b;
    }
    .domain-strength-overlay-content p {
      margin: 0;
      font-size: 0.95rem;
      color: #64748b;
      line-height: 1.6;
    }
    /* Sticky positioning for domain strength table */
    #domain-strength-table thead {
      position: sticky;
      top: 0;
      z-index: 10;
      background: #f8fafc;
    }
    #domain-strength-table thead th {
      background: #f8fafc;
    }
    #domain-strength-self-row {
      position: sticky;
      top: 40px; /* Adjust based on header height */
      z-index: 9;
      background: #fefce8 !important;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      overflow: auto;
    }
    .modal-content {
      background-color: white;
      margin: 5% auto;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      animation: modalSlideIn 0.3s ease;
    }
    @keyframes modalSlideIn {
      from {
        transform: translateY(-50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    .ranking-ai-step-item {
      display: flex;
      align-items: center;
      padding: 0.75rem;
      border-radius: 6px;
      background-color: #f9fafb;
      transition: all 0.2s ease;
    }
    .ranking-ai-step-item.active {
      background-color: #fef3c7;
      border-left: 4px solid var(--brand-orange);
    }
    .ranking-ai-step-item.completed {
      background-color: #d1fae5;
      border-left: 4px solid #10b981;
    }
    .ranking-ai-step-item.pending {
      opacity: 0.5;
    }
    .ranking-ai-step-icon {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 0.75rem;
      font-weight: bold;
      font-size: 0.85rem;
    }
    .ranking-ai-step-item.pending .ranking-ai-step-icon {
      background-color: #e5e7eb;
      color: #9ca3af;
    }
    .ranking-ai-step-item.active .ranking-ai-step-icon {
      background-color: var(--brand-orange);
      color: white;
      animation: pulse 1.5s ease-in-out infinite;
    }
    .ranking-ai-step-item.completed .ranking-ai-step-icon {
      background-color: #10b981;
      color: white;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    .ranking-ai-step-label {
      flex: 1;
      font-size: 0.9rem;
      color: #374151;
    }
    .ranking-ai-step-item.completed .ranking-ai-step-label {
      color: #059669;
    }
    .ranking-ai-step-item.active .ranking-ai-step-label {
      color: #92400e;
      font-weight: 600;
    }
    .help-text {
      font-size: 0.875rem;
      color: var(--brand-grey);
      margin-top: 0.25rem;
    }

    .debug-panel-bottom {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1a1a1a;
      border-top: 3px solid #E57200;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      z-index: 1000;
      box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.5);
      max-height: 50vh;
      display: flex;
      flex-direction: column;
    }

    .debug-panel-bottom.collapsed {
      max-height: 50px;
    }

    .debug-panel-bottom.collapsed .debug-content {
      display: none !important;
    }

    .debug-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #333;
      background: #252525;
      user-select: none;
    }

    .debug-header h3 {
      margin: 0;
      color: #fff;
      font-size: 1rem;
    }

    .debug-actions {
      display: flex;
      gap: 0.5rem;
    }

    .btn-small {
      padding: 0.25rem 0.75rem;
      font-size: 0.75rem;
      background: #333;
      color: #fff;
      border: 1px solid #555;
    }

    .btn-small:hover {
      background: #444;
    }

    .debug-content {
      color: #fff;
      line-height: 1.6;
      padding: 1rem;
      overflow-y: auto;
      flex: 1;
      max-height: calc(50vh - 60px);
    }

    .debug-log-entry {
      margin-bottom: 0.25rem;
      padding: 0.25rem 0;
      border-left: 2px solid transparent;
      padding-left: 0.5rem;
    }

    .debug-log-entry.error {
      color: #f44;
      border-left-color: #f44;
    }

    .debug-log-entry.warn {
      color: #fa4;
      border-left-color: #fa4;
    }

    .debug-log-entry.info {
      color: #9cf;
      border-left-color: #4af;
    }

    .debug-log-entry.success {
      color: #9f9;
      border-left-color: #4f4;
    }

    .debug-timestamp {
      color: #aaa;
      margin-right: 0.5rem;
    }

    /* Sidebar Layout */
    .aigeo-layout {
      display: flex;
      min-height: calc(100vh - 120px); /* Account for header */
    }

    .aigeo-sidebar {
      width: 260px;
      background: linear-gradient(180deg, #ffffff 0%, #f8f9fa 100%);
      border-right: 2px solid #e2e8f0;
      padding: 1.5rem 0;
      position: sticky;
      top: 0;
      height: calc(100vh - 120px);
      overflow-y: auto;
      flex-shrink: 0;
      box-shadow: 2px 0 8px rgba(0,0,0,0.05);
    }

    .aigeo-nav-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      width: 100%;
      padding: 0.875rem 1.5rem;
      background: none;
      border: none;
      text-align: left;
      font-size: 0.95rem;
      font-weight: 500;
      color: #64748b;
      cursor: pointer;
      transition: all 0.2s ease;
      border-left: 4px solid transparent;
      position: relative;
    }

    .aigeo-nav-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0;
      background: var(--brand-orange);
      transition: width 0.2s ease;
    }

    .aigeo-nav-item:hover {
      background: linear-gradient(90deg, #fff5f0 0%, #ffffff 100%);
      color: var(--brand-dark);
      padding-left: 1.75rem;
    }

    .aigeo-nav-item.is-active {
      background: linear-gradient(90deg, #fff5f0 0%, #ffffff 100%);
      color: var(--brand-orange);
      border-left-color: var(--brand-orange);
      font-weight: 600;
      box-shadow: inset 0 0 0 1px rgba(229, 114, 0, 0.1);
    }

    .aigeo-nav-item.is-active::before {
      width: 4px;
    }

    .aigeo-nav-icon {
      font-size: 1.25rem;
      width: 24px;
      text-align: center;
      flex-shrink: 0;
    }

    .aigeo-main {
      flex: 1;
      overflow-y: auto;
      padding: 2rem;
      padding-bottom: 60px; /* Space for debug panel */
    }

    .aigeo-panel {
      display: none;
    }

    .aigeo-panel.is-active {
      display: block;
    }

    /* Ensure ranking panel uses block layout when active, not flex */
    .aigeo-panel[data-panel="ranking"].is-active {
      display: block !important;
    }

    /* Ensure ranking panel children stack vertically, but allow metric pills, side-by-side cards, and details grid to use their layouts */
    .aigeo-panel[data-panel="ranking"] > .ranking-metric-pills {
      display: grid !important;
    }

    .aigeo-panel[data-panel="ranking"] > .ranking-details-grid {
      display: grid !important;
    }

    .aigeo-panel[data-panel="ranking"] > .ranking-cards-side-by-side {
      display: flex !important;
    }

    .aigeo-panel[data-panel="ranking"] > *:not(.ranking-metric-pills):not(.ranking-cards-side-by-side):not(.ranking-priority-matrix-section):not(.ranking-table-section):not(.ranking-details-grid) {
      width: 100% !important;
      display: block !important;
      clear: both !important;
      float: none !important;
    }

    /* Ranking & AI Tab Styles */
    .ranking-pillars-note {
      font-size: 0.9rem;
      color: #64748b;
      margin: 0.75rem 0;
      line-height: 1.6;
    }

    .ranking-intro {
      margin-top: 0.25rem;
      font-size: 1rem;
      color: #4b5563;
      max-width: 56rem;
    }

    .ranking-intro-bullets {
      margin: 0.25rem 0 0.5rem;
      padding-left: 1.25rem;
      font-size: 0.95rem;
      color: #6b7280;
    }

    .ranking-intro-bullets li {
      margin-bottom: 0.1rem;
    }

    .ranking-header-actions {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-top: 0.4rem;
    }

    /* Section B: Metric pills - all 5 on one row */
    .ranking-metric-pills {
      display: grid !important;
      grid-template-columns: repeat(5, 1fr) !important;
      gap: 1rem;
      margin-top: 1rem;
      margin-bottom: 1.5rem;
      width: 100%;
      grid-auto-flow: row;
    }

    .ranking-metric-pills > .metric-pill {
      display: block;
      width: 100%;
      min-width: 0;
    }

    /* For medium screens, reduce gap but keep all 5 in one row */
    @media (min-width: 769px) and (max-width: 1400px) {
      .ranking-metric-pills {
        grid-template-columns: repeat(5, 1fr);
        gap: 0.75rem;
      }
    }

    /* Only wrap on very small screens */
    @media (max-width: 768px) {
      .ranking-metric-pills {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    .metric-pill {
      background: #ffffff;
      border-radius: 8px;
      padding: 1rem 1.25rem;
      box-shadow: 0 1px 3px rgba(15, 23, 42, 0.06);
      transition: all 0.2s ease;
      border-left: 4px solid transparent;
    }
    
    .metric-pill--active {
      background: #1e40af !important;
      color: #ffffff !important;
      box-shadow: 0 2px 6px rgba(30, 64, 175, 0.3);
      border-left-color: #1e3a8a;
      font-weight: 600;
    }
    
    .metric-pill--active span,
    .metric-pill--active .optimisation-tab-count {
      color: #ffffff !important;
    }
    
    .metric-pill--active:hover {
      background: #1e3a8a !important;
    }

    .metric-pill--green {
      background: #f0fdf4;
      border-left-color: #16a34a;
    }

    .metric-pill--amber {
      background: #fffbeb;
      border-left-color: #f59e0b;
    }

    .metric-pill--red {
      background: #fef2f2;
      border-left-color: #dc2626;
    }

    .metric-pill--neutral {
      background: #f9fafb;
      border-left-color: #6b7280;
    }

    .metric-pill-value {
      font-size: 2rem;
      font-weight: 700;
      margin: 0.25rem 0;
      color: #1e293b;
    }

    .metric-pill-label {
      font-size: 1rem;
      font-weight: 600;
      color: #374151;
      margin-bottom: 0.25rem;
    }

    .metric-pill-status {
      font-size: 0.85rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.7rem;
      border-radius: 999px;
      margin: 0.25rem 0;
    }

    /* ============================================
       OPTIMISATION MODULE - DARK THEME
       ============================================ */
    
    /* Dark background for entire optimisation section - fill full width of main content area */
    section[data-panel="optimisation"] {
      background: var(--dark-bg) !important;
      min-height: calc(100vh - 4rem);
      position: relative;
      color: var(--dark-text) !important;
      width: calc(100vw - 260px); /* Full viewport width minus sidebar */
      margin-left: calc(-50vw + 50% + 130px); /* Position to start after sidebar */
      margin-right: calc(-50vw + 50% - 130px);
      padding: 2rem;
      box-sizing: border-box;
    }
    
    section[data-panel="optimisation"] * {
      color: inherit;
    }
    
    /* Section header */
    section[data-panel="optimisation"] .card--section-header {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
    }
    
    section[data-panel="optimisation"] .card--section-header h2 {
      color: var(--dark-brand) !important;
      margin: 0 0 0.5rem 0;
    }
    
    section[data-panel="optimisation"] .card--section-header p {
      color: var(--dark-text-muted) !important;
      margin: 0;
    }
    
    /* Buttons */
    section[data-panel="optimisation"] .btn {
      background: var(--dark-brand) !important;
      color: #000 !important;
      border: none !important;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    section[data-panel="optimisation"] .btn:hover {
      background: #d97706 !important;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
    }

    /* ============================================
       DASHBOARD MODULE - DARK THEME (MATCH OPTIMISATION)
       ============================================ */

    /* Dark background for entire dashboard section - fill full width of main content area */
    section[data-panel="dashboard"] {
      background: var(--dark-bg) !important;
      min-height: calc(100vh - 4rem);
      position: relative;
      color: var(--dark-text) !important;
      width: calc(100vw - 260px); /* Full viewport width minus sidebar */
      margin-left: calc(-50vw + 50% + 130px); /* Position to start after sidebar */
      margin-right: calc(-50vw + 50% - 130px);
      padding: 2rem;
      box-sizing: border-box;
    }

    section[data-panel="dashboard"] * {
      color: inherit;
    }

    section[data-panel="dashboard"] .card--section-header {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
    }

    section[data-panel="dashboard"] .card--section-header h2 {
      color: var(--dark-brand) !important;
      margin: 0 0 0.5rem 0;
    }

    section[data-panel="dashboard"] .card--section-header p {
      color: var(--dark-text-muted) !important;
      margin: 0;
    }

    section[data-panel="dashboard"] .card {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px;
      padding: 1.5rem;
    }

    section[data-panel="dashboard"] .btn {
      background: var(--dark-brand) !important;
      color: #000 !important;
      border: none !important;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-weight: 600;
      transition: all 0.2s;
    }

    section[data-panel="dashboard"] .btn:hover {
      background: #d97706 !important;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
    }

    /* Dashboard: dials */
    section[data-panel="dashboard"] .dashboard-dials-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem;
      margin-bottom: 1rem;
    }

    section[data-panel="dashboard"] .dashboard-summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    section[data-panel="dashboard"] .dashboard-dial-card {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      align-items: center;
      text-align: center;
    }

    section[data-panel="dashboard"] .dashboard-dial-header {
      width: 100%;
      position: relative;
    }

    section[data-panel="dashboard"] .dashboard-dial-title {
      font-weight: 800;
      font-size: 1.05rem;
      color: var(--dark-text) !important;
    }

    section[data-panel="dashboard"] .dashboard-dial-subtitle {
      font-size: 0.85rem;
      color: var(--dark-text-muted) !important;
      margin-top: 0.15rem;
    }

    section[data-panel="dashboard"] .dashboard-dial-ring {
      --pct: 0;
      --ring: rgba(148, 163, 184, 0.25);
      --accent: var(--dark-brand);
      width: 150px;
      height: 150px;
      border-radius: 999px;
      background: conic-gradient(var(--accent) calc(var(--pct) * 1%), var(--ring) 0);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: inset 0 0 0 2px rgba(148, 163, 184, 0.15);
    }

    section[data-panel="dashboard"] .dashboard-dial-inner {
      width: 118px;
      height: 118px;
      border-radius: 999px;
      background: var(--dark-panel);
      border: 1px solid var(--dark-border);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
    }

    section[data-panel="dashboard"] .dashboard-dial-value {
      font-size: 1.45rem;
      font-weight: 900;
      letter-spacing: -0.02em;
    }

    section[data-panel="dashboard"] .dashboard-dial-delta {
      font-size: 0.85rem;
      font-weight: 700;
      color: var(--dark-text-muted);
    }
    section[data-panel="dashboard"] .dashboard-dial-delta[data-dir="up"] { color: #10b981; }
    section[data-panel="dashboard"] .dashboard-dial-delta[data-dir="down"] { color: #ef4444; }
    section[data-panel="dashboard"] .dashboard-dial-delta[data-dir="flat"] { color: rgba(148, 163, 184, 0.95); }

    /* Dashboard: mini visuals under dials */
    section[data-panel="dashboard"] .dashboard-mini-gauge {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.18);
      overflow: hidden;
      position: relative;
      border: 1px solid rgba(148, 163, 184, 0.16);
    }
    section[data-panel="dashboard"] .dashboard-mini-gauge .fill {
      height: 100%;
      background: linear-gradient(90deg, rgba(239, 68, 68, 0.75), rgba(245, 158, 11, 0.85), rgba(16, 185, 129, 0.85));
      width: 100%;
      opacity: 0.85;
    }
    section[data-panel="dashboard"] .dashboard-mini-gauge .marker {
      position: absolute;
      top: -3px;
      width: 2px;
      height: 16px;
      background: rgba(226, 232, 240, 0.95);
      box-shadow: 0 0 0 2px rgba(15, 20, 25, 0.75);
      border-radius: 2px;
    }
    section[data-panel="dashboard"] .dashboard-mini-note {
      margin-top: 0.45rem;
      font-size: 0.78rem;
      color: var(--dark-text-muted);
      font-weight: 650;
      line-height: 1.3;
    }

    section[data-panel="dashboard"] .dashboard-delta-breakdown {
      margin-top: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    section[data-panel="dashboard"] .dashboard-delta-breakdown-title {
      font-size: 0.66rem;
      font-weight: 800;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--dark-text-muted);
    }
    section[data-panel="dashboard"] .dashboard-delta-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
    }
    section[data-panel="dashboard"] .dashboard-delta-label {
      font-size: 0.78rem;
      font-weight: 600;
      color: rgba(226, 232, 240, 0.88);
    }
    section[data-panel="dashboard"] .dashboard-delta-row .dashboard-kpi-delta {
      font-size: 0.78rem;
      font-weight: 700;
    }

    /* Dashboard: traffic-light tile content (matches Optimisation module semantics) */
    section[data-panel="dashboard"] .dashboard-traffic-row {
      display: flex;
      gap: 0.45rem;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 0.35rem;
    }
    section[data-panel="dashboard"] .dashboard-traffic-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.5rem;
      border-radius: 999px;
      font-size: 0.78rem;
      font-weight: 900;
      border: 1px solid rgba(148, 163, 184, 0.20);
      background: rgba(15, 20, 25, 0.25);
      color: rgba(226, 232, 240, 0.95);
      white-space: nowrap;
    }
    section[data-panel="dashboard"] .dashboard-traffic-pill[data-bucket="worse"] { border-color: rgba(239, 68, 68, 0.45); background: rgba(239, 68, 68, 0.12); }
    section[data-panel="dashboard"] .dashboard-traffic-pill[data-bucket="same"] { border-color: rgba(245, 158, 11, 0.55); background: rgba(245, 158, 11, 0.14); }
    section[data-panel="dashboard"] .dashboard-traffic-pill[data-bucket="better"] { border-color: rgba(16, 185, 129, 0.45); background: rgba(16, 185, 129, 0.12); }

    /* Dashboard: summary cards */
    section[data-panel="dashboard"] .dashboard-summary-card {
      position: relative;
      overflow: hidden;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    /* Delta indicator badge - top right corner */
    section[data-panel="dashboard"] .dashboard-delta-indicator {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.25rem 0.5rem;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 700;
      background: rgba(15, 20, 25, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: rgba(226, 232, 240, 0.95);
      z-index: 10;
      white-space: nowrap;
      backdrop-filter: blur(4px);
    }
    section[data-panel="dashboard"] .dashboard-delta-indicator[data-dir="up"] {
      border-color: rgba(16, 185, 129, 0.5);
      background: rgba(16, 185, 129, 0.15);
      color: #10b981;
    }
    section[data-panel="dashboard"] .dashboard-delta-indicator[data-dir="down"] {
      border-color: rgba(239, 68, 68, 0.5);
      background: rgba(239, 68, 68, 0.15);
      color: #ef4444;
    }
    section[data-panel="dashboard"] .dashboard-delta-indicator[data-dir="flat"] {
      border-color: rgba(148, 163, 184, 0.3);
      background: rgba(148, 163, 184, 0.1);
      color: rgba(148, 163, 184, 0.8);
    }
    section[data-panel="dashboard"] .dashboard-delta-indicator .delta-arrow {
      font-size: 0.7rem;
      line-height: 1;
    }
    /* Dashboard tiles: match Optimisation hover animation */
    section[data-panel="dashboard"] .dashboard-summary-card::after,
    section[data-panel="dashboard"] .dashboard-dial-card::after,
    section[data-panel="dashboard"] .dashboard-kpi-tile::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--dark-brand);
      transform: scaleX(0);
      transform-origin: left;
      transition: transform 0.3s ease;
      pointer-events: none;
    }

    section[data-panel="dashboard"] .dashboard-summary-card:hover,
    section[data-panel="dashboard"] .dashboard-dial-card:hover,
    section[data-panel="dashboard"] .dashboard-kpi-tile:hover {
      border-color: var(--dark-brand) !important;
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(245, 158, 11, 0.2);
      animation: wobble 0.5s ease-in-out;
    }
    section[data-panel="dashboard"] .dashboard-summary-card:hover::after,
    section[data-panel="dashboard"] .dashboard-dial-card:hover::after,
    section[data-panel="dashboard"] .dashboard-kpi-tile:hover::after {
      transform: scaleX(1);
    }
    section[data-panel="dashboard"] .dashboard-summary-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(245, 158, 11, 0.2);
    }
    section[data-panel="dashboard"] .dashboard-summary-card::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 5px;
      background: rgba(148, 163, 184, 0.5);
    }
    section[data-panel="dashboard"] .dashboard-summary-card[data-rag="green"]::before { background: #10b981; }
    section[data-panel="dashboard"] .dashboard-summary-card[data-rag="amber"]::before { background: #f59e0b; }
    section[data-panel="dashboard"] .dashboard-summary-card[data-rag="red"]::before { background: #ef4444; }

    section[data-panel="dashboard"] .dashboard-summary-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-bottom: 0.75rem;
      padding-left: 0.25rem;
    }
    section[data-panel="dashboard"] .dashboard-summary-title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 900;
      letter-spacing: -0.01em;
    }
    section[data-panel="dashboard"] .dashboard-summary-subtitle {
      margin-top: 0.15rem;
      font-size: 0.85rem;
      color: var(--dark-text-muted);
    }
    section[data-panel="dashboard"] .dashboard-rag-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      font-weight: 800;
      font-size: 0.8rem;
      color: var(--dark-text);
      background: rgba(15, 20, 25, 0.35);
      white-space: nowrap;
    }
    section[data-panel="dashboard"] .dashboard-rag-pill[data-rag="green"] { border-color: rgba(16,185,129,0.45); }
    section[data-panel="dashboard"] .dashboard-rag-pill[data-rag="amber"] { border-color: rgba(245,158,11,0.55); }
    section[data-panel="dashboard"] .dashboard-rag-pill[data-rag="red"] { border-color: rgba(239,68,68,0.55); }
    section[data-panel="dashboard"] .dashboard-rag-pill[data-rag="green"] { background: rgba(16,185,129,0.12); }
    section[data-panel="dashboard"] .dashboard-rag-pill[data-rag="amber"] { background: rgba(245,158,11,0.14); }
    section[data-panel="dashboard"] .dashboard-rag-pill[data-rag="red"] { background: rgba(239,68,68,0.14); }

    section[data-panel="dashboard"] .dashboard-kpi-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.75rem;
      margin-top: 0.75rem;
      padding-left: 0.25rem;
    }
    section[data-panel="dashboard"] .dashboard-kpi-tile {
      background: rgba(15, 20, 25, 0.35);
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: 10px;
      padding: 0.8rem 0.9rem;
      min-height: 72px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 0.25rem;
      position: relative;
    }
    section[data-panel="dashboard"] .dashboard-kpi-label {
      font-size: 0.8rem;
      color: var(--dark-text-muted);
      font-weight: 700;
    }
    section[data-panel="dashboard"] .dashboard-kpi-value {
      font-size: 1.25rem;
      font-weight: 900;
      letter-spacing: -0.02em;
    }

    section[data-panel="dashboard"] .dashboard-kpi-delta {
      margin-top: 0.1rem;
      font-size: 0.85rem;
      font-weight: 900;
      letter-spacing: -0.01em;
    }
    section[data-panel="dashboard"] .dashboard-kpi-delta[data-dir="up"] { color: #10b981; }
    section[data-panel="dashboard"] .dashboard-kpi-delta[data-dir="down"] { color: #ef4444; }
    section[data-panel="dashboard"] .dashboard-kpi-delta[data-dir="flat"] { color: rgba(148, 163, 184, 0.95); }

    /* Delta indicator badge for KPI tiles - top right corner */
    section[data-panel="dashboard"] .dashboard-kpi-tile-indicator {
      position: absolute;
      top: 0.4rem;
      right: 0.4rem;
      display: inline-flex;
      align-items: center;
      gap: 0.2rem;
      padding: 0.15rem 0.4rem;
      border-radius: 999px;
      font-size: 0.65rem;
      font-weight: 700;
      background: rgba(15, 20, 25, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: rgba(226, 232, 240, 0.95);
      z-index: 10;
      white-space: nowrap;
      backdrop-filter: blur(4px);
    }
    section[data-panel="dashboard"] .dashboard-kpi-tile-indicator[data-dir="up"] {
      border-color: rgba(16, 185, 129, 0.5);
      background: rgba(16, 185, 129, 0.15);
      color: #10b981;
    }
    section[data-panel="dashboard"] .dashboard-kpi-tile-indicator[data-dir="down"] {
      border-color: rgba(239, 68, 68, 0.5);
      background: rgba(239, 68, 68, 0.15);
      color: #ef4444;
    }
    section[data-panel="dashboard"] .dashboard-kpi-tile-indicator[data-dir="flat"] {
      border-color: rgba(148, 163, 184, 0.3);
      background: rgba(148, 163, 184, 0.1);
      color: rgba(148, 163, 184, 0.8);
    }
    section[data-panel="dashboard"] .dashboard-kpi-tile-indicator .delta-arrow {
      font-size: 0.6rem;
      line-height: 1;
    }

    section[data-panel="dashboard"] .dashboard-pillar-strip {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0.3rem;
    }
    section[data-panel="dashboard"] .dashboard-pillar-row {
      display: grid;
      grid-template-columns: 124px 1fr 40px;
      gap: 0.6rem;
      align-items: center;
      font-size: 0.75rem;
    }
    section[data-panel="dashboard"] .dashboard-pillar-label {
      color: rgba(226, 232, 240, 0.92);
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    section[data-panel="dashboard"] .dashboard-pillar-bar {
      height: 8px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.22);
      overflow: hidden;
      position: relative;
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.10);
    }
    section[data-panel="dashboard"] .dashboard-pillar-bar > span {
      display: block;
      height: 100%;
      width: 0%;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.55);
      transition: width 0.25s ease;
    }
    section[data-panel="dashboard"] .dashboard-pillar-score {
      font-weight: 600;
      text-align: right;
      color: rgba(226, 232, 240, 0.95);
    }
    
    /* Optimisation module tiles - dark theme with green centered counts and orange hover animation */
    .optimisation-summary-cards .card,
    .optimisation-kpi-tiles .card {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px;
      padding: 1.5rem;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    /* Bronze/Silver/Gold backgrounds for Potential Extra Clicks tile */
    #impact-potential-clicks-card.impact-bronze {
      background: linear-gradient(135deg, #cd7f32 0%, #b87333 100%) !important;
      border: 1px solid #a0652a !important;
      color: #ffffff !important;
    }
    
    #impact-potential-clicks-card.impact-bronze * {
      color: #ffffff !important;
    }
    
    #impact-potential-clicks-card.impact-silver {
      background: linear-gradient(135deg, #c0c0c0 0%, #a8a8a8 100%) !important;
      border: 1px solid #909090 !important;
      color: #1a1a1a !important;
    }
    
    #impact-potential-clicks-card.impact-silver * {
      color: #1a1a1a !important;
    }
    
    #impact-potential-clicks-card.impact-gold {
      background: linear-gradient(135deg, #ffd700 0%, #ffb700 100%) !important;
      border: 1px solid #e6a600 !important;
      color: #1a1a1a !important;
    }
    
    #impact-potential-clicks-card.impact-gold * {
      color: #1a1a1a !important;
    }
    
    .optimisation-impact-tiles .card:not(.impact-bronze):not(.impact-silver):not(.impact-gold) {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px;
      padding: 1.5rem;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    /* Task Details Modal/Drawer - Dark Theme */
    #optimisation-task-drawer {
      background: var(--dark-panel) !important;
      color: var(--dark-text) !important;
    }
    
    #optimisation-task-drawer * {
      color: var(--dark-text) !important;
    }
    
    #optimisation-drawer-header-bar {
      background: var(--dark-panel) !important;
      border-bottom: 1px solid var(--dark-border) !important;
    }
    
    #optimisation-drawer-header-bar h3 {
      color: var(--dark-text) !important;
    }
    
    #optimisation-drawer-header-bar button {
      color: var(--dark-text-muted) !important;
    }
    
    #optimisation-drawer-header-bar button:hover {
      color: var(--dark-text) !important;
    }
    
    /* Modal sections with light backgrounds */
    #optimisation-task-drawer div[style*="background: #fff5f5"],
    #optimisation-task-drawer div[style*="background: #f8f9fa"],
    #optimisation-task-drawer div[style*="background: white"] {
      background: var(--dark-panel) !important;
      border-color: var(--dark-border) !important;
    }
    
    /* Input fields */
    #optimisation-task-drawer input,
    #optimisation-task-drawer select,
    #optimisation-task-drawer textarea {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    #optimisation-task-drawer input::placeholder,
    #optimisation-task-drawer textarea::placeholder {
      color: var(--dark-text-muted) !important;
    }
    
    /* Labels and strong text */
    #optimisation-task-drawer strong,
    #optimisation-task-drawer label {
      color: var(--dark-text) !important;
    }
    
    /* Divs with muted colors */
    #optimisation-task-drawer div[style*="color: #666"],
    #optimisation-task-drawer div[style*="color: #475569"] {
      color: var(--dark-text-muted) !important;
    }
    
    /* Links */
    #optimisation-task-drawer a {
      color: var(--dark-brand) !important;
    }
    
    /* Buttons - use proper dark backgrounds with white text for readability */
    #optimisation-task-drawer .btn,
    #optimisation-task-drawer button.btn {
      background: var(--dark-brand) !important;
      color: #ffffff !important;
      border: 1px solid var(--dark-brand) !important;
      font-weight: 700 !important;
    }
    
    #optimisation-task-drawer .btn:hover,
    #optimisation-task-drawer button.btn:hover {
      background: #f59e0b !important;
      color: #ffffff !important;
      border-color: #f59e0b !important;
    }
    
    #optimisation-task-drawer .btn-secondary,
    #optimisation-task-drawer button.btn-secondary {
      background: #4b5563 !important;
      color: #ffffff !important;
      border: 1px solid #4b5563 !important;
      font-weight: 700 !important;
    }
    
    #optimisation-task-drawer .btn-secondary:hover,
    #optimisation-task-drawer button.btn-secondary:hover {
      background: #6b7280 !important;
      color: #ffffff !important;
      border-color: #6b7280 !important;
    }
    
    /* Specific button IDs - dark backgrounds with white text */
    #optimisation-cancel-task-btn,
    #optimisation-delete-task-btn {
      background: #dc2626 !important;
      color: #ffffff !important;
      border: 1px solid #dc2626 !important;
      font-weight: 700 !important;
    }
    
    #optimisation-cancel-task-btn:hover,
    #optimisation-delete-task-btn:hover {
      background: #b91c1c !important;
      color: #ffffff !important;
      border-color: #b91c1c !important;
    }
    
    #optimisation-complete-cycle-btn {
      background: #059669 !important;
      color: #ffffff !important;
      border: 1px solid #059669 !important;
      font-weight: 700 !important;
    }
    
    #optimisation-complete-cycle-btn:hover {
      background: #047857 !important;
      color: #ffffff !important;
      border-color: #047857 !important;
    }
    
    #optimisation-archive-cycle-btn {
      background: #4b5563 !important;
      color: #ffffff !important;
      border: 1px solid #4b5563 !important;
      font-weight: 700 !important;
    }
    
    #optimisation-archive-cycle-btn:hover {
      background: #6b7280 !important;
      color: #ffffff !important;
      border-color: #6b7280 !important;
    }
    
    #optimisation-add-event-btn,
    #optimisation-save-status-btn {
      background: var(--dark-brand) !important;
      color: #ffffff !important;
      border: 1px solid var(--dark-brand) !important;
      font-weight: 700 !important;
    }
    
    #optimisation-add-event-btn:hover,
    #optimisation-save-status-btn:hover {
      background: #f59e0b !important;
      color: #ffffff !important;
      border-color: #f59e0b !important;
    }
    
    /* Buttons with orange/yellow backgrounds need BLACK text for readability */
    #optimisation-edit-objective-btn,
    #optimisation-add-measurement-btn,
    #optimisation-save-objective-btn {
      background: var(--dark-brand) !important;
      color: #000000 !important;
      border: 1px solid var(--dark-brand) !important;
      font-weight: 700 !important;
    }
    
    #optimisation-edit-objective-btn:hover,
    #optimisation-add-measurement-btn:hover,
    #optimisation-save-objective-btn:hover {
      background: #f59e0b !important;
      color: #000000 !important;
      border-color: #f59e0b !important;
    }
    
    /* Status badges and pills */
    #optimisation-task-drawer span[style*="background: #f0f0f0"] {
      background: rgba(156, 163, 175, 0.2) !important;
      color: var(--dark-text) !important;
    }
    
    /* Table borders and backgrounds */
    #optimisation-task-drawer table,
    #optimisation-task-drawer th,
    #optimisation-task-drawer td {
      border-color: var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    #optimisation-task-drawer th {
      background: var(--dark-bg) !important;
    }
    
    /* Timeline border */
    #optimisation-drawer-events-container div[style*="border-left"] {
      border-left-color: var(--dark-border) !important;
    }

    .optimisation-summary-cards .card::before,
    .optimisation-kpi-tiles .card::before,
    .optimisation-impact-tiles .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--dark-brand);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }

    .optimisation-summary-cards .card:hover,
    .optimisation-kpi-tiles .card:hover,
    .optimisation-impact-tiles .card:not(.impact-bronze):not(.impact-silver):not(.impact-gold):hover {
      border-color: var(--dark-brand) !important;
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(245, 158, 11, 0.2);
      animation: wobble 0.5s ease-in-out;
    }

    @keyframes wobble {
      0%, 100% { transform: translateY(-4px) rotate(0deg); }
      25% { transform: translateY(-4px) rotate(-1deg); }
      75% { transform: translateY(-4px) rotate(1deg); }
    }

    .optimisation-summary-cards .card:hover::before,
    .optimisation-kpi-tiles .card:hover::before,
    .optimisation-impact-tiles .card:not(.impact-bronze):not(.impact-silver):not(.impact-gold):hover::before {
      transform: scaleX(1);
    }
    
    /* Traffic light pills - same styling as other cards */
    .traffic-light-pill {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px !important;
      padding: 1rem !important;
      transition: all 0.3s ease !important;
      position: relative !important;
      overflow: visible !important;
      text-align: center !important;
      cursor: pointer !important;
      z-index: 1 !important;
    }
    
    .traffic-light-pill::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--dark-brand);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }
    
    .traffic-light-pill:hover {
      border-color: var(--dark-brand) !important;
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(245, 158, 11, 0.2);
      animation: wobble 0.5s ease-in-out;
    }
    
    .traffic-light-pill:hover::before {
      transform: scaleX(1);
    }
    
    /* Restore background colors on hover based on bucket */
    .traffic-light-pill[data-bucket="worse"]:hover {
      background: rgba(239, 68, 68, 0.3) !important;
    }
    
    .traffic-light-pill[data-bucket="same"]:hover {
      background: rgba(245, 158, 11, 0.3) !important;
    }
    
    .traffic-light-pill[data-bucket="better"]:hover {
      background: rgba(16, 185, 129, 0.3) !important;
    }

    /* Green centered count values (like analytics.html) - no background */
    .optimisation-summary-cards .card > div:first-child,
    .optimisation-kpi-tiles .card > div:first-child,
    .optimisation-impact-tiles .card > div:first-child {
      font-size: 2.5rem !important;
      font-weight: 700 !important;
      color: var(--success) !important;
      margin-bottom: 0.5rem;
      text-align: center;
      background: transparent !important;
      padding: 0 !important;
    }

    /* Labels - no background */
    .optimisation-summary-cards .card > div:last-child,
    .optimisation-kpi-tiles .card > div:last-child,
    .optimisation-impact-tiles .card > div:last-child {
      color: var(--dark-text-muted) !important;
      font-size: 0.9rem;
      text-align: center;
      background: transparent !important;
      padding: 0 !important;
    }

    /* Goal rollup badges */
    section[data-panel="optimisation"] .optimisation-goal-rollups {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      border-radius: 8px;
      padding: 1rem;
      margin: 1.5rem 0;
    }
    
    section[data-panel="optimisation"] .optimisation-goal-rollups > div:first-child {
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .ranking-badge {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
      transition: all 0.2s;
    }
    
    section[data-panel="optimisation"] .ranking-badge:hover {
      border-color: var(--dark-brand) !important;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.2);
    }
    
    /* Scope toggle */
    section[data-panel="optimisation"] .optimisation-scope-toggle {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-scope-toggle label {
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-scope-toggle select {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-scope-toggle span {
      color: var(--dark-text-muted) !important;
    }
    
    /* Tab pills */
    section[data-panel="optimisation"] .optimisation-tab-pills {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      border-radius: 8px;
      padding: 1rem;
      margin: 1.5rem 0;
    }
    
    section[data-panel="optimisation"] .optimisation-tab-btn {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-tab-btn:hover {
      border-color: var(--dark-brand) !important;
      background: rgba(245, 158, 11, 0.1) !important;
    }
    
    section[data-panel="optimisation"] .metric-pill--active {
      background: var(--dark-brand) !important;
      border-color: var(--dark-brand) !important;
      color: #000 !important;
      animation: wobble 0.5s ease-in-out;
    }
    
    /* Tables */
    section[data-panel="optimisation"] .ranking-table-wrapper {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      border-radius: 8px;
      overflow: hidden;
    }
    
    section[data-panel="optimisation"] .ranking-table {
      background: var(--dark-panel) !important;
    }
    
    section[data-panel="optimisation"] .ranking-table thead th {
      background: var(--dark-bg) !important;
      color: #ffffff !important;
      border-bottom: 1px solid var(--dark-border) !important;
      font-weight: 600;
    }
    
    /* Sort indicators and info icons - white */
    section[data-panel="optimisation"] .ranking-table thead th .sort-indicator,
    section[data-panel="optimisation"] .ranking-table thead th i,
    section[data-panel="optimisation"] .ranking-table thead th [class*="icon"],
    section[data-panel="optimisation"] .ranking-table thead th::after {
      color: #ffffff !important;
      opacity: 0.8;
    }
    
    section[data-panel="optimisation"] .ranking-table thead th:hover .sort-indicator,
    section[data-panel="optimisation"] .ranking-table thead th:hover i {
      opacity: 1;
    }
    
    /* Table cells - no darker background, transparent */
    section[data-panel="optimisation"] .ranking-table tbody td {
      background: transparent !important;
      color: var(--dark-text) !important;
      border-bottom: 1px solid var(--dark-border) !important;
    }
    
    /* Remove any background from text/spans inside cells */
    section[data-panel="optimisation"] .ranking-table tbody td *,
    section[data-panel="optimisation"] .ranking-table tbody td span,
    section[data-panel="optimisation"] .ranking-table tbody td strong,
    section[data-panel="optimisation"] .ranking-table tbody td div {
      background: transparent !important;
    }
    
    /* Ensure all text in table cells is readable */
    section[data-panel="optimisation"] .ranking-table tbody td {
      background: transparent !important;
    }
    
    section[data-panel="optimisation"] .ranking-table tbody td strong {
      color: var(--dark-text) !important;
      background: transparent !important;
    }
    
    section[data-panel="optimisation"] .ranking-table tbody tr:hover {
      background: rgba(255, 255, 255, 0.05) !important;
    }
    
    section[data-panel="optimisation"] .ranking-table tbody tr:hover td {
      background: rgba(255, 255, 255, 0.05) !important;
    }
    
    section[data-panel="optimisation"] .ranking-table-empty {
      color: var(--dark-text-muted) !important;
      background: transparent !important;
    }
    
    /* Pagination */
    section[data-panel="optimisation"] #optimisation-pagination-controls {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      border-radius: 8px;
      padding: 1rem;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] #optimisation-pagination-controls button,
    section[data-panel="optimisation"] #optimisation-pagination-controls select {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] #optimisation-pagination-controls button:hover {
      border-color: var(--dark-brand) !important;
      background: rgba(245, 158, 11, 0.1) !important;
    }
    
    /* Charts container */
    section[data-panel="optimisation"] .optimisation-timeseries-charts .card {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-timeseries-charts h3 {
      color: #ffffff !important;
      font-size: 1.2rem !important;
      font-weight: 600;
    }
    
    /* Chart text - bright white and larger */
    section[data-panel="optimisation"] canvas {
      color: #ffffff !important;
    }
    
    /* Chart axis labels and text - white and larger */
    section[data-panel="optimisation"] #chart-measurements-per-week,
    section[data-panel="optimisation"] #chart-median-delta {
      color: #ffffff !important;
    }
    
    /* Filters and inputs */
    section[data-panel="optimisation"] input[type="text"],
    section[data-panel="optimisation"] input[type="checkbox"],
    section[data-panel="optimisation"] select {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] input[type="text"]:focus,
    section[data-panel="optimisation"] select:focus {
      border-color: var(--dark-brand) !important;
      outline: none;
    }
    
    /* Portfolio Tab Styling - Match Optimisation tab dark theme */
    section[data-panel="portfolio"] .portfolio-container {
      background: var(--dark-bg) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="portfolio"] .portfolio-container h1 {
      color: var(--dark-text) !important;
      font-size: 2rem !important;
      font-weight: 700;
    }
    
    section[data-panel="portfolio"] .portfolio-chart-section .card,
    section[data-panel="portfolio"] .portfolio-table-section .card {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3) !important;
    }
    
    section[data-panel="portfolio"] .portfolio-chart-section h2,
    section[data-panel="portfolio"] .portfolio-table-section h2 {
      color: #ffffff !important;
      font-size: 1.3rem !important;
      font-weight: 600;
    }
    
    section[data-panel="portfolio"] .portfolio-chart-section p,
    section[data-panel="portfolio"] .portfolio-table-section p {
      color: var(--dark-text-muted) !important;
    }
    
    section[data-panel="portfolio"] .portfolio-controls label {
      color: var(--dark-text) !important;
    }
    
    section[data-panel="portfolio"] .portfolio-controls select,
    section[data-panel="portfolio"] #portfolio-table-kpi-select {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
      padding: 0.5rem 0.75rem !important;
      border-radius: 6px !important;
      font-size: 0.875rem !important;
    }
    
    section[data-panel="portfolio"] .portfolio-controls select:focus,
    section[data-panel="portfolio"] #portfolio-table-kpi-select:focus {
      border-color: var(--dark-brand) !important;
      outline: none;
      box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.1) !important;
    }
    
    section[data-panel="portfolio"] .portfolio-controls select:hover,
    section[data-panel="portfolio"] #portfolio-table-kpi-select:hover {
      border-color: var(--dark-brand) !important;
    }
    
    section[data-panel="portfolio"] #portfolio-monthly-table {
      background: var(--dark-panel) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="portfolio"] #portfolio-monthly-table thead th {
      background: rgba(55, 65, 81, 0.5) !important;
      color: var(--dark-text) !important;
      border-bottom: 2px solid var(--dark-border) !important;
      font-weight: 600;
    }
    
    section[data-panel="portfolio"] #portfolio-monthly-table tbody td {
      color: var(--dark-text) !important;
      border-bottom: 1px solid var(--dark-border) !important;
    }
    
    section[data-panel="portfolio"] #portfolio-monthly-table tbody tr:hover {
      background: rgba(245, 158, 11, 0.05) !important;
    }
    
    section[data-panel="portfolio"] #portfolio-delta-chart {
      color: #ffffff !important;
    }
    
    /* Remove border-left from inline styles */
    .optimisation-summary-cards .card[style*="border-left"],
    .optimisation-kpi-tiles .card[style*="border-left"],
    .optimisation-impact-tiles .card[style*="border-left"] {
      border-left: 2px solid var(--dark-border) !important;
    }

    .metric-pill--green .metric-pill-status {
      background: #dcfce7;
      color: #166534;
    }

    .metric-pill--amber .metric-pill-status {
      background: #fef3c7;
      color: #92400e;
    }

    .metric-pill--red .metric-pill-status {
      background: #fee2e2;
      color: #b91c1c;
    }

    .metric-pill--neutral .metric-pill-status {
      background: #e5e7eb;
      color: #4b5563;
    }

    .metric-pill-footer {
      font-size: 0.85rem;
      color: #6b7280;
      margin-top: 0.5rem;
      line-height: 1.4;
    }

    .metric-pill-toggle {
      font-size: 0.85rem;
      color: #0284c7;
      cursor: pointer;
      margin-top: 0.5rem;
      text-decoration: underline;
      user-select: none;
    }

    .metric-pill-toggle:hover {
      color: #0369a1;
    }

    .metric-pill-details {
      display: none;
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid #e5e7eb;
    }

    .metric-pill-details.expanded {
      display: block;
    }

    /* ============================================
       AI Sources & Influence tab: layout styling
       ============================================ */
    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer {
      background: #fffbeb;
      border-left: 4px solid #f59e0b;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer .card-header {
      padding: 1.25rem 1.5rem 0.75rem 1.5rem;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer .card-header h3 {
      color: #92400e;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer .card-body {
      padding: 1.25rem 1.5rem;
      color: #78350f;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer ul {
      padding-left: 1.5rem;
      margin: 0.25rem 0;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-domain-table-card {
      background: rgba(204, 255, 255, 0.15);
      border-left: 4px solid #CCFFFF;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-domain-table-card .card-header {
      background: transparent;
    }

    /* AI sources table: alignment + hover highlight */
    #ai-sources-table th:nth-child(1),
    #ai-sources-table td:nth-child(1),
    #ai-sources-table th:nth-child(2),
    #ai-sources-table td:nth-child(2),
    #ai-sources-table th:nth-child(6),
    #ai-sources-table td:nth-child(6) {
      text-align: left !important;
    }

    #ai-sources-table th:nth-child(3),
    #ai-sources-table td:nth-child(3),
    #ai-sources-table th:nth-child(4),
    #ai-sources-table td:nth-child(4),
    #ai-sources-table th:nth-child(5),
    #ai-sources-table td:nth-child(5) {
      text-align: right !important;
    }

    #ai-sources-table tbody tr:hover td {
      background: #eff6ff !important;
    }

    /* Tile details styling */
    .tile-details-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: #374151;
      margin: 0 0 0.75rem 0;
      line-height: 1.5;
    }

    .tile-details-list {
      list-style: none;
      padding: 0;
      margin: 0 0 0.75rem 0;
    }

    .tile-details-list li {
      font-size: 0.875rem;
      color: #4b5563;
      line-height: 1.8;
      margin-bottom: 0.5rem;
    }

    .tile-details-list li strong {
      color: #1f2937;
      font-weight: 600;
    }

    .tile-details-footnote {
      font-size: 0.8rem;
      color: #6b7280;
      margin: 0.75rem 0 0 0;
      font-style: italic;
      line-height: 1.5;
    }

    /* Insights card styling */
    /* Side-by-side container for insights and visibility cards - 50% each */
    .ranking-cards-side-by-side {
      display: flex !important;
      flex-direction: row !important;
      gap: 1.5rem;
      margin: 1.5rem 0;
      align-items: flex-start;
      flex-wrap: wrap !important;
      width: 100%;
      overflow: visible;
    }

    .ranking-cards-side-by-side > *:first-child,
    .ranking-cards-side-by-side > *:nth-child(2) {
      flex: 0 0 calc(50% - 0.75rem) !important;
      min-width: 0;
      max-width: calc(50% - 0.75rem) !important;
      width: calc(50% - 0.75rem) !important;
      display: block !important;
    }

    /* Force all other children to be full width and on new rows */
    .ranking-cards-side-by-side > *:nth-child(n+3) {
      flex: 0 0 100% !important;
      width: 100% !important;
      max-width: 100% !important;
      clear: both !important;
      display: block !important;
      margin-top: 1.5rem;
    }

    .ranking-visibility-metrics-section {
      display: block !important;
    }

    /* Ensure sections after side-by-side cards are full width and stacked on new row */
    .ranking-cards-side-by-side ~ .ranking-priority-matrix-section,
    .ranking-cards-side-by-side ~ .ranking-table-section {
      width: 100% !important;
      display: block !important;
      clear: both !important;
      flex: none !important;
      margin-left: 0 !important;
      margin-right: 0 !important;
      float: none !important;
      position: relative !important;
    }

    @media (max-width: 1024px) {
      .ranking-cards-side-by-side {
        flex-direction: column;
      }
    }

    .card--insights {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin: 0;
      padding: 1.25rem 1.5rem;
    }

    .card--insights h2 {
      font-weight: 600;
      color: #92400e;
      margin: 0 0 0.5rem 0;
      font-size: 0.95rem;
    }

    .card--insights .card-subtitle {
      font-weight: 400;
      color: #78350f;
      margin: 0 0 1rem 0;
      font-size: 0.8rem;
      line-height: 1.5;
    }

    .card-pill-container {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .card-pill {
      background: #fffbeb;
      border: 1px solid #fde68a;
      border-radius: 6px;
      padding: 0.875rem;
      margin-bottom: 0.75rem;
    }

    .card-pill p {
      margin: 0;
      font-size: 0.8rem;
      line-height: 1.5;
      color: #78350f;
    }

    .card-pill strong {
      color: #92400e;
      font-weight: 600;
    }

    /* Visibility metrics card styling */
    .ranking-visibility-metrics-section .card {
      padding: 1.25rem 1.5rem;
    }

    .ranking-visibility-metrics-section h4 {
      font-size: 0.95rem !important;
      font-weight: 600 !important;
      margin-bottom: 0.5rem !important;
    }

    .ranking-visibility-metrics-section p,
    .ranking-visibility-metrics-section ul,
    .ranking-visibility-metrics-section li {
      font-size: 0.8rem !important;
    }

    .ranking-visibility-metrics-section strong {
      font-weight: 600 !important;
    }

    /* Section C: Filters */
    .ranking-filters-section {
      margin-bottom: 1rem;
      background: rgba(204, 255, 255, 0.15) !important;
      border-left: 4px solid #CCFFFF !important;
      border-radius: 8px;
      padding: 1rem 1.25rem;
      font-size: 0.75rem !important;
    }

    .ranking-filter-bar {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 0.75rem 1rem;
      align-items: end;
      padding: 0;
      background: transparent;
    }

    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 0.375rem;
      min-width: 0;
    }

    .filter-group label {
      font-size: 0.65rem !important;
      font-weight: 600;
      color: #374151;
      white-space: nowrap;
      margin: 0;
      line-height: 1.2;
    }

    .filter-control {
      padding: 0.35rem 0.55rem;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.85rem !important;
      background: #ffffff;
      width: 100%;
      min-width: 110px;
      transition: all 0.2s ease;
    }
    
    .filter-control option {
      font-size: 0.85rem;
    }

    /* Active filter state - when value is not "all" */
    .filter-control.filter-active {
      background: #eff6ff !important;
      border-color: #3b82f6 !important;
      color: #1e40af !important;
      font-weight: 600;
    }

    .filter-control:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.15);
    }

    #ranking-filter-keyword {
      min-width: 300px;
    }

    /* Search filter group should be wider */
    .filter-group-search {
      grid-column: span 2;
      min-width: 300px;
    }

    /* Clear filters button */
    #ranking-filter-clear {
      font-size: 0.7rem !important;
      padding: 0.4rem 0.75rem;
      align-self: end;
    }

    /* Keyword Priority Matrix section - full width, stacked layout */
    .ranking-priority-matrix-section {
      width: 100% !important;
      clear: both !important;
      display: block !important;
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
      flex: none !important;
      flex-basis: 100% !important;
      max-width: 100% !important;
      float: none !important;
      position: relative !important;
      box-sizing: border-box !important;
      order: 999 !important;
    }

    /* Section C: Table section - separate card */
    .ranking-table-section {
      margin: 2rem 0;
      width: 100% !important;
      clear: both !important;
      display: block !important;
      flex: none !important;
      max-width: 100% !important;
      float: none !important;
      position: relative !important;
      box-sizing: border-box !important;
      background: rgba(204, 255, 255, 0.2) !important;
      border-left: 4px solid #CCFFFF !important;
      border-radius: 8px;
      padding: 1.5rem;
      font-size: 14pt !important;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .ranking-table-section .card {
      background: transparent;
      box-shadow: none;
      padding: 0;
    }
    
    /* Apply 14pt to section elements but exclude table */
    .ranking-table-section .card-header,
    .ranking-table-section .card-subtitle,
    .ranking-table-section .filter-group,
    .ranking-table-section .filter-control,
    .ranking-table-section .btn {
      font-size: 14pt !important;
    }
    
    /* Table font size - must come after to override any universal selectors */
    .ranking-table-section .ranking-table,
    .ranking-table-section .ranking-table th,
    .ranking-table-section .ranking-table td,
    .ranking-table-section .ranking-table-wrapper .ranking-table,
    .ranking-table-section .ranking-table-wrapper .ranking-table th,
    .ranking-table-section .ranking-table-wrapper .ranking-table td {
      font-size: 0.875rem !important;
    }
    
    /* Pagination controls */
    .ranking-pagination-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #e5e7eb;
      flex-wrap: wrap;
      gap: 1rem;
    }
    
    .ranking-pagination-info {
      font-size: 14pt !important;
      color: #374151;
    }
    
    .ranking-pagination-buttons {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    
    .ranking-pagination-buttons button {
      padding: 0.5rem 1rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      background: #ffffff;
      font-size: 14pt !important;
      cursor: pointer;
      color: #374151;
    }
    
    .ranking-pagination-buttons button:hover:not(:disabled) {
      background: #f3f4f6;
      border-color: #9ca3af;
    }
    
    .ranking-pagination-buttons button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .ranking-rows-per-page {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .ranking-rows-per-page label {
      font-size: 14pt !important;
      color: #374151;
      white-space: nowrap;
    }
    
    .ranking-rows-per-page select {
      padding: 0.5rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 14pt !important;
      background: #ffffff;
    }

    /* Section D: Details grid - three columns (33% each) */
    .ranking-details-grid {
      display: grid !important;
      grid-template-columns: repeat(3, 1fr) !important;
      gap: 1rem;
      margin-top: 2rem;
      background: rgba(204, 255, 255, 0.15) !important;
      border-left: 4px solid #CCFFFF !important;
      border-radius: 8px;
      padding: 1.5rem;
    }
    
    .ranking-details-grid .card {
      min-width: 0;
      overflow: hidden;
    }
    
    .ranking-details-grid table {
      width: 100%;
      table-layout: fixed;
      font-size: 0.8rem;
    }
    
    .ranking-details-grid table th,
    .ranking-details-grid table td {
      padding: 0.5rem 0.4rem;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    .ranking-details-grid table th:first-child,
    .ranking-details-grid table td:first-child {
      width: 35%;
      max-width: 35%;
    }
    
    .ranking-details-grid table th:nth-child(2),
    .ranking-details-grid table td:nth-child(2) {
      width: 15%;
      max-width: 15%;
    }
    
    .ranking-details-grid table th:nth-child(3),
    .ranking-details-grid table td:nth-child(3) {
      width: 20%;
      max-width: 20%;
    }
    
    .ranking-details-grid table th:nth-child(4),
    .ranking-details-grid table td:nth-child(4) {
      width: 20%;
      max-width: 20%;
    }
    
    .ranking-details-grid table th:nth-child(5),
    .ranking-details-grid table td:nth-child(5) {
      width: 10%;
      max-width: 10%;
    }

    .ranking-details-grid .card {
      background: #ffffff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 0;
      margin-bottom: 0.75rem;
      border-radius: 6px;
      border: 1px solid #e5e7eb;
    }

    .ranking-details-grid .card:last-child {
      margin-bottom: 0;
    }

    /* Card header and body padding for consistent spacing */
    .ranking-details-grid .card-header {
      padding: 1.25rem 1.25rem 0.75rem 1.25rem;
    }

    .ranking-details-grid .card-body,
    .ranking-details-grid .ranking-ai-detail-body {
      padding: 0 1.25rem 1.25rem 1.25rem;
      font-size: 0.95rem;
      font-weight: 400;
      color: #1e293b;
      line-height: 1.6;
    }

    /* Typography hierarchy for cards */
    .ranking-details-grid .card-header h3 {
      font-size: 1.25rem;
      font-weight: 700;
      color: #1e293b;
      margin: 0 0 0.5rem 0;
      line-height: 1.4;
    }

    .ranking-details-grid .card-header h2 {
      font-size: 1.1rem;
      font-weight: 600;
      color: #374151;
      margin: 0 0 0.5rem 0;
      line-height: 1.4;
    }

    .ranking-details-grid .card-header p,
    .ranking-details-grid .card-subtitle {
      font-size: 0.9rem;
      font-weight: 400;
      color: #64748b;
      line-height: 1.5;
      margin: 0;
    }

    .ranking-details-grid .card-header h5 {
      font-size: 1rem;
      font-weight: 600;
      color: #374151;
      margin: 1rem 0 0.5rem 0;
    }

    /* List padding to match card body */
    .ranking-details-grid .ranking-ai-detail-list {
      padding: 0 1.25rem 1.25rem 1.25rem;
      margin: 0;
    }

    @media (max-width: 1200px) {
      .ranking-details-grid {
        grid-template-columns: 1fr;
      }
    }


    .ranking-table-wrapper {
      max-height: 540px;
      overflow: auto;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
    }

    .ranking-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.875rem !important;
    }

    /* Table header styling */
    .ranking-table th {
      text-align: center !important;
      vertical-align: middle;
      position: relative;
    }

    .ranking-table th > div:first-child {
      font-weight: 700 !important;
      text-align: center;
      margin-bottom: 0.25rem;
    }

    .ranking-table th > div:last-child {
      text-align: center !important;
      color: #2563eb !important;
      opacity: 1 !important;
    }

    .ranking-table th .sort-indicator {
      color: #1e40af !important;
      font-weight: 700 !important;
      margin-left: 0.25rem;
      opacity: 1 !important;
    }

    .ranking-table th.sortable {
      cursor: pointer;
    }

    .ranking-table th.sortable:hover {
      background-color: #f3f4f6;
    }

    /* Dynamic column widths - adjust based on content */
    .ranking-table {
      table-layout: auto;
      width: 100%;
    }

    .ranking-table th,
    .ranking-table td {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #e5e7eb;
      text-align: center;
      font-size: 0.875rem !important;
    }

    .ranking-table th {
      position: sticky;
      top: 0;
      background: #f3f4f6;
      z-index: 10;
      font-weight: 600;
      font-size: 0.875rem !important;
      vertical-align: top;
    }

    .ranking-table th > div:first-child {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
    }

    .ranking-table th.sortable {
      cursor: pointer;
      user-select: none;
      position: sticky;
      top: 0;
    }

    .ranking-table th.sortable:hover {
      background: #e5e7eb;
      position: sticky;
      top: 0;
    }

    .sort-indicator {
      display: inline-block;
      margin-left: 0.25rem;
      font-size: 0.85rem;
      opacity: 0.5;
    }

    .sort-indicator::after {
      content: "";
    }

    .ranking-table th.sort-asc .sort-indicator::after {
      content: "";
      opacity: 1;
    }

    .ranking-table th.sort-desc .sort-indicator::after {
      content: "";
      opacity: 1;
    }

    .ranking-table tr:nth-child(even) td {
      background: #f9fafb;
    }

    .ranking-table tr:hover {
      cursor: pointer;
    }

    .ranking-table-row--selected td {
      background: #eef2ff !important;
    }

    .ranking-row-good td {
      box-shadow: inset 3px 0 0 #16a34a;
    }

    .ranking-row-ok td {
      box-shadow: inset 3px 0 0 #f59e0b;
    }

    .ranking-row-weak td {
      box-shadow: inset 3px 0 0 #dc2626;
    }

    .ranking-table-empty {
      text-align: center;
      padding: 1rem;
      color: #6b7280;
    }


    .ranking-subtitle-tight {
      font-size: 0.875rem !important;
      max-width: 48rem;
    }

    /* RAG badges in table */
    .ranking-badge-rank {
      display: inline-flex;
      align-items: center;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .ranking-badge-rank--good {
      background: #dcfce7;
      color: #166534;
    }

    .ranking-badge-rank--ok {
      background: #fef3c7;
      color: #92400e;
    }

    .ranking-badge-rank--weak {
      background: #fee2e2;
      color: #b91c1c;
    }

    .ranking-badge-volume {
      display: inline-flex;
      align-items: center;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }
    
    .ranking-badge-volume--high {
      background: #dcfce7;
      color: #166534;
    }
    
    .ranking-badge-volume--med {
      background: #fef3c7;
      color: #92400e;
    }
    
    .ranking-badge-volume--low {
      background: #fee2e2;
      color: #b91c1c;
    }
    
    .ranking-badge-volume--none {
      background: #f3f4f6;
      color: #6b7280;
    }

    .ranking-badge-citation {
      display: inline-flex;
      align-items: center;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .ranking-badge-citation--good {
      background: #dcfce7;
      color: #166534;
    }

    .ranking-badge-citation--weak {
      background: #fee2e2;
      color: #b91c1c;
    }

    .ranking-ai-detail-body {
      padding: 1rem 0;
    }

    .ranking-ai-detail-content {
      /* Make scorecard stand out as separate object */
      margin: 0.75rem 0;
      padding: 1.5rem 1.5rem;
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      border-top: 1px solid #e5e7eb;
      border-right: 1px solid #e5e7eb;
      border-bottom: 1px solid #e5e7eb;
      /* Left border will be set dynamically based on priority */
    }

    .ranking-ai-detail-content.scorecard-priority-high {
      border-left: 6px solid #ef4444; /* Red for High priority */
      background: #fef2f2;
    }

    .ranking-ai-detail-content.scorecard-priority-medium {
      border-left: 6px solid #f59e0b; /* Amber for Medium priority */
      background: #fffbeb;
    }

    .ranking-ai-detail-content.scorecard-priority-low {
      border-left: 6px solid #10b981; /* Green for Low priority */
      background: #f0fdf4;
    }

    .ranking-ai-detail-content h4 {
      margin: 0 0 0.5rem 0;
      font-size: 1.25rem;
      font-weight: 700;
      color: #1e293b;
    }

    .ranking-ai-detail-content h5 {
      margin: 1rem 0 0.5rem 0;
      font-size: 1rem;
      font-weight: 600;
      color: #374151;
    }

    /* Section breaks for scorecard components */
    .ranking-ai-detail-content .scorecard-section {
      padding: 1rem 1.25rem;
      margin-bottom: 1.0rem !important;
      background: #f5f5f5;
      border-left: 3px solid #cbd5e1;
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .ranking-ai-detail-content .scorecard-section:last-child {
      margin-bottom: 0 !important;
    }

    .ranking-ai-detail-list {
      list-style: none;
      padding-left: 0;
      margin: 0.5rem 0 0;
    }

    .ranking-ai-detail-list li {
      margin-bottom: 0.4rem;
      padding: 0.5rem 0.75rem;
      background: #f9fafb;
      border-radius: 4px;
      font-size: 0.95rem;
    }

    .ranking-ai-detail-list li a {
      color: #2563eb;
      text-decoration: none;
    }

    .ranking-ai-detail-list li a:hover {
      text-decoration: underline;
    }

    .ranking-ai-last-run {
      margin-left: 0.75rem;
      font-size: 0.95rem;
      color: #6b7280;
    }

    .ranking-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 500;
    }

    .ranking-badge--ai-on { background: #ecfdf5; color: #059669; }
    .ranking-badge--ai-off { background: #f9fafb; color: #6b7280; }
    .ranking-badge--cited { background: #eff6ff; color: #1d4ed8; }
    .ranking-badge--not-cited { background: #fef2f2; color: #b91c1c; }
    .ranking-badge--segment-money { background: #fef3c7; color: #92400e; }
    .ranking-badge--segment-education { background: #e0f2fe; color: #075985; }
    .ranking-badge--segment-brand { background: #f5f3ff; color: #6d28d9; }
    .ranking-badge--segment-general { background: #f9fafb; color: #4b5563; }
    .ranking-badge--rank-good { background: #dcfce7; color: #166534; }
    .ranking-badge--rank-mid { background: #fef3c7; color: #92400e; }
    .ranking-badge--rank-weak { background: #fee2e2; color: #b91c1c; }
    
    /* Demand share styling */
    .ranking-badge-demand-share--high { color: #059669; font-weight: 600; }
    .ranking-badge-demand-share--med { color: #d97706; font-weight: 500; }
    .ranking-badge-demand-share--low { color: #6b7280; font-weight: 400; }
    .ranking-badge-demand-share--none { color: #9ca3af; }
    
    /* Opportunity score styling (RAG colors matching Money Pages priority matrix) */
    .ranking-badge-opportunity {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.9rem;
      font-weight: 600;
    }
    .ranking-badge-opportunity--high { background: #dcfce7; color: #166534; } /* Green - High */
    .ranking-badge-opportunity--medium { background: #fef3c7; color: #92400e; } /* Amber - Medium */
    .ranking-badge-opportunity--low { background: #fee2e2; color: #b91c1c; } /* Red - Low */
    
    /* Page type badge styling (matching Money Pages matrix) */
    .ranking-badge-page-type {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 500;
    }
    .ranking-badge-page-type--landing { background: #fef3c7; color: #92400e; }
    .ranking-badge-page-type--event { background: #dbeafe; color: #1e40af; }
    .ranking-badge-page-type--product { background: #fce7f3; color: #9f1239; }
    .ranking-badge-page-type--blog { background: #e0f2fe; color: #075985; }
    .ranking-badge-page-type--gbp { background: #f5f3ff; color: #6d28d9; }

    /* Money Pages KPI trend arrow colors */
    .kpi-trend-up { color: #10b981; font-weight: 700; }
    .kpi-trend-down { color: #ef4444; font-weight: 700; }
    .kpi-trend-flat { color: #64748b; font-weight: 700; }

    /* Domain Strength (Ranking & AI) */
    .domain-strength-badge {
      display: inline-flex;
      padding: 0.125rem 0.375rem !important;
      font-size: 0.65rem !important;
      line-height: 1.2 !important;
      align-items: center;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 600;
      white-space: nowrap;
    }
    .domain-strength-badge--very-strong { background: #dcfce7; color: #166534; }
    .domain-strength-badge--strong { background: #ecfdf5; color: #059669; }
    .domain-strength-badge--moderate { background: #fef3c7; color: #92400e; }
    .domain-strength-badge--weak { background: #fde68a; color: #92400e; }
    .domain-strength-badge--very-weak { background: #fee2e2; color: #b91c1c; }
    .domain-strength-badge--na { background: #f9fafb; color: #6b7280; }

    .domain-strength-summary-row {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      align-items: stretch;
      margin-top: 1rem;
    }
    .domain-strength-summary-card {
      flex: 1 1 280px;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 1rem 1.25rem;
      min-width: 280px;
    }
    .domain-strength-summary-top {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .domain-strength-summary-score {
      font-size: 2rem;
      font-weight: 800;
      letter-spacing: -0.02em;
      color: #0f172a;
      line-height: 1;
    }
    .domain-strength-summary-subtitle {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #64748b;
      line-height: 1.45;
    }
    .domain-strength-legend {
      flex: 1 1 320px;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      align-content: flex-start;
      padding: 1rem 1.25rem;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      min-width: 280px;
    }
    .domain-strength-help {
      margin-left: 0.4rem;
      opacity: 0.7;
      cursor: help;
      font-size: 0.95rem;
      border: 1px solid rgba(100, 116, 139, 0.35);
      border-radius: 999px;
      width: 20px;
      height: 20px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      background: rgba(248, 250, 252, 0.8);
    }
    .domain-strength-sparkline {
      display: inline-block;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>GAIO (Generative AI Optimization) Audit Dashboard</h1>
    <p>Automated GAIO Performance Tracking & Optimisation</p>
    <p style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 1; background: rgba(0,0,0,0.3); padding: 0.25rem 0.5rem; border-radius: 4px; display: inline-block;">
      <strong>Version: <span id="gitVersion">Loading...</span></strong> | Built: <span id="buildDate"></span> |
      <span id="loadTime" style="color: #4f4;">Loaded: <span id="loadTimeValue"></span></span>
    </p>
    <script>
      // Set load time to current time (this is correct - it's when the page loaded)
      const now = new Date();
      document.getElementById('loadTimeValue').textContent = now.toLocaleTimeString();
      
      // Build date will be set by updateVersionPill function after fetching from API
      // For now, show loading state
      document.getElementById('buildDate').textContent = 'Loading...';
    </script>
  </div>

  <div class="aigeo-layout">
    <aside class="aigeo-sidebar">
      <button class="aigeo-nav-item" data-panel="config">
        <span class="aigeo-nav-icon"></span>
        <span>Configuration & Reporting</span>
      </button>
      <button class="aigeo-nav-item" data-panel="dashboard">
        <span class="aigeo-nav-icon"></span>
        <span>Dashboard</span>
      </button>
      <button class="aigeo-nav-item is-active" data-panel="overview">
        <span class="aigeo-nav-icon"></span>
        <span>AI Health Scorecard</span>
      </button>
      <button class="aigeo-nav-item" data-panel="portfolio">
        <span class="aigeo-nav-icon"></span>
        <span>Portfolio</span>
      </button>
      <button class="aigeo-nav-item" data-panel="authority">
        <span class="aigeo-nav-icon"></span>
        <span>Authority</span>
      </button>
      <button class="aigeo-nav-item" data-panel="money">
        <span class="aigeo-nav-icon"></span>
        <span>URL Money Pages</span>
      </button>
      <button class="aigeo-nav-item" data-panel="ranking">
        <span class="aigeo-nav-icon"></span>
        <span>Keyword Ranking and AI</span>
      </button>
      <button class="aigeo-nav-item" data-panel="optimisation">
        <span class="aigeo-nav-icon"></span>
        <span>Optimisation Tracking</span>
      </button>
      <button class="aigeo-nav-item" data-panel="ai-sources">
        <span class="aigeo-nav-icon"></span>
        <span>AI Sources & Influence</span>
      </button>
      <button class="aigeo-nav-item" data-panel="local">
        <span class="aigeo-nav-icon"></span>
        <span>Local & Reviews</span>
      </button>
      <button class="aigeo-nav-item" data-panel="history">
        <span class="aigeo-nav-icon"></span>
        <span>History</span>
      </button>
    </aside>
    <main class="aigeo-main">
  <div class="container">

    <div class="status" id="status"></div>

    <div class="loading" id="loading">
      <div class="progress-container">
        <div class="spinner"></div>
        <div class="progress-bar-wrapper">
          <div class="progress-bar" id="progressBar" style="width: 0%;">0%</div>
        </div>
        <div class="progress-status" id="progressStatus">Initializing audit scan...</div>
      </div>
    </div>

    <!-- Completion Summary Modal -->
    <div id="completionModal" class="modal" style="display: none;">
      <div class="modal-content" style="max-width: 600px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Audit Complete</h2>
          <button onclick="closeCompletionModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;" title="Close the audit completion summary modal">&times;</button>
        </div>
        <div id="completionSummaryContent"></div>
        <div style="margin-top: 1.5rem; text-align: right;">
          <button class="btn" onclick="closeCompletionModal()" style="background: var(--brand-orange); color: white; border-color: var(--brand-orange);" title="Close the audit completion summary modal and return to the dashboard">Close</button>
        </div>
      </div>
    </div>

    <!-- Bulk Update Results Modal -->
    <div id="optimisation-bulk-update-results-modal" class="modal" style="display: none;">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Bulk Update Complete</h2>
          <button onclick="closeBulkUpdateResultsModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;" title="Close">&times;</button>
        </div>
        <div id="bulk-update-results-content">
          <!-- Content will be populated by JavaScript -->
        </div>
        <div style="margin-top: 1.5rem; text-align: right;">
          <button class="btn" onclick="closeBulkUpdateResultsModal()" style="background: var(--brand-orange); color: white; border-color: var(--brand-orange);">Close</button>
        </div>
      </div>
    </div>

    <!-- Dashboard: Global Run Modal -->
    <div id="dashboardRunModal" class="modal" style="display: none; z-index: 1001;">
      <div class="modal-content" style="max-width: 500px; max-height: 90vh; overflow-y: auto; background: var(--dark-panel); color: var(--dark-text); border: 1px solid var(--dark-border); position: fixed; left: 20px; top: 5%; margin: 0;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
          <h2 style="margin: 0; color: var(--dark-brand);">Running Global Audit</h2>
          <button id="dashboardRunClose" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--dark-text-muted);" title="Close">&times;</button>
        </div>

        <div style="margin-bottom: 1rem;">
          <div style="width: 100%; height: 22px; background-color: rgba(148,163,184,0.25); border-radius: 999px; overflow: hidden; position: relative;">
            <div id="dashboardRunProgressFill" style="width: 0%; height: 100%; background: linear-gradient(90deg, var(--dark-brand), #ff8c42); transition: width 0.25s ease;"></div>
          </div>
          <div id="dashboardRunProgressText" style="margin-top: 0.5rem; text-align: center; font-size: 0.9rem; color: var(--dark-text-muted); font-weight: 600;">0%</div>
        </div>

        <div id="dashboardRunCurrentStep" style="font-size: 1rem; font-weight: 700; margin-bottom: 0.5rem;">Initializing</div>
        <div id="dashboardRunNarrative" style="font-size: 0.95rem; color: var(--dark-text-muted); line-height: 1.5; margin-bottom: 0.5rem;">Preparing to run all audits and updates.</div>
        <div id="dashboardRunTimeInfo" style="font-size: 0.85rem; color: var(--dark-text-muted); margin-bottom: 1rem;">
          <div>Elapsed: <span id="dashboardRunElapsedTime">0:00</span></div>
          <div style="margin-top: 0.25rem;">Current step: <span id="dashboardRunStepTime">0:00</span></div>
        </div>

        <div style="border-top: 1px solid var(--dark-border); padding-top: 1rem;">
          <div style="font-size: 0.8rem; font-weight: 700; color: var(--dark-text-muted); margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Steps</div>
          <div id="dashboardRunStepsList" style="display: flex; flex-direction: column; gap: 0.5rem;"></div>
        </div>

        <div id="dashboardRunSummary" style="display: none; border-top: 2px solid #10b981; padding-top: 1rem; margin-top: 1rem;">
          <div style="font-weight: 800; color: #10b981; margin-bottom: 0.5rem;"> Global run complete</div>
          <div id="dashboardRunSummaryContent" style="color: var(--dark-text); font-size: 0.95rem;"></div>
          <div style="margin-top: 1rem; text-align: right;">
            <button id="dashboardRunCloseBottom" class="btn" style="background: var(--brand-orange); color: white; border-color: var(--brand-orange); padding: 0.5rem 1.5rem; font-size: 0.9rem; font-weight: 600; cursor: pointer;" title="Close the global audit modal">Close</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Ranking & AI Progress Modal -->
    <div id="rankingAiProgressModal" class="modal" style="display: none; z-index: 1002;">
      <div class="modal-content" style="max-width: 700px; position: fixed; right: 20px; top: 5%; margin: 0;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Running Ranking & AI Check</h2>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <button id="rankingAiProgressStop" style="display: none; padding: 0.5rem 1rem; background: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 600;" title="Stop the scan">Stop Scan</button>
            <button id="rankingAiProgressClose" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666; opacity: 0.5;" disabled title="Cannot close during processing">&times;</button>
          </div>
        </div>
        
        <!-- Keyword Count Display (shown before scan starts) -->
        <div id="rankingAiKeywordCount" style="display: none; margin-bottom: 1rem; padding: 1rem; background: #fef3c7; border: 1px solid #fbbf24; border-radius: 6px;">
          <div style="font-weight: 600; color: #92400e; margin-bottom: 0.5rem;">Ready to scan:</div>
          <div style="font-size: 1.2rem; font-weight: 700; color: #78350f;" id="rankingAiKeywordCountValue">0 keywords</div>
          <div style="font-size: 0.85rem; color: #78350f; margin-top: 0.5rem;">Click "Start Scan" below to begin, or close this modal to cancel.</div>
        </div>
        
        <!-- Progress Bar -->
        <div style="margin-bottom: 2rem;">
          <div id="rankingAiProgressBar" style="width: 100%; height: 24px; background-color: #e5e7eb; border-radius: 12px; overflow: hidden; position: relative;">
            <div id="rankingAiProgressFill" style="width: 0%; height: 100%; background: linear-gradient(90deg, var(--brand-orange), #ff8c42); transition: width 0.3s ease; border-radius: 12px;"></div>
          </div>
          <div id="rankingAiProgressText" style="margin-top: 0.5rem; text-align: center; font-size: 0.9rem; color: #6b7280; font-weight: 500;">0%</div>
        </div>

        <!-- Step Details -->
        <div id="rankingAiStepDetails" style="margin-bottom: 1.5rem;">
          <div id="rankingAiCurrentStep" style="font-size: 1.1rem; font-weight: 600; color: #1f2937; margin-bottom: 0.75rem;">
            Initializing...
          </div>
          <div id="rankingAiStepNarrative" style="font-size: 0.95rem; color: #6b7280; line-height: 1.6; margin-bottom: 1rem;">
            Preparing to fetch ranking and AI data...
          </div>
          <div id="rankingAiStepCounts" style="font-size: 0.9rem; color: #9ca3af; font-style: italic;">
            <!-- Counts will be populated here -->
          </div>
        </div>

        <!-- Step List -->
        <div style="border-top: 1px solid #e5e7eb; padding-top: 1rem;">
          <div style="font-size: 0.85rem; font-weight: 600; color: #6b7280; margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Progress Steps</div>
          <div id="rankingAiStepsList" style="display: flex; flex-direction: column; gap: 0.5rem;">
            <!-- Steps will be populated here -->
          </div>
        </div>

        <!-- Completion Summary (hidden by default) -->
        <div id="rankingAiSummary" style="display: none; border-top: 2px solid #10b981; padding-top: 1.5rem; margin-top: 1.5rem;">
          <h3 style="margin: 0 0 1rem 0; color: #10b981; font-size: 1.2rem; font-weight: 600;"> Scan Complete</h3>
          <div id="rankingAiSummaryContent" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; font-size: 0.95rem;">
            <!-- Summary content will be populated here -->
          </div>
        </div>
      </div>
    </div>

    <div id="dashboard" style="display: none;">
      <div id="auditTimestamp" style="background: #e8f5e9; padding: 0.75rem 1rem; border-radius: 6px; margin-bottom: 1rem; border-left: 4px solid #10b981; font-size: 0.9rem; color: #555; display: flex; flex-wrap: wrap; gap: 1rem; align-items: center;">
        <div><strong>GSC Audit Date:</strong> <span id="gscAuditDate">Not yet run</span></div>
        <div style="font-size: 0.85rem; color: #666;"><strong>GSC 28 Day Date Range:</strong> <span id="gscDateRange">-</span></div>
        <div><strong>Ranking & AI Date:</strong> <span id="rankingAiAuditDate">Not yet run</span></div>
      </div>

      <!-- Configuration & Reporting Panel -->
      <section class="aigeo-panel" data-panel="config">
    <div class="config-panel">
      <h2>Configuration</h2>
      <div class="info-box" style="background: #e8f4f8; border-left: 4px solid #2196F3; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #1565C0;"><strong>Entity-Level Audit:</strong> This dashboard analyzes <strong>www.alanranger.com</strong> as a global entity, tracking AI-powered search visibility, entity recognition, and SERP behavior across the entire domain.</p>
      </div>
      <div class="form-group">
        <label for="propertyUrl">Property URL</label>
        <input type="text" id="propertyUrl" placeholder="https://yourwebsite.com" value="https://www.alanranger.com">
        <div class="help-text">The domain being audited (entity-level analysis)</div>
      </div>
      <div style="background: #f0f0f0; padding: 0.75rem; border-radius: 4px; margin-bottom: 1rem; font-size: 0.85rem; color: #555;">
        <strong>API Key:</strong> Loaded automatically from Vercel environment variables. No manual entry required.
      </div>
      <!-- Manual URL List Section (Collapsible) -->
      <div class="csv-upload-section collapsed" id="urlListSection">
        <div class="csv-section-header" onclick="toggleCsvSection('urlListSection')">
          <h3>Manual URL List (Optional)</h3>
          <span class="csv-section-toggle" id="urlListToggle"></span>
        </div>
        <div class="csv-section-content collapsed" id="urlListContent">
          <div class="form-group" style="margin-bottom: 0;">
        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">
          Load list of site URLs from a CSV file
        </div>
        <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
          <input type="file" id="urlListFile" accept=".csv" style="flex: 1; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem;">
              <button class="btn btn-small" onclick="loadUrlListFromFile()" style="padding: 0.5rem 1rem;" title="Load a CSV file containing site URLs. The CSV must have a 'url' column in the header row. URLs will be used for schema audit instead of the default CSV source.">Load CSV</button>
              <button class="btn btn-small" onclick="clearManualUrlList()" style="padding: 0.5rem 1rem; background: #ef4444; color: white; border-color: #ef4444;" title="Clear the manually loaded URL list and revert to using the default CSV source for schema audit">Clear</button>
        </div>
        <textarea id="manualUrlList" placeholder="Or paste CSV content here (must include 'url' column in header row)..." style="width: 100%; min-height: 100px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace; resize: vertical;"></textarea>
        <div class="help-text">
          <strong>Required column:</strong> <code>url</code> (case-insensitive). CSV must have a header row. URLs will be extracted from the 'url' column.
        </div>
        <div id="urlListStatus" style="margin-top: 0.5rem; font-size: 0.85rem;"></div>
          </div>
        </div>
      </div>
      
      <!-- Backlink CSV Upload Section (Collapsible) -->
      <div class="csv-upload-section collapsed" id="backlinkCsvSection">
        <div class="csv-section-header" onclick="toggleCsvSection('backlinkCsvSection')">
          <h3>Backlink CSV Upload (Optional)</h3>
          <span class="csv-section-toggle" id="backlinkCsvToggle"></span>
        </div>
        <div class="csv-section-content collapsed" id="backlinkCsvContentWrapper">
          <div class="form-group" style="margin-bottom: 0;">
            <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">
              Upload backlink data CSV file for Authority score calculation. Can be uploaded independently of site URLs CSV.
            </div>
            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
              <input type="file" id="backlinkCsvFile" accept=".csv" style="flex: 1; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem;">
                  <button class="btn btn-small" onclick="loadBacklinkCsvFromFile()" style="padding: 0.5rem 1rem;" title="Load a CSV file containing backlink data. The CSV must have 'source_url' and 'target_url' columns in the header row. Backlinks will be used for Authority score calculation.">Load CSV</button>
                  <button class="btn btn-small" onclick="clearBacklinkCsv()" style="padding: 0.5rem 1rem; background: #ef4444; color: white; border-color: #ef4444;" title="Clear the backlink CSV data">Clear</button>
            </div>
                <textarea id="backlinkCsvContent" placeholder="Or paste CSV content here (must include 'source_url' and 'target_url' columns in header row)..." style="width: 100%; min-height: 100px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace; resize: vertical;"></textarea>
            <div class="help-text">
                  <strong>Required columns:</strong> <code>source_url</code> and <code>target_url</code> (case-insensitive). CSV must have a header row. Backlinks will be extracted from these columns.
            </div>
            <div id="backlinkCsvStatus" style="margin-top: 0.5rem; font-size: 0.85rem;"></div>
          </div>
        </div>
      </div>
          
          <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-top: 1.5rem;">
        <button class="btn" onclick="runAudit()" title="Start a GSC & Backlink audit scan. Fetches Google Search Console data and uses backlink data (if backlink CSV uploaded). Results will appear in the dashboard below.">GSC & Backlink Audit</button>
            <button class="btn btn-secondary" onclick="shareAudit()" title="Generate a shareable link to your current audit results. The link will allow others to view your audit data without running a new scan.">Share Audit</button>
        <button class="btn btn-secondary" onclick="saveConfig()" title="Save your current configuration (property URL and date range) to browser localStorage. Settings will be restored when you reload the page.">Save Configuration</button>
            <button class="btn btn-success" onclick="syncCsv()" title="Sync CSV data from the configured source. This will update your URL list and backlink data from the remote CSV file.">Sync CSV</button>
      </div>
    </div>

    <!-- Share Mode Banner (read-only) -->
    <div id="share-mode-banner" class="config-panel" style="margin-top: 2rem; display: none; background: #fef3c7; border-left: 4px solid #f59e0b; padding: 1rem; border-radius: 4px;">
      <div style="display: flex; align-items: center; gap: 0.5rem;">
        <span style="font-size: 1.25rem;"></span>
        <strong style="color: #92400e;">Shared view (read-only)</strong>
        <span style="color: #92400e; font-size: 0.9rem;"> You can view all data but cannot make changes</span>
      </div>
    </div>

    <!-- Admin Key Configuration (Phase A - Security) -->
    <div id="admin-key-panel" class="config-panel" style="margin-top: 2rem;">
      <h2>Optimisation Tracking Security</h2>
      <div class="info-box" style="background: #e0f2fe; border-left: 4px solid #0284c7; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #0c4a6e;">
          <strong>Admin Key Required:</strong> Set your admin key to enable optimisation tracking actions (Track, Manage, Cycle). 
          The key is stored in your browser session and sent with API requests.
        </p>
      </div>
      <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-bottom: 1rem;">
        <input 
          type="password" 
          id="admin-key-input" 
          placeholder="Enter admin key (32+ characters)" 
          style="flex: 1; min-width: 300px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace;"
          value=""
        />
        <button 
          class="btn" 
          onclick="saveAdminKey()" 
          title="Save admin key to session storage. Required for optimisation tracking actions."
        >
          Save Admin Key
        </button>
        <button 
          class="btn btn-secondary" 
          onclick="clearAdminKeyUI()" 
          title="Clear admin key from session storage."
        >
          Clear
        </button>
      </div>
      <div id="admin-key-status" style="font-size: 0.85rem; color: #64748b; margin-top: 0.5rem;"></div>
      <script>
        // Share mode initialization
        (function() {
          const urlParams = new URLSearchParams(window.location.search);
          const isShare = urlParams.get('share') === '1';
          const shareToken = urlParams.get('st') || '';
          
          if (isShare) {
            // Hide admin key panel
            const adminPanel = document.getElementById('admin-key-panel');
            if (adminPanel) adminPanel.style.display = 'none';
            
            // Show share mode banner
            const shareBanner = document.getElementById('share-mode-banner');
            if (shareBanner) shareBanner.style.display = 'block';
            
            // Disable write buttons
            window.addEventListener('DOMContentLoaded', function() {
              // Disable audit scan, sync CSV, save config buttons
              const writeButtons = document.querySelectorAll('[onclick="runAudit()"], [onclick="syncCsv()"], [onclick="saveConfig()"]');
              writeButtons.forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
                btn.title = 'Not available in share mode (read-only)';
              });
              
              // Disable Optimisation Tracking write buttons
              const bulkUpdateBtn = document.getElementById('optimisation-bulk-update-btn');
              if (bulkUpdateBtn) {
                bulkUpdateBtn.disabled = true;
                bulkUpdateBtn.style.opacity = '0.5';
                bulkUpdateBtn.style.cursor = 'not-allowed';
                bulkUpdateBtn.title = 'Not available in share mode (read-only)';
              }
            });
          }
        })();
        
        // Admin key UI functions
        function saveAdminKey() {
          const input = document.getElementById('admin-key-input');
          const key = input.value.trim();
          if (!key) {
            alert('Please enter an admin key');
            return;
          }
          if (key.length < 32) {
            if (!confirm('Admin key should be at least 32 characters. Save anyway?')) {
              return;
            }
          }
          window.setAdminKey(key);
          updateAdminKeyStatus();
          input.value = ''; // Clear input for security
          
          // Clear auth error and reload optimisation tasks if on that tab
          if (window.optimisationModuleState) {
            window.optimisationModuleState.authError = null;
            const optimisationTab = document.querySelector('[data-panel="optimisation"]');
            if (optimisationTab && optimisationTab.classList.contains('is-active')) {
              if (typeof window.loadAllOptimisationTasks === 'function') {
                window.loadAllOptimisationTasks();
              }
            }
          }
          
          // Re-render Ranking & AI table to enable Track buttons
          // Check if Ranking & AI tab is active
          const rankingTab = document.querySelector('[data-panel="ranking"]');
          if (rankingTab && rankingTab.classList.contains('is-active')) {
            // Tab is active, try to refresh the table
            if (typeof renderRankingAiTab === 'function') {
              renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
            } else if (typeof window.renderRankingAiTab === 'function') {
              window.renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
            } else {
              // Fallback: reload the page
              if (confirm('Admin key saved! Refresh the page to enable Track buttons?')) {
                // Preserve current tab state before reload
                const currentPanel = document.querySelector('.aigeo-panel.is-active');
                if (currentPanel) {
                  const panelId = currentPanel.dataset.panel;
                  sessionStorage.setItem('activeTab', panelId);
                  window.location.hash = '#' + panelId;
                }
                location.reload();
              }
            }
          } else {
            alert('Admin key saved! Switch to the "Ranking & AI" tab to see enabled Track buttons.');
          }
        }

        function clearAdminKeyUI() {
          if (confirm('Clear admin key? Optimisation tracking actions will be disabled.')) {
            window.clearAdminKey();
            document.getElementById('admin-key-input').value = '';
            updateAdminKeyStatus();
            
            // Re-render Ranking & AI table to disable Track buttons
            const rankingTab = document.querySelector('[data-panel="ranking"]');
            if (rankingTab && rankingTab.classList.contains('is-active')) {
              if (typeof renderRankingAiTab === 'function') {
                renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
              } else if (typeof window.renderRankingAiTab === 'function') {
                window.renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
              }
            }
          }
        }

        function updateAdminKeyStatus() {
          const statusEl = document.getElementById('admin-key-status');
          if (!statusEl) return;
          
          // Safety check: ensure hasAdminKey function is loaded
          if (typeof window.hasAdminKey !== 'function') {
            // Retry after a short delay if function not yet loaded
            setTimeout(() => {
              if (typeof window.hasAdminKey === 'function') {
                updateAdminKeyStatus();
              } else {
                // If still not loaded after retry, show warning
                statusEl.innerHTML = '<span style="color: #f59e0b;"> Loading admin key functions...</span>';
                // Try one more time after longer delay
                setTimeout(() => {
                  if (typeof window.hasAdminKey === 'function') {
                    updateAdminKeyStatus();
                  } else {
                    statusEl.innerHTML = '<span style="color: #ef4444;"> Admin key functions not loaded  please refresh the page</span>';
                  }
                }, 1000);
              }
            }, 100);
            return;
          }
          
          const hasKey = window.hasAdminKey();
          if (hasKey) {
            const key = window.getAdminKey();
            statusEl.innerHTML = `<span style="color: #10b981;"> Admin key set</span> (${key.length} characters, stored in session)`;
          } else {
            statusEl.innerHTML = '<span style="color: #ef4444;"> Admin key not set  tracking actions disabled</span>';
          }
        }

        // Update status on load
        if (typeof window !== 'undefined' && document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', updateAdminKeyStatus);
        } else {
          updateAdminKeyStatus();
        }
      </script>
    </div>

    <div class="config-panel" style="margin-top: 2rem;">
      <h2>Reporting</h2>
      <div class="info-box" style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #856404;"><strong>Generate Reports:</strong> Create comprehensive PDF reports containing all audit data, charts, and pillar score definitions.</p>
      </div>
      <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
        <button class="btn" onclick="try { console.log('[PDF] Button clicked!'); generatePDFReport(); } catch(e) { console.error('[PDF] Error in onclick:', e); alert('Error generating PDF: ' + e.message); }" id="generatePdfBtn" style="background: #dc2626; color: white; border-color: #dc2626;" title="Generate a comprehensive PDF report containing all audit data, charts, pillar scores, definitions, and metrics. The report will include all sections from the dashboard.">
           Generate PDF Report
        </button>
        <div id="pdfStatus" style="font-size: 0.85rem; color: #666; margin-left: 0.5rem;"></div>
      </div>
    </div>

    <div class="config-panel" id="audit-scheduler-panel" style="margin-top: 2rem;">
      <h2>Audits Scheduler</h2>
      <div class="info-box" style="background: #e0f2fe; border-left: 4px solid #0284c7; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #0c4a6e;">
          <strong>Automation:</strong> Set frequency and time (GMT) for each audit. Turning a job to <strong>Off</strong> pauses it.
        </p>
      </div>
      <div style="overflow-x: auto;">
        <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
          <thead>
            <tr style="background: #f8fafc; border-bottom: 1px solid #e2e8f0;">
              <th style="text-align: left; padding: 0.75rem;">Job</th>
              <th style="text-align: left; padding: 0.75rem;">Frequency</th>
              <th style="text-align: left; padding: 0.75rem;">Time (GMT)</th>
              <th style="text-align: left; padding: 0.75rem;">Last Run</th>
              <th style="text-align: left; padding: 0.75rem;">Status</th>
              <th style="text-align: left; padding: 0.75rem;">Next Scheduled</th>
            </tr>
          </thead>
          <tbody>
            <tr style="border-bottom: 1px solid #e2e8f0;">
              <td style="padding: 0.75rem; font-weight: 600;">GSC + Backlinks Audit</td>
              <td style="padding: 0.75rem;">
                <select id="scheduler-gsc-frequency" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px;">
                  <option value="off">Off</option>
                  <option value="daily">Daily</option>
                  <option value="weekly">Weekly</option>
                  <option value="monthly">Monthly</option>
                </select>
              </td>
              <td style="padding: 0.75rem;">
                <input id="scheduler-gsc-time" type="time" step="60" style="padding: 0.35rem 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px;">
              </td>
              <td style="padding: 0.75rem;" id="scheduler-gsc-last"></td>
              <td style="padding: 0.75rem;" id="scheduler-gsc-status"></td>
              <td style="padding: 0.75rem;" id="scheduler-gsc-next"></td>
            </tr>
            <tr style="border-bottom: 1px solid #e2e8f0;">
              <td style="padding: 0.75rem; font-weight: 600;">Keyword Ranking &amp; AI Audit</td>
              <td style="padding: 0.75rem;">
                <select id="scheduler-ranking-frequency" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px;">
                  <option value="off">Off</option>
                  <option value="daily">Daily</option>
                  <option value="weekly">Weekly</option>
                  <option value="monthly">Monthly</option>
                </select>
              </td>
              <td style="padding: 0.75rem;">
                <input id="scheduler-ranking-time" type="time" step="60" style="padding: 0.35rem 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px;">
              </td>
              <td style="padding: 0.75rem;" id="scheduler-ranking-last"></td>
              <td style="padding: 0.75rem;" id="scheduler-ranking-status"></td>
              <td style="padding: 0.75rem;" id="scheduler-ranking-next"></td>
            </tr>
            <tr style="border-bottom: 1px solid #e2e8f0;">
              <td style="padding: 0.75rem; font-weight: 600;">Global Dashboard Run</td>
              <td style="padding: 0.75rem;">
                <select id="scheduler-global-frequency" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px;">
                  <option value="off">Off</option>
                  <option value="daily">Daily</option>
                  <option value="weekly">Weekly</option>
                  <option value="monthly">Monthly</option>
                </select>
              </td>
              <td style="padding: 0.75rem;">
                <input id="scheduler-global-time" type="time" step="60" style="padding: 0.35rem 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px;">
              </td>
              <td style="padding: 0.75rem;" id="scheduler-global-last"></td>
              <td style="padding: 0.75rem;" id="scheduler-global-status"></td>
              <td style="padding: 0.75rem;" id="scheduler-global-next"></td>
            </tr>
          </tbody>
        </table>
      </div>
      <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-top: 1rem;">
        <button class="btn" id="scheduler-save-btn" title="Save scheduler settings for all cron jobs.">Save Scheduler</button>
        <button class="btn btn-secondary" id="scheduler-refresh-btn" title="Refresh last run / next scheduled times.">Refresh Status</button>
        <div id="scheduler-status" style="font-size: 0.85rem; color: #666;"></div>
      </div>
      <div id="audit-coverage-map" style="margin-top: 1.5rem;">
        <h3 style="margin: 0 0 0.5rem 0;">Audit Coverage Map</h3>
        <style>
          #audit-coverage-map th {
            white-space: normal;
            line-height: 1.2;
          }
          #audit-coverage-map tbody span {
            font-size: 1rem;
            font-weight: 800;
          }
        </style>
        <div class="info-box" style="background: #f8fafc; border-left: 4px solid #94a3b8; padding: 0.75rem 1rem; margin-bottom: 0.75rem; border-radius: 4px;">
          <p style="margin: 0; font-size: 0.85rem; color: #475569;">
            This map shows which processes update which data. Use it to pick cron frequencies and to spot gaps.
          </p>
          <p style="margin: 0.35rem 0 0; font-size: 0.8rem; color: #64748b;">
            Legend: <span style="color: #16a34a; font-weight: 800;"></span> full update, <span style="color: #64748b; font-weight: 800;">-</span> not touched, <span style="color: #f97316; font-weight: 800;">Refresh</span> refresh/inputs only
          </p>
        </div>

        <h4 style="margin: 0 0 0.5rem 0;">Cron Jobs</h4>
        <div style="overflow-x: auto; margin-bottom: 1rem;">
          <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
            <thead>
              <tr style="background: #f1f5f9; border-bottom: 1px solid #e2e8f0;">
                <th style="text-align: left; padding: 0.6rem; min-width: 160px;">Module / Tab</th>
                <th style="text-align: left; padding: 0.6rem; min-width: 220px;">Cron Job</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 110px;">GSC<br>Data</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 110px;">Back<br>links</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 120px;">Local<br>Signals</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 110px;">Reviews</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 120px;">Schema<br>Audit</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 120px;">Ranking<br>&amp; AI</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 120px;">Money<br>Pages</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 130px;">Domain<br>Strength</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 120px;">Pillar<br>Scores</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 120px;">Task<br>Updates</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 100px;">CSV<br>Sync</th>
              </tr>
            </thead>
            <tbody>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Cron Scheduler</td>
                <td style="padding: 0.6rem; font-weight: 600;">GSC + Backlinks</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #64748b; font-weight: 700;">-</span></td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Cron Scheduler</td>
                <td style="padding: 0.6rem; font-weight: 600;">Keyword Ranking &amp; AI</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Cron Scheduler</td>
                <td style="padding: 0.6rem; font-weight: 600;">Global Dashboard Run</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #64748b; font-weight: 700;">-</span></td>
              </tr>
            </tbody>
          </table>
        </div>

        <h4 style="margin: 0 0 0.5rem 0;">Manual Buttons</h4>
        <div style="overflow-x: auto;">
          <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
            <thead>
              <tr style="background: #f1f5f9; border-bottom: 1px solid #e2e8f0;">
                <th style="text-align: left; padding: 0.6rem; min-width: 190px;">Module / Tab</th>
                <th style="text-align: left; padding: 0.6rem; min-width: 240px;">Button</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 110px;">GSC<br>Data</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 110px;">Back<br>links</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 120px;">Local<br>Signals</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 110px;">Reviews</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 120px;">Schema<br>Audit</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 120px;">Ranking<br>&amp; AI</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 120px;">Money<br>Pages</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 130px;">Domain<br>Strength</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 120px;">Pillar<br>Scores</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 120px;">Task<br>Updates</th>
                <th style="text-align: center; padding: 0.6rem; min-width: 100px;">CSV<br>Sync</th>
              </tr>
            </thead>
            <tbody>
              <tr style="background: #e2e8f0; border-top: 2px solid #cbd5f5; border-bottom: 2px solid #cbd5f5;">
                <td colspan="13" style="padding: 0.5rem 0.6rem; font-weight: 700; color: #0f172a; letter-spacing: 0.02em;">Configuration &amp; Reporting</td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Configuration &amp; Reporting</td>
                <td style="padding: 0.6rem; font-weight: 600;">GSC &amp; Backlink Audit</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Configuration &amp; Reporting</td>
                <td style="padding: 0.6rem; font-weight: 600;">Sync CSV</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #64748b; font-weight: 700;">-</span></td>
              </tr>
              <tr style="background: #e2e8f0; border-top: 2px solid #cbd5f5; border-bottom: 2px solid #cbd5f5;">
                <td colspan="13" style="padding: 0.5rem 0.6rem; font-weight: 700; color: #0f172a; letter-spacing: 0.02em;">Dashboard</td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Dashboard</td>
                <td style="padding: 0.6rem; font-weight: 600;"> Run All Audits &amp; Updates</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #64748b; font-weight: 700;">-</span></td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Dashboard (Keyword Ranking and AI card)</td>
                <td style="padding: 0.6rem; font-weight: 600;">Run scan</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Dashboard (URL Money Pages card)</td>
                <td style="padding: 0.6rem; font-weight: 600;">Run scan</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #64748b; font-weight: 700;">-</span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Dashboard (Domain Strength card)</td>
                <td style="padding: 0.6rem; font-weight: 600;">Run snapshot</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
              </tr>
              <tr style="background: #e2e8f0; border-top: 2px solid #cbd5f5; border-bottom: 2px solid #cbd5f5;">
                <td colspan="13" style="padding: 0.5rem 0.6rem; font-weight: 700; color: #0f172a; letter-spacing: 0.02em;">Keyword Ranking and AI</td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Keyword Ranking and AI</td>
                <td style="padding: 0.6rem; font-weight: 600;">Run Domain Strength Snapshot (Google)</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Keyword Ranking and AI</td>
                <td style="padding: 0.6rem; font-weight: 600;">Run ranking &amp; AI check</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Keyword Ranking and AI</td>
                <td style="padding: 0.6rem; font-weight: 600;">Refresh GSC Data</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #64748b; font-weight: 700;">-</span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Keyword Ranking and AI</td>
                <td style="padding: 0.6rem; font-weight: 600;">Backfill Missing Ranks</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
              </tr>
              <tr style="background: #e2e8f0; border-top: 2px solid #cbd5f5; border-bottom: 2px solid #cbd5f5;">
                <td colspan="13" style="padding: 0.5rem 0.6rem; font-weight: 700; color: #0f172a; letter-spacing: 0.02em;">Optimisation Tracking</td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Optimisation Tracking</td>
                <td style="padding: 0.6rem; font-weight: 600;"> Update All Tasks with Latest Data</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Optimisation Tracking (Table)</td>
                <td style="padding: 0.6rem; font-weight: 600;">Update</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Optimisation Tracking (Task drawer)</td>
                <td style="padding: 0.6rem; font-weight: 600;">Add Measurement</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Optimisation Tracking (Task drawer)</td>
                <td style="padding: 0.6rem; font-weight: 600;">Rebaseline</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
              </tr>
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.6rem; font-weight: 600;">Optimisation Tracking</td>
                <td style="padding: 0.6rem; font-weight: 600;"> Rebaseline Incomplete Baselines</td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #16a34a; font-weight: 700;"></span></td>
                <td style="text-align: center; padding: 0.6rem;"><span style="color: #dc2626; font-weight: 700;"></span></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <script>
        (function normalizeAuditCoverageMap() {
          const map = document.getElementById('audit-coverage-map');
          if (!map) return;
          map.querySelectorAll('tbody span').forEach((span) => {
            const value = span.textContent.trim();
            if (value === '') {
              span.textContent = '-';
              span.style.color = '#64748b';
            } else if (value === '-') {
              span.textContent = 'Refresh';
              span.style.color = '#f97316';
            }
          });
        })();
      </script>
    </div>
    <script>
      (function initAuditScheduler() {
        const JOB_KEYS = {
          gsc: 'gsc_backlinks',
          ranking: 'ranking_ai',
          global: 'global_run'
        };

        const DEFAULTS = {
          [JOB_KEYS.gsc]: { frequency: 'daily', timeOfDay: '11:00' },
          [JOB_KEYS.ranking]: { frequency: 'weekly', timeOfDay: '11:10' },
          [JOB_KEYS.global]: { frequency: 'weekly', timeOfDay: '11:20' }
        };

        const formatUtc = (value) => {
          if (!value) return '';
          const dt = new Date(value);
          if (isNaN(dt.getTime())) return '';
          return dt.toLocaleString('en-GB', {
            timeZone: 'UTC',
            day: '2-digit',
            month: 'short',
            year: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            hour12: false
          }) + ' GMT';
        };

        const parseTime = (value) => {
          if (!value || !/^\d{2}:\d{2}$/.test(value)) return null;
          const [h, m] = value.split(':').map(v => parseInt(v, 10));
          if (Number.isNaN(h) || Number.isNaN(m)) return null;
          return { hours: h, minutes: m };
        };

        const computeNextRun = ({ frequency, timeOfDay, lastRunAt }, now = new Date()) => {
          if (!frequency || frequency === 'off') return null;
          const time = parseTime(timeOfDay);
          if (!time) return null;
          const candidate = new Date(Date.UTC(
            now.getUTCFullYear(),
            now.getUTCMonth(),
            now.getUTCDate(),
            time.hours,
            time.minutes,
            0,
            0
          ));

          const addMonths = (date, months) => {
            const d = new Date(date);
            const day = d.getUTCDate();
            d.setUTCMonth(d.getUTCMonth() + months);
            const maxDay = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth() + 1, 0)).getUTCDate();
            d.setUTCDate(Math.min(day, maxDay));
            return d;
          };

          if (!lastRunAt) {
            if (frequency === 'daily') {
              if (candidate <= now) candidate.setUTCDate(candidate.getUTCDate() + 1);
              return candidate.toISOString();
            }
            if (frequency === 'weekly') {
              if (candidate <= now) candidate.setUTCDate(candidate.getUTCDate() + 7);
              return candidate.toISOString();
            }
            if (frequency === 'monthly') {
              return (candidate <= now ? addMonths(candidate, 1) : candidate).toISOString();
            }
            return null;
          }

          const last = new Date(lastRunAt);
          if (frequency === 'daily') {
            if (candidate <= now) candidate.setUTCDate(candidate.getUTCDate() + 1);
            return candidate.toISOString();
          }
          if (frequency === 'weekly') {
            const weekly = new Date(last);
            weekly.setUTCHours(time.hours, time.minutes, 0, 0);
            weekly.setUTCDate(weekly.getUTCDate() + 7);
            return weekly.toISOString();
          }
          if (frequency === 'monthly') {
            const monthly = new Date(last);
            monthly.setUTCHours(time.hours, time.minutes, 0, 0);
            return addMonths(monthly, 1).toISOString();
          }
          return null;
        };

        const statusEl = document.getElementById('scheduler-status');
        const apiBase = typeof window.apiUrl === 'function' ? window.apiUrl('') : '';
        const schedulerApiUrl = (path) => apiBase ? apiBase + path : path;

        const readForm = () => ({
          [JOB_KEYS.gsc]: {
            frequency: document.getElementById('scheduler-gsc-frequency')?.value || 'off',
            timeOfDay: document.getElementById('scheduler-gsc-time')?.value || ''
          },
          [JOB_KEYS.ranking]: {
            frequency: document.getElementById('scheduler-ranking-frequency')?.value || 'off',
            timeOfDay: document.getElementById('scheduler-ranking-time')?.value || ''
          },
          [JOB_KEYS.global]: {
            frequency: document.getElementById('scheduler-global-frequency')?.value || 'off',
            timeOfDay: document.getElementById('scheduler-global-time')?.value || ''
          }
        });

        const applyForm = (jobs) => {
          const gsc = jobs[JOB_KEYS.gsc] || DEFAULTS[JOB_KEYS.gsc];
          const ranking = jobs[JOB_KEYS.ranking] || DEFAULTS[JOB_KEYS.ranking];
          const global = jobs[JOB_KEYS.global] || DEFAULTS[JOB_KEYS.global];
          const gscFreq = document.getElementById('scheduler-gsc-frequency');
          const gscTime = document.getElementById('scheduler-gsc-time');
          const rankingFreq = document.getElementById('scheduler-ranking-frequency');
          const rankingTime = document.getElementById('scheduler-ranking-time');
          const globalFreq = document.getElementById('scheduler-global-frequency');
          const globalTime = document.getElementById('scheduler-global-time');
          if (gscFreq) gscFreq.value = gsc.frequency || DEFAULTS[JOB_KEYS.gsc].frequency;
          if (gscTime) gscTime.value = gsc.timeOfDay || DEFAULTS[JOB_KEYS.gsc].timeOfDay;
          if (rankingFreq) rankingFreq.value = ranking.frequency || DEFAULTS[JOB_KEYS.ranking].frequency;
          if (rankingTime) rankingTime.value = ranking.timeOfDay || DEFAULTS[JOB_KEYS.ranking].timeOfDay;
          if (globalFreq) globalFreq.value = global.frequency || DEFAULTS[JOB_KEYS.global].frequency;
          if (globalTime) globalTime.value = global.timeOfDay || DEFAULTS[JOB_KEYS.global].timeOfDay;
        };

        const renderSchedule = (jobs) => {
          const gsc = jobs[JOB_KEYS.gsc] || {};
          const ranking = jobs[JOB_KEYS.ranking] || {};
          const global = jobs[JOB_KEYS.global] || {};
          document.getElementById('scheduler-gsc-last').textContent = formatUtc(gsc.lastRunAt);
          const gscStatusEl = document.getElementById('scheduler-gsc-status');
          if (gscStatusEl) {
            gscStatusEl.textContent = gsc.lastStatus ? String(gsc.lastStatus) : '';
            gscStatusEl.title = gsc.lastError || '';
          }
          document.getElementById('scheduler-gsc-next').textContent = formatUtc(gsc.nextRunAt || computeNextRun(gsc));
          document.getElementById('scheduler-ranking-last').textContent = formatUtc(ranking.lastRunAt);
          const rankingStatusEl = document.getElementById('scheduler-ranking-status');
          if (rankingStatusEl) {
            rankingStatusEl.textContent = ranking.lastStatus ? String(ranking.lastStatus) : '';
            rankingStatusEl.title = ranking.lastError || '';
          }
          document.getElementById('scheduler-ranking-next').textContent = formatUtc(ranking.nextRunAt || computeNextRun(ranking));
          document.getElementById('scheduler-global-last').textContent = formatUtc(global.lastRunAt);
          const globalStatusEl = document.getElementById('scheduler-global-status');
          if (globalStatusEl) {
            globalStatusEl.textContent = global.lastStatus ? String(global.lastStatus) : '';
            globalStatusEl.title = global.lastError || '';
          }
          document.getElementById('scheduler-global-next').textContent = formatUtc(global.nextRunAt || computeNextRun(global));
        };

        const loadSchedule = async () => {
          try {
            const resp = await fetch(schedulerApiUrl('/api/supabase/get-cron-schedule'));
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const json = await resp.json();
            if (json.status === 'missing_table') {
              statusEl.textContent = 'Scheduler table not found. Run migration 20260118_add_audit_cron_schedule.sql.';
              const cached = JSON.parse(localStorage.getItem('audit_scheduler_settings') || '{}');
              applyForm(cached.jobs || DEFAULTS);
              renderSchedule(cached.jobs || DEFAULTS);
              if (typeof window.updateAuditTimestamp === 'function') {
                window.updateAuditTimestamp();
              }
              return;
            }
            const jobs = json.data?.jobs || {};
            applyForm(jobs);
            renderSchedule(jobs);
            statusEl.textContent = `Last updated: ${formatUtc(json.data?.updatedAt)}`;
            if (typeof window.updateAuditTimestamp === 'function') {
              window.updateAuditTimestamp();
            }
          } catch (err) {
            statusEl.textContent = `Scheduler status unavailable (${err.message}).`;
            const cached = JSON.parse(localStorage.getItem('audit_scheduler_settings') || '{}');
            applyForm(cached.jobs || DEFAULTS);
            renderSchedule(cached.jobs || DEFAULTS);
            if (typeof window.updateAuditTimestamp === 'function') {
              window.updateAuditTimestamp();
            }
          }
        };

        const saveSchedule = async () => {
          const jobs = readForm();
          Object.keys(jobs).forEach((key) => {
            if (jobs[key].frequency !== 'off' && !parseTime(jobs[key].timeOfDay)) {
              throw new Error('Time is required for active schedules.');
            }
          });
          try {
            const resp = await fetch(schedulerApiUrl('/api/supabase/save-cron-schedule'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ jobs })
            });
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const json = await resp.json();
            const savedJobs = json.data?.jobs || jobs;
            localStorage.setItem('audit_scheduler_settings', JSON.stringify({ jobs: savedJobs }));
            renderSchedule(savedJobs);
            statusEl.textContent = `Saved at ${formatUtc(json.data?.updatedAt || new Date().toISOString())}`;
            if (typeof window.updateAuditTimestamp === 'function') {
              window.updateAuditTimestamp();
            }
          } catch (err) {
            localStorage.setItem('audit_scheduler_settings', JSON.stringify({ jobs }));
            renderSchedule(jobs);
            statusEl.textContent = `Saved locally (${err.message}).`;
            if (typeof window.updateAuditTimestamp === 'function') {
              window.updateAuditTimestamp();
            }
          }
        };

        const saveBtn = document.getElementById('scheduler-save-btn');
        const refreshBtn = document.getElementById('scheduler-refresh-btn');
        if (saveBtn) {
          saveBtn.addEventListener('click', () => {
            saveSchedule().catch((err) => {
              statusEl.textContent = err.message;
            });
          });
        }
        if (refreshBtn) refreshBtn.addEventListener('click', loadSchedule);

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', loadSchedule);
        } else {
          loadSchedule();
        }
      })();
    </script>
    <script>
      (function initAuditTimestampRefresh() {
        const formatUtcShort = (value) => {
          if (!value) return '';
          const dt = new Date(value);
          if (isNaN(dt.getTime())) return '';
          return dt.toLocaleString('en-GB', {
            timeZone: 'UTC',
            day: '2-digit',
            month: 'short',
            year: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            hour12: false
          }) + ' GMT';
        };

        const formatDateRange = (start, end) => {
          if (!start || !end) return '';
          const startDate = new Date(start);
          const endDate = new Date(end);
          if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) return '';
          const fmt = { timeZone: 'UTC', day: '2-digit', month: 'short', year: '2-digit' };
          return `${startDate.toLocaleDateString('en-GB', fmt)}  ${endDate.toLocaleDateString('en-GB', fmt)}`;
        };

        const computeRangeFromTimeseries = (timeseries) => {
          if (!Array.isArray(timeseries) || timeseries.length === 0) return null;
          const dates = timeseries.map(p => p?.date).filter(Boolean).sort();
          if (!dates.length) return null;
          return { start: dates[0], end: dates[dates.length - 1] };
        };

        window.updateAuditTimestamp = async function updateAuditTimestamp() {
          const gscAuditEl = document.getElementById('gscAuditDate');
          const gscRangeEl = document.getElementById('gscDateRange');
          const rankingEl = document.getElementById('rankingAiAuditDate');
          const propertyUrl = document.getElementById('propertyUrl')?.value ||
            localStorage.getItem('gsc_property_url') ||
            localStorage.getItem('last_property_url') ||
            'https://www.alanranger.com';

          if (!gscAuditEl || !gscRangeEl || !rankingEl || !propertyUrl) return;

          try {
            let latestAudit = null;
            if (typeof window.fetchLatestAuditFromSupabase === 'function') {
              latestAudit = await window.fetchLatestAuditFromSupabase(propertyUrl, false);
            }
            if (!latestAudit) {
              const resp = await fetch((window.apiUrl ? window.apiUrl('') : '') + `/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`);
              if (resp.ok) latestAudit = await resp.json();
            }
            if (latestAudit) {
              const auditPayload = latestAudit.data || latestAudit;
              const auditDate = auditPayload.auditDate || auditPayload.audit_date || null;
              const auditTimestamp = auditPayload.updated_at || auditPayload.timestamp || null;
              if (auditDate || auditTimestamp) {
                gscAuditEl.textContent = auditTimestamp ? formatUtcShort(auditTimestamp) : String(auditDate);
              }
              const rangeFromTs = computeRangeFromTimeseries(auditPayload.searchData?.timeseries);
              if (rangeFromTs) {
                gscRangeEl.textContent = formatDateRange(rangeFromTs.start, rangeFromTs.end);
              } else {
                const gscRange = parseInt(localStorage.getItem('gsc_date_range') || '28', 10);
                const lastDate = window.lastGscTimeseriesDate ? new Date(window.lastGscTimeseriesDate) : null;
                if (lastDate && !isNaN(lastDate.getTime())) {
                  const startDate = new Date(lastDate);
                  startDate.setUTCDate(startDate.getUTCDate() - Math.max(1, gscRange - 1));
                  gscRangeEl.textContent = formatDateRange(startDate.toISOString(), lastDate.toISOString());
                } else {
                  gscRangeEl.textContent = gscRange ? `${gscRange} days` : '';
                }
              }
            }
          } catch (err) {
            gscAuditEl.textContent = '';
            gscRangeEl.textContent = '';
          }

          try {
            const resp = await fetch((window.apiUrl ? window.apiUrl('') : '') + `/api/supabase/get-keyword-rankings?propertyUrl=${encodeURIComponent(propertyUrl)}&latestOnly=true`);
            if (resp.ok) {
              const json = await resp.json();
              const ts = json?.data?.latestTimestamp || json?.data?.latestAuditDate || null;
              rankingEl.textContent = ts ? formatUtcShort(ts) : 'Not yet run';
            }
          } catch (err) {
            rankingEl.textContent = '';
          }
        };

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => {
            window.updateAuditTimestamp();
          });
        } else {
          window.updateAuditTimestamp();
        }
      })();
    </script>
      </section>

      <!-- Dashboard Panel (placeholder  content to be defined) -->
      <section class="aigeo-panel" data-panel="dashboard">
        <div class="card--section-header">
          <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 1rem; flex-wrap: wrap;">
            <div>
              <h2 style="margin: 0 0 0.25rem 0;">Dashboard</h2>
              <p style="margin: 0;">Global run + executive summary across all modules. Deltas compare against the previous global run.</p>
              <div style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--dark-text-muted);">
                <strong>Last global run:</strong> <span id="dashboard-last-run"></span>
                <span style="margin-left: 0.75rem;"><strong>Status:</strong> <span id="dashboard-last-status"></span></span>
              </div>
            </div>

            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
              <button id="dashboard-run-all-btn" class="btn" type="button" title="Runs Audit Scan, Ranking & AI scan, Domain Strength snapshot, then updates all tasks with latest data.">
                 Run All Audits & Updates
              </button>
            </div>
          </div>
        </div>

        <div class="dashboard-dials-grid" id="dashboard-dials-grid">
          <div class="card dashboard-dial-card">
            <div class="dashboard-dial-header">
              <div class="dashboard-delta-indicator" id="dashboard-delta-gaio" style="display: none;"></div>
              <div class="dashboard-dial-title">AI Health (GAIO)</div>
              <div class="dashboard-dial-subtitle">Score (0100)</div>
            </div>
            <div class="dashboard-dial-ring" id="dashboard-dial-gaio" data-pct="0">
              <div class="dashboard-dial-inner">
                <div class="dashboard-dial-value" data-field="value"></div>
                <div class="dashboard-dial-delta" data-field="delta"></div>
              </div>
            </div>
            <div id="dashboard-gaio-breakdown" style="margin-top: 0.5rem;"></div>
            <div id="dashboard-gaio-pillars" style="margin-top: 0.75rem;"></div>
            <div style="margin-top: 0.75rem;">
              <canvas id="dashboard-gaio-radar" width="460" height="340" style="width: 100%; height: 340px;"></canvas>
            </div>
          </div>

          <div class="card dashboard-dial-card">
            <div class="dashboard-dial-header">
              <div class="dashboard-delta-indicator" id="dashboard-delta-ai-summary" style="display: none;"></div>
              <div class="dashboard-dial-title">AI Summary Likelihood</div>
              <div class="dashboard-dial-subtitle">Score (0100)</div>
            </div>
            <div class="dashboard-dial-ring" id="dashboard-dial-ai-summary" data-pct="0">
              <div class="dashboard-dial-inner">
                <div class="dashboard-dial-value" data-field="value"></div>
                <div class="dashboard-dial-delta" data-field="delta"></div>
              </div>
            </div>
            <div id="dashboard-ai-summary-mini" style="margin-top: 0.75rem;"></div>
            <div id="dashboard-ai-summary-breakdown" style="margin-top: 0.5rem;"></div>
            <div style="margin-top: 0.75rem;">
              <canvas id="dashboard-ai-summary-radar" width="460" height="340" style="width: 100%; height: 340px;"></canvas>
            </div>
          </div>

          <div class="card dashboard-dial-card">
            <div class="dashboard-dial-header">
              <div class="dashboard-delta-indicator" id="dashboard-delta-money-share" style="display: none;"></div>
              <div class="dashboard-dial-title">AI Citations (Money Share)</div>
              <div class="dashboard-dial-subtitle">Money citations / total</div>
            </div>
            <div class="dashboard-dial-ring" id="dashboard-dial-money-share" data-pct="0">
              <div class="dashboard-dial-inner">
                <div class="dashboard-dial-value" data-field="value"></div>
                <div class="dashboard-dial-delta" data-field="delta"></div>
              </div>
            </div>
            <div id="dashboard-money-share-mini" style="margin-top: 0.75rem;"></div>
            <div id="dashboard-money-share-breakdown" style="margin-top: 0.5rem;"></div>
            <div style="margin-top: 0.75rem;">
              <canvas id="dashboard-money-share-radar" width="460" height="340" style="width: 100%; height: 340px;"></canvas>
            </div>
          </div>

          <div class="card dashboard-dial-card">
            <div class="dashboard-dial-header">
              <div class="dashboard-delta-indicator" id="dashboard-delta-uplift" style="display: none;"></div>
              <div class="dashboard-dial-title">Uplift Remaining</div>
              <div class="dashboard-dial-subtitle">Estimated extra clicks (28d)</div>
            </div>
            <div class="dashboard-dial-ring" id="dashboard-dial-uplift" data-pct="0">
              <div class="dashboard-dial-inner">
                <div class="dashboard-dial-value" data-field="value"></div>
                <div class="dashboard-dial-delta" data-field="delta"></div>
              </div>
            </div>
            <div id="dashboard-uplift-mini" style="margin-top: 0.75rem;"></div>
            <div id="dashboard-uplift-breakdown" style="margin-top: 0.5rem;"></div>
            <div style="margin-top: 0.75rem;">
              <canvas id="dashboard-uplift-chart" width="440" height="320" style="width: 100%; height: 320px;"></canvas>
            </div>
          </div>

          <div class="card dashboard-dial-card">
            <div class="dashboard-dial-header">
              <div class="dashboard-delta-indicator" id="dashboard-delta-eeat" style="display: none;"></div>
              <div class="dashboard-dial-title">EEAT</div>
              <div class="dashboard-dial-subtitle">Score (0100)</div>
            </div>
            <div class="dashboard-dial-ring" id="dashboard-dial-eeat" data-pct="0">
              <div class="dashboard-dial-inner">
                <div class="dashboard-dial-value" data-field="value"></div>
                <div class="dashboard-dial-delta" data-field="delta"></div>
              </div>
            </div>
            <div id="dashboard-eeat-mini" style="margin-top: 0.75rem;"></div>
            <div id="dashboard-eeat-breakdown" style="margin-top: 0.5rem;"></div>
            <div style="margin-top: 0.75rem;">
              <canvas id="dashboard-eeat-radar" width="460" height="340" style="width: 100%; height: 340px;"></canvas>
            </div>
          </div>
        </div>

        <div class="dashboard-summary-grid" id="dashboard-summary-grid">
          <div class="card">
            <div style="font-weight: 700; margin-bottom: 0.5rem;">Module summary cards</div>
            <div style="color: var(--dark-text-muted);">
              Next: well add compact summary panels from each tab (Portfolio, Ranking & AI, Money Pages, Optimisation Tracking, etc.).
            </div>
          </div>
        </div>
      </section>

      <!-- Authority Panel -->
      <section class="aigeo-panel" data-panel="authority">
        <!-- Authority - Behaviour & Ranking section will be inserted here by JS -->
      </section>

      <!-- Portfolio Panel -->
      <section class="aigeo-panel" data-panel="portfolio">
        <div class="portfolio-container" style="padding: 2rem;">
          <h1 style="margin-bottom: 2rem;">Portfolio Optimisation Trends</h1>
          
          <!-- Chart A: Median Delta Over Time -->
          <div class="portfolio-chart-section" style="margin-bottom: 3rem;">
            <div class="card" style="padding: 1.5rem;">
              <h2 style="margin-top: 0; margin-bottom: 1rem;" title="Median Delta Over Time: Shows the change (delta) in selected KPI between consecutive time periods. Each point shows how much the metric changed compared to the previous period.">Median Delta Over Time</h2>
              <p style="color: #666; margin-bottom: 1.5rem;" title="Shows the change (delta) in selected KPI over time using rolling 28d snapshots. Segment meanings: Entire site = all pages on the property (unfiltered). Money Pages = Landing + Event + Product combined. Money Pages (tracked) = only money pages that currently have an active optimisation task (planned/in_progress/monitoring). Blog Pages = URLs containing /blog-on-photography/. All tracked = all pages (any type) that currently have an active optimisation task. Note: AI Citations / AI Overview metrics are keyword-driven; page/segment is inferred using the keyword's best_url.">
                Portfolio movement over time using rolling 28d snapshots. <strong>Tip:</strong> Tracked segments only include URLs with active optimisation tasks.
              </p>
              
              <!-- Controls -->
              <div class="portfolio-controls" style="display: flex; gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap; align-items: center;">
                <div>
                  <label for="portfolio-kpi-select" style="display: block; margin-bottom: 0.25rem; font-weight: 600;" title="Key Performance Indicator: Select which metric to track over time">KPI:</label>
                  <select id="portfolio-kpi-select" style="padding: 0.5rem; min-width: 180px;">
                    <option value="ctr_28d" title="Click-Through Rate: Percentage of impressions that resulted in clicks (rolling 28 days)">CTR (28d)</option>
                    <option value="clicks_28d" title="Total clicks from Google Search (rolling 28 days)">Clicks (28d)</option>
                    <option value="impressions_28d" title="Total impressions in Google Search results (rolling 28 days)">Impressions (28d)</option>
                    <option value="avg_position" title="Average ranking position in Google Search results (lower is better)">Avg Position</option>
                    <option value="ai_citations" title="AI citations are keyword-driven. Segment is inferred using each keyword's best_url. Shows total citations from your domain (alanranger.com) in Google AI Overviews.">AI Citations</option>
                    <option value="ai_overview" title="AI Overview is keyword-driven. Segment is inferred using each keyword's best_url. Shows the number of keywords that have an AI Overview present.">AI Overview</option>
                  </select>
                </div>
                <div>
                  <label for="portfolio-segment-select" style="display: block; margin-bottom: 0.25rem; font-weight: 600;" title="Segment: Choose which set of pages to measure. Entire site = all pages. Money Pages = Landing+Event+Product. All tracked = only URLs with active optimisation tasks.">Segment:</label>
                  <select id="portfolio-segment-select" style="padding: 0.5rem; min-width: 150px;">
                    <option value="site" title="Entire site: all pages on the property (unfiltered)">Entire site</option>
                    <option value="all_tracked" title="All pages that have active optimisation tasks tracking them">All tracked</option>
                    <option value="money" title="All commercial pages: landing pages, event pages, and product pages combined">Money Pages</option>
                    <option value="money_tracked" title="Only money pages (landing/event/product) that currently have active optimisation tasks">Money Pages (tracked)</option>
                    <option value="academy" title="Academy: single signup page only (/free-online-photography-course)">Academy</option>
                    <option value="blog" title="Blog pages: URLs containing /blog-on-photography/">Blog Pages</option>
                    <option value="other" title="Other (non-money): all pages that are not money pages, not blog posts, and not the Academy signup page">Other (non-money)</option>
                    <option value="landing" title="Landing pages: general commercial landing pages (not events or products)">Landing</option>
                    <option value="event" title="Event pages: photography workshop and course event pages">Event</option>
                    <option value="product" title="Product pages: photography service and product pages">Product</option>
                  </select>
                </div>
                <div>
                  <label for="portfolio-time-grain" style="display: block; margin-bottom: 0.25rem; font-weight: 600;" title="Time aggregation: How to group data points on the chart">Time Grain:</label>
                  <select id="portfolio-time-grain" style="padding: 0.5rem; min-width: 120px;">
                    <option value="weekly" title="Group data by week: Shows the last snapshot from each week">Weekly</option>
                    <option value="monthly" selected title="Group data by month: Shows the last snapshot from each month">Monthly</option>
                  </select>
                </div>
              </div>
              
              <!-- Chart Canvas -->
              <div style="position: relative; height: 400px;">
                <canvas id="portfolio-delta-chart"></canvas>
              </div>
            </div>
          </div>
          
          <!-- Table B: Monthly KPI Tracker -->
          <div class="portfolio-table-section">
            <div class="card" style="padding: 1.5rem;">
              <h2 style="margin-top: 0; margin-bottom: 1rem;" title="Monthly KPI Tracker: View actual metric values (not deltas) for each segment across the last 12 months">Monthly KPI Tracker</h2>
              <p style="color: #666; margin-bottom: 1.5rem;" title="Shows the actual KPI value (not delta) for each segment across the last 12 months. Segment meanings: Entire site = all pages (unfiltered). Money Pages = Landing + Event + Product. Money Pages (tracked) = only money pages with active optimisation tasks. Blog Pages = URLs containing /blog-on-photography/. All tracked = only URLs with active optimisation tasks. Note: AI Citations / AI Overview metrics are keyword-driven; page/segment is inferred using the keyword's best_url.">Executive summary by segment over time (rolling 12 months)</p>
              
              <!-- KPI Selector for Table -->
              <div style="margin-bottom: 1.5rem;">
                <label for="portfolio-table-kpi-select" style="display: block; margin-bottom: 0.25rem; font-weight: 600;" title="Key Performance Indicator: Select which metric to display in the monthly table">KPI:</label>
                <select id="portfolio-table-kpi-select" style="padding: 0.5rem; min-width: 180px;">
                  <option value="ctr_28d" title="Click-Through Rate: Percentage of impressions that resulted in clicks (rolling 28 days)">CTR (28d)</option>
                  <option value="clicks_28d" title="Total clicks from Google Search (rolling 28 days)">Clicks (28d)</option>
                  <option value="impressions_28d" title="Total impressions in Google Search results (rolling 28 days)">Impressions (28d)</option>
                  <option value="avg_position" title="Average ranking position in Google Search results (lower is better)">Avg Position</option>
                  <option value="ai_citations" title="AI citations are keyword-driven. Segment is inferred using each keyword's best_url. Shows total citations from your domain (alanranger.com) in Google AI Overviews.">AI Citations</option>
                  <option value="ai_overview" title="AI Overview is keyword-driven. Segment is inferred using each keyword's best_url. Shows the number of keywords that have an AI Overview present.">AI Overview</option>
                </select>
              </div>
              
              <!-- Table Container -->
              <div style="overflow-x: auto;">
                <table id="portfolio-monthly-table" class="portfolio-table" style="width: 100%; border-collapse: collapse;">
                  <thead>
                    <tr>
                      <th style="text-align: left; padding: 0.75rem; border-bottom: 2px solid #ddd; font-weight: 600;">Segment</th>
                      <!-- Month columns will be inserted here by JS -->
                    </tr>
                  </thead>
                  <tbody>
                    <!-- Rows will be inserted here by JS -->
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Overview Panel -->
      <section class="aigeo-panel is-active" data-panel="overview">

      <!-- Five-Pillar Framework (collapsed by default) -->
      <div class="calculation-explanation collapsed" id="frameworkExplanation">
        <div class="calculation-header" onclick="toggleFrameworkExplanation()">
          <h4> Five-Pillar Framework</h4>
          <span class="calculation-toggle" id="frameworkToggle"></span>
        </div>
        <div class="calculation-content collapsed" id="frameworkContent">
          <p style="margin-top: 0; color: #555; line-height: 1.6; margin-bottom: 1rem;">
            This audit analyzes <strong>www.alanranger.com</strong> as a global entity using a five-pillar framework to assess AI-powered search visibility, entity recognition, and SERP behavior. Each pillar is scored 0-100 and assigned a RAG (Red/Amber/Green) status based on performance thresholds.
          </p>
          <p style="color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
            <strong>Data Sources:</strong> Scores are calculated using data from Google Search Console API (impressions, clicks, position, queries), Google Business Profile API (ratings, reviews, locations, service areas), schema markup validation, backlink CSV upload, and Trustpilot reviews snapshot.
          </p>
          <p style="color: #555; line-height: 1.6; margin-bottom: 0;">
            <strong>Score Calculation:</strong> The GAIO score combines five weighted pillars: Authority (30%: Behaviour 40% + Ranking 20% + Backlinks 20% + Reviews 20%), Content/Schema (25%: Foundation schemas 30% + Rich Results 35% + Coverage 20% + Diversity 15%), Visibility (20%: average position mapping), Local Entity (15%: NAP consistency + knowledge panel + locations), and Service Area (10%: service areas count with NAP multiplier). Brand & Entity Overlay and AI Summary Likelihood are overlay metrics that do not affect the GAIO score but provide additional insights. Scores are normalized to 0-100 scale with thresholds: Green (70), Amber (40-69), Red (&lt;40). Money pages behaviour is tracked separately and stored per audit, so you can see whether Authority improvements are coming from better CTR on commercial pages or from broader site-wide changes.
          </p>
        </div>
      </div>

      <div class="calculation-explanation collapsed" id="calculationExplanation">
        <div class="calculation-header" onclick="toggleCalculationExplanation()">
          <h4> Detailed Calculation Explanation</h4>
          <span class="calculation-toggle" id="calculationToggle"></span>
        </div>
        <div class="calculation-content collapsed" id="calculationContent">
          <h5>1. Visibility</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Primary: Average position from Google Search Console (1-40 mapped to 100-10)</li>
            <li>Formula: <code>posScore = 100 - ((clampedPosition - 1) / 39) * 90</code> where clampedPosition is constrained to 1-40</li>
            <li>Visibility score = clamped posScore (0-100)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: impressions, clicks, average position, CTR</li>
            <li>Real-time data from GSC API for the selected date range</li>
          </ul>
          <p><strong>Data Checked:</strong> Search Console impressions/clicks, average position, CTR, ranking distribution.</p>

          <h5>2. Authority (E-E-A-T)</h5>
          <p><strong>What Authority Represents:</strong></p>
          <p>Authority is not "how good the content is", it's "how much the outside world and searchers trust and choose you". It approximates E-E-A-T using four ingredients:</p>
          <ul>
            <li><strong>Behavioural signals</strong>  do people click your results when they see them?</li>
            <li><strong>Ranking strength</strong>  how often do you show near the top of organic results?</li>
            <li><strong>Off-site credibility</strong>  backlinks from other domains (Phase 3)</li>
            <li><strong>Reputation & reviews</strong>  ratings and review volume across GBP + website</li>
          </ul>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Four-component model: Behaviour (40%), Ranking (20%), Backlinks (20%), Reviews (20%)</li>
            <li>Formula: <code>authority = 0.4 * behaviourScore + 0.2 * rankingScore + 0.2 * backlinkScore + 0.2 * reviewScore</code></li>
            <li>Each sub-score is normalized to 0-100, then combined with weights above</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>2.1 Behaviour Score (40%):</strong></p>
          <ul>
            <li>From Google Search Console: Only uses queries where average position  20</li>
            <li>Computes: ctrAll = CTR for all ranking queries, ctrTop10 = CTR for impressions where position  10</li>
            <li>Maps: ctrAll 0-5%  0-100 (values >5% capped at 100), ctrTop10 0-10%  0-100</li>
            <li>Combines: <code>BehaviourScore = 0.5 * score(ctrAll) + 0.5 * score(ctrTop10)</code></li>
            <li>This stops long-tail / low-rank pages dragging the whole site down</li>
          </ul>
          <p><strong>2.2 Ranking Score (20%):</strong></p>
          <ul>
            <li>From GSC, again only for position  20</li>
            <li>avgPos = impression-weighted average position</li>
            <li>top10Share = % of impressions where position  10</li>
            <li>posScore = map(avgPos, 1  100, 20  0) (clamped)</li>
            <li>top10Score = top10Share as a % (0-100)</li>
            <li>Combines: <code>RankingScore = 0.5 * posScore + 0.5 * top10Score</code></li>
          </ul>
          <p><strong>2.3 Review Score (20%):</strong></p>
          <ul>
            <li>Inputs: From GBP API (gbpRating 0-5, gbpReviewCount) and Trustpilot snapshot (siteRating 4.6, siteReviewCount 610)</li>
            <li>Per source: ratingScore = (rating/5)*100, countScore = min(reviewCount, 500)/500*100</li>
            <li>sourceScore = 0.6 * ratingScore + 0.4 * countScore</li>
            <li>Final: <code>ReviewScore = 0.6 * gbpSourceScore + 0.4 * siteSourceScore</code></li>
            <li>If one source missing, falls back to the other; if both missing, uses neutral default (50)</li>
          </ul>
          <p><strong>2.4 Backlink Score (20%):</strong></p>
          <ul>
            <li>Phase 3  using CSVs: refDomainCount, qualityDomains, qualityRatio</li>
            <li>countScore = map(refDomainCount, 0  0, N  100) where N is cap (e.g. 150-200)</li>
            <li>qualityScore = qualityRatio * 100</li>
            <li>Combines: <code>BacklinkScore = 0.5 * countScore + 0.5 * qualityScore</code></li>
            <li>Currently placeholder (50) until Phase 3 is implemented</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API (CTR, position, impressions by position bucket)</li>
            <li>Google Business Profile API (ratings, review count)</li>
            <li>Trustpilot reviews (historic snapshot: rating 4.6, count 610)</li>
            <li>Backlink CSV upload (referring domains, quality metrics) - Phase 3</li>
          </ul>
          <p><strong>How to Improve Authority:</strong></p>
          <ul>
            <li><strong>Behaviour:</strong> Improve titles/meta descriptions on pages already in top 10-20. Focus on high-impression queries in GSC.</li>
            <li><strong>Ranking:</strong> Push more core pages into top 10 (content refreshes, internal links, stronger schema).</li>
            <li><strong>Reviews:</strong> Keep growing GBP and Trustpilot reviews; higher rating and more volume both help.</li>
            <li><strong>Backlinks:</strong> Acquire more distinct linking domains, favouring sites with real traffic/authority (Phase 3).</li>
          </ul>

          <h5>3. Local Entity</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li><strong>Primary method (when Business Profile data available):</strong> Base score from NAP consistency (0-100), with bonuses:
              <ul>
                <li>Knowledge panel detected: +10 points</li>
                <li>At least one location: +5 points</li>
                <li>Final score capped at 100</li>
              </ul>
            </li>
            <li><strong>Fallback method (no Business Profile data):</strong> Derived from search performance:
              <ul>
            <li>Formula: <code>localEntity = 60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50)</code></li>
                <li>Uses position score and CTR score from GSC</li>
              </ul>
            </li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li> <strong>Primary:</strong> Google Business Profile API: NAP consistency score, knowledge panel detection, locations count</li>
            <li> <strong>Fallback:</strong> Google Search Console API: position, CTR (when Business Profile data unavailable)</li>
          </ul>
          <p><strong>Data Checked:</strong> NAP consistency percentage, knowledge panel presence, locations count, LocalBusiness schema presence, entity recognition signals.</p>

          <h5>4. Service Area</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li><strong>Primary method (when Business Profile data available):</strong>
              <ul>
                <li>Base score from service areas count: 0 areas = 0, 1 area = 12.5, 2 areas = 25, ..., 8+ areas = 100</li>
                <li>Formula: <code>baseScore = min(serviceAreasCount * 12.5, 100)</code></li>
                <li>NAP consistency multiplier applied: <code>serviceArea = baseScore * (napConsistencyScore / 100)</code></li>
                <li>If NAP consistency is low, service area score is reduced proportionally</li>
              </ul>
            </li>
            <li><strong>Fallback method (no Business Profile data):</strong> Derived from Local Entity score (when Business Profile unavailable)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li> <strong>Primary:</strong> Google Business Profile API: service areas count, NAP consistency score</li>
            <li> <strong>Fallback:</strong> Derived from Local Entity (when Business Profile data unavailable)</li>
          </ul>
          <p><strong>Data Checked:</strong> Service areas count from Business Profile, NAP consistency percentage, geographic coverage signals.</p>

          <h5>5. Content/Schema</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Weighted calculation based on four components: Foundation schemas, Rich Results, Coverage, and Diversity</li>
            <li>Formula: <code>contentSchema = (Foundation  30%) + (Rich Results  35%) + (Coverage  20%) + (Diversity  15%)</code></li>
            <li><strong>Foundation Schemas (30%):</strong> Organization, Person, WebSite, BreadcrumbList presence. Score = (types present / 4)  100</li>
            <li><strong>Rich Results (35%):</strong> Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList eligibility. Score = (eligible types / 11)  100</li>
            <li><strong>Coverage (20%):</strong> Pages with schema / total pages. Score = coverage percentage</li>
            <li><strong>Diversity (15%):</strong> Number of unique schema types across site. Score = min((unique types / 15)  100, 100)</li>
            <li><strong>Data Source:</strong> Schema audit API (crawls actual pages for JSON-LD markup)</li>
            <li>Uses real schema coverage from CSV-based audit (when available)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Schema Audit API: CSV-based domain crawl of all site URLs</li>
            <li>Schema markup detection and type counting</li>
            <li>Foundation schema presence detection (Organization, Person, WebSite, BreadcrumbList)</li>
            <li>Rich result eligibility detection (Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList)</li>
          </ul>
          <p><strong>Data Checked:</strong> Total pages scanned, pages with schema, schema coverage percentage, schema types present (Organization, Person, LocalBusiness, Article, Course, Event, FAQ, HowTo, etc.), missing schema types, rich result eligibility (Article, Event, FAQ, Product, LocalBusiness, Course, Review, HowTo).</p>

          <h5>6. Brand & Entity Overlay</h5>
          <p><strong>What Brand Overlay Represents:</strong></p>
          <p>Brand & Entity Overlay measures how strongly your brand is recognized in search and how well entity signals support AI understanding. It combines branded search performance, review signals, and entity recognition. <strong>Note:</strong> This is an overlay metric and does not directly affect the GAIO score calculation.</p>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li><strong>Brand Search Component (40% of brand search score):</strong>
              <ul>
                <li>Brand Query Share: % of impressions that are branded queries (30%+ share = 100 points)</li>
                <li>Brand CTR: Click-through rate on branded queries (40%+ CTR = 100 points)</li>
                <li>Brand Avg Position: Average position for branded queries (normalized 1-10  100-0)</li>
                <li>Formula: <code>brandSearchScore = 0.4 * shareScore + 0.3 * ctrScore + 0.3 * posScore</code></li>
              </ul>
            </li>
            <li><strong>Combined Score:</strong>
              <ul>
                <li>Formula: <code>brandOverlay = 0.4 * brandSearchScore + 0.3 * reviewScore + 0.3 * entityScore</code></li>
                <li>Label thresholds: &lt;40 = Weak, 40-69 = Developing, 70 = Strong</li>
              </ul>
            </li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: Branded query identification, brand impressions, brand clicks, brand CTR, brand average position</li>
            <li>Google Business Profile API: Review score (reused from Authority pillar)</li>
            <li>Local Entity score: Entity recognition signals (reused from Local Entity pillar)</li>
          </ul>
          <p><strong>Data Checked:</strong> Brand query share (% of total impressions), branded CTR, average brand position, review signals, entity recognition strength.</p>

          <h5>7. AI Summary Likelihood</h5>
          <p><strong>What AI Summary Likelihood Represents:</strong></p>
          <p>AI Summary Likelihood indicates how likely AI systems (like Google's AI Overviews) are to provide accurate, comprehensive summaries about your brand and content. It combines snippet readiness, visibility, and brand strength signals.</p>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Three-component model: Snippet Readiness (50%), Visibility (30%), Brand & Entity (20%)</li>
            <li>Formula: <code>aiSummary = 0.5 * snippetReadinessScore + 0.3 * visibilityScore + 0.2 * brandScore</code></li>
            <li>Label thresholds: &lt;50 = Low, 50-69 = Medium, 70 = High</li>
            <li>Uses same RAG bands as GAIO Score (70 green, 50 amber, &lt;50 red)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Snippet Readiness score: From snippet readiness gauge (FAQ/HowTo/Article blocks, schema, rich results)</li>
            <li>Visibility score: Current Visibility pillar score (average position from GSC)</li>
            <li>Brand score: Brand & Entity Overlay score</li>
          </ul>
          <p><strong>Data Checked:</strong> Snippet-friendly content blocks, schema markup for rich results, average search position, branded search performance, entity recognition.</p>

          <div class="note">
            <strong>Current Implementation Status:</strong><br>
            <strong> Fully Implemented:</strong><br>
             Google Search Console API integration (real-time data) - Total clicks, Total impressions, Average position, CTR calculation, Top queries, Brand query classification<br>
             Schema markup validation and analysis - Full site crawl, coverage analysis, type diversity, rich result eligibility (11 types), foundation schema detection<br>
             Backlink quality/quantity analysis - CSV upload support, domain rating, referring domains tracking<br>
             Review aggregation - Trustpilot integration (snapshot), Google Business Profile reviews, review score calculation<br>
             Knowledge panel tracking - Detection and scoring (part of Local Entity pillar)<br>
             Local pack visibility metrics - Service Area pillar with NAP consistency, location coverage<br>
             SERP feature detection - Rich result eligibility checks, snippet readiness scoring<br>
             Brand overlay metrics - Brand query share, branded CTR, brand position, entity strength<br>
             AI Summary Likelihood - Composite score based on snippet readiness, visibility, and brand signals<br>
             Historical trend tracking - Supabase integration for all pillars, trend charts with segmented Authority data<br>
             Shareable audit links - Public sharing with 30-day expiration<br><br>
            <strong>Future Enhancements:</strong><br>
             Real-time SERP feature monitoring and alerts<br>
             Advanced backlink analysis with automated discovery<br>
             Competitive analysis and benchmarking<br>
             Automated action recommendations engine<br>
             Export capabilities (PDF, CSV reports)<br><br>
            <strong>Note:</strong> All five core pillars (Authority, Content/Schema, Visibility, Local Entity, Service Area) are fully implemented with real data sources. Brand & Entity and AI Summary Likelihood are overlay metrics that enhance the core scoring without changing the GAIO score calculation.
          </div>
        </div>
      </div>

      <!-- Date Range Selector -->
      <div class="config-panel" style="margin-bottom: 2rem; background: #f8f9fa; padding: 1.5rem; border-radius: 8px; border: 1px solid #e2e8f0;">
        <div class="form-group">
          <label for="dateRange">Date Range</label>
          <div class="date-range-selector">
            <button class="date-range-btn active" onclick="setDateRange(30)" data-days="30" title="Analyze search performance data from the last 30 days">Last 30 Days</button>
            <button class="date-range-btn" onclick="setDateRange(60)" data-days="60" title="Analyze search performance data from the last 60 days">Last 60 Days</button>
            <button class="date-range-btn" onclick="setDateRange(90)" data-days="90" title="Analyze search performance data from the last 90 days">Last 90 Days</button>
            <button class="date-range-btn" onclick="setDateRange(120)" data-days="120" title="Analyze search performance data from the last 120 days">Last 120 Days</button>
            <button class="date-range-btn" onclick="setDateRange(180)" data-days="180" title="Analyze search performance data from the last 6 months (180 days)">Last 6 Months</button>
            <button class="date-range-btn" onclick="setDateRange(365)" data-days="365" title="Analyze search performance data from the last 12 months (365 days)">Last 12 Months</button>
            <button class="date-range-btn" onclick="setDateRange(540)" data-days="540" title="Analyze search performance data from the last 18 months (540 days)">Last 18 Months</button>
            <button class="date-range-btn" onclick="showCustomDateRange()" id="customDateBtn" title="Set a custom date range for analysis (enter number of days)">Custom</button>
        </div>
          <input type="number" id="dateRange" value="28" min="1" style="display: none;">
          <div id="customDateRange" style="display: none; margin-top: 0.5rem;">
            <input type="number" id="customDays" placeholder="Enter days" min="1" style="width: 150px; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px;">
            <button class="btn btn-small" onclick="applyCustomDateRange()" style="margin-left: 0.5rem; padding: 0.5rem 1rem;" title="Apply the custom date range you entered">Apply</button>
      </div>
          <div class="help-text">Analysis period for historical data</div>
      </div>
    </div>

      <div class="dashboard-grid" id="pillarCards"></div>

      <div class="section-break"></div>

      <div class="metrics-section">
        <h3 style="color: var(--brand-orange); margin-bottom: 0.5rem;">Key Performance Indicators</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Core metrics from Google Search Console showing overall search performance for the entity. <strong>Note:</strong> Small differences from live GSC may occur due to data processing delays (up to 48 hours) and exact date range calculations.</p>
        <div class="metrics-grid" id="metricsGrid"></div>
      </div>

      <div class="section-break"></div>

      <div class="dashboard-two-column">
        <div class="chart-container large">
          <h3>Pillar Scores Overview</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Radar chart showing current performance across all five pillars. The larger the area, the stronger your overall entity recognition.</p>
          
          <!-- Audit Timestamp for Radar Chart -->
          <div id="radarChartTimestamp" style="background: #fff3cd; padding: 0.5rem 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #f59e0b; font-size: 0.8rem; color: #856404; display: none;">
            <strong>Current data as of:</strong> <span id="radarChartAuditTime">-</span> <span style="color: #666; font-size: 0.75rem;">(Not historical - reflects last audit scan)</span>
          </div>
          
          <canvas id="radarChart"></canvas>
        </div>

        <div class="snippet-readiness-gauge">
          <h3 style="margin-top: 0; color: var(--brand-orange);">Snippet Readiness Gauge</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Snippet readiness summarises how likely your content is to be lifted into featured snippets and AI answers. It reflects three ingredients: snippet-friendly answer blocks, suitable schema (FAQ/HowTo/Article/Course/Event) and existing rich-result behaviour.</p>
          
          <!-- Audit Timestamp for Snippet Readiness -->
          <div id="snippetReadinessTimestamp" style="background: #fff3cd; padding: 0.5rem 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #f59e0b; font-size: 0.8rem; color: #856404; display: none;">
            <strong>Current data as of:</strong> <span id="snippetReadinessAuditTime">-</span> <span style="color: #666; font-size: 0.75rem;">(Not historical - reflects last audit scan)</span>
            </div>
          
          <div id="snippetReadinessExplanation" style="display: none; background: #fde68a; border-left: 4px solid #f59e0b; padding: 1rem; margin-bottom: 1rem; border-radius: 4px; font-size: 0.85rem; color: #78350f;">
            <strong id="explanationTitle" style="color: #78350f;">Top 5 Actions to Improve Snippet Readiness</strong>
            <p style="margin: 0.5rem 0; color: #78350f;">Prioritized actions based on your current scores and their impact on overall snippet readiness:</p>
            <ol id="topActionsList" style="margin: 0.5rem 0 0 1.5rem; padding: 0; list-style-type: decimal;">
              <!-- Top 5 actions will be populated dynamically -->
            </ol>
            </div>
          
          <!-- Overall Combined Score -->
          <div style="text-align: center; margin-bottom: 1.5rem;">
            <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">Overall Snippet Readiness</div>
            <div id="snippetReadinessScore" style="font-size: 3rem; font-weight: 700; color: var(--brand-orange); line-height: 1;">0</div>
            <div id="gaugeStatus" style="font-size: 0.9rem; color: #666; margin-top: 0.25rem;">Calculating...</div>
          </div>
          
          <!-- Pie Chart Container -->
          <div style="display: flex; align-items: center; justify-content: center; gap: 1.5rem; flex-wrap: wrap;">
            <div style="flex: 2; min-width: 400px; max-width: 500px;">
              <canvas id="snippetReadinessPieChart"></canvas>
            </div>
            <div style="flex: 1; min-width: 180px; max-width: 250px;">
              <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--brand-dark);">Component Breakdown:</div>
              <div id="snippetReadinessLegend" style="display: flex; flex-direction: column; gap: 0.5rem;">
                <!-- Legend will be populated by JavaScript -->
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="section-break"></div>

      <div class="chart-container">
        <h3>Score Trends</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Historical performance tracking for all five pillars (Local Entity, Service Area, Authority, Visibility, Content/Schema) over the selected date range.</p>
        <div id="trendAuthorityModeToggle" class="authority-mode-toggle" style="margin-bottom: 1rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; display: none;">
          <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
            <span style="font-weight: 600; color: #666;">Authority Mode:</span>
            <button id="trend-mode-all" class="authority-mode-btn" data-mode="all" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: #10b981; color: white; cursor: pointer; font-size: 0.75rem;">
              All pages
            </button>
            <button id="trend-mode-nonEducation" class="authority-mode-btn" data-mode="nonEducation" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
              Exclude education
            </button>
            <button id="trend-mode-money" class="authority-mode-btn" data-mode="money" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
              Money pages only
            </button>
          </div>
        </div>
        <div id="trendSummaryRow" class="trend-summary-row"></div>
        <canvas id="trendChart"></canvas>
      </div>
      </section>

      <!-- Money Pages Panel -->
      <section class="aigeo-panel" data-panel="money">
        <!-- Money Pages content will be inserted here by JS -->
      </section>

      <!-- Keyword Ranking and AI Panel -->
      <section class="aigeo-panel" data-panel="ranking">
        <div class="card card--section-header">
          <h2>Keyword Ranking and AI Visibility</h2>
          <p class="ranking-intro">
            Keyword-level view of how search engines and AI systems see you. This is an overlay on the
            <strong>Visibility</strong>, <strong>Authority</strong>, <strong>Content/Schema</strong> and
            <strong>Local Entity</strong> pillars  it does not change their weights or scores.
          </p>

          <ul class="ranking-intro-bullets">
            <li><strong>Classic rankings</strong>  Visibility + Authority (Ranking component).</li>
            <li><strong>AI Overviews &amp; citations</strong>  Content/Schema + Authority.</li>
            <li><strong>Local packs</strong>  Local Entity + Service Area.</li>
          </ul>

          <div class="ranking-header-actions" style="display: flex; align-items: center; gap: 1rem;">
            <button id="ranking-ai-refresh" class="btn btn-secondary" type="button">
              Run ranking &amp; AI check
            </button>
            <button id="ranking-gsc-refresh" class="btn btn-secondary" type="button" style="background: #10b981; color: white; border: 1px solid #10b981; font-weight: 600; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;" title="Refresh CTR & Impressions from Google Search Console (no API costs)">
              Refresh GSC Data
            </button>
            <button id="edit-keywords-btn" class="btn btn-secondary" type="button" style="background: #2563eb; color: white; border: 1px solid #2563eb; font-weight: 600; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">
              Edit Keywords
            </button>
            <span id="ranking-ai-last-run" class="ranking-ai-last-run"></span>
          </div>
        </div>

        <!-- Edit Keywords Modal -->
        <div id="edit-keywords-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 10000; align-items: center; justify-content: center;">
          <div style="background: white; border-radius: 8px; padding: 2rem; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
              <h3 style="margin: 0; font-size: 1.5rem; color: #1e293b;">Edit Keywords</h3>
              <button id="edit-keywords-close" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #64748b; padding: 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;">&times;</button>
            </div>
            
            <!-- Warning and Instructions Box -->
            <div style="background: #fef3c7; border: 1px solid #fbbf24; border-radius: 6px; padding: 1rem; margin-bottom: 1.5rem;">
              <div style="display: flex; align-items: start; gap: 0.75rem;">
                <div style="color: #d97706; font-size: 1.25rem; line-height: 1; margin-top: 0.125rem;"></div>
                <div style="flex: 1;">
                  <div style="font-weight: 600; color: #92400e; font-size: 0.9rem; margin-bottom: 0.5rem;">Important: Data Loss Warning</div>
                  <ul style="margin: 0; padding-left: 1.25rem; color: #78350f; font-size: 0.85rem; line-height: 1.6;">
                    <li><strong>Removing keywords:</strong> All historical data (rankings, AI citations, SERP features) will be permanently deleted.</li>
                    <li><strong>Changing/renaming keywords:</strong> Treated as removing the old keyword and adding a new one. All data is lost and cannot be recovered.</li>
                    <li><strong>New keywords:</strong> Will appear in the list but won't have data until you run a "Ranking & AI check".</li>
                  </ul>
                  <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #fbbf24; color: #78350f; font-size: 0.85rem;">
                    <strong>Instructions:</strong> Enter one keyword per line. Changes will be saved immediately. Keywords will be updated on the next Ranking & AI check.
                    <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                      <label for="csv-upload" style="display: inline-flex; align-items: center; padding: 0.375rem 0.75rem; background: #3b82f6; color: white; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                         Upload CSV
                        <input type="file" id="csv-upload" accept=".csv,.txt" style="display: none;" />
                      </label>
                      <span style="color: #78350f; font-size: 0.8rem;">Upload a CSV file (one keyword per line, first column)</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <textarea id="edit-keywords-textarea" style="width: 100%; min-height: 300px; padding: 0.75rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.9rem; font-family: inherit; resize: vertical; box-sizing: border-box; color: #1e293b; background: white;"></textarea>
            <div style="display: flex; justify-content: flex-end; gap: 0.75rem; margin-top: 1.5rem;">
              <button id="edit-keywords-cancel" style="padding: 0.5rem 1rem; background: #f1f5f9; color: #475569; border: 1px solid #cbd5e1; border-radius: 4px; cursor: pointer; font-size: 0.9rem;">Cancel</button>
              <button id="edit-keywords-save" style="padding: 0.5rem 1rem; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; font-weight: 600;">Save Keywords</button>
            </div>
            <div id="edit-keywords-status" style="margin-top: 1rem; font-size: 0.85rem; color: #475569; min-height: 1.5rem;"></div>
          </div>
        </div>

        <!-- Section B: Metric pills row -->
        <div class="ranking-metric-pills">
          <div class="metric-pill metric-pill--red" id="ranking-card-ai-coverage">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">AI Overview coverage</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Pillars: Visibility, Content/Schema</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-ai-coverage')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-ai-coverage-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-ai-citations">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">AI citations (alanranger.com)</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Pillars: Authority (Reviews), Content/Schema</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-ai-citations')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-ai-citations-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-ai-citations-money">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">AI citations (Money pages)</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Counts citations to Landing/Event/Product pages (cited URLs)</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-ai-citations-money')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-ai-citations-money-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-top10">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">Top-10 rank coverage</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Pillars: Visibility, Authority (Ranking)</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-top10')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-top10-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-serp-features">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">SERP feature coverage</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Pillars: Content/Schema, Local Entity</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-serp-features')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-serp-features-details"></div>
          </div>
        </div>

        <!-- Global Insights & actions and Visibility metrics side by side (underneath summary tiles) -->
        <div class="ranking-cards-side-by-side">
          <!-- Global Insights & actions (all tracked keywords) -->
          <section class="card card--insights" id="ranking-ai-insights-card-global">
            <div class="card-header">
              <h2>Insights &amp; actions (all tracked keywords)</h2>
              <p class="card-subtitle">
                Recommendations based on how your tracked keywords currently rank in classic search and appear in AI Overviews.
                These insights are global, not tied to the selected keyword.
              </p>
            </div>
            <div class="card-pill-container" id="ranking-ai-insights-list-global">
              <!-- Content populated by renderRankingAiInsights -->
            </div>
          </section>

          <!-- Tracked keyword visibility metrics (DataForSEO only - not part of GAIO pillars) -->
          <div class="ranking-visibility-metrics-section" id="ranking-visibility-metrics">
            <div class="card" style="background: rgba(204, 255, 255, 0.15); border-left: 4px solid #CCFFFF;">
            <div class="card-header">
              <h4 style="font-size: 14pt !important; margin-bottom: 0.5rem;">Tracked keyword visibility (DataForSEO)</h4>
              <div style="font-size: 12pt !important; color: #666; margin-bottom: 0.75rem; line-height: 1.5;">
                <p style="margin-bottom: 0.5rem;">
                  These metrics use DataForSEO live rankings and Google Ads search volume for your tracked keyword set only.
                </p>
                <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                  <li><strong>Demand-weighted avg position</strong>  average Google rank where each keyword is weighted by its monthly search volume (high-demand terms pull this number more).</li>
                  <li><strong>Unweighted avg position</strong>  simple average rank across all tracked keywords, with each keyword counted equally.</li>
                </ul>
                <p style="margin-top: 0.5rem; margin-bottom: 0;">
                  These are diagnostic metrics for your tracked set; the main Visibility and Authority pillar scores are still calculated from full Google Search Console data across all queries and pages.
                </p>
              </div>
              <div style="display: flex; gap: 2rem; flex-wrap: wrap; font-size: 14pt !important; align-items: baseline;">
                <div>
                  <strong style="font-size: 13pt !important;">Demand-weighted avg position:</strong>
                  <span id="ranking-avg-position-weighted" style="font-weight: bold; color: #0284c7; font-size: 16pt !important; margin-left: 0.5rem;"></span>
                  <span title="Average rank for tracked keywords where each rank is weighted by the keyword's monthly search volume from DataForSEO." style="margin-left: 0.25rem; opacity: 0.6; cursor: help; font-size: 12pt !important;"></span>
                </div>
                <div style="font-size: 12pt !important; color: #666;">
                  <strong>Unweighted avg position:</strong>
                  <span id="ranking-avg-position-unweighted" style="font-weight: normal; margin-left: 0.5rem;"></span>
                  <span title="Simple average rank for all tracked keywords from DataForSEO, each keyword counted once." style="margin-left: 0.25rem; opacity: 0.6; cursor: help;"></span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Keyword Priority Matrix (Impact  Difficulty) - Full width below side-by-side cards -->
        <div class="ranking-priority-matrix-section" id="ranking-priority-matrix-section" style="display: none; width: 100%; clear: both; float: none;">
          <div class="card" style="background: rgba(204, 255, 255, 0.15); border-left: 4px solid #CCFFFF; padding: 1.5rem;">
            <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Keyword Priority  Impact & Difficulty</h3>
            <p style="margin: 0 0 1rem 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
              Uses search volume share and current rank to surface the highest-impact keywords to work on.
              Impact is driven mainly by search volume share (global, not filter-relative) and opportunity score. Difficulty reflects current rank bucket (page 1 vs page 2+).
            </p>
            <div id="ranking-keyword-priority-matrix" style="background: #f8fafc; padding: 1rem; border-radius: 8px;">
              <!-- 3x3 grid rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Domain Strength (manual monthly snapshots) -->
        <div class="ranking-domain-strength-section" id="ranking-domain-strength-section" style="width: 100%; clear: both; float: none; margin: 1.5rem 0;">
          <div class="card" style="background: rgba(204, 255, 255, 0.15); border-left: 4px solid #CCFFFF; padding: 1.5rem;">
            <div style="display: flex; align-items: center; justify-content: space-between; gap: 1rem; flex-wrap: wrap;">
              <div>
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">
                  Domain Strength (Google  DataForSEO Labs)
                  <span
                    class="domain-strength-help"
                    title="Domain Strength (0100) is a composite score based on DataForSEO Labs. It combines:&#10; Estimated organic traffic value (visibility)&#10; Total organic keywords (breadth)&#10; Share of keywords ranking in Googles top 10 (quality)&#10;We calculate it monthly and store history so you can see trends over time."
                  >?</span>
                </h3>
                <p style="margin: 0; font-size: 0.9rem; color: #64748b; line-height: 1.6;">
                  Manual monthly snapshots based on DataForSEO Labs <code style="font-size: 0.85rem;">domain_rank_overview</code>.
                  Uses visibility (ETV), breadth (ranking keywords), and top10 share to produce a 0100 score.
                </p>
              </div>
              <div style="display: flex; gap: 0.75rem; align-items: center;">
                <button id="domain-strength-run-btn" class="btn btn-secondary" type="button">
                  Run Domain Strength Snapshot (Google)
                </button>
              </div>
            </div>

            <!-- Full-page progress overlay -->
            <div id="domain-strength-overlay" class="domain-strength-overlay">
              <div class="domain-strength-overlay-content">
                <div class="spinner"></div>
                <h3>Running Domain Strength Snapshot</h3>
                <p id="domain-strength-overlay-status">Fetching domain data from DataForSEO...</p>
              </div>
            </div>

            <!-- Completion modal -->
            <div id="domain-strength-completion-modal" class="domain-strength-overlay" style="display: none;">
              <div class="domain-strength-overlay-content" style="max-width: 500px;">
                <h3 style="margin: 0 0 1rem 0; font-size: 1.5rem; font-weight: 700; color: #1e293b;"> Snapshot Complete</h3>
                <div id="domain-strength-completion-stats" style="text-align: left; margin: 1.5rem 0;">
                  <!-- Stats will be inserted here -->
                </div>
                <button id="domain-strength-completion-close" class="btn btn-primary" style="margin-top: 1rem; width: 100%;">Close</button>
              </div>
            </div>

            <div class="domain-strength-summary-row">
              <div class="domain-strength-summary-card" id="domain-strength-summary-card">
                <div style="color:#64748b; font-size:0.95rem;">Loading domain strength</div>
              </div>
              <div style="font-size: 0.875rem; color: #64748b; line-height: 1.6;">
                <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #475569;">Understanding Domain Strength:</p>
                <ul style="margin: 0; padding-left: 1.25rem; list-style-type: disc;">
                  <li style="margin-bottom: 0.25rem;"><strong>Strength score (0-100):</strong> Composite metric combining estimated organic traffic value (visibility), total organic keywords (breadth), and share of keywords ranking in Google's top 10 (quality).</li>
                  <li style="margin-bottom: 0.25rem;"><strong>Band:</strong> Qualitative classification: Very weak (0-19), Weak (20-39), Moderate (40-59), Strong (60-79), Very strong (80-100).</li>
                  <li style="margin-bottom: 0.25rem;"><strong>ETV:</strong> Estimated Traffic Value in USD. DataForSEO's estimate of monthly organic traffic value based on keyword rankings and search volume.</li>
                  <li style="margin-bottom: 0.25rem;"><strong>Top-10 keywords:</strong> Number of keywords ranking in Google's top 10 positions. Higher counts indicate broader keyword coverage.</li>
                  <li style="margin-bottom: 0.25rem;"><strong>Change:</strong> Change in Strength score compared to the previous snapshot. Positive values (green ) indicate improvement.</li>
                  <li><strong>12-month trend:</strong> Visual graph showing Strength score over the last 12 months. Each point represents a monthly snapshot.</li>
                </ul>
              </div>
            </div>

            <div id="domain-strength-run-status" style="margin-top: 0.75rem; font-size: 0.875rem; color: #64748b;"></div>
            <h3 style="margin-top: 1.5rem; margin-bottom: 1rem; font-size: 1.25rem; font-weight: 600; color: #1e293b;">Competitors</h3>
            <div class="ranking-table-wrapper" style="margin-top: 1rem; max-height: none;">
              <div style="position: relative; overflow: visible; max-height: 80vh; overflow-y: auto;">
                <table class="ranking-table" id="domain-strength-table" style="position: relative;">
                  <thead id="domain-strength-thead" style="position: sticky; top: 0; z-index: 10; background: #f8fafc;">
                  <tr>
                    <th data-sort="name" class="sortable" title="Domain name or label for this site">
                      <div>Name <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Domain name or label for this site"></div>
                    </th>
                    <th data-sort="segment" class="sortable" title="Category or ownership segment (e.g., 'Your site' for your primary domain, or competitor segment)">
                      <div>Domain type <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Category or ownership segment (e.g., 'Your site' for your primary domain, or competitor segment)"></div>
                    </th>
                    <th data-sort="score" class="sortable" title="Domain Strength score (0-100). Composite metric combining: Estimated organic traffic value (visibility), Total organic keywords (breadth), and Share of keywords ranking in Google's top 10 (quality). Higher scores indicate stronger domain authority.">
                      <div>Strength score <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Domain Strength score (0-100). Composite metric combining: Estimated organic traffic value (visibility), Total organic keywords (breadth), and Share of keywords ranking in Google's top 10 (quality). Higher scores indicate stronger domain authority."></div>
                    </th>
                    <th data-sort="band" class="sortable" title="Qualitative band based on Strength score: Very weak (0-19), Weak (20-39), Moderate (40-59), Strong (60-79), Very strong (80-100)">
                      <div>Band <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Qualitative band based on Strength score: Very weak (0-19), Weak (20-39), Moderate (40-59), Strong (60-79), Very strong (80-100)"></div>
                    </th>
                    <th data-sort="etv" class="sortable" style="text-align:right;" title="Estimated Traffic Value (ETV). DataForSEO's estimate of monthly organic traffic value in USD based on keyword rankings and search volume. Higher values indicate more valuable organic traffic potential.">
                      <div style="text-align:right;">ETV <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Estimated Traffic Value (ETV). DataForSEO's estimate of monthly organic traffic value in USD based on keyword rankings and search volume. Higher values indicate more valuable organic traffic potential."></div>
                    </th>
                    <th data-sort="top10" class="sortable" style="text-align:right;" title="Number of keywords ranking in Google's top 10 positions. Higher counts indicate broader keyword coverage and stronger domain authority across multiple search terms.">
                      <div style="text-align:right; line-height: 1.2;">Top10<br>keywords <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Number of keywords ranking in Google's top 10 positions. Higher counts indicate broader keyword coverage and stronger domain authority across multiple search terms."></div>
                    </th>
                    <th data-sort="change" class="sortable" style="text-align:center;" title="Change in Strength score compared to the previous snapshot. Positive values (green ) indicate improvement, negative values (red ) indicate decline. Shows how domain strength is trending between snapshots.">
                      <div>Change <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Change in Strength score compared to the previous snapshot. Positive values (green ) indicate improvement, negative values (red ) indicate decline. Shows how domain strength is trending between snapshots."></div>
                    </th>
                    <th style="text-align:center;" title="Visual trend graph showing Strength score over the last 12 months. Each point represents a monthly snapshot. Helps identify long-term trends and patterns in domain authority changes.">
                      <div>12month trend</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Visual trend graph showing Strength score over the last 12 months. Each point represents a monthly snapshot. Helps identify long-term trends and patterns in domain authority changes."></div>
                    </th>
                    <th style="text-align:center;" title="Mark this domain as a competitor">
                      <div>Competitor</div>
                    </th>
                  </tr>
                  </tr>
                </thead>
                <tbody id="domain-strength-table-body">
                  <tr><td colspan="9" class="ranking-table-empty">No domain strength snapshots yet. Click "Run Domain Strength Snapshot".</td></tr>
                </tbody>
              </table>
              </div>
            </div>
            <div id="domain-strength-pagination-controls" style="margin-top: 1rem; display: flex; justify-content: space-between; align-items: center; padding-top: 1rem; border-top: 1px solid #e2e8f0; flex-wrap: wrap; gap: 1rem;">
              <div style="font-size: 0.85rem; color: #64748b;">
                <span id="domain-strength-pagination-info">Page 1 of 1  Total: 0</span>
              </div>
              <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  Rows per page:
                  <select id="domain-strength-rows-per-page" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; background: white; cursor: pointer;">
                    <option value="10" selected>10</option>
                    <option value="25">25</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                    <option value="all">All</option>
                  </select>
                </label>
                <button id="domain-strength-pagination-prev" type="button" disabled style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cbd5e1; background: #f1f5f9; cursor: not-allowed; color: #94a3b8; font-weight: 600;">
                  Previous
                </button>
                <button id="domain-strength-pagination-next" type="button" disabled style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cbd5e1; background: #f1f5f9; cursor: not-allowed; color: #94a3b8; font-weight: 600;">
                  Next
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Section C: Filters + full-width table -->
        <div class="ranking-table-section" style="width: 100%; clear: both; float: none;">
          <div class="card">
            <div class="card-header">
              <h3>Keyword rankings &amp; AI usage</h3>
              <p class="card-subtitle ranking-subtitle-tight" style="max-width: 100%; width: 100%;">
                Keyword-level inputs to <strong>Visibility</strong> and the <strong>Authority  Behaviour / Ranking</strong> components. Search volume shows demand for each tracked keyword (Visibility pillar). Combined with AI citations, it also highlights topics where you have strong or weak Authority. AI columns show where <strong>Content/Schema</strong> helps make you a source.
              </p>
            </div>
            <!-- Preset buttons -->
            <div class="ranking-presets-section" style="padding: 1rem 1.5rem; border-bottom: 1px solid #e2e8f0; background: #f8fafc;">
              <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center;">
                <span style="font-size: 0.875rem; font-weight: 600; color: #475569; margin-right: 0.5rem;">Presets:</span>
                <button type="button" class="ranking-preset-btn" data-preset="all" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Reset all filters and restore default sort">
                  All keywords
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="high-impact-money" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Segment: Money | Best rank: 1120 | Search volume: High | Min opportunity:  65 | Sort: Opportunity ">
                  High-impact money
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="ai-overview-not-cited" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="AI Overview: On | AI citation: Not cited | Min opportunity:  50 | Sort: Volume ">
                  AI Overview, not cited
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="brand-safety" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Segment: Brand | Best rank: Not top 3 | Sort: Rank  (worst first)">
                  Brand safety
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="education-growth" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Page type: Blog | Best rank: Not top 3 | Min opportunity:  30 | Sort: Opportunity ">
                  Blog opportunities
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="local-visibility" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Page type: GBP | Best rank: Not top 3 | Min opportunity:  30 | Sort: Opportunity ">
                  Local visibility
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="top-10-opportunities" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Best rank: Not top 3 | Min opportunity:  50 | Sort: Opportunity  | Shows top 10 results">
                  Top 10 opportunities
                </button>
              </div>
              <!-- Criteria chips (shown when preset is active) -->
              <div id="ranking-preset-criteria-chips" style="display: none; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0;">
                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center;">
                  <!-- Chips will be inserted here by JavaScript -->
                </div>
              </div>
            </div>
            <div class="ranking-filters-section" style="padding: 1rem 1.5rem; border-bottom: 1px solid #e2e8f0;">
              <div class="ranking-filter-bar" style="display: flex; flex-wrap: nowrap; gap: 0.75rem; align-items: flex-end; margin-bottom: 0.75rem;">
                <div class="filter-group">
                  <label>Segment:</label>
                  <select id="ranking-filter-segment" class="filter-control">
                    <option value="all">All</option>
                    <option value="brand">Brand</option>
                    <option value="money">Money</option>
                    <option value="education">Education</option>
                    <option value="other">Other</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Best rank:</label>
                  <select id="ranking-filter-rank" class="filter-control">
                    <option value="all">All</option>
                    <option value="top3">Top 3</option>
                    <option value="4-10">410</option>
                    <option value="11-20">1120</option>
                    <option value="21+">21+ / Not ranked</option>
                    <option value="not-top3">Not top 3</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Search volume:</label>
                  <select id="ranking-filter-volume" class="filter-control">
                    <option value="all">All</option>
                    <option value="high">High (200+)</option>
                    <option value="medium">Medium (50-199)</option>
                    <option value="low">Low (1-49)</option>
                    <option value="none">None</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>CTR:</label>
                  <select id="ranking-filter-ctr" class="filter-control">
                    <option value="all">All</option>
                    <option value="high">High (5%)</option>
                    <option value="medium">Medium (2-4.9%)</option>
                    <option value="low">Low (<2%)</option>
                    <option value="none">No data</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Opportunity score: <span title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10; Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10; Classic ranking strength (page 1 vs page 2+ and current position).&#10; AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first.&#10;&#10;Bands: Low <40  Medium 4069  High 70" style="opacity: 0.6; cursor: help;"></span></label>
                  <select id="ranking-filter-opportunity" class="filter-control">
                    <option value="all">All</option>
                    <option value="high">High ( 70)</option>
                    <option value="medium">Medium (4069)</option>
                    <option value="low">Low (< 40)</option>
                  </select>
                </div>
                <div class="filter-group">
                  <label>Min opportunity:</label>
                  <input type="number" id="ranking-filter-min-opportunity" class="filter-control" placeholder="e.g. 65" min="0" max="100" step="1" style="width: 80px;">
                  <div id="ranking-filter-min-opportunity-note" style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem; display: none;">
                    Min opportunity overrides band selection.
                  </div>
                </div>

                <div class="filter-group">
                  <label>AI Overview:</label>
                  <select id="ranking-filter-ai-overview" class="filter-control">
                    <option value="all">All</option>
                    <option value="has">Has AI Overview</option>
                    <option value="no">No AI Overview</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>AI citation:</label>
                  <select id="ranking-filter-ai-citation" class="filter-control">
                    <option value="all">All</option>
                    <option value="cited">Cited in AI</option>
                    <option value="not-cited">Not cited</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Page type:</label>
                  <select id="ranking-filter-page-type" class="filter-control">
                    <option value="all">All</option>
                    <option value="GBP">GBP</option>
                    <option value="Blog">Blog</option>
                    <option value="Landing">Landing</option>
                    <option value="Event">Event</option>
                    <option value="Product">Product</option>
                    <option value="Other">Other</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>SERP features:</label>
                  <select id="ranking-filter-serp-features" class="filter-control">
                    <option value="all">All</option>
                    <option value="ai-overview">AI Overview</option>
                    <option value="local-pack">Local pack</option>
                    <option value="paa">People Also Ask</option>
                    <option value="featured-snippet">Featured snippet</option>
                    <option value="none">None</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Optimisation status: <span title="Filter keywords by their optimisation tracking status. Shows whether optimisation work is planned, in progress, being monitored, completed, paused, cancelled, or not yet tracked." style="opacity: 0.6; cursor: help;"></span></label>
                  <select id="ranking-filter-optimisation-status" class="filter-control">
                    <option value="all">All</option>
                    <option value="not-tracked">Not tracked</option>
                    <option value="planned">Planned</option>
                    <option value="in_progress">In progress</option>
                    <option value="monitoring">Monitoring</option>
                    <option value="done">Done</option>
                    <option value="paused">Paused</option>
                    <option value="cancelled">Cancelled</option>
                  </select>
                </div>
              </div>

              <div style="display: flex; gap: 0.75rem; align-items: flex-end;">
                <div class="filter-group filter-group-search" style="flex: 1; min-width: 300px;">
                  <label>Search:</label>
                  <input type="text" id="ranking-filter-keyword" class="filter-control" placeholder="Filter by keyword...">
                </div>

                <div class="filter-group filter-group-button" style="align-items: end;">
                  <button id="ranking-filter-clear" class="btn btn-small" style="width: 100%;">Clear filters</button>
                </div>
              </div>
            </div>
            <div class="ranking-table-wrapper" style="max-height: none;">
              <table class="ranking-table" id="ranking-ai-table">
                <thead>
                  <tr>
                    <th data-sort="keyword" class="sortable" title="The tracked keyword or search query.">
                      <div>Keyword <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="The tracked keyword or search query."></div>
                    </th>
                    <th data-sort="segment" class="sortable" title="Keyword intent segment: Brand (branded queries), Money (commercial intent), Education (informational), or Other.">
                      <div>Segment <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Keyword intent segment: Brand (branded queries), Money (commercial intent), Education (informational), or Other."></div>
                    </th>
                    <th data-sort="rank" class="sortable" title="Current organic search ranking position for this keyword. Lower numbers are better (1 is the top position).">
                      <div>Current organic rank <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Current organic search ranking position for this keyword. Lower numbers are better (1 is the top position)."></div>
                    </th>
                    <th data-sort="volume" class="sortable" title="Average monthly Google search volume for this keyword in the UK. Source: DataForSEO Labs  Keyword Overview.">
                      <div>Search volume <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Average monthly Google search volume for this keyword in the UK. Source: DataForSEO Labs  Keyword Overview."></div>
                    </th>
                    <th data-sort="ctr" class="sortable" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days.">
                      <div>CTR (28d) <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days (matches GSC UI)."></div>
                    </th>
                    <th data-sort="impressions30d" class="sortable" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days.">
                      <div>Impressions (28d) <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days (matches GSC UI)."></div>
                    </th>
                    <th data-sort="opportunityScore" class="sortable" title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10; Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10; Classic ranking strength (page 1 vs page 2+ and current position).&#10; AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first.">
                      <div>Opportunity score <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10; Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10; Classic ranking strength (page 1 vs page 2+ and current position).&#10; AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first."></div>
                    </th>
                    <th title="Whether Google AI Overview is present in SERP results for this keyword.">
                      <div>AI Overview</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Whether Google AI Overview is present in SERP results for this keyword."></div>
                    </th>
                    <th data-sort="citations" class="sortable" title="Number of citations from your domain (alanranger.com) out of total citations in AI Overview for this keyword.">
                      <div>AI citations <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Number of citations from your domain (alanranger.com) out of total citations in AI Overview for this keyword."></div>
                    </th>
                    <th title="This is the traditional blue link in SERP results.">
                      <div>Classic Ranking URL</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="This is the traditional blue link in SERP results."></div>
                    </th>
                    <th data-sort="pageType" class="sortable" title="Type of page that ranks for this keyword: GBP (Google Business Profile), Landing (landing page), Event (event/workshop page), Product (product/service page), or Other.">
                      <div>Page type <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Type of page that ranks for this keyword: GBP (Google Business Profile), Landing (landing page), Event (event/workshop page), Product (product/service page), or Other."></div>
                    </th>
                    <th title="Optimisation tracking status for this keyword and target URL. Shows whether optimisation work is planned, in progress, being monitored, or completed.">
                      <div>Optimisation</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Optimisation tracking status for this keyword and target URL. Shows whether optimisation work is planned, in progress, being monitored, or completed."></div>
                    </th>
                  </tr>
                </thead>
                <tbody id="ranking-ai-table-body">
                  <tr><td colspan="12" class="ranking-table-empty">Click "Run ranking &amp; AI check" to load data.</td></tr>
                </tbody>
              </table>
            </div>
            <div class="ranking-pagination-controls" id="ranking-pagination-controls" style="display: none;">
              <div class="ranking-pagination-info" id="ranking-pagination-info">
                Showing 0-0 of 0
              </div>
              <div class="ranking-pagination-buttons">
                <button id="ranking-pagination-first" type="button">First</button>
                <button id="ranking-pagination-prev" type="button">Previous</button>
                <span id="ranking-pagination-page-info" style="padding: 0 0.5rem; font-size: 0.875rem;">Page 1 of 1</span>
                <button id="ranking-pagination-next" type="button">Next</button>
                <button id="ranking-pagination-last" type="button">Last</button>
              </div>
              <div class="ranking-rows-per-page">
                <label>Rows per page:</label>
                <select id="ranking-rows-per-page">
                  <option value="10" selected>10</option>
                  <option value="25">25</option>
                  <option value="50">50</option>
                  <option value="100">100</option>
                  <option value="all">All</option>
                </select>
              </div>
            </div>
          </div>
        </div>

        <!-- Section D: Keyword details & insights (three columns: 33% each) -->
        <div class="ranking-details-grid">
          <div class="card" id="ranking-ai-detail-card">
            <div class="card-header">
              <h3>Keyword Scorecard</h3>
              <p class="card-subtitle ranking-subtitle-tight">
                Detailed analysis of the selected keyword's impact, difficulty, and recommended actions. Shows demand, ranking strength, AI usage, and priority.
              </p>
            </div>
            <div class="ranking-ai-detail-body">
              <p id="ranking-ai-detail-empty">
                Select a keyword in the table or a cell in the priority grid to see a detailed scorecard.
              </p>
              <div id="ranking-ai-detail-content" class="ranking-ai-detail-content" hidden>
                <h4 id="ranking-ai-detail-keyword"></h4>
                <p id="ranking-ai-detail-summary"></p>
              </div>
            </div>
          </div>

          <div class="card" id="ranking-ai-competitors-card">
            <div class="card-header">
              <h3>Competitors in AI &amp; SERPs</h3>
              <p class="card-subtitle ranking-subtitle-tight">
                Domains that appear repeatedly in AI citations and/or classic top-10 rankings. Competitive backdrop for <strong>Authority</strong> and <strong>Visibility</strong>.
              </p>
            </div>
            <div style="padding: 0 1.25rem 1.25rem 1.25rem;">
              <div style="overflow-x: auto; max-width: 100%;">
                <table id="ranking-ai-competitors-table" style="width: 100%; border-collapse: collapse; table-layout: fixed; font-size: 0.8rem;">
                  <thead>
                    <tr style="background: #f1f5f9;">
                      <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 35%; word-wrap: break-word;">Domain</th>
                      <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 20%;">AI citations</th>
                      <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 25%;">Domain Rank</th>
                      <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 15%; word-wrap: break-word; line-height: 1.2;">
                        <div style="display: flex; flex-direction: column; align-items: flex-start;">
                          <span>Domain</span>
                          <span>type</span>
                        </div>
                      </th>
                      <th style="text-align: center; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 5%;">C</th>
                    </tr>
                  </thead>
                  <tbody id="ranking-ai-competitors-body"></tbody>
                </table>
              </div>
              <p style="margin: 0.75rem 0 0 0; font-size: 0.8rem; color: #64748b;">
                Domain Rank is sourced from your latest Domain Strength snapshot (0100).
              </p>
            </div>
          </div>

          <div class="card" id="ranking-ai-citations-card">
            <div class="card-header">
              <h3>AI Citations for Selected Keyword</h3>
              <p class="card-subtitle ranking-subtitle-tight">
                Pages from alanranger.com and other domains cited in AI Overviews for the selected keyword.
              </p>
            </div>
            <div class="ranking-ai-detail-body">
              <p id="ranking-ai-citations-empty">
                Select a keyword in the table to see AI citations.
              </p>
              <div id="ranking-ai-citations-content" hidden>
                <p class="card-subtitle ranking-subtitle-tight" style="margin-bottom: 1rem;">
                  Pages from alanranger.com and other domains cited in AI Overviews for the selected keyword.
                </p>
                <h5>Your cited pages</h5>
                <ul id="ranking-ai-detail-our-pages" class="ranking-ai-detail-list"></ul>

                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                  <h5 style="margin: 0;">Other cited domains</h5>
                  <button id="backfill-domain-ranks-btn" onclick="backfillMissingDomainRanks()" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;" title="Fetch Domain Rank for domains currently showing ''">Backfill Missing Ranks</button>
                </div>
                <div style="overflow-x: auto; margin-top: 0.5rem; max-width: 100%;">
                  <table id="ranking-ai-detail-competitors-table" style="width: 100%; border-collapse: collapse; table-layout: fixed; font-size: 0.8rem;">
                    <thead>
                      <tr style="background: #f1f5f9;">
                        <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 28%; word-wrap: break-word;">Domain</th>
                        <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 12%;">Citations</th>
                        <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 18%;">Domain Rank</th>
                        <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 16%; word-wrap: break-word; line-height: 1.2;">
                          <div style="display: flex; flex-direction: column; align-items: flex-start;">
                            <span>Domain</span>
                            <span>type</span>
                          </div>
                        </th>
                        <th style="text-align: center; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 26%;">Competitor</th>
                      </tr>
                    </thead>
                    <tbody id="ranking-ai-detail-competitors-body"></tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- AI Sources & Influence Panel -->
      <section class="aigeo-panel" data-panel="ai-sources">
        <div class="container" style="max-width: 1400px; margin: 0 auto; padding: 2rem;">
          <div class="card" style="margin-bottom: 2rem;">
            <div class="card-header">
              <h2>AI Sources & Influence</h2>
              <p class="card-subtitle">
                Domains that AI relies on most often when answering your tracked keywords. Identify which external sources you should strengthen or join so AI is more confident recommending you.
              </p>
            </div>
          </div>

          <!-- Summary Tiles -->
          <div id="ai-sources-tiles" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
            <!-- Tiles will be populated by JS -->
          </div>

          <!-- Source Types & Quick Insights -->
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 2rem;">
            <!-- Left: Source Types Overview -->
            <div class="card">
              <div class="card-header">
                <h3>Source Types Overview</h3>
              </div>
              <div class="card-body" id="ai-sources-types-breakdown">
                <p style="color: #64748b; text-align: center; padding: 2rem;">Loading source types...</p>
              </div>
            </div>

            <!-- Right: AI Influence Summary -->
            <div class="card ai-sources-explainer">
              <div class="card-header">
                <h3>How to read this tab</h3>
              </div>
              <div class="card-body">
                <p style="line-height: 1.6; margin-bottom: 0.75rem;">
                  This view shows the domains AI relies on most often when answering your tracked keywords.
                </p>
                <ul style="line-height: 1.8;">
                  <li>Repeated citations from the same domain signal trusted sources in your niche.</li>
                  <li>Directories and review platforms highlight places where you need consistent NAP, reviews and listings.</li>
                  <li>Course marketplaces and education sites show where learners are discovering alternatives to your workshops and lessons.</li>
                </ul>
                <p style="line-height: 1.6; margin-top: 0.75rem; font-weight: 600;">
                  The goal is to identify which external sources you should strengthen or join so AI is more confident recommending you.
                </p>
              </div>
            </div>
          </div>
        </div>

          <!-- Domain Influence Table -->
          <div class="card ai-sources-domain-table-card">
            <div class="card-header">
              <h3>Domain Influence Table</h3>
              <div style="display: flex; gap: 1rem; margin-top: 1rem; flex-wrap: wrap;">
                <div class="filter-group">
                  <label>Source type:</label>
                  <select id="ai-sources-filter-type" class="filter-control">
                    <option value="all">All</option>
                    <option value="Directory">Directory</option>
                    <option value="Review platform">Review platform</option>
                    <option value="Course marketplace / education">Course marketplace / education</option>
                    <option value="Publisher / blog">Publisher / blog</option>
                    <option value="Other">Other</option>
                  </select>
                </div>
                <div class="filter-group">
                  <label>Domain type:</label>
                  <select id="ai-sources-filter-domain-type" class="filter-control">
                    <option value="all">All</option>
                    <option value="self">Your site</option>
                    <option value="competitor">Competitor</option>
                    <option value="site">Site</option>
                    <option value="platform">Platform</option>
                    <option value="directory">Directory</option>
                    <option value="publisher">Publisher</option>
                    <option value="vendor">Vendor</option>
                    <option value="institution">Institution</option>
                    <option value="government">Government</option>
                    <option value="unmapped">Unmapped</option>
                  </select>
                </div>
                <div class="filter-group">
                  <label>Search:</label>
                  <input type="text" id="ai-sources-filter-domain" class="filter-control" placeholder="Filter by domain...">
                </div>
                <button id="ai-sources-filter-clear" class="btn btn-small">Clear filters</button>
              </div>
            </div>
            <div class="ranking-table-wrapper">
              <table class="ranking-table" id="ai-sources-table">
                <thead style="position: sticky; top: 0; z-index: 20; background: white;">
                  <tr>
                    <th data-sort="domain" class="sortable" style="background: white;">Domain <span class="sort-indicator"></span></th>
                    <th data-sort="domain_type" class="sortable" style="background: white;">Domain type <span class="sort-indicator"></span></th>
                    <th data-sort="competitor" class="sortable" style="background: white;">Competitor <span class="sort-indicator"></span></th>
                    <th data-sort="rank" class="sortable" style="background: white;">Domain Rank <span class="sort-indicator"></span></th>
                    <th data-sort="citations" class="sortable" style="background: white;">AI citations <span class="sort-indicator"></span></th>
                    <th data-sort="keywords" class="sortable" style="background: white;">Keywords <span class="sort-indicator"></span></th>
                    <th data-sort="share" class="sortable" style="background: white;">Citation share <span class="sort-indicator"></span></th>
                    <th style="background: white;">Example page</th>
                  </tr>
                </thead>
                <tbody id="ai-sources-table-body">
                  <tr><td colspan="8" class="ranking-table-empty">Loading domain data...</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- Domain Detail Panel (Right Side) -->
          <div id="ai-sources-detail-panel" style="display: none; margin-top: 2rem;">
            <div class="card">
              <div class="card-header">
                <h3 id="ai-sources-detail-domain">Domain Details</h3>
                <p id="ai-sources-detail-meta" class="card-subtitle"></p>
              </div>
              <div class="card-body" id="ai-sources-detail-content">
                <!-- Content populated by JS -->
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Local & Reviews Panel -->
      <section class="aigeo-panel" data-panel="local">
        <!-- Local entity, GBP, reviews content will be inserted here by JS -->
      </section>

      <!-- Optimisation Tracking Panel -->
      <section class="aigeo-panel" data-panel="optimisation" hidden>
        <div class="card card--section-header" style="display: flex; justify-content: space-between; align-items: center;">
          <div>
            <h2>Optimisation Tracking</h2>
            <p>Track and manage keyword optimisation tasks across your site. Monitor progress, cycles, and outcomes.</p>
          </div>
          <button id="optimisation-bulk-update-btn" class="btn" style="padding: 0.75rem 1.5rem; font-size: 0.95rem; white-space: nowrap;" title="Captures the latest metrics for every active task (creates a measurement entry).">
             Update All Tasks with Latest Data
          </button>
          <button id="optimisation-bulk-rebaseline-btn" class="btn" style="padding: 0.75rem 1.5rem; font-size: 0.95rem; white-space: nowrap; background: #f59e0b; color: #000000; border: 1px solid #f59e0b;" title="Rebaseline all tasks with incomplete baselines (missing AI Overview, AI Citations, or Current Rank).">
             Rebaseline Incomplete Baselines (<span id="optimisation-incomplete-baseline-count">0</span>)
          </button>
          <button id="optimisation-copy-urls-btn" class="btn" style="padding: 0.75rem 1.5rem; font-size: 0.95rem; white-space: nowrap; background: #3b82f6; color: #ffffff; border: 1px solid #3b82f6;" title="Copy all task URLs to clipboard (one URL per line).">
             Copy All Task URLs
          </button>
        </div>

        <!-- Summary Cards (B6) -->
        <h2 style="color: var(--dark-text) !important; font-size: 1.5rem; font-weight: 600; margin: 2rem 0 1rem 0;">Task Counts</h2>
        <div class="optimisation-summary-cards" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1.5rem 0;">
          <div class="card" title="Tasks with status: planned, in_progress, or monitoring (not done, cancelled, or deleted).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-active"></div>
            <div style="margin-top: 0.5rem;">Active Tasks</div>
          </div>
          <div class="card" title="Tasks with status: planned (task created but work not started).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-planned"></div>
            <div style="margin-top: 0.5rem;">Planned</div>
          </div>
          <div class="card" title="Tasks with status: in_progress (actively being worked on).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-in-progress"></div>
            <div style="margin-top: 0.5rem;">In Progress</div>
          </div>
          <div class="card" title="Tasks with status: monitoring (changes deployed, tracking results).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-monitoring"></div>
            <div style="margin-top: 0.5rem;">Monitoring</div>
          </div>
          <div class="card" title="Tasks with status: done (cycle completed; start a new cycle if optimising again).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-done"></div>
            <div style="margin-top: 0.5rem;">Done</div>
          </div>
          <div class="card" title="Tasks with status: paused (tracking stopped; you can start a new cycle later).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-paused"></div>
            <div style="margin-top: 0.5rem;">Paused</div>
          </div>
          <div class="card" title="Tasks with status: cancelled (tracking stopped; you can start a new cycle later).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-cancelled"></div>
            <div style="margin-top: 0.5rem;">Cancelled</div>
          </div>
          <div class="card" title="Tasks that have had a measurement event created in the last 28 days.">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-recent"></div>
            <div style="margin-top: 0.5rem;">Updated (28d)</div>
          </div>
        </div>

        <!-- Divider line between Task Counts and Objectives -->
        <hr style="border: none; border-top: 1px solid rgba(156, 163, 175, 0.3); margin: 2rem 0;">

        <!-- Goal Rollup Badges (Phase B) -->
        <h2 style="color: var(--dark-text) !important; font-size: 1.5rem; font-weight: 600; margin: 2rem 0 1rem 0;">Objectives</h2>
        <div class="optimisation-goal-rollups" style="display: flex; gap: 0.75rem; margin: 1rem 0; flex-wrap: wrap; align-items: center;">
          <div style="font-weight: 600; color: #475569; margin-right: 0.5rem;">Objectives:</div>
          <span id="optimisation-goal-filter-not-set" class="ranking-badge ranking-badge--segment-general" style="padding: 0.5rem 1rem; cursor: pointer;" title="Tasks with no objective set (no KPI, target, or timeframe defined). Click to filter.">
            Not set: <span id="optimisation-goal-not-set">0</span>
          </span>
          <span id="optimisation-goal-filter-on-track" class="ranking-badge ranking-badge--segment-education" style="padding: 0.5rem 1rem; cursor: pointer;" title="Objective set and not yet due, or delta is moving in the right direction but hasn't met target yet. Click to filter.">
            On track: <span id="optimisation-goal-on-track">0</span>
          </span>
          <span id="optimisation-goal-filter-overdue" class="ranking-badge ranking-badge--segment-money" style="padding: 0.5rem 1rem; background: #fee2e2; color: #991b1b; cursor: pointer;" title="Due date has passed and target has not been met. Click to filter.">
            Overdue: <span id="optimisation-goal-overdue">0</span>
          </span>
          <span id="optimisation-goal-filter-met" class="ranking-badge ranking-badge--segment-brand" style="padding: 0.5rem 1rem; background: #d1fae5; color: #065f46; cursor: pointer;" title="Target has been met (delta meets or exceeds target value). Click to filter.">
            Met: <span id="optimisation-goal-met">0</span>
          </span>
        </div>

        <!-- Objective Metrics Traffic Lights (7 columns: All Metrics aggregated + 6 individual metrics) -->
        <div class="optimisation-objective-metrics" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 1rem; margin: 2rem 0;">
          <!-- All Metrics (Aggregated) -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">All Metrics</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div class="traffic-light-pill" data-metric="all_metrics" data-bucket="worse" style="background: rgba(239, 68, 68, 0.2);" onclick="handleTrafficLightClick('all_metrics', 'worse')">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-all-metrics-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div class="traffic-light-pill" data-metric="all_metrics" data-bucket="same" style="background: rgba(245, 158, 11, 0.2);" onclick="handleTrafficLightClick('all_metrics', 'same')">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-all-metrics-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div class="traffic-light-pill" data-metric="all_metrics" data-bucket="better" style="background: rgba(16, 185, 129, 0.2);" onclick="handleTrafficLightClick('all_metrics', 'better')">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-all-metrics-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- CTR (28d) -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">CTR (28d)</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div class="traffic-light-pill" data-metric="ctr_28d" data-bucket="worse" style="background: rgba(239, 68, 68, 0.2);" onclick="handleTrafficLightClick('ctr_28d', 'worse')">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-ctr-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div class="traffic-light-pill" data-metric="ctr_28d" data-bucket="same" style="background: rgba(245, 158, 11, 0.2);" onclick="handleTrafficLightClick('ctr_28d', 'same')">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-ctr-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div class="traffic-light-pill" data-metric="ctr_28d" data-bucket="better" style="background: rgba(16, 185, 129, 0.2);" onclick="handleTrafficLightClick('ctr_28d', 'better')">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-ctr-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- Impressions (28d) -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">Impressions (28d)</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-impressions-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-impressions-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-impressions-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- Clicks (28d) -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">Clicks (28d)</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-clicks-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-clicks-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-clicks-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- Rank -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">Rank</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-rank-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-rank-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-rank-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- AI Citations -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">AI Citations</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-ai-citations-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-ai-citations-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-ai-citations-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- AI Overview -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">AI Overview</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-ai-overview-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-ai-overview-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-ai-overview-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

        </div>

        <!-- Faint gray line separator after traffic lights -->
        <div style="height: 1px; background: rgba(156, 163, 175, 0.3); margin: 2rem 0;"></div>

        <!-- Phase 9: KPI Tiles (RAG) -->
        <div class="optimisation-kpi-tiles" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 1rem; margin: 1.5rem 0;">
          <div class="card" style="cursor: pointer;" id="kpi-tile-ctr-on-track" onclick="filterByKPIRAG('ctr', 'on_track')" title="CTR objectives that are on track. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-ctr-on-track">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">CTR: On track</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-ctr-at-risk" onclick="filterByKPIRAG('ctr', 'at_risk')" title="CTR objectives at risk (due within 7 days). Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-ctr-at-risk">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">CTR: At risk</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-ctr-overdue" onclick="filterByKPIRAG('ctr', 'overdue')" title="CTR objectives that are overdue. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-ctr-overdue">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">CTR: Overdue</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-rank-improved" onclick="filterByRankDelta('improved')" title="Rank objectives with improved rank (lower is better). Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-rank-improved">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Rank: Improved</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-rank-worse" onclick="filterByRankDelta('worse')" title="Rank objectives with worsened rank. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-rank-worse">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Rank: Worse</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-rank-flat" onclick="filterByRankDelta('flat')" title="Rank objectives with no change. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-rank-flat">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Rank: Flat</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-ai-gap" onclick="filterByAIGap()" title="Tasks with AI Overview on but citations = 0. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-ai-gap">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">AI Citation Gap</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-needs-measurement" onclick="filterByNeedsMeasurement()" title="Tasks needing measurement update (>30 days or missing). Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-needs-measurement">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Needs Measurement</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-overdue-cycles" onclick="filterByOverdueCycles()" title="Tasks with overdue cycles (past due date and target not met). Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-overdue-cycles">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Overdue Cycles</div>
          </div>
        </div>

        <!-- Phase 9: Estimated Impact Tiles - Split into Potential and Actual -->
        <div class="optimisation-impact-tiles" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1.5rem 0;">
          <!-- Left Tile: Potential Extra Clicks -->
          <div class="card" id="impact-potential-clicks-card" style="cursor: pointer; position: relative; text-align: center;" title="Projection: assumes objectives met for CTR/Impressions/Clicks tasks. Uses latest measurements. Excludes Rank/AI metrics. Click to filter table to traffic KPI tasks.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="impact-potential-clicks">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Potential Extra Clicks (28d)</div>
            <div style="margin-top: 0.125rem; font-size: 0.75rem; color: rgba(255, 255, 255, 0.7);">If all CTR/Impressions/Clicks objectives are met</div>
            <div id="impact-potential-clicks-clear" style="display: none; position: absolute; top: 0.5rem; right: 0.5rem; font-size: 0.75rem; color: rgba(255, 255, 255, 0.8); cursor: pointer; padding: 0.25rem 0.5rem; background: rgba(0, 0, 0, 0.2); border-radius: 4px;" title="Clear filter"> Clear</div>
          </div>
          <!-- Right Tile: Actual Click Change -->
          <div class="card" id="impact-actual-clicks-card" style="cursor: pointer; position: relative; text-align: center;" title="Observed: baseline  latest click change across traffic KPI tasks. Uses measured clicks (or CTRImpressions fallback). Click to filter table to click-related tasks.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="impact-actual-clicks">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Actual Click Change (28d)</div>
            <div style="margin-top: 0.125rem; font-size: 0.75rem; color: rgba(255, 255, 255, 0.7);">Measured baseline  latest across click-related tasks</div>
            <div id="impact-actual-clicks-clear" style="display: none; position: absolute; top: 0.5rem; right: 0.5rem; font-size: 0.75rem; color: rgba(255, 255, 255, 0.8); cursor: pointer; padding: 0.25rem 0.5rem; background: rgba(0, 0, 0, 0.2); border-radius: 4px;" title="Clear filter"> Clear</div>
          </div>
        </div>
        
        <!-- Context strip showing task counts -->
        <div id="impact-tiles-context" style="margin-top: 0.5rem; margin-bottom: 1rem; font-size: 0.75rem; color: rgba(255, 255, 255, 0.6); text-align: center;">
          <span id="traffic-kpi-count">Traffic KPI tasks included: 0</span>
          <span style="margin: 0 1rem;">|</span>
          <span id="click-related-count">Click-related tasks included: 0</span>
        </div>

        <!-- Phase 9: Scope Toggle -->
        <div class="optimisation-scope-toggle" style="display: flex; align-items: center; gap: 1rem; margin: 1.5rem 0; padding: 1rem; background: #f9fafb; border-radius: 8px;">
          <label style="font-weight: 600; color: #374151;">Scope:</label>
          <select id="optimisation-scope-select" style="padding: 0.5rem 1rem; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer; font-size: 0.875rem;">
            <option value="active_cycle">Active Cycle Only</option>
            <option value="all_tasks">All Tasks</option>
          </select>
          <span style="font-size: 0.875rem; color: #6b7280;" id="optimisation-scope-description">Showing metrics for tasks with active cycles only</span>
        </div>

        <!-- Phase 9: Time-based Charts -->
        <div class="optimisation-timeseries-charts" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 1.5rem; margin: 1.5rem 0;">
          <div class="card" style="padding: 1.5rem;">
            <div id="chart-left-title-container" style="margin-bottom: 0.75rem;">
              <h3 id="chart-left-title" style="margin: 0 0 0.25rem 0; font-size: 1.1rem; font-weight: 600; color: var(--dark-text);">Estimated Gap to Target (28d)  Clicks Potential</h3>
              <p id="chart-left-subtitle" style="margin: 0; font-size: 0.75rem; color: rgba(255, 255, 255, 0.7); line-height: 1.3;">Sum of remaining click-equivalent gap to targets (traffic KPIs only).</p>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <button id="chart-left-toggle-clicks" class="chart-toggle-btn active" data-chart="clicks" style="padding: 0.5rem 1rem; background: var(--dark-brand); color: #000; border: 1px solid var(--dark-brand); border-radius: 4px; font-weight: 600; cursor: pointer;">Gap to Target</button>
                <button id="chart-left-toggle-trend" class="chart-toggle-btn" data-chart="trend" style="padding: 0.5rem 1rem; background: var(--dark-panel); color: var(--dark-text); border: 1px solid var(--dark-border); border-radius: 4px; font-weight: 600; cursor: pointer;">Weekly Trend</button>
                <span id="chart-trend-kpi-label" style="display: none; font-size: 0.875rem; color: var(--dark-text); margin-left: 0.5rem;">KPI: <strong id="chart-trend-kpi-label-value"></strong></span>
              </div>
              <select id="chart-trend-kpi-select" style="display: none; padding: 0.5rem; background: var(--dark-panel); color: var(--dark-text); border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem;">
                <option value="ctr_28d">CTR (pp)</option>
                <option value="impressions_28d">Impressions</option>
                <option value="clicks_28d">Clicks</option>
                <option value="current_rank">Rank</option>
                <option value="ai_citations">AI Citations</option>
              </select>
            </div>
            <div id="chart-left-container" style="position: relative; height: 280px;">
              <canvas id="chart-estimated-clicks-by-kpi" style="width: 100%; height: 280px;"></canvas>
              <canvas id="chart-median-delta-trend" style="width: 100%; height: 280px; display: none;"></canvas>
            </div>
          </div>
          <div class="card" style="padding: 1.5rem;">
            <h3 style="margin: 0 0 0.25rem 0; font-size: 1.1rem; font-weight: 600; color: var(--dark-text);">Median Delta by KPI (Last 28d)</h3>
            <p style="margin: 0 0 1rem 0; font-size: 0.75rem; color: rgba(255, 255, 255, 0.7); line-height: 1.3;">Median baseline  latest change per KPI across filtered tasks. (Median  net change.) CTR shown in pp. Negative for Rank can be good (lower rank).</p>
            <div style="position: relative; height: 280px;">
              <canvas id="chart-median-delta" style="width: 100%; height: 280px;"></canvas>
            </div>
          </div>
        </div>

        <!-- Tab Pills (B2) -->
        <div class="optimisation-tab-pills" style="display: flex; gap: 0.5rem; margin: 1.5rem 0; flex-wrap: wrap;">
          <button class="metric-pill metric-pill--neutral optimisation-tab-btn" data-tab="active" style="cursor: pointer; padding: 0.75rem 1.5rem;">
            <span>Active</span>
            <span class="optimisation-tab-count" data-tab="active">0</span>
          </button>
          <button class="metric-pill metric-pill--neutral optimisation-tab-btn" data-tab="done" style="cursor: pointer; padding: 0.75rem 1.5rem;">
            <span>Done</span>
            <span class="optimisation-tab-count" data-tab="done">0</span>
          </button>
          <button class="metric-pill metric-pill--neutral optimisation-tab-btn" data-tab="paused-cancelled" style="cursor: pointer; padding: 0.75rem 1.5rem;">
            <span>Paused/Cancelled</span>
            <span class="optimisation-tab-count" data-tab="paused-cancelled">0</span>
          </button>
        </div>

        <!-- Filters (B6) -->
        <div class="optimisation-filters" style="display: flex; gap: 1rem; margin: 1rem 0; flex-wrap: wrap; align-items: center;">
          <select id="optimisation-filter-status" style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">All Statuses</option>
            <option value="planned">Planned</option>
            <option value="in_progress">In Progress</option>
            <option value="monitoring">Monitoring</option>
            <option value="done">Done</option>
            <option value="paused">Paused</option>
            <option value="cancelled">Cancelled</option>
          </select>
          <select id="optimisation-filter-type" style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">All Types</option>
            <option value="on_page">On Page</option>
            <option value="content">Content</option>
            <option value="internal_links">Internal Links</option>
            <option value="links_pr">Links/PR</option>
            <option value="technical">Technical</option>
            <option value="local">Local</option>
            <option value="other">Other</option>
          </select>
          <input type="text" id="optimisation-filter-keyword" placeholder="Filter by keyword..." style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; flex: 1; min-width: 200px;">
          <input type="text" id="optimisation-filter-url" placeholder="Filter by URL..." style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; flex: 1; min-width: 200px;">
          <button id="optimisation-filter-needs-update" class="btn btn-secondary" style="padding: 0.5rem 1rem;" title="Show tasks that need measurement update (no measurement or older than 30 days).">Needs Update</button>
          <button id="optimisation-filter-active-cycle" class="btn btn-secondary" style="padding: 0.5rem 1rem;" title="Show only tasks with an active cycle (current cycle not completed or archived).">Active Cycle Only</button>
          <button id="optimisation-filter-overdue-cycle" class="btn btn-secondary" style="padding: 0.5rem 1rem;" title="Show tasks with overdue current cycle (past due date and target not met).">Overdue Cycle</button>
          <label style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; cursor: pointer;" title="Include test tasks in the view (test tasks are excluded from bulk updates).">
            <input type="checkbox" id="optimisation-filter-include-test" style="cursor: pointer;">
            <span>Include Test Tasks</span>
          </label>
          <button id="optimisation-clear-filters" class="btn btn-secondary" style="padding: 0.5rem 1rem;">Clear Filters</button>
        </div>

        <!-- Tasks Table (B2) -->
        <div class="ranking-table-section" style="margin-top: 1.5rem;">
          <div class="card">
            <div class="ranking-table-wrapper" id="optimisation-tasks-table-container" style="overflow: visible; max-height: none;">
            <table id="optimisation-tasks-table" class="ranking-table">
              <thead>
                <tr>
                  <th data-sort="keyword" class="sortable" title="The tracked keyword, search query, or page URL (for page-level tasks).">
                    <div>Keyword or Page <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="The tracked keyword, search query, or page URL (for page-level tasks)."></div>
                  </th>
                  <th data-sort="url" class="sortable" title="The target URL being optimised for this keyword." style="max-width: 150px;">
                    <div>Target URL <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="The target URL being optimised for this keyword."></div>
                  </th>
                  <th data-sort="type" class="sortable" title="Type of optimisation task: on_page (content/SEO changes), technical (site structure), or other.">
                    <div>Task Type <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Type of optimisation task: on_page (content/SEO changes), technical (site structure), or other."></div>
                  </th>
                  <th data-sort="status" class="sortable" title="Current status: planned (not started), in_progress (actively working), monitoring (tracking results), done (completed), paused (temporarily stopped), or cancelled.">
                    <div>Status <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Current status: planned (not started), in_progress (actively working), monitoring (tracking results), done (completed), paused (temporarily stopped), or cancelled."></div>
                  </th>
                  <th data-sort="cycle" class="sortable" title="Current cycle number. Each cycle represents a new optimisation attempt for the same keyword.">
                    <div>Cycle <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Current cycle number. Each cycle represents a new optimisation attempt for the same keyword."></div>
                  </th>
                  <th data-sort="baselineCaptured" class="sortable" title="Date when baseline metrics snapshot was captured (when task was created).">
                    <div>Baseline Captured <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Date when baseline metrics snapshot was captured (when task was created)."></div>
                  </th>
                  <th data-sort="latestCaptured" class="sortable" title="Date when latest measurement snapshot was captured, with 'Needs update' indicator if >30 days.">
                    <div>Latest Captured <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Date when latest measurement snapshot was captured, with 'Needs update' indicator if >30 days."></div>
                  </th>
                  <th data-sort="title" class="sortable" title="Optional title or label for this optimisation task.">
                    <div>Title <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Optional title or label for this optimisation task."></div>
                  </th>
                  <th data-sort="objectiveKpi" class="sortable" title="Objective KPI type (e.g., CTR, Rank, AI Citations).">
                    <div>Objective KPI <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Objective KPI type (e.g., CTR, Rank, AI Citations)."></div>
                  </th>
                  <th data-sort="baselineLatest" class="sortable" title="Baseline  Latest values for the objective KPI.">
                    <div>Baseline  Latest <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Baseline  Latest values for the objective KPI."></div>
                  </th>
                  <th data-sort="delta" class="sortable" title="Change (delta) from baseline to latest for the objective KPI.">
                    <div> vs Baseline <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Change (delta) from baseline to latest for the objective KPI."></div>
                  </th>
                  <th data-sort="dueIn" class="sortable" title="Days remaining until due date, or 'Overdue Xd' if past due.">
                    <div>Due In <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Days remaining until due date, or 'Overdue Xd' if past due."></div>
                  </th>
                  <th title="Mini trend line (sparkline) showing last ~10 measurements for the objective KPI.">
                    <div>Trend</div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Mini trend line (sparkline) showing last ~10 measurements for the objective KPI."></div>
                  </th>
                  <th title="Goal status and progress for the current cycle objective.">
                    <div>Goal</div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Goal status and progress for the current cycle objective."></div>
                  </th>
                  <th style="text-align: center;" title="Actions available for this task.">
                    <div>Actions</div>
                  </th>
                </tr>
              </thead>
              <tbody id="optimisation-tasks-tbody">
                <tr>
                  <td colspan="13" style="padding: 2rem; text-align: center; color: #666;">Loading tasks...</td>
                </tr>
              </tbody>
            </table>
            </div>
            <div class="ranking-pagination-controls" id="optimisation-pagination-controls" style="display: none;">
            <div class="ranking-pagination-info" id="optimisation-pagination-info">
              Showing 0-0 of 0
            </div>
            <div class="ranking-pagination-buttons">
              <button id="optimisation-pagination-first" type="button">First</button>
              <button id="optimisation-pagination-prev" type="button">Previous</button>
              <span id="optimisation-pagination-page-info" style="padding: 0 0.5rem; font-size: 0.875rem;">Page 1 of 1</span>
              <button id="optimisation-pagination-next" type="button">Next</button>
              <button id="optimisation-pagination-last" type="button">Last</button>
            </div>
            <div class="ranking-rows-per-page">
              <label>Rows per page:</label>
              <select id="optimisation-rows-per-page">
                <option value="10" selected>10</option>
                <option value="25">25</option>
                <option value="50">50</option>
                <option value="100">100</option>
                <option value="all">All</option>
              </select>
            </div>
          </div>
          </div>
        </div>

        <!-- Task Detail Drawer (B3) -->
        <!-- Backdrop -->
        <div id="optimisation-task-drawer-backdrop" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 999;"></div>
        
        <!-- Draggable Modal Window -->
        <div id="optimisation-task-drawer" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 1200px; max-width: 95vw; max-height: 95vh; background: var(--dark-panel); box-shadow: 0 10px 40px rgba(0,0,0,0.5); z-index: 1000; border-radius: 8px; overflow: hidden; flex-direction: column; color: var(--dark-text);">
          <!-- Draggable Header -->
          <div id="optimisation-drawer-header-bar" style="padding: 1rem 1.5rem; border-bottom: 1px solid var(--dark-border); display: flex; justify-content: space-between; align-items: center; background: var(--dark-panel); cursor: move; user-select: none;">
            <h3 id="optimisation-drawer-header-title" style="margin: 0; flex: 1; color: var(--dark-text);">Task Details</h3>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
              <button id="optimisation-drawer-minimize" style="background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0.25rem 0.5rem; color: var(--dark-text-muted);" title="Minimize"></button>
              <button id="optimisation-drawer-maximize" style="background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0.25rem 0.5rem; color: var(--dark-text-muted);" title="Maximize"></button>
              <button id="optimisation-drawer-close" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; padding: 0.25rem 0.5rem; color: var(--dark-text-muted);" title="Close">&times;</button>
            </div>
          </div>
          
          <!-- Cancel Task, Delete Task, and Title (moved to header area) -->
          <div style="padding: 0.75rem 1.5rem; border-bottom: 1px solid var(--dark-border); background: var(--dark-panel); display: flex; gap: 0.5rem; align-items: center;">
            <button id="optimisation-cancel-task-btn" class="btn" style="background: #dc2626; border: 1px solid #dc2626; padding: 0.5rem 1rem; font-size: 0.875rem; color: #ffffff; font-weight: 700;" title="Stop tracking (keeps history).">Cancel Task</button>
            <button id="optimisation-delete-task-btn" class="btn" style="background: #991b1b; border: 1px solid #991b1b; padding: 0.5rem 1rem; font-size: 0.875rem; color: #ffffff; font-weight: 700;" title="Permanently remove task and events (cannot be undone).">Delete Task</button>
            <div style="flex: 1; display: flex; align-items: center; gap: 0.5rem; margin-left: 1rem;">
              <strong style="white-space: nowrap; color: var(--dark-text);">Title:</strong>
              <input type="text" id="optimisation-drawer-title" style="flex: 1; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="Enter task title...">
            </div>
          </div>
          
          <!-- Scrollable Content -->
          <div id="optimisation-drawer-content" style="padding: 1.5rem; overflow-y: auto; flex: 1;">
          <div>
            <!-- Task Header (Full Width) -->
            <div id="optimisation-drawer-header" style="margin-bottom: 1.5rem; display: grid; grid-template-columns: 1fr 2fr 1.5fr; gap: 1.5rem;">
              <div>
                <strong>Keyword:</strong>
                <div id="optimisation-drawer-keyword" style="margin-top: 0.25rem; font-size: 1.1rem; color: #2563eb;"></div>
              </div>
              <div>
                <strong>Target URL:</strong>
                <div id="optimisation-drawer-url" style="margin-top: 0.25rem; word-break: break-all;"></div>
              </div>
              <div style="text-align: right;">
                <div style="margin-bottom: 0.5rem;">
                  <strong style="color: var(--dark-text);">Task Type:</strong>
                  <span id="optimisation-drawer-type" style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; background: rgba(156, 163, 175, 0.2); border-radius: 4px; color: var(--dark-text);"></span>
                </div>
                <div style="margin-bottom: 0.5rem;">
                  <strong>Status:</strong>
                  <span id="optimisation-drawer-status" style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; border-radius: 4px;"></span>
                </div>
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                  <strong>Cycle:</strong>
                  <span id="optimisation-drawer-cycle" style="margin-left: 0;"></span>
                  <select id="optimisation-drawer-cycle-selector" style="padding: 0.25rem 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text); cursor: pointer; display: none; min-width: 100px;" title="Select a cycle to view its objective, measurements, and events">
                    <!-- Options will be populated by JavaScript -->
                  </select>
                </div>
              </div>
            </div>

            <!-- Objective Section (Full Width) -->
            <div id="optimisation-drawer-objective" style="margin-bottom: 1.5rem; padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                  <h4 style="margin: 0; font-size: 0.95rem; font-weight: 600;">Objective <span id="optimisation-drawer-objective-cycle">(Cycle 1)</span></h4>
                  <span id="optimisation-drawer-objective-badge" style="padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; display: none;"></span>
                </div>
                <button id="optimisation-edit-objective-btn" class="btn btn-small" style="padding: 0.25rem 0.75rem; font-size: 0.875rem; background: var(--dark-brand); color: #000000; font-weight: 700; border: 1px solid var(--dark-brand);" title="Set target KPI and timeframe for this cycle.">Edit</button>
              </div>
              <div id="optimisation-drawer-objective-content" style="font-size: 0.875rem; color: var(--dark-text);">
                <div style="color: var(--dark-text-muted); font-style: italic;">Loading objective...</div>
              </div>
              <!-- Edit Objective Form (Hidden by default) -->
              <div id="optimisation-edit-objective-form" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--dark-border);">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Title</label>
                    <input type="text" id="optimisation-edit-objective-title" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="Objective title">
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">KPI Label</label>
                    <input type="text" id="optimisation-edit-objective-kpi" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="e.g., AI citations increase by 1">
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Metric</label>
                    <select id="optimisation-edit-objective-metric" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);">
                      <option value="">Select metric</option>
                      <option value="ai_citations">AI Citations</option>
                      <option value="ai_overview">AI Overview</option>
                      <option value="ctr_28d">CTR (28d)</option>
                      <option value="impressions_28d">Impressions (28d)</option>
                      <option value="clicks_28d">Clicks (28d)</option>
                      <option value="current_rank">Rank</option>
                    </select>
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Direction</label>
                    <select id="optimisation-edit-objective-direction" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);">
                      <option value="">Select direction</option>
                      <option value="increase">Increase</option>
                      <option value="decrease">Decrease</option>
                      <option value="at_least">At least</option>
                      <option value="at_most">At most</option>
                    </select>
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Target Value</label>
                    <input type="number" id="optimisation-edit-objective-target-value" step="0.01" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="0">
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Timeframe (days)</label>
                    <input type="number" id="optimisation-edit-objective-timeframe" min="1" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="30">
                  </div>
                  <div style="display: flex; align-items: flex-end;">
                    <div id="optimisation-edit-objective-due-date" style="padding: 0.5rem; font-size: 0.875rem; color: var(--dark-text-muted);"></div>
                  </div>
                </div>
                <div style="margin-bottom: 1rem;">
                  <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Plan</label>
                  <textarea id="optimisation-edit-objective-plan" rows="3" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; resize: vertical; background: var(--dark-bg); color: var(--dark-text);" placeholder="Describe your plan..."></textarea>
                </div>
                <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                  <button id="optimisation-cancel-edit-objective-btn" class="btn btn-secondary" style="padding: 0.5rem 1rem; font-size: 0.875rem;">Cancel</button>
                  <button id="optimisation-save-objective-btn" class="btn" style="padding: 0.5rem 1rem; font-size: 0.875rem;">Save</button>
                </div>
              </div>
            </div>

            <!-- Two Column Layout -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;">
              <!-- Left Column -->
              <div style="display: flex; flex-direction: column; gap: 1.5rem;">
                <!-- Performance Snapshot -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center; font-size: 0.95rem; color: var(--dark-text);">
                    <span>Performance Snapshot <span title="Shows current metrics compared to baseline measurement. Baseline is captured when the cycle starts, and latest shows the most recent measurement. Use 'Add Measurement' to capture new snapshots." style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></span>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                      <button id="optimisation-rebaseline-btn" class="btn btn-small" style="padding: 0.25rem 0.75rem; font-size: 0.875rem; background: rgba(156, 163, 175, 0.15); color: var(--dark-text); font-weight: 700; border: 1px solid var(--dark-border);" title="Create a new baseline measurement (keeps history).">Rebaseline</button>
                      <button id="optimisation-add-measurement-btn" class="btn btn-small" style="padding: 0.25rem 0.75rem; font-size: 0.875rem; background: var(--dark-brand); color: #000000; font-weight: 700; border: 1px solid var(--dark-brand);" title="Capture the latest metrics and compare to baseline.">Add Measurement</button>
                    </div>
                  </h4>
                  <div id="optimisation-metrics-snapshot" style="display: grid; grid-template-columns: 1.5fr 1fr 1fr; gap: 0.75rem; font-size: 0.9rem; color: var(--dark-text);">
                    <!-- Metrics will be populated by JavaScript -->
                    <div style="color: var(--dark-text-muted); font-style: italic; grid-column: 1 / -1;">Loading metrics...</div>
                  </div>
                </div>

                <!-- Measurement History -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; font-size: 0.95rem; display: flex; justify-content: space-between; align-items: center; color: var(--dark-text);">
                    <span>Measurement History <span title="Recent measurement snapshots for this cycle. Shows captured date, key metrics, and delta vs previous measurement." style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></span>
                    <button id="optimisation-measurement-history-toggle" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; background: rgba(156, 163, 175, 0.6); border: 1px solid var(--dark-border); border-radius: 4px; cursor: pointer;">Show</button>
                  </h4>
                  <div id="optimisation-measurement-history" style="display: none; max-height: 400px; overflow-y: auto;">
                    <div style="color: var(--dark-text-muted); font-style: italic;">Loading measurement history...</div>
                  </div>
                </div>

                <!-- Close Button -->
                <div style="padding-top: 1rem;">
                  <button id="optimisation-drawer-close-bottom" class="btn btn-secondary" style="width: 100%; padding: 0.5rem 1rem;">Close</button>
                </div>

              </div>

              <!-- Right Column -->
              <div style="display: flex; flex-direction: column; gap: 1.5rem;">
                <!-- Timeline/Events (Collapsible) -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center; cursor: pointer; font-size: 0.95rem; color: var(--dark-text);" id="optimisation-timeline-header">
                    <span>Timeline <span title="Chronological history of all events for this task: measurements, notes, status changes, and deployed changes. Click to expand or collapse the timeline view." style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></span>
                    <span id="optimisation-timeline-toggle" style="font-size: 1.2rem; user-select: none; color: var(--dark-text);"></span>
                  </h4>
                  <div id="optimisation-drawer-events-container" style="display: none;">
                    <div id="optimisation-drawer-events" style="border-left: 2px solid var(--dark-border); padding-left: 1rem; max-height: 400px; overflow-y: auto;">
                      <div style="color: var(--dark-text-muted); font-style: italic;">Loading events...</div>
                    </div>
                  </div>
                </div>

                <!-- Cycle Management -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; font-size: 0.95rem; color: var(--dark-text);">Cycle Management</h4>
                  <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                    <button id="optimisation-complete-cycle-btn" class="btn" style="width: 100%; padding: 0.5rem; font-size: 0.875rem; background: #059669; border-color: #059669; color: #ffffff; font-weight: 700;" title="Mark the current cycle as completed. This closes the cycle and makes it viewable in history.">Complete Cycle</button>
                    <button id="optimisation-archive-cycle-btn" class="btn btn-secondary" style="width: 100%; padding: 0.5rem; font-size: 0.875rem; background: #4b5563; color: #ffffff; font-weight: 700; border: 1px solid #4b5563;" title="Archive the current cycle (for abandoned work). The cycle remains in history but is marked as archived.">Archive Cycle</button>
                    <button id="optimisation-start-cycle-btn" class="btn btn-secondary" style="width: 100%; padding: 0.5rem; font-size: 0.875rem; background: rgba(156, 163, 175, 0.6); color: #000000; font-weight: 700; border: 1px solid var(--dark-border);" title="Begins a new optimisation attempt while preserving history from previous cycles.">Start New Cycle</button>
                  </div>
                </div>

                <!-- Add Event Form -->
                <div style="padding: 0.5rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.5rem; font-size: 0.95rem; color: var(--dark-text);">Add Event <span title="Record activities and milestones: Notes for observations, Change Deployed for updates, Measurement for metric snapshots, or Status Changed for workflow updates. All events appear in the Timeline." style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></h4>
                  <div style="margin-bottom: 0.5rem;">
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Event Type:</label>
                    <select id="optimisation-event-type" style="width: 100%; padding: 0.4rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);">
                      <option value="note">Note</option>
                      <option value="change_deployed">Change Deployed</option>
                      <option value="measurement">Measurement</option>
                      <option value="status_changed">Status Changed</option>
                    </select>
                  </div>
                  <div style="margin-bottom: 0.5rem;">
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Note:</label>
                    <textarea id="optimisation-event-note" rows="2" style="width: 100%; padding: 0.4rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);"></textarea>
                  </div>
                  <button id="optimisation-add-event-btn" class="btn btn-primary" style="width: 100%; padding: 0.5rem; font-size: 0.875rem; background: var(--dark-brand); color: #000000; font-weight: 700; border: 1px solid var(--dark-brand);" title="Adds the event to the timeline. Select the event type and add any notes, then click to record it.">Add Event</button>
                </div>

                <!-- Change Status -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; font-size: 0.95rem; color: var(--dark-text);">Change Status <span title="Status meanings:&#10; Planned: Task created but work not started&#10; In Progress: Currently being worked on&#10; Monitoring: Changes deployedmonitor metrics&#10; Done: Cycle completed; start a new cycle if optimising again&#10; Paused: Tracking stopped; you can start a new cycle later&#10; Cancelled: Tracking stopped; you can start a new cycle later&#10; Deleted: Task permanently removed" style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></h4>
                  <div style="display: flex; gap: 0.5rem;">
                    <select id="optimisation-change-status" style="flex: 1; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; background: var(--dark-bg); color: var(--dark-text);" title="Updates task workflow stage; adds a timeline event.">
                      <option value="">Change Status...</option>
                      <option value="planned" title="Task created but work not started">Planned</option>
                      <option value="in_progress" title="Currently being worked on">In Progress</option>
                      <option value="monitoring" title="Changes deployedmonitor metrics">Monitoring</option>
                      <option value="done" title="Cycle completed; start a new cycle if optimising again">Done</option>
                      <option value="paused" title="Tracking stopped; you can start a new cycle later">Paused</option>
                      <option value="cancelled" title="Tracking stopped; you can start a new cycle later">Cancelled</option>
                      <option value="deleted" title="Task permanently removed">Deleted</option>
                    </select>
                    <button id="optimisation-save-status-btn" class="btn btn-primary" title="Save the selected status change.">Save</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- History Panel -->
      <section class="aigeo-panel" data-panel="history">
        <!-- Supabase history charts / trend lines / previous audits will be inserted here by JS -->
      </section>

    </div>
      </div>
    </main>
    </div>

    <!-- Debug Panel - Fixed at bottom, collapsible -->
    <div class="debug-panel-bottom" id="debugPanel">
      <div class="debug-header" onclick="toggleDebugPanel()" style="cursor: pointer;">
        <h3> Debug Log</h3>
        <div class="debug-actions">
          <button class="btn btn-small" onclick="event.stopPropagation(); clearDebugLog();" title="Clear all debug log entries. Useful for starting fresh during troubleshooting.">Clear</button>
          <button class="btn btn-small" onclick="event.stopPropagation(); copyDebugLog();" title="Copy the entire debug log to your clipboard. Useful for sharing logs or troubleshooting issues.">Copy Log</button>
          <button class="btn btn-small" id="debugFilterBtn" onclick="event.stopPropagation(); toggleDebugLogFilter();" title="Filter to show only warnings and errors">Filter: All</button>
          <span id="debugToggleIcon" style="color: #fff; font-size: 1.2rem;"></span>
        </div>
      </div>
      <div class="debug-content" id="debugLog" style="display: block;">
        <div class="debug-log-entry info">
          <span class="debug-timestamp">[Initializing...]</span>Debug panel loaded. Waiting for page initialization...
        </div>
      </div>
    </div>
  </div>

  <script>
    // Immediate console log to verify script is running
    console.log('%c=== GAIO AUDIT DASHBOARD LOADED ===', 'color: #E57200; font-size: 16px; font-weight: bold;');
    console.log('%cDebug panel should be visible at bottom with orange border', 'color: #E57200; font-size: 14px;');
    console.log('Current time:', new Date().toISOString());
    console.log('Page URL:', window.location.href);

    // Build id is logged for verification only (no forced URL changes).
    const BUILD_ID = '2026-01-14T23-10Z';
    window.__BUILD_ID__ = BUILD_ID;
    console.log('Build ID:', BUILD_ID);
    // Clear persisted error logs when build changes to avoid stale errors.
    try {
      const previousBuildId = localStorage.getItem('_build_id');
      const buildChanged = !!previousBuildId && previousBuildId !== BUILD_ID;
      if (buildChanged) {
        const staleKeys = [
          '_capturedErrors',
          '_capturedWarnings',
          'last_audit_results',
          'aigeo_audit_data',
          'rankingAiData',
          'ranking_ai_data',
          'backlink_metrics'
        ];
        staleKeys.forEach((key) => {
          try { localStorage.removeItem(key); } catch (e) { /* ignore */ }
        });
      }
      localStorage.setItem('_build_id', BUILD_ID);
    } catch (e) {
      // Ignore localStorage issues.
    }
    
    // Helper function to safely save to localStorage (handles quota errors gracefully)
    // Define apiUrl helper IMMEDIATELY at the top level so it's available to all functions
    // This must be defined before any functions that use it
    (function() {
      const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
        ? 'https://ai-geo-audit.vercel.app' // Change this to your Vercel deployment URL
        : '';
      
      window.apiUrl = function apiUrl(path) {
        if (!API_BASE_URL) {
          // When deployed on Vercel, use relative paths
          return path.startsWith('/') ? path : `/${path}`;
        }
        // When running locally, prepend the Vercel URL
        // Handle paths with or without leading slash
        const cleanPath = path.startsWith('/') ? path : `/${path}`;
        return `${API_BASE_URL}${cleanPath}`;
      };
    })();

    // Global helpers to read config from either UI inputs or localStorage.
    // Preview/prod domains have different localStorage, so the UI input should be a first-class fallback.
    window.getPropertyUrl = function getPropertyUrl() {
      const domVal = (document.getElementById('propertyUrl')?.value || '').trim();
      const stored = (localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '').trim();
      const val = domVal || stored;
      // Keep localStorage in sync (so other modules that read localStorage work).
      if (val && val !== stored) {
        try { localStorage.setItem('gsc_property_url', val); } catch (e) { /* ignore */ }
      }
      return val;
    };
    
    // ======================
    // Optimisation Tracking Utilities (Phase 2)
    // ======================
    // Normalization functions matching DB helpers (arp_keyword_key, arp_clean_url)
    window.keywordKey = function keywordKey(keyword) {
      if (!keyword || typeof keyword !== 'string') return null;
      return keyword.trim().replace(/\s+/g, ' ').toLowerCase();
    };

    window.cleanUrlForKey = function cleanUrlForKey(url) {
      if (!url || typeof url !== 'string') return null;
      // Remove fragment (#)
      let cleaned = url.split('#')[0];
      // Remove query string (?)
      cleaned = cleaned.split('?')[0];
      // Remove protocol (http:// or https://)
      cleaned = cleaned.replace(/^https?:\/\//, '');
      // Remove trailing slashes
      cleaned = cleaned.replace(/\/+$/, '');
      return cleaned;
    };

    // Clean URL but keep protocol (for display in modals)
    window.cleanUrlForDisplay = function cleanUrlForDisplay(url) {
      if (!url || typeof url !== 'string') return '';
      // Remove fragment (#)
      let cleaned = url.split('#')[0];
      // Remove query string (?)
      cleaned = cleaned.split('?')[0];
      // Remove trailing slashes
      cleaned = cleaned.replace(/\/+$/, '');
      return cleaned;
    };

    // Admin key utilities (Phase A - Security)
    window.getAdminKey = function getAdminKey() {
      if (typeof window === "undefined") return "";
      // Prefer sessionStorage, but also support localStorage for persistence across browser restarts.
      return sessionStorage.getItem("arp_admin_key") || localStorage.getItem("arp_admin_key") || "";
    };

    window.setAdminKey = function setAdminKey(key) {
      if (typeof window === "undefined") return;
      sessionStorage.setItem("arp_admin_key", key);
      try { localStorage.setItem("arp_admin_key", key); } catch (e) {}
    };

    window.hasAdminKey = function hasAdminKey() {
      return window.getAdminKey().length > 0;
    };

    window.clearAdminKey = function clearAdminKey() {
      if (typeof window === "undefined") return;
      sessionStorage.removeItem("arp_admin_key");
      try { localStorage.removeItem("arp_admin_key"); } catch (e) {}
    };

    // Share mode detection
    const urlParams = new URLSearchParams(window.location.search);
    window.isShareMode = urlParams.get('share') === '1';
    window.shareToken = urlParams.get('st') || '';

    // Helper to build headers with admin key or share token
    window.getOptimisationHeaders = function getOptimisationHeaders() {
      const headers = { 'Content-Type': 'application/json' };
      if (window.isShareMode && window.shareToken) {
        headers['x-arp-share-token'] = window.shareToken;
      } else {
      const adminKey = window.getAdminKey();
      if (adminKey) {
        headers['x-arp-admin-key'] = adminKey;
        }
      }
      return headers;
    };

    // Cache for optimisation status (keyed by keyword_key::target_url_clean::task_type)
    window.optimisationStatusCache = new Map();

    // Fetch optimisation statuses in bulk
    window.fetchOptimisationStatuses = async function fetchOptimisationStatuses(rows) {
      if (!rows || rows.length === 0) {
        window.optimisationStatusCache.clear();
        return;
      }

      try {
        // Build unique set of keyword keys and URL keys
        const keywordKeys = new Set();
        const urlKeys = new Set();
        rows.forEach(row => {
          const kwKey = window.keywordKey ? window.keywordKey(row.keyword || '') : (row.keyword || '').toLowerCase().trim();
          const url = row.best_url || row.targetUrl || row.ranking_url || '';
          const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(url) : url.toLowerCase().trim();
          // Add keyword key (can be empty string for page-level tasks)
          keywordKeys.add(kwKey || '');
          if (urlKey) urlKeys.add(urlKey);
        });
        
        // DEBUG: Log what we're sending to the API
        if (Array.from(urlKeys).some(u => u.includes('landscape-photography-workshops'))) {
          console.log('[Optimisation] Sending to API:', {
            urlKeys: Array.from(urlKeys).filter(u => u.includes('landscape')),
            keywordKeys: Array.from(keywordKeys),
            totalUrlKeys: urlKeys.size,
            totalKeywordKeys: keywordKeys.size
          });
        }

        // Don't require keywordKeys - page-level tasks have empty keyword keys
        if (urlKeys.size === 0) {
          window.optimisationStatusCache.clear();
          return;
        }

        // Fetch from API endpoint (we'll create this)
        const response = await fetch(apiUrl('/api/optimisation/status'), {
          method: 'POST',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            keyword_keys: Array.from(keywordKeys),
            url_keys: Array.from(urlKeys)
          })
        });

        if (!response.ok) {
          // 401 is expected in share mode (no auth) - don't log as error
          if (response.status === 401) {
            debugLog('[Optimisation] Status fetch requires authentication (expected in share mode)', 'info');
          } else {
            let errText = '';
            try { errText = await response.text(); } catch (e) {}
            console.warn('[Optimisation] Failed to fetch statuses:', response.status, errText || '');
            debugLog(`[Optimisation] Failed to fetch statuses: ${response.status} ${errText || ''}`.trim(), 'warn');
          }
          window.optimisationStatusCache.clear();
          return;
        }

        const data = await response.json();
        
        // DEBUG: Log raw API response structure with full details
        console.log('[Optimisation] API response received:', {
          statusCount: data.statuses?.length || 0,
          sampleStatus: data.statuses?.[0] || null,
          sampleStatusKeys: data.statuses?.[0] ? Object.keys(data.statuses[0]) : [],
          allStatusesWithId: (data.statuses || []).map(s => ({
            id: s.id,
            task_id: s.task_id,
            hasId: 'id' in s,
            hasTaskId: 'task_id' in s,
            keyword_key: s.keyword_key,
            target_url_clean: s.target_url_clean,
            status: s.status
          }))
        });
        
        // CRITICAL: Preserve ALL existing cache entries BEFORE clearing
        // We'll restore any that aren't returned by the API
        const now = Date.now();
        const immediateEntryAgeLimit = 10000; // 10 seconds
        const preservedEntries = new Map();
        
        // Build set of keys we're about to fetch
        const keysBeingFetched = new Set();
        rows.forEach(row => {
          const kwKey = window.keywordKey ? window.keywordKey(row.keyword || '') : (row.keyword || '').toLowerCase().trim();
          const url = row.best_url || row.targetUrl || row.ranking_url || '';
          const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(url) : url.toLowerCase().trim();
          // Build all possible cache keys for this row (different task types)
          // 'on_page' for page-level tasks, 'content' for keyword-level tasks from Ranking & AI
          ['on_page', 'content'].forEach(taskType => {
            const cacheKey = kwKey ? `${kwKey}::${urlKey}::${taskType}` : `::${urlKey}::${taskType}`;
            keysBeingFetched.add(cacheKey);
          });
        });
        
        // CRITICAL: Preserve ALL existing entries for keys we're fetching
        // This way, if the API doesn't return them, we keep the existing cache entry
        if (window.optimisationStatusCache && window.optimisationStatusCache.size > 0) {
          window.optimisationStatusCache.forEach((value, key) => {
            // Always preserve entries for keys we're fetching (in case API doesn't return them)
            if (keysBeingFetched.has(key)) {
              preservedEntries.set(key, value);
              console.log(`[Optimisation] Preserving existing cache entry for key being fetched: key="${key}", id="${value.id || value.task_id || 'null'}"`);
            }
            // Also preserve entries that are NOT being fetched in this call
            // This prevents clearing cache for other rows that aren't part of this fetch
            if (!keysBeingFetched.has(key)) {
              preservedEntries.set(key, value);
            }
          });
        }
        
        // CRITICAL: Clear entries for keys we're fetching (we'll restore them if API doesn't return them)
        keysBeingFetched.forEach(key => {
          window.optimisationStatusCache.delete(key);
        });
        console.log(`[Optimisation] Cleared ${keysBeingFetched.size} keys from cache, preserved ${preservedEntries.size} entries (${Array.from(preservedEntries.keys()).filter(k => keysBeingFetched.has(k)).length} for keys being fetched)`);

        // Build cache map: key = keyword_key::target_url_clean::task_type
        // For page-level tasks, keyword_key is null or empty string - use empty string for consistency
        (data.statuses || []).forEach(status => {
          // CRITICAL: Ensure id field is always present - use task_id as fallback if needed
          if (!status.id) {
            if (status.task_id) {
              status.id = status.task_id;
              console.warn('[Optimisation] API response missing id field, using task_id as fallback:', {
                task_id: status.task_id,
                url: status.target_url_clean,
                status: status.status,
                allKeys: Object.keys(status)
              });
            } else {
              console.error('[Optimisation] Status object missing both id and task_id fields - skipping:', {
                status,
                keys: Object.keys(status),
                keyword_key: status.keyword_key,
                target_url_clean: status.target_url_clean
              });
              return; // Skip this status entry
            }
          }
          
          // CRITICAL: Also ensure task_id is set if missing (for backward compatibility)
          if (!status.task_id && status.id) {
            status.task_id = status.id;
          }
          
          // Normalize keyword_key: convert null/undefined to empty string, trim whitespace
          const keywordKey = (status.keyword_key || '').trim();
          // Normalize target_url_clean using cleanUrlForKey to ensure consistent lookup
          // The API returns target_url_clean, but we need to normalize it the same way we normalize URLs in getOptimisationStatus
          const normalizedUrl = window.cleanUrlForKey ? window.cleanUrlForKey(status.target_url_clean || status.target_url || '') : (status.target_url_clean || status.target_url || '').toLowerCase().trim();
          
          // DEBUG: Log every status being cached (especially page-level tasks)
          if (!status.keyword_key || status.keyword_key.trim() === '') {
            console.log('[Optimisation] Caching page-level task:', {
              key: `::${normalizedUrl}::${status.task_type || 'on_page'}`,
              id: status.id,
              task_id: status.task_id,
              url: status.target_url_clean,
              normalizedUrl: normalizedUrl,
              status: status.status,
              hasId: 'id' in status,
              hasTaskId: 'task_id' in status
            });
          }
          // For page-level tasks (empty keyword_key), use :: prefix to match getOptimisationStatus format
          // For keyword-level tasks, use keyword_key:: prefix
          const key = keywordKey ? `${keywordKey}::${normalizedUrl}::${status.task_type || 'on_page'}` : `::${normalizedUrl}::${status.task_type || 'on_page'}`;
          // Always update/overwrite with API data (API is source of truth for existing tasks)
          window.optimisationStatusCache.set(key, status);
          // Debug: Log page-level tasks with id verification
          if (!keywordKey) {
            debugLog(`[Optimisation] Cached page-level task: key="${key}", id="${status.id}", url="${status.target_url_clean}", normalized="${normalizedUrl}", status="${status.status}"`, 'info');
            // Special debug for landscape page
            if (normalizedUrl.includes('landscape-photography-workshops') || status.target_url_clean?.includes('landscape-photography-workshops')) {
              debugLog(`[Optimisation]  Landscape page task cached: key="${key}", id="${status.id}", status="${status.status}"`, 'success');
            }
          }
        });
        
        // CRITICAL: Restore preserved entries that weren't returned by the API
        // This includes both immediate cache entries AND existing entries that the API didn't return
        const keysReturnedByApi = new Set();
        (data.statuses || []).forEach(status => {
          const keywordKey = (status.keyword_key || '').trim();
          const normalizedUrl = window.cleanUrlForKey ? window.cleanUrlForKey(status.target_url_clean || status.target_url || '') : (status.target_url_clean || status.target_url || '').toLowerCase().trim();
          const key = keywordKey ? `${keywordKey}::${normalizedUrl}::${status.task_type || 'on_page'}` : `::${normalizedUrl}::${status.task_type || 'on_page'}`;
          keysReturnedByApi.add(key);
        });
        
        preservedEntries.forEach((value, key) => {
          if (!keysReturnedByApi.has(key)) {
            // API didn't return this entry - restore the preserved one
            window.optimisationStatusCache.set(key, value);
            console.log(`[Optimisation] Restored preserved entry (not returned by API): key="${key}", id="${value.id || value.task_id || 'null'}", status="${value.status || 'null'}"`);
          } else {
            // API returned this entry - verify it has id field
            const apiStatus = window.optimisationStatusCache.get(key);
            if (apiStatus) {
              console.log(`[Optimisation] Entry returned by API: key="${key}", apiId="${apiStatus.id || apiStatus.task_id || 'null'}", preservedId="${value.id || value.task_id || 'null'}"`);
              // Ensure API status has id field - if not, keep the preserved entry
              if (!apiStatus.id && !apiStatus.task_id && (value.id || value.task_id)) {
                console.warn(`[Optimisation] API status missing id field, keeping preserved entry: key="${key}"`);
                window.optimisationStatusCache.set(key, value);
              }
            }
          }
        });
        
        console.log(`[Optimisation] Cache refreshed: ${window.optimisationStatusCache.size} entries (${preservedEntries.size} preserved immediate entries)`);

        console.log(`[Optimisation] Loaded ${window.optimisationStatusCache.size} status records (${(data.statuses || []).filter(s => !s.keyword_key || s.keyword_key.trim() === '').length} page-level)`);
      } catch (error) {
        debugLog(`[Optimisation] Error fetching statuses: ${error?.message || error}`, 'warn');
        window.optimisationStatusCache.clear();
      }
    };

    // Get optimisation status for a row
    window.getOptimisationStatus = function getOptimisationStatus(row, taskType = 'on_page') {
      const kwKey = window.keywordKey ? window.keywordKey(row.keyword || '') : (row.keyword || '').toLowerCase().trim();
      const url = row.best_url || row.targetUrl || row.ranking_url || '';
      const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(url) : url.toLowerCase().trim();
      
      // For page-level tasks (on_page), keyword can be empty - only require urlKey
      // For keyword-level tasks (content, keyword, etc.), require both kwKey and urlKey
      if (taskType === 'on_page') {
        if (!urlKey) return null;
        // For page-level tasks, use empty string for keyword_key
        const key = `::${urlKey}::${taskType}`;
        const status = window.optimisationStatusCache.get(key) || null;
        
        // CRITICAL: Ensure status object has id field (use task_id as fallback)
        if (status && !status.id) {
          if (status.task_id) {
            status.id = status.task_id;
            console.warn('[Optimisation] Status object missing id field, using task_id as fallback:', {
              task_id: status.task_id,
              url: status.target_url_clean || url,
              key
            });
          } else {
            console.error('[Optimisation] Status object missing both id and task_id fields:', {
              status,
              url,
              key
            });
            return null; // Return null if no id available
          }
        }
        
        // Debug logging for landscape page
        if (url && url.includes('landscape-photography-workshops')) {
          console.log(`[Optimisation] getOptimisationStatus lookup: key="${key}", found=${!!status}, cacheSize=${window.optimisationStatusCache.size}, id="${status?.id || 'null'}", task_id="${status?.task_id || 'null'}"`);
          if (status) {
            console.log(`[Optimisation] Status object retrieved:`, {
              id: status.id,
              task_id: status.task_id,
              hasId: 'id' in status,
              hasTaskId: 'task_id' in status,
              status: status.status,
              allKeys: Object.keys(status).slice(0, 15)
            });
          } else {
            // Log all keys in cache for debugging
            const allKeys = Array.from(window.optimisationStatusCache.keys());
            console.log(`[Optimisation] Cache keys (first 10):`, allKeys.slice(0, 10));
            const matchingKeys = allKeys.filter(k => k.includes('landscape') || k.includes(urlKey));
            console.log(`[Optimisation] Matching keys:`, matchingKeys);
            // Also log what's in the cache for matching keys
            matchingKeys.forEach(mk => {
              const cached = window.optimisationStatusCache.get(mk);
              console.log(`[Optimisation] Cached entry for "${mk}":`, {
                id: cached?.id,
                task_id: cached?.task_id,
                status: cached?.status,
                hasId: cached ? ('id' in cached) : false
              });
            });
          }
        }
        return status;
      } else {
        // Keyword-level tasks require both
      if (!kwKey || !urlKey) return null;
      const key = `${kwKey}::${urlKey}::${taskType}`;
      return window.optimisationStatusCache.get(key) || null;
      }
    };

    // ======================
    // Optimisation Tracking Modals (Phase 2)
    // ======================
    
    // Open Track Keyword modal
    window.openTrackKeywordModal = function openTrackKeywordModal(row, taskType = 'on_page') {
      console.log('[Optimisation] openTrackKeywordModal called', { row, taskType });
      const modal = document.getElementById('optimisation-track-modal');
      if (!modal) {
        console.error('[Optimisation] Track modal not found');
        alert('Track modal not found. Please refresh the page.');
        return;
      }

      // Get and clean URL (remove query strings and fragments)
      const rawUrl = row.best_url || row.targetUrl || row.ranking_url || '';
      console.log('[Optimisation] Raw URL:', rawUrl);
      if (!window.cleanUrlForDisplay) {
        console.error('[Optimisation] cleanUrlForDisplay function not found');
        alert('Error: cleanUrlForDisplay function not found. Please refresh the page.');
        return;
      }
      const cleanedUrl = window.cleanUrlForDisplay(rawUrl);
      console.log('[Optimisation] Cleaned URL:', cleanedUrl);

      // Populate fields
      document.getElementById('track-keyword-text').textContent = row.keyword;
      
      // Make URL clickable in Track modal
      const trackUrlContainer = document.getElementById('track-url-text');
      trackUrlContainer.innerHTML = ''; // Clear existing content
      if (cleanedUrl) {
        // Ensure URL has protocol
        let fullUrl = cleanedUrl;
        if (!fullUrl.startsWith('http://') && !fullUrl.startsWith('https://')) {
          fullUrl = 'https://' + fullUrl;
        }
        const urlLink = document.createElement('a');
        urlLink.href = fullUrl;
        urlLink.target = '_blank';
        urlLink.rel = 'noopener noreferrer';
        urlLink.textContent = cleanedUrl;
        urlLink.style.color = '#0284c7';
        urlLink.style.textDecoration = 'none';
        urlLink.style.fontWeight = '600';
        urlLink.style.wordBreak = 'break-all';
        urlLink.addEventListener('mouseenter', () => {
          urlLink.style.textDecoration = 'underline';
        });
        urlLink.addEventListener('mouseleave', () => {
          urlLink.style.textDecoration = 'none';
        });
        trackUrlContainer.appendChild(urlLink);
      } else {
        trackUrlContainer.textContent = 'No URL available';
      }
      
      document.getElementById('track-task-type').value = taskType;
      document.getElementById('track-status').value = 'planned';
      // For keyword-level tasks, suggest keyword as title; for page-level, leave empty
      const suggestedTitle = (taskType !== 'on_page' && row.keyword) ? row.keyword : '';
      document.getElementById('track-title').value = suggestedTitle;
      document.getElementById('track-notes').value = '';
      // Reset objective fields
      document.getElementById('track-objective-title').value = '';
      document.getElementById('track-primary-kpi').value = '';
      document.getElementById('track-target-direction').value = '';
      document.getElementById('track-target-value').value = '';
      document.getElementById('track-timeframe-days').value = '';
      
      // Populate Plan / Hypothesis from Priority & Next Actions
      let planText = '';
      const source = modal.dataset.source || '';
      
      // Check if this is a Money Pages task (URL-based, no keyword)
      const isMoneyPagesTask = source === 'money_pages' || !row.keyword;
      
      debugLog('[Optimisation] Modal opened - source: "' + source + '", has keyword: ' + !!row.keyword + ', isMoneyPagesTask: ' + isMoneyPagesTask);
      debugLog('[Optimisation] Row data: ' + JSON.stringify({
        clicks: row.clicks,
        impressions: row.impressions,
        ctr: row.ctr,
        avgPosition: row.avgPosition || row.position,
        aiCitations: row._aiCitations || row.aiCitations,
        url: row.url || row.targetUrl
      }));
      
      // For Money Pages tasks, build recommendations from row data
      if (isMoneyPagesTask) {
        try {
          // Use row data directly (row is already available as a parameter)
          // Build recommendations similar to how they're built for performance cards
          const recommendations = [];
          const clicks = row.clicks || 0;
          const impressions = row.impressions || 0;
          const ctr = row.ctr || 0;
          const avgPosition = row.avgPosition || row.position || null;
          const aiCitations = row._aiCitations || row.aiCitations || 0;
          
          debugLog('[Optimisation] Building recommendations from row: clicks=' + clicks + ', impressions=' + impressions + ', ctr=' + ctr + ', position=' + avgPosition + ', aiCitations=' + aiCitations);
          
          // High Priority: Low Click-Through Rate (shown first in View Details)
          const ctrPercent = (ctr > 1 ? ctr : ctr * 100);
          if (ctrPercent < 2 && impressions > 0) {
            const potentialClicks = Math.round(impressions * 0.02);
            const additionalClicks = Math.max(0, potentialClicks - clicks);
            recommendations.push({
              priority: 'High',
              title: 'Low Click-Through Rate',
              nextSteps: 'Optimize title tags and meta descriptions to improve CTR',
              estimatedImpact: `Could gain ~${additionalClicks} additional clicks/month with better CTR`,
              reason: `Current CTR ${ctrPercent.toFixed(2)}% is below 2% benchmark`
            });
            debugLog('[Optimisation] Added High priority: Low Click-Through Rate');
          }
          
          // Medium Priority: Ranking Below Top 10
          if (avgPosition != null && avgPosition > 10) {
            const potentialClicksLow = Math.round(impressions * 0.025);
            const potentialClicksHigh = Math.round(impressions * 0.05);
            recommendations.push({
              priority: 'Medium',
              title: 'Ranking Below Top 10',
              nextSteps: 'Improve on-page SEO, build authority, or optimize for target keywords',
              estimatedImpact: `Moving to top 10 could increase clicks by ${potentialClicksLow} - ${potentialClicksHigh}`,
              reason: `Current position ${avgPosition.toFixed(1)} is outside top 10`
            });
            debugLog('[Optimisation] Added Medium priority: Ranking Below Top 10');
          }
          
          // Low Priority: Focus on Higher Volume Keywords (if AI citations exist but are low volume)
          // Note: This recommendation typically appears when most citations are for low-volume keywords
          // Since we don't have keyword volume data in the row, we'll add this if there are citations but low traffic
          if (aiCitations > 0 && impressions < 1000) {
            recommendations.push({
              priority: 'Low',
              title: 'Focus on Higher Volume Keywords',
              nextSteps: 'Expand content to target keywords with 100+ monthly search volume',
              estimatedImpact: 'Could increase potential traffic by targeting higher-volume opportunities',
              reason: 'Most citations are for low-volume keywords (<100 searches/month)'
            });
            debugLog('[Optimisation] Added Low priority: Focus on Higher Volume Keywords');
          }
          
          // Sort by priority: High first, then Medium, then Low
          recommendations.sort((a, b) => {
            const priorityOrder = { 'High': 3, 'Medium': 2, 'Low': 1 };
            return (priorityOrder[b.priority] || 0) - (priorityOrder[a.priority] || 0);
          });
          
          debugLog('[Optimisation] Generated ' + recommendations.length + ' recommendations');
          
          // Build plan text from recommendations
          if (recommendations.length > 0) {
            const planLines = [];
            planLines.push('CTR target:  2.5%');
            planLines.push('');
            
            // Limit to top 3 recommendations
            const topRecs = recommendations.slice(0, 3);
            
            topRecs.forEach((rec, idx) => {
              planLines.push(`${rec.priority.toUpperCase()} PRIORITY: ${rec.title}`);
              planLines.push(`Next steps: ${rec.nextSteps}`);
              planLines.push(`Estimated impact: ${rec.estimatedImpact}`);
              planLines.push(`Reason: ${rec.reason}`);
              if (idx < topRecs.length - 1) planLines.push('');
            });
            
            planText = planLines.join('\n');
            debugLog('[Optimisation] Plan text generated (length: ' + planText.length + '): ' + planText.substring(0, 200) + '...');
          } else {
            planText = 'CTR target:  2.5%';
            debugLog('[Optimisation] No recommendations generated, using default plan text');
          }
        } catch (e) {
          console.warn('[Optimisation] Error generating plan from money pages recommendations:', e);
          debugLog('[Optimisation] Error generating plan: ' + e.message + ' - ' + e.stack);
          planText = 'CTR target:  2.5%';
        }
      } else {
        // For keyword tasks, use existing logic
        debugLog('[Optimisation] Not a Money Pages task, using keyword task logic');
        try {
          const scorecardData = buildKeywordScorecardData(row);
          if (scorecardData) {
            const actions = generateActionBullets(scorecardData);
            if (actions && actions.length > 0) {
              planText = actions.join('\n');
            }
          }
        } catch (e) {
          console.warn('[Optimisation] Error generating plan from scorecard:', e);
        }
      }
      
      debugLog('[Optimisation] Final plan text to set: ' + planText.substring(0, 200));
      const planField = document.getElementById('track-plan');
      if (planField) {
        planField.value = planText;
        debugLog('[Optimisation] Plan field updated successfully');
      } else {
        debugLog('[Optimisation] ERROR: track-plan field not found!');
      }

      // Store cleaned URL and row data for submit (row data needed for baseline metrics)
      modal.dataset.rowKeyword = row.keyword;
      modal.dataset.rowUrl = cleanedUrl;
      modal.dataset.taskType = taskType;
      // Store row data as JSON string for baseline metrics
      modal.dataset.rowData = JSON.stringify(row);

      modal.style.display = 'flex';
    };

    // Submit Track Keyword
    window.submitTrackKeyword = async function submitTrackKeyword() {
      const modal = document.getElementById('optimisation-track-modal');
      if (!modal) return;

      const keyword = modal.dataset.rowKeyword;
      // Get cleaned URL from dataset (already cleaned when modal opened)
      let targetUrl = modal.dataset.rowUrl || '';
      // Double-check it's cleaned (in case it was modified elsewhere)
      // NOTE: Don't rely on scheme-less display URLs for GSC fetches.
      // GSC "page" filters expect full absolute URLs (https://...). We'll compute that once here.
      const propertyForAbs = document.getElementById('propertyUrl')?.value ||
        localStorage.getItem('gsc_property_url') ||
        localStorage.getItem('last_property_url') || '';
      const targetUrlAbs = toAbsoluteUrlForGsc(targetUrl, propertyForAbs);
      targetUrl = window.cleanUrlForDisplay(targetUrl);
      const taskType = modal.dataset.taskType || document.getElementById('track-task-type').value;
      const status = document.getElementById('track-status').value;
      const title = document.getElementById('track-title').value.trim();
      const notes = document.getElementById('track-notes').value.trim();
      
      // Get objective fields (Phase B)
      const objective_title = document.getElementById('track-objective-title').value.trim();
      const primary_kpi = document.getElementById('track-primary-kpi').value.trim();
      // Map primary_kpi to objective_kpi (ctr_28d is the only CTR option now)
      const objective_kpi = primary_kpi === 'ctr_28d' ? 'ctr_28d' : primary_kpi;
      const objective_metric = objective_kpi; // Use same value for metric
      const objective_direction = document.getElementById('track-target-direction').value.trim();
      const objective_target_delta = document.getElementById('track-target-value').value.trim() ? parseFloat(document.getElementById('track-target-value').value) : null;
      const objective_timeframe_days = document.getElementById('track-timeframe-days').value.trim() ? parseInt(document.getElementById('track-timeframe-days').value) : null;
      const objective_plan = document.getElementById('track-plan').value.trim();
      
      // Calculate objective_due_at if timeframe is set
      let objective_due_at = null;
      if (objective_timeframe_days) {
        const startDate = new Date();
        objective_due_at = new Date(startDate.getTime() + objective_timeframe_days * 24 * 60 * 60 * 1000).toISOString();
      }

      // For Money Pages (page-level tasks), keyword is empty - only require targetUrl
      // For Ranking & AI (keyword-level tasks), both keyword and targetUrl are required
      const source = modal.dataset.source || '';
      if (source === 'money_pages') {
        // Money Pages: only require targetUrl (keyword is empty for page-level tasks)
        if (!targetUrl) {
          alert('Missing target URL');
          return;
        }
      } else {
        // Ranking & AI: require both keyword and targetUrl
      if (!keyword || !targetUrl) {
        alert('Missing keyword or URL');
        return;
        }
      }

      // Build baseline metrics from row data (stored in modal dataset)
      const rowDataStr = modal.dataset.rowData;
      // source is already declared above (line 5556)
      let baselineMetrics = null;
      
      // Use shared helper functions to ensure consistency
      // Create a temporary task-like object for the helper functions
      const tempTask = {
        keyword_text: keyword || '',
        target_url: targetUrl || '',
        target_url_clean: targetUrl || '',
        page_type: null,
        segment: source === 'money_pages' ? 'money_pages' : null
      };
      
      // Fetch latest audit and combinedRows once
      const { latestAudit, combinedRows } = await window.fetchLatestAuditAndCombinedRows();
      
      if (rowDataStr) {
        try {
          const rowData = JSON.parse(rowDataStr);
          
          // Check if this is a Money Pages task (page-level)
          if (source === 'money_pages' || !keyword) {
            // Money Pages: baseline must match the same "source of truth" used by measurements.
            // Measurements pull from `window.moneyPagesMetrics.rows` (latest audit), so prefer that over
            // any stale rowData captured when the modal was opened.
            const taskUrl = rowData.url || rowData.targetUrl || targetUrl || '';
            const taskUrlAbs = toAbsoluteUrlForGsc(taskUrl, propertyForAbs);
            const norm = (u) => normalizeUrlForDedupe
              ? normalizeUrlForDedupe(u)
              : String(u || '').toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
            const normalizedTaskUrl = norm(taskUrl);

            let row = null;
            const rows = window.moneyPagesMetrics?.rows || [];
            if (Array.isArray(rows) && rows.length > 0 && normalizedTaskUrl) {
              row = rows.find(r => norm(r.url || r.page_url || '') === normalizedTaskUrl) || null;
            }

            // If we have a current moneyPagesMetrics row, use it (this matches measurement logic).
            // This is faster than calling the helper function, so we try it first.
            if (!baselineMetrics && row) {
              const src = row || rowData;
              // Debug: Log all available position-related fields
              const positionValue = src.avgPosition != null ? src.avgPosition : (src.position != null ? src.position : (src.position_28d != null ? src.position_28d : (src.avg_position != null ? src.avg_position : null)));
              debugLog(`[Optimisation] Building baseline from row data - Position fields: avgPosition=${src.avgPosition}, position=${src.position}, position_28d=${src.position_28d}, avg_position=${src.avg_position}, final=${positionValue}`, 'info');
              debugLog(`[Optimisation] Building baseline from row data - AI Citations: _aiCitations=${src._aiCitations}, aiCitations=${src.aiCitations}`, 'info');
              
              baselineMetrics = {
                gsc_clicks_28d: src.clicks != null ? src.clicks : (src.clicks_28d || 0),
                gsc_impressions_28d: src.impressions != null ? src.impressions : (src.impressions_28d || 0),
                // Money Pages CTR should be ratio (0-1); if stored as percent, normalize.
                gsc_ctr_28d: (() => {
                  const v = src.ctr != null ? src.ctr : (src.ctr_28d != null ? src.ctr_28d : 0);
                  const n = Number(v || 0);
                  if (n > 1 && n <= 100) return n / 100;
                  return n;
                })(),
                gsc_position_28d: positionValue,
                current_rank: positionValue, // Also set current_rank for display logic
                classic_ranking_url: taskUrlAbs || taskUrl || null,
                segment: src.segment || 'money_pages',
                captured_at: new Date().toISOString()
              };
              
              debugLog(`[Optimisation] Baseline metrics created - gsc_position_28d: ${baselineMetrics.gsc_position_28d}, current_rank: ${baselineMetrics.current_rank}`, 'info');
              
              // Use AI citations directly from row if available (already computed during table rendering)
              if (typeof src._aiCitations === 'number' && src._aiCitations >= 0) {
                baselineMetrics.ai_citations = src._aiCitations;
                debugLog(`[Optimisation] Using AI citations from row (_aiCitations): ${src._aiCitations}`, 'success');
              } else if (typeof src.aiCitations === 'number' && src.aiCitations >= 0) {
                baselineMetrics.ai_citations = src.aiCitations;
                debugLog(`[Optimisation] Using AI citations from row (aiCitations): ${src.aiCitations}`, 'success');
              } else {
                debugLog(`[Optimisation] No AI citations found in row data`, 'warn');
              }
            }

            // Use helper function to fetch metrics if we don't have baselineMetrics yet
            // This ensures consistency with other update paths
            if (!baselineMetrics && taskUrl) {
              try {
                tempTask.target_url = taskUrl;
                tempTask.target_url_clean = taskUrl;
                baselineMetrics = await window.fetchMetricsForUrlTask(tempTask, latestAudit, combinedRows);
                if (baselineMetrics) {
                  debugLog(`[Optimisation] URL task creation: Fetched metrics using helper function`, 'success');
                }
              } catch (helperErr) {
                debugLog(`[Optimisation] URL task creation: Helper function failed: ${helperErr.message}`, 'warn');
                // Fall back to rowData below
              }
            }

            // If impressions are missing, don't create a baseline measurement (avoids "0/0/0%" baselines).
            if (!baselineMetrics?.gsc_impressions_28d) {
              baselineMetrics = null;
            }
          } else {
            // Ranking & AI: use keyword-based metrics
            // Use helper function to ensure consistency with other update paths
            try {
              tempTask.keyword_text = keyword;
              tempTask.target_url = targetUrl || rowData.best_url || rowData.targetUrl || rowData.ranking_url || '';
              tempTask.target_url_clean = targetUrl || '';
              baselineMetrics = await window.fetchMetricsForKeywordTask(tempTask, latestAudit, combinedRows);
              if (baselineMetrics) {
                debugLog(`[Optimisation] Keyword task creation: Fetched metrics using helper function`, 'success');
              }
            } catch (helperErr) {
              debugLog(`[Optimisation] Keyword task creation: Helper function failed, falling back to rowData: ${helperErr.message}`, 'warn');
              // Fallback to rowData if helper function fails
              let queryTotal = null;
              if (typeof getQueryTotalForKeyword === 'function') {
                queryTotal = getQueryTotalForKeyword(keyword);
              }
              
              baselineMetrics = {
                gsc_clicks_28d: (queryTotal && queryTotal.clicks) || rowData.gsc_clicks_28d || rowData.clicks_28d || null,
                gsc_impressions_28d: (queryTotal && queryTotal.impressions) || rowData.gsc_impressions_28d || rowData.impressions_28d || null,
                // queryTotal.ctr is a percentage (0-100), convert to decimal for storage
                gsc_ctr_28d: (queryTotal && queryTotal.ctr != null) ? (queryTotal.ctr / 100) : (rowData.gsc_ctr_28d || rowData.ctr_28d || null),
                current_rank: rowData.best_rank_group || rowData.current_rank || null,
                opportunity_score: rowData.opportunityScore || null,
                ai_overview: rowData.has_ai_overview || false,
                ai_citations: rowData.ai_alan_citations_count || 0,
                ai_citations_total: rowData.ai_total_citations || 0,
                classic_ranking_url: rowData.best_url || rowData.targetUrl || rowData.ranking_url || null,
                page_type: rowData.pageType || null,
                segment: rowData.segment || null,
                captured_at: new Date().toISOString()
              };
            }
          }
        } catch (e) {
          console.error('[Optimisation] Failed to parse row data for baseline metrics:', e);
        }
      }

      try {
        const source = modal.dataset.source || '';
        console.log('[Money Pages] Source from modal:', source, 'modal.dataset:', modal.dataset);
        // Debug: Log what we're sending to API
        console.log('[Money Pages] Sending task creation request with baselineMetrics:', baselineMetrics);
        debugLog(` Creating task with baseline: clicks=${baselineMetrics?.gsc_clicks_28d || 0}, impressions=${baselineMetrics?.gsc_impressions_28d || 0}, CTR=${((baselineMetrics?.gsc_ctr_28d || 0) * 100).toFixed(2)}%`, 'info');
        
        // Debug: Log what we're sending
        const requestBody = {
          keyword_text: keyword || '', // Empty for page-level tasks
            // Store full URL for Money Pages (page-level) tasks so measurements/baselines match GSC exactly.
            target_url: source === 'money_pages' ? (targetUrlAbs || targetUrl) : targetUrl,
            task_type: taskType,
            status: status,
            title: title || null,
            notes: notes || null,
          source: source, // Pass source to API
            baselineMetrics: baselineMetrics,
            // Phase B objective fields
            objective_title: objective_title || null,
            objective_kpi: objective_kpi || null,
            objective_metric: objective_metric || null,
            objective_direction: objective_direction || null,
            objective_target_delta: objective_target_delta,
            objective_timeframe_days: objective_timeframe_days,
            objective_due_at: objective_due_at,
            objective_plan: objective_plan || null,
            // Also set cycle_started_at when creating task
            cycle_started_at: new Date().toISOString()
        };
        
        console.log('[Money Pages] Sending task creation request:', {
          target_url: requestBody.target_url,
          source: requestBody.source,
          hasBaselineMetrics: !!requestBody.baselineMetrics,
          baselineMetrics: requestBody.baselineMetrics
        });
        
        const response = await fetch(apiUrl('/api/optimisation/task'), {
          method: 'POST',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
          if (response.status === 401) {
            throw new Error('Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.');
          }
          
          // Handle duplicate task error (409 Conflict)
          if (response.status === 409) {
            try {
              const errorData = await response.json();
              if (errorData.existingTaskId) {
                // Task already exists - open it instead
                alert(`A task already exists for this page. Opening existing task...`);
                if (typeof window.openOptimisationTaskDrawer === 'function') {
                  window.openOptimisationTaskDrawer(errorData.existingTaskId);
                }
                modal.style.display = 'none';
                return;
              }
              throw new Error(errorData.error || 'A task already exists for this keyword/URL combination');
            } catch (e) {
              throw new Error('A task already exists for this keyword/URL combination. Please use the "Manage" button instead.');
            }
          }
          
          const error = await response.text();
          throw new Error(error || 'Failed to create task');
        }

        const result = await response.json();
        console.log('[Money Pages] Task creation response:', {
          success: response.ok,
          taskId: result.task?.id,
          hasBaselineMeasurement: result.baselineMeasurementCreated || false
        });
        
        if (!response.ok) {
          console.error('[Money Pages] Task creation failed:', result);
        }
        
        const createdTask = result.task;
        const createdTaskId = createdTask?.id;
        const createdTaskUrl = createdTask?.target_url || targetUrl;
        
        // Validate task was created successfully
        if (!createdTaskId) {
          console.error('[Money Pages] Task creation failed: no task ID returned', {
            result,
            createdTask,
            response: result
          });
          throw new Error('Task creation failed: no task ID returned. Please try again.');
        }
        
        // Re-read source from modal (in case it was lost)
        const currentSource = modal.dataset.source || source || '';

        console.log('[Money Pages] Task created successfully:', {
          taskId: createdTaskId,
          url: createdTaskUrl,
          source: currentSource,
          originalSource: source,
          task: createdTask,
          taskKeys: createdTask ? Object.keys(createdTask) : []
        });

        // Close modal
        modal.style.display = 'none';
        
        // Handle Money Pages vs Ranking & AI differently
        if (currentSource === 'money_pages' && createdTask && createdTaskUrl) {
          console.log('[Money Pages] Processing Money Pages task creation...');
          
          // CRITICAL: Immediately add the created task to the cache so the table can find it
          // This avoids waiting for the database view to refresh
          const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(createdTaskUrl) : createdTaskUrl.toLowerCase().trim();
          const cacheKey = `::${urlKey}::on_page`;
          
          console.log('[Money Pages] URL normalization:', {
            original: createdTaskUrl,
            normalized: urlKey,
            cacheKey
          });
          
          // Build a status object that matches what the API would return
          // CRITICAL: Ensure id field is set (API uses 'id', not 'task_id')
          const immediateStatus = {
            id: createdTaskId, // This is the primary key field used by the API
            task_id: createdTaskId, // Also include task_id for compatibility
            keyword_key: null,
            target_url: createdTaskUrl,
            target_url_clean: urlKey, // Use normalized URL
            task_type: 'on_page',
            status: createdTask.status || 'planned',
            objective_state: 'on_track', // Default for new tasks with baseline
            cycle_id: createdTask.current_cycle_id || null,
            cycle_number: 1,
            cycle_active: 1, // Active cycle number
            due_at: createdTask.due_at || null,
            days_remaining: null,
            last_activity_at: new Date().toISOString() // Set to now for immediate entries
          };
          
          console.log('[Money Pages] Immediate status object created:', {
            id: immediateStatus.id,
            task_id: immediateStatus.task_id,
            hasId: 'id' in immediateStatus,
            hasTaskId: 'task_id' in immediateStatus,
            status: immediateStatus.status
          });
          
          // Ensure cache exists
          if (!window.optimisationStatusCache) {
            window.optimisationStatusCache = new Map();
            console.log('[Money Pages] Created new optimisationStatusCache');
          }
          
          // Add to cache immediately with a timestamp flag so we can preserve it during cache refresh
          immediateStatus._immediateCache = true;
          immediateStatus._cacheTimestamp = Date.now();
          window.optimisationStatusCache.set(cacheKey, immediateStatus);
          console.log('[Money Pages]  Immediately cached created task:', {
            cacheKey,
            taskId: createdTaskId,
            url: createdTaskUrl,
            urlKey,
            status: immediateStatus.status,
            cacheSize: window.optimisationStatusCache.size
          });
          
          // Verify it's in the cache
          const verifyCache = window.optimisationStatusCache.get(cacheKey);
          console.log('[Money Pages] Cache verification:', {
            cacheKey,
            found: !!verifyCache,
            cachedStatus: verifyCache?.status
          });
          
          // Also add to temporary cache for immediate UI update
          if (!window.moneyPagesTaskCache) {
            window.moneyPagesTaskCache = new Map();
            console.log('[Money Pages] Created new moneyPagesTaskCache');
          }
          window.moneyPagesTaskCache.set(urlKey, {
            id: createdTaskId,
            status: immediateStatus.status,
            cycle_number: 1
          });
          console.log('[Money Pages] Added to temporary cache:', {
            urlKey,
            taskId: createdTaskId,
            tempCacheSize: window.moneyPagesTaskCache.size
          });
        }
        
        // Reload all tasks so the new task is available for the drawer
        if (typeof window.loadAllOptimisationTasks === 'function') {
          await window.loadAllOptimisationTasks();
        }
        
        // Handle Money Pages vs Ranking & AI differently
        // Use currentSource (re-read from modal) to ensure we have the correct value
        const finalSource = currentSource || source || '';
        if (finalSource === 'money_pages') {
          // FIRST: Re-render table immediately with immediate cache entry
          // This ensures the UI updates right away, even before the API refreshes
          console.log('[Money Pages] Re-rendering table immediately with immediate cache entry...');
          if (typeof renderMoneyPagesTable === 'function' && window.moneyPagesMetrics) {
            const moneyPagesContainer = document.getElementById('money-pages-table-container');
            if (moneyPagesContainer) {
              const currentPage = window.moneyPagesCurrentPage || 1;
              const rowsPerPage = window.moneyPagesRowsPerPage || 10;
              const tableHtml = await renderMoneyPagesTable(window.moneyPagesMetrics.rows, currentPage, rowsPerPage);
              if (tableHtml && typeof tableHtml === 'string' && tableHtml.trim().length > 0) {
                moneyPagesContainer.innerHTML = tableHtml;
                console.log('[Money Pages]  Table re-rendered immediately with immediate cache');
              }
            }
          }
          
          // THEN: Small delay to ensure database is updated and view is refreshed
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Refresh optimisation statuses cache (same as Ranking & AI)
          // This will update the cache with the latest from the database
          if (typeof window.fetchOptimisationStatuses === 'function' && window.moneyPagesMetrics && window.moneyPagesMetrics.rows) {
            // Create row-like objects for fetchOptimisationStatuses
            const statusRows = window.moneyPagesMetrics.rows.map(row => ({
              keyword: '', // Empty for page-level tasks
              best_url: row.url,
              targetUrl: row.url,
              ranking_url: row.url
            }));
            console.log('[Money Pages] Fetching statuses for', statusRows.length, 'rows after task creation');
            await window.fetchOptimisationStatuses(statusRows);
            console.log('[Money Pages] Status cache size after fetch:', window.optimisationStatusCache ? window.optimisationStatusCache.size : 0);
            
            // Verify the created task is in the cache
            if (createdTaskUrl) {
              const testRow = { keyword: '', best_url: createdTaskUrl, targetUrl: createdTaskUrl, ranking_url: createdTaskUrl };
              const testStatus = window.getOptimisationStatus ? window.getOptimisationStatus(testRow, 'on_page') : null;
              const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(createdTaskUrl) : createdTaskUrl.toLowerCase().trim();
              const expectedKey = `::${urlKey}::on_page`;
              const cacheHasKey = window.optimisationStatusCache ? window.optimisationStatusCache.has(expectedKey) : false;
              const cachedValue = window.optimisationStatusCache ? window.optimisationStatusCache.get(expectedKey) : null;
              
              console.log('[Money Pages] Status lookup test for created task:', {
                url: createdTaskUrl,
                urlKey,
                expectedKey,
                found: !!testStatus,
                status: testStatus?.status,
                taskId: testStatus?.id,
                cacheHasKey,
                cachedValueStatus: cachedValue?.status,
                cachedValueId: cachedValue?.id
              });
              
              // If not found, log all cache keys for debugging
              if (!testStatus && window.optimisationStatusCache) {
                const allKeys = Array.from(window.optimisationStatusCache.keys());
                const matchingKeys = allKeys.filter(k => k.includes(urlKey) || k.includes('landscape'));
                console.log('[Money Pages] Cache keys containing URL:', matchingKeys);
                console.log('[Money Pages] All cache keys (first 20):', allKeys.slice(0, 20));
              }
            }
          }
          
          // Refresh Money Pages table to show updated Track/Manage status
          console.log('[Money Pages] About to re-render table...', {
            hasRenderFunction: typeof renderMoneyPagesTable === 'function',
            hasMetrics: !!window.moneyPagesMetrics,
            metricsRows: window.moneyPagesMetrics?.rows?.length || 0,
            containerExists: !!document.getElementById('money-pages-table-container')
          });
          
          if (typeof renderMoneyPagesTable === 'function' && window.moneyPagesMetrics) {
            const moneyPagesContainer = document.getElementById('money-pages-table-container');
            if (moneyPagesContainer) {
              const currentPage = window.moneyPagesCurrentPage || 1;
              const rowsPerPage = window.moneyPagesRowsPerPage || 10;
              console.log('[Money Pages] Re-rendering table after task creation...', {
                currentPage,
                rowsPerPage,
                totalRows: window.moneyPagesMetrics.rows.length,
                cacheSize: window.optimisationStatusCache?.size || 0,
                tempCacheSize: window.moneyPagesTaskCache?.size || 0
              });
              
              const tableHtml = await renderMoneyPagesTable(window.moneyPagesMetrics.rows, currentPage, rowsPerPage);
              console.log('[Money Pages] Table HTML generated, length:', tableHtml?.length || 0);
              moneyPagesContainer.innerHTML = tableHtml;
              console.log('[Money Pages]  Opportunity table re-rendered successfully');
              // Re-attach event handlers (they're set up in the render function)
              // Note: renderMoneyPagesTable already calls these handlers, but we need to ensure they're attached after re-render
              if (typeof attachMoneyPagesSortHandlers === 'function') {
                attachMoneyPagesSortHandlers();
              }
              if (typeof attachMoneyPagesPaginationHandlers === 'function') {
                attachMoneyPagesPaginationHandlers(window.moneyPagesMetrics.rows);
              }
              if (typeof attachMoneyPagesCopyHandler === 'function') {
                attachMoneyPagesCopyHandler(window.moneyPagesMetrics.rows);
              }
              if (typeof attachMoneyPagesFilterHandlers === 'function') {
                attachMoneyPagesFilterHandlers(window.moneyPagesMetrics.rows, async () => {
                  // Re-apply filters and re-render
                  const currentPage = window.moneyPagesCurrentPage || 1;
                  const rowsPerPage = window.moneyPagesRowsPerPage || 10;
                  if (moneyPagesContainer && typeof renderMoneyPagesTable === 'function') {
                    moneyPagesContainer.innerHTML = await renderMoneyPagesTable(window.moneyPagesMetrics.rows, currentPage, rowsPerPage);
                  }
                });
              }
            }
          }
          
          // ALSO: Re-render Priority table if it exists
          if (window.moneyPagePriorityData && window.moneyPagePriorityData.length > 0) {
            console.log('[Money Pages] Re-rendering Priority table after task creation...');
            if (typeof window.renderMoneyPagesPriorityTable === 'function') {
              const filters = {
                typeFilter: window.moneyPagesTypeFilter || 'all',
                minImpr: window.moneyPagesMinImpr || 0,
                matrixFilter: window.moneyPagesMatrixFilter || null
              };
              try {
                await window.renderMoneyPagesPriorityTable(null, filters);
                console.log('[Money Pages]  Priority table re-rendered successfully');
              } catch (err) {
                console.error('[Money Pages] Error re-rendering Priority table:', err);
              }
            }
          }
          
          // Show success message
          const pageTitle = title ? title.replace(/^MP: /, '') : targetUrl;
          showStatus(` Created optimisation task for ${pageTitle} with baseline snapshot`, 'success');
        } else {
          // Ranking & AI: refresh Ranking & AI table
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        if (rankingTab) {
          // Use setActivePanel to properly show the panel
          if (typeof setActivePanel === 'function') {
            setActivePanel('ranking');
          } else {
            // Fallback: manually set active state
            document.querySelectorAll('.aigeo-panel').forEach(panel => {
              panel.classList.remove('is-active');
              panel.hidden = true;
            });
          rankingTab.classList.add('is-active');
            rankingTab.hidden = false;
          }
          
          // Update nav button states
          document.querySelectorAll('.aigeo-nav-item').forEach(btn => btn.classList.remove('is-active'));
          const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav-item')).find(btn => 
            btn.getAttribute('data-panel') === 'ranking'
          );
          if (rankingNavBtn) rankingNavBtn.classList.add('is-active');
          
          // Ensure panel is rendered
          if (typeof ensurePanelRendered === 'function') {
            ensurePanelRendered('ranking');
          }
        }
        
        // Trigger table re-render
        if (typeof renderRankingAiTab === 'function') {
          await renderRankingAiTab();
        } else if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        } else {
          console.warn('[Optimisation] renderRankingAiTab not found, refreshing page');
          // Preserve Ranking & AI tab state before reload
          sessionStorage.setItem('activeTab', 'ranking');
          window.location.hash = '#ranking';
          location.reload();
          }
        }
      } catch (error) {
        console.error('[Optimisation] Error creating task:', error);
        alert('Failed to create task: ' + error.message);
      }
    };

    // Open Manage Optimisation modal
    window.openManageOptimisationModal = function openManageOptimisationModal(row, status, taskType = 'on_page') {
      const modal = document.getElementById('optimisation-manage-modal');
      if (!modal) {
        console.error('[Optimisation] Manage modal not found');
        return;
      }

      // Populate read-only fields
      document.getElementById('manage-keyword-text').textContent = row.keyword;
      
      // Make URL clickable in Manage modal
      const manageUrlContainer = document.getElementById('manage-url-text');
      const rawUrl = row.best_url || row.targetUrl || row.ranking_url || '';
      const urlText = window.cleanUrlForDisplay ? window.cleanUrlForDisplay(rawUrl) : window.cleanUrlForKey(rawUrl);
      manageUrlContainer.innerHTML = ''; // Clear existing content
      if (urlText) {
        // Ensure URL has protocol
        let fullUrl = urlText;
        if (!fullUrl.startsWith('http://') && !fullUrl.startsWith('https://')) {
          fullUrl = 'https://' + fullUrl;
        }
        const urlLink = document.createElement('a');
        urlLink.href = fullUrl;
        urlLink.target = '_blank';
        urlLink.rel = 'noopener noreferrer';
        urlLink.textContent = urlText;
        urlLink.style.color = '#0284c7';
        urlLink.style.textDecoration = 'none';
        urlLink.style.wordBreak = 'break-all';
        urlLink.addEventListener('mouseenter', () => {
          urlLink.style.textDecoration = 'underline';
        });
        urlLink.addEventListener('mouseleave', () => {
          urlLink.style.textDecoration = 'none';
        });
        manageUrlContainer.appendChild(urlLink);
      } else {
        manageUrlContainer.textContent = 'No URL available';
      }
      
      document.getElementById('manage-task-type-text').textContent = taskType;
      document.getElementById('manage-status-text').textContent = status.status;
      document.getElementById('manage-cycle-text').textContent = status.cycle_active || 1;
      document.getElementById('manage-last-activity-text').textContent = status.last_activity_at 
        ? new Date(status.last_activity_at).toLocaleDateString()
        : 'Never';

      // Set current status in dropdown
      document.getElementById('manage-status-select').value = status.status;

      // Store data for submit
      modal.dataset.taskId = status.id;
      modal.dataset.rowKeyword = row.keyword;
      modal.dataset.rowUrl = row.best_url || row.targetUrl || row.ranking_url || '';
      modal.dataset.taskType = taskType;
      modal.dataset.currentCycle = status.cycle_active || 1;
      modal.dataset.currentStatus = status.status; // Store actual status value for comparison

      modal.style.display = 'flex';
    };

    // Submit status change
    window.submitStatusChange = async function submitStatusChange(newStatusParam, taskIdParam) {
      // B5: Support both modal and drawer - accept optional parameters
      const modal = document.getElementById('optimisation-manage-modal');
      const drawerTaskId = (window.optimisationModuleState && window.optimisationModuleState.currentTaskId);
      const modalTaskId = (modal && modal.dataset.taskId);
      const taskId = taskIdParam || drawerTaskId || modalTaskId;
      
      if (!taskId) {
        console.warn('[Optimisation] No task ID found');
        return;
      }

      // Get status from parameter, modal select, or drawer select
      const newStatus = newStatusParam || 
        (modal ? (document.getElementById('manage-status-select') && document.getElementById('manage-status-select').value) : null) ||
        (document.getElementById('optimisation-change-status') && document.getElementById('optimisation-change-status').value);
      
      if (!newStatus) {
        alert('Please select a status');
        return;
      }

      const oldStatus = (modal && modal.dataset.currentStatus) || 
        (document.getElementById('manage-status-text') && document.getElementById('manage-status-text').textContent) ||
        (document.getElementById('optimisation-drawer-status') && document.getElementById('optimisation-drawer-status').textContent);

      if (oldStatus === newStatus) {
        alert('Status unchanged');
        return;
      }

      try {
        const headers = window.getOptimisationHeaders();
        console.log('[Optimisation] Updating status:', { taskId, newStatus, oldStatus, hasAdminKey: !!headers['x-arp-admin-key'] });
        
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'PATCH',
          headers: headers,
          body: JSON.stringify({
            status: newStatus
          })
        });

        console.log('[Optimisation] Response status:', response.status, response.statusText);
        console.log('[Optimisation] Response headers:', Object.fromEntries(response.headers.entries()));

        if (!response.ok) {
          // Clone response BEFORE reading to allow multiple reads
          const responseClone = response.clone();
          let errorMessage = 'Failed to update status';
          let errorDetails = null;
          
          try {
            // Try to read as JSON first (most APIs return JSON)
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
            errorDetails = errorData;
            console.error('[Optimisation] API error response:', errorData);
          } catch (e) {
            // If JSON parsing fails, try text from clone
            console.error('[Optimisation] JSON parse failed, trying text:', e);
            try {
              const errorText = await responseClone.text();
              console.error('[Optimisation] Error response text (length):', errorText ? errorText.length : 0);
              if (errorText && errorText.trim()) {
                // Try to parse as JSON if it looks like JSON
                try {
                  const parsed = JSON.parse(errorText);
                  errorMessage = parsed.error || parsed.message || errorText;
                  errorDetails = parsed;
                } catch (parseError) {
                  errorMessage = errorText.substring(0, 200); // Limit length
                  errorDetails = { rawText: errorText.substring(0, 500) };
                }
                console.error('[Optimisation] API error text:', errorText.substring(0, 200));
              } else {
                console.error('[Optimisation] Error response body is empty');
                errorDetails = { empty: true };
              }
            } catch (e2) {
              console.error('[Optimisation] Failed to read error response:', e2);
              errorDetails = { readError: e2.message };
            }
          }
          
          // Enhance error message based on status code
          if (response.status === 401) {
            errorMessage = 'Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.';
          } else if (response.status === 404) {
            errorMessage = 'Task not found. It may have been deleted.';
          } else if (response.status === 403) {
            errorMessage = 'Forbidden - you do not have permission to update this task.';
          } else if (response.status === 500) {
            errorMessage = `Server error (${response.status}): ${errorMessage}`;
          } else {
            errorMessage = `HTTP ${response.status}: ${errorMessage}`;
          }
          
          console.error('[Optimisation] Full error details:', {
            status: response.status,
            statusText: response.statusText,
            errorMessage,
            errorDetails
          });
          
          throw new Error(errorMessage);
        }

        // Read successful response
        const result = await response.json();
        console.log('[Optimisation] Status update successful:', result);

        // Refresh data
        if (modal && modal.dataset.rowKeyword) {
        await window.fetchOptimisationStatuses([{
          keyword: modal.dataset.rowKeyword,
          best_url: modal.dataset.rowUrl
        }]);
        }
        
        // Refresh all tasks if drawer is open
        if (window.optimisationModuleState && window.optimisationModuleState.currentTaskId) {
          await window.loadAllOptimisationTasks();
        }
        
        // Close modal if open
        if (modal) {
        modal.style.display = 'none';
        }
        
        // Ensure Ranking & AI tab stays active and refresh table (only if modal was used)
        if (modal && modal.dataset.rowKeyword) {
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        if (rankingTab) {
          // Use setActivePanel to properly show the panel
          if (typeof setActivePanel === 'function') {
            setActivePanel('ranking');
          } else {
            // Fallback: manually set active state
            document.querySelectorAll('.aigeo-panel').forEach(panel => {
              panel.classList.remove('is-active');
              panel.hidden = true;
            });
          rankingTab.classList.add('is-active');
            rankingTab.hidden = false;
          }
          
          // Update nav button states
          document.querySelectorAll('.aigeo-nav-item').forEach(btn => btn.classList.remove('is-active'));
          const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav-item')).find(btn => 
            btn.getAttribute('data-panel') === 'ranking'
          );
          if (rankingNavBtn) rankingNavBtn.classList.add('is-active');
          
          // Ensure panel is rendered
          if (typeof ensurePanelRendered === 'function') {
            ensurePanelRendered('ranking');
          }
        }
        }
        
        // Trigger table re-render
        if (typeof renderRankingAiTab === 'function') {
          await renderRankingAiTab();
        } else if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        } else {
          console.warn('[Optimisation] renderRankingAiTab not found, refreshing page');
          // Preserve Ranking & AI tab state before reload
          sessionStorage.setItem('activeTab', 'ranking');
          window.location.hash = '#ranking';
          location.reload();
        }
      } catch (error) {
        console.error('[Optimisation] Error updating status:', error);
        alert('Failed to update status: ' + error.message);
      }
    };

    // Start new cycle
    window.startNewCycle = async function startNewCycle() {
      const taskId = (window.optimisationModuleState && window.optimisationModuleState.currentTaskId);
      
      if (!taskId) {
        console.warn('[Optimisation] No task ID found');
        return;
      }

      // Get current task to get cycle info
      const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      if (!task) {
        alert('Task not found. Please refresh the page.');
        return;
      }

      const currentCycleNo = task.cycle_no || task.cycle_active || 1;
      const newCycleNo = currentCycleNo + 1;

      // Show modal for editing new cycle objective
      const modal = document.getElementById('optimisation-new-cycle-modal');
      if (!modal) {
        alert('New cycle modal not found. Please refresh the page.');
        return;
      }

      // Populate with previous cycle's objective if it exists (for copying)
      if (task.objective_title) {
        document.getElementById('new-cycle-objective-title').value = task.objective_title;
      }
      if (task.primary_kpi) {
        document.getElementById('new-cycle-primary-kpi').value = task.primary_kpi;
      }
      if (task.target_direction) {
        document.getElementById('new-cycle-target-direction').value = task.target_direction;
      }
      if (task.target_value != null) {
        document.getElementById('new-cycle-target-value').value = task.target_value;
      }
      if (task.timeframe_days) {
        document.getElementById('new-cycle-timeframe-days').value = task.timeframe_days;
      }
      if (task.plan) {
        document.getElementById('new-cycle-plan').value = task.plan;
      }

      document.getElementById('new-cycle-cycle-no').textContent = `Cycle ${newCycleNo}`;
      modal.dataset.taskId = taskId;
      modal.style.display = 'flex';
    };

    window.submitNewCycle = async function submitNewCycle() {
      const modal = document.getElementById('optimisation-new-cycle-modal');
      if (!modal) return;

      const taskId = modal.dataset.taskId;
      if (!taskId) {
        alert('Task ID not found');
        return;
      }

      // Get objective fields
      const objective_title = document.getElementById('new-cycle-objective-title').value.trim();
      const primary_kpi = document.getElementById('new-cycle-primary-kpi').value.trim();
      const target_direction = document.getElementById('new-cycle-target-direction').value.trim();
      const target_value = document.getElementById('new-cycle-target-value').value.trim();
      const timeframe_days = document.getElementById('new-cycle-timeframe-days').value.trim();
      const plan = document.getElementById('new-cycle-plan').value.trim();

      try {
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/cycle`), {
          method: 'POST',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            objective_title: objective_title || null,
            primary_kpi: primary_kpi || null,
            target_direction: target_direction || null,
            target_value: target_value ? parseFloat(target_value) : null,
            timeframe_days: timeframe_days ? parseInt(timeframe_days) : null,
            plan: plan || null
          })
        });

        if (!response.ok) {
          if (response.status === 401) {
            throw new Error('Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.');
          }
          const errorData = await response.json();
          throw new Error(errorData.error || 'Failed to start new cycle');
        }

        const result = await response.json();
        
        // Update task in state immediately with returned task data (includes new cycle objective)
        if (result.task && window.optimisationModuleState && window.optimisationModuleState.allTasks) {
          const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
          if (taskIndex >= 0) {
            window.optimisationModuleState.allTasks[taskIndex] = result.task;
            console.log('[Optimisation] Updated task in state with new cycle data:', result.task);
          } else {
            window.optimisationModuleState.allTasks.push(result.task);
          }
          // Also update filtered tasks if it exists there
          if (window.optimisationModuleState.filteredTasks) {
            const filteredIndex = window.optimisationModuleState.filteredTasks.findIndex(t => t.id === taskId);
            if (filteredIndex >= 0) {
              window.optimisationModuleState.filteredTasks[filteredIndex] = result.task;
            }
          }
        }
        
        // Small delay to ensure view has updated with new cycle
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Refresh tasks to ensure all data is up to date
        await window.loadAllOptimisationTasks();
        
        // Reload drawer if it's open (will use updated task data)
        if (window.optimisationModuleState.currentTaskId === taskId) {
          // Force reload by closing and reopening
          const currentTaskId = window.optimisationModuleState.currentTaskId;
          window.optimisationModuleState.currentTaskId = null;
          await new Promise(resolve => setTimeout(resolve, 100));
          await window.openOptimisationTaskDrawer(currentTaskId);
        }
        
        modal.style.display = 'none';
        
        // Show success message with cycle info
        const cycleNo = (result.cycle && result.cycle.cycle_no) || (result.task && result.task.cycle_active) || 'new';
        alert(`Cycle ${cycleNo} started successfully!${result.baseline_from_audit ? ' Baseline set from latest audit.' : (result.baseline_from_measurement ? ' Baseline set from previous latest measurement.' : '')}`);
      } catch (error) {
        console.error('[Optimisation] Error starting new cycle:', error);
        alert('Failed to start new cycle: ' + error.message);
      }
    };

    // Edit Objective function
    // Edit objective (inline form)
    window.editObjective = async function editObjective() {
      const taskId = (window.optimisationModuleState && window.optimisationModuleState.currentTaskId);
      if (!taskId) return;

      const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      if (!task) return;

      const form = document.getElementById('optimisation-edit-objective-form');
      const content = document.getElementById('optimisation-drawer-objective-content');
      if (!form || !content) return;

      // Populate form with current values (Phase 5: use objective from cycle, fallback to legacy)
      const objective = task.objective || task.cycle?.objective || null;
      
      if (objective) {
        // Phase 5 format
        document.getElementById('optimisation-edit-objective-title').value = objective.title || '';
        document.getElementById('optimisation-edit-objective-kpi').value = ''; // KPI label not used in Phase 5
        document.getElementById('optimisation-edit-objective-metric').value = objective.kpi || '';
        document.getElementById('optimisation-edit-objective-direction').value = objective.target_type === 'absolute' ? 'at_least' : 'increase'; // Default
        // For CTR, convert from ratio (0-1) to percentage for display in input field
        let displayTarget = objective.target;
        if (objective.kpi === 'ctr_28d' && displayTarget != null) {
          // If target is stored as ratio (0-1), multiply by 100 for display
          if (displayTarget < 1 && displayTarget > 0) {
            displayTarget = displayTarget * 100;
          }
        }
        document.getElementById('optimisation-edit-objective-target-value').value = displayTarget != null ? displayTarget : '';
        document.getElementById('optimisation-edit-objective-plan').value = objective.plan || '';
        
        // Calculate timeframe from due_at if available
        if (objective.due_at) {
          const dueDate = new Date(objective.due_at);
          const taskStart = task.cycle_started_at || task.cycle_start_date || new Date();
          const startDate = new Date(taskStart);
          const daysDiff = Math.round((dueDate - startDate) / (1000 * 60 * 60 * 24));
          document.getElementById('optimisation-edit-objective-timeframe').value = daysDiff > 0 ? daysDiff : '';
          
          const dueDateEl = document.getElementById('optimisation-edit-objective-due-date');
          if (dueDateEl) {
            dueDateEl.textContent = `Due: ${dueDate.toLocaleDateString('en-GB')}`;
          }
        } else {
          document.getElementById('optimisation-edit-objective-timeframe').value = '';
        }
      } else {
        // Legacy format fallback
        document.getElementById('optimisation-edit-objective-title').value = task.objective_title || '';
        document.getElementById('optimisation-edit-objective-kpi').value = task.objective_kpi || task.objective_metric || '';
        document.getElementById('optimisation-edit-objective-metric').value = task.objective_metric || task.objective_kpi || '';
        document.getElementById('optimisation-edit-objective-direction').value = task.objective_direction || '';
        document.getElementById('optimisation-edit-objective-target-value').value = task.objective_target_delta != null ? task.objective_target_delta : (task.objective_target_value != null ? task.objective_target_value : '');
        document.getElementById('optimisation-edit-objective-timeframe').value = task.objective_timeframe_days != null ? task.objective_timeframe_days : '';
        document.getElementById('optimisation-edit-objective-plan').value = task.objective_plan || '';
        
        // If objective_due_at exists, calculate and display it
        if (task.objective_due_at) {
          const dueDateEl = document.getElementById('optimisation-edit-objective-due-date');
          if (dueDateEl) {
            const dueDate = new Date(task.objective_due_at);
            dueDateEl.textContent = `Due: ${dueDate.toLocaleDateString('en-GB')}`;
          }
        }
      }

      // Calculate and show due date
      updateObjectiveDueDate();

      // Show form, hide content
      form.style.display = 'block';
      content.style.display = 'none';
    };

    // Update due date display when timeframe changes
    function updateObjectiveDueDate() {
      const timeframeInput = document.getElementById('optimisation-edit-objective-timeframe');
      const dueDateEl = document.getElementById('optimisation-edit-objective-due-date');
      if (!timeframeInput || !dueDateEl) return;

      const timeframe = parseInt(timeframeInput.value);
      if (timeframe > 0) {
        const taskId = (window.optimisationModuleState && window.optimisationModuleState.currentTaskId);
        const task = window.optimisationModuleState?.allTasks?.find(t => t.id === taskId);
        const startDate = (task && task.cycle_started_at) || (task && task.cycle_start_date) || new Date();
        const dueDate = new Date(new Date(startDate).getTime() + timeframe * 24 * 60 * 60 * 1000);
        dueDateEl.textContent = `Due: ${dueDate.toLocaleDateString('en-GB')}`;
      } else {
        dueDateEl.textContent = '';
      }
    }

    // Save objective
    window.saveObjective = async function saveObjective() {
      const taskId = (window.optimisationModuleState && window.optimisationModuleState.currentTaskId);
      if (!taskId) {
        alert('Task ID not found');
        return;
      }

      // Get form values (Phase 5 format)
      const title = document.getElementById('optimisation-edit-objective-title').value.trim();
      const kpi = document.getElementById('optimisation-edit-objective-metric').value || '';
      const targetValue = document.getElementById('optimisation-edit-objective-target-value').value;
      let target = targetValue ? (kpi === 'ai_overview' ? targetValue === 'true' : parseFloat(targetValue)) : null;
      // For CTR, convert from percentage to ratio (0-1) for storage
      if (kpi === 'ctr_28d' && target != null) {
        // If value is >= 1, assume it's a percentage and convert to ratio
        if (target >= 1) {
          target = target / 100;
        }
        // If value is < 1, assume it's already a ratio (but warn if it seems wrong)
        if (target < 0.01 && target > 0) {
          console.warn('[Optimisation] CTR target value seems very small. Expected percentage (e.g., 2.5 for 2.5%) or ratio (e.g., 0.025). Got:', target);
        }
      }
      const direction = document.getElementById('optimisation-edit-objective-direction').value || null;
      
      // Determine target_type based on KPI
      let target_type = 'delta';
      if (kpi === 'ai_overview' || kpi === 'current_rank') {
        target_type = 'absolute';
      } else if (direction === 'at_least' || direction === 'at_most') {
        target_type = 'absolute';
      }

      const timeframeDays = document.getElementById('optimisation-edit-objective-timeframe').value;
      const plan = document.getElementById('optimisation-edit-objective-plan').value.trim() || null;

      // Calculate due_at if timeframe is set
      let due_at = null;
      if (timeframeDays) {
        const task = window.optimisationModuleState?.allTasks?.find(t => t.id === taskId);
        const startDate = (task && task.cycle_started_at) || (task && task.cycle_start_date) ? new Date((task && task.cycle_started_at) || (task && task.cycle_start_date)) : new Date();
        due_at = new Date(startDate.getTime() + parseInt(timeframeDays) * 24 * 60 * 60 * 1000).toISOString();
      }

      // Client-side validation before sending
      if (!title || title.trim().length === 0) {
        alert('Please enter an objective title');
        return;
      }
      if (!kpi || kpi.trim().length === 0) {
        alert('Please select a metric');
        return;
      }
      if (target === null || target === undefined || isNaN(target)) {
        alert('Please enter a valid target value');
        return;
      }

      // Phase 5: Send new format (send empty strings instead of null for title/kpi to match API expectations)
      const objectiveData = {
        title: title,
        kpi: kpi,
        target: target,
        target_type: target_type,
        due_at: due_at,
        plan: plan
      };

      try {
        const headers = window.getOptimisationHeaders();
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/objective`), {
          method: 'PATCH',
          headers: { ...headers, 'Content-Type': 'application/json' },
          body: JSON.stringify(objectiveData)
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || (error.errors && error.errors.join(', ')) || 'Failed to save objective');
        }

        const data = await response.json();

        // Hide edit form
        document.getElementById('optimisation-edit-objective-form').style.display = 'none';
        document.getElementById('optimisation-drawer-objective-content').style.display = 'block';

        // Reload tasks and refresh drawer
        if (typeof window.loadAllOptimisationTasks === 'function') {
          await window.loadAllOptimisationTasks();
        }
        // Explicitly refresh the table to ensure "Due In" and other fields update
        if (typeof window.renderOptimisationTasksTable === 'function') {
          window.renderOptimisationTasksTable();
        }
        await window.openOptimisationTaskDrawer(taskId);
      } catch (error) {
        console.error('[Optimisation] Error saving objective:', error);
        alert('Failed to save objective: ' + error.message);
      }
    };

    // Cancel edit objective
    window.cancelEditObjective = function cancelEditObjective() {
      const form = document.getElementById('optimisation-edit-objective-form');
      const content = document.getElementById('optimisation-drawer-objective-content');
      if (form) form.style.display = 'none';
      if (content) content.style.display = 'block';
    };

    // Old modal-based edit (keeping for backward compatibility but not used)
    window.editObjectiveOld = async function editObjectiveOld() {
      const taskId = (window.optimisationModuleState && window.optimisationModuleState.currentTaskId);
      if (!taskId) return;

      const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      if (!task) return;

      // Show edit modal (reuse new cycle modal structure)
      const modal = document.getElementById('optimisation-edit-objective-modal');
      if (!modal) {
        alert('Edit objective modal not found. Please refresh the page.');
        return;
      }

      // Populate with current objective
      document.getElementById('edit-objective-title').value = task.objective_title || '';
      document.getElementById('edit-objective-primary-kpi').value = task.primary_kpi || '';
      document.getElementById('edit-objective-target-direction').value = task.target_direction || '';
      document.getElementById('edit-objective-target-value').value = task.target_value || '';
      document.getElementById('edit-objective-timeframe-days').value = task.timeframe_days || '';
      document.getElementById('edit-objective-plan').value = task.plan || '';

      modal.dataset.taskId = taskId;
      modal.style.display = 'flex';
    };

    window.submitEditObjective = async function submitEditObjective() {
      const modal = document.getElementById('optimisation-edit-objective-modal');
      if (!modal) return;

      const taskId = modal.dataset.taskId;
      if (!taskId) {
        alert('Task ID not found');
        return;
      }

      // Get objective fields
      const objective_title = document.getElementById('edit-objective-title').value.trim();
      const primary_kpi = document.getElementById('edit-objective-primary-kpi').value.trim();
      const target_direction = document.getElementById('edit-objective-target-direction').value.trim();
      const target_value = document.getElementById('edit-objective-target-value').value.trim();
      const timeframe_days = document.getElementById('edit-objective-timeframe-days').value.trim();
      const plan = document.getElementById('edit-objective-plan').value.trim();

      try {
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'PATCH',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            objective_title: objective_title || null,
            primary_kpi: primary_kpi || null,
            target_direction: target_direction || null,
            target_value: target_value ? parseFloat(target_value) : null,
            timeframe_days: timeframe_days ? parseInt(timeframe_days) : null,
            plan: plan || null
          })
        });

        if (!response.ok) {
          if (response.status === 401) {
            throw new Error('Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.');
          }
          const errorData = await response.json();
          throw new Error(errorData.error || 'Failed to update objective');
        }

        // Refresh tasks and reload drawer
        await window.loadAllOptimisationTasks();
        
        // Reload drawer if it's open
        if (window.optimisationModuleState.currentTaskId === taskId) {
          await window.openOptimisationTaskDrawer(taskId);
        }
        
        modal.style.display = 'none';
        
        alert('Objective updated successfully!');
      } catch (error) {
        console.error('[Optimisation] Error updating objective:', error);
        alert('Failed to update objective: ' + error.message);
      }
    };

    // Helper function to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Stop tracking
    window.stopTracking = async function stopTracking() {
      // B5: Support both modal and drawer
      const modal = document.getElementById('optimisation-manage-modal');
      const drawerTaskId = (window.optimisationModuleState && window.optimisationModuleState.currentTaskId);
      const modalTaskId = (modal && modal.dataset.taskId);
      const taskId = drawerTaskId || modalTaskId;
      
      if (!taskId) {
        console.warn('[Optimisation] No task ID found in modal or drawer');
        return;
      }

      if (!confirm('Stop tracking this keyword? The task will be marked as cancelled but history will be preserved.')) {
        return;
      }

      try {
        const headers = window.getOptimisationHeaders();
        console.log('[Optimisation] Stopping tracking:', { taskId, hasAdminKey: !!headers['x-arp-admin-key'] });
        
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'PATCH',
          headers: headers,
          body: JSON.stringify({
            status: 'cancelled'
          })
        });

        console.log('[Optimisation] Response status:', response.status, response.statusText);

        if (!response.ok) {
          // Clone response BEFORE reading to allow multiple reads
          const responseClone = response.clone();
          let errorMessage = 'Failed to stop tracking';
          let errorDetails = null;
          
          try {
            // Try to read as JSON first (most APIs return JSON)
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
            errorDetails = errorData;
            console.error('[Optimisation] API error response:', errorData);
          } catch (e) {
            // If JSON parsing fails, try text from clone
            console.error('[Optimisation] JSON parse failed, trying text:', e);
            try {
              const errorText = await responseClone.text();
              console.error('[Optimisation] Error response text (length):', errorText ? errorText.length : 0);
              if (errorText && errorText.trim()) {
                // Try to parse as JSON if it looks like JSON
                try {
                  const parsed = JSON.parse(errorText);
                  errorMessage = parsed.error || parsed.message || errorText;
                  errorDetails = parsed;
                } catch (parseError) {
                  errorMessage = errorText.substring(0, 200); // Limit length
                  errorDetails = { rawText: errorText.substring(0, 500) };
                }
                console.error('[Optimisation] API error text:', errorText.substring(0, 200));
              } else {
                console.error('[Optimisation] Error response body is empty');
                errorDetails = { empty: true };
              }
            } catch (e2) {
              console.error('[Optimisation] Failed to read error response:', e2);
              errorDetails = { readError: e2.message };
            }
          }
          
          // Enhance error message based on status code
          if (response.status === 401) {
            errorMessage = 'Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.';
          } else if (response.status === 404) {
            errorMessage = 'Task not found. It may have been deleted.';
          } else if (response.status === 403) {
            errorMessage = 'Forbidden - you do not have permission to update this task.';
          } else if (response.status === 500) {
            errorMessage = `Server error (${response.status}): ${errorMessage}`;
          } else {
            errorMessage = `HTTP ${response.status}: ${errorMessage}`;
          }
          
          console.error('[Optimisation] Full error details:', {
            status: response.status,
            statusText: response.statusText,
            errorMessage,
            errorDetails
          });
          
          throw new Error(errorMessage);
        }
        
        // Read successful response
        const result = await response.json();
        console.log('[Optimisation] Stop tracking successful:', result);

        // Refresh data
        if (modal && modal.dataset.rowKeyword) {
        await window.fetchOptimisationStatuses([{
          keyword: modal.dataset.rowKeyword,
          best_url: modal.dataset.rowUrl
        }]);
        }
        
        // Refresh all tasks if drawer is open
        if (window.optimisationModuleState && window.optimisationModuleState.currentTaskId) {
          await window.loadAllOptimisationTasks();
        }
        
        // Close modal if open, drawer if open
        if (modal) {
        modal.style.display = 'none';
        }
        if (window.optimisationModuleState && window.optimisationModuleState.currentTaskId) {
          closeOptimisationTaskDrawer();
        }
        
        // Ensure Ranking & AI tab stays active and refresh table
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        if (rankingTab) {
          // Use setActivePanel to properly show the panel
          if (typeof setActivePanel === 'function') {
            setActivePanel('ranking');
          } else {
            // Fallback: manually set active state
            document.querySelectorAll('.aigeo-panel').forEach(panel => {
              panel.classList.remove('is-active');
              panel.hidden = true;
            });
          rankingTab.classList.add('is-active');
            rankingTab.hidden = false;
          }
          
          // Update nav button states
          document.querySelectorAll('.aigeo-nav-item').forEach(btn => btn.classList.remove('is-active'));
          const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav-item')).find(btn => 
            btn.getAttribute('data-panel') === 'ranking'
          );
          if (rankingNavBtn) rankingNavBtn.classList.add('is-active');
          
          // Ensure panel is rendered
          if (typeof ensurePanelRendered === 'function') {
            ensurePanelRendered('ranking');
          }
        }
        
        // Trigger table re-render
        if (typeof renderRankingAiTab === 'function') {
          await renderRankingAiTab();
        } else if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        } else {
          console.warn('[Optimisation] renderRankingAiTab not found, refreshing page');
          // Preserve Ranking & AI tab state before reload
          sessionStorage.setItem('activeTab', 'ranking');
          window.location.hash = '#ranking';
          location.reload();
        }
      } catch (error) {
        console.error('[Optimisation] Error stopping tracking:', error);
        alert('Failed to stop tracking: ' + error.message);
      }
    };

    // Delete task (hard delete - removes task and all events)
    window.deleteTask = async function deleteTask() {
      const taskId = (window.optimisationModuleState && window.optimisationModuleState.currentTaskId);
      
      if (!taskId) {
        console.warn('[Optimisation] No task ID found');
        return;
      }

      if (!confirm('Permanently delete this task and all its events? This cannot be undone.')) {
        return;
      }

      try {
        const headers = window.getOptimisationHeaders();
        console.log('[Optimisation] Deleting task:', { taskId, hasAdminKey: !!headers['x-arp-admin-key'] });
        
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'DELETE',
          headers: headers
        });

        console.log('[Optimisation] Response status:', response.status, response.statusText);

        if (!response.ok) {
          const responseClone = response.clone();
          let errorMessage = 'Failed to delete task';
          
          try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
            console.error('[Optimisation] API error response:', errorData);
          } catch (e) {
            try {
              const errorText = await responseClone.text();
              if (errorText && errorText.trim()) {
                try {
                  const parsed = JSON.parse(errorText);
                  errorMessage = parsed.error || parsed.message || errorText;
                } catch (parseError) {
                  errorMessage = errorText.substring(0, 200);
                }
              }
            } catch (e2) {
              console.error('[Optimisation] Failed to read error response:', e2);
            }
          }
          
          if (response.status === 401) {
            errorMessage = 'Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.';
          } else if (response.status === 404) {
            errorMessage = 'Task not found. It may have been deleted.';
          } else if (response.status === 403) {
            errorMessage = 'Forbidden - you do not have permission to update this task.';
          } else if (response.status === 500) {
            errorMessage = `Server error (${response.status}): ${errorMessage}`;
          } else {
            errorMessage = `HTTP ${response.status}: ${errorMessage}`;
          }
          
          throw new Error(errorMessage);
        }
        
        const result = await response.json();
        console.log('[Optimisation] Delete task successful:', result);

        // Close the modal/drawer
        const drawer = document.getElementById('optimisation-task-drawer');
        if (drawer) {
          drawer.style.display = 'none';
        }

        // Clear the cache to force refresh
        if (window.optimisationStatusCache) {
          window.optimisationStatusCache.clear();
        }

        // Refresh Optimisation Tracking table
        await window.loadAllOptimisationTasks();

        // Refresh Ranking & AI table to show "Not tracked"
        if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        }
      } catch (error) {
        console.error('[Optimisation] Error deleting task:', error);
        throw error; // Re-throw so caller can handle
      }
    };

    // ======================
    // Optimisation Tracking Module (Phase B)
    // ======================
    
    // State
    window.optimisationModuleState = {
      allTasks: [],
      dashboardTiles: null,
      dashboardImpact: null,
      dashboardTimeseries: null,
      filteredTasks: [],
      activeTab: 'active',
      currentTaskId: null,
      authError: null,
      activeObjectiveFilter: null, // 'not_set' | 'on_track' | 'overdue' | 'met' | null
      scope: 'active_cycle', // 'active_cycle' | 'all_tasks'
      metricTrafficFilter: null, // { metricKey: string, bucket: 'better'|'same'|'worse' } | null
      trafficKpiOnly: false, // Filter to tasks with CTR/Impressions/Clicks objectives
      clickRelatedOnly: false, // Filter to tasks where clicks delta is computable
      selectedKpiForTrend: 'ctr_28d', // KPI selected for trend chart
      leftChartView: 'clicks' // 'clicks' | 'trend'
    };
    
    // Traffic Light Utility Functions (inline from lib/optimisation/metricTraffic.js)
    function isActiveStatus(status) {
      return ['planned', 'in_progress', 'monitoring'].includes(status);
    }

    function getBaselineLatest(measurements, scope, activeCycle = null) {
      if (!measurements || measurements.length === 0) {
        return null;
      }

      let eligibleMeasurements = [...measurements];

      // Filter by scope
      if (scope === 'active_cycle' && activeCycle) {
        const cycleStartDate = activeCycle.start_date ? new Date(activeCycle.start_date) : 
                              (activeCycle.started_at ? new Date(activeCycle.started_at) : null);
        if (cycleStartDate) {
          const filtered = eligibleMeasurements.filter(m => {
            const mDate = m.captured_at ? new Date(m.captured_at) : null;
            return mDate && mDate >= cycleStartDate;
          });
          // If filtering by cycle date results in no measurements, but we only have 1 measurement total,
          // use that measurement anyway (it's likely the baseline captured at task creation)
          if (filtered.length > 0) {
            eligibleMeasurements = filtered;
          } else if (eligibleMeasurements.length === 1) {
            // Keep the single measurement even if it's before cycle start (baseline case)
            // Don't filter it out
          } else {
            eligibleMeasurements = filtered;
          }
        }
      }

      // Need at least 1 measurement (baseline) to compute baseline/latest
      // If only 1 measurement, use it as both baseline and latest
      if (eligibleMeasurements.length < 1) {
        return null;
      }

      // Sort by date (oldest first)
      eligibleMeasurements.sort((a, b) => {
        const dateA = a.captured_at ? new Date(a.captured_at) : new Date(0);
        const dateB = b.captured_at ? new Date(b.captured_at) : new Date(0);
        return dateA - dateB;
      });

      // Baseline selection must respect rebaselining:
      // If there are measurements explicitly marked as baseline, use the *most recent* baseline marker.
      // Otherwise fallback to the first (oldest) measurement.
      const baselineIdx = (() => {
        for (let i = eligibleMeasurements.length - 1; i >= 0; i--) {
          const m = eligibleMeasurements[i];
          if (m && (m.is_baseline === true || m.isBaseline === true)) return i;
        }
        return 0;
      })();

      const baseline = eligibleMeasurements[baselineIdx];
      // Latest = most recent measurement after baseline (or baseline itself if it's the newest)
      const latest = eligibleMeasurements.length > 1 ? eligibleMeasurements[eligibleMeasurements.length - 1] : baseline;

      // DEBUG: Log what we're returning
      if (typeof debugLog === 'function' && eligibleMeasurements.length > 0) {
        const baselineDate = baseline?.captured_at || baseline?.created_at || 'no-date';
        const latestDate = latest?.captured_at || latest?.created_at || 'no-date';
        const isSame = baseline === latest;
        debugLog(`[getBaselineLatest] eligibleMeasurements.length=${eligibleMeasurements.length}, baselineIdx=${baselineIdx}, baselineDate=${baselineDate}, latestDate=${latestDate}, isSameObject=${isSame}`, isSame ? 'warn' : 'info');
      }

      return { baseline, latest };
    }

    function getMetricValue(measurement, metricKey) {
      if (!measurement) return null;

      const extractors = {
        ctr_28d: (m) => {
          // Handle both gsc_ prefixed fields (from baseline) and regular fields
          if (m && (m.gsc_ctr_28d != null || m.ctr_28d != null)) {
            return m.gsc_ctr_28d != null ? m.gsc_ctr_28d : m.ctr_28d;
          }
          return null;
        },
        impressions_28d: (m) => {
          if (m && (m.gsc_impressions_28d != null || m.impressions_28d != null)) {
            return m.gsc_impressions_28d != null ? m.gsc_impressions_28d : m.impressions_28d;
          }
          return null;
        },
        clicks_28d: (m) => {
          if (m && (m.gsc_clicks_28d != null || m.clicks_28d != null)) {
            return m.gsc_clicks_28d != null ? m.gsc_clicks_28d : m.clicks_28d;
          }
          return null;
        },
        current_rank: (m) => {
          if (m && (m.gsc_position_28d != null || m.current_rank != null || m.rank != null)) {
            return m.gsc_position_28d != null ? m.gsc_position_28d : (m.current_rank != null ? m.current_rank : m.rank);
          }
          return null;
        },
        opportunity_score: (m) => (m && m.opportunity_score) != null ? m.opportunity_score : null,
        ai_overview: (m) => (m && m.ai_overview) != null ? m.ai_overview : null,
        ai_citations: (m) => (m && m.ai_citations) != null ? m.ai_citations : null,
      };

      const extractor = extractors[metricKey];
      if (!extractor) return null;

      return extractor(measurement);
    }

    function classifyMetric(metricKey, baseline, latest) {
      if (!baseline || !latest) {
        return null;
      }

      const baselineValue = getMetricValue(baseline, metricKey);
      const latestValue = getMetricValue(latest, metricKey);

      // If either value is null/undefined, cannot classify
      if (baselineValue == null || latestValue == null) {
        return null;
      }

      // CTR (28d) - stored as ratio (0-1), compare as percentage points
      if (metricKey === 'ctr_28d') {
        // Normalize CTR to a ratio (0-1).
        // Legacy data sometimes stores CTR as a percent in the 1..100 range (including 1.00 meaning 1%).
        const normalizeCtrRatio = (raw, measurement) => {
          const v = Number(raw);
          if (!isFinite(v)) return null;

          // Canonical ratio
          if (v >= 0 && v < 1) return v;

          // Likely percent
          if (v >= 1 && v <= 100) {
            // Edge case: some legitimate CTR ratios could be exactly 1.0 (100%) for tiny impression counts.
            // If clicks==impressions and impressions are very small, treat 1.0 as ratio; otherwise treat as 1%.
            if (v === 1) {
              const impr = getMetricValue(measurement, 'impressions_28d');
              const clicks = getMetricValue(measurement, 'clicks_28d');
              if (impr != null && clicks != null && Number(impr) > 0 && Number(impr) <= 10 && Number(clicks) === Number(impr)) {
                return 1;
              }
            }
            return v / 100;
          }

          // Fallback
          return v;
        };

        const baselineRatio = normalizeCtrRatio(baselineValue, baseline);
        const latestRatio = normalizeCtrRatio(latestValue, latest);
        if (baselineRatio == null || latestRatio == null) return null;

        // Match what the UI shows: baseline/latest are displayed to 2dp (%) in the task table/drawer.
        // If they render equal, classify as 'same' (avoid confusing "Better" due to tiny precision noise).
        const baselinePct2 = Math.round((baselineRatio * 100) * 100) / 100;
        const latestPct2 = Math.round((latestRatio * 100) * 100) / 100;
        const deltaPp = latestPct2 - baselinePct2;
        if (Math.abs(deltaPp) < 0.10) {
          return 'same';
        }
        return deltaPp > 0.10 ? 'better' : 'worse';
      }

      // Impressions (28d)
      if (metricKey === 'impressions_28d') {
        const delta = latestValue - baselineValue;
        const tol = Math.max(20, Math.round(baselineValue * 0.02));
        if (Math.abs(delta) < tol) {
          return 'same';
        }
        return delta >= tol ? 'better' : 'worse';
      }

      // Clicks (28d)
      if (metricKey === 'clicks_28d') {
        const delta = latestValue - baselineValue;
        const tol = Math.max(5, Math.round(baselineValue * 0.05));
        if (Math.abs(delta) < tol) {
          return 'same';
        }
        return delta >= tol ? 'better' : 'worse';
      }

      // Rank (lower is better)
      if (metricKey === 'current_rank') {
        const delta = latestValue - baselineValue; // positive means rank got worse (increased)
        if (Math.abs(delta) < 0.5) {
          return 'same';
        }
        return delta <= -0.5 ? 'better' : 'worse';
      }

      // AI Citations
      if (metricKey === 'ai_citations') {
        const delta = latestValue - baselineValue;
        if (delta === 0) {
          return 'same';
        }
        return delta > 0 ? 'better' : 'worse';
      }

      // AI Overview (boolean)
      if (metricKey === 'ai_overview') {
        const baselineBool = baselineValue === true || baselineValue === 'On' || baselineValue === 1;
        const latestBool = latestValue === true || latestValue === 'On' || latestValue === 1;
        
        if (baselineBool === latestBool) {
          return 'same';
        }
        // Better: Off -> On, Worse: On -> Off
        return (!baselineBool && latestBool) ? 'better' : 'worse';
      }

      // Opportunity Score
      if (metricKey === 'opportunity_score') {
        const delta = latestValue - baselineValue;
        if (Math.abs(delta) < 2) {
          return 'same';
        }
        return delta >= 2 ? 'better' : 'worse';
      }

      // Unknown metric
      return null;
    }

    // Helper: Get latest measurement in scope for a task
    function getLatestMeasurementInScope(task, scope) {
      const measurements = task.measurements || [];
      if (measurements.length === 0) {
        return null;
      }

      let eligibleMeasurements = [...measurements];

      // Filter by scope
      if (scope === 'active_cycle') {
        const activeCycle = (task.cycles && task.cycles.find(c => c.is_active || c.id === task.active_cycle_id)) || null;
        if (activeCycle) {
          const cycleStartDate = activeCycle.start_date ? new Date(activeCycle.start_date) : 
                                (activeCycle.started_at ? new Date(activeCycle.started_at) : null);
          if (cycleStartDate) {
            eligibleMeasurements = eligibleMeasurements.filter(m => {
              const mDate = m.captured_at ? new Date(m.captured_at) : null;
              return mDate && mDate >= cycleStartDate;
            });
          }
        }
      }
      // For 'all_tasks' scope, use all measurements

      if (eligibleMeasurements.length === 0) {
        return null;
      }

      // Sort by date (newest first) and return the latest
      eligibleMeasurements.sort((a, b) => {
        const dateA = a.captured_at ? new Date(a.captured_at) : new Date(0);
        const dateB = b.captured_at ? new Date(b.captured_at) : new Date(0);
        return dateB - dateA; // Descending (newest first)
      });

      return eligibleMeasurements[0];
    }

    // Helper: Get Monday-start week key (YYYY-MM-DD)
    function weekStartISO(date) {
      const d = new Date(date);
      d.setHours(0, 0, 0, 0);
      // Get day of week (0 = Sunday, 1 = Monday, etc.)
      const day = d.getDay();
      // Calculate days to subtract to get to Monday
      const diff = day === 0 ? 6 : day - 1; // If Sunday, go back 6 days; otherwise go back (day-1) days
      d.setDate(d.getDate() - diff);
      // Return YYYY-MM-DD format
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, '0');
      const dayOfMonth = String(d.getDate()).padStart(2, '0');
      return `${year}-${month}-${dayOfMonth}`;
    }

    // Helper: Compute delta for a KPI with correct units
    function computeDeltaForKPI(kpi, baseline, latest) {
      if (!baseline || !latest) {
        return null;
      }

      const baselineValue = getMetricValue(baseline, kpi);
      const latestValue = getMetricValue(latest, kpi);

      if (baselineValue == null || latestValue == null) {
        return null;
      }

      // CTR: return as percentage points
      if (kpi === 'ctr_28d') {
        // Normalize: CTR should be stored as ratio (0-1), but legacy values can be stored as percent (0-100).
        let baselineRatio = baselineValue;
        let latestRatio = latestValue;
        if (Math.abs(baselineValue) > 1) {
          baselineRatio = baselineValue / 100;
        }
        if (Math.abs(latestValue) > 1) {
          latestRatio = latestValue / 100;
        }
        
        const rawDelta = latestRatio - baselineRatio;
        const deltaPp = rawDelta * 100; // Convert ratio delta to percentage points
        
        return deltaPp;
      }

      // Rank: lower is better, so invert the delta (baseline - latest)
      // Positive delta = improvement (rank decreased)
      if (kpi === 'current_rank') {
        return baselineValue - latestValue;
      }

      // All others: absolute delta (higher is better)
      return latestValue - baselineValue;
    }

    // Helper: Compute median of an array
    function median(values) {
      if (values.length === 0) return null;
      const sorted = [...values].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2 === 0
        ? (sorted[mid - 1] + sorted[mid]) / 2
        : sorted[mid];
    }

    function computeTrafficLightCounts(tasks, scope) {
      const counts = {
        ctr_28d: { worse: 0, same: 0, better: 0 },
        impressions_28d: { worse: 0, same: 0, better: 0 },
        clicks_28d: { worse: 0, same: 0, better: 0 },
        current_rank: { worse: 0, same: 0, better: 0 },
        ai_citations: { worse: 0, same: 0, better: 0 },
        ai_overview: { worse: 0, same: 0, better: 0 },
        all_metrics: { worse: 0, same: 0, better: 0 }, // Aggregated counts
      };

      const metricKeys = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];

      for (const task of tasks) {
        // Only count active tasks
        if (!isActiveStatus(task.status)) {
          continue;
        }

        // Get active cycle if scope is 'active_cycle'
        const activeCycle = scope === 'active_cycle' 
          ? ((task.cycles && task.cycles.find(c => c.is_active || c.id === task.active_cycle_id)) || null)
          : null;

        // Get measurements
        const measurements = task.measurements || [];
        let baselineLatest = getBaselineLatest(measurements, scope, activeCycle);
        
        // FALLBACK: If getBaselineLatest returned null (no measurements or only 1), try using baseline_metrics/latest_metrics
        // ALSO: If baseline === latest (same object, meaning only 1 measurement), use baseline_metrics/latest_metrics
        // BUT: Only use fallback if baseline_metrics and latest_metrics actually have different captured_at dates
        if (!baselineLatest && task.baseline_metrics && task.latest_metrics) {
          const baselineDate = task.baseline_metrics.captured_at || task.baseline_metrics.created_at || null;
          const latestDate = task.latest_metrics.captured_at || task.latest_metrics.created_at || null;
          // Only use fallback if dates are actually different (indicating different snapshots)
          if (baselineDate && latestDate && baselineDate !== latestDate) {
            debugLog(`[Traffic Lights] Task "${task.title || task.id}": No measurements array, using baseline_metrics/latest_metrics fallback (dates differ: ${baselineDate} vs ${latestDate})`, 'info');
            
            // DEBUG: Log raw values from baseline_metrics and latest_metrics for each metric
            const metricKeysForDebug = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
            for (const mk of metricKeysForDebug) {
              const baselineRaw = task.baseline_metrics[mk] ?? task.baseline_metrics[`gsc_${mk}`] ?? task.baseline_metrics[`gsc_${mk.replace('_28d', '')}`] ?? 'NOT_FOUND';
              const latestRaw = task.latest_metrics[mk] ?? task.latest_metrics[`gsc_${mk}`] ?? task.latest_metrics[`gsc_${mk.replace('_28d', '')}`] ?? 'NOT_FOUND';
              debugLog(`[Traffic Lights] Task "${task.title || task.id}" RAW ${mk}: baseline_metrics=${baselineRaw}, latest_metrics=${latestRaw}`, 'info');
            }
            
            baselineLatest = {
              baseline: { ...task.baseline_metrics, captured_at: task.baseline_metrics.captured_at || null },
              latest: { ...task.latest_metrics, captured_at: task.latest_metrics.captured_at || null }
            };
            
            // DEBUG: Log what getMetricValue extracts after creating baselineLatest
            for (const mk of metricKeysForDebug) {
              const baselineExtracted = getMetricValue(baselineLatest.baseline, mk);
              const latestExtracted = getMetricValue(baselineLatest.latest, mk);
              debugLog(`[Traffic Lights] Task "${task.title || task.id}" EXTRACTED ${mk}: baselineValue=${baselineExtracted}, latestValue=${latestExtracted}`, baselineExtracted === latestExtracted ? 'warn' : 'info');
            }
          } else {
            debugLog(`[Traffic Lights] Task "${task.title || task.id}": No measurements and baseline_metrics/latest_metrics have same date (${baselineDate}) - cannot compute delta`, 'warn');
          }
        } else if (baselineLatest && baselineLatest.baseline === baselineLatest.latest) {
          // Only 1 measurement - baseline and latest are the same object
          // Use baseline_metrics/latest_metrics if available (they should have different values)
          if (task.baseline_metrics && task.latest_metrics) {
            const baselineDate = task.baseline_metrics.captured_at || task.baseline_metrics.created_at || null;
            const latestDate = task.latest_metrics.captured_at || task.latest_metrics.created_at || null;
            const datesAreDifferent = baselineDate !== latestDate;
            // Only use fallback if dates are actually different (indicating different snapshots)
            if (baselineDate && latestDate && datesAreDifferent) {
              debugLog(`[Traffic Lights] Task "${task.title || task.id}": Only 1 measurement (baseline === latest), using baseline_metrics/latest_metrics fallback. baselineDate=${baselineDate}, latestDate=${latestDate}`, 'info');
              
              // DEBUG: Log raw values from baseline_metrics and latest_metrics for each metric
              const metricKeysForDebug = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
              for (const mk of metricKeysForDebug) {
                const baselineRaw = task.baseline_metrics[mk] ?? task.baseline_metrics[`gsc_${mk}`] ?? task.baseline_metrics[`gsc_${mk.replace('_28d', '')}`] ?? 'NOT_FOUND';
                const latestRaw = task.latest_metrics[mk] ?? task.latest_metrics[`gsc_${mk}`] ?? task.latest_metrics[`gsc_${mk.replace('_28d', '')}`] ?? 'NOT_FOUND';
                debugLog(`[Traffic Lights] Task "${task.title || task.id}" RAW ${mk}: baseline_metrics=${baselineRaw}, latest_metrics=${latestRaw}`, 'info');
              }
              
              baselineLatest = {
                baseline: { ...task.baseline_metrics, captured_at: baselineDate },
                latest: { ...task.latest_metrics, captured_at: latestDate }
              };
              
              // DEBUG: Log what getMetricValue extracts after creating baselineLatest
              for (const mk of metricKeysForDebug) {
                const baselineExtracted = getMetricValue(baselineLatest.baseline, mk);
                const latestExtracted = getMetricValue(baselineLatest.latest, mk);
                debugLog(`[Traffic Lights] Task "${task.title || task.id}" EXTRACTED ${mk}: baselineValue=${baselineExtracted}, latestValue=${latestExtracted}`, baselineExtracted === latestExtracted ? 'warn' : 'info');
              }
            } else {
              debugLog(`[Traffic Lights] Task "${task.title || task.id}": Only 1 measurement but baseline_metrics/latest_metrics have same date (${baselineDate}) - cannot compute delta`, 'warn');
            }
          } else {
            debugLog(`[Traffic Lights] Task "${task.title || task.id}": Only 1 measurement and no baseline_metrics/latest_metrics available - metrics will show as 'same'`, 'warn');
          }
        } else if (!baselineLatest) {
          // No baselineLatest could be computed - log why
          debugLog(`[Traffic Lights] Task "${task.title || task.id}": Cannot compute baselineLatest - measurements.length=${measurements.length}, hasBaselineMetrics=${!!task.baseline_metrics}, hasLatestMetrics=${!!task.latest_metrics}`, 'warn');
        }

        // DEBUG: Log task details for troubleshooting
        if (task.title && (task.title.includes('Landscape') || task.title.includes('photography-courses'))) {
          if (typeof debugLog === 'function') {
            debugLog(`[Traffic Lights] Task: id=${task.id}, title="${task.title}", status=${task.status}, objectiveKpiKey=${task.objectiveKpiKey}, measurementsCount=${measurements.length}, hasBaselineLatest=${!!baselineLatest}, hasBaselineMetrics=${!!task.baseline_metrics}, hasLatestMetrics=${!!task.latest_metrics}`, 'info');
          }
        }
        
        // DEBUG: Log data structure for all tasks with objectives
        if (typeof debugLog === 'function' && task.objectiveKpiKey) {
          const baselineMetricsKeys = task.baseline_metrics ? Object.keys(task.baseline_metrics).filter(k => k.includes('ctr') || k.includes('citation') || k.includes('clicks') || k.includes('impression') || k.includes('rank') || k.includes('overview')).join(', ') : 'none';
          const latestMetricsKeys = task.latest_metrics ? Object.keys(task.latest_metrics).filter(k => k.includes('ctr') || k.includes('citation') || k.includes('clicks') || k.includes('impression') || k.includes('rank') || k.includes('overview')).join(', ') : 'none';
          debugLog(`[Traffic Lights] Task "${task.title || task.id}": measurements.length=${measurements.length}, baseline_metrics keys=[${baselineMetricsKeys}], latest_metrics keys=[${latestMetricsKeys}]`, 'info');
          
          // DEBUG: Log ALL keys in baseline_metrics and latest_metrics to see full structure
          if (task.baseline_metrics || task.latest_metrics) {
            const allBaselineKeys = task.baseline_metrics ? Object.keys(task.baseline_metrics).join(', ') : 'none';
            const allLatestKeys = task.latest_metrics ? Object.keys(task.latest_metrics).join(', ') : 'none';
            debugLog(`[Traffic Lights] Task "${task.title || task.id}": ALL baseline_metrics keys=[${allBaselineKeys}], ALL latest_metrics keys=[${allLatestKeys}]`, 'info');
          }
        }

        // Track classifications for all metrics to compute aggregated count
        const taskClassifications = [];

        if (baselineLatest) {
          // DEBUG: Log measurement structure for all tasks with objectives
          if (typeof debugLog === 'function' && task.objectiveKpiKey) {
            const baselineKeys = Object.keys(baselineLatest.baseline || {}).filter(k => k.includes('ctr') || k.includes('citation') || k.includes('clicks') || k.includes('impression') || k.includes('rank') || k.includes('overview'));
            const latestKeys = Object.keys(baselineLatest.latest || {}).filter(k => k.includes('ctr') || k.includes('citation') || k.includes('clicks') || k.includes('impression') || k.includes('rank') || k.includes('overview'));
            debugLog(`[Traffic Lights] Task "${task.title || task.id}": objectiveKpiKey=${task.objectiveKpiKey}, measurementsCount=${measurements.length}, baselineFields=[${baselineKeys.join(', ')}], latestFields=[${latestKeys.join(', ')}]`, 'info');
            // Log measurement details
            if (measurements.length > 0) {
              const measurementDates = measurements.map(m => m.captured_at || m.created_at || 'no-date').join(', ');
              debugLog(`[Traffic Lights] Task "${task.title || task.id}": measurement dates: [${measurementDates}]`, 'info');
              debugLog(`[Traffic Lights] Task "${task.title || task.id}": baseline.captured_at=${baselineLatest.baseline?.captured_at || baselineLatest.baseline?.created_at || 'N/A'}, latest.captured_at=${baselineLatest.latest?.captured_at || baselineLatest.latest?.created_at || 'N/A'}`, 'info');
              // Check if baseline and latest are the same object
              const isSameObject = baselineLatest.baseline === baselineLatest.latest;
              debugLog(`[Traffic Lights] Task "${task.title || task.id}": baseline === latest (same object)? ${isSameObject}`, isSameObject ? 'warn' : 'info');
            }
          }
          
          // Classify ALL metrics for ALL tasks (regardless of task objective)
          // This ensures traffic lights show improvements/declines across all metrics, not just the objective
          for (const metricKey of metricKeys) {
            const baselineValue = getMetricValue(baselineLatest.baseline, metricKey);
            const latestValue = getMetricValue(baselineLatest.latest, metricKey);
            const classification = classifyMetric(
              metricKey,
              baselineLatest.baseline,
              baselineLatest.latest
            );

            // DEBUG: Log classification for all tasks with detailed value comparison
            if (typeof debugLog === 'function') {
              const baselineDate = baselineLatest.baseline?.captured_at || baselineLatest.baseline?.created_at || 'no-date';
              const latestDate = baselineLatest.latest?.captured_at || baselineLatest.latest?.created_at || 'no-date';
              const isSameObject = baselineLatest.baseline === baselineLatest.latest;
              const delta = (baselineValue != null && latestValue != null) ? (latestValue - baselineValue) : null;
              debugLog(`[Traffic Lights] Task "${task.title || task.id}" ${metricKey}: baselineValue=${baselineValue}, latestValue=${latestValue}, delta=${delta}, classification=${classification || 'null'}, baselineDate=${baselineDate}, latestDate=${latestDate}, isSameObject=${isSameObject}`, classification === 'same' && delta !== 0 ? 'warn' : 'info');
            }

            if (classification) {
              counts[metricKey][classification]++;
              taskClassifications.push(classification);
            }
          }
        } else if (typeof debugLog === 'function' && task.objectiveKpiKey) {
          debugLog(`[Traffic Lights] Task "${task.title || task.id}": No baselineLatest (measurementsCount=${measurements.length}, scope=${scope})`, 'warn');
        } else if (task.title && (task.title.includes('Landscape') || task.title.includes('photography-courses'))) {
          if (typeof debugLog === 'function') {
            debugLog(`[Traffic Lights] No baselineLatest for task: id=${task.id}, title="${task.title}", measurementsCount=${measurements.length}, scope=${scope}, hasActiveCycle=${!!activeCycle}`, 'warn');
          }
        }

        // For aggregated "all_metrics": count ALL active tasks
        // If task has classifications, use majority vote (at least 3 out of 6 metrics)
        // If no classifications or tie, default to 'same'
        if (taskClassifications.length > 0) {
          // Count occurrences of each classification
          const classCounts = { worse: 0, same: 0, better: 0 };
          taskClassifications.forEach(cls => {
            if (cls) classCounts[cls]++;
          });
          
          // Find the majority classification
          const total = classCounts.worse + classCounts.same + classCounts.better;
          const majority = Math.max(classCounts.worse, classCounts.same, classCounts.better);
          
          let majorityClass = null;
          if (classCounts.better === majority && majority > 0) {
            majorityClass = 'better';
          } else if (classCounts.worse === majority && majority > 0) {
            majorityClass = 'worse';
          } else if (classCounts.same === majority && majority > 0) {
            majorityClass = 'same';
          }
          
          // If there's a clear majority (more than half), use it
          // Otherwise default to 'same'
          if (majorityClass && majority > total / 2) {
            counts.all_metrics[majorityClass]++;
          } else {
            // No clear majority or no classifications - default to 'same'
            counts.all_metrics.same++;
          }
        } else {
          // Task has no metric classifications (insufficient data) - count as 'same'
          counts.all_metrics.same++;
        }
      }

      return counts;
    }

    // Sorting state
    let optimisationSortState = {
      column: 'latestCaptured',
      direction: 'desc'
    };
    
    // Pagination state
    let optimisationPaginationState = {
      currentPage: 1,
      rowsPerPage: 10
    };

    // Load all optimisation tasks (Phase 9: use dashboard API)
    window.loadAllOptimisationTasks = async function loadAllOptimisationTasks() {
      try {
        // Get headers (will include admin key if available)
        const headers = window.getOptimisationHeaders ? window.getOptimisationHeaders() : {};
        const scope = window.optimisationModuleState.scope || 'active_cycle';
        
        // Check if admin key is in headers (but still make API call - let server decide)
        const hasKeyInHeaders = !!(headers['x-arp-admin-key'] || headers['x-arp-share-token']);
        
        if (!hasKeyInHeaders) {
          // Only show warning if we're sure there's no key (check both storage locations)
          const adminKey = window.getAdminKey ? window.getAdminKey() : (sessionStorage.getItem('arp_admin_key') || localStorage.getItem('arp_admin_key') || '');
          if (!adminKey) {
            window.optimisationModuleState.allTasks = [];
            window.optimisationModuleState.filteredTasks = [];
            window.optimisationModuleState.authError = 'Admin key not set. Please set your admin key in the Configuration section.';
            updateOptimisationSummaryCards();
            renderOptimisationTasksTable();
            return [];
          }
        }
        
        // Add cache-busting timestamp to ensure fresh data
        const cacheBuster = `_t=${Date.now()}`;
        const response = await fetch(apiUrl(`/api/optimisation/dashboard?scope=${scope}&${cacheBuster}`), {
          method: 'GET',
          headers: {
            ...headers,
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache'
          }
        });

        if (!response.ok) {
          let errorMessage = `Failed to load dashboard (${response.status}).`;
          
          // Try to get error details from response
          try {
            const errorData = await response.json();
            if (errorData.error) {
              errorMessage = errorData.error;
            }
          } catch (e) {
            // If JSON parsing fails, use status-based message
            if (response.status === 401) {
              errorMessage = 'Unauthorized - admin key missing or invalid. Please check your admin key in the Configuration section.';
            } else if (response.status === 500) {
              errorMessage = 'Server error - please try refreshing the page. If the issue persists, check the server logs.';
            }
          }
          
          window.optimisationModuleState.authError = errorMessage;
          window.optimisationModuleState.allTasks = [];
          window.optimisationModuleState.filteredTasks = [];
          window.optimisationModuleState.dashboardTiles = null;
          window.optimisationModuleState.dashboardImpact = null;
          window.optimisationModuleState.dashboardTimeseries = null;
          updateOptimisationSummaryCards();
          renderOptimisationTasksTable();
          
          // Log for debugging
          console.error('[Optimisation Dashboard] API error:', {
            status: response.status,
            statusText: response.statusText,
            hasAdminKey: hasKeyInHeaders,
            headers: Object.keys(headers)
          });
          
          return [];
        }

        // Clear any previous auth errors
        window.optimisationModuleState.authError = null;

        const data = await response.json();
        debugLog(`[Optimisation] API returned ${data.tasks?.length || 0} tasks. Sample: ${data.tasks?.[0]?.title || 'N/A'} (ID: ${data.tasks?.[0]?.id || 'N/A'}, latest_metrics.captured_at: ${data.tasks?.[0]?.latest_metrics?.captured_at || 'N/A'})`, 'info');
        // DEBUG: Check if tasks have measurements array
        if (data.tasks && data.tasks.length > 0) {
          const sampleTask = data.tasks[0];
          const hasMeasurements = Array.isArray(sampleTask.measurements);
          const measurementsCount = hasMeasurements ? sampleTask.measurements.length : 0;
          debugLog(`[Optimisation] Sample task "${sampleTask.title || sampleTask.id}": hasMeasurements=${hasMeasurements}, measurementsCount=${measurementsCount}, hasLatestMetrics=${!!sampleTask.latest_metrics}, hasBaselineMetrics=${!!sampleTask.baseline_metrics}`, 'info');
          if (hasMeasurements && measurementsCount > 0) {
            const measurementDates = sampleTask.measurements.map(m => m.captured_at || m.created_at || 'no-date').join(', ');
            debugLog(`[Optimisation] Sample task measurements dates: [${measurementDates}]`, 'info');
          }
        }
        window.optimisationModuleState.allTasks = data.tasks || [];
        window.optimisationModuleState.filteredTasks = [...window.optimisationModuleState.allTasks];
        debugLog(`[Optimisation] State updated - allTasks count: ${window.optimisationModuleState.allTasks.length}`, 'info');
        window.optimisationModuleState.dashboardTiles = data.tiles || null;
        window.optimisationModuleState.dashboardImpact = data.impact || null;
        window.optimisationModuleState.dashboardTimeseries = data.timeseries || null;
        
        updateOptimisationSummaryCards();
        updateKPITiles();
        updateImpactTiles();
        updateTimeseriesCharts();
        updateTrafficLights();
        applyOptimisationFilters();
        renderOptimisationTasksTable();

        // Dashboard: refresh live dials/cards after tasks load
        // Only refresh if dashboard tab is currently active to prevent unnecessary re-renders
        // Use a flag to prevent loops
        if (!window.__dashboardRefreshInProgress && typeof window.renderDashboardTab === 'function') {
          const activePanel = document.querySelector('.panel.active[data-panel="dashboard"]');
          if (activePanel) {
            window.__dashboardRefreshInProgress = true;
            try { 
              window.renderDashboardTab(); 
            } catch (e) {
              console.warn('[Dashboard] Error refreshing dashboard:', e);
            } finally {
              // Reset flag after a short delay
              setTimeout(() => {
                window.__dashboardRefreshInProgress = false;
              }, 2000);
            }
          }
        }
        
        return window.optimisationModuleState.allTasks;
      } catch (error) {
        console.error('[Optimisation Module] Error loading dashboard:', error);
        window.optimisationModuleState.allTasks = [];
        window.optimisationModuleState.filteredTasks = [];
        window.optimisationModuleState.dashboardTiles = null;
        window.optimisationModuleState.dashboardImpact = null;
        window.optimisationModuleState.dashboardTimeseries = null;
        window.optimisationModuleState.authError = error.message || 'Failed to load dashboard. Please try refreshing the page.';
        updateOptimisationSummaryCards();
        renderOptimisationTasksTable();

        // Dashboard: refresh (will reflect missing task data)
        if (typeof window.renderDashboardTab === 'function') {
          try { window.renderDashboardTab(); } catch (e) {}
        }
        return [];
      }
    };

    // Update summary cards (B6)
    // Count tasks with incomplete baselines (missing critical fields)
    function countTasksWithIncompleteBaselines(tasks) {
      const criticalFields = ['ai_overview', 'ai_citations', 'current_rank'];
      return tasks.filter(task => {
        // Only check active tasks (not done/cancelled/deleted)
        if (['done', 'cancelled', 'deleted'].includes(task.status)) return false;
        if (!task.baseline_metrics) return true; // No baseline = incomplete
        const missingFields = criticalFields.filter(field => {
          const val = task.baseline_metrics[field];
          // For current_rank, also treat 0 as missing (should be a positive number)
          if (field === 'current_rank') {
            return val == null || val === '' || val === 0 || val === '0';
          }
          // For boolean fields (ai_overview), false is valid, only null/undefined/empty is missing
          if (field === 'ai_overview') {
            return val == null || val === '';
          }
          // For other fields, null or empty string is missing
          return val == null || val === '';
        });
        return missingFields.length > 0;
      }).length;
    }

    function updateOptimisationSummaryCards() {
      let tasks = window.optimisationModuleState.allTasks;
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      const active = tasks.filter(t => ['planned', 'in_progress', 'monitoring'].includes(t.status));
      const planned = tasks.filter(t => t.status === 'planned');
      const inProgress = tasks.filter(t => t.status === 'in_progress');
      const monitoring = tasks.filter(t => t.status === 'monitoring');
      const done = tasks.filter(t => t.status === 'done');
      const paused = tasks.filter(t => t.status === 'paused');
      const cancelled = tasks.filter(t => t.status === 'cancelled');
      
      // Updated (28d): Count distinct tasks with latest measurement in last 28 days
      // Must use the same task set and scope as other status tiles
      const scope = window.optimisationModuleState.scope || 'active_cycle';
      const twentyEightDaysAgo = new Date();
      twentyEightDaysAgo.setDate(twentyEightDaysAgo.getDate() - 28);
      const updatedTaskIds = new Set();
      for (const task of tasks) {
        const latestMeasurement = getLatestMeasurementInScope(task, scope);
        if (latestMeasurement && latestMeasurement.captured_at) {
          const latestDate = new Date(latestMeasurement.captured_at);
          if (latestDate >= twentyEightDaysAgo) {
            updatedTaskIds.add(task.id);
          }
        }
      }
      const recent = Array.from(updatedTaskIds).length;

      document.getElementById('optimisation-summary-active').textContent = active.length;
      document.getElementById('optimisation-summary-planned').textContent = planned.length;
      document.getElementById('optimisation-summary-in-progress').textContent = inProgress.length;
      document.getElementById('optimisation-summary-monitoring').textContent = monitoring.length;
      document.getElementById('optimisation-summary-done').textContent = done.length;
      document.getElementById('optimisation-summary-paused').textContent = paused.length;
      document.getElementById('optimisation-summary-cancelled').textContent = cancelled.length;
      document.getElementById('optimisation-summary-recent').textContent = recent.length;
      
      // Count tasks with incomplete baselines
      const incompleteBaselineCount = countTasksWithIncompleteBaselines(tasks);
      const incompleteBaselineCountEl = document.getElementById('optimisation-incomplete-baseline-count');
      if (incompleteBaselineCountEl) {
        incompleteBaselineCountEl.textContent = incompleteBaselineCount;
      }

      // Update tab counts
      const pausedCancelled = paused.length + cancelled.length;
      
      document.querySelectorAll('.optimisation-tab-count[data-tab="active"]').forEach(el => {
        el.textContent = `(${active.length})`;
      });
      document.querySelectorAll('.optimisation-tab-count[data-tab="done"]').forEach(el => {
        el.textContent = `(${done.length})`;
      });
      document.querySelectorAll('.optimisation-tab-count[data-tab="paused-cancelled"]').forEach(el => {
        el.textContent = `(${pausedCancelled})`;
      });

      // Update goal rollups (Phase B) - only count active tasks (not cancelled/deleted)
      const activeTasks = tasks.filter(t => !['done', 'cancelled', 'deleted'].includes(t.status));
      // Use objective_status from cycle (Phase 5) or fallback to goal_state
      const goalNotSet = activeTasks.filter(t => {
        const status = t.objective_status || t.goal_state;
        return !status || status === 'not_set';
      }).length;
      const goalOnTrack = activeTasks.filter(t => {
        const status = t.objective_status || t.goal_state;
        return status === 'on_track';
      }).length;
      const goalOverdue = activeTasks.filter(t => {
        const status = t.objective_status || t.goal_state;
        return status === 'overdue';
      }).length;
      const goalMet = activeTasks.filter(t => {
        const status = t.objective_status || t.goal_state;
        return status === 'met';
      }).length;

      const notSetEl = document.getElementById('optimisation-goal-not-set');
      const onTrackEl = document.getElementById('optimisation-goal-on-track');
      const overdueEl = document.getElementById('optimisation-goal-overdue');
      const metEl = document.getElementById('optimisation-goal-met');
      
      if (notSetEl) notSetEl.textContent = goalNotSet;
      if (onTrackEl) onTrackEl.textContent = goalOnTrack;
      if (overdueEl) overdueEl.textContent = goalOverdue;
      if (metEl) metEl.textContent = goalMet;
    }

    // Update timeseries charts
    // OLD updateTimeseriesCharts function removed - see new implementation below

    // Sort optimisation tasks
    function sortOptimisationTasks(tasks) {
      const sorted = [...tasks];
      sorted.sort((a, b) => {
        let aVal, bVal;
        switch (optimisationSortState.column) {
          case 'keyword':
            aVal = (a.keyword_text || '').toLowerCase();
            bVal = (b.keyword_text || '').toLowerCase();
            break;
          case 'url':
            aVal = (a.target_url_clean || '').toLowerCase();
            bVal = (b.target_url_clean || '').toLowerCase();
            break;
          case 'type':
            aVal = (a.task_type || 'on_page').toLowerCase();
            bVal = (b.task_type || 'on_page').toLowerCase();
            break;
          case 'status':
            aVal = (a.status || 'planned').toLowerCase();
            bVal = (b.status || 'planned').toLowerCase();
            break;
          case 'cycle':
            aVal = a.cycle_active || 1;
            bVal = b.cycle_active || 1;
            break;
          case 'lastActivity':
            aVal = a.last_activity_at ? new Date(a.last_activity_at).getTime() : (a.updated_at ? new Date(a.updated_at).getTime() : 0);
            bVal = b.last_activity_at ? new Date(b.last_activity_at).getTime() : (b.updated_at ? new Date(b.updated_at).getTime() : 0);
            break;
          case 'baselineCaptured':
            aVal = ((a.baseline_metrics && a.baseline_metrics.captured_at) || (a.baseline_metrics && a.baseline_metrics.created_at)) ? new Date((a.baseline_metrics && a.baseline_metrics.captured_at) || (a.baseline_metrics && a.baseline_metrics.created_at)).getTime() : 0;
            bVal = ((b.baseline_metrics && b.baseline_metrics.captured_at) || (b.baseline_metrics && b.baseline_metrics.created_at)) ? new Date((b.baseline_metrics && b.baseline_metrics.captured_at) || (b.baseline_metrics && b.baseline_metrics.created_at)).getTime() : 0;
            break;
          case 'latestCaptured':
            aVal = (a.latest_metrics?.captured_at || a.latest_metrics?.created_at) ? new Date(a.latest_metrics.captured_at || a.latest_metrics.created_at).getTime() : 0;
            bVal = (b.latest_metrics?.captured_at || b.latest_metrics?.created_at) ? new Date(b.latest_metrics.captured_at || b.latest_metrics.created_at).getTime() : 0;
            break;
          case 'title':
            aVal = (a.title || '').toLowerCase();
            bVal = (b.title || '').toLowerCase();
            break;
          case 'objectiveKpi':
            // Sort by objective KPI key (e.g., 'ctr_28d', 'current_rank', 'ai_citations')
            const aKpi = a.objectiveKpiKey || (a.objective && a.objective.kpi) || a.objective_metric || a.objective_kpi || '';
            const bKpi = b.objectiveKpiKey || (b.objective && b.objective.kpi) || b.objective_metric || b.objective_kpi || '';
            aVal = String(aKpi).toLowerCase();
            bVal = String(bKpi).toLowerCase();
            break;
          case 'delta':
            // Sort by delta value (numeric)
            aVal = a.delta != null ? a.delta : (a.objective_progress && a.objective_progress.delta != null ? a.objective_progress.delta : null);
            bVal = b.delta != null ? b.delta : (b.objective_progress && b.objective_progress.delta != null ? b.objective_progress.delta : null);
            // Handle null values - put them at the end
            if (aVal == null && bVal == null) return 0;
            if (aVal == null) return 1;
            if (bVal == null) return -1;
            break;
          case 'baselineLatest':
            // Sort by latest value (or baseline if latest not available)
            aVal = a.latestValue != null ? a.latestValue : (a.baselineValue != null ? a.baselineValue : null);
            bVal = b.latestValue != null ? b.latestValue : (b.baselineValue != null ? b.baselineValue : null);
            // Handle null values - put them at the end
            if (aVal == null && bVal == null) return 0;
            if (aVal == null) return 1;
            if (bVal == null) return -1;
            break;
          case 'dueIn':
            // Sort by due date (earliest first)
            let aDueAt = a.dueAt || (a.objective && a.objective.due_at) || (a.cycle && a.cycle.due_at) || null;
            let bDueAt = b.dueAt || (b.objective && b.objective.due_at) || (b.cycle && b.cycle.due_at) || null;
            aVal = aDueAt ? new Date(aDueAt).getTime() : null;
            bVal = bDueAt ? new Date(bDueAt).getTime() : null;
            // Handle null values - put them at the end
            if (aVal == null && bVal == null) return 0;
            if (aVal == null) return 1;
            if (bVal == null) return -1;
            break;
          case 'goal':
            // Sort by goal status (on_track, at_risk, overdue, no_data)
            const goalStatusOrder = { 'on_track': 1, 'off_track': 2, 'at_risk': 3, 'overdue': 4, 'no_data': 5 };
            aVal = goalStatusOrder[a.objectiveRag] || 5;
            bVal = goalStatusOrder[b.objectiveRag] || 5;
            break;
          default:
            return 0;
        }
        
        if (aVal < bVal) return optimisationSortState.direction === 'asc' ? -1 : 1;
        if (aVal > bVal) return optimisationSortState.direction === 'asc' ? 1 : -1;
        return 0;
      });
      return sorted;
    }

    // Copy all task URLs to clipboard
    window.copyOptimisationTaskUrls = function copyOptimisationTaskUrls() {
      try {
        if (!window.optimisationModuleState || !window.optimisationModuleState.filteredTasks) {
          alert('No tasks available to copy.');
          return;
        }

        let tasks = window.optimisationModuleState.filteredTasks;

        // Apply tab filter (same as table)
        if (window.optimisationModuleState.activeTab === 'active') {
          tasks = tasks.filter(t => ['planned', 'in_progress', 'monitoring', 'paused'].includes(t.status));
        } else if (window.optimisationModuleState.activeTab === 'done') {
          tasks = tasks.filter(t => t.status === 'done');
        } else if (window.optimisationModuleState.activeTab === 'paused-cancelled') {
          tasks = tasks.filter(t => ['paused', 'cancelled'].includes(t.status));
        }

        // Extract unique URLs from tasks
        const urls = new Set();
        tasks.forEach(task => {
          const url = task.target_url_clean || task.target_url || '';
          if (url) {
            // Normalize URL to full URL format
            let fullUrl = '';
            try {
              if (url.includes('alanranger.com') || url.startsWith('http')) {
                const urlObj = new URL(url.startsWith('http') ? url : 'https://' + url);
                fullUrl = urlObj.href;
              } else if (url.startsWith('/')) {
                fullUrl = 'https://www.alanranger.com' + url;
              } else {
                fullUrl = 'https://www.alanranger.com/' + url;
              }
              urls.add(fullUrl);
            } catch (e) {
              // Fallback: treat as path
              const path = url.startsWith('/') ? url : '/' + url;
              urls.add('https://www.alanranger.com' + path);
            }
          }
        });

        if (urls.size === 0) {
          alert('No URLs found in tasks.');
          return;
        }

        // Convert to sorted array and join with newlines
        const urlList = Array.from(urls).sort().join('\n');

        // Copy to clipboard
        navigator.clipboard.writeText(urlList).then(() => {
          alert(`Copied ${urls.size} unique URL${urls.size !== 1 ? 's' : ''} to clipboard.`);
        }).catch(err => {
          console.error('Failed to copy to clipboard:', err);
          // Fallback: use textarea method
          const textarea = document.createElement('textarea');
          textarea.value = urlList;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand('copy');
            alert(`Copied ${urls.size} unique URL${urls.size !== 1 ? 's' : ''} to clipboard.`);
          } catch (fallbackErr) {
            console.error('Fallback copy failed:', fallbackErr);
            alert('Failed to copy URLs. Please try again or check browser permissions.');
          }
          document.body.removeChild(textarea);
        });
      } catch (err) {
        console.error('Error copying URLs:', err);
        alert('An error occurred while copying URLs: ' + err.message);
      }
    };

    // Render tasks table (B2)
    function renderOptimisationTasksTable() {
      const tbody = document.getElementById('optimisation-tasks-tbody');
      if (!tbody) return;

      let tasks = window.optimisationModuleState.filteredTasks;

      // Apply tab filter
      if (window.optimisationModuleState.activeTab === 'active') {
        // Show active tasks (planned, in_progress, monitoring) AND paused tasks (so they're visible)
        tasks = tasks.filter(t => ['planned', 'in_progress', 'monitoring', 'paused'].includes(t.status));
      } else if (window.optimisationModuleState.activeTab === 'done') {
        tasks = tasks.filter(t => t.status === 'done');
      } else if (window.optimisationModuleState.activeTab === 'paused-cancelled') {
        tasks = tasks.filter(t => ['paused', 'cancelled'].includes(t.status));
      }

      // Sort tasks
      tasks = sortOptimisationTasks(tasks);
      
      // Calculate pagination
      const totalRows = tasks.length;
      const rowsPerPage = optimisationPaginationState.rowsPerPage === 'all' ? totalRows : optimisationPaginationState.rowsPerPage;
      const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
      const currentPage = Math.min(Math.max(1, optimisationPaginationState.currentPage), totalPages);
      optimisationPaginationState.currentPage = currentPage;
      
      const startIdx = rowsPerPage === 'all' ? 0 : (currentPage - 1) * rowsPerPage;
      const endIdx = rowsPerPage === 'all' ? totalRows : Math.min(startIdx + rowsPerPage, totalRows);
      const paginatedTasks = tasks.slice(startIdx, endIdx);

      tbody.innerHTML = '';

        // Check for authentication error
      if (window.optimisationModuleState.authError) {
        const errorMessage = window.optimisationModuleState.authError;
        tbody.innerHTML = `<tr><td colspan="13" style="padding: 2rem; text-align: center;">
          <div style="color: #ef4444; margin-bottom: 0.5rem; font-weight: 600;"> Authentication Error</div>
          <div style="color: #666; margin-bottom: 1rem;">${escapeHtml(errorMessage)}</div>
          <a href="#configuration" onclick="if(typeof setActivePanel === 'function') setActivePanel('configuration');" style="color: #2563eb; text-decoration: underline;">Go to Configuration to set your admin key</a>
        </td></tr>`;
        updateOptimisationPaginationControls(0, 1, 1, 0, 0);
        return;
      }

      if (tasks.length === 0) {
        tbody.innerHTML = '<tr><td colspan="13" class="ranking-table-empty">No tasks found</td></tr>';
        updateOptimisationPaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx);
        return;
      }

      paginatedTasks.forEach((task, index) => {
        const tr = document.createElement('tr');
        tr.onclick = () => openOptimisationTaskDrawer(task.id);

        const statusColors = {
          planned: { bg: 'rgba(245, 158, 11, 0.3)', color: '#fbbf24' }, // Brighter amber
          in_progress: { bg: 'rgba(16, 185, 129, 0.3)', color: '#34d399' }, // Brighter green
          monitoring: { bg: 'rgba(59, 130, 246, 0.3)', color: '#60a5fa' }, // Brighter blue
          done: { bg: 'rgba(156, 163, 175, 0.3)', color: '#d1d5db' }, // Brighter grey
          paused: { bg: 'rgba(245, 158, 11, 0.3)', color: '#fbbf24' }, // Brighter amber
          cancelled: { bg: 'rgba(239, 68, 68, 0.3)', color: '#f87171' } // Brighter red
        };

        const statusStyle = statusColors[task.status] || statusColors.planned;
        const lastActivity = task.last_activity_at 
          ? new Date(task.last_activity_at).toLocaleDateString('en-GB')
          : new Date(task.updated_at).toLocaleDateString('en-GB');

        // Format baseline and latest captured dates
        // Use captured_at from metrics (set by view from event.created_at) or fallback to created_at
        const baselineCaptured = (task.baseline_metrics?.captured_at || task.baseline_metrics?.created_at)
          ? new Date(task.baseline_metrics.captured_at || task.baseline_metrics.created_at).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' })
          : '';
        const latestCapturedDate = (task.latest_metrics?.captured_at || task.latest_metrics?.created_at)
          ? new Date(task.latest_metrics.captured_at || task.latest_metrics.created_at)
          : null;
        const latestCaptured = latestCapturedDate 
          ? latestCapturedDate.toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' })
          : null;
        
        // "Needs update" indicator: blank or older than 30 days
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const needsUpdate = !latestCapturedDate || latestCapturedDate < thirtyDaysAgo;
        const needsUpdateBadge = needsUpdate 
          ? '<span style="padding: 0.125rem 0.375rem; background: #fee2e2; color: #991b1b; border-radius: 4px; font-size: 0.7rem; font-weight: 600; margin-left: 0.25rem;">Needs update</span>'
          : '';
        
        // "No measurement yet" indicator
        const measurementIndicator = !latestCaptured 
          ? '<span style="padding: 0.25rem 0.5rem; background: #fef3c7; color: #92400e; border-radius: 4px; font-size: 0.75rem;">No measurement yet</span>'
          : '';

        // Extract path from URL for display
        let urlPath = '';
        let fullUrl = '';
        const urlText = task.target_url_clean || task.target_url || '';
        if (urlText) {
          try {
            // If URL contains domain, extract just the path
            if (urlText.includes('alanranger.com')) {
              const urlObj = new URL(urlText.startsWith('http') ? urlText : 'https://' + urlText);
              urlPath = urlObj.pathname || '/';
              fullUrl = urlObj.href;
            } else if (urlText.startsWith('/')) {
              // Already a path
              urlPath = urlText;
              fullUrl = 'https://www.alanranger.com' + urlText;
            } else {
              // Assume it's a path without leading slash
              urlPath = '/' + urlText;
              fullUrl = 'https://www.alanranger.com/' + urlText;
            }
          } catch (e) {
            // Fallback: treat as path
            urlPath = urlText.startsWith('/') ? urlText : '/' + urlText;
            fullUrl = 'https://www.alanranger.com' + urlPath;
          }
        }

        // Build goal status display (Phase 5: use objective_status from cycle)
        // BUT validate with actual values to ensure consistency with drawer
        let goalHtml = '';
        // Use the same validation function as drawer to ensure consistency
        const objectiveStatus = validateObjectiveStatus(task, task.objective_progress);
        
        if (objectiveStatus && objectiveStatus !== 'not_set') {
          const goalConfig = {
            'on_track': { text: 'Met', bg: 'rgba(16, 185, 129, 0.3)', color: '#34d399' }, // Green for met/on track
            'off_track': { text: 'Off track', bg: 'rgba(239, 68, 68, 0.3)', color: '#f87171' }, // Red for off track
            'overdue': { text: 'Overdue', bg: 'rgba(239, 68, 68, 0.3)', color: '#f87171' }, // Brighter red
            'met': { text: 'Met', bg: 'rgba(16, 185, 129, 0.3)', color: '#34d399' }, // Brighter green
            'at_risk': { text: 'At risk', bg: 'rgba(245, 158, 11, 0.3)', color: '#fbbf24' }, // Brighter amber
            'no_measurement': { text: 'No measurement', bg: 'rgba(156, 163, 175, 0.3)', color: '#9ca3af' }, // Grey for no measurement
            'no_data': { text: 'No measurement', bg: 'rgba(156, 163, 175, 0.3)', color: '#9ca3af' } // Grey for no data
          };
          const config = goalConfig[objectiveStatus] || goalConfig['on_track'];
          let goalText = `<span style="padding: 0.25rem 0.5rem; border-radius: 4px; background: ${config.bg}; color: ${config.color}; font-size: 0.75rem; font-weight: 700; display: inline-block; margin-bottom: 0.25rem;">${config.text}</span>`;
          
          // Add progress info from objective_progress (Phase 8: use computeGoalProgress)
          if (task.objective_progress) {
            const progress = task.objective_progress;
            if (progress.baseline_value != null && progress.latest_value != null && progress.target != null) {
              const taskKpi = task.objective_kpi || task.primary_kpi || task.objective_metric || null;
              const targetType = (task.objective && task.objective.target_type) || 'delta';
              
              if (taskKpi) {
                // Use Phase 8 helper for proper formatting
                const goalProgress = computeGoalProgress({
                  kpiKey: taskKpi,
                  baseline: progress.baseline_value,
                  latest: progress.latest_value,
                  targetValue: progress.target,
                  targetType: targetType
                });
                
                const delta = progress.delta != null ? progress.delta : 0;
                let deltaColor = '#f59e0b'; // Amber for no change (default)
                if (delta > 0) deltaColor = '#10b981'; // Green for positive/improvement
                else if (delta < 0) deltaColor = '#ef4444'; // Red for negative/worsening
                goalText += `<div style="font-size: 0.7rem; color: ${deltaColor} !important; margin-top: 0.125rem; font-weight: 600;">${goalProgress.deltaLabel} vs target ${goalProgress.targetLabel}</div>`;
                if (goalProgress.remainingToTarget != null && goalProgress.remainingToTarget > 0) {
                  const displayMeta = KPI_DISPLAY_METADATA[taskKpi];
                  const remainingLabel = displayMeta ? displayMeta.formatDelta(goalProgress.remainingToTarget) : String(goalProgress.remainingToTarget);
                  goalText += `<div style="font-size: 0.65rem; color: #d1d5db; margin-top: 0.125rem; font-weight: 500;">Remaining: ${remainingLabel}</div>`;
                }
              }
            }
          } else if (task.objective && task.objective.kpi && task.objective.target != null) {
            // Use objective from cycle
            const kpiLabel = task.objective.kpi.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            // Format target value: for CTR KPIs, convert ratio to percentage
            let formattedTarget = task.objective.target;
            const isCtrKpi = task.objective.kpi === 'ctr_28d' || task.objective.kpi === 'ctr';
            if (isCtrKpi && task.objective.target_type === 'absolute' && formattedTarget < 1 && formattedTarget > 0) {
              // Convert ratio (0.025) to percentage (2.5%)
              formattedTarget = (formattedTarget * 100).toFixed(1) + '%';
            } else if (isCtrKpi && task.objective.target_type === 'delta') {
              // For delta targets, also format as percentage if it's a small value
              if (Math.abs(formattedTarget) < 1 && Math.abs(formattedTarget) > 0) {
                formattedTarget = (formattedTarget * 100).toFixed(1) + '%';
              }
            }
            const targetText = task.objective.target_type === 'delta' 
              ? `${kpiLabel} ${task.objective.target >= 0 ? '+' : ''}${formattedTarget}`
              : `${kpiLabel}  ${formattedTarget}`;
            let dueText = '';
            if (task.objective.due_at || task.objective_due_at) {
              const dueDate = new Date(task.objective.due_at || task.objective_due_at).toLocaleDateString('en-GB');
              dueText = ` by ${dueDate}`;
            }
            goalText += `<div style="font-size: 0.7rem; color: #d1d5db; margin-top: 0.25rem; font-weight: 500;">${targetText}${dueText}</div>`;
          } else if (task.objective_kpi && task.objective_target_delta != null) {
            // Legacy fallback
            const kpiLabel = task.objective_kpi.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            // Format target value: for CTR KPIs, convert ratio to percentage
            let formattedTarget = Math.abs(task.objective_target_delta);
            const isCtrKpi = task.objective_kpi === 'ctr_28d' || task.objective_kpi === 'ctr';
            if (isCtrKpi && formattedTarget < 1 && formattedTarget > 0) {
              // Convert ratio (0.025) to percentage (2.5%)
              formattedTarget = (formattedTarget * 100).toFixed(1) + '%';
            }
            const direction = task.objective_direction === 'decrease' ? '-' : '+';
            const targetText = `${kpiLabel} ${direction}${formattedTarget}`;
            let dueText = '';
            if (task.objective_due_at) {
              const dueDate = new Date(task.objective_due_at).toLocaleDateString('en-GB');
              dueText = ` by ${dueDate}`;
            }
            goalText += `<div style="font-size: 0.7rem; color: #d1d5db; margin-top: 0.25rem; font-weight: 500;">${targetText}${dueText}</div>`;
          }
          
          // Add delta if available (from progress or legacy) - use same formatting as deltaLabel
          if (task.objective_progress && task.objective_progress.delta != null) {
            const delta = task.objective_progress.delta;
            const deltaColor = delta >= 0 ? '#34d399' : '#f87171'; // Brighter colors
            
            // Use same formatting as deltaLabel (percentage points for CTR, etc.)
            const taskKpi = task.objective_kpi || task.primary_kpi || task.objective_metric || null;
            let deltaFormatted;
            if (taskKpi && KPI_DISPLAY_METADATA[taskKpi] && KPI_DISPLAY_METADATA[taskKpi].formatDelta) {
              // Use KPI-specific formatting (e.g., converts 0.0016 to "+0.16pp" for CTR)
              deltaFormatted = KPI_DISPLAY_METADATA[taskKpi].formatDelta(delta);
            } else {
              // Fallback: format to 4 decimal places
              const deltaSign = delta >= 0 ? '+' : '';
              deltaFormatted = `${deltaSign}${typeof delta === 'number' ? delta.toFixed(4) : String(delta)}`;
            }
            goalText += `<div style="font-size: 0.7rem; color: ${deltaColor}; margin-top: 0.125rem; font-weight: 700;"> ${deltaFormatted}</div>`;
          } else if (task.objective_delta != null) {
            // Legacy fallback
            const deltaColor = task.objective_delta >= 0 ? '#34d399' : '#f87171'; // Brighter colors
            
            // Use same formatting as deltaLabel
            const taskKpi = task.objective_kpi || task.primary_kpi || task.objective_metric || null;
            let deltaFormatted;
            if (taskKpi && KPI_DISPLAY_METADATA[taskKpi] && KPI_DISPLAY_METADATA[taskKpi].formatDelta) {
              // Use KPI-specific formatting
              deltaFormatted = KPI_DISPLAY_METADATA[taskKpi].formatDelta(task.objective_delta);
            } else {
              // Fallback: format to 4 decimal places
              const deltaSign = task.objective_delta >= 0 ? '+' : '';
              deltaFormatted = `${deltaSign}${typeof task.objective_delta === 'number' ? task.objective_delta.toFixed(4) : String(task.objective_delta)}`;
            }
            goalText += `<div style="font-size: 0.7rem; color: ${deltaColor}; margin-top: 0.125rem; font-weight: 700;"> ${deltaFormatted}</div>`;
          }
          
          goalHtml = goalText;
        }

        // Phase 9: Format new columns
        // Get objective KPI key from various possible locations
        let objectiveKpiKey = task.objectiveKpiKey || 
                              (task.objective && task.objective.kpi) || 
                              task.objective_metric || 
                              task.objective_kpi || 
                              null;
        
        // Map "Rank" to "current_rank" if needed
        if (objectiveKpiKey === 'Rank' || objectiveKpiKey === 'rank') {
          objectiveKpiKey = 'current_rank';
        }
        
        let objectiveKpiLabel = '';
        let baselineLatestHtml = '';
        let deltaHtml = '';
        let sparklineHtml = '';
        
        if (objectiveKpiKey && KPI_DISPLAY_METADATA[objectiveKpiKey]) {
          const kpiMeta = KPI_DISPLAY_METADATA[objectiveKpiKey];
          objectiveKpiLabel = kpiMeta.label || objectiveKpiKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          
          // Baseline  Latest
          const baselineValue = task.baselineValue != null ? task.baselineValue : (task.baseline_metrics ? kpiMeta.get ? kpiMeta.get(task.baseline_metrics) : null : null);
          const latestValue = task.latestValue != null ? task.latestValue : (task.latest_metrics ? kpiMeta.get ? kpiMeta.get(task.latest_metrics) : null : null);
          
          if (baselineValue != null && latestValue != null) {
            const baselineFormatted = kpiMeta.formatValue ? kpiMeta.formatValue(baselineValue) : String(baselineValue);
            const latestFormatted = kpiMeta.formatValue ? kpiMeta.formatValue(latestValue) : String(latestValue);
            baselineLatestHtml = `${baselineFormatted}  ${latestFormatted}`;
          } else if (baselineValue != null) {
            baselineLatestHtml = `${kpiMeta.formatValue ? kpiMeta.formatValue(baselineValue) : String(baselineValue)}  `;
          } else if (latestValue != null) {
            baselineLatestHtml = `  ${kpiMeta.formatValue ? kpiMeta.formatValue(latestValue) : String(latestValue)}`;
          }
          
          //  vs Baseline
          const delta = task.delta != null ? task.delta : (baselineValue != null && latestValue != null ? (objectiveKpiKey === 'current_rank' ? baselineValue - latestValue : latestValue - baselineValue) : null);
          if (delta != null) {
            const deltaFormatted = kpiMeta.formatDelta ? kpiMeta.formatDelta(delta) : (delta >= 0 ? `+${delta}` : String(delta));
            const deltaColor = delta >= 0 ? '#10b981' : '#ef4444';
            deltaHtml = `<span style="color: ${deltaColor}; font-weight: 600;">${deltaFormatted}</span>`;
          }
          
          // Sparkline - use delta direction for color, not first vs last point
          // CRITICAL: If baseline and latest are the same, show a flat line
          const sparklinePoints = task.sparklinePoints || [];
          if (sparklinePoints.length > 1) {
            // If baseline equals latest, create a flat line (all points at same value)
            if (baselineValue != null && latestValue != null && baselineValue === latestValue) {
              // Create flat line with all points at the same value
              const flatPoints = new Array(Math.min(sparklinePoints.length, 10)).fill(baselineValue);
              sparklineHtml = renderSparkline(flatPoints, 80, 24, 0); // delta = 0 for flat line
            } else {
              // Pass delta to determine color correctly
              const sparklineDelta = delta != null ? delta : null;
              sparklineHtml = renderSparkline(sparklinePoints, 80, 24, sparklineDelta);
            }
          }
        }
        
        // Due In - check multiple sources: task.dueIn, task.dueAt, or objective.due_at
        let dueIn = task.dueIn;
        if (!dueIn) {
          // Try task.dueAt first
          let dueAt = task.dueAt;
          // If not found, try objective.due_at
          if (!dueAt && task.objective && task.objective.due_at) {
            dueAt = task.objective.due_at;
          }
          // If still not found, try cycle.due_at
          if (!dueAt && task.cycle && task.cycle.due_at) {
            dueAt = task.cycle.due_at;
          }
          // Calculate from dueAt if we have it
          if (dueAt) {
            const dueDate = new Date(dueAt);
            const now = new Date();
            const daysUntilDue = Math.ceil((dueDate - now) / (1000 * 60 * 60 * 24));
            if (daysUntilDue < 0) {
              dueIn = `Overdue ${Math.abs(daysUntilDue)}d`;
            } else {
              dueIn = `${daysUntilDue}d`;
            }
          }
        }
        const dueInHtml = dueIn ? (dueIn.startsWith('Overdue') ? `<span style="color: #dc2626; font-weight: 600;">${dueIn}</span>` : dueIn) : '';

        tr.innerHTML = `
          <td style="text-align: left;"><strong>${escapeHtml(task.keyword_text || '')}</strong></td>
          <td style="max-width: 150px; word-wrap: break-word; word-break: break-all;">
            ${urlPath ? `<a href="${fullUrl}" target="_blank" rel="noopener noreferrer" style="color: #fbbf24; text-decoration: none;" onmouseover="this.style.textDecoration='underline'; this.style.color='#fcd34d';" onmouseout="this.style.textDecoration='none'; this.style.color='#fbbf24';">${escapeHtml(urlPath)}</a>` : ''}
          </td>
          <td><span style="padding: 0.25rem 0.5rem; background: #f0f0f0; border-radius: 4px;">${escapeHtml(task.task_type || 'on_page')}</span></td>
          <td><span style="padding: 0.25rem 0.5rem; border-radius: 4px; background: ${statusStyle.bg}; color: ${statusStyle.color}; font-weight: 600; font-size: 0.85rem;">${escapeHtml(task.status || 'planned')}</span></td>
          <td>Cycle ${task.cycle_no || task.cycle_active || 1}</td>
          <td>${baselineCaptured}</td>
          <td>${latestCaptured || measurementIndicator}${needsUpdateBadge}</td>
          <td>${escapeHtml(task.title || '')}</td>
          <td style="font-size: 0.85rem;">${objectiveKpiLabel}</td>
          <td style="font-size: 0.85rem;">${baselineLatestHtml}</td>
          <td style="font-size: 0.85rem;">${deltaHtml}</td>
          <td style="font-size: 0.85rem;">${dueInHtml}</td>
          <td style="font-size: 0.75rem; text-align: center;">${sparklineHtml}</td>
          <td style="font-size: 0.85rem;">${goalHtml}</td>
          <td style="display: flex; flex-direction: column; gap: 1rem; align-items: center; min-width: 60px;">
            <button class="btn btn-secondary" onclick="event.stopPropagation(); openOptimisationTaskDrawer('${task.id}');" style="padding: 0.04rem 0.1rem; font-size: 0.5rem; width: 100%; background: var(--dark-brand) !important; color: #000 !important; border: 1px solid var(--dark-brand) !important; font-weight: 600;">Open</button>
            <button class="btn btn-small" onclick="event.stopPropagation(); updateTaskLatest('${task.id}');" style="padding: 0.04rem 0.1rem; font-size: 0.5rem; width: 100%; background: rgba(59, 130, 246, 0.2) !important; color: #60a5fa !important; border: 1px solid #60a5fa !important; font-weight: 600;" title="Capture latest metrics for this task.">Update</button>
          </td>
        `;

        tbody.appendChild(tr);
      });
      
      // Update sort indicators
      document.querySelectorAll('#optimisation-tasks-table th.sortable').forEach(th => {
        th.classList.remove('sort-asc', 'sort-desc');
        if (th.dataset.sort === optimisationSortState.column) {
          th.classList.add(`sort-${optimisationSortState.direction}`);
        }
      });
      
      // Update pagination controls
      updateOptimisationPaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx);
      
      // Wire sorting handlers
      wireOptimisationSorting();
      
      // Wire pagination handlers
      wireOptimisationPagination();
      
      // Wire pagination on initial load if not already done
      setTimeout(() => {
        wireOptimisationPagination();
      }, 100);
    }
    
    // Update pagination controls
    function updateOptimisationPaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx) {
      const paginationControls = document.getElementById('optimisation-pagination-controls');
      const paginationInfo = document.getElementById('optimisation-pagination-info');
      const pageInfo = document.getElementById('optimisation-pagination-page-info');
      const firstBtn = document.getElementById('optimisation-pagination-first');
      const prevBtn = document.getElementById('optimisation-pagination-prev');
      const nextBtn = document.getElementById('optimisation-pagination-next');
      const lastBtn = document.getElementById('optimisation-pagination-last');
      const rowsPerPageSelect = document.getElementById('optimisation-rows-per-page');
      
      if (!paginationControls) return;
      
      if (totalRows === 0) {
        paginationControls.style.display = 'none';
        return;
      }
      
      paginationControls.style.display = 'flex';
      
      if (paginationInfo) {
        paginationInfo.textContent = `Showing ${startIdx + 1}-${endIdx} of ${totalRows}`;
      }
      
      if (pageInfo) {
        pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
      }
      
      if (firstBtn) {
        firstBtn.disabled = currentPage === 1;
      }
      
      if (prevBtn) {
        prevBtn.disabled = currentPage === 1;
      }
      
      if (nextBtn) {
        nextBtn.disabled = currentPage === totalPages;
      }
      
      if (lastBtn) {
        lastBtn.disabled = currentPage === totalPages;
      }
      
      if (rowsPerPageSelect) {
        rowsPerPageSelect.value = optimisationPaginationState.rowsPerPage === 'all' ? 'all' : String(optimisationPaginationState.rowsPerPage);
      }
    }
    
    // Wire pagination handlers
    function wireOptimisationPagination() {
      const firstBtn = document.getElementById('optimisation-pagination-first');
      const prevBtn = document.getElementById('optimisation-pagination-prev');
      const nextBtn = document.getElementById('optimisation-pagination-next');
      const lastBtn = document.getElementById('optimisation-pagination-last');
      const rowsPerPageSelect = document.getElementById('optimisation-rows-per-page');
      
      if (firstBtn) {
        const newFirstBtn = firstBtn.cloneNode(true);
        firstBtn.parentNode.replaceChild(newFirstBtn, firstBtn);
        newFirstBtn.addEventListener('click', () => {
          optimisationPaginationState.currentPage = 1;
          renderOptimisationTasksTable();
        });
      }
      
      if (prevBtn) {
        const newPrevBtn = prevBtn.cloneNode(true);
        prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
        newPrevBtn.addEventListener('click', () => {
          if (optimisationPaginationState.currentPage > 1) {
            optimisationPaginationState.currentPage--;
            renderOptimisationTasksTable();
          }
        });
      }
      
      if (nextBtn) {
        const newNextBtn = nextBtn.cloneNode(true);
        nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
        newNextBtn.addEventListener('click', () => {
          const totalRows = window.optimisationModuleState.filteredTasks.length;
          const rowsPerPage = optimisationPaginationState.rowsPerPage === 'all' ? totalRows : optimisationPaginationState.rowsPerPage;
          const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
          if (optimisationPaginationState.currentPage < totalPages) {
            optimisationPaginationState.currentPage++;
            renderOptimisationTasksTable();
          }
        });
      }
      
      if (lastBtn) {
        const newLastBtn = lastBtn.cloneNode(true);
        lastBtn.parentNode.replaceChild(newLastBtn, lastBtn);
        newLastBtn.addEventListener('click', () => {
          const totalRows = window.optimisationModuleState.filteredTasks.length;
          const rowsPerPage = optimisationPaginationState.rowsPerPage === 'all' ? totalRows : optimisationPaginationState.rowsPerPage;
          const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
          optimisationPaginationState.currentPage = totalPages;
          renderOptimisationTasksTable();
        });
      }
      
      if (rowsPerPageSelect) {
        const newSelect = rowsPerPageSelect.cloneNode(true);
        rowsPerPageSelect.parentNode.replaceChild(newSelect, rowsPerPageSelect);
        newSelect.addEventListener('change', () => {
          optimisationPaginationState.rowsPerPage = newSelect.value === 'all' ? 'all' : parseInt(newSelect.value, 10);
          optimisationPaginationState.currentPage = 1; // Reset to first page
          renderOptimisationTasksTable();
        });
      }
    }
    
    // Wire sorting handlers
    function wireOptimisationSorting() {
      const sortableHeaders = document.querySelectorAll('#optimisation-tasks-table th.sortable');
      sortableHeaders.forEach(th => {
        // Remove existing listeners by cloning
        const newTh = th.cloneNode(true);
        th.parentNode.replaceChild(newTh, th);
        
        newTh.addEventListener('click', function(e) {
          e.stopPropagation();
          const column = this.dataset.sort;
          if (!column) return;
          
          if (optimisationSortState.column === column) {
            optimisationSortState.direction = optimisationSortState.direction === 'asc' ? 'desc' : 'asc';
          } else {
            optimisationSortState.column = column;
            optimisationSortState.direction = 'asc';
          }
          
          renderOptimisationTasksTable();
        });
      });
    }

    // Helper to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Tab switching (B2)
    function switchOptimisationTab(tabName) {
      window.optimisationModuleState.activeTab = tabName;
      
      // Reset pagination when switching tabs
      optimisationPaginationState.currentPage = 1;
      
      // Update tab button states
      document.querySelectorAll('.optimisation-tab-btn').forEach(btn => {
        btn.classList.toggle('metric-pill--active', btn.dataset.tab === tabName);
      });

      renderOptimisationTasksTable();
    }

    // Dragging state
    let optimisationDrawerDragState = {
      isDragging: false,
      startX: 0,
      startY: 0,
      startLeft: 0,
      startTop: 0
    };
    
    let optimisationDrawerState = {
      isMinimized: false,
      isMaximized: false,
      originalWidth: '1200px',
      originalHeight: 'auto',
      originalTop: '50%',
      originalLeft: '50%'
    };

    // Shared function to validate objective status using actual values
    // Used by drawer, loadCycleData, and table to ensure consistency
    function validateObjectiveStatus(taskData, progressData) {
      const objective = taskData.objective || taskData.cycle?.objective || null;
      const targetType = objective?.target_type || (taskData.objective_target_delta != null ? 'delta' : 'absolute');
      const target = objective?.target != null ? objective.target : 
        (taskData.objective_target_delta != null ? taskData.objective_target_delta : 
        (taskData.objective_target_value != null ? taskData.objective_target_value : null));
      const objectiveKpi = objective?.kpi || taskData.objective_kpi || taskData.primary_kpi || taskData.objective_metric || null;
      
      // If no target or KPI, can't validate
      if (!target || !objectiveKpi) {
        return taskData.objective_status || taskData.goal_state || 'not_set';
      }
      
      // Get latest and baseline values
      // Use same extraction logic as API (KPI_EXTRACTORS)
      let latestValue = null;
      let baselineValue = null;
      
      // Debug logging using UI debug log
      if (typeof debugLog === 'function') {
        debugLog(`[validateObjectiveStatus] Extracting values: kpi="${objectiveKpi}", hasProgressData=${!!progressData}, hasObjectiveProgress=${!!taskData.objective_progress}, hasLatestMetrics=${!!taskData.latest_metrics}, hasBaselineMetrics=${!!taskData.baseline_metrics}`, 'info');
        if (taskData.latest_metrics) {
          debugLog(`[validateObjectiveStatus] latest_metrics keys: ${Object.keys(taskData.latest_metrics).join(', ')}`, 'info');
        }
        if (taskData.baseline_metrics) {
          debugLog(`[validateObjectiveStatus] baseline_metrics keys: ${Object.keys(taskData.baseline_metrics).join(', ')}`, 'info');
        }
      }
      
      if (progressData && progressData.latest_value != null && progressData.baseline_value != null) {
        latestValue = progressData.latest_value;
        baselineValue = progressData.baseline_value;
        if (typeof debugLog === 'function') {
          debugLog(`[validateObjectiveStatus] Using progressData: latestValue=${latestValue}, baselineValue=${baselineValue}`, 'info');
        }
      } else if (taskData.objective_progress) {
        latestValue = taskData.objective_progress.latest_value ?? null;
        baselineValue = taskData.objective_progress.baseline_value ?? null;
        if (typeof debugLog === 'function') {
          debugLog(`[validateObjectiveStatus] Using objective_progress: latestValue=${latestValue}, baselineValue=${baselineValue}`, 'info');
        }
      } else if (taskData.latest_metrics && taskData.baseline_metrics) {
        // Use same extraction logic as API KPI_EXTRACTORS
        const extractValue = (metrics, kpi) => {
          if (!metrics) return null;
          // Handle different KPI field names (same as API KPI_EXTRACTORS)
          let value = null;
          switch (kpi) {
            case 'clicks_28d':
              value = metrics.gsc_clicks_28d ?? metrics.clicks_28d ?? null;
              break;
            case 'impressions_28d':
              value = metrics.gsc_impressions_28d ?? metrics.impressions_28d ?? null;
              break;
            case 'ctr_28d':
              value = metrics.gsc_ctr_28d ?? metrics.ctr_28d ?? null;
              break;
            case 'current_rank':
            case 'rank':
              // Try all possible field names for rank
              value = metrics.gsc_position_28d ?? metrics.current_rank ?? metrics.rank ?? metrics.gsc_current_rank ?? null;
              break;
            case 'opportunity_score':
              value = metrics.opportunity_score ?? null;
              break;
            case 'ai_overview':
              value = metrics.ai_overview ?? null;
              break;
            case 'ai_citations':
              value = metrics.ai_citations ?? null; // No gsc_ prefix for AI citations
              break;
            default:
              // Fallback: try gsc_ prefix first, then direct key
              value = metrics[`gsc_${kpi}`] ?? metrics[kpi] ?? null;
          }
          if (typeof debugLog === 'function') {
            debugLog(`[validateObjectiveStatus] Extracted ${kpi} from metrics: value=${value}, tried keys: ${kpi === 'current_rank' || kpi === 'rank' ? 'gsc_position_28d, current_rank, rank, gsc_current_rank' : `gsc_${kpi}, ${kpi}`}`, 'info');
          }
          return value;
        };
        latestValue = extractValue(taskData.latest_metrics, objectiveKpi);
        baselineValue = extractValue(taskData.baseline_metrics, objectiveKpi);
        if (typeof debugLog === 'function') {
          debugLog(`[validateObjectiveStatus] Final extracted values: latestValue=${latestValue}, baselineValue=${baselineValue}, kpi="${objectiveKpi}"`, 'info');
        }
      }
      
      // Fallback: if latest is null but baseline exists, use baseline as latest
      // This handles cases where baseline was captured but latest measurement is missing the KPI
      if (latestValue == null && baselineValue != null) {
        if (typeof debugLog === 'function') {
          debugLog(`[validateObjectiveStatus] latestValue is null but baselineValue exists (${baselineValue}). Using baseline as latest for validation.`, 'warn');
        }
        latestValue = baselineValue;
        // For delta targets, we still need both values, so keep baselineValue as is
        // For absolute targets, we can validate with baseline as latest
      }
      
      // Final check: if still null, log what we have
      if (latestValue == null && typeof debugLog === 'function') {
        debugLog(`[validateObjectiveStatus] WARNING: latestValue is null after all extraction attempts. kpi="${objectiveKpi}", latest_metrics=${JSON.stringify(taskData.latest_metrics)}, baseline_metrics=${JSON.stringify(taskData.baseline_metrics)}`, 'warn');
      }
      
      // Validate status based on values
      if (latestValue == null) {
        return 'no_measurement';
      } else if (targetType === 'absolute') {
        let direction = 'higher_better';
        if (objective?.kpi === 'current_rank' || objective?.kpi === 'rank') {
          direction = 'lower_better';
        }
        const meetsTarget = direction === 'higher_better' 
          ? latestValue >= target 
          : latestValue <= target;
        return meetsTarget ? 'met' : 'off_track';
      } else if (targetType === 'delta') {
        if (baselineValue == null) {
          return 'no_measurement';
        } else {
          const delta = latestValue - baselineValue;
          const direction = taskData.objective_direction || 'increase';
          const meetsTarget = direction === 'decrease' 
            ? delta <= (target * -1)
            : delta >= target;
          return meetsTarget ? 'met' : 'off_track';
        }
      }
      
      return taskData.objective_status || taskData.goal_state || 'not_set';
    }

    // Helper to disable write buttons in share mode
    function disableWriteButtonsInShareMode() {
      if (!window.isShareMode) return;
      
      const writeButtonIds = [
        'optimisation-cancel-task-btn',
        'optimisation-delete-task-btn',
        'optimisation-edit-objective-btn',
        'optimisation-add-measurement-btn',
        'optimisation-start-cycle-btn',
        'optimisation-complete-cycle-btn',
        'optimisation-archive-cycle-btn',
        'optimisation-add-event-btn',
        'optimisation-save-status-btn',
        'optimisation-save-objective-btn',
        'optimisation-update-latest-btn'
      ];
      
      writeButtonIds.forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
          btn.disabled = true;
          btn.style.opacity = '0.5';
          btn.style.cursor = 'not-allowed';
          btn.title = (btn.title || '') + ' (Not available in share mode)';
        }
      });
      
      // Disable inputs
      const titleInput = document.getElementById('optimisation-drawer-title');
      if (titleInput) {
        titleInput.disabled = true;
        titleInput.style.opacity = '0.5';
      }
      
      const statusSelect = document.getElementById('optimisation-change-status');
      if (statusSelect) {
        statusSelect.disabled = true;
        statusSelect.style.opacity = '0.5';
      }
      
      // Hide edit objective form
      const editForm = document.getElementById('optimisation-edit-objective-form');
      if (editForm) editForm.style.display = 'none';
    }

    // Open task drawer (B3, B4)
    window.openOptimisationTaskDrawer = async function openOptimisationTaskDrawer(taskId) {
      // DEBUG: Log what we received
      console.log('[Optimisation Drawer] openOptimisationTaskDrawer called with:', {
        taskId: taskId,
        taskIdType: typeof taskId,
        taskIdLength: taskId ? String(taskId).length : 0,
        taskIdValue: String(taskId),
        isUndefined: taskId === undefined,
        isNull: taskId === null,
        isEmptyString: taskId === '',
        isFalsy: !taskId
      });
      
      // Validate taskId
      if (!taskId) {
        console.error('[Optimisation Drawer] Task ID is missing or invalid:', {
          taskId: taskId,
          type: typeof taskId,
          value: String(taskId),
          stack: new Error().stack
        });
        alert('Task ID not found. Please try refreshing the page or creating the task again.');
        return;
      }
      
      // CRITICAL: Switch to Optimisation tab first, otherwise drawer will be hidden
      if (typeof setActivePanel === 'function') {
        setActivePanel('optimisation');
        ensurePanelRendered('optimisation');
        // Wait a moment for panel to become visible
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      const drawer = document.getElementById('optimisation-task-drawer');
      const backdrop = document.getElementById('optimisation-task-drawer-backdrop');
      
      if (!drawer) {
        console.error('[Optimisation Drawer] Drawer element not found');
        alert('Drawer element not found. Please refresh the page.');
        return;
      }
      
      if (!backdrop) {
        console.error('[Optimisation Drawer] Backdrop element not found');
        alert('Backdrop element not found. Please refresh the page.');
        return;
      }

      if (!window.optimisationModuleState) {
        window.optimisationModuleState = { allTasks: [], filteredTasks: [], activeTab: 'active', currentTaskId: null };
      }

      window.optimisationModuleState.currentTaskId = taskId;
      
      // Always reload tasks to ensure we have latest goal_state from the view
      // This ensures the badge uses the correct state even if migrations haven't been run
      if (typeof window.loadAllOptimisationTasks === 'function') {
        await window.loadAllOptimisationTasks();
      }
      
      // Find task (after reload to ensure fresh data)
      let task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      
      // If task still not found, error
      if (!task) {
        console.error('[Optimisation Drawer] Task not found after reload:', taskId);
        alert(`Task not found (ID: ${taskId}). Please try refreshing the page.`);
        return;
      }

      // Phase 6: Fetch full task details including cycles
      try {
        const headers = window.getOptimisationHeaders();
        // Add cache-busting to ensure fresh task data
        const cacheBuster = `_t=${Date.now()}`;
        const taskResponse = await fetch(apiUrl(`/api/optimisation/task/${taskId}?${cacheBuster}`), {
          method: 'GET',
          headers: {
            ...headers,
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache'
          }
        });
        if (taskResponse.ok) {
          const taskData = await taskResponse.json();
          console.log('[Optimisation Drawer] Task data from API:', taskData);
          // Merge cycles and other detailed fields into task
          task = {
            ...task,
            ...taskData.task,
            cycles: taskData.cycles || [],
            events: taskData.events || []
          };
          console.log('[Optimisation Drawer] Merged task with cycles:', task.cycles);
        }
      } catch (error) {
        console.error('[Optimisation Drawer] Error fetching task details:', error);
        // Continue with task from state if fetch fails
      }

      // Populate header
      document.getElementById('optimisation-drawer-keyword').textContent = task.keyword_text || '';
      const titleInput = document.getElementById('optimisation-drawer-title');
      if (titleInput) {
        titleInput.value = task.title || '';
      }
      
      // Make Target URL clickable
      const urlEl = document.getElementById('optimisation-drawer-url');
      const targetUrl = task.target_url_clean || task.target_url || '';
      let fullUrl = '';
      if (targetUrl) {
        try {
          if (targetUrl.includes('alanranger.com')) {
            fullUrl = targetUrl.startsWith('http') ? targetUrl : 'https://' + targetUrl;
          } else if (targetUrl.startsWith('/')) {
            fullUrl = 'https://www.alanranger.com' + targetUrl;
          } else {
            fullUrl = 'https://www.alanranger.com/' + targetUrl;
          }
        } catch (e) {
          fullUrl = 'https://www.alanranger.com/' + (targetUrl.startsWith('/') ? targetUrl : '/' + targetUrl);
        }
      }
      if (fullUrl) {
        urlEl.innerHTML = `<a href="${fullUrl}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${escapeHtml(targetUrl)}</a>`;
      } else {
        urlEl.textContent = targetUrl;
      }
      
      document.getElementById('optimisation-drawer-type').textContent = task.task_type || 'on_page';
      
      const statusColors = {
        planned: { bg: '#4b5563', color: '#ffffff' },
        in_progress: { bg: '#059669', color: '#ffffff' },
        monitoring: { bg: '#2563eb', color: '#ffffff' },
        done: { bg: '#6b7280', color: '#ffffff' },
        paused: { bg: '#d97706', color: '#ffffff' },
        cancelled: { bg: '#dc2626', color: '#ffffff' }
      };
      const statusStyle = statusColors[task.status] || statusColors.planned;
      const statusEl = document.getElementById('optimisation-drawer-status');
      statusEl.textContent = task.status || 'planned';
      statusEl.style.background = statusStyle.bg;
      statusEl.style.color = statusStyle.color;
      
      // Update cycle display with cycle info
      const cycleEl = document.getElementById('optimisation-drawer-cycle');
      const cycleSelector = document.getElementById('optimisation-drawer-cycle-selector');
      const cycleNo = task.cycle_no || task.cycle_active || 1;
      const cycleText = `Cycle ${cycleNo}`;
      if (task.cycle_start_date) {
        const startDate = new Date(task.cycle_start_date).toLocaleDateString('en-GB');
        cycleEl.textContent = `${cycleText} (Started: ${startDate})`;
      } else if (task.created_at) {
        const createdDate = new Date(task.created_at).toLocaleDateString('en-GB');
        cycleEl.textContent = `${cycleText} (Created: ${createdDate})`;
      } else {
        cycleEl.textContent = cycleText;
      }

      // Phase 6: Populate cycle selector dropdown
      // Debug: Log cycles data
      console.log('[Optimisation Drawer] Cycles data:', task.cycles, 'Length:', task.cycles?.length, 'Active cycle ID:', task.active_cycle_id);
      
      if (cycleSelector) {
        if (task.cycles && Array.isArray(task.cycles) && task.cycles.length > 0) {
          cycleSelector.innerHTML = '';
          // Sort cycles by cycle_no descending (newest first)
          const sortedCycles = [...task.cycles].sort((a, b) => (b.cycle_no || 0) - (a.cycle_no || 0));
          sortedCycles.forEach(c => {
            const option = document.createElement('option');
            option.value = c.id;
            option.textContent = `Cycle ${c.cycle_no}`;
            if (c.id === task.active_cycle_id) {
              option.selected = true;
            }
            cycleSelector.appendChild(option);
          });
          // Show selector if there are multiple cycles
          if (task.cycles.length > 1) {
            cycleSelector.style.display = 'inline-block';
            console.log('[Optimisation Drawer] Cycle selector shown with', task.cycles.length, 'cycles');
          } else {
            cycleSelector.style.display = 'none';
            console.log('[Optimisation Drawer] Cycle selector hidden (only 1 cycle)');
          }
          
          // Store cycles in state for later use
          if (!window.optimisationModuleState) {
            window.optimisationModuleState = {};
          }
          window.optimisationModuleState.taskCycles = task.cycles;
          window.optimisationModuleState.selectedCycleId = task.active_cycle_id;
          
          // Handle cycle selection change (remove old listener first to avoid duplicates)
          const oldHandler = cycleSelector.dataset.handler;
          if (oldHandler) {
            cycleSelector.removeEventListener('change', window[oldHandler]);
          }
          const handlerName = `cycleSelectorHandler_${taskId}`;
          const handler = async (e) => {
            const selectedCycleId = e.target.value;
            window.optimisationModuleState.selectedCycleId = selectedCycleId;
            const selectedCycle = task.cycles.find(c => c.id === selectedCycleId);
            const selectedCycleNo = selectedCycle?.cycle_no || 1;
            await loadCycleData(taskId, selectedCycleId, task.cycles, selectedCycle, selectedCycleNo, task);
          };
          window[handlerName] = handler;
          cycleSelector.dataset.handler = handlerName;
          cycleSelector.addEventListener('change', handler);
        } else {
          cycleSelector.style.display = 'none';
          console.log('[Optimisation Drawer] Cycle selector hidden (no cycles data)');
        }
      } else {
        console.error('[Optimisation Drawer] Cycle selector element not found!');
      }

      // Load progress data
      let progress = null;
      try {
        const headers = window.getOptimisationHeaders();
        const progressResponse = await fetch(apiUrl(`/api/optimisation/task/${taskId}/progress`), {
          method: 'GET',
          headers: headers
        });
        if (progressResponse.ok) {
          const progressData = await progressResponse.json();
          progress = progressData.progress || null;
        }
      } catch (error) {
        console.error('[Optimisation Drawer] Error loading progress:', error);
      }

      // Update objective display
      const objectiveCycleEl = document.getElementById('optimisation-drawer-objective-cycle');
      if (objectiveCycleEl) {
        objectiveCycleEl.textContent = `(Cycle ${cycleNo})`;
      }

      // Update progress badge - Use objective_status from cycle (Phase 5) or fallback to goal_state
      const objectiveBadgeEl = document.getElementById('optimisation-drawer-objective-badge');
      if (objectiveBadgeEl) {
        // Validate status using actual values - don't trust database state
        let state = validateObjectiveStatus(task, progress);
        
        // Debug logging to understand what's happening
        if (typeof debugLog === 'function') {
          debugLog(`[Optimisation Badge] Task ${task.id}: goal_state="${task.goal_state}", objective_delta=${task.objective_delta}, target=${task.objective_target_delta || task.objective_target_value}, direction=${task.objective_direction}, progress.objective_state="${progress?.objective_state}"`, 'info');
        }
        
        // If goal_state is not available, determine from objective fields
        if (!state && (task.objective_metric || task.objective_kpi)) {
          // Check if baseline_metrics exists (from view) or if we have any measurement
          const hasBaseline = task.baseline_metrics || (progress && progress.baseline_value != null);
          state = hasBaseline ? 'on_track' : 'no_measurement';
          if (typeof debugLog === 'function') {
            debugLog(`[Optimisation Badge] goal_state was null, determined state="${state}" from objective fields`, 'warn');
          }
        } else if (!state) {
          state = 'not_set';
        }
        
        // NEVER use progress.objective_state - it's from a different (buggy) view
        // If we're seeing 'achieved' here, it means task.goal_state is wrong or missing
        if (typeof debugLog === 'function' && progress?.objective_state && progress.objective_state !== state) {
          debugLog(`[Optimisation Badge] WARNING: progress.objective_state="${progress.objective_state}" differs from goal_state="${state}". Using goal_state.`, 'warn');
        }
        
        // State is already validated by validateObjectiveStatus function above
        if (typeof debugLog === 'function') {
          debugLog(`[Optimisation Badge] Validated state: "${state}"`, 'info');
        }
        
        const badgeConfig = {
          'achieved': { text: 'Achieved', bg: '#10b981', color: '#ffffff' },
          'met': { text: 'Met', bg: '#10b981', color: '#ffffff' },
          'on_track': { text: 'Met', bg: '#10b981', color: '#ffffff' }, // on_track means met
          'off_track': { text: 'Off track', bg: '#ef4444', color: '#ffffff' }, // off_track means not met
          'at_risk': { text: 'At risk', bg: '#f59e0b', color: '#ffffff' },
          'overdue': { text: 'Overdue', bg: '#ef4444', color: '#ffffff' },
          'not_set': { text: 'Not set', bg: '#9ca3af', color: '#ffffff' },
          'no_measurement': { text: 'No measurement', bg: '#9ca3af', color: '#ffffff' },
          'no_data': { text: 'No measurement', bg: '#9ca3af', color: '#ffffff' } // API returns 'no_data' when values missing
        };
        const config = badgeConfig[state] || badgeConfig['not_set'];
        
        if (typeof debugLog === 'function') {
          debugLog(`[Optimisation Badge] Setting badge: state="${state}", text="${config.text}"`, 'info');
        }
        
        objectiveBadgeEl.textContent = config.text;
        objectiveBadgeEl.style.background = config.bg;
        objectiveBadgeEl.style.color = config.color;
        objectiveBadgeEl.style.display = 'inline-block';
      }

      const objectiveContentEl = document.getElementById('optimisation-drawer-objective-content');
      if (objectiveContentEl) {
        // Phase 5: Use objective from cycle (jsonb) or fallback to legacy task fields
        const objective = task.objective || task.cycle?.objective || null;
        const objectiveProgress = task.objective_progress || task.cycle?.objective_progress || null;
        const objectiveStatus = task.objective_status || task.cycle?.objective_status || task.goal_state || 'not_set';
        const objectiveDueAt = task.objective_due_at || task.cycle?.due_at || null;

        // Legacy fallback fields - read from cycle fields (via view) or task fields
        const objectiveTitle = objective?.title || task.objective_title || null;
        const objectiveKpi = objective?.kpi || task.primary_kpi || task.objective_kpi || task.objective_metric || null;
        const objectiveMetric = objective?.kpi || task.primary_kpi || task.objective_metric || task.objective_kpi || null;
        // target_direction comes from cycle, objective_direction is legacy task field
        const objectiveDirection = objective?.target_type === 'delta' ? 'increase' : (task.target_direction || task.objective_direction || null);
        const objectiveTargetValue = objective?.target != null ? objective.target : (task.target_value != null ? task.target_value : (task.objective_target_delta != null ? task.objective_target_delta : (task.objective_target_value != null ? task.objective_target_value : null)));
        const objectiveTimeframe = objective?.due_at ? null : (task.timeframe_days != null ? task.timeframe_days : (task.objective_timeframe_days != null ? task.objective_timeframe_days : null));
        const objectivePlan = objective?.plan || task.plan || task.objective_plan || null;
        const cycleStartedAt = task.cycle_started_at || task.cycle_start_date || null;

        if (objective || objectiveTitle || objectiveKpi || objectiveMetric || objectiveDirection) {
          // Use two-column layout for objective details
          let leftColumn = '';
          let rightColumn = '';
          
          if (objectiveTitle) {
            leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Title:</strong> ${escapeHtml(objectiveTitle)}</div>`;
          }
            if (objectiveKpi) {
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>KPI:</strong> ${escapeHtml(objectiveKpi)}</div>`;
            }
            // Show target if we have a target value (direction is optional)
            if (objectiveTargetValue != null) {
              const directionLabels = {
                'increase': 'Increase by',
                'decrease': 'Decrease by',
                'at_least': 'At least',
                'at_most': 'At most'
              };
              let targetText = '';
              // For CTR, convert from ratio (0-1) to percentage for display
              if (objectiveMetric === 'ctr_28d' || (objectiveKpi && objectiveKpi.includes('ctr'))) {
                // If target is stored as ratio (0-1), multiply by 100 for display
                // Check if value is likely a ratio (< 1) vs percentage (>= 1)
                let displayTargetValue = objectiveTargetValue;
                if (objectiveTargetValue != null && objectiveTargetValue < 1 && objectiveTargetValue > 0) {
                  displayTargetValue = objectiveTargetValue * 100;
                }
                if (objectiveDirection) {
                  targetText = `${directionLabels[objectiveDirection] || objectiveDirection} ${displayTargetValue.toFixed(1)}%`;
                } else {
                  targetText = `${displayTargetValue.toFixed(1)}%`;
                }
              } else {
              if (objectiveDirection) {
                targetText = `${directionLabels[objectiveDirection] || objectiveDirection} ${objectiveTargetValue}`;
              } else {
                // If no direction specified, just show the target value
                targetText = `${objectiveTargetValue}`;
              }
              }
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Target:</strong> ${escapeHtml(targetText)}</div>`;
            } else if (objectiveDirection) {
              // Show direction even if no target value
              const directionLabels = {
                'increase': 'Increase',
                'decrease': 'Decrease',
                'at_least': 'At least',
                'at_most': 'At most'
              };
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Direction:</strong> ${escapeHtml(directionLabels[objectiveDirection] || objectiveDirection)}</div>`;
            }
          
          if (objectiveTimeframe || task.objective_due_at) {
            let timeframeText = '';
            const dueAt = task.objective_due_at || (progress && progress.due_at) || null;
            if (dueAt) {
              const dueDate = new Date(dueAt).toLocaleDateString('en-GB');
              timeframeText = `Due: ${dueDate}`;
              if (progress && progress.days_remaining != null) {
                const daysRemaining = Math.round(progress.days_remaining);
                timeframeText += ` (${daysRemaining} days remaining)`;
              }
            } else if (objectiveTimeframe) {
              timeframeText = `${objectiveTimeframe} days`;
              if (cycleStartedAt) {
                const startDate = new Date(cycleStartedAt);
                const dueDate = new Date(startDate.getTime() + objectiveTimeframe * 24 * 60 * 60 * 1000);
                timeframeText += ` (Due: ${dueDate.toLocaleDateString('en-GB')})`;
              }
            }
            if (timeframeText) {
              rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>Timeframe:</strong> ${timeframeText}</div>`;
            }
          }
          
          // Show progress: baseline  latest () vs target (using single source of truth helper)
          if (objectiveProgress && objectiveProgress.baseline_value != null && objectiveProgress.latest_value != null) {
            const baselineVal = objectiveProgress.baseline_value;
            const latestVal = objectiveProgress.latest_value;
            const target = objectiveProgress.target != null ? objectiveProgress.target : objectiveTargetValue;
            const targetType = (objective && objective.target_type) || 'delta';
            const kpiKey = objectiveKpi || objectiveMetric;
            
            if (kpiKey) {
              // Use single source of truth helper for correct delta math
              const progressLine = computeObjectiveProgressLine({
                kpiKey: kpiKey,
                baselineValue: baselineVal,
                latestValue: latestVal,
                targetValue: target,
                direction: targetType
              });
              
              rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>${progressLine.text}</strong></div>`;
              
              // Show remaining to target if applicable
              if (target != null && targetType === 'delta' && progressLine.delta != null) {
                const remaining = Math.max(0, target - progressLine.delta);
                if (remaining > 0) {
                  const displayMeta = KPI_DISPLAY_METADATA[kpiKey];
                  const remainingLabel = displayMeta ? displayMeta.formatDelta(remaining) : String(remaining);
                  rightColumn += `<div style="font-size: 0.85rem; color: #666; margin-top: 0.25rem;">Remaining: ${remainingLabel}</div>`;
                }
              }
            }
          } else if (progress && progress.baseline_value != null && progress.latest_value != null && objectiveMetric) {
            // Legacy fallback - use helper function for consistency
            const baselineVal = progress.baseline_value;
            const latestVal = progress.latest_value;
            const targetDelta = task.objective_target_delta != null ? task.objective_target_delta : (task.objective_target_value != null ? task.objective_target_value : null);
            const targetType = task.objective_target_type || 'delta';
            
            if (objectiveMetric) {
              const progressLine = computeObjectiveProgressLine({
                kpiKey: objectiveMetric,
                baselineValue: baselineVal,
                latestValue: latestVal,
                targetValue: targetDelta,
                direction: targetType
              });
              
              rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>${progressLine.text}</strong></div>`;
            }
          }
          
          // Build two-column layout
          let objectiveHtml = `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
            <div>${leftColumn || '<div style="color: #999; font-style: italic;"></div>'}</div>
            <div>${rightColumn || '<div style="color: #999; font-style: italic;"></div>'}</div>
          </div>`;
          
          if (objectivePlan) {
            objectiveHtml += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #e2e8f0;"><strong>Plan:</strong> ${escapeHtml(objectivePlan)}</div>`;
          }
          objectiveContentEl.innerHTML = objectiveHtml || '<div style="color: #666; font-style: italic;">No objective set</div>';
        } else {
          objectiveContentEl.innerHTML = '<div style="color: #666; font-style: italic;">No objective set</div>';
        }
      }
      
      document.getElementById('optimisation-change-status').value = task.status || '';

      // Phase 6: Load data for selected cycle (defaults to active cycle)
      const selectedCycleId = window.optimisationModuleState?.selectedCycleId || task.active_cycle_id;
      const selectedCycle = (task.cycles && task.cycles.find(c => c.id === selectedCycleId)) || null;
      const selectedCycleNo = selectedCycle?.cycle_no || task.cycle_no || task.cycle_active || 1;
      
      await loadCycleData(taskId, selectedCycleId, task.cycles, selectedCycle, selectedCycleNo, task);

      // Reset timeline to collapsed state
      const timelineContainer = document.getElementById('optimisation-drawer-events-container');
      const timelineToggle = document.getElementById('optimisation-timeline-toggle');
      if (timelineContainer && timelineToggle) {
        timelineContainer.style.display = 'none';
        timelineToggle.textContent = '';
      }

      // Reset state
      optimisationDrawerState.isMinimized = false;
      optimisationDrawerState.isMaximized = false;
      
      // Show backdrop and drawer (centered)
      backdrop.style.display = 'block';
      drawer.style.display = 'flex';
      drawer.style.top = '50%';
      drawer.style.left = '50%';
      drawer.style.transform = 'translate(-50%, -50%)';
      drawer.style.width = optimisationDrawerState.originalWidth;
      drawer.style.height = optimisationDrawerState.originalHeight;
      
      // Disable write buttons in share mode
      disableWriteButtonsInShareMode();
      drawer.style.maxHeight = '90vh';
      
      // Ensure content is visible
      const content = document.getElementById('optimisation-drawer-content');
      if (content) {
        content.style.display = 'block';
      }
      
      // Update button states
      document.getElementById('optimisation-drawer-minimize').textContent = '';
      document.getElementById('optimisation-drawer-maximize').textContent = '';
      
      // Phase 7: Show/hide Complete/Archive buttons based on active cycle
      const completeCycleBtn = document.getElementById('optimisation-complete-cycle-btn');
      const archiveCycleBtn = document.getElementById('optimisation-archive-cycle-btn');
      const hasActiveCycle = task.active_cycle_id != null;
      
      if (completeCycleBtn) {
        completeCycleBtn.style.display = hasActiveCycle ? 'block' : 'none';
        completeCycleBtn.disabled = !hasActiveCycle || window.isShareMode;
      }
      if (archiveCycleBtn) {
        archiveCycleBtn.style.display = hasActiveCycle ? 'block' : 'none';
        archiveCycleBtn.disabled = !hasActiveCycle || window.isShareMode;
      }
    };

    // Close task drawer
    window.closeOptimisationTaskDrawer = function closeOptimisationTaskDrawer() {
      const drawer = document.getElementById('optimisation-task-drawer');
      const backdrop = document.getElementById('optimisation-task-drawer-backdrop');
      if (!drawer || !backdrop) return;
      
      backdrop.style.display = 'none';
      drawer.style.display = 'none';
      window.optimisationModuleState.currentTaskId = null;
      optimisationDrawerState.isMinimized = false;
      optimisationDrawerState.isMaximized = false;
    };
    
    // Minimize drawer
    function minimizeOptimisationDrawer() {
      const drawer = document.getElementById('optimisation-task-drawer');
      if (!drawer) return;
      
      if (optimisationDrawerState.isMinimized) {
        // Restore
        drawer.style.height = optimisationDrawerState.originalHeight;
        drawer.style.maxHeight = '90vh';
        document.getElementById('optimisation-drawer-content').style.display = 'block';
        optimisationDrawerState.isMinimized = false;
        document.getElementById('optimisation-drawer-minimize').textContent = '';
      } else {
        // Minimize
        optimisationDrawerState.originalHeight = drawer.style.height || 'auto';
        drawer.style.height = '60px';
        drawer.style.maxHeight = '60px';
        document.getElementById('optimisation-drawer-content').style.display = 'none';
        optimisationDrawerState.isMinimized = true;
        document.getElementById('optimisation-drawer-minimize').textContent = '+';
      }
    }
    
    // Maximize drawer
    function maximizeOptimisationDrawer() {
      const drawer = document.getElementById('optimisation-task-drawer');
      if (!drawer) return;
      
      if (optimisationDrawerState.isMaximized) {
        // Restore
        drawer.style.top = optimisationDrawerState.originalTop;
        drawer.style.left = optimisationDrawerState.originalLeft;
        drawer.style.transform = 'translate(-50%, -50%)';
        drawer.style.width = optimisationDrawerState.originalWidth;
        drawer.style.height = optimisationDrawerState.originalHeight;
        drawer.style.maxHeight = '90vh';
        optimisationDrawerState.isMaximized = false;
        document.getElementById('optimisation-drawer-maximize').textContent = '';
      } else {
        // Maximize
        optimisationDrawerState.originalTop = drawer.style.top;
        optimisationDrawerState.originalLeft = drawer.style.left;
        optimisationDrawerState.originalWidth = drawer.style.width;
        optimisationDrawerState.originalHeight = drawer.style.height || 'auto';
        
        drawer.style.top = '0';
        drawer.style.left = '0';
        drawer.style.transform = 'none';
        drawer.style.width = '100vw';
        drawer.style.height = '100vh';
        drawer.style.maxHeight = '100vh';
        optimisationDrawerState.isMaximized = true;
        document.getElementById('optimisation-drawer-maximize').textContent = '';
      }
    }
    
    // Make drawer draggable
    function initOptimisationDrawerDragging() {
      const drawer = document.getElementById('optimisation-task-drawer');
      const headerBar = document.getElementById('optimisation-drawer-header-bar');
      if (!drawer || !headerBar) return;
      
      headerBar.addEventListener('mousedown', (e) => {
        if (optimisationDrawerState.isMaximized) return; // Don't drag when maximized
        
        optimisationDrawerDragState.isDragging = true;
        const rect = drawer.getBoundingClientRect();
        optimisationDrawerDragState.startX = e.clientX;
        optimisationDrawerDragState.startY = e.clientY;
        optimisationDrawerDragState.startLeft = rect.left;
        optimisationDrawerDragState.startTop = rect.top;
        
        drawer.style.transition = 'none';
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!optimisationDrawerDragState.isDragging) return;
        
        const deltaX = e.clientX - optimisationDrawerDragState.startX;
        const deltaY = e.clientY - optimisationDrawerDragState.startY;
        
        drawer.style.left = (optimisationDrawerDragState.startLeft + deltaX) + 'px';
        drawer.style.top = (optimisationDrawerDragState.startTop + deltaY) + 'px';
        drawer.style.transform = 'none';
      });
      
      document.addEventListener('mouseup', () => {
        if (optimisationDrawerDragState.isDragging) {
          optimisationDrawerDragState.isDragging = false;
          drawer.style.transition = '';
        }
      });
    }

    // Phase 6: Load cycle-specific data (objective, measurements, events)
    async function loadCycleData(taskId, cycleId, allCycles, selectedCycle, cycleNo, task) {
      // Update objective display for selected cycle
      const objectiveCycleEl = document.getElementById('optimisation-drawer-objective-cycle');
      if (objectiveCycleEl) {
        objectiveCycleEl.textContent = `(Cycle ${cycleNo})`;
      }

      // Get cycle data (use selected cycle if provided, otherwise fetch from task)
      let cycleData = selectedCycle;
      if (!cycleData && cycleId && allCycles) {
        cycleData = allCycles.find(c => c.id === cycleId);
      }

      // Update objective display with selected cycle's objective
      if (cycleData) {
        // Merge cycle data into task for rendering
        const cycleTask = {
          ...task,
          objective: cycleData.objective || null,
          objective_status: cycleData.objective_status || 'not_set',
          objective_progress: cycleData.objective_progress || null,
          objective_due_at: cycleData.due_at || null,
          objective_title: cycleData.objective_title || null,
          primary_kpi: cycleData.primary_kpi || null,
          target_value: cycleData.target_value != null ? parseFloat(cycleData.target_value) : null,
          target_direction: cycleData.target_direction || null,
          timeframe_days: cycleData.timeframe_days != null ? parseInt(cycleData.timeframe_days) : null,
          plan: cycleData.plan || null,
          cycle_start_date: cycleData.start_date || null
        };
        
        // Re-render objective badge and content for selected cycle
        // Use the same validation function to ensure consistency
        const objectiveBadgeEl = document.getElementById('optimisation-drawer-objective-badge');
        if (objectiveBadgeEl) {
          // Validate status using actual values - don't trust database state
          const validatedStatus = validateObjectiveStatus(cycleTask, cycleTask.objective_progress);
          const badgeConfig = {
            'achieved': { text: 'Achieved', bg: '#10b981', color: '#ffffff' },
            'met': { text: 'Met', bg: '#10b981', color: '#ffffff' },
            'on_track': { text: 'Met', bg: '#10b981', color: '#ffffff' }, // on_track means met
            'off_track': { text: 'Off track', bg: '#ef4444', color: '#ffffff' }, // off_track means not met
            'at_risk': { text: 'At risk', bg: '#f59e0b', color: '#ffffff' },
            'overdue': { text: 'Overdue', bg: '#ef4444', color: '#ffffff' },
            'not_set': { text: 'Not set', bg: '#9ca3af', color: '#ffffff' },
            'no_measurement': { text: 'No measurement', bg: '#9ca3af', color: '#ffffff' },
            'no_data': { text: 'No measurement', bg: '#9ca3af', color: '#ffffff' } // API returns 'no_data' when values missing
          };
          const config = badgeConfig[validatedStatus] || badgeConfig['not_set'];
          objectiveBadgeEl.textContent = config.text;
          objectiveBadgeEl.style.background = config.bg;
          objectiveBadgeEl.style.color = config.color;
          objectiveBadgeEl.style.display = 'inline-block';
        }
        
        // Re-render objective content (reuse existing logic from earlier in the file)
        const objectiveContentEl = document.getElementById('optimisation-drawer-objective-content');
        if (objectiveContentEl) {
          const objective = cycleTask.objective || null;
          const objectiveProgress = cycleTask.objective_progress || null;
          const objectiveTitle = objective?.title || cycleTask.objective_title || null;
          const objectiveKpi = objective?.kpi || cycleTask.primary_kpi || null;
          const objectiveMetric = objective?.kpi || cycleTask.primary_kpi || null;
          // Handle target_type: 'delta' means increase/decrease, 'absolute' means at_least/at_most
          let objectiveDirection = null;
          if (objective?.target_type === 'delta') {
            // For delta, check if target is positive (increase) or negative (decrease)
            const targetVal = objective?.target != null ? objective.target : (cycleTask.target_value != null ? cycleTask.target_value : null);
            objectiveDirection = targetVal != null && targetVal >= 0 ? 'increase' : 'decrease';
          } else if (objective?.target_type === 'absolute') {
            // For absolute, we need to determine from KPI direction (higher_better vs lower_better)
            // For now, default to 'at_least' for most KPIs, 'at_most' for rank
            objectiveDirection = (objectiveKpi && objectiveKpi.includes('rank')) ? 'at_most' : 'at_least';
          } else {
            // Fallback to legacy target_direction
            objectiveDirection = cycleTask.target_direction || null;
          }
          const objectiveTargetValue = objective?.target != null ? objective.target : (cycleTask.target_value != null ? cycleTask.target_value : null);
          const objectiveTimeframe = objective?.due_at ? null : (cycleTask.timeframe_days != null ? cycleTask.timeframe_days : null);
          const objectivePlan = objective?.plan || cycleTask.plan || null;
          const cycleStartedAt = cycleTask.cycle_start_date || null;

          // Debug logging
          console.log('[loadCycleData] Cycle objective data:', {
            objective,
            objectiveTitle,
            objectiveKpi,
            objectiveMetric,
            objectiveDirection,
            objectiveTargetValue,
            cycleTask
          });

          if (objective || objectiveTitle || objectiveKpi || objectiveMetric || objectiveDirection || objectiveTargetValue != null) {
            let leftColumn = '';
            let rightColumn = '';
            
            if (objectiveTitle) {
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Title:</strong> ${escapeHtml(objectiveTitle)}</div>`;
            }
            if (objectiveKpi) {
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>KPI:</strong> ${escapeHtml(objectiveKpi)}</div>`;
            }
            // Show target if we have a target value (direction is optional)
            if (objectiveTargetValue != null) {
              const directionLabels = {
                'increase': 'Increase by',
                'decrease': 'Decrease by',
                'at_least': 'At least',
                'at_most': 'At most'
              };
              let targetText = '';
              // For CTR, convert from ratio (0-1) to percentage for display
              if (objectiveMetric === 'ctr_28d' || (objectiveKpi && objectiveKpi.includes('ctr'))) {
                // If target is stored as ratio (0-1), multiply by 100 for display
                // Check if value is likely a ratio (< 1) vs percentage (>= 1)
                let displayTargetValue = objectiveTargetValue;
                if (objectiveTargetValue != null && objectiveTargetValue < 1 && objectiveTargetValue > 0) {
                  displayTargetValue = objectiveTargetValue * 100;
                }
                if (objectiveDirection) {
                  targetText = `${directionLabels[objectiveDirection] || objectiveDirection} ${displayTargetValue.toFixed(1)}%`;
                } else {
                  targetText = `${displayTargetValue.toFixed(1)}%`;
                }
              } else {
              if (objectiveDirection) {
                targetText = `${directionLabels[objectiveDirection] || objectiveDirection} ${objectiveTargetValue}`;
              } else {
                // If no direction specified, just show the target value
                targetText = `${objectiveTargetValue}`;
              }
              }
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Target:</strong> ${escapeHtml(targetText)}</div>`;
            } else if (objectiveDirection) {
              // Show direction even if no target value
              const directionLabels = {
                'increase': 'Increase',
                'decrease': 'Decrease',
                'at_least': 'At least',
                'at_most': 'At most'
              };
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Direction:</strong> ${escapeHtml(directionLabels[objectiveDirection] || objectiveDirection)}</div>`;
            }
            
            if (objectiveTimeframe || cycleTask.objective_due_at) {
              let timeframeText = '';
              const dueAt = cycleTask.objective_due_at || null;
              if (dueAt) {
                const dueDate = new Date(dueAt).toLocaleDateString('en-GB');
                timeframeText = `Due: ${dueDate}`;
              } else if (objectiveTimeframe && cycleStartedAt) {
                timeframeText = `${objectiveTimeframe} days`;
                const startDate = new Date(cycleStartedAt);
                const dueDate = new Date(startDate.getTime() + objectiveTimeframe * 24 * 60 * 60 * 1000);
                timeframeText += ` (Due: ${dueDate.toLocaleDateString('en-GB')})`;
              }
              if (timeframeText) {
                rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>Timeframe:</strong> ${timeframeText}</div>`;
              }
            }
            
            if (objectiveProgress && objectiveProgress.baseline_value != null && objectiveProgress.latest_value != null) {
              const baselineVal = objectiveProgress.baseline_value;
              const latestVal = objectiveProgress.latest_value;
              const target = objectiveProgress.target != null ? objectiveProgress.target : objectiveTargetValue;
              const targetType = (objective && objective.target_type) || 'delta';
              const kpiKey = objectiveKpi || objectiveMetric;
              
              if (kpiKey) {
                // Use single source of truth helper for correct delta math
                const progressLine = computeObjectiveProgressLine({
                  kpiKey: kpiKey,
                  baselineValue: baselineVal,
                  latestValue: latestVal,
                  targetValue: target,
                  direction: targetType
                });
                
                rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>Progress:</strong> ${progressLine.baselineDisp}  ${progressLine.latestDisp} (<span style="color: ${progressLine.deltaColor} !important; font-weight: 600;">${progressLine.deltaDisp}</span>) vs target ${progressLine.targetDisp}</div>`;
              }
            }
            
            let objectiveHtml = `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
              <div>${leftColumn || '<div style="color: #999; font-style: italic;"></div>'}</div>
              <div>${rightColumn || '<div style="color: #999; font-style: italic;"></div>'}</div>
            </div>`;
            
            if (objectivePlan) {
              objectiveHtml += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #e2e8f0;"><strong>Plan:</strong> ${escapeHtml(objectivePlan)}</div>`;
            }
            objectiveContentEl.innerHTML = objectiveHtml || '<div style="color: #666; font-style: italic;">No objective set</div>';
          } else {
            objectiveContentEl.innerHTML = '<div style="color: #666; font-style: italic;">No objective set</div>';
          }
        }
      }

      // Fetch baseline and latest metrics for selected cycle
      await renderOptimisationMetricsSnapshotForCycle(taskId, cycleId, cycleNo, task);

      // Load measurement history (for selected cycle)
      await loadOptimisationMeasurementHistory(taskId, cycleId, cycleNo);

      // Load events (filtered to selected cycle)
      await loadOptimisationTaskEventsForCycle(taskId, cycleId, cycleNo);
    }

    // Phase 6: Render metrics snapshot for a specific cycle
    async function renderOptimisationMetricsSnapshotForCycle(taskId, cycleId, cycleNo, task = null) {
      // Fetch events for this cycle to get baseline and latest
      const headers = window.getOptimisationHeaders();
      const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/events?cycle_id=${cycleId || ''}&cycle_number=${cycleNo || ''}&event_type=measurement`), {
        headers: headers
      });

      let baselineMetrics = null;
      let latestMetrics = null;

      if (response.ok) {
        const data = await response.json();
        const measurements = data.events || [];
        
        if (measurements.length > 0) {
          const sorted = [...measurements].sort((a, b) => {
            const dateA = new Date(a.created_at || a.event_at || 0);
            const dateB = new Date(b.created_at || b.event_at || 0);
            return dateA - dateB;
          });

          // Baseline: prefer the most recent baseline marker; fallback to first measurement.
          // CRITICAL: Sort baseline candidates by created_at DESC to get the LATEST baseline (after rebaselining)
          const baselineCandidates = sorted.filter(m => m && m.is_baseline === true && m.metrics);
          const baselineEvent = baselineCandidates.length > 0
            ? baselineCandidates.sort((a, b) => {
                const dateA = new Date(a.created_at || a.event_at || 0);
                const dateB = new Date(b.created_at || b.event_at || 0);
                return dateB - dateA; // DESC - most recent first
              })[0] // Get the most recent baseline
            : sorted[0];

          if (baselineEvent && baselineEvent.metrics) {
            baselineMetrics = { ...baselineEvent.metrics };
            if (baselineEvent.created_at) baselineMetrics.captured_at = baselineEvent.created_at;
          }
          
          // Latest is always the most recent measurement
          
          if (sorted[sorted.length - 1] && sorted[sorted.length - 1].metrics) {
            latestMetrics = { ...sorted[sorted.length - 1].metrics };
            if (sorted[sorted.length - 1].created_at) {
            latestMetrics.captured_at = sorted[sorted.length - 1].created_at;
          }
          }
          
        } else {
          // No measurements for this cycle
        }
      }

      // If task not provided, try to get it from state
      if (!task) {
        if (window.optimisationModuleState && window.optimisationModuleState.allTasks) {
          task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
        }
      }
      
      // Render with cycle-specific metrics, including task objective fields
      const cycleTask = {
        ...(task || {}),
        baseline_metrics: baselineMetrics,
        latest_metrics: latestMetrics
      };
      renderOptimisationMetricsSnapshot(cycleTask);
    }

    // Phase 6: Load events filtered to selected cycle
    async function loadOptimisationTaskEventsForCycle(taskId, cycleId, cycleNo) {
      const eventsContainer = document.getElementById('optimisation-drawer-events');
      if (!eventsContainer) return;

      try {
        const headers = window.getOptimisationHeaders();
        let url = apiUrl(`/api/optimisation/task/${taskId}/events`);
        if (cycleId) {
          url += `?cycle_id=${cycleId}`;
        } else if (cycleNo) {
          url += `?cycle_number=${cycleNo}`;
        }
        
        const response = await fetch(url, {
          method: 'GET',
          headers: headers
        });

        if (!response.ok) {
          throw new Error(`Failed to load events: ${response.status}`);
        }

        const data = await response.json();
        let events = data.events || [];

        // Filter to selected cycle if not already filtered by API
        if (cycleId || cycleNo) {
          events = events.filter(e => {
            if (cycleId) return e.cycle_id === cycleId;
            if (cycleNo) return e.cycle_number === cycleNo;
            return true;
          });
        }

        if (events.length === 0) {
          eventsContainer.innerHTML = `<div style="color: #666; font-style: italic;">No events for Cycle ${cycleNo || 'this cycle'}</div>`;
          return;
        }

        // Group events by cycle for display
        const eventsByCycle = {};
        events.forEach(event => {
          const cycleKey = event.cycle_number || 'unknown';
          if (!eventsByCycle[cycleKey]) {
            eventsByCycle[cycleKey] = [];
          }
          eventsByCycle[cycleKey].push(event);
        });

        eventsContainer.innerHTML = Object.keys(eventsByCycle).sort((a, b) => {
          if (a === 'unknown') return 1;
          if (b === 'unknown') return -1;
          return parseInt(b) - parseInt(a);
        }).map(cycleKey => {
          const cycleEvents = eventsByCycle[cycleKey];
          const cycleLabel = cycleKey === 'unknown' ? 'Other' : `Cycle ${cycleKey}`;
          return `
            <div style="margin-bottom: 1.5rem;">
              <div style="font-weight: 700; color: #1e293b; margin-bottom: 0.5rem; padding-bottom: 0.25rem; border-bottom: 2px solid #e2e8f0;">${cycleLabel}</div>
              ${cycleEvents.map(event => {
                const date = new Date(event.event_at || event.created_at).toLocaleString('en-GB', { timeZone: 'UTC' });
                return `
                  <div style="margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid #eee;">
                    <div style="font-weight: 600; color: #2563eb;">${escapeHtml(event.event_type || 'note')}</div>
                    <div style="color: #666; font-size: 0.875rem; margin-top: 0.25rem;">${date}</div>
                    ${event.note ? `<div style="margin-top: 0.5rem;">${escapeHtml(event.note)}</div>` : ''}
                  </div>
                `;
              }).join('')}
            </div>
          `;
        }).join('');
      } catch (error) {
        console.error('[Optimisation Module] Error loading events:', error);
        eventsContainer.innerHTML = '<div style="color: #ef4444;">Error loading events</div>';
      }
    }

    // Phase 8: KPI-specific formatting metadata (Phase 9: add get methods)
    const KPI_DISPLAY_METADATA = {
      clicks_28d: {
        label: 'Clicks (28d)',
        get: (m) => (m && m.clicks_28d) != null ? m.clicks_28d : ((m && m.gsc_clicks_28d) != null ? m.gsc_clicks_28d : null),
        formatValue: (val) => val != null ? Math.round(val).toLocaleString('en-GB') : '',
        formatDelta: (delta) => {
          if (delta == null) return '';
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Math.round(delta).toLocaleString('en-GB')}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toLocaleString('en-GB');
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target).toLocaleString('en-GB')}`;
        }
      },
      impressions_28d: {
        label: 'Impressions (28d)',
        get: (m) => (m && m.impressions_28d) != null ? m.impressions_28d : ((m && m.gsc_impressions_28d) != null ? m.gsc_impressions_28d : null),
        formatValue: (val) => {
          if (val == null) return '';
          // Always show exact values (no "k") to avoid hiding small deltas (e.g. 4,558 vs 4,702).
          return Math.round(val).toLocaleString('en-GB');
        },
        formatDelta: (delta) => {
          if (delta == null) return '';
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Math.round(delta).toLocaleString('en-GB')}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toLocaleString('en-GB');
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target).toLocaleString('en-GB')}`;
        }
      },
      ctr_28d: {
        formatValue: (val) => {
          if (val == null) return '';
          return (val * 100).toFixed(2) + '%';
        },
        formatDelta: (delta) => {
          if (delta == null) return '';
          // Delta is in decimal (0-1), convert to percentage points (pp)
          const deltaPp = delta * 100;
          const sign = deltaPp >= 0 ? '+' : '';
          return `${sign}${deltaPp.toFixed(2)}pp`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            // Absolute target is stored as decimal (0-1), display as %
            return (target * 100).toFixed(2) + '%';
          }
          // Delta target: for CTR, show as percentage points
          // The target is the absolute delta in decimal units
          const targetPp = target * 100;
          const sign = target >= 0 ? '+' : '';
          return `${sign}${targetPp.toFixed(2)}pp`;
        }
      },
      current_rank: {
        label: 'Current Rank',
        get: (m) => (m && m.current_rank) != null ? m.current_rank : ((m && m.rank) != null ? m.rank : null),
        formatValue: (val) => val != null ? Number(val).toFixed(2) : '',
        formatDelta: (delta) => {
          if (delta == null) return '';
          // For rank, positive delta means improvement (rank went down)
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Number(delta).toFixed(2)}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toString();
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target)}`;
        }
      },
      opportunity_score: {
        label: 'Opportunity Score',
        get: (m) => (m && m.opportunity_score) != null ? m.opportunity_score : null,
        formatValue: (val) => val != null ? Math.round(val).toString() : '',
        formatDelta: (delta) => {
          if (delta == null) return '';
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Math.round(delta)}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toString();
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target)}`;
        }
      },
      ai_overview: {
        label: 'AI Overview',
        get: (m) => (m && m.ai_overview) != null ? m.ai_overview : false,
        formatValue: (val) => val === true ? 'On' : (val === false ? 'Off' : ''),
        formatDelta: (delta) => {
          if (delta == null) return '';
          if (delta > 0) return '+1';
          if (delta < 0) return '-1';
          return '0';
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          return target === true ? 'On' : 'Off';
        }
      },
      ai_citations: {
        label: 'AI Citations',
        get: (m) => (m && m.ai_citations) != null ? m.ai_citations : null,
        formatValue: (val) => val != null ? Math.round(val).toString() : '',
        formatDelta: (delta) => {
          if (delta == null) return '';
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Math.round(delta)}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toString();
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target)}`;
        }
      }
    };

    // Helper: Compute objective progress line with correct delta math (single source of truth)
    // Always calculates delta as latest - baseline (or baseline - latest for rank)
    function computeObjectiveProgressLine({ kpiKey, baselineValue, latestValue, targetValue, direction }) {
      // If baseline/latest missing, return placeholder
      if (baselineValue == null || latestValue == null) {
        return { text: 'Progress: ', delta: null, deltaColor: '#666' };
      }
      
      // Calculate raw delta (always from baseline to latest)
      let deltaRaw = latestValue - baselineValue;
      
      // For rank, lower is better, so invert: improvement = baseline - latest (positive when rank decreases)
      if (kpiKey === 'current_rank') {
        deltaRaw = baselineValue - latestValue;
      }
      
      // Format values based on KPI type
      let baselineDisp, latestDisp, deltaDisp;
      
      if (kpiKey === 'ctr_28d') {
        baselineDisp = (baselineValue * 100).toFixed(2) + '%';
        latestDisp = (latestValue * 100).toFixed(2) + '%';
        const deltaPp = (latestValue - baselineValue) * 100;
        deltaDisp = (deltaPp >= 0 ? '+' : '') + deltaPp.toFixed(2) + 'pp';
      } else if (kpiKey === 'current_rank') {
        baselineDisp = baselineValue.toFixed(1);
        latestDisp = latestValue.toFixed(1);
        // For rank, deltaRaw is already inverted (baseline - latest), so positive = improvement
        deltaDisp = (deltaRaw >= 0 ? '+' : '') + deltaRaw.toFixed(1);
      } else {
        // For other metrics, use number formatting
        const displayMeta = KPI_DISPLAY_METADATA[kpiKey];
        if (displayMeta) {
          baselineDisp = displayMeta.formatValue(baselineValue);
          latestDisp = displayMeta.formatValue(latestValue);
          deltaDisp = displayMeta.formatDelta(deltaRaw);
        } else {
          baselineDisp = baselineValue.toLocaleString('en-GB');
          latestDisp = latestValue.toLocaleString('en-GB');
          deltaDisp = (deltaRaw >= 0 ? '+' : '') + deltaRaw.toLocaleString('en-GB');
        }
      }
      
      // Determine color: green for positive, red for negative, amber for zero
      let deltaColor = '#f59e0b'; // Amber for no change
      if (deltaRaw > 0) deltaColor = '#10b981'; // Green for positive/improvement
      else if (deltaRaw < 0) deltaColor = '#ef4444'; // Red for negative/worsening
      
      // Format target display
      let targetDisp = '';
      if (targetValue != null) {
        const displayMeta = KPI_DISPLAY_METADATA[kpiKey];
        if (displayMeta && displayMeta.formatTarget) {
          targetDisp = displayMeta.formatTarget(targetValue, direction || 'delta', baselineValue);
        } else {
          // Fallback formatting
          if (direction === 'delta') {
            targetDisp = (targetValue >= 0 ? '+' : '') + targetValue.toLocaleString('en-GB');
          } else {
            targetDisp = targetValue.toLocaleString('en-GB');
          }
        }
      }
      
      // Build progress line text with colored delta
      const text = `Progress: ${baselineDisp}  ${latestDisp} (<span style="color: ${deltaColor} !important; font-weight: 600;">${deltaDisp}</span>) vs target ${targetDisp}`;
      
      return {
        text,
        delta: deltaRaw,
        deltaColor,
        baselineDisp,
        latestDisp,
        deltaDisp,
        targetDisp
      };
    }
    
    // Legacy formatProgressValue function (kept for backward compatibility)
    function formatProgressValue(value, kpi) {
      if (value == null || value === undefined) return '';
      
      const displayMeta = kpi ? KPI_DISPLAY_METADATA[kpi] : null;
      if (displayMeta) {
        return displayMeta.formatValue(value);
      }
      
      // Fallback for unknown KPIs
      if (typeof value === 'number') {
        if (Math.abs(value) < 1 && value !== 0) {
          return value.toFixed(2);
        }
        if (Number.isInteger(value) || Math.abs(value) >= 1) {
          return value.toLocaleString('en-GB', { maximumFractionDigits: 2 });
        }
        return value.toFixed(2);
      }
      
      return String(value);
    }
    
    // Phase 8: Compute goal progress with proper formatting
    function computeGoalProgress({ kpiKey, baseline, latest, targetValue, targetType }) {
      const displayMeta = KPI_DISPLAY_METADATA[kpiKey];
      if (!displayMeta) {
        return {
          baselineLabel: baseline != null ? String(baseline) : '',
          latestLabel: latest != null ? String(latest) : '',
          deltaLabel: '',
          targetLabel: targetValue != null ? String(targetValue) : '',
          progressLabel: ''
        };
      }

      // Calculate delta
      let delta = null;
      if (baseline != null && latest != null) {
        // For rank, improvement is positive when rank decreases
        if (kpiKey === 'current_rank') {
          delta = baseline - latest;
        } else {
          delta = latest - baseline;
        }
      }

      // Format labels
      const baselineLabel = displayMeta.formatValue(baseline);
      const latestLabel = displayMeta.formatValue(latest);
      const deltaLabel = displayMeta.formatDelta(delta);
      const targetLabel = displayMeta.formatTarget(targetValue, targetType, baseline);
      
      // Calculate remaining to target
      let remainingToTarget = null;
      if (targetType === 'delta' && delta != null && targetValue != null) {
        remainingToTarget = Math.max(0, targetValue - delta);
      } else if (targetType === 'absolute' && latest != null && targetValue != null) {
        if (kpiKey === 'current_rank') {
          remainingToTarget = Math.max(0, latest - targetValue);
        } else {
          remainingToTarget = Math.max(0, targetValue - latest);
        }
      }

      // Build progress label
      let progressLabel = '';
      if (baseline != null && latest != null && targetValue != null) {
        if (targetType === 'delta') {
          if (remainingToTarget != null && remainingToTarget > 0) {
            progressLabel = `${deltaLabel}/${targetLabel} (${displayMeta.formatDelta(remainingToTarget)} remaining)`;
          } else if (delta != null && delta >= targetValue) {
            progressLabel = `${deltaLabel}/${targetLabel} (Met)`;
          } else {
            progressLabel = `${deltaLabel}/${targetLabel}`;
          }
        } else {
          if (remainingToTarget != null && remainingToTarget > 0) {
            progressLabel = `${latestLabel}/${targetLabel} (${displayMeta.formatValue(remainingToTarget)} remaining)`;
          } else if (latest != null && ((kpiKey === 'current_rank' && latest <= targetValue) || (kpiKey !== 'current_rank' && latest >= targetValue))) {
            progressLabel = `${latestLabel}/${targetLabel} (Met)`;
          } else {
            progressLabel = `${latestLabel}/${targetLabel}`;
          }
        }
      }

      return {
        baselineLabel,
        latestLabel,
        deltaLabel,
        targetLabel,
        progressLabel,
        remainingToTarget
      };
    }

    // Phase 9: Helper functions for dashboard features
    
    // Render sparkline SVG
    function renderSparkline(points, width = 80, height = 24, delta = null) {
      if (!points || points.length < 2) return '';
      
      const filtered = points.filter(p => p != null);
      if (filtered.length < 2) return '';
      
      const min = Math.min(...filtered);
      const max = Math.max(...filtered);
      const range = max - min || 1; // Avoid division by zero
      
      const padding = 2;
      const plotWidth = width - padding * 2;
      const plotHeight = height - padding * 2;
      
      const path = filtered.map((val, idx) => {
        const x = padding + (idx / (filtered.length - 1)) * plotWidth;
        const y = padding + plotHeight - ((val - min) / range) * plotHeight;
        return `${x},${y}`;
      }).join(' ');
      
      // Use delta direction if provided (matches delta column color), otherwise fall back to first vs last
      let color = '#f59e0b'; // Amber default
      if (delta != null) {
        // Use delta direction: positive = green, negative = red
        color = delta >= 0 ? '#10b981' : '#ef4444';
      } else {
        // Fallback: compare last point to first point
        color = filtered[filtered.length - 1] >= filtered[0] ? '#10b981' : '#ef4444';
      }
      
      return `<svg width="${width}" height="${height}" style="display: block;">
        <polyline points="${path}" fill="none" stroke="${color}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>`;
    }
    
    // Update KPI tiles
    function updateKPITiles() {
      let tasks = window.optimisationModuleState.allTasks || [];
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      // Recalculate tiles from filtered tasks
      const tiles = {
        ctr: { on_track: 0, at_risk: 0, overdue: 0 },
        rank: { improved: 0, worse: 0, flat: 0 },
        ai_gap: 0,
        needs_measurement: 0,
        overdue_cycles: 0,
      };
      
      for (const task of tasks) {
        const objectiveRag = task.objectiveRag || task.objective_status || 'no_data';
        let objectiveKpiKey = task.objectiveKpiKey || (task.objective && task.objective.kpi) || task.objective_metric || task.objective_kpi || task.primary_kpi || null;
        
        // Map "Rank" to "current_rank" if needed
        if (objectiveKpiKey === 'Rank' || objectiveKpiKey === 'rank') {
          objectiveKpiKey = 'current_rank';
        }
        
        // Compute delta for rank tasks if not already set
        let delta = task.delta;
        let baselineValue = null;
        let latestValue = null;
        
        if (objectiveKpiKey === 'current_rank' && delta == null) {
          // Get baseline and latest values for rank
          baselineValue = task.baselineValue;
          latestValue = task.latestValue;
          
          // Fallback to extracting from metrics if not directly available
          if (baselineValue == null || latestValue == null) {
            const kpiMeta = KPI_DISPLAY_METADATA['current_rank'];
            if (kpiMeta && kpiMeta.get) {
              if (baselineValue == null && task.baseline_metrics) {
                baselineValue = kpiMeta.get(task.baseline_metrics);
              }
              if (latestValue == null && task.latest_metrics) {
                latestValue = kpiMeta.get(task.latest_metrics);
              }
            }
          }
          
          // Compute delta: for rank, positive delta = improvement (baseline - latest)
          if (baselineValue != null && latestValue != null) {
            delta = baselineValue - latestValue;
          }
        }
        
        // CTR tiles
        if (objectiveKpiKey === 'ctr_28d' && objectiveRag !== 'no_data') {
          if (objectiveRag === 'on_track') tiles.ctr.on_track++;
          else if (objectiveRag === 'at_risk') tiles.ctr.at_risk++;
          else if (objectiveRag === 'overdue') tiles.ctr.overdue++;
        }
        
        // Rank tiles
        // For rank: delta = baseline - latest
        // Positive delta = rank improved (went down, e.g., 10 -> 5)
        // Negative delta = rank worsened (went up, e.g., 5 -> 10)
        if (objectiveKpiKey === 'current_rank' && delta != null) {
          // Get baseline/latest values for logging if not already set
          if (baselineValue == null) baselineValue = task.baselineValue;
          if (latestValue == null) latestValue = task.latestValue;
          
          // Only count tasks that have a rank objective set
          if (delta > 0) {
            tiles.rank.improved++;
            debugLog(`[Rank Tiles] Task "${task.keyword_text || task.target_url || 'unknown'}" improved: baseline=${baselineValue}, latest=${latestValue}, delta=${delta}`, 'info');
          } else if (delta < 0) {
            tiles.rank.worse++;
            debugLog(`[Rank Tiles] Task "${task.keyword_text || task.target_url || 'unknown'}" worsened: baseline=${baselineValue}, latest=${latestValue}, delta=${delta}`, 'info');
          } else {
            tiles.rank.flat++;
          }
        }
        
        // AI Gap
        if (task.latestValue != null && objectiveKpiKey === 'ai_citations') {
          // Check if AI overview is on but citations = 0
          const latestMetrics = task.latest_metrics || {};
          if (latestMetrics.ai_overview === true && (latestMetrics.ai_citations === 0 || latestMetrics.ai_citations == null)) {
            tiles.ai_gap++;
          }
        }
        
        // Needs Measurement
        if (task.needsMeasurement) {
          tiles.needs_measurement++;
        }
        
        // Overdue Cycles
        if (objectiveRag === 'overdue') {
          tiles.overdue_cycles++;
        }
      }
      
      if (tiles.ctr) {
        const onTrackEl = document.getElementById('kpi-ctr-on-track');
        const atRiskEl = document.getElementById('kpi-ctr-at-risk');
        const overdueEl = document.getElementById('kpi-ctr-overdue');
        if (onTrackEl) onTrackEl.textContent = tiles.ctr.on_track || 0;
        if (atRiskEl) atRiskEl.textContent = tiles.ctr.at_risk || 0;
        if (overdueEl) overdueEl.textContent = tiles.ctr.overdue || 0;
      }
      
      if (tiles.rank) {
        const improvedEl = document.getElementById('kpi-rank-improved');
        const worseEl = document.getElementById('kpi-rank-worse');
        const flatEl = document.getElementById('kpi-rank-flat');
        if (improvedEl) improvedEl.textContent = tiles.rank.improved || 0;
        if (worseEl) worseEl.textContent = tiles.rank.worse || 0;
        if (flatEl) flatEl.textContent = tiles.rank.flat || 0;
      }
      
      const aiGapEl = document.getElementById('kpi-ai-gap');
      const needsMeasEl = document.getElementById('kpi-needs-measurement');
      const overdueCyclesEl = document.getElementById('kpi-overdue-cycles');
      if (aiGapEl) aiGapEl.textContent = tiles.ai_gap || 0;
      if (needsMeasEl) needsMeasEl.textContent = tiles.needs_measurement || 0;
      if (overdueCyclesEl) overdueCyclesEl.textContent = tiles.overdue_cycles || 0;
    }
    
    // Update impact tiles
    function updateImpactTiles() {
      let tasks = window.optimisationModuleState.allTasks || [];
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      // Get current scope (respects the scope filter)
      const scope = window.optimisationModuleState.scope || 'active_cycle';
      
      // Compute potential and actual clicks with deduplication
      const { potential, actual, includedTasksCount } = computePotentialAndActualClicks28d(tasks, scope);
      
      // Count traffic KPI tasks and click-related tasks for context strip
      const trafficKpis = new Set(['ctr_28d', 'impressions_28d', 'clicks_28d']);
      let trafficKpiCount = 0;
      let clickRelatedCount = 0;
      
      for (const task of tasks) {
        const objectiveKpiKey = task.objectiveKpiKey || (task.objective && task.objective.kpi) || 
                                (task.cycle && task.cycle.objective && task.cycle.objective.kpi);
        
        // Count traffic KPI tasks
        if (objectiveKpiKey && trafficKpis.has(objectiveKpiKey)) {
          trafficKpiCount++;
          
          // Check if click-related (can compute clicks delta)
          const activeCycle = scope === 'active_cycle' 
            ? ((task.cycles && task.cycles.find(c => c.is_active || c.id === task.active_cycle_id)) || null)
            : null;
          const measurements = task.measurements || [];
          const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);
          
          if (baselineLatest && baselineLatest.baseline && baselineLatest.latest) {
            const delta = computeActualClickDeltaForTask(task, baselineLatest.baseline, baselineLatest.latest);
            if (delta != null) {
              clickRelatedCount++;
            }
          } else if (task.baseline_metrics && task.latest_metrics) {
            const delta = computeActualClickDeltaForTask(task, task.baseline_metrics, task.latest_metrics);
            if (delta != null) {
              clickRelatedCount++;
            }
          } else if (task.baselineValue != null && task.latestValue != null && objectiveKpiKey === 'clicks_28d') {
            clickRelatedCount++;
          }
        }
      }
      
      // Also compute per-task values for chart aggregation (still needed for charts)
      let aiCitationGapCount = 0;
      for (const task of tasks) {
        // Store per-task value for chart aggregation
        const extraClicks = computeEstimatedExtraClicks28d(task);
        task.estimated_extra_clicks_28d = extraClicks;
        
        // AI Citation Gap
        const latestMetrics = task.latest_metrics || {};
        if (latestMetrics.ai_overview === true && (latestMetrics.ai_citations === 0 || latestMetrics.ai_citations == null)) {
          aiCitationGapCount++;
        }
      }
      
      // Update Potential Extra Clicks tile
      const potentialClicksEl = document.getElementById('impact-potential-clicks');
      const potentialClicksCard = document.getElementById('impact-potential-clicks-card');
      const potentialClicksClear = document.getElementById('impact-potential-clicks-clear');
      if (potentialClicksEl) {
        potentialClicksEl.textContent = potential >= 1000 
          ? (potential / 1000).toFixed(1) + 'k' 
          : Math.round(potential).toLocaleString('en-GB');
      }
      
      // Show/hide clear button for potential tile
      if (potentialClicksClear) {
        potentialClicksClear.style.display = window.optimisationModuleState.trafficKpiOnly ? 'block' : 'none';
      }
      
      // Set bronze/silver/gold background for potential tile
      if (potentialClicksCard) {
        potentialClicksCard.classList.remove('impact-bronze', 'impact-silver', 'impact-gold');
        if (potential < 50) {
          potentialClicksCard.classList.add('impact-bronze');
        } else if (potential >= 50 && potential < 200) {
          potentialClicksCard.classList.add('impact-silver');
        } else {
          potentialClicksCard.classList.add('impact-gold');
        }
      }
      
      // Update Actual Click Change tile
      const actualClicksEl = document.getElementById('impact-actual-clicks');
      const actualClicksClear = document.getElementById('impact-actual-clicks-clear');
      if (actualClicksEl) {
        // Format with sign (+ or -)
        const sign = actual >= 0 ? '+' : '';
        actualClicksEl.textContent = sign + (Math.abs(actual) >= 1000 
          ? (Math.abs(actual) / 1000).toFixed(1) + 'k' 
          : Math.round(Math.abs(actual)).toLocaleString('en-GB'));
        
        // Color code: green for positive, red for negative
        actualClicksEl.style.color = actual >= 0 ? '#10b981' : '#ef4444';
      }
      
      // Show/hide clear button for actual tile
      if (actualClicksClear) {
        actualClicksClear.style.display = window.optimisationModuleState.clickRelatedOnly ? 'block' : 'none';
      }
      
      // Update context strip
      const trafficKpiCountEl = document.getElementById('traffic-kpi-count');
      const clickRelatedCountEl = document.getElementById('click-related-count');
      if (trafficKpiCountEl) {
        trafficKpiCountEl.textContent = `Traffic KPI tasks included: ${trafficKpiCount}`;
      }
      if (clickRelatedCountEl) {
        clickRelatedCountEl.textContent = `Click-related tasks included: ${clickRelatedCount}`;
      }
      
      const aiGapEl = document.getElementById('impact-ai-gap');
      if (aiGapEl) aiGapEl.textContent = aiCitationGapCount || 0;
    }
    
    // Handle traffic light pill click
    window.handleTrafficLightClick = function(metricKey, bucket) {
      const currentFilter = window.optimisationModuleState.metricTrafficFilter;
      
      // Toggle: if clicking the same pill, clear filter
      if (currentFilter && currentFilter.metricKey === metricKey && currentFilter.bucket === bucket) {
        window.optimisationModuleState.metricTrafficFilter = null;
      } else {
        window.optimisationModuleState.metricTrafficFilter = { metricKey, bucket };
      }
      
      // Update visual state (highlighting)
      updateTrafficLightVisuals();
      
      // Apply filters (this will update filteredTasks)
      applyOptimisationFilters();
      
      // Update charts with new filtered data
      updateTimeseriesCharts();
      
      // Only sort if there's an active filter
      if (window.optimisationModuleState.metricTrafficFilter) {
        const filter = window.optimisationModuleState.metricTrafficFilter;
        let tasks = [...window.optimisationModuleState.filteredTasks];
        const scope = window.optimisationModuleState.scope || 'active_cycle';
        const metricKeys = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
        
        // Sort tasks by their classification for this metric
        tasks.sort((a, b) => {
          // Get classifications for both tasks
          const aActiveCycle = scope === 'active_cycle' 
            ? (a.cycles?.find(c => c.is_active || c.id === a.active_cycle_id) || null)
            : null;
          const bActiveCycle = scope === 'active_cycle' 
            ? (b.cycles?.find(c => c.is_active || c.id === b.active_cycle_id) || null)
            : null;
          
          const aMeasurements = a.measurements || [];
          const bMeasurements = b.measurements || [];
          
          const aBaselineLatest = getBaselineLatest(aMeasurements, scope, aActiveCycle);
          const bBaselineLatest = getBaselineLatest(bMeasurements, scope, bActiveCycle);
          
          let aClass, bClass;
          
          if (filter.metricKey === 'all_metrics') {
            // For all_metrics, find majority classification (at least 3 out of 6)
            const aClasses = [];
            const bClasses = [];
            
            if (aBaselineLatest) {
              for (const mk of metricKeys) {
                const cls = classifyMetric(mk, aBaselineLatest.baseline, aBaselineLatest.latest);
                if (cls) aClasses.push(cls);
              }
            }
            
            if (bBaselineLatest) {
              for (const mk of metricKeys) {
                const cls = classifyMetric(mk, bBaselineLatest.baseline, bBaselineLatest.latest);
                if (cls) bClasses.push(cls);
              }
            }
            
            // Find majority classification for task A
            if (aClasses.length >= 4) {
              const aCounts = { worse: 0, same: 0, better: 0 };
              aClasses.forEach(c => aCounts[c]++);
              const aMajority = Math.max(aCounts.worse, aCounts.same, aCounts.better);
              aClass = aCounts.worse === aMajority ? 'worse' :
                       aCounts.same === aMajority ? 'same' :
                       aCounts.better === aMajority ? 'better' : null;
              // Only use if majority is at least 4
              if (aMajority < 4) aClass = null;
            } else {
              aClass = null;
            }
            
            // Find majority classification for task B
            if (bClasses.length >= 4) {
              const bCounts = { worse: 0, same: 0, better: 0 };
              bClasses.forEach(c => bCounts[c]++);
              const bMajority = Math.max(bCounts.worse, bCounts.same, bCounts.better);
              bClass = bCounts.worse === bMajority ? 'worse' :
                       bCounts.same === bMajority ? 'same' :
                       bCounts.better === bMajority ? 'better' : null;
              // Only use if majority is at least 4
              if (bMajority < 4) bClass = null;
            } else {
              bClass = null;
            }
          } else {
            // Single metric
            aClass = aBaselineLatest ? classifyMetric(filter.metricKey, aBaselineLatest.baseline, aBaselineLatest.latest) : null;
            bClass = bBaselineLatest ? classifyMetric(filter.metricKey, bBaselineLatest.baseline, bBaselineLatest.latest) : null;
          }
          
          // Priority: better (2) > same (1) > worse (0) > null (-1)
          const getPriority = (cls) => {
            if (cls === 'better') return 2;
            if (cls === 'same') return 1;
            if (cls === 'worse') return 0;
            return -1;
          };
          
          const aPriority = getPriority(aClass);
          const bPriority = getPriority(bClass);
          
          // Sort descending (better first)
          return bPriority - aPriority;
        });
        
        window.optimisationModuleState.filteredTasks = tasks;
      }
      
      // Re-render table with new filter and sort
      renderOptimisationTasksTable();
    };
    
    // Update visual state of traffic light pills (selected/not selected)
    function updateTrafficLightVisuals() {
      const filter = window.optimisationModuleState.metricTrafficFilter;
      const pills = document.querySelectorAll('.traffic-light-pill');
      
      pills.forEach(pill => {
        const metricKey = pill.dataset.metric;
        const bucket = pill.dataset.bucket;
        const isSelected = filter && filter.metricKey === metricKey && filter.bucket === bucket;
        
        if (isSelected) {
          // Active state: bright orange border, strong glow, and brighter background
          pill.style.border = '3px solid var(--dark-brand)';
          pill.style.boxShadow = '0 0 16px rgba(245, 158, 11, 0.8), 0 0 8px rgba(245, 158, 11, 0.6)';
          pill.style.transform = 'scale(1.05)';
          pill.style.zIndex = '10';
          // Make background brighter when selected
          if (bucket === 'worse') {
            pill.style.background = 'rgba(239, 68, 68, 0.4) !important';
          } else if (bucket === 'same') {
            pill.style.background = 'rgba(245, 158, 11, 0.4) !important';
          } else {
            pill.style.background = 'rgba(16, 185, 129, 0.4) !important';
          }
        } else {
          // Inactive state: normal border, no glow, normal size
          pill.style.border = '2px solid var(--dark-border)';
          pill.style.boxShadow = 'none';
          pill.style.transform = 'scale(1)';
          pill.style.zIndex = '1';
          // Restore default background
          if (bucket === 'worse') {
            pill.style.background = 'rgba(239, 68, 68, 0.2)';
          } else if (bucket === 'same') {
            pill.style.background = 'rgba(245, 158, 11, 0.2)';
          } else {
            pill.style.background = 'rgba(16, 185, 129, 0.2)';
          }
        }
      });
    }
    
    // Helper to restore hover state (considering selection) - no longer needed with CSS hover
    window.updateTrafficLightHover = function(element) {
      // CSS handles hover now, but keep for compatibility
    };
    
    // Update traffic light counts and display
    function updateTrafficLights() {
      let tasks = window.optimisationModuleState.allTasks || [];
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      // Apply other existing filters (keyword, url, type, status) - same as table uses
      // Get filter values
      const keywordFilter = document.getElementById('optimisation-filter-keyword')?.value?.toLowerCase().trim() || '';
      const urlFilter = document.getElementById('optimisation-filter-url')?.value?.toLowerCase().trim() || '';
      const typeFilter = document.getElementById('optimisation-filter-type')?.value || '';
      const statusFilter = document.getElementById('optimisation-filter-status')?.value || '';
      
      // Apply filters
      if (keywordFilter) {
        tasks = tasks.filter(t => (t.keyword || '').toLowerCase().includes(keywordFilter));
      }
      if (urlFilter) {
        tasks = tasks.filter(t => (t.target_url || '').toLowerCase().includes(urlFilter));
      }
      if (typeFilter) {
        tasks = tasks.filter(t => t.task_type === typeFilter);
      }
      if (statusFilter) {
        tasks = tasks.filter(t => t.status === statusFilter);
      }
      
      // Get scope
      const scope = window.optimisationModuleState.scope || 'active_cycle';
      
      // Compute traffic light counts
      const counts = computeTrafficLightCounts(tasks, scope);
      
      // Update display
      const metricMap = {
        all_metrics: 'all-metrics',
        ctr_28d: 'ctr',
        impressions_28d: 'impressions',
        clicks_28d: 'clicks',
        current_rank: 'rank',
        ai_citations: 'ai-citations',
        ai_overview: 'ai-overview',
        opportunity_score: 'opportunity-score'
      };
      
      for (const [metricKey, displayKey] of Object.entries(metricMap)) {
        const worseEl = document.getElementById(`objective-${displayKey}-red`);
        const sameEl = document.getElementById(`objective-${displayKey}-amber`);
        const betterEl = document.getElementById(`objective-${displayKey}-green`);
        
        if (worseEl) worseEl.textContent = counts[metricKey].worse || 0;
        if (sameEl) sameEl.textContent = counts[metricKey].same || 0;
        if (betterEl) betterEl.textContent = counts[metricKey].better || 0;
      }
    }
    
    // Apply all filters to filteredTasks (including metric traffic filter)
    function applyOptimisationFilters() {
      let tasks = [...window.optimisationModuleState.allTasks];
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      // Apply keyword filter
      const keywordFilter = document.getElementById('optimisation-filter-keyword')?.value?.toLowerCase().trim() || '';
      if (keywordFilter) {
        tasks = tasks.filter(t => (t.keyword || '').toLowerCase().includes(keywordFilter));
      }
      
      // Apply URL filter
      const urlFilter = document.getElementById('optimisation-filter-url')?.value?.toLowerCase().trim() || '';
      if (urlFilter) {
        tasks = tasks.filter(t => (t.target_url || '').toLowerCase().includes(urlFilter));
      }
      
      // Apply type filter
      const typeFilter = document.getElementById('optimisation-filter-type')?.value || '';
      if (typeFilter) {
        tasks = tasks.filter(t => t.task_type === typeFilter);
      }
      
      // Apply status filter
      const statusFilter = document.getElementById('optimisation-filter-status')?.value || '';
      if (statusFilter) {
        tasks = tasks.filter(t => t.status === statusFilter);
      }
      
      // Apply trafficKpiOnly filter (CTR/Impressions/Clicks objectives only)
      if (window.optimisationModuleState.trafficKpiOnly) {
        const trafficKpis = new Set(['ctr_28d', 'impressions_28d', 'clicks_28d']);
        tasks = tasks.filter(task => {
          const objectiveKpiKey = task.objectiveKpiKey || (task.objective && task.objective.kpi) || 
                                  (task.cycle && task.cycle.objective && task.cycle.objective.kpi);
          return objectiveKpiKey && trafficKpis.has(objectiveKpiKey);
        });
      }
      
      // Apply clickRelatedOnly filter (tasks where clicks delta is computable)
      if (window.optimisationModuleState.clickRelatedOnly) {
        const scope = window.optimisationModuleState.scope || 'active_cycle';
        const trafficKpis = new Set(['ctr_28d', 'impressions_28d', 'clicks_28d']);
        tasks = tasks.filter(task => {
          // Must have traffic KPI objective
          const objectiveKpiKey = task.objectiveKpiKey || (task.objective && task.objective.kpi) || 
                                  (task.cycle && task.cycle.objective && task.cycle.objective.kpi);
          if (!objectiveKpiKey || !trafficKpis.has(objectiveKpiKey)) {
            return false;
          }
          
          // Must be able to compute clicks delta
          const activeCycle = scope === 'active_cycle' 
            ? ((task.cycles && task.cycles.find(c => c.is_active || c.id === task.active_cycle_id)) || null)
            : null;
          const measurements = task.measurements || [];
          const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);
          
          if (baselineLatest && baselineLatest.baseline && baselineLatest.latest) {
            // Check if clicks can be computed
            const baselineClicks = getMetricValue(baselineLatest.baseline, 'clicks_28d');
            const latestClicks = getMetricValue(baselineLatest.latest, 'clicks_28d');
            if (baselineClicks != null && latestClicks != null) {
              return true; // Direct clicks available
            }
            
            // Check CTR  Impressions fallback
            const baselineCtr = getMetricValue(baselineLatest.baseline, 'ctr_28d');
            const latestCtr = getMetricValue(baselineLatest.latest, 'ctr_28d');
            const baselineImpr = getMetricValue(baselineLatest.baseline, 'impressions_28d');
            const latestImpr = getMetricValue(baselineLatest.latest, 'impressions_28d');
            if (baselineCtr != null && baselineImpr != null && latestCtr != null && latestImpr != null) {
              return true; // Can compute from CTR  Impressions
            }
          }
          
          // Fallback: check task.baseline_metrics/latest_metrics
          if (task.baseline_metrics && task.latest_metrics) {
            const baselineClicks = getMetricValue(task.baseline_metrics, 'clicks_28d');
            const latestClicks = getMetricValue(task.latest_metrics, 'clicks_28d');
            if (baselineClicks != null && latestClicks != null) {
              return true;
            }
            
            const baselineCtr = getMetricValue(task.baseline_metrics, 'ctr_28d');
            const latestCtr = getMetricValue(task.latest_metrics, 'ctr_28d');
            const baselineImpr = getMetricValue(task.baseline_metrics, 'impressions_28d');
            const latestImpr = getMetricValue(task.latest_metrics, 'impressions_28d');
            if (baselineCtr != null && baselineImpr != null && latestCtr != null && latestImpr != null) {
              return true;
            }
          }
          
          return false; // Cannot compute clicks delta
        });
      }
      
      // Apply metric traffic filter
      const metricTrafficFilter = window.optimisationModuleState.metricTrafficFilter;
      if (metricTrafficFilter) {
        const scope = window.optimisationModuleState.scope || 'active_cycle';
        const metricKeys = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
        
        tasks = tasks.filter(task => {
          // Only active tasks can match
          if (!isActiveStatus(task.status)) {
            return false;
          }
          
          // Get active cycle if scope is 'active_cycle'
          const activeCycle = scope === 'active_cycle' 
            ? ((task.cycles && task.cycles.find(c => c.is_active || c.id === task.active_cycle_id)) || null)
            : null;
          
          // Get measurements
          const measurements = task.measurements || [];
          const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);
          
          if (!baselineLatest) {
            // Task doesn't have enough measurements, exclude
            return false;
          }
          
          // Handle "all_metrics" filter: check that majority of metrics (at least 3 out of 6) match the bucket
          if (metricTrafficFilter.metricKey === 'all_metrics') {
            const classifications = [];
            for (const metricKey of metricKeys) {
              const classification = classifyMetric(
                metricKey,
                baselineLatest.baseline,
                baselineLatest.latest
              );
              if (classification) {
                classifications.push(classification);
              }
            }
            
            // Count occurrences of the filter bucket
            const bucketCount = classifications.filter(cls => cls === metricTrafficFilter.bucket).length;
            
            // At least 4 metrics must match the bucket (majority)
            return bucketCount >= 4;
          } else {
            // Single metric filter
            const classification = classifyMetric(
              metricTrafficFilter.metricKey,
              baselineLatest.baseline,
              baselineLatest.latest
            );
            
            // Include only if classification matches the filter bucket
            return classification === metricTrafficFilter.bucket;
          }
        });
      }
      
      window.optimisationModuleState.filteredTasks = tasks;
    }
    
    // Helper: Compute estimated extra clicks (28d) for a single task
    // Supports traffic KPIs: ctr_28d, impressions_28d, clicks_28d
    function computeEstimatedExtraClicks28d(task) {
      // Try multiple sources for objective
      const objective = task.objective || (task.cycle && task.cycle.objective) || null;
      const objectiveKpiKey = task.objectiveKpiKey || (objective && objective.kpi);
      const baselineValue = task.baselineValue;
      const latestValue = task.latestValue;
      const latestMetrics = task.latest_metrics || {};
      
      // Must have objective and latest value
      if (!objectiveKpiKey || !objective || latestValue == null) {
        return 0;
      }
      
      // Calculate target value (normalize delta vs absolute)
      let targetValue = null;
      if (objective.target_type === 'delta') {
        // Delta: target = baseline + delta
        if (baselineValue != null) {
          targetValue = baselineValue + objective.target;
        }
      } else {
        // Absolute: target = target value directly
        targetValue = objective.target;
      }
      
      if (targetValue == null) {
        return 0;
      }
      
      // Compute based on KPI type
      switch (objectiveKpiKey) {
        case 'ctr_28d': {
          // CTR: extra clicks = impressions * (target_ctr - latest_ctr)
          // Handle both gsc_ prefixed fields (from baseline) and regular fields
          const impressions = latestMetrics.gsc_impressions_28d ?? latestMetrics.impressions_28d ?? 0;
          if (impressions > 0 && targetValue > latestValue) {
            const deltaCtr = targetValue - latestValue;
            if (deltaCtr > 0) {
              return Math.round(impressions * deltaCtr);
            }
          }
          return 0;
        }
        
        case 'impressions_28d': {
          // Impressions: extra clicks = (target_impressions - latest_impressions) * latest_ctr
          // Handle both gsc_ prefixed fields (from baseline) and regular fields
          const latestCtr = latestMetrics.gsc_ctr_28d ?? latestMetrics.ctr_28d ?? 0;
          if (targetValue > latestValue && latestCtr > 0) {
            const deltaImpr = targetValue - latestValue;
            if (deltaImpr > 0) {
              return Math.round(deltaImpr * latestCtr);
            }
          }
          return 0;
        }
        
        case 'clicks_28d': {
          // Clicks: extra clicks = target_clicks - latest_clicks (direct delta)
          if (targetValue > latestValue) {
            const deltaClicks = targetValue - latestValue;
            if (deltaClicks > 0) {
              return Math.round(deltaClicks);
            }
          }
          return 0;
        }
        
        default:
          return 0;
      }
    }

    // Compute potential extra clicks (28d) with deduplication
    // Groups by target_url to prevent double-counting when multiple tasks target the same page
    // Returns: { potential: number, actual: number }
    function computePotentialAndActualClicks28d(tasks, scope) {
      const trafficKpis = new Set(['ctr_28d', 'impressions_28d', 'clicks_28d']);
      
      // Group tasks by target_url for deduplication
      // Deduplication strategy:
      // - Potential: MAX per URL (avoids fantasy stacking when multiple tasks target same page)
      // - Actual: SUM per URL (measured changes can legitimately stack across tasks)
      const tasksByUrl = {};
      for (const task of tasks) {
        const objectiveKpiKey = task.objectiveKpiKey || (task.objective && task.objective.kpi) || 
                                (task.cycle && task.cycle.objective && task.cycle.objective.kpi);
        if (!objectiveKpiKey || !trafficKpis.has(objectiveKpiKey)) {
          continue; // Skip non-traffic KPIs
        }
        
        const targetUrl = task.target_url_clean || task.target_url || 'unknown';
        if (!tasksByUrl[targetUrl]) {
          tasksByUrl[targetUrl] = [];
        }
        tasksByUrl[targetUrl].push(task);
      }
      
      let totalPotential = 0;
      let totalActual = 0;
      
      // Debug: count included tasks for Actual calculation
      let includedTasksCount = 0;
      
      // Process each URL group
      for (const [url, urlTasks] of Object.entries(tasksByUrl)) {
        // For potential: take MAX per URL (avoid fantasy stacking)
        // For actual: sum within group (it's measured, so multiple tasks can contribute)
        let maxPotential = 0;
        let sumActual = 0;
        
        for (const task of urlTasks) {
          // Get active cycle if scope is 'active_cycle'
          const activeCycle = scope === 'active_cycle' 
            ? ((task.cycles && task.cycles.find(c => c.is_active || c.id === task.active_cycle_id)) || null)
            : null;
          const measurements = task.measurements || [];
          const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);
          
          // Potential: compute estimated extra clicks (uses task.objective and task.baselineValue/latestValue)
          const potential = computeEstimatedExtraClicks28d(task);
          maxPotential = Math.max(maxPotential, potential);
          
          // Actual: compute measured click delta
          // Only include if clicks can be computed (exclude if neither clicks nor CTRImpressions available)
          let actual = null; // null means cannot compute
          
          if (baselineLatest && baselineLatest.baseline && baselineLatest.latest) {
            // Use measurements if available
            actual = computeActualClickDeltaForTask(task, baselineLatest.baseline, baselineLatest.latest);
          } else if (task.baseline_metrics && task.latest_metrics) {
            // Fallback to task's baseline_metrics/latest_metrics
            actual = computeActualClickDeltaForTask(task, task.baseline_metrics, task.latest_metrics);
          } else if (task.baselineValue != null && task.latestValue != null) {
            // Last resort: use task's baselineValue/latestValue if this is for clicks_28d KPI
            const objectiveKpiKey = task.objectiveKpiKey || (task.objective && task.objective.kpi) || 
                                    (task.cycle && task.cycle.objective && task.cycle.objective.kpi);
            if (objectiveKpiKey === 'clicks_28d') {
              actual = task.latestValue - task.baselineValue;
            }
            // For CTR/Impressions, we can't compute clicks from just baselineValue/latestValue
            // (we'd need impressions or CTR separately), so actual remains null
          }
          
          // Only include if actual is not null (clicks can be computed)
          if (actual != null) {
            sumActual += actual;
            includedTasksCount++;
          }
          // If actual is null, exclude this task (don't treat as 0)
        }
        
        totalPotential += maxPotential;
        totalActual += sumActual;
      }
      
      // Debug log (not shown in UI, but available in console)
      console.log('[computePotentialAndActualClicks28d] Included tasks for Actual:', includedTasksCount);
      
      return {
        potential: Math.round(totalPotential),
        actual: Math.round(totalActual),
        includedTasksCount // For debugging
      };
    }
    
    // Compute actual click delta for a single task
    // Returns click change from baseline  latest (can be negative)
    // Returns null if clicks cannot be computed (neither clicks nor CTRImpressions available)
    // Accepts either measurement objects or metric objects
    function computeActualClickDeltaForTask(task, baseline, latest) {
      // Prefer direct clicks_28d if available
      const baselineClicks = getMetricValue(baseline, 'clicks_28d');
      const latestClicks = getMetricValue(latest, 'clicks_28d');
      
      if (baselineClicks != null && latestClicks != null) {
        return latestClicks - baselineClicks;
      }
      
      // Fallback: compute from CTR  Impressions
      const baselineCtr = getMetricValue(baseline, 'ctr_28d');
      const latestCtr = getMetricValue(latest, 'ctr_28d');
      const baselineImpr = getMetricValue(baseline, 'impressions_28d');
      const latestImpr = getMetricValue(latest, 'impressions_28d');
      
      if (baselineCtr != null && baselineImpr != null && latestCtr != null && latestImpr != null) {
        // CTR is stored as ratio (0-1), so multiply by impressions to get clicks
        const baselineComputedClicks = baselineImpr * baselineCtr;
        const latestComputedClicks = latestImpr * latestCtr;
        return latestComputedClicks - baselineComputedClicks;
      }
      
      return null; // Cannot compute clicks delta (exclude from sum)
    }

    // Build Chart 1: Estimated Extra Clicks (28d) by KPI
    // Only include traffic KPIs where "extra clicks" is meaningful: CTR, Impressions, Clicks
    function buildEstimatedClicksByKpi(filteredTasks) {
      // Define allowed traffic KPIs only
      const allowedTrafficKpis = new Set(['ctr_28d', 'impressions_28d', 'clicks_28d']);
      
      const kpiBuckets = {
        'ctr_28d': { label: 'CTR (28d)', sum: 0, count: 0 },
        'impressions_28d': { label: 'Impressions (28d)', sum: 0, count: 0 },
        'clicks_28d': { label: 'Clicks (28d)', sum: 0, count: 0 },
        'no_objective': { label: 'No Traffic Objective', sum: 0, count: 0 }
      };
      
      for (const task of filteredTasks) {
        const extraClicks = computeEstimatedExtraClicks28d(task);
        const objectiveKpiKey = task.objectiveKpiKey || (task.objective && task.objective.kpi) ||
                                (task.cycle && task.cycle.objective && task.cycle.objective.kpi);
        
        // Only include if objective KPI is a traffic KPI
        if (objectiveKpiKey && allowedTrafficKpis.has(objectiveKpiKey) && kpiBuckets[objectiveKpiKey]) {
          kpiBuckets[objectiveKpiKey].sum += extraClicks;
          kpiBuckets[objectiveKpiKey].count += 1;
        } else {
          // Tasks with no objective, or non-traffic KPIs (Rank, AI Citations, AI Overview, etc.) go to "No Traffic Objective"
          kpiBuckets['no_objective'].sum += extraClicks;
          kpiBuckets['no_objective'].count += 1;
        }
      }
      
      // Filter out buckets with zero sum (remove "No Traffic Objective" if always 0)
      const result = [];
      for (const [kpi, data] of Object.entries(kpiBuckets)) {
        // Only include if sum > 0 (exclude zero-sum buckets)
        if (data.sum > 0) {
          result.push({ kpi, label: data.label, sum: data.sum, count: data.count });
        }
      }
      
      return result;
    }

    // Build Chart 2: Median Delta Over Time for Selected KPI
    function buildMedianDeltaTrend(filteredTasks, selectedKpi, scope, weeks = 12) {
      if (!selectedKpi) return { weeks: [], medians: [], sampleSizes: [] };
      
      // Get measurements for all tasks in scope
      const weekDeltas = new Map(); // weekKey -> [deltas from all tasks]
      
      for (const task of filteredTasks) {
        const activeCycle = scope === 'active_cycle' 
          ? ((task.cycles && task.cycles.find(c => c.is_active || c.id === task.active_cycle_id)) || null)
          : null;
        const measurements = task.measurements || [];
        
        // Filter measurements by scope
        let eligibleMeasurements = [...measurements];
        if (scope === 'active_cycle' && activeCycle) {
          const cycleStartDate = activeCycle.start_date ? new Date(activeCycle.start_date) : 
                                (activeCycle.started_at ? new Date(activeCycle.started_at) : null);
          if (cycleStartDate) {
            eligibleMeasurements = eligibleMeasurements.filter(m => {
              const mDate = m.captured_at ? new Date(m.captured_at) : null;
              return mDate && mDate >= cycleStartDate;
            });
          }
        }
        
        if (eligibleMeasurements.length < 2) continue;
        
        // Sort by date
        eligibleMeasurements.sort((a, b) => {
          const dateA = a.captured_at ? new Date(a.captured_at) : new Date(0);
          const dateB = b.captured_at ? new Date(b.captured_at) : new Date(0);
          return dateA - dateB;
        });
        
        // Group measurements by week
        const measurementsByWeek = new Map();
        for (const m of eligibleMeasurements) {
          if (!m.captured_at) continue;
          const weekKey = weekStartISO(m.captured_at);
          if (!measurementsByWeek.has(weekKey)) {
            measurementsByWeek.set(weekKey, []);
          }
          measurementsByWeek.get(weekKey).push(m);
        }
        
        // For each week, compute delta if we have at least 2 measurements
        for (const [weekKey, weekMeasurements] of measurementsByWeek.entries()) {
          if (weekMeasurements.length < 2) continue;
          
          // Sort by date within week
          weekMeasurements.sort((a, b) => {
            const dateA = a.captured_at ? new Date(a.captured_at) : new Date(0);
            const dateB = b.captured_at ? new Date(b.captured_at) : new Date(0);
            return dateA - dateB;
          });
          
          const startValue = getMetricValue(weekMeasurements[0], selectedKpi);
          const endValue = getMetricValue(weekMeasurements[weekMeasurements.length - 1], selectedKpi);
          
          if (startValue == null || endValue == null) continue;
          
          // Compute delta with correct units
          let delta;
          if (selectedKpi === 'ctr_28d') {
            delta = (endValue - startValue) * 100; // percentage points
          } else if (selectedKpi === 'current_rank') {
            delta = startValue - endValue; // lower is better, so invert
          } else {
            delta = endValue - startValue;
          }
          
          if (!weekDeltas.has(weekKey)) {
            weekDeltas.set(weekKey, []);
          }
          weekDeltas.get(weekKey).push(delta);
        }
      }
      
      // Get last N weeks
      const now = new Date();
      const weekKeys = [];
      for (let i = weeks - 1; i >= 0; i--) {
        const weekDate = new Date(now);
        weekDate.setDate(weekDate.getDate() - (i * 7));
        weekKeys.push(weekStartISO(weekDate));
      }
      
      // Compute medians for each week
      const result = {
        weeks: [],
        medians: [],
        sampleSizes: []
      };
      
      for (const weekKey of weekKeys) {
        const deltas = weekDeltas.get(weekKey) || [];
        result.weeks.push(weekKey);
        if (deltas.length > 0) {
          result.medians.push(median(deltas));
          result.sampleSizes.push(deltas.length);
        } else {
          result.medians.push(null);
          result.sampleSizes.push(0);
        }
      }
      
      return result;
    }

    // Update timeseries charts
    function updateTimeseriesCharts() {
      // Use the SAME filteredTasks as the table (includes all filters + scope + traffic-pill filter)
      let filteredTasks = window.optimisationModuleState.filteredTasks || [];
      
      // Filter out test tasks if checkbox is unchecked (same as table)
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        filteredTasks = filteredTasks.filter(t => !t.is_test_task);
      }
      
      const scope = window.optimisationModuleState.scope || 'active_cycle';
      
      // PART 1: Estimated Extra Clicks (28d) by KPI
      const estimatedClicksByKpi = buildEstimatedClicksByKpi(filteredTasks);
      
      // PART 1B: Median Delta Over Time for Selected KPI
      const selectedKpiForTrend = (window.optimisationModuleState && window.optimisationModuleState.selectedKpiForTrend) || 'ctr_28d';
      const medianDeltaTrend = buildMedianDeltaTrend(filteredTasks, selectedKpiForTrend, scope, 12);
      
      // PART 2: Median Delta by KPI (Last 28d) - only tasks with latest measurement in last 28 days
      const twentyEightDaysAgo = new Date();
      twentyEightDaysAgo.setDate(twentyEightDaysAgo.getDate() - 28);
      
      const eligibleTasks = filteredTasks.filter(task => {
        const latestMeasurement = getLatestMeasurementInScope(task, scope);
        if (!latestMeasurement || !latestMeasurement.captured_at) {
          return false;
        }
        const latestDate = new Date(latestMeasurement.captured_at);
        return latestDate >= twentyEightDaysAgo;
      });
      
      // Compute deltas for each KPI
      const deltasByKpi = {};
      const kpiList = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
      
      for (const task of eligibleTasks) {
        const activeCycle = scope === 'active_cycle' 
          ? ((task.cycles && task.cycles.find(c => c.is_active || c.id === task.active_cycle_id)) || null)
          : null;
        const measurements = task.measurements || [];
        const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);
        
        if (!baselineLatest) {
          continue;
        }
        
        // Compute delta for each KPI
        for (const kpi of kpiList) {
          const delta = computeDeltaForKPI(kpi, baselineLatest.baseline, baselineLatest.latest);
          if (delta != null) {
            if (!deltasByKpi[kpi]) {
              deltasByKpi[kpi] = [];
            }
            deltasByKpi[kpi].push(delta);
            // Log rank deltas for debugging
            if (kpi === 'current_rank') {
              debugLog(`[Rank Chart] Task "${task.keyword_text || task.target_url || 'unknown'}" delta: baseline=${baselineLatest.baseline?.current_rank}, latest=${baselineLatest.latest?.current_rank}, delta=${delta}`, 'info');
            }
          }
        }
      }
      
      // TEMP: Log raw CTR deltas for debugging
      if (deltasByKpi.ctr_28d && deltasByKpi.ctr_28d.length > 0) {
        console.log("[KPI MEDIAN] CTR raw deltas (from computeDeltaForKPI):", deltasByKpi.ctr_28d);
        console.log("[KPI MEDIAN] CTR raw deltas sample (first 5):", deltasByKpi.ctr_28d.slice(0, 5));
      }
      
      // Compute medians and include task counts
      const medianDeltaByKpi = [];
      for (const [kpi, deltas] of Object.entries(deltasByKpi)) {
        if (deltas.length > 0) {
          const med = median(deltas);
          if (med != null) {
            medianDeltaByKpi.push({ kpi, value: med, count: deltas.length });
            // TEMP: Log CTR median before formatting
            if (kpi === 'ctr_28d') {
              console.log("[KPI MEDIAN] CTR median BEFORE format:", med);
              console.log("[KPI MEDIAN] CTR median absolute value:", Math.abs(med));
              if (Math.abs(med) > 20) {
                console.warn("[KPI MEDIAN] CTR delta seems too large:", med, "pp. Contributing deltas:", deltas.slice(0, 10));
              }
            }
          }
        }
      }
      
      // Sort to match traffic light order: CTR, Impressions, Clicks, Rank, AI Citations, AI Overview
      const kpiOrder = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
      medianDeltaByKpi.sort((a, b) => {
        const indexA = kpiOrder.indexOf(a.kpi);
        const indexB = kpiOrder.indexOf(b.kpi);
        // If KPI not in order list, put it at the end
        if (indexA === -1 && indexB === -1) return a.kpi.localeCompare(b.kpi);
        if (indexA === -1) return 1;
        if (indexB === -1) return -1;
        return indexA - indexB;
      });
      
      const timeseries = {
        estimatedClicksByKpi,
        medianDeltaTrend,
        selectedKpiForTrend,
        medianDeltaByKpi
      };
      
      // Render Chart 1: Estimated Extra Clicks (28d) by KPI
      const clicksCanvas = document.getElementById('chart-estimated-clicks-by-kpi');
      if (clicksCanvas && timeseries.estimatedClicksByKpi) {
        const ctx = clicksCanvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        // Get width from container to ensure it fills properly
        const container = document.getElementById('chart-left-container');
        const displayWidth = (container ? container.offsetWidth : clicksCanvas.offsetWidth) || 400;
        const displayHeight = 280;
        
        clicksCanvas.width = displayWidth * dpr;
        clicksCanvas.height = displayHeight * dpr;
        clicksCanvas.style.width = displayWidth + 'px';
        clicksCanvas.style.height = displayHeight + 'px';
        ctx.scale(dpr, dpr);
        
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        
        const data = timeseries.estimatedClicksByKpi;
        if (!data || data.length === 0) {
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No data', displayWidth / 2, displayHeight / 2);
        } else {
          const maxSum = Math.max(...data.map(d => d.sum), 1);
          const padding = { top: 20, right: 20, bottom: 70, left: 60 };
          const chartWidth = displayWidth - padding.left - padding.right;
          const chartHeight = displayHeight - padding.top - padding.bottom;
          const barWidth = chartWidth / data.length * 0.7;
          const barSpacing = chartWidth / data.length * 0.3;
          
          // Draw axes
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(padding.left, padding.top);
          ctx.lineTo(padding.left, displayHeight - padding.bottom);
          ctx.lineTo(displayWidth - padding.right, displayHeight - padding.bottom);
          ctx.stroke();
          
          // Draw y-axis label
          ctx.save();
          ctx.translate(15, displayHeight / 2);
          ctx.rotate(-Math.PI / 2);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 18px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Estimated Remaining Clicks (28d)', 0, 0);
          ctx.restore();
          
          // Draw y-axis ticks and labels
          const yTicks = 5;
          for (let i = 0; i <= yTicks; i++) {
            const value = (maxSum / yTicks) * i;
            const y = displayHeight - padding.bottom - (i / yTicks) * chartHeight;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(padding.left, y);
            ctx.lineTo(displayWidth - padding.right, y);
            ctx.stroke();
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'right';
            const labelText = value >= 1000 ? (value / 1000).toFixed(1) + 'k' : Math.round(value).toString();
            ctx.fillText(labelText, padding.left - 10, y + 4);
          }
          
          // Draw bars
          data.forEach((d, i) => {
            const x = padding.left + i * (barWidth + barSpacing) + barSpacing / 2;
            const barHeight = (d.sum / maxSum) * chartHeight;
            const y = displayHeight - padding.bottom - barHeight;
            
            // Green bars
            ctx.fillStyle = '#10b981';
            ctx.fillRect(x, y, barWidth, barHeight);
            
            // Value label on top of bar
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            const valueText = d.sum >= 1000 ? (d.sum / 1000).toFixed(1) + 'k' : Math.round(d.sum).toString();
            ctx.fillText(valueText, x + barWidth / 2, y - 5);
            
            // Label below bar
            ctx.font = 'bold 11px sans-serif';
            const labelLines = d.label.split(' ');
            labelLines.forEach((line, lineIdx) => {
              ctx.fillText(line, x + barWidth / 2, displayHeight - padding.bottom + 12 + (lineIdx * 12));
            });
          });
        }
      }
      
      // Render Chart 2: Median Delta Over Time for Selected KPI
      const trendCanvas = document.getElementById('chart-median-delta-trend');
      if (trendCanvas && timeseries.medianDeltaTrend) {
        const ctx = trendCanvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        // Get width from container to ensure it fills properly
        const container = document.getElementById('chart-left-container');
        const displayWidth = (container ? container.offsetWidth : trendCanvas.offsetWidth) || 400;
        const displayHeight = 280;
        
        trendCanvas.width = displayWidth * dpr;
        trendCanvas.height = displayHeight * dpr;
        trendCanvas.style.width = displayWidth + 'px';
        trendCanvas.style.height = displayHeight + 'px';
        ctx.scale(dpr, dpr);
        
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        
        const trend = timeseries.medianDeltaTrend;
        const kpiLabels = {
          'ctr_28d': 'CTR (pp)',
          'impressions_28d': 'Impressions',
          'clicks_28d': 'Clicks',
          'current_rank': 'Rank  (lower better)',
          'ai_citations': 'AI Citations',
          'opportunity_score': 'Opportunity Score'
        };
        
        if (!trend.weeks || trend.weeks.length === 0 || trend.medians.every(m => m == null)) {
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Not enough history', displayWidth / 2, displayHeight / 2);
        } else {
          const validMedians = trend.medians.filter(m => m != null);
          if (validMedians.length === 0) {
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Not enough history', displayWidth / 2, displayHeight / 2);
          } else {
            const maxAbs = Math.max(...validMedians.map(m => Math.abs(m)), 1);
            const padding = { top: 20, right: 20, bottom: 70, left: 60 };
            const chartWidth = displayWidth - padding.left - padding.right;
            const chartHeight = displayHeight - padding.top - padding.bottom;
            const zeroY = displayHeight - padding.bottom - (maxAbs / (maxAbs * 2)) * chartHeight;
            
            // Draw axes
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, displayHeight - padding.bottom);
            ctx.lineTo(displayWidth - padding.right, displayHeight - padding.bottom);
            ctx.stroke();
            
            // Draw zero line
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, zeroY);
            ctx.lineTo(displayWidth - padding.right, zeroY);
            ctx.stroke();
            
            // Draw y-axis label based on KPI unit
            ctx.save();
            ctx.translate(15, displayHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'center';
            const selectedKpi = timeseries.selectedKpiForTrend;
            let yAxisLabel = 'Median Delta';
            if (selectedKpi === 'ctr_28d') {
              yAxisLabel = ' CTR (pp)';
            } else if (selectedKpi === 'current_rank') {
              yAxisLabel = ' Rank (lower is better)';
            } else if (selectedKpi === 'impressions_28d') {
              yAxisLabel = ' Impressions';
            } else if (selectedKpi === 'clicks_28d') {
              yAxisLabel = ' Clicks';
            } else if (selectedKpi === 'ai_citations') {
              yAxisLabel = ' AI Citations';
            } else if (selectedKpi === 'opportunity_score') {
              yAxisLabel = ' Opportunity Score';
            }
            ctx.fillText(yAxisLabel, 0, 0);
            ctx.restore();
            
            // Draw y-axis ticks and labels
            const yTicks = 5;
            for (let i = 0; i <= yTicks; i++) {
              const value = (maxAbs * 2 / yTicks) * i - maxAbs;
              const y = displayHeight - padding.bottom - (i / yTicks) * chartHeight;
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
              ctx.lineWidth = 0.5;
              ctx.beginPath();
              ctx.moveTo(padding.left, y);
              ctx.lineTo(displayWidth - padding.right, y);
              ctx.stroke();
              
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 14px sans-serif';
              ctx.textAlign = 'right';
              ctx.fillText(value.toFixed(1), padding.left - 10, y + 4);
            }
            
            // Draw x-axis week labels
            trend.weeks.forEach((weekKey, i) => {
              const x = padding.left + (i / (trend.weeks.length - 1 || 1)) * chartWidth;
              const weekDate = new Date(weekKey);
              const day = weekDate.getDate();
              const month = weekDate.getMonth() + 1;
              const weekLabel = `${day}/${month}`;
              
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 11px sans-serif';
              ctx.textAlign = 'center';
              ctx.fillText(weekLabel, x, displayHeight - padding.bottom + 18);
            });
            
            // Draw line
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            let hasMoved = false;
            trend.medians.forEach((med, i) => {
              if (med != null) {
                const x = padding.left + (i / (trend.weeks.length - 1 || 1)) * chartWidth;
                const y = displayHeight - padding.bottom - ((med + maxAbs) / (maxAbs * 2)) * chartHeight;
                if (!hasMoved) {
                  ctx.moveTo(x, y);
                  hasMoved = true;
                } else {
                  ctx.lineTo(x, y);
                }
              }
            });
            ctx.stroke();
            
            // Draw points with value labels
            ctx.fillStyle = '#3b82f6';
            trend.medians.forEach((med, i) => {
              if (med != null) {
                const x = padding.left + (i / (trend.weeks.length - 1 || 1)) * chartWidth;
                const y = displayHeight - padding.bottom - ((med + maxAbs) / (maxAbs * 2)) * chartHeight;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Show value label on last point, or all points if not too many
                const showLabel = (i === trend.medians.length - 1) || (trend.medians.length <= 8);
                if (showLabel) {
                  ctx.fillStyle = '#ffffff';
                  ctx.font = 'bold 10px sans-serif';
                  ctx.textAlign = 'center';
                  const valueText = med >= 0 ? `+${med.toFixed(1)}` : med.toFixed(1);
                  ctx.fillText(valueText, x, y - 10);
                  ctx.fillStyle = '#3b82f6'; // Reset for next point
                }
              }
            });
          }
        }
      }

      // Render Median Delta by KPI chart (with device pixel ratio for crisp rendering)
      const deltaCanvas = document.getElementById('chart-median-delta');
      if (deltaCanvas && timeseries.medianDeltaByKpi) {
        const ctx = deltaCanvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        // Get width from container to ensure it fills properly
        const container = deltaCanvas.parentElement;
        const displayWidth = (container ? container.offsetWidth : deltaCanvas.offsetWidth) || 400;
        const displayHeight = 280;
        
        // Set canvas internal size accounting for device pixel ratio for crisp rendering
        deltaCanvas.width = displayWidth * dpr;
        deltaCanvas.height = displayHeight * dpr;
        
        // Scale canvas CSS size to display size
        deltaCanvas.style.width = displayWidth + 'px';
        deltaCanvas.style.height = displayHeight + 'px';
        
        // Scale context to match device pixel ratio
        ctx.scale(dpr, dpr);
        
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        
        const data = timeseries.medianDeltaByKpi;
        if (data.length === 0) {
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No data', displayWidth / 2, displayHeight / 2);
        } else {
          const maxAbs = Math.max(...data.map(d => Math.abs(d.value)), 1);
          const padding = { top: 20, right: 20, bottom: 70, left: 60 };
          const chartWidth = displayWidth - padding.left - padding.right;
          const chartHeight = displayHeight - padding.top - padding.bottom;
          const barWidth = chartWidth / data.length * 0.7;
          const barSpacing = chartWidth / data.length * 0.3;
          const zeroY = displayHeight - padding.bottom - (maxAbs / (maxAbs * 2)) * chartHeight;
          
          // KPI label mapping
          const kpiLabels = {
            'ctr_28d': 'CTR (pp)',
            'impressions_28d': 'Impressions',
            'clicks_28d': 'Clicks',
            'current_rank': 'Rank (, lower better)',
            'ai_citations': 'AI Citations',
            'ai_overview': 'AI Overview'
          };
          
          // Draw y-axis label - bright white and much larger
          ctx.save();
          ctx.translate(15, displayHeight / 2);
          ctx.rotate(-Math.PI / 2);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 18px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Median Delta', 0, 0);
          ctx.restore();
          
          // Draw zero line - white
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(padding.left, zeroY);
          ctx.lineTo(displayWidth - padding.right, zeroY);
          ctx.stroke();
          
          // Draw y-axis ticks and labels - white and larger
          const yTicks = 5;
          for (let i = 0; i <= yTicks; i++) {
            const value = (maxAbs * 2 / yTicks) * i - maxAbs;
            const y = displayHeight - padding.bottom - (i / yTicks) * chartHeight;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(padding.left, y);
            ctx.lineTo(displayWidth - padding.right, y);
            ctx.stroke();
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'right';
            const label = value >= 0 ? `+${value.toFixed(1)}` : value.toFixed(1);
            ctx.fillText(label, padding.left - 10, y + 4);
          }
          
          // Draw bars
          data.forEach((d, i) => {
            const x = padding.left + i * (barWidth + barSpacing) + barSpacing / 2;
            // For rank, the delta is already inverted (baseline - latest), so positive = improvement
            // For other metrics, positive = improvement
            const isRank = d.kpi === 'current_rank';
            const barHeight = (Math.abs(d.value) / maxAbs) * chartHeight;
            const y = d.value >= 0 ? zeroY - barHeight : zeroY;
            
            // Rank: positive delta (lower rank = better) is green, negative (higher rank = worse) is red
            // Other metrics: positive delta (higher = better) is green, negative (lower = worse) is red
            ctx.fillStyle = d.value >= 0 ? '#10b981' : '#ef4444';
            ctx.fillRect(x, y, barWidth, barHeight);
            
            // Value label on bar
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            let valueText = '';
            if (d.kpi === 'ctr_28d') {
              // CTR delta is already in percentage points from computeDeltaForKPI
              // computeDeltaForKPI returns: (latestRatio - baselineRatio) * 100
              // So d.value is already in pp, NO further multiplication needed
              // TEMP: Log the value being formatted
              console.log("[KPI MEDIAN] CTR dataset value for bar label:", d.value);
              if (Math.abs(d.value) > 20) {
                console.error("[KPI MEDIAN] CTR delta seems too large - possible double scaling bug:", d.value, "pp");
              }
              const deltaPp = d.value; // Already in pp, use directly - NO multiplication
              valueText = (deltaPp >= 0 ? '+' : '') + deltaPp.toFixed(2) + 'pp';
              console.log("[KPI MEDIAN] CTR formatted label:", valueText);
            } else if (d.kpi === 'current_rank') {
              valueText = (d.value >= 0 ? '+' : '') + d.value.toFixed(1);
            } else {
              valueText = (d.value >= 0 ? '+' : '') + Math.round(d.value).toString();
            }
            // Position label above or below bar depending on direction
            const labelY = d.value >= 0 ? y - 5 : y + barHeight + 15;
            ctx.fillText(valueText, x + barWidth / 2, labelY);
            
            // Draw KPI label (horizontal, wrapped) - white and much larger
            const label = kpiLabels[d.kpi] || d.kpi.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            const labelX = x + barWidth / 2;
            const labelMaxWidth = barWidth * 0.95;
            
            ctx.font = 'bold 11px sans-serif';
            
            // Simple word wrapping: split on spaces if needed
            const words = label.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (const word of words) {
              const testLine = currentLine ? `${currentLine} ${word}` : word;
              const metrics = ctx.measureText(testLine);
              if (metrics.width > labelMaxWidth && currentLine) {
                lines.push(currentLine);
                currentLine = word;
              } else {
                currentLine = testLine;
              }
            }
            if (currentLine) lines.push(currentLine);
            
            // Draw lines centered under the bar
            const lineHeight = 12;
            const startY = displayHeight - padding.bottom + 15;
            lines.forEach((line, lineIdx) => {
              ctx.fillText(line, labelX, startY + (lineIdx * lineHeight));
            });
          });
        }
      }
      
      // Setup toggle buttons for left chart
      const clicksToggle = document.getElementById('chart-left-toggle-clicks');
      const trendToggle = document.getElementById('chart-left-toggle-trend');
      const kpiSelect = document.getElementById('chart-trend-kpi-select');
      const clicksCanvasEl = document.getElementById('chart-estimated-clicks-by-kpi');
      const trendCanvasEl = document.getElementById('chart-median-delta-trend');
      
      if (clicksToggle && trendToggle) {
        // Set initial state
        const currentView = window.optimisationModuleState.leftChartView || 'clicks';
        if (currentView === 'clicks') {
          if (clicksCanvasEl) clicksCanvasEl.style.display = 'block';
          if (trendCanvasEl) trendCanvasEl.style.display = 'none';
          if (kpiSelect) kpiSelect.style.display = 'none';
          const kpiLabelEl = document.getElementById('chart-trend-kpi-label');
          if (kpiLabelEl) kpiLabelEl.style.display = 'none';
          clicksToggle.classList.add('active');
          clicksToggle.style.background = 'var(--dark-brand)';
          clicksToggle.style.color = '#000';
          trendToggle.classList.remove('active');
          trendToggle.style.background = 'var(--dark-panel)';
          trendToggle.style.color = 'var(--dark-text)';
        } else {
          if (clicksCanvasEl) clicksCanvasEl.style.display = 'none';
          if (trendCanvasEl) trendCanvasEl.style.display = 'block';
          if (kpiSelect) kpiSelect.style.display = 'block';
          const kpiLabelEl = document.getElementById('chart-trend-kpi-label');
          if (kpiLabelEl) kpiLabelEl.style.display = 'inline';
          trendToggle.classList.add('active');
          trendToggle.style.background = 'var(--dark-brand)';
          trendToggle.style.color = '#000';
          clicksToggle.classList.remove('active');
          clicksToggle.style.background = 'var(--dark-panel)';
          clicksToggle.style.color = 'var(--dark-text)';
        }
        
        // Handle clicks toggle
        clicksToggle.addEventListener('click', () => {
          window.optimisationModuleState.leftChartView = 'clicks';
          if (clicksCanvasEl) {
            clicksCanvasEl.style.display = 'block';
            // Force resize after display change to fix canvas sizing
            setTimeout(() => updateTimeseriesCharts(), 10);
          }
          if (trendCanvasEl) trendCanvasEl.style.display = 'none';
          if (kpiSelect) kpiSelect.style.display = 'none';
          const kpiLabelEl = document.getElementById('chart-trend-kpi-label');
          if (kpiLabelEl) kpiLabelEl.style.display = 'none';
          clicksToggle.classList.add('active');
          clicksToggle.style.background = 'var(--dark-brand)';
          clicksToggle.style.color = '#000';
          trendToggle.classList.remove('active');
          trendToggle.style.background = 'var(--dark-panel)';
          trendToggle.style.color = 'var(--dark-text)';
          
          // Update title and subtitle
          const titleEl = document.getElementById('chart-left-title');
          const subtitleEl = document.getElementById('chart-left-subtitle');
          if (titleEl) titleEl.textContent = 'Estimated Gap to Target (28d)  Clicks Potential';
          if (subtitleEl) subtitleEl.textContent = 'Sum of remaining clicks needed to hit each task\'s objective (traffic KPIs only). This is a target gap, not last-30d performance.';
        });
        
        // Handle trend toggle
        trendToggle.addEventListener('click', () => {
          window.optimisationModuleState.leftChartView = 'trend';
          if (clicksCanvasEl) clicksCanvasEl.style.display = 'none';
          if (trendCanvasEl) {
            trendCanvasEl.style.display = 'block';
            // Force resize after display change to fix canvas sizing
            setTimeout(() => updateTimeseriesCharts(), 10);
          }
          if (kpiSelect) kpiSelect.style.display = 'block';
          const kpiLabelEl = document.getElementById('chart-trend-kpi-label');
          if (kpiLabelEl) kpiLabelEl.style.display = 'inline';
          trendToggle.classList.add('active');
          trendToggle.style.background = 'var(--dark-brand)';
          trendToggle.style.color = '#000';
          clicksToggle.classList.remove('active');
          clicksToggle.style.background = 'var(--dark-panel)';
          clicksToggle.style.color = 'var(--dark-text)';
          
          // Update title and subtitle
          const titleEl = document.getElementById('chart-left-title');
          const subtitleEl = document.getElementById('chart-left-subtitle');
          if (titleEl) titleEl.textContent = 'Weekly Median Change  Selected KPI';
          if (subtitleEl) subtitleEl.textContent = 'Median week-to-week delta across tasks with measurements in that week (scope + filters apply).';
          
          // Update KPI label
          updateKpiLabel();
        });
      }
      
      // Function to update KPI label
      function updateKpiLabel() {
        const kpiLabelValueEl = document.getElementById('chart-trend-kpi-label-value');
        const selectedKpi = window.optimisationModuleState.selectedKpiForTrend || 'ctr_28d';
        const kpiLabelMap = {
          'ctr_28d': 'CTR (pp)',
          'impressions_28d': 'Impressions',
          'clicks_28d': 'Clicks',
          'current_rank': 'Rank',
          'ai_citations': 'AI Citations',
          'opportunity_score': 'Opportunity Score'
        };
        if (kpiLabelValueEl) {
          kpiLabelValueEl.textContent = kpiLabelMap[selectedKpi] || selectedKpi;
        }
      }
      
      // Handle KPI select change
      if (kpiSelect) {
        kpiSelect.value = window.optimisationModuleState.selectedKpiForTrend || 'ctr_28d';
        updateKpiLabel();
        kpiSelect.addEventListener('change', (e) => {
          window.optimisationModuleState.selectedKpiForTrend = e.target.value;
          updateKpiLabel();
          updateTimeseriesCharts();
        });
      }
      
      // Set initial title/subtitle based on current view
      const currentView = window.optimisationModuleState.leftChartView || 'clicks';
      const titleEl = document.getElementById('chart-left-title');
      const subtitleEl = document.getElementById('chart-left-subtitle');
      if (currentView === 'clicks') {
        if (titleEl) titleEl.textContent = 'Estimated Gap to Target (28d)  Clicks Potential';
        if (subtitleEl) subtitleEl.textContent = 'Sum of remaining clicks needed to hit each task\'s objective (traffic KPIs only). This is a target gap, not last-30d performance.';
      } else {
        if (titleEl) titleEl.textContent = 'Weekly Median Change  Selected KPI';
        if (subtitleEl) subtitleEl.textContent = 'Median week-to-week delta across tasks with measurements in that week (scope + filters apply).';
        updateKpiLabel();
      }
    }
    
    // Simple line chart renderer
    function renderLineChart(canvas, data, valueKey, label) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width || canvas.offsetWidth || 400;
      const height = canvas.height || canvas.offsetHeight || 200;
      canvas.width = width;
      canvas.height = height;
      
      ctx.clearRect(0, 0, width, height);
      
      if (!data || data.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No data', width / 2, height / 2);
        return;
      }
      
      const padding = 40;
      const plotWidth = width - padding * 2;
      const plotHeight = height - padding * 2;
      
      const values = data.map(d => d[valueKey] || 0);
      const max = Math.max(...values, 1);
      
      ctx.strokeStyle = '#3b82f6';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      data.forEach((d, idx) => {
        const x = padding + (idx / (data.length - 1 || 1)) * plotWidth;
        const y = padding + plotHeight - ((d[valueKey] || 0) / max) * plotHeight;
        if (idx === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      
      ctx.stroke();
      
      // Draw points
      ctx.fillStyle = '#3b82f6';
      data.forEach((d, idx) => {
        const x = padding + (idx / (data.length - 1 || 1)) * plotWidth;
        const y = padding + plotHeight - ((d[valueKey] || 0) / max) * plotHeight;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      });
    }
    
    // Simple bar chart renderer
    function renderBarChart(canvas, data, valueKey, label) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width || canvas.offsetWidth || 400;
      const height = canvas.height || canvas.offsetHeight || 200;
      canvas.width = width;
      canvas.height = height;
      
      ctx.clearRect(0, 0, width, height);
      
      if (!data || data.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No data', width / 2, height / 2);
        return;
      }
      
      const padding = 40;
      const plotWidth = width - padding * 2;
      const plotHeight = height - padding * 2;
      const barWidth = plotWidth / data.length;
      
      const values = data.map(d => d[valueKey] || 0);
      const max = Math.max(...values.map(Math.abs), 1);
      
      data.forEach((d, idx) => {
        const value = d[valueKey] || 0;
        const barHeight = (Math.abs(value) / max) * plotHeight;
        const x = padding + idx * barWidth;
        const y = padding + plotHeight - barHeight;
        
        ctx.fillStyle = value >= 0 ? '#10b981' : '#ef4444';
        ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
        
        // Label
        ctx.fillStyle = '#333';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        const kpiLabel = d.kpi ? d.kpi.replace(/_/g, ' ').substring(0, 10) : '';
        ctx.fillText(kpiLabel, x + barWidth / 2, height - 5);
      });
    }
    
    // Filter functions for KPI tiles
    window.filterByKPIRAG = function(kpi, rag) {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        return t.objectiveKpiKey === (kpi === 'ctr' ? 'ctr_28d' : null) && t.objectiveRag === rag;
      });
      renderOptimisationTasksTable();
    };
    
    window.filterByRankDelta = function(direction) {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        if (t.objectiveKpiKey !== 'current_rank' || t.delta == null) return false;
        if (direction === 'improved') return t.delta > 0;
        if (direction === 'worse') return t.delta < 0;
        if (direction === 'flat') return t.delta === 0;
        return false;
      });
      renderOptimisationTasksTable();
    };
    
    window.filterByAIGap = function() {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        return t.objectiveKpiKey === 'ai_citations' && t.latestValue === 0;
      });
      renderOptimisationTasksTable();
    };
    
    window.filterByNeedsMeasurement = function() {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        return t.needsMeasurement === true;
      });
      renderOptimisationTasksTable();
    };
    
    window.filterByOverdueCycles = function() {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        return t.objectiveRag === 'overdue';
      });
      renderOptimisationTasksTable();
    };

    // Load task events (B3)

    // Load task events (B3)
    // Render metrics snapshot (baseline + latest + deltas)
    function renderOptimisationMetricsSnapshot(task) {
      const container = document.getElementById('optimisation-metrics-snapshot');
      if (!container) return;

      // Use baseline_metrics and latest_metrics from task (may be cycle-specific from renderOptimisationMetricsSnapshotForCycle)
      const baseline = task.baseline_metrics || null;
      const latest = task.latest_metrics || null;

      if (!baseline && !latest) {
        container.innerHTML = '<div style="color: #666; font-style: italic; grid-column: 1 / -1;">No metrics snapshot available yet.</div>';
        return;
      }

      // Helper to format numbers (always show exact values; no "k" abbreviations)
      const formatNum = (val) => {
        if (val == null) return '';
        const n = (typeof val === 'number') ? val : (val !== '' && isFinite(Number(val)) ? Number(val) : null);
        if (n == null) return val;
        if (Number.isInteger(n)) return n.toLocaleString('en-GB');
        // Keep precision for ranks/positions etc
        return n.toLocaleString('en-GB', { maximumFractionDigits: 3 });
      };

      // Helper to calculate delta (numeric-safe)
      const calcDelta = (latestVal, baselineVal) => {
        const a = (typeof latestVal === 'number') ? latestVal : (latestVal != null && latestVal !== '' && isFinite(Number(latestVal)) ? Number(latestVal) : null);
        const b = (typeof baselineVal === 'number') ? baselineVal : (baselineVal != null && baselineVal !== '' && isFinite(Number(baselineVal)) ? Number(baselineVal) : null);
        if (a == null || b == null) return null;
        return a - b;
      };

      // Helper to format delta with color (handles rank where lower is better)
      const formatDelta = (delta, metricKey) => {
        if (delta == null) return { text: '', color: '#666' };
        // For CTR, delta is in ratio format (0-1), convert to percentage points
        if (metricKey === 'gsc_ctr_28d' || metricKey === 'ctr_28d') {
          const deltaPp = delta * 100; // Convert ratio delta to percentage points
          const sign = deltaPp >= 0 ? '+' : '';
          const formatted = `${sign}${deltaPp.toFixed(2)}pp`;
          if (deltaPp > 0) return { text: formatted, color: '#10b981' }; // Up - green
          if (deltaPp < 0) return { text: formatted, color: '#ef4444' }; // Down - red
          return { text: '0.00pp', color: '#f59e0b' }; // No change - amber
        }
        // For rank, lower is better (negative delta means improved rank = good)
        if (metricKey === 'current_rank') {
          const absDelta = Math.abs(delta);
          const roundedDelta = Math.round(absDelta * 10) / 10; // Round to 1 decimal place
          if (delta < 0) return { text: `${roundedDelta}`, color: '#10b981' }; // Improved (rank went down = better) - green with up arrow
          if (delta > 0) return { text: `${roundedDelta}`, color: '#ef4444' }; // Worsened (rank went up = worse) - red with down arrow
          return { text: '0', color: '#f59e0b' }; // No change - amber
        }
        // For other metrics, higher is typically better
        if (delta > 0) return { text: `+${formatNum(delta)}`, color: '#10b981' }; // Up - green
        if (delta < 0) return { text: formatNum(delta), color: '#ef4444' }; // Down - red
        return { text: '0', color: '#f59e0b' }; // No change - amber
      };

      // AI metrics for URL-only tasks (derived from Ranking & AI cited-URL lists).
      // This answers: "Is THIS page URL cited in AI Overviews, and how many citation items point to it?"
      // NOTE: AI data is keyword-driven, but citations can be attributed to pages by scanning cited URLs.
      window.getRankingAiCombinedRows = window.getRankingAiCombinedRows || function getRankingAiCombinedRows() {
        try {
          if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
            const s = RankingAiModule.state();
            if (s && Array.isArray(s.combinedRows) && s.combinedRows.length > 0) return s.combinedRows;
          }
        } catch (e) {
          // ignore
        }
        if (Array.isArray(window.rankingAiData) && window.rankingAiData.length > 0) return window.rankingAiData;
        try {
          const local = localStorage.getItem('rankingAiData');
          if (local) {
            const parsed = JSON.parse(local);
            if (parsed && Array.isArray(parsed.combinedRows)) return parsed.combinedRows;
          }
        } catch (e) {
          // ignore
        }
        return [];
      };

      window.computeAiMetricsForPageUrl = window.computeAiMetricsForPageUrl || function computeAiMetricsForPageUrl(pageUrl, combinedRows) {
        // CRITICAL: Use console.log first to ensure we see if function is called
        console.log('[computeAiMetricsForPageUrl] FUNCTION CALLED', pageUrl, combinedRows?.length);
        try {
          // ALWAYS log function entry for debugging
          console.log('[computeAiMetricsForPageUrl] ENTRY:', pageUrl, combinedRows?.length);
          debugLog(`[computeAiMetricsForPageUrl] ENTRY: pageUrl="${pageUrl}", combinedRows type=${typeof combinedRows}, isArray=${Array.isArray(combinedRows)}, length=${Array.isArray(combinedRows) ? combinedRows.length : 'N/A'}`, 'error');
          
          const rows = Array.isArray(combinedRows) ? combinedRows : [];
          
          // Normalize the target URL for comparison - handles all URL format variations
          const normalizeUrl = (url) => {
            if (!url) return '';
            let normalized = String(url).toLowerCase().trim();
            
            // Remove protocol
            normalized = normalized.replace(/^https?:\/\//, '');
            
            // Remove www.
            normalized = normalized.replace(/^www\./, '');
            
            // Remove query params and hash
            normalized = normalized.split('?')[0].split('#')[0];
            
            // Extract path portion (everything after domain, or entire string if no domain)
            // Handle both absolute URLs (with domain) and relative paths (with/without leading slash)
            let path = normalized;
            const domainMatch = normalized.match(/^[^\/]+(\/.*)?$/);
            if (domainMatch && normalized.includes('/')) {
              // Has domain - extract path
              path = normalized.split('/').slice(1).join('/');
            } else if (normalized.startsWith('/')) {
              // Relative path with leading slash
              path = normalized.substring(1);
            }
            // If no leading slash and no domain, it's already just the path
            
            // Remove leading and trailing slashes
            path = path.replace(/^\/+/, '').replace(/\/+$/, '');
            
            return path;
          };
        
          const canonTarget = normalizeUrl(pageUrl);
          debugLog(`[computeAiMetricsForPageUrl] Normalized URL: "${pageUrl}"  "${canonTarget}"`, 'error');
          
          // If we don't have ranking rows loaded, we don't know (avoid false negatives).
          if (!canonTarget || rows.length === 0) {
            debugLog(`[computeAiMetricsForPageUrl] No rows or no target URL: canonTarget="${canonTarget}", rowsLength=${rows.length}`, 'error');
            return { ai_overview: null, ai_citations: null };
          }
        
          // CRITICAL DEBUG: Log the exact normalized target for this URL
          if (canonTarget.includes('photography-courses-coventry')) {
            debugLog(`[computeAiMetricsForPageUrl] START (NEW LOGIC): pageUrl="${pageUrl}", canonTarget="${canonTarget}", rowsCount=${rows.length}`, 'error');
            debugLog(`[computeAiMetricsForPageUrl] DIAGNOSTIC: Normalization test - Input: "${pageUrl}"  Output: "${canonTarget}"`, 'error');
            
            // Check what fields are available in the first row
            if (rows.length > 0) {
              const firstRow = rows[0];
              const availableFields = Object.keys(firstRow).filter(k => 
                k.toLowerCase().includes('citation') || 
                k.toLowerCase().includes('ai') ||
                k.toLowerCase().includes('overview')
              );
              debugLog(`[computeAiMetricsForPageUrl] DIAGNOSTIC: Available AI-related fields in rows: ${JSON.stringify(availableFields)}`, 'error');
              
              // Check if ai_alan_citations exists and what it looks like
              if (firstRow.ai_alan_citations !== undefined) {
                debugLog(`[computeAiMetricsForPageUrl] DIAGNOSTIC: firstRow.ai_alan_citations type: ${typeof firstRow.ai_alan_citations}, isArray: ${Array.isArray(firstRow.ai_alan_citations)}, length: ${Array.isArray(firstRow.ai_alan_citations) ? firstRow.ai_alan_citations.length : 'N/A'}`, 'error');
                if (Array.isArray(firstRow.ai_alan_citations) && firstRow.ai_alan_citations.length > 0) {
                  debugLog(`[computeAiMetricsForPageUrl] DIAGNOSTIC: First citation sample: ${JSON.stringify(firstRow.ai_alan_citations[0])}`, 'error');
                }
              } else {
                debugLog(`[computeAiMetricsForPageUrl] DIAGNOSTIC: firstRow.ai_alan_citations is undefined`, 'error');
              }
            }
          }

          // NEW LOGIC: Find all keywords where ai_alan_citations array contains the target URL
          // This is the correct approach - citations are keyword-driven, not URL-driven
          const citingKeywords = [];
          let hasOverview = false;
          let totalCitationCount = 0; // Count total citations (not just unique keywords)
          
          // ENHANCED DIAGNOSTIC: Log target URL and sample of data structure
          if (canonTarget.includes('photography-courses-coventry')) {
          debugLog(`[computeAiMetricsForPageUrl] DIAGNOSTIC: Target normalized URL="${canonTarget}"`, 'error');
          // Check first few rows to see data structure
          const sampleRows = rows.slice(0, 3).map(r => ({
            keyword: r.keyword || 'N/A',
            has_ai_alan_citations: !!r.ai_alan_citations,
            ai_alan_citations_type: Array.isArray(r.ai_alan_citations) ? 'array' : typeof r.ai_alan_citations,
            ai_alan_citations_length: Array.isArray(r.ai_alan_citations) ? r.ai_alan_citations.length : 'N/A',
            ai_alan_citations_sample: Array.isArray(r.ai_alan_citations) && r.ai_alan_citations.length > 0 
              ? (typeof r.ai_alan_citations[0] === 'string' ? r.ai_alan_citations[0] : (r.ai_alan_citations[0]?.url || r.ai_alan_citations[0]?.URL || 'object'))
              : 'empty'
          }));
          debugLog(`[computeAiMetricsForPageUrl] DIAGNOSTIC: Sample rows structure: ${JSON.stringify(sampleRows, null, 2)}`, 'error');
          }
          
          // Count rows with citations for diagnostic
          let rowsWithCitations = 0;
          let totalCitations = 0;
          
          rows.forEach((r, idx) => {
            // Get citations array - try multiple field name variations
            const citationsArray = r.ai_alan_citations || r.aiAlanCitations || r.citations || [];
            if (!Array.isArray(citationsArray) || citationsArray.length === 0) {
              return; // Skip if no citations
            }
            
            rowsWithCitations++;
            totalCitations += citationsArray.length;
            
            // ENHANCED DIAGNOSTIC: Log citations for keywords that might cite the target
            if (canonTarget.includes('photography-courses-coventry') && citationsArray.length > 0) {
              const sampleCitations = citationsArray.slice(0, 3).map(cit => {
                if (typeof cit === 'string') return cit;
                if (cit && typeof cit === 'object') return cit.url || cit.URL || cit.link || JSON.stringify(cit).substring(0, 50);
                return String(cit);
              });
              debugLog(`[computeAiMetricsForPageUrl] DIAGNOSTIC: Keyword "${r.keyword || 'unknown'}" has ${citationsArray.length} citations. Sample: ${JSON.stringify(sampleCitations)}`, 'error');
            }
            
            // Count how many citations in this keyword's array match the target URL
            let keywordCitationCount = 0; // Count citations for this keyword
            citationsArray.forEach(citation => {
              // Try multiple field names to extract citation URL (matches API endpoint logic)
              const citedUrl = typeof citation === 'string' 
                ? citation 
                : (citation && typeof citation === 'object' 
                    ? (citation.url || citation.URL || citation.link || citation.href || citation.page || citation.pageUrl || citation.target || citation.targetUrl || citation.best_url || citation.bestUrl || '') 
                    : null);
              if (!citedUrl) return;
              
              const citedUrlNormalized = normalizeUrl(citedUrl);
              
              // Strict URL matching: exact match or same path segments (not substring matching)
              // This prevents matching "photography-workshops" when looking for "landscape-photography-workshops"
              const targetPathParts = canonTarget.split('/').filter(p => p);
              const citedPathParts = citedUrlNormalized.split('/').filter(p => p);
              
              // Exact match
              let matches = citedUrlNormalized === canonTarget;
              
              // If not exact, check if paths match (same segments, allowing query/fragment variants)
              // Only match if the citation path starts with the target path (not substring matching)
              if (!matches && targetPathParts.length > 0 && citedPathParts.length >= targetPathParts.length) {
                // Check if citation path starts with target path segments
                matches = targetPathParts.every((part, idx) => citedPathParts[idx] === part);
              }
              
              // ENHANCED DIAGNOSTIC: Log comparison for photography-courses-coventry or landscape-photography-workshops
              if (canonTarget.includes('photography-courses-coventry') || canonTarget.includes('landscape-photography-workshops')) {
                debugLog(
                  `[computeAiMetricsForPageUrl] DIAGNOSTIC: Comparing citation "${citedUrl}" (normalized: "${citedUrlNormalized}") ` +
                  `with target "${canonTarget}" - Exact: ${citedUrlNormalized === canonTarget} | PathMatch: ${matches}`,
                  'error'
                );
              }
              
              if (matches) {
                keywordCitationCount++; // Count this citation
              }
            });
            
            // If this keyword cites the target URL, track it and add to total count
            if (keywordCitationCount > 0) {
              totalCitationCount += keywordCitationCount; // Add to total citation count
              const rowHasOverview = r.has_ai_overview === true || r.hasAiOverview === true || r.ai_overview_present_any === true || r.aiOverviewPresentAny === true;
              if (rowHasOverview) {
                hasOverview = true;
              }
              
              citingKeywords.push({
                keyword: r.keyword || 'unknown',
                has_ai_overview: rowHasOverview,
                best_url: r.best_url || r.bestUrl || r.targetUrl || r.ranking_url || '',
                best_rank: r.best_rank_group || r.bestRankGroup || r.best_rank_absolute || null,
                citation_count: keywordCitationCount // Track how many citations this keyword has for the URL
              });
              
              // Debug log for the problematic URL
              if (canonTarget.includes('photography-courses-coventry')) {
                debugLog(
                  `[computeAiMetricsForPageUrl]  Found keyword citing URL: keyword="${r.keyword || 'unknown'}", ` +
                  `has_ai_overview=${rowHasOverview}, best_url="${r.best_url || r.bestUrl || 'N/A'}"`,
                  'success'
                );
              }
            }
          });
          
          // DIAGNOSTIC: Log summary of citations found
          if (canonTarget.includes('photography-courses-coventry')) {
            debugLog(
              `[computeAiMetricsForPageUrl] DIAGNOSTIC: Scanned ${rows.length} rows, ` +
              `found ${rowsWithCitations} rows with citations (${totalCitations} total citations), ` +
              `found ${citingKeywords.length} keywords citing target URL`,
              'error'
            );
          }

          // Count unique keywords that cite this URL (for display in card 2)
          const uniqueKeywordsCount = citingKeywords.length;
          
          // ENHANCED DIAGNOSTIC: Log which keywords were found
          if (canonTarget.includes('photography-courses-coventry')) {
            debugLog(
              `[computeAiMetricsForPageUrl] DIAGNOSTIC: Found ${uniqueKeywordsCount} unique keywords citing URL with ${totalCitationCount} total citations: ` +
              `${JSON.stringify(citingKeywords.map(k => ({ keyword: k.keyword, citation_count: k.citation_count, has_ai_overview: k.has_ai_overview })))}`,
              'error'
            );
            debugLog(
              `[computeAiMetricsForPageUrl] DIAGNOSTIC: Final calculation - ` +
              `uniqueKeywordsCount=${uniqueKeywordsCount}, totalCitationCount=${totalCitationCount}, ` +
              `hasOverview=${hasOverview}`,
              'error'
            );
          }
          
          // Return results: citations count is TOTAL citations (sum across all keywords), overview is true if any citing keyword has it
          let finalOverview = null;
          let finalCitations = null;
          
          if (totalCitationCount > 0) {
            // We found citations for this URL - return total count
            finalCitations = totalCitationCount; // Return total citations, not unique keywords
            finalOverview = hasOverview; // true if at least one citing keyword has overview
          } else {
            // No citations found for this URL - return null (unknown, not zero)
            finalCitations = null;
            finalOverview = null;
          }
          
          // FINAL VALIDATION: Ensure consistency - if one is null, both must be null
          if ((finalOverview !== null && finalCitations === null) || (finalOverview === null && finalCitations !== null)) {
            // Inconsistency detected - force both to null (unknown state)
            finalOverview = null;
            finalCitations = null;
          }

          // Final debug summary for this URL
          if (canonTarget.includes('photography-courses-coventry')) {
            debugLog(
              `[computeAiMetricsForPageUrl] FINAL RESULT: target=${canonTarget} ` +
              `uniqueKeywordsCount=${uniqueKeywordsCount} totalCitationCount=${totalCitationCount} ` +
              `finalOverview=${finalOverview} finalCitations=${finalCitations}`,
              'error'
            );
          }

          console.log('[computeAiMetricsForPageUrl] RETURNING:', { ai_overview: finalOverview, ai_citations: finalCitations });
          return { ai_overview: finalOverview, ai_citations: finalCitations };
        } catch (err) {
          console.error('[computeAiMetricsForPageUrl] ERROR:', err);
          debugLog(`[computeAiMetricsForPageUrl] ERROR: ${err.message}`, 'error');
          debugLog(`[computeAiMetricsForPageUrl] ERROR stack: ${err.stack}`, 'error');
          return { ai_overview: null, ai_citations: null };
        }
      };

      // TEST FUNCTION: Directly test URL matching logic for photography-courses-coventry
      window.testUrlTaskAiMatching = window.testUrlTaskAiMatching || async function testUrlTaskAiMatching() {
        const testUrl = 'www.alanranger.com/photography-courses-coventry';
        const testUrlFull = 'https://www.alanranger.com/photography-courses-coventry';
        
        debugLog(`[TEST] Starting URL task AI matching test for: ${testUrl}`, 'error');
        
        // Get combinedRows from all sources
        let aiRows = [];
        if (typeof window.getRankingAiCombinedRows === 'function') {
          aiRows = window.getRankingAiCombinedRows();
          debugLog(`[TEST] Got ${aiRows.length} rows from getRankingAiCombinedRows()`, 'error');
        }
        if (aiRows.length === 0 && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
          aiRows = window.rankingAiData;
          debugLog(`[TEST] Got ${aiRows.length} rows from window.rankingAiData`, 'error');
        }
        if (aiRows.length === 0) {
          try {
            const local = localStorage.getItem('rankingAiData');
            if (local) {
              const parsed = JSON.parse(local);
              if (parsed && Array.isArray(parsed.combinedRows)) {
                aiRows = parsed.combinedRows;
                debugLog(`[TEST] Got ${aiRows.length} rows from localStorage`, 'error');
              }
            }
          } catch (e) {
            debugLog(`[TEST] Error reading localStorage: ${e.message}`, 'error');
          }
        }
        
        if (aiRows.length === 0) {
          debugLog(`[TEST] ERROR: No combinedRows available. Please run Ranking & AI scan first.`, 'error');
          return { error: 'No data available' };
        }
        
        // Find rows that might match
        const normalizeUrl = (url) => {
          if (!url) return '';
          let normalized = String(url).toLowerCase().trim();
          normalized = normalized.replace(/^https?:\/\//, '');
          normalized = normalized.replace(/^www\./, '');
          normalized = normalized.split('?')[0].split('#')[0];
          normalized = normalized.replace(/\/$/, '');
          return normalized;
        };
        
        const testUrlNormalized = normalizeUrl(testUrl);
        debugLog(`[TEST] Normalized test URL: "${testUrlNormalized}"`, 'error');
        
        // Check first 10 rows
        const sampleRows = aiRows.slice(0, 10).map((r, idx) => {
          const rowUrl = r.best_url || r.bestUrl || r.targetUrl || r.ranking_url || '';
          const rowUrlNormalized = normalizeUrl(rowUrl);
          const matches = rowUrlNormalized === testUrlNormalized || 
                         rowUrlNormalized.includes('photography-courses-coventry') ||
                         testUrlNormalized.includes(rowUrlNormalized.split('/').pop() || '');
          return {
            index: idx,
            keyword: r.keyword || 'N/A',
            originalUrl: rowUrl,
            normalizedUrl: rowUrlNormalized,
            matches: matches,
            has_ai_overview: r.has_ai_overview || r.hasAiOverview || r.ai_overview_present_any || false,
            ai_alan_citations_count: r.ai_alan_citations_count || r.aiAlanCitationsCount || 0
          };
        });
        
        debugLog(`[TEST] Sample rows (first 10): ${JSON.stringify(sampleRows, null, 2)}`, 'error');
        
        // Find all rows with photography-courses-coventry
        const matchingRows = aiRows.filter(r => {
          const rowUrl = r.best_url || r.bestUrl || r.targetUrl || r.ranking_url || '';
          const rowUrlNormalized = normalizeUrl(rowUrl);
          return rowUrlNormalized.includes('photography-courses-coventry') || 
                 testUrlNormalized.includes(rowUrlNormalized.split('/').pop() || '');
        });
        
        debugLog(`[TEST] Found ${matchingRows.length} rows that might match photography-courses-coventry`, 'error');
        if (matchingRows.length > 0) {
          const matchDetails = matchingRows.slice(0, 5).map(r => ({
            keyword: r.keyword || 'N/A',
            best_url: r.best_url || r.bestUrl || r.targetUrl || r.ranking_url || 'N/A',
            normalized: normalizeUrl(r.best_url || r.bestUrl || r.targetUrl || r.ranking_url || ''),
            has_ai_overview: r.has_ai_overview || r.hasAiOverview || r.ai_overview_present_any || false,
            ai_alan_citations_count: r.ai_alan_citations_count || r.aiAlanCitationsCount || 0
          }));
          debugLog(`[TEST] Matching rows details (first 5): ${JSON.stringify(matchDetails, null, 2)}`, 'error');
        }
        
        // Test the actual function
        debugLog(`[TEST] Testing computeAiMetricsForPageUrl with testUrl="${testUrl}"`, 'error');
        const result1 = (typeof window.computeAiMetricsForPageUrl === 'function')
          ? window.computeAiMetricsForPageUrl(testUrl, aiRows)
          : { ai_overview: null, ai_citations: null };
        debugLog(`[TEST] Result 1 (testUrl): ${JSON.stringify(result1)}`, 'error');
        
        debugLog(`[TEST] Testing computeAiMetricsForPageUrl with testUrlFull="${testUrlFull}"`, 'error');
        const result2 = (typeof window.computeAiMetricsForPageUrl === 'function')
          ? window.computeAiMetricsForPageUrl(testUrlFull, aiRows)
          : { ai_overview: null, ai_citations: null };
        debugLog(`[TEST] Result 2 (testUrlFull): ${JSON.stringify(result2)}`, 'error');
        
        return {
          testUrl: testUrl,
          testUrlFull: testUrlFull,
          testUrlNormalized: testUrlNormalized,
          totalRows: aiRows.length,
          matchingRowsCount: matchingRows.length,
          sampleRows: sampleRows,
          matchingRows: matchingRows.slice(0, 5),
          result1: result1,
          result2: result2
        };
      };

      // Build metrics table
      // Get objective KPI and map to metric key
      let objectiveKpiKey = task.objectiveKpiKey || 
                            (task.objective && task.objective.kpi) || 
                            task.objective_metric || 
                            task.objective_kpi || 
                            null;
      
      // Map common objective KPI values to metric keys
      const objectiveKpiMap = {
        'Rank': 'current_rank',
        'rank': 'current_rank',
        'current_rank': 'current_rank',
        'CTR': 'gsc_ctr_28d',
        'ctr': 'gsc_ctr_28d',
        'ctr_28d': 'gsc_ctr_28d',
        'gsc_ctr_28d': 'gsc_ctr_28d',
        'Clicks': 'gsc_clicks_28d',
        'clicks': 'gsc_clicks_28d',
        'clicks_28d': 'gsc_clicks_28d',
        'gsc_clicks_28d': 'gsc_clicks_28d',
        'Impressions': 'gsc_impressions_28d',
        'impressions': 'gsc_impressions_28d',
        'impressions_28d': 'gsc_impressions_28d',
        'gsc_impressions_28d': 'gsc_impressions_28d',
        'AI Citations': 'ai_citations',
        'ai_citations': 'ai_citations',
        'AI Overview': 'ai_overview',
        'ai_overview': 'ai_overview'
      };
      
      const targetMetricKey = objectiveKpiKey ? (objectiveKpiMap[objectiveKpiKey] || objectiveKpiKey) : null;

      const metrics = [
        { label: 'Clicks (28d)', baselineKey: 'gsc_clicks_28d', latestKey: 'gsc_clicks_28d', higherIsBetter: true },
        { label: 'Impressions (28d)', baselineKey: 'gsc_impressions_28d', latestKey: 'gsc_impressions_28d', higherIsBetter: true },
        { label: 'CTR (28d)', baselineKey: 'gsc_ctr_28d', latestKey: 'gsc_ctr_28d', higherIsBetter: true, format: (v) => v != null ? (v * 100).toFixed(2) + '%' : '' },
        { label: 'Current Rank', baselineKey: 'current_rank', latestKey: 'current_rank', higherIsBetter: false, format: (v) => v != null ? Number(v).toFixed(2) : '' },
        { label: 'AI Overview', baselineKey: 'ai_overview', latestKey: 'ai_overview', format: (v) => v === true ? 'Present' : (v === false ? 'Not present' : '') },
        { label: 'AI Citations', baselineKey: 'ai_citations', latestKey: 'ai_citations', higherIsBetter: true }
      ];

      let html = `
        <div style="font-weight: 700; padding: 0.5rem; background: var(--dark-panel); border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.9rem; color: var(--dark-text);">Metric</div>
        <div style="font-weight: 700; padding: 0.5rem; background: var(--dark-panel); border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.9rem; color: var(--dark-text);">Baseline</div>
        <div style="font-weight: 700; padding: 0.5rem; background: var(--dark-panel); border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.9rem; color: var(--dark-text);">Latest</div>
      `;

      // REMOVED: Warning banner check - user requested removal
      // Baseline completeness is now handled by the bulk rebaseline feature

      metrics.forEach(metric => {
        const baselineVal = baseline?.[metric.baselineKey];
        const latestVal = latest?.[metric.latestKey];
        const delta = calcDelta(latestVal, baselineVal);
        const deltaFormatted = formatDelta(delta, metric.latestKey);
        
        // Check if this specific metric has missing baseline
        const isBaselineMissing = (baselineVal == null || baselineVal === '') && (latestVal != null && latestVal !== '');

        const formatValue = (val) => {
          if (metric.format) return metric.format(val);
          return formatNum(val);
        };

        // Check if this metric matches the objective KPI
        const isTargetMetric = targetMetricKey && (
          metric.baselineKey === targetMetricKey || 
          metric.latestKey === targetMetricKey
        );
        
        // Highlighting styles for target metric row - border only (no background)
        const highlightStyle = isTargetMetric 
          ? 'border-left: 4px solid #f59e0b; padding-left: calc(0.5rem - 4px);' 
          : '';
        const highlightBorder = isTargetMetric 
          ? 'border-bottom: 2px solid #f59e0b;' 
          : 'border-bottom: 1px solid #e5e7eb;';
        
        // Add warning indicator for missing baseline
        const baselineWarning = isBaselineMissing 
          ? '<span style="margin-left: 0.25rem; color: #f59e0b; font-size: 0.7rem;" title="Baseline value missing - delta cannot be calculated"></span>'
          : '';

        html += `
          <div style="padding: 0.5rem; ${highlightBorder} ${highlightStyle} font-weight: 600; font-size: 0.9rem; color: #1e293b;">${metric.label}${isTargetMetric ? ' <span style="color: #f59e0b; font-size: 0.75rem;">(Target)</span>' : ''}</div>
          <div style="padding: 0.5rem; ${highlightBorder} ${highlightStyle} font-weight: 700; font-size: 1rem; color: #1e293b;">${formatValue(baselineVal)}${baselineWarning}</div>
          <div style="padding: 0.5rem; ${highlightBorder} ${highlightStyle} font-weight: 700; font-size: 1rem; color: #1e293b;">
            ${formatValue(latestVal)}
            ${delta != null ? `<span style="margin-left: 0.5rem; color: ${deltaFormatted.color} !important; font-weight: 700;">(${deltaFormatted.text})</span>` : (isBaselineMissing ? '<span style="margin-left: 0.5rem; color: #f59e0b; font-size: 0.85rem; font-weight: 600;" title="Baseline missing - cannot calculate delta"></span>' : '')}
          </div>
        `;
      });
      
      // REMOVED: Warning banner - user requested removal

      // Add captured_at timestamps (use created_at from event if captured_at not in metrics)
      const baselineDate = baseline?.captured_at || baseline?.created_at;
      const latestDate = latest?.captured_at || latest?.created_at;
      if (baselineDate || latestDate) {
        html += `
          <div style="padding: 0.5rem; border-top: 2px solid #e5e7eb; font-size: 0.85rem; color: #1e293b; font-weight: 600;">Captured</div>
          <div style="padding: 0.5rem; border-top: 2px solid #e5e7eb; font-size: 0.85rem; color: #1e293b; font-weight: 700;">
            ${baselineDate ? new Date(baselineDate).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' }) : ''}
          </div>
          <div style="padding: 0.5rem; border-top: 2px solid #e5e7eb; font-size: 0.85rem; color: #1e293b; font-weight: 700;">
            ${latestDate ? new Date(latestDate).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' }) : ''}
          </div>
        `;
      }

      container.innerHTML = html;
    }

    // Load and render measurement history for a task
    async function loadOptimisationMeasurementHistory(taskId, cycleId, cycleNo) {
      const container = document.getElementById('optimisation-measurement-history');
      if (!container) return;

      try {
        // Fetch last 10 measurement events for this task (current cycle only)
        const cycleFilter = cycleId ? `&cycle_id=${cycleId}` : (cycleNo ? `&cycle_number=${cycleNo}` : '');
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/events?event_type=measurement&limit=10${cycleFilter}`), {
          headers: window.getOptimisationHeaders()
        });

        if (!response.ok) {
          container.innerHTML = '<div style="color: #ef4444; font-size: 0.875rem;">Failed to load measurement history</div>';
          return;
        }

        const data = await response.json();
        const events = data.events || [];
        
        if (!events || events.length === 0) {
          container.innerHTML = '<div style="color: #666; font-style: italic; font-size: 0.875rem;">No measurements captured yet for this cycle</div>';
          return;
        }

        // Filter to current cycle and sort by created_at descending (most recent first)
        const cycleEvents = events.filter(e => {
          if (cycleId) return e.cycle_id === cycleId;
          if (cycleNo) return e.cycle_number === cycleNo;
          return true;
        }).sort((a, b) => {
          const dateA = new Date(a.created_at || a.event_at || 0);
          const dateB = new Date(b.created_at || b.event_at || 0);
          return dateB - dateA;
        });

        if (cycleEvents.length === 0) {
          container.innerHTML = '<div style="color: #666; font-style: italic; font-size: 0.875rem;">No measurements captured yet for this cycle</div>';
          return;
        }

        // Build history table
        let html = `
          <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
            <thead>
              <tr style="background: #f3f4f6; border-bottom: 2px solid #d1d5db;">
                <th style="padding: 0.5rem; text-align: left; font-weight: 600;">Date</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">Clicks</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">Impr.</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">CTR</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">Rank</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">AI Cit.</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;"> vs Prev</th>
              </tr>
            </thead>
            <tbody>
        `;

        cycleEvents.forEach((event, idx) => {
          const metrics = event.metrics || {};
          const capturedAt = event.created_at || event.event_at || event.metrics?.captured_at;
          const prevEvent = idx < cycleEvents.length - 1 ? cycleEvents[idx + 1] : null;
          const prevMetrics = prevEvent?.metrics || {};

          // Calculate deltas vs previous measurement
          const deltaClicks = metrics.gsc_clicks_28d != null && prevMetrics.gsc_clicks_28d != null 
            ? metrics.gsc_clicks_28d - prevMetrics.gsc_clicks_28d : null;
          const deltaImpr = metrics.gsc_impressions_28d != null && prevMetrics.gsc_impressions_28d != null
            ? metrics.gsc_impressions_28d - prevMetrics.gsc_impressions_28d : null;
          const deltaCTR = metrics.gsc_ctr_28d != null && prevMetrics.gsc_ctr_28d != null
            ? ((metrics.gsc_ctr_28d - prevMetrics.gsc_ctr_28d) * 100).toFixed(2) : null;
          const deltaRank = metrics.current_rank != null && prevMetrics.current_rank != null
            ? metrics.current_rank - prevMetrics.current_rank : null;
          const deltaAICit = metrics.ai_citations != null && prevMetrics.ai_citations != null
            ? metrics.ai_citations - prevMetrics.ai_citations : null;

          const formatDelta = (val, isRank = false) => {
            if (val == null) return '';
            if (isRank) {
              if (val < 0) return `<span style="color: #10b981;">${Math.abs(val)}</span>`;
              if (val > 0) return `<span style="color: #ef4444;">${val}</span>`;
              return '0';
            }
            if (val > 0) return `<span style="color: #10b981;">+${val}</span>`;
            if (val < 0) return `<span style="color: #ef4444;">${val}</span>`;
            return '0';
          };

          html += `
            <tr style="border-bottom: 1px solid #e5e7eb;">
              <td style="padding: 0.5rem; white-space: nowrap;">
                ${capturedAt ? new Date(capturedAt).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' }) : ''}
              </td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.gsc_clicks_28d != null ? metrics.gsc_clicks_28d.toLocaleString() : ''}</td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.gsc_impressions_28d != null ? metrics.gsc_impressions_28d.toLocaleString() : ''}</td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.gsc_ctr_28d != null ? (metrics.gsc_ctr_28d * 100).toFixed(2) + '%' : ''}</td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.current_rank != null ? metrics.current_rank : ''}</td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.ai_citations != null ? metrics.ai_citations : ''}</td>
              <td style="padding: 0.5rem; text-align: right; font-size: 0.8rem;">
                ${prevEvent ? `
                  <div>${formatDelta(deltaClicks)}</div>
                  <div>${formatDelta(deltaImpr)}</div>
                  <div>${formatDelta(deltaCTR)}</div>
                  <div>${formatDelta(deltaRank, true)}</div>
                  <div>${formatDelta(deltaAICit)}</div>
                ` : '<span style="color: #9ca3af;">Baseline</span>'}
              </td>
            </tr>
          `;
        });

        html += `
            </tbody>
          </table>
        `;

        container.innerHTML = html;
      } catch (error) {
        console.error('[Optimisation] Error loading measurement history:', error);
        container.innerHTML = '<div style="color: #ef4444; font-size: 0.875rem;">Error loading measurement history</div>';
      }
    }

    async function loadOptimisationTaskEvents(taskId) {
      const eventsContainer = document.getElementById('optimisation-drawer-events');
      if (!eventsContainer) return;

      try {
        const headers = window.getOptimisationHeaders();
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/events`), {
          method: 'GET',
          headers: headers
        });

        if (!response.ok) {
          throw new Error(`Failed to load events: ${response.status}`);
        }

        const data = await response.json();
        const events = data.events || [];

        if (events.length === 0) {
          eventsContainer.innerHTML = '<div style="color: #666; font-style: italic;">No events yet</div>';
          return;
        }

        eventsContainer.innerHTML = events.map(event => {
          const date = new Date(event.event_at || event.created_at).toLocaleString('en-GB');
          // Format event type for display (replace underscores with spaces, capitalize)
          const eventTypeDisplay = (event.event_type || 'note')
            .replace(/_/g, ' ')
            .replace(/\b\w/g, l => l.toUpperCase());
          // Use different colors for different event types
          let eventColor = '#2563eb'; // Default blue
          if (event.event_type === 'cycle_completed') eventColor = '#10b981'; // Green
          if (event.event_type === 'cycle_archived') eventColor = '#6b7280'; // Grey
          if (event.event_type === 'cycle_start') eventColor = '#3b82f6'; // Blue
          if (event.event_type === 'measurement') eventColor = '#8b5cf6'; // Purple
          if (event.event_type === 'status_changed') eventColor = '#f59e0b'; // Orange
          
          return `
            <div style="margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid #eee;">
              <div style="font-weight: 600; color: ${eventColor};">${escapeHtml(eventTypeDisplay)}</div>
              <div style="color: #666; font-size: 0.875rem; margin-top: 0.25rem;">${date}</div>
              ${event.note ? `<div style="margin-top: 0.5rem;">${escapeHtml(event.note)}</div>` : ''}
            </div>
          `;
        }).join('');
      } catch (error) {
        console.error('[Optimisation Module] Error loading events:', error);
        eventsContainer.innerHTML = '<div style="color: #ef4444;">Error loading events</div>';
      }
    }

    // Initialize Optimisation Tracking module
    function initOptimisationTrackingModule() {
      // Set initial active tab
      if (!window.optimisationModuleState.activeTab) {
        window.optimisationModuleState.activeTab = 'active';
      }
      
      // Update tab button states on init
      document.querySelectorAll('.optimisation-tab-btn').forEach(btn => {
        btn.classList.toggle('metric-pill--active', btn.dataset.tab === window.optimisationModuleState.activeTab);
      });
      
      // Tab button handlers
      document.querySelectorAll('.optimisation-tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          switchOptimisationTab(btn.dataset.tab);
        });
      });

      // Drawer buttons
      const closeBtn = document.getElementById('optimisation-drawer-close');
      if (closeBtn) {
        closeBtn.addEventListener('click', closeOptimisationTaskDrawer);
      }
      
      const closeBottomBtn = document.getElementById('optimisation-drawer-close-bottom');
      if (closeBottomBtn) {
        closeBottomBtn.addEventListener('click', closeOptimisationTaskDrawer);
      }
      
      const minimizeBtn = document.getElementById('optimisation-drawer-minimize');
      if (minimizeBtn) {
        minimizeBtn.addEventListener('click', minimizeOptimisationDrawer);
      }
      
      const maximizeBtn = document.getElementById('optimisation-drawer-maximize');
      if (maximizeBtn) {
        maximizeBtn.addEventListener('click', maximizeOptimisationDrawer);
      }
      
      // Edit Objective button
      const editObjectiveBtn = document.getElementById('optimisation-edit-objective-btn');
      if (editObjectiveBtn) {
        editObjectiveBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (typeof window.editObjective === 'function') {
            window.editObjective();
          }
        });
      }

      // Save Objective button
      const saveObjectiveBtn = document.getElementById('optimisation-save-objective-btn');
      if (saveObjectiveBtn) {
        saveObjectiveBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (typeof window.saveObjective === 'function') {
            window.saveObjective();
          }
        });
      }

      // Cancel Edit Objective button
      const cancelEditObjectiveBtn = document.getElementById('optimisation-cancel-edit-objective-btn');
      if (cancelEditObjectiveBtn) {
        cancelEditObjectiveBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (typeof window.cancelEditObjective === 'function') {
            window.cancelEditObjective();
          }
        });
      }

      // Measurement history toggle
      const measurementHistoryToggle = document.getElementById('optimisation-measurement-history-toggle');
      const measurementHistoryContainer = document.getElementById('optimisation-measurement-history');
      if (measurementHistoryToggle && measurementHistoryContainer) {
        measurementHistoryToggle.addEventListener('click', () => {
          const isVisible = measurementHistoryContainer.style.display !== 'none';
          measurementHistoryContainer.style.display = isVisible ? 'none' : 'block';
          measurementHistoryToggle.textContent = isVisible ? 'Show' : 'Hide';
        });
      }

      // Update due date when timeframe changes
      const timeframeInput = document.getElementById('optimisation-edit-objective-timeframe');
      if (timeframeInput) {
        timeframeInput.addEventListener('input', updateObjectiveDueDate);
      }

      // Backdrop click to close (but not when clicking on drawer)
      const backdrop = document.getElementById('optimisation-task-drawer-backdrop');
      if (backdrop) {
        backdrop.addEventListener('click', (e) => {
          if (e.target === backdrop) {
            closeOptimisationTaskDrawer();
          }
        });
      }
      
      // Initialize dragging
      initOptimisationDrawerDragging();

      // Bulk update button
      const bulkUpdateBtn = document.getElementById('optimisation-bulk-update-btn');
      if (bulkUpdateBtn) {
        bulkUpdateBtn.addEventListener('click', async () => {
          if (typeof window.bulkUpdateAllTasks === 'function') {
            await window.bulkUpdateAllTasks();
          }
        });
      }

        // Bulk rebaseline button
        const bulkRebaselineBtn = document.getElementById('optimisation-bulk-rebaseline-btn');
        if (bulkRebaselineBtn) {
          bulkRebaselineBtn.addEventListener('click', async () => {
            if (window.isShareMode) {
              alert('Write operations are not available in share mode (read-only).');
              return;
            }
            if (!window.hasAdminKey()) {
              alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
              return;
            }
            if (typeof window.bulkRebaselineIncompleteBaselines === 'function') {
              await window.bulkRebaselineIncompleteBaselines();
            }
          });
        }

        // Copy URLs button
        const copyUrlsBtn = document.getElementById('optimisation-copy-urls-btn');
        if (copyUrlsBtn) {
          copyUrlsBtn.addEventListener('click', () => {
            if (typeof window.copyOptimisationTaskUrls === 'function') {
              window.copyOptimisationTaskUrls();
            }
          });
        }

      // Timeline toggle (collapsed by default)
      const timelineHeader = document.getElementById('optimisation-timeline-header');
      const timelineToggle = document.getElementById('optimisation-timeline-toggle');
      const timelineContainer = document.getElementById('optimisation-drawer-events-container');
      if (timelineHeader && timelineToggle && timelineContainer) {
        timelineHeader.addEventListener('click', () => {
          const isCollapsed = timelineContainer.style.display === 'none';
          timelineContainer.style.display = isCollapsed ? 'block' : 'none';
          timelineToggle.textContent = isCollapsed ? '' : '';
        });
        // Ensure it starts collapsed
        timelineContainer.style.display = 'none';
        timelineToggle.textContent = '';
      }

      // Filter handlers
      const filterStatus = document.getElementById('optimisation-filter-status');
      const filterType = document.getElementById('optimisation-filter-type');
      const filterKeyword = document.getElementById('optimisation-filter-keyword');
      const filterUrl = document.getElementById('optimisation-filter-url');
      const clearFilters = document.getElementById('optimisation-clear-filters');

      const applyFilters = () => {
        // Apply base filters (test tasks, keyword, url, type, status, metric traffic)
        applyOptimisationFilters();
        
        // Apply additional button filters on top of base filters
        let filtered = [...window.optimisationModuleState.filteredTasks];
        
        // Apply status/type/keyword/url filters (using field name variations)
        if (filterStatus && filterStatus.value) {
          filtered = filtered.filter(t => t.status === filterStatus.value);
        }
        if (filterType && filterType.value) {
          filtered = filtered.filter(t => t.task_type === filterType.value);
        }
        if (filterKeyword && filterKeyword.value) {
          const keyword = filterKeyword.value.toLowerCase();
          filtered = filtered.filter(t => 
            (t.keyword_text || t.keyword || '').toLowerCase().includes(keyword)
          );
        }
        if (filterUrl && filterUrl.value) {
          const url = filterUrl.value.toLowerCase();
          filtered = filtered.filter(t => 
            (t.target_url_clean || t.target_url || '').toLowerCase().includes(url)
          );
        }
        
        // "Needs Update" filter: tasks with no measurement or measurement older than 30 days
        const needsUpdateBtn = document.getElementById('optimisation-filter-needs-update');
        if (needsUpdateBtn && needsUpdateBtn.classList.contains('active')) {
          const thirtyDaysAgo = new Date();
          thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
          
          filtered = filtered.filter(t => {
            // Check if task has latest_metrics
            if (!t.latest_metrics) {
              return true; // No measurement = needs update
            }
            
            // Check captured_at from latest_metrics
            const capturedAt = t.latest_metrics.captured_at;
            if (!capturedAt) {
              return true; // No capture date = needs update
            }
            
            const latestCapturedDate = new Date(capturedAt);
            return latestCapturedDate < thirtyDaysAgo; // Older than 30 days = needs update
          });
        }
        
        // "Active Cycle Only" filter: tasks with an active cycle (not completed/archived)
        const activeCycleBtn = document.getElementById('optimisation-filter-active-cycle');
        if (activeCycleBtn && activeCycleBtn.classList.contains('active')) {
          filtered = filtered.filter(t => {
            return t.active_cycle_id != null; // Has an active cycle
          });
        }
        
        // "Overdue Cycle" filter: tasks with overdue current cycle
        const overdueCycleBtn = document.getElementById('optimisation-filter-overdue-cycle');
        if (overdueCycleBtn && overdueCycleBtn.classList.contains('active')) {
          filtered = filtered.filter(t => {
            // Check if current cycle is overdue
            const status = t.objective_status || t.goal_state;
            return status === 'overdue';
          });
        }

        window.optimisationModuleState.filteredTasks = filtered;
        // Reset pagination when filters change
        optimisationPaginationState.currentPage = 1;
        updateTrafficLights(); // Update traffic lights when filters change
        updateTrafficLightVisuals(); // Update visual state of pills
        updateTimeseriesCharts(); // Update charts with filtered data
        renderOptimisationTasksTable();
      };

      if (filterStatus) filterStatus.addEventListener('change', applyFilters);
      if (filterType) filterType.addEventListener('change', applyFilters);
      if (filterKeyword) filterKeyword.addEventListener('input', applyFilters);
      if (filterUrl) filterUrl.addEventListener('input', applyFilters);
      
      // Attach click handlers to all traffic light pills (for pills that don't have onclick yet)
      setTimeout(() => {
        const metricMap = {
          'objective-impressions': 'impressions_28d',
          'objective-clicks': 'clicks_28d',
          'objective-rank': 'current_rank',
          'objective-ai-citations': 'ai_citations',
          'objective-ai-overview': 'ai_overview'
        };
        
        for (const [prefix, metricKey] of Object.entries(metricMap)) {
          const worseEl = document.getElementById(`${prefix}-red`);
          const sameEl = document.getElementById(`${prefix}-amber`);
          const betterEl = document.getElementById(`${prefix}-green`);
          
          if (worseEl && !worseEl.closest('.traffic-light-pill')) {
            const pill = worseEl.closest('div[style*="background"]');
            if (pill) {
              pill.classList.add('traffic-light-pill');
              pill.dataset.metric = metricKey;
              pill.dataset.bucket = 'worse';
              pill.style.background = 'rgba(239, 68, 68, 0.2)';
              pill.onclick = () => handleTrafficLightClick(metricKey, 'worse');
              // Remove any inline hover handlers - CSS handles it now
              pill.removeAttribute('onmouseover');
              pill.removeAttribute('onmouseout');
            }
          }
          
          if (sameEl && !sameEl.closest('.traffic-light-pill')) {
            const pill = sameEl.closest('div[style*="background"]');
            if (pill) {
              pill.classList.add('traffic-light-pill');
              pill.dataset.metric = metricKey;
              pill.dataset.bucket = 'same';
              pill.style.background = 'rgba(245, 158, 11, 0.2)';
              pill.onclick = () => handleTrafficLightClick(metricKey, 'same');
              // Remove any inline hover handlers - CSS handles it now
              pill.removeAttribute('onmouseover');
              pill.removeAttribute('onmouseout');
            }
          }
          
          if (betterEl && !betterEl.closest('.traffic-light-pill')) {
            const pill = betterEl.closest('div[style*="background"]');
            if (pill) {
              pill.classList.add('traffic-light-pill');
              pill.dataset.metric = metricKey;
              pill.dataset.bucket = 'better';
              pill.style.background = 'rgba(16, 185, 129, 0.2)';
              pill.onclick = () => handleTrafficLightClick(metricKey, 'better');
              // Remove any inline hover handlers - CSS handles it now
              pill.removeAttribute('onmouseover');
              pill.removeAttribute('onmouseout');
            }
          }
        }
        
        // Update visual state on initial load
        updateTrafficLightVisuals();
      }, 100);
      
      const needsUpdateBtn = document.getElementById('optimisation-filter-needs-update');
      if (needsUpdateBtn) {
        needsUpdateBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('[Optimisation] Needs Update button clicked');
          needsUpdateBtn.classList.toggle('active');
          if (needsUpdateBtn.classList.contains('active')) {
            needsUpdateBtn.style.background = '#3b82f6';
            needsUpdateBtn.style.color = '#ffffff';
          } else {
            needsUpdateBtn.style.background = '';
            needsUpdateBtn.style.color = '';
          }
          console.log('[Optimisation] Needs Update filter active:', needsUpdateBtn.classList.contains('active'));
          applyFilters();
        });
      } else {
        console.error('[Optimisation] Needs Update button not found!');
      }
      
      // Active Cycle Only filter button
      const activeCycleBtn = document.getElementById('optimisation-filter-active-cycle');
      if (activeCycleBtn) {
        activeCycleBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          activeCycleBtn.classList.toggle('active');
          if (activeCycleBtn.classList.contains('active')) {
            activeCycleBtn.style.background = '#3b82f6';
            activeCycleBtn.style.color = '#ffffff';
          } else {
            activeCycleBtn.style.background = '';
            activeCycleBtn.style.color = '';
          }
          applyFilters();
        });
      }
      
      // Overdue Cycle filter button
      const overdueCycleBtn = document.getElementById('optimisation-filter-overdue-cycle');
      if (overdueCycleBtn) {
        overdueCycleBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          overdueCycleBtn.classList.toggle('active');
          if (overdueCycleBtn.classList.contains('active')) {
            overdueCycleBtn.style.background = '#ef4444';
            overdueCycleBtn.style.color = '#ffffff';
          } else {
            overdueCycleBtn.style.background = '';
            overdueCycleBtn.style.color = '';
          }
          applyFilters();
        });
      }
      
      // Objective filter pills
      const goalNotSet = document.getElementById('optimisation-goal-filter-not-set');
      const goalOnTrack = document.getElementById('optimisation-goal-filter-on-track');
      const goalOverdue = document.getElementById('optimisation-goal-filter-overdue');
      const goalMet = document.getElementById('optimisation-goal-filter-met');
      
      const updateObjectiveFilterUI = () => {
        const active = window.optimisationModuleState.activeObjectiveFilter;
        [goalNotSet, goalOnTrack, goalOverdue, goalMet].forEach((el, idx) => {
          if (!el) return;
          const states = ['not_set', 'on_track', 'overdue', 'met'];
          if (active === states[idx]) {
            el.style.opacity = '1';
            el.style.fontWeight = '600';
            el.style.border = '2px solid #3b82f6';
          } else {
            el.style.opacity = active ? '0.6' : '1';
            el.style.fontWeight = '';
            el.style.border = '';
          }
        });
      };
      
      if (goalNotSet) {
        goalNotSet.addEventListener('click', () => {
          if (window.optimisationModuleState.activeObjectiveFilter === 'not_set') {
            window.optimisationModuleState.activeObjectiveFilter = null;
          } else {
            window.optimisationModuleState.activeObjectiveFilter = 'not_set';
          }
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      if (goalOnTrack) {
        goalOnTrack.addEventListener('click', () => {
          if (window.optimisationModuleState.activeObjectiveFilter === 'on_track') {
            window.optimisationModuleState.activeObjectiveFilter = null;
          } else {
            window.optimisationModuleState.activeObjectiveFilter = 'on_track';
          }
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      if (goalOverdue) {
        goalOverdue.addEventListener('click', () => {
          if (window.optimisationModuleState.activeObjectiveFilter === 'overdue') {
            window.optimisationModuleState.activeObjectiveFilter = null;
          } else {
            window.optimisationModuleState.activeObjectiveFilter = 'overdue';
          }
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      if (goalMet) {
        goalMet.addEventListener('click', () => {
          if (window.optimisationModuleState.activeObjectiveFilter === 'met') {
            window.optimisationModuleState.activeObjectiveFilter = null;
          } else {
            window.optimisationModuleState.activeObjectiveFilter = 'met';
          }
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      
      if (clearFilters) {
        clearFilters.addEventListener('click', () => {
          if (filterStatus) filterStatus.value = '';
          if (filterType) filterType.value = '';
          if (filterKeyword) filterKeyword.value = '';
          if (filterUrl) filterUrl.value = '';
          // Clear metric traffic filter
          window.optimisationModuleState.metricTrafficFilter = null;
          updateTrafficLightVisuals();
          if (needsUpdateBtn) {
            needsUpdateBtn.classList.remove('active');
            needsUpdateBtn.style.background = '';
            needsUpdateBtn.style.color = '';
          }
          const activeCycleBtn = document.getElementById('optimisation-filter-active-cycle');
          if (activeCycleBtn) {
            activeCycleBtn.classList.remove('active');
            activeCycleBtn.style.background = '';
            activeCycleBtn.style.color = '';
          }
          const overdueCycleBtn = document.getElementById('optimisation-filter-overdue-cycle');
          if (overdueCycleBtn) {
            overdueCycleBtn.classList.remove('active');
            overdueCycleBtn.style.background = '';
            overdueCycleBtn.style.color = '';
          }
          const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
          if (includeTestCheckbox) {
            includeTestCheckbox.checked = false;
          }
          window.optimisationModuleState.activeObjectiveFilter = null;
          window.optimisationModuleState.trafficKpiOnly = false;
          window.optimisationModuleState.clickRelatedOnly = false;
          updateObjectiveFilterUI();
          applyFilters();
          updateImpactTiles();
        });
      }
      
      // Include test tasks checkbox
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (includeTestCheckbox) {
        includeTestCheckbox.addEventListener('change', () => {
          applyFilters();
          updateOptimisationSummaryCards();
          updateKPITiles();
          updateImpactTiles();
          updateTimeseriesCharts();
        });
      }
      
      // Hero tile click handlers
      const potentialClicksCard = document.getElementById('impact-potential-clicks-card');
      const potentialClicksClear = document.getElementById('impact-potential-clicks-clear');
      if (potentialClicksCard) {
        potentialClicksCard.addEventListener('click', (e) => {
          // Don't trigger if clicking the clear button
          if (e.target === potentialClicksClear || e.target.closest('#impact-potential-clicks-clear')) {
            return;
          }
          
          // Toggle trafficKpiOnly filter
          window.optimisationModuleState.trafficKpiOnly = !window.optimisationModuleState.trafficKpiOnly;
          window.optimisationModuleState.clickRelatedOnly = false; // Clear the other filter
          
          // Clear metric traffic filter (conflicting)
          window.optimisationModuleState.metricTrafficFilter = null;
          
          updateImpactTiles();
          applyOptimisationFilters();
          renderOptimisationTasksTable();
          updateTimeseriesCharts();
        });
      }
      
      if (potentialClicksClear) {
        potentialClicksClear.addEventListener('click', (e) => {
          e.stopPropagation();
          window.optimisationModuleState.trafficKpiOnly = false;
          updateImpactTiles();
          applyOptimisationFilters();
          renderOptimisationTasksTable();
          updateTimeseriesCharts();
        });
      }
      
      const actualClicksCard = document.getElementById('impact-actual-clicks-card');
      const actualClicksClear = document.getElementById('impact-actual-clicks-clear');
      if (actualClicksCard) {
        actualClicksCard.addEventListener('click', (e) => {
          // Don't trigger if clicking the clear button
          if (e.target === actualClicksClear || e.target.closest('#impact-actual-clicks-clear')) {
            return;
          }
          
          // Toggle clickRelatedOnly filter
          window.optimisationModuleState.clickRelatedOnly = !window.optimisationModuleState.clickRelatedOnly;
          window.optimisationModuleState.trafficKpiOnly = false; // Clear the other filter
          
          // Clear metric traffic filter (conflicting)
          window.optimisationModuleState.metricTrafficFilter = null;
          
          updateImpactTiles();
          applyOptimisationFilters();
          renderOptimisationTasksTable();
          updateTimeseriesCharts();
        });
      }
      
      if (actualClicksClear) {
        actualClicksClear.addEventListener('click', (e) => {
          e.stopPropagation();
          window.optimisationModuleState.clickRelatedOnly = false;
          updateImpactTiles();
          applyOptimisationFilters();
          renderOptimisationTasksTable();
          updateTimeseriesCharts();
        });
      }
      
      // Scope toggle
      const scopeSelect = document.getElementById('optimisation-scope-select');
      const scopeDescription = document.getElementById('optimisation-scope-description');
      if (scopeSelect) {
        scopeSelect.value = window.optimisationModuleState.scope || 'active_cycle';
        scopeSelect.addEventListener('change', () => {
          window.optimisationModuleState.scope = scopeSelect.value;
          if (scopeDescription) {
            scopeDescription.textContent = scopeSelect.value === 'active_cycle' 
              ? 'Showing metrics for tasks with active cycles only'
              : 'Showing metrics for all tasks';
          }
          // Update impact tiles immediately (they depend on scope)
          updateImpactTiles();
          // Then reload all tasks (which will also call updateImpactTiles, but this ensures immediate update)
          window.loadAllOptimisationTasks();
        });
        if (scopeDescription) {
          scopeDescription.textContent = scopeSelect.value === 'active_cycle' 
            ? 'Showing metrics for tasks with active cycles only'
            : 'Showing metrics for all tasks';
        }
      }

      // Drawer action handlers
      const addEventBtn = document.getElementById('optimisation-add-event-btn');
      if (addEventBtn) {
        addEventBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          const eventType = document.getElementById('optimisation-event-type').value;
          const note = document.getElementById('optimisation-event-note').value;

          if (!note.trim()) {
            alert('Please enter a note');
            return;
          }

          try {
            const headers = window.getOptimisationHeaders();
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/event`), {
              method: 'POST',
              headers: headers,
              body: JSON.stringify({ event_type: eventType, note })
            });

            if (!response.ok) throw new Error('Failed to add event');

            document.getElementById('optimisation-event-note').value = '';
            await loadOptimisationTaskEvents(taskId);
            await window.loadAllOptimisationTasks();
            
            // If it was a measurement event, refresh the modal to update badge with fresh goal_state
            if (eventType === 'measurement') {
              if (typeof debugLog === 'function') {
                debugLog(`[Optimisation] Measurement added, refreshing modal to update badge state`, 'info');
              }
              await openOptimisationTaskDrawer(taskId);
            }
          } catch (error) {
            if (typeof debugLog === 'function') {
              debugLog(`[Optimisation] Error adding event: ${error.message}`, 'error');
            }
            console.error('[Optimisation Module] Error adding event:', error);
            alert('Failed to add event: ' + error.message);
          }
        });
      }

      const saveStatusBtn = document.getElementById('optimisation-save-status-btn');
      if (saveStatusBtn) {
        saveStatusBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          const newStatus = document.getElementById('optimisation-change-status').value;
          if (!newStatus) {
            alert('Please select a status');
            return;
          }

          try {
            await window.submitStatusChange(newStatus, taskId);
            await window.loadAllOptimisationTasks();
            await openOptimisationTaskDrawer(taskId);
          } catch (error) {
            console.error('[Optimisation Module] Error changing status:', error);
            alert('Failed to change status: ' + error.message);
          }
        });
      }

      // Complete Cycle button
      const completeCycleBtn = document.getElementById('optimisation-complete-cycle-btn');
      if (completeCycleBtn) {
        completeCycleBtn.addEventListener('click', async () => {
          // Get task ID from state
          let taskId = window.optimisationModuleState?.currentTaskId;
          
          // If not in state, try to get from the drawer's displayed content
          if (!taskId && window.optimisationModuleState?.allTasks?.length > 0) {
            // Find the task that has an active cycle (most likely the one being viewed)
            const taskWithActiveCycle = window.optimisationModuleState.allTasks.find(t => t.active_cycle_id);
            if (taskWithActiveCycle) {
              taskId = taskWithActiveCycle.id;
            }
          }
          
          if (!taskId) {
            alert('No task selected. Please open a task first.');
            return;
          }

          const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
          if (!task) {
            alert('Task not found. Please refresh the page.');
            return;
          }
          
          if (!task.active_cycle_id) {
            alert('No active cycle to complete');
            return;
          }

          if (!confirm(`Complete Cycle ${task.cycle_no || task.cycle_active || 'current'}? This will close the cycle and mark it as completed.`)) {
            return;
          }

          try {
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/cycle/complete`), {
              method: 'POST',
              headers: { ...window.getOptimisationHeaders(), 'Content-Type': 'application/json' },
              body: JSON.stringify({
                action: 'complete',
                cycle_id: task.active_cycle_id
              })
            });

            if (!response.ok) {
              const error = await response.json().catch(() => ({ error: 'Unknown error' }));
              throw new Error(error.error || 'Failed to complete cycle');
            }

            const result = await response.json();
            console.log('[Optimisation] Cycle completed successfully:', result);
            
            // Update task in state
            const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
            if (taskIndex >= 0 && result.task) {
              window.optimisationModuleState.allTasks[taskIndex] = result.task;
            }

            // Reload tasks to get fresh data
            if (typeof window.loadAllOptimisationTasks === 'function') {
              await window.loadAllOptimisationTasks();
            }
            
            // Refresh drawer if it's still open for this task
            if (window.optimisationModuleState.currentTaskId === taskId) {
              if (typeof window.openOptimisationTaskDrawer === 'function') {
                await window.openOptimisationTaskDrawer(taskId);
              }
            }

            // Refresh table
            if (typeof renderOptimisationTasksTable === 'function') {
              renderOptimisationTasksTable();
            }
            
            // Show success message
            alert(`Cycle ${task.cycle_no || task.cycle_active || 'current'} has been completed successfully.`);
          } catch (error) {
            console.error('[Optimisation] Error completing cycle:', error);
            alert('Failed to complete cycle: ' + error.message);
          }
        });
      }

      // Archive Cycle button
      const archiveCycleBtn = document.getElementById('optimisation-archive-cycle-btn');
      if (archiveCycleBtn) {
        archiveCycleBtn.addEventListener('click', async () => {
          // Get task ID from state
          let taskId = window.optimisationModuleState?.currentTaskId;
          
          // If not in state, try to get from the drawer's displayed content
          if (!taskId && window.optimisationModuleState?.allTasks?.length > 0) {
            // Find the task that has an active cycle (most likely the one being viewed)
            const taskWithActiveCycle = window.optimisationModuleState.allTasks.find(t => t.active_cycle_id);
            if (taskWithActiveCycle) {
              taskId = taskWithActiveCycle.id;
            }
          }
          
          if (!taskId) {
            alert('No task selected. Please open a task first.');
            return;
          }

          const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
          if (!task) {
            alert('Task not found. Please refresh the page.');
            return;
          }
          
          if (!task.active_cycle_id) {
            alert('No active cycle to archive');
            return;
          }

          if (!confirm(`Archive Cycle ${task.cycle_no || task.cycle_active || 'current'}? This will mark the cycle as archived (for abandoned work).`)) {
            return;
          }

          try {
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/cycle/complete`), {
              method: 'POST',
              headers: { ...window.getOptimisationHeaders(), 'Content-Type': 'application/json' },
              body: JSON.stringify({
                action: 'archive',
                cycle_id: task.active_cycle_id
              })
            });

            if (!response.ok) {
              const error = await response.json().catch(() => ({ error: 'Unknown error' }));
              throw new Error(error.error || 'Failed to archive cycle');
            }

            const result = await response.json();
            console.log('[Optimisation] Cycle archived successfully:', result);
            
            // Update task in state
            const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
            if (taskIndex >= 0 && result.task) {
              window.optimisationModuleState.allTasks[taskIndex] = result.task;
            }

            // Reload tasks to get fresh data
            if (typeof window.loadAllOptimisationTasks === 'function') {
              await window.loadAllOptimisationTasks();
            }
            
            // Refresh drawer if it's still open for this task
            if (window.optimisationModuleState.currentTaskId === taskId) {
              if (typeof window.openOptimisationTaskDrawer === 'function') {
                await window.openOptimisationTaskDrawer(taskId);
              }
            }

            // Refresh table
            if (typeof renderOptimisationTasksTable === 'function') {
              renderOptimisationTasksTable();
            }
            
            // Show success message
            alert(`Cycle ${task.cycle_no || task.cycle_active || 'current'} has been archived successfully.`);
          } catch (error) {
            console.error('[Optimisation] Error archiving cycle:', error);
            alert('Failed to archive cycle: ' + error.message);
          }
        });
      }

      const startCycleBtn = document.getElementById('optimisation-start-cycle-btn');
      if (startCycleBtn) {
        startCycleBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          try {
            await window.startNewCycle();
            await window.loadAllOptimisationTasks();
            await openOptimisationTaskDrawer(taskId);
          } catch (error) {
            console.error('[Optimisation Module] Error starting cycle:', error);
            alert('Failed to start cycle: ' + error.message);
          }
        });
      }

      const cancelTaskBtn = document.getElementById('optimisation-cancel-task-btn');
      if (cancelTaskBtn) {
        cancelTaskBtn.addEventListener('click', async () => {
          if (!confirm('Cancel this task? It will be marked as cancelled but history will be preserved.')) {
            return;
          }

          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          try {
            await window.stopTracking();
            await window.loadAllOptimisationTasks();
            closeOptimisationTaskDrawer();
          } catch (error) {
            console.error('[Optimisation Module] Error cancelling task:', error);
            alert('Failed to cancel task: ' + error.message);
          }
        });
      }

      const deleteTaskBtn = document.getElementById('optimisation-delete-task-btn');
      if (deleteTaskBtn) {
        deleteTaskBtn.addEventListener('click', async () => {
          try {
            await window.deleteTask();
          } catch (error) {
            alert('Failed to delete task: ' + error.message);
          }

          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          try {
            await window.deleteTask();
            await window.loadAllOptimisationTasks();
            // Refresh Ranking & AI table if it's visible
            if (typeof window.renderRankingAiTab === 'function') {
              await window.renderRankingAiTab();
            }
            closeOptimisationTaskDrawer();
          } catch (error) {
            console.error('[Optimisation Module] Error deleting task:', error);
            alert('Failed to delete task: ' + error.message);
          }
        });
      }

      const addMeasurementBtn = document.getElementById('optimisation-add-measurement-btn');
      if (addMeasurementBtn) {
        addMeasurementBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          // Try to get current row data from Ranking & AI table if available
          const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
          if (!task) {
            alert('Task not found. Please refresh the page.');
            return;
          }

          const taskUrlForPage = task.target_url_clean || task.target_url || '';
          const hasKeyword = !!(task.keyword_text && String(task.keyword_text).trim());

          // Use shared helper functions to ensure consistency
          const { latestAudit, combinedRows } = await window.fetchLatestAuditAndCombinedRows();
          
          let currentMetrics = null;
          
          // Use shared helper functions based on task type
          if (hasKeyword) {
            if (skipKeywordTasks) {
              skippedCount += 1;
              return;
            }
            // Keyword-based task: Use keyword-specific data
            currentMetrics = await window.fetchMetricsForKeywordTask(task, latestAudit, combinedRows);
          } else if (taskUrlForPage) {
            // URL-only task: Use GSC page totals API + Ranking & AI data
            currentMetrics = await window.fetchMetricsForUrlTask(task, latestAudit, combinedRows);
          }

          // Legacy code below - keeping for now but should be removed
          // For URL-only tasks (e.g. Money Pages), prefer an exact GSC page totals fetch.
          // FIX: Also fetch Ranking & AI data so we can look up AI Overview/Citations for this URL
          if (!currentMetrics && !hasKeyword && taskUrlForPage) {
            // CRITICAL: Fetch latest audit from Supabase to get fresh ranking_ai_data for URL lookup
            let latestAuditFromSupabase = null;
            try {
              const propertyUrl = document.getElementById('propertyUrl')?.value || 
                                  localStorage.getItem('gsc_property_url') || 
                                  'https://www.alanranger.com';
              if (typeof fetchLatestAuditFromSupabase === 'function') {
                debugLog(`[Optimisation] URL task: Fetching latest audit from Supabase for Ranking & AI data...`, 'info');
                latestAuditFromSupabase = await fetchLatestAuditFromSupabase(propertyUrl, false);
                if (!skipRankingAiCheck && latestAuditFromSupabase && latestAuditFromSupabase.ranking_ai_data) {
                  try {
                    const rankingAiData = latestAuditFromSupabase.ranking_ai_data;
                    if (rankingAiData.combinedRows && Array.isArray(rankingAiData.combinedRows)) {
                      // Helper function to safely save to localStorage with size check
                      const safeSetItem = (key, value) => {
                        try {
                          const jsonStr = JSON.stringify(value);
                          const sizeKB = (new Blob([jsonStr]).size) / 1024;
                          const maxSizeKB = 4000; // Leave some headroom (browsers typically allow 5-10MB total)
                          
                          if (sizeKB > maxSizeKB) {
                            debugLog(` Data too large for localStorage (${sizeKB.toFixed(1)}KB), skipping save. Supabase is source of truth.`, 'warn');
                            return false;
                          }
                          localStorage.setItem(key, jsonStr);
                          return true;
                        } catch (err) {
                          if (err.name === 'QuotaExceededError' || err.message.includes('quota')) {
                            debugLog(` Data too large for localStorage, skipping save. Supabase is source of truth.`, 'warn');
                          } else {
                            debugLog(` Error saving to localStorage: ${err.message}`, 'warn');
                          }
                          return false;
                        }
                      };
                      
                      // Try to save, but don't fail if it's too large
                      safeSetItem('rankingAiData', rankingAiData);
                      // Always set window.rankingAiData regardless of localStorage success
                      window.rankingAiData = rankingAiData.combinedRows;
                      debugLog(`[Optimisation] URL task: Loaded ${rankingAiData.combinedRows.length} keywords from latest audit`, 'success');
                    }
                  } catch (rankingErr) {
                    debugLog(`[Optimisation] URL task: Error loading ranking_ai_data: ${rankingErr.message}`, 'warn');
                  }
                }
              }
            } catch (fetchErr) {
              debugLog(`[Optimisation] URL task: Error fetching latest audit: ${fetchErr.message}`, 'warn');
            }
            
            try {
              const property = document.getElementById('propertyUrl')?.value ||
                localStorage.getItem('gsc_property_url') ||
                localStorage.getItem('last_property_url') || '';
              if (property) {
                const range = (typeof getGscDateRange === 'function') ? getGscDateRange(28, 2) : null;
                const startDate = range?.startDate ? `&startDate=${encodeURIComponent(range.startDate)}` : '';
                const endDate = range?.endDate ? `&endDate=${encodeURIComponent(range.endDate)}` : '';
                const pageUrlForGsc = toAbsoluteUrlForGsc(taskUrlForPage, property);
                const totalsUrl = apiUrl(`/api/aigeo/gsc-page-totals?property=${encodeURIComponent(property)}&pageUrl=${encodeURIComponent(pageUrlForGsc)}${startDate}${endDate}`);
                const totalsRes = await fetch(totalsUrl);
                const totalsJson = await totalsRes.json().catch(() => null);
                const totals = totalsRes.ok && totalsJson && totalsJson.status === 'ok' ? totalsJson.data : null;
                if (totals) {
                  // Get combinedRows from multiple sources (prioritize fresh data)
                  let aiRows = [];
                  if (typeof window.getRankingAiCombinedRows === 'function') {
                    aiRows = window.getRankingAiCombinedRows();
                  }
                  if (aiRows.length === 0 && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
                    aiRows = window.rankingAiData;
                  }
                  if (aiRows.length === 0) {
                    try {
                      const local = localStorage.getItem('rankingAiData');
                      if (local) {
                        const parsed = JSON.parse(local);
                        if (parsed && Array.isArray(parsed.combinedRows)) {
                          aiRows = parsed.combinedRows;
                        }
                      }
                    } catch (e) {
                      // ignore
                    }
                  }
                  
                  debugLog(`[Optimisation] URL task: Found ${aiRows.length} combinedRows for AI lookup`, 'info');
                  
                  // ENHANCED DIAGNOSTIC: Log sample of combinedRows data structure for photography-courses-coventry
                  if (taskUrlForPage && taskUrlForPage.includes('photography-courses-coventry')) {
                    const sampleRows = aiRows.slice(0, 5).map(r => ({
                      keyword: r.keyword || 'N/A',
                      best_url: r.best_url || r.bestUrl || r.targetUrl || r.ranking_url || 'N/A',
                      has_ai_overview: r.has_ai_overview || r.hasAiOverview || r.ai_overview_present_any || false,
                      ai_alan_citations_count: r.ai_alan_citations_count || r.aiAlanCitationsCount || 0
                    }));
                    debugLog(`[Optimisation] URL task DIAGNOSTIC: Sample combinedRows (first 5): ${JSON.stringify(sampleRows, null, 2)}`, 'error');
                    debugLog(`[Optimisation] URL task DIAGNOSTIC: Task URL="${taskUrlForPage}", GSC URL="${pageUrlForGsc}"`, 'error');
                    
                    // Find rows that might match
                    const potentialMatches = aiRows.filter(r => {
                      const rowUrl = r.best_url || r.bestUrl || r.targetUrl || r.ranking_url || '';
                      return rowUrl.includes('photography-courses-coventry') || rowUrl.includes('photography-courses');
                    });
                    debugLog(`[Optimisation] URL task DIAGNOSTIC: Found ${potentialMatches.length} rows with "photography-courses" in URL`, 'error');
                    if (potentialMatches.length > 0) {
                      const matchDetails = potentialMatches.slice(0, 3).map(r => ({
                        keyword: r.keyword || 'N/A',
                        best_url: r.best_url || r.bestUrl || r.targetUrl || r.ranking_url || 'N/A',
                        has_ai_overview: r.has_ai_overview || r.hasAiOverview || r.ai_overview_present_any || false,
                        ai_alan_citations_count: r.ai_alan_citations_count || r.aiAlanCitationsCount || 0
                      }));
                      debugLog(`[Optimisation] URL task DIAGNOSTIC: Potential matches (first 3): ${JSON.stringify(matchDetails, null, 2)}`, 'error');
                    }
                  }
                  
                  // Fix 1: Ensure combinedRows is loaded before calling computeAiMetricsForPageUrl
                  if (aiRows.length === 0) {
                    debugLog(`[Optimisation] URL task: No combinedRows loaded, attempting to reload from Supabase...`, 'warn');
                    // Try to reload from Supabase if we just fetched it
                    if (latestAuditFromSupabase && latestAuditFromSupabase.ranking_ai_data) {
                      const rankingAiData = latestAuditFromSupabase.ranking_ai_data;
                      if (rankingAiData.combinedRows && Array.isArray(rankingAiData.combinedRows)) {
                        aiRows = rankingAiData.combinedRows;
                        debugLog(`[Optimisation] URL task: Reloaded ${aiRows.length} combinedRows from latest audit`, 'info');
                      }
                    }
                  }
                  
                  // Only call computeAiMetricsForPageUrl if we have data
                  let aiForUrl = { ai_overview: null, ai_citations: null };
                  if (aiRows.length > 0) {
                    // CRITICAL FIX: Check if combinedRows has ai_alan_citations arrays
                    // If not, we need to fetch from Supabase directly
                    const hasCitationsArrays = aiRows.some(r => 
                      Array.isArray(r.ai_alan_citations) && r.ai_alan_citations.length > 0
                    );
                    
                    // DIAGNOSTIC: Log the check result
                    debugLog(`[Optimisation] URL task DIAGNOSTIC: Checking for citations arrays in ${aiRows.length} rows...`, 'error');
                    debugLog(`[Optimisation] URL task DIAGNOSTIC: hasCitationsArrays=${hasCitationsArrays}`, 'error');
                    
                    // Check first few rows to see what citation data exists
                    const sampleCheck = aiRows.slice(0, 3).map(r => ({
                      keyword: r.keyword || 'N/A',
                      has_ai_alan_citations_field: r.ai_alan_citations !== undefined,
                      ai_alan_citations_type: typeof r.ai_alan_citations,
                      is_array: Array.isArray(r.ai_alan_citations),
                      array_length: Array.isArray(r.ai_alan_citations) ? r.ai_alan_citations.length : 'N/A',
                      ai_alan_citations_count: r.ai_alan_citations_count || 'N/A'
                    }));
                    debugLog(`[Optimisation] URL task DIAGNOSTIC: Sample citation data check: ${JSON.stringify(sampleCheck, null, 2)}`, 'error');
                    
                    if (!hasCitationsArrays) {
                      // combinedRows doesn't have citations arrays - try to get from latest audit first
                      let citationsFound = false;
                      
                      if (latestAuditFromSupabase && latestAuditFromSupabase.ranking_ai_data) {
                        const rankingAiData = latestAuditFromSupabase.ranking_ai_data;
                        if (rankingAiData.combinedRows && Array.isArray(rankingAiData.combinedRows)) {
                          const auditRows = rankingAiData.combinedRows;
                          const auditHasArrays = auditRows.some(r => 
                            Array.isArray(r.ai_alan_citations) && r.ai_alan_citations.length > 0
                          );
                          
                          if (auditHasArrays) {
                            // Latest audit has citations arrays - use those
                            debugLog(`[Optimisation] URL task: Using citations from latest audit ranking_ai_data`, 'info');
                            aiRows = auditRows;
                            citationsFound = true;
                          }
                        }
                      }
                      
                      if (!citationsFound) {
                        // Still no citations arrays - fetch from Supabase directly
                        debugLog(`[Optimisation] URL task: combinedRows missing ai_alan_citations arrays, fetching from Supabase...`, 'warn');
                        
                        try {
                          const propertyUrl = document.getElementById('propertyUrl')?.value || 
                                            localStorage.getItem('gsc_property_url') || 
                                            'https://www.alanranger.com';
                          
                          // Use API endpoint to query Supabase
                          const queryUrl = apiUrl(`/api/supabase/query-keywords-citing-url?` +
                            `property_url=${encodeURIComponent(propertyUrl)}&` +
                            `target_url=${encodeURIComponent(pageUrlForGsc || taskUrlForPage)}`
                          );
                          
                          debugLog(`[Optimisation] URL task DIAGNOSTIC: Fetching from Supabase API: ${queryUrl}`, 'error');
                          
                          const citationResponse = await fetch(queryUrl);
                          debugLog(`[Optimisation] URL task DIAGNOSTIC: Supabase API response status: ${citationResponse.status}`, 'error');
                          
                          if (citationResponse.ok) {
                            const citationData = await citationResponse.json();
                            debugLog(`[Optimisation] URL task DIAGNOSTIC: Supabase API response: ${JSON.stringify(citationData)}`, 'error');
                            
                            if (citationData.status === 'ok' && citationData.data && citationData.data.length > 0) {
                              const citingKeywords = citationData.data;
                              // Use total citation count from API (not unique keywords count)
                              const totalCitationCount = typeof citationData.count === 'number' ? citationData.count : citingKeywords.reduce((sum, k) => sum + (k.citation_count || 1), 0);
                              const hasOverview = citingKeywords.some(k => k.has_ai_overview === true);
                              
                              aiForUrl = {
                                ai_overview: hasOverview,
                                ai_citations: totalCitationCount // Use total citations, not unique keywords
                              };
                              
                              debugLog(
                                `[Optimisation] URL task: Found ${citingKeywords.length} keywords with ${totalCitationCount} total citations citing URL from Supabase: ` +
                                `${citingKeywords.map(k => k.keyword).join(', ')}`,
                                'success'
                              );
                            } else {
                              debugLog(`[Optimisation] URL task: No keywords found citing URL in Supabase (status: ${citationData.status}, data length: ${citationData.data?.length || 0})`, 'error');
                            }
                          } else {
                            const errorText = await citationResponse.text().catch(() => 'Unable to read error');
                            debugLog(`[Optimisation] URL task: Failed to query Supabase for citations: ${citationResponse.status} - ${errorText}`, 'error');
                          }
                        } catch (supabaseErr) {
                          debugLog(`[Optimisation] URL task: Error querying Supabase for citations: ${supabaseErr.message}`, 'error');
                          debugLog(`[Optimisation] URL task: Error stack: ${supabaseErr.stack}`, 'error');
                        }
                      }
                    }
                    
                    // If we have citations arrays (either from combinedRows or latest audit), use computeAiMetricsForPageUrl
                    // Check again after potentially updating aiRows from latest audit
                    const finalHasArrays = aiRows.some(r => 
                      Array.isArray(r.ai_alan_citations) && r.ai_alan_citations.length > 0
                    );
                    
                    if (finalHasArrays && aiForUrl.ai_overview === null && aiForUrl.ai_citations === null) {
                      // combinedRows has citations arrays - use existing logic
                      // Try both the full GSC URL and the original task URL (in case formats differ)
                      const urlsToTry = [pageUrlForGsc, taskUrlForPage];
                      
                      for (const urlToCheck of urlsToTry) {
                        if (urlToCheck) {
                          // ENHANCED DIAGNOSTIC: Log before calling function
                          if (urlToCheck.includes('photography-courses-coventry')) {
                            debugLog(`[Optimisation] URL task DIAGNOSTIC: About to call computeAiMetricsForPageUrl with url="${urlToCheck}", rowsCount=${aiRows.length}`, 'error');
                          }
                          
                          const result = (typeof window.computeAiMetricsForPageUrl === 'function')
                            ? window.computeAiMetricsForPageUrl(urlToCheck, aiRows)
                            : { ai_overview: null, ai_citations: null };
                          
                          // ENHANCED DIAGNOSTIC: Log result immediately
                          if (urlToCheck.includes('photography-courses-coventry')) {
                            debugLog(`[Optimisation] URL task DIAGNOSTIC: computeAiMetricsForPageUrl returned: ${JSON.stringify(result)}`, 'error');
                          }
                          
                          // Use first result where BOTH values are non-null (consistent match found)
                          if (result.ai_overview !== null && result.ai_citations !== null) {
                            aiForUrl = result;
                            debugLog(`[Optimisation] URL task: AI lookup for ${urlToCheck} - Overview: ${aiForUrl.ai_overview}, Citations: ${aiForUrl.ai_citations}`, 'info');
                            break;
                          } else if (result.ai_overview !== null || result.ai_citations !== null) {
                            debugLog(`[Optimisation] URL task: Inconsistent result from computeAiMetricsForPageUrl for ${urlToCheck} - Overview: ${result.ai_overview}, Citations: ${result.ai_citations}`, 'warn');
                          }
                        }
                      }
                      
                      // HARD FALLBACK: If arrays exist but we still have null, force Supabase lookup to avoid stale local data
                      if (aiForUrl.ai_overview === null && aiForUrl.ai_citations === null) {
                        debugLog(`[Optimisation] URL task: Local arrays yielded null; forcing Supabase citation lookup`, 'warn');
                        try {
                          const propertyUrl = document.getElementById('propertyUrl')?.value || 
                                            localStorage.getItem('gsc_property_url') || 
                                            'https://www.alanranger.com';
                          const queryUrl = apiUrl(`/api/supabase/query-keywords-citing-url?` +
                            `property_url=${encodeURIComponent(propertyUrl)}&` +
                            `target_url=${encodeURIComponent(pageUrlForGsc || taskUrlForPage)}`
                          );
                          
                          const citationResponse = await fetch(queryUrl);
                          if (citationResponse.ok) {
                            const citationData = await citationResponse.json();
                            if (citationData.status === 'ok' && citationData.data && citationData.data.length > 0) {
                              const citingKeywords = citationData.data;
                              // Use total citation count from API (not unique keywords count)
                              const totalCitationCount = typeof citationData.count === 'number' ? citationData.count : citingKeywords.reduce((sum, k) => sum + (k.citation_count || 1), 0);
                              const hasOverview = citingKeywords.some(k => k.has_ai_overview === true);
                              
                              aiForUrl = {
                                ai_overview: hasOverview,
                                ai_citations: totalCitationCount // Use total citations, not unique keywords
                              };
                              
                              debugLog(
                                `[Optimisation] URL task: Supabase fallback found ${citingKeywords.length} keywords with ${totalCitationCount} total citations: ` +
                                `${citingKeywords.map(k => k.keyword).join(', ')}`,
                                'success'
                              );
                            } else {
                              debugLog(`[Optimisation] URL task: Supabase fallback found no citations (status=${citationData.status})`, 'warn');
                            }
                          } else {
                            const errorText = await citationResponse.text().catch(() => 'Unable to read error');
                            debugLog(`[Optimisation] URL task: Supabase fallback failed: ${citationResponse.status} - ${errorText}`, 'error');
                          }
                        } catch (supabaseErr) {
                          debugLog(`[Optimisation] URL task: Supabase fallback error: ${supabaseErr.message}`, 'error');
                        }
                      }
                    }
                  } else {
                    debugLog(`[Optimisation] URL task: Cannot lookup AI data - no combinedRows available (${aiRows.length} rows)`, 'warn');
                  }
                  
                  // Try to get ranking from Ranking & AI data if GSC position is null
                  let rankingFromAi = null;
                  if ((totals.position == null || totals.position === 0) && aiRows.length > 0) {
                    // Find rows matching this URL and get average rank
                    const matchingRows = aiRows.filter(r => {
                      const rowUrl = (r.best_url || r.bestUrl || r.targetUrl || r.ranking_url || '').toLowerCase();
                      const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
                      const taskUrlClean = pageUrlForGsc.replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
                      return rowUrlClean === taskUrlClean || 
                             rowUrl.includes(taskUrlClean) || 
                             taskUrlClean.includes(rowUrlClean);
                    });
                    
                    if (matchingRows.length > 0) {
                      // Calculate average rank from all matching rows
                      const ranks = matchingRows
                        .map(r => r.best_rank_group || r.current_rank || null)
                        .filter(r => r != null && r > 0);
                      
                      if (ranks.length > 0) {
                        const avgRank = ranks.reduce((sum, r) => sum + r, 0) / ranks.length;
                        rankingFromAi = avgRank;
                        debugLog(`[Optimisation] URL task: Found ranking from Ranking & AI data: ${avgRank.toFixed(2)} (from ${ranks.length} keywords)`, 'info');
                      }
                    }
                  }
                  
                  currentMetrics = {
                    gsc_clicks_28d: Number(totals.clicks || 0),
                    gsc_impressions_28d: Number(totals.impressions || 0),
                    gsc_ctr_28d: Number(totals.ctr || 0), // totals.ctr is already a ratio (0-1) from fetchMetricsForUrlTask
                    // Prefer GSC position, fallback to Ranking & AI average rank
                    current_rank: totals.position != null && totals.position > 0 
                      ? Number(totals.position) 
                      : (rankingFromAi != null ? Number(rankingFromAi) : null),
                    opportunity_score: null,
                    ai_overview: aiForUrl.ai_overview === true ? true : (aiForUrl.ai_overview === false ? false : null),
                    // If ranking data isn't available, keep as null so UI shows "" (unknown) rather than 0 (false negative).
                    ai_citations: aiForUrl.ai_citations != null ? Number(aiForUrl.ai_citations) : null,
                    ai_citations_total: null,
                    classic_ranking_url: pageUrlForGsc,
                    page_type: task.page_type || null,
                    segment: task.segment || 'money_pages',
                    captured_at: new Date().toISOString()
                  };
                  console.log('[Optimisation] Built currentMetrics from GSC page totals (URL task):', currentMetrics);
                }
              }
            } catch (e) {
              console.warn('[Optimisation] Failed to fetch GSC page totals for URL task:', e);
            }
          }

          // Try to ensure Ranking & AI data is loaded (keyword-based tasks only)
          if (!currentMetrics && hasKeyword) {
            // CRITICAL: Fetch latest audit from Supabase to get fresh ranking_ai_data
            let latestAuditFromSupabase = null;
            try {
              const propertyUrl = document.getElementById('propertyUrl')?.value || 
                                  localStorage.getItem('gsc_property_url') || 
                                  'https://www.alanranger.com';
              if (typeof fetchLatestAuditFromSupabase === 'function') {
                debugLog(`[Optimisation] Fetching latest audit from Supabase for Ranking & AI data...`, 'info');
                latestAuditFromSupabase = await fetchLatestAuditFromSupabase(propertyUrl, false);
                if (latestAuditFromSupabase && latestAuditFromSupabase.ranking_ai_data) {
                  try {
                    const rankingAiData = latestAuditFromSupabase.ranking_ai_data;
                    if (rankingAiData.combinedRows && Array.isArray(rankingAiData.combinedRows)) {
                      // Helper function to safely save to localStorage with size check
                      const safeSetItem = (key, value) => {
                        try {
                          const jsonStr = JSON.stringify(value);
                          const sizeKB = (new Blob([jsonStr]).size) / 1024;
                          const maxSizeKB = 4000; // Leave some headroom (browsers typically allow 5-10MB total)
                          
                          if (sizeKB > maxSizeKB) {
                            debugLog(` Data too large for localStorage (${sizeKB.toFixed(1)}KB), skipping save. Supabase is source of truth.`, 'warn');
                            return false;
                          }
                          localStorage.setItem(key, jsonStr);
                          return true;
                        } catch (err) {
                          if (err.name === 'QuotaExceededError' || err.message.includes('quota')) {
                            debugLog(` Data too large for localStorage, skipping save. Supabase is source of truth.`, 'warn');
                          } else {
                            debugLog(` Error saving to localStorage: ${err.message}`, 'warn');
                          }
                          return false;
                        }
                      };
                      
                      // Try to save, but don't fail if it's too large
                      safeSetItem('rankingAiData', rankingAiData);
                      // Always set window.rankingAiData regardless of localStorage success
                      debugLog(`[Optimisation] Loaded ${rankingAiData.combinedRows.length} keywords from latest audit's ranking_ai_data`, 'success');
                      // Also set window.rankingAiData
                      window.rankingAiData = rankingAiData.combinedRows;
                    }
                  } catch (rankingErr) {
                    debugLog(`[Optimisation] Error loading ranking_ai_data from latest audit: ${rankingErr.message}`, 'warn');
                  }
                }
              }
            } catch (fetchErr) {
              debugLog(`[Optimisation] Error fetching latest audit from Supabase: ${fetchErr.message}`, 'warn');
            }
            
            // Also try renderRankingAiTab to refresh data
            if (typeof window.renderRankingAiTab === 'function') {
              try {
                await window.renderRankingAiTab();
                // Small delay to let data load
                await new Promise(resolve => setTimeout(resolve, 500));
              } catch (e) {
                console.warn('[Optimisation] Could not refresh Ranking & AI data:', e);
              }
            }
          }
          
          // First try RankingAiModule state
          if (!currentMetrics && hasKeyword && typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
            const { combinedRows } = RankingAiModule.state();
            console.log('[Optimisation] Searching in combinedRows:', combinedRows?.length, 'rows');
            
            // If combinedRows is empty, try to get from window.rankingAiData or localStorage
            let rowsToSearch = combinedRows;
            if (!rowsToSearch || rowsToSearch.length === 0) {
              if (typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData) && window.rankingAiData.length > 0) {
                rowsToSearch = window.rankingAiData;
                debugLog(`[Optimisation] Using window.rankingAiData (${rowsToSearch.length} rows)`, 'info');
              } else {
                try {
                  const local = localStorage.getItem('rankingAiData');
                  if (local) {
                    const parsed = JSON.parse(local);
                    if (parsed && Array.isArray(parsed.combinedRows) && parsed.combinedRows.length > 0) {
                      rowsToSearch = parsed.combinedRows;
                      debugLog(`[Optimisation] Using localStorage rankingAiData (${rowsToSearch.length} rows)`, 'info');
                    }
                  }
                } catch (e) {
                  debugLog(`[Optimisation] Error reading localStorage rankingAiData: ${e.message}`, 'warn');
                }
              }
            }
            
            // Normalize URLs for comparison
            const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
            const taskUrlPath = taskUrlClean.includes('/') ? taskUrlClean.split('/').slice(1).join('/') : '';
            
            matchingRow = rowsToSearch?.find(r => {
              const keywordMatch = (r.keyword || '').toLowerCase() === (task.keyword_text || '').toLowerCase();
              if (!keywordMatch) return false;
              
              // FIX 1: For keyword-based tasks, URL matching is optional
              // If task has no URL, keyword match is sufficient
              if (!taskUrlClean || taskUrlClean.length === 0) {
                return true; // Keyword match only - no URL required
              }
              
              // If task has URL, try to match it (preferred but not required for keyword tasks)
              const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
              const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
              const rowUrlPath = rowUrlClean.includes('/') ? rowUrlClean.split('/').slice(1).join('/') : '';
              
              const urlMatch = rowUrl === taskUrlClean || 
                              rowUrlClean === taskUrlClean ||
                              rowUrlPath === taskUrlPath ||
                              rowUrl.includes(taskUrlClean) ||
                              taskUrlClean.includes(rowUrlClean);
              
              // For keyword-based tasks: accept if URL matches OR if keyword matches (URL is optional)
              // This ensures keyword tasks can find ranking/AI data even if URLs differ slightly
              return urlMatch || true; // Always accept keyword match for keyword tasks
            });
            
            debugLog(`[Optimisation] Found matching row: ${matchingRow ? 'YES' : 'NO'} (taskKeyword: ${task.keyword_text}, taskUrl: ${task.target_url_clean || task.target_url}, rowsSearched: ${rowsToSearch?.length || 0}, matchingRowKeyword: ${matchingRow?.keyword}, matchingRowUrl: ${matchingRow?.best_url || matchingRow?.targetUrl})`, matchingRow ? 'info' : 'warn');
            
            if (matchingRow) {
              // Get queryTotal data for clicks, impressions, and CTR (same as submitTrackKeyword)
              let queryTotal = null;
              if (typeof getQueryTotalForKeyword === 'function') {
                queryTotal = getQueryTotalForKeyword(task.keyword_text);
              }
              
              currentMetrics = {
                gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
                gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
                // queryTotal.ctr is a percentage (0-100), convert to decimal for storage
                gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
                current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
                opportunity_score: matchingRow.opportunityScore || null,
                ai_overview: matchingRow.has_ai_overview || false,
                ai_citations: matchingRow.ai_alan_citations_count || 0,
                ai_citations_total: matchingRow.ai_total_citations || 0,
                classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
                page_type: matchingRow.pageType || null,
                segment: matchingRow.segment || null,
                captured_at: new Date().toISOString()
              };
            }
          }
          
          // If still no data, try to get from window.rankingAiData or localStorage
          if (!matchingRow && hasKeyword) {
            let rowsToSearch = null;
            
            // Try window.rankingAiData first
            if (typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData) && window.rankingAiData.length > 0) {
              rowsToSearch = window.rankingAiData;
              console.log('[Optimisation] Searching in window.rankingAiData:', rowsToSearch.length, 'rows');
            } else {
              // Fallback to localStorage
              try {
                const local = localStorage.getItem('rankingAiData');
                if (local) {
                  const parsed = JSON.parse(local);
                  if (parsed && Array.isArray(parsed.combinedRows) && parsed.combinedRows.length > 0) {
                    rowsToSearch = parsed.combinedRows;
                    console.log('[Optimisation] Searching in localStorage rankingAiData:', rowsToSearch.length, 'rows');
                  }
                }
              } catch (e) {
                debugLog(`[Optimisation] Error reading localStorage rankingAiData: ${e.message}`, 'warn');
              }
            }
            
            if (rowsToSearch && rowsToSearch.length > 0) {
              const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
              const taskUrlPath = taskUrlClean.includes('/') ? taskUrlClean.split('/').slice(1).join('/') : '';
              
              matchingRow = rowsToSearch.find(r => {
              const keywordMatch = (r.keyword || '').toLowerCase() === (task.keyword_text || '').toLowerCase();
              if (!keywordMatch) return false;
              
              // FIX 1: For keyword-based tasks, URL matching is optional
              // If task has no URL, keyword match is sufficient
              if (!taskUrlClean || taskUrlClean.length === 0) {
                return true; // Keyword match only - no URL required
              }
              
              // If task has URL, try to match it (preferred but not required for keyword tasks)
              const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
              const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
              const rowUrlPath = rowUrlClean.includes('/') ? rowUrlClean.split('/').slice(1).join('/') : '';
              
              const urlMatch = rowUrl === taskUrlClean || 
                              rowUrlClean === taskUrlClean ||
                              rowUrlPath === taskUrlPath ||
                              rowUrl.includes(taskUrlClean) ||
                              taskUrlClean.includes(rowUrlClean);
              
              // For keyword-based tasks: accept if URL matches OR if keyword matches (URL is optional)
              // This ensures keyword tasks can find ranking/AI data even if URLs differ slightly
              return urlMatch || true; // Always accept keyword match for keyword tasks
            });
            
              debugLog(`[Optimisation] Found matching row in window.rankingAiData/localStorage: ${matchingRow ? 'YES' : 'NO'} (rowsSearched: ${rowsToSearch.length})`, matchingRow ? 'info' : 'warn');
              
              // Build metrics from matching row if found
              if (matchingRow && !currentMetrics) {
                // Get queryTotal data for clicks, impressions, and CTR
                let queryTotal = null;
                if (typeof getQueryTotalForKeyword === 'function') {
                  queryTotal = getQueryTotalForKeyword(task.keyword_text);
                }
                
                currentMetrics = {
                  gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
                  gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
                  gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
                  current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
                  opportunity_score: matchingRow.opportunityScore || null,
                  ai_overview: matchingRow.has_ai_overview === true || matchingRow.ai_overview_present_any === true,
                  ai_citations: matchingRow.ai_alan_citations_count != null ? Number(matchingRow.ai_alan_citations_count) : 0,
                  ai_citations_total: matchingRow.ai_total_citations != null ? Number(matchingRow.ai_total_citations) : 0,
                  classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || taskUrl,
                  page_type: matchingRow.pageType || null,
                  segment: matchingRow.segment || null,
                  captured_at: new Date().toISOString()
                };
                debugLog(`[Optimisation] Built currentMetrics from window.rankingAiData/localStorage: rank=${currentMetrics.current_rank}, ai_overview=${currentMetrics.ai_overview}`, 'success');
              }
            } else {
              debugLog(`[Optimisation] No ranking AI data available in window.rankingAiData or localStorage`, 'warn');
            }
          }
          
          // Build metrics from matching row if found (legacy fallback - should already be set above)
          if (matchingRow && !currentMetrics) {
            // Get queryTotal data for clicks, impressions, and CTR (same as submitTrackKeyword)
            let queryTotal = null;
            if (typeof getQueryTotalForKeyword === 'function') {
              queryTotal = getQueryTotalForKeyword(task.keyword_text);
              debugLog(`[Optimisation] QueryTotal for keyword: ${JSON.stringify(queryTotal)}`, 'info');
            }
            
            currentMetrics = {
              gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
              gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
              // queryTotal.ctr is a percentage (0-100), convert to decimal for storage
              gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
              current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
              opportunity_score: matchingRow.opportunityScore || null,
              ai_overview: matchingRow.has_ai_overview || false,
              ai_citations: matchingRow.ai_alan_citations_count || 0,
              ai_citations_total: matchingRow.ai_total_citations || 0,
              classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
              page_type: matchingRow.pageType || null,
              segment: matchingRow.segment || null,
              captured_at: new Date().toISOString()
            };
            
            debugLog(`[Optimisation] Built currentMetrics from matching row: ${JSON.stringify(currentMetrics)}`, 'info');
          }

          // If no current data from Ranking & AI, try Money Pages data
          if (!currentMetrics) {
            debugLog('[Optimisation] No Ranking & AI data found, checking Money Pages data...', 'info');
            const taskUrl = task.target_url_clean || task.target_url || '';
            const taskKeyword = task.keyword_text || '';
            const normalizedTaskUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(taskUrl) : taskUrl.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
            
              // Check window.moneyPagesMetrics
              if (window.moneyPagesMetrics && window.moneyPagesMetrics.rows) {
                const moneyPageRow = window.moneyPagesMetrics.rows.find(row => {
                  const rowUrl = row.url || row.page_url || '';
                  const normalizedRowUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(rowUrl) : rowUrl.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                  return normalizedRowUrl === normalizedTaskUrl;
                });
                
                if (moneyPageRow) {
                  debugLog(`[Optimisation] Found matching Money Page row: ${JSON.stringify({ url: moneyPageRow.url || moneyPageRow.page_url, clicks: moneyPageRow.clicks, impressions: moneyPageRow.impressions, ctr: moneyPageRow.ctr })}`, 'info');
                  // Normalize CTR: Money Pages stores CTR as ratio (0-1), but check if it's actually a percentage
                  let ctrValue = moneyPageRow.ctr || moneyPageRow.ctr_28d || null;
                  if (ctrValue != null) {
                    // If CTR is > 1, assume it's a percentage and convert to ratio
                    if (ctrValue > 1 && ctrValue <= 100) {
                      debugLog(`[Optimisation] Money Pages CTR appears to be percentage, converting to ratio: ${ctrValue} -> ${ctrValue / 100}`, 'warn');
                      ctrValue = ctrValue / 100;
                    } else if (ctrValue > 100) {
                      debugLog(`[Optimisation] Money Pages CTR value seems invalid (>100%): ${ctrValue}`, 'error');
                      ctrValue = null;
                    }
                    // If CTR is <= 1, assume it's already a ratio (0-1)
                  }
                currentMetrics = {
                  gsc_clicks_28d: moneyPageRow.clicks || moneyPageRow.clicks_28d || null,
                  gsc_impressions_28d: moneyPageRow.impressions || moneyPageRow.impressions_28d || null,
                  gsc_ctr_28d: ctrValue, // Normalized to ratio (0-1)
                  current_rank: moneyPageRow.avg_position || moneyPageRow.position || null,
                  opportunity_score: null,
                  // Derive AI metrics from cited URLs if ranking data is available
                  ai_overview: (typeof window.computeAiMetricsForPageUrl === 'function')
                    ? !!window.computeAiMetricsForPageUrl(moneyPageRow.url || moneyPageRow.page_url || taskUrl, (typeof window.getRankingAiCombinedRows === 'function') ? window.getRankingAiCombinedRows() : []).ai_overview
                    : false,
                  ai_citations: (typeof window.computeAiMetricsForPageUrl === 'function')
                    ? (window.computeAiMetricsForPageUrl(moneyPageRow.url || moneyPageRow.page_url || taskUrl, (typeof window.getRankingAiCombinedRows === 'function') ? window.getRankingAiCombinedRows() : []).ai_citations ?? null)
                    : null,
                  ai_citations_total: null,
                  classic_ranking_url: moneyPageRow.url || moneyPageRow.page_url || taskUrl,
                  page_type: moneyPageRow.page_type || moneyPageRow.type || null,
                  segment: 'money_pages',
                  captured_at: new Date().toISOString()
                };
                debugLog(`[Optimisation] Built currentMetrics from Money Page row: ${JSON.stringify(currentMetrics)}`, 'info');
              }
            }
            
            // If still no data, check localStorage/Supabase audit results
            if (!currentMetrics) {
              debugLog('[Optimisation] Checking localStorage/Supabase audit results...', 'info');
              try {
                // Check both keys: last_audit_results (current) and aigeo_audit_data (legacy)
                let savedAudit = localStorage.getItem('last_audit_results');
                if (!savedAudit) {
                  savedAudit = localStorage.getItem('aigeo_audit_data');
                }
                if (savedAudit) {
                  const parsed = JSON.parse(savedAudit);
                  const moneyPagesData = parsed.scores?.moneyPagesMetrics || parsed.moneyPagesMetrics;
                  
                  if (moneyPagesData && moneyPagesData.rows) {
                    const moneyPageRow = moneyPagesData.rows.find(row => {
                      const rowUrl = row.url || row.page_url || '';
                      const normalizedRowUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(rowUrl) : rowUrl.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                      return normalizedRowUrl === normalizedTaskUrl;
                    });
                    
                    if (moneyPageRow) {
                      debugLog(`[Optimisation] Found matching Money Page row in localStorage: ${JSON.stringify({ url: moneyPageRow.url || moneyPageRow.page_url, clicks: moneyPageRow.clicks, impressions: moneyPageRow.impressions, ctr: moneyPageRow.ctr })}`, 'info');
                      // Normalize CTR: Money Pages stores CTR as ratio (0-1), but check if it's actually a percentage
                      let ctrValue = moneyPageRow.ctr || moneyPageRow.ctr_28d || null;
                      if (ctrValue != null) {
                        // If CTR is > 1, assume it's a percentage and convert to ratio
                        if (ctrValue > 1 && ctrValue <= 100) {
                          debugLog(`[Optimisation] Money Pages CTR appears to be percentage, converting to ratio: ${ctrValue} -> ${ctrValue / 100}`, 'warn');
                          ctrValue = ctrValue / 100;
                        } else if (ctrValue > 100) {
                          debugLog(`[Optimisation] Money Pages CTR value seems invalid (>100%): ${ctrValue}`, 'error');
                          ctrValue = null;
                        }
                        // If CTR is <= 1, assume it's already a ratio (0-1)
                      }
                      currentMetrics = {
                        gsc_clicks_28d: moneyPageRow.clicks || moneyPageRow.clicks_28d || null,
                        gsc_impressions_28d: moneyPageRow.impressions || moneyPageRow.impressions_28d || null,
                        gsc_ctr_28d: ctrValue, // Normalized to ratio (0-1)
                        current_rank: moneyPageRow.avg_position || moneyPageRow.position || null,
                        opportunity_score: null,
                        ai_overview: (typeof window.computeAiMetricsForPageUrl === 'function')
                          ? !!window.computeAiMetricsForPageUrl(moneyPageRow.url || moneyPageRow.page_url || taskUrl, (typeof window.getRankingAiCombinedRows === 'function') ? window.getRankingAiCombinedRows() : []).ai_overview
                          : false,
                        ai_citations: (typeof window.computeAiMetricsForPageUrl === 'function')
                          ? (window.computeAiMetricsForPageUrl(moneyPageRow.url || moneyPageRow.page_url || taskUrl, (typeof window.getRankingAiCombinedRows === 'function') ? window.getRankingAiCombinedRows() : []).ai_citations ?? null)
                          : null,
                        ai_citations_total: null,
                        classic_ranking_url: moneyPageRow.url || moneyPageRow.page_url || taskUrl,
                        page_type: moneyPageRow.page_type || moneyPageRow.type || null,
                        segment: 'money_pages',
                        captured_at: new Date().toISOString()
                      };
                      debugLog(`[Optimisation] Built currentMetrics from localStorage Money Page row: clicks=${currentMetrics.gsc_clicks_28d}, impressions=${currentMetrics.gsc_impressions_28d}, ctr=${currentMetrics.gsc_ctr_28d}, rank=${currentMetrics.current_rank}`, 'info');
                    }
                  }
                  
                  // Also check searchData.queryTotals for URL-based matching
                  if (!currentMetrics && parsed.searchData && parsed.searchData.queryTotals) {
                    // Find query totals that match the URL (for page-level tasks) OR keyword (for keyword-based tasks)
                    const matchingQueries = parsed.searchData.queryTotals.filter(qt => {
                      // URL-based matching (for page-level tasks)
                      if (normalizedTaskUrl && normalizedTaskUrl.length > 0) {
                        const qtUrl = (qt.best_url || qt.targetUrl || '').toLowerCase();
                        const normalizedQtUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(qtUrl) : qtUrl.replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                          if (normalizedQtUrl === normalizedTaskUrl) {
                          return true;
                        }
                      }
                      // Keyword-based matching (for keyword-based tasks)
                      if (taskKeyword && taskKeyword.length > 0) {
                        const qtKeyword = (qt.query || qt.keyword || '').toLowerCase();
                        if (qtKeyword === taskKeyword.toLowerCase()) {
                          return true;
                        }
                      }
                      return false;
                    });
                    
                    if (matchingQueries.length > 0) {
                      // For URL-based matching, aggregate all queries for that URL (page-level data)
                      // For keyword-based matching, use the first match (query-level data)
                      if (normalizedTaskUrl && normalizedTaskUrl.length > 0 && matchingQueries.length > 1) {
                        // URL-based: aggregate all queries for this URL
                        const totalClicks = matchingQueries.reduce((sum, qt) => sum + (qt.clicks || 0), 0);
                        const totalImpressions = matchingQueries.reduce((sum, qt) => sum + (qt.impressions || 0), 0);
                        const weightedCtr = totalImpressions > 0 ? totalClicks / totalImpressions : null;
                        // Use best rank from the query with highest clicks
                        const bestQuery = matchingQueries.reduce((best, qt) => 
                          (qt.clicks || 0) > (best.clicks || 0) ? qt : best, matchingQueries[0]);
                        debugLog(`[Optimisation] Aggregated ${matchingQueries.length} queries for URL: ${totalClicks} clicks, ${totalImpressions} impressions`, 'info');
                        currentMetrics = {
                          gsc_clicks_28d: totalClicks || null,
                          gsc_impressions_28d: totalImpressions || null,
                          gsc_ctr_28d: weightedCtr, // Already a ratio (0-1)
                          current_rank: bestQuery.best_rank || bestQuery.avg_position || null,
                          opportunity_score: bestQuery.opportunityScore || null,
                          ai_overview: matchingQueries.some(qt => qt.has_ai_overview) || false,
                          ai_citations: matchingQueries.reduce((sum, qt) => sum + (qt.ai_alan_citations_count || 0), 0),
                          ai_citations_total: matchingQueries.reduce((sum, qt) => sum + (qt.ai_total_citations || 0), 0),
                          classic_ranking_url: bestQuery.best_url || bestQuery.targetUrl || taskUrl,
                          page_type: bestQuery.pageType || null,
                          segment: bestQuery.segment || null,
                          captured_at: new Date().toISOString()
                        };
                      } else {
                        // Keyword-based or single match: use first query
                        const qt = matchingQueries[0];
                        debugLog(`[Optimisation] Found matching query totals: ${JSON.stringify({ keyword: qt.keyword || qt.query, clicks: qt.clicks, impressions: qt.impressions, ctr: qt.ctr, best_rank: qt.best_rank })}`, 'info');
                        currentMetrics = {
                          gsc_clicks_28d: qt.clicks || null,
                          gsc_impressions_28d: qt.impressions || null,
                          gsc_ctr_28d: qt.ctr != null ? (qt.ctr / 100) : null, // Convert percentage to ratio
                          current_rank: qt.best_rank || qt.avg_position || null,
                          opportunity_score: qt.opportunityScore || null,
                          ai_overview: qt.has_ai_overview || false,
                          ai_citations: qt.ai_alan_citations_count || 0,
                          ai_citations_total: qt.ai_total_citations || 0,
                          classic_ranking_url: qt.best_url || qt.targetUrl || taskUrl,
                          page_type: qt.pageType || null,
                          segment: qt.segment || null,
                          captured_at: new Date().toISOString()
                        };
                      }
                      debugLog(`[Optimisation] Built currentMetrics from query totals: clicks=${currentMetrics.gsc_clicks_28d}, impressions=${currentMetrics.gsc_impressions_28d}, ctr=${currentMetrics.gsc_ctr_28d}, rank=${currentMetrics.current_rank}`, 'info');
                    }
                  }
                  
                  // Also check query_pages for URL-based matching (query+page level data)
                  // First try scores.query_pages, then searchData.queryPages (where fresh audit data stores it)
                  if (!currentMetrics) {
                    let queryPages = [];
                    if (parsed.scores && parsed.scores.query_pages && Array.isArray(parsed.scores.query_pages)) {
                      queryPages = parsed.scores.query_pages;
                    } else if (parsed.searchData && parsed.searchData.queryPages && Array.isArray(parsed.searchData.queryPages)) {
                      queryPages = parsed.searchData.queryPages;
                    }
                    
                    if (queryPages.length > 0) {
                      // For keyword-based tasks, match by keyword first, then URL
                      // For URL-based tasks, match by URL
                      let matchingQueryPage = null;
                      if (taskKeyword && taskKeyword.length > 0) {
                        // Keyword-based: find by keyword, then match URL if provided
                        matchingQueryPage = queryPages.find(qp => {
                          const qpKeyword = (qp.query || qp.keyword || '').toLowerCase();
                          if (qpKeyword !== taskKeyword.toLowerCase()) return false;
                          // If URL is provided, also match URL
                          if (normalizedTaskUrl && normalizedTaskUrl.length > 0) {
                            const qpUrl = (qp.page || qp.url || '').toLowerCase();
                            const normalizedQpUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(qpUrl) : qpUrl.replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                            return normalizedQpUrl === normalizedTaskUrl;
                          }
                          return true; // Keyword match is enough if no URL
                        });
                      }
                      
                      // If no keyword match or URL-based task, try URL matching
                      if (!matchingQueryPage && normalizedTaskUrl && normalizedTaskUrl.length > 0) {
                        matchingQueryPage = queryPages.find(qp => {
                          const qpUrl = (qp.page || qp.url || '').toLowerCase();
                          const normalizedQpUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(qpUrl) : qpUrl.replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                          return normalizedQpUrl === normalizedTaskUrl;
                        });
                      }
                      
                      if (matchingQueryPage) {
                        debugLog(`[Optimisation] Found matching query_pages entry: ${JSON.stringify({ url: matchingQueryPage.url, clicks: matchingQueryPage.clicks, impressions: matchingQueryPage.impressions, ctr: matchingQueryPage.ctr, position: matchingQueryPage.position })}`, 'info');
                        currentMetrics = {
                          gsc_clicks_28d: matchingQueryPage.clicks || null,
                          gsc_impressions_28d: matchingQueryPage.impressions || null,
                          gsc_ctr_28d: matchingQueryPage.ctr != null ? (matchingQueryPage.ctr / 100) : null,
                          current_rank: matchingQueryPage.position || matchingQueryPage.avg_position || null,
                          opportunity_score: null,
                          ai_overview: false,
                          ai_citations: 0,
                          ai_citations_total: 0,
                          classic_ranking_url: matchingQueryPage.page || matchingQueryPage.url || taskUrl,
                          page_type: null,
                          segment: null,
                          captured_at: new Date().toISOString()
                        };
                        console.log('[Optimisation] Built currentMetrics from query_pages:', currentMetrics);
                      }
                    }
                  }
                }
              } catch (e) {
                console.warn('[Optimisation] Error checking localStorage:', e);
              }
            }
            
            // If still no data, query Supabase directly for latest audit data
            if (!currentMetrics) {
              debugLog('[Optimisation] Querying Supabase for latest audit data...', 'info');
              try {
                const propertyUrl = document.getElementById('propertyUrl')?.value || localStorage.getItem('gsc_property_url') || 'https://www.alanranger.com';
                if (typeof fetchLatestAuditFromSupabase === 'function') {
                  const supabaseData = await fetchLatestAuditFromSupabase(propertyUrl);
                  if (supabaseData) {
                    console.log('[Optimisation] Fetched latest audit from Supabase, searching for URL/keyword match...');
                    
                    // Check Money Pages data from Supabase
                    const moneyPagesData = supabaseData.scores?.moneyPagesMetrics || supabaseData.moneyPagesMetrics;
                    if (moneyPagesData && moneyPagesData.rows) {
                      const moneyPageRow = moneyPagesData.rows.find(row => {
                        const rowUrl = row.url || row.page_url || '';
                        const normalizedRowUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(rowUrl) : rowUrl.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                        return normalizedRowUrl === normalizedTaskUrl;
                      });
                      
                      if (moneyPageRow) {
                        debugLog(`[Optimisation] Found matching Money Page row in Supabase: ${JSON.stringify({ url: moneyPageRow.url || moneyPageRow.page_url, clicks: moneyPageRow.clicks, impressions: moneyPageRow.impressions, ctr: moneyPageRow.ctr })}`, 'info');
                        // Normalize CTR: Money Pages stores CTR as ratio (0-1), but check if it's actually a percentage
                        let ctrValue = moneyPageRow.ctr || moneyPageRow.ctr_28d || null;
                        if (ctrValue != null) {
                          // If CTR is > 1, assume it's a percentage and convert to ratio
                          if (ctrValue > 1 && ctrValue <= 100) {
                            debugLog(`[Optimisation] Money Pages CTR appears to be percentage, converting to ratio: ${ctrValue} -> ${ctrValue / 100}`, 'warn');
                            ctrValue = ctrValue / 100;
                          } else if (ctrValue > 100) {
                            debugLog(`[Optimisation] Money Pages CTR value seems invalid (>100%): ${ctrValue}`, 'error');
                            ctrValue = null;
                          }
                          // If CTR is <= 1, assume it's already a ratio (0-1)
                        }
                        currentMetrics = {
                          gsc_clicks_28d: moneyPageRow.clicks || moneyPageRow.clicks_28d || null,
                          gsc_impressions_28d: moneyPageRow.impressions || moneyPageRow.impressions_28d || null,
                          gsc_ctr_28d: ctrValue, // Normalized to ratio (0-1)
                          current_rank: moneyPageRow.avg_position || moneyPageRow.position || null,
                          opportunity_score: null,
                          ai_overview: false,
                          ai_citations: 0,
                          ai_citations_total: 0,
                          classic_ranking_url: moneyPageRow.url || moneyPageRow.page_url || taskUrl,
                          page_type: moneyPageRow.page_type || moneyPageRow.type || null,
                          segment: 'money_pages',
                          captured_at: new Date().toISOString()
                        };
                        console.log('[Optimisation] Built currentMetrics from Supabase Money Page row:', currentMetrics);
                      }
                    }
                    
                    // Check queryTotals from Supabase (supports both keyword and URL matching)
                    if (!currentMetrics && supabaseData.searchData && supabaseData.searchData.queryTotals) {
                      const matchingQueries = supabaseData.searchData.queryTotals.filter(qt => {
                        // URL-based matching (for page-level tasks)
                        if (normalizedTaskUrl && normalizedTaskUrl.length > 0) {
                          const qtUrl = (qt.best_url || qt.targetUrl || '').toLowerCase();
                          const normalizedQtUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(qtUrl) : qtUrl.replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                          if (normalizedQtUrl === normalizedTaskUrl) {
                            return true;
                          }
                        }
                        // Keyword-based matching (for keyword-based tasks)
                        if (taskKeyword && taskKeyword.length > 0) {
                          const qtKeyword = (qt.query || qt.keyword || '').toLowerCase();
                          if (qtKeyword === taskKeyword.toLowerCase()) {
                            return true;
                          }
                        }
                        return false;
                      });
                      
                      if (matchingQueries.length > 0) {
                        // For URL-based matching, aggregate all queries for that URL (page-level data)
                        // For keyword-based matching, use the first match (query-level data)
                        if (normalizedTaskUrl && normalizedTaskUrl.length > 0 && matchingQueries.length > 1) {
                          // URL-based: aggregate all queries for this URL
                          const totalClicks = matchingQueries.reduce((sum, qt) => sum + (qt.clicks || 0), 0);
                          const totalImpressions = matchingQueries.reduce((sum, qt) => sum + (qt.impressions || 0), 0);
                          const weightedCtr = totalImpressions > 0 ? totalClicks / totalImpressions : null;
                          // Use best rank from the query with highest clicks
                          const bestQuery = matchingQueries.reduce((best, qt) => 
                            (qt.clicks || 0) > (best.clicks || 0) ? qt : best, matchingQueries[0]);
                          console.log(`[Optimisation] Aggregated ${matchingQueries.length} queries from Supabase for URL: ${totalClicks} clicks, ${totalImpressions} impressions`);
                          currentMetrics = {
                            gsc_clicks_28d: totalClicks || null,
                            gsc_impressions_28d: totalImpressions || null,
                            gsc_ctr_28d: weightedCtr, // Already a ratio (0-1)
                            current_rank: bestQuery.best_rank || bestQuery.avg_position || null,
                            opportunity_score: bestQuery.opportunityScore || null,
                            ai_overview: matchingQueries.some(qt => qt.has_ai_overview) || false,
                            ai_citations: matchingQueries.reduce((sum, qt) => sum + (qt.ai_alan_citations_count || 0), 0),
                            ai_citations_total: matchingQueries.reduce((sum, qt) => sum + (qt.ai_total_citations || 0), 0),
                            classic_ranking_url: bestQuery.best_url || bestQuery.targetUrl || taskUrl,
                            page_type: bestQuery.pageType || null,
                            segment: bestQuery.segment || null,
                            captured_at: new Date().toISOString()
                          };
                        } else {
                          // Keyword-based or single match: use first query
                          const qt = matchingQueries[0];
                          debugLog(`[Optimisation] Found matching query totals in Supabase: ${JSON.stringify({ keyword: qt.keyword || qt.query, clicks: qt.clicks, impressions: qt.impressions, ctr: qt.ctr, best_rank: qt.best_rank })}`, 'info');
                          currentMetrics = {
                            gsc_clicks_28d: qt.clicks || null,
                            gsc_impressions_28d: qt.impressions || null,
                            gsc_ctr_28d: qt.ctr != null ? (qt.ctr / 100) : null,
                            current_rank: qt.best_rank || qt.avg_position || null,
                            opportunity_score: qt.opportunityScore || null,
                            ai_overview: qt.has_ai_overview || false,
                            ai_citations: qt.ai_alan_citations_count || 0,
                            ai_citations_total: qt.ai_total_citations || 0,
                            classic_ranking_url: qt.best_url || qt.targetUrl || taskUrl,
                            page_type: qt.pageType || null,
                            segment: qt.segment || null,
                            captured_at: new Date().toISOString()
                          };
                        }
                        console.log('[Optimisation] Built currentMetrics from Supabase query totals:', currentMetrics);
                      }
                    }
                    
                    // Check query_pages from Supabase (query+page level data)
                    // First try scores.query_pages, then searchData.queryPages (where fresh audit data stores it)
                    if (!currentMetrics) {
                      let queryPages = [];
                      if (supabaseData.scores && supabaseData.scores.query_pages && Array.isArray(supabaseData.scores.query_pages)) {
                        queryPages = supabaseData.scores.query_pages;
                      } else if (supabaseData.searchData && supabaseData.searchData.queryPages && Array.isArray(supabaseData.searchData.queryPages)) {
                        queryPages = supabaseData.searchData.queryPages;
                      }
                      
                      if (queryPages.length > 0) {
                        // For keyword-based tasks, match by keyword first, then URL
                        // For URL-based tasks, match by URL
                        let matchingQueryPage = null;
                        if (taskKeyword && taskKeyword.length > 0) {
                          // Keyword-based: find by keyword, then match URL if provided
                          matchingQueryPage = queryPages.find(qp => {
                            const qpKeyword = (qp.query || qp.keyword || '').toLowerCase();
                            if (qpKeyword !== taskKeyword.toLowerCase()) return false;
                            // If URL is provided, also match URL
                            if (normalizedTaskUrl && normalizedTaskUrl.length > 0) {
                              const qpUrl = (qp.page || qp.url || '').toLowerCase();
                              const normalizedQpUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(qpUrl) : qpUrl.replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                              return normalizedQpUrl === normalizedTaskUrl;
                            }
                            return true; // Keyword match is enough if no URL
                          });
                        }
                        
                        // If no keyword match or URL-based task, try URL matching
                        if (!matchingQueryPage && normalizedTaskUrl && normalizedTaskUrl.length > 0) {
                          matchingQueryPage = queryPages.find(qp => {
                            const qpUrl = (qp.page || qp.url || '').toLowerCase();
                            const normalizedQpUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(qpUrl) : qpUrl.replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                            return normalizedQpUrl === normalizedTaskUrl;
                          });
                        }
                        
                        if (matchingQueryPage) {
                          debugLog(`[Optimisation] Found matching query_pages in Supabase: ${JSON.stringify({ url: matchingQueryPage.url, clicks: matchingQueryPage.clicks, impressions: matchingQueryPage.impressions, ctr: matchingQueryPage.ctr, position: matchingQueryPage.position })}`, 'info');
                          currentMetrics = {
                            gsc_clicks_28d: matchingQueryPage.clicks || null,
                            gsc_impressions_28d: matchingQueryPage.impressions || null,
                            gsc_ctr_28d: matchingQueryPage.ctr != null ? (matchingQueryPage.ctr / 100) : null,
                            current_rank: matchingQueryPage.position || matchingQueryPage.avg_position || null,
                            opportunity_score: null,
                            ai_overview: false,
                            ai_citations: 0,
                            ai_citations_total: 0,
                            classic_ranking_url: matchingQueryPage.page || matchingQueryPage.url || taskUrl,
                            page_type: null,
                            segment: null,
                            captured_at: new Date().toISOString()
                          };
                          console.log('[Optimisation] Built currentMetrics from Supabase query_pages:', currentMetrics);
                        }
                      }
                    }
                  }
                }
              } catch (e) {
                console.warn('[Optimisation] Error querying Supabase:', e);
              }
            }
          }

          // If no current data, try to use baseline metrics (if no new audit, current = baseline)
          if (!currentMetrics) {
            debugLog(`[Optimisation] No matching row found in Ranking & AI, Money Pages, or audit data for task ${task.id}: keyword="${task.keyword_text || 'none'}", url="${task.target_url_clean || task.target_url || 'none'}"`, 'warn');
            
            // Check if we have baseline metrics to reuse
            const baselineMetrics = task.baseline_metrics;
            if (baselineMetrics && typeof baselineMetrics === 'object') {
              console.log('[Optimisation] Using baseline metrics as current (no new audit data found)');
              // Reuse baseline metrics but update captured_at to current timestamp
              currentMetrics = {
                ...baselineMetrics,
                captured_at: new Date().toISOString()
              };
            } else {
              // No baseline either, ask user
              const proceed = confirm('Could not find current ranking data for this keyword/URL. Create measurement with current timestamp only?');
              if (!proceed) return;
              
              // Create minimal metrics with just captured_at
              currentMetrics = {
                captured_at: new Date().toISOString()
              };
            }
          }

          try {
            const headers = window.getOptimisationHeaders();
            console.log('[Optimisation] Adding measurement with metrics:', currentMetrics);
            
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/measurement`), {
              method: 'POST',
              headers: headers,
              body: JSON.stringify({
                metrics: currentMetrics,
                note: 'Measurement snapshot'
              })
            });

            if (!response.ok) {
              const errorText = await response.text();
              console.error('[Optimisation] Measurement error response:', errorText);
              throw new Error(errorText || 'Failed to add measurement');
            }

            const responseData = await response.json();
            console.log('[Optimisation] Measurement response:', responseData);

            // Reload tasks to get fresh data from view
            await window.loadAllOptimisationTasks();
            
            // If the response includes updated task data, use it to update state immediately
            if (responseData.task) {
              const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
              if (taskIndex >= 0) {
                window.optimisationModuleState.allTasks[taskIndex] = responseData.task;
                console.log('[Optimisation] Updated task in state with latest_metrics:', responseData.task.latest_metrics);
              } else {
                // Task not in state yet, add it
                window.optimisationModuleState.allTasks.push(responseData.task);
              }
            }
            
            // Refresh drawer with updated data
            await openOptimisationTaskDrawer(taskId);
            
            alert('Measurement added successfully!');
          } catch (error) {
            console.error('[Optimisation Module] Error adding measurement:', error);
            alert('Failed to add measurement: ' + error.message);
          }
        });
      }

      const rebaselineBtn = document.getElementById('optimisation-rebaseline-btn');
      if (rebaselineBtn) {
        rebaselineBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
          if (!task) {
            alert('Task not found. Please refresh the page.');
            return;
          }

          if (!confirm('Create a new baseline measurement for the current cycle? This keeps history, but baseline comparisons will use the newest baseline.')) {
            return;
          }

          const taskUrlForPage = task.target_url_clean || task.target_url || '';
          const hasKeyword = !!(task.keyword_text && String(task.keyword_text).trim());

          // Use shared helper functions to ensure consistency
          const { latestAudit, combinedRows } = await window.fetchLatestAuditAndCombinedRows();
          
          let currentMetrics = null;
          
          // Use shared helper functions based on task type
          if (hasKeyword) {
            // Keyword-based task: Use keyword-specific data
            currentMetrics = await window.fetchMetricsForKeywordTask(task, latestAudit, combinedRows);
          } else if (taskUrlForPage) {
            // URL-only task: Use GSC page totals API + Ranking & AI data
            currentMetrics = await window.fetchMetricsForUrlTask(task, latestAudit, combinedRows);
          }

          // Legacy code below - keeping for now but should be removed
          // FIX: For keyword tasks, use same logic as "Add Measurement" to fetch Ranking & AI data
          if (!currentMetrics && hasKeyword) {
            // CRITICAL: Fetch latest audit from Supabase to get fresh ranking_ai_data
            let latestAuditFromSupabase = null;
            try {
              const propertyUrl = document.getElementById('propertyUrl')?.value || 
                                  localStorage.getItem('gsc_property_url') || 
                                  'https://www.alanranger.com';
              if (typeof fetchLatestAuditFromSupabase === 'function') {
                debugLog(`[Optimisation] Rebaseline: Fetching latest audit from Supabase for Ranking & AI data...`, 'info');
                latestAuditFromSupabase = await fetchLatestAuditFromSupabase(propertyUrl, false);
                if (latestAuditFromSupabase && latestAuditFromSupabase.ranking_ai_data) {
                  try {
                    const rankingAiData = latestAuditFromSupabase.ranking_ai_data;
                    if (rankingAiData.combinedRows && Array.isArray(rankingAiData.combinedRows)) {
                      localStorage.setItem('rankingAiData', JSON.stringify(rankingAiData));
                      window.rankingAiData = rankingAiData.combinedRows;
                      debugLog(`[Optimisation] Rebaseline: Loaded ${rankingAiData.combinedRows.length} keywords from latest audit`, 'success');
                    }
                  } catch (rankingErr) {
                    debugLog(`[Optimisation] Rebaseline: Error loading ranking_ai_data: ${rankingErr.message}`, 'warn');
                  }
                }
              }
            } catch (fetchErr) {
              debugLog(`[Optimisation] Rebaseline: Error fetching latest audit: ${fetchErr.message}`, 'warn');
            }

            // Try to get from RankingAiModule or window.rankingAiData or localStorage
            let combinedRows = [];
            if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
              const state = RankingAiModule.state();
              combinedRows = state.combinedRows || [];
            }
            if (combinedRows.length === 0 && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
              combinedRows = window.rankingAiData;
            }
            if (combinedRows.length === 0) {
              try {
                const local = localStorage.getItem('rankingAiData');
                if (local) {
                  const parsed = JSON.parse(local);
                  if (parsed && Array.isArray(parsed.combinedRows)) {
                    combinedRows = parsed.combinedRows;
                  }
                }
              } catch (e) {
                debugLog(`[Optimisation] Rebaseline: Error reading localStorage rankingAiData: ${e.message}`, 'warn');
              }
            }

            // Find matching row with optional URL matching (same as Add Measurement)
            if (combinedRows.length > 0) {
              const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
              const taskUrlPath = taskUrlClean.includes('/') ? taskUrlClean.split('/').slice(1).join('/') : '';
              
              const matchingRow = combinedRows.find(r => {
                const keywordMatch = (r.keyword || '').toLowerCase() === (task.keyword_text || '').toLowerCase();
                if (!keywordMatch) return false;
                
                // FIX 1: For keyword-based tasks, URL matching is optional
                if (!taskUrlClean || taskUrlClean.length === 0) {
                  return true; // Keyword match only - no URL required
                }
                
                // If task has URL, try to match it (preferred but not required)
                const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
                const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
                const rowUrlPath = rowUrlClean.includes('/') ? rowUrlClean.split('/').slice(1).join('/') : '';
                
                const urlMatch = rowUrl === taskUrlClean || 
                                rowUrlClean === taskUrlClean ||
                                rowUrlPath === taskUrlPath ||
                                rowUrl.includes(taskUrlClean) ||
                                taskUrlClean.includes(rowUrlClean);
                
                return urlMatch || true; // Always accept keyword match for keyword tasks
              });

              if (matchingRow) {
                debugLog(`[Optimisation] Rebaseline: Found matching row for keyword "${task.keyword_text}"`, 'success');
                
                // Get queryTotal data for clicks, impressions, and CTR
                let queryTotal = null;
                if (typeof getQueryTotalForKeyword === 'function') {
                  queryTotal = getQueryTotalForKeyword(task.keyword_text);
                }
                
                currentMetrics = {
                  gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
                  gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
                  gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
                  current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
                  opportunity_score: matchingRow.opportunityScore || null,
                  ai_overview: matchingRow.has_ai_overview === true || matchingRow.ai_overview_present_any === true,
                  ai_citations: matchingRow.ai_alan_citations_count != null ? Number(matchingRow.ai_alan_citations_count) : 0,
                  ai_citations_total: matchingRow.ai_total_citations != null ? Number(matchingRow.ai_total_citations) : 0,
                  classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || taskUrlForPage,
                  page_type: matchingRow.pageType || null,
                  segment: matchingRow.segment || null,
                  captured_at: new Date().toISOString()
                };
                debugLog(`[Optimisation] Rebaseline: Built metrics from Ranking & AI data - rank=${currentMetrics.current_rank}, ai_overview=${currentMetrics.ai_overview}, impressions=${currentMetrics.gsc_impressions_28d}`, 'success');
              } else {
                debugLog(`[Optimisation] Rebaseline: No matching row found for keyword "${task.keyword_text}" in ${combinedRows.length} rows`, 'warn');
              }
            } else {
              debugLog(`[Optimisation] Rebaseline: No combinedRows available for keyword task`, 'warn');
            }
          }

          // Legacy code below - keeping for now but should be removed
          // Prefer exact GSC page totals for URL-only tasks
          // FIX: Also fetch Ranking & AI data so we can look up AI Overview/Citations for this URL
          if (!currentMetrics && !hasKeyword && taskUrlForPage) {
            // CRITICAL: Fetch latest audit from Supabase to get fresh ranking_ai_data for URL lookup
            let latestAuditFromSupabase = null;
            try {
              const propertyUrl = document.getElementById('propertyUrl')?.value || 
                                  localStorage.getItem('gsc_property_url') || 
                                  'https://www.alanranger.com';
              if (typeof fetchLatestAuditFromSupabase === 'function') {
                debugLog(`[Optimisation] Rebaseline URL task: Fetching latest audit from Supabase for Ranking & AI data...`, 'info');
                latestAuditFromSupabase = await fetchLatestAuditFromSupabase(propertyUrl, false);
                if (latestAuditFromSupabase && latestAuditFromSupabase.ranking_ai_data) {
                  try {
                    const rankingAiData = latestAuditFromSupabase.ranking_ai_data;
                    if (rankingAiData.combinedRows && Array.isArray(rankingAiData.combinedRows)) {
                      localStorage.setItem('rankingAiData', JSON.stringify(rankingAiData));
                      window.rankingAiData = rankingAiData.combinedRows;
                      debugLog(`[Optimisation] Rebaseline URL task: Loaded ${rankingAiData.combinedRows.length} keywords from latest audit`, 'success');
                    }
                  } catch (rankingErr) {
                    debugLog(`[Optimisation] Rebaseline URL task: Error loading ranking_ai_data: ${rankingErr.message}`, 'warn');
                  }
                }
              }
            } catch (fetchErr) {
              debugLog(`[Optimisation] Rebaseline URL task: Error fetching latest audit: ${fetchErr.message}`, 'warn');
            }
            
            try {
              const property = document.getElementById('propertyUrl')?.value ||
                localStorage.getItem('gsc_property_url') ||
                localStorage.getItem('last_property_url') || '';
              if (property) {
                // CRITICAL: Use the audit's date range (28 days ending 2 days before audit date) for consistency
                let auditDateRange = null;
                if (latestAuditFromSupabase && latestAuditFromSupabase.audit_date) {
                  const auditDate = new Date(latestAuditFromSupabase.audit_date);
                  const endDate = new Date(auditDate);
                  endDate.setDate(endDate.getDate() - 2); // 2 days before audit date
                  endDate.setHours(0, 0, 0, 0);
                  
                  const startDate = new Date(endDate);
                  startDate.setDate(startDate.getDate() - 27); // 27 days back = 28 days total (inclusive)
                  startDate.setHours(0, 0, 0, 0);
                  
                  auditDateRange = {
                    startDate: startDate.toISOString().split('T')[0],
                    endDate: endDate.toISOString().split('T')[0]
                  };
                } else {
                  // Fallback to getGscDateRange if no audit available
                  auditDateRange = (typeof getGscDateRange === 'function') ? getGscDateRange(28, 2) : null;
                }
                
                const startDate = auditDateRange?.startDate ? `&startDate=${encodeURIComponent(auditDateRange.startDate)}` : '';
                const endDate = auditDateRange?.endDate ? `&endDate=${encodeURIComponent(auditDateRange.endDate)}` : '';
                const pageUrlForGsc = toAbsoluteUrlForGsc(taskUrlForPage, property);
                const totalsUrl = apiUrl(`/api/aigeo/gsc-page-totals?property=${encodeURIComponent(property)}&pageUrl=${encodeURIComponent(pageUrlForGsc)}${startDate}${endDate}`);
                const totalsRes = await fetch(totalsUrl);
                const totalsJson = await totalsRes.json().catch(() => null);
                const totals = totalsRes.ok && totalsJson && totalsJson.status === 'ok' ? totalsJson.data : null;
                if (totals) {
                  // Get combinedRows from multiple sources (prioritize fresh data)
                  let aiRows = [];
                  if (typeof window.getRankingAiCombinedRows === 'function') {
                    aiRows = window.getRankingAiCombinedRows();
                  }
                  if (aiRows.length === 0 && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
                    aiRows = window.rankingAiData;
                  }
                  if (aiRows.length === 0) {
                    try {
                      const local = localStorage.getItem('rankingAiData');
                      if (local) {
                        const parsed = JSON.parse(local);
                        if (parsed && Array.isArray(parsed.combinedRows)) {
                          aiRows = parsed.combinedRows;
                        }
                      }
                    } catch (e) {
                      // ignore
                    }
                  }
                  
                  debugLog(`[Optimisation] Rebaseline URL task: Found ${aiRows.length} combinedRows for AI lookup`, 'info');
                  
                  // Fix 1: Ensure combinedRows is loaded before calling computeAiMetricsForPageUrl
                  if (aiRows.length === 0) {
                    debugLog(`[Optimisation] Rebaseline URL task: No combinedRows loaded, attempting to reload from Supabase...`, 'warn');
                    // Try to reload from Supabase if we just fetched it
                    if (latestAuditFromSupabase && latestAuditFromSupabase.ranking_ai_data) {
                      const rankingAiData = latestAuditFromSupabase.ranking_ai_data;
                      if (rankingAiData.combinedRows && Array.isArray(rankingAiData.combinedRows)) {
                        aiRows = rankingAiData.combinedRows;
                        debugLog(`[Optimisation] Rebaseline URL task: Reloaded ${aiRows.length} combinedRows from latest audit`, 'info');
                      }
                    }
                  }
                  
                  // Only call computeAiMetricsForPageUrl if we have data
                  let aiForUrl = { ai_overview: null, ai_citations: null };
                  if (aiRows.length > 0) {
                    // Try both the full GSC URL and the original task URL (in case formats differ)
                    const urlsToTry = [pageUrlForGsc, taskUrlForPage];
                    
                    for (const urlToCheck of urlsToTry) {
                      if (urlToCheck) {
                        const result = (typeof window.computeAiMetricsForPageUrl === 'function')
                          ? window.computeAiMetricsForPageUrl(urlToCheck, aiRows)
                          : { ai_overview: null, ai_citations: null };
                        
                        // Use first result where BOTH values are non-null (consistent match found)
                        // This ensures we only use results where a match was definitively found
                        if (result.ai_overview !== null && result.ai_citations !== null) {
                          aiForUrl = result;
                          debugLog(`[Optimisation] Rebaseline URL task: AI lookup for ${urlToCheck} - Overview: ${aiForUrl.ai_overview}, Citations: ${aiForUrl.ai_citations}`, 'info');
                          break;
                        } else if (result.ai_overview !== null || result.ai_citations !== null) {
                          // Inconsistent result (shouldn't happen, but log it for debugging)
                          debugLog(`[Optimisation] Rebaseline URL task: Inconsistent result from computeAiMetricsForPageUrl for ${urlToCheck} - Overview: ${result.ai_overview}, Citations: ${result.ai_citations}`, 'warn');
                        }
                      }
                    }
                    
                    if (aiForUrl.ai_overview === null && aiForUrl.ai_citations === null) {
                      debugLog(`[Optimisation] Rebaseline URL task: No AI data found for ${pageUrlForGsc} or ${taskUrlForPage} in ${aiRows.length} rows`, 'warn');
                    }
                  } else {
                    debugLog(`[Optimisation] Rebaseline URL task: Cannot lookup AI data - no combinedRows available (${aiRows.length} rows)`, 'warn');
                  }
                  
                  // Try to get ranking from Ranking & AI data if GSC position is null
                  let rankingFromAi = null;
                  if ((totals.position == null || totals.position === 0) && aiRows.length > 0) {
                    // Find rows matching this URL and get average rank
                    const matchingRows = aiRows.filter(r => {
                      const rowUrl = (r.best_url || r.bestUrl || r.targetUrl || r.ranking_url || '').toLowerCase();
                      const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
                      const taskUrlClean = pageUrlForGsc.replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
                      return rowUrlClean === taskUrlClean || 
                             rowUrl.includes(taskUrlClean) || 
                             taskUrlClean.includes(rowUrlClean);
                    });
                    
                    if (matchingRows.length > 0) {
                      // Calculate average rank from all matching rows
                      const ranks = matchingRows
                        .map(r => r.best_rank_group || r.current_rank || null)
                        .filter(r => r != null && r > 0);
                      
                      if (ranks.length > 0) {
                        const avgRank = ranks.reduce((sum, r) => sum + r, 0) / ranks.length;
                        rankingFromAi = avgRank;
                        debugLog(`[Optimisation] Rebaseline: Found ranking from Ranking & AI data: ${avgRank.toFixed(2)} (from ${ranks.length} keywords)`, 'info');
                      }
                    }
                  }
                  
                  currentMetrics = {
                    gsc_clicks_28d: Number(totals.clicks || 0),
                    gsc_impressions_28d: Number(totals.impressions || 0),
                    gsc_ctr_28d: Number(totals.ctr || 0), // totals.ctr is already a ratio (0-1) from fetchMetricsForUrlTask
                    // Prefer GSC position, fallback to Ranking & AI average rank
                    current_rank: totals.position != null && totals.position > 0 
                      ? Number(totals.position) 
                      : (rankingFromAi != null ? Number(rankingFromAi) : null),
                    classic_ranking_url: pageUrlForGsc,
                    ai_overview: aiForUrl.ai_overview === true ? true : (aiForUrl.ai_overview === false ? false : null),
                    ai_citations: aiForUrl.ai_citations != null ? Number(aiForUrl.ai_citations) : null,
                    ai_citations_total: null,
                    segment: task.segment || 'money_pages',
                    captured_at: new Date().toISOString()
                  };
                }
              }
            } catch (e) {
              console.warn('[Optimisation] Failed to fetch GSC page totals for rebaseline:', e);
            }
          }

          // Fallback to existing baseline metrics ONLY if all data sources failed
          // For keyword tasks, this should rarely happen if Ranking & AI data is available
          if (!currentMetrics) {
            const baselineMetrics = task.baseline_metrics;
            if (baselineMetrics && typeof baselineMetrics === 'object') {
              debugLog(`[Optimisation] Rebaseline: Falling back to existing baseline metrics (no fresh data found)`, 'warn');
              currentMetrics = { ...baselineMetrics, captured_at: new Date().toISOString() };
            } else {
              if (hasKeyword) {
                alert('Could not find Ranking & AI data to rebaseline. Please run "Run Ranking & AI Scan" first, then try again.');
              } else {
                alert('Could not find metrics to rebaseline. Try again after running an audit.');
              }
              return;
            }
          }

          try {
            const headers = window.getOptimisationHeaders();
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/measurement`), {
              method: 'POST',
              headers: headers,
              body: JSON.stringify({
                metrics: currentMetrics,
                note: 'Rebaseline snapshot',
                is_baseline: true
              })
            });

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(errorText || 'Failed to rebaseline');
            }

            await window.loadAllOptimisationTasks();
            // Force reload task data from API to get fresh baseline_metrics
            try {
              const headers = window.getOptimisationHeaders();
              const cacheBuster = `_t=${Date.now()}`;
              const taskResponse = await fetch(apiUrl(`/api/optimisation/task/${taskId}?${cacheBuster}`), {
                method: 'GET',
                headers: {
                  ...headers,
                  'Cache-Control': 'no-cache, no-store, must-revalidate',
                  'Pragma': 'no-cache'
                }
              });
              if (taskResponse.ok) {
                const taskData = await taskResponse.json();
                // Update task in state with fresh data
                const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
                if (taskIndex >= 0) {
                  window.optimisationModuleState.allTasks[taskIndex] = {
                    ...window.optimisationModuleState.allTasks[taskIndex],
                    ...taskData.task
                  };
                }
              }
            } catch (e) {
              debugLog(`[Optimisation] Error refreshing task data after rebaseline: ${e.message}`, 'warn');
            }
            // Re-open drawer to refresh with new baseline
            await openOptimisationTaskDrawer(taskId);
            alert('Baseline updated successfully!');
          } catch (error) {
            console.error('[Optimisation Module] Error rebaselining:', error);
            alert('Failed to rebaseline: ' + error.message);
          }
        });
      }
    }

    // Bulk rebaseline tasks with incomplete baselines
    window.bulkRebaselineIncompleteBaselines = async function bulkRebaselineIncompleteBaselines() {
      if (!window.optimisationModuleState || !window.optimisationModuleState.allTasks) {
        alert('No tasks loaded. Please wait for tasks to load first.');
        return;
      }

      const criticalFields = ['ai_overview', 'ai_citations', 'current_rank'];
      let tasks = window.optimisationModuleState.allTasks.filter(
        t => !['done', 'cancelled', 'deleted'].includes(t.status)
      );

      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }

      // Find tasks with incomplete baselines
      const incompleteTasks = tasks.filter(task => {
        if (!task.baseline_metrics) return true; // No baseline = incomplete
        const missingFields = criticalFields.filter(field => {
          const val = task.baseline_metrics[field];
          // For current_rank, also treat 0 as missing (should be a positive number)
          if (field === 'current_rank') {
            return val == null || val === '' || val === 0 || val === '0';
          }
          // For boolean fields (ai_overview), false is valid, only null/undefined/empty is missing
          if (field === 'ai_overview') {
            return val == null || val === '';
          }
          // For other fields, null or empty string is missing
          return val == null || val === '';
        });
        return missingFields.length > 0;
      });

      if (incompleteTasks.length === 0) {
        alert('No tasks with incomplete baselines found. All baselines are complete!');
        return;
      }

      const confirmMsg = `Found ${incompleteTasks.length} task(s) with incomplete baselines.\n\n` +
        `This will create a new baseline measurement for each task with all fields properly captured.\n\n` +
        `Continue?`;
      if (!confirm(confirmMsg)) {
        return;
      }

      const bulkRebaselineBtn = document.getElementById('optimisation-bulk-rebaseline-btn');
      const originalText = bulkRebaselineBtn ? bulkRebaselineBtn.textContent : '';
      if (bulkRebaselineBtn) {
        bulkRebaselineBtn.disabled = true;
        bulkRebaselineBtn.textContent = 'Rebaselining...';
      }

      let successCount = 0;
      let failCount = 0;
      const errors = [];

      try {
        // Process sequentially to avoid rate limits (max 2 concurrent)
        const maxConcurrent = 2;
        for (let i = 0; i < incompleteTasks.length; i += maxConcurrent) {
          const batch = incompleteTasks.slice(i, i + maxConcurrent);
          
          await Promise.all(batch.map(async (task) => {
            const taskNum = i + batch.indexOf(task) + 1;
            if (bulkRebaselineBtn) {
              bulkRebaselineBtn.textContent = `Rebaselining ${taskNum}/${incompleteTasks.length}...`;
            }

            try {
              // Use the same logic as individual rebaseline
              const taskUrlForPage = task.target_url_clean || task.target_url || '';
              const hasKeyword = !!(task.keyword_text && String(task.keyword_text).trim());
              let currentMetrics = null;

              // Fetch latest audit for Ranking & AI data
              let latestAuditFromSupabase = null;
              try {
                const propertyUrl = document.getElementById('propertyUrl')?.value || 
                                    localStorage.getItem('gsc_property_url') || 
                                    'https://www.alanranger.com';
                if (typeof fetchLatestAuditFromSupabase === 'function') {
                  latestAuditFromSupabase = await fetchLatestAuditFromSupabase(propertyUrl, false);
                  if (latestAuditFromSupabase && latestAuditFromSupabase.ranking_ai_data) {
                    const rankingAiData = latestAuditFromSupabase.ranking_ai_data;
                    if (rankingAiData.combinedRows && Array.isArray(rankingAiData.combinedRows)) {
                      localStorage.setItem('rankingAiData', JSON.stringify(rankingAiData));
                      window.rankingAiData = rankingAiData.combinedRows;
                    }
                  }
                }
              } catch (fetchErr) {
                debugLog(`[Optimisation] Bulk Rebaseline: Error fetching latest audit: ${fetchErr.message}`, 'warn');
              }

              // Get ranking data sources
              let combinedRows = [];
              if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
                const state = RankingAiModule.state();
                combinedRows = state.combinedRows || [];
              }
              if (combinedRows.length === 0 && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
                combinedRows = window.rankingAiData;
              }
              if (combinedRows.length === 0) {
                try {
                  const local = localStorage.getItem('rankingAiData');
                  if (local) {
                    const parsed = JSON.parse(local);
                    if (parsed && Array.isArray(parsed.combinedRows)) {
                      combinedRows = parsed.combinedRows;
                    }
                  }
                } catch (e) {}
              }

              // Build metrics (same logic as individual rebaseline)
              if (hasKeyword && combinedRows.length > 0) {
                const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
                const matchingRow = combinedRows.find(r => {
                  const keywordMatch = (r.keyword || '').toLowerCase() === (task.keyword_text || '').toLowerCase();
                  if (!keywordMatch) return false;
                  if (!taskUrlClean || taskUrlClean.length === 0) return true;
                  const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
                  const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
                  return rowUrl === taskUrlClean || rowUrlClean === taskUrlClean || 
                         rowUrl.includes(taskUrlClean) || taskUrlClean.includes(rowUrlClean);
                });

                if (matchingRow) {
                  let queryTotal = null;
                  if (typeof getQueryTotalForKeyword === 'function') {
                    queryTotal = getQueryTotalForKeyword(task.keyword_text);
                  }
                  
                  currentMetrics = {
                    gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
                    gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
                    gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
                    current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
                    opportunity_score: matchingRow.opportunityScore || null,
                    ai_overview: matchingRow.has_ai_overview === true || matchingRow.ai_overview_present_any === true,
                    ai_citations: matchingRow.ai_alan_citations_count != null ? Number(matchingRow.ai_alan_citations_count) : 0,
                    ai_citations_total: matchingRow.ai_total_citations != null ? Number(matchingRow.ai_total_citations) : 0,
                    classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || taskUrlForPage,
                    page_type: matchingRow.pageType || null,
                    segment: matchingRow.segment || null,
                    captured_at: new Date().toISOString()
                  };
                }
              } else if (!hasKeyword && taskUrlForPage) {
                // URL-only task - fetch GSC page totals and AI data
                try {
                  const property = document.getElementById('propertyUrl')?.value ||
                    localStorage.getItem('gsc_property_url') ||
                    localStorage.getItem('last_property_url') || '';
                  if (property) {
                    const range = (typeof getGscDateRange === 'function') ? getGscDateRange(28, 2) : null;
                    const startDate = range?.startDate ? `&startDate=${encodeURIComponent(range.startDate)}` : '';
                    const endDate = range?.endDate ? `&endDate=${encodeURIComponent(range.endDate)}` : '';
                    const pageUrlForGsc = toAbsoluteUrlForGsc(taskUrlForPage, property);
                    const totalsUrl = apiUrl(`/api/aigeo/gsc-page-totals?property=${encodeURIComponent(property)}&pageUrl=${encodeURIComponent(pageUrlForGsc)}${startDate}${endDate}`);
                    const totalsRes = await fetch(totalsUrl);
                    const totalsJson = await totalsRes.json().catch(() => null);
                    const totals = totalsRes.ok && totalsJson && totalsJson.status === 'ok' ? totalsJson.data : null;
                    
                    if (totals) {
                      let aiRows = [];
                      if (typeof window.getRankingAiCombinedRows === 'function') {
                        aiRows = window.getRankingAiCombinedRows();
                      }
                      if (aiRows.length === 0 && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
                        aiRows = window.rankingAiData;
                      }
                      if (aiRows.length === 0) {
                        try {
                          const local = localStorage.getItem('rankingAiData');
                          if (local) {
                            const parsed = JSON.parse(local);
                            if (parsed && Array.isArray(parsed.combinedRows)) {
                              aiRows = parsed.combinedRows;
                            }
                          }
                        } catch (e) {}
                      }
                      
                      let aiForUrl = { ai_overview: null, ai_citations: null };
                      if (aiRows.length > 0 && typeof window.computeAiMetricsForPageUrl === 'function') {
                        const urlsToTry = [pageUrlForGsc, taskUrlForPage];
                        for (const urlToCheck of urlsToTry) {
                          if (urlToCheck) {
                            const result = window.computeAiMetricsForPageUrl(urlToCheck, aiRows);
                            if (result.ai_overview !== null && result.ai_citations !== null) {
                              aiForUrl = result;
                              break;
                            }
                          }
                        }
                      }
                      
                      // CTR conversion: totals.ctr from fetchMetricsForUrlTask is already a ratio (0-1)
                      // No conversion needed - it's already normalized
                      let ctrValue = totals.ctr != null ? Number(totals.ctr) : null;
                      
                      // Try to get ranking from Ranking & AI data if GSC position is null
                      let rankingFromAi = null;
                      if ((totals.position == null || totals.position === 0) && aiRows.length > 0) {
                        // Find rows matching this URL and get average rank
                        const matchingRows = aiRows.filter(r => {
                          const rowUrl = (r.best_url || r.bestUrl || r.targetUrl || r.ranking_url || '').toLowerCase();
                          const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
                          const taskUrlClean = pageUrlForGsc.replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
                          return rowUrlClean === taskUrlClean || 
                                 rowUrl.includes(taskUrlClean) || 
                                 taskUrlClean.includes(rowUrlClean);
                        });
                        
                        if (matchingRows.length > 0) {
                          // Calculate average rank from all matching rows
                          const ranks = matchingRows
                            .map(r => r.best_rank_group || r.current_rank || null)
                            .filter(r => r != null && r > 0);
                          
                          if (ranks.length > 0) {
                            const avgRank = ranks.reduce((sum, r) => sum + r, 0) / ranks.length;
                            rankingFromAi = avgRank;
                            debugLog(`[Optimisation] Bulk Rebaseline: Found ranking from Ranking & AI data: ${avgRank.toFixed(2)} (from ${ranks.length} keywords)`, 'info');
                          }
                        }
                      }
                      
                      currentMetrics = {
                        gsc_clicks_28d: Number(totals.clicks || 0),
                        gsc_impressions_28d: Number(totals.impressions || 0),
                        gsc_ctr_28d: ctrValue,
                        // Prefer GSC position, fallback to Ranking & AI average rank
                        current_rank: totals.position != null && totals.position > 0 
                          ? Number(totals.position) 
                          : (rankingFromAi != null ? Number(rankingFromAi) : null),
                        opportunity_score: null,
                        ai_overview: aiForUrl.ai_overview === true ? true : (aiForUrl.ai_overview === false ? false : null),
                        ai_citations: aiForUrl.ai_citations != null ? Number(aiForUrl.ai_citations) : null,
                        ai_citations_total: null,
                        classic_ranking_url: pageUrlForGsc,
                        page_type: task.page_type || null,
                        segment: task.segment || 'money_pages',
                        captured_at: new Date().toISOString()
                      };
                    }
                  }
                } catch (e) {
                  debugLog(`[Optimisation] Bulk Rebaseline: Error fetching GSC data for task ${task.id}: ${e.message}`, 'warn');
                }
              }

              if (!currentMetrics) {
                throw new Error('Could not fetch metrics for rebaseline');
              }

              // Create baseline measurement
              const headers = window.getOptimisationHeaders();
              const response = await fetch(apiUrl(`/api/optimisation/task/${task.id}/measurement`), {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                  metrics: currentMetrics,
                  note: 'Bulk rebaseline - complete baseline with all fields',
                  is_baseline: true
                })
              });

              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(errorText || 'Failed to rebaseline');
              }

              // After creating baseline, check if latest measurement is also missing critical fields
              // If so, create a new measurement (not baseline) to update the latest metrics
              try {
                const taskResponse = await fetch(apiUrl(`/api/optimisation/task/${task.id}?_t=${Date.now()}`), {
                  method: 'GET',
                  headers: headers,
                  'Cache-Control': 'no-cache, no-store, must-revalidate',
                  'Pragma': 'no-cache'
                });
                
                if (taskResponse.ok) {
                  const taskData = await taskResponse.json();
                  const latestMetrics = taskData.task?.latest_metrics;
                  
                  // Check if latest measurement is missing critical fields
                  const latestMissingFields = criticalFields.filter(field => {
                    const val = latestMetrics?.[field];
                    if (field === 'current_rank') {
                      return val == null || val === '' || val === 0 || val === '0';
                    }
                    if (field === 'ai_overview') {
                      return val == null || val === '';
                    }
                    return val == null || val === '';
                  });
                  
                  // If latest measurement is missing fields, create a new measurement with complete data
                  if (latestMissingFields.length > 0 && currentMetrics) {
                    debugLog(`[Optimisation] Bulk Rebaseline: Latest measurement missing ${latestMissingFields.length} field(s), creating new measurement`, 'info');
                    const measurementResponse = await fetch(apiUrl(`/api/optimisation/task/${task.id}/measurement`), {
                      method: 'POST',
                      headers: headers,
                      body: JSON.stringify({
                        metrics: currentMetrics,
                        note: 'Bulk rebaseline - updated latest measurement with complete data',
                        is_baseline: false
                      })
                    });
                    
                    if (measurementResponse.ok) {
                      debugLog(`[Optimisation] Bulk Rebaseline: Updated latest measurement for task ${task.id}`, 'success');
                    } else {
                      debugLog(`[Optimisation] Bulk Rebaseline: Failed to update latest measurement for task ${task.id}`, 'warn');
                    }
                  }
                }
              } catch (latestUpdateErr) {
                // Non-fatal - log but don't fail the rebaseline
                debugLog(`[Optimisation] Bulk Rebaseline: Could not check/update latest measurement: ${latestUpdateErr.message}`, 'warn');
              }

              successCount++;
              debugLog(`[Optimisation] Bulk Rebaseline: Successfully rebaselined task ${task.id}`, 'success');
            } catch (error) {
              failCount++;
              const errorMsg = `Task "${task.title || task.id}": ${error.message}`;
              errors.push(errorMsg);
              debugLog(`[Optimisation] Bulk Rebaseline: ${errorMsg}`, 'error');
            }
          }));
        }

        // Reload tasks to refresh counts - force fresh data from API
        await window.loadAllOptimisationTasks();
        
        // Wait a moment for view to update
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Reload again to ensure view has updated baseline_metrics
        await window.loadAllOptimisationTasks();
        
        // Update summary cards
        updateOptimisationSummaryCards();

        const resultMsg = `Rebaseline complete!\n\n` +
          `Success: ${successCount}\n` +
          `Failed: ${failCount}` +
          (errors.length > 0 ? `\n\nErrors:\n${errors.slice(0, 5).join('\n')}${errors.length > 5 ? `\n... and ${errors.length - 5} more` : ''}` : '');
        alert(resultMsg);
      } catch (error) {
        debugLog(`[Optimisation] Bulk Rebaseline: Fatal error: ${error.message}`, 'error');
        alert('Bulk rebaseline failed: ' + error.message);
      } finally {
        if (bulkRebaselineBtn) {
          bulkRebaselineBtn.disabled = false;
          bulkRebaselineBtn.textContent = originalText;
        }
      }
    };

    /**
     * Fetches latest audit from Supabase and loads combinedRows from Ranking & AI data
     * 
     * This is a unified data fetching function used by all task update functions to ensure consistency.
     * It provides the data sources needed by fetchMetricsForUrlTask() and fetchMetricsForKeywordTask().
     * 
     * Returns:
     * - latestAudit: Latest audit from Supabase (contains ranking_ai_data with combinedRows)
     * - combinedRows: Array of keyword ranking data from Ranking & AI scan
     * 
     * Fallback order for combinedRows:
     * 1. Latest audit from Supabase (ranking_ai_data.combinedRows)
     * 2. RankingAiModule state (if available)
     * 3. window.rankingAiData (if set)
     * 4. localStorage rankingAiData (if available)
     * 
     * @returns {Promise<Object>} Object with { latestAudit, combinedRows }
     */
    window.fetchLatestAuditAndCombinedRows = async function fetchLatestAuditAndCombinedRows() {
      let latestAudit = null;
      let combinedRows = [];

      try {
        const propertyUrl = document.getElementById('propertyUrl')?.value || 
                          localStorage.getItem('gsc_property_url') || 
                          localStorage.getItem('last_property_url') || 
                          'https://www.alanranger.com';
        
        if (typeof window.fetchLatestAuditFromSupabase === 'function') {
          debugLog(`[Optimisation] Fetching latest audit from Supabase for ${propertyUrl}...`, 'info');
          latestAudit = await window.fetchLatestAuditFromSupabase(propertyUrl, false);
          
          if (latestAudit && latestAudit.ranking_ai_data) {
            try {
              const rankingAiData = latestAudit.ranking_ai_data;
              if (rankingAiData.combinedRows && Array.isArray(rankingAiData.combinedRows)) {
                localStorage.setItem('rankingAiData', JSON.stringify(rankingAiData));
                window.rankingAiData = rankingAiData.combinedRows;
                combinedRows = rankingAiData.combinedRows;
                debugLog(`[Optimisation] Loaded ${combinedRows.length} keywords from latest audit`, 'success');
              }
            } catch (rankingErr) {
              debugLog(`[Optimisation] Error loading ranking_ai_data: ${rankingErr.message}`, 'warn');
            }
          }
        }
      } catch (fetchErr) {
        debugLog(`[Optimisation] Error fetching latest audit: ${fetchErr.message}`, 'warn');
      }

      // Fallback: Try to get combinedRows from other sources
      if (combinedRows.length === 0) {
        if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
          const state = RankingAiModule.state();
          combinedRows = state.combinedRows || [];
        }
        if (combinedRows.length === 0 && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
          combinedRows = window.rankingAiData;
        }
        if (combinedRows.length === 0) {
          try {
            const local = localStorage.getItem('rankingAiData');
            if (local) {
              const parsed = JSON.parse(local);
              if (parsed && Array.isArray(parsed.combinedRows)) {
                combinedRows = parsed.combinedRows;
              }
            }
          } catch (e) {
            // ignore
          }
        }
      }

      return { latestAudit, combinedRows };
    };

    /**
     * Fetches metrics for URL-only tasks (no keyword)
     * 
     * IMPORTANT: This function fetches ALL fields from BOTH data sources:
     * - GSC (Google Search Console) data: clicks, impressions, CTR, position/rank
     * - Ranking & AI data: AI overview, AI citations, ranking fallback
     * 
     * Data sources:
     * 1. GSC page totals API: Provides clicks, impressions, CTR, and position for the URL
     * 2. Ranking & AI data (combinedRows): Provides AI overview, AI citations, and ranking fallback
     * 3. Supabase API fallback: If local Ranking & AI lookup fails, queries Supabase directly
     * 
     * Returns a complete metrics object with ALL fields populated from BOTH sources:
     * - gsc_clicks_28d, gsc_impressions_28d, gsc_ctr_28d (from GSC)
     * - current_rank (from GSC, with fallback to Ranking & AI average rank)
     * - ai_overview, ai_citations (from Ranking & AI data or Supabase)
     * - classic_ranking_url, page_type, segment, captured_at
     * 
     * @param {Object} task - Task object with target_url or target_url_clean
     * @param {Object} latestAudit - Latest audit from Supabase (optional, used for combinedRows fallback)
     * @param {Array} combinedRows - Combined rows from Ranking & AI scan (optional, will be fetched if not provided)
     * @returns {Promise<Object|null>} Complete metrics object with ALL fields from BOTH sources, or null if failed
     */
    window.fetchMetricsForUrlTask = async function fetchMetricsForUrlTask(task, latestAudit = null, combinedRows = []) {
      const taskUrlForPage = task.target_url_clean || task.target_url || '';
      if (!taskUrlForPage) {
        debugLog(`[Optimisation] URL task ${task.id}: No URL provided`, 'warn');
        return null;
      }

      try {
        const property = document.getElementById('propertyUrl')?.value ||
          localStorage.getItem('gsc_property_url') ||
          localStorage.getItem('last_property_url') || '';
        
        if (!property) {
          debugLog(`[Optimisation] URL task ${task.id}: No property URL found`, 'warn');
          return null;
        }

        // CRITICAL: Use Supabase stored data (same as Money Pages table) for consistency
        // This ensures task drawer shows the same clicks/impressions as Money Pages table
        
        // PRIORITY 1: Use window.moneyPagesMetrics if available (set directly after audit completes)
        // This is the most up-to-date source and matches what Money Pages table uses
        if (!window.moneyPagesMetrics || !window.moneyPagesMetrics.rows || window.moneyPagesMetrics.rows.length === 0) {
          // PRIORITY 2: Load from latest audit if provided
          if (latestAudit) {
            if (latestAudit.scores?.moneyPagesMetrics) {
              window.moneyPagesMetrics = latestAudit.scores.moneyPagesMetrics;
            } else if (latestAudit.moneyPagesMetrics) {
              window.moneyPagesMetrics = latestAudit.moneyPagesMetrics;
            }
          }
          
          // PRIORITY 3: Load from localStorage if still not available
          if (!window.moneyPagesMetrics || !window.moneyPagesMetrics.rows || window.moneyPagesMetrics.rows.length === 0) {
            try {
              const stored = localStorage.getItem('last_audit_results');
              if (stored) {
                const parsed = JSON.parse(stored);
                if (parsed.scores?.moneyPagesMetrics) {
                  window.moneyPagesMetrics = parsed.scores.moneyPagesMetrics;
                } else if (parsed.moneyPagesMetrics) {
                  window.moneyPagesMetrics = parsed.moneyPagesMetrics;
                }
              }
            } catch (e) {
              // ignore
            }
          }
        }
        
        // Use same normalization logic as Money Pages table
        // IMPORTANT: Normalize the task URL directly (don't use toAbsoluteUrlForGsc for matching)
        // Money Pages rows have URLs like "https://www.alanranger.com/photography-workshops"
        // Task URLs are like "www.alanranger.com/photography-workshops"
        // We need to normalize both to the same format for matching
        // CRITICAL: Don't use window.normalizeUrlForDedupe here as it may call toAbsoluteUrlForGsc
        // Use our own simple normalization that matches Money Pages table logic
        const norm = (u) => {
          if (!u) return '';
          // Standard normalization: remove protocol, www, trailing slash, lowercase
          return String(u).toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
        };
        const normalizedTaskUrl = norm(taskUrlForPage);
        
        // pageUrlForGsc is only needed for GSC API fallback (not for Money Pages matching)
        const pageUrlForGsc = toAbsoluteUrlForGsc(taskUrlForPage, property);
        
        // Try to find matching row in stored Money Pages data first
        let totals = null;
        const rows = window.moneyPagesMetrics?.rows || [];
        debugLog(`[Optimisation] URL task ${task.id}: Searching for URL "${taskUrlForPage}" (normalized: "${normalizedTaskUrl}") in ${rows.length} Money Pages rows`, 'info');
        
        if (Array.isArray(rows) && rows.length > 0 && normalizedTaskUrl) {
          const matchingRow = rows.find(r => {
            const rowUrl = r.url || r.page_url || r.keys?.[0] || '';
            const normalizedRowUrl = norm(rowUrl);
            const matches = normalizedRowUrl === normalizedTaskUrl;
            if (taskUrlForPage.includes('photography-workshops')) {
              debugLog(`[Optimisation] URL task ${task.id}: Comparing "${normalizedRowUrl}" === "${normalizedTaskUrl}" = ${matches}`, 'info');
            }
            return matches;
          });
          
          if (matchingRow) {
            debugLog(`[Optimisation] URL task ${task.id}: Found matching row in stored Money Pages data - clicks=${matchingRow.clicks}, impressions=${matchingRow.impressions}`, 'success');
            const clicks = matchingRow.clicks != null ? matchingRow.clicks : (matchingRow.clicks_28d || 0);
            const impressions = matchingRow.impressions != null ? matchingRow.impressions : (matchingRow.impressions_28d || 0);
            
            totals = {
              clicks: clicks,
              impressions: impressions,
              ctr: (() => {
                // First try to get stored CTR value
                const v = matchingRow.ctr != null ? matchingRow.ctr : (matchingRow.ctr_28d != null ? matchingRow.ctr_28d : null);
                if (v != null && v !== 0) {
                  const n = Number(v);
                  // If stored as percentage (0-100), convert to ratio (0-1)
                  if (n > 1 && n <= 100) return n / 100;
                  return n;
                }
                // If CTR is missing or 0 but we have clicks and impressions, calculate it
                if (impressions > 0 && clicks > 0) {
                  return clicks / impressions;
                }
                return 0;
              })(),
              position: matchingRow.avgPosition != null ? matchingRow.avgPosition : (matchingRow.position != null ? matchingRow.position : (matchingRow.position_28d != null ? matchingRow.position_28d : (matchingRow.avg_position != null ? matchingRow.avg_position : null)))
            };
          } else {
            debugLog(`[Optimisation] URL task ${task.id}: No matching row found in Money Pages data. Task URL: "${taskUrlForPage}", Normalized: "${normalizedTaskUrl}". Sample row URLs: ${rows.slice(0, 3).map(r => r.url || r.page_url || r.keys?.[0] || 'N/A').join(', ')}`, 'warn');
          }
        } else {
          debugLog(`[Optimisation] URL task ${task.id}: No Money Pages rows available (rows.length=${rows.length}, normalizedTaskUrl="${normalizedTaskUrl}")`, 'warn');
        }
        
        // Fallback to GSC API only if no match found in stored data
        // CRITICAL: Use the audit's date range (28 days ending 2 days before audit date) for consistency
        if (!totals) {
          debugLog(`[Optimisation] URL task ${task.id}: No match in stored data, falling back to GSC API`, 'warn');
          
          // Get the audit's date range for consistency
          let auditDateRange = null;
          if (latestAudit && latestAudit.audit_date) {
            const auditDate = new Date(latestAudit.audit_date);
            const endDate = new Date(auditDate);
            endDate.setDate(endDate.getDate() - 2); // 2 days before audit date
            endDate.setHours(0, 0, 0, 0);
            
            const startDate = new Date(endDate);
            startDate.setDate(startDate.getDate() - 27); // 27 days back = 28 days total (inclusive)
            startDate.setHours(0, 0, 0, 0);
            
            auditDateRange = {
              startDate: startDate.toISOString().split('T')[0],
              endDate: endDate.toISOString().split('T')[0]
            };
          } else {
            // Fallback to getGscDateRange if no audit available
            auditDateRange = (typeof getGscDateRange === 'function') ? getGscDateRange(28, 2) : null;
          }
          
          const startDate = auditDateRange?.startDate ? `&startDate=${encodeURIComponent(auditDateRange.startDate)}` : '';
          const endDate = auditDateRange?.endDate ? `&endDate=${encodeURIComponent(auditDateRange.endDate)}` : '';
          const totalsUrl = apiUrl(`/api/aigeo/gsc-page-totals?property=${encodeURIComponent(property)}&pageUrl=${encodeURIComponent(pageUrlForGsc)}${startDate}${endDate}`);
          
          const totalsRes = await fetch(totalsUrl);
          const totalsJson = await totalsRes.json().catch(() => null);
          totals = totalsRes.ok && totalsJson && totalsJson.status === 'ok' ? totalsJson.data : null;
          
          if (!totals) {
            debugLog(`[Optimisation] URL task ${task.id}: GSC page totals API returned no data`, 'warn');
            return null;
          }
        }

        // Get combinedRows if not provided
        let aiRows = combinedRows;
        if (aiRows.length === 0) {
          if (typeof window.getRankingAiCombinedRows === 'function') {
            aiRows = window.getRankingAiCombinedRows();
          }
          if (aiRows.length === 0 && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
            aiRows = window.rankingAiData;
          }
          if (aiRows.length === 0 && latestAudit && latestAudit.ranking_ai_data) {
            const rankingAiData = latestAudit.ranking_ai_data;
            if (rankingAiData.combinedRows && Array.isArray(rankingAiData.combinedRows)) {
              aiRows = rankingAiData.combinedRows;
            }
          }
          if (aiRows.length === 0) {
            try {
              const local = localStorage.getItem('rankingAiData');
              if (local) {
                const parsed = JSON.parse(local);
                if (parsed && Array.isArray(parsed.combinedRows)) {
                  aiRows = parsed.combinedRows;
                }
              }
            } catch (e) {
              // ignore
            }
          }
        }

        // Get AI metrics for URL
        let aiForUrl = { ai_overview: null, ai_citations: null };
        if (aiRows.length > 0) {
          // Check if combinedRows has citations arrays
          const hasCitationsArrays = aiRows.some(r => 
            Array.isArray(r.ai_alan_citations) && r.ai_alan_citations.length > 0
          );
          
          if (hasCitationsArrays) {
            // Use computeAiMetricsForPageUrl
            const urlsToTry = [pageUrlForGsc, taskUrlForPage];
            for (const urlToCheck of urlsToTry) {
              if (urlToCheck) {
                const result = (typeof window.computeAiMetricsForPageUrl === 'function')
                  ? window.computeAiMetricsForPageUrl(urlToCheck, aiRows)
                  : { ai_overview: null, ai_citations: null };
                
                if (result.ai_overview !== null && result.ai_citations !== null) {
                  aiForUrl = result;
                  break;
                }
              }
            }
          }
          
          // Fallback to Supabase API if local lookup failed
          if (aiForUrl.ai_overview === null && aiForUrl.ai_citations === null) {
            try {
              const propertyUrl = document.getElementById('propertyUrl')?.value || 
                                localStorage.getItem('gsc_property_url') || 
                                'https://www.alanranger.com';
              const queryUrl = apiUrl(`/api/supabase/query-keywords-citing-url?` +
                `property_url=${encodeURIComponent(propertyUrl)}&` +
                `target_url=${encodeURIComponent(pageUrlForGsc || taskUrlForPage)}`
              );
              
              const citationResponse = await fetch(queryUrl);
              if (citationResponse.ok) {
                const citationData = await citationResponse.json();
                if (citationData.status === 'ok' && citationData.data && citationData.data.length > 0) {
                  const citingKeywords = citationData.data;
                  const totalCitationCount = typeof citationData.count === 'number' ? citationData.count : citingKeywords.reduce((sum, k) => sum + (k.citation_count || 1), 0);
                  const hasOverview = citingKeywords.some(k => k.has_ai_overview === true);
                  
                  aiForUrl = {
                    ai_overview: hasOverview,
                    ai_citations: totalCitationCount
                  };
                  
                  debugLog(`[Optimisation] URL task ${task.id}: Found ${citingKeywords.length} keywords with ${totalCitationCount} total citations from Supabase`, 'success');
                }
              }
            } catch (supabaseErr) {
              debugLog(`[Optimisation] URL task ${task.id}: Error querying Supabase for citations: ${supabaseErr.message}`, 'warn');
            }
          }
        }

        // Try to get ranking from Ranking & AI data if GSC position is null
        let rankingFromAi = null;
        if ((totals.position == null || totals.position === 0) && aiRows.length > 0) {
          const matchingRows = aiRows.filter(r => {
            const rowUrl = (r.best_url || r.bestUrl || r.targetUrl || r.ranking_url || '').toLowerCase();
            const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
            const taskUrlClean = pageUrlForGsc.replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
            return rowUrlClean === taskUrlClean || 
                   rowUrl.includes(taskUrlClean) || 
                   taskUrlClean.includes(rowUrlClean);
          });
          
          if (matchingRows.length > 0) {
            const ranks = matchingRows
              .map(r => r.best_rank_group || r.current_rank || null)
              .filter(r => r != null && r > 0);
            
            if (ranks.length > 0) {
              const avgRank = ranks.reduce((sum, r) => sum + r, 0) / ranks.length;
              rankingFromAi = avgRank;
              debugLog(`[Optimisation] URL task ${task.id}: Found ranking from Ranking & AI data: ${avgRank.toFixed(2)} (from ${ranks.length} keywords)`, 'info');
            }
          }
        }

        // Build metrics object
        const metrics = {
          gsc_clicks_28d: Number(totals.clicks || 0),
          gsc_impressions_28d: Number(totals.impressions || 0),
          gsc_ctr_28d: Number(totals.ctr || 0), // totals.ctr is already a ratio (0-1) from fetchMetricsForUrlTask
          current_rank: totals.position != null && totals.position > 0 
            ? Number(totals.position) 
            : (rankingFromAi != null ? Number(rankingFromAi) : null),
          opportunity_score: null,
          ai_overview: aiForUrl.ai_overview === true ? true : (aiForUrl.ai_overview === false ? false : null),
          ai_citations: aiForUrl.ai_citations != null ? Number(aiForUrl.ai_citations) : null,
          ai_citations_total: null,
          classic_ranking_url: pageUrlForGsc,
          page_type: task.page_type || null,
          segment: task.segment || 'money_pages',
          captured_at: new Date().toISOString()
        };

        debugLog(`[Optimisation] URL task ${task.id}: Built metrics - clicks=${metrics.gsc_clicks_28d}, impressions=${metrics.gsc_impressions_28d}, rank=${metrics.current_rank}, ai_citations=${metrics.ai_citations}`, 'info');
        return metrics;
      } catch (e) {
        debugLog(`[Optimisation] URL task ${task.id}: Error fetching metrics: ${e.message}`, 'error');
        return null;
      }
    };

    /**
     * Fetches metrics for keyword-based tasks
     * 
     * IMPORTANT: This function fetches ALL fields from BOTH data sources:
     * - GSC (Google Search Console) data: clicks, impressions, CTR (via queryTotals)
     * - Ranking & AI data: current rank, AI overview, AI citations, opportunity score
     * 
     * CRITICAL: NEVER uses Money Pages data (which is page-level aggregated).
     * Keyword tasks MUST use keyword-specific data from combinedRows.
     * 
     * Data sources:
     * 1. combinedRows (Ranking & AI): Provides keyword-specific rank, AI overview, AI citations
     * 2. queryTotals (GSC): Provides keyword-specific clicks, impressions, CTR via getQueryTotalForKeyword()
     * 
     * Returns a complete metrics object with ALL fields populated from BOTH sources:
     * - gsc_clicks_28d, gsc_impressions_28d, gsc_ctr_28d (from GSC queryTotals)
     * - current_rank (from Ranking & AI combinedRows)
     * - ai_overview, ai_citations (from Ranking & AI combinedRows)
     * - opportunity_score, classic_ranking_url, page_type, segment, captured_at
     * 
     * @param {Object} task - Task object with keyword_text
     * @param {Object} latestAudit - Latest audit from Supabase (optional, not used for keyword tasks)
     * @param {Array} combinedRows - Combined rows from Ranking & AI scan (REQUIRED for keyword tasks)
     * @returns {Promise<Object|null>} Complete metrics object with ALL fields from BOTH sources, or null if failed
     */
    window.fetchMetricsForKeywordTask = async function fetchMetricsForKeywordTask(task, latestAudit = null, combinedRows = []) {
      const taskKeyword = task.keyword_text || '';
      if (!taskKeyword || !taskKeyword.trim()) {
        debugLog(`[Optimisation] Keyword task ${task.id}: No keyword provided`, 'warn');
        return null;
      }

      if (!combinedRows || combinedRows.length === 0) {
        debugLog(`[Optimisation] Keyword task ${task.id}: No combinedRows available`, 'warn');
        return null;
      }

      // Find matching row by keyword (URL match is optional for keyword tasks)
      const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
      const taskUrlPath = taskUrlClean.includes('/') ? taskUrlClean.split('/').slice(1).join('/') : '';
      
      const matchingRow = combinedRows.find(r => {
        const keywordMatch = (r.keyword || '').toLowerCase() === taskKeyword.toLowerCase();
        if (!keywordMatch) return false;
        
        // For keyword-based tasks, URL matching is optional
        if (!taskUrlClean || taskUrlClean.length === 0) {
          return true; // Keyword match only - no URL required
        }
        
        // If task has URL, try to match it (preferred but not required)
        const rowUrl = (r.best_url || r.bestUrl || r.targetUrl || r.ranking_url || '').toLowerCase();
        const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
        const rowUrlPath = rowUrlClean.includes('/') ? rowUrlClean.split('/').slice(1).join('/') : '';
        
        const urlMatch = rowUrl === taskUrlClean || 
                        rowUrlClean === taskUrlClean ||
                        rowUrlPath === taskUrlPath ||
                        rowUrl.includes(taskUrlClean) ||
                        taskUrlClean.includes(rowUrlClean);
        
        // Always accept keyword match for keyword tasks (URL is optional)
        return urlMatch || true;
      });

      if (!matchingRow) {
        debugLog(`[Optimisation] Keyword task ${task.id}: No matching row found for keyword "${taskKeyword}" in ${combinedRows.length} rows`, 'warn');
        return null;
      }

      debugLog(`[Optimisation] Keyword task ${task.id}: Found matching row for keyword "${taskKeyword}"`, 'success');

      // Get queryTotal data for clicks, impressions, and CTR (keyword-specific GSC data)
      let queryTotal = null;
      if (typeof getQueryTotalForKeyword === 'function') {
        queryTotal = getQueryTotalForKeyword(taskKeyword);
      }
      
      // Also try to get from latest audit's queryTotals if available
      if (!queryTotal && latestAudit && latestAudit.ranking_ai_data && latestAudit.ranking_ai_data.queryTotals) {
        queryTotal = latestAudit.ranking_ai_data.queryTotals.find(qt => 
          (qt.query || qt.keyword || '').toLowerCase() === taskKeyword.toLowerCase()
        );
      }

      // Build metrics object from keyword-specific data
      const metrics = {
        gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
        gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
        gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d != null ? matchingRow.gsc_ctr_28d : (matchingRow.ctr_28d != null ? matchingRow.ctr_28d : null)),
        current_rank: matchingRow.best_rank_group || matchingRow.current_rank || matchingRow.rank || null,
        opportunity_score: matchingRow.opportunityScore || matchingRow.opportunity_score || null,
        ai_overview: matchingRow.has_ai_overview === true || matchingRow.ai_overview_present_any === true || false,
        ai_citations: matchingRow.ai_alan_citations_count != null ? matchingRow.ai_alan_citations_count : (matchingRow.ai_total_citations != null ? matchingRow.ai_total_citations : 0),
        ai_citations_total: matchingRow.ai_total_citations || null,
        classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
        page_type: matchingRow.pageType || matchingRow.page_type || null,
        segment: matchingRow.segment || null,
        captured_at: new Date().toISOString()
      };

      debugLog(`[Optimisation] Keyword task ${task.id}: Built metrics - clicks=${metrics.gsc_clicks_28d}, impressions=${metrics.gsc_impressions_28d}, rank=${metrics.current_rank}, ai_citations=${metrics.ai_citations}`, 'info');
      return metrics;
    };

    // Bulk update all tasks with latest data
    window.bulkUpdateAllTasks = async function bulkUpdateAllTasks(skipConfirmation = false, options = {}) {
      if (skipConfirmation && typeof skipConfirmation === 'object') {
        options = skipConfirmation;
        skipConfirmation = !!options.skipConfirmation;
      }
      const skipRankingAiCheck = !!options.skipRankingAiCheck;
      const skipKeywordTasks = !!options.skipKeywordTasks;
      debugLog('[Optimisation] ===== bulkUpdateAllTasks START =====', 'info');
      
      // CRITICAL: Ensure we're using the latest audit data from Supabase (by audit_date, not just localStorage)
      // Fetch latest audit from Supabase to ensure we have the most recent audit_date data
      // Note: GSC data is 2 days behind the audit_date, so audit_date 2025-12-28 means GSC data is from 2025-12-26
      let latestAuditFromSupabase = null;
      try {
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (propertyUrl) {
          // Try using fetchLatestAuditFromSupabase function if available
          if (typeof window.fetchLatestAuditFromSupabase === 'function') {
            debugLog(`[Optimisation] Fetching latest audit from Supabase using fetchLatestAuditFromSupabase for ${propertyUrl}...`, 'info');
            latestAuditFromSupabase = await window.fetchLatestAuditFromSupabase(propertyUrl, false);
          } else {
            // Fallback: fetch directly from API
            debugLog(`[Optimisation] fetchLatestAuditFromSupabase not available, fetching directly from API for ${propertyUrl}...`, 'info');
            try {
              const apiBase = window.apiUrl ? window.apiUrl('') : (window.location.origin.includes('localhost') ? 'http://localhost:3000' : 'https://ai-geo-audit.vercel.app');
              const response = await fetch(`${apiBase}/api/supabase/get-latest-audit?property_url=${encodeURIComponent(propertyUrl)}`);
              if (response.ok) {
                latestAuditFromSupabase = await response.json();
                debugLog(`[Optimisation] Successfully fetched latest audit from API`, 'success');
              } else {
                debugLog(`[Optimisation] API returned ${response.status}: ${response.statusText}`, 'warn');
              }
            } catch (apiErr) {
              debugLog(`[Optimisation] Error fetching from API: ${apiErr.message || apiErr}`, 'warn');
            }
          }
          
          if (latestAuditFromSupabase) {
            // Update localStorage with latest audit data to ensure bulk update uses it
            try {
              localStorage.setItem('last_audit_results', JSON.stringify(latestAuditFromSupabase));
              debugLog(`[Optimisation] Updated localStorage with latest audit from Supabase (audit_date: ${latestAuditFromSupabase.auditDate || latestAuditFromSupabase.audit_date || 'unknown'})`, 'success');
              // Also update window.moneyPagesMetrics if available
              if (latestAuditFromSupabase.scores?.moneyPagesMetrics || latestAuditFromSupabase.moneyPagesMetrics) {
                window.moneyPagesMetrics = latestAuditFromSupabase.scores?.moneyPagesMetrics || latestAuditFromSupabase.moneyPagesMetrics;
                window.currentMoneyPagesMetrics = window.moneyPagesMetrics;
                const rowCount = window.moneyPagesMetrics?.rows?.length || 0;
                debugLog(`[Optimisation] Updated window.moneyPagesMetrics from latest audit: ${rowCount} rows available`, 'success');
                if (rowCount > 0) {
                  const sampleUrl = window.moneyPagesMetrics.rows[0].url || window.moneyPagesMetrics.rows[0].page_url || 'N/A';
                  debugLog(`[Optimisation] Sample Money Pages URL: ${sampleUrl}`, 'info');
                }
              } else {
                debugLog(`[Optimisation] Latest audit from Supabase does not contain moneyPagesMetrics`, 'warn');
              }
            } catch (storageErr) {
              debugLog(`[Optimisation] Failed to update localStorage: ${storageErr.message}`, 'warn');
            }
          } else {
            debugLog(`[Optimisation] No latest audit found in Supabase, will use localStorage data`, 'warn');
          }
        } else {
          debugLog(`[Optimisation] No property URL found in localStorage, skipping Supabase fetch`, 'warn');
        }
      } catch (fetchErr) {
        debugLog(`[Optimisation] Error fetching latest audit from Supabase: ${fetchErr.message || fetchErr}`, 'warn');
        // Continue with localStorage data as fallback
      }
      
      // Check available data sources
      const hasLastAuditResults = !!localStorage.getItem('last_audit_results');
      const hasAigeoAuditData = !!localStorage.getItem('aigeo_audit_data');
      const hasWindowMoneyPages = !!(window.moneyPagesMetrics && window.moneyPagesMetrics.rows);
      const auditDate = latestAuditFromSupabase?.auditDate || (() => {
        try {
          const stored = localStorage.getItem('last_audit_results');
          if (stored) {
            const parsed = JSON.parse(stored);
            return parsed.auditDate || null;
          }
        } catch (e) {}
        return null;
      })();
      debugLog(`[Optimisation] Data sources available: last_audit_results=${hasLastAuditResults}, aigeo_audit_data=${hasAigeoAuditData}, window.moneyPagesMetrics=${hasWindowMoneyPages}, audit_date=${auditDate || 'unknown'}`, 'info');
      if (auditDate) {
        const gscDataDate = new Date(new Date(auditDate).getTime() - 2 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
        debugLog(`[Optimisation] Note: GSC data is 2 days behind audit_date, so data reflects: ${gscDataDate}`, 'info');
      }
      
      if (hasLastAuditResults) {
        try {
          const auditData = JSON.parse(localStorage.getItem('last_audit_results'));
          debugLog(`[Optimisation] last_audit_results structure: hasScores=${!!auditData.scores}, hasMoneyPagesMetrics=${!!(auditData.scores?.moneyPagesMetrics)}, hasSearchData=${!!auditData.searchData}, queryTotalsCount=${auditData.searchData?.queryTotals?.length || 0}`, 'info');
        } catch (e) {
          debugLog(`[Optimisation] Error parsing last_audit_results: ${e.message || e}`, 'warn');
        }
      }
      
      if (!window.optimisationModuleState || !window.optimisationModuleState.allTasks) {
        alert('No tasks loaded. Please wait for tasks to load first.');
        return;
      }

      // Get active tasks (not done/cancelled/deleted)
      let activeTasks = window.optimisationModuleState.allTasks.filter(
        t => !['done', 'cancelled', 'deleted'].includes(t.status)
      );

      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        activeTasks = activeTasks.filter(t => !t.is_test_task);
      }

      if (activeTasks.length === 0) {
        alert('No active tasks to update.');
        return;
      }

      // Nudge if Ranking & AI snapshot is stale (bulk update relies on it for keyword-based tasks)
      const hasKeywordTasks = !skipKeywordTasks && activeTasks.some(t => (t.keyword_text || t.keyword || '').trim().length > 0);
      const getRankingAiSnapshotInfo = () => {
        try {
          const local = localStorage.getItem('rankingAiData');
          if (!local) return { has: false, date: null, daysOld: null };
          const parsed = JSON.parse(local);
          const ts = parsed?.timestamp ? new Date(parsed.timestamp) : null;
          if (!ts || isNaN(ts.getTime())) return { has: false, date: null, daysOld: null };
          const now = new Date();
          const daysOld = Math.floor((now.getTime() - ts.getTime()) / 86400000);
          const date = ts.toISOString().split('T')[0];
          return { has: true, date, daysOld };
        } catch (e) {
          return { has: false, date: null, daysOld: null };
        }
      };

      if (hasKeywordTasks && !skipRankingAiCheck) {
        const info = getRankingAiSnapshotInfo();
        // Thresholds: gentle warning at 3+ days; stronger warning at 7+ days.
        const warnDays = 3;
        const strongDays = 7;
        if (!info.has) {
          const ok = confirm(
            'Ranking & AI data is missing in this browser.\n\n' +
            'Bulk update uses Ranking & AI data for keyword-based tasks, so results may be stale or incomplete.\n\n' +
            'Click Cancel to run "Run ranking & AI check" first, or OK to continue anyway.'
          );
          if (!ok) return;
        } else if (info.daysOld != null && info.daysOld >= warnDays) {
          const severity = info.daysOld >= strongDays ? 'WARNING' : 'Note';
          const ok = confirm(
            `${severity}: Ranking & AI data is ${info.daysOld} day(s) old (last: ${info.date}).\n\n` +
            'Bulk update will use this snapshot for keyword-based tasks.\n\n' +
            'Click Cancel to run "Run ranking & AI check" first, or OK to continue.'
          );
          if (!ok) return;
        }
      }

      // Skip confirmation if called from global run (skipConfirmation = true)
      if (!skipConfirmation) {
        const confirmMsg = `Update ${activeTasks.length} task(s) with latest ranking data? This will create a new measurement for each task.`;
        if (!confirm(confirmMsg)) {
          return;
        }
      } else {
        debugLog(`[Optimisation] Bulk update called from global run - skipping confirmation dialog`, 'info');
      }

      // CRITICAL: Load Ranking & AI data for ALL tasks (needed for AI Overview and AI Citations)
      // Even URL-based tasks need Ranking & AI data to populate AI metrics
      // First, try to load from latest audit's ranking_ai_data if available
      if (latestAuditFromSupabase && latestAuditFromSupabase.ranking_ai_data) {
        try {
          debugLog(`[Optimisation] Loading Ranking & AI data from latest audit's ranking_ai_data...`, 'info');
          const rankingAiData = latestAuditFromSupabase.ranking_ai_data;
          if (rankingAiData.combinedRows && Array.isArray(rankingAiData.combinedRows)) {
            // Helper function to safely save to localStorage with size check
            const safeSetItem = (key, value) => {
              try {
                const jsonStr = JSON.stringify(value);
                const sizeKB = (new Blob([jsonStr]).size) / 1024;
                const maxSizeKB = 4000; // Leave some headroom (browsers typically allow 5-10MB total)
                
                if (sizeKB > maxSizeKB) {
                  debugLog(` Data too large for localStorage (${sizeKB.toFixed(1)}KB), skipping save. Supabase is source of truth.`, 'warn');
                  return false;
                }
                localStorage.setItem(key, jsonStr);
                return true;
              } catch (err) {
                if (err.name === 'QuotaExceededError' || err.message.includes('quota')) {
                  debugLog(` Data too large for localStorage, skipping save. Supabase is source of truth.`, 'warn');
                } else {
                  debugLog(` Error saving to localStorage: ${err.message}`, 'warn');
                }
                return false;
              }
            };
            
            // Try to save, but don't fail if it's too large
            safeSetItem('rankingAiData', rankingAiData);
            // Always set window.rankingAiData regardless of localStorage success
            window.rankingAiData = rankingAiData.combinedRows;
            debugLog(`[Optimisation] Loaded ${rankingAiData.combinedRows.length} keywords from latest audit's ranking_ai_data`, 'success');
            // Also set window.combinedRows if RankingAiModule expects it
            if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
              // Trigger state update by calling renderRankingAiTab
          await window.renderRankingAiTab();
            }
          } else {
            debugLog(`[Optimisation] Latest audit ranking_ai_data does not contain combinedRows array`, 'warn');
          }
        } catch (rankingErr) {
          debugLog(`[Optimisation] Error loading ranking_ai_data from latest audit: ${rankingErr.message || rankingErr}`, 'warn');
        }
      }
      
      // Also try to load via renderRankingAiTab (will use localStorage or fetch from API)
      if (typeof window.renderRankingAiTab === 'function') {
        try {
          debugLog(`[Optimisation] Loading Ranking & AI data via renderRankingAiTab...`, 'info');
          await window.renderRankingAiTab();
          await new Promise(resolve => setTimeout(resolve, 2000)); // Give more time for data to load
          // Verify data is loaded
          const rankingDataLoaded = (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) 
            ? (RankingAiModule.state().combinedRows || []).length > 0
            : false;
          if (rankingDataLoaded) {
            debugLog(`[Optimisation] Ranking & AI data loaded successfully via renderRankingAiTab`, 'success');
          } else {
            debugLog(`[Optimisation] WARNING: Ranking & AI data not loaded - AI Overview and Citations may be missing`, 'warn');
            // Try to get from localStorage as fallback
            const localRankingData = localStorage.getItem('rankingAiData');
            if (localRankingData) {
              try {
                const parsed = JSON.parse(localRankingData);
                if (parsed.combinedRows && parsed.combinedRows.length > 0) {
                  debugLog(`[Optimisation] Found ${parsed.combinedRows.length} keywords in localStorage rankingAiData`, 'info');
                }
              } catch (e) {
                debugLog(`[Optimisation] Error parsing localStorage rankingAiData: ${e.message}`, 'warn');
              }
            }
          }
        } catch (e) {
          debugLog(`[Optimisation] Could not refresh Ranking & AI data: ${e.message || e}`, 'warn');
        }
      }

      // Get ranking data sources
      let combinedRows = [];
      if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
        const state = RankingAiModule.state();
        combinedRows = state.combinedRows || [];
      }
      if (combinedRows.length === 0 && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
        combinedRows = window.rankingAiData;
      }
      // Fallback: use localStorage snapshot if present (saved by Ranking & AI check)
      if (combinedRows.length === 0) {
        try {
          const local = localStorage.getItem('rankingAiData');
          if (local) {
            const parsed = JSON.parse(local);
            if (parsed && Array.isArray(parsed.combinedRows)) {
              combinedRows = parsed.combinedRows;
            }
          }
        } catch (e) {
          // ignore
        }
      }

      // Only block if we truly need ranking data (keyword-based tasks)
      if (hasKeywordTasks && combinedRows.length === 0) {
        alert('No ranking data available. Please run a Ranking & AI check first.');
        return;
      }

      const bulkUpdateBtn = document.getElementById('optimisation-bulk-update-btn');
      const originalText = bulkUpdateBtn ? bulkUpdateBtn.textContent : '';
      if (bulkUpdateBtn) {
        bulkUpdateBtn.disabled = true;
        bulkUpdateBtn.textContent = 'Updating...';
      }

      let successCount = 0;
      let skippedCount = 0;
      let failCount = 0;
      const errors = [];

      try {
        // Process sequentially to avoid rate limits (max 3 concurrent)
        const maxConcurrent = 3;
        for (let i = 0; i < activeTasks.length; i += maxConcurrent) {
          const batch = activeTasks.slice(i, i + maxConcurrent);
          
          await Promise.all(batch.map(async (task, batchIdx) => {
            const taskNum = i + batchIdx + 1;
            if (bulkUpdateBtn) {
              bulkUpdateBtn.textContent = `Updating ${taskNum}/${activeTasks.length}...`;
            }

          // Use shared helper functions to ensure consistency across all update paths
          const taskKeyword = task.keyword_text || '';
          const hasKeyword = !!(taskKeyword && taskKeyword.trim());
          const taskUrl = task.target_url_clean || task.target_url || ''; // Define early for use in error messages
          
          let currentMetrics = null;
          let matchingRow = null; // Declare for legacy fallback code
          
          // CRITICAL: For keyword-based tasks, use keyword-specific data (NEVER Money Pages)
          // For URL-only tasks, use GSC page totals API + Ranking & AI data
          if (hasKeyword) {
            if (skipKeywordTasks) {
              skippedCount += 1;
              return;
            }
            // Keyword-based task: Use keyword-specific data from combinedRows
            debugLog(`[Optimisation] Task ${task.id}: Fetching metrics for keyword task "${taskKeyword}"`, 'info');
            currentMetrics = await window.fetchMetricsForKeywordTask(task, latestAuditFromSupabase, combinedRows);
          } else {
            // URL-only task: Use GSC page totals API + Ranking & AI data
            debugLog(`[Optimisation] Task ${task.id}: Fetching metrics for URL-only task`, 'info');
            currentMetrics = await window.fetchMetricsForUrlTask(task, latestAuditFromSupabase, combinedRows);
            
            // Fallback: If GSC API failed, try Money Pages data (from latest audit)
            if (!currentMetrics) {
              debugLog(`[Optimisation] Task ${task.id}: GSC API failed, trying Money Pages data fallback...`, 'warn');
              let normalizedTaskUrl = taskUrl.toLowerCase()
                .replace(/^https?:\/\//, '')
                .replace(/^www\./, '')
                .replace(/\/$/, '');
              
              if (normalizedTaskUrl && normalizedTaskUrl.length > 0 && window.moneyPagesMetrics && window.moneyPagesMetrics.rows) {
                const moneyPageRow = window.moneyPagesMetrics.rows.find(row => {
                  const rowUrl = row.url || row.page_url || '';
                  let normalizedRowUrl = rowUrl.toLowerCase()
                    .replace(/^https?:\/\//, '')
                    .replace(/^www\./, '')
                    .replace(/\/$/, '');
                  return normalizedRowUrl === normalizedTaskUrl;
                });
                
                if (moneyPageRow) {
                  // Simple Money Pages fallback - build metrics from Money Pages data
                  let ctrValue = moneyPageRow.ctr || moneyPageRow.ctr_28d || null;
                  if (ctrValue != null && ctrValue > 1 && ctrValue <= 100) {
                    ctrValue = ctrValue / 100;
                  }
                  
                  // Get AI metrics from combinedRows
                  let aiForUrl = { ai_overview: false, ai_citations: null };
                  if (typeof window.computeAiMetricsForPageUrl === 'function' && combinedRows.length > 0) {
                    aiForUrl = window.computeAiMetricsForPageUrl(moneyPageRow.url || moneyPageRow.page_url || taskUrl, combinedRows);
                  }
                  
                  // Get rank - try Money Pages first, then Ranking & AI fallback
                  let currentRank = moneyPageRow.avg_position != null ? moneyPageRow.avg_position : 
                                     (moneyPageRow.position != null ? moneyPageRow.position : null);
                  if ((currentRank == null || currentRank === 0) && combinedRows.length > 0) {
                    const matchingRows = combinedRows.filter(r => {
                      const rowUrl = (r.best_url || r.bestUrl || r.targetUrl || r.ranking_url || '').toLowerCase();
                      const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
                      const taskUrlClean = (moneyPageRow.url || moneyPageRow.page_url || taskUrl).replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
                      return rowUrlClean === taskUrlClean || 
                             rowUrl.includes(taskUrlClean) || 
                             taskUrlClean.includes(rowUrlClean);
                    });
                    
                    if (matchingRows.length > 0) {
                      const ranks = matchingRows
                        .map(r => r.best_rank_group || r.current_rank || null)
                        .filter(r => r != null && r > 0);
                      
                      if (ranks.length > 0) {
                        currentRank = ranks.reduce((sum, r) => sum + r, 0) / ranks.length;
                      }
                    }
                  }
                  
                  currentMetrics = {
                    gsc_clicks_28d: moneyPageRow.clicks || moneyPageRow.clicks_28d || null,
                    gsc_impressions_28d: moneyPageRow.impressions || moneyPageRow.impressions_28d || null,
                    gsc_ctr_28d: ctrValue,
                    current_rank: currentRank,
                    opportunity_score: null,
                    ai_overview: aiForUrl.ai_overview === true ? true : (aiForUrl.ai_overview === false ? false : null),
                    ai_citations: aiForUrl.ai_citations != null ? Number(aiForUrl.ai_citations) : null,
                    ai_citations_total: null,
                    classic_ranking_url: moneyPageRow.url || moneyPageRow.page_url || taskUrl,
                    page_type: moneyPageRow.page_type || moneyPageRow.type || null,
                    segment: 'money_pages',
                    captured_at: new Date().toISOString()
                  };
                }
              }
            }
          }
          
          // Fallback to baseline if no current data found
          if (!currentMetrics && task.baseline_metrics) {
            debugLog(`[Optimisation] Task ${task.id} (${task.keyword_text || taskUrl || 'Unknown task'}): No current data found, using baseline metrics as fallback`, 'warn');
            const normalizedTaskUrl = taskUrl.toLowerCase()
              .replace(/^https?:\/\//, '')
              .replace(/^www\./, '')
              .replace(/\/$/, '');
            debugLog(`[Optimisation] Task ${task.id}: Searching for URL "${normalizedTaskUrl}" in Money Pages data`, 'info');
            
            // Check window.moneyPagesMetrics first
            if (window.moneyPagesMetrics && window.moneyPagesMetrics.rows) {
              // Old code removed - using helper functions instead
              const moneyPageRow = window.moneyPagesMetrics.rows.find(row => {
                const rowUrl = row.url || row.page_url || '';
                // Normalize row URL the same way as task URL (simple normalization, no normalizeUrlForDedupe)
                let normalizedRowUrl = rowUrl.toLowerCase()
                  .replace(/^https?:\/\//, '')
                  .replace(/^www\./, '')
                  .replace(/\/$/, '');
                if (normalizedRowUrl === normalizedTaskUrl) {
                  debugLog(`[Optimisation] Task ${task.id}: Found match in window.moneyPagesMetrics: ${rowUrl} -> ${normalizedRowUrl} (task: ${normalizedTaskUrl})`, 'success');
                  return true;
                }
                return false;
              });
              
              if (moneyPageRow) {
                debugLog(`[Optimisation] Task ${task.id}: Using window.moneyPagesMetrics data: clicks=${moneyPageRow.clicks || moneyPageRow.clicks_28d}, impressions=${moneyPageRow.impressions || moneyPageRow.impressions_28d}, ctr=${moneyPageRow.ctr || moneyPageRow.ctr_28d}, rank=${moneyPageRow.avg_position || moneyPageRow.position}`, 'success');
                debugLog(`[Optimisation] Task ${task.id}: Full moneyPageRow data: ${JSON.stringify({url: moneyPageRow.url, clicks: moneyPageRow.clicks, clicks_28d: moneyPageRow.clicks_28d, impressions: moneyPageRow.impressions, impressions_28d: moneyPageRow.impressions_28d, ctr: moneyPageRow.ctr, ctr_28d: moneyPageRow.ctr_28d, avg_position: moneyPageRow.avg_position, position: moneyPageRow.position})}`, 'info');
                // Normalize CTR: Money Pages stores CTR as ratio (0-1), but check if it's actually a percentage
                let ctrValue = moneyPageRow.ctr || moneyPageRow.ctr_28d || null;
                if (ctrValue != null) {
                  // If CTR is > 1, assume it's a percentage and convert to ratio
                  if (ctrValue > 1 && ctrValue <= 100) {
                    debugLog(`[Optimisation] Money Pages CTR appears to be percentage, converting to ratio: ${ctrValue} -> ${ctrValue / 100}`, 'warn');
                    ctrValue = ctrValue / 100;
                  } else if (ctrValue > 100) {
                    debugLog(`[Optimisation] Money Pages CTR value seems invalid (>100%): ${ctrValue}`, 'error');
                    ctrValue = null;
                  }
                  // If CTR is <= 1, assume it's already a ratio (0-1)
                }
                // Get AI metrics - try multiple data sources
                let aiForUrl = { ai_overview: false, ai_citations: null };
                if (typeof window.computeAiMetricsForPageUrl === 'function') {
                  // Try with combinedRows first
                  aiForUrl = window.computeAiMetricsForPageUrl(moneyPageRow.url || moneyPageRow.page_url || taskUrl, combinedRows);
                  // If no data found, try with RankingAiModule state
                  if ((aiForUrl.ai_overview === false || aiForUrl.ai_overview === null) && aiForUrl.ai_citations === null) {
                    if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
                      const state = RankingAiModule.state();
                      const stateRows = state.combinedRows || [];
                      if (stateRows.length > 0) {
                        debugLog(`[Optimisation] Task ${task.id}: Retrying AI metrics with RankingAiModule state (${stateRows.length} rows)`, 'info');
                        aiForUrl = window.computeAiMetricsForPageUrl(moneyPageRow.url || moneyPageRow.page_url || taskUrl, stateRows);
                      }
                    }
                  }
                  // If still no data, try latest audit's ranking_ai_data directly (keyword-based lookup)
                  if ((aiForUrl.ai_overview === false || aiForUrl.ai_overview === null) && aiForUrl.ai_citations === null && taskKeyword) {
                    if (latestAuditFromSupabase && latestAuditFromSupabase.ranking_ai_data && latestAuditFromSupabase.ranking_ai_data.combinedRows) {
                      const auditRows = latestAuditFromSupabase.ranking_ai_data.combinedRows;
                      const keywordMatch = auditRows.find(r => 
                        (r.keyword || '').toLowerCase() === taskKeyword.toLowerCase()
                      );
                      if (keywordMatch) {
                        debugLog(`[Optimisation] Task ${task.id}: Found keyword "${taskKeyword}" in latest audit's ranking_ai_data`, 'success');
                        aiForUrl = {
                          ai_overview: keywordMatch.has_ai_overview === true || keywordMatch.ai_overview_present_any === true,
                          ai_citations: keywordMatch.ai_alan_citations_count != null ? keywordMatch.ai_alan_citations_count : (keywordMatch.ai_total_citations || 0)
                        };
                        debugLog(`[Optimisation] Task ${task.id}: AI metrics from latest audit: overview=${aiForUrl.ai_overview}, citations=${aiForUrl.ai_citations}`, 'info');
                      }
                    }
                  }
                  
                  // FALLBACK: For URL-only tasks, if AI citations still missing, query Supabase directly (same as addMeasurement)
                  if ((aiForUrl.ai_overview === false || aiForUrl.ai_overview === null) && aiForUrl.ai_citations === null && !taskKeyword) {
                    debugLog(`[Optimisation] Task ${task.id}: URL-only task - AI citations missing, querying Supabase directly...`, 'info');
                    try {
                      const propertyUrl = document.getElementById('propertyUrl')?.value || 
                                        localStorage.getItem('gsc_property_url') || 
                                        'https://www.alanranger.com';
                      const taskUrlForQuery = moneyPageRow.url || moneyPageRow.page_url || taskUrl;
                      const queryUrl = apiUrl(`/api/supabase/query-keywords-citing-url?` +
                        `property_url=${encodeURIComponent(propertyUrl)}&` +
                        `target_url=${encodeURIComponent(taskUrlForQuery)}`
                      );
                      
                      const citationResponse = await fetch(queryUrl);
                      if (citationResponse.ok) {
                        const citationData = await citationResponse.json();
                        if (citationData.status === 'ok' && citationData.data && citationData.data.length > 0) {
                          const citingKeywords = citationData.data;
                          // Use total citation count from API (not unique keywords count)
                          const totalCitationCount = typeof citationData.count === 'number' ? citationData.count : citingKeywords.reduce((sum, k) => sum + (k.citation_count || 1), 0);
                          const hasOverview = citingKeywords.some(k => k.has_ai_overview === true);
                          
                          aiForUrl = {
                            ai_overview: hasOverview,
                            ai_citations: totalCitationCount
                          };
                          
                          debugLog(
                            `[Optimisation] Task ${task.id}: Supabase query found ${citingKeywords.length} keywords with ${totalCitationCount} total citations: ` +
                            `${citingKeywords.map(k => k.keyword).join(', ')}`,
                            'success'
                          );
                        } else {
                          debugLog(`[Optimisation] Task ${task.id}: Supabase query found no citations (status: ${citationData.status})`, 'warn');
                        }
                      } else {
                        const errorText = await citationResponse.text().catch(() => 'Unable to read error');
                        debugLog(`[Optimisation] Task ${task.id}: Supabase query failed: ${citationResponse.status} - ${errorText}`, 'warn');
                      }
                    } catch (supabaseErr) {
                      debugLog(`[Optimisation] Task ${task.id}: Error querying Supabase for citations: ${supabaseErr.message}`, 'warn');
                    }
                  }
                  
                  debugLog(`[Optimisation] Task ${task.id}: Final AI metrics result: overview=${aiForUrl.ai_overview}, citations=${aiForUrl.ai_citations}`, 'info');
                } else {
                  debugLog(`[Optimisation] Task ${task.id}: computeAiMetricsForPageUrl function not available`, 'warn');
                }
                
                // Get current rank - ensure we use the correct field name
                let currentRank = moneyPageRow.avg_position != null ? moneyPageRow.avg_position : 
                                   (moneyPageRow.position != null ? moneyPageRow.position : null);
                debugLog(`[Optimisation] Task ${task.id}: Current rank from Money Pages: avg_position=${moneyPageRow.avg_position}, position=${moneyPageRow.position}, final=${currentRank}`, 'info');
                
                // FALLBACK: If rank is missing from Money Pages, try to get from Ranking & AI data (same as addMeasurement)
                if ((currentRank == null || currentRank === 0) && combinedRows.length > 0) {
                  debugLog(`[Optimisation] Task ${task.id}: Rank missing from Money Pages, trying Ranking & AI fallback...`, 'info');
                  const taskUrlForLookup = moneyPageRow.url || moneyPageRow.page_url || taskUrl;
                  const matchingRows = combinedRows.filter(r => {
                    const rowUrl = (r.best_url || r.bestUrl || r.targetUrl || r.ranking_url || '').toLowerCase();
                    const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
                    const taskUrlClean = taskUrlForLookup.replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
                    return rowUrlClean === taskUrlClean || 
                           rowUrl.includes(taskUrlClean) || 
                           taskUrlClean.includes(rowUrlClean);
                  });
                  
                  if (matchingRows.length > 0) {
                    const ranks = matchingRows
                      .map(r => r.best_rank_group || r.current_rank || null)
                      .filter(r => r != null && r > 0);
                    
                    if (ranks.length > 0) {
                      const avgRank = ranks.reduce((sum, r) => sum + r, 0) / ranks.length;
                      currentRank = avgRank;
                      debugLog(`[Optimisation] Task ${task.id}: Found ranking from Ranking & AI data: ${avgRank.toFixed(2)} (from ${ranks.length} keywords)`, 'success');
                    }
                  }
                }
                
                currentMetrics = {
                  gsc_clicks_28d: moneyPageRow.clicks || moneyPageRow.clicks_28d || null,
                  gsc_impressions_28d: moneyPageRow.impressions || moneyPageRow.impressions_28d || null,
                  gsc_ctr_28d: ctrValue, // Normalized to ratio (0-1)
                  current_rank: currentRank,
                  opportunity_score: null,
                  ai_overview: aiForUrl.ai_overview === true ? true : (aiForUrl.ai_overview === false ? false : null),
                  ai_citations: aiForUrl.ai_citations != null ? Number(aiForUrl.ai_citations) : null,
                  ai_citations_total: null,
                  classic_ranking_url: moneyPageRow.url || moneyPageRow.page_url || taskUrl,
                  page_type: moneyPageRow.page_type || moneyPageRow.type || null,
                  segment: 'money_pages',
                  captured_at: new Date().toISOString()
                };
                debugLog(`[Optimisation] Task ${task.id}: Final metrics being saved: rank=${currentMetrics.current_rank}, ai_overview=${currentMetrics.ai_overview}, ai_citations=${currentMetrics.ai_citations}`, 'info');
              }
            }
            
          // If still no data, check localStorage/Supabase audit results
          if (!currentMetrics) {
            try {
              // Check both keys: last_audit_results (current) and aigeo_audit_data (legacy)
              let savedAudit = localStorage.getItem('last_audit_results');
              let dataSource = 'last_audit_results';
              if (!savedAudit) {
                savedAudit = localStorage.getItem('aigeo_audit_data');
                dataSource = 'aigeo_audit_data';
              }
              if (savedAudit) {
                debugLog(`[Optimisation] Reading audit data from ${dataSource} for task ${task.id} (${task.keyword_text || taskUrl})`, 'info');
                const parsed = JSON.parse(savedAudit);
                const moneyPagesData = parsed.scores?.moneyPagesMetrics || parsed.moneyPagesMetrics;
                debugLog(`[Optimisation] Parsed audit data: hasMoneyPagesData=${!!moneyPagesData}, moneyPagesRows=${moneyPagesData?.rows?.length || 0}, hasSearchData=${!!parsed.searchData}, queryTotalsCount=${parsed.searchData?.queryTotals?.length || 0}`, 'info');
                  
                  if (moneyPagesData && moneyPagesData.rows) {
                    debugLog(`[Optimisation] Task ${task.id}: Searching ${moneyPagesData.rows.length} rows in ${dataSource} for normalized URL: "${normalizedTaskUrl}" (original: "${taskUrl}")`, 'info');
                    const moneyPageRow = moneyPagesData.rows.find(row => {
                      const rowUrl = row.url || row.page_url || '';
                      // Normalize row URL the same way as task URL (simple normalization, no normalizeUrlForDedupe)
                      let normalizedRowUrl = rowUrl.toLowerCase()
                        .replace(/^https?:\/\//, '')
                        .replace(/^www\./, '')
                        .replace(/\/$/, '');
                      if (normalizedRowUrl === normalizedTaskUrl) {
                        debugLog(`[Optimisation] Task ${task.id}: Found match in ${dataSource}: ${rowUrl} -> ${normalizedRowUrl} (task: ${normalizedTaskUrl})`, 'success');
                        return true;
                      }
                      return false;
                    });
                    
                    if (moneyPageRow) {
                      debugLog(`[Optimisation] Task ${task.id} (${task.keyword_text || taskUrl}): Found matching Money Page row in ${dataSource}: clicks=${moneyPageRow.clicks || moneyPageRow.clicks_28d}, impressions=${moneyPageRow.impressions || moneyPageRow.impressions_28d}, ctr=${moneyPageRow.ctr || moneyPageRow.ctr_28d}, rank=${moneyPageRow.avg_position || moneyPageRow.position}`, 'success');
                      debugLog(`[Optimisation] Task ${task.id}: Full moneyPageRow from ${dataSource}: ${JSON.stringify({url: moneyPageRow.url, clicks: moneyPageRow.clicks, clicks_28d: moneyPageRow.clicks_28d, impressions: moneyPageRow.impressions, impressions_28d: moneyPageRow.impressions_28d, ctr: moneyPageRow.ctr, ctr_28d: moneyPageRow.ctr_28d, avg_position: moneyPageRow.avg_position, position: moneyPageRow.position})}`, 'info');
                      // Normalize CTR: Money Pages stores CTR as ratio (0-1), but check if it's actually a percentage
                      let ctrValue = moneyPageRow.ctr || moneyPageRow.ctr_28d || null;
                      if (ctrValue != null) {
                        // If CTR is > 1, assume it's a percentage and convert to ratio
                        if (ctrValue > 1 && ctrValue <= 100) {
                          debugLog(`[Optimisation] Money Pages CTR appears to be percentage, converting to ratio: ${ctrValue} -> ${ctrValue / 100}`, 'warn');
                          ctrValue = ctrValue / 100;
                        } else if (ctrValue > 100) {
                          debugLog(`[Optimisation] Money Pages CTR value seems invalid (>100%): ${ctrValue}`, 'error');
                          ctrValue = null;
                        }
                        // If CTR is <= 1, assume it's already a ratio (0-1)
                      }
                      
                      // Get AI metrics - try multiple data sources
                      let aiForUrl = { ai_overview: false, ai_citations: null };
                      if (typeof window.computeAiMetricsForPageUrl === 'function') {
                        // Try with combinedRows first
                        aiForUrl = window.computeAiMetricsForPageUrl(moneyPageRow.url || moneyPageRow.page_url || taskUrl, combinedRows);
                        // If no data found, try with RankingAiModule state
                        if ((aiForUrl.ai_overview === false || aiForUrl.ai_overview === null) && aiForUrl.ai_citations === null) {
                          if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
                            const state = RankingAiModule.state();
                            const stateRows = state.combinedRows || [];
                            if (stateRows.length > 0) {
                              debugLog(`[Optimisation] Task ${task.id}: Retrying AI metrics with RankingAiModule state (${stateRows.length} rows)`, 'info');
                              aiForUrl = window.computeAiMetricsForPageUrl(moneyPageRow.url || moneyPageRow.page_url || taskUrl, stateRows);
                            }
                          }
                        }
                        // If still no data, try latest audit's ranking_ai_data directly (keyword-based lookup)
                        if ((aiForUrl.ai_overview === false || aiForUrl.ai_overview === null) && aiForUrl.ai_citations === null && taskKeyword) {
                          if (latestAuditFromSupabase && latestAuditFromSupabase.ranking_ai_data && latestAuditFromSupabase.ranking_ai_data.combinedRows) {
                            const auditRows = latestAuditFromSupabase.ranking_ai_data.combinedRows;
                            const keywordMatch = auditRows.find(r => 
                              (r.keyword || '').toLowerCase() === taskKeyword.toLowerCase()
                            );
                            if (keywordMatch) {
                              debugLog(`[Optimisation] Task ${task.id}: Found keyword "${taskKeyword}" in latest audit's ranking_ai_data`, 'success');
                              aiForUrl = {
                                ai_overview: keywordMatch.has_ai_overview === true || keywordMatch.ai_overview_present_any === true,
                                ai_citations: keywordMatch.ai_alan_citations_count != null ? keywordMatch.ai_alan_citations_count : (keywordMatch.ai_total_citations || 0)
                              };
                              debugLog(`[Optimisation] Task ${task.id}: AI metrics from latest audit: overview=${aiForUrl.ai_overview}, citations=${aiForUrl.ai_citations}`, 'info');
                            }
                          }
                        }
                        
                        // FALLBACK: For URL-only tasks, if AI citations still missing, query Supabase directly (same as addMeasurement)
                        if ((aiForUrl.ai_overview === false || aiForUrl.ai_overview === null) && aiForUrl.ai_citations === null && !taskKeyword) {
                          debugLog(`[Optimisation] Task ${task.id}: URL-only task - AI citations missing, querying Supabase directly...`, 'info');
                          try {
                            const propertyUrl = document.getElementById('propertyUrl')?.value || 
                                              localStorage.getItem('gsc_property_url') || 
                                              'https://www.alanranger.com';
                            const taskUrlForQuery = moneyPageRow.url || moneyPageRow.page_url || taskUrl;
                            const queryUrl = apiUrl(`/api/supabase/query-keywords-citing-url?` +
                              `property_url=${encodeURIComponent(propertyUrl)}&` +
                              `target_url=${encodeURIComponent(taskUrlForQuery)}`
                            );
                            
                            const citationResponse = await fetch(queryUrl);
                            if (citationResponse.ok) {
                              const citationData = await citationResponse.json();
                              if (citationData.status === 'ok' && citationData.data && citationData.data.length > 0) {
                                const citingKeywords = citationData.data;
                                // Use total citation count from API (not unique keywords count)
                                const totalCitationCount = typeof citationData.count === 'number' ? citationData.count : citingKeywords.reduce((sum, k) => sum + (k.citation_count || 1), 0);
                                const hasOverview = citingKeywords.some(k => k.has_ai_overview === true);
                                
                                aiForUrl = {
                                  ai_overview: hasOverview,
                                  ai_citations: totalCitationCount
                                };
                                
                                debugLog(
                                  `[Optimisation] Task ${task.id}: Supabase query found ${citingKeywords.length} keywords with ${totalCitationCount} total citations: ` +
                                  `${citingKeywords.map(k => k.keyword).join(', ')}`,
                                  'success'
                                );
                              } else {
                                debugLog(`[Optimisation] Task ${task.id}: Supabase query found no citations (status: ${citationData.status})`, 'warn');
                              }
                            } else {
                              const errorText = await citationResponse.text().catch(() => 'Unable to read error');
                              debugLog(`[Optimisation] Task ${task.id}: Supabase query failed: ${citationResponse.status} - ${errorText}`, 'warn');
                            }
                          } catch (supabaseErr) {
                            debugLog(`[Optimisation] Task ${task.id}: Error querying Supabase for citations: ${supabaseErr.message}`, 'warn');
                          }
                        }
                        
                        debugLog(`[Optimisation] Task ${task.id}: Final AI metrics result from ${dataSource}: overview=${aiForUrl.ai_overview}, citations=${aiForUrl.ai_citations}`, 'info');
                      } else {
                        debugLog(`[Optimisation] Task ${task.id}: computeAiMetricsForPageUrl function not available`, 'warn');
                      }
                      
                      // Get current rank - ensure we use the correct field name
                      let currentRank = moneyPageRow.avg_position != null ? moneyPageRow.avg_position : 
                                         (moneyPageRow.position != null ? moneyPageRow.position : null);
                      debugLog(`[Optimisation] Task ${task.id}: Current rank from ${dataSource}: avg_position=${moneyPageRow.avg_position}, position=${moneyPageRow.position}, final=${currentRank}`, 'info');
                      
                      // FALLBACK: If rank is missing from Money Pages, try to get from Ranking & AI data (same as addMeasurement)
                      if ((currentRank == null || currentRank === 0) && combinedRows.length > 0) {
                        debugLog(`[Optimisation] Task ${task.id}: Rank missing from ${dataSource}, trying Ranking & AI fallback...`, 'info');
                        const taskUrlForLookup = moneyPageRow.url || moneyPageRow.page_url || taskUrl;
                        const matchingRows = combinedRows.filter(r => {
                          const rowUrl = (r.best_url || r.bestUrl || r.targetUrl || r.ranking_url || '').toLowerCase();
                          const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
                          const taskUrlClean = taskUrlForLookup.replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
                          return rowUrlClean === taskUrlClean || 
                                 rowUrl.includes(taskUrlClean) || 
                                 taskUrlClean.includes(rowUrlClean);
                        });
                        
                        if (matchingRows.length > 0) {
                          const ranks = matchingRows
                            .map(r => r.best_rank_group || r.current_rank || null)
                            .filter(r => r != null && r > 0);
                          
                          if (ranks.length > 0) {
                            const avgRank = ranks.reduce((sum, r) => sum + r, 0) / ranks.length;
                            currentRank = avgRank;
                            debugLog(`[Optimisation] Task ${task.id}: Found ranking from Ranking & AI data: ${avgRank.toFixed(2)} (from ${ranks.length} keywords)`, 'success');
                          }
                        }
                      }
                      
                      currentMetrics = {
                        gsc_clicks_28d: moneyPageRow.clicks || moneyPageRow.clicks_28d || null,
                        gsc_impressions_28d: moneyPageRow.impressions || moneyPageRow.impressions_28d || null,
                        gsc_ctr_28d: ctrValue, // Normalized to ratio (0-1)
                        current_rank: currentRank,
                        opportunity_score: null,
                        ai_overview: aiForUrl.ai_overview === true ? true : (aiForUrl.ai_overview === false ? false : null),
                        ai_citations: aiForUrl.ai_citations != null ? Number(aiForUrl.ai_citations) : null,
                        ai_citations_total: null,
                        classic_ranking_url: moneyPageRow.url || moneyPageRow.page_url || taskUrl,
                        page_type: moneyPageRow.page_type || moneyPageRow.type || null,
                        segment: 'money_pages',
                        captured_at: new Date().toISOString()
                      };
                      debugLog(`[Optimisation] Task ${task.id}: Final metrics from ${dataSource}: rank=${currentMetrics.current_rank}, ai_overview=${currentMetrics.ai_overview}, ai_citations=${currentMetrics.ai_citations}`, 'info');
                    }
                  }
                  
                  // Check queryTotals for URL-based matching
                  if (!currentMetrics && parsed.searchData && parsed.searchData.queryTotals) {
                    const matchingQueries = parsed.searchData.queryTotals.filter(qt => {
                      const qtUrl = (qt.best_url || qt.targetUrl || '').toLowerCase();
                      // Normalize queryTotals URL the same way as task URL (simple normalization, no normalizeUrlForDedupe)
                      let normalizedQtUrl = qtUrl
                        .replace(/^https?:\/\//, '')
                        .replace(/^www\./, '')
                        .replace(/\/$/, '');
                      return normalizedQtUrl === normalizedTaskUrl;
                    });
                    
                    if (matchingQueries.length > 0) {
                      debugLog(`[Optimisation] Task ${task.id} (${task.keyword_text || taskUrl}): Found ${matchingQueries.length} matching query(ies) in ${dataSource}`, 'info');
                      // For URL-based matching, aggregate all queries for that URL (page-level data)
                      if (matchingQueries.length > 1) {
                        // Aggregate all queries for this URL
                        const totalClicks = matchingQueries.reduce((sum, qt) => sum + (qt.clicks || 0), 0);
                        const totalImpressions = matchingQueries.reduce((sum, qt) => sum + (qt.impressions || 0), 0);
                        const weightedCtr = totalImpressions > 0 ? totalClicks / totalImpressions : null;
                        // Use best rank from the query with highest clicks
                        const bestQuery = matchingQueries.reduce((best, qt) => 
                          (qt.clicks || 0) > (best.clicks || 0) ? qt : best, matchingQueries[0]);
                        debugLog(`[Optimisation] Aggregated ${matchingQueries.length} queries for URL in bulk update: ${totalClicks} clicks, ${totalImpressions} impressions`, 'info');
                        currentMetrics = {
                          gsc_clicks_28d: totalClicks || null,
                          gsc_impressions_28d: totalImpressions || null,
                          gsc_ctr_28d: weightedCtr, // Already a ratio (0-1)
                          current_rank: bestQuery.best_rank || bestQuery.avg_position || null,
                          opportunity_score: bestQuery.opportunityScore || null,
                          ai_overview: matchingQueries.some(qt => qt.has_ai_overview) || false,
                          ai_citations: matchingQueries.reduce((sum, qt) => sum + (qt.ai_alan_citations_count || 0), 0),
                          ai_citations_total: matchingQueries.reduce((sum, qt) => sum + (qt.ai_total_citations || 0), 0),
                          classic_ranking_url: bestQuery.best_url || bestQuery.targetUrl || taskUrl,
                          page_type: bestQuery.pageType || null,
                          segment: bestQuery.segment || null,
                          captured_at: new Date().toISOString()
                        };
                      } else {
                        // Single match: use first query
                        const qt = matchingQueries[0];
                        currentMetrics = {
                          gsc_clicks_28d: qt.clicks || null,
                          gsc_impressions_28d: qt.impressions || null,
                          gsc_ctr_28d: qt.ctr != null ? (qt.ctr / 100) : null,
                          current_rank: qt.best_rank || qt.avg_position || null,
                          opportunity_score: qt.opportunityScore || null,
                          ai_overview: qt.has_ai_overview || false,
                          ai_citations: qt.ai_alan_citations_count || 0,
                          ai_citations_total: qt.ai_total_citations || 0,
                          classic_ranking_url: qt.best_url || qt.targetUrl || taskUrl,
                          page_type: qt.pageType || null,
                          segment: qt.segment || null,
                          captured_at: new Date().toISOString()
                        };
                      }
                    }
                  }
                }
              } catch (e) {
                debugLog(`[Optimisation] Error checking localStorage for task ${task.id}: ${e.message || e}`, 'warn');
              }
            }
          }

          // If found matching row in Ranking & AI, use that data
          // CRITICAL: This must run BEFORE Money Pages lookup to prioritize keyword-specific data
          if (matchingRow && !currentMetrics) {
            debugLog(`[Optimisation] Task ${task.id}: Using keyword-specific data from combinedRows for "${taskKeyword}"`, 'success');
            // Get queryTotal data for clicks, impressions, and CTR (from latest audit)
            let queryTotal = null;
            if (typeof getQueryTotalForKeyword === 'function') {
              queryTotal = getQueryTotalForKeyword(task.keyword_text);
            }
            
            // Also try to get from latest audit's queryTotals if available
            if (!queryTotal && latestAuditFromSupabase && latestAuditFromSupabase.ranking_ai_data && latestAuditFromSupabase.ranking_ai_data.queryTotals) {
              queryTotal = latestAuditFromSupabase.ranking_ai_data.queryTotals.find(qt => 
                (qt.query || qt.keyword || '').toLowerCase() === taskKeyword.toLowerCase()
              );
            }
            
            currentMetrics = {
              gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
              gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
              gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d != null ? matchingRow.gsc_ctr_28d : (matchingRow.ctr_28d != null ? matchingRow.ctr_28d : null)),
              current_rank: matchingRow.best_rank_group || matchingRow.current_rank || matchingRow.rank || null,
              opportunity_score: matchingRow.opportunityScore || matchingRow.opportunity_score || null,
              ai_overview: matchingRow.has_ai_overview === true || matchingRow.ai_overview_present_any === true || false,
              ai_citations: matchingRow.ai_alan_citations_count != null ? matchingRow.ai_alan_citations_count : (matchingRow.ai_total_citations != null ? matchingRow.ai_total_citations : 0),
              ai_citations_total: matchingRow.ai_total_citations || null,
              classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
              page_type: matchingRow.pageType || matchingRow.page_type || null,
              segment: matchingRow.segment || null,
              captured_at: new Date().toISOString()
            };
            debugLog(`[Optimisation] Task ${task.id}: Keyword-specific metrics: clicks=${currentMetrics.gsc_clicks_28d}, impressions=${currentMetrics.gsc_impressions_28d}, rank=${currentMetrics.current_rank}, ai_citations=${currentMetrics.ai_citations}`, 'info');
          }
          
          // Fallback to baseline if no current data found
          if (!currentMetrics && task.baseline_metrics) {
            const taskUrl = task.target_url_clean || task.target_url || '';
            debugLog(`[Optimisation] Task ${task.id} (${task.keyword_text || taskUrl}): No current data found, using baseline metrics as fallback`, 'warn');
            // Log sample URLs from available data sources for debugging
            if (window.moneyPagesMetrics && window.moneyPagesMetrics.rows && window.moneyPagesMetrics.rows.length > 0) {
                  const sampleUrls = window.moneyPagesMetrics.rows.slice(0, 5).map(r => {
                const u = r.url || r.page_url || '';
                // Simple normalization (no normalizeUrlForDedupe)
                let normalized = u.toLowerCase()
                  .replace(/^https?:\/\//, '')
                  .replace(/^www\./, '')
                  .replace(/\/$/, '');
                return `${u} -> ${normalized}`;
              });
              debugLog(`[Optimisation] Task ${task.id}: Sample URLs from window.moneyPagesMetrics (original -> normalized): ${sampleUrls.join('; ')}`, 'warn');
            }
            try {
              const savedAudit = localStorage.getItem('last_audit_results');
              if (savedAudit) {
                const parsed = JSON.parse(savedAudit);
                const moneyPagesData = parsed.scores?.moneyPagesMetrics || parsed.moneyPagesMetrics;
                if (moneyPagesData && moneyPagesData.rows && moneyPagesData.rows.length > 0) {
                  // Check if the exact URL we're looking for exists
                  const exactMatch = moneyPagesData.rows.find(r => {
                    const u = r.url || r.page_url || '';
                    // Simple normalization (no normalizeUrlForDedupe)
                    let normalized = u.toLowerCase()
                      .replace(/^https?:\/\//, '')
                      .replace(/^www\./, '')
                      .replace(/\/$/, '');
                    return normalized === normalizedTaskUrl;
                  });
                  if (exactMatch) {
                    debugLog(`[Optimisation] Task ${task.id}: EXACT MATCH FOUND in localStorage but not used! URL: ${exactMatch.url || exactMatch.page_url}, clicks=${exactMatch.clicks || exactMatch.clicks_28d}, impressions=${exactMatch.impressions || exactMatch.impressions_28d}`, 'error');
                  }
                  const sampleUrls = moneyPagesData.rows.slice(0, 5).map(r => {
                    const u = r.url || r.page_url || '';
                    // Simple normalization (no normalizeUrlForDedupe)
                    let normalized = u.toLowerCase()
                      .replace(/^https?:\/\//, '')
                      .replace(/^www\./, '')
                      .replace(/\/$/, '');
                    return `${u} -> ${normalized}`;
                  });
                  debugLog(`[Optimisation] Task ${task.id}: Sample URLs from localStorage (original -> normalized): ${sampleUrls.join('; ')}`, 'warn');
                }
              }
            } catch (e) {
              // ignore
            }
            currentMetrics = { ...task.baseline_metrics, captured_at: new Date().toISOString() };
            // Remove null GSC metrics to avoid stale nulls
            if (currentMetrics.gsc_clicks_28d === null) delete currentMetrics.gsc_clicks_28d;
            if (currentMetrics.gsc_impressions_28d === null) delete currentMetrics.gsc_impressions_28d;
            if (currentMetrics.gsc_ctr_28d === null) delete currentMetrics.gsc_ctr_28d;
          }

          if (!currentMetrics) {
            failCount++;
            const errorMsg = `${task.keyword_text || taskUrl || 'Unknown task'}: No data found`;
            errors.push(errorMsg);
            debugLog(`[Optimisation] Task ${task.id} (${task.keyword_text || taskUrl || 'Unknown task'}): FAILED - ${errorMsg}`, 'error');
            return;
          }

            // Create measurement
            try {
              debugLog(`[Optimisation] Task ${task.id}: Creating measurement with metrics: ${JSON.stringify(currentMetrics)}`, 'info');
              const headers = window.getOptimisationHeaders();
              const response = await fetch(apiUrl(`/api/optimisation/task/${task.id}/measurement`), {
                method: 'POST',
                headers: { ...headers, 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  metrics: currentMetrics,
                  note: 'Bulk update - latest data snapshot'
                })
              });

              if (!response.ok) {
                const error = await response.json().catch(() => ({ error: 'Unknown error' }));
                throw new Error(error.error || 'Failed to create measurement');
              }

              const result = await response.json();
              if (result.skipped) {
                skippedCount++;
                debugLog(`[Optimisation] Task ${task.id} (${task.keyword_text || taskUrl || 'Unknown task'}) skipped: measurement too recent (within 5-minute window)`, 'info');
              } else {
                successCount++;
                debugLog(`[Optimisation] Task ${task.id} (${task.keyword_text || taskUrl || 'Unknown task'}) updated successfully: clicks=${currentMetrics.gsc_clicks_28d}, impressions=${currentMetrics.gsc_impressions_28d}, ctr=${currentMetrics.gsc_ctr_28d}, rank=${currentMetrics.current_rank}`, 'success');
              }
            } catch (error) {
              failCount++;
              // Safely extract error message without referencing potentially undefined variables
              const errorMsg = error?.message || String(error || 'Unknown error');
              const taskIdentifier = task.keyword_text || task.target_url_clean || task.target_url || 'unknown';
              errors.push(`${taskIdentifier}: ${errorMsg}`);
              debugLog(`[Optimisation] Error updating task ${task.id}: ${errorMsg}`, 'error');
            }
          }));
        }

        // Show results in modal first (so user sees progress)
        showBulkUpdateResultsModal(successCount, skippedCount, failCount, errors, activeTasks.length);
        
        // CRITICAL: Wait longer for backend to fully process and persist all updates
        // Even if tasks were skipped, we need fresh data from the backend
        debugLog('[Optimisation] Waiting for backend to process updates (3 seconds)...', 'info');
        await new Promise(resolve => setTimeout(resolve, 3000)); // Increased to 3 seconds
        
        // Store current task ID if drawer is open (before clearing state)
        const drawer = document.getElementById('optimisation-task-drawer');
        const isDrawerOpen = drawer && drawer.style.display !== 'none' && drawer.style.display !== '';
        const currentTaskId = (isDrawerOpen && window.optimisationModuleState && window.optimisationModuleState.currentTaskId) 
          ? window.optimisationModuleState.currentTaskId 
          : null;
        
        // Store timestamps of tasks before reload to verify they changed
        const beforeReloadTimestamps = new Map();
        if (window.optimisationModuleState && window.optimisationModuleState.allTasks) {
          window.optimisationModuleState.allTasks.forEach(task => {
            const timestamp = task.latest_metrics?.captured_at || task.latest_metrics?.created_at || null;
            if (timestamp) {
              beforeReloadTimestamps.set(task.id, timestamp);
            }
          });
        }
        
        // Reload tasks to show updated data (even if all were skipped, refresh to show current state)
        // This ensures the UI reflects the latest data from the backend
        debugLog('[Optimisation] Reloading tasks after bulk update (even if skipped)...', 'info');
        
        // Force clear any cached state before reloading
        if (window.optimisationModuleState) {
          // Clear tasks to force fresh fetch
          window.optimisationModuleState.allTasks = [];
          window.optimisationModuleState.filteredTasks = [];
          debugLog('[Optimisation] Cleared existing tasks state to force fresh fetch.', 'info');
        }
        
        // Reload with aggressive cache-busting - retry up to 3 times if data seems stale
        let fetchedTasks = null;
        let retryCount = 0;
        const maxRetries = 3;
        
        while (retryCount < maxRetries) {
          debugLog(`[Optimisation] Fetching fresh task data from API (attempt ${retryCount + 1}/${maxRetries})...`, 'info');
          fetchedTasks = await window.loadAllOptimisationTasks();
          
          // Verify data freshness: check if any task has a newer timestamp
          let hasNewData = false;
          if (fetchedTasks && fetchedTasks.length > 0) {
            for (const task of fetchedTasks) {
              const newTimestamp = task.latest_metrics?.captured_at || task.latest_metrics?.created_at || null;
              const oldTimestamp = beforeReloadTimestamps.get(task.id);
              
              if (newTimestamp && (!oldTimestamp || new Date(newTimestamp) > new Date(oldTimestamp))) {
                hasNewData = true;
                debugLog(`[Optimisation] Task ${task.id} has new data: ${oldTimestamp} -> ${newTimestamp}`, 'success');
                break;
              }
            }
          }
          
          // If we have new data or this is the first attempt (might be skipped tasks), proceed
          if (hasNewData || retryCount === 0 || !beforeReloadTimestamps.size) {
            debugLog(`[Optimisation] API returned ${fetchedTasks?.length || 0} tasks. Sample first task latest_metrics.captured_at: ${fetchedTasks?.[0]?.latest_metrics?.captured_at || 'N/A'}`, 'info');
            debugLog(`[Optimisation] State updated - allTasks count: ${window.optimisationModuleState.allTasks.length}, filteredTasks count: ${window.optimisationModuleState.filteredTasks.length}`, 'info');
            break;
          }
          
          // If no new data and we have retries left, wait and retry
          retryCount++;
          if (retryCount < maxRetries) {
            debugLog(`[Optimisation] No new data detected, waiting 2 seconds before retry...`, 'warn');
            await new Promise(resolve => setTimeout(resolve, 2000));
          } else {
            debugLog(`[Optimisation] No new data detected after ${maxRetries} attempts. Proceeding with current data.`, 'warn');
          }
        }

        // Force refresh of optimization tab UI components - call multiple times to ensure update
        debugLog('[Optimisation] Force refreshing all UI components...', 'info');
        if (typeof window.renderOptimisationTasksTable === 'function') {
          window.renderOptimisationTasksTable();
          // Call again after a brief delay to ensure it takes
          await new Promise(resolve => setTimeout(resolve, 100));
          window.renderOptimisationTasksTable();
        }
        if (typeof window.updateOptimisationSummaryCards === 'function') {
          window.updateOptimisationSummaryCards();
          await new Promise(resolve => setTimeout(resolve, 100));
          window.updateOptimisationSummaryCards();
        }
        if (typeof window.updateTrafficLights === 'function') {
          window.updateTrafficLights();
          await new Promise(resolve => setTimeout(resolve, 100));
          window.updateTrafficLights();
        }
        if (typeof window.updateKPITiles === 'function') {
          window.updateKPITiles();
        }
        if (typeof window.updateImpactTiles === 'function') {
          window.updateImpactTiles();
        }
        if (typeof window.updateTimeseriesCharts === 'function') {
          window.updateTimeseriesCharts();
        }

        // Refresh task drawer if it was open - force close and reopen to ensure fresh data
        if (currentTaskId && isDrawerOpen) {
          debugLog(`[Optimisation] Force refreshing task details drawer for task ${currentTaskId}...`, 'info');
          
          // Find the task in the reloaded data first to verify it exists
          const reloadedTask = window.optimisationModuleState.allTasks.find(t => t.id === currentTaskId);
          if (!reloadedTask) {
            debugLog(`[Optimisation] Task ${currentTaskId} not found in reloaded data - closing drawer`, 'warn');
            if (drawer) {
              drawer.style.display = 'none';
            }
            if (window.optimisationModuleState) {
              window.optimisationModuleState.currentTaskId = null;
            }
          } else {
            // Clear the drawer content to force a complete re-render
            const drawerContent = document.getElementById('optimisation-drawer-content');
            if (drawerContent) {
              drawerContent.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--dark-text-muted);">Refreshing task details...</div>';
            }
            
            // Clear currentTaskId to force openOptimisationTaskDrawer to re-render
            if (window.optimisationModuleState) {
              window.optimisationModuleState.currentTaskId = null;
            }
            
            // Wait a moment for state to clear
            await new Promise(resolve => setTimeout(resolve, 200));
            
            // Re-open the drawer with the same task - this will fetch fresh data
            if (typeof window.openOptimisationTaskDrawer === 'function') {
              debugLog(`[Optimisation] Re-opening drawer for task ${currentTaskId} with fresh data`, 'info');
              await window.openOptimisationTaskDrawer(currentTaskId);
            } else {
              debugLog(`[Optimisation] openOptimisationTaskDrawer function not found.`, 'warn');
            }
          }
        }

        // Dashboard: refresh live dials/cards after bulk update completes
        if (typeof window.renderDashboardTab === 'function') {
          try { 
            window.renderDashboardTab();
            // Call again after delay
            await new Promise(resolve => setTimeout(resolve, 200));
            window.renderDashboardTab();
          } catch (e) {
            debugLog(`[Optimisation] Error refreshing dashboard: ${e.message || e}`, 'warn');
          }
        }
        
        debugLog('[Optimisation] UI refresh complete - check if data updated', 'info');

      } catch (error) {
        debugLog(`[Optimisation] Bulk update error: ${error.message || error}`, 'error');
        showBulkUpdateResultsModal(0, 0, activeTasks.length, [`Bulk update failed: ${error.message}`], activeTasks.length);
      } finally {
        if (bulkUpdateBtn) {
          bulkUpdateBtn.disabled = false;
          bulkUpdateBtn.textContent = originalText;
        }
      }
    };

    // Show bulk update results modal
    function showBulkUpdateResultsModal(successCount, skippedCount, failCount, errors, totalTasks) {
      const modal = document.getElementById('optimisation-bulk-update-results-modal');
      const content = document.getElementById('bulk-update-results-content');
      
      if (!modal || !content) {
        // Fallback to alert if modal not found
        let message = `Updated ${successCount} task(s) successfully.`;
        if (skippedCount > 0) {
          message += ` Skipped ${skippedCount} (recent measurement within 5 minutes).`;
        }
        if (failCount > 0) {
          message += `\n\nFailed to update ${failCount} task(s):\n${errors.slice(0, 5).join('\n')}`;
          if (errors.length > 5) {
            message += `\n... and ${errors.length - 5} more.`;
          }
        }
        alert(message);
        return;
      }

      // Build summary HTML
      let html = '<div style="margin-bottom: 1.5rem;">';
      
      // Summary stats
      html += '<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 1.5rem;">';
      html += `<div style="padding: 1rem; background: #f0fdf4; border-left: 4px solid #10b981; border-radius: 4px;">
        <div style="font-size: 2rem; font-weight: 700; color: #10b981;">${successCount}</div>
        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">Successfully Updated</div>
      </div>`;
      html += `<div style="padding: 1rem; background: #fef3c7; border-left: 4px solid #f59e0b; border-radius: 4px;">
        <div style="font-size: 2rem; font-weight: 700; color: #f59e0b;">${skippedCount}</div>
        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">Skipped</div>
      </div>`;
      html += `<div style="padding: 1rem; background: #fee2e2; border-left: 4px solid #ef4444; border-radius: 4px;">
        <div style="font-size: 2rem; font-weight: 700; color: #ef4444;">${failCount}</div>
        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">Failed</div>
      </div>`;
      html += `<div style="padding: 1rem; background: #f3f4f6; border-left: 4px solid #6b7280; border-radius: 4px;">
        <div style="font-size: 2rem; font-weight: 700; color: #6b7280;">${totalTasks}</div>
        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">Total Tasks</div>
      </div>`;
      html += '</div>';

      // Skipped tasks explanation
      if (skippedCount > 0) {
        html += '<div style="padding: 1rem; background: #fef3c7; border-left: 4px solid #f59e0b; border-radius: 4px; margin-bottom: 1rem;">';
        html += '<div style="font-weight: 600; color: #92400e; margin-bottom: 0.5rem;">Why were tasks skipped?</div>';
        html += '<div style="font-size: 0.875rem; color: #78350f;">Tasks were skipped because they already have a recent measurement (within the last 5 minutes). This prevents duplicate measurements if you click the update button multiple times.</div>';
        html += '</div>';
      }

      // Failed tasks details
      if (failCount > 0 && errors.length > 0) {
        html += '<div style="padding: 1rem; background: #fee2e2; border-left: 4px solid #ef4444; border-radius: 4px; margin-bottom: 1rem;">';
        html += '<div style="font-weight: 600; color: #991b1b; margin-bottom: 0.75rem;">Failed Tasks:</div>';
        html += '<div style="max-height: 300px; overflow-y: auto; font-size: 0.875rem;">';
        html += '<ul style="margin: 0; padding-left: 1.5rem; color: #7f1d1d;">';
        errors.forEach(error => {
          html += `<li style="margin-bottom: 0.5rem;">${escapeHtml(error)}</li>`;
        });
        html += '</ul>';
        html += '</div>';
        html += '<div style="margin-top: 0.75rem; font-size: 0.875rem; color: #7f1d1d;">';
        html += '<strong>Common reasons for failures:</strong><ul style="margin-top: 0.5rem; padding-left: 1.5rem;">';
        html += '<li>No matching data found in Ranking & AI results</li>';
        html += '<li>Task keyword or URL doesn\'t match any ranking data</li>';
        html += '<li>Network or server error during update</li>';
        html += '<li>Task is missing required fields</li>';
        html += '</ul>';
        html += '</div>';
        html += '</div>';
      }

      // Success message
      if (successCount > 0) {
        html += '<div style="padding: 1rem; background: #f0fdf4; border-left: 4px solid #10b981; border-radius: 4px;">';
        html += '<div style="font-weight: 600; color: #065f46; margin-bottom: 0.5rem;"> Update Complete</div>';
        html += '<div style="font-size: 0.875rem; color: #047857;">Successfully updated measurements for ' + successCount + ' task(s). The table has been refreshed to show the latest data.</div>';
        html += '</div>';
      }

      html += '</div>';

      content.innerHTML = html;
      modal.style.display = 'flex';
    }

    // Close bulk update results modal
    window.closeBulkUpdateResultsModal = function closeBulkUpdateResultsModal() {
      const modal = document.getElementById('optimisation-bulk-update-results-modal');
      if (modal) {
        modal.style.display = 'none';
      }
    };

    // Bulk rebaseline all tasks with incomplete baselines
    window.bulkRebaselineIncompleteBaselines = async function bulkRebaselineIncompleteBaselines() {
      if (!window.optimisationModuleState || !window.optimisationModuleState.allTasks) {
        alert('No tasks loaded. Please wait for tasks to load first.');
        return;
      }

      const criticalFields = ['ai_overview', 'ai_citations', 'current_rank'];
      let tasks = window.optimisationModuleState.allTasks.filter(
        t => !['done', 'cancelled', 'deleted'].includes(t.status)
      );

      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }

      // Find tasks with incomplete baselines
      const incompleteTasks = tasks.filter(task => {
        if (!task.baseline_metrics) return true; // No baseline = incomplete
        const missingFields = criticalFields.filter(field => {
          const val = task.baseline_metrics[field];
          return val == null || val === '';
        });
        return missingFields.length > 0;
      });

      if (incompleteTasks.length === 0) {
        alert('No tasks with incomplete baselines found. All baselines are complete!');
        return;
      }

      const confirmMsg = `Found ${incompleteTasks.length} task(s) with incomplete baselines.\n\n` +
        `This will create a new baseline measurement for each task with all fields properly captured.\n\n` +
        `Continue?`;
      if (!confirm(confirmMsg)) {
        return;
      }

      const bulkRebaselineBtn = document.getElementById('optimisation-bulk-rebaseline-btn');
      const originalText = bulkRebaselineBtn ? bulkRebaselineBtn.textContent : '';
      if (bulkRebaselineBtn) {
        bulkRebaselineBtn.disabled = true;
        bulkRebaselineBtn.textContent = 'Rebaselining...';
      }

      let successCount = 0;
      let failCount = 0;
      const errors = [];

      try {
        // Use shared helper functions to ensure consistency
        const { latestAudit, combinedRows } = await window.fetchLatestAuditAndCombinedRows();

        // Process sequentially to avoid rate limits (max 2 concurrent)
        const maxConcurrent = 2;
        for (let i = 0; i < incompleteTasks.length; i += maxConcurrent) {
          const batch = incompleteTasks.slice(i, i + maxConcurrent);
          
          await Promise.all(batch.map(async (task) => {
            const taskNum = i + batch.indexOf(task) + 1;
            if (bulkRebaselineBtn) {
              bulkRebaselineBtn.textContent = `Rebaselining ${taskNum}/${incompleteTasks.length}...`;
            }

            try {
              const taskUrlForPage = task.target_url_clean || task.target_url || '';
              const hasKeyword = !!(task.keyword_text && String(task.keyword_text).trim());

              // Use shared helper functions based on task type
              let currentMetrics = null;
              if (hasKeyword) {
                // Keyword-based task: Use keyword-specific data
                currentMetrics = await window.fetchMetricsForKeywordTask(task, latestAudit, combinedRows);
              } else if (taskUrlForPage) {
                // URL-only task: Use GSC page totals API + Ranking & AI data
                currentMetrics = await window.fetchMetricsForUrlTask(task, latestAudit, combinedRows);
              }

              if (!currentMetrics) {
                throw new Error('Could not fetch metrics for rebaseline');
              }

              // Create baseline measurement
              const headers = window.getOptimisationHeaders();
              const response = await fetch(apiUrl(`/api/optimisation/task/${task.id}/measurement`), {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                  metrics: currentMetrics,
                  note: 'Bulk rebaseline - complete baseline with all fields',
                  is_baseline: true
                })
              });

              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(errorText || 'Failed to rebaseline');
              }

              successCount++;
              debugLog(`[Optimisation] Bulk Rebaseline: Successfully rebaselined task ${task.id}`, 'success');
            } catch (error) {
              failCount++;
              const errorMsg = `Task "${task.title || task.id}": ${error.message}`;
              errors.push(errorMsg);
              debugLog(`[Optimisation] Bulk Rebaseline: ${errorMsg}`, 'error');
            }
          }));
        }

        // Reload tasks to refresh counts
        await window.loadAllOptimisationTasks();
        
        // Update summary cards
        updateOptimisationSummaryCards();

        const resultMsg = `Rebaseline complete!\n\n` +
          `Success: ${successCount}\n` +
          `Failed: ${failCount}` +
          (errors.length > 0 ? `\n\nErrors:\n${errors.slice(0, 5).join('\n')}${errors.length > 5 ? `\n... and ${errors.length - 5} more` : ''}` : '');
        alert(resultMsg);
      } catch (error) {
        debugLog(`[Optimisation] Bulk Rebaseline: Fatal error: ${error.message}`, 'error');
        alert('Bulk rebaseline failed: ' + error.message);
      } finally {
        if (bulkRebaselineBtn) {
          bulkRebaselineBtn.disabled = false;
          bulkRebaselineBtn.textContent = originalText;
        }
      }
    };

    // Update latest metrics for a single task
    window.updateTaskLatest = async function updateTaskLatest(taskId) {
      const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      if (!task) {
        alert('Task not found. Please refresh the page.');
        return;
      }

      const taskUrlForPage = task.target_url_clean || task.target_url || '';
      const hasKeyword = !!(task.keyword_text && String(task.keyword_text).trim());

      // Use shared helper functions to ensure consistency
      const { latestAudit, combinedRows } = await window.fetchLatestAuditAndCombinedRows();
      
      let currentMetrics = null;
      
      // Use shared helper functions based on task type
      if (hasKeyword) {
        // Keyword-based task: Use keyword-specific data
        currentMetrics = await window.fetchMetricsForKeywordTask(task, latestAudit, combinedRows);
      } else if (taskUrlForPage) {
        // URL-only task: Use GSC page totals API + Ranking & AI data
        currentMetrics = await window.fetchMetricsForUrlTask(task, latestAudit, combinedRows);
      }

      // Legacy code below - keeping for now but should be removed
      // For URL-only tasks (e.g. Money Pages), prefer an exact GSC page totals fetch
      if (!currentMetrics && !hasKeyword && taskUrlForPage) {
        try {
          const property = document.getElementById('propertyUrl')?.value ||
            localStorage.getItem('gsc_property_url') ||
            localStorage.getItem('last_property_url') || '';
          if (property) {
            const range = (typeof getGscDateRange === 'function') ? getGscDateRange(28, 2) : null;
            const startDate = range?.startDate ? `&startDate=${encodeURIComponent(range.startDate)}` : '';
            const endDate = range?.endDate ? `&endDate=${encodeURIComponent(range.endDate)}` : '';
            const pageUrlForGsc = toAbsoluteUrlForGsc(taskUrlForPage, property);
            const totalsUrl = apiUrl(`/api/aigeo/gsc-page-totals?property=${encodeURIComponent(property)}&pageUrl=${encodeURIComponent(pageUrlForGsc)}${startDate}${endDate}`);
            const totalsRes = await fetch(totalsUrl);
            const totalsJson = await totalsRes.json().catch(() => null);
            const totals = totalsRes.ok && totalsJson && totalsJson.status === 'ok' ? totalsJson.data : null;
            if (totals) {
              // Get combinedRows from multiple sources (prioritize fresh data from Supabase)
              let aiRows = [];
              if (typeof window.getRankingAiCombinedRows === 'function') {
                aiRows = window.getRankingAiCombinedRows();
              }
              if (aiRows.length === 0 && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
                aiRows = window.rankingAiData;
              }
              if (aiRows.length === 0) {
                try {
                  const local = localStorage.getItem('rankingAiData');
                  if (local) {
                    const parsed = JSON.parse(local);
                    if (parsed && Array.isArray(parsed.combinedRows)) {
                      aiRows = parsed.combinedRows;
                    }
                  }
                } catch (e) {
                  // ignore
                }
              }
              
              // If still no data, try latest audit from Supabase
              if (aiRows.length === 0 && latestAuditFromSupabase && latestAuditFromSupabase.ranking_ai_data) {
                const rankingAiData = latestAuditFromSupabase.ranking_ai_data;
                if (rankingAiData.combinedRows && Array.isArray(rankingAiData.combinedRows)) {
                  aiRows = rankingAiData.combinedRows;
                }
              }
              
              // Get AI metrics for URL
              let aiForUrl = { ai_overview: null, ai_citations: null };
              if (aiRows.length > 0) {
                const hasCitationsArrays = aiRows.some(r => 
                  Array.isArray(r.ai_alan_citations) && r.ai_alan_citations.length > 0
                );
                
                if (hasCitationsArrays) {
                  const urlsToTry = [pageUrlForGsc, taskUrlForPage];
                  for (const urlToCheck of urlsToTry) {
                    if (urlToCheck) {
                      const result = (typeof window.computeAiMetricsForPageUrl === 'function')
                        ? window.computeAiMetricsForPageUrl(urlToCheck, aiRows)
                        : { ai_overview: null, ai_citations: null };
                      if (result.ai_overview !== null && result.ai_citations !== null) {
                        aiForUrl = result;
                        break;
                      }
                    }
                  }
                }
                
                // Fallback to Supabase API if local lookup failed
                if (aiForUrl.ai_overview === null && aiForUrl.ai_citations === null) {
                  try {
                    const propertyUrl = document.getElementById('propertyUrl')?.value || 
                                      localStorage.getItem('gsc_property_url') || 
                                      'https://www.alanranger.com';
                    const queryUrl = apiUrl(`/api/supabase/query-keywords-citing-url?` +
                      `property_url=${encodeURIComponent(propertyUrl)}&` +
                      `target_url=${encodeURIComponent(pageUrlForGsc || taskUrlForPage)}`
                    );
                    const citationResponse = await fetch(queryUrl);
                    if (citationResponse.ok) {
                      const citationData = await citationResponse.json();
                      if (citationData.status === 'ok' && citationData.data && citationData.data.length > 0) {
                        const citingKeywords = citationData.data;
                        const totalCitationCount = typeof citationData.count === 'number' ? citationData.count : citingKeywords.reduce((sum, k) => sum + (k.citation_count || 1), 0);
                        const hasOverview = citingKeywords.some(k => k.has_ai_overview === true);
                        aiForUrl = {
                          ai_overview: hasOverview,
                          ai_citations: totalCitationCount
                        };
                      }
                    }
                  } catch (supabaseErr) {
                    debugLog(`[Optimisation] Update Task Latest: Error querying Supabase for citations: ${supabaseErr.message}`, 'warn');
                  }
                }
              }
              
              currentMetrics = {
                gsc_clicks_28d: totals.clicks || null,
                gsc_impressions_28d: totals.impressions || null,
                gsc_ctr_28d: totals.ctr != null ? totals.ctr : null, // totals.ctr is already a ratio (0-1) from fetchMetricsForUrlTask
                current_rank: totals.position || null,
                ai_overview: aiForUrl.ai_overview,
                ai_citations: aiForUrl.ai_citations || 0,
                captured_at: new Date().toISOString()
              };
            }
          }
        } catch (urlTaskErr) {
          debugLog(`[Optimisation] Update Task Latest: Error handling URL task: ${urlTaskErr.message}`, 'error');
        }
      }

      // Legacy code below - keeping for now but should be removed
      // For keyword tasks, find matching row from combinedRows
      if (!currentMetrics && hasKeyword) {
        // Find matching row
        const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
        const taskUrlPath = taskUrlClean.includes('/') ? taskUrlClean.split('/').slice(1).join('/') : '';
        
        matchingRow = combinedRows.find(r => {
        const keywordMatch = (r.keyword || '').toLowerCase() === (task.keyword_text || '').toLowerCase();
        if (!keywordMatch) return false;
        
        // FIX 1: For keyword-based tasks, URL matching is optional
        // If task has no URL, keyword match is sufficient
        if (!taskUrlClean || taskUrlClean.length === 0) {
          return true; // Keyword match only - no URL required
        }
        
        // If task has URL, try to match it (preferred but not required for keyword tasks)
        const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
        const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
        const rowUrlPath = rowUrlClean.includes('/') ? rowUrlClean.split('/').slice(1).join('/') : '';
        
        const urlMatch = rowUrl === taskUrlClean || 
                        rowUrlClean === taskUrlClean ||
                        rowUrlPath === taskUrlPath ||
                        rowUrl.includes(taskUrlClean) ||
                        taskUrlClean.includes(rowUrlClean);
        
        // For keyword-based tasks: accept if URL matches OR if keyword matches (URL is optional)
        // This ensures keyword tasks can find ranking/AI data even if URLs differ slightly
        return urlMatch || true; // Always accept keyword match for keyword tasks
        });
        
        debugLog(`[Optimisation] Update Task Latest: Found matching row: ${matchingRow ? 'YES' : 'NO'} (taskKeyword: ${task.keyword_text}, rowsSearched: ${combinedRows?.length || 0})`, matchingRow ? 'info' : 'warn');
        
        if (matchingRow) {
        // Get queryTotal data for clicks, impressions, and CTR
        let queryTotal = null;
        if (typeof getQueryTotalForKeyword === 'function') {
          queryTotal = getQueryTotalForKeyword(task.keyword_text);
        }
        
        currentMetrics = {
          gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
          gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
          gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
          current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
          opportunity_score: matchingRow.opportunityScore || null,
          ai_overview: matchingRow.has_ai_overview || false,
          ai_citations: matchingRow.ai_alan_citations_count || 0,
          ai_citations_total: matchingRow.ai_total_citations || 0,
          classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
          page_type: matchingRow.pageType || null,
          segment: matchingRow.segment || null,
          captured_at: new Date().toISOString()
        };
        }
      }

      // Final fallback to baseline if no current data found
      if (!currentMetrics && task.baseline_metrics) {
        // Fallback to baseline if no current data found
        currentMetrics = { ...task.baseline_metrics, captured_at: new Date().toISOString() };
        if (currentMetrics.gsc_clicks_28d === null) delete currentMetrics.gsc_clicks_28d;
        if (currentMetrics.gsc_impressions_28d === null) delete currentMetrics.gsc_impressions_28d;
        if (currentMetrics.gsc_ctr_28d === null) delete currentMetrics.gsc_ctr_28d;
      }

      if (!currentMetrics) {
        alert('No ranking data available for this task. Please run a Ranking & AI check first.');
        return;
      }

      // Find the Update button to show loading state
      const updateBtn = event?.target;
      const originalText = updateBtn?.textContent || 'Update';
      if (updateBtn) {
        updateBtn.disabled = true;
        updateBtn.textContent = 'Updating...';
      }

      try {
        const headers = window.getOptimisationHeaders();
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/measurement`), {
          method: 'POST',
          headers: { ...headers, 'Content-Type': 'application/json' },
          body: JSON.stringify({
            metrics: currentMetrics,
            note: 'Latest measurement captured'
          })
        });

        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: 'Unknown error' }));
          throw new Error(error.error || 'Failed to create measurement');
        }

        const result = await response.json();
        
        // Reload tasks to show updated data
        await window.loadAllOptimisationTasks();
        
        // Show success message
        if (result.skipped) {
          if (typeof debugLog === 'function') {
            debugLog(`[Optimisation] Update Task Latest: Measurement skipped (recent): ${task.keyword_text || taskUrlForPage}`, 'info');
          }
          // Show brief feedback
          if (updateBtn) {
            updateBtn.textContent = 'Skipped';
            setTimeout(() => {
              if (updateBtn) {
                updateBtn.disabled = false;
                updateBtn.textContent = originalText;
              }
            }, 2000);
          }
        } else {
          if (typeof debugLog === 'function') {
            debugLog(`[Optimisation] Update Task Latest: Measurement updated: ${task.keyword_text || taskUrlForPage}`, 'success');
          }
          // Show brief success feedback
          if (updateBtn) {
            updateBtn.textContent = '';
            setTimeout(() => {
              if (updateBtn) {
                updateBtn.disabled = false;
                updateBtn.textContent = originalText;
              }
            }, 2000);
          }
        }
      } catch (error) {
        console.error(`[Optimisation] Update Task Latest: Error updating task ${taskId}:`, error);
        alert(`Failed to update task: ${error.message}`);
        if (updateBtn) {
          updateBtn.disabled = false;
          updateBtn.textContent = originalText;
        }
      }
    };

    // Add to ensurePanelRendered
    const originalEnsurePanelRendered = ensurePanelRendered;
    ensurePanelRendered = function(panelId) {
      originalEnsurePanelRendered(panelId);
      
      if (panelId === 'optimisation') {
        if (!window.optimisationModuleInitialized) {
          initOptimisationTrackingModule();
          window.optimisationModuleInitialized = true;
        }
        window.loadAllOptimisationTasks();
      }
      
      if (panelId === 'portfolio') {
        setTimeout(() => {
          wirePortfolioControls();
          if (typeof window.renderPortfolioTab === 'function') {
            window.renderPortfolioTab();
          }
        }, 100);
      }
    };

    // ======================
    // GSC Date Range Configuration
    // ======================
    // Centralized constant for GSC window (matches GSC UI default)
    const GSC_WINDOW_DAYS = 28;
    
    /**
     * Get GSC date range helper (matches backend utils.js getGscDateRange)
     * @param {number} daysBack - Number of days to look back (default: GSC_WINDOW_DAYS)
     * @param {number} endOffsetDays - Days to subtract from today for end date (default: 1 = yesterday)
     * @returns {Object} { startDate, endDate } as ISO strings (YYYY-MM-DD)
     */
    function getGscDateRange(daysBack = GSC_WINDOW_DAYS, endOffsetDays = 2) {
      // End date = 2 days ago (GSC data is typically 2-3 days behind today)
      const end = new Date();
      end.setDate(end.getDate() - endOffsetDays);
      end.setHours(0, 0, 0, 0);
      
      // Start date = end date - (daysBack - 1) days (inclusive range)
      const start = new Date(end);
      start.setDate(start.getDate() - (daysBack - 1));
      start.setHours(0, 0, 0, 0);
      
      // Format as YYYY-MM-DD
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      return {
        startDate: formatDate(start),
        endDate: formatDate(end)
      };
    }

    /**
     * GSC "page" dimension expects a FULL absolute URL (including https://).
     * Our UI often stores/displays URLs without a scheme (e.g. "www.example.com/path"),
     * so normalize before calling any GSC-backed endpoints.
     */
    function toAbsoluteUrlForGsc(inputUrl, propertyUrl = '') {
      const raw = String(inputUrl || '').trim();
      if (!raw) return '';
      if (/^https?:\/\//i.test(raw)) return raw;
      if (/^\/\//.test(raw)) return `https:${raw}`;

      // If it's a path, join to property origin.
      if (raw.startsWith('/')) {
        try {
          const base = String(propertyUrl || '').trim();
          const baseAbs = /^https?:\/\//i.test(base) ? base : (base ? `https://${base}` : 'https://www.alanranger.com');
          const u = new URL(baseAbs);
          return `${u.origin}${raw}`;
        } catch (e) {
          return `https://www.alanranger.com${raw}`;
        }
      }

      // Otherwise assume it's host[/path] and prepend https://
      return `https://${raw}`;
    }
    
    function safeSetLocalStorage(key, value) {
      try {
        const valueString = typeof value === 'string' ? value : JSON.stringify(value);
        // Check size before saving (localStorage limit is typically 5-10MB)
        if (valueString.length > 4 * 1024 * 1024) {
          debugLog(` Data too large for localStorage (${Math.round(valueString.length / 1024)}KB), skipping save. Supabase is source of truth.`, 'warn');
          return false;
        }
        localStorage.setItem(key, valueString);
        return true;
      } catch (error) {
        if (error.name === 'QuotaExceededError' || error.message.includes('quota')) {
          debugLog(` localStorage quota exceeded for ${key}, skipping save. Supabase is source of truth.`, 'warn');
          return false;
        } else {
          debugLog(` Error saving to localStorage (${key}): ${error.message}`, 'error');
          return false;
        }
      }
    }
    
    // ======================
    // CRITICAL: Define buildMoneyPageMetrics at GLOBAL SCOPE first
    // This ensures it's available when displayDashboard runs
    // ======================
    console.log('[Money Pages] Defining buildMoneyPageMetrics at global scope...');
    
    // Define helper functions that buildMoneyPageMetrics depends on (if not already defined)
    // These will be defined later in the script, but we need to ensure buildMoneyPageMetrics
    // can be called even if these helpers aren't ready yet
    
    // Placeholder - will be replaced by actual function when script loads
    // This is a fallback used only if no external Money Pages module is wired.
    // It returns empty metrics so the UI can show "No data" rather than crash.
    // Diagnostic function to check keyword matching issues AND missing search volume
    window.diagnoseKeywordMatching = function() {
      try {
        const savedAudit = loadAuditResultsSync();
        if (!savedAudit || !savedAudit.searchData) {
          debugLog(' No audit data found. Cannot diagnose keyword matching.', 'warn');
          return;
        }
        
        // Get keywords from ranking data
        let rankingData = [];
        if (window.RankingAiModule && typeof window.RankingAiModule.state === 'function') {
          const state = window.RankingAiModule.state();
          rankingData = state.combinedRows || [];
        }
        
        if (!rankingData || rankingData.length === 0) {
          debugLog(' No ranking keywords found. Cannot diagnose.', 'warn');
          return;
        }
        
        const allKeywords = rankingData.map(r => r.keyword).filter(k => k && k.trim());
        const queryTotals = savedAudit.searchData.queryTotals || [];
        
        debugLog(` Diagnostic: Checking ${allKeywords.length} keywords`, 'info');
        
        // CRITICAL: Check for missing search_volume (this is what the UI shows as "")
        const missingSearchVolume = [];
        const hasSearchVolume = [];
        
        rankingData.forEach(row => {
          const searchVolume = row.search_volume;
          // IMPORTANT: Only treat as missing if null/undefined, not if 0 (0 is a valid value)
          if (searchVolume == null || searchVolume === undefined) {
            missingSearchVolume.push({ keyword: row.keyword, search_volume: searchVolume });
          } else {
            hasSearchVolume.push({ keyword: row.keyword, search_volume: searchVolume });
          }
        });
        
        debugLog(` Search Volume Analysis:`, 'info');
        debugLog(`   Has search volume: ${hasSearchVolume.length} keywords`, 'success');
        debugLog(`   Missing search volume: ${missingSearchVolume.length} keywords`, missingSearchVolume.length > 0 ? 'warn' : 'success');
        if (missingSearchVolume.length > 0) {
          const missingList = missingSearchVolume.slice(0, 20).map(m => m.keyword).join(', ');
          debugLog(`  Missing search volume keywords: ${missingList}${missingSearchVolume.length > 20 ? ` ... (${missingSearchVolume.length - 20} more)` : ''}`, 'warn');
        }
        
        // Also check queryTotals matching (for impressions/CTR)
        const missingQueryTotals = [];
        const matchedQueryTotals = [];
        const zeroImpressionKeywords = [];
        
        allKeywords.forEach(keyword => {
          const normalizedKeyword = normalizeKeywordForMatching(keyword);
          const queryTotal = queryTotals.find(
            qt => {
              if (!qt.query) return false;
              const normalizedQuery = normalizeKeywordForMatching(qt.query);
              return normalizedQuery === normalizedKeyword || 
                     normalizedQuery.includes(normalizedKeyword) || 
                     normalizedKeyword.includes(normalizedQuery);
            }
          );
          
          if (!queryTotal) {
            missingQueryTotals.push(keyword);
          } else {
            matchedQueryTotals.push(keyword);
            if (queryTotal.impressions === 0 || queryTotal.impressions == null) {
              zeroImpressionKeywords.push({ keyword, query: queryTotal.query, impressions: queryTotal.impressions });
            }
          }
        });
        
        debugLog(` QueryTotals Analysis (for impressions/CTR):`, 'info');
        debugLog(`   Matched: ${matchedQueryTotals.length} keywords`, 'success');
        debugLog(`   Missing: ${missingQueryTotals.length} keywords`, missingQueryTotals.length > 0 ? 'warn' : 'info');
        if (missingQueryTotals.length > 0) {
          debugLog(`  Missing queryTotals: ${missingQueryTotals.slice(0, 20).join(', ')}${missingQueryTotals.length > 20 ? ` ... (${missingQueryTotals.length - 20} more)` : ''}`, 'warn');
        }
        
        debugLog(` Zero impressions: ${zeroImpressionKeywords.length} keywords`, zeroImpressionKeywords.length > 0 ? 'info' : 'success');
        if (zeroImpressionKeywords.length > 0) {
          const sample = zeroImpressionKeywords.slice(0, 10).map(z => `${z.keyword} (query: "${z.query}", impressions: ${z.impressions})`).join(', ');
          debugLog(`Sample zero-impression keywords: ${sample}${zeroImpressionKeywords.length > 10 ? '...' : ''}`, 'info');
        }
        
        // Check for queries in queryTotals that don't match any keywords (orphaned queries)
        const orphanedQueries = queryTotals.filter(qt => {
          const normalizedQuery = normalizeKeywordForMatching(qt.query || '');
          return !allKeywords.some(k => {
            const normalizedKeyword = normalizeKeywordForMatching(k);
            return normalizedQuery === normalizedKeyword || 
                   normalizedQuery.includes(normalizedKeyword) || 
                   normalizedKeyword.includes(normalizedQuery);
          });
        });
        
        if (orphanedQueries.length > 0) {
          debugLog(` Found ${orphanedQueries.length} orphaned queries in queryTotals (don't match any keywords)`, 'warn');
          const sample = orphanedQueries.slice(0, 10).map(qt => qt.query || '(no query)').join(', ');
          debugLog(`Sample orphaned queries: ${sample}${orphanedQueries.length > 10 ? '...' : ''}`, 'warn');
        }
        
        return {
          totalKeywords: allKeywords.length,
          totalQueryTotals: queryTotals.length,
          // Search volume analysis (what UI shows as "")
          missingSearchVolume: missingSearchVolume.length,
          missingSearchVolumeKeywords: missingSearchVolume,
          hasSearchVolume: hasSearchVolume.length,
          // QueryTotals analysis (for impressions/CTR)
          matched: matchedQueryTotals.length,
          missing: missingQueryTotals.length,
          missingKeywords: missingQueryTotals,
          zeroImpression: zeroImpressionKeywords.length,
          zeroImpressionKeywords: zeroImpressionKeywords,
          orphaned: orphanedQueries.length,
          orphanedQueries: orphanedQueries
        };
      } catch (error) {
        debugLog(` Error diagnosing keyword matching: ${error.message}`, 'error');
        return null;
      }
    };
    
    // Function to check Supabase database for missing search volume
    window.checkSupabaseSearchVolume = async function() {
      try {
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (!propertyUrl) {
          debugLog(' No property URL found. Cannot query Supabase.', 'warn');
          return;
        }
        
        debugLog(` Querying Supabase for missing search volume...`, 'info');
        
        const response = await fetch(apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`));
        if (!response.ok) {
          const errorText = await response.text();
          debugLog(` Failed to fetch from Supabase: ${response.status} - ${errorText}`, 'warn');
          return;
        }
        
        const data = await response.json();
        if (data.status !== 'ok' || !data.data || !data.data.rankingAiData || !data.data.rankingAiData.combinedRows) {
          debugLog(' No ranking data found in Supabase response', 'warn');
          return;
        }
        
        const keywords = data.data.rankingAiData.combinedRows || [];
        const missingSearchVolume = keywords.filter(k => k.search_volume == null || k.search_volume === undefined);
        const hasSearchVolume = keywords.filter(k => k.search_volume != null && k.search_volume !== undefined);
        
        debugLog(` Supabase Search Volume Analysis:`, 'info');
        debugLog(`  Total keywords in DB: ${keywords.length}`, 'info');
        debugLog(`   Has search volume: ${hasSearchVolume.length} keywords`, 'success');
        debugLog(`   Missing search volume: ${missingSearchVolume.length} keywords`, missingSearchVolume.length > 0 ? 'warn' : 'success');
        
        if (missingSearchVolume.length > 0) {
          const missingList = missingSearchVolume.slice(0, 30).map(k => k.keyword).join(', ');
          debugLog(`  Missing search volume keywords: ${missingList}${missingSearchVolume.length > 30 ? ` ... (${missingSearchVolume.length - 30} more)` : ''}`, 'warn');
        }
        
        return {
          total: keywords.length,
          hasSearchVolume: hasSearchVolume.length,
          missingSearchVolume: missingSearchVolume.length,
          missingKeywords: missingSearchVolume.map(k => k.keyword)
        };
      } catch (error) {
        debugLog(` Error checking Supabase: ${error.message}`, 'error');
        return null;
      }
    };
    
    // Manual function to fetch and save queryTotals (for debugging/fixing missing data)
    window.fetchQueryTotalsManually = async function() {
      try {
        const savedAudit = loadAuditResultsSync();
        if (!savedAudit || !savedAudit.searchData) {
          debugLog(' No audit data found in localStorage. Please run a full audit first.', 'warn');
          return;
        }
        
        // Get keywords from ranking data
        let rankingData = [];
        
        // Try to get from RankingAiModule state first
        if (window.RankingAiModule && typeof window.RankingAiModule.state === 'function') {
          const state = window.RankingAiModule.state();
          rankingData = state.combinedRows || [];
          debugLog(` Found ${rankingData.length} keywords from RankingAiModule state`, 'info');
        }
        
        // Fallback: try to get from localStorage
        if (!rankingData || rankingData.length === 0) {
          try {
            const storedData = localStorage.getItem('ranking_ai_data');
            if (storedData) {
              const parsed = JSON.parse(storedData);
              if (parsed && parsed.combinedRows && Array.isArray(parsed.combinedRows)) {
                rankingData = parsed.combinedRows;
                debugLog(` Found ${rankingData.length} keywords from localStorage`, 'info');
              }
            }
          } catch (e) {
            debugLog(` Failed to parse ranking data from localStorage: ${e.message}`, 'warn');
          }
        }
        
        // Fallback: try to get from saved audit's keyword_rankings
        if (!rankingData || rankingData.length === 0) {
          if (savedAudit.keywordRankings && Array.isArray(savedAudit.keywordRankings)) {
            rankingData = savedAudit.keywordRankings;
            debugLog(` Found ${rankingData.length} keywords from saved audit`, 'info');
          }
        }
        
        if (!rankingData || rankingData.length === 0) {
          debugLog(' No ranking keywords found. Please run the ranking scan first.', 'warn');
          return;
        }
        
        const allKeywords = rankingData.map(r => r.keyword).filter(k => k && k.trim());
        if (allKeywords.length === 0) {
          debugLog(' No valid keywords found in ranking data.', 'warn');
          return;
        }
        
        debugLog(` Manually fetching queryTotals for ${allKeywords.length} keywords...`, 'info');
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28');
        
        // Fetch queryTotals from GSC API
        const keywordsParam = encodeURIComponent(JSON.stringify(allKeywords));
        const propertyParam = encodeURIComponent(propertyUrl);
        const gscResponse = await fetch(apiUrl(`/api/aigeo/gsc-entity-metrics?property=${propertyParam}&keywords=${keywordsParam}&days=${dateRange}`));
        
        if (gscResponse.ok) {
          const gscData = await gscResponse.json();
          if (gscData.status === 'ok' && gscData.data && Array.isArray(gscData.data.queryTotals)) {
            const queryTotals = gscData.data.queryTotals;
            debugLog(` Fetched queryTotals for ${queryTotals.length} keywords from GSC`, 'success');
            
            // Merge queryTotals into searchData
            savedAudit.searchData.queryTotals = queryTotals;
            
            // Use the SAME audit_date as the existing audit
            let auditDate = new Date().toISOString().split('T')[0];
            if (savedAudit.timestamp) {
              try {
                auditDate = new Date(savedAudit.timestamp).toISOString().split('T')[0];
              } catch (e) {
                // Use today as fallback
              }
            }
            
            // Save to Supabase
            const saveResponse = await fetch(apiUrl('/api/supabase/save-audit'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                propertyUrl: propertyUrl,
                auditDate: auditDate,
                searchData: savedAudit.searchData
              })
            });
            
            if (saveResponse.ok) {
              debugLog(` Saved queryTotals to Supabase (${queryTotals.length} keywords)`, 'success');
              
              // Update localStorage
              try {
                safeSetLocalStorage('last_audit_results', savedAudit);
                debugLog(` Updated localStorage with queryTotals`, 'success');
              } catch (localStorageErr) {
                debugLog(` Failed to update localStorage: ${localStorageErr.message}`, 'warn');
              }
              
              // Re-render the table to show the new data
              renderRankingAiTab();
              debugLog(' Table re-rendered with queryTotals data', 'success');
            } else {
              const errorText = await saveResponse.text();
              debugLog(` Failed to save queryTotals to Supabase: ${saveResponse.status} - ${errorText}`, 'warn');
            }
          } else {
            debugLog(` GSC API did not return queryTotals data`, 'warn');
          }
        } else {
          const errorText = await gscResponse.text();
          debugLog(` Failed to fetch queryTotals from GSC: ${gscResponse.status} - ${errorText}`, 'warn');
        }
      } catch (error) {
        debugLog(` Error manually fetching queryTotals: ${error.message}`, 'error');
      }
    };
    
    window.buildMoneyPageMetrics = function(topPages, schemaAudit) {
      console.warn('[Money Pages]  buildMoneyPageMetrics placeholder called - full implementation not loaded yet. This is a fallback to prevent crashes. The UI will show "No data" until the full implementation loads.');
      // Return empty array as fallback so UI can gracefully handle missing data
      return [];
    };
    
    console.log('[Money Pages]  buildMoneyPageMetrics placeholder assigned to window');
    
    // ======================
    // Ranking & AI module - DEFINE FIRST to ensure it's available
    // ======================
    console.log('[RankingAiModule] Starting module definition at top of script...');
    window.RankingAiModule = (function () {
      console.log('[RankingAiModule] IIFE executing...');
      // Core tracked keywords. Real queries, no mock values.
      // Include both Money and Education terms.
      const TRACKED_KEYWORDS = [
        "alan ranger",
        "beginner photography classes",
        "beginner photography courses",
        "beginners photography course near me",
        "beginning photography lessons",
        "best photography classes",
        "best photography course",
        "best photography workshops",
        "camera courses for beginners",
        "commercial photographer",
        "commercial photography services",
        "corporate photography",
        "free online photography course",
        "hire a photographer",
        "hire a professional photographer",
        "landscape photography courses",
        "landscape photography workshop",
        "Landscape Photography Workshops",
        "landscape photography workshops uk",
        "landscape workshops",
        "lightroom courses",
        "one day photography workshops",
        "online photography courses",
        "online photography lesson",
        "photo editing course",
        "photo workshops",
        "photographer coventry",
        "photographer in coventry",
        "photographic workshops",
        "photography classes",
        "photography classes near me",
        "photography classes online",
        "photography course online",
        "photography courses",
        "photography courses coventry",
        "photography courses for beginners",
        "photography courses near me",
        "photography evening classes",
        "photography gift card",
        "photography gift voucher",
        "photography holidays uk",
        "photography lessons",
        "photography lessons near me",
        "photography lessons online",
        "photography masterclasses",
        "photography mentor",
        "photography presents",
        "photography training",
        "photography tuition",
        "photography tutor",
        "photography vouchers",
        "photography workshops",
        "photography workshops near me",
        "photography workshops uk",
        "private photography lessons",
        "private photography tuition",
        "professional commercial photography",
        "professional photographer",
        "professional photographer coventry",
        "professional photographer near me",
        "rps courses",
        "rps distinctions",
        "uk photography workshops"
      ];

      // API endpoints  adjust if the deployed paths differ.
      // window.apiUrl is already defined at the top level, so we can use it here
      // Also create a local const for use within this scope
      const apiUrl = window.apiUrl;
      
      const SERP_RANK_ENDPOINT = apiUrl('/api/aigeo/serp-rank-test');
      const AI_MODE_ENDPOINT = apiUrl('/api/aigeo/ai-mode-serp-batch-test'); // Using batch endpoint

      let hasLoadedOnce = false;
      let isLoading = false;
      let combinedRows = [];
      let summary = null;

      function normaliseKeyword(k) {
        return (k || "").trim().toLowerCase();
      }

      // Intent-based keyword segment classifier (client-side version)
      function classifyKeywordSegment(keyword, bestUrl) {
        if (!keyword || typeof keyword !== 'string') {
          return 'other';
        }
        
        const normalizedKeyword = keyword.trim().toLowerCase();
        
        // Priority 1: Brand (highest priority)
        const brandTerms = ['alan ranger', 'alanranger', 'alan ranger photography', 'photography academy', 'alan ranger academy'];
        if (brandTerms.some(term => normalizedKeyword.includes(term.toLowerCase()))) {
          return 'brand';
        }
        
        // Priority 2: Money (transactional OR local intent)
        const moneyTerms = ['lesson', 'lessons', 'class', 'classes', 'course', 'courses', 'training', 'workshop', 'workshops', 'mentoring', 'mentor', '1-2-1', '1:1', 'private', 'hire', 'service', 'services', 'photographer', 'booking', 'book', 'price', 'cost', 'voucher', 'gift'];
        const localModifiers = ['near me', 'in coventry', 'coventry', 'birmingham', 'warwick', 'leamington', 'solihull', 'rugby'];
        const hasMoneyTerm = moneyTerms.some(term => normalizedKeyword.includes(term.toLowerCase()));
        const hasLocalModifier = localModifiers.some(term => normalizedKeyword.includes(term.toLowerCase()));
        const hasPostcode = /\b([A-Z]{1,2}\d{1,2}\s?\d?[A-Z]{0,2})\b/i.test(normalizedKeyword);
        
        if (hasMoneyTerm || hasLocalModifier || hasPostcode) {
          return 'money';
        }
        
        // Priority 3: Education (informational/learning intent)
        const educationTerms = ['how to', 'what is', 'guide', 'tutorial', 'tips', 'settings', 'meaning', 'vs', 'difference', 'examples', 'best way to'];
        const techniqueTopics = ['aperture', 'shutter speed', 'iso', 'depth of field', 'histogram', 'dynamic range', 'composition'];
        const hasEducationTerm = educationTerms.some(term => normalizedKeyword.includes(term.toLowerCase()));
        const hasTechniqueTopic = techniqueTopics.some(term => normalizedKeyword.includes(term.toLowerCase()));
        
        if (hasEducationTerm || hasTechniqueTopic) {
          return 'education';
        }
        
        // Priority 4: Other (fallback)
        return 'other';
      }
      
      function classifyPageTypeForKeyword(bestUrl) {
        // Use shared classification function
        if (typeof window.classifyUrlForRankingAi === 'function') {
          const classification = window.classifyUrlForRankingAi(bestUrl || '');
          return classification.pageType;
        }
        return "Landing"; // Default fallback
      }

        const module = {
        TRACKED_KEYWORDS,
        SERP_RANK_ENDPOINT,
        AI_MODE_ENDPOINT,
        normaliseKeyword,
        classifyKeywordSegment,
        classifyPageTypeForKeyword,
        state: () => ({ hasLoadedOnce, isLoading, combinedRows, summary }),
        setLoadedOnce: (value) => { hasLoadedOnce = value; },
        setLoading: (value) => { isLoading = value; },
        setData: (rows, sum) => { 
          // Normalize rows: add segment_norm, segment_display, page_type_norm, page_type_display, impressions30d
          // Use window references since functions may be defined later
          const normSeg = window.normalizeSegment || ((input) => {
            const s = (input ?? "").trim().toLowerCase();
            return s.charAt(0).toUpperCase() + s.slice(1);
          });
          const segLabel = window.segmentLabel || ((s) => s);
          const normPageType = window.normalizePageType || ((pt) => {
            const k = (pt ?? "").trim().toLowerCase();
            return k.charAt(0).toUpperCase() + k.slice(1);
          });
          const pageTypeLab = window.pageTypeLabel || ((pt) => {
            const k = normPageType(pt);
            return k.charAt(0).toUpperCase() + k.slice(1);
          });
          // Get impressions30d for each row using getGscMetricsForKeywordRow (which returns impressions)
          const getGscMetrics = window.getGscMetricsForKeywordRow || (() => null);
          combinedRows = rows.map(r => {
            const segNorm = normSeg(r.segment);
            const segDisplay = segLabel(r.segment);
            const ptNorm = normPageType(r.pageType);
            const ptDisplay = pageTypeLab(r.pageType);
            // Get impressions30d from GSC data - use canonical targetUrl
            const pageUrlForGsc = r.targetUrl || r.ranking_url || r.best_url || '';
            const gscMetrics = getGscMetrics({ query: r.keyword, pageUrl: pageUrlForGsc });
            const impressions30d = gscMetrics && gscMetrics.impressions != null ? gscMetrics.impressions : null;
            return {
              ...r,
              segment_norm: segNorm,
              segment_display: segDisplay,
              page_type_norm: ptNorm,
              page_type_display: ptDisplay,
              impressions30d: impressions30d
            };
          });
          summary = sum; 
        }
      };
      console.log('[RankingAiModule] Module object created:', Object.keys(module));
      return module;
    })();
    
    console.log('[RankingAiModule] Assignment complete. window.RankingAiModule exists:', typeof window.RankingAiModule !== 'undefined');
    console.log('[RankingAiModule] window.RankingAiModule:', window.RankingAiModule);
    
    if (typeof window.RankingAiModule !== 'undefined') {
      console.log('[RankingAiModule]  Successfully assigned to window');
      console.log('[RankingAiModule] TRACKED_KEYWORDS:', window.RankingAiModule.TRACKED_KEYWORDS);
    } else {
      console.error('[RankingAiModule]  FAILED to assign to window');
    }
    
    // Debug logging system - cleaned up to reduce noise
    const debugLogEntries = [];
    let debugLogFilter = 'all'; // 'all', 'warnings-errors'
    
    // Patterns to suppress (common verbose logs that aren't needed)
    const suppressedPatterns = [
      /.*rendered successfully/i,
      /.*loaded successfully/i,
      /.*stored globally/i,
      /.*initialized/i,
      /Money Pages:.*/i,
      /.*renderMoneyPages/i,
      /\[Optimisation\].*URL task:.*Inconsistent result/i,
      /\[Optimisation\].*Loaded.*keywords/i,
      /\[Optimisation\].*Found.*combinedRows/i,
      /\[Optimisation\].*Fetching.*audit/i,
      /\[Traffic Lights\].*/i,
      /\[getBaselineLatest\].*/i,
      / Money Pages.*/i,
    ];
    
    // Generate session ID for tracking browser sessions (persists for page lifetime)
    const debugLogSessionId = (() => {
      let sessionId = sessionStorage.getItem('debug_log_session_id');
      if (!sessionId) {
        sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
        try {
          sessionStorage.setItem('debug_log_session_id', sessionId);
        } catch (e) {
          // Ignore storage errors
        }
      }
      return sessionId;
    })();
    
    // Expose debugLog globally for use throughout the application
    window.debugLog = function debugLog(message, type = 'info') {
      // Truncate very long messages (limit to 500 chars to prevent database bloat)
      const maxMessageLength = 500;
      const truncatedMessage = message.length > maxMessageLength 
        ? message.substring(0, maxMessageLength) + '...[truncated]'
        : message;
      
      // Check if this log should be suppressed (don't show in UI at all)
      const shouldSuppress = suppressedPatterns.some(pattern => pattern.test(truncatedMessage));
      if (shouldSuppress && type === 'info') {
        return; // Completely suppress these logs
      }
      
      const timestamp = new Date().toISOString();
      const entry = {
        timestamp,
        message: truncatedMessage,
        type
      };
      debugLogEntries.push(entry);
      
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        // Check if entry should be displayed based on filter
        const shouldShow = debugLogFilter === 'all' || (debugLogFilter === 'warnings-errors' && (type === 'warn' || type === 'error'));
        
        if (shouldShow) {
          const entryDiv = document.createElement('div');
          entryDiv.className = `debug-log-entry ${type}`;
          entryDiv.innerHTML = `<span class="debug-timestamp">[${new Date(timestamp).toLocaleTimeString()}]</span>${truncatedMessage}`;
          logElement.appendChild(entryDiv);
          logElement.scrollTop = logElement.scrollHeight;
        }
      }
      
      // DISABLED: Supabase saving is causing schema cache issues and spam
      // Re-enable later once schema cache is stable
      
      // Only log to browser console if explicitly enabled
      // Default: keep debug output in the UI log only
      const shouldConsoleLogErrors = window.DEBUG_LOG_TO_CONSOLE === true;
      if (type === 'error' && shouldConsoleLogErrors) {
        if (window._originalConsoleError) {
          window._originalConsoleError(`[DEBUG ERROR]`, truncatedMessage);
        } else {
          try {
            console.error(`[DEBUG ERROR]`, truncatedMessage);
          } catch (e) {
            // Skip console output if recursion detected
          }
        }
      }
    }
    
    function toggleDebugLogFilter() {
      debugLogFilter = debugLogFilter === 'all' ? 'warnings-errors' : 'all';
      const filterBtn = document.getElementById('debugFilterBtn');
      if (filterBtn) {
        filterBtn.textContent = `Filter: ${debugLogFilter === 'all' ? 'All' : 'Warnings/Errors'}`;
      }
      
      // Re-render all log entries with current filter
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        logElement.innerHTML = '';
        debugLogEntries.forEach(entry => {
          const shouldShow = debugLogFilter === 'all' || (debugLogFilter === 'warnings-errors' && (entry.type === 'warn' || entry.type === 'error'));
          if (shouldShow) {
            const entryDiv = document.createElement('div');
            entryDiv.className = `debug-log-entry ${entry.type}`;
            entryDiv.innerHTML = `<span class="debug-timestamp">[${new Date(entry.timestamp).toLocaleTimeString()}]</span>${entry.message}`;
            logElement.appendChild(entryDiv);
          }
        });
        logElement.scrollTop = logElement.scrollHeight;
      }
    }

    function clearDebugLog() {
      debugLogEntries.length = 0;
      window._capturedErrors = [];
      window._capturedWarnings = [];
      try {
        localStorage.removeItem('_capturedErrors');
        localStorage.removeItem('_capturedWarnings');
      } catch (e) {
        // Ignore localStorage errors
      }
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        logElement.innerHTML = '';
      }
      debugLog('Debug log cleared', 'info');
    }
    
    // NOTE: Error handlers are set up in the <head> section (line ~12) to run IMMEDIATELY
    // This ensures errors are captured before any other code runs
    // Function to display all captured errors in debug log (call after page loads)
    window.displayCapturedErrors = function() {
      if (typeof debugLog !== 'function') return;
      
      // Display all captured errors
      window._capturedErrors.forEach(entry => {
        debugLog(entry.message, 'error');
      });
      
      // Display all captured warnings
      window._capturedWarnings.forEach(entry => {
        debugLog(entry.message, 'warn');
      });
      
      if (window._capturedErrors.length > 0 || window._capturedWarnings.length > 0) {
        debugLog(`[ERROR CAPTURE] Displayed ${window._capturedErrors.length} errors and ${window._capturedWarnings.length} warnings that occurred during page load`, 'info');
      }
    };
    
    // Initialize filter button text on page load
    window.addEventListener('DOMContentLoaded', () => {
      const filterBtn = document.getElementById('debugFilterBtn');
      if (filterBtn) {
        filterBtn.textContent = `Filter: ${debugLogFilter === 'all' ? 'All' : 'Warnings/Errors'}`;
      }
      
      // Display any errors that were captured before debugLog was available
      setTimeout(() => {
        if (typeof window.displayCapturedErrors === 'function') {
          window.displayCapturedErrors();
        }
      }, 500);
      
      // Call updateAuditTimestamp on page load after a short delay to ensure DOM is ready
      setTimeout(() => {
        if (typeof window.updateAuditTimestamp === 'function') {
          debugLog('[Page Load] Calling updateAuditTimestamp on page load', 'info');
          window.updateAuditTimestamp();
        } else {
          debugLog('[Page Load] updateAuditTimestamp function not found on window', 'error');
        }
      }, 1000);

      // Restore Ranking & AI data after hard refresh (localStorage may be cleared)
      setTimeout(async () => {
        try {
          if (typeof loadRankingAiDataFromStorage === 'function' && window.RankingAiModule) {
            const stored = await loadRankingAiDataFromStorage(true);
            if (stored && stored.combinedRows && stored.summary) {
              const mod = window.RankingAiModule;
              if (mod?.state && !mod.state().hasLoadedOnce) {
                const normalizedSummary = normalizeSummaryFields(stored.summary);
                mod.setData(stored.combinedRows, normalizedSummary);
                mod.setLoadedOnce(true);
                window.rankingAiData = stored.combinedRows;
              }
            }
          }
        } catch (err) {
          debugLog(`[Page Load] Ranking & AI restore failed: ${err?.message || err}`, 'warn');
        }
      }, 1500);
    });

    function copyDebugLog() {
      // Filter entries based on current filter state
      const filteredEntries = debugLogEntries.filter(entry => {
        return debugLogFilter === 'all' || (debugLogFilter === 'warnings-errors' && (entry.type === 'warn' || entry.type === 'error'));
      });
      
      const logText = filteredEntries.map(entry => 
        `[${entry.timestamp}] [${entry.type.toUpperCase()}] ${entry.message}`
      ).join('\n');
      
      navigator.clipboard.writeText(logText).then(() => {
        debugLog(`Debug log copied to clipboard (${filteredEntries.length} ${debugLogFilter === 'all' ? 'entries' : 'warnings/errors'})`, 'success');
        showStatus(`Debug log copied! (${filteredEntries.length} ${debugLogFilter === 'all' ? 'entries' : 'warnings/errors'})`, 'success');
      }).catch(err => {
        debugLog('Failed to copy log: ' + err.message, 'error');
        showStatus('Failed to copy log', 'error');
      });
    }

    function toggleDebugPanel() {
      const panel = document.getElementById('debugPanel');
      const icon = document.getElementById('debugToggleIcon');
      if (panel.classList.contains('collapsed')) {
        panel.classList.remove('collapsed');
        if (icon) icon.textContent = '';
      } else {
        panel.classList.add('collapsed');
        if (icon) icon.textContent = '';
      }
    }

    // Performance optimization: Defer heavy work to improve INP
    function defer(fn) {
      if (window.requestIdleCallback) {
        requestIdleCallback(fn, { timeout: 800 });
      } else {
        setTimeout(fn, 0);
      }
    }

    const panelInitDone = new Set();

    function setActivePanel(panelId) {
      // 1) fast: toggle active nav styles
      document.querySelectorAll('.aigeo-nav-item').forEach(btn => {
        btn.classList.toggle('is-active', btn.dataset.panel === panelId);
        btn.setAttribute('aria-selected', btn.dataset.panel === panelId ? 'true' : 'false');
      });

      // 2) fast: show/hide panels only (NO rendering work here)
      document.querySelectorAll('.aigeo-panel').forEach(p => {
        const isActive = p.dataset.panel === panelId;
        p.classList.toggle('is-active', isActive);
        
        // CRITICAL: When Portfolio tab becomes active, initialize charts
        if (isActive && panelId === 'portfolio') {
          setTimeout(() => {
            if (typeof window.renderPortfolioTab === 'function') {
              window.renderPortfolioTab();
            }
          }, 100);
        }

        // Dashboard: render lightweight summary (no heavy work)
        if (isActive && panelId === 'dashboard') {
          setTimeout(() => {
            if (typeof window.renderDashboardTab === 'function') {
              window.renderDashboardTab();
            }
            // Also update audit timestamp badge when dashboard tab is activated
            if (typeof window.updateAuditTimestamp === 'function') {
              setTimeout(() => window.updateAuditTimestamp(), 200);
            }
          }, 50);
        }
        
        // CRITICAL: When Money Pages tab becomes active, re-fetch statuses from database
        if (isActive && panelId === 'money') {
          console.log('[Money Pages] Tab activated - checking if re-fetch needed...', {
            hasMetrics: !!window.moneyPagesMetrics,
            hasRows: !!(window.moneyPagesMetrics && window.moneyPagesMetrics.rows),
            rowCount: window.moneyPagesMetrics?.rows?.length || 0,
            hasPriorityData: !!window.moneyPagePriorityData,
            priorityDataCount: window.moneyPagePriorityData?.length || 0
          });
          
          // Use setTimeout to ensure panel is fully visible before fetching
          setTimeout(async () => {
            // CRITICAL: Fetch statuses for BOTH tables at once to avoid clearing cache multiple times
            // Build combined list of all rows from both tables
            const allStatusRows = [];
            
            // Add Opportunity table rows
            if (window.moneyPagesMetrics && window.moneyPagesMetrics.rows && window.moneyPagesMetrics.rows.length > 0) {
              window.moneyPagesMetrics.rows.forEach(row => {
                allStatusRows.push({
                  keyword: '', // Empty for page-level tasks
                  best_url: row.url,
                  targetUrl: row.url,
                  ranking_url: row.url
                });
              });
            }
            
            // Add Priority table rows
            if (window.moneyPagePriorityData && window.moneyPagePriorityData.length > 0) {
              window.moneyPagePriorityData.forEach(p => {
                allStatusRows.push({
                  keyword: '', // Empty for page-level tasks
                  best_url: p.url,
                  targetUrl: p.url,
                  ranking_url: p.url
                });
              });
            }
            
            // Fetch statuses for ALL rows at once (prevents multiple cache clears)
            if (allStatusRows.length > 0 && typeof window.fetchOptimisationStatuses === 'function') {
              const testUrl = 'https://www.alanranger.com/landscape-photography-workshops';
              const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(testUrl) : testUrl.toLowerCase().trim();
              const key = `::${urlKey}::on_page`;
              const cacheBefore = {
                size: window.optimisationStatusCache?.size || 0,
                hasLandscape: window.optimisationStatusCache?.has(key),
                landscapeValue: window.optimisationStatusCache?.get(key) ? {
                  id: window.optimisationStatusCache.get(key).id,
                  status: window.optimisationStatusCache.get(key).status
                } : null
              };
              
              debugLog(`[Money Pages] Tab switch: Fetching statuses for ${allStatusRows.length} rows (combined from both tables). Cache BEFORE: size=${cacheBefore.size}, hasLandscape=${cacheBefore.hasLandscape}, landscapeId=${cacheBefore.landscapeValue?.id || 'null'}`, 'info');
              
              try {
                await window.fetchOptimisationStatuses(allStatusRows);
                
                const cacheAfter = {
                  size: window.optimisationStatusCache?.size || 0,
                  hasLandscape: window.optimisationStatusCache?.has(key),
                  landscapeValue: window.optimisationStatusCache?.get(key) ? {
                    id: window.optimisationStatusCache.get(key).id,
                    status: window.optimisationStatusCache.get(key).status
                  } : null
                };
                
                debugLog(`[Money Pages] Tab switch: Cache AFTER fetch: size=${cacheAfter.size}, hasLandscape=${cacheAfter.hasLandscape}, landscapeId=${cacheAfter.landscapeValue?.id || 'null'}, status=${cacheAfter.landscapeValue?.status || 'null'}`, cacheAfter.hasLandscape ? 'success' : 'warn');
              } catch (err) {
                debugLog(`[Money Pages] Error re-fetching statuses: ${err.message}`, 'error');
              }
            }
            
            // NOW re-render both tables (statuses are already fetched)
            // Re-render Opportunity table
            if (window.moneyPagesMetrics && window.moneyPagesMetrics.rows && window.moneyPagesMetrics.rows.length > 0) {
              const tableContainer = document.getElementById('money-pages-table-container');
              if (tableContainer && typeof renderMoneyPagesTable === 'function') {
                const currentPage = window.moneyPagesCurrentPage || 1;
                const rowsPerPage = window.moneyPagesRowsPerPage || 10;
                const tableHtml = await renderMoneyPagesTable(window.moneyPagesMetrics.rows, currentPage, rowsPerPage);
                if (tableHtml && typeof tableHtml === 'string' && tableHtml.trim().length > 0) {
                  tableContainer.innerHTML = tableHtml;
                  console.log('[Money Pages]  Opportunity table re-rendered after tab switch');
                }
              }
            }
            
            // Re-render Priority table
            if (window.moneyPagePriorityData && window.moneyPagePriorityData.length > 0) {
              if (typeof window.renderMoneyPagesPriorityTable === 'function') {
                const filters = {
                  typeFilter: window.moneyPagesTypeFilter || 'all',
                  minImpr: window.moneyPagesMinImpr || 0,
                  matrixFilter: window.moneyPagesMatrixFilter || null
                };
                await window.renderMoneyPagesPriorityTable(null, filters);
                console.log('[Money Pages]  Priority table re-rendered after tab switch');
              }
            }
          }, 100); // Small delay to ensure panel is visible
        }
        p.hidden = !isActive; // Explicitly set hidden attribute
      });
    }

    function ensurePanelRendered(panelId) {
      if (panelInitDone.has(panelId)) return;

      // IMPORTANT: only do heavy first-time render here
      // e.g. build big tables, compute summaries, populate dropdowns
      if (panelId === 'ranking') {
        // Fix DOM structure first
        fixRankingPanelStructure();
        // Load data and render ranking panel
        (async () => {
          debugLog(' Ranking panel: Loading data from storage...', 'info');
          const storedData = await loadRankingAiDataFromStorage(false);
          if (storedData && storedData.combinedRows && storedData.summary) {
            const mod = window.RankingAiModule;
            if (mod) {
              const normalizedSummary = normalizeSummaryFields(storedData.summary);
              mod.setData(storedData.combinedRows, normalizedSummary);
              mod.setLoadedOnce(true);
              renderRankingAiTab();
              const lastRunEl = document.getElementById("ranking-ai-last-run");
              if (lastRunEl && storedData.timestamp) {
                const date = new Date(storedData.timestamp);
                // Format in GMT/UTC: "DD MMM YYYY, HH:MM:SS GMT"
                const day = String(date.getUTCDate()).padStart(2, '0');
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const month = monthNames[date.getUTCMonth()];
                const year = date.getUTCFullYear();
                const hours = String(date.getUTCHours()).padStart(2, '0');
                const minutes = String(date.getUTCMinutes()).padStart(2, '0');
                const seconds = String(date.getUTCSeconds()).padStart(2, '0');
                const formatted = `${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
                lastRunEl.textContent = `Last run: ${formatted}`;
              }
            }
          } else {
            const mod = window.RankingAiModule;
            if (mod) {
              mod.setData([], { total_keywords: 0, keywords_with_rank: 0, keywords_with_ai_overview: 0, keywords_with_ai_citations: 0, top10: 0, top3: 0 });
              renderRankingAiTab();
            }
          }
          
          // CRITICAL: After initial render, check if queryTotals are available and re-render if needed
          // This ensures CTR/Impressions columns are populated even if loadAuditResults() completes after initial render
          (async () => {
            try {
              debugLog(` Checking for queryTotals after initial render...`, 'info');
              const savedAudit = await loadAuditResults();
              debugLog(` loadAuditResults() completed - savedAudit=${!!savedAudit}, searchData=${!!savedAudit?.searchData}, queryTotals=${savedAudit?.searchData?.queryTotals?.length || 0}`, savedAudit?.searchData?.queryTotals?.length > 0 ? 'success' : 'warn');
              if (savedAudit && savedAudit.searchData && Array.isArray(savedAudit.searchData.queryTotals) && savedAudit.searchData.queryTotals.length > 0) {
                debugLog(` queryTotals loaded (${savedAudit.searchData.queryTotals.length} keywords), re-rendering table to show CTR/Impressions`, 'success');
                // Re-render the table to show CTR/Impressions data
                if (typeof renderRankingAiTab === 'function') {
                  renderRankingAiTab();
                  debugLog(` Table re-rendered with queryTotals data`, 'success');
                } else {
                  debugLog(` renderRankingAiTab function not found`, 'warn');
                }
              } else {
                debugLog(` No queryTotals found in savedAudit - searchData=${!!savedAudit?.searchData}, queryTotals type=${typeof savedAudit?.searchData?.queryTotals}, length=${savedAudit?.searchData?.queryTotals?.length || 0}`, 'warn');
                if (savedAudit && savedAudit.searchData) {
                  debugLog(` searchData keys: ${Object.keys(savedAudit.searchData).join(', ')}`, 'warn');
                }
              }
            } catch (err) {
              debugLog(` Error loading queryTotals for re-render: ${err.message}`, 'error');
              debugLog(` Error stack: ${err.stack}`, 'error');
            }
          })();
          
          // Wire up filters and sorting after render
          setTimeout(() => {
            // Fix DOM structure after render
            fixRankingPanelStructure();
            if (typeof wireRankingAiButton === 'function') wireRankingAiButton();
            if (typeof wireRankingFilters === 'function') wireRankingFilters();
            if (typeof wireRankingSorting === 'function') wireRankingSorting();
            if (typeof wireRankingPagination === 'function') wireRankingPagination();
          }, 100);
        })();
      } else if (panelId === 'ai-sources') {
        setTimeout(() => {
          if (typeof wireAiSourcesFilters === 'function') wireAiSourcesFilters();
        }, 100);
        (async () => {
          debugLog(' AI Sources & Influence tab clicked - loading data...', 'info');
          const storedData = await loadRankingAiDataFromStorage(false);
          if (storedData && storedData.combinedRows && storedData.combinedRows.length > 0) {
            const mod = window.RankingAiModule;
            if (mod) {
              const normalizedSummary = normalizeSummaryFields(storedData.summary);
              mod.setData(storedData.combinedRows, normalizedSummary);
              debugLog(` AI Sources tab: Rendering with ${storedData.combinedRows.length} keywords`, 'success');
              if (typeof renderAiSourcesTab === 'function') {
                renderAiSourcesTab();
              }
            }
          } else {
            debugLog(' AI Sources tab: No keyword data available. Run a Ranking & AI check first.', 'warn');
            if (typeof renderAiSourcesTab === 'function') {
              renderAiSourcesTab(); // Will show empty state
            }
          }
        })();
      } else if (panelId === 'overview') {
        setTimeout(async () => {
          // Use async loadAuditResults to ensure we get latest data from Supabase (including localSignals with locations)
          const saved = await loadAuditResults();
          if (saved && saved.scores && saved.searchData) {
            const trendCanvas = document.getElementById('trendChart');
            if (trendCanvas && typeof displayDashboard === 'function') {
              debugLog('Re-rendering Score Trends chart for Overview tab', 'info');
              // DEBUG: Log localSignals structure when loading Overview tab
              if (saved.localSignals) {
                debugLog(`[Overview Tab] localSignals structure: status=${saved.localSignals.status}, hasData=${!!saved.localSignals.data}, hasLocations=${!!saved.localSignals.data?.locations}, locationsCount=${saved.localSignals.data?.locations?.length || 0}`, 'info');
              } else {
                debugLog(`[Overview Tab]  localSignals is missing from saved audit data`, 'warn');
              }
              try {
                await displayDashboard(saved.scores, saved.searchData, saved.snippetReadiness || 0, saved.schemaAudit || null, saved.localSignals || null, saved.backlinkMetrics || null);
              } catch (err) {
                debugLog(`Error re-rendering trend chart: ${err.message}`, 'warn');
              }

              // Refresh GBP data on overview load to avoid stale review counts
              try {
                const propertyUrl = document.getElementById('propertyUrl')?.value || saved.searchData?.propertyUrl || saved.propertyUrl;
                if (propertyUrl) {
                  const localSignalsResponse = await fetch(apiUrl(`/api/aigeo/local-signals?property=${encodeURIComponent(propertyUrl)}`));
                  if (localSignalsResponse.ok) {
                    const freshLocalSignals = await localSignalsResponse.json();
                    const freshCount = freshLocalSignals?.data?.gbpReviewCount;
                    const cachedCount = saved.localSignals?.data?.gbpReviewCount;
                    if (freshCount != null && freshCount !== cachedCount) {
                      debugLog(`[Overview Tab] GBP count refreshed: ${cachedCount || 'N/A'} -> ${freshCount}`, 'info');
                      const updatedSaved = { ...saved, localSignals: freshLocalSignals };
                      try {
                        localStorage.setItem('last_audit_results', JSON.stringify(updatedSaved));
                      } catch (storageErr) {
                        // Non-fatal
                      }
                      await displayDashboard(saved.scores, saved.searchData, saved.snippetReadiness || 0, saved.schemaAudit || null, freshLocalSignals || null, saved.backlinkMetrics || null);
                    }
                  }
                }
              } catch (err) {
                debugLog(`[Overview Tab] GBP refresh failed: ${err.message}`, 'warn');
              }
            }
          }
        }, 200);
      } else if (panelId === 'money') {
        // Money Pages is rendered by `ensureMoneyPagesRendered()` during `displayDashboard()`.
        // Avoid rebuilding/wiring Money Pages from the generic panel initializer (it causes races where
        // selectors/containers don't exist yet, spamming warnings and leaving KPIs blank).
        panelInitDone.add(panelId);
        return;
      }

      // Mark panel as initialized
      panelInitDone.add(panelId);
    }

    // Portfolio Tab Functions
    let portfolioDeltaChart = null;
    
    window.renderPortfolioTab = async function() {
      debugLog(' Rendering Portfolio tab...', 'info');
      
      // Initialize chart if not already done
      if (!portfolioDeltaChart) {
        await initializePortfolioChart();
      }
      
      // Load and render data
      await loadPortfolioData();
      await renderPortfolioTable();
    };

    async function initializePortfolioChart() {
      const canvas = document.getElementById('portfolio-delta-chart');
      if (!canvas) {
        debugLog(' Portfolio chart canvas not found', 'warn');
        return;
      }

      const ctx = canvas.getContext('2d');
      
      // Destroy existing chart if it exists
      if (portfolioDeltaChart) {
        portfolioDeltaChart.destroy();
      }

      portfolioDeltaChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Delta',
            data: [],
            borderColor: 'var(--dark-brand)',
            backgroundColor: 'rgba(245, 158, 11, 0.15)',
            borderWidth: 2,
            tension: 0.4,
            fill: true,
            pointRadius: 4,
            pointHoverRadius: 6,
            pointBackgroundColor: 'var(--dark-brand)',
            pointBorderColor: '#ffffff',
            pointBorderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                color: '#ffffff',
                font: { size: 12, weight: '600' },
                padding: 15
              }
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              backgroundColor: 'rgba(26, 31, 46, 0.95)',
              titleColor: '#ffffff',
              bodyColor: 'var(--dark-text)',
              borderColor: 'var(--dark-border)',
              borderWidth: 1,
              padding: 12,
              displayColors: true,
              callbacks: {
                label: function(context) {
                  const value = context.parsed.y;
                  if (value === null) return 'No data';
                  const kpi = document.getElementById('portfolio-kpi-select')?.value || 'ctr_28d';
                  if (kpi === 'ctr_28d') {
                    return `${value >= 0 ? '+' : ''}${value.toFixed(2)}pp`;
                  } else if (kpi === 'avg_position') {
                    return `${value >= 0 ? '+' : ''}${value.toFixed(1)} (${value < 0 ? 'improved' : 'worsened'})`;
                  } else {
                    return `${value >= 0 ? '+' : ''}${value.toLocaleString()}`;
                  }
                }
              }
            }
          },
          scales: {
            x: {
              display: true,
              title: {
                display: true,
                text: 'Date',
                color: '#ffffff',
                font: { size: 13, weight: '600' }
              },
              ticks: {
                color: '#ffffff',
                font: { size: 11, weight: '500' }
              },
              grid: {
                color: 'rgba(55, 65, 81, 0.3)',
                drawBorder: false
              }
            },
            y: {
              display: true,
              title: {
                display: true,
                text: 'Delta',
                color: '#ffffff',
                font: { size: 13, weight: '600' }
              },
              ticks: {
                color: '#ffffff',
                font: { size: 11, weight: '500' },
                callback: function(value) {
                  const kpi = document.getElementById('portfolio-kpi-select')?.value || 'ctr_28d';
                  if (kpi === 'ctr_28d') {
                    return value.toFixed(1) + 'pp';
                  }
                  return value;
                }
              },
              grid: {
                color: 'rgba(55, 65, 81, 0.3)',
                drawBorder: false
              },
              zeroLine: {
                color: 'var(--dark-border)',
                width: 2
              }
            }
          }
        }
      });
    }

    async function loadPortfolioData() {
      const kpiSelect = document.getElementById('portfolio-kpi-select')?.value || 'ctr_28d';
      const segmentUi = document.getElementById('portfolio-segment-select')?.value || 'all_tracked';
      const timeGrain = document.getElementById('portfolio-time-grain')?.value || 'weekly';

      // Map UI KPI to portfolio_segment_metrics_28d field
      const kpiFieldMap = {
        'ctr_28d': 'ctr_28d',
        'clicks_28d': 'clicks_28d',
        'impressions_28d': 'impressions_28d',
        'avg_position': 'position_28d',
        'ai_citations': 'ai_citations_28d',
        'ai_overview': 'ai_overview_present_count'
      };
      
      const kpiField = kpiFieldMap[kpiSelect];
      if (!kpiField && kpiSelect !== 'ai_citations' && kpiSelect !== 'ai_overview') {
        debugLog(` KPI ${kpiSelect} not supported in segment metrics`, 'warn');
        return;
      }
      
      // Portfolio no longer uses a separate "Scope" control (too nuanced).
      // Instead we expose explicit tracked segments. Map UI segment -> (db segment, db scope).
      const segmentMap = (() => {
        if (segmentUi === 'money_tracked') return { segment: 'money', scope: 'active_cycles_only' };
        if (segmentUi === 'all_tracked') return { segment: 'all_tracked', scope: 'active_cycles_only' };
        if (segmentUi === 'site') return { segment: 'site', scope: 'all_pages' };
        // Default: untracked / full segment
        return { segment: segmentUi, scope: 'all_pages' };
      })();
      const segment = segmentMap.segment;
      const mappedScope = segmentMap.scope;

      try {
        const propertyUrl = (window.getPropertyUrl ? window.getPropertyUrl() : '') || localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (!propertyUrl) {
          debugLog(' No property URL found for portfolio data', 'warn');
          return;
        }
        
        // Calculate date range (last 365 days to ensure enough data for weekly and monthly views)
        const toDate = new Date();
        const fromDate = new Date();
        fromDate.setDate(fromDate.getDate() - 365);
        
        const params = new URLSearchParams({ 
          siteUrl: propertyUrl,
          segment,
          from: fromDate.toISOString(),
          to: toDate.toISOString(),
          order: 'asc' // Chronological for chart
        });
        if (mappedScope) params.set('scope', mappedScope);
        
        const response = await fetch(apiUrl(`/api/supabase/get-portfolio-segment-metrics?${params}`));
        
        if (!response.ok) {
          const errorText = await response.text();
          debugLog(` Portfolio API error: ${response.status} - ${errorText}`, 'error');
          throw new Error(`API error: ${response.status}`);
        }
        
        const data = await response.json();
        const metrics = data.metrics || [];
        
        debugLog(` Portfolio data loaded: ${metrics.length} metrics for segment=${segmentUi} (db: segment=${segment}, scope=${mappedScope}), kpi=${kpiSelect}`, 'info');
        debugLog(` API params: siteUrl=${propertyUrl}, segment=${segment}, scope=${mappedScope}, from=${fromDate.toISOString()}, to=${toDate.toISOString()}`, 'info');
        
        // Debug: Log sample metrics to see what data we have
        if (metrics.length > 0) {
          const sampleMetric = metrics[0];
          debugLog(` Sample metric: run_id=${sampleMetric.run_id}, created_at=${sampleMetric.created_at}, date_end=${sampleMetric.date_end}, position_28d=${sampleMetric.position_28d}, ctr_28d=${sampleMetric.ctr_28d}`, 'info');
          
          // Check for position data
          const metricsWithPosition = metrics.filter(m => m.position_28d !== null && m.position_28d !== undefined && !isNaN(parseFloat(m.position_28d)));
          debugLog(` Metrics with position data: ${metricsWithPosition.length} out of ${metrics.length}`, metricsWithPosition.length > 0 ? 'success' : 'warn');
          
          // Log position values for debugging
          if (metricsWithPosition.length > 0) {
            const positionValues = metricsWithPosition.slice(0, 5).map(m => m.position_28d).join(', ');
            debugLog(` Sample position values: ${positionValues}`, 'info');
          } else {
            debugLog(` No valid position data found. Checking raw values...`, 'warn');
            const rawPositions = metrics.slice(0, 5).map(m => `run_id=${m.run_id}, position_28d=${m.position_28d} (type=${typeof m.position_28d})`).join('; ');
            debugLog(` Raw position samples: ${rawPositions}`, 'info');
          }
        }
        
        if (metrics.length === 0) {
          debugLog(` No metrics found. Checking if data exists in database...`, 'warn');
          // Try querying without scope filter to see if data exists
          const testParams = new URLSearchParams({ 
            siteUrl: propertyUrl,
            segment,
            from: fromDate.toISOString(),
            to: toDate.toISOString(),
            order: 'asc'
          });
          const testResponse = await fetch(apiUrl(`/api/supabase/get-portfolio-segment-metrics?${testParams}`));
          if (testResponse.ok) {
            const testData = await testResponse.json();
            const testMetrics = testData.metrics || [];
            if (testMetrics.length > 0) {
              debugLog(` Found ${testMetrics.length} metrics WITHOUT scope filter. Scope filter '${mappedScope}' may be excluding all data.`, 'warn');
              debugLog(` Available scopes in data: ${[...new Set(testMetrics.map(m => m.scope))].join(', ')}`, 'warn');
            } else {
              debugLog(` No metrics found even without scope filter. Check if portfolio_segment_metrics_28d table has data for this site.`, 'warn');
            }
          }
        }
        
        if (metrics.length === 0) {
          debugLog(' No portfolio metrics found - check segment and scope filters', 'warn');
          if (portfolioDeltaChart) {
            portfolioDeltaChart.data.labels = [];
            portfolioDeltaChart.data.datasets[0].data = [];
            portfolioDeltaChart.update();
          }
          return;
        }
        
        // Bucket by time grain and compute deltas
        // Use created_at (when the audit was run) as the primary date for bucketing
        // This ensures audits run on different days get different buckets, even if they share the same date_end
        // For monthly bucketing, also check run_id if it's in YYYY-MM format
        const buckets = new Map(); // key: bucket label, value: { value, date }
        
        const dateKeyUTC = (d) => {
          const y = d.getUTCFullYear();
          const m = String(d.getUTCMonth() + 1).padStart(2, '0');
          const day = String(d.getUTCDate()).padStart(2, '0');
          return `${y}-${m}-${day}`;
        };
        const mondayKeyUTCFromDate = (d) => {
          // Get Monday (UTC) for the week containing d
          const dayOfWeek = d.getUTCDay(); // 0=Sun..6=Sat
          const diff = d.getUTCDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1);
          const monday = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
          monday.setUTCDate(diff);
          return dateKeyUTC(monday);
        };
        const safeDateFrom = (v) => {
          if (!v) return null;
          const d = new Date(v);
          return isNaN(d.getTime()) ? null : d;
        };
        
        metrics.forEach(m => {
          // For weekly view: ONLY use actual weekly snapshots (run_id in YYYY-MM-DD format)
          // Skip monthly backfilled data (run_id in YYYY-MM format) to avoid misleading weekly distribution
          if (timeGrain === 'weekly' && m.run_id && m.run_id.match(/^\d{4}-\d{2}$/)) {
            // Skip monthly backfilled data in weekly view
            return;
          }
          
          // Determine the date to use for bucketing:
          // 1. If run_id is in YYYY-MM format, use that for monthly bucketing (historical backfill)
          // 2. Otherwise, use created_at (when the audit was run) - this ensures different audit runs get different buckets
          // 3. Fallback to date_end if created_at is not available
          let dateForBucket = null;
          let bucketKey = null;
          
          // Determine date for bucketing based on time grain
          if (timeGrain === 'monthly' && m.run_id && m.run_id.match(/^\d{4}-\d{2}$/)) {
            // Monthly: use run_id directly if it's in YYYY-MM format (for historical backfill)
            bucketKey = m.run_id;
            dateForBucket = new Date(m.run_id + '-01');
          } else if (timeGrain === 'weekly') {
            // For weekly: only use actual weekly snapshots (run_id in YYYY-MM-DD format)
            // Prefer date_end (actual GSC period end). created_at can be "now" for backfilled history.
            if (m.date_end) {
              dateForBucket = safeDateFrom(m.date_end);
            } else if (m.run_id && m.run_id.match(/^\d{4}-\d{2}-\d{2}$/)) {
              dateForBucket = safeDateFrom(m.run_id);
            } else if (m.created_at) {
              dateForBucket = safeDateFrom(m.created_at);
            } else {
              debugLog(` No valid date found for weekly metric: run_id=${m.run_id}, date_end=${m.date_end}, created_at=${m.created_at}`, 'warn');
              return; // Skip this metric
            }
          } else if (m.created_at) {
            // For monthly (non-backfill): use created_at (when the audit was run)
            dateForBucket = safeDateFrom(m.created_at);
          } else if (m.run_id && m.run_id.match(/^\d{4}-\d{2}-\d{2}$/)) {
            // If run_id is in YYYY-MM-DD format, use that
            dateForBucket = safeDateFrom(m.run_id);
          } else if (m.date_end) {
            // Fallback to date_end
            dateForBucket = safeDateFrom(m.date_end);
          } else {
            debugLog(` No valid date found for metric: run_id=${m.run_id}, date_end=${m.date_end}, created_at=${m.created_at}`, 'warn');
            return; // Skip this metric
          }
          
          if (!dateForBucket || isNaN(dateForBucket.getTime())) {
            debugLog(` Invalid date for metric: run_id=${m.run_id}, date_end=${m.date_end}, created_at=${m.created_at}`, 'warn');
            return; // Skip this metric
          }
          
          if (!bucketKey) {
            // Calculate bucket key from date
            if (timeGrain === 'weekly') {
              bucketKey = mondayKeyUTCFromDate(dateForBucket); // Use Monday date (UTC) as key
            } else {
              // Monthly: YYYY-MM
              bucketKey = `${dateForBucket.getFullYear()}-${String(dateForBucket.getMonth() + 1).padStart(2, '0')}`;
            }
          }
          
          // Keep the LAST snapshot in each bucket using date_end first (actual period end), then created_at as fallback
          const comparisonDate = safeDateFrom(m.date_end) || safeDateFrom(m.created_at) || dateForBucket;
          if (!buckets.has(bucketKey) || comparisonDate > buckets.get(bucketKey).date) {
            const value = kpiField === 'ctr_28d' ? parseFloat(m.ctr_28d || 0) :
                          kpiField === 'clicks_28d' ? parseFloat(m.clicks_28d || 0) :
                          kpiField === 'impressions_28d' ? parseFloat(m.impressions_28d || 0) :
                          kpiField === 'position_28d' ? (m.position_28d !== null && m.position_28d !== undefined && !isNaN(parseFloat(m.position_28d)) ? parseFloat(m.position_28d) : null) :
                          kpiField === 'ai_citations_28d' ? (m.ai_citations_28d ? parseInt(m.ai_citations_28d) : 0) :
                          kpiField === 'ai_overview_present_count' ? (m.ai_overview_present_count ? parseInt(m.ai_overview_present_count) : 0) : null;
            
            buckets.set(bucketKey, { value, date: comparisonDate });
          }
        });
        
        debugLog(` Bucketed into ${buckets.size} time buckets (${timeGrain})`, 'info');
        
        // Debug: Log bucket details and date sources
        if (buckets.size > 0) {
          const bucketEntries = Array.from(buckets.entries());
          bucketEntries.forEach(([key, bucket]) => {
            const valueStr = bucket.value !== null 
              ? (kpiSelect === 'ctr_28d' ? (bucket.value * 100).toFixed(2) + '%' : 
                 kpiSelect === 'avg_position' ? bucket.value.toFixed(1) : 
                 bucket.value.toFixed(2))
              : 'null';
            debugLog(` Bucket ${key}: value=${valueStr}, date=${bucket.date.toISOString()}`, 'info');
          });
          
          // Log date source info for first few metrics
          if (metrics.length > 0) {
            const dateSources = metrics.slice(0, 5).map(m => {
              const source = (timeGrain === 'monthly' && m.run_id && m.run_id.match(/^\d{4}-\d{2}$/)) ? 'run_id (YYYY-MM)' :
                            m.created_at ? 'created_at' :
                            m.run_id && m.run_id.match(/^\d{4}-\d{2}-\d{2}$/) ? 'run_id (YYYY-MM-DD)' :
                            m.date_end ? 'date_end' :
                            'none';
              const dateUsed = (timeGrain === 'monthly' && m.run_id && m.run_id.match(/^\d{4}-\d{2}$/)) ? m.run_id :
                              m.created_at || m.date_end || 'N/A';
              return `run_id=${m.run_id}, source=${source}, date=${dateUsed}`;
            }).join('; ');
            debugLog(` Date sources for bucketing (first 5): ${dateSources}`, 'info');
          }
        }
        
        // Sort buckets by bucket key (chronological order - oldest first)
        // For monthly: sort by YYYY-MM string (lexicographic sort works for dates)
        // For weekly: sort by date string (YYYY-MM-DD)
        const sortedBuckets = Array.from(buckets.entries())
          .sort((a, b) => {
            const keyA = a[0];
            const keyB = b[0];
            // Lexicographic sort works for YYYY-MM and YYYY-MM-DD formats
            return keyA.localeCompare(keyB);
          });
        
        // Filter to only last 12 months for monthly grain (rolling 12 months)
        // Match the table logic: show last 12 months including current month
        let filteredBuckets = sortedBuckets;
        if (timeGrain === 'monthly') {
          const today = new Date();
          // Get the first day of the month 12 months ago (to include that month)
          // e.g., if today is Dec 23, 2025, we want to include from Jan 1, 2025
          const firstMonthToInclude = new Date(today.getFullYear(), today.getMonth() - 11, 1);
          const firstMonthKey = `${firstMonthToInclude.getFullYear()}-${String(firstMonthToInclude.getMonth() + 1).padStart(2, '0')}`;
          
          filteredBuckets = sortedBuckets.filter(([bucketKey, bucket]) => {
            // Compare bucket keys directly (YYYY-MM format)
            return bucketKey >= firstMonthKey;
          });
          
          debugLog(` Filtered to last 12 months (from ${firstMonthKey}): ${filteredBuckets.length} buckets (from ${sortedBuckets.length} total)`, 'info');
        }
        
        // If we only have 1 bucket, we can't show deltas
        if (filteredBuckets.length < 2) {
          debugLog(` Only ${filteredBuckets.length} bucket(s) - need at least 2 different ${timeGrain} periods to show deltas`, 'warn');
          debugLog(` This usually means: (1) Only one audit has been run, or (2) Multiple audits are in the same ${timeGrain} period`, 'warn');
          if (portfolioDeltaChart) {
            portfolioDeltaChart.data.labels = [];
            portfolioDeltaChart.data.datasets[0].data = [];
            portfolioDeltaChart.update();
          }
          
          // Show empty state message
          const canvas = document.getElementById('portfolio-delta-chart');
          if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Need at least 2 different ${timeGrain} periods to show deltas.`, 
              canvas.width / 2, canvas.height / 2);
          }
          return;
        }
        
        // Compute deltas
        const labels = [];
        const deltas = [];
        
        filteredBuckets.forEach(([bucketKey, bucket], index) => {
          let label;
          if (timeGrain === 'weekly') {
            // Weekly: show Monday date as "DD MMM"
            label = new Date(bucketKey + 'T00:00:00Z').toLocaleDateString('en-GB', { day: '2-digit', month: 'short' });
          } else {
            // Monthly: show as "MMM YY" (e.g., "Jan 25", "Dec 25")
            const monthDate = new Date(bucketKey + '-01');
            const monthName = monthDate.toLocaleDateString('en-GB', { month: 'short' });
            const yearShort = bucketKey.split('-')[0].slice(2);
            label = `${monthName} ${yearShort}`;
          }
          
          // Always add the label
          labels.push(label);
          
          if (index === 0) {
            // First bucket: set delta to 0 so the line starts from baseline
            // This ensures the first month is visible on the chart
            deltas.push(0);
          } else {
            const prevBucket = filteredBuckets[index - 1][1];
            const delta = bucket.value !== null && prevBucket.value !== null 
              ? bucket.value - prevBucket.value 
              : null;
            
            deltas.push(delta);
          }
        });
        
        debugLog(` Computed ${deltas.filter(d => d !== null).length} deltas from ${sortedBuckets.length} buckets`, 'info');

        if (portfolioDeltaChart) {
          // Format deltas for display
          const formattedDeltas = deltas.map(d => {
            if (d === null) return null;
            // CTR delta: convert ratio to percentage points
            if (kpiSelect === 'ctr_28d') {
              return d * 100; // Convert ratio delta to percentage points
            }
            // AI citations and AI overview are already integers, no conversion needed
            return d;
          });
          
          debugLog(` Chart data: ${labels.length} labels, ${formattedDeltas.filter(d => d !== null).length} non-null deltas`, 'info');
          
          portfolioDeltaChart.data.labels = labels;
          portfolioDeltaChart.data.datasets[0].data = formattedDeltas;
          portfolioDeltaChart.data.datasets[0].label = `Delta (${kpiSelect})`;
          // Use brand orange (#E57200) for line and points
          portfolioDeltaChart.data.datasets[0].borderColor = '#E57200';
          portfolioDeltaChart.data.datasets[0].pointBackgroundColor = '#E57200';
          portfolioDeltaChart.data.datasets[0].pointBorderColor = '#ffffff';
          portfolioDeltaChart.data.datasets[0].pointBorderWidth = 2;
          // Simple brand orange fill
          portfolioDeltaChart.data.datasets[0].backgroundColor = 'rgba(229, 114, 0, 0.15)';
          
          // Update Y-axis label
          if (kpiSelect === 'ctr_28d') {
            portfolioDeltaChart.options.scales.y.title.text = 'Delta (percentage points)';
          } else if (kpiSelect === 'avg_position') {
            portfolioDeltaChart.options.scales.y.title.text = 'Delta (negative is improvement)';
          } else {
            portfolioDeltaChart.options.scales.y.title.text = `Delta (${kpiSelect})`;
          }
          
          portfolioDeltaChart.update('none'); // Use 'none' animation mode for faster updates
          debugLog(' Portfolio chart updated', 'success');
        } else {
          debugLog(' Portfolio chart not initialized', 'warn');
        }
      } catch (err) {
        debugLog(`Error loading portfolio data: ${err.message}`, 'error');
      }
    }

    async function renderPortfolioTable() {
      const kpi = document.getElementById('portfolio-table-kpi-select')?.value || 'ctr_28d';
      const segments = ['site', 'money', 'money_tracked', 'landing', 'event', 'product', 'academy', 'blog', 'other', 'all_tracked'];
      const segmentLabels = {
        'site': 'Entire site',
        'money': 'Money Pages',
        'money_tracked': 'Money Pages (tracked)',
        'landing': 'Landing',
        'event': 'Event',
        'product': 'Product',
        'blog': 'Blog Pages',
        'academy': 'Academy',
        'other': 'Other (non-money)',
        'all_tracked': 'All tracked'
      };
      const segmentIndentPx = {
        // Only indent TRUE roll-ups (sub-segments that sum to the parent)
        'landing': 18,
        'event': 18,
        'product': 18,
        // Subtotal (subset of Entire site)
        'all_tracked': 18
      };
      
      // Map UI KPI to portfolio_segment_metrics_28d field
      const kpiFieldMap = {
        'ctr_28d': 'ctr_28d',
        'clicks_28d': 'clicks_28d',
        'impressions_28d': 'impressions_28d',
        'avg_position': 'position_28d',
        'ai_citations': 'ai_citations_28d',
        'ai_overview': 'ai_overview_present_count'
      };
      
      const kpiField = kpiFieldMap[kpi];
      if (!kpiField && kpi !== 'ai_citations' && kpi !== 'ai_overview') {
        debugLog(` KPI ${kpi} not supported in segment metrics`, 'warn');
        return;
      }
      
      try {
        const propertyUrl = (window.getPropertyUrl ? window.getPropertyUrl() : '') || localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (!propertyUrl) {
          debugLog(' No property URL found for portfolio table', 'warn');
          return;
        }

        // Portfolio no longer uses a separate "Scope" control (too nuanced).
        // Instead we expose explicit tracked segments. Map UI segment -> (db segment, db scope).
        const mapSegmentToDb = (segUi) => {
          if (segUi === 'money_tracked') return { segment: 'money', scope: 'active_cycles_only' };
          if (segUi === 'all_tracked') return { segment: 'all_tracked', scope: 'active_cycles_only' };
          if (segUi === 'site') return { segment: 'site', scope: 'all_pages' };
          return { segment: segUi, scope: 'all_pages' };
        };
        
        // Calculate date range (last 13 months to get previous month for trend)
        const toDate = new Date();
        const fromDate = new Date();
        fromDate.setMonth(fromDate.getMonth() - 13);
        
        // Fetch data for all segments
        const allData = {};
        for (const segment of segments) {
          const dbMap = mapSegmentToDb(segment);
          const params = new URLSearchParams({ 
            siteUrl: propertyUrl,
            segment: dbMap.segment,
            from: fromDate.toISOString(),
            to: toDate.toISOString(),
            order: 'desc' // Latest first
          });
          params.set('scope', dbMap.scope);
          const response = await fetch(apiUrl(`/api/supabase/get-portfolio-segment-metrics?${params}`));
          
          if (response.ok) {
            const data = await response.json();
            allData[segment] = data.metrics || [];
          } else {
            allData[segment] = [];
          }
        }

        const monthKeyFromDate = (d) => {
          const y = d.getFullYear();
          const m = String(d.getMonth() + 1).padStart(2, '0');
          return `${y}-${m}`;
        };
        const monthStartDateFromKey = (monthKey) => {
          // monthKey: YYYY-MM
          const [yStr, mStr] = String(monthKey).split('-');
          const y = parseInt(yStr, 10);
          const m = parseInt(mStr, 10);
          return new Date(y, (m || 1) - 1, 1);
        };
        const monthEndDateFromKey = (monthKey) => {
          const start = monthStartDateFromKey(monthKey);
          return new Date(start.getFullYear(), start.getMonth() + 1, 0);
        };
        const toDateOnlyStr = (d) => {
          // yyyy-mm-dd in local timezone
          const y = d.getFullYear();
          const m = String(d.getMonth() + 1).padStart(2, '0');
          const day = String(d.getDate()).padStart(2, '0');
          return `${y}-${m}-${day}`;
        };
        const pickLatestSnapshotInMonth = (snapshots) => {
          if (!snapshots || snapshots.length === 0) return null;
          // Prefer latest date_end, tie-break by created_at (handles backfills where created_at is "now")
          return snapshots
            .slice()
            .sort((a, b) => {
              const aDateEnd = a?.date_end ? new Date(a.date_end) : null;
              const bDateEnd = b?.date_end ? new Date(b.date_end) : null;
              const aKey = aDateEnd && !isNaN(aDateEnd.getTime()) ? aDateEnd.getTime() : -Infinity;
              const bKey = bDateEnd && !isNaN(bDateEnd.getTime()) ? bDateEnd.getTime() : -Infinity;
              if (bKey !== aKey) return bKey - aKey;
              return new Date(b.created_at) - new Date(a.created_at);
            })[0];
        };

        // Generate last 12 months (LOCAL month keys; avoid toISOString() timezone shifting)
        const months = [];
        const today = new Date();
        for (let i = 11; i >= 0; i--) {
          const date = new Date(today.getFullYear(), today.getMonth() - i, 1);
          months.push(monthKeyFromDate(date)); // YYYY-MM
        }

        // Build table
        const table = document.getElementById('portfolio-monthly-table');
        if (!table) return;

        // Clear existing content
        const thead = table.querySelector('thead tr');
        const tbody = table.querySelector('tbody');
        const segmentTh = document.createElement('th');
        segmentTh.style.cssText = 'text-align: left; padding: 0.75rem; border-bottom: 2px solid var(--dark-border); font-weight: 600; background: rgba(55, 65, 81, 0.5); color: var(--dark-text);';
        segmentTh.textContent = 'Segment';
        segmentTh.title = 'Page segment: Filter metrics by page type';
        thead.innerHTML = '';
        thead.appendChild(segmentTh);
        tbody.innerHTML = '';

        // Add month headers
        months.forEach(month => {
          const th = document.createElement('th');
          th.style.cssText = 'text-align: center; padding: 0.75rem; border-bottom: 2px solid var(--dark-border); font-weight: 600; background: rgba(55, 65, 81, 0.5); color: var(--dark-text);';
          const monthDate = monthStartDateFromKey(month);
          const isCurrentMonth = month === monthKeyFromDate(today);
          th.textContent = monthDate.toLocaleDateString('en-GB', { month: 'short', year: 'numeric' }) + (isCurrentMonth ? '*' : '');
          th.title = `Value for ${monthDate.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' })}: Last snapshot from this month (rolling 28-day window)`;
          thead.appendChild(th);
        });

        // Add sparkline column
        const sparklineTh = document.createElement('th');
        sparklineTh.style.cssText = 'text-align: center; padding: 0.75rem; border-bottom: 2px solid var(--dark-border); font-weight: 600; background: rgba(55, 65, 81, 0.5); color: var(--dark-text);';
        sparklineTh.textContent = 'Trend';
        sparklineTh.title = 'Month-over-month change: Shows the difference between this month and the previous month ( = increase,  = decrease)';
        thead.appendChild(sparklineTh);

        // Formatting helpers
        const formatCountCompact = (n) => {
          const v = Number(n);
          if (!isFinite(v)) return '';
          const abs = Math.abs(v);
          // 0999 -> show full integer
          if (abs < 1000) return Math.round(v).toString();
          // Use compact for thousands+ (K/M/B). Keep it readable:
          // - 1 decimal for 1K9.9K
          // - 0 decimals for 10K999K
          // - 1 decimal for 1M+ so you can see 1.1M vs 1.4M
          const maxFractionDigits = abs >= 1_000_000 ? 1 : (abs < 10_000 ? 1 : 0);
          try {
            return new Intl.NumberFormat('en-GB', {
              notation: 'compact',
              compactDisplay: 'short',
              maximumFractionDigits: maxFractionDigits
            }).format(v);
          } catch (e) {
            // Fallback (older browsers): comma format
            return Math.round(v).toLocaleString();
          }
        };

        const formatCountFull = (n) => {
          const v = Number(n);
          if (!isFinite(v)) return '';
          return Math.round(v).toLocaleString('en-GB');
        };

        // Format value based on KPI (display)
        const formatValue = (value, kpiKey) => {
          if (value === null || value === undefined) return '';
          if (kpiKey === 'ctr_28d') {
            // CTR is stored as ratio (0-1), display as percentage
            return (parseFloat(value) * 100).toFixed(1) + '%';
          }
          if (kpiKey === 'clicks_28d' || kpiKey === 'impressions_28d' || kpiKey === 'ai_citations' || kpiKey === 'ai_overview') {
            // Counts - compact (K/M/B)
            return formatCountCompact(value);
          }
          if (kpiKey === 'avg_position') {
            // Position - 1 decimal
            return parseFloat(value).toFixed(1);
          }
          return parseFloat(value).toFixed(2);
        };

        // Add rows for each segment
        segments.forEach(segment => {
          const row = document.createElement('tr');
          row.style.cursor = 'help';
          
          // Segment name
          const segmentCell = document.createElement('td');
          segmentCell.style.cssText = 'padding: 0.75rem; border-bottom: 1px solid var(--dark-border); font-weight: 600; color: var(--dark-text);';
          segmentCell.textContent = segmentLabels[segment] || segment;
          if (segmentIndentPx[segment]) {
            segmentCell.style.paddingLeft = `${0.75 * 16 + segmentIndentPx[segment]}px`; // base 0.75rem + indent
            segmentCell.style.fontWeight = '500';
          }
          segmentCell.style.cursor = 'pointer';
          // Add tooltip based on segment
          const segmentTooltips = {
            'site': 'Entire site: all pages on the property (unfiltered)',
            'money': 'All commercial pages: landing pages, event pages, and product pages combined',
            'money_tracked': 'Only money pages (landing/event/product) that currently have an active optimisation task (planned/in_progress/monitoring)',
            'academy': 'Academy: single signup page only (/free-online-photography-course)',
            'other': 'Other (non-money): all pages that are not money pages, not blog posts, and not the Academy signup page',
            'landing': 'Landing pages: general commercial landing pages (not events or products)',
            'event': 'Event pages: photography workshop and course event pages',
            'product': 'Product pages: photography service and product pages',
            'blog': 'Blog pages: URLs containing /blog-on-photography/',
            'all_tracked': 'All pages that have active optimisation tasks tracking them'
          };
          segmentCell.title = segmentTooltips[segment] || segment;
          segmentCell.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (typeof openPortfolioSegmentUrlsModal === 'function') {
              openPortfolioSegmentUrlsModal(segment);
            }
          });
          row.appendChild(segmentCell);

          // Month values
          const monthValues = [];
          months.forEach(month => {
            const cell = document.createElement('td');
            cell.style.cssText = 'text-align: center; padding: 0.75rem; border-bottom: 1px solid var(--dark-border); color: var(--dark-text);';
            
            // Monthly KPI Tracker:
            // - For CLOSED months: prefer month-end snapshots (run_id=YYYY-MM, or date_end=last day of month)
            //   BUT if month-end snapshot has 0/null for the KPI, fall back to latest snapshot with actual data
            // - For CURRENT month: show the latest available snapshot in the month, but mark it as partial (*)
            const monthEnd = monthEndDateFromKey(month);
            const monthEndStr = toDateOnlyStr(monthEnd); // YYYY-MM-DD (local)
            const isCurrentMonth = month === monthKeyFromDate(today);
            
            // First, try to get month-end snapshots (preferred for closed months)
            const monthEndSnapshots = allData[segment]?.filter(s => {
              // Preferred: explicit month backfill snapshot
              if (s.run_id && s.run_id.match(/^\d{4}-\d{2}$/)) {
                return s.run_id === month;
              }
              // Otherwise: use date_end
              if (s.date_end) {
                const dStr = String(s.date_end).slice(0, 10); // YYYY-MM-DD
                const mStr = String(s.date_end).slice(0, 7);  // YYYY-MM
                // Current month: allow any snapshot within the month (we'll mark as partial later)
                if (isCurrentMonth) return mStr === month;
                // Closed months: only accept if date_end is the last day of the month
                return dStr === monthEndStr;
              }
              return false;
            });
            
            // Get the latest month-end snapshot
            let snapshot = monthEndSnapshots?.length > 0 ? pickLatestSnapshotInMonth(monthEndSnapshots) : null;
            
            // Helper function to check if snapshot has valid data for the KPI
            const hasValidData = (snap) => {
              if (!snap) return false;
              if (kpiField === 'impressions_28d') {
                return parseFloat(snap.impressions_28d || 0) > 0;
              } else if (kpiField === 'clicks_28d') {
                return parseFloat(snap.clicks_28d || 0) > 0;
              } else if (kpiField === 'position_28d') {
                return snap.position_28d !== null && snap.position_28d !== undefined && !isNaN(parseFloat(snap.position_28d));
              } else if (kpiField === 'ctr_28d') {
                return parseFloat(snap.ctr_28d || 0) > 0;
              } else if (kpiField === 'ai_citations_28d') {
                return parseInt(snap.ai_citations_28d || 0) > 0;
              } else if (kpiField === 'ai_overview_present_count') {
                return parseInt(snap.ai_overview_present_count || 0) > 0;
              }
              return true; // For other KPIs, assume any value is valid
            };
            
            // If month-end snapshot doesn't have valid data, fall back to latest snapshot in month with actual data
            if (snapshot && !hasValidData(snapshot) && !isCurrentMonth) {
              // Get all snapshots in the month (not just month-end)
              const allMonthSnapshots = allData[segment]?.filter(s => {
                if (s.run_id && s.run_id.match(/^\d{4}-\d{2}$/)) {
                  return s.run_id === month;
                }
                if (s.date_end) {
                  const mStr = String(s.date_end).slice(0, 7);  // YYYY-MM
                  return mStr === month;
                }
                // Fallback to created_at month
                if (s.created_at) {
                  const createdDate = new Date(s.created_at);
                  const mStr = `${createdDate.getFullYear()}-${String(createdDate.getMonth() + 1).padStart(2, '0')}`;
                  return mStr === month;
                }
                return false;
              });
              
              // Find the latest snapshot with valid data
              if (allMonthSnapshots && allMonthSnapshots.length > 0) {
                const validSnapshots = allMonthSnapshots.filter(hasValidData);
                if (validSnapshots.length > 0) {
                  snapshot = pickLatestSnapshotInMonth(validSnapshots);
                }
              }
              
              // If still no valid data, check early next month snapshots (GSC is always 2-3 days behind)
              // For ANY closed month, snapshots created in first 3 days of next month with date_end in next month
              // actually represent the previous month's end-of-month data
              if (!snapshot || !hasValidData(snapshot)) {
                const monthDate = monthStartDateFromKey(month);
                const nextMonth = new Date(monthDate);
                nextMonth.setMonth(nextMonth.getMonth() + 1);
                const nextMonthStr = monthKeyFromDate(nextMonth);
                
                // Look for snapshots in the first 3 days of next month with date_end in next month
                // These represent the previous month's data due to GSC 2-3 day delay
                const nextMonthSnapshots = allData[segment]?.filter(s => {
                  if (!s.created_at || !s.date_end) return false;
                  
                  const createdDate = new Date(s.created_at);
                  const dateEnd = new Date(s.date_end);
                  
                  // Validate dates are valid
                  if (isNaN(createdDate.getTime()) || isNaN(dateEnd.getTime())) return false;
                  
                  const dateEndMonth = monthKeyFromDate(dateEnd);
                  
                  // Must be created in first 3 days of next month AND have date_end in next month
                  // This ensures we get the snapshot that represents the previous month's end data
                  const isEarlyNextMonth = dateEndMonth === nextMonthStr && 
                                          createdDate.getDate() <= 3 &&
                                          createdDate.getMonth() === nextMonth.getMonth() &&
                                          createdDate.getFullYear() === nextMonth.getFullYear();
                  
                  return isEarlyNextMonth;
                });
                
                if (nextMonthSnapshots && nextMonthSnapshots.length > 0) {
                  const validNextMonthSnapshots = nextMonthSnapshots.filter(hasValidData);
                  if (validNextMonthSnapshots.length > 0) {
                    // Use the earliest date_end in next month (closest to previous month end)
                    // This represents the most recent data from the previous month
                    const sorted = validNextMonthSnapshots.sort((a, b) => {
                      const aDate = a.date_end ? new Date(a.date_end) : new Date(a.created_at);
                      const bDate = b.date_end ? new Date(b.date_end) : new Date(b.created_at);
                      return aDate - bDate; // Earliest first (closest to previous month end)
                    });
                    snapshot = sorted[0];
                  }
                }
              }
            }
            
            if (snapshot) {
              // Extract value based on KPI field
              let value = null;
              if (kpiField === 'ctr_28d') {
                value = parseFloat(snapshot.ctr_28d || 0);
              } else if (kpiField === 'clicks_28d') {
                value = parseFloat(snapshot.clicks_28d || 0);
              } else if (kpiField === 'impressions_28d') {
                value = parseFloat(snapshot.impressions_28d || 0);
              } else if (kpiField === 'position_28d') {
                // Handle position: check if it's null, undefined, or NaN
                if (snapshot.position_28d !== null && snapshot.position_28d !== undefined && !isNaN(parseFloat(snapshot.position_28d))) {
                  value = parseFloat(snapshot.position_28d);
                } else {
                  value = null;
                }
              } else if (kpiField === 'ai_citations_28d') {
                value = snapshot.ai_citations_28d ? parseInt(snapshot.ai_citations_28d) : 0;
              } else if (kpiField === 'ai_overview_present_count') {
                value = snapshot.ai_overview_present_count ? parseInt(snapshot.ai_overview_present_count) : 0;
              }
              
              if (value !== null && value !== undefined) {
                const formatted = formatValue(value, kpi);
                const formattedFull = (kpi === 'clicks_28d' || kpi === 'impressions_28d' || kpi === 'ai_citations' || kpi === 'ai_overview')
                  ? formatCountFull(value)
                  : formatted;
                monthValues.push(value);
                
                const isCurrentMonth = month === monthKeyFromDate(today);
                const monthEnd = monthEndDateFromKey(month);
                const snapshotEnd = snapshot.date_end ? new Date(snapshot.date_end) : null;
                const isPartialMonth = isCurrentMonth && snapshotEnd && !isNaN(snapshotEnd.getTime()) && snapshotEnd < monthEnd;
                
                // Build tooltip text
                const monthDate = monthStartDateFromKey(month);
                const monthName = monthDate.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' });
                let tooltipText = `${segmentLabels[segment]}: ${formattedFull} for ${monthName}`;
                if (formattedFull !== formatted) {
                  tooltipText += ` (shown as ${formatted})`;
                }
                if (isPartialMonth) {
                  tooltipText += ` (partial month: latest snapshot ends ${toDateOnlyStr(snapshotEnd)})`;
                }
                
                // Find previous month snapshot for trend
                const prevMonth = monthStartDateFromKey(month);
                prevMonth.setMonth(prevMonth.getMonth() - 1);
                const prevMonthStr = `${prevMonth.getFullYear()}-${String(prevMonth.getMonth() + 1).padStart(2, '0')}`;
                
                const prevMonthSnapshots = allData[segment]?.filter(s => {
                  // Try to match by run_id first (if it's in YYYY-MM format)
                  if (s.run_id && s.run_id.match(/^\d{4}-\d{2}$/)) {
                    return s.run_id === prevMonthStr;
                  }
                  // Otherwise match by date_end month
                  if (s.date_end) {
                    const dateEnd = new Date(s.date_end);
                    const dateEndMonth = `${dateEnd.getFullYear()}-${String(dateEnd.getMonth() + 1).padStart(2, '0')}`;
                    return dateEndMonth === prevMonthStr;
                  }
                  // Fallback to created_at month
                  const snapshotDate = new Date(s.created_at);
                  const snapshotMonth = `${snapshotDate.getFullYear()}-${String(snapshotDate.getMonth() + 1).padStart(2, '0')}`;
                  return snapshotMonth === prevMonthStr;
                });
                
                const prevSnapshot = prevMonthSnapshots?.length > 0
                  ? prevMonthSnapshots.sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0]
                  : null;
                
                // For current partial month, suppress month-over-month delta (comparison is misleading until month-end snapshot exists)
                if (!isPartialMonth) {
                  // Get previous month value - if no previous snapshot, treat as 0 (no data = baseline of 0)
                  let prevValue = null;
                  if (prevSnapshot) {
                    prevValue = kpiField === 'ctr_28d' ? parseFloat(prevSnapshot.ctr_28d || 0) :
                                kpiField === 'clicks_28d' ? parseFloat(prevSnapshot.clicks_28d || 0) :
                                kpiField === 'impressions_28d' ? parseFloat(prevSnapshot.impressions_28d || 0) :
                                kpiField === 'position_28d' ? (prevSnapshot.position_28d !== null && prevSnapshot.position_28d !== undefined && !isNaN(parseFloat(prevSnapshot.position_28d)) ? parseFloat(prevSnapshot.position_28d) : null) :
                                kpiField === 'ai_citations_28d' ? (prevSnapshot.ai_citations_28d ? parseInt(prevSnapshot.ai_citations_28d) : 0) :
                                kpiField === 'ai_overview_present_count' ? (prevSnapshot.ai_overview_present_count ? parseInt(prevSnapshot.ai_overview_present_count) : 0) : null;
                  }
                  
                  // If previous month had no data (null), treat it as 0 for delta calculation
                  // This means going from no data to having data is always a positive change
                  const prevValueForDelta = prevValue !== null && prevValue !== undefined ? prevValue : 0;
                  const delta = value - prevValueForDelta;
                  
                  // Determine indicator and color
                  // For position: lower is better, so delta < 0 is good (green )
                  // For all others: higher is better, so delta >= 0 is good (green )
                  let indicator, color;
                  if (kpi === 'avg_position') {
                    indicator = delta < 0 ? '' : (delta > 0 ? '' : '');
                    color = delta < 0 ? '#10b981' : (delta > 0 ? '#ef4444' : '#94a3b8');
                  } else {
                    // For AI citations and AI overview: if prevValue was null (no previous data), always show 
                    if ((kpi === 'ai_citations' || kpi === 'ai_overview') && (prevValue === null || prevValue === undefined)) {
                      indicator = '';
                      color = '#10b981';
                    } else {
                      indicator = delta >= 0 ? '' : '';
                      color = delta >= 0 ? '#10b981' : '#ef4444';
                    }
                  }
                    
                    // Format delta based on KPI
                    let deltaFormatted;
                    if (kpi === 'ctr_28d') {
                      // CTR stored as ratio (0-1). Render as percentage points delta.
                      deltaFormatted = Math.abs(delta * 100).toFixed(1) + 'pp';
                      cell.innerHTML = `${formatted} <span style="color: ${color};">${indicator} ${deltaFormatted}</span>`;
                      const changeText = (prevValue === null || prevValue === undefined) 
                        ? `New data (no previous month data)` 
                        : `Change from previous month: ${indicator} ${deltaFormatted}`;
                      tooltipText += ` | ${changeText}`;
                    } else if (kpi === 'avg_position') {
                      // For position: LOWER is better. So delta<0 => improvement (green ), delta>0 => worse (red ).
                      deltaFormatted = Math.abs(delta).toFixed(1);
                      // Use indicator and color already set above
                      // const posIndicator = delta < 0 ? '' : (delta > 0 ? '' : '');
                      // const posColor = delta < 0 ? '#10b981' : (delta > 0 ? '#ef4444' : '#94a3b8');
                      cell.innerHTML = `${formatted} <span style="color: ${color};">${indicator} ${deltaFormatted}</span>`;
                      const changeText = (prevValue === null || prevValue === undefined) 
                        ? `New data (no previous month data)` 
                        : `Change from previous month: ${indicator} ${deltaFormatted}`;
                      tooltipText += ` | ${changeText}`;
                    } else if (kpi === 'ai_citations' || kpi === 'ai_overview') {
                      // AI metrics are integers, show absolute change
                      deltaFormatted = formatCountCompact(Math.abs(delta));
                      // Use indicator and color already set above
                      // const actualIndicator = delta < 0 ? '' : '';
                      // const actualColor = delta < 0 ? '#10b981' : '#ef4444';
                      cell.innerHTML = `${formatted} <span style="color: ${color};">${indicator} ${deltaFormatted}</span>`;
                      const changeText = (prevValue === null || prevValue === undefined) 
                        ? `New data (no previous month data)` 
                        : `Change from previous month: ${indicator} ${deltaFormatted}`;
                      tooltipText += ` | ${changeText}`;
                    } else {
                      deltaFormatted = formatCountCompact(Math.abs(delta));
                      cell.innerHTML = `${formatted} <span style="color: ${color};">${indicator} ${deltaFormatted}</span>`;
                      const changeText = (prevValue === null || prevValue === undefined) 
                        ? `New data (no previous month data)` 
                        : `Change from previous month: ${indicator} ${deltaFormatted}`;
                      tooltipText += ` | ${changeText}`;
                    }
                } else {
                  // If partial month, show a subtle marker so big apparent drops don't look like a full-month collapse
                  cell.textContent = isPartialMonth ? `${formatted} *` : formatted;
                }
                
                // Add tooltip to cell
                cell.title = tooltipText;
              } else {
                cell.textContent = '';
                monthValues.push(null);
                const monthDate = monthStartDateFromKey(month);
                const monthName = monthDate.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' });
                cell.title = `${segmentLabels[segment]}: No data for ${monthName}`;
              }
            } else {
              cell.textContent = '';
              monthValues.push(null);
              const monthDate = monthStartDateFromKey(month);
              const monthName = monthDate.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' });
              cell.title = `${segmentLabels[segment]}: No data for ${monthName}`;
            }
            row.appendChild(cell);
          });

          // Sparkline (simple text representation)
          const sparklineCell = document.createElement('td');
          sparklineCell.style.cssText = 'text-align: center; padding: 0.75rem; border-bottom: 1px solid var(--dark-border); color: var(--dark-text); font-family: monospace;';
          const validValues = monthValues.filter(v => v !== null);
          if (validValues.length > 0) {
            const min = Math.min(...validValues);
            const max = Math.max(...validValues);
            const range = max - min || 1;
            const sparkline = monthValues.map(v => {
              if (v === null) return ' ';
              const height = Math.round(((v - min) / range) * 7);
              return ''[Math.min(height, 7)] || '';
            }).join('');
            sparklineCell.textContent = sparkline;
            sparklineCell.title = `${segmentLabels[segment]}: Trend visualization across 12 months. Higher bars indicate higher values.`;
          } else {
            sparklineCell.textContent = '';
            sparklineCell.title = `${segmentLabels[segment]}: No trend data available`;
          }
          row.appendChild(sparklineCell);

          tbody.appendChild(row);
        });

      } catch (err) {
        debugLog(`Error rendering portfolio table: ${err.message}`, 'error');
      }
    }

    // Load and render Money Pages KPI Tracker (last 28 days)
    window.loadAuditHistoryAndRenderKpis = async function(propertyUrl) {
      // Prevent multiple simultaneous calls
      if (window._loadingMoneyKpiTracker) {
        debugLog(' Money Pages KPI Tracker already loading, skipping duplicate call', 'warn');
        return;
      }
      
      window._loadingMoneyKpiTracker = true;
      
      try {
        debugLog(' Loading Money Pages KPI Tracker data...', 'info');
        
        if (!propertyUrl) {
          propertyUrl = (window.getPropertyUrl ? window.getPropertyUrl() : '') || localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
          if (!propertyUrl) {
            debugLog(' No property URL found for Money Pages KPI Tracker', 'warn');
            return;
          }
        }
        
        // Get selected metric (with fallback if selector doesn't exist yet)
        const metricSelect = document.getElementById('money-kpi-metric-select');
        if (!metricSelect) {
          debugLog(' Money KPI metric selector not found - will use default avgPosition', 'warn');
        }
        const selectedMetric = metricSelect?.value || 'avgPosition';
        
        // Map UI metric to database field
        const metricFieldMap = {
          'ctr': 'ctr_28d',
          'impressions': 'impressions_28d',
          'clicks': 'clicks_28d',
          'avgPosition': 'position_28d'
        };
        const dbField = metricFieldMap[selectedMetric] || 'position_28d';
        
        // Use the same date range logic as loadPortfolioData (last 365 days to ensure enough data for weekly bucketing)
        const toDate = new Date();
        const fromDate = new Date();
        fromDate.setDate(fromDate.getDate() - 365);
        
        debugLog(` Money Pages KPI Tracker: Fetching data from ${fromDate.toISOString().split('T')[0]} to ${toDate.toISOString().split('T')[0]} (same as top charts)`, 'info');
        
        // Fetch data for all money page segments
        const segments = ['money', 'landing', 'event', 'product'];
        const segmentData = {};
        const rawMetricsBySegment = {};
        
        const dateKeyUTC = (d) => {
          const y = d.getUTCFullYear();
          const m = String(d.getUTCMonth() + 1).padStart(2, '0');
          const day = String(d.getUTCDate()).padStart(2, '0');
          return `${y}-${m}-${day}`;
        };
        const mondayKeyUTCFromDate = (d) => {
          const dayOfWeek = d.getUTCDay(); // 0=Sun..6=Sat
          const diff = d.getUTCDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1);
          const monday = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
          monday.setUTCDate(diff);
          return dateKeyUTC(monday);
        };
        const safeDateFrom = (v) => {
          if (!v) return null;
          const d = new Date(v);
          return isNaN(d.getTime()) ? null : d;
        };
        const metricDateForPeriod = (m) => {
          // Prefer date_end (actual GSC period). Fall back to run_id (weekly snapshot) or created_at.
          return safeDateFrom(m?.date_end) || (m?.run_id && /^\d{4}-\d{2}-\d{2}$/.test(m.run_id) ? safeDateFrom(m.run_id) : null) || safeDateFrom(m?.created_at);
        };
        
        for (const segment of segments) {
          const params = new URLSearchParams({
            siteUrl: propertyUrl,
            segment,
            scope: 'active_cycles_only',
            from: fromDate.toISOString(),
            to: toDate.toISOString(),
            order: 'asc'
          });
          
          const response = await fetch(apiUrl(`/api/supabase/get-portfolio-segment-metrics?${params}`));
          if (response.ok) {
            const data = await response.json();
            rawMetricsBySegment[segment] = Array.isArray(data.metrics) ? data.metrics : [];
            // Store raw metrics for bucketing (same approach as loadPortfolioData)
            segmentData[segment] = (data.metrics || []).map(m => ({
              metric: m,
                value: dbField === 'ctr_28d' ? parseFloat(m.ctr_28d || 0) :
                       dbField === 'position_28d' ? (m.position_28d !== null && m.position_28d !== undefined && !isNaN(parseFloat(m.position_28d)) ? parseFloat(m.position_28d) : null) :
                       dbField === 'clicks_28d' ? parseFloat(m.clicks_28d || 0) :
                     dbField === 'impressions_28d' ? parseFloat(m.impressions_28d || 0) : null
            })).filter(d => d.value !== null && !isNaN(d.value));
            
            debugLog(` Fetched ${segmentData[segment].length} records for segment '${segment}'`, 'info');
          } else {
            debugLog(` Failed to fetch data for segment '${segment}': ${response.status}`, 'warn');
            segmentData[segment] = [];
            rawMetricsBySegment[segment] = [];
          }
        }
        
        // Determine the last valid GSC date (use window.lastGscTimeseriesDate if available)
        // This should match what the top charts use
        let lastValidGscDate = null;
        if (window.lastGscTimeseriesDate) {
          lastValidGscDate = new Date(window.lastGscTimeseriesDate);
          debugLog(` Using last GSC timeseries date: ${window.lastGscTimeseriesDate}`, 'info');
        } else {
          // Fallback: find the maximum date_end that appears in ALL segments (most recent complete date)
          // This ensures we only show dates where we have complete data for all segments
          const dateCounts = new Map();
          // segmentData entries are objects shaped like { metric: <raw row>, value: <number> }
          // Derive a safe date string for each record (prefer date_end as the actual GSC period).
          const safeDateStr = (m) => {
            try {
              if (!m) return null;
              if (m.date_end) {
                const d = new Date(m.date_end);
                return isNaN(d.getTime()) ? null : d.toISOString().split('T')[0];
              }
              // Weekly snapshot run_id (YYYY-MM-DD)
              if (m.run_id && /^\d{4}-\d{2}-\d{2}$/.test(m.run_id)) return m.run_id;
              if (m.created_at) {
                const d = new Date(m.created_at);
                return isNaN(d.getTime()) ? null : d.toISOString().split('T')[0];
              }
            } catch (e) {
              // ignore
            }
            return null;
          };

          segments.forEach(segment => {
            const segmentDates = new Set(
              (segmentData[segment] || [])
                .map(({ metric: m }) => safeDateStr(m))
                .filter(Boolean)
            );
            segmentDates.forEach(dateStr => {
              dateCounts.set(dateStr, (dateCounts.get(dateStr) || 0) + 1);
            });
          });
          
          // Only include dates that appear in ALL segments (complete data)
          const completeDates = Array.from(dateCounts.entries())
            .filter(([date, count]) => count === segments.length)
            .map(([date]) => new Date(date))
            .sort((a, b) => b - a);
          
          if (completeDates.length > 0) {
            lastValidGscDate = completeDates[0];
            if (lastValidGscDate) {
              debugLog(` Using max complete date_end (appears in all ${segments.length} segments): ${lastValidGscDate.toISOString().split('T')[0]}`, 'info');
            }
          } else {
            // If no date appears in all segments, use the most recent date that appears in at least 2 segments
            const partialDates = Array.from(dateCounts.entries())
              .filter(([date, count]) => count >= 2)
              .map(([date]) => new Date(date))
              .sort((a, b) => b - a);
            if (partialDates.length > 0) {
              lastValidGscDate = partialDates[0];
              if (lastValidGscDate) {
                debugLog(` Using max partial date_end (appears in at least 2 segments): ${lastValidGscDate.toISOString().split('T')[0]}`, 'info');
              }
            }
          }
        }
        
        // Additional safety: if lastValidGscDate is today or in the future, cap it to yesterday
        // This prevents showing data for dates that haven't completed yet
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        if (lastValidGscDate && lastValidGscDate >= today) {
          const yesterday = new Date(today);
          yesterday.setDate(yesterday.getDate() - 1);
          if (lastValidGscDate > yesterday) {
            lastValidGscDate = yesterday;
            debugLog(` Capped lastValidGscDate to yesterday: ${lastValidGscDate.toISOString().split('T')[0]}`, 'info');
          }
        }
        
        // If we still don't have a valid date, or if the date is Dec 22 but top charts show Dec 21,
        // explicitly cap to Dec 21 to match top charts behavior
        if (!lastValidGscDate) {
          // If we still don't have a valid date, try to use window.lastGscTimeseriesDate as fallback
          if (window.lastGscTimeseriesDate) {
            lastValidGscDate = new Date(window.lastGscTimeseriesDate);
            if (lastValidGscDate && lastValidGscDate.toISOString) {
              debugLog(` Using window.lastGscTimeseriesDate as fallback: ${lastValidGscDate.toISOString().split('T')[0]}`, 'info');
            }
          }
        }
        
        if (lastValidGscDate && lastValidGscDate.toISOString && lastValidGscDate.toISOString().split('T')[0] > '2025-12-21') {
          // Check if Dec 21 data exists in any segment
          const hasDec21Data = segments.some(segment => 
            segmentData[segment].some(({ metric: m }) => {
              const dateEnd = m.date_end ? new Date(m.date_end).toISOString().split('T')[0] : null;
              return dateEnd === '2025-12-21';
            })
          );
          if (hasDec21Data) {
            lastValidGscDate = new Date('2025-12-21');
            debugLog(` Explicitly capping to Dec 21 to match top charts: ${lastValidGscDate.toISOString().split('T')[0]}`, 'info');
          }
        }
        
        // Bucket data by week (Monday start) like the top charts
        // Use date_end for the actual GSC data period, but bucket into weeks
        // Only include data where date_end <= lastValidGscDate
        const weeklyBuckets = new Map(); // key: Monday date (YYYY-MM-DD), value: Map<segment, {value, date_end}>
        
        segments.forEach(segment => {
          segmentData[segment].forEach(({ metric: m, value }) => {
            // Use the same date logic as loadPortfolioData for weekly bucketing
            // For weekly: only use actual weekly snapshots (run_id in YYYY-MM-DD format)
            if (m.run_id && m.run_id.match(/^\d{4}-\d{2}$/)) {
              // Skip monthly backfilled data in weekly view (same as loadPortfolioData)
              return;
            }
            
            // Determine date for bucketing (prefer date_end)
            const dateForBucket = metricDateForPeriod(m);
            
            if (!dateForBucket || isNaN(dateForBucket.getTime())) {
              return; // Skip invalid dates
            }
            
            // Filter out data beyond the last valid GSC date
            const dateStr = dateKeyUTC(dateForBucket);
            const lastValidDateStr = lastValidGscDate ? lastValidGscDate.toISOString().split('T')[0] : null;
            if (lastValidDateStr && dateStr > lastValidDateStr) {
              return; // Skip this record
            }
            
            // Calculate Monday of the week (UTC)
            const mondayKey = mondayKeyUTCFromDate(dateForBucket);
            
            if (!weeklyBuckets.has(mondayKey)) {
              weeklyBuckets.set(mondayKey, new Map());
            }
            
            const bucket = weeklyBuckets.get(mondayKey);
            // Keep the LAST snapshot in each week using period end first
            const comparisonDate = metricDateForPeriod(m) || safeDateFrom(m.created_at) || dateForBucket;
            if (!bucket.has(segment) || comparisonDate > bucket.get(segment).date) {
              bucket.set(segment, {
                value: value,
                date: comparisonDate
              });
            }
          });
        });
        
        // Get all unique week dates (Mondays) and sort them
        const sortedWeekDates = Array.from(weeklyBuckets.keys()).sort();
        
        if (sortedWeekDates.length === 0) {
          debugLog(' No data found for Money Pages KPI Tracker', 'warn');
          return;
        }
        
        // Build chart data
        const segmentLabels = {
          'money': 'All',
          'landing': 'Landing',
          'event': 'Event',
          'product': 'Product'
        };
        
        const segmentColors = {
          'money': '#3b82f6',    // Blue
          'landing': '#10b981',  // Green
          'event': '#f59e0b',   // Orange/Yellow
          'product': '#ef4444'   // Red
        };
        
        const chartData = {
          labels: sortedWeekDates.map(mondayStr => {
            const date = new Date(mondayStr + 'T00:00:00Z');
            return date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short' });
          }),
          datasets: segments.map(segment => {
            const data = sortedWeekDates.map(mondayStr => {
              const bucket = weeklyBuckets.get(mondayStr);
              const segmentBucket = bucket?.get(segment);
              return segmentBucket ? segmentBucket.value : null;
            });
            
            return {
              label: segmentLabels[segment],
              data: data,
              borderColor: segmentColors[segment],
              backgroundColor: segmentColors[segment] + '20',
              borderWidth: 2,
              fill: false,
              tension: 0.4,
              pointRadius: 4,
              pointHoverRadius: 6
            };
          })
        };
        
        // Render chart
        const canvas = document.getElementById('money-kpi-sparkline');
        if (canvas) {
          // Destroy existing chart if it exists (check both window variable and Chart.js registry)
          if (window.moneyKpiChart) {
            try {
              window.moneyKpiChart.destroy();
            } catch (e) {
              debugLog(`Error destroying window.moneyKpiChart: ${e.message}`, 'warn');
            }
            window.moneyKpiChart = null;
          }
          
          // Also check Chart.js registry for any chart on this canvas
          if (typeof Chart !== 'undefined' && Chart.getChart) {
            const existingChart = Chart.getChart(canvas);
            if (existingChart) {
              try {
                existingChart.destroy();
                debugLog('Destroyed existing Chart.js instance from registry for money-kpi-sparkline', 'info');
              } catch (e) {
                debugLog(`Error destroying chart from registry: ${e.message}`, 'warn');
              }
            }
          }
          
          const ctx = canvas.getContext('2d');
          
          window.moneyKpiChart = new Chart(ctx, {
            type: 'line',
            data: chartData,
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  display: true,
                  position: 'top'
                },
                tooltip: {
                  mode: 'index',
                  intersect: false
                }
              },
              scales: {
                x: {
                  display: true,
                  title: {
                    display: true,
                    text: 'Month'
                  }
                },
                y: {
                  display: true,
                  title: {
                    display: true,
                    text: selectedMetric === 'avgPosition' ? 'Avg Position' :
                          selectedMetric === 'ctr' ? 'CTR (%)' :
                          selectedMetric === 'impressions' ? 'Impressions' :
                          'Clicks'
                  }
                }
              }
            }
          });
        }
        
        // Render table
        const table = document.getElementById('money-kpi-table');
        if (table) {
          const thead = table.querySelector('thead tr');
          const tbody = table.querySelector('tbody');
          
          // Clear existing content
          thead.innerHTML = '';
          tbody.innerHTML = '';
          
          // Add header row
          const segmentHeader = document.createElement('th');
          segmentHeader.textContent = 'Segment ';
          segmentHeader.style.cssText = 'padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0; background: #f1f5f9; font-weight: 600;';
          thead.appendChild(segmentHeader);
          
          sortedWeekDates.forEach(mondayStr => {
            const th = document.createElement('th');
            const date = new Date(mondayStr);
            th.textContent = date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short' });
            th.style.cssText = 'padding: 0.75rem; text-align: center; border-bottom: 2px solid #e2e8f0; background: #f1f5f9; font-weight: 600;';
            thead.appendChild(th);
          });
          
          const trendHeader = document.createElement('th');
          trendHeader.textContent = 'Trend';
          trendHeader.style.cssText = 'padding: 0.75rem; text-align: center; border-bottom: 2px solid #e2e8f0; background: #f1f5f9; font-weight: 600;';
          thead.appendChild(trendHeader);
          
          // Add data rows
          segments.forEach(segment => {
            const row = document.createElement('tr');
            
            // Segment name
            const segmentCell = document.createElement('td');
            segmentCell.textContent = segmentLabels[segment];
            segmentCell.style.cssText = 'padding: 0.75rem; border-bottom: 1px solid #e2e8f0; font-weight: 600;';
            row.appendChild(segmentCell);
            
            // Data cells - use weekly buckets
            const values = sortedWeekDates.map(mondayStr => {
              const bucket = weeklyBuckets.get(mondayStr);
              const segmentBucket = bucket?.get(segment);
              return segmentBucket ? segmentBucket.value : null;
            });
            
            values.forEach((value, idx) => {
              const cell = document.createElement('td');
              if (value !== null) {
                if (selectedMetric === 'avgPosition') {
                  cell.textContent = value.toFixed(1) + '-';
                } else if (selectedMetric === 'ctr') {
                  cell.textContent = (value * 100).toFixed(2) + '%';
                } else {
                  cell.textContent = Math.round(value).toLocaleString();
                }
              }
              cell.style.cssText = 'padding: 0.75rem; text-align: center; border-bottom: 1px solid #e2e8f0;';
              row.appendChild(cell);
            });
            
            // Trend cell
            const trendCell = document.createElement('td');
            const validValues = values.filter(v => v !== null);
            if (validValues.length >= 2) {
              const first = validValues[0];
              const last = validValues[validValues.length - 1];
              const change = last - first;
              const changePercent = first !== 0 ? ((change / first) * 100) : 0;
              
              let trendText = ' 0.0';
              let trendClass = 'kpi-trend-flat';
              
              if (Math.abs(change) > 0.01) {
                if (selectedMetric === 'avgPosition') {
                  // For position, lower is better, so negative change is good
                  trendText = change < 0 ? ` ${Math.abs(change).toFixed(1)}` : ` ${change.toFixed(1)}`;
                  trendClass = change < 0 ? 'kpi-trend-up' : 'kpi-trend-down';
                } else {
                  trendText = change > 0 ? ` ${changePercent.toFixed(1)}%` : ` ${Math.abs(changePercent).toFixed(1)}%`;
                  trendClass = change > 0 ? 'kpi-trend-up' : 'kpi-trend-down';
                }
              }
              
              trendCell.innerHTML = `<span class="${trendClass}">${trendText}</span>`;
            } else {
              trendCell.textContent = '';
            }
            trendCell.style.cssText = 'padding: 0.75rem; text-align: center; border-bottom: 1px solid #e2e8f0;';
            row.appendChild(trendCell);
            
            tbody.appendChild(row);
          });
        }

        // NOTE: Do NOT render Money Pages Performance Trends from portfolio segment snapshots here.
        // It causes a stale render then flip on page load because the KPI loader later re-renders
        // the charts from GSC timeseries (our canonical source). Trends are now rendered only from
        // `loadAuditHistoryAndRenderKpis()` using `gsc_timeseries`.
        
        debugLog(' Money Pages KPI Tracker rendered', 'success');
        
        // Wire up metric selector after rendering
        if (typeof window.wireMoneyKpiMetricSelector === 'function') {
          window.wireMoneyKpiMetricSelector();
        }
      } catch (err) {
        debugLog(`Error loading Money Pages KPI Tracker: ${err.message}`, 'error');
        console.error(err);
      } finally {
        window._loadingMoneyKpiTracker = false;
      }
    };

    // Wire up Money KPI metric selector
    window.wireMoneyKpiMetricSelector = function() {
      const metricSelect = document.getElementById('money-kpi-metric-select');
      if (metricSelect) {
        // Remove any existing listeners by cloning the element
        const newSelect = metricSelect.cloneNode(true);
        metricSelect.parentNode.replaceChild(newSelect, metricSelect);
        
        newSelect.addEventListener('change', () => {
          const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
          if (propertyUrl && typeof window.loadAuditHistoryAndRenderKpis === 'function') {
            debugLog(` Money KPI metric changed to: ${newSelect.value}`, 'info');
            window.loadAuditHistoryAndRenderKpis(propertyUrl);
          }
        });
        debugLog(' Money KPI metric selector wired up', 'success');
      } else {
        debugLog(' Money KPI metric selector not found', 'warn');
      }
    };

    // Wire up Portfolio controls
    function wirePortfolioControls() {
      const kpiSelect = document.getElementById('portfolio-kpi-select');
      const segmentSelect = document.getElementById('portfolio-segment-select');
      const timeGrain = document.getElementById('portfolio-time-grain');
      const tableKpiSelect = document.getElementById('portfolio-table-kpi-select');

      const updateChart = () => {
        if (typeof loadPortfolioData === 'function') {
          loadPortfolioData();
        }
      };

      if (kpiSelect) kpiSelect.addEventListener('change', updateChart);
      if (segmentSelect) {
        segmentSelect.addEventListener('change', () => {
          updateChart();
        });
      }
      if (timeGrain) timeGrain.addEventListener('change', updateChart);
      if (tableKpiSelect) {
        tableKpiSelect.addEventListener('change', () => {
          if (typeof renderPortfolioTable === 'function') {
            renderPortfolioTable();
          }
        });
      }
    }

    // Calculate and save portfolio segment snapshots (Phase 3a - Using gsc_page_metrics_28d)
    async function calculateAndSavePortfolioSegmentSnapshots(runId, siteUrl, dateStart, dateEnd, pageTotalsByKey) {
      try {
        debugLog(' Calculating portfolio segment snapshots...', 'info');
        
        // If pageTotalsByKey is not available, fetch from Supabase
        let pageMetrics = new Map();
        if (!pageTotalsByKey || pageTotalsByKey.size === 0) {
          debugLog(' pageTotalsByKey not available, fetching from Supabase...', 'info');
          try {
            const response = await fetch(apiUrl(`/api/supabase/get-gsc-page-metrics?runId=${encodeURIComponent(runId)}&siteUrl=${encodeURIComponent(siteUrl)}&dateStart=${dateStart}&dateEnd=${dateEnd}`));
            if (response.ok) {
              const data = await response.json();
              if (data.pages && data.pages.length > 0) {
                let positionCount = 0;
                let positionSum = 0;
                data.pages.forEach(page => {
                  const key = normalizeGscPageKey(page.page_url);
                  // Handle position: check if it's null, undefined, or NaN (but allow 0 as valid)
                  let position = null;
                  if (page.position_28d !== null && page.position_28d !== undefined) {
                    const parsed = parseFloat(page.position_28d);
                    if (!isNaN(parsed) && isFinite(parsed)) {
                      position = parsed;
                    }
                  }
                  if (position !== null) {
                    positionCount++;
                    positionSum += position;
                  }
                  pageMetrics.set(key, {
                    url: page.page_url,
                    clicks: parseFloat(page.clicks_28d) || 0,
                    impressions: parseFloat(page.impressions_28d) || 0,
                    ctr: parseFloat(page.ctr_28d) || 0,
                    position: position
                  });
                });
                debugLog(` Fetched ${pageMetrics.size} pages from Supabase (${positionCount} with position, avg=${positionCount > 0 ? (positionSum / positionCount).toFixed(2) : 'N/A'})`, 'success');
              }
            }
          } catch (fetchError) {
            debugLog(` Error fetching page metrics from Supabase: ${fetchError.message}`, 'warn');
          }
        } else {
          pageMetrics = pageTotalsByKey;
        }
        
        if (pageMetrics.size === 0) {
          debugLog(' No page metrics available for segment snapshots', 'warn');
          return;
        }
        
        // Get tracked tasks (active cycles) for all_tracked and active_cycles_only scope.
        const trackedTaskUrls = new Set();
        try {
          const tasksResponse = await fetch(apiUrl('/api/optimisation/status?includeDeleted=false'));
          if (tasksResponse.ok) {
            const { tasks } = await tasksResponse.json();
            if (tasks && tasks.length > 0) {
              tasks
                .filter(t => t.status && !['done', 'cancelled', 'deleted'].includes(t.status))
                .forEach(task => {
                if (task.target_url) {
                  const normalizedUrl = normalizeGscPageKey(task.target_url);
                  trackedTaskUrls.add(normalizedUrl);
                }
              });
            }
          }
        } catch (taskError) {
          debugLog(` Error fetching tasks for all_tracked segment: ${taskError.message}`, 'warn');
        }
        
        // Classify pages by segment for BOTH scopes:
        // - all_pages: all pages in the segment
        // - active_cycles_only: only pages currently being tracked by active optimisation tasks
        const segmentPagesAll = {
          site: [],
          money: [],
          academy: [],
          landing: [],
          event: [],
          product: [],
          blog: [],
          other: [],
          all_tracked: []
        };
        const segmentPagesActive = {
          site: [],
          money: [],
          academy: [],
          landing: [],
          event: [],
          product: [],
          blog: [],
          other: [],
          all_tracked: []
        };
        
        const academyKey = normalizeGscPageKey('https://www.alanranger.com/free-online-photography-course');
        
        pageMetrics.forEach((metrics, normalizedKey) => {
          const pageUrl = metrics.url;
          if (!pageUrl) return;
          
          // Whole-site segment always includes everything.
          segmentPagesAll.site.push(metrics);

          // Blog segment: URLs containing /blog-on-photography/
          const pageUrlLower = String(pageUrl).toLowerCase();
          const isBlog = pageUrlLower.includes('/blog-on-photography/');
          if (isBlog) {
            segmentPagesAll.blog.push(metrics);
          }
          
          // Academy segment: single signup page only
          if (normalizedKey === academyKey) {
            segmentPagesAll.academy.push(metrics);
          }

          // Money Pages segments should match Money Pages classifier (exclude blogs/support/system).
          const moneyClass = (typeof classifyMoneyPage === 'function')
            ? classifyMoneyPage(pageUrl)
            : { isMoney: false, segmentType: null };
          const isMoney = !!moneyClass.isMoney;
          const specificSegment = isMoney ? moneyClass.segmentType : null;
          const isOther = !isMoney && !isBlog && normalizedKey !== academyKey;

          // All pages scope
          if (specificSegment && segmentPagesAll[specificSegment]) segmentPagesAll[specificSegment].push(metrics);
          if (specificSegment && segmentPagesAll.money) segmentPagesAll.money.push(metrics); // money = aggregate of landing+event+product
          if (isOther) segmentPagesAll.other.push(metrics);
          if (trackedTaskUrls.has(normalizedKey)) segmentPagesAll.all_tracked.push(metrics); // tracked subset across the whole site

          // Active cycles only scope (only pages that are tracked)
          if (trackedTaskUrls.has(normalizedKey)) {
            segmentPagesActive.site.push(metrics); // tracked subset across the whole site
            if (isBlog) segmentPagesActive.blog.push(metrics);
            if (normalizedKey === academyKey) segmentPagesActive.academy.push(metrics);
            if (specificSegment && segmentPagesActive[specificSegment]) segmentPagesActive[specificSegment].push(metrics);
            if (specificSegment && segmentPagesActive.money) segmentPagesActive.money.push(metrics);
            if (isOther) segmentPagesActive.other.push(metrics);
            segmentPagesActive.all_tracked.push(metrics);
          }
        });
        
        // Fetch AI citations and AI overview data from keyword_rankings.
        // IMPORTANT: do NOT overwrite existing portfolio AI fields with zeros if no keyword_rankings exist
        // for this date (common due to GSC lag vs "ranking audit" date). If no data found, we omit AI fields
        // and the save endpoint will preserve existing DB values.
        const aiMetricsBySegment = {
          site: { citations: 0, overviewCount: 0 },
          money: { citations: 0, overviewCount: 0 },
          academy: { citations: 0, overviewCount: 0 },
          landing: { citations: 0, overviewCount: 0 },
          event: { citations: 0, overviewCount: 0 },
          product: { citations: 0, overviewCount: 0 },
          blog: { citations: 0, overviewCount: 0 },
          other: { citations: 0, overviewCount: 0 },
          all_tracked: { citations: 0, overviewCount: 0 }
        };
        let includeAiFields = false;
        let aiAuditDateUsed = null;
        
        try {
          const candidates = [];
          const addCandidate = (d) => {
            const s = d ? String(d).slice(0, 10) : '';
            if (s && !candidates.includes(s)) candidates.push(s);
          };
          // 1) Prefer last Ranking & AI run date (localStorage rankingAiData.timestamp)
          try {
            const local = localStorage.getItem('rankingAiData');
            if (local) {
              const parsed = JSON.parse(local);
              addCandidate(parsed?.timestamp ? String(parsed.timestamp).split('T')[0] : null);
            }
          } catch (e) {
            // ignore
          }
          // 2) Today's date (Ranking & AI save uses "today")
          addCandidate(new Date().toISOString().split('T')[0]);
          // 3) Fallback: dateEnd (GSC window end date; often ~2d behind)
          addCandidate(dateEnd);

          for (const auditDate of candidates) {
            const keywordsResponse = await fetch(apiUrl(`/api/supabase/get-keyword-rankings?auditDate=${auditDate}&propertyUrl=${encodeURIComponent(siteUrl)}`));
            if (!keywordsResponse.ok) continue;
            const keywordsData = await keywordsResponse.json();
            if (keywordsData.keywords && keywordsData.keywords.length > 0) {
              includeAiFields = true;
              aiAuditDateUsed = auditDate;
              // AI metrics are keyword-driven, but we attribute citations by the ACTUAL cited URLs (not best_url).
              // This gives a true picture of which page segments are being cited in AI Overviews.
              const normalizeUrlForMatch = (url) => {
                if (!url) return '';
                let u = String(url);
                u = u.split('?')[0];
                u = u.split('#')[0];
                u = u.replace(/\/$/, '');
                return u.toLowerCase();
              };

              const extractAlanCitedUrls = (keyword) => {
                const raw = keyword?.ai_alan_citations;
                if (!raw || !Array.isArray(raw)) return [];
                return raw
                  .map(v => {
                    if (!v) return null;
                    if (typeof v === 'string') return v;
                    if (typeof v === 'object' && v.url) return v.url;
                    return null;
                  })
                  .filter(Boolean);
              };

              const inferSegmentsFromCitedUrl = (citedUrl) => {
                const u = normalizeUrlForMatch(citedUrl);
                if (!u || !u.includes('alanranger.com')) return [];
                if (u.includes('/free-online-photography-course')) return ['academy'];
                if (u.includes('/blog-on-photography/')) return ['blog'];

                // Money pages only (landing/event/product)
                if (typeof classifyMoneyPage === 'function') {
                  const mc = classifyMoneyPage(citedUrl);
                  if (mc && mc.isMoney && mc.segmentType) {
                    return [mc.segmentType, 'money']; // include money rollup
                  }
                }
                return ['other'];
              };

              keywordsData.keywords.forEach(keyword => {
                const citations = parseInt(keyword.ai_alan_citations_count) || 0;
                const hasOverview = keyword.has_ai_overview === true || keyword.ai_overview_present_any === true;
                
                // Entire site = keyword-level totals (what the Ranking & AI summary shows)
                aiMetricsBySegment.site.citations += citations;
                if (hasOverview) aiMetricsBySegment.site.overviewCount += 1;

                // Attribute citations by cited URLs (can span multiple segments per keyword)
                const citedUrls = extractAlanCitedUrls(keyword);
                const segsForKeyword = new Set();
                const segsTrackedForKeyword = new Set();

                citedUrls.forEach(citedUrl => {
                  const segs = inferSegmentsFromCitedUrl(citedUrl); // may include 'money' rollup
                  segs.forEach(seg => {
                    if (aiMetricsBySegment[seg]) {
                      aiMetricsBySegment[seg].citations += 1; // 1 per cited URL
                      segsForKeyword.add(seg);
                    }
                  });

                  // all_tracked: only if the cited URL is an actively tracked task URL
                  const normKey = normalizeGscPageKey(citedUrl);
                  if (trackedTaskUrls.has(normKey)) {
                    aiMetricsBySegment.all_tracked.citations += 1;
                    segsTrackedForKeyword.add('all_tracked');
                  }
                });

                // Overview keyword counts: count keyword once per segment it appears in
                if (hasOverview) {
                  segsForKeyword.forEach(seg => {
                    if (aiMetricsBySegment[seg]) aiMetricsBySegment[seg].overviewCount += 1;
                  });
                  if (segsTrackedForKeyword.size > 0) {
                    aiMetricsBySegment.all_tracked.overviewCount += 1;
                  }
                }
              });

              // Reconcile: ai_alan_citations_count totals can exceed captured cited URL list length.
              // Put any remainder into Other so segment totals can still reconcile.
              const sumBase = (aiMetricsBySegment.landing?.citations || 0)
                + (aiMetricsBySegment.event?.citations || 0)
                + (aiMetricsBySegment.product?.citations || 0)
                + (aiMetricsBySegment.academy?.citations || 0)
                + (aiMetricsBySegment.blog?.citations || 0)
                + (aiMetricsBySegment.other?.citations || 0);
              const delta = (aiMetricsBySegment.site?.citations || 0) - sumBase;
              if (delta > 0) aiMetricsBySegment.other.citations += delta;

              debugLog(` Aggregated AI metrics from ${keywordsData.keywords.length} keywords (auditDate=${auditDate})`, 'success');
              break; // stop after first successful match
            }
          }
        } catch (aiError) {
          debugLog(` Error fetching AI metrics from keyword_rankings: ${aiError.message}`, 'warn');
        }
        if (!includeAiFields) {
          debugLog(' No keyword_rankings found for candidate AI audit dates; preserving existing portfolio AI fields (skipping AI write in Audit Scan).', 'info');
        }
        
        const buildSegmentRows = (segmentPages, scopeName) => {
        const segmentRows = [];
          ['site', 'money', 'academy', 'landing', 'event', 'product', 'blog', 'other', 'all_tracked'].forEach(segment => {
          const pages = segmentPages[segment];
          const aiMetrics = aiMetricsBySegment[segment] || { citations: 0, overviewCount: 0 };
          
          if (pages.length === 0) {
            // Still create a row with zeros (but include AI metrics if available)
            segmentRows.push({
              segment,
              pages_count: 0,
              clicks_28d: 0,
              impressions_28d: 0,
              ctr_28d: 0,
              position_28d: null,
              ai_citations_28d: includeAiFields ? aiMetrics.citations : undefined,
              ai_overview_present_count: includeAiFields ? aiMetrics.overviewCount : undefined
            });
            return;
          }
          
          // Aggregate: sum clicks and impressions
          const totalClicks = pages.reduce((sum, p) => sum + (parseFloat(p.clicks) || 0), 0);
          const totalImpressions = pages.reduce((sum, p) => sum + (parseFloat(p.impressions) || 0), 0);
          
          // Calculate CTR (weighted by impressions): clicks / impressions
          const ctr = totalImpressions > 0 ? totalClicks / totalImpressions : 0;
          
          // Calculate weighted average position
          let totalPositionWeight = 0;
          let totalPositionImpressions = 0;
          let positionCount = 0;
          pages.forEach(p => {
            const impressions = parseFloat(p.impressions) || 0;
            // Try multiple position field names (position, position_28d, avgPosition)
            // Note: When fetched from Supabase, position is stored in p.position (set from position_28d)
            // When from pageTotalsByKey, it might be in p.position or p.avgPosition
            // IMPORTANT: Check p.position first (set from position_28d when fetching from Supabase)
            let position = null;
            if (p.position !== null && p.position !== undefined) {
              const parsed = parseFloat(p.position);
              if (!isNaN(parsed) && isFinite(parsed)) {
                position = parsed;
              }
            } else if (p.position_28d !== null && p.position_28d !== undefined) {
              const parsed = parseFloat(p.position_28d);
              if (!isNaN(parsed) && isFinite(parsed)) {
                position = parsed;
              }
            } else if (p.avgPosition !== null && p.avgPosition !== undefined) {
              const parsed = parseFloat(p.avgPosition);
              if (!isNaN(parsed) && isFinite(parsed)) {
                position = parsed;
              }
            }
            
            if (position !== null && impressions > 0) {
              totalPositionWeight += position * impressions;
              totalPositionImpressions += impressions;
              positionCount++;
            }
          });
          const avgPosition = totalPositionImpressions > 0 ? totalPositionWeight / totalPositionImpressions : null;
          
          // Debug logging for position calculation
          debugLog(` Position calc for ${segment}: ${positionCount} pages with position (out of ${pages.length} total), total impressions=${totalPositionImpressions}, avgPosition=${avgPosition !== null ? avgPosition.toFixed(2) : 'N/A'}`, 'info');
          
          // Additional debug: log sample positions for first few pages (for all segments, not just money)
          if (pages.length > 0) {
            const samplePositions = pages.slice(0, 5).map(p => {
              const pos = p.position !== null && p.position !== undefined ? parseFloat(p.position) : 
                          (p.position_28d !== null && p.position_28d !== undefined ? parseFloat(p.position_28d) : 
                           (p.avgPosition !== null && p.avgPosition !== undefined ? parseFloat(p.avgPosition) : null));
              const imps = parseFloat(p.impressions) || 0;
              return `pos=${pos !== null ? pos.toFixed(1) : 'null'}, imps=${imps}`;
            }).join('; ');
            debugLog(` Sample positions for ${segment}: ${samplePositions}`, 'info');
            
            // Also log how many pages have null position
            const nullPositionCount = pages.filter(p => {
              const pos = p.position !== null && p.position !== undefined ? parseFloat(p.position) : 
                          (p.position_28d !== null && p.position_28d !== undefined ? parseFloat(p.position_28d) : 
                           (p.avgPosition !== null && p.avgPosition !== undefined ? parseFloat(p.avgPosition) : null));
              return pos === null || isNaN(pos) || pos <= 0;
            }).length;
            if (nullPositionCount > 0) {
              debugLog(` ${segment}: ${nullPositionCount} out of ${pages.length} pages have null/invalid position`, 'warn');
            }
          }
          
          segmentRows.push({
            segment,
            pages_count: pages.length,
            clicks_28d: totalClicks,
            impressions_28d: totalImpressions,
            ctr_28d: ctr, // Ratio (0-1)
            position_28d: avgPosition,
            ai_citations_28d: includeAiFields ? aiMetrics.citations : undefined,
            ai_overview_present_count: includeAiFields ? aiMetrics.overviewCount : undefined
          });
        });
          return { scopeName, segmentRows };
        };

        const scopesToSave = [
          buildSegmentRows(segmentPagesAll, 'all_pages'),
          buildSegmentRows(segmentPagesActive, 'active_cycles_only')
        ];

        for (const s of scopesToSave) {
          debugLog(` Saving ${s.segmentRows.length} segment snapshots to Supabase (scope=${s.scopeName})...`, 'info');
        const saveResponse = await fetch(apiUrl('/api/supabase/save-portfolio-segment-metrics'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            siteUrl,
            runId,
            dateStart,
            dateEnd,
              scope: s.scopeName,
              rows: s.segmentRows
          })
        });
        
        if (!saveResponse.ok) {
          const errorText = await saveResponse.text();
            throw new Error(`Failed to save segment snapshots (scope=${s.scopeName}): ${saveResponse.status} - ${errorText}`);
        }
        
        const saveResult = await saveResponse.json();
          debugLog(` Saved ${saveResult.inserted} portfolio segment snapshots to Supabase (scope=${s.scopeName})`, 'success');
        }
        
      } catch (err) {
        debugLog(`Error calculating portfolio segment snapshots: ${err.message}`, 'error');
        throw err;
      }
    }

    // Calculate and save portfolio snapshots (Phase 3 - Using gsc_page_metrics_28d)
    async function calculateAndSavePortfolioSnapshots(auditDate, windowDays = 28) {
      try {
        debugLog(' Calculating portfolio snapshots from gsc_page_metrics_28d...', 'info');
        
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (!propertyUrl) {
          debugLog(' No property URL found, skipping portfolio snapshots', 'warn');
          return;
        }
        
        // Calculate window dates (rolling 28d ending yesterday)
        const endDate = new Date();
        endDate.setDate(endDate.getDate() - 1); // Yesterday
        endDate.setHours(0, 0, 0, 0);
        const startDate = new Date(endDate);
        startDate.setDate(startDate.getDate() - 27); // 27 days back = 28 days total (inclusive)
        startDate.setHours(0, 0, 0, 0);
        
        const dateStartStr = startDate.toISOString().split('T')[0];
        const dateEndStr = endDate.toISOString().split('T')[0];
        
        // Aggregate page metrics by segment from Supabase
        debugLog(` Aggregating page metrics for run_id: ${auditDate}, date range: ${dateStartStr} to ${dateEndStr}`, 'info');
        
        const aggregateResponse = await fetch(apiUrl('/api/portfolio/aggregate-page-metrics'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            runId: auditDate,
            siteUrl: propertyUrl,
            dateStart: dateStartStr,
            dateEnd: dateEndStr
          })
        });
        
        if (!aggregateResponse.ok) {
          const errorText = await aggregateResponse.text();
          throw new Error(`Failed to aggregate page metrics: ${aggregateResponse.status} - ${errorText}`);
        }
        
        const aggregateData = await aggregateResponse.json();
        const segmentAggregates = aggregateData.segments || {};
        
        debugLog(` Aggregated ${aggregateData.pageCount || 0} pages into segments`, 'success');
        
        // Build snapshots array
        const snapshots = [];
        
        // Level KPIs (for Monthly KPI Tracker) - from aggregated page metrics
        const levelKpis = ['ctr_28d', 'clicks_28d', 'impressions_28d', 'avg_position'];
        const segments = ['money', 'landing', 'event', 'product', 'all_tracked'];
        const scopes = ['active_only']; // Start with active_only only
        
        for (const segment of segments) {
          const segmentData = segmentAggregates[segment];
          if (!segmentData) continue;
          
          for (const kpi of levelKpis) {
            let value = null;
            let unit = null;
            
            if (kpi === 'ctr_28d') {
              value = segmentData.ctr_28d || 0; // Already a ratio (0-1)
              unit = 'ratio';
            } else if (kpi === 'clicks_28d') {
              value = segmentData.clicks_28d || 0;
              unit = 'count';
            } else if (kpi === 'impressions_28d') {
              value = segmentData.impressions_28d || 0;
              unit = 'count';
            } else if (kpi === 'avg_position') {
              value = segmentData.avg_position || null;
              unit = 'position';
            }
            
            if (value !== null) {
              for (const scope of scopes) {
                snapshots.push({
                  segment,
                  scope,
                  kpi,
                  value,
                  unit,
                  meta: { pageCount: segmentData.page_count || 0 }
                });
              }
            }
          }
        }
        
        // Median Delta KPIs (for Median Delta Over Time chart) - from tasks
        try {
          const tasksResponse = await fetch(apiUrl('/api/optimisation/status?includeDeleted=false'));
          if (tasksResponse.ok) {
            const { tasks } = await tasksResponse.json();
            
            if (tasks && tasks.length > 0) {
              // Filter to active tasks only
              const activeTasks = tasks.filter(t => 
                t.status && !['done', 'cancelled', 'deleted'].includes(t.status)
              );
              
              const medianDeltaKpis = ['ctr_28d', 'clicks_28d', 'impressions_28d', 'avg_position', 'ai_citations', 'ai_overview'];
              
              for (const kpi of medianDeltaKpis) {
                const deltas = [];
                
                activeTasks.forEach(task => {
                  if (!task.baseline_metrics || !task.latest_metrics) return;
                  
                  let baselineValue = null;
                  let latestValue = null;
                  
                  if (kpi === 'ctr_28d') {
                    baselineValue = task.baseline_metrics.ctr_28d;
                    latestValue = task.latest_metrics.ctr_28d;
                  } else if (kpi === 'clicks_28d') {
                    baselineValue = task.baseline_metrics.clicks_28d;
                    latestValue = task.latest_metrics.clicks_28d;
                  } else if (kpi === 'impressions_28d') {
                    baselineValue = task.baseline_metrics.impressions_28d;
                    latestValue = task.latest_metrics.impressions_28d;
                  } else if (kpi === 'avg_position') {
                    baselineValue = task.baseline_metrics.avg_position;
                    latestValue = task.latest_metrics.avg_position;
                  } else if (kpi === 'ai_citations') {
                    baselineValue = task.baseline_metrics.ai_citations;
                    latestValue = task.latest_metrics.ai_citations;
                  } else if (kpi === 'ai_overview') {
                    baselineValue = task.baseline_metrics.ai_overview ? 1 : 0;
                    latestValue = task.latest_metrics.ai_overview ? 1 : 0;
                  }
                  
                  if (baselineValue !== null && latestValue !== null) {
                    deltas.push(latestValue - baselineValue);
                  }
                });
                
                if (deltas.length > 0) {
                  const sortedDeltas = [...deltas].sort((a, b) => a - b);
                  const medianDelta = sortedDeltas[Math.floor(sortedDeltas.length / 2)];
                  
                  snapshots.push({
                    segment: 'all_tracked',
                    scope: 'active_only',
                    kpi: `median_delta_${kpi}`,
                    value: medianDelta,
                    unit: kpi === 'ctr_28d' ? 'pp' : (kpi === 'avg_position' ? 'position' : 'count'),
                    meta: { taskCount: activeTasks.length }
                  });
                }
              }
            }
          }
        } catch (taskError) {
          debugLog(` Error fetching tasks for median deltas: ${taskError.message}`, 'warn');
        }
        
        // Save audit run and snapshots in one API call
        const saveResponse = await fetch(apiUrl('/api/portfolio/save-run'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            windowDays,
            windowStart: startDate.toISOString().split('T')[0],
            windowEnd: endDate.toISOString().split('T')[0],
            note: `Audit run for ${auditDate}`,
            snapshots
          })
        });
        
        if (!saveResponse.ok) {
          const errorText = await saveResponse.text();
          throw new Error(`Failed to save portfolio run: ${saveResponse.status} - ${errorText}`);
        }
        
        const result = await saveResponse.json();
        debugLog(` Created portfolio audit run: ${result.run.id} with ${result.snapshotsCount} snapshots`, 'success');

        debugLog(' Portfolio snapshots calculated and saved', 'success');
      } catch (err) {
        debugLog(`Error calculating portfolio snapshots: ${err.message}`, 'error');
        throw err;
      }
    }

    // Fix ranking panel DOM structure - ensure sections are siblings, not nested
    function fixRankingPanelStructure() {
      const rankingPanel = document.querySelector('.aigeo-panel[data-panel="ranking"]');
      if (!rankingPanel) return;

      const sideBySide = rankingPanel.querySelector('.ranking-cards-side-by-side');
      const priority = rankingPanel.querySelector('#ranking-priority-matrix-section');
      const table = rankingPanel.querySelector('.ranking-table-section');
      const details = rankingPanel.querySelector('.ranking-details-grid');

      if (!sideBySide) return;

      // Check if sections are incorrectly nested inside side-by-side container
      const sideBySideChildren = Array.from(sideBySide.children);
      const needsFix = sideBySideChildren.includes(priority) || 
                       sideBySideChildren.includes(table) || 
                       sideBySideChildren.includes(details);

      if (needsFix) {
        // Move sections out of side-by-side container to be siblings
        if (priority && sideBySide.contains(priority)) {
          sideBySide.parentElement.insertBefore(priority, sideBySide.nextSibling);
        }
        if (table && sideBySide.contains(table)) {
          sideBySide.parentElement.insertBefore(table, priority?.nextSibling || sideBySide.nextSibling);
        }
        if (details && sideBySide.contains(details)) {
          sideBySide.parentElement.insertBefore(details, table?.nextSibling || priority?.nextSibling || sideBySide.nextSibling);
        }
      }

      // Ensure correct order: side-by-side, priority, table, details
      const allSections = [sideBySide, priority, table, details].filter(Boolean);
      allSections.forEach((section, index) => {
        if (section.parentElement === rankingPanel) {
          const currentIndex = Array.from(rankingPanel.children).indexOf(section);
          const expectedIndex = Array.from(rankingPanel.children).indexOf(allSections[0]) + index;
          if (currentIndex !== expectedIndex && expectedIndex >= 0) {
            rankingPanel.insertBefore(section, rankingPanel.children[expectedIndex] || null);
          }
        }
      });
    }

    function toggleCalculationExplanation() {
      const explanation = document.getElementById('calculationExplanation');
      const content = document.getElementById('calculationContent');
      const toggle = document.getElementById('calculationToggle');
      if (explanation.classList.contains('collapsed')) {
        explanation.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '';
      } else {
        explanation.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '';
      }
    }

    function toggleFrameworkExplanation() {
      const explanation = document.getElementById('frameworkExplanation');
      const content = document.getElementById('frameworkContent');
      const toggle = document.getElementById('frameworkToggle');
      if (!explanation || !content) return;
      if (explanation.classList.contains('collapsed')) {
        explanation.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '';
      } else {
        explanation.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '';
      }
    }
    
    window.toggleCsvSection = function(sectionId) {
      const section = document.getElementById(sectionId);
      const contentId = sectionId === 'urlListSection' ? 'urlListContent' : 'backlinkCsvContentWrapper';
      const toggleId = sectionId === 'urlListSection' ? 'urlListToggle' : 'backlinkCsvToggle';
      const content = document.getElementById(contentId);
      const toggle = document.getElementById(toggleId);
      
      if (section.classList.contains('collapsed')) {
        section.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '';
      } else {
        section.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '';
      }
    }

    // Debug panel is always visible at bottom, start collapsed by default
    window.addEventListener('DOMContentLoaded', () => {
      const debugPanel = document.getElementById('debugPanel');
      const debugToggleIcon = document.getElementById('debugToggleIcon');
      if (debugPanel) {
        debugPanel.style.display = 'flex';
        // Start collapsed by default
        debugPanel.classList.add('collapsed');
        if (debugToggleIcon) {
          debugToggleIcon.textContent = '';
        }
      }
    });

    // Initialize Money Pages Priority Matrix global state early
    window.moneyPagePriorityData = window.moneyPagePriorityData || [];
    window.moneySegmentMetrics = window.moneySegmentMetrics || null;
    window.moneyMatrixFilterState = window.moneyMatrixFilterState || { impact: null, diff: null };
    
    // Verify RankingAiModule is available
    if (typeof window.RankingAiModule === 'undefined') {
      debugLog(' RankingAiModule not found in window on page load', 'warn');
    } else {
      debugLog(' RankingAiModule verified on page load', 'success');
    }

    // Fix ranking panel structure on page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(fixRankingPanelStructure, 100);
      });
    } else {
      setTimeout(fixRankingPanelStructure, 100);
    }

    // Load saved configuration
    async function loadConfig() {
      debugLog('=== PAGE LOAD: Starting configuration load ===', 'info');
      
      // Check if Chart.js is loaded
      debugLog('Checking Chart.js library...', 'info');
      if (typeof Chart !== 'undefined') {
        debugLog(' Chart.js library loaded successfully', 'success');
      } else {
        debugLog(' Chart.js library NOT loaded', 'error');
      }
      
      // Try to fetch API key from Vercel environment variable (via API endpoint)
      let vercelApiKey = null;
      try {
        debugLog('Checking Vercel environment variable...', 'info');
        const response = await fetch(apiUrl('/api/get-api-key'));
        if (response.ok) {
          const data = await response.json();
          if (data.apiKey) {
            vercelApiKey = data.apiKey;
            debugLog(' API key loaded from Vercel environment variable', 'success');
            // Persist for this domain to reduce future cold-start issues
            try { localStorage.setItem('gsc_api_key', data.apiKey); } catch (e) { /* ignore */ }
          }
        } else {
          const txt = await response.text();
          debugLog(` /api/get-api-key returned ${response.status}: ${txt}`, 'warn');
        }
      } catch (e) {
        debugLog(` /api/get-api-key fetch failed: ${e.message}`, 'warn');
      }
      
      // Check config.js (local dev only; on Vercel we prefer env via /api/get-api-key)
      debugLog('Checking for config.js...', 'info');
      const configApiKey = window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey;
      if (configApiKey) {
        debugLog(' config.js found with API key', 'success');
      } else if (vercelApiKey || localStorage.getItem('gsc_api_key')) {
        debugLog(' config.js not present (expected on Vercel). Using env/localStorage key.', 'info');
      } else {
        debugLog(' No API key found (config.js missing and env/localStorage key unavailable)', 'warn');
      }
      
      // Check localStorage
      debugLog('Checking localStorage...', 'info');
      const apiKey = vercelApiKey || configApiKey || localStorage.getItem('gsc_api_key');
      const propertyUrl = window.getPropertyUrl ? window.getPropertyUrl() : (localStorage.getItem('gsc_property_url') || '');
      const dateRange = localStorage.getItem('gsc_date_range');
      
      const apiKeySource = vercelApiKey ? 'Vercel env var' : configApiKey ? 'config.js' : localStorage.getItem('gsc_api_key') ? 'localStorage' : 'none';
      debugLog(`API Key source: ${apiKeySource}`, 'info');
      debugLog(`Property URL: ${propertyUrl || 'not set'}`, 'info');
      debugLog(`Date Range: ${dateRange || 'not set'}`, 'info');
      
      if (apiKey) {
        debugLog(' API key loaded from environment', 'success');
        // Store in a hidden variable for use in runAudit
        window._loadedApiKey = apiKey;
      } else {
        debugLog(' No API key found', 'warn');
      }
      
      if (propertyUrl) {
        const el = document.getElementById('propertyUrl');
        if (el && !el.value) el.value = propertyUrl;
        debugLog(' Property URL available', 'success');
      }
      if (dateRange) {
        document.getElementById('dateRange').value = dateRange;
        // Set active button based on saved date range
        const savedDays = parseInt(dateRange);
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          btn.classList.remove('active');
          const btnDays = parseInt(btn.getAttribute('data-days'));
          if (btnDays === savedDays) {
            btn.classList.add('active');
          }
        });
        // If no preset matches, show custom
        const presetDays = [7, 28, 30, 90, 180, 365];
        if (!presetDays.includes(savedDays)) {
          document.getElementById('customDateBtn').classList.add('active');
          document.getElementById('customDays').value = savedDays;
          document.getElementById('customDateRange').style.display = 'block';
        }
        debugLog(' Date range loaded', 'success');
      }
      
      // Load manual URL list if saved
      const savedUrlList = localStorage.getItem('manual_url_list');
      if (savedUrlList) {
        try {
          const urls = JSON.parse(savedUrlList);
          const statusDiv = document.getElementById('urlListStatus');
          if (statusDiv) {
            statusDiv.innerHTML = `<span style="color: #10b981;"> ${urls.length} URLs loaded from saved list</span>`;
          }
          debugLog(` Manual URL list loaded: ${urls.length} URLs`, 'success');
        } catch (e) {
          debugLog(' Failed to load saved URL list', 'warn');
        }
      }
      
      // Load backlink CSV content if saved
      const savedBacklinkCsv = localStorage.getItem('backlink_csv_content');
      if (savedBacklinkCsv) {
        const textarea = document.getElementById('backlinkCsvContent');
        if (textarea) {
          textarea.value = savedBacklinkCsv;
        }
        // Check if backlink metrics are already uploaded
        try {
          const backlinkResponse = await fetch(apiUrl('/api/aigeo/backlink-metrics'));
          if (backlinkResponse.ok) {
            const backlinkData = await backlinkResponse.json();
            if (backlinkData.status === 'ok' && backlinkData.data && backlinkData.data.totalBacklinks > 0) {
              const metrics = backlinkData.data;
              const statusDiv = document.getElementById('backlinkCsvStatus');
              if (statusDiv) {
                statusDiv.innerHTML = `<span style="color: #10b981;"> Backlink CSV loaded: ${metrics.referringDomains} domains, ${metrics.totalBacklinks} links</span>`;
              }
              debugLog(` Backlink CSV already uploaded: ${metrics.referringDomains} domains`, 'success');
            }
          }
        } catch (e) {
          // Ignore errors - backlink metrics may not be uploaded yet
        }
      }
      
      debugLog('=== Configuration load complete ===', 'info');
    }

    // Save configuration
    // Date range selector functions
    function setDateRange(days) {
      const oldDateRange = parseInt(document.getElementById('dateRange').value) || 28;
      document.getElementById('dateRange').value = days;
      localStorage.setItem('gsc_date_range', days);
      
      // Update active button
      document.querySelectorAll('.date-range-btn').forEach(btn => {
        btn.classList.remove('active');
        const btnDays = parseInt(btn.getAttribute('data-days'));
        if (btnDays === days) {
          btn.classList.add('active');
        }
      });
      
      // Hide custom input if showing
      document.getElementById('customDateRange').style.display = 'none';
      document.getElementById('customDateBtn').classList.remove('active');
      
      debugLog(`Date range set to ${days} days`, 'info');
      
      // Check if saved audit exists and if its date range matches
      const savedAudit = loadAuditResultsSync();
      if (savedAudit && savedAudit.scores) {
        const savedDateRange = savedAudit.dateRange || oldDateRange;
        // Always update if date range changed (even if going back to a previous range)
        // This ensures charts refresh properly when switching between ranges
        if (savedDateRange !== days) {
          // Date range changed - update GSC data and recalculate scores
          debugLog(`Date range changed from ${savedDateRange} to ${days} days. Updating metrics...`, 'info');
          updateAuditForNewDateRange(days, savedAudit);
        } else {
          // Date range matches, but force refresh to ensure charts are updated
          // This handles the case where user switches back to the same range
          debugLog(`Date range is already ${days} days, but refreshing charts to ensure they're up to date...`, 'info');
          // Force a refresh by calling displayDashboard with current data
          if (savedAudit.scores && savedAudit.searchData) {
            displayDashboard(savedAudit.scores, savedAudit.searchData, savedAudit.snippetReadiness, savedAudit.schemaAudit, savedAudit.localSignals);
          }
        }
      }
    }

    function showCustomDateRange() {
      const customDiv = document.getElementById('customDateRange');
      const customBtn = document.getElementById('customDateBtn');
      
      if (customDiv.style.display === 'none') {
        customDiv.style.display = 'block';
        customBtn.classList.add('active');
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          if (btn !== customBtn) btn.classList.remove('active');
        });
      } else {
        customDiv.style.display = 'none';
        customBtn.classList.remove('active');
      }
    }

    function applyCustomDateRange() {
      const customDaysInput = document.getElementById('customDays');
      const dateRangeInput = document.getElementById('dateRange');
      if (!customDaysInput || !dateRangeInput) {
        showStatus('Date range inputs are missing. Please refresh the page.', 'error');
        return;
      }
      const customDays = parseInt(customDaysInput.value);
      if (customDays && customDays > 0) {
        const oldDateRange = parseInt(dateRangeInput.value) || 28;
        dateRangeInput.value = customDays;
        localStorage.setItem('gsc_date_range', customDays);
        document.getElementById('customDateRange').style.display = 'none';
        document.getElementById('customDateBtn').classList.remove('active');
        debugLog(`Custom date range set to ${customDays} days`, 'info');
        
        // Check if saved audit exists and if its date range matches
        const savedAudit = loadAuditResultsSync();
        if (savedAudit && savedAudit.scores) {
          const savedDateRange = savedAudit.dateRange || oldDateRange;
          if (savedDateRange !== customDays) {
            // Date range changed - update GSC data and recalculate scores
            debugLog(`Date range changed from ${savedDateRange} to ${customDays} days. Updating metrics...`, 'info');
            updateAuditForNewDateRange(customDays, savedAudit);
          }
        }
      } else {
        showStatus('Please enter a valid number of days', 'error');
      }
    }

    function saveConfig() {
      const apiKeyInput = document.getElementById('apiKey');
      const propertyInput = document.getElementById('propertyUrl');
      const dateRangeInput = document.getElementById('dateRange');
      
      if (!apiKeyInput && !propertyInput && !dateRangeInput) {
        showStatus('Configuration inputs are missing. Please refresh the page.', 'error');
        return;
      }
      
      if (apiKeyInput) {
        localStorage.setItem('gsc_api_key', apiKeyInput.value);
      }
      if (propertyInput) {
        localStorage.setItem('gsc_property_url', propertyInput.value);
      }
      if (dateRangeInput) {
        localStorage.setItem('gsc_date_range', dateRangeInput.value);
      }
      showStatus('Configuration saved!', 'success');
    }

    window.shareAudit = async function shareAudit() {
      // Check if admin key is set
      const adminKey = window.getAdminKey();
      if (!adminKey) {
        alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
        return;
      }

      try {
        // Call share create endpoint
        const response = await fetch(apiUrl('/api/share/create'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-arp-admin-key': adminKey
          },
          body: JSON.stringify({
            expiryDays: 30 // Default to 30 days
          })
        });

        if (!response.ok) {
          let errorMessage = `HTTP ${response.status}`;
          // Read response as text first (body can only be read once)
          try {
            const text = await response.text();
            // Try to parse as JSON
            try {
              const errorData = JSON.parse(text);
              errorMessage = errorData.error || errorMessage;
            } catch (jsonError) {
              // Not JSON, use text as-is
              errorMessage = text || errorMessage;
            }
          } catch (e) {
            // If reading fails, use status
            errorMessage = `HTTP ${response.status}: ${response.statusText || 'Unknown error'}`;
          }
          throw new Error(errorMessage);
        }

        const data = await response.json();
        const shareUrl = data.shareUrl;
        const expiresAt = data.expiresAt ? new Date(data.expiresAt).toLocaleDateString('en-GB') : 'Unknown';

        // Show share URL in a prompt for easy copying
        const message = `Share URL created!\n\nExpires: ${expiresAt}\n\nShare URL:\n${shareUrl}\n\nClick OK to copy to clipboard.`;
        if (confirm(message)) {
          // Copy to clipboard
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(shareUrl);
            showStatus('Share URL copied to clipboard!', 'success');
          } else {
            // Fallback: select text
            const textarea = document.createElement('textarea');
            textarea.value = shareUrl;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
              document.execCommand('copy');
              showStatus('Share URL copied to clipboard!', 'success');
            } catch (e) {
              showStatus('Share URL created. Please copy it manually.', 'info');
            }
            document.body.removeChild(textarea);
          }
        }
      } catch (error) {
        console.error('[Share Audit] Error:', error);
        alert(`Failed to create share URL: ${error.message}`);
      }
    }

    // Parse CSV and validate column names
    function parseUrlListCsv(csvText) {
      const lines = csvText.split('\n').filter(line => line.trim());
      if (lines.length === 0) {
        throw new Error('CSV is empty');
      }
      
      // Parse header row
      const headerLine = lines[0].trim();
      const headers = headerLine.split(',').map(h => h.trim().replace(/^"|"$/g, '').toLowerCase());
      
      // Check for required 'url' column
      const urlColumnIndex = headers.findIndex(h => h === 'url');
      if (urlColumnIndex === -1) {
        throw new Error(`Required column 'url' not found. Found columns: ${headers.join(', ')}`);
      }
      
      // Extract URLs from the 'url' column
      const urls = [];
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        // Parse CSV line (handle quoted values)
        const columns = [];
        let current = '';
        let inQuotes = false;
        
        for (let j = 0; j < line.length; j++) {
          const char = line[j];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            columns.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        columns.push(current.trim()); // Add last column
        
        // Extract URL from the url column
        if (columns[urlColumnIndex]) {
          const url = columns[urlColumnIndex].replace(/^"|"$/g, '').trim();
          if (url && url.startsWith('http')) {
            urls.push(url);
          }
        }
      }
      
      return {
        headers,
        urls,
        totalRows: lines.length - 1,
        validUrls: urls.length
      };
    }

    // Load URL list from file input
    async function loadUrlListFromFile() {
      const fileInput = document.getElementById('urlListFile');
      const statusDiv = document.getElementById('urlListStatus');
      const textarea = document.getElementById('manualUrlList');
      
      if (!fileInput.files || fileInput.files.length === 0) {
        // If no file, try to parse from textarea
        const csvText = textarea.value.trim();
        if (!csvText) {
          statusDiv.innerHTML = '<span style="color: #ef4444;"> Please select a CSV file or paste CSV content</span>';
          return;
        }
        
        try {
          const result = parseUrlListCsv(csvText);
          localStorage.setItem('manual_url_list', JSON.stringify(result.urls));
          statusDiv.innerHTML = `<span style="color: #10b981;"> Loaded ${result.validUrls} URLs from ${result.totalRows} rows</span>`;
          debugLog(` Manual URL list loaded: ${result.validUrls} URLs from CSV`, 'success');
          showStatus(`URL list loaded! Found ${result.validUrls} URLs.`, 'success');
        } catch (error) {
          statusDiv.innerHTML = `<span style="color: #ef4444;"> ${error.message}</span>`;
          debugLog(` URL list parse error: ${error.message}`, 'error');
          showStatus(`URL list error: ${error.message}`, 'error');
        }
        return;
      }
      
      const file = fileInput.files[0];
      debugLog(`Loading URL list from file: ${file.name} (${file.size} bytes)`, 'info');
      
      try {
        const fileText = await file.text();
        const result = parseUrlListCsv(fileText);
        
        // Store URLs in localStorage
        localStorage.setItem('manual_url_list', JSON.stringify(result.urls));
        
        // Also populate textarea with the CSV content
        textarea.value = fileText;
        
        statusDiv.innerHTML = `<span style="color: #10b981;"> Loaded ${result.validUrls} URLs from ${result.totalRows} rows. Columns: ${result.headers.join(', ')}</span>`;
        debugLog(` URL list loaded from file: ${result.validUrls} URLs`, 'success');
        debugLog(`  File: ${file.name}, Columns: ${result.headers.join(', ')}`, 'info');
        showStatus(`URL list loaded! Found ${result.validUrls} URLs from ${file.name}.`, 'success');
        
        // Clear file input
        fileInput.value = '';
      } catch (error) {
        statusDiv.innerHTML = `<span style="color: #ef4444;"> ${error.message}</span>`;
        debugLog(` URL list file error: ${error.message}`, 'error');
        showStatus(`URL list error: ${error.message}`, 'error');
      }
    }

    // Clear manual URL list
    function clearManualUrlList() {
      const textarea = document.getElementById('manualUrlList');
      const fileInput = document.getElementById('urlListFile');
      const statusDiv = document.getElementById('urlListStatus');
      
      textarea.value = '';
      fileInput.value = '';
      localStorage.removeItem('manual_url_list');
      statusDiv.innerHTML = '<span style="color: #666;">Manual URL list cleared</span>';
      debugLog('Manual URL list cleared', 'info');
      showStatus('Manual URL list cleared', 'success');
    }

    // Load backlink CSV from file (wrapper for uploadBacklinkCsv)
    async function loadBacklinkCsvFromFile() {
      return await uploadBacklinkCsv();
    }

    // Upload backlink CSV file
    async function uploadBacklinkCsv() {
      const fileInput = document.getElementById('backlinkCsvFile');
      const statusDiv = document.getElementById('backlinkCsvStatus');
      const textarea = document.getElementById('backlinkCsvContent');
      
      let csvContent = '';
      
      if (fileInput.files && fileInput.files.length > 0) {
        const file = fileInput.files[0];
        debugLog(`Uploading backlink CSV from file: ${file.name} (${file.size} bytes)`, 'info');
        
        try {
          csvContent = await file.text();
          // Also populate textarea with the CSV content
          textarea.value = csvContent;
        } catch (error) {
          statusDiv.innerHTML = `<span style="color: #ef4444;"> Error reading file: ${error.message}</span>`;
          debugLog(` Backlink CSV file read error: ${error.message}`, 'error');
          showStatus(`Backlink CSV error: ${error.message}`, 'error');
          return;
        }
      } else {
        // If no file, try to get from textarea
        csvContent = textarea.value.trim();
        if (!csvContent) {
          statusDiv.innerHTML = '<span style="color: #ef4444;"> Please select a CSV file or paste CSV content</span>';
          return;
        }
      }

      if (!csvContent) {
        statusDiv.innerHTML = '<span style="color: #ef4444;"> No CSV content to upload</span>';
        return;
      }

      // Validate CSV has required columns
      const lines = csvContent.split('\n').filter(line => line.trim());
      if (lines.length === 0) {
        statusDiv.innerHTML = '<span style="color: #ef4444;"> CSV is empty</span>';
        return;
      }

      const headerLine = lines[0].trim();
      const headers = headerLine.split(',').map(h => h.trim().replace(/^"|"$/g, ''));
      
      // More flexible column matching - check for URL column (required) and Link Type (optional)
      const hasUrlColumn = headers.some(h => {
        const lower = h.toLowerCase();
        return (lower.includes('linking') && lower.includes('url')) ||
               lower.includes('url') ||
               lower.includes('source url') ||
               lower.includes('page url');
      });
      
      const hasLinkType = headers.some(h => {
        const lower = h.toLowerCase();
        return lower.includes('link type') ||
               lower.includes('type') ||
               lower.includes('follow');
      });
      
      if (!hasUrlColumn) {
        statusDiv.innerHTML = `<span style="color: #ef4444;"> Missing URL column. Found columns: ${headers.join(', ')}. Need a column containing 'URL' or 'Linking Page + URL'</span>`;
        debugLog(` Backlink CSV missing URL column. Found: ${headers.join(', ')}`, 'error');
        return;
      }
      
      if (!hasLinkType) {
        statusDiv.innerHTML = `<span style="color: #ef4444;"> Missing Link Type column. Found columns: ${headers.join(', ')}. The Link Type column is required to calculate the follow ratio for the Authority score.</span>`;
        debugLog(` Backlink CSV missing Link Type column. Found: ${headers.join(', ')}`, 'error');
        return;
      }

      // Upload to API
      try {
        statusDiv.innerHTML = '<span style="color: #666;"> Uploading and processing backlink CSV...</span>';
        debugLog('Uploading backlink CSV to API...', 'info');
        
        // Send CSV as JSON since Vercel doesn't parse text/csv automatically
        const response = await fetch(apiUrl('/api/aigeo/backlink-metrics'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ csv: csvContent })
        });

        if (!response.ok) {
          let errorMessage = `HTTP ${response.status}`;
          try {
            const errorData = await response.json();
            errorMessage = errorData.message || errorData.error || errorMessage;
            debugLog(`API error response: ${JSON.stringify(errorData)}`, 'error');
          } catch (e) {
            // If response is not JSON, try to get text
            try {
              const errorText = await response.text();
              if (errorText) {
                errorMessage = errorText.substring(0, 200);
              }
            } catch (e2) {
              // Ignore
            }
          }
          throw new Error(errorMessage);
        }

        const result = await response.json();
        debugLog(`API response: ${JSON.stringify(result).substring(0, 200)}...`, 'info');
        
        if (result.status === 'ok' && result.data) {
          const metrics = result.data;
          statusDiv.innerHTML = `<span style="color: #10b981;"> Backlink CSV uploaded successfully! Found ${metrics.referringDomains} referring domains, ${metrics.totalBacklinks} backlinks, ${Math.round(metrics.followRatio * 100)}% follow ratio</span>`;
          debugLog(` Backlink CSV uploaded: ${metrics.referringDomains} domains, ${metrics.totalBacklinks} links, ${(metrics.followRatio * 100).toFixed(1)}% follow`, 'success');
          showStatus(`Backlink CSV uploaded! ${metrics.referringDomains} referring domains found.`, 'success');
          
          // Store in localStorage for persistence
          localStorage.setItem('backlink_csv_content', csvContent);
          localStorage.setItem('backlink_metrics', JSON.stringify(metrics));
          window.latestBacklinkMetrics = metrics;
          debugLog(` Backlink metrics stored in localStorage`, 'success');
        } else {
          // Error response - log debug info to UI
          const errorMsg = result.message || result.error || 'Upload failed - invalid response format';
          statusDiv.innerHTML = `<span style="color: #ef4444;"> ${errorMsg}</span>`;
          debugLog(` Backlink CSV upload error: ${errorMsg}`, 'error');
          
          // Log debug info if available
          if (result.debug) {
            debugLog(`[DEBUG] CSV Length: ${result.debug.csvLength || 'N/A'}`, 'info');
            debugLog(`[DEBUG] Logical Lines: ${result.debug.logicalLines || 'N/A'}`, 'info');
            debugLog(`[DEBUG] Headers Found: ${result.debug.headers ? result.debug.headers.join(', ') : 'N/A'}`, 'info');
            if (result.debug.firstChars) {
              debugLog(`[DEBUG] First 500 chars: ${result.debug.firstChars}`, 'info');
            }
            if (result.debug.rowCount !== undefined) {
              debugLog(`[DEBUG] Rows parsed: ${result.debug.rowCount}`, 'info');
            }
            if (result.debug.firstRowKeys) {
              debugLog(`[DEBUG] First row keys: ${result.debug.firstRowKeys.join(', ')}`, 'info');
            }
            if (result.debug.error) {
              debugLog(`[DEBUG] Error details: ${result.debug.error}`, 'error');
            }
          }
          
          // Also log full error response for debugging
          debugLog(`[DEBUG] Full error response: ${JSON.stringify(result, null, 2)}`, 'error');
          showStatus(`Backlink CSV error: ${errorMsg}`, 'error');
        }
      } catch (error) {
        const errorMsg = error.message || error.toString() || 'Unknown error';
        statusDiv.innerHTML = `<span style="color: #ef4444;"> ${errorMsg}</span>`;
        debugLog(` Backlink CSV upload error: ${errorMsg}`, 'error');
        debugLog(`Error stack: ${error.stack || 'No stack trace'}`, 'error');
        showStatus(`Backlink CSV error: ${errorMsg}`, 'error');
      }
    }

    // Clear backlink CSV
    function clearBacklinkCsv() {
      const textarea = document.getElementById('backlinkCsvContent');
      const fileInput = document.getElementById('backlinkCsvFile');
      const statusDiv = document.getElementById('backlinkCsvStatus');
      
      textarea.value = '';
      fileInput.value = '';
      localStorage.removeItem('backlink_csv_content');
      statusDiv.innerHTML = '<span style="color: #666;">Backlink CSV cleared</span>';
      debugLog('Backlink CSV cleared', 'info');
      showStatus('Backlink CSV cleared', 'success');
    }

    // Sync CSV from alan-shared-resources
    async function syncCSV() {
      const btn = document.getElementById('syncCsvBtn');
      const btnText = document.getElementById('syncCsvBtnText');
      const originalText = btnText?.textContent || 'Sync CSV';
      
      debugLog('=== CSV SYNC: Starting CSV sync verification ===', 'info');
      debugLog('CSV sync initiated...', 'info');
      
      // Disable button and show loading state (only if elements exist)
      if (btn) {
        btn.disabled = true;
        btn.style.opacity = '0.6';
        btn.style.cursor = 'not-allowed';
      }
      if (btnText) {
        btnText.textContent = ' Syncing...';
      }
      if (btn || btnText) {
        debugLog('Button state: disabled, showing loading indicator', 'info');
      }
      
      try {
        debugLog('Fetching /api/sync-csv endpoint...', 'info');
        const response = await fetch(apiUrl('/api/sync-csv'), {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
        });
        
        debugLog(`API response status: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
        
        const data = await response.json();
        debugLog(`API response data: ${JSON.stringify(data).substring(0, 200)}...`, 'info');
        
        if (response.ok && data.status === 'ok') {
          const urlCount = data.data.totalUrls || 0;
          const source = data.source || 'unknown';
          const backlinkDomains = data.data.backlinkDomains;
          
          debugLog(` CSV fetched successfully from ${source}`, 'success');
          debugLog(`  CSV URL: ${data.csvUrl || 'not provided'}`, 'info');
          debugLog(`  Total URLs fetched: ${urlCount}`, 'success');
          if (backlinkDomains !== null && backlinkDomains !== undefined) {
            debugLog(`  Backlink domains fetched: ${backlinkDomains}`, 'success');
          } else if (data.data.backlinkError) {
            debugLog(`  Backlink CSV error: ${data.data.backlinkError}`, 'warn');
          }
          debugLog(`  CSV size: ${data.data.csvSize} bytes`, 'info');
          debugLog(`  Lines processed: ${data.data.linesProcessed || 'N/A'}`, 'info');
          debugLog(`  Fetched at: ${data.data.fetchedAt}`, 'info');
          
          // Show toast with URL count
          const backlinkSummary = (backlinkDomains !== null && backlinkDomains !== undefined)
            ? ` Backlink domains: ${backlinkDomains}.`
            : '';
          showStatus(` CSV synced from ${source}! Fetched ${urlCount} URLs.${backlinkSummary}`, 'success');
          if (btnText) {
            btnText.textContent = ` ${urlCount} URLs`;
          }
          
          // Reset button after 3 seconds
          setTimeout(() => {
            if (btnText) btnText.textContent = originalText;
            if (btn) {
              btn.style.opacity = '1';
            }
            debugLog('Button reset to original state', 'info');
          }, 3000);
        } else {
          debugLog(` CSV sync failed`, 'error');
          debugLog(`  Error message: ${data.message || 'Unknown error'}`, 'error');
          debugLog(`  CSV URL attempted: ${data.csvUrl || 'not provided'}`, 'error');
          if (data.details) {
            if (data.details.githubError) {
              debugLog(`  GitHub error: ${data.details.githubError}`, 'warn');
            }
            if (Array.isArray(data.details.githubAttempts) && data.details.githubAttempts.length > 0) {
              debugLog(`  GitHub attempts: ${JSON.stringify(data.details.githubAttempts).substring(0, 300)}...`, 'info');
            }
          }
          if (data.suggestion) {
            debugLog(`  Suggestion: ${data.suggestion}`, 'warn');
          }
          showStatus(`CSV sync failed: ${data.message}. ${data.suggestion || ''}`, 'error');
          if (btnText) {
            btnText.textContent = ' Sync Failed';
          }
          
          // Reset button after 5 seconds
          setTimeout(() => {
            if (btnText) btnText.textContent = originalText;
            if (btn) {
              btn.style.opacity = '1';
            }
            debugLog('Button reset to original state after error', 'info');
          }, 5000);
        }
      } catch (error) {
        debugLog(` CSV sync error occurred`, 'error');
        debugLog(`  Error type: ${error.name || 'Unknown'}`, 'error');
        debugLog(`  Error message: ${error.message}`, 'error');
        if (error.stack) {
          debugLog(`  Stack trace: ${error.stack.substring(0, 300)}...`, 'error');
        }
        showStatus(`CSV sync error: ${error.message}. Please run "npm run sync:csv" locally.`, 'error');
        if (btnText) {
          btnText.textContent = ' Error';
        }
        
        // Reset button after 5 seconds
        setTimeout(() => {
          if (btnText) btnText.textContent = originalText;
          if (btn) {
            btn.style.opacity = '1';
          }
          debugLog('Button reset to original state after exception', 'info');
        }, 5000);
      } finally {
        if (btn) {
          btn.disabled = false;
          btn.style.cursor = 'pointer';
        }
        debugLog('=== CSV SYNC: Complete ===', 'info');
      }
    }

    // Expose syncCSV to window for global run
    window.syncCsv = syncCSV;

    // Update progress bar
    function updateProgress(percent, statusText) {
      const progressBar = document.getElementById('progressBar');
      const progressStatus = document.getElementById('progressStatus');
      if (progressBar) {
        progressBar.style.width = Math.min(100, Math.max(0, percent)) + '%';
        progressBar.textContent = Math.round(percent) + '%';
      }
      if (progressStatus) {
        progressStatus.textContent = statusText || 'Processing...';
      }
    }

    // Show status message
    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = `status ${type} show`;
      setTimeout(() => {
        status.classList.remove('show');
      }, 5000);
    }

    // Show completion summary modal
    function showCompletionModal(schemaAudit) {
      debugLog('showCompletionModal called', 'info');
      const modal = document.getElementById('completionModal');
      const content = document.getElementById('completionSummaryContent');
      
      debugLog(`Modal element found: ${modal ? 'yes' : 'no'}`, 'info');
      debugLog(`Content element found: ${content ? 'yes' : 'no'}`, 'info');
      
      if (!modal || !content) {
        debugLog(' Modal or content element not found, cannot show modal', 'error');
        return;
      }
      
      let html = '';
      
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const data = schemaAudit.data;
        const meta = schemaAudit.meta || {};
        const diag = meta.diagnostic || {};
        
        const totalPages = data.totalPages || diag.totalPages || 0;
        const successfulPages = diag.successfulPages || (totalPages - (data.missingSchemaCount || 0));
        const failedPages = diag.failedPages || data.missingSchemaCount || 0;
        const isComplete = failedPages === 0;
        
        html += `<div style="margin-bottom: 1.5rem;">`;
        html += `<div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">`;
        html += `<span style="font-size: 2rem;">${isComplete ? '' : ''}</span>`;
        html += `<h3 style="margin: 0; color: ${isComplete ? '#10b981' : '#f59e0b'};">
          ${isComplete ? 'Complete' : 'Incomplete'} Data
        </h3>`;
        html += `</div>`;
        
        html += `<div style="background: ${isComplete ? '#f0fdf4' : '#fffbeb'}; border-left: 4px solid ${isComplete ? '#10b981' : '#f59e0b'}; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">`;
        html += `<p style="margin: 0; color: #555; line-height: 1.6;">`;
        if (isComplete) {
          html += `All pages were successfully crawled. Dashboard data is complete and accurate.`;
        } else {
          html += `<strong>Warning:</strong> ${failedPages} page${failedPages !== 1 ? 's' : ''} failed to crawl. Dashboard data may be incomplete. Failed pages are counted as missing schema.`;
        }
        html += `</p>`;
        html += `</div>`;
        
        html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">`;
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Total URLs Scanned</div>`;
        html += `<div style="font-size: 1.5rem; font-weight: 600; color: #333;">${totalPages}</div>`;
        html += `</div>`;
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Successful Crawls</div>`;
        html += `<div style="font-size: 1.5rem; font-weight: 600; color: #10b981;">${successfulPages}</div>`;
        html += `</div>`;
        html += `</div>`;
        
        if (failedPages > 0) {
          // Get failed URLs from missingSchemaPages that have errors
          const failedUrls = (data.missingSchemaPages || []).filter(p => p.error).map(p => p.url);
          
          html += `<div style="background: #fef2f2; border-left: 4px solid #ef4444; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">`;
          html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Failed Crawls</div>`;
          html += `<div style="font-size: 1.5rem; font-weight: 600; color: #ef4444;">${failedPages}</div>`;
          
          if (diag.errorTypes && Object.keys(diag.errorTypes).length > 0) {
            html += `<div style="margin-top: 0.75rem; font-size: 0.85rem; color: #666;">`;
            html += `<strong>Error Breakdown:</strong><br>`;
            Object.entries(diag.errorTypes).forEach(([type, count]) => {
              html += `${type}: ${count}<br>`;
            });
            html += `</div>`;
          }
          
          // Add retry button if there are failed URLs
          if (failedUrls.length > 0) {
            html += `<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #fee2e2;">`;
            html += `<button id="retryFailedUrls" class="btn" style="background: #10b981; color: white; border-color: #10b981; width: 100%;" title="Retry crawling the ${failedUrls.length} failed URLs. This will rescan only the URLs that failed during the initial audit.">`;
            html += ` Retry Failed URLs (${failedUrls.length})`;
            html += `</button>`;
            html += `<div style="font-size: 0.8rem; color: #666; margin-top: 0.5rem; text-align: center;">Click to rescan only the failed URLs</div>`;
            html += `</div>`;
          }
          
          html += `</div>`;
        }
        
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px; margin-top: 1rem;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;"><strong>Schema Coverage</strong></div>`;
        // Ensure coverage is a number, not an object
        const coverageValue = typeof data.coverage === 'number' && !isNaN(data.coverage) 
          ? data.coverage 
          : (() => {
              // Calculate from pagesWithSchema and totalPages if coverage is not a number
              const pagesWithSchemaCount = Array.isArray(data.pagesWithSchema) 
                ? data.pagesWithSchema.length 
                : (typeof data.pagesWithSchema === 'number' ? data.pagesWithSchema : 0);
              const totalPagesCount = typeof data.totalPages === 'number' ? data.totalPages : totalPages;
              return totalPagesCount > 0 ? ((pagesWithSchemaCount / totalPagesCount) * 100) : 0;
            })();
        html += `<div style="font-size: 1.25rem; font-weight: 600; color: #333;">${coverageValue.toFixed(1)}%</div>`;
        const pagesWithSchemaCount = Array.isArray(data.pagesWithSchema) 
          ? data.pagesWithSchema.length 
          : (typeof data.pagesWithSchema === 'number' ? data.pagesWithSchema : 0);
        html += `<div style="font-size: 0.85rem; color: #666; margin-top: 0.25rem;">${pagesWithSchemaCount} pages with inline schema</div>`;
        
        // Display schema types if available, properly formatted
        if (data.schemaTypes && Array.isArray(data.schemaTypes) && data.schemaTypes.length > 0) {
          const formattedTypes = data.schemaTypes
            .filter(t => t !== null && t !== undefined)
            .map(t => {
              if (typeof t === 'string') return t;
              if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type;
              return null;
            })
            .filter(t => t !== null && typeof t === 'string')
            .slice(0, 10)
            .join(', ');
          if (formattedTypes) {
            html += `<div style="font-size: 0.75rem; color: #666; margin-top: 0.5rem; line-height: 1.4;">Schema types: ${formattedTypes}${data.schemaTypes.length > 10 ? '...' : ''}</div>`;
          }
        }
        html += `</div>`;
        
        html += `</div>`;
      } else {
        // Provide more helpful error message
        let errorMsg = 'Unable to load audit summary data.';
        if (!schemaAudit) {
          errorMsg = 'Schema audit data is missing. The audit may have failed or data was not saved properly.';
        } else if (schemaAudit.status !== 'ok') {
          errorMsg = `Schema audit failed with status: ${schemaAudit.status}. ${schemaAudit.error || schemaAudit.message || ''}`;
        } else if (!schemaAudit.data) {
          errorMsg = 'Schema audit completed but data is missing. Please check the console for errors.';
        }
        html += `<div style="background: #fef2f2; border-left: 4px solid #ef4444; padding: 1rem; border-radius: 4px;">`;
        html += `<p style="margin: 0; color: #991b1b; line-height: 1.6;">${errorMsg}</p>`;
        html += `<p style="margin: 0.5rem 0 0 0; font-size: 0.85rem; color: #666;">Check the debug log at the bottom of the page for more details.</p>`;
        html += `</div>`;
        debugLog(` Completion modal error: schemaAudit=${!!schemaAudit}, status=${schemaAudit?.status}, hasData=${!!schemaAudit?.data}, hasMeta=${!!schemaAudit?.meta}`, 'warn');
      }
      
      content.innerHTML = html;
      modal.style.display = 'block';
      debugLog('Modal display set to block', 'info');
      debugLog(`Modal is now visible: ${modal.style.display}`, 'info');
      
      // Attach retry button handler if it exists
      const retryButton = document.getElementById('retryFailedUrls');
      if (retryButton) {
        retryButton.onclick = function() {
          retryFailedUrls(schemaAudit);
        };
      }
    }
    
    // Retry failed URLs from schema audit
    async function retryFailedUrls(schemaAudit) {
      if (!schemaAudit || !schemaAudit.data || !schemaAudit.data.missingSchemaPages) {
        debugLog(' No failed URLs to retry', 'error');
        showStatus('No failed URLs found to retry', 'error');
        return;
      }
      
      // Extract failed URLs (those with errors)
      const failedUrls = schemaAudit.data.missingSchemaPages
        .filter(p => p.error)
        .map(p => p.url);
      
      if (failedUrls.length === 0) {
        debugLog(' No failed URLs to retry', 'error');
        showStatus('No failed URLs found to retry', 'error');
        return;
      }
      
      debugLog(` Retrying ${failedUrls.length} failed URLs...`, 'info');
      showStatus(`Retrying ${failedUrls.length} failed URLs...`, 'info');
      
      // Close the modal
      closeCompletionModal();
      
      // Show loading indicator
      document.getElementById('loading').classList.add('show');
      document.getElementById('dashboard').style.display = 'none';
      updateProgress(0, `Retrying ${failedUrls.length} failed URLs...`);
      
      try {
        updateProgress(20, 'Scanning failed URLs for schema markup...');
        debugLog(`Sending retry request for ${failedUrls.length} URLs`, 'info');
        
        // Call schema-audit API with only the failed URLs
        const schemaResponse = await fetch(apiUrl('/api/schema-audit'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ urls: failedUrls })
        });
        
        if (!schemaResponse.ok) {
          throw new Error(`Schema audit API returned error: ${schemaResponse.status}`);
        }
        
        const retrySchemaAudit = await schemaResponse.json();
        
        if (retrySchemaAudit.status !== 'ok') {
          throw new Error(retrySchemaAudit.message || 'Schema audit failed');
        }
        
        const retryData = retrySchemaAudit.data;
        const retrySuccessful = retryData.pagesWithSchema || 0;
        const retryStillFailed = (retryData.missingSchemaCount || 0);
        
        debugLog(` Retry completed: ${retrySuccessful} pages now have schema, ${retryStillFailed} still failed`, 'success');
        updateProgress(60, 'Merging retry results with original audit...');
        
        // Load original audit results from localStorage or Supabase
        const savedAudit = await loadAuditResults();
        if (savedAudit && savedAudit.schemaAudit && savedAudit.schemaAudit.data) {
          // Merge retry results with original schema audit
          const originalData = savedAudit.schemaAudit.data;
          const originalPages = originalData.pagesWithSchema || 0;
          const originalFailed = originalData.missingSchemaCount || 0;
          
          // Create merged schema audit data
          const mergedSchemaAudit = {
            ...savedAudit.schemaAudit,
            data: {
              ...originalData,
              // Update counts: add retry successful pages, remove retry successful from failed
              pagesWithSchema: originalPages + retrySuccessful,
              missingSchemaCount: Math.max(0, originalFailed - retrySuccessful),
              // Update missingSchemaPages: remove successfully retried URLs
              missingSchemaPages: (originalData.missingSchemaPages || []).filter(p => {
                // Keep only pages that weren't in the retry list or still failed
                return !failedUrls.includes(p.url) || (retryData.missingSchemaPages || []).some(rp => rp.url === p.url);
              }),
              // Update coverage
              coverage: ((originalPages + retrySuccessful) / originalData.totalPages) * 100
            }
          };
          
          // Update saved audit with merged results
          const mergedAudit = {
            ...savedAudit,
            schemaAudit: mergedSchemaAudit
          };
          
          // Recalculate scores with merged data (use saved localSignals if available)
          // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
          const normalizedSiteReviews = getTrustpilotSnapshot(savedAudit.siteReviews || null);
          const mergedScores = await calculatePillarScores(savedAudit.searchData, mergedSchemaAudit, savedAudit.localSignals || null, normalizedSiteReviews, savedAudit.backlinkMetrics || null);
          const mergedSnippetReadiness = calculateSnippetReadiness(mergedScores, savedAudit.searchData);
          
          // Save merged results (preserve localSignals, siteReviews, and backlinkMetrics)
          saveAuditResults(mergedScores, savedAudit.searchData, mergedSnippetReadiness, mergedSchemaAudit, savedAudit.localSignals || null, normalizedSiteReviews, savedAudit.backlinkMetrics || null);
          
          // Update retry button visibility
          updateRetryButtonVisibility(mergedSchemaAudit);
          
          // Refresh dashboard with merged results
          updateProgress(80, 'Refreshing dashboard with merged results...');
          displayDashboard(mergedScores, savedAudit.searchData, mergedSnippetReadiness, mergedSchemaAudit, savedAudit.localSignals || null);
          
          updateProgress(100, 'Retry completed and dashboard updated!');
          showStatus(`Retry completed: ${retrySuccessful} URLs now have schema. Dashboard updated with merged results.`, 'success');
          
          // Show completion modal with merged results
          showCompletionModal(mergedSchemaAudit);
        } else {
          // No saved audit found, just show retry results
          updateProgress(80, 'Retry completed!');
          showCompletionModal(retrySchemaAudit);
          updateProgress(100, 'Retry completed!');
          showStatus(`Retry completed: ${retrySuccessful} URLs now have schema, ${retryStillFailed} still failed`, 'success');
          debugLog(' No saved audit found to merge with. Run full audit to see complete results.', 'warn');
        }
        
      } catch (error) {
        debugLog(` Retry error: ${error.message}`, 'error');
        showStatus(`Error retrying failed URLs: ${error.message}`, 'error');
      } finally {
        document.getElementById('loading').classList.remove('show');
        setTimeout(() => {
          updateProgress(0, 'Initializing audit scan...');
        }, 500);
      }
    }

    // Save audit results to localStorage
    function saveAuditResults(scores, searchData, snippetReadiness, schemaAudit, localSignals = null, siteReviews = null, backlinkMetrics = null, preserveTimestamp = false) {
      try {
        const dateRange = parseInt(document.getElementById('dateRange')?.value) || 28;
        // Get property URL from input field or from searchData
        const propertyUrl = document.getElementById('propertyUrl')?.value || 
                           searchData?.propertyUrl || 
                           searchData?.property_url ||
                           localStorage.getItem('gsc_property_url') ||
                           'https://www.alanranger.com'; // Fallback default
        
        // Get existing audit data to preserve timestamp if requested
        let existingTimestamp = null;
        if (preserveTimestamp) {
          try {
            const existing = localStorage.getItem('last_audit_results');
            if (existing) {
              const parsed = JSON.parse(existing);
              existingTimestamp = parsed.timestamp;
            }
          } catch (e) {
            // Ignore errors when reading existing data
          }
        }
        
        // Ensure moneyPagesMetrics is included in scores (for dashboard to read)
        if (!scores.moneyPagesMetrics && window.moneyPagesMetrics) {
          scores.moneyPagesMetrics = window.moneyPagesMetrics;
          debugLog(` Added moneyPagesMetrics to scores from window (${window.moneyPagesMetrics.rows?.length || 0} rows)`, 'success');
        }
        
        const auditData = {
          scores,
          searchData,
          snippetReadiness,
          schemaAudit,
          localSignals, // Store local signals data for future use
          siteReviews, // Store site reviews data for future use (preserve on retry)
          backlinkMetrics, // Store backlink metrics data
          dateRange, // Store the date range used for this audit
          propertyUrl, // CRITICAL: Save property URL so we can fetch from Supabase later
          timestamp: preserveTimestamp && existingTimestamp ? existingTimestamp : new Date().toISOString(),
          // Save Money Pages Priority Matrix data for persistence
          moneyPagePriorityData: window.moneyPagePriorityData || null,
          moneySegmentMetrics: window.moneySegmentMetrics || null
        };
        
        // Try to save to localStorage, but don't fail if quota exceeded (Supabase is source of truth)
        if (safeSetLocalStorage('last_audit_results', auditData)) {
          debugLog(` Audit results saved to localStorage (propertyUrl: ${propertyUrl})`, 'success');
        }
        // Also save property URL separately for easy access
        if (propertyUrl) {
          localStorage.setItem('gsc_property_url', propertyUrl);
        }
        debugLog(` Audit results saved to localStorage (propertyUrl: ${propertyUrl})`, 'success');
        
        // Save dashboard snapshot for delta comparisons (only if not preserving timestamp - i.e., this is a new audit)
        if (!preserveTimestamp) {
          if (typeof computeDashboardSnapshot === 'function' && typeof saveDashboardRun === 'function') {
            try {
              const snapshot = computeDashboardSnapshot();
              const runRecord = {
                timestamp: auditData.timestamp,
                status: 'ok',
                steps: [{ label: 'Audit completed', status: 'ok' }],
                metrics: snapshot
              };
              saveDashboardRun(runRecord);
              debugLog(` Dashboard snapshot saved for delta comparisons`, 'success');
            } catch (snapshotError) {
              debugLog(` Failed to save dashboard snapshot: ${snapshotError.message}`, 'warn');
            }
          } else if (typeof saveDashboardRun === 'function') {
            // Fallback: Save minimal run record with just timestamp if computeDashboardSnapshot isn't available
            try {
              const runRecord = {
                timestamp: auditData.timestamp,
                status: 'ok',
                steps: [{ label: 'Audit completed', status: 'ok' }],
                metrics: {}
              };
              saveDashboardRun(runRecord);
              debugLog(` Dashboard run record saved (minimal - snapshot function not available)`, 'success');
            } catch (runError) {
              debugLog(` Failed to save dashboard run record: ${runError.message}`, 'warn');
            }
          }
        }
        
        // Update timestamp display - REMOVED: Now only updated from renderDashboardTab() to prevent flickering
        // updateAuditTimestamp(auditData.timestamp);

        // Dashboard: refresh live dials/cards immediately when any audit saves
        if (typeof window.renderDashboardTab === 'function') {
          try { 
            window.renderDashboardTab();
            // Also update audit timestamp badge after saving audit
            if (typeof window.updateAuditTimestamp === 'function') {
              setTimeout(() => window.updateAuditTimestamp(), 500);
            }
          } catch (e) {}
        }
      } catch (error) {
        debugLog(` Error saving audit results: ${error.message}`, 'error');
      }
    }
    
    // Show full-screen loading overlay
    function showFullScreenLoading(message = 'Loading...') {
      // Remove any existing overlay
      const existing = document.getElementById('fullScreenLoadingOverlay');
      if (existing) existing.remove();
      
      // Create overlay
      const overlay = document.createElement('div');
      overlay.id = 'fullScreenLoadingOverlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(4px);
      `;
      
      // Create spinner container
      const spinnerContainer = document.createElement('div');
      spinnerContainer.style.cssText = `
        background: white;
        padding: 3rem 4rem;
        border-radius: 12px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        text-align: center;
        min-width: 300px;
      `;
      
      // Create spinner
      const spinner = document.createElement('div');
      spinner.style.cssText = `
        width: 60px;
        height: 60px;
        border: 6px solid #e2e8f0;
        border-top-color: #3b82f6;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 1.5rem;
      `;
      
      // Create message
      const messageDiv = document.createElement('div');
      messageDiv.style.cssText = 'font-size: 1.1rem; color: #1f2937; font-weight: 500;';
      messageDiv.textContent = message;
      
      // Add spin animation if not already in stylesheet
      if (!document.getElementById('full-screen-spin-style')) {
        const style = document.createElement('style');
        style.id = 'full-screen-spin-style';
        style.textContent = '@keyframes spin { to { transform: rotate(360deg); } }';
        document.head.appendChild(style);
      }
      
      spinnerContainer.appendChild(spinner);
      spinnerContainer.appendChild(messageDiv);
      overlay.appendChild(spinnerContainer);
      document.body.appendChild(overlay);
    }
    
    // Hide full-screen loading overlay
    function hideFullScreenLoading() {
      const overlay = document.getElementById('fullScreenLoadingOverlay');
      if (overlay) overlay.remove();
    }
    
    // Update audit results for new date range without full rescan
    async function updateAuditForNewDateRange(newDateRange, savedAudit) {
      // Show full-screen loading overlay
      showFullScreenLoading(`Updating metrics for ${newDateRange} day period...`);
      
      try {
        showStatus(`Updating metrics for ${newDateRange} day period...`, 'info');
        
        const propertyUrl = document.getElementById('propertyUrl')?.value || savedAudit.propertyUrl || '';
        if (!propertyUrl) {
          // Remove loading spinner
          if (trendCanvas && trendCanvas.parentElement) {
            const loadingDiv = trendCanvas.parentElement.querySelector('.trend-chart-loading');
            if (loadingDiv) loadingDiv.remove();
          }
          clearDashboard();
          showStatus(`Date range changed to ${newDateRange} days. Please run a new audit to see updated metrics.`, 'info');
          return;
        }
        
        // Get API key (needed for fetchSearchConsoleData signature, but not actually used)
        let apiKey = window._loadedApiKey || '';
        
        // Fetch new GSC data for the new date range (will use Supabase cache)
        debugLog(`Fetching GSC data for ${newDateRange} day period...`, 'info');
        const searchData = await fetchSearchConsoleData(apiKey, propertyUrl, newDateRange);
        
        // Fetch local signals (Business Profile data doesn't change with date range, but fetch to ensure it's fresh)
        let localSignals = savedAudit.localSignals || null;
        
        // Normalize cached localSignals structure if needed (handle old format where it might just be {data: {...}})
        if (localSignals && localSignals.data && !localSignals.status) {
          debugLog(`[Local Signals] Normalizing cached data structure - wrapping in status/data format`, 'info');
          localSignals = { status: 'ok', data: localSignals.data || localSignals };
        }
        
        try {
          const localSignalsResponse = await fetch(apiUrl(`/api/aigeo/local-signals?property=${encodeURIComponent(propertyUrl)}`));
          if (localSignalsResponse.ok) {
            const freshLocalSignals = await localSignalsResponse.json();
            debugLog(`[Local Signals API] Response received - status: ${freshLocalSignals.status}, has data: ${!!freshLocalSignals.data}, locations count: ${freshLocalSignals.data?.locations?.length || 0}, structure keys: ${Object.keys(freshLocalSignals).join(', ')}`, 'info');
            
            const dataPayload = freshLocalSignals.data
              || (freshLocalSignals && typeof freshLocalSignals === 'object' && !freshLocalSignals.status ? freshLocalSignals : null);
            const hasGbpFallback = dataPayload && (dataPayload.gbpRating != null || dataPayload.gbpReviewCount != null);

            // Use fresh data if API returned successfully (or fallback data is present)
            if (freshLocalSignals.status === 'ok' && dataPayload) {
              // Always use fresh data if API returned successfully, even if locations is 0
              // (API might return 0 locations legitimately, or we want to update cached data)
              localSignals = { ...freshLocalSignals, data: dataPayload };
              debugLog(` Local signals data fetched successfully - Locations: ${dataPayload.locations?.length || 0}, Service Areas: ${dataPayload.serviceAreas?.length || 0}, NAP: ${dataPayload.napConsistencyScore || 'null'}`, 'success');
            } else if (hasGbpFallback) {
              // Allow GBP fallback data even when status is error
              localSignals = { ...freshLocalSignals, status: 'ok', data: dataPayload, _statusOverride: 'gbp-fallback' };
              debugLog(` Local signals API returned status="${freshLocalSignals.status}" but GBP fallback data is present. Using fallback.`, 'warn');
            } else if (freshLocalSignals.status === 'error') {
              debugLog(` Local signals API error: ${freshLocalSignals.error?.message || 'Unknown error'}, keeping cached data`, 'warn');
              // Keep using cached data - don't overwrite with error response
            } else {
              debugLog(` Local signals API returned unexpected status (status: ${freshLocalSignals.status}, has data: ${!!dataPayload}, locations: ${dataPayload?.locations?.length || 0}), keeping cached data`, 'warn');
              // Keep using cached data - don't overwrite with unexpected response
            }
          } else {
            const errorText = await localSignalsResponse.text();
            debugLog(` Local signals API HTTP error: ${localSignalsResponse.status} - ${errorText}`, 'error');
          }
        } catch (localSignalsError) {
          debugLog(` Local signals fetch error: ${localSignalsError.message}, using cached data if available`, 'error');
        }
        
        // Final normalization - ensure localSignals always has the correct structure
        if (localSignals && localSignals.data && !localSignals.status) {
          localSignals = { status: 'ok', data: localSignals.data || localSignals };
        }
        
        // Recalculate pillar scores based on new GSC data
        // Keep existing schema audit data (doesn't change with date range)
        // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
        const normalizedSiteReviews = getTrustpilotSnapshot(savedAudit.siteReviews || null);
        // Get backlinkMetrics from savedAudit (it should be there from the last audit)
        const backlinkMetrics = savedAudit.backlinkMetrics || null;
        const scores = await calculatePillarScores(searchData, savedAudit.schemaAudit, localSignals, normalizedSiteReviews, backlinkMetrics);
        const snippetReadiness = calculateSnippetReadiness(scores, searchData);
        
        debugLog(`Recalculated scores for ${newDateRange} days: ${JSON.stringify(scores)}`, 'info');
        
        // Update saved audit with new data
        // Preserve the original audit timestamp - don't update it when changing date range
        const updatedAudit = {
          ...savedAudit,
          dateRange: newDateRange,
          searchData: searchData,
          scores: scores,
          snippetReadiness: snippetReadiness,
          localSignals: localSignals, // Store local signals for future use
          timestamp: savedAudit.timestamp || new Date().toISOString(), // Preserve original timestamp
          // Preserve Money Pages Priority Matrix data if it exists
          moneyPagePriorityData: window.moneyPagePriorityData || savedAudit.moneyPagePriorityData || null,
          moneySegmentMetrics: window.moneySegmentMetrics || savedAudit.moneySegmentMetrics || null
        };
        
        // Save updated audit
        // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
        const normalizedSiteReviewsForLoad = getTrustpilotSnapshot(savedAudit.siteReviews || null);
        // Use backlinkMetrics from savedAudit (preserved from last audit)
        const preservedBacklinkMetrics = backlinkMetrics;
        // Pass preserveTimestamp=true to keep the original audit timestamp
        saveAuditResults(scores, searchData, snippetReadiness, savedAudit.schemaAudit, localSignals, normalizedSiteReviewsForLoad, preservedBacklinkMetrics, true);
        safeSetLocalStorage('last_audit_results', updatedAudit);
        
        // Do NOT save to Supabase here.
        // This "metrics refresh" (date range change) is not a full audit run, and saving it
        // can incorrectly update today's audit_results row and the "Last Audit" time.
        
        // Update dashboard with new data - ensure scores object has all required properties
        debugLog(`Updating dashboard with scores: ${JSON.stringify(scores)}`, 'info');
        displayDashboard(scores, searchData, snippetReadiness, savedAudit.schemaAudit, localSignals);
        
        showStatus(`Metrics updated for ${newDateRange} day period.`, 'success');
        debugLog(` Audit updated for ${newDateRange} day period`, 'success');
        
      } catch (error) {
        debugLog(` Error updating audit for new date range: ${error.message}`, 'error');
        
        // Remove loading spinner and show error
        // Hide full-screen loading overlay
        hideFullScreenLoading();
        
        // Show error message in trend chart area
        const trendCanvas = document.getElementById('trendChart');
        if (trendCanvas && trendCanvas.parentElement) {
          // Remove any existing error messages
          const existingError = trendCanvas.parentElement.querySelector('.trend-chart-error');
          if (existingError) existingError.remove();
          
          // Show error message to user
          const errorDiv = document.createElement('div');
          errorDiv.className = 'trend-chart-error';
          errorDiv.style.cssText = 'background: #fee2e2; padding: 1rem; border-radius: 4px; border-left: 3px solid #ef4444; margin-bottom: 1rem; font-size: 0.9rem; color: #991b1b;';
          errorDiv.innerHTML = `<strong>Error updating trend chart:</strong> ${error.message}. Please refresh the page or run a new audit.`;
          trendCanvas.parentElement.insertBefore(errorDiv, trendCanvas);
        }
        
        clearDashboard();
        showStatus(`Date range changed to ${newDateRange} days. Please run a new audit to see updated metrics.`, 'info');
      }
    }
    
    // Clear dashboard and show message that new audit is needed
    function clearDashboard() {
      const dashboard = document.getElementById('dashboard');
      if (dashboard) {
        dashboard.style.display = 'none';
      }
      // Clear any charts
      if (window.radarChart) {
        window.radarChart.destroy();
        window.radarChart = null;
      }
      if (window.trendChart) {
        window.trendChart.destroy();
        window.trendChart = null;
      }
      if (window.snippetReadinessChart) {
        window.snippetReadinessChart.destroy();
        window.snippetReadinessChart = null;
      }
    }
    
    // Load audit results from localStorage
    async function loadAuditResults() {
      let auditData = null;
      let localStorageData = null;
      let hasMoneyPagesData = false;
      let hasQueryTotals = false;
      
      // First, try localStorage
      try {
        const saved = localStorage.getItem('last_audit_results');
        if (saved) {
          localStorageData = JSON.parse(saved);
          debugLog(' Audit results loaded from localStorage', 'success');
          
          // Check if localStorage data has critical Money Pages data
          hasMoneyPagesData = !!(localStorageData?.scores?.moneyPagesMetrics || localStorageData?.moneyPagesMetrics);
          // Also check if queryTotals are present (needed for CTR/Impressions columns)
          hasQueryTotals = !!(localStorageData?.searchData?.queryTotals && Array.isArray(localStorageData.searchData.queryTotals) && localStorageData.searchData.queryTotals.length > 0);
          
          if (hasMoneyPagesData) {
            debugLog(` localStorage has moneyPagesMetrics: ${localStorageData?.scores?.moneyPagesMetrics?.rows?.length || localStorageData?.moneyPagesMetrics?.rows?.length || 0} rows`, 'success');
            if (!hasQueryTotals) {
              debugLog(` localStorage missing queryTotals (${localStorageData?.searchData?.queryTotals?.length || 0} items), will try Supabase...`, 'warn');
            } else {
              debugLog(` localStorage has queryTotals: ${localStorageData.searchData.queryTotals.length} keywords`, 'success');
            }
            // Don't return yet: we still want to confirm "Last Audit" against Supabase
            auditData = localStorageData;
          } else {
            debugLog(' localStorage data missing moneyPagesMetrics, will try Supabase...', 'warn');
            // Keep localStorageData as fallback
            auditData = localStorageData;
          }
        }
      } catch (error) {
        debugLog(` Error loading audit results from localStorage: ${error.message}`, 'error');
      }
      
      // If localStorage is empty or missing critical data, try fetching from Supabase
      // Try multiple sources for property URL - prioritize saved audit data
      let propertyUrl = (localStorageData && localStorageData.propertyUrl) || // First check: saved in auditData
                        localStorage.getItem('gsc_property_url') || 
                        localStorage.getItem('last_property_url') ||
                        (localStorageData && localStorageData.searchData && localStorageData.searchData.propertyUrl) ||
                        (localStorageData && localStorageData.searchData && localStorageData.searchData.property_url);
      
      // If still no property URL, try to extract from saved audit data structure
      if (!propertyUrl && localStorageData) {
        // Check if there's a property URL embedded in the saved data
        if (localStorageData.searchData && typeof localStorageData.searchData === 'object') {
          propertyUrl = localStorageData.searchData.propertyUrl || localStorageData.searchData.property_url;
        }
      }
      
      // Last resort: try to get from input field
      if (!propertyUrl) {
        const propertyUrlInput = document.getElementById('propertyUrl');
        if (propertyUrlInput && propertyUrlInput.value) {
          propertyUrl = propertyUrlInput.value;
        }
      }
      
      debugLog(`Property URL for Supabase fetch: ${propertyUrl || 'NOT SET'}`, propertyUrl ? 'info' : 'warn');
      
      if (propertyUrl) {
        // Always do a quick minimal check so "Last Audit" reflects the latest *full* audit,
        // even when we can serve the rest of the page from localStorage.
        try {
          const minimalResponse = await fetch(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}&minimal=true`);
          if (minimalResponse.ok) {
            const minimalJson = await minimalResponse.json();
            const minimalData = minimalJson?.data;
            if (minimalJson?.status === 'ok' && minimalData?.timestamp) {
              // REMOVED: Now only updated from renderDashboardTab() to prevent flickering
              // updateAuditTimestamp(minimalData.timestamp);
              // IMPORTANT: also update cached local data, otherwise displayDashboard() will
              // overwrite the UI with stale localStorageData.timestamp.
              const normalizedTs = typeof minimalData.timestamp === 'number'
                ? new Date(minimalData.timestamp).toISOString()
                : minimalData.timestamp;
              if (localStorageData && normalizedTs) {
                localStorageData.timestamp = normalizedTs;
                try {
                  safeSetLocalStorage('last_audit_results', localStorageData);
                } catch (e) {
                  // Non-fatal
                }
              }
              if (auditData && normalizedTs) {
                auditData.timestamp = normalizedTs;
              }
            }
          }
        } catch (e) {
          // Non-fatal
        }

        // ALWAYS fetch from Supabase as the source of truth
        debugLog(` Always fetching from Supabase (source of truth)...`, 'info');
        debugLog(` Calling fetchLatestAuditFromSupabase(${propertyUrl})...`, 'info');
        const supabaseData = await fetchLatestAuditFromSupabase(propertyUrl);
        debugLog(` fetchLatestAuditFromSupabase returned: ${supabaseData ? 'data' : 'null/undefined'}`, supabaseData ? 'success' : 'warn');
        
        if (supabaseData) {
          debugLog(' Audit results loaded from Supabase', 'success');
          debugLog(` Supabase data structure: scores.moneyPagesMetrics=${!!supabaseData?.scores?.moneyPagesMetrics}, moneyPagesMetrics=${!!supabaseData?.moneyPagesMetrics}, searchData=${!!supabaseData?.searchData}, queryTotals=${supabaseData?.searchData?.queryTotals?.length || 0} keywords`, 'info');
          // Ensure backlink metrics persist across hard refresh
          try {
            const storedBacklink = localStorage.getItem('backlink_metrics');
            if (!supabaseData.backlinkMetrics && storedBacklink) {
              supabaseData.backlinkMetrics = JSON.parse(storedBacklink);
              debugLog(' Restored backlink metrics from localStorage fallback', 'info');
            }
            if (supabaseData.backlinkMetrics) {
              localStorage.setItem('backlink_metrics', JSON.stringify(supabaseData.backlinkMetrics));
              window.latestBacklinkMetrics = supabaseData.backlinkMetrics;
            }
          } catch (e) {
            debugLog(` Failed to restore backlink metrics: ${e.message}`, 'warn');
          }
          if (supabaseData.searchData) {
            debugLog(` Supabase searchData keys: ${Object.keys(supabaseData.searchData).join(', ')}`, 'info');
            if (supabaseData.searchData.queryTotals) {
              debugLog(` Supabase queryTotals type: ${Array.isArray(supabaseData.searchData.queryTotals) ? 'array' : typeof supabaseData.searchData.queryTotals}, length: ${Array.isArray(supabaseData.searchData.queryTotals) ? supabaseData.searchData.queryTotals.length : 'N/A'}`, 'success');
            } else {
              debugLog(` Supabase searchData exists but queryTotals is missing/null`, 'warn');
            }
          } else {
            debugLog(` Supabase data exists but searchData is missing/null`, 'warn');
          }
          
          // Store in localStorage for offline/cache purposes (but Supabase is always source of truth)
          try {
            safeSetLocalStorage('last_audit_results', supabaseData);
            debugLog(' Stored Supabase data in localStorage for caching', 'success');
            // Update timestamp display - REMOVED: Now only updated from renderDashboardTab() to prevent flickering
            // if (supabaseData.timestamp) {
            //   updateAuditTimestamp(supabaseData.timestamp);
            // }
              // Dashboard: ensure the new Dashboard tab reflects freshly-loaded audit data.
              if (typeof window.renderDashboardTab === 'function') {
                try { 
                  window.renderDashboardTab();
                  // Also update audit timestamp badge after loading audit data
                  if (typeof window.updateAuditTimestamp === 'function') {
                    setTimeout(() => window.updateAuditTimestamp(), 500);
                  }
                } catch (e) {}
              }
          } catch (storageError) {
            debugLog(` Could not store Supabase data in localStorage: ${storageError.message}`, 'warn');
          }
          return supabaseData;
        } else {
          debugLog(' No audit data found in Supabase (fetchLatestAuditFromSupabase returned null/undefined), using localStorage data as fallback', 'warn');
          debugLog(` This could mean: 1) No audit exists in Supabase for ${propertyUrl}, 2) API call failed, 3) API returned error status`, 'warn');
        }
      } else {
        debugLog(' Cannot fetch from Supabase: property URL not set, using localStorage data as fallback', 'warn');
      }
      
      // Return localStorage data as fallback (even if incomplete) rather than null
      // This ensures the page still loads with whatever data we have
      if (localStorageData) {
        debugLog(' Returning localStorage data as fallback (may be incomplete)', 'info');
        return localStorageData;
      }
      
      return null;
    }
    
    // Synchronous version for callers that can't be async (returns localStorage only)
    function loadAuditResultsSync() {
      try {
        const saved = localStorage.getItem('last_audit_results');
        if (saved) {
          return JSON.parse(saved);
        }
      } catch (error) {
        // Silent fail for sync version
      }
      return null;
    }
    
    // Update audit timestamp display - shows GSC and Ranking & AI audit dates separately
    // Debounced to prevent rapid updates from multiple callers
    let updateAuditTimestampDebounceTimer = null;
    async function updateAuditTimestamp() {
      debugLog('[updateAuditTimestamp] Function called', 'info');
      if (updateAuditTimestampDebounceTimer) clearTimeout(updateAuditTimestampDebounceTimer);
      updateAuditTimestampDebounceTimer = setTimeout(async () => {
        try {
          const gscAuditElement = document.getElementById('gscAuditDate');
          const gscDateRangeElement = document.getElementById('gscDateRange');
          const rankingAiAuditElement = document.getElementById('rankingAiAuditDate');
          const snippetTimestampElement = document.getElementById('snippetReadinessAuditTime');
          const snippetTimestampContainer = document.getElementById('snippetReadinessTimestamp');
          const radarTimestampElement = document.getElementById('radarChartAuditTime');
          const radarTimestampContainer = document.getElementById('radarChartTimestamp');

          const normalizeTimestamp = (value) => {
            if (!value) return null;
            if (typeof value === 'number') {
              const d = new Date(value);
              return isNaN(d.getTime()) ? null : d.toISOString();
            }
            if (typeof value === 'string') {
              const normalized = value.includes(' ') && !value.includes('T')
                ? value.replace(' ', 'T')
                : value;
              const d = new Date(normalized);
              return isNaN(d.getTime()) ? null : d.toISOString();
            }
            return null;
          };

          const formatDateShort = (dateStr) => {
            if (!dateStr) return 'Not yet run';
            try {
              const date = new Date(dateStr);
              if (isNaN(date.getTime())) return 'Not yet run';
              const day = String(date.getUTCDate()).padStart(2, '0');
              const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
              const month = monthNames[date.getUTCMonth()];
              const year = String(date.getUTCFullYear()).slice(-2);
              const hours = String(date.getUTCHours()).padStart(2, '0');
              const minutes = String(date.getUTCMinutes()).padStart(2, '0');
              return `${day}-${month}-${year}, ${hours}:${minutes}`;
            } catch (e) {
              return 'Not yet run';
            }
          };

          const formatDateRange = (startDateStr, endDateStr) => {
            if (!startDateStr || !endDateStr) return '-';
            try {
              const start = new Date(startDateStr);
              const end = new Date(endDateStr);
              if (isNaN(start.getTime()) || isNaN(end.getTime())) return '-';
              const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
              const formatDate = (d) => {
                const day = String(d.getUTCDate()).padStart(2, '0');
                const month = monthNames[d.getUTCMonth()];
                const year = String(d.getUTCFullYear()).slice(-2);
                return `${day}-${month}-${year}`;
              };
              return `${formatDate(start)} -> ${formatDate(end)}`;
            } catch (e) {
              return '-';
            }
          };

          const propertyUrlInput = document.getElementById('propertyUrl');
          const propertyUrlFromInput = propertyUrlInput?.value?.trim();
          const propertyUrlFromStorage = localStorage.getItem('gsc_property_url')?.trim();
          const propertyUrlDefault = 'https://www.alanranger.com';
          const propertyUrl = propertyUrlFromInput || propertyUrlFromStorage || propertyUrlDefault;
          if (!propertyUrl || propertyUrl.trim() === '') {
            debugLog('[updateAuditTimestamp] Property URL is empty, cannot fetch audit data', 'error');
            return;
          }

          let gscAuditDate = null;
          let gscTimestamp = null;
          let gscStartDate = null;
          let gscEndDate = null;
          let rankingAiAuditDate = null;
          let rankingAiTimestamp = null;
          let latestFullAuditData = null;

          const safeFetch = async (url, label, controller) => {
            try {
              const res = await fetch(url, controller ? { signal: controller.signal } : undefined);
              if (!res.ok) throw new Error(`${res.status}`);
              return res;
            } catch (err) {
              debugLog(`[updateAuditTimestamp] ${label}: ${err.message}`, 'warn');
              return null;
            }
          };

          // GSC minimal + full
          const gscMinimalUrl = apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}&minimal=true&includePartial=true&preferRecent=true`);
          const gscRes = await safeFetch(gscMinimalUrl, 'GSC minimal fetch failed');
          if (gscRes) {
            const gscData = await gscRes.json();
            if (gscData.status === 'ok' && gscData.data?.auditDate) {
              const fullUrl = apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}&includePartial=true&preferRecent=true`);
              const fullRes = await safeFetch(fullUrl, 'GSC full fetch failed');
              if (fullRes) {
                const fullData = await fullRes.json();
                if (fullData.status === 'ok' && fullData.data) {
                  latestFullAuditData = fullData.data;
                  gscAuditDate = fullData.data.auditDate || fullData.data.audit_date || gscAuditDate;
                  window.lastGscAuditDate = gscAuditDate;
                  let auditDateForCalculation = null;
                  const gscTimestampCandidate = normalizeTimestamp(
                    fullData.data.timestamp ||
                    fullData.data.updated_at ||
                    fullData.data.updatedAt
                  );
                  if (gscTimestampCandidate) {
                    const tsDate = new Date(gscTimestampCandidate);
                    auditDateForCalculation = new Date(Date.UTC(tsDate.getUTCFullYear(), tsDate.getUTCMonth(), tsDate.getUTCDate()));
                  } else if (gscAuditDate) {
                    auditDateForCalculation = new Date(gscAuditDate + 'T00:00:00Z');
                  }
                  const dateRange = 28;
                  if (auditDateForCalculation) {
                    gscEndDate = new Date(auditDateForCalculation);
                    gscEndDate.setUTCDate(gscEndDate.getUTCDate() - 2);
                    gscStartDate = new Date(gscEndDate);
                    gscStartDate.setUTCDate(gscStartDate.getUTCDate() - (dateRange - 1));
                    if (gscTimestampCandidate) {
                      gscTimestamp = gscTimestampCandidate;
                    } else if (gscAuditDate) {
                      gscTimestamp = auditDateForCalculation.toISOString();
                    }
                  }
                }
              }
            }
          }

          // Ranking & AI: latest audit data (cron + manual)
          if (!rankingAiTimestamp && (latestFullAuditData?.ranking_ai_data || latestFullAuditData?.rankingAiData)) {
            const rankingFromAudit = latestFullAuditData.ranking_ai_data || latestFullAuditData.rankingAiData;
            rankingAiAuditDate =
              rankingFromAudit.audit_date ||
              rankingFromAudit.auditDate ||
              rankingAiAuditDate;
            rankingAiTimestamp = normalizeTimestamp(
              rankingFromAudit.lastRunTimestamp ||
              rankingFromAudit.lastRunAt ||
              rankingFromAudit.timestamp
            );
          }

          // Ranking & AI: localStorage fast path (only if audit_results did not supply a timestamp)
          if (!rankingAiTimestamp) {
            try {
              const savedAudit = localStorage.getItem('last_audit_results');
              const savedRankingData = localStorage.getItem('ranking_ai_data');
              if (savedAudit) {
                const parsed = JSON.parse(savedAudit);
                if (parsed.ranking_ai_data && parsed.timestamp) {
                  const auditTs = new Date(parsed.timestamp);
                  if (!isNaN(auditTs.getTime())) {
                    rankingAiTimestamp = auditTs.toISOString();
                    rankingAiAuditDate = parsed.audit_date || parsed.ranking_ai_data.audit_date || rankingAiAuditDate;
                    debugLog(`[updateAuditTimestamp]  Found timestamp from localStorage (fast path): ${rankingAiTimestamp}`, 'success');
                  }
                }
              }
              if (!rankingAiTimestamp && savedRankingData) {
                try {
                  const parsedRanking = JSON.parse(savedRankingData);
                  if (parsedRanking.timestamp) {
                    const ts = new Date(parsedRanking.timestamp);
                    if (!isNaN(ts.getTime())) {
                      rankingAiTimestamp = ts.toISOString();
                      rankingAiAuditDate = parsedRanking.audit_date || rankingAiAuditDate;
                      debugLog(`[updateAuditTimestamp]  Found timestamp from ranking_ai_data localStorage: ${rankingAiTimestamp}`, 'success');
                    }
                  }
                } catch (e) {
                  debugLog(`[updateAuditTimestamp] Error parsing ranking_ai_data from localStorage: ${e.message}`, 'warn');
                }
              }
            } catch (localErr) {
              debugLog(`[updateAuditTimestamp] Error reading localStorage (fast path): ${localErr.message}`, 'warn');
            }
          }

          // Ranking & AI: API path
          if (!rankingAiTimestamp) {
            try {
              const rankingsUrl = apiUrl(`/api/supabase/get-keyword-rankings?propertyUrl=${encodeURIComponent(propertyUrl)}&latestOnly=true`);
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 10000);
              const rankingsRes = await safeFetch(rankingsUrl, 'keyword_rankings fetch failed', controller);
              clearTimeout(timeoutId);
              if (rankingsRes) {
                const rankingsData = await rankingsRes.json();
                if (rankingsData.status === 'ok' && rankingsData.data?.latestAuditDate) {
                  rankingAiAuditDate = rankingsData.data.latestAuditDate;
                  const ts = rankingsData.data.latestTimestamp || rankingsData.data.rankingAiTimestamp;
                  if (ts) {
                    let normalizedTs = ts;
                    if (typeof normalizedTs === 'string') {
                      if (normalizedTs.includes(' ') && !normalizedTs.includes('T')) {
                        normalizedTs = normalizedTs.replace(' ', 'T');
                      }
                      if (normalizedTs.endsWith('+00')) {
                        normalizedTs = `${normalizedTs}:00`;
                      }
                    }
                    const tsDate = new Date(normalizedTs);
                    if (!isNaN(tsDate.getTime())) {
                      rankingAiTimestamp = tsDate.toISOString();
                    }
                  }
                  if (!rankingAiTimestamp && rankingAiAuditDate) {
                    try {
                      const auditResultsUrl = apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}&minimal=true`);
                      const auditRes = await safeFetch(auditResultsUrl, 'audit_results minimal fetch failed');
                      if (auditRes) {
                        const auditData = await auditRes.json();
                        if (auditData.status === 'ok' && auditData.data?.timestamp) {
                          const ts2 = new Date(auditData.data.timestamp);
                          if (!isNaN(ts2.getTime())) {
                            rankingAiTimestamp = ts2.toISOString();
                          }
                        }
                      }
                    } catch (_) { /* ignore */ }
                  }
                  if (!rankingAiTimestamp && rankingAiAuditDate) {
                    const auditDate = new Date(rankingAiAuditDate + 'T00:00:00Z');
                    rankingAiTimestamp = auditDate.toISOString();
                  }
                }
              }
            } catch (apiErr) {
              debugLog(`[updateAuditTimestamp] Ranking API error: ${apiErr.message}`, 'warn');
            }
          }

          // Final localStorage fallback (only if audit_results did not supply a timestamp)
          if (!rankingAiTimestamp) {
            try {
              const savedAudit = localStorage.getItem('last_audit_results');
              if (savedAudit) {
                const parsed = JSON.parse(savedAudit);
                if (parsed.ranking_ai_data && parsed.timestamp) {
                  const auditTs = new Date(parsed.timestamp);
                  if (!isNaN(auditTs.getTime())) {
                    rankingAiTimestamp = auditTs.toISOString();
                    debugLog(`[updateAuditTimestamp]  Found timestamp from localStorage (fallback): ${rankingAiTimestamp}`, 'success');
                  }
                }
              }
            } catch (e) {
              debugLog(`[updateAuditTimestamp] Error reading localStorage (fallback): ${e.message}`, 'warn');
            }
          }

          if (!rankingAiTimestamp && rankingAiAuditDate) {
            const auditDate = new Date(rankingAiAuditDate + 'T00:00:00Z');
            rankingAiTimestamp = auditDate.toISOString();
            debugLog(`[updateAuditTimestamp]  No timestamp found - using midnight as last resort: ${rankingAiAuditDate}`, 'warn');
          }

          if (!rankingAiTimestamp && !rankingAiAuditDate) {
            try {
              const rankingAiUrl = apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`);
              const controller2 = new AbortController();
              const timeoutId2 = setTimeout(() => controller2.abort(), 10000);
              const rankingAiRes = await safeFetch(rankingAiUrl, 'get-latest-audit fetch failed', controller2);
              clearTimeout(timeoutId2);
              if (rankingAiRes) {
                const rankingAiData = await rankingAiRes.json();
                if (rankingAiData.status === 'ok' && rankingAiData.data) {
                  if (rankingAiData.data.rankingAiData?.audit_date) {
                    rankingAiAuditDate = rankingAiData.data.rankingAiData.audit_date;
                    const rawRankingTimestamp = rankingAiData.data.rankingAiData?.timestamp || rankingAiData.data.timestamp;
                    if (rawRankingTimestamp) {
                      let normalizedRankingTimestamp = rawRankingTimestamp;
                      if (typeof normalizedRankingTimestamp === 'string') {
                        if (normalizedRankingTimestamp.includes(' ') && !normalizedRankingTimestamp.includes('T')) {
                          normalizedRankingTimestamp = normalizedRankingTimestamp.replace(' ', 'T');
                        }
                        if (normalizedRankingTimestamp.endsWith('+00')) {
                          normalizedRankingTimestamp = `${normalizedRankingTimestamp}:00`;
                        }
                      }
                      const ts = new Date(normalizedRankingTimestamp);
                      if (!isNaN(ts.getTime())) rankingAiTimestamp = ts.toISOString();
                    }
                  } else if (rankingAiData.data.auditDate && rankingAiData.data.timestamp) {
                    rankingAiAuditDate = rankingAiData.data.auditDate;
                    rankingAiTimestamp = new Date(rankingAiData.data.timestamp).toISOString();
                  }
                }
              }
            } catch (fallbackErr) {
              debugLog(`[updateAuditTimestamp] Error calling get-latest-audit API: ${fallbackErr.message}`, 'warn');
            }
          }

          if (rankingAiTimestamp) {
            debugLog(`[updateAuditTimestamp] Final Ranking & AI timestamp: ${rankingAiTimestamp}`, 'info');
          } else {
            debugLog(`[updateAuditTimestamp]  No Ranking & AI timestamp available`, 'warn');
          }

          if (gscAuditElement) {
            if (gscTimestamp) {
              gscAuditElement.textContent = formatDateShort(gscTimestamp);
              debugLog(`[updateAuditTimestamp] Updated GSC audit date element`, 'info');
            } else {
              gscAuditElement.textContent = 'Not yet run';
              debugLog('[updateAuditTimestamp] GSC timestamp is null, showing "Not yet run"', 'warn');
            }
          }

          if (gscDateRangeElement) {
            if (gscStartDate && gscEndDate) {
              const rangeText = formatDateRange(gscStartDate.toISOString(), gscEndDate.toISOString());
              gscDateRangeElement.textContent = rangeText;
              debugLog(`[updateAuditTimestamp] Updated GSC date range element`, 'info');
            } else {
              gscDateRangeElement.textContent = '-';
              debugLog('[updateAuditTimestamp] GSC date range is null, showing "-"', 'warn');
            }
          }

          if (rankingAiAuditElement) {
            if (rankingAiTimestamp) {
              rankingAiAuditElement.textContent = formatDateShort(rankingAiTimestamp);
              debugLog(`[updateAuditTimestamp] Updated Ranking & AI audit date element`, 'info');
            } else {
              rankingAiAuditElement.textContent = 'Not yet run';
              debugLog('[updateAuditTimestamp] Ranking & AI timestamp is null, showing "Not yet run"', 'warn');
            }
          }

          if (snippetTimestampElement && gscTimestamp) {
            snippetTimestampElement.textContent = formatDateShort(gscTimestamp);
          }
          if (snippetTimestampContainer) {
            snippetTimestampContainer.style.display = gscTimestamp ? 'block' : 'none';
          }
          if (radarTimestampElement && gscTimestamp) {
            radarTimestampElement.textContent = formatDateShort(gscTimestamp);
          }
          if (radarTimestampContainer) {
            radarTimestampContainer.style.display = gscTimestamp ? 'block' : 'none';
          }
        } catch (e) {
          debugLog(`[updateAuditTimestamp] Error updating audit timestamps: ${e?.message || e}`, 'error');
          const gscAuditElement = document.getElementById('gscAuditDate');
          const gscDateRangeElement = document.getElementById('gscDateRange');
          const rankingAiAuditElement = document.getElementById('rankingAiAuditDate');
          if (gscAuditElement) gscAuditElement.textContent = 'Not yet run';
          if (gscDateRangeElement) gscDateRangeElement.textContent = '-';
          if (rankingAiAuditElement) rankingAiAuditElement.textContent = 'Not yet run';
        }
      }, 100);
    }
    
    // Expose to window for global audit to call
    window.updateAuditTimestamp = updateAuditTimestamp;
    
    // Save audit results to Supabase for historical tracking
    async function saveAuditToSupabase(propertyUrl, scores, searchData, snippetReadiness, schemaAudit, localSignals = null, auditDateOverride = null, backlinkMetrics = null) {
      try {
        // IMPORTANT: Only full audits should write a new audit_date.
        // If auditDateOverride is provided, use it; otherwise try to derive from the saved audit timestamp.
        let auditDate = auditDateOverride;
        if (!auditDate) {
          try {
            const saved = loadAuditResultsSync();
            if (saved && saved.timestamp) {
              auditDate = new Date(saved.timestamp).toISOString().split('T')[0];
            }
          } catch (e) {
            // Ignore
          }
        }
        if (!auditDate) {
          auditDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD fallback
        }
        
        // Ensure searchData has overview object with siteTotalImpressions and siteTotalClicks
        // These are needed for calculating shareOfImpressions in buildMoneyPagesSummary
        let overview = null;
        
        if (searchData) {
          // Create overview object if it doesn't exist
          if (!searchData.overview) {
            searchData.overview = {};
          }
          
          // Populate overview with siteTotalImpressions and siteTotalClicks
          // Priority: searchData.overview.siteTotalImpressions > searchData.totalImpressions > searchData.overview.totalImpressions
          if (!searchData.overview.siteTotalImpressions || searchData.overview.siteTotalImpressions === 0) {
            if (searchData.totalImpressions != null && searchData.totalImpressions > 0) {
              searchData.overview.siteTotalImpressions = searchData.totalImpressions;
            } else if (searchData.overview.totalImpressions != null && searchData.overview.totalImpressions > 0) {
              searchData.overview.siteTotalImpressions = searchData.overview.totalImpressions;
            } else {
              // Fallback: set to 0 if all else fails
              searchData.overview.siteTotalImpressions = 0;
            }
          }
          
          if (!searchData.overview.siteTotalClicks || searchData.overview.siteTotalClicks === 0) {
            if (searchData.totalClicks != null && searchData.totalClicks > 0) {
              searchData.overview.siteTotalClicks = searchData.totalClicks;
            } else if (searchData.overview.totalClicks != null && searchData.overview.totalClicks > 0) {
              searchData.overview.siteTotalClicks = searchData.overview.totalClicks;
            } else {
              // Fallback: set to 0 if all else fails
              searchData.overview.siteTotalClicks = 0;
            }
          }
          
          // Also ensure totalImpressions and totalClicks are set in overview for compatibility
          if (!searchData.overview.totalImpressions) {
            searchData.overview.totalImpressions = searchData.overview.siteTotalImpressions;
          }
          if (!searchData.overview.totalClicks) {
            searchData.overview.totalClicks = searchData.overview.siteTotalClicks;
          }
          
          overview = searchData.overview;
          
          // Debug logging
          debugLog(`saveAuditToSupabase: searchData.totalImpressions=${searchData.totalImpressions}, overview.siteTotalImpressions=${overview.siteTotalImpressions || 'missing'}, overview.totalImpressions=${overview.totalImpressions || 'missing'}`, 'info');
        } else {
          debugLog(` saveAuditToSupabase: searchData is null or undefined`, 'warn');
          // Create empty overview as fallback
          overview = { siteTotalImpressions: 0, siteTotalClicks: 0, totalImpressions: 0, totalClicks: 0 };
        }
        
        // Build Money Pages summary for trend tracking (Phase 3)
        // CRITICAL: Ensure moneyPagesMetrics exists in scores - check multiple sources
        debugLog(`saveAuditToSupabase: Checking for moneyPagesMetrics - scores.moneyPagesMetrics=${!!scores?.moneyPagesMetrics}, window.moneyPagesMetrics=${!!window.moneyPagesMetrics}`, 'info');
        
        if (!scores.moneyPagesMetrics) {
          debugLog(` saveAuditToSupabase: scores.moneyPagesMetrics is missing, checking window.moneyPagesMetrics`, 'warn');
          // Try to get from global state if available
          if (window.moneyPagesMetrics) {
            scores.moneyPagesMetrics = window.moneyPagesMetrics;
            debugLog(` saveAuditToSupabase: Using moneyPagesMetrics from window (${window.moneyPagesMetrics.rows?.length || 0} rows)`, 'info');
          } else {
            debugLog(` saveAuditToSupabase: No moneyPagesMetrics available anywhere - this means money pages data was not generated during audit`, 'warn');
            debugLog(` saveAuditToSupabase: This could be because: 1) No queryPages data from GSC, 2) CSV fetch failed, 3) No money pages found in CSV`, 'warn');
            // Set to null explicitly so it's saved (even if empty)
            scores.moneyPagesMetrics = null;
          }
        } else {
          debugLog(` saveAuditToSupabase: moneyPagesMetrics found in scores (${scores.moneyPagesMetrics.rows?.length || 0} rows)`, 'info');
        }
        
        // CRITICAL: Log what we're about to save
        debugLog(`saveAuditToSupabase: Final moneyPagesMetrics to save: ${scores.moneyPagesMetrics ? (scores.moneyPagesMetrics.rows?.length || 0) + ' rows' : 'NULL'}`, 'info');
        
        // Ensure overview is never null - create fallback if needed
        if (!overview) {
          debugLog(` saveAuditToSupabase: overview is null, creating fallback`, 'warn');
          overview = { 
            siteTotalImpressions: searchData?.totalImpressions || 0, 
            siteTotalClicks: searchData?.totalClicks || 0,
            totalImpressions: searchData?.totalImpressions || 0,
            totalClicks: searchData?.totalClicks || 0
          };
        }
        
        debugLog(`saveAuditToSupabase: About to call buildMoneyPagesSummary - overview exists=${!!overview}, overview.siteTotalImpressions=${overview?.siteTotalImpressions || 'missing'}, searchData.totalImpressions=${searchData?.totalImpressions || 'missing'}, moneyPagesMetrics=${!!scores?.moneyPagesMetrics}`, 'info');
        const moneyPagesSummary = window.buildMoneyPagesSummary ? window.buildMoneyPagesSummary(
          scores?.moneyPagesMetrics || null,
          overview || { siteTotalImpressions: 0, siteTotalClicks: 0, totalImpressions: 0, totalClicks: 0 }
        ) : null;
        if (moneyPagesSummary) {
          debugLog(`saveAuditToSupabase: moneyPagesSummary created - shareOfImpressions=${moneyPagesSummary.shareOfImpressions || 'null'}`, 'info');
        } else {
          debugLog(`saveAuditToSupabase: moneyPagesSummary is null`, 'warn');
        }
        
        // Get money segment metrics for 12-month KPI tracking
        // Ensure it's never null - build empty structure if missing
        let moneySegmentMetrics = window.moneySegmentMetrics;
        if (!moneySegmentMetrics) {
          debugLog(` saveAuditToSupabase: moneySegmentMetrics is null, building empty structure`, 'warn');
          // Build empty structure to ensure it's always saved (even if empty)
          if (typeof buildMoneySegmentSummary === 'function') {
            // Try to rebuild from moneyPagePriorityData if available
            const priorityData = window.moneyPagePriorityData || [];
            if (priorityData.length > 0) {
              debugLog(` saveAuditToSupabase: Rebuilding moneySegmentMetrics from priority data (${priorityData.length} pages)`, 'info');
              moneySegmentMetrics = buildMoneySegmentSummary(priorityData, {});
            } else {
              moneySegmentMetrics = buildMoneySegmentSummary([], {});
            }
          } else {
            // Fallback structure if function not available
            moneySegmentMetrics = {
              allMoney: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
              landingPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
              eventPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
              productPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 }
            };
          }
        }
        
        // Also ensure moneyPagePriorityData is available for saving
        if (!window.moneyPagePriorityData || window.moneyPagePriorityData.length === 0) {
          debugLog(` saveAuditToSupabase: moneyPagePriorityData is missing or empty`, 'warn');
          // Try to rebuild from moneyPagesMetrics if available
          if (scores?.moneyPagesMetrics?.rows && scores.moneyPagesMetrics.rows.length > 0) {
            debugLog(` saveAuditToSupabase: Rebuilding moneyPagePriorityData from moneyPagesMetrics (${scores.moneyPagesMetrics.rows.length} rows)`, 'info');
            const topPagesForPriority = scores.moneyPagesMetrics.rows.map(row => ({
              page: row.url,
              url: row.url,
              clicks: row.clicks || 0,
              impressions: row.impressions || 0,
              // row.ctr is already a ratio (0-1). Do NOT multiply by 100, or well display 100x inflated CTRs.
              ctr: (row.ctr || 0),
              position: row.avgPosition || 0,
              avgPosition: row.avgPosition || 0,
              title: row.title || row.url
            }));
            // Use window.buildMoneyPageMetrics if available, otherwise use local function
            if (typeof window.buildMoneyPageMetrics === 'function') {
              window.moneyPagePriorityData = window.buildMoneyPageMetrics(topPagesForPriority, schemaAudit);
            } else if (typeof buildMoneyPageMetrics === 'function') {
              window.moneyPagePriorityData = buildMoneyPageMetrics(topPagesForPriority, schemaAudit);
            } else {
              debugLog(` buildMoneyPageMetrics not available in saveAuditToSupabase, cannot rebuild`, 'error');
              window.moneyPagePriorityData = [];
            }
            debugLog(` saveAuditToSupabase: Rebuilt ${window.moneyPagePriorityData.length} priority entries`, 'info');
          }
        }
        debugLog(`saveAuditToSupabase: moneySegmentMetrics ready with ${Object.keys(moneySegmentMetrics).length} segments`, 'info');
        debugLog(`saveAuditToSupabase: moneySegmentMetrics.allMoney clicks=${moneySegmentMetrics.allMoney?.clicks || 0}, impressions=${moneySegmentMetrics.allMoney?.impressions || 0}`, 'info');
        
        // Get rankingAiData - but ONLY if this is a Ranking & AI scan, not a GSC audit
        // GSC audits don't fetch rankingAiData, so don't include old data from localStorage
        // The API will fetch it from Supabase if needed for computed fields
        let rankingAiData = null;
        
        // Only include rankingAiData if this is NOT a fresh GSC audit run
        // (GSC audits set window._isFreshAuditRun = true, but Ranking & AI scans don't)
        const isGscAudit = window._isFreshAuditRun === true;
        
        if (!isGscAudit) {
          // This is likely a Ranking & AI scan or a combined audit - include rankingAiData if available
          try {
            const localRankingData = localStorage.getItem('rankingAiData');
            if (localRankingData) {
              rankingAiData = JSON.parse(localRankingData);
              debugLog(` saveAuditToSupabase: Loaded rankingAiData from localStorage (${rankingAiData.combinedRows?.length || 0} keywords)`, 'info');
            } else if (window.rankingAiData) {
              rankingAiData = window.rankingAiData;
              debugLog(` saveAuditToSupabase: Using rankingAiData from window (${rankingAiData.combinedRows?.length || 0} keywords)`, 'info');
            } else {
              debugLog(` saveAuditToSupabase: No rankingAiData available`, 'warn');
            }
          } catch (rankingErr) {
            debugLog(` saveAuditToSupabase: Error loading rankingAiData: ${rankingErr.message}`, 'warn');
          }
        } else {
          debugLog(` saveAuditToSupabase: GSC audit detected - skipping rankingAiData (will be fetched from Supabase by API if needed)`, 'info');
        }
        
        // Ensure scores.moneyPages namespace exists and includes GSC page totals
        scores.moneyPages = scores.moneyPages || {};
        if (scores.moneyPagesMetrics) {
          // Add GSC range and page totals for persistence (if available)
          if (scores.moneyPagesMetrics.gscRange) {
            scores.moneyPages.gscRange = scores.moneyPagesMetrics.gscRange;
          }
          if (scores.moneyPagesMetrics.gscPageTotals28d) {
            scores.moneyPages.gscPageTotals28d = scores.moneyPagesMetrics.gscPageTotals28d;
          }
        }
        
        // Fetch domain strength snapshot for storage (if not already available)
        let domainStrength = null;
        try {
          // Normalize domain for domain strength API
          const normalizedDomain = propertyUrl.replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
          debugLog(`saveAuditToSupabase: Fetching domain strength for ${normalizedDomain}`, 'info');
          
          const urlHelper = window.apiUrl || ((path) => {
            const base = window.location.origin.includes('localhost') ? 'http://localhost:3000' : 'https://ai-geo-audit.vercel.app';
            return `${base}${path}`;
          });
          const domainStrengthResp = await fetch(urlHelper(`/api/domain-strength/overview`));
          if (domainStrengthResp.ok) {
            const domainStrengthJson = await domainStrengthResp.json();
            if (domainStrengthJson?.status === 'ok' && Array.isArray(domainStrengthJson.items)) {
              // Find our domain in the overview response
              const ourItem = domainStrengthJson.items.find(item => {
                const itemDomain = String(item?.domain || '').replace(/^www\./, '').toLowerCase();
                return itemDomain === normalizedDomain.toLowerCase();
              });
              
              if (ourItem && ourItem.latest) {
                const latest = ourItem.latest;
                domainStrength = {
                  selfScore: typeof latest.score === 'number' ? latest.score : null,
                  topCompetitorScore: typeof ourItem.topCompetitor?.score === 'number' ? ourItem.topCompetitor.score : null,
                  strongerCount: typeof ourItem.strongerCount === 'number' ? ourItem.strongerCount : null,
                  competitorsCount: typeof ourItem.competitorsCount === 'number' ? ourItem.competitorsCount : null,
                  snapshotDate: latest.snapshotDate || null
                };
                debugLog(` saveAuditToSupabase: Fetched domain strength - selfScore=${domainStrength.selfScore}, snapshotDate=${domainStrength.snapshotDate}`, 'success');
              } else {
                debugLog(` saveAuditToSupabase: Domain ${normalizedDomain} not found in domain strength overview`, 'warn');
              }
            } else {
              debugLog(` saveAuditToSupabase: Domain strength overview response invalid: status=${domainStrengthJson?.status}`, 'warn');
            }
          } else {
            debugLog(` saveAuditToSupabase: Failed to fetch domain strength: ${domainStrengthResp.status}`, 'warn');
          }
        } catch (domainStrengthErr) {
          debugLog(` saveAuditToSupabase: Error fetching domain strength: ${domainStrengthErr.message}`, 'warn');
          // Continue without domain strength - it's not critical for saving the audit
        }
        
        // Prepare full payload to check size
        const fullPayload = {
          propertyUrl,
          auditDate,
          schemaAudit,
          scores,
          searchData,
          snippetReadiness,
          localSignals, // Pass Business Profile data for storage
          backlinkMetrics, // Pass backlink metrics data for storage
          moneyPagesSummary, // Phase 3: Money Pages summary for trend tracking
          moneySegmentMetrics, // Phase: Money Pages Priority Matrix - segment metrics for KPI tracker
          moneyPagePriorityData: window.moneyPagePriorityData || null, // CRITICAL: Save Priority Matrix data to Supabase
          rankingAiData, // Ranking & AI data (SERP rankings + AI Overview citations)
          domainStrength // Domain strength snapshot for historical delta calculations
        };
        
        // Check payload size before sending (Vercel limit is ~4.5MB)
        const payloadJson = JSON.stringify(fullPayload);
        const payloadSizeKB = Math.round(payloadJson.length / 1024);
        debugLog(`saveAuditToSupabase: Full payload size: ${payloadSizeKB}KB`, 'info');
        
        // Extract large fields that might need to be saved separately
        const queryPages = searchData?.queryPages || null;
        const topQueries = searchData?.topQueries || null;
        const queryPagesSizeKB = queryPages ? Math.round(JSON.stringify(queryPages).length / 1024) : 0;
        const topQueriesSizeKB = topQueries ? Math.round(JSON.stringify(topQueries).length / 1024) : 0;
        
        const logBatchPartialStatus = (batchLabel, result) => {
          const record = result && Array.isArray(result.data) ? result.data[0] : null;
          if (!record) {
            debugLog(` ${batchLabel}: No audit record returned`, 'info');
            return;
          }
          if (record.is_partial === true) {
            const reason = record.partial_reason ? ` (${record.partial_reason})` : '';
            debugLog(` ${batchLabel}: audit marked partial${reason}`, 'warn');
          } else if (record.is_partial === false) {
            debugLog(` ${batchLabel}: audit marked complete (is_partial=false)`, 'success');
          }
        };
        
        // OPTION 3: Split into batches if payload exceeds 3.5MB (safety margin)
        const USE_BATCH_SAVE = payloadSizeKB > 3500;
        
        if (USE_BATCH_SAVE) {
          debugLog(` Payload size (${payloadSizeKB}KB) exceeds 3.5MB - splitting into batches...`, 'info');
          debugLog(` Large fields: queryPages=${queryPagesSizeKB}KB, topQueries=${topQueriesSizeKB}KB`, 'info');
          
          // BATCH 1: Core audit data (without large fields)
          const coreSearchData = { ...searchData };
          delete coreSearchData.queryPages;
          delete coreSearchData.topQueries;
          
          const batch1Payload = {
            ...fullPayload,
            searchData: coreSearchData
          };
          
          const batch1SizeKB = Math.round(JSON.stringify(batch1Payload).length / 1024);
          debugLog(` Batch 1 (Core data): ${batch1SizeKB}KB`, 'info');
          
          // Save Batch 1: Core audit data
          debugLog(` Saving batch 1/3: Core audit data (scores, dates, summaries)...`, 'info');
          const batch1Response = await fetch(apiUrl('/api/supabase/save-audit'), {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(batch1Payload)
          });
          
          if (!batch1Response.ok) {
            const errorText = await batch1Response.text();
            let errorMessage = 'Unknown error';
            try {
              const error = JSON.parse(errorText);
                errorMessage = error.details || error.message || errorText;
            } catch (e) {
              errorMessage = errorText || `HTTP ${batch1Response.status}: ${batch1Response.statusText}`;
            }
            throw new Error(`Failed to save batch 1 (core data): ${errorMessage}`);
          }
          
          const batch1Result = await batch1Response.json();
          debugLog(` Batch 1/3 saved successfully`, 'success');
          logBatchPartialStatus('Batch 1/3', batch1Result);
          
          // BATCH 2: queryPages (if exists and is large)
          if (queryPages && Array.isArray(queryPages) && queryPages.length > 0) {
            debugLog(` Saving batch 2/3: Query pages data (${queryPages.length} items, ${queryPagesSizeKB}KB)...`, 'info');
            const batch2Payload = {
              propertyUrl,
              auditDate,
              searchData: {
                queryPages: queryPages
              }
            };
            
            const batch2Response = await fetch(apiUrl('/api/supabase/save-audit'), {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(batch2Payload)
            });
            
            if (!batch2Response.ok) {
              const errorText = await batch2Response.text();
              let errorMessage = 'Unknown error';
              try {
                const error = JSON.parse(errorText);
                errorMessage = error.details || error.message || errorText;
              } catch (e) {
                errorMessage = errorText || `HTTP ${batch2Response.status}: ${batch2Response.statusText}`;
              }
              debugLog(` Batch 2/3 failed (non-critical): ${errorMessage}`, 'warn');
              // Continue - core data is saved
            } else {
              let batch2Result = null;
              try {
                batch2Result = await batch2Response.json();
              } catch (e) {
                debugLog(` Batch 2/3 response JSON parse failed: ${e.message}`, 'warn');
              }
              debugLog(` Batch 2/3 saved successfully`, 'success');
              if (batch2Result) {
                logBatchPartialStatus('Batch 2/3', batch2Result);
              }
            }
          } else {
            debugLog(` Batch 2/3 skipped: No queryPages data to save`, 'info');
          }
          
          // BATCH 3: topQueries (if exists and is large)
          if (topQueries && Array.isArray(topQueries) && topQueries.length > 0) {
            debugLog(` Saving batch 3/3: Top queries data (${topQueries.length} items, ${topQueriesSizeKB}KB)...`, 'info');
            const batch3Payload = {
              propertyUrl,
              auditDate,
              searchData: {
                topQueries: topQueries
              }
            };
            
            const batch3Response = await fetch(apiUrl('/api/supabase/save-audit'), {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(batch3Payload)
            });
            
            if (!batch3Response.ok) {
              const errorText = await batch3Response.text();
              let errorMessage = 'Unknown error';
              try {
                const error = JSON.parse(errorText);
              errorMessage = error.details || error.message || errorText;
              } catch (e) {
                errorMessage = errorText || `HTTP ${batch3Response.status}: ${batch3Response.statusText}`;
              }
              debugLog(` Batch 3/3 failed (non-critical): ${errorMessage}`, 'warn');
              // Continue - core data is saved
            } else {
              let batch3Result = null;
              try {
                batch3Result = await batch3Response.json();
              } catch (e) {
                debugLog(` Batch 3/3 response JSON parse failed: ${e.message}`, 'warn');
              }
              debugLog(` Batch 3/3 saved successfully`, 'success');
              if (batch3Result) {
                logBatchPartialStatus('Batch 3/3', batch3Result);
              }
            }
          } else {
            debugLog(` Batch 3/3 skipped: No topQueries data to save`, 'info');
          }
          
          debugLog(` All batches saved successfully (audit_date: ${auditDate})`, 'success');
          const result = batch1Result; // Use batch 1 result for verification
          debugLog(` Saved data: schema_total_pages=${schemaAudit?.data?.totalPages || 'N/A'}, scores=${JSON.stringify(Object.keys(scores || {}))}`, 'info');
          
        } else {
          // Single request (payload is small enough)
          debugLog(` Payload size (${payloadSizeKB}KB) is under 3.5MB - saving in single request...`, 'info');
          
          const response = await fetch(apiUrl('/api/supabase/save-audit'), {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(fullPayload)
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            let errorMessage = 'Unknown error';
            try {
              const error = JSON.parse(errorText);
              errorMessage = error.details || error.message || errorText;
            } catch (e) {
              errorMessage = errorText || `HTTP ${response.status}: ${response.statusText}`;
            }
            throw new Error(`Failed to save audit to Supabase: ${errorMessage}`);
          }
          
          const result = await response.json();
          debugLog(` Audit results saved to Supabase successfully (audit_date: ${auditDate})`, 'success');
          debugLog(` Saved data: schema_total_pages=${schemaAudit?.data?.totalPages || 'N/A'}, scores=${JSON.stringify(Object.keys(scores || {}))}`, 'info');
        }
        
        // Verify the save by checking Supabase (works for both single and batch saves)
        try {
          debugLog('Verifying audit save in Supabase...', 'info');
          const verifyResponse = await fetch(apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}&minimal=true`));
          if (verifyResponse.ok) {
              const verifyResult = await verifyResponse.json();
              if (verifyResult.status === 'ok' && verifyResult.data && verifyResult.data.auditDate === auditDate) {
                debugLog(` Verified: Audit ${auditDate} exists in Supabase with schema_total_pages=${verifyResult.data.scores?.contentSchema !== null ? 'present' : 'null'}`, 'success');
                showStatus(` Audit saved and verified in Supabase (${auditDate})`, 'success');
          } else {
            debugLog(` Verification failed: Audit ${auditDate} not found in Supabase yet`, 'warn');
            showStatus(` Audit save reported success but verification pending (${auditDate})`, 'warn');
          }
        } else {
          debugLog(` Could not verify audit save: ${verifyResponse.status}`, 'warn');
          showStatus(` Audit saved to Supabase (${auditDate}) - verification skipped`, 'success');
        }
      } catch (verifyError) {
        debugLog(` Verification error (non-critical): ${verifyError.message}`, 'warn');
        showStatus(` Audit saved to Supabase (${auditDate})`, 'success');
      }
      
      // Save GSC page-level 28d metrics to Supabase
      try {
            if (window._pendingPageMetrics && window._pendingPageMetrics.pages && window._pendingPageMetrics.pages.length > 0) {
              debugLog(` Saving ${window._pendingPageMetrics.pages.length} page metrics to Supabase (run_id: ${auditDate})...`, 'info');
              
              const saveResponse = await fetch(apiUrl('/api/supabase/save-gsc-page-metrics'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  runId: auditDate,
                  siteUrl: window._pendingPageMetrics.propertyUrl,
                  dateStart: window._pendingPageMetrics.gscRange.startDate,
                  dateEnd: window._pendingPageMetrics.gscRange.endDate,
                  pages: window._pendingPageMetrics.pages
                })
              });
              
              if (saveResponse.ok) {
                const saveResult = await saveResponse.json();
                debugLog(` Saved ${saveResult.inserted} page metrics to Supabase`, 'success');
                
                // Calculate and save portfolio segment snapshots (Phase 3a)
                try {
                  await calculateAndSavePortfolioSegmentSnapshots(
                    auditDate,
                    window._pendingPageMetrics.propertyUrl,
                    window._pendingPageMetrics.gscRange.startDate,
                    window._pendingPageMetrics.gscRange.endDate,
                    window.pageTotalsByKey || new Map()
                  );
                } catch (segmentError) {
                  debugLog(` Error saving portfolio segment snapshots (non-critical): ${segmentError.message}`, 'warn');
                }
                
                // Clear pending metrics
                window._pendingPageMetrics = null;
        } else {
          const errorText = await saveResponse.text();
          debugLog(` Failed to save page metrics to Supabase: ${saveResponse.status} - ${errorText}`, 'warn');
        }
      }
    } catch (pageMetricsError) {
      debugLog(` Error saving page metrics to Supabase (non-critical): ${pageMetricsError.message}`, 'warn');
    }
    
    // Calculate and save portfolio snapshots (Phase 3)
    try {
      await calculateAndSavePortfolioSnapshots(auditDate);
    } catch (portfolioError) {
      debugLog(` Error saving portfolio snapshots (non-critical): ${portfolioError.message}`, 'warn');
    }
    
    // After saving, refresh Money Pages charts with updated history
    // This ensures the trend chart and KPI tracker show the new audit data
    try {
      debugLog('Refreshing Money Pages charts with updated history...', 'info');
      
      // Refresh KPI tracker (which now also refreshes Performance Trends from portfolio metrics).
      if (typeof window.loadAuditHistoryAndRenderKpis === 'function') {
        setTimeout(() => {
          window.loadAuditHistoryAndRenderKpis(propertyUrl);
          debugLog(' Money Pages KPI tracker + trends refreshed', 'success');
        }, 500);
      }
    } catch (refreshError) {
      debugLog(` Error refreshing Money Pages charts: ${refreshError.message}`, 'warn');
      // Don't fail the save operation if refresh fails
    }
      } catch (error) {
        // Show error to user - this is critical for data persistence
        debugLog(` Supabase save exception: ${error.message}`, 'error');
        console.error('[Supabase Save] Exception:', error);
        showStatus(` Failed to save audit to Supabase: ${error.message}. Check console for details.`, 'error');
        // CRITICAL: Re-throw error so calling code knows the save failed
        throw error;
      }
    }
    
    // Fetch historical Content/Schema data from Supabase
    // Forward-fill missing audit dates in history data (exclude last 3 days due to GSC lag)
    function forwardFillHistoryData(history, excludeLastDays = 3) {
      if (!history || history.length === 0) return history;
      
      // Sort by date
      const sorted = [...history].sort((a, b) => new Date(a.date) - new Date(b.date));
      
      // Calculate cutoff date (exclude last N days)
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - excludeLastDays);
      
      // Track last known values for each metric
      const lastValues = {};
      
      // Forward-fill missing values (but not for dates in the last N days)
      return sorted.map(entry => {
        const entryDate = new Date(entry.date);
        const isRecent = entryDate >= cutoffDate;
        
        // List of metric keys to forward-fill
        const metricKeys = [
          'contentSchemaScore', 'visibilityScore', 'authorityScore', 'localEntityScore', 'serviceAreaScore',
          'brandScore', 'moneyPagesBehaviourScore', 'shareOfImpressions', 'shareOfClicks', 'ctr',
          'authorityBehaviourScore', 'authorityRankingScore', 'authorityBacklinkScore', 'authorityReviewScore'
        ];
        
        const filled = { ...entry };
        
        for (const key of metricKeys) {
          const value = entry[key];
          
          // Only forward-fill if:
          // 1. Value is null/undefined (NOT 0, as 0 is a valid score) AND
          // 2. We have a last known value AND
          // 3. This is NOT a recent date (within last N days)
          if ((value == null || value === undefined) && lastValues[key] != null && !isRecent) {
            filled[key] = lastValues[key];
          } else if (value != null && value !== undefined) {
            // Update last known value (including 0, as it's a valid score)
            lastValues[key] = value;
          }
        }
        
        // Handle nested objects (e.g., moneyPagesSummary)
        if (entry.moneyPagesSummary) {
          filled.moneyPagesSummary = { ...entry.moneyPagesSummary };
          const summaryKeys = ['shareOfImpressions', 'shareOfClicks', 'ctr'];
          for (const key of summaryKeys) {
            const value = entry.moneyPagesSummary[key];
            if ((value == null || value === undefined) && lastValues[`summary_${key}`] != null && !isRecent) {
              filled.moneyPagesSummary[key] = lastValues[`summary_${key}`];
            } else if (value != null && value !== undefined) {
              lastValues[`summary_${key}`] = value;
            }
          }
        }
        
        return filled;
      });
    }
    
    async function fetchContentSchemaHistory(propertyUrl, startDate, endDate) {
      try {
        // Use window.apiUrl if available (for functions outside the main scope)
        const urlHelper = window.apiUrl || ((path) => {
          // Fallback: check if running locally and prepend Vercel URL
          const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
          const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
          if (!baseUrl) {
            return path.startsWith('/') ? path : `/${path}`;
          }
          const cleanPath = path.startsWith('/') ? path : `/${path}`;
          return `${baseUrl}${cleanPath}`;
        });
        const response = await fetch(urlHelper(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDate}&endDate=${endDate}`));
        
        if (response.ok) {
          const result = await response.json();
          if (result.status === 'ok' && result.data) {
            debugLog(` Fetched ${result.count} historical Content/Schema records from Supabase`, 'success');
            // Forward-fill missing audit dates (exclude last 3 days for GSC lag)
            const filledData = forwardFillHistoryData(result.data, 3);
            return filledData;
          }
          } else {
            // Read response body once as text, then try to parse as JSON to avoid "body stream already read" error
            debugLog(` Supabase API returned non-OK status: ${response.status} ${response.statusText}`, 'warn');
            try {
              const responseText = await response.text();
              try {
                const error = JSON.parse(responseText);
                debugLog(` Supabase API error: ${error.message || 'Unknown error'}`, 'warn');
              } catch (parseError) {
                debugLog(` Supabase API error (non-JSON): ${responseText || 'Unknown error'}`, 'warn');
              }
            } catch (textError) {
              debugLog(` Could not read Supabase error response: ${textError.message}`, 'warn');
            }
          }
      } catch (error) {
        debugLog(` Supabase fetch error: ${error.message}`, 'warn');
      }
      return [];
    }
    
    // Fetch the latest audit from Supabase
    async function fetchLatestAuditFromSupabase(propertyUrl, minimalOnly = false) {
      try {
        if (!propertyUrl) {
          debugLog(' Cannot fetch from Supabase: property URL not set', 'warn');
          return null;
        }
        
        // Use window.apiUrl if available (for functions outside the main scope)
        const urlHelper = window.apiUrl || ((path) => {
          // Fallback: check if running locally and prepend Vercel URL
          const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
          const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
          if (!baseUrl) {
            return path.startsWith('/') ? path : `/${path}`;
          }
          const cleanPath = path.startsWith('/') ? path : `/${path}`;
          return `${baseUrl}${cleanPath}`;
        });
        
        // Step 1: Try minimal request first to get timestamp (fast, unlikely to timeout)
        let minimalData = null;
        if (!minimalOnly) {
          debugLog(`Fetching minimal audit data (timestamp + scores) from Supabase for ${propertyUrl}...`, 'info');
          try {
            const minimalController = new AbortController();
            const minimalTimeout = setTimeout(() => minimalController.abort(), 10000); // 10 second timeout
            
            const minimalResponse = await fetch(urlHelper(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}&minimal=true`), {
              signal: minimalController.signal
            });
            clearTimeout(minimalTimeout);
            
            if (minimalResponse.ok) {
              const minimalResult = await minimalResponse.json();
              if (minimalResult.status === 'ok' && minimalResult.data && minimalResult.data.timestamp) {
                minimalData = minimalResult.data; // Store minimal data for fallback
                // Update timestamp immediately, even if full data fetch fails
                updateAuditTimestamp(minimalResult.data.timestamp);
                debugLog(` Updated audit timestamp from minimal Supabase response: ${new Date(minimalResult.data.timestamp).toLocaleString()}`, 'success');
              }
            }
          } catch (minimalError) {
            if (minimalError.name === 'AbortError') {
              debugLog(` Minimal request timed out (non-critical)`, 'warn');
            } else {
              debugLog(` Minimal request failed (non-critical): ${minimalError.message}`, 'warn');
            }
            // Continue to try full request
          }
        }
        
        // Step 2: Try full request (may timeout, but we already have timestamp)
        debugLog(`Fetching full audit data from Supabase for ${propertyUrl}...`, 'info');
        try {
          const fullController = new AbortController();
          const fullTimeout = setTimeout(() => fullController.abort(), 30000); // 30 second timeout
          
          const response = await fetch(urlHelper(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`), {
            signal: fullController.signal
          });
          clearTimeout(fullTimeout);
          
          if (response.ok) {
            const result = await response.json();
            debugLog(` Supabase API response: status=${result.status}, hasData=${!!result.data}`, result.status === 'ok' && result.data ? 'success' : 'warn');
            if (result.status === 'ok' && result.data) {
              debugLog(` Found latest audit from Supabase: ${result.data.auditDate || 'unknown date'}`, 'success');
              // Debug: Check what moneyPagesMetrics structure we got
              const hasMoneyPages = !!(result.data?.scores?.moneyPagesMetrics || result.data?.moneyPagesMetrics);
              debugLog(` Supabase data check: hasMoneyPagesMetrics=${hasMoneyPages}, structure=${result.data?.scores?.moneyPagesMetrics ? 'scores.moneyPagesMetrics' : result.data?.moneyPagesMetrics ? 'moneyPagesMetrics' : 'none'}`, 'info');
              if (hasMoneyPages) {
                const rows = result.data?.scores?.moneyPagesMetrics?.rows || result.data?.moneyPagesMetrics?.rows || [];
                debugLog(` Supabase moneyPagesMetrics has ${rows.length} rows`, 'success');
                // CRITICAL: Reconstruct scores.moneyPages from moneyPagesMetrics if gscPageTotals28d exists
                const moneyPagesMetrics = result.data?.scores?.moneyPagesMetrics || result.data?.moneyPagesMetrics;
                if (moneyPagesMetrics && (moneyPagesMetrics.gscPageTotals28d || moneyPagesMetrics.gscRange)) {
                  if (!result.data.scores) result.data.scores = {};
                  if (!result.data.scores.moneyPages) result.data.scores.moneyPages = {};
                  if (moneyPagesMetrics.gscRange) {
                    result.data.scores.moneyPages.gscRange = moneyPagesMetrics.gscRange;
                  }
                  if (moneyPagesMetrics.gscPageTotals28d) {
                    result.data.scores.moneyPages.gscPageTotals28d = moneyPagesMetrics.gscPageTotals28d;
                    debugLog(` Reconstructed scores.moneyPages.gscPageTotals28d from moneyPagesMetrics (${moneyPagesMetrics.gscPageTotals28d.length} pages)`, 'success');
                  }
                }
              } else {
                debugLog(` Supabase data missing moneyPagesMetrics!`, 'warn');
              }
              // Debug: Check queryTotals in response
              const hasQueryTotals = !!(result.data?.searchData?.queryTotals && Array.isArray(result.data.searchData.queryTotals));
              debugLog(` Supabase queryTotals check: hasSearchData=${!!result.data?.searchData}, hasQueryTotals=${hasQueryTotals}, length=${result.data?.searchData?.queryTotals?.length || 0}`, hasQueryTotals ? 'success' : 'warn');
              if (result.data.searchData) {
                debugLog(` Supabase searchData keys: ${Object.keys(result.data.searchData).join(', ')}`, 'info');
              } else {
                debugLog(` Supabase data missing searchData!`, 'warn');
              }
              // Ensure timestamp is set from Supabase data (use timestamp if available, otherwise construct from auditDate)
              if (result.data.timestamp) {
                // Convert to ISO string if it's a number (milliseconds since epoch)
                if (typeof result.data.timestamp === 'number') {
                  result.data.timestamp = new Date(result.data.timestamp).toISOString();
                }
                // Timestamp is already set (and now in ISO string format)
              } else if (result.data.auditDate) {
                // Construct timestamp from auditDate (use noon as default time to avoid timezone issues)
                const auditDateStr = result.data.auditDate;
                result.data.timestamp = new Date(auditDateStr + 'T12:00:00').toISOString();
                debugLog(` Constructed timestamp from auditDate: ${auditDateStr}`, 'info');
              }
              // Update timestamp display immediately when Supabase data is loaded
              if (result.data.timestamp) {
                updateAuditTimestamp(result.data.timestamp);
                debugLog(` Updated audit timestamp display from Supabase data`, 'success');
              }
              return result.data;
            } else {
              debugLog(` No audit found in Supabase - result.status=${result.status}, hasData=${!!result.data}, error=${result.message || 'none'}`, 'warn');
              // Return minimal data if available, otherwise null
              if (minimalData) {
                debugLog(` Returning minimal data (timestamp + scores) as fallback`, 'info');
                return minimalData;
              }
              return null;
            }
          } else {
            const responseText = await response.text();
            try {
              const error = JSON.parse(responseText);
              debugLog(` Could not fetch latest audit from Supabase: ${error.message || 'Unknown error'}`, 'warn');
              if (error.message && error.message.includes('FUNCTION_INVOCATION_FAILED')) {
                debugLog(` Full data fetch failed due to timeout/size. Returning minimal data (timestamp + scores) as fallback.`, 'warn');
                if (minimalData) {
                  return minimalData;
                }
              }
            } catch (parseError) {
              debugLog(` Could not fetch latest audit from Supabase: ${responseText || 'Unknown error'}`, 'warn');
            }
            // Return minimal data if available, otherwise null
            if (minimalData) {
              debugLog(` Returning minimal data (timestamp + scores) as fallback after full request failure`, 'info');
              return minimalData;
            }
            return null;
          }
        } catch (error) {
          if (error.name === 'AbortError' || error.name === 'TimeoutError' || error.message.includes('timeout')) {
            debugLog(` Supabase fetch timed out. Returning minimal data (timestamp + scores) as fallback.`, 'warn');
            if (minimalData) {
              return minimalData;
            }
          } else {
            debugLog(` Supabase fetch error: ${error.message}`, 'warn');
          }
          // Return minimal data if available, otherwise null
          if (minimalData) {
            debugLog(` Returning minimal data (timestamp + scores) as fallback after error`, 'info');
            return minimalData;
          }
          return null;
        }
      } catch (outerError) {
        // Catch any errors in the outer try block (shouldn't happen, but just in case)
        debugLog(` Outer error in fetchLatestAuditFromSupabase: ${outerError.message}`, 'warn');
        if (minimalData) {
          return minimalData;
        }
        return null;
      }
    }
    
    function normalizePropertyHost(value) {
      if (!value || typeof value !== 'string') return '';
      const trimmed = value.trim();
      if (!trimmed) return '';
      try {
        const url = trimmed.startsWith('http') ? new URL(trimmed) : new URL(`https://${trimmed}`);
        return url.hostname.replace(/^www\./i, '').toLowerCase();
      } catch (e) {
        return trimmed
          .replace(/^https?:\/\//i, '')
          .replace(/^www\./i, '')
          .split('/')[0]
          .toLowerCase();
      }
    }

    function getAuditPropertyHost(auditData) {
      const raw = auditData?.propertyUrl ||
        auditData?.property_url ||
        auditData?.searchData?.propertyUrl ||
        auditData?.searchData?.property_url ||
        '';
      return normalizePropertyHost(raw);
    }

    /**
     * Unified Data Fetching Utility (Phase 4)
     * Standardized function for fetching audit data with Supabase-first pattern and localStorage fallback
     * 
     * @param {string} propertyUrl - Property URL to fetch audit for
     * @param {Object} options - Configuration options
     * @param {boolean} options.minimalOnly - If true, fetch minimal data only (timestamp + scores)
     * @param {string} options.localStorageKey - localStorage key to use for fallback (default: 'last_audit_results')
     * @param {string} options.context - Context for logging (e.g., 'Global Run', 'Money Pages Scan')
     * @param {boolean} options.updateLocalStorage - If true, update localStorage with fresh Supabase data (default: true)
     * @returns {Promise<Object|null>} Audit data object or null if not found
     */
    async function fetchAuditDataUnified(propertyUrl, options = {}) {
      const {
        minimalOnly = false,
        localStorageKey = 'last_audit_results',
        context = 'Audit Data Fetch',
        updateLocalStorage = true
      } = options;
      
      // Get property URL if not provided
      if (!propertyUrl) {
        propertyUrl = typeof window.getPropertyUrl === 'function' 
          ? window.getPropertyUrl() 
          : (localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '');
      }
      
      if (!propertyUrl) {
        debugLog(`[${context}]  Cannot fetch audit data: property URL not set`, 'warn');
        return null;
      }
      
      // Step 1: Try Supabase first (source of truth)
      let auditData = null;
      let dataSource = null;
      
      if (typeof window.fetchLatestAuditFromSupabase === 'function') {
        try {
          debugLog(`[${context}] Fetching latest audit from Supabase (source of truth)...`, 'info');
          auditData = await window.fetchLatestAuditFromSupabase(propertyUrl, minimalOnly);
          
          if (auditData) {
            dataSource = 'supabase';
            debugLog(`[${context}]  Fetched audit from Supabase: hasSearchData=${!!auditData.searchData}, hasMoneyPagesMetrics=${!!(auditData.scores?.moneyPagesMetrics || auditData.moneyPagesMetrics)}`, 'success');
            
            // Update localStorage with fresh Supabase data for consistency
            if (updateLocalStorage) {
              try {
                localStorage.setItem(localStorageKey, JSON.stringify(auditData));
                debugLog(`[${context}]  Updated localStorage with fresh Supabase data`, 'success');
              } catch (localStorageErr) {
                debugLog(`[${context}]  Failed to update localStorage: ${localStorageErr.message}`, 'warn');
              }
            }
          } else {
            debugLog(`[${context}]  No audit data returned from Supabase, falling back to localStorage...`, 'warn');
          }
        } catch (supabaseError) {
          debugLog(`[${context}]  Failed to fetch from Supabase: ${supabaseError?.message || supabaseError}, falling back to localStorage...`, 'warn');
        }
      } else {
        debugLog(`[${context}]  fetchLatestAuditFromSupabase function not available, falling back to localStorage...`, 'warn');
      }
      
      // Step 2: Fallback to localStorage if Supabase fetch failed or returned no data
      if (!auditData) {
        try {
          const localData = localStorage.getItem(localStorageKey);
          if (localData) {
            auditData = dashboardSafeJsonParse(localData, null);
            if (auditData) {
              const requestedHost = normalizePropertyHost(propertyUrl);
              const storedHost = getAuditPropertyHost(auditData);
              if (requestedHost && storedHost && requestedHost !== storedHost) {
                debugLog(`[${context}]  Ignoring localStorage audit (property mismatch: ${storedHost} vs ${requestedHost})`, 'warn');
                auditData = null;
              } else {
                dataSource = 'localStorage';
                debugLog(`[${context}]  Using audit data from localStorage (fallback)`, 'info');
              }
            } else {
              debugLog(`[${context}]  Invalid data in localStorage`, 'warn');
            }
          } else {
            debugLog(`[${context}]  No audit data in localStorage`, 'warn');
          }
        } catch (localStorageError) {
          debugLog(`[${context}]  Error reading from localStorage: ${localStorageError.message}`, 'warn');
        }
      }
      
      // Log final result
      if (auditData) {
        debugLog(`[${context}]  Audit data loaded from ${dataSource}`, 'success');
      } else {
        debugLog(`[${context}]  No audit data available from Supabase or localStorage`, 'error');
      }
      
      return auditData;
    }
    
    // Expose to window for global access
    window.fetchAuditDataUnified = fetchAuditDataUnified;
    
    // Update retry button visibility based on failed URLs
    function updateRetryButtonVisibility(schemaAudit) {
      const retryBtn = document.getElementById('retryFailedUrlsBtn');
      if (!retryBtn) return;
      
      if (schemaAudit && schemaAudit.data && schemaAudit.data.missingSchemaPages) {
        const failedUrls = schemaAudit.data.missingSchemaPages.filter(p => p.error);
        if (failedUrls.length > 0) {
          retryBtn.style.display = 'inline-block';
          retryBtn.textContent = ` Retry Failed URLs (${failedUrls.length})`;
        } else {
          retryBtn.style.display = 'none';
        }
      } else {
        retryBtn.style.display = 'none';
      }
    }

    // Close completion modal
    function closeCompletionModal() {
      const modal = document.getElementById('completionModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    // Close modal when clicking outside
    window.onclick = function(event) {
      const modal = document.getElementById('completionModal');
      if (event.target === modal) {
        closeCompletionModal();
      }
    }

    // Calculate RAG status from score
    function getRAGStatus(score) {
      if (score >= 70) return { status: 'green', label: 'Green' };
      if (score >= 40) return { status: 'amber', label: 'Amber' };
      return { status: 'red', label: 'Red' };
    }

    // Helper: clamp score to 0-100 and round
    function clampScore(value) {
      return Math.max(0, Math.min(100, Math.round(value)));
    }

    // Calculate pillar scores (deterministic, based on GSC data and schema audit)
    
    // Page Segment Classifier
    // NOTE: PageSegment classification is derived from the canonical site-urls CSV.
    // GSC page URLs are matched by path against this inventory and then classified by
    // classifyPageSegment(...) to keep behaviour/ranking segments aligned with the UI.
    const PageSegment = {
      EDUCATION: 'education',
      MONEY: 'money',
      SUPPORT: 'support',
      SYSTEM: 'system'
    };
    
    /**
     * Canonicalize URL - removes query params, fragments, normalizes trailing slashes
     * Returns full URL with origin and path only (no query/hash)
     * @param {string} raw - Raw URL (may contain query params, fragments)
     * @returns {string} Canonical URL
     */
    function canonicalizeUrl(raw) {
      if (!raw) return "";
      
      try {
        const u = raw.startsWith("http") ? new URL(raw) : new URL(raw, "https://www.alanranger.com");
        let path = u.pathname || "/";
        if (path.length > 1) path = path.replace(/\/+$/, "");
        return `${u.origin}${path}`;
      } catch (e) {
        const noHash = raw.split("#")[0];
        const noQuery = noHash.split("?")[0];
        return (noQuery.replace(/\/+$/, "") || raw).trim();
      }
    }
    
    function normalisePath(rawUrlOrPath) {
      try {
        let url;
        if (rawUrlOrPath && rawUrlOrPath.startsWith('http')) {
          url = new URL(rawUrlOrPath);
        } else {
          url = new URL(rawUrlOrPath || '/', 'https://www.alanranger.com');
        }
        let p = url.pathname.toLowerCase();
        if (p.length > 1 && p.endsWith('/')) p = p.slice(0, -1);
        return p;
      } catch (e) {
        return '/';
      }
    }
    
    function isFineArtGalleryPage(path) {
      const p = path.toLowerCase();
      // Explicit known fine-art URLs from 06-site-urls.csv
      if (
        p === '/fine-art-prints' ||
        p === '/photography-services-near-me/fine-art-photography-prints-unframed' ||
        p === '/photography-services-near-me/framed-fine-art-photography-prints' ||
        p === '/photography-services-near-me/fine-art-photography-prints-canvas'
      ) {
        return true;
      }
      // Safety net: treat any future fine-art print variants as gallery/info too
      return (
        p.includes('fine-art-prints') ||
        p.includes('fine-art-photography-prints')
      );
    }
    
    function classifyPageSegment(rawUrlOrPath, title = null, kindOverride = null) {
      const path = normalisePath(rawUrlOrPath);
      
      // Manual overrides via CSV column
      if (kindOverride) {
        const v = kindOverride.toLowerCase().trim();
        if (v === 'education' || v === 'educational') return PageSegment.EDUCATION;
        if (v === 'money' || v === 'commercial') return PageSegment.MONEY;
        if (v === 'support') return PageSegment.SUPPORT;
        if (v === 'system') return PageSegment.SYSTEM;
      }
      
      // Education  all blogs + free course + calculator + tips hub
      // EXCLUDE blog posts from money pages (check both /blog-on-photography/ and /blogs/)
      if (path.startsWith('/blog-on-photography/') || path.startsWith('/blogs/')) return PageSegment.EDUCATION;
      if (
        path === '/blog-on-photography' ||
        path === '/blogs' ||
        path === '/free-online-photography-course' ||
        path === '/outdoor-photography-exposure-calculator' ||
        path === '/free-photography-tips' ||
        path === '/photography-news-blog'
      ) {
        return PageSegment.EDUCATION;
      }
      
      // Fine-art gallery pages  portfolio/informational, NOT money pages
      // These must be checked BEFORE money classification
      if (isFineArtGalleryPage(path)) return PageSegment.SYSTEM;
      
      // Support pages (must be checked before money classification)
      const SUPPORT_EXACT = new Set([
        '/', '/about-alan-ranger', '/testimonials-customer-reviews', '/awards-and-qualifications',
        '/gallery-image-portfolios', '/help-site-map', '/help-portrait-uk-coventry',
        '/photography-equipment-recommendations', '/newsletter-signup-form',
        '/which-photography-style-is-right-for-you', '/contact-us',
      ]);
      if (SUPPORT_EXACT.has(path)) return PageSegment.SUPPORT;
      
      // Money pages = Events + Products + Landing pages (excluding blog posts)
      // Events: URLs starting with specific paths (check both with and without trailing slash)
      if (path.startsWith('/beginners-photography-lessons/') || 
          path.startsWith('/beginners-photography-lessons') ||
          path.startsWith('/photographic-workshops-near-me/') ||
          path.startsWith('/photographic-workshops-near-me')) {
        return PageSegment.MONEY;
      }
      
      // Products: URLs starting with specific paths (check both with and without trailing slash)
      if (path.startsWith('/photo-workshops-uk/') || 
          path.startsWith('/photo-workshops-uk') ||
          path.startsWith('/photography-services-near-me/') ||
          path.startsWith('/photography-services-near-me')) {
        return PageSegment.MONEY;
      }
      
      // Legacy exact matches for money pages (keep for backward compatibility)
      const MONEY_EXACT = new Set([
        '/photography-workshops', '/photography-workshops-near-me', '/photography-workshops-uk',
        '/landscape-photography-workshops', '/outdoor-photography-workshops',
        '/photographic-workshops-near-me', '/photographic-workshops-uk',
        '/photography-courses-coventry', '/course-finder-photography-classes-near-me',
        '/photography-tuition-services', '/photography-services-near-me', '/photography-shop-services',
        '/rps-courses-mentoring-distinctions', '/hire-a-professional-photographer-in-coventry',
        '/professional-commercial-photographer-coventry', '/professional-photographer-near-me',
        '/coventry-photographer', '/photographer-in-coventry', '/photography-mentoring-programme',
        '/photography-academy-membership', '/photography-academy', '/photography-session-vouchers',
        '/photography-gift-vouchers', '/photography-presents-for-photographers',
        '/batsford-arboretum-photography', '/bluebell-woods-near-me',
      ]);
      if (MONEY_EXACT.has(path)) return PageSegment.MONEY;
      
      // Landing pages: Everything else that's NOT blog posts, education, support, or system
      // Default to MONEY (landing page) if it's not a blog post and doesn't match other categories
      // This ensures all non-blog pages are treated as money pages (landing pages) by default
      // Only exclude fine-art gallery pages from being money pages
      if (!isFineArtGalleryPage(path)) {
        // If we've gotten here, it's not education, support, system, or fine-art
        // So it must be a money page (landing page)
        return PageSegment.MONEY;
      }
      
      // Everything else = system (only fine-art gallery pages should reach here)
      return PageSegment.SYSTEM;
    }
    
    /**
     * Shared classification function for Ranking & AI tab
     * Returns both segment (Brand/Education/Money/Other) and pageType (Landing/Blog/Event/Product/GBP)
     * Uses canonical classification from Money Pages logic
     * @param {string} rawUrlOrPath - URL or path to classify
     * @param {string} keyword - Optional keyword for brand detection
     * @returns {{segment: string, pageType: string}}
     */
    function classifyUrlForRankingAi(rawUrlOrPath, keyword = null) {
      // Normalize URL to lowercase for consistent matching
      const urlLower = (rawUrlOrPath || "").toLowerCase();
      const path = normalisePath(rawUrlOrPath);
      
      // Brand detection: check keyword first
      if (keyword) {
        const kw = (keyword || "").toLowerCase();
        if (kw.includes("alan ranger") || kw.includes("alanranger")) {
          return { segment: "Brand", pageType: "GBP" };
        }
      }
      
      // If URL is missing/blank, return Other
      if (!rawUrlOrPath || !path) {
        return { segment: "Other", pageType: "Other" };
      }
      
      // STEP 1: Check Event pages FIRST (before Blog/GBP/Landing)
      // Event if URL contains:
      // - alanranger.com/beginners-photography-lessons/
      // - alanranger.com/photographic-workshops-near-me
      if (urlLower.includes('/beginners-photography-lessons') ||
          urlLower.includes('/photographic-workshops-near-me')) {
        return { segment: "Money", pageType: "Event" };
      }
      
      // STEP 2: Check Product pages (before Blog/GBP/Landing)
      // Product if URL contains:
      // - alanranger.com/photo-workshops-uk/
      // - alanranger.com/photography-services-near-me/
      if (urlLower.includes('/photo-workshops-uk') ||
          urlLower.includes('/photography-services-near-me')) {
        return { segment: "Money", pageType: "Product" };
      }
      
      // STEP 3: Check for Blog pages (Education segment)
      if (path.startsWith('/blog-on-photography/') || path.startsWith('/blogs/')) {
        return { segment: "Education", pageType: "Blog" };
      }
      
      // STEP 4: Check for GBP/Home/About pages (Brand segment)
      if (path === '/' ||
          path === '/about-alan-ranger' ||
          path.includes('/contact') ||
          path.includes('/reviews')) {
        return { segment: "Brand", pageType: "GBP" };
      }
      
      // STEP 5: Use canonical page classification for remaining pages
      // Try window.classifyMoneyPage first (if available), then fallback to local scope
      let isMoney = false;
      let segmentType = null;
      
      const classifyMoneyPageFn = (typeof window !== 'undefined' && window.classifyMoneyPage)
        ? window.classifyMoneyPage
        : (typeof classifyMoneyPage !== 'undefined' ? classifyMoneyPage : null);
      
      if (classifyMoneyPageFn) {
        try {
          const result = classifyMoneyPageFn(rawUrlOrPath);
          isMoney = result.isMoney;
          segmentType = result.segmentType;
        } catch (e) {
          const segment = classifyPageSegment(rawUrlOrPath);
          isMoney = segment === PageSegment.MONEY;
          segmentType = isMoney ? 'landing' : null;
        }
      } else {
        const segment = classifyPageSegment(rawUrlOrPath);
        isMoney = segment === PageSegment.MONEY;
        segmentType = isMoney ? 'landing' : null;
        if (window.DEBUG_MODE) {
          debugLog(' classifyMoneyPage not available, using fallback classification', 'warn');
        }
      }
      
      // Determine pageType from canonical segmentType (for remaining pages)
      let pageType = "Landing"; // Default
      if (segmentType === "event") {
        pageType = "Event";
      } else if (segmentType === "product") {
        pageType = "Product";
      } else if (segmentType === "landing" || segmentType === "all") {
        pageType = "Landing";
      } else if (isMoney) {
        pageType = "Landing";
      } else {
        pageType = "Other";
      }
      
      // Determine segment from pageType and canonical classification
      let segment = "Other"; // Default
      
      // Brand: home page, about, contact, reviews, or brand keywords
      if (pageType === "GBP" || path === '/' || path === '/about-alan-ranger') {
        segment = "Brand";
      }
      // Money: Landing, Event, or Product page types
      else if (pageType === "Landing" || pageType === "Event" || pageType === "Product") {
        segment = "Money";
      }
      // Education: Blog pages or free course/educational content
      else if (pageType === "Blog" || 
               path === '/free-online-photography-course' ||
               path === '/outdoor-photography-exposure-calculator' ||
               path === '/free-photography-tips') {
        segment = "Education";
      }
      // Everything else is Other
      
      return { segment, pageType };
    }
    
    // Make available globally for RankingAiModule
    if (typeof window !== 'undefined') {
      window.classifyUrlForRankingAi = classifyUrlForRankingAi;
    }
    
    // Helper functions for Authority score calculation
    function normalisePct(value, max) {
      // value in 0-1 range; scale to 0-100 and cap
      const pct = Math.max(0, Math.min(1, value / max));
      return pct * 100;
    }

    function normalisePosition(pos, minPos, maxPos) {
      // map [minPos..maxPos] -> [100..10], clamp outside range
      const clamped = Math.max(minPos, Math.min(maxPos, pos));
      const t = (clamped - minPos) / (maxPos - minPos); // 0..1
      return 100 - t * 90; // 100 at best, 10 at worst
    }

    // Raw Behaviour score calculation (internal, used by segmented version)
    // ============================================================================
    // PHASE 1: Brand Overlay Metrics
    // ============================================================================
    
    /**
     * @typedef {Object} BrandOverlay
     * @property {number} score - 0-100
     * @property {'Weak'|'Developing'|'Strong'} label
     * @property {number} brandQueryShare - 0-1, impressions share
     * @property {number} brandCtr - 0-1
     * @property {number} brandAvgPosition - numeric position
     * @property {number} reviewScore - 0-100, from existing review metrics
     * @property {number} entityScore - 0-100, based on knowledge panel / GBP presence
     * @property {string[]} notes - short machine-generated reasons for the label
     */
    
    /**
     * @typedef {Object} AiSummaryLikelihood
     * @property {number} score - 0-100 composite
     * @property {'Low'|'Medium'|'High'} label
     * @property {string[]} reasons - short bullets used in UI tooltip / priorities
     */
    
    /**
     * @typedef {"LOW" | "MEDIUM" | "HIGH"} PriorityLevel
     */
    
    /**
     * @typedef {"LOW" | "MEDIUM" | "HIGH"} ImpactLevel
     */
    
    /**
     * @typedef {"LOW" | "MEDIUM" | "HIGH"} DifficultyLevel
     */
    
    /**
     * @typedef {"all" | "landing" | "event" | "product"} MoneySegmentKey
     */
    
    /**
     * @typedef {Object} MoneyPageMetrics
     * @property {string} url
     * @property {string} title
     * @property {MoneySegmentKey} segmentType       // landing / event / product / (fallback "all")
     * @property {number} clicks
     * @property {number} impressions
     * @property {number} ctr                        // 01 decimal
     * @property {number} avgPosition
     * @property {ImpactLevel} impactLevel
     * @property {DifficultyLevel} difficultyLevel
     * @property {PriorityLevel} priorityLevel
     * @property {number} [_lostClicks]              // Internal: calculated lost clicks
     */
    
    /**
     * Per audit, stored for history in Supabase.
     *
     * @typedef {Object} MoneySegmentSummary
     * @property {number} clicks
     * @property {number} impressions
     * @property {number} ctr           // 01 decimal
     * @property {number} avgPosition
     * @property {number} behaviourScore
     */
    
    /**
     * @typedef {Object} MoneySegmentMetricsByAudit
     * @property {MoneySegmentSummary} allMoney
     * @property {MoneySegmentSummary} landingPages
     * @property {MoneySegmentSummary} eventPages
     * @property {MoneySegmentSummary} productPages
     */
    
    // Brand query classification
    const BRAND_TERMS = ['alan ranger', 'alanranger', 'alan ranger photography'];
    
    /**
     * Check if a query is a brand query
     * @param {string} query - Search query text
     * @returns {boolean}
     */
    function isBrandQuery(query) {
      if (!query || typeof query !== 'string') return false;
      const q = query.toLowerCase();
      return BRAND_TERMS.some(term => q.includes(term));
    }
    
    /**
     * Calculate brand metrics from GSC query data
     * @param {Array} queries - Array of query objects with {query, clicks, impressions, position}
     * @returns {Object} Brand metrics {brandQueryShare, brandCtr, brandAvgPosition}
     */
    function calculateBrandMetrics(queries) {
      if (!queries || !Array.isArray(queries) || queries.length === 0) {
        return {
          brandQueryShare: 0,
          brandCtr: 0,
          brandAvgPosition: null
        };
      }
      
      // Filter to ranking queries (position 1-20, with impressions)
      const ranking = queries.filter(q => {
        const pos = q.position || 0;
        const impr = q.impressions || 0;
        return pos > 0 && pos <= 20 && impr > 0;
      });
      
      if (ranking.length === 0) {
        return {
          brandQueryShare: 0,
          brandCtr: 0,
          brandAvgPosition: null
        };
      }
      
      // Split into brand vs non-brand
      const brandQueries = ranking.filter(q => isBrandQuery(q.query || ''));
      const nonBrandQueries = ranking.filter(q => !isBrandQuery(q.query || ''));
      
      // Calculate totals
      const totalImpressions = ranking.reduce((s, q) => s + (q.impressions || 0), 0);
      const brandImpressions = brandQueries.reduce((s, q) => s + (q.impressions || 0), 0);
      const brandClicks = brandQueries.reduce((s, q) => s + (q.clicks || 0), 0);
      
      // Brand query share (0-1)
      const brandQueryShare = totalImpressions > 0 ? brandImpressions / totalImpressions : 0;
      
      // Brand CTR (0-1)
      const brandCtr = brandImpressions > 0 ? brandClicks / brandImpressions : 0;
      
      // Brand average position (weighted by impressions)
      const brandAvgPosition = brandImpressions > 0
        ? brandQueries.reduce((s, q) => s + (q.position || 0) * (q.impressions || 0), 0) / brandImpressions
        : null;
      
      return {
        brandQueryShare,
        brandCtr,
        brandAvgPosition
      };
    }
    
    /**
     * Normalize position to 0-100 score (for brand overlay)
     * @param {number|null} pos - Position value
     * @param {number} minPos - Minimum position (default 1)
     * @param {number} maxPos - Maximum position (default 10)
     * @returns {number} Score 0-100
     */
    function normalisePositionForBrand(pos, minPos = 1, maxPos = 10) {
      if (pos == null) return 0;
      const clamped = Math.max(minPos, Math.min(maxPos, pos));
      const t = (clamped - minPos) / (maxPos - minPos); // 0..1
      return 100 - t * 100;
    }
    
    /**
     * Compute Brand Overlay score
     * @param {Object} args - Brand overlay parameters
     * @param {number} args.brandQueryShare - 0-1, impressions share
     * @param {number} args.brandCtr - 0-1
     * @param {number|null} args.brandAvgPosition - numeric position
     * @param {number} args.reviewScore - 0-100, from existing Authority review score
     * @param {number} args.entityScore - 0-100, from Local Entity pillar
     * @returns {BrandOverlay}
     */
    function computeBrandOverlay(args) {
      const {
        brandQueryShare = 0,
        brandCtr = 0,
        brandAvgPosition = null,
        reviewScore = 0,
        entityScore = 0
      } = args;
      
      // Brand search component
      const shareScore = Math.min(brandQueryShare / 0.30, 1) * 100; // 30%+ share = 100
      const ctrScore = Math.min(brandCtr / 0.40, 1) * 100; // 40%+ CTR = 100
      const posScore = normalisePositionForBrand(brandAvgPosition, 1, 10);
      
      const brandSearchScore =
        0.4 * shareScore +
        0.3 * ctrScore +
        0.3 * posScore;
      
      // Combine with review + entity strength
      const combined =
        0.4 * brandSearchScore +
        0.3 * reviewScore +
        0.3 * entityScore;
      
      let label;
      if (combined < 40) label = 'Weak';
      else if (combined < 70) label = 'Developing';
      else label = 'Strong';
      
      const notes = [];
      if (brandQueryShare < 0.1) notes.push('Low share of branded searches in GSC.');
      if (brandCtr < 0.25) notes.push('Branded CTR is below 25%.');
      if (brandAvgPosition == null || brandAvgPosition > 5)
        notes.push('Branded queries do not consistently rank in top-5.');
      if (reviewScore < 70) notes.push('Review rating / volume is still maturing.');
      if (entityScore < 70) notes.push('Knowledge-panel / entity coverage could be stronger.');
      
      return {
        score: Math.round(combined),
        label,
        brandQueryShare,
        brandCtr,
        brandAvgPosition: brandAvgPosition ?? 0,
        reviewScore,
        entityScore,
        notes
      };
    }
    
    /**
     * Compute AI Summary Likelihood
     * @param {number} snippetReadinessScore - Existing donut score
     * @param {number} visibilityScore - Current Visibility pillar score
     * @param {number} brandScore - Brand overlay score
     * @returns {AiSummaryLikelihood}
     */
    function computeAiSummaryLikelihood(snippetReadinessScore, visibilityScore, brandScore) {
      const composite =
        0.5 * snippetReadinessScore +
        0.3 * visibilityScore +
        0.2 * brandScore;
      
      // Use same RAG bands as GAIO Score: 70 High (green), 50 Medium (amber), <50 Low (red)
      let label;
      if (composite < 50) label = 'Low';
      else if (composite < 70) label = 'Medium';
      else label = 'High';
      
      const reasons = [];
      
      if (snippetReadinessScore < 70)
        reasons.push('Improve FAQ/HowTo/Article blocks and schema to raise snippet readiness.');
      if (visibilityScore < 70)
        reasons.push('Improve average position and top-10 impression share.');
      if (brandScore < 70)
        reasons.push('Strengthen branded search and entity signals.');
      
      return {
        score: Math.round(composite),
        label,
        reasons
      };
    }
    
    // ============================================================================
    // End Phase 1: Brand Overlay Metrics
    // ============================================================================

    function computeBehaviourScoreRaw(queries) {
      if (!queries || !Array.isArray(queries) || queries.length === 0) {
        return 50; // neutral fallback
      }

      // Filter to ranking queries (position > 0, <= 20, with impressions)
      const ranking = queries.filter(q => q.position > 0 && q.position <= 20 && q.impressions > 0);

      if (ranking.length === 0) {
        return 50; // neutral fallback
      }

      // Calculate CTR for all ranking queries
      const totalClicks = ranking.reduce((s, q) => s + q.clicks, 0);
      const totalImpr = ranking.reduce((s, q) => s + q.impressions, 0);
      const ctrAll = totalImpr > 0 ? totalClicks / totalImpr : 0; // 0-1

      // Calculate CTR for top-10 queries
      const top10 = ranking.filter(q => q.position <= 10);
      const top10Clicks = top10.reduce((s, q) => s + q.clicks, 0);
      const top10Impr = top10.reduce((s, q) => s + q.impressions, 0);
      const ctrTop10 = top10Impr > 0 ? top10Clicks / top10Impr : ctrAll;

      // Normalize CTR scores: 5% CTR = 100 for all ranking, 10% CTR = 100 for top-10
      // ctrAll 0-5%  0-100 (values >5% capped at 100)
      // ctrTop10 0-10%  0-100 (values >10% capped at 100)
      const ctrScoreAll = normalisePct(ctrAll, 0.05); // 5% overall CTR -> 100
      const ctrScoreTop10 = normalisePct(ctrTop10, 0.10); // 10% top-10 CTR -> 100

      // Combine: 50% ctrAll + 50% ctrTop10
      return 0.5 * ctrScoreAll + 0.5 * ctrScoreTop10; // 0-100
    }
    
    // Public Behaviour score (backward compatible, uses all queries)
    function computeBehaviourScore(queries) {
      return computeBehaviourScoreRaw(queries);
    }
    
    // Segmented Behaviour score calculation
    // queryPages: Array of {query, page, clicks, impressions, ctr, position}
    // Returns: {all, nonBlog, money}
    function computeBehaviourScoreWithSegment(queryPages) {
      if (!queryPages || !Array.isArray(queryPages) || queryPages.length === 0) {
        return { all: 50, nonBlog: 50, money: 50 };
      }
      
      // Classify each query+page row by page segment
      const withSegment = queryPages.map(row => {
        const segment = classifyPageSegment(row.page || row.url || '/');
        return { ...row, __segment: segment };
      });
      
      // Convert to format expected by computeBehaviourScoreRaw
      const toQueryFormat = (rows) => rows.map(r => ({
        clicks: r.clicks || 0,
        impressions: r.impressions || 0,
        ctr: (r.ctr || 0) / 100, // Convert percentage to decimal
        position: r.position || 0
      }));
      
      // All queries
      const all = computeBehaviourScoreRaw(toQueryFormat(withSegment));
      
      // Non-blog (exclude education)
      const nonBlog = computeBehaviourScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment !== PageSegment.EDUCATION))
      );
      
      // Money pages only
      const money = computeBehaviourScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment === PageSegment.MONEY))
      );
      
      return { all, nonBlog, money };
    }

    // Raw Ranking score calculation (internal, used by segmented version)
    function computeRankingScoreRaw(queries) {
      if (!queries || !Array.isArray(queries) || queries.length === 0) {
        return 50; // neutral fallback
      }

      // Filter to ranking queries (position > 0, <= 20, with impressions)
      const ranking = queries.filter(q => q.position > 0 && q.position <= 20 && q.impressions > 0);

      if (ranking.length === 0) {
        return 50; // neutral fallback
      }

      // Calculate impression-weighted average position
      const totalImpr = ranking.reduce((s, q) => s + q.impressions, 0);
      const avgPos = totalImpr > 0
        ? ranking.reduce((s, q) => s + q.position * q.impressions, 0) / totalImpr
        : 0;

      // Map position: 1  100, 20  0 (clamped)
      const clampedPos = Math.max(1, Math.min(20, avgPos));
      const posScore = normalisePosition(clampedPos, 1, 20); // 0-100

      // Calculate top-10 impression share (% of impressions where position  10)
      const top10Impr = ranking
        .filter(q => q.position <= 10)
        .reduce((s, q) => s + q.impressions, 0);
      const top10Share = totalImpr > 0 ? top10Impr / totalImpr : 0; // 0-1
      const top10Score = top10Share * 100; // 0-100 (as a percentage)

      // Combine: 50% posScore + 50% top10Score
      return 0.5 * posScore + 0.5 * top10Score; // 0-100
    }
    
    // Public Ranking score (backward compatible, uses all queries)
    function computeRankingScore(queries) {
      return computeRankingScoreRaw(queries);
    }
    
    // Segmented Ranking score calculation
    // queryPages: Array of {query, page, clicks, impressions, ctr, position}
    // Returns: {all, nonBlog, money}
    function computeRankingScoreWithSegment(queryPages) {
      if (!queryPages || !Array.isArray(queryPages) || queryPages.length === 0) {
        return { all: 50, nonBlog: 50, money: 50 };
      }
      
      // Classify each query+page row by page segment
      const withSegment = queryPages.map(row => {
        const segment = classifyPageSegment(row.page || row.url || '/');
        return { ...row, __segment: segment };
      });
      
      // Convert to format expected by computeRankingScoreRaw
      const toQueryFormat = (rows) => rows.map(r => ({
        clicks: r.clicks || 0,
        impressions: r.impressions || 0,
        ctr: (r.ctr || 0) / 100, // Convert percentage to decimal
        position: r.position || 0
      }));
      
      // All queries
      const all = computeRankingScoreRaw(toQueryFormat(withSegment));
      
      // Non-blog (exclude education)
      const nonBlog = computeRankingScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment !== PageSegment.EDUCATION))
      );
      
      // Money pages only
      const money = computeRankingScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment === PageSegment.MONEY))
      );
      
      return { all, nonBlog, money };
    }

    function computeReviewScore(opts) {
      const {
        gbpRating = null,
        gbpCount = null,
        siteRating = null,
        siteCount = null
      } = opts || {};

      // Check if sources have valid data (not null, not 0, not undefined)
      const hasGBP = (gbpRating !== null && gbpRating !== undefined && gbpRating > 0) || 
                     (gbpCount !== null && gbpCount !== undefined && gbpCount > 0);
      const hasSite = (siteRating !== null && siteRating !== undefined && siteRating > 0) || 
                      (siteCount !== null && siteCount !== undefined && siteCount > 0);

      // If neither source exists, return neutral default
      if (!hasGBP && !hasSite) {
        debugLog('Review Score: No review data available (GBP or site), using neutral default (50)', 'warn');
        return 50;
      }

      const maxCount = 500; // cap so a few extra reviews don't blow up score

      let reviewScore;

      if (hasGBP && hasSite) {
        // Both sources exist: 60% GBP + 40% site
        const gbpRatingScore = ((gbpRating || 0) / 5) * 100;
        const gbpCountScore = Math.min((gbpCount || 0) / maxCount, 1) * 100;
        const gbpScore = 0.6 * gbpRatingScore + 0.4 * gbpCountScore;

        const siteRatingScore = ((siteRating || 0) / 5) * 100;
        const siteCountScore = Math.min((siteCount || 0) / maxCount, 1) * 100;
        const siteScore = 0.6 * siteRatingScore + 0.4 * siteCountScore;

        reviewScore = 0.6 * gbpScore + 0.4 * siteScore;
      } else if (hasGBP) {
        // Only GBP exists: 100% GBP
        const gbpRatingScore = ((gbpRating || 0) / 5) * 100;
        const gbpCountScore = Math.min((gbpCount || 0) / maxCount, 1) * 100;
        reviewScore = 0.6 * gbpRatingScore + 0.4 * gbpCountScore;
      } else {
        // Only site reviews exist: 100% site
        const siteRatingScore = ((siteRating || 0) / 5) * 100;
        const siteCountScore = Math.min((siteCount || 0) / maxCount, 1) * 100;
        reviewScore = 0.6 * siteRatingScore + 0.4 * siteCountScore;
      }

      return clampScore(reviewScore);
    }

    /**
     * Compute Backlink Score from backlink metrics
     * @param {Object|undefined} m - Backlink metrics object with referringDomains, totalBacklinks, followRatio
     * @returns {number} Score 0-100
     */
    function computeBacklinkScore(m) {
      if (!m) {
        // If metrics not present at all, return 0 (no backlink data)
        return 0;
      }

      const rd = m.referringDomains ?? 0;
      // If followRatio is missing, it means data integrity issue - log warning and use 0
      const fb = m.followRatio ?? (() => {
        debugLog(' Backlink metrics missing followRatio - data integrity issue', 'warn');
        return 0;
      })();

      // If no backlinks at all, score is 0
      if (rd === 0 && (m.totalBacklinks ?? 0) === 0) {
        return 0;
      }

      // Referring domains score: 100+ domains = max score (100)
      const rdScore = Math.min(rd / 100, 1) * 100;
      
      // Follow ratio score: clamp 0-1  0-100
      const followScore = Math.max(0, Math.min(fb, 1)) * 100;

      // Combined: 70% referring domains, 30% follow ratio
      const score = 0.7 * rdScore + 0.3 * followScore;
      
      return Math.round(clampScore(score));
    }

    // Helper function to always return correct Trustpilot snapshot values
    // This ensures we never use old cached values (4.80, 127) - always use (4.6, 610)
    function getTrustpilotSnapshot(siteReviews = null) {
      const TRUSTPILOT_SNAPSHOT = {
        siteRating: 4.6,
        siteReviewCount: 610,
        lastUpdated: '2025-12-07',
        notes: 'Fixed Trustpilot snapshot for Authority score calculation. Update manually when Trustpilot metrics change significantly.'
      };
      
      // Always return the correct snapshot, regardless of input
      if (!siteReviews || siteReviews.siteRating !== 4.6 || siteReviews.siteReviewCount !== 610) {
        return TRUSTPILOT_SNAPSHOT;
      }
      return siteReviews;
    }

    // Helper function to get color for score (same thresholds as main pillars)
    function getScoreColor(score) {
      if (score >= 70) return { color: '#10b981', label: 'Green', bg: '#d1fae5' }; // Green
      if (score >= 40) return { color: '#f59e0b', label: 'Amber', bg: '#fef3c7' }; // Amber
      return { color: '#ef4444', label: 'Red', bg: '#fee2e2' }; // Red
    }

    // Helper function to get tooltip text for each component
    function getComponentTooltip(label) {
      const tooltips = {
        // Authority components
        'Behaviour': 'Overall CTR Score (50% weight) + Top-10 Ranked Search Terms CTR Score (50% weight). Measures CTR for all ranking search terms vs. search terms ranking in positions 1-10. Indicates how well your titles/descriptions convert impressions to clicks.',
        'Ranking': 'Average Position Score (50% weight) + Top-10 Impression Share (50% weight). Measures how high you rank on average and what percentage of impressions appear in positions 1-10.',
        'Backlinks': 'Referring Domains Score (70% weight) + Follow Ratio Score (30% weight). Measures domain authority from external links.',
        'Reviews': 'Google Business Profile Reviews (60% weight if both exist) + Trustpilot Reviews (40% weight if both exist). Each source combines rating (60%) and count (40%). Measures trust signals from customer reviews.',
        // Content/Schema components
        'Foundation': 'Foundation Schemas (30% weight): Presence of Organization, Person, WebSite, and BreadcrumbList schemas. These core schemas establish your entity identity and site structure for AI systems.',
        'Rich Results': 'Rich Result Eligibility (35% weight): Count of eligible rich result types (Article, Event, FAQPage, Product, LocalBusiness, Course, Review, HowTo, VideoObject, ImageObject, ItemList). More types = better AI understanding.',
        'Coverage': 'Schema Coverage (20% weight): Percentage of pages with structured data markup. Higher coverage means more pages are machine-readable.',
        'Diversity': 'Type Diversity (15% weight): Number of unique schema types detected across your domain. More diverse types indicate richer structured data.',
        // Visibility components
        'Position': 'Average Position Score: Derived from Google Search Console average position (1-40 scale). Better positions (lower numbers) = higher score. Measures how prominently your content appears in search results.',
        'CTR': 'Click-Through Rate Score: Derived from Google Search Console CTR percentage. Higher CTR indicates better title/description effectiveness and user engagement.',
        // Local Entity components
        'NAP Consistency': 'Name, Address, Phone consistency score (0-100%). Measures how consistently your business information appears across Google Business Profile. Higher consistency improves entity recognition.',
        'Knowledge Panel': 'Knowledge Panel Detection: Whether Google has detected and displays a knowledge panel for your entity. Indicates strong entity recognition by AI systems.',
        'Locations': 'Location Count: Number of physical locations listed in Google Business Profile. Having at least one location improves local entity recognition.',
        // Service Area components
        'Service Areas': 'Service Area Count: Number of service areas defined in Google Business Profile. More service areas (8+) indicate broader geographic coverage and better AI understanding of your operational regions.',
        'NAP Consistency': 'Name, Address, Phone consistency score (0-100%). Measures how consistently your business information appears across Google Business Profile. Higher consistency improves service area recognition.'
      };
      return tooltips[label] || '';
    }

    // Helper function to format component score with color, scale indicator, and tooltip
    function formatComponentScore(label, score) {
      const rounded = Math.round(score);
      const colorInfo = getScoreColor(rounded);
      const tooltip = getComponentTooltip(label);
      return `
        <div style="display: flex; align-items: center; gap: 0.5rem;">
          <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background-color: ${colorInfo.color};"></span>
          <span style="color: #666; position: relative; cursor: help; border-bottom: 1px dotted #999;" title="${tooltip}">${label}:</span>
          <strong style="color: ${colorInfo.color};">${rounded}</strong>
          <span style="color: #999; font-size: 0.75em;">/100</span>
        </div>
      `;
    }

    async function calculatePillarScores(data, schemaAudit = null, localSignals = null, siteReviews = null, backlinkMetrics = null) {
      // Use new API response format - get values from GSC overview
      const position = data.averagePosition || 40; // 1 (best) - 100 (worst)
      const ctr = data.ctr || 0; // 0-100 percentage from API (e.g., 10 = 10%)
      const topQueries = data.topQueries || []; // Array of query objects with clicks, impressions, ctr, position
      const queryPages = data.queryPages || []; // Array of query+page objects for segmentation
      
      // Keep backlink metrics stable across recomputations
      if (!backlinkMetrics && window.latestBacklinkMetrics) {
        backlinkMetrics = window.latestBacklinkMetrics;
        debugLog(' Using cached backlink metrics for recalculation', 'info');
      }

      // Map average position (1-40) -> 100-10 (better position => higher score)
      const posScore = (() => {
        const clampedPos = Math.max(1, Math.min(40, position));
        const scale = (clampedPos - 1) / 39; // 0 to 1
        return 100 - scale * 90; // 100 to 10
      })();

      // Visibility is primarily driven by position
      const visibility = clampScore(posScore);

      // Authority: New 4-component model with segmentation support
      let behaviourScore, rankingScore;
      let behaviourScoresSegmented = null;
      let rankingScoresSegmented = null;
      
      // CRITICAL DEBUG: Log queryPages availability
      debugLog(`[calculatePillarScores] queryPages check: exists=${!!queryPages}, isArray=${Array.isArray(queryPages)}, length=${queryPages?.length || 0}, type=${typeof queryPages}`, 'info');
      
      // If we have queryPages data, use segmented calculation
      if (queryPages && Array.isArray(queryPages) && queryPages.length > 0) {
        debugLog(` Segmentation: Received ${queryPages.length} query+page combinations from GSC API`, 'info');
        
        // Classify all pages and show distribution
        const segmentCounts = {};
        queryPages.forEach(row => {
          const segment = classifyPageSegment(row.page || row.url || '/');
          segmentCounts[segment] = (segmentCounts[segment] || 0) + 1;
        });
        
        debugLog(` Segmentation: Page distribution - Education: ${segmentCounts[PageSegment.EDUCATION] || 0}, Money: ${segmentCounts[PageSegment.MONEY] || 0}, Support: ${segmentCounts[PageSegment.SUPPORT] || 0}, System: ${segmentCounts[PageSegment.SYSTEM] || 0}`, 'info');
        
        // Use segmented calculation
        debugLog(' Segmentation: Calculating Behaviour scores for all segments...', 'info');
        behaviourScoresSegmented = computeBehaviourScoreWithSegment(queryPages);
        debugLog(` Segmentation: Behaviour scores - All: ${behaviourScoresSegmented.all.toFixed(1)}, Non-blog: ${behaviourScoresSegmented.nonBlog.toFixed(1)}, Money: ${behaviourScoresSegmented.money.toFixed(1)}`, 'success');
        
        debugLog(' Segmentation: Calculating Ranking scores for all segments...', 'info');
        rankingScoresSegmented = computeRankingScoreWithSegment(queryPages);
        debugLog(` Segmentation: Ranking scores - All: ${rankingScoresSegmented.all.toFixed(1)}, Non-blog: ${rankingScoresSegmented.nonBlog.toFixed(1)}, Money: ${rankingScoresSegmented.money.toFixed(1)}`, 'success');
        
        // Use 'all' segment for main Authority score (backward compatible)
        behaviourScore = behaviourScoresSegmented.all;
        rankingScore = rankingScoresSegmented.all;
        
        debugLog(` Using segmented calculation (queryPages available). Main scores use 'all' segment.`, 'success');
      } else {
        // Fallback to non-segmented calculation (backward compatible)
        debugLog(' Segmentation: queryPages not available, using non-segmented calculation (backward compatible)', 'warn');
        const queriesForCalculation = topQueries.map(q => ({
          clicks: q.clicks || 0,
          impressions: q.impressions || 0,
          ctr: (q.ctr || 0) / 100, // Convert percentage to decimal
          position: q.position || 0
        }));
        behaviourScore = computeBehaviourScore(queriesForCalculation);
        rankingScore = computeRankingScore(queriesForCalculation);
        debugLog(` Non-segmented scores: Behaviour=${behaviourScore.toFixed(1)}, Ranking=${rankingScore.toFixed(1)}`, 'warn');
      }

      // Review Score: Phase 2 - Use real review data if available
      // Accept GBP data even when localSignals.status !== 'ok' if data is present.
      const localSignalsData = localSignals?.data
        || (localSignals && typeof localSignals === 'object' && !localSignals.status ? localSignals : null)
        || null;
      const gbpRating = localSignalsData?.gbpRating !== null && localSignalsData?.gbpRating !== undefined
        ? localSignalsData.gbpRating
        : null;
      const gbpCount = localSignalsData?.gbpReviewCount !== null && localSignalsData?.gbpReviewCount !== undefined
        ? localSignalsData.gbpReviewCount
        : null;
      
      // Get site review data - ALWAYS use correct Trustpilot snapshot (4.6, 610)
      const normalizedSiteReviews = getTrustpilotSnapshot(siteReviews);
      const siteRating = normalizedSiteReviews?.siteRating !== null && normalizedSiteReviews?.siteRating !== undefined ? normalizedSiteReviews.siteRating : null;
      const siteCount = normalizedSiteReviews?.siteReviewCount !== null && normalizedSiteReviews?.siteReviewCount !== undefined ? normalizedSiteReviews.siteReviewCount : null;
      
      // Calculate review score (handles optional sources internally)
      const reviewScore = computeReviewScore({
        gbpRating,
        gbpCount,
        siteRating,
        siteCount
      });
      
      // Log the calculation details
      const gbpInfo = gbpRating !== null || gbpCount !== null 
        ? `GBP (rating=${gbpRating !== null ? gbpRating : 'N/A'}, count=${gbpCount !== null ? gbpCount : 'N/A'})`
        : 'GBP (no data)';
      const siteInfo = siteRating !== null || siteCount !== null
        ? `Trustpilot snapshot (rating=${siteRating !== null ? siteRating : 'N/A'}, count=${siteCount !== null ? siteCount : 'N/A'})`
        : 'Trustpilot snapshot (no data)';
      debugLog(`Review Score: ${gbpInfo}, ${siteInfo}, Final=${reviewScore.toFixed(1)}`, 'info');

      // Backlink Score: Phase 3 - Use real backlink metrics if available
      // backlinkMetrics is passed as a parameter (fetched from API)
      const backlinkScore = computeBacklinkScore(backlinkMetrics);

      // Authority weights (constant across all segments)
      const AUTHORITY_WEIGHTS = {
        behaviour: 0.4,
        ranking: 0.2,
        backlinks: 0.2,
        reviews: 0.2
      };
      
      // Helper to compute Authority from component scores
      function computeAuthorityFromComponents(components) {
        const total = clampScore(
          AUTHORITY_WEIGHTS.behaviour * components.behaviour +
          AUTHORITY_WEIGHTS.ranking * components.ranking +
          AUTHORITY_WEIGHTS.backlinks * components.backlinks +
          AUTHORITY_WEIGHTS.reviews * components.reviews
        );
        return {
          behaviour: clampScore(components.behaviour),
          ranking: clampScore(components.ranking),
          backlinks: clampScore(components.backlinks),
          reviews: clampScore(components.reviews),
          total: total
        };
      }
      
      // Base Authority (all pages) - current behaviour
      const authorityAll = computeAuthorityFromComponents({
        behaviour: behaviourScore,
        ranking: rankingScore,
        backlinks: backlinkScore,
        reviews: reviewScore
      });
      
      // Per-segment Authority scores (if segmentation available)
      // Helper function to compute top pages for a segment
      function computeTopPagesForSegment(pageRows, max = 10) {
        if (!pageRows || !Array.isArray(pageRows) || pageRows.length === 0) {
          return [];
        }
        
        // Aggregate by page URL (sum clicks, impressions, weighted position)
        const pageMap = new Map();
        
        pageRows.forEach(row => {
          const url = row.page || row.url || '';
          if (!url) return;
          
          if (!pageMap.has(url)) {
            pageMap.set(url, {
              url: url,
              clicks: 0,
              impressions: 0,
              totalPositionWeight: 0,
              count: 0
            });
          }
          
          const page = pageMap.get(url);
          page.clicks += row.clicks || 0;
          page.impressions += row.impressions || 0;
          page.totalPositionWeight += (row.position || 0) * (row.impressions || 0);
          page.count += 1;
        });
        
        // Convert to top pages format
        const topPages = Array.from(pageMap.values())
          .map(page => ({
            url: page.url,
            clicks: page.clicks,
            impressions: page.impressions,
            ctr: page.impressions > 0 ? (page.clicks / page.impressions) * 100 : 0,
            avgPosition: page.impressions > 0 ? page.totalPositionWeight / page.impressions : 0
          }))
          .filter(page => page.impressions > 0) // Only pages with impressions
          .sort((a, b) => b.impressions - a.impressions) // Sort by impressions descending
          .slice(0, max);
        
        return topPages;
      }
      
      // Compute all pages including zero impressions (for money pages segmentation validation)
      function computeAllPagesForSegment(pageRows) {
        if (!pageRows || !Array.isArray(pageRows) || pageRows.length === 0) {
          return [];
        }
        
        // Aggregate by page URL (sum clicks, impressions, weighted position)
        const pageMap = new Map();
        
        pageRows.forEach(row => {
          const url = row.page || row.url || '';
          if (!url) return;
          
          if (!pageMap.has(url)) {
            pageMap.set(url, {
              url: url,
              clicks: 0,
              impressions: 0,
              totalPositionWeight: 0,
              count: 0
            });
          }
          
          const page = pageMap.get(url);
          page.clicks += row.clicks || 0;
          page.impressions += row.impressions || 0;
          page.totalPositionWeight += (row.position || 0) * (row.impressions || 0);
          page.count += 1;
        });
        
        // Convert to pages format (include zero impressions)
        const allPages = Array.from(pageMap.values())
          .map(page => ({
            url: page.url,
            clicks: page.clicks,
            impressions: page.impressions,
            ctr: page.impressions > 0 ? (page.clicks / page.impressions) * 100 : 0,
            avgPosition: page.impressions > 0 ? page.totalPositionWeight / page.impressions : null,
            position: page.impressions > 0 ? page.totalPositionWeight / page.impressions : null
          }))
          .sort((a, b) => {
            // Sort by impressions descending, but put zero impressions at the end
            if (a.impressions === 0 && b.impressions > 0) return 1;
            if (b.impressions === 0 && a.impressions > 0) return -1;
            return b.impressions - a.impressions;
          });
        
        return allPages;
      }
      
      let authorityBySegment = null;
      // CRITICAL: Check if we have queryPages data - if not, authorityBySegment will be null
      // and Authority tab will show "No page data available"
      // CRITICAL FIX: queryPages is extracted at line 26301 from data.queryPages in calculatePillarScores
      // The variable 'queryPages' is in scope here (extracted from data.queryPages at line 26301)
      // But we also need to check data directly since it might be passed differently
      let queryPagesData = [];
      
      // Priority 1: Use the queryPages variable extracted at line 26301 (most reliable)
      if (queryPages && Array.isArray(queryPages) && queryPages.length > 0) {
        queryPagesData = queryPages;
        debugLog(`[Authority]  Using queryPages from calculatePillarScores (line 26301): ${queryPages.length} rows`, 'success');
      } 
      // Priority 2: Check data.queryPages directly (in case variable wasn't set)
      else if (data && data.queryPages && Array.isArray(data.queryPages) && data.queryPages.length > 0) {
        queryPagesData = data.queryPages;
        debugLog(`[Authority]  Using data.queryPages directly: ${data.queryPages.length} rows`, 'success');
      } 
      // Priority 3: Check data.searchData?.queryPages (nested structure)
      else if (data && data.searchData && data.searchData.queryPages && Array.isArray(data.searchData.queryPages) && data.searchData.queryPages.length > 0) {
        queryPagesData = data.searchData.queryPages;
        debugLog(`[Authority]  Using data.searchData.queryPages: ${data.searchData.queryPages.length} rows`, 'success');
      } 
      // Priority 4: Check window.rankingAiData (from latest audit)
      else if (window.rankingAiData && window.rankingAiData.queryPages && Array.isArray(window.rankingAiData.queryPages) && window.rankingAiData.queryPages.length > 0) {
        queryPagesData = window.rankingAiData.queryPages;
        debugLog(`[Authority]  Using window.rankingAiData.queryPages: ${window.rankingAiData.queryPages.length} rows`, 'success');
      } 
      // Priority 5: Check saved audit data
      else {
        // Try to get from saved audit if available
        try {
          const savedAudit = loadAuditResultsSync();
          if (savedAudit && savedAudit.searchData && savedAudit.searchData.queryPages && Array.isArray(savedAudit.searchData.queryPages) && savedAudit.searchData.queryPages.length > 0) {
            queryPagesData = savedAudit.searchData.queryPages;
            debugLog(`[Authority]  Using savedAudit.searchData.queryPages: ${savedAudit.searchData.queryPages.length} rows`, 'success');
          } else {
            const queryPagesLen = queryPages?.length || 'null';
            const dataQueryPagesLen = (data && data.queryPages) ? data.queryPages.length : 'null';
            const searchDataQueryPagesLen = (data && data.searchData && data.searchData.queryPages) ? data.searchData.queryPages.length : 'null';
            const windowQueryPagesLen = (window.rankingAiData && window.rankingAiData.queryPages) ? window.rankingAiData.queryPages.length : 'null';
            const savedQueryPagesLen = (savedAudit && savedAudit.searchData && savedAudit.searchData.queryPages) ? savedAudit.searchData.queryPages.length : 'null';
            debugLog(`[Authority]  No queryPages data found - queryPages=${queryPagesLen}, data.queryPages=${dataQueryPagesLen}, data.searchData?.queryPages=${searchDataQueryPagesLen}, window.rankingAiData.queryPages=${windowQueryPagesLen}, savedAudit.searchData.queryPages=${savedQueryPagesLen}`, 'warn');
          }
        } catch (e) {
          debugLog(`[Authority]  Error checking saved audit for queryPages: ${e.message}`, 'warn');
        }
      }
      debugLog(`[Authority] Final queryPagesData length: ${queryPagesData.length}`, 'info');
      
      // CRITICAL FIX: Get segmented scores from scores.authority if not in scope
      // This handles the case where displayDashboard is called with pre-calculated scores
      const behaviourScoresForAuthority = behaviourScoresSegmented || (scores?.authority?.behaviourScoresSegmented) || null;
      const rankingScoresForAuthority = rankingScoresSegmented || (scores?.authority?.rankingScoresSegmented) || null;
      
      debugLog(`[Authority] Segmented scores check: behaviourScoresSegmented=${!!behaviourScoresForAuthority}, rankingScoresSegmented=${!!rankingScoresForAuthority}, queryPagesData.length=${queryPagesData.length}`, 'info');
      debugLog(`[Authority] Segmented scores source: behaviourScoresSegmented=${behaviourScoresSegmented ? 'local' : (scores?.authority?.behaviourScoresSegmented ? 'scores.authority' : 'null')}, rankingScoresSegmented=${rankingScoresSegmented ? 'local' : (scores?.authority?.rankingScoresSegmented ? 'scores.authority' : 'null')}`, 'info');
      
      if (behaviourScoresForAuthority && rankingScoresForAuthority && queryPagesData.length > 0) {
        debugLog(`[Authority]  All conditions met - building authorityBySegment`, 'success');
        // Get page-level data for top pages computation
        
        // Filter to ranking pages (position 1-20, with impressions)
        const rankingPages = queryPagesData.filter(row => {
          const pos = row.position || 0;
          const impr = row.impressions || 0;
          return pos > 0 && pos <= 20 && impr > 0;
        });
        
        // Classify pages by segment
        const allPages = rankingPages;
        const excludeEduPages = rankingPages.filter(row => {
          const segment = classifyPageSegment(row.page || row.url || '/');
          return segment !== PageSegment.EDUCATION;
        });
        const moneyPages = rankingPages.filter(row => {
          const segment = classifyPageSegment(row.page || row.url || '/');
          return segment === PageSegment.MONEY;
        });
        
        // Compute top pages for each segment
        const allTopPages = computeTopPagesForSegment(allPages, 10);
        const excludeEduTopPages = computeTopPagesForSegment(excludeEduPages, 10);
        const moneyTopPages = computeTopPagesForSegment(moneyPages, 10);
        
        // Non-education (exclude education pages)
        const authorityNonEducation = computeAuthorityFromComponents({
          behaviour: behaviourScoresForAuthority.nonBlog,
          ranking: rankingScoresForAuthority.nonBlog,
          backlinks: backlinkScore, // Same across all segments
          reviews: reviewScore      // Same across all segments
        });
        
        // Money pages only
        const authorityMoney = computeAuthorityFromComponents({
          behaviour: behaviourScoresForAuthority.money,
          ranking: rankingScoresForAuthority.money,
          backlinks: backlinkScore, // Same across all segments
          reviews: reviewScore      // Same across all segments
        });
        
        // Helper to compute GSC metrics for a segment from queryPages data
        const computeGSCMetricsForSegment = (queryPagesData, segmentFilter) => {
          if (!queryPagesData || queryPagesData.length === 0) {
            return { siteCtr: 0, top10Ctr: 0, avgPosition: 0, top10Share: 0 };
          }
          
          // Filter by segment if filter function provided
          let filteredData = queryPagesData;
          if (segmentFilter) {
            filteredData = queryPagesData.filter(row => {
              const segment = classifyPageSegment(row.page || row.url || '/');
              return segmentFilter(segment);
            });
          }
          
          // Filter to ranking queries (position 1-20, with impressions)
          const rankingQueries = filteredData.filter(q => {
            const pos = q.position || 0;
            const impr = q.impressions || 0;
            return pos > 0 && pos <= 20 && impr > 0;
          });
          const top10Queries = rankingQueries.filter(q => (q.position || 0) <= 10);
          
          let siteCtr = 0;
          let top10Ctr = 0;
          let avgPosition = 0;
          let top10Share = 0;
          
          if (rankingQueries.length > 0) {
            const totalClicks = rankingQueries.reduce((s, q) => s + (q.clicks || 0), 0);
            const totalImpr = rankingQueries.reduce((s, q) => s + (q.impressions || 0), 0);
            siteCtr = totalImpr > 0 ? (totalClicks / totalImpr) * 100 : 0;
            
            const top10Clicks = top10Queries.reduce((s, q) => s + (q.clicks || 0), 0);
            const top10Impr = top10Queries.reduce((s, q) => s + (q.impressions || 0), 0);
            top10Ctr = top10Impr > 0 ? (top10Clicks / top10Impr) * 100 : 0;
            
            avgPosition = totalImpr > 0
              ? rankingQueries.reduce((s, q) => s + (q.position || 0) * (q.impressions || 0), 0) / totalImpr
              : 0;
            
            top10Share = totalImpr > 0 ? (top10Impr / totalImpr) : 0; // Store as 0-1 fraction
          }
          
          return { siteCtr, top10Ctr, avgPosition, top10Share };
        };
        
        // Compute GSC metrics for each segment using full queryPages data (not pre-filtered rankingPages)
        const allGSCMetrics = computeGSCMetricsForSegment(queryPagesData, null); // All pages
        const excludeEduGSCMetrics = computeGSCMetricsForSegment(queryPagesData, (seg) => seg !== PageSegment.EDUCATION);
        const moneyGSCMetrics = computeGSCMetricsForSegment(queryPagesData, (seg) => seg === PageSegment.MONEY);
        
        debugLog(` GSC Metrics - All: CTR=${allGSCMetrics.siteCtr != null ? allGSCMetrics.siteCtr.toFixed(2) : 'N/A'}%, Pos=${allGSCMetrics.avgPosition != null ? allGSCMetrics.avgPosition.toFixed(1) : 'N/A'}`, 'info');
        debugLog(` GSC Metrics - ExcludeEdu: CTR=${excludeEduGSCMetrics.siteCtr != null ? excludeEduGSCMetrics.siteCtr.toFixed(2) : 'N/A'}%, Pos=${excludeEduGSCMetrics.avgPosition != null ? excludeEduGSCMetrics.avgPosition.toFixed(1) : 'N/A'}`, 'info');
        debugLog(` GSC Metrics - Money: CTR=${moneyGSCMetrics.siteCtr != null ? moneyGSCMetrics.siteCtr.toFixed(2) : 'N/A'}%, Pos=${moneyGSCMetrics.avgPosition != null ? moneyGSCMetrics.avgPosition.toFixed(1) : 'N/A'}`, 'info');
        
        authorityBySegment = {
          all: { 
            ...authorityAll, 
            topPages: allTopPages,
            siteCtr: allGSCMetrics.siteCtr,
            top10Ctr: allGSCMetrics.top10Ctr,
            avgPosition: allGSCMetrics.avgPosition,
            top10Share: allGSCMetrics.top10Share
          },
          nonEducation: { 
            ...authorityNonEducation, 
            topPages: excludeEduTopPages,
            siteCtr: excludeEduGSCMetrics.siteCtr,
            top10Ctr: excludeEduGSCMetrics.top10Ctr,
            avgPosition: excludeEduGSCMetrics.avgPosition,
            top10Share: excludeEduGSCMetrics.top10Share
          },
          money: { 
            ...authorityMoney, 
            topPages: moneyTopPages,
            siteCtr: moneyGSCMetrics.siteCtr,
            top10Ctr: moneyGSCMetrics.top10Ctr,
            avgPosition: moneyGSCMetrics.avgPosition,
            top10Share: moneyGSCMetrics.top10Share
          }
        };
        
        debugLog(` Authority by segment - All: ${authorityAll.total.toFixed(1)}, Non-education: ${authorityNonEducation.total.toFixed(1)}, Money: ${authorityMoney.total.toFixed(1)}`, 'info');
      }
      
      // Main Authority score (default: all pages)
      const authority = authorityAll.total;
      
      debugLog(`Authority calculation: Behaviour=${behaviourScore.toFixed(1)}, Ranking=${rankingScore.toFixed(1)}, Backlinks=${backlinkScore}, Reviews=${reviewScore}, Final=${authority}`, 'info');
      
      // Store component scores for historical tracking (backward compatible)
      const authorityComponents = {
        behaviour: authorityAll.behaviour,
        ranking: authorityAll.ranking,
        backlinks: authorityAll.backlinks,
        reviews: authorityAll.reviews,
        // Segmented scores (if available) - for backward compatibility
        behaviourScoreAll: behaviourScoresSegmented ? clampScore(behaviourScoresSegmented.all) : clampScore(behaviourScore),
        behaviourScoreNonBlog: behaviourScoresSegmented ? clampScore(behaviourScoresSegmented.nonBlog) : null,
        behaviourScoreMoney: behaviourScoresSegmented ? clampScore(behaviourScoresSegmented.money) : null,
        rankingScoreAll: rankingScoresSegmented ? clampScore(rankingScoresSegmented.all) : clampScore(rankingScore),
        rankingScoreNonBlog: rankingScoresSegmented ? clampScore(rankingScoresSegmented.nonBlog) : null,
        rankingScoreMoney: rankingScoresSegmented ? clampScore(rankingScoresSegmented.money) : null
      };
      
      // Log final segmented scores stored
      if (behaviourScoresSegmented) {
        debugLog(` Segmentation: Final stored scores - Behaviour: All=${authorityComponents.behaviourScoreAll}, NonBlog=${authorityComponents.behaviourScoreNonBlog}, Money=${authorityComponents.behaviourScoreMoney}`, 'info');
        debugLog(` Segmentation: Final stored scores - Ranking: All=${authorityComponents.rankingScoreAll}, NonBlog=${authorityComponents.rankingScoreNonBlog}, Money=${authorityComponents.rankingScoreMoney}`, 'info');
      }

      // Local Entity: Use real Business Profile data if available, otherwise fallback to derived calculation
      let localEntity;
      if (localSignals && localSignals.status === 'ok' && localSignals.data) {
        const localData = localSignals.data;
        const explicitLocalEntity = localData.localEntityScore;
        if (explicitLocalEntity !== null && explicitLocalEntity !== undefined) {
          localEntity = clampScore(explicitLocalEntity);
          debugLog(`Local Entity: Using explicit score from localSignals (${explicitLocalEntity})`, 'info');
        } else {
          // Base score from NAP consistency (0-100)
          let baseScore = localData.napConsistencyScore || 0;
          
          // Bonus for knowledge panel detection (+10 points)
          if (localData.knowledgePanelDetected) {
            baseScore = Math.min(100, baseScore + 10);
          }
          
          // Bonus for having at least one location (+5 points)
          if (localData.locations && localData.locations.length > 0) {
            baseScore = Math.min(100, baseScore + 5);
          }
          
          localEntity = clampScore(baseScore);
          debugLog(`Local Entity: NAP=${localData.napConsistencyScore || 0}, Knowledge Panel=${localData.knowledgePanelDetected}, Locations=${localData.locations?.length || 0}, Final=${localEntity}`, 'info');
        }
      } else {
        // Fallback: derived calculation (old method)
        // Calculate ctrScore from ctr (which is 0-100 percentage)
      const ctrDecimal = ctr / 100; // Convert percentage to decimal (e.g., 10% -> 0.10)
      const ctrScore = Math.min((ctrDecimal / 0.10) * 100, 100);
        localEntity = clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
        debugLog('Local Entity: Using fallback calculation (no Business Profile data)', 'warn');
      }

      // Service Area: Use real Business Profile service areas count if available, otherwise fallback
      let serviceArea;
      if (localSignals && localSignals.status === 'ok' && localSignals.data) {
        const localData = localSignals.data;
        const explicitServiceArea = localData.serviceAreaScore;
        if (explicitServiceArea !== null && explicitServiceArea !== undefined) {
          serviceArea = clampScore(explicitServiceArea);
          debugLog(`Service Area: Using explicit score from localSignals (${explicitServiceArea})`, 'info');
        } else {
          const serviceAreasCount = localData.serviceAreas?.length || 0;
          
          // Normalize service areas count to 0-100 score
          // 0 areas = 0, 8+ areas = 100 (more reasonable threshold)
          // Linear scale: 1 area = 12.5 points (8 areas = 100)
          if (serviceAreasCount === 0) {
            serviceArea = 0;
          } else if (serviceAreasCount >= 8) {
            serviceArea = 100;
          } else {
            // Linear scale: 1 area = 12.5 points, 2 = 25, ..., 8 = 100
            serviceArea = Math.min(100, serviceAreasCount * 12.5);
          }
          
          // Apply NAP consistency as a multiplier (if NAP is low, reduce service area score)
          if (localData.napConsistencyScore !== null && localData.napConsistencyScore < 100) {
            const napMultiplier = localData.napConsistencyScore / 100;
            serviceArea = Math.round(serviceArea * napMultiplier);
          }
          
          serviceArea = clampScore(serviceArea);
          debugLog(`Service Area: Count=${serviceAreasCount}, NAP Multiplier=${localData.napConsistencyScore !== null ? (localData.napConsistencyScore / 100).toFixed(2) : 'N/A'}, Final=${serviceArea}`, 'info');
        }
      } else {
        // Fallback: derived from Local Entity (old method)
        serviceArea = clampScore(localEntity - 5);
        debugLog('Service Area: Using fallback calculation (no Business Profile data)', 'warn');
      }

      // Content/Schema: weighted calculation based on foundation schemas, rich results, coverage, and diversity
      let contentSchema;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        const allTypes = new Set();
        
        // Use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
        if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
          // Use all detected types for accurate calculation
          schemaData.allDetectedTypes.forEach(type => {
            if (type) allTypes.add(type);
          });
        } else if (schemaData.foundation && typeof schemaData.foundation === 'object') {
          // Use foundation object to get foundation types (most reliable)
          Object.keys(schemaData.foundation).forEach(type => {
            if (schemaData.foundation[type] === true) {
              allTypes.add(type);
            }
          });
          // Also add from richEligible for complete type list
          if (schemaData.richEligible && typeof schemaData.richEligible === 'object') {
            Object.keys(schemaData.richEligible).forEach(type => {
              if (schemaData.richEligible[type] === true) {
                allTypes.add(type);
              }
            });
          }
        } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          // Fallback: collect from schemaTypes array (contains all types, sorted by count)
          // Handle both object format {type, count} and string format
          schemaData.schemaTypes.forEach(item => {
            if (typeof item === 'string') {
              allTypes.add(item);
            } else if (item && typeof item === 'object' && item.type) {
              allTypes.add(item.type);
            }
          });
        }
        
        // 1. Foundation Schemas Score (30% weight): Organization, Person, WebSite, BreadcrumbList
        const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
        const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
        const foundationScore = (foundationPresent / foundationTypes.length) * 100;
        
        // 2. Rich Result Eligibility Score (35% weight): Count eligible rich result types
        // Note: This list must match RICH_RESULT_TYPES in api/schema-audit.js
        const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
        const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
        const richResultScore = (richEligibleCount / richResultTypes.length) * 100;
        
        // 3. Coverage Score (20% weight): Pages with schema / total pages
        // Calculate coverage from pagesWithSchema and totalPages if coverage is not available
        let coverageScore = 0;
        if (typeof schemaData.coverage === 'number' && !isNaN(schemaData.coverage)) {
          coverageScore = schemaData.coverage;
        } else {
          // Calculate from pagesWithSchema and totalPages
          const pagesWithSchemaCount = Array.isArray(schemaData.pagesWithSchema) 
            ? schemaData.pagesWithSchema.length 
            : (typeof schemaData.pagesWithSchema === 'number' ? schemaData.pagesWithSchema : 0);
          const totalPagesCount = typeof schemaData.totalPages === 'number' 
            ? schemaData.totalPages 
            : (Array.isArray(schemaData.pages) ? schemaData.pages.length : 0);
          if (totalPagesCount > 0) {
            coverageScore = (pagesWithSchemaCount / totalPagesCount) * 100;
          }
        }
        
        // 4. Type Diversity Score (15% weight): Number of unique schema types (normalized to 15 types)
        const uniqueTypesCount = allTypes.size;
        const diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
        
        // Weighted calculation: 30% foundation + 35% rich results + 20% coverage + 15% diversity
        contentSchema = clampScore(
          foundationScore * 0.30 +
          richResultScore * 0.35 +
          coverageScore * 0.20 +
          diversityScore * 0.15
        );
        
        debugLog(`Content/Schema calculation: Foundation=${foundationScore != null ? foundationScore.toFixed(1) : 'N/A'}% (${foundationPresent}/4), Rich Results=${richResultScore != null ? richResultScore.toFixed(1) : 'N/A'}% (${richEligibleCount}/${richResultTypes.length}), Coverage=${coverageScore != null ? coverageScore.toFixed(1) : 'N/A'}%, Diversity=${diversityScore != null ? diversityScore.toFixed(1) : 'N/A'}% (${uniqueTypesCount} types)`, 'info');
      } else {
        // Fallback: if no schema audit data, return 0 (can't calculate without data)
        contentSchema = 0;
        debugLog(' No schema audit data available, Content/Schema score set to 0', 'warn');
      }

      // Extract coverage and diversity scores from contentSchema calculation for GAIO health
      let coverageScore = 0;
      let diversityScore = 0;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        // Coverage: Pages with schema / total pages (0-100)
        coverageScore = schemaData.coverage || 0;
        
        // Diversity: Number of unique schema types (normalized to 15 types, 0-100)
        const allTypes = new Set();
        if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
          schemaData.allDetectedTypes.forEach(type => {
            if (type) allTypes.add(type);
          });
        } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          schemaData.schemaTypes.forEach(item => {
            if (item.type) allTypes.add(item.type);
          });
        }
        const uniqueTypesCount = allTypes.size;
        diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
      }

      // ============================================================================
      // PHASE 1: Brand Overlay Calculation
      // ============================================================================
      
      // Calculate brand metrics from GSC query data
      // Use queryPages if available (more accurate), otherwise fall back to topQueries
      let brandMetrics;
      if (queryPages && queryPages.length > 0) {
        // Convert queryPages to query format for brand metrics calculation
        const queriesForBrand = queryPages.map(row => ({
          query: row.query || '',
          clicks: row.clicks || 0,
          impressions: row.impressions || 0,
          position: row.position || 0
        }));
        brandMetrics = calculateBrandMetrics(queriesForBrand);
      } else {
        // Fallback to topQueries
        brandMetrics = calculateBrandMetrics(topQueries);
      }
      debugLog(`Brand Metrics: Share=${(brandMetrics.brandQueryShare * 100).toFixed(2)}%, CTR=${(brandMetrics.brandCtr * 100).toFixed(2)}%, AvgPos=${brandMetrics.brandAvgPosition?.toFixed(1) || 'N/A'}`, 'info');
      
      // Compute brand overlay score
      const brandOverlay = computeBrandOverlay({
        brandQueryShare: brandMetrics.brandQueryShare,
        brandCtr: brandMetrics.brandCtr,
        brandAvgPosition: brandMetrics.brandAvgPosition,
        reviewScore: reviewScore,
        entityScore: localEntity
      });
      debugLog(`Brand Overlay: Score=${brandOverlay.score}, Label=${brandOverlay.label}, Notes=${brandOverlay.notes.length}`, 'info');
      
      // ============================================================================
      // End Phase 1: Brand Overlay Calculation
      // ============================================================================

      // ============================================================================
      // Money Pages Performance Metrics
      // ============================================================================
      
      /**
       * Compute site-wide aggregates from topPages data
       * @param {Array} topPages - Array of page objects with clicks, impressions, position
       * @returns {Object} Site aggregates
       */
      function computeSiteAggregateFromTopPages(topPages) {
        if (!topPages || !Array.isArray(topPages) || topPages.length === 0) {
          return {
            totalClicks: 0,
            totalImpressions: 0,
            avgCtr: 0,
            avgPosition: null
          };
        }
        
        let totalClicks = 0;
        let totalImpressions = 0;
        let weightedPosSum = 0;
        
        topPages.forEach(page => {
          const clicks = page.clicks || 0;
          const impressions = page.impressions || 0;
          const position = page.position || page.avgPosition || 0;
          
          totalClicks += clicks;
          totalImpressions += impressions;
          if (impressions > 0 && position > 0) {
            weightedPosSum += position * impressions;
          }
        });
        
        const avgCtr = totalImpressions > 0 ? totalClicks / totalImpressions : 0;
        const avgPosition = totalImpressions > 0 ? weightedPosSum / totalImpressions : null;
        
        return {
          totalClicks,
          totalImpressions,
          avgCtr,
          avgPosition
        };
      }
      
      /**
       * Classify a money page into an opportunity category and return a short recommendation.
       * @param {Object} metrics - { ctr (01), avgPosition, impressions }
       * @param {Object} siteAgg - { avgCtr, avgPosition }
       * @returns {Object} { category, categoryLabel, categoryColor, recommendation }
       */
      function classifyMoneyPageOpportunity(metrics, siteAgg, hasSchema = null, schemaTypes = []) {
        const { ctr, avgPosition, impressions } = metrics;
        const siteCtr = siteAgg.avgCtr || 0;
        const sitePos = siteAgg.avgPosition || 0;
        
        // Sensible defaults
        const safePos = avgPosition || 99;
        const safeCtr = ctr || 0;
        const imp = impressions || 0;
        
        // Thresholds (tune later)
        const MIN_IMPRESSIONS = 100;
        const HIGH_OPP_MAX_POS = 15;
        const MAINTAIN_MAX_POS = 8;
        
        const targetCtrHigh = 0.05;   // 5% for strong
        const targetCtrMid = 0.03;    // 3% mid range
        const lowCtrThreshold = 0.02;  // 2%
        
        let category = 'VISIBILITY_FIX';
        let categoryLabel = 'Visibility fix';
        let categoryColor = 'red';
        let recommendation = '';
        
        // Check which schema types are missing (for money pages, we typically want Product, Event, FAQPage)
        const desiredSchemaTypes = ['Product', 'Event', 'FAQPage'];
        // Normalize present types to lowercase for case-insensitive comparison
        const presentTypes = Array.isArray(schemaTypes) && schemaTypes.length > 0 
          ? schemaTypes.map(t => {
              if (typeof t === 'string') return t.trim().toLowerCase();
              if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type.trim().toLowerCase();
              return String(t).trim().toLowerCase();
            }).filter(t => t && t !== '[object object]')
          : [];
        // Check for missing types (case-insensitive comparison)
        const missingTypes = desiredSchemaTypes.filter(type => {
          const typeLower = type.toLowerCase();
          return !presentTypes.includes(typeLower);
        });
        
        // Build schema recommendation based on what's actually missing
        // Only recommend schema types that are NOT already present
        let schemaRecommendation = '';
        if (hasSchema === false) {
          // No schema at all - generic recommendation
          schemaRecommendation = 'ensure Product/Event/FAQ schema is present, and ';
        } else if (missingTypes.length > 0) {
          // Has schema but missing some or all desired types
          if (missingTypes.length === desiredSchemaTypes.length) {
            // Has schema but none of the desired types (Product, Event, FAQPage) - generic
            schemaRecommendation = 'ensure Product/Event/FAQ schema is present, and ';
          } else {
            // Missing specific types - only recommend what's actually missing (e.g., "add Product/Event schema")
            const missingTypesText = missingTypes.join('/');
            schemaRecommendation = `add ${missingTypesText} schema, and `;
          }
        }
        // If hasSchema === true AND missingTypes.length === 0, no schema recommendation (all desired types present)
        
        // 1) High opportunity: decent position, impressions, but weak CTR
        const hasDecentPosition = safePos >= 3 && safePos <= HIGH_OPP_MAX_POS;
        const hasVolume = imp >= MIN_IMPRESSIONS;
        const ctrBelowTargetForBand =
          (safePos <= 6 && safeCtr < targetCtrHigh) ||
          (safePos > 6 && safePos <= 10 && safeCtr < targetCtrMid) ||
          (safePos > 10 && safePos <= HIGH_OPP_MAX_POS && safeCtr < lowCtrThreshold);
        
        if (hasDecentPosition && hasVolume && ctrBelowTargetForBand) {
          category = 'HIGH_OPPORTUNITY';
          categoryLabel = 'High opportunity (improve CTR)';
          categoryColor = 'amber';
          // Add schema recommendation if missing (use same logic as visibility fix)
          let schemaNote = '';
          if (hasSchema === false) {
            // No schema at all
            schemaNote = ' Add Product/Event/FAQ schema to improve rich result eligibility. ';
          } else if (missingTypes.length > 0) {
            // Has schema but missing some or all desired types
            if (missingTypes.length === desiredSchemaTypes.length) {
              // Has schema but none of the desired types
              schemaNote = ' Add Product/Event/FAQ schema to improve rich result eligibility. ';
            } else {
              // Missing specific types - only recommend what's actually missing
              schemaNote = ` Add ${missingTypes.join('/')} schema to improve rich result eligibility. `;
            }
          }
          // If missingTypes.length === 0, no schema recommendation (all desired types present)
          recommendation =
            `Good visibility (avg position ${safePos.toFixed(1)}) and ` +
            `${imp.toLocaleString()} impressions, but low CTR (${(safeCtr * 100).toFixed(1)}%). ` +
            `Prioritise title/meta improvements, "best" phrasing for this offer, ` +
            `${schemaNote}` +
            `and adding FAQs that address objections for this money page.`;
        }
        // 2) Maintain: strong position + CTR above target
        else if (safePos <= MAINTAIN_MAX_POS && safeCtr >= targetCtrMid && imp >= MIN_IMPRESSIONS) {
          category = 'MAINTAIN';
          categoryLabel = 'Maintain (performing well)';
          categoryColor = 'green';
          recommendation =
            `Strong performer with avg position ${safePos.toFixed(1)} and ` +
            `CTR ${(safeCtr * 100).toFixed(1)}%. Maintain current messaging and ` +
            `internal links; focus optimisation efforts on weaker money pages first.`;
        }
        // 3) Visibility fix: fallback
        else {
          category = 'VISIBILITY_FIX';
          categoryLabel = 'Visibility fix (low impressions/rank)';
          categoryColor = 'red';
          recommendation =
            `Limited visibility (avg position ${Number.isFinite(safePos) ? safePos.toFixed(1) : ''} ` +
            `and ${imp.toLocaleString()} impressions). Strengthen internal links from high-traffic ` +
            `educational posts, ${schemaRecommendation}` +
            `consider a clearer "best [topic]" section to signal value to searchers and AI.`;
        }
        
        return { category, categoryLabel, categoryColor, recommendation };
      }
      
      /**
       * Compute aggregate and per-URL metrics for money pages.
       * @param {Array} topPages - Array from GSC (page/url, clicks, impressions, position)
       * @param {Function} classifySegment - function(url) -> 'money' | 'education' | 'general' | ...
       * @param {Object} siteAgg - { totalClicks, totalImpressions, avgCtr, avgPosition }
       * @param {Map|Object} pageTitleLookup - Optional Map/object url->title
       * @param {Object} schemaAudit - Optional schema audit data with pages array
       * @returns {Object} { overview, rows }
       */
      // Ranking & AI module - MOVED TO TOP OF SCRIPT (see line ~1820)

      // Classify money page sub-segment (Product, Event, Landing)
      function classifyMoneyPageSubSegment(url) {
        if (!url) return 'LANDING';
        
        // Use the same classification logic as Ranking & AI for consistency
        // This ensures Event/Product pages are classified the same way in both tabs
        if (typeof window.classifyUrlForRankingAi === 'function') {
          const classification = window.classifyUrlForRankingAi(url);
          const pageType = classification.pageType;
          
          // Map Ranking & AI pageType to Money Pages segmentType
          if (pageType === 'Event') return 'EVENT';
          if (pageType === 'Product') return 'PRODUCT';
          if (pageType === 'Landing') return 'LANDING';
          // For non-money pages (GBP, Blog, Other), return LANDING as fallback
          // (Money Pages only shows money pages, so these shouldn't appear anyway)
          return 'LANDING';
        }
        
        // Fallback: Use original logic if classifyUrlForRankingAi not available
        const path = normalisePath(url);
        const urlLower = url.toLowerCase();
        
        // Event Pages: Use same pattern as Ranking & AI (substring match for consistency)
        if (urlLower.includes('/beginners-photography-lessons') ||
            urlLower.includes('/photographic-workshops-near-me')) {
          return 'EVENT';
        }
        
        // Product Pages: Use same pattern as Ranking & AI (substring match for consistency)
        if (urlLower.includes('/photo-workshops-uk') ||
            urlLower.includes('/photography-services-near-me')) {
          return 'PRODUCT';
        }
        
        // Landing Pages (default - anything not matching above)
        return 'LANDING';
      }
      
      function computeMoneyPagesMetrics(topPages, classifySegment, siteAgg, pageTitleLookup = null, schemaAudit = null) {
        // Initialize summary by category (Phase 2)
        const summaryByCategory = {
          HIGH_OPPORTUNITY: { count: 0, impressions: 0, clicks: 0 },
          VISIBILITY_FIX: { count: 0, impressions: 0, clicks: 0 },
          MAINTAIN: { count: 0, impressions: 0, clicks: 0 }
        };
        
        // Initialize summary by sub-segment
        const summaryBySubSegment = {
          PRODUCT: { count: 0, impressions: 0, clicks: 0 },
          EVENT: { count: 0, impressions: 0, clicks: 0 },
          LANDING: { count: 0, impressions: 0, clicks: 0 }
        };
        
        if (!topPages || !Array.isArray(topPages) || topPages.length === 0) {
          return {
            overview: {
              moneyClicks: 0,
              moneyImpressions: 0,
              moneyCtr: 0,
              moneyAvgPosition: null,
              moneyCoverageCount: 0,
              moneyTotalKnown: null,
              moneyCoveragePct: null,
              siteCtr: siteAgg.avgCtr || 0,
              siteAvgPosition: siteAgg.avgPosition || null,
              siteTotalClicks: siteAgg.totalClicks || 0,
              siteTotalImpressions: siteAgg.totalImpressions || 0
            },
            rows: [],
            summaryByCategory
          };
        }
        
        const moneyRows = [];
        let moneyClicks = 0;
        let moneyImpressions = 0;
        let weightedPosSum = 0;
        const moneyActiveUrls = new Set();
        
        // Convert pageTitleLookup to Map if it's an object (for backward compatibility)
        // If it's already a Map with metadata objects, use it directly
        let metadataMap = null;
        if (pageTitleLookup instanceof Map) {
          // Check if it contains metadata objects or just titles
          const firstValue = pageTitleLookup.values().next().value;
          if (firstValue && typeof firstValue === 'object' && (firstValue.title !== undefined || firstValue.metaDescription !== undefined)) {
            metadataMap = pageTitleLookup; // It's already a metadata map
          } else {
            // Convert title-only map to metadata map
            metadataMap = new Map();
            pageTitleLookup.forEach((title, url) => {
              metadataMap.set(url, { title: title, metaDescription: null });
            });
          }
        } else if (pageTitleLookup) {
          // Convert object to metadata map
          metadataMap = new Map();
          Object.entries(pageTitleLookup).forEach(([url, value]) => {
            if (typeof value === 'object' && value !== null) {
              metadataMap.set(url, { title: value.title || null, metaDescription: value.metaDescription || null });
            } else {
              metadataMap.set(url, { title: value || null, metaDescription: null });
            }
          });
        }
        
        // Build schema lookup map from schema audit data
        const schemaLookup = new Map();
        const schemaTypesLookup = new Map();
        if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data && schemaAudit.data.pages) {
          schemaAudit.data.pages.forEach(page => {
            if (page.url) {
              // Normalize URL for matching (handles trailing slashes, query params, etc.)
              const normalizedUrl = normalizeUrlForMatching(page.url);
              // Store both original and normalized for lookup flexibility
              const hasSchema = page.hasSchema || page.hasInheritedSchema || false;
              schemaLookup.set(page.url, hasSchema);
              schemaLookup.set(normalizedUrl, hasSchema); // Also store normalized version
              // Store schema types array
              schemaTypesLookup.set(page.url, page.schemaTypes || []);
              schemaTypesLookup.set(normalizedUrl, page.schemaTypes || []); // Also store normalized version
            }
          });
        }
        
        // Iterate over topPages
        // Note: topPages is already aggregated by page from queryPages
        // The Segment Overview uses query+page level data filtered to position 1-20
        // Money Pages uses page-level GSC totals (unfiltered, all positions) to match GSC "Pages" tab exactly
        // to give a complete view of money page performance
        topPages.forEach(page => {
          const url = page.page || page.url || '';
          if (!url) return;
          
          const segment = classifyPageSegment(url);
          if (segment !== PageSegment.MONEY) return;
          
          const clicks = page.clicks || 0;
          const impressions = page.impressions || 0;
          const position = page.position || page.avgPosition || 0;
          
          if (impressions > 0) {
            moneyClicks += clicks;
            moneyImpressions += impressions;
            weightedPosSum += position * impressions;
            moneyActiveUrls.add(url);
          }
          
          // Compute row-level metrics
          const ctr = impressions > 0 ? clicks / impressions : 0;
          const avgPosition = position || null;
          
          // Get title and meta description from metadata lookup
          const metadata = metadataMap?.get(url) || {};
          const title = metadata.title || null;
          const metaDescription = metadata.metaDescription || null;
          
          // Check if schema exists for this page (normalize URL for matching)
          const normalizedUrl = normalizeUrlForMatching(url);
          const hasSchema = schemaLookup.has(url) ? schemaLookup.get(url) : 
                          schemaLookup.has(normalizedUrl) ? schemaLookup.get(normalizedUrl) : null;
          const schemaTypes = schemaTypesLookup.get(url) || schemaTypesLookup.get(normalizedUrl) || [];
          
          // Classify opportunity
          const { category, categoryLabel, categoryColor, recommendation } =
            classifyMoneyPageOpportunity({ ctr, avgPosition, impressions }, siteAgg, hasSchema, schemaTypes);
          
          // Classify sub-segment
          const subSegment = classifyMoneyPageSubSegment(url);
          
          // Update category summary (Phase 2)
          const bucket = summaryByCategory[category];
          if (bucket) {
            bucket.count += 1;
            bucket.impressions += impressions;
            bucket.clicks += clicks;
          }
          
          // Update sub-segment summary
          const subBucket = summaryBySubSegment[subSegment];
          if (subBucket) {
            subBucket.count += 1;
            subBucket.impressions += impressions;
            subBucket.clicks += clicks;
          }
          
          // Push row
          moneyRows.push({
            url,
            title,
            metaDescription,
            clicks,
            impressions,
            ctr,
            avgPosition,
            category,
            categoryLabel,
            categoryColor,
            recommendation,
            schemaTypes,
            subSegment // Add sub-segment to each row
          });
        });
        
        // Compute money overview
        const moneyCtr = moneyImpressions > 0 ? moneyClicks / moneyImpressions : 0;
        const moneyAvgPosition = moneyImpressions > 0 ? weightedPosSum / moneyImpressions : null;
        
        const overview = {
          moneyClicks,
          moneyImpressions,
          moneyCtr,
          moneyAvgPosition,
          moneyCoverageCount: moneyActiveUrls.size,
          moneyTotalKnown: null, // Can be populated if we have a known money URLs list
          moneyCoveragePct: null,
          siteCtr: siteAgg.avgCtr || 0,
          siteAvgPosition: siteAgg.avgPosition || null,
          siteTotalClicks: siteAgg.totalClicks || 0,
          siteTotalImpressions: siteAgg.totalImpressions || 0
        };
        
        // Sort by category then impressions desc
        const categoryOrder = { HIGH_OPPORTUNITY: 0, VISIBILITY_FIX: 1, MAINTAIN: 2 };
        moneyRows.sort((a, b) => {
          const ca = categoryOrder[a.category] ?? 99;
          const cb = categoryOrder[b.category] ?? 99;
          if (ca !== cb) return ca - cb;
          return (b.impressions || 0) - (a.impressions || 0);
        });
        
        return { overview, rows: moneyRows, summaryByCategory, summaryBySubSegment };
      }
      
      // Build compact Money Pages summary for trend tracking (Phase 3)
      // Make buildMoneyPagesSummary globally accessible
      window.buildMoneyPagesSummary = function buildMoneyPagesSummary(moneyPagesMetrics, overview) {
        if (!moneyPagesMetrics || !moneyPagesMetrics.rows || !moneyPagesMetrics.rows.length) {
          return null;
        }

        const pages = moneyPagesMetrics.rows;
        const impressions = pages.reduce((sum, p) => sum + (p.impressions || 0), 0);
        const clicks = pages.reduce((sum, p) => sum + (p.clicks || 0), 0);
        const avgPosWeightedSum = pages.reduce((sum, p) =>
          sum + ((p.avgPosition || p.position || 0) * (p.impressions || 0)), 0
        );

        if (!impressions) return null;

        const avgPosition = avgPosWeightedSum / impressions;
        const ctr = clicks / impressions;

        // Use siteTotalImpressions and siteTotalClicks from overview
        const totalImpressions = overview?.siteTotalImpressions || overview?.totalImpressions || null;
        const totalClicks = overview?.siteTotalClicks || overview?.totalClicks || null;
        
        const shareOfImpressions = totalImpressions && totalImpressions > 0
          ? impressions / totalImpressions
          : null;

        const shareOfClicks = totalClicks && totalClicks > 0
          ? clicks / totalClicks
          : null;

        // Debug logging (only log if we have impressions but no overview - expected when overview is missing)
        if (shareOfImpressions == null && impressions > 0) {
          // Only log if this is unexpected (we have impressions but no overview data)
          // This is expected when overview data is not available, so reduce log level
          debugLog(` buildMoneyPagesSummary: shareOfImpressions is null (overview data not available) - impressions=${impressions}`, 'info');
        } else if (shareOfImpressions != null) {
          debugLog(` buildMoneyPagesSummary: shareOfImpressions=${shareOfImpressions} (${impressions}/${totalImpressions})`, 'info');
        }

        return {
          count: pages.length,
          impressions,
          clicks,
          ctr,
          avgPosition,
          shareOfImpressions,
          shareOfClicks,
          behaviourScore: moneyPagesMetrics.behaviour
            ? moneyPagesMetrics.behaviour.score
            : null
        };
      };
      
      // ============================================================================
      // PHASE: Money Pages Priority Matrix + 12-Month KPI Tracker
      // ============================================================================
      
      /**
       * Unified money page classification - returns both isMoney flag and segmentType
       * @param {string} url
       * @returns {{ isMoney: boolean, segmentType: MoneySegmentKey | null }}
       */
      function classifyMoneyPage(url) {
        if (!url) return { isMoney: false, segmentType: null };
        
        const path = normalisePath(url);
        
        // Check if it's a money page using existing logic
        const segment = classifyPageSegment(url);
        const isMoney = segment === PageSegment.MONEY;
        
        if (!isMoney) {
          return { isMoney: false, segmentType: null };
        }
        
        // Get sub-segment type (normalize to lowercase for consistency)
        const subSegment = classifyMoneyPageSubSegment(url);
        let segmentType = /** @type {MoneySegmentKey} */ ("all");
        
        if (subSegment === 'PRODUCT') {
          segmentType = "product";
        } else if (subSegment === 'EVENT') {
          segmentType = "event";
        } else if (subSegment === 'LANDING') {
          segmentType = "landing";
        }
        
        return { isMoney: true, segmentType };
      }
      
      // Make available globally for classifyUrlForRankingAi
      if (typeof window !== 'undefined') {
        window.classifyMoneyPage = classifyMoneyPage;
      }
      
      /**
       * Naive expected CTR curve by average position.
       * Returns decimal (01).
       * @param {number} pos - Average position
       * @returns {number}
       */
      function expectedCtrForPosition(pos) {
        if (!isFinite(pos) || pos <= 0) return 0.10;     // fallback
        if (pos <= 3) return 0.10;                       // 10% ideal for top 3
        if (pos <= 6) return 0.07;                       // 7% for 46
        if (pos <= 10) return 0.05;                      // 5% for 710
        if (pos <= 20) return 0.03;                      // 3% for 1120
        return 0.02;                                     // long tail
      }
      
      /**
       * Compute impact levels based on lost clicks (expected CTR - actual CTR)
       * @param {Array<MoneyPageMetrics>} pages
       */
      function computeImpactLevels(pages) {
        // Step 1: compute lostClicks for each page
        let maxLost = 0;
        for (const p of pages) {
          const expectedCtr = expectedCtrForPosition(p.avgPosition);
          const gap = Math.max(0, expectedCtr - (p.ctr || 0));
          const lostClicks = (p.impressions || 0) * gap;
          p._lostClicks = lostClicks;
          if (lostClicks > maxLost) maxLost = lostClicks;
        }

        if (maxLost <= 0) {
          // All pages flat  mark all as LOW impact
          for (const p of pages) {
            p.impactLevel = "LOW";
          }
          return;
        }

        // Step 2: thresholds relative to max (no magic numbers baked into data)
        const highThreshold = 0.75 * maxLost;
        const medThreshold = 0.35 * maxLost;

        for (const p of pages) {
          const lost = p._lostClicks || 0;
          if (lost >= highThreshold) p.impactLevel = "HIGH";
          else if (lost >= medThreshold) p.impactLevel = "MEDIUM";
          else p.impactLevel = "LOW";
        }
      }
      
      /**
       * Check if a page has the "key schema" for its segment type
       * @param {string} url
       * @param {MoneySegmentKey} segmentType
       * @param {Object} schemaAudit - Schema audit data with pages array
       * @returns {boolean}
       */
      function pageHasKeySchema(url, segmentType, schemaAudit) {
        if (!schemaAudit || !schemaAudit.data || !schemaAudit.data.pages) {
          return false;
        }
        
        const page = schemaAudit.data.pages.find(p => p.url === url);
        if (!page) return false;
        
        const schemaTypes = page.schemaTypes || [];
        const typesLower = schemaTypes.map(t => {
          if (typeof t === 'string') return t.toLowerCase();
          if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type.toLowerCase();
          return String(t).toLowerCase();
        }).filter(t => t && t !== '[object object]');
        
        if (segmentType === "event") {
          return typesLower.includes("event") || typesLower.includes("course");
        } else if (segmentType === "product") {
          return typesLower.includes("product") || typesLower.includes("offer");
        } else if (segmentType === "landing") {
          return typesLower.includes("itemlist") || typesLower.includes("faqpage") || typesLower.includes("article");
        }
        
        return false;
      }
      
      /**
       * Compute difficulty level based on position + schema effort
       * @param {MoneyPageMetrics} p
       * @param {boolean} hasKeySchema   // true if this page already has the main rich type it "should"
       * @returns {DifficultyLevel}
       */
      function computeDifficultyLevel(p, hasKeySchema) {
        const pos = p.avgPosition || 0;
        let base;
        if (pos > 0 && pos <= 5) base = "LOW";          // already ranking well  "easy" CTR fixes
        else if (pos <= 10) base = "MEDIUM";
        else base = "HIGH";

        // If no key schema yet for an event/product, bump difficulty by one
        if (!hasKeySchema && (p.segmentType === "event" || p.segmentType === "product")) {
          if (base === "LOW") base = "MEDIUM";
          else if (base === "MEDIUM") base = "HIGH";
        }

        return /** @type {DifficultyLevel} */ (base);
      }
      
      /**
       * Derive priority level from Impact + Difficulty
       * @param {ImpactLevel} impact
       * @param {DifficultyLevel} difficulty
       * @returns {PriorityLevel}
       */
      function derivePriorityLevel(impact, difficulty) {
        // High impact & easy/medium difficulty  HIGH priority
        if (impact === "HIGH" && (difficulty === "LOW" || difficulty === "MEDIUM")) {
          return "HIGH";
        }

        // Medium cases or high impact but high difficulty  MEDIUM
        if (
          impact === "HIGH" && difficulty === "HIGH" ||
          impact === "MEDIUM" && (difficulty === "LOW" || difficulty === "MEDIUM")
        ) {
          return "MEDIUM";
        }

        // Everything else  LOW
        return "LOW";
      }
      
      /**
       * Build MoneyPageMetrics array from topPages data
       * @param {Array<{page: string, clicks: number, impressions: number, ctr: number, position: number, title?: string}>} topPages
       * @param {Object} schemaAudit - Optional schema audit data
       * @returns {Array<MoneyPageMetrics>}
       */
      function buildMoneyPageMetrics(topPages, schemaAudit = null) {
        const result = [];

        for (const row of topPages) {
          const url = row.page || row.url;
          const { isMoney, segmentType } = classifyMoneyPage(url);
          if (!isMoney) continue;

          // CTR might be percentage (0-100) or decimal (0-1), normalize to decimal
          let ctr = row.ctr || 0;
          if (ctr > 1) ctr = ctr / 100; // Convert percentage to decimal
          
          const m = /** @type {MoneyPageMetrics} */ ({
            url,
            title: row.title || url,
            segmentType: segmentType || "all",
            clicks: row.clicks || 0,
            impressions: row.impressions || 0,
            ctr: ctr,
            avgPosition: row.position || row.avgPosition || 0,
            impactLevel: "LOW",
            difficultyLevel: "MEDIUM",
            priorityLevel: "LOW"
          });

          const hasKeySchema = pageHasKeySchema(url, m.segmentType, schemaAudit);
          m.difficultyLevel = computeDifficultyLevel(m, hasKeySchema);
          result.push(m);
        }

        computeImpactLevels(result);

        for (const p of result) {
          p.priorityLevel = derivePriorityLevel(p.impactLevel, p.difficultyLevel);
        }

        return result;
      }
      
      // Make function globally accessible immediately after definition
      // CRITICAL: Assign to window immediately so it's available when displayDashboard runs
      // This REPLACES the placeholder we defined at the top of the script
      if (typeof window !== 'undefined') {
        window.buildMoneyPageMetrics = buildMoneyPageMetrics;
        // Also assign to global scope as fallback
        if (typeof globalThis !== 'undefined') {
          globalThis.buildMoneyPageMetrics = buildMoneyPageMetrics;
        }
        // Debug: Log that function is now available
        console.log('[Money Pages]  buildMoneyPageMetrics FULL IMPLEMENTATION assigned to window (replaced placeholder)');
      }
      
      /**
       * Build per-segment summaries for Money Pages (for 12-month KPI tracking)
       * @param {Array<MoneyPageMetrics>} moneyPages
       * @param {Object} behaviourScores - Optional behaviour scores by segment
       * @returns {MoneySegmentMetricsByAudit}
       */
      function buildMoneySegmentSummary(moneyPages, behaviourScores = {}) {
        // Ensure moneyPages is an array (default to empty array)
        const pages = Array.isArray(moneyPages) ? moneyPages : [];
        
        const segments = {
          allMoney: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
          landingPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
          eventPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
          productPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 }
        };

        const groups = {
          allMoney: pages,
          landingPages: pages.filter(p => p.segmentType === "landing"),
          eventPages: pages.filter(p => p.segmentType === "event"),
          productPages: pages.filter(p => p.segmentType === "product")
        };

        for (const [key, groupPages] of Object.entries(groups)) {
          if (!groupPages || !groupPages.length) continue;
          const clicks = groupPages.reduce((s, p) => s + (p.clicks || 0), 0);
          const impressions = groupPages.reduce((s, p) => s + (p.impressions || 0), 0);
          const ctr = impressions > 0 ? clicks / impressions : 0;
          const avgPosition = groupPages.length > 0
            ? groupPages.reduce((s, p) => s + (p.avgPosition || 0), 0) / groupPages.length
            : 0;

          segments[key].clicks = clicks;
          segments[key].impressions = impressions;
          segments[key].ctr = ctr;
          segments[key].avgPosition = avgPosition;
          // Use behaviour score from parameter if available, otherwise 0
          segments[key].behaviourScore = behaviourScores[key] || behaviourScores[key.toLowerCase()] || 0;
        }

        // Always return a valid structure (never null)
        return segments;
      }
      
      // Compute money pages behaviour score (for Authority overlay)
      // Define globally to ensure accessibility from event handlers
      window.computeMoneyPagesBehaviour = function(gscQueries, moneyPages, useAllPositions = false) {
        if (!gscQueries || !gscQueries.length || !moneyPages || !moneyPages.length) {
          debugLog(` computeMoneyPagesBehaviour: Missing data - gscQueries=${!!gscQueries}(${gscQueries?.length || 0}), moneyPages=${!!moneyPages}(${moneyPages?.length || 0})`, 'warn');
          return null;
        }

        // Normalize URLs: remove trailing slash, convert to lowercase, remove protocol if present
        const normalizeUrl = (url) => {
          if (!url) return '';
          let normalized = url.toString().trim().toLowerCase();
          // Remove protocol (http:// or https://)
          normalized = normalized.replace(/^https?:\/\//, '');
          // Remove trailing slash
          normalized = normalized.replace(/\/$/, '');
          return normalized;
        };

        const moneySet = new Set(
          moneyPages.map(p => {
            const url = normalizeUrl(p.url || p.page || '');
            return url;
          })
        );

        debugLog(` computeMoneyPagesBehaviour: Created moneySet with ${moneySet.size} URLs. useAllPositions=${useAllPositions}. Sample URLs: ${Array.from(moneySet).slice(0, 3).join(', ')}`, 'info');

        let clicks = 0;
        let impressions = 0;
        let top10Clicks = 0;
        let top10Impressions = 0;
        let weightedPosSum = 0;
        let weightedPosImps = 0;
        let matchedUrls = 0;
        let unmatchedUrls = 0;
        let filteredOutByPosition = 0;

        gscQueries.forEach(row => {
          const url = normalizeUrl(row.page || row.url || '');
          if (!moneySet.has(url)) {
            unmatchedUrls++;
            return;
          }
          matchedUrls++;

          const pos = typeof row.position === 'number'
            ? row.position
            : (row.avgPosition || null);
          const imps = row.impressions || 0;
          const cls = row.clicks || 0;

          // For filtered calculations, include all positions; otherwise only 1-20 to match Authority
          if (!imps || !pos || pos <= 0) return;
          if (!useAllPositions && pos > 20) {
            filteredOutByPosition++;
            return;
          }

          clicks += cls;
          impressions += imps;

          weightedPosSum += pos * imps;
          weightedPosImps += imps;
          if (pos <= 10) {
            top10Clicks += cls;
            top10Impressions += imps;
          }
        });

        debugLog(` computeMoneyPagesBehaviour: Matched ${matchedUrls} URLs, unmatched ${unmatchedUrls} URLs, filtered by position ${filteredOutByPosition}. Total impressions: ${impressions}, clicks: ${clicks}`, 'info');

        if (!impressions || !weightedPosImps) {
          debugLog(` computeMoneyPagesBehaviour: No valid impressions (${impressions}) or weighted positions (${weightedPosImps}), returning null`, 'warn');
          return null;
        }

        const siteCtr = clicks / impressions;
        const top10Ctr = top10Impressions > 0 ? (top10Clicks / top10Impressions) : 0;
        const avgPos = weightedPosSum / weightedPosImps;
        const top10Share = impressions > 0 ? (top10Impressions / impressions) : 0;

        // Reuse existing Behaviour score calculation (same as Authority)
        // For filtered calculations, include all positions; otherwise only 1-20
        const rankingQueries = gscQueries.filter(row => {
          const url = normalizeUrl(row.page || row.url || '');
          if (!moneySet.has(url)) return false;
          const pos = typeof row.position === 'number' ? row.position : (row.avgPosition || null);
          if (!pos || pos <= 0 || !(row.impressions || 0)) return false;
          if (!useAllPositions && pos > 20) return false;
          return true;
        });

        const behaviourScore = computeBehaviourScoreRaw(rankingQueries);

        return {
          score: behaviourScore,
          siteCtr,
          top10Ctr,
          avgPos,
          top10Share,
          clicks,
          impressions
        };
      };

      // Fallback: compute Money Pages behaviour from page-level aggregates (no queryPages required)
      // Used when queryPages is missing/truncated or URLs don't match.
      function computeMoneyPagesBehaviourFromPageAggregates(moneyPages) {
        if (!Array.isArray(moneyPages) || moneyPages.length === 0) return null;

        let clicks = 0;
        let impressions = 0;
        let weightedPosSum = 0;
        let weightedPosImps = 0;
        let top10Clicks = 0;
        let top10Impressions = 0;

        moneyPages.forEach(p => {
          const imps = p.impressions || 0;
          const cls = p.clicks || 0;
          const pos = typeof p.avgPosition === 'number' ? p.avgPosition : (p.avgPosition ? parseFloat(p.avgPosition) : null);
          if (!imps || !pos || pos <= 0) return;

          clicks += cls;
          impressions += imps;
          weightedPosSum += pos * imps;
          weightedPosImps += imps;

          // Approximate top-10 using avgPosition (best available without query-level data)
          if (pos <= 10) {
            top10Clicks += cls;
            top10Impressions += imps;
          }
        });

        if (!impressions || !weightedPosImps) return null;

        const siteCtr = clicks / impressions;
        const top10Ctr = top10Impressions > 0 ? (top10Clicks / top10Impressions) : 0;
        const avgPos = weightedPosSum / weightedPosImps;
        const top10Share = impressions > 0 ? (top10Impressions / impressions) : 0;

        // Map CTR to score using same bands as Authority behaviour
        const scoreCtrAll = Math.min(siteCtr / 0.05, 1) * 100;    // 05% => 0100
        const scoreCtrTop10 = Math.min(top10Ctr / 0.10, 1) * 100; // 010% => 0100
        const behaviourScore = 0.5 * scoreCtrAll + 0.5 * scoreCtrTop10;

        return {
          score: behaviourScore,
          siteCtr,
          top10Ctr,
          avgPos,
          top10Share,
          clicks,
          impressions
        };
      }
      
      // ============================================
      // STEP 1: Build pageTotalsByKey (single source of truth for page-level GSC data)
      // ============================================
      // Fetch page-level data from GSC API (unfiltered, all positions)
      // This matches GSC "Pages" tab totals exactly
      // Always uses rolling "last 28d" range for consistency
      // CRITICAL: During a fresh audit run, ALWAYS fetch fresh data from GSC API
      // Only use persisted data when explicitly loading a historical audit from Supabase
      let pageTotalsByKey = new Map();
      let pageLevelDataFetched = false;
      let gscRange = null;
      
      // CRITICAL: During a fresh audit run, ALWAYS fetch fresh data from GSC API
      // Only use persisted data when loading historical audits from Supabase
      // Check global flag set by runAudit() to determine if we're in a fresh audit
      const isFreshAudit = window._isFreshAuditRun === true;
      
      // Try to load from Supabase first (preferred source)
      // CRITICAL: Use the audit's date range (28 days ending on audit end date) for consistency
      if (!isFreshAudit) {
        try {
          const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
          if (propertyUrl) {
            debugLog(` Loading page metrics from Supabase using audit date range...`, 'info');
            
            // First, get the latest audit to determine the correct date range
            let auditDateRange = null;
            if (typeof window.fetchLatestAuditFromSupabase === 'function') {
              const latestAudit = await window.fetchLatestAuditFromSupabase(propertyUrl, true); // minimalOnly=true for speed
              if (latestAudit && latestAudit.audit_date) {
                // Calculate 28-day range ending 2 days before audit date (same as audit data)
                const auditDate = new Date(latestAudit.audit_date);
                const endDate = new Date(auditDate);
                endDate.setDate(endDate.getDate() - 2); // 2 days before audit date
                endDate.setHours(0, 0, 0, 0);
                
                const startDate = new Date(endDate);
                startDate.setDate(startDate.getDate() - 27); // 27 days back = 28 days total (inclusive)
                startDate.setHours(0, 0, 0, 0);
                
                auditDateRange = {
                  startDate: startDate.toISOString().split('T')[0],
                  endDate: endDate.toISOString().split('T')[0]
                };
                debugLog(` Using audit date range: ${auditDateRange.startDate} to ${auditDateRange.endDate} (28 days ending on ${auditDateRange.endDate})`, 'info');
              }
            }
            
            // Build API URL with date range if we have it
            let apiUrlParams = `siteUrl=${encodeURIComponent(propertyUrl)}`;
            if (auditDateRange) {
              apiUrlParams += `&dateStart=${encodeURIComponent(auditDateRange.startDate)}&dateEnd=${encodeURIComponent(auditDateRange.endDate)}`;
            }
            
            const supabaseResponse = await fetch(apiUrl(`/api/supabase/get-gsc-page-metrics?${apiUrlParams}`));
            
            if (supabaseResponse.ok) {
              const supabaseData = await supabaseResponse.json();
              if (supabaseData.pages && supabaseData.pages.length > 0) {
                debugLog(` Loaded ${supabaseData.pages.length} page metrics from Supabase`, 'success');
                
                // Use the date range from the first page (all should have same range)
                const firstPage = supabaseData.pages[0];
                gscRange = {
                  startDate: firstPage.date_start,
                  endDate: firstPage.date_end
                };
                
                supabaseData.pages.forEach(page => {
                  // page.page_url is stored as full normalized URL (e.g., "https://www.alanranger.com/path")
                  // Use it directly with normalizeGscPageKey for consistency
                  const key = normalizeGscPageKey(page.page_url);
                  
                  pageTotalsByKey.set(key, {
                    url: page.page_url,
                    clicks: parseFloat(page.clicks_28d) || 0,
                    impressions: parseFloat(page.impressions_28d) || 0,
                    ctr: parseFloat(page.ctr_28d) || 0,
                    position: page.position_28d ? parseFloat(page.position_28d) : null
                  });
                });
                pageLevelDataFetched = true;
              }
            }
          }
        } catch (supabaseError) {
          debugLog(` Error loading from Supabase: ${supabaseError.message}, will try localStorage fallback`, 'warn');
        }
        
        // Fallback to localStorage if Supabase didn't have data
        if (!pageLevelDataFetched) {
          try {
            const saved = loadAuditResultsSync();
            if (saved && saved.scores) {
              // Check scores.moneyPages namespace first (new format)
              const moneyPagesData = saved.scores.moneyPages || {};
              if (moneyPagesData.gscPageTotals28d && Array.isArray(moneyPagesData.gscPageTotals28d) && moneyPagesData.gscPageTotals28d.length > 0) {
                debugLog(` Using persisted page totals from saved audit (${moneyPagesData.gscPageTotals28d.length} pages)`, 'success');
                gscRange = moneyPagesData.gscRange || getGscDateRange(28, 2);
                moneyPagesData.gscPageTotals28d.forEach(pageData => {
                  const key = normalizeGscPageKey(pageData.url);
                  const position = (pageData.position != null && pageData.position !== undefined && !isNaN(parseFloat(pageData.position)) && parseFloat(pageData.position) > 0) 
                    ? parseFloat(pageData.position) 
                    : null;
                  pageTotalsByKey.set(key, {
                    url: pageData.url,
                    clicks: pageData.clicks || 0,
                    impressions: pageData.impressions || 0,
                    ctr: pageData.ctr || 0,
                    position: position
                  });
                });
                pageLevelDataFetched = true;
              } else if (saved.scores.moneyPagesMetrics && saved.scores.moneyPagesMetrics.gscPageTotals28d && Array.isArray(saved.scores.moneyPagesMetrics.gscPageTotals28d)) {
                // Fallback: check moneyPagesMetrics directly (backwards compatibility)
                debugLog(` Using persisted page totals from moneyPagesMetrics (${saved.scores.moneyPagesMetrics.gscPageTotals28d.length} pages)`, 'success');
                gscRange = saved.scores.moneyPagesMetrics.gscRange || getGscDateRange(28, 2);
                saved.scores.moneyPagesMetrics.gscPageTotals28d.forEach(pageData => {
                  const key = normalizeGscPageKey(pageData.url);
                  const position = (pageData.position != null && pageData.position !== undefined && !isNaN(parseFloat(pageData.position)) && parseFloat(pageData.position) > 0) 
                    ? parseFloat(pageData.position) 
                    : null;
                  pageTotalsByKey.set(key, {
                    url: pageData.url,
                    clicks: pageData.clicks || 0,
                    impressions: pageData.impressions || 0,
                    ctr: pageData.ctr || 0,
                    position: position
                  });
                });
                pageLevelDataFetched = true;
              }
            }
          } catch (persistError) {
            debugLog(` Error loading persisted page totals: ${persistError.message}, will fetch fresh data`, 'warn');
          }
        }
      } else {
        debugLog(` Fresh audit run detected - will fetch fresh page-level data from GSC API`, 'info');
      }
      
      // If persisted data not available (or we're in a fresh audit), fetch from GSC API
      if (!pageLevelDataFetched) {
        try {
          const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
          
          if (propertyUrl) {
          // CRITICAL: Use the audit's date range (28 days ending 2 days before audit date) for consistency
          // This matches the date range used by the audit data and DataForSEO
          // Get the latest audit to determine the correct date range
          let auditEndDate = null;
          if (typeof window.fetchLatestAuditFromSupabase === 'function') {
            const latestAudit = await window.fetchLatestAuditFromSupabase(propertyUrl, true); // minimalOnly=true for speed
            if (latestAudit && latestAudit.audit_date) {
              const auditDate = new Date(latestAudit.audit_date);
              auditEndDate = new Date(auditDate);
              auditEndDate.setDate(auditEndDate.getDate() - 2); // 2 days before audit date
              auditEndDate.setHours(0, 0, 0, 0);
            }
          }
          
          // If we have audit end date, use it; otherwise fall back to yesterday
          const endDate = auditEndDate || (() => {
            const d = new Date();
            d.setDate(d.getDate() - 1); // Yesterday
            d.setHours(0, 0, 0, 0);
            return d;
          })();
          
          const startDate = new Date(endDate);
          startDate.setDate(startDate.getDate() - 27); // 27 days back = 28 days total (inclusive)
          startDate.setHours(0, 0, 0, 0);
          
          gscRange = {
            startDate: startDate.toISOString().split('T')[0],
            endDate: endDate.toISOString().split('T')[0]
          };
          debugLog(` Fetching page-level GSC data (unfiltered, all positions) for 28d range matching audit: ${gscRange.startDate} to ${gscRange.endDate}...`, 'info');
          
          debugLog(` Calling GSC page-level API: ${apiUrl('/api/aigeo/gsc-page-level')}`, 'info');
          debugLog(` Request body: propertyUrl=${propertyUrl}, startDate=${gscRange.startDate}, endDate=${gscRange.endDate}`, 'info');
          
          const pageLevelResponse = await fetch(apiUrl('/api/aigeo/gsc-page-level'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              propertyUrl,
              startDate: gscRange.startDate,
              endDate: gscRange.endDate,
              dimensions: ['page'],
              rowLimit: 25000
            })
          });
          
          debugLog(` GSC page-level API response status: ${pageLevelResponse.status} ${pageLevelResponse.statusText}`, 'info');
          
          if (pageLevelResponse.ok) {
            const pageLevelData = await pageLevelResponse.json();
            debugLog(` GSC page-level API response: status=${pageLevelData.status}, hasData=${!!pageLevelData.data}, rowsCount=${pageLevelData.data?.rows?.length || 0}`, 'info');
            
            if (pageLevelData.status !== 'ok') {
              debugLog(` GSC page-level API returned error status: ${JSON.stringify(pageLevelData)}`, 'warn');
            }
            
            if (pageLevelData.status === 'ok' && pageLevelData.data && Array.isArray(pageLevelData.data.rows)) {
              // Build pageTotalsByKey map from page-level data using normalized page key
              let landscapePageFound = false;
              // IMPORTANT: GSC "page" dimension can include URL variants (e.g. query params like ?srsltid=...).
              // We normalize to a canonical key, but we MUST aggregate (sum) metrics across variants rather than overwriting.
              for (const row of (pageLevelData.data.rows || [])) {
                const rawPageUrl = row.keys?.[0];
                if (!rawPageUrl) continue;

                const key = normalizeGscPageKey(rawPageUrl);
                const clicks = row.clicks || 0;
                const impressions = row.impressions || 0;
                const ctr = row.ctr != null ? (row.ctr > 1 ? row.ctr / 100 : row.ctr) : (impressions > 0 ? clicks / impressions : 0);
                // Position: use null if not provided (0 is not a valid position, positions start at 1)
                const position = (row.position != null && row.position !== undefined && !isNaN(parseFloat(row.position)) && parseFloat(row.position) > 0) 
                  ? parseFloat(row.position) 
                  : null;

                // Debug: Log specific URL if it matches the one we're looking for
                if (rawPageUrl.includes('landscape-photography-workshops') || key.includes('landscape-photography-workshops')) {
                  debugLog(` Found landscape-photography-workshops in page-level API: rawUrl=${rawPageUrl}, normalizedKey=${key}, clicks=${clicks}, impressions=${impressions}, ctr=${(ctr * 100).toFixed(2)}%, position=${position}`, 'info');
                  landscapePageFound = true;
                }

                const existing = pageTotalsByKey.get(key);
                const nextClicks = (existing?.clicks || 0) + clicks;
                const nextImpressions = (existing?.impressions || 0) + impressions;

                let posWeight = existing?._posWeight || 0;
                let posImpr = existing?._posImpr || 0;
                if (position !== null && impressions > 0) {
                  posWeight += position * impressions;
                  posImpr += impressions;
                }
                const nextPosition = posImpr > 0 ? (posWeight / posImpr) : null;
                const nextCtr = nextImpressions > 0 ? (nextClicks / nextImpressions) : 0;

                pageTotalsByKey.set(key, {
                  url: existing?.url || rawPageUrl,
                  clicks: nextClicks,
                  impressions: nextImpressions,
                  ctr: nextCtr, // Store as ratio (0-1)
                  position: nextPosition,
                  _posWeight: posWeight,
                  _posImpr: posImpr
                });
              }
              
              if (!landscapePageFound) {
                debugLog(` landscape-photography-workshops NOT found in page-level API response. Total pages fetched: ${pageLevelData.data.rows?.length || 0}`, 'warn');
                // Log first 5 URLs for debugging
                const sampleUrls = (pageLevelData.data.rows || []).slice(0, 5).map(r => r.keys?.[0] || 'N/A');
                debugLog(` Sample URLs from API: ${sampleUrls.join(', ')}`, 'info');
              }
              
              // Count pages with valid position data
              let pagesWithPosition = 0;
              let totalPositionSum = 0;
              pageTotalsByKey.forEach((metrics, key) => {
                if (metrics.position !== null && metrics.position !== undefined && !isNaN(metrics.position) && metrics.position > 0) {
                  pagesWithPosition++;
                  totalPositionSum += metrics.position;
                }
              });
              const avgPosition = pagesWithPosition > 0 ? (totalPositionSum / pagesWithPosition).toFixed(2) : 'N/A';
              debugLog(` Built pageTotalsByKey from GSC page-level API: ${pageTotalsByKey.size} pages (${pagesWithPosition} with position data, avg=${avgPosition})`, 'success');
              
              // Save to Supabase for persistence
              // This will be called after audit is saved, using the audit_date as run_id
              // Store the data temporarily for later saving
              window._pendingPageMetrics = {
                pages: Array.from(pageTotalsByKey.values()).map(metrics => ({
                  url: metrics.url,
                  page_url: metrics.url, // Will be normalized in API
                  clicks: metrics.clicks,
                  impressions: metrics.impressions,
                  ctr: metrics.ctr,
                  position: metrics.position // Can be null if not available
                })),
                gscRange: gscRange,
                propertyUrl: propertyUrl
              };
              const pagesWithPositionInPending = window._pendingPageMetrics.pages.filter(p => p.position !== null && p.position !== undefined && !isNaN(p.position) && p.position > 0).length;
              debugLog(` Prepared ${window._pendingPageMetrics.pages.length} page metrics for Supabase save (${pagesWithPositionInPending} with position data, will save after audit completes)`, 'info');
              
              pageLevelDataFetched = true;
            } else if (pageLevelData.status === 'ok' && pageLevelData.data && Array.isArray(pageLevelData.data.pages)) {
              // Fallback: handle old API response format
              pageLevelData.data.pages.forEach(page => {
                const rawPageUrl = page.page || page.url || '';
                if (!rawPageUrl) return;

                const key = normalizeGscPageKey(rawPageUrl);
                const clicks = page.clicks || 0;
                const impressions = page.impressions || 0;
                const ctr = page.ctr != null ? (page.ctr > 1 ? page.ctr / 100 : page.ctr) : (impressions > 0 ? clicks / impressions : 0);
                // Position: use null if not provided (0 is not a valid position, positions start at 1)
                const rawPosition = page.position || page.avgPosition;
                const position = (rawPosition != null && rawPosition !== undefined && !isNaN(parseFloat(rawPosition)) && parseFloat(rawPosition) > 0) 
                  ? parseFloat(rawPosition) 
                  : null;

                pageTotalsByKey.set(key, {
                  url: rawPageUrl,
                  clicks: clicks,
                  impressions: impressions,
                  ctr: ctr,
                  position: position
                });
              });
              
              debugLog(` Built pageTotalsByKey from GSC page-level API (legacy format): ${pageTotalsByKey.size} pages`, 'success');
              pageLevelDataFetched = true;
            } else {
              debugLog(` GSC page-level API did not return page data in expected format. Response structure: ${JSON.stringify(Object.keys(pageLevelData.data || {}))}`, 'error');
              debugLog(` CRITICAL: Cannot use queryPages fallback for Money Pages - it's filtered to position 1-20 and will show incorrect totals!`, 'error');
            }
          } else {
            const errorText = await pageLevelResponse.text().catch(() => 'Unknown error');
            debugLog(` Failed to fetch page-level data from GSC API (${pageLevelResponse.status}): ${errorText}`, 'error');
            debugLog(` CRITICAL: Cannot use queryPages fallback for Money Pages - it's filtered to position 1-20 and will show incorrect totals!`, 'error');
          }
          } else {
            debugLog(` No property URL available, cannot fetch page-level GSC data`, 'warn');
          }
        } catch (pageLevelError) {
          debugLog(` Error fetching page-level GSC data: ${pageLevelError.message}`, 'error');
          debugLog(` CRITICAL: Cannot use queryPages fallback for Money Pages - it's filtered to position 1-20 and will show incorrect totals!`, 'error');
        }
      }
      
      // CRITICAL: Do NOT fall back to queryPages aggregation for Money Pages
      // queryPages is filtered to position 1-20 and will give incorrect page totals
      // If page-level API failed, we must log an error and use empty data rather than wrong data
      if (!pageLevelDataFetched) {
        debugLog(` CRITICAL: Page-level GSC data not available. Money Pages metrics will be incomplete.`, 'error');
        debugLog(` This means the /api/aigeo/gsc-page-level API either failed or returned no data.`, 'error');
        debugLog(` Money Pages will show zero/incorrect metrics until page-level data is available.`, 'error');
        debugLog(` Check Vercel function logs for /api/aigeo/gsc-page-level to diagnose the issue.`, 'error');
      }
      
      // REMOVED: Fallback to queryPages aggregation (this was causing incorrect data)
      // The old fallback code has been removed to prevent showing filtered (position 1-20) data as page totals
      
      // Store pageTotalsByKey globally for use in Money Pages and other modules
      window.pageTotalsByKey = pageTotalsByKey;
      // Also store as pageTotalsByUrl for backwards compatibility
      window.pageTotalsByUrl = pageTotalsByKey;
      
      // Compute money pages metrics if we have queryPages data
      let moneyPagesMetrics = null;
      if (queryPages && queryPages.length > 0) {
          // Aggregate all pages from queryPages (not just top 10) - KEEP for secondary analytics only (pos 1-20 filtered, not used for Money Pages totals)
        const pageMap = new Map();
        queryPages.forEach(row => {
          const url = row.page || row.url || '';
          if (!url) return;
          
          if (!pageMap.has(url)) {
            pageMap.set(url, {
              url: url,
              clicks: 0,
              impressions: 0,
              totalPositionWeight: 0
            });
          }
          
          const page = pageMap.get(url);
          page.clicks += row.clicks || 0;
          page.impressions += row.impressions || 0;
          page.totalPositionWeight += (row.position || 0) * (row.impressions || 0);
        });
        
          // Convert to topPages format (for secondary analytics only - pos 1-20 filtered, not used for Money Pages totals)
        const allTopPages = Array.from(pageMap.values())
          .map(page => ({
            url: page.url,
            clicks: page.clicks,
            impressions: page.impressions,
            ctr: page.impressions > 0 ? (page.clicks / page.impressions) : 0,
            avgPosition: page.impressions > 0 ? page.totalPositionWeight / page.impressions : 0,
            position: page.impressions > 0 ? page.totalPositionWeight / page.impressions : 0,
            _source: 'queryPages_pos1_20' // Flag to indicate this is filtered data
          }))
          .filter(page => page.impressions > 0); // Only pages with impressions
        
        // Compute site aggregates
        const siteAgg = computeSiteAggregateFromTopPages(allTopPages);
        
        // Build page metadata lookup from schema audit if available
        const pageMetadataLookup = new Map();
        if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
          const schemaData = schemaAudit.data;
          // Use the new pages array with metadata (title, metaDescription)
          if (schemaData.pages && Array.isArray(schemaData.pages)) {
            schemaData.pages.forEach(page => {
              if (page.url) {
                pageMetadataLookup.set(page.url, {
                  title: page.title || null,
                  metaDescription: page.metaDescription || null
                });
              }
            });
          }
          // Fallback to old structure for backwards compatibility
          if (schemaData.pagesWithSchema && Array.isArray(schemaData.pagesWithSchema) && pageMetadataLookup.size === 0) {
            schemaData.pagesWithSchema.forEach(page => {
              if (page.url) {
                pageMetadataLookup.set(page.url, {
                  title: page.title || null,
                  metaDescription: page.metaDescription || page.description || null
                });
              }
            });
          }
          // Also check missing pages (fallback)
          if (schemaData.missingSchemaPages && Array.isArray(schemaData.missingSchemaPages)) {
            schemaData.missingSchemaPages.forEach(page => {
              const url = typeof page === 'string' ? page : page.url;
              if (url && !pageMetadataLookup.has(url)) {
                pageMetadataLookup.set(url, {
                  title: typeof page === 'object' ? (page.title || null) : null,
                  metaDescription: typeof page === 'object' ? (page.metaDescription || page.description || null) : null
                });
              }
            });
          }
        }
        
        // ============================================
        // STEP 2: Update Money Pages to use pageTotalsByUrl (page-level totals, not filtered)
        // ============================================
        // Compute money pages metrics
        // Use CSV as source of truth for all pages, then match GSC page-level data to CSV URLs
        // This ensures we segment ALL pages (433 URLs) not just those in GSC data (78 pages)
          // Use page-level totals (unfiltered, all positions) from pageTotalsByKey to match GSC "Pages" tab exactly
        
        // Fetch CSV and segment all URLs
        // First check for manually loaded URL list, then try GitHub/fallback
        let csvUrls = [];
        try {
          // Check for manually loaded URL list first
          const manualUrlList = localStorage.getItem('manual_url_list');
          if (manualUrlList) {
            try {
              csvUrls = JSON.parse(manualUrlList);
              debugLog(` Using manual URL list: ${csvUrls.length} URLs`, 'info');
            } catch (parseErr) {
              debugLog(` Failed to parse manual URL list: ${parseErr.message}`, 'warn');
            }
          }
          
          // If no manual list, try fetching from GitHub/fallback
          if (csvUrls.length === 0) {
            csvUrls = await fetchAndParseSiteUrlsCsv();
            debugLog(` Fetched ${csvUrls.length} URLs from CSV (GitHub/fallback)`, 'info');
          }
          
          // Debug: Check if landscape page is in CSV
          const landscapeInCsv = csvUrls.find(u => u.includes('landscape-photography-workshops'));
          if (landscapeInCsv) {
            debugLog(` Landscape page found in CSV: "${landscapeInCsv}"`, 'info');
          } else {
            debugLog(` Landscape page NOT found in CSV! Total CSV URLs: ${csvUrls.length}`, 'warn');
            // Log sample CSV URLs for debugging
            const sampleCsvUrls = csvUrls.slice(0, 10);
            debugLog(` Sample CSV URLs: ${sampleCsvUrls.join(', ')}`, 'info');
          }
          
          // Segment all CSV URLs and match with pageTotalsByKey (page-level totals)
          const allCsvPages = csvUrls.map(url => {
            const segment = classifyPageSegment(url);
            const pageKey = normalizeGscPageKey(url);
            
            // Get page-level totals from pageTotalsByKey (unfiltered, matches GSC page totals)
            const gscMetrics = pageTotalsByKey.get(pageKey) || {
              clicks: 0,
              impressions: 0,
              ctr: 0,
              position: 0
            };
            
            // Debug: Log if this is the URL we're looking for
            if (url.includes('landscape-photography-workshops') || pageKey.includes('landscape-photography-workshops')) {
              debugLog(` Money Pages CSV lookup: csvUrl=${url}, normalizedKey=${pageKey}, found=${pageTotalsByKey.has(pageKey)}, clicks=${gscMetrics.clicks}, impressions=${gscMetrics.impressions}, ctr=${(gscMetrics.ctr * 100).toFixed(2)}%, position=${gscMetrics.position}`, 'info');
              debugLog(` CSV URL format: "${url}", normalized to: "${pageKey}"`, 'info');
              
              // Also log all keys in pageTotalsByKey that contain 'landscape' for debugging
              const matchingKeys = Array.from(pageTotalsByKey.keys()).filter(k => k.includes('landscape') || k.includes('workshop'));
              if (matchingKeys.length > 0) {
                debugLog(` Available keys containing 'landscape' or 'workshop': ${matchingKeys.join(', ')}`, 'info');
                // Also log the actual data for these keys
                matchingKeys.forEach(k => {
                  const data = pageTotalsByKey.get(k);
                  if (data) {
                    debugLog(` Key "${k}": clicks=${data.clicks}, impressions=${data.impressions}, ctr=${(data.ctr * 100).toFixed(2)}%, position=${data.position}, rawUrl=${data.url}`, 'info');
                  }
                });
              } else {
                debugLog(` No keys found containing 'landscape' or 'workshop'. Total keys in pageTotalsByKey: ${pageTotalsByKey.size}`, 'warn');
                // Log first 20 keys for debugging
                const firstKeys = Array.from(pageTotalsByKey.keys()).slice(0, 20);
                debugLog(` First 20 keys in pageTotalsByKey: ${firstKeys.join(', ')}`, 'info');
              }
            }
            
            if (gscMetrics.impressions > 0 || gscMetrics.clicks > 0) {
              // Use page-level totals (matches GSC "Pages" tab exactly)
              return {
                url: url,
                page: url, // Also set page property for compatibility
                segment: segment,
                clicks: gscMetrics.clicks || 0,
                impressions: gscMetrics.impressions || 0,
                ctr: gscMetrics.ctr || 0, // Already a ratio (0-1)
                avgPosition: gscMetrics.position || null,
                position: gscMetrics.position || null,
                _source: 'pageTotalsByKey' // Flag to indicate this is from page-level data
              };
            } else {
              // No GSC data for this URL (zero impressions or never appeared in search)
              return {
                url: url,
                page: url, // Also set page property for compatibility
                segment: segment,
                clicks: 0,
                impressions: 0,
                ctr: 0,
                avgPosition: null,
                position: null,
                _source: 'no_data'
              };
            }
          });
          
          // Filter to money pages only and compute metrics
          const moneyPagesFromCsv = allCsvPages.filter(page => page.segment === PageSegment.MONEY);
          debugLog(` Segmented ${moneyPagesFromCsv.length} money pages from CSV (out of ${csvUrls.length} total URLs)`, 'info');
          debugLog(` Using pageTotalsByUrl for Money Pages metrics (matches GSC page-level totals)`, 'success');
          
          // Recompute site aggregates from pageTotalsByKey (all pages, not just money pages)
          let siteAggFromPageTotals = { totalClicks: 0, totalImpressions: 0, avgCtr: 0, avgPosition: null };
          let totalPositionWeight = 0;
          pageTotalsByKey.forEach(gscMetrics => {
            siteAggFromPageTotals.totalClicks += gscMetrics.clicks || 0;
            siteAggFromPageTotals.totalImpressions += gscMetrics.impressions || 0;
            if (gscMetrics.position != null && gscMetrics.impressions > 0) {
              totalPositionWeight += gscMetrics.position * gscMetrics.impressions;
            }
          });
          siteAggFromPageTotals.avgCtr = siteAggFromPageTotals.totalImpressions > 0 
            ? siteAggFromPageTotals.totalClicks / siteAggFromPageTotals.totalImpressions 
            : 0;
          siteAggFromPageTotals.avgPosition = siteAggFromPageTotals.totalImpressions > 0
            ? totalPositionWeight / siteAggFromPageTotals.totalImpressions
            : null;
          
          moneyPagesMetrics = computeMoneyPagesMetrics(
            moneyPagesFromCsv, // Use CSV URLs with page-level GSC data from pageTotalsByUrl
            classifyPageSegment,
            siteAggFromPageTotals, // Use site aggregates from page-level data
            pageMetadataLookup, // Pass metadata lookup
            schemaAudit // Pass schema audit data to check for schema presence
          );
        } catch (csvError) {
          debugLog(` Failed to fetch CSV, falling back to pageTotalsByKey only: ${csvError.message}`, 'warn');
          // Fallback: Build pages from pageTotalsByKey directly (no CSV)
          const pagesFromPageTotals = Array.from(pageTotalsByKey.entries()).map(([pageKey, gscMetrics]) => {
            // Use the stored URL from gscMetrics, or reconstruct from pageKey
            let fullUrl = gscMetrics.url || pageKey;
            if (!fullUrl.startsWith('http')) {
              const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || 'https://www.alanranger.com';
              fullUrl = propertyUrl.replace(/\/$/, '') + (pageKey.startsWith('/') ? pageKey : '/' + pageKey);
            }
            
            return {
              url: fullUrl,
              page: fullUrl,
              segment: classifyPageSegment(fullUrl),
              clicks: gscMetrics.clicks || 0,
              impressions: gscMetrics.impressions || 0,
              ctr: gscMetrics.ctr || 0,
              avgPosition: gscMetrics.position || null,
              position: gscMetrics.position || null,
              _source: 'pageTotalsByKey_fallback'
            };
          }).filter(page => page.segment === PageSegment.MONEY);
          
          // Recompute site aggregates from pageTotalsByKey
          let siteAggFromPageTotals = { totalClicks: 0, totalImpressions: 0, avgCtr: 0, avgPosition: null };
          let totalPositionWeight = 0;
          pageTotalsByKey.forEach(gscMetrics => {
            siteAggFromPageTotals.totalClicks += gscMetrics.clicks || 0;
            siteAggFromPageTotals.totalImpressions += gscMetrics.impressions || 0;
            if (gscMetrics.position != null && gscMetrics.impressions > 0) {
              totalPositionWeight += gscMetrics.position * gscMetrics.impressions;
            }
          });
          siteAggFromPageTotals.avgCtr = siteAggFromPageTotals.totalImpressions > 0 
            ? siteAggFromPageTotals.totalClicks / siteAggFromPageTotals.totalImpressions 
            : 0;
          siteAggFromPageTotals.avgPosition = siteAggFromPageTotals.totalImpressions > 0
            ? totalPositionWeight / siteAggFromPageTotals.totalImpressions
            : null;
          
          moneyPagesMetrics = computeMoneyPagesMetrics(
            pagesFromPageTotals,
            classifyPageSegment,
            siteAggFromPageTotals,
            pageMetadataLookup,
            schemaAudit
          );
        }
        
        // Compute money pages behaviour score
        const moneyPagesList = moneyPagesMetrics.rows || [];
        // Use queryPages for behaviour calculation (all GSC query+page data)
        const allGSCPages = queryPages || [];
        const moneyBehaviour = window.computeMoneyPagesBehaviour(
          allGSCPages, // Use all GSC pages for behaviour calculation
          moneyPagesList
        );
        moneyPagesMetrics.behaviour = moneyBehaviour;
        
        // Add page-level GSC totals (filtered to money pages) for persistence
        // This ensures Money Pages metrics remain consistent when loading from history
        const moneyPagesGscTotals28d = moneyPagesList.map(mp => {
          const k = normalizeGscPageKey(mp.url);
          const m = pageTotalsByKey.get(k);
          
          // Debug: Log if this is the landscape page
          if (mp.url.includes('landscape-photography-workshops') || k.includes('landscape-photography-workshops')) {
            debugLog(` Saving landscape page to DB: mp.url=${mp.url}, normalizedKey=${k}, foundInPageTotals=${!!m}, clicks=${m?.clicks ?? 0}, impressions=${m?.impressions ?? 0}, ctr=${m?.ctr ? (m.ctr * 100).toFixed(2) : 0}%, position=${m?.position ?? 0}`, 'info');
            if (!m) {
              debugLog(` landscape page NOT found in pageTotalsByKey! Total keys: ${pageTotalsByKey.size}`, 'warn');
              // Log similar keys
              const similarKeys = Array.from(pageTotalsByKey.keys()).filter(key => key.includes('landscape') || key.includes('workshop'));
              if (similarKeys.length > 0) {
                debugLog(` Similar keys in pageTotalsByKey: ${similarKeys.join(', ')}`, 'info');
              }
            }
          }
          
          return {
            url: mp.url,
            clicks: m?.clicks ?? 0,
            impressions: m?.impressions ?? 0,
            ctr: m?.ctr ?? 0,
            position: m?.position ?? 0
          };
        });
        
        // Store GSC range and page totals in moneyPagesMetrics for persistence
        moneyPagesMetrics.gscRange = gscRange || getGscDateRange(28, 2);
        moneyPagesMetrics.gscPageTotals28d = moneyPagesGscTotals28d;
        
        debugLog(`Money Pages Metrics: ${moneyPagesMetrics.rows.length} money pages found, ${moneyPagesMetrics.overview.moneyClicks} clicks, ${moneyPagesMetrics.overview.moneyImpressions} impressions`, 'info');
        if (moneyBehaviour) {
          debugLog(`Money Pages Behaviour: score=${moneyBehaviour.score != null ? moneyBehaviour.score.toFixed(1) : 'N/A'}, CTR=${moneyBehaviour.siteCtr != null ? (moneyBehaviour.siteCtr * 100).toFixed(2) : 'N/A'}%, Top-10 CTR=${moneyBehaviour.top10Ctr != null ? (moneyBehaviour.top10Ctr * 100).toFixed(2) : 'N/A'}%`, 'info');
        }
        
        // Build Money Page Priority Matrix data
        // Convert moneyPagesMetrics.rows to format expected by buildMoneyPageMetrics
        const topPagesForPriority = moneyPagesMetrics.rows.map(row => ({
          page: row.url,
          url: row.url,
          clicks: row.clicks || 0,
          impressions: row.impressions || 0,
          // row.ctr is already a ratio (0-1). buildMoneyPageMetrics can accept either ratio or percent,
          // but passing percent here caused CTRs to be treated as ratios and display ~100x too high.
          ctr: (row.ctr || 0),
          position: row.avgPosition || 0,
          avgPosition: row.avgPosition || 0,
          title: row.title || row.url
        }));
        
        // Store priority matrix data globally
        window.moneyPagePriorityData = buildMoneyPageMetrics(topPagesForPriority, schemaAudit);
        debugLog(`Money Pages Priority: Built ${window.moneyPagePriorityData.length} priority entries`, 'info');
        
        // Build segment summary for Supabase storage
        // CRITICAL: Use moneyPagesMetrics.rows (has clicks/impressions/avgPosition/segmentType) not moneyPagePriorityData
        const behaviourScoresBySegment = {};
        if (moneyBehaviour && moneyBehaviour.bySegment) {
          behaviourScoresBySegment.allMoney = moneyBehaviour.bySegment.money?.behaviour?.score || 0;
          behaviourScoresBySegment.landingPages = 0; // Will be calculated per segment if needed
          behaviourScoresBySegment.eventPages = 0;
          behaviourScoresBySegment.productPages = 0;
        }
        // Build segment metrics from moneyPagesMetrics.rows (has the actual GSC data)
        // Map subSegment (PRODUCT/EVENT/LANDING) to segmentType (product/event/landing)
        const moneyPagesForSegments = (moneyPagesMetrics?.rows || []).map(row => {
          const subSegment = row.subSegment || 'LANDING';
          let segmentType = 'landing'; // Default
          if (subSegment === 'PRODUCT') segmentType = 'product';
          else if (subSegment === 'EVENT') segmentType = 'event';
          else if (subSegment === 'LANDING') segmentType = 'landing';
          
          return {
            clicks: row.clicks || 0,
            impressions: row.impressions || 0,
            ctr: row.ctr || 0,
            avgPosition: row.avgPosition || 0,
            segmentType: segmentType
          };
        });
        window.moneySegmentMetrics = buildMoneySegmentSummary(moneyPagesForSegments, behaviourScoresBySegment);
        debugLog(`Money Pages Segments: Built segment summary from ${moneyPagesForSegments.length} pages`, 'info');
        debugLog(`Money Pages Segments: allMoney clicks=${window.moneySegmentMetrics.allMoney.clicks}, impressions=${window.moneySegmentMetrics.allMoney.impressions}`, 'info');
      } else {
        debugLog(' Money Pages Metrics: No queryPages data available - building empty structure', 'warn');
        window.moneyPagePriorityData = [];
        // Always build empty segment metrics structure (never null) so it can be saved to Supabase
        window.moneySegmentMetrics = buildMoneySegmentSummary([], {});
        debugLog(`Money Pages Segments: Built empty segment summary (no data available) - allMoney clicks=${window.moneySegmentMetrics.allMoney.clicks}, impressions=${window.moneySegmentMetrics.allMoney.impressions}`, 'info');
      }
      
      // Ensure moneySegmentMetrics is never null (always a valid structure)
      if (!window.moneySegmentMetrics) {
        debugLog(' Money Pages Segments: moneySegmentMetrics was null, building empty structure', 'warn');
        window.moneySegmentMetrics = buildMoneySegmentSummary([], {});
      }

      const scores = {
        localEntity,
        serviceArea,
        authority: {
          score: authority, // Main score (default: all pages)
          bySegment: authorityBySegment, // Per-segment Authority scores (if available)
          // CRITICAL: Store segmented scores so Authority tab can access them
          behaviourScoresSegmented: behaviourScoresSegmented,
          rankingScoresSegmented: rankingScoresSegmented
        },
        visibility,
        contentSchema,
        // Authority component scores for historical tracking (backward compatible)
        authorityComponents: authorityComponents,
        // GAIO health components (extracted from contentSchema)
        coverage: coverageScore,
        diversity: diversityScore,
        // Phase 1: Brand overlay (overlay only, not weighted in GAIO score)
        brandOverlay: brandOverlay,
        // Money Pages Performance metrics (overlay only, not weighted in GAIO score)
        // Always include moneyPagesMetrics, even if null (ensures it's saved to Supabase)
        moneyPagesMetrics: moneyPagesMetrics || null
      };
      
      // Store moneyPagesMetrics globally for saveAuditToSupabase to access
      if (moneyPagesMetrics) {
        window.moneyPagesMetrics = moneyPagesMetrics;
        debugLog(` Stored moneyPagesMetrics globally: ${moneyPagesMetrics.rows?.length || 0} rows`, 'info');
      } else {
        debugLog(` moneyPagesMetrics is null - will be saved as null to Supabase`, 'warn');
      }

      debugLog(`Deterministic pillar scores: ${JSON.stringify(scores)}`, 'info');
      return scores;
    }
    
    // Calculate GAIO Health Score
    // IMPORTANT: GAIO score uses ONLY the 5 pillars - brandOverlay and aiSummary are overlay metrics only
    function calculateAiGeoScore(scores, schemaAudit = null, snippetReadiness = null) {
      // GAIO weights - ONLY the 5 pillars
      const AIGEO_WEIGHTS = {
        authority: 0.30,
        content: 0.25,
        visibility: 0.20,
        localEntity: 0.15,
        serviceArea: 0.10
      };
      
      // Extract scores from the 5 pillars ONLY
      const authorityScore = (typeof scores.authority === 'object' && scores.authority !== null) 
        ? scores.authority.score 
        : scores.authority || 0;
      const contentScore = scores.contentSchema || 0;
      const visibilityScore = scores.visibility || 0;
      const localEntityScore = scores.localEntity || 0;
      const serviceAreaScore = scores.serviceArea || 0;
      
      // Calculate weighted score using ONLY the 5 pillars
      const aiGeoScore = Math.round(
        authorityScore * AIGEO_WEIGHTS.authority +
        contentScore * AIGEO_WEIGHTS.content +
        visibilityScore * AIGEO_WEIGHTS.visibility +
        localEntityScore * AIGEO_WEIGHTS.localEntity +
        serviceAreaScore * AIGEO_WEIGHTS.serviceArea
      );
      
      // Phase 1: Calculate AI Summary Likelihood using new method (overlay only, not part of GAIO score)
      // Handle both number format (legacy) and object format (if it exists)
      let snippetReadinessScore = typeof snippetReadiness === 'number' 
        ? snippetReadiness 
        : (snippetReadiness?.overallScore || 0);
      
      // CRITICAL FIX: If snippetReadiness is 0 but we have scores, recalculate it
      // This fixes the issue where snippet readiness shows 0/100 but AI summary shows 80
      // FIXED v2: Ensure we never reference undefined 'data' variable - always pass empty object
      if (snippetReadinessScore === 0 && scores && typeof calculateSnippetReadiness === 'function') {
        try {
          // Explicitly pass empty object - never reference 'data' variable
          const emptyDataObject = {};
          snippetReadinessScore = calculateSnippetReadiness(scores, emptyDataObject);
          debugLog(`[calculateAiGeoScore] Recalculated snippetReadiness from scores: ${snippetReadinessScore} (was 0)`, 'info');
        } catch (e) {
          debugLog(`[calculateAiGeoScore] Error recalculating snippetReadiness: ${e.message}`, 'error');
          // Fallback: use 0 if calculation fails
          snippetReadinessScore = 0;
        }
      }
      
      const brandScore = scores.brandOverlay?.score || 0;
      
      // Use new computeAiSummaryLikelihood if we have snippet readiness data (brandScore can be 0)
      let aiSummary;
      if (snippetReadinessScore > 0) {
        aiSummary = computeAiSummaryLikelihood(snippetReadinessScore, visibilityScore, brandScore);
      } else {
        // Fallback to old method for backward compatibility
        aiSummary = {
          label: calculateAiSummaryLikelihood({
            aiGeoScore,
            authority: authorityScore,
            content: contentScore,
            coverage: 0 // Not used in new calculation
          }),
          score: aiGeoScore, // Use aiGeoScore as fallback
          reasons: []
        };
      }
      
      return {
        aiGeoScore, // Calculated from 5 pillars ONLY
        aiGeoStatus: aiGeoScore >= 70 ? 'green' : aiGeoScore >= 50 ? 'amber' : 'red',
        aiSummaryLikelihood: aiSummary.label, // Keep backward compatibility
        aiSummary: aiSummary // New Phase 1 field (overlay only)
      };
    }
    
    // Calculate AI Summary Likelihood (OLD - kept for backward compatibility, but will be replaced)
    // NOTE: This is being replaced by computeAiSummaryLikelihood which uses snippetReadiness, visibility, and brand
    function calculateAiSummaryLikelihood({ aiGeoScore, authority, content, coverage }) {
      const strongAuthority = authority >= 65;
      const strongContent = content >= 70;
      const strongCoverage = coverage >= 80;
      
      if (aiGeoScore >= 75 && strongAuthority && strongContent && strongCoverage) {
        return 'high';
      }
      if (aiGeoScore >= 55) {
        return 'medium';
      }
      return 'low';
    }

    function calculateSnippetReadiness(scores, data) {
      // Snippet readiness combines:
      // 1. Content/Schema score (structured data quality)
      // 2. Visibility score (SERP feature presence)
      // 3. Authority score (content depth and trust)
      // Weighted average: 40% Content/Schema, 35% Visibility, 25% Authority
      // Handle both old format (number) and new format (object with score)
      const authorityScore = typeof scores.authority === 'object' ? scores.authority.score : scores.authority;
      const readiness = (
        scores.contentSchema * 0.4 +
        scores.visibility * 0.35 +
        authorityScore * 0.25
      );
      return Math.round(Math.min(100, Math.max(0, readiness)));
    }

    // Fetch real data from Google Search Console API using unified endpoint
    // Note: apiKey parameter kept for compatibility but not used (endpoint uses OAuth2)
    async function fetchSearchConsoleData(apiKey, propertyUrl, days) {
      debugLog(`Fetching real GSC data for ${days} days...`, 'info');
      
      // Calculate date range
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);
      
      // Format dates as YYYY-MM-DD
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      const startDateStr = formatDate(startDate);
      const endDateStr = formatDate(endDate);
      
      debugLog(`Date range: ${startDateStr} to ${endDateStr}`, 'info');
      
      try {
        // Get tracked keywords for queryTotals fetching
        const trackedKeywords = window.RankingAiModule?.TRACKED_KEYWORDS || [];
        const keywordsParam = trackedKeywords.length > 0 
          ? `&keywords=${encodeURIComponent(JSON.stringify(trackedKeywords))}`
          : '';
        
        // Call unified GSC entity metrics endpoint
        const response = await fetch(apiUrl(`/api/aigeo/gsc-entity-metrics?property=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDateStr}${keywordsParam}`));

        if (!response.ok) {
          // Try to parse as JSON, but handle non-JSON error responses
          let errorData = null;
          const contentType = response.headers.get('content-type') || '';
          try {
            if (contentType.includes('application/json')) {
              errorData = await response.json();
            } else {
              // Response is not JSON (likely HTML error page)
              const errorText = await response.text();
              debugLog(` GSC API returned non-JSON error (HTTP ${response.status}): ${errorText.substring(0, 200)}`, 'error');
              throw new Error(`Server error (HTTP ${response.status}): ${errorText.substring(0, 100)}...`);
            }
          } catch (parseError) {
            // If JSON parsing fails, use the parse error or create a generic error
            if (parseError.message && !parseError.message.includes('Server error')) {
              debugLog(` Failed to parse error response: ${parseError.message}`, 'error');
              throw new Error(`Server error (HTTP ${response.status}): Unable to parse error response. The API may be experiencing issues.`);
            }
            throw parseError;
          }
          
          debugLog(` GSC API error: ${errorData.message || errorData.error}`, 'error');
          if (errorData.details) {
            debugLog(`Details: ${errorData.details}`, 'error');
          }
          
          // If OAuth not configured, show helpful message
          if (errorData.message && errorData.message.includes('OAuth2 credentials not configured')) {
            throw new Error('Google Search Console OAuth2 credentials not configured. Please set GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, and GOOGLE_REFRESH_TOKEN in Vercel environment variables.');
          }
          
          throw new Error(errorData.message || errorData.error || 'Failed to fetch Search Console data');
        }

        const gsc = await response.json();
        
        if (gsc.status !== 'ok') {
          throw new Error(gsc.message || 'Failed to fetch Search Console data');
        }
        
        debugLog(` Real GSC data fetched: ${gsc.data.overview.totalClicks} clicks, ${gsc.data.overview.totalImpressions} impressions`, 'success');
        
        // Log segmentation data availability
        if (gsc.data.queryPages && gsc.data.queryPages.length > 0) {
          debugLog(` GSC API returned ${gsc.data.queryPages.length} query+page combinations for segmentation`, 'success');
        } else {
          debugLog(' GSC API did not return queryPages data. Segmentation will use fallback calculation.', 'warn');
        }
        
        // Log queryTotals availability
        if (gsc.data.queryTotals && gsc.data.queryTotals.length > 0) {
          debugLog(` GSC API returned ${gsc.data.queryTotals.length} query-only totals for tracked keywords`, 'success');
        } else {
          debugLog(' GSC API did not return queryTotals data. Table will show  for missing keywords.', 'warn');
        }
        
        // Return data in format expected by existing code
        const searchData = {
          totalClicks: gsc.data.overview.totalClicks || 0,
          totalImpressions: gsc.data.overview.totalImpressions || 0,
          averagePosition: gsc.data.overview.avgPosition || 0,
          ctr: gsc.data.overview.ctr || 0, // Already 0-100 from API
          topQueries: gsc.data.topQueries || [],
          queryPages: gsc.data.queryPages || [], // Query+page combinations for segmentation
          queryTotals: gsc.data.queryTotals || [], // Query-only totals for tracked keywords (for table)
          timeseries: gsc.data.timeseries || [], // For trend chart
          dateRange: days,
          // Store full GSC response for trend chart access
          _gscResponse: gsc,
          // Create overview object with siteTotalImpressions and siteTotalClicks for buildMoneyPagesSummary
          overview: {
            siteTotalImpressions: gsc.data.overview.totalImpressions || 0,
            siteTotalClicks: gsc.data.overview.totalClicks || 0,
            totalImpressions: gsc.data.overview.totalImpressions || 0,
            totalClicks: gsc.data.overview.totalClicks || 0
          }
        };
        return searchData;
      } catch (error) {
        debugLog(` Error fetching GSC data: ${error.message}`, 'error');
        throw error;
      }
    }

    // Run the audit
    async function runAudit() {
      // CRITICAL: Set flag to indicate we're in a fresh audit run
      // This ensures page-level GSC data is always fetched fresh, not from stale localStorage
      window._isFreshAuditRun = true;
      debugLog('=== AUDIT START: Beginning audit scan ===', 'info');
      
      // Get API key - prioritize Vercel env var, then loaded key, then localStorage
      let apiKey = window._loadedApiKey;
      
      // Try Vercel environment variable first
      if (!apiKey) {
        try {
          debugLog('Fetching API key from Vercel environment variable...', 'info');
          const response = await fetch(apiUrl('/api/get-api-key'));
          if (response.ok) {
            const data = await response.json();
            if (data.apiKey) {
              apiKey = data.apiKey;
              debugLog(' Using API key from Vercel environment variable', 'success');
              window._loadedApiKey = apiKey;
            }
          }
        } catch (e) {
          debugLog('Vercel env var endpoint not available', 'info');
        }
      }
      
      // Fall back to config.js
      if (!apiKey && window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey) {
        apiKey = window.API_CONFIG.googleSearchConsoleApiKey;
        debugLog(' Using API key from config.js', 'success');
        window._loadedApiKey = apiKey;
      }
      
      // Fall back to localStorage
      if (!apiKey) {
        apiKey = localStorage.getItem('gsc_api_key');
        if (apiKey) {
          debugLog(' Using API key from localStorage', 'success');
          window._loadedApiKey = apiKey;
        }
      }
      
      const propertyUrl = document.getElementById('propertyUrl').value;
      const dateRange = parseInt(document.getElementById('dateRange').value);
      
      debugLog(`Property URL: ${propertyUrl}`, 'info');
      debugLog(`Date Range: ${dateRange} days`, 'info');

      // Note: API key no longer required - new endpoint uses OAuth2 from env vars
      if (!propertyUrl) {
        debugLog(' No property URL provided', 'error');
        showStatus('Please enter your property URL', 'error');
        return;
      }

      debugLog('Showing loading indicator...', 'info');
      document.getElementById('loading').classList.add('show');
      document.getElementById('dashboard').style.display = 'none';
      updateProgress(0, 'Initializing audit scan...');

      // Load saved audit data first to use as defaults (preserve data when sources unavailable)
      let savedAudit = null;
      try {
        const saved = localStorage.getItem('last_audit_results');
        if (saved) {
          savedAudit = JSON.parse(saved);
          debugLog(' Loaded previous audit data for fallback', 'info');
        }
      } catch (e) {
        debugLog(` Could not load previous audit data: ${e.message}`, 'warn');
      }

      // Declare schemaAudit outside try block so it's accessible in finally
      // Initialize with saved data if available (preserves Content/Schema when endpoint unavailable)
      let schemaAudit = savedAudit?.schemaAudit || null;
      let localSignals = savedAudit?.localSignals || null;
      // Don't use cached siteReviews - always fetch fresh Trustpilot snapshot
      // Old cached values (4.8, 127) should be replaced with new snapshot (4.6, 610)
      let siteReviews = null; // Always fetch fresh
      let backlinkMetrics = savedAudit?.backlinkMetrics || null;

      try {
        updateProgress(10, 'Fetching Search Console data...');
        debugLog('Fetching Search Console data...', 'info');
        // Fetch data
        const searchData = await fetchSearchConsoleData(apiKey, propertyUrl, dateRange);
        debugLog(' Search Console data fetched successfully', 'success');
        debugLog(`Data: ${JSON.stringify(searchData).substring(0, 200)}...`, 'info');
        
        updateProgress(35, 'Fetching local signals data...');
        debugLog('Fetching local signals data...', 'info');
        // Fetch local signals (Business Profile) data
        // Only fetch if we don't have saved data, or always fetch fresh (Business Profile can change)
        try {
          const localSignalsResponse = await fetch(apiUrl(`/api/aigeo/local-signals?property=${encodeURIComponent(propertyUrl)}`));
          let freshLocalSignals = null;
          const responseContentType = localSignalsResponse.headers.get('content-type') || '';
          try {
            if (responseContentType.includes('application/json')) {
              freshLocalSignals = await localSignalsResponse.json();
            } else {
              const errorText = await localSignalsResponse.text();
              debugLog(` Local signals returned non-JSON (HTTP ${localSignalsResponse.status}): ${errorText.substring(0, 200)}`, 'error');
            }
          } catch (parseError) {
            debugLog(` Local signals response parse error: ${parseError.message}`, 'error');
          }
          
          if (freshLocalSignals) {
            // If API reports error but still provides data (e.g., GBP fallback), allow downstream use.
            if (freshLocalSignals.status !== 'ok' && freshLocalSignals.data) {
              const hasGbpFallback = freshLocalSignals.data.gbpRating != null || freshLocalSignals.data.gbpReviewCount != null;
              if (hasGbpFallback) {
                freshLocalSignals = { ...freshLocalSignals, status: 'ok', _statusOverride: 'gbp-fallback' };
              }
            }
            localSignals = freshLocalSignals;
            if (freshLocalSignals.status === 'ok') {
              debugLog(' Local signals data fetched successfully', 'success');
              debugLog(`Service areas: ${localSignals.data?.serviceAreas?.length || 0}, NAP score: ${localSignals.data?.napConsistencyScore || 'N/A'}`, 'info');
            } else {
              debugLog(` Local signals returned status="${freshLocalSignals.status}" (using response data if present)`, 'warn');
            }
          } else if (!localSignalsResponse.ok) {
            debugLog(` Local signals endpoint HTTP error: ${localSignalsResponse.status}`, 'error');
          }
        } catch (localSignalsError) {
          debugLog(` Local signals fetch error: ${localSignalsError.message}`, 'error');
          console.error('[Local Signals] Fetch error:', localSignalsError);
        }
        
        // If fetch failed but we have saved data, keep using it
        if (!localSignals && savedAudit?.localSignals) {
          localSignals = savedAudit.localSignals;
          debugLog(' Using saved local signals data', 'info');
        }
        
        updateProgress(37, 'Fetching Trustpilot snapshot data...');
        debugLog('Fetching Trustpilot snapshot data...', 'info');
        // Always fetch fresh Trustpilot snapshot data (it's a fixed snapshot, so should always work)
        try {
          const siteReviewsResponse = await fetch(apiUrl('/api/reviews/site-reviews'));
          if (siteReviewsResponse.ok) {
            const siteReviewsData = await siteReviewsResponse.json();
            if (siteReviewsData.status === 'ok' && siteReviewsData.data) {
              siteReviews = siteReviewsData.data;
              debugLog(' Trustpilot snapshot data fetched successfully', 'success');
              debugLog(`Trustpilot snapshot: rating=${siteReviews.siteRating}, count=${siteReviews.siteReviewCount}`, 'info');
            } else {
              debugLog(' Trustpilot snapshot returned error, using saved data if available', 'warn');
              // Fallback to saved data only if API completely fails
              if (savedAudit?.siteReviews) {
                siteReviews = savedAudit.siteReviews;
                debugLog(' Using saved Trustpilot data as fallback (will override with correct values)', 'warn');
              }
            }
          } else {
            debugLog(' Trustpilot snapshot endpoint not available, using saved data if available', 'warn');
            // Fallback to saved data only if API completely fails
            if (savedAudit?.siteReviews) {
              siteReviews = savedAudit.siteReviews;
              debugLog(' Using saved Trustpilot data as fallback (will override with correct values)', 'warn');
            }
          }
        } catch (siteReviewsError) {
          debugLog(` Trustpilot snapshot error: ${siteReviewsError.message}, using saved data if available`, 'warn');
          // Fallback to saved data only if API completely fails
          if (savedAudit?.siteReviews) {
            siteReviews = savedAudit.siteReviews;
            debugLog(' Using saved Trustpilot data as fallback (will override with correct values)', 'warn');
          }
        }
        
        // ALWAYS force correct Trustpilot snapshot values (4.6, 610) - override ANY old values
        // This ensures we always use the correct snapshot regardless of API response or cached data
        const TRUSTPILOT_SNAPSHOT = {
          siteRating: 4.6,
          siteReviewCount: 610,
          lastUpdated: '2025-12-07',
          notes: 'Fixed Trustpilot snapshot for Authority score calculation. Update manually when Trustpilot metrics change significantly.'
        };
        
        if (!siteReviews || siteReviews.siteRating !== 4.6 || siteReviews.siteReviewCount !== 610) {
          if (siteReviews) {
            debugLog(` Overriding old Trustpilot values (${siteReviews.siteRating}, ${siteReviews.siteReviewCount}) with correct snapshot (4.6, 610)`, 'warn');
          } else {
            debugLog(' Using default Trustpilot snapshot values (4.6, 610)', 'warn');
          }
          siteReviews = TRUSTPILOT_SNAPSHOT;
        } else {
          debugLog(' Trustpilot snapshot verified (4.6, 610)', 'success');
        }
        
        updateProgress(38, 'Fetching backlink metrics data...');
        debugLog('Fetching backlink metrics data...', 'info');
        // Fetch backlink metrics - try localStorage first (from CSV upload), then API
        
        // First, try to get from localStorage (stored when CSV was uploaded)
        try {
          const storedMetrics = localStorage.getItem('backlink_metrics');
          if (storedMetrics) {
            backlinkMetrics = JSON.parse(storedMetrics);
            window.latestBacklinkMetrics = backlinkMetrics;
            debugLog(' Backlink metrics loaded from localStorage', 'success');
            debugLog(`Backlink metrics: domains=${backlinkMetrics.referringDomains}, links=${backlinkMetrics.totalBacklinks}, followRatio=${(backlinkMetrics.followRatio * 100).toFixed(1)}%`, 'info');
          }
        } catch (e) {
          debugLog(` Error reading backlink metrics from localStorage: ${e.message}`, 'warn');
        }
        
        // If not in localStorage, try API (for cases where metrics were uploaded via API directly)
        if (!backlinkMetrics) {
          try {
            const backlinkResponse = await fetch(apiUrl('/api/aigeo/backlink-metrics'));
            if (backlinkResponse.ok) {
              const backlinkData = await backlinkResponse.json();
              if (backlinkData.status === 'ok' && backlinkData.data && backlinkData.data.totalBacklinks > 0) {
                backlinkMetrics = backlinkData.data;
              window.latestBacklinkMetrics = backlinkMetrics;
                // Store in localStorage for next time
                localStorage.setItem('backlink_metrics', JSON.stringify(backlinkMetrics));
                debugLog(' Backlink metrics data fetched from API and stored', 'success');
                debugLog(`Backlink metrics: domains=${backlinkMetrics.referringDomains}, links=${backlinkMetrics.totalBacklinks}, followRatio=${(backlinkMetrics.followRatio * 100).toFixed(1)}%`, 'info');
              } else {
                debugLog(' Backlink metrics returned empty/zero, using saved data if available', 'warn');
              }
            } else {
              debugLog(' Backlink metrics endpoint not available, using saved data if available', 'warn');
            }
          } catch (backlinkError) {
            debugLog(` Backlink metrics error: ${backlinkError.message}, using saved data if available`, 'warn');
          }
        }
        
        // If fetch failed but we have saved data, keep using it
        if (!backlinkMetrics && savedAudit?.backlinkMetrics) {
          backlinkMetrics = savedAudit.backlinkMetrics;
          window.latestBacklinkMetrics = backlinkMetrics;
          debugLog(' Using saved backlink metrics data', 'info');
        }
        
        updateProgress(40, 'Fetching schema audit data...');
        debugLog('Fetching schema audit data...', 'info');
        // Fetch schema audit data
        try {
          // Check if manual URL list is available
          const manualUrlList = localStorage.getItem('manual_url_list');
          let schemaRequest;
          
          if (manualUrlList) {
            try {
              const urls = JSON.parse(manualUrlList);
              debugLog(`Using manual URL list: ${urls.length} URLs`, 'info');
              updateProgress(45, `Crawling ${urls.length} URLs for schema markup...`);
              schemaRequest = fetch(apiUrl('/api/schema-audit'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ urls })
              });
            } catch (e) {
              debugLog(' Failed to parse manual URL list, using default CSV', 'warn');
              updateProgress(45, 'Loading URLs from CSV and crawling for schema markup...');
              schemaRequest = fetch(apiUrl('/api/schema-audit'));
            }
          } else {
            debugLog('No manual URL list, using default CSV source', 'info');
            updateProgress(45, 'Loading URLs from CSV and crawling for schema markup...');
            schemaRequest = fetch(apiUrl('/api/schema-audit'));
          }
          
          const schemaResponse = await schemaRequest;
          if (schemaResponse.ok) {
            schemaAudit = await schemaResponse.json();
            if (schemaAudit.status === 'ok') {
              debugLog(' Schema audit data fetched successfully', 'success');
              debugLog(`Schema coverage: ${schemaAudit.data.coverage}%`, 'info');
              if (manualUrlList) {
                debugLog('  Source: Manual URL list', 'info');
              } else {
                debugLog('  Source: CSV (GitHub/hosted)', 'info');
              }
              
              // Log comprehensive diagnostic info if available
              if (schemaAudit.meta && schemaAudit.meta.diagnostic) {
                const diag = schemaAudit.meta.diagnostic;
                debugLog('', 'info');
                debugLog(' SCHEMA AUDIT DIAGNOSTICS', 'info');
                debugLog('', 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                debugLog(' PAGE COUNTS:', 'info');
                debugLog(`   Total pages scanned: ${diag.totalPages}`, 'info');
                debugLog(`   Successful crawls: ${diag.successfulPages || diag.totalPages}`, 'info');
                debugLog(`   Failed crawls: ${diag.failedPages || 0}`, diag.failedPages > 0 ? 'warn' : 'info');
                if (diag.failedPages > 0) {
                  debugLog(`     Failed crawls are counted as pages without schema`, 'warn');
                  
                  // Show error breakdown if available
                  if (diag.errorTypes && Object.keys(diag.errorTypes).length > 0) {
                    debugLog('', 'info'); // Empty line
                    debugLog('   ERROR BREAKDOWN:', 'warn');
                    Object.entries(diag.errorTypes).forEach(([type, count]) => {
                      debugLog(`     ${type}: ${count} pages`, 'warn');
                      if (diag.errorExamples && diag.errorExamples[type]) {
                        const example = diag.errorExamples[type];
                        debugLog(`      Example: ${example.url}`, 'info');
                        debugLog(`      Error: ${example.error}`, 'info');
                      }
                    });
                  }
                }
                debugLog(`   Pages with inline schema: ${diag.pagesWithInlineSchema}`, 'info');
                debugLog(`   Pages without inline schema: ${diag.pagesWithoutInlineSchema}`, 'info');
                if (diag.failedPages > 0) {
                  debugLog(`    (includes ${diag.failedPages} failed crawls)`, 'info');
                }
                debugLog(`   Pages with inherited schema: ${diag.pagesWithInheritedSchema}`, 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                if (diag.urlsWithoutSchemas && diag.urlsWithoutSchemas.length > 0) {
                  debugLog(' URLs WITHOUT SCHEMAS:', 'info');
                  diag.urlsWithoutSchemas.forEach(url => {
                    debugLog(`   ${url}`, 'info');
                  });
                  if (diag.pagesWithoutInlineSchema > diag.urlsWithoutSchemas.length) {
                    debugLog(`  ... and ${diag.pagesWithoutInlineSchema - diag.urlsWithoutSchemas.length} more`, 'info');
                  }
                  debugLog('', 'info'); // Empty line for spacing
                }
                
                debugLog(' MISSING SCHEMA BREAKDOWN:', 'info');
                debugLog(`   Pages with parent but no inherited: ${diag.pagesWithParentButNoInherited}`, 'info');
                debugLog(`   Pages with parent but not checked: ${diag.pagesWithParentButNotChecked}`, diag.pagesWithParentButNotChecked > 0 ? 'warn' : 'info');
                debugLog(`   Pages without parent page: ${diag.pagesWithoutParent}`, 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                debugLog(' VALIDATION:', 'info');
                debugLog(`   Total missing pages (calculated): ${diag.totalMissing}`, 'info');
                debugLog(`   Expected missing (total - inline - inherited): ${diag.expectedMissing}`, 'info');
                
                if (diag.mismatch) {
                  debugLog('', 'info'); // Empty line for spacing
                  debugLog(`   MISMATCH DETECTED!`, 'error');
                  debugLog(`  ${diag.mismatchDetails}`, 'error');
                  debugLog(`  This indicates pages are being double-counted or missed in the calculation.`, 'error');
                } else {
                  debugLog(`   Counts match correctly`, 'success');
                }
                
                debugLog('', 'info'); // Empty line for spacing
                debugLog('', 'info');
              }
            } else {
              debugLog(` Schema audit returned error status: ${schemaAudit.status}`, 'warn');
              if (schemaAudit.message) {
                debugLog(`  Error message: ${schemaAudit.message}`, 'warn');
              }
            }
          } else {
            const errorText = await schemaResponse.text();
            debugLog(` Schema audit endpoint returned ${schemaResponse.status}: ${schemaResponse.statusText}`, 'warn');
            if (errorText) {
              debugLog(`  Response: ${errorText.substring(0, 200)}`, 'warn');
            }
            // schemaAudit already initialized with saved data at start, so it's preserved
            if (schemaAudit) {
              debugLog(' Using saved schema audit data from previous audit', 'success');
              debugLog(`Schema coverage: ${schemaAudit.data?.coverage || 'N/A'}%`, 'info');
            } else {
              debugLog(' No saved schema audit data available', 'warn');
            }
          }
        } catch (schemaError) {
          debugLog(` Schema audit error: ${schemaError.message}, using saved data`, 'warn');
          // schemaAudit already initialized with saved data at start, so it's preserved
          if (schemaAudit) {
            debugLog(' Using saved schema audit data from previous audit (fallback)', 'success');
            debugLog(`Schema coverage: ${schemaAudit.data?.coverage || 'N/A'}%`, 'info');
          } else {
            debugLog(' No saved schema audit data available', 'warn');
          }
        }
        
        updateProgress(70, 'Calculating pillar scores...');
        debugLog('Calculating pillar scores...', 'info');
        // Calculate scores (pass schema audit data, local signals, site reviews, and backlink metrics)
        const scores = await calculatePillarScores(searchData, schemaAudit, localSignals, siteReviews, backlinkMetrics);
        debugLog(' Pillar scores calculated', 'success');
        debugLog(`Scores: ${JSON.stringify(scores)}`, 'info');

        updateProgress(85, 'Calculating snippet readiness...');
        debugLog('Calculating snippet readiness...', 'info');
        const snippetReadiness = calculateSnippetReadiness(scores, searchData);
        debugLog(`Snippet readiness: ${snippetReadiness}`, 'info');

        updateProgress(95, 'Generating dashboard...');
        debugLog('Displaying dashboard...', 'info');
        // Display results (pass current audit data including localSignals and backlinkMetrics)
        displayDashboard(scores, searchData, snippetReadiness, schemaAudit, localSignals, backlinkMetrics);
        
        updateProgress(100, 'Audit completed successfully!');
        debugLog('=== AUDIT COMPLETE: Success ===', 'success');
        
        // CRITICAL: Save audit results to Supabase FIRST (before localStorage)
        // This ensures Supabase is the source of truth
        try {
          const propertyUrl = document.getElementById('propertyUrl')?.value || 
                              searchData?.propertyUrl || 
                              searchData?.property_url ||
                              localStorage.getItem('gsc_property_url') ||
                              'https://www.alanranger.com';
          
          debugLog('=== SAVING AUDIT TO SUPABASE ===', 'info');
          debugLog(`Property URL: ${propertyUrl}`, 'info');
          debugLog(`Audit Date: ${new Date().toISOString().split('T')[0]}`, 'info');
          
          await saveAuditToSupabase(propertyUrl, scores, searchData, snippetReadiness, schemaAudit, localSignals, new Date().toISOString().split('T')[0], backlinkMetrics);
          debugLog(' Audit saved to Supabase successfully', 'success');
        } catch (supabaseErr) {
          debugLog(` CRITICAL: Failed to save audit to Supabase: ${supabaseErr.message}`, 'error');
          debugLog(` Error stack: ${supabaseErr.stack}`, 'error');
          showStatus(` CRITICAL: Audit completed but FAILED to save to Supabase. Error: ${supabaseErr.message}`, 'error');
          // Continue anyway - will save to localStorage as fallback
        } finally {
          // Reset the flag after audit completes
          window._isFreshAuditRun = false;
        }
        
        // Save audit results to localStorage AFTER Supabase save (for performance/caching)
        saveAuditResults(scores, searchData, snippetReadiness, schemaAudit, localSignals, siteReviews, backlinkMetrics);
        
        // Update audit timestamp display after saving - with retry mechanism for Supabase commit delay
        if (typeof updateAuditTimestamp === 'function') {
          // First attempt after 2 seconds (allow Supabase to commit)
          setTimeout(() => {
            updateAuditTimestamp();
          }, 2000);
          
          // Retry after 5 seconds if first attempt didn't find the new audit
          setTimeout(() => {
            updateAuditTimestamp();
          }, 5000);
          
          // Final retry after 10 seconds
          setTimeout(() => {
            updateAuditTimestamp();
          }, 10000);
        }
        
        // Save GSC timeseries data to database (for last 28 days, updated each audit)
        (async () => {
          try {
            // Save GSC timeseries data to database (for last 28 days, updated each audit)
            if (searchData.timeseries && Array.isArray(searchData.timeseries) && searchData.timeseries.length > 0) {
              try {
                debugLog(`Saving ${searchData.timeseries.length} GSC timeseries records to database...`, 'info');
                const timeseriesResponse = await fetch(apiUrl('/api/supabase/save-gsc-timeseries'), {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    propertyUrl: propertyUrl,
                    timeseries: searchData.timeseries
                  })
                });
                if (timeseriesResponse.ok) {
                  const timeseriesResult = await timeseriesResponse.json();
                  debugLog(` Saved ${timeseriesResult.saved || searchData.timeseries.length} GSC timeseries records to database`, 'success');
                } else {
                  const errorText = await timeseriesResponse.text();
                  debugLog(` Failed to save timeseries data: ${timeseriesResponse.status} - ${errorText.substring(0, 200)}`, 'warn');
                }
              } catch (timeseriesError) {
                debugLog(` Error saving timeseries data (non-critical): ${timeseriesError.message}`, 'warn');
              }
            } else {
              debugLog(' No timeseries data to save (searchData.timeseries is missing or empty)', 'warn');
            }
            
            // Note: saveAuditToSupabase was already called before localStorage save (line ~26467)
            // After saving to Supabase, refresh the trend chart to show the latest audit
            debugLog('Refreshing Score Trends chart after saving audit...', 'info');
            // Re-render the dashboard to update the trend chart with new data
            setTimeout(async () => {
              const saved = loadAuditResultsSync();
              if (saved && saved.scores && saved.searchData) {
                try {
                  await displayDashboard(saved.scores, saved.searchData, saved.snippetReadiness || 0, saved.schemaAudit || null, saved.localSignals || null);
                  debugLog(' Score Trends chart refreshed after saving audit', 'success');
                } catch (err) {
                  debugLog(` Error refreshing trend chart: ${err.message}`, 'warn');
                }
              }
            }, 1000); // Delay to ensure Supabase save is complete
          } catch (err) {
            debugLog(` Error saving to Supabase (chart refresh skipped): ${err.message}`, 'warn');
          }
        })();
        
        showStatus('Audit completed successfully!', 'success');
        
        // Show prompt clarifying what was updated and what wasn't
        setTimeout(() => {
          const message = 'Audit Scan completed!\n\n' +
            ' Updated: GSC metrics (clicks, impressions, CTR, GSC-based rank)\n' +
            ' NOT updated: AI metrics (AI Overview, AI Citations, Ranking & AI rank)\n\n' +
            'To update AI metrics, run "Run Ranking & AI Scan" from the Dashboard or Ranking & AI tab.\n\n' +
            'Would you like to update optimisation tasks now with the GSC data?';
          
          const updateTasks = confirm(message);
          if (updateTasks) {
            // Navigate to Optimisation tab and trigger task update
            const optimisationTab = document.querySelector('[data-panel="optimisation"]');
            if (optimisationTab) {
              // Switch to Optimisation tab
              const tabBtn = document.querySelector('[data-tab="optimisation"]');
              if (tabBtn) {
                tabBtn.click();
              }
              
              // Wait a moment for tab to switch, then trigger bulk update
              setTimeout(() => {
                if (typeof window.bulkUpdateAllTasks === 'function') {
                  window.bulkUpdateAllTasks({
                    skipConfirmation: true,
                    skipRankingAiCheck: true,
                    skipKeywordTasks: true
                  }); // GSC-only update after audit scan
                } else {
                  alert('Task update function not available. Please use "Update All Tasks" button in the Optimisation tab.');
                }
              }, 500);
            } else {
              alert('Please navigate to the Optimisation tab and click "Update All Tasks" to update tasks with the new GSC data.');
            }
          }
        }, 1000); // Wait 1 second after success message
      } catch (error) {
        debugLog(` AUDIT ERROR: ${error.message}`, 'error');
        debugLog(`Stack trace: ${error.stack}`, 'error');
        showStatus('Error running audit: ' + error.message, 'error');
        console.error(error);
      } finally {
        // Clear the fresh audit flag after audit completes (success or error)
        window._isFreshAuditRun = false;
        debugLog('Hiding loading indicator...', 'info');
        document.getElementById('loading').classList.remove('show');
        
        // Show completion summary modal
        debugLog(`Schema audit available for modal: ${schemaAudit ? 'yes' : 'no'}`, 'info');
        if (schemaAudit) {
          debugLog('Showing completion modal...', 'info');
          setTimeout(() => {
            showCompletionModal(schemaAudit);
          }, 500);
        } else {
          debugLog(' No schema audit data available for modal', 'warn');
        }
        
        // Reset progress bar for next run
        setTimeout(() => {
          updateProgress(0, 'Initializing audit scan...');
        }, 500);
        
        // Save debug log to repo after audit completes
        try {
          const auditDate = new Date().toISOString().split('T')[0];
          const currentPropertyUrl = propertyUrl || document.getElementById('propertyUrl')?.value || '';
          
          if (debugLogEntries && debugLogEntries.length > 0) {
            debugLog('Saving debug log to repo...', 'info');
            
            fetch(apiUrl('/api/save-debug-log'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                propertyUrl: currentPropertyUrl,
                auditDate: auditDate,
                debugLogEntries: debugLogEntries
              })
            }).then(response => {
              if (response.ok) {
                return response.json();
              } else {
                throw new Error(`HTTP ${response.status}`);
              }
            }).then(result => {
              if (result.status === 'ok') {
                debugLog(` Debug log saved to repo: ${result.data.filename} (${result.data.entriesCount} entries)`, 'success');
              } else {
                debugLog(` Failed to save debug log: ${result.message}`, 'warn');
              }
            }).catch(err => {
              debugLog(` Error saving debug log to repo (non-critical): ${err.message}`, 'warn');
            });
          } else {
            debugLog(' No debug log entries to save', 'warn');
          }
        } catch (saveLogError) {
          debugLog(` Error preparing debug log save (non-critical): ${saveLogError.message}`, 'warn');
        }
      }
    }

    // Fetch and parse site-urls.csv
    async function fetchAndParseSiteUrlsCsv() {
      const PRIMARY_CSV_URL = "https://schema-tools-six.vercel.app/06-site-urls.csv";
      const FALLBACK_CSV_URL = "https://raw.githubusercontent.com/alanranger/alan-shared-resources/main/csv/06-site-urls.csv";
      
      try {
        // Try primary source first to avoid noisy 404s
        const cacheBust = `cb=${Date.now()}`;
        const primaryUrl = PRIMARY_CSV_URL.includes('?')
          ? `${PRIMARY_CSV_URL}&${cacheBust}`
          : `${PRIMARY_CSV_URL}?${cacheBust}`;
        const res = await fetch(primaryUrl, { cache: 'no-store' });
        if (!res.ok) throw new Error(`Primary fetch failed: HTTP ${res.status}`);
        const csvText = await res.text();
        
        // Parse CSV - extract URLs from url column
        const lines = csvText.split('\n').filter(line => line.trim());
        const headerLine = lines[0] ? lines[0].trim() : '';
        // Guard: primary URL sometimes returns HTML (not CSV)
        if (!headerLine || headerLine.toLowerCase().startsWith('<!doctype') || headerLine.toLowerCase().startsWith('<html')) {
          throw new Error('Primary CSV response looks like HTML, falling back');
        }
        const urls = [];
        
        // Parse header row to find URL column index
        let urlColumnIndex = 0;
        if (lines.length > 0) {
          const headers = parseCsvLine(headerLine);
          const urlHeaderIndex = headers.findIndex(h => h.toLowerCase() === 'url');
          if (urlHeaderIndex !== -1) {
            urlColumnIndex = urlHeaderIndex;
          } else {
            throw new Error('Primary CSV missing url header, falling back');
          }
        }
        
        // Helper function to parse CSV line with proper quote handling
        function parseCsvLine(line) {
          const columns = [];
          let current = '';
          let inQuotes = false;
          
          for (let i = 0; i < line.length; i++) {
            const char = line[i];
            const nextChar = line[i + 1];
            
            if (char === '"') {
              if (inQuotes && nextChar === '"') {
                current += '"';
                i++;
              } else {
                inQuotes = !inQuotes;
              }
            } else if (char === ',' && !inQuotes) {
              columns.push(current.trim());
              current = '';
            } else {
              current += char;
            }
          }
          columns.push(current.trim());
          return columns;
        }
        
        // Parse data rows (skip header)
        for (let i = 1; i < lines.length; i++) {
          const columns = parseCsvLine(lines[i]);
          if (columns[urlColumnIndex]) {
            const url = columns[urlColumnIndex].trim();
            if (url) {
              // Accept URLs starting with http/https, or relative URLs starting with /
              // Also accept full URLs without protocol (will be normalized)
              if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('/')) {
                urls.push(url);
              } else if (url.includes('.') && !url.includes(' ')) {
                // Likely a URL without protocol - add https://
                urls.push(url.startsWith('//') ? `https:${url}` : `https://${url}`);
              }
            }
          }
        }
        
        return urls;
      } catch (githubErr) {
        // Try fallback
        try {
          const fallbackRes = await fetch(FALLBACK_CSV_URL);
          if (!fallbackRes.ok) throw new Error(`Fallback fetch failed: HTTP ${fallbackRes.status}`);
          const csvText = await fallbackRes.text();
          
          // Same parsing logic as above
          const lines = csvText.split('\n').filter(line => line.trim());
          const urls = [];
          let urlColumnIndex = 0;
          
          if (lines.length > 0) {
            const headerLine = lines[0].trim();
            const headers = parseCsvLine(headerLine);
            const urlHeaderIndex = headers.findIndex(h => h.toLowerCase() === 'url');
            if (urlHeaderIndex !== -1) {
              urlColumnIndex = urlHeaderIndex;
            }
          }
          
          function parseCsvLine(line) {
            const columns = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
              const char = line[i];
              const nextChar = line[i + 1];
              if (char === '"') {
                if (inQuotes && nextChar === '"') {
                  current += '"';
                  i++;
                } else {
                  inQuotes = !inQuotes;
                }
              } else if (char === ',' && !inQuotes) {
                columns.push(current.trim());
                current = '';
              } else {
                current += char;
              }
            }
            columns.push(current.trim());
            return columns;
          }
          
          for (let i = 1; i < lines.length; i++) {
            const columns = parseCsvLine(lines[i]);
            if (columns[urlColumnIndex]) {
              const url = columns[urlColumnIndex].trim();
              if (url) {
                // Accept URLs starting with http/https, or relative URLs starting with /
                // Also accept full URLs without protocol (will be normalized)
                if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('/')) {
                  urls.push(url);
                } else if (url.includes('.') && !url.includes(' ')) {
                  // Likely a URL without protocol - add https://
                  urls.push(url.startsWith('//') ? `https:${url}` : `https://${url}`);
                }
              }
            }
          }
          
          return urls;
        } catch (fallbackErr) {
          throw new Error(`Unable to load site URLs CSV: ${githubErr.message}`);
        }
      }
    }
    
    // Simple safe extractor for diagnostics
    function diagVal(val) {
      if (val === null || val === undefined) return val;
      if (typeof val === 'number') return isNaN(val) ? 'NaN' : val;
      if (typeof val === 'string') return val.slice(0, 120);
      return val;
    }

    // Normalize GSC page keys so we can safely join page-level data
    // - Lowercase, trim
    // - Strip protocol/domain/query/hash
    // - Force leading slash
    // - Decode URI components when possible
    function normalizeGscPageKey(input) {
      try {
        let url = String(input || '').trim().toLowerCase();
        if (!url) return '';
        // Remove protocol
        url = url.replace(/^https?:\/\//, '');
        // Drop hash/query
        url = url.split('#')[0].split('?')[0];
        // Remove leading host if present
        const slashIndex = url.indexOf('/');
        if (slashIndex > -1) {
          url = url.slice(slashIndex);
        } else {
          url = '/' + url;
        }
        // Remove www.
        url = url.replace(/^www\./, '');
        // Decode if possible
        try { url = decodeURIComponent(url); } catch (e) {}
        // Remove trailing slash (except root)
        if (url.length > 1 && url.endsWith('/')) url = url.slice(0, -1);
        return url;
      } catch (e) {
        return String(input || '').trim();
      }
    }

    function logDiagnosticSnapshot(scores, data, snippetReadiness, localSignals, rankingAiDataMeta = {}) {
      try {
        const authority = scores?.authority || {};
        const authorityComponents = scores?.authorityComponents || {};
        const behaviourSeg = authority?.behaviourScoresSegmented || null;
        const rankingSeg = authority?.rankingScoresSegmented || null;
        const queryPagesLen = Array.isArray(data?.queryPages) ? data.queryPages.length : 0;
        const searchDataLen = Array.isArray(data?.searchData?.queryPages) ? data.searchData.queryPages.length : 0;
        const rankingAiTs = rankingAiDataMeta?.timestamp || rankingAiDataMeta?.audit_date || rankingAiDataMeta?.auditDate || null;
        const diag = {
          diagBuild: window.__GAIO_DIAG_BUILD__ || 'unknown',
          versionLabel: document.getElementById('gitVersion')?.textContent || 'n/a',
          rankingAiTimestamp: diagVal(rankingAiTs),
          gscAuditDate: diagVal(window.lastGscAuditDate || null),
          queryPages: { direct: queryPagesLen, searchData: searchDataLen },
          behaviourScoresSegmented: behaviourSeg ? {
            all: diagVal(behaviourSeg.all), nonBlog: diagVal(behaviourSeg.nonBlog), money: diagVal(behaviourSeg.money)
          } : null,
          rankingScoresSegmented: rankingSeg ? {
            all: diagVal(rankingSeg.all), nonBlog: diagVal(rankingSeg.nonBlog), money: diagVal(rankingSeg.money)
          } : null,
          authorityComponents: {
            behaviour: diagVal(authorityComponents.behaviour),
            ranking: diagVal(authorityComponents.ranking),
            backlinks: diagVal(authorityComponents.backlinks),
            reviews: diagVal(authorityComponents.reviews),
            total: diagVal(authority?.score)
          },
          snippetReadiness: diagVal(snippetReadiness),
          localSignals: {
            status: localSignals?.status || null,
            hasData: !!localSignals?.data,
            locations: Array.isArray(localSignals?.data?.locations) ? localSignals.data.locations.length : null
          }
        };
        debugLog(`[DIAG] Snapshot ${JSON.stringify(diag)}`, 'info');
      } catch (e) {
        debugLog(`[DIAG] Failed to log diagnostic snapshot: ${e?.message || e}`, 'warn');
      }
    }

    // Display dashboard
    async function displayDashboard(scores, data, snippetReadiness = 0, schemaAudit = null, localSignals = null, backlinkMetrics = null) {
      // Normalize localSignals structure if needed (handle old format where it might just be {data: {...}})
      if (localSignals && localSignals.data && !localSignals.status) {
        debugLog(`[displayDashboard] Normalizing localSignals structure - wrapping in status/data format`, 'info');
        localSignals = { status: 'ok', data: localSignals.data || localSignals };
      }
      // Update timestamp if this is a fresh display
      const saved = await loadAuditResults();
      if (saved && saved.timestamp) {
        updateAuditTimestamp(saved.timestamp);
      }
      // Log a diagnostic snapshot early (helps correlate UI with data source)
      logDiagnosticSnapshot(scores, data, snippetReadiness, localSignals, window.rankingAiData || {});
      
      // CRITICAL: Ensure Money Pages data is in scores object
      // If scores.moneyPagesMetrics is missing, get it from saved data
      // Check explicitly for null/undefined/false (not just falsy)
      debugLog(`DEBUG: Checking moneyPagesMetrics - scores.moneyPagesMetrics=${scores?.moneyPagesMetrics}, type=${typeof scores?.moneyPagesMetrics}, saved.scores.moneyPagesMetrics=${saved?.scores?.moneyPagesMetrics}, type=${typeof saved?.scores?.moneyPagesMetrics}, saved.moneyPagesMetrics=${saved?.moneyPagesMetrics}, type=${typeof saved?.moneyPagesMetrics}`, 'info');
      
      if (!scores.moneyPagesMetrics || scores.moneyPagesMetrics === null || scores.moneyPagesMetrics === false) {
        if (saved && saved.scores && saved.scores.moneyPagesMetrics !== null && saved.scores.moneyPagesMetrics !== undefined && saved.scores.moneyPagesMetrics !== false) {
          scores.moneyPagesMetrics = saved.scores.moneyPagesMetrics;
          debugLog(` Restored moneyPagesMetrics from saved.scores (${saved.scores.moneyPagesMetrics.rows?.length || 0} rows)`, 'success');
        } else if (saved && saved.moneyPagesMetrics !== null && saved.moneyPagesMetrics !== undefined && saved.moneyPagesMetrics !== false) {
          scores.moneyPagesMetrics = saved.moneyPagesMetrics;
          debugLog(` Restored moneyPagesMetrics from saved.moneyPagesMetrics (${saved.moneyPagesMetrics.rows?.length || 0} rows)`, 'success');
        } else {
          debugLog(` No moneyPagesMetrics found in saved data: saved.scores.moneyPagesMetrics=${saved?.scores?.moneyPagesMetrics} (type: ${typeof saved?.scores?.moneyPagesMetrics}), saved.moneyPagesMetrics=${saved?.moneyPagesMetrics} (type: ${typeof saved?.moneyPagesMetrics})`, 'warn');
        }
      }
      
      // Store globally for Money Pages sections
      if (scores.moneyPagesMetrics) {
        window.currentMoneyPagesMetrics = scores.moneyPagesMetrics;
        window.moneyPagesMetrics = scores.moneyPagesMetrics;
        debugLog(` Stored moneyPagesMetrics globally: ${scores.moneyPagesMetrics.rows?.length || 0} rows`, 'success');
      }
      
      // Use current audit data (passed as parameter) or fallback to saved data
      // This ensures we always use the most recent audit run data, not stale localStorage
      // Check both localSignals and localSignalsSnapshot (different storage formats)
      const currentLocalSignals = localSignals || (saved && (saved.localSignals || saved.localSignalsSnapshot)) || null;
      // If Authority components/segmented scores are missing but we have queryPages, recompute from searchData
      const searchDataForRecalc = data?.searchData || data || saved?.searchData || null;
      const missingAuthority =
        !scores?.authority ||
        !scores?.authority?.behaviourScoresSegmented ||
        !scores?.authority?.rankingScoresSegmented ||
        !scores?.authorityComponents ||
        scores?.authorityComponents?.behaviour == null ||
        scores?.authorityComponents?.ranking == null ||
        scores?.authorityComponents?.backlinks == null ||
        scores?.authorityComponents?.reviews == null;
      if (missingAuthority && searchDataForRecalc && Array.isArray(searchDataForRecalc.queryPages) && searchDataForRecalc.queryPages.length > 0) {
        try {
          debugLog(`[displayDashboard] Recomputing authority from queryPages (${searchDataForRecalc.queryPages.length} rows) due to missing segmented scores/components`, 'info');
          const recomputed = await calculatePillarScores(
            searchDataForRecalc,
            schemaAudit || saved?.schemaAudit || null,
            currentLocalSignals || saved?.localSignals || null,
            null,
            null
          );
          // Merge recomputed scores back into current scores
          scores = { ...scores, ...recomputed };
          if (recomputed.authority) {
            scores.authority = { ...scores.authority, ...recomputed.authority };
          }
          if (recomputed.authorityComponents) {
            scores.authorityComponents = recomputed.authorityComponents;
          }
          debugLog(`[displayDashboard]  Recomputed authority with segmented scores: behaviour=${recomputed.authorityComponents?.behaviour}, ranking=${recomputed.authorityComponents?.ranking}`, 'success');
        } catch (e) {
          debugLog(`[displayDashboard]  Failed to recompute authority from queryPages: ${e?.message || e}`, 'warn');
        }
      }
      
      // DEBUG: Log currentLocalSignals structure
      if (currentLocalSignals) {
        debugLog(`[displayDashboard] currentLocalSignals structure: status=${currentLocalSignals.status}, hasData=${!!currentLocalSignals.data}, hasLocations=${!!currentLocalSignals.data?.locations}, locationsCount=${currentLocalSignals.data?.locations?.length || 0}`, 'info');
        if (currentLocalSignals.data && currentLocalSignals.data.locations) {
          debugLog(`[displayDashboard] currentLocalSignals.data.locations type: ${typeof currentLocalSignals.data.locations}, isArray: ${Array.isArray(currentLocalSignals.data.locations)}, length: ${currentLocalSignals.data.locations.length}`, 'info');
        } else {
          debugLog(`[displayDashboard]  currentLocalSignals.data.locations is missing!`, 'warn');
        }
      } else {
        debugLog(`[displayDashboard]  currentLocalSignals is null!`, 'warn');
      }
      
      // Restore Money Pages Priority Matrix data from localStorage
      // If not available, try to rebuild from saved data
      if (saved && saved.moneyPagePriorityData && Array.isArray(saved.moneyPagePriorityData) && saved.moneyPagePriorityData.length > 0) {
        window.moneyPagePriorityData = saved.moneyPagePriorityData;
        // Use saved moneySegmentMetrics if available, otherwise rebuild
        if (saved.moneySegmentMetrics) {
          window.moneySegmentMetrics = saved.moneySegmentMetrics;
          debugLog(` Restored Money Pages Priority data and segment metrics from localStorage: ${window.moneyPagePriorityData.length} pages`, 'success');
        } else {
          window.moneySegmentMetrics = null;
          debugLog(` Restored Money Pages Priority data from localStorage: ${window.moneyPagePriorityData.length} pages (no segment metrics)`, 'success');
        }
      } else {
        // Try to rebuild from saved data - check multiple locations
        // IMPORTANT: Check for null/undefined explicitly, not just truthy (null is falsy but we need to distinguish it from missing)
        let savedMetrics = null;
        if (saved && saved.scores && saved.scores.moneyPagesMetrics !== null && saved.scores.moneyPagesMetrics !== undefined && saved.scores.moneyPagesMetrics !== false) {
          savedMetrics = saved.scores.moneyPagesMetrics;
          debugLog(` Found moneyPagesMetrics in saved.scores.moneyPagesMetrics`, 'success');
        } else if (saved && saved.moneyPagesMetrics !== null && saved.moneyPagesMetrics !== undefined && saved.moneyPagesMetrics !== false) {
          savedMetrics = saved.moneyPagesMetrics;
          debugLog(` Found moneyPagesMetrics in saved.moneyPagesMetrics`, 'success');
        } else if (scores && scores.moneyPagesMetrics !== null && scores.moneyPagesMetrics !== undefined && scores.moneyPagesMetrics !== false) {
          savedMetrics = scores.moneyPagesMetrics;
          debugLog(` Found moneyPagesMetrics in scores.moneyPagesMetrics`, 'success');
        } else {
          debugLog(` moneyPagesMetrics not found in any location: saved.scores.moneyPagesMetrics=${saved?.scores?.moneyPagesMetrics}, saved.moneyPagesMetrics=${saved?.moneyPagesMetrics}, scores.moneyPagesMetrics=${scores?.moneyPagesMetrics}`, 'warn');
        }
        
        const savedSearchData = data || (saved && saved.searchData);
        
        if (savedMetrics && savedMetrics.rows && Array.isArray(savedMetrics.rows) && savedMetrics.rows.length > 0 && savedSearchData) {
          // Rebuild from saved data if priority data is missing but we have the source data
          // schemaAudit is optional - buildMoneyPageMetrics can work without it
          try {
            debugLog(`Rebuilding Money Pages Priority data from ${savedMetrics.rows.length} rows`, 'info');
            const topPagesForPriority = savedMetrics.rows.map(row => ({
              page: row.url,
              url: row.url,
              clicks: row.clicks || 0,
              impressions: row.impressions || 0,
              // row.ctr is already a ratio (0-1). Do not multiply by 100.
              ctr: (row.ctr || 0),
              position: row.avgPosition || 0,
              avgPosition: row.avgPosition || 0,
              title: row.title || row.url
            }));
            
            // Use schemaAudit if available, otherwise pass null (function handles it)
            const auditSchema = schemaAudit || (saved && saved.schemaAudit) || null;
            // Use global function - it should be available after the function is defined
            // If not available, try to wait a bit for it to load
            if (typeof window.buildMoneyPageMetrics !== 'function') {
              debugLog(' buildMoneyPageMetrics not available, waiting 100ms...', 'warn');
              // Wait a bit for function to be defined (in case script hasn't finished loading)
              await new Promise(resolve => setTimeout(resolve, 100));
              
              if (typeof window.buildMoneyPageMetrics !== 'function') {
                debugLog(' buildMoneyPageMetrics still not available after wait, cannot rebuild Priority data', 'warn');
                // Function should be defined earlier in the script, but if not, we can't rebuild
                // Don't throw - just skip rebuilding and show empty state
                window.moneyPagePriorityData = [];
                window.moneySegmentMetrics = null;
              } else {
                debugLog(' buildMoneyPageMetrics now available after wait', 'success');
                // Function is now available, proceed with rebuild
                window.moneyPagePriorityData = window.buildMoneyPageMetrics(topPagesForPriority, auditSchema);
                
                // Use saved moneySegmentMetrics if available (from Supabase), otherwise rebuild
                if (saved && saved.moneySegmentMetrics) {
                  window.moneySegmentMetrics = saved.moneySegmentMetrics;
                  debugLog(` Using moneySegmentMetrics from saved data (Supabase)`, 'success');
                } else {
                  // Rebuild segment metrics
                  const behaviourScoresBySegment = {};
                  if (savedMetrics.behaviour) {
                    behaviourScoresBySegment.allMoney = savedMetrics.behaviour.score || 0;
                  }
                  if (typeof buildMoneySegmentSummary === 'function') {
                    window.moneySegmentMetrics = buildMoneySegmentSummary(window.moneyPagePriorityData, behaviourScoresBySegment);
                    debugLog(` Rebuilt moneySegmentMetrics from moneyPagePriorityData`, 'success');
                  } else {
                    debugLog(` buildMoneySegmentSummary is not available, cannot rebuild moneySegmentMetrics`, 'warn');
                    window.moneySegmentMetrics = null;
                  }
                }
                
                debugLog(` Rebuilt Money Pages Priority data from saved metrics: ${window.moneyPagePriorityData.length} pages`, 'success');
                
                // Save the rebuilt data back to localStorage
                if (window.moneyPagePriorityData && window.moneyPagePriorityData.length > 0) {
                  const updatedAudit = { ...saved, moneyPagePriorityData: window.moneyPagePriorityData, moneySegmentMetrics: window.moneySegmentMetrics };
                  safeSetLocalStorage('last_audit_results', updatedAudit);
                }
              }
            } else {
              // Function is available, proceed with rebuild
              window.moneyPagePriorityData = window.buildMoneyPageMetrics(topPagesForPriority, auditSchema);
              
              // Use saved moneySegmentMetrics if available (from Supabase), otherwise rebuild
              if (saved && saved.moneySegmentMetrics) {
                window.moneySegmentMetrics = saved.moneySegmentMetrics;
                debugLog(` Using moneySegmentMetrics from saved data (Supabase)`, 'success');
              } else {
                // Rebuild segment metrics
                const behaviourScoresBySegment = {};
                if (savedMetrics.behaviour) {
                  behaviourScoresBySegment.allMoney = savedMetrics.behaviour.score || 0;
                }
                if (typeof buildMoneySegmentSummary === 'function') {
                  window.moneySegmentMetrics = buildMoneySegmentSummary(window.moneyPagePriorityData, behaviourScoresBySegment);
                  debugLog(` Rebuilt moneySegmentMetrics from moneyPagePriorityData`, 'success');
                } else {
                  debugLog(` buildMoneySegmentSummary is not available, cannot rebuild moneySegmentMetrics`, 'warn');
                  window.moneySegmentMetrics = null;
                }
              }
              
              debugLog(` Rebuilt Money Pages Priority data from saved metrics: ${window.moneyPagePriorityData.length} pages`, 'success');
              
              // Save the rebuilt data back to localStorage
              if (window.moneyPagePriorityData && window.moneyPagePriorityData.length > 0) {
                const updatedAudit = { ...saved, moneyPagePriorityData: window.moneyPagePriorityData, moneySegmentMetrics: window.moneySegmentMetrics };
                safeSetLocalStorage('last_audit_results', updatedAudit);
              }
            }
          } catch (error) {
            debugLog(` Failed to rebuild Money Pages Priority data: ${error.message}`, 'warn');
            debugLog(`Error stack: ${error.stack}`, 'error');
            window.moneyPagePriorityData = [];
            window.moneySegmentMetrics = null;
          }
        } else {
          // No saved data available
          window.moneyPagePriorityData = window.moneyPagePriorityData || [];
          window.moneySegmentMetrics = window.moneySegmentMetrics || null;
          debugLog(' No Money Pages Priority data available (will be empty until next audit)', 'warn');
          debugLog(`Debug: saved=${!!saved}, savedMetrics=${!!savedMetrics}, savedMetrics.rows=${savedMetrics?.rows?.length || 0}, searchData=${!!(saved && saved.searchData || data)}`, 'warn');
        }
      }
      
      // Update retry button visibility
      updateRetryButtonVisibility(schemaAudit);
      
      debugLog('=== DISPLAY DASHBOARD: Starting ===', 'info');
      debugLog(`Using current audit data: schemaAudit=${schemaAudit ? 'yes' : 'no'}, localSignals=${currentLocalSignals ? 'yes' : 'no'}`, 'info');
      debugLog(`Scores object keys: ${scores ? Object.keys(scores).join(', ') : 'null'}`, 'info');
      debugLog(`Money Pages Metrics in scores: ${scores?.moneyPagesMetrics ? 'yes' : 'no'}`, 'info');
      if (saved && saved.scores) {
        debugLog(`Saved scores keys: ${Object.keys(saved.scores).join(', ')}`, 'info');
        debugLog(`Money Pages Metrics in saved scores: ${saved.scores.moneyPagesMetrics ? 'yes' : 'no'}`, 'info');
      }
      
      // Show dashboard first (canvas elements need to be visible for Chart.js)
      const dashboardDiv = document.getElementById('dashboard');
      if (!dashboardDiv) {
        debugLog(' Dashboard div not found', 'error');
        console.error('Dashboard div not found');
        return;
      }
      debugLog(' Dashboard div found', 'success');
      dashboardDiv.style.display = 'block';
      debugLog('Dashboard div displayed', 'info');
      
      // Update trend chart description with date range
      const dateRange = parseInt(document.getElementById('dateRange').value) || 28;
      const trendDesc = document.getElementById('trendChartDescription');
      if (trendDesc) {
        let rangeText = '';
        if (dateRange === 28) rangeText = 'Last 28 Days';
        else if (dateRange === 30) rangeText = 'Last 30 Days';
        else if (dateRange === 60) rangeText = 'Last 60 Days';
        else if (dateRange === 90) rangeText = 'Last 90 Days';
        else if (dateRange === 120) rangeText = 'Last 120 Days';
        else if (dateRange === 180) rangeText = 'Last 6 Months';
        else if (dateRange === 365) rangeText = 'Last 12 Months';
        else if (dateRange === 540) rangeText = 'Last 18 Months';
        else rangeText = `Last ${dateRange} Days`;
        trendDesc.textContent = `Historical performance tracking for Local Entity, Visibility, and Authority pillars over ${rangeText.toLowerCase()}.`;
      }
      
      const pillarNames = {
        localEntity: 'Local Entity',
        serviceArea: 'Service Area',
        authority: 'Authority',
        visibility: 'Visibility',
        contentSchema: 'Content / Schema'
      };
      
      // Define pillar weightings and order by weight (highest to lowest)
      const pillarWeights = {
        authority: 0.30,        // 30% - E-A-T is crucial for AI trust
        contentSchema: 0.25,     // 25% - Structured data is key for AI understanding
        visibility: 0.20,        // 20% - How AI surfaces your content
        localEntity: 0.15,       // 15% - Entity recognition important but not critical
        serviceArea: 0.10         // 10% - Less critical for AI search
      };
      
      // Sort pillars by weight (highest to lowest) for consistent ordering
      const getOrderedPillars = (scoresObj) => {
        // Filter out non-pillar keys (like authorityComponents)
        const validPillars = ['localEntity', 'serviceArea', 'authority', 'visibility', 'contentSchema'];
        return Object.entries(scoresObj)
          .filter(([key]) => validPillars.includes(key))
          .map(([key, scoreValue]) => {
            // Handle new Authority structure (object with score) or legacy (number)
            let score = scoreValue;
            if (key === 'authority' && typeof scoreValue === 'object' && scoreValue !== null) {
              score = scoreValue.score || 0;
            }
            return [key, score];
          })
          .sort((a, b) => {
          return (pillarWeights[b[0]] || 0) - (pillarWeights[a[0]] || 0);
        });
      };

      // Use current audit data (passed as parameter) for health dashboard
      // This ensures we use the most recent audit run data, not stale localStorage
      // Handle both status/data structure and direct data structure
      const hasLocalSignals = currentLocalSignals && (
        (currentLocalSignals.status === 'ok' && currentLocalSignals.data) ||
        (currentLocalSignals.data && (currentLocalSignals.data.napConsistencyScore !== undefined || currentLocalSignals.data.locationsScore !== undefined))
      );
      const localSignalsData = hasLocalSignals 
        ? (currentLocalSignals.data || currentLocalSignals)
        : null;
      
      // DEBUG: Log local signals status for health dashboard
      debugLog(`[Health Dashboard] Local signals: hasLocalSignals=${hasLocalSignals}, currentLocalSignals=${JSON.stringify(currentLocalSignals ? {status: currentLocalSignals.status, hasData: !!currentLocalSignals.data} : null)}`, 'info');
      
      // DEBUG: Verify brandOverlay is populated
      console.log('DEBUG brandOverlay', scores.brandOverlay);
      debugLog(`DEBUG brandOverlay: ${JSON.stringify(scores.brandOverlay)}`, 'info');
      
      // Calculate GAIO Health Score
      const aiGeoHealth = calculateAiGeoScore(scores, schemaAudit, snippetReadiness);
      debugLog(`GAIO Health: Score=${aiGeoHealth.aiGeoScore}, Status=${aiGeoHealth.aiGeoStatus}, Likelihood=${aiGeoHealth.aiSummaryLikelihood}`, 'info');
      
      // Extract component scores for health dashboard
      const authorityScore = (typeof scores.authority === 'object' && scores.authority !== null) 
        ? scores.authority.score 
        : scores.authority || 0;
      const contentScore = scores.contentSchema || 0;
      
      // Extract coverage and diversity from schema audit (same logic as calculateAiGeoScore)
      let coverageScore = scores.coverage || 0;
      let diversityScore = scores.diversity || 0;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        coverageScore = schemaData.coverage || 0;
        const allTypes = new Set();
        if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
          schemaData.allDetectedTypes.forEach(type => {
            if (type) allTypes.add(type);
          });
        } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          schemaData.schemaTypes.forEach(item => {
            if (item.type) allTypes.add(item.type);
          });
        }
        const uniqueTypesCount = allTypes.size;
        diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
      }
      
      const locationsScore = ((scores.localEntity || 0) + (scores.serviceArea || 0)) / 2;
      
      // Create GAIO Health Dashboard (insert before pillar cards)
      const healthDashboard = document.createElement('div');
      healthDashboard.id = 'ai-geo-health-dashboard';
      healthDashboard.style.marginBottom = '2rem';
      
      // Get pillar hints/comments for the comparison table
      const getPillarHint = (pillarKey, score, scoresObj, schemaAuditData, localSignalsData) => {
        switch(pillarKey) {
          case 'authority':
            const authComponents = scoresObj?.authorityComponents;
            if (authComponents) {
              if (authComponents.behaviour < 30 && authComponents.backlinks >= 50 && authComponents.reviews >= 50) {
                return 'Backlinks and reviews strong; CTR weak';
              } else if (authComponents.behaviour >= 50 && authComponents.ranking < 30) {
                return 'CTR strong; ranking needs improvement';
              } else if (authComponents.behaviour < 30) {
                return 'Behaviour is weak; backlinks/reviews strong';
              }
            }
            return 'E-A-T signals balanced';
          case 'content':
            if (score >= 90) return 'Fully structured, rich schema';
            if (score >= 70) return 'Good schema coverage';
            return 'Schema needs improvement';
          case 'coverage':
            if (score >= 90) return 'All priority pages ingested';
            if (score >= 70) return 'Most pages covered';
            return 'Coverage gaps present';
          case 'diversity':
            if (score >= 80) return 'Good mix of topics and formats';
            if (score >= 60) return 'Moderate diversity';
            return 'Limited schema diversity';
          case 'locations':
            if (score >= 85) return 'GBP + core locations covered well';
            if (score >= 70) return 'Local entity and service areas solid';
            return 'Location signals need strengthening';
          default:
            return '';
        }
      };
      
      // Phase 2: Get brand priority
      const getBrandPriority = (summary) => {
        const b = summary.brandOverlay;
        if (!b) return null;
        if (b.score >= 70) return null; // only suggest actions if score is below "Strong"
        
        const share = b.brandQueryShare || 0;
        const ctr = b.brandCtr || 0;
        const entity = b.entityScore ?? 0;
        const review = b.reviewScore ?? 0;
        
        // Decide the most important brand-related action
        if (share < 0.10) {
          return {
            pillar: 'Brand & Entity',
            severity: 'medium',
            message: 'Increase the share of branded searches (e.g. "Alan Ranger Photography") by using your full brand name consistently in campaigns, key landing pages and off-site mentions.',
            link: '#pillarCards',
            score: b.score
          };
        }
        
        if (ctr < 0.25) {
          return {
            pillar: 'Brand & Entity',
            severity: 'medium',
            message: 'Improve titles and meta descriptions on core brand pages (home, about, tuition, workshops) to raise CTR on branded queries above 25%.',
            link: '#pillarCards',
            score: b.score
          };
        }
        
        if (entity < 70) {
          return {
            pillar: 'Brand & Entity',
            severity: 'medium',
            message: 'Strengthen entity signals by maintaining NAP consistency, adding more detail to GBP and About/Press pages, and earning mentions on relevant third-party sites.',
            link: '#pillarCards',
            score: b.score
          };
        }
        
        if (review < 70) {
          return {
            pillar: 'Brand & Entity',
            severity: 'medium',
            message: 'Boost review signals with a steady flow of new Google reviews and clear calls-to-review after workshops and lessons.',
            link: '#pillarCards',
            score: b.score
          };
        }
        
        // Fallback for mid-range scores
        return {
          pillar: 'Brand & Entity',
          severity: 'low',
          message: 'Continue building branded visibility by consolidating strong informational content into clear "hub" pages that use your brand name and service area.',
          link: '#pillarCards',
          score: b.score
        };
      };
      
      // Generate priorities list from pillar diagnostics
      // Helper to generate money pages priority (Phase 2)
      function getMoneyPagesPriority(moneyPagesMetrics) {
        if (!moneyPagesMetrics || !moneyPagesMetrics.rows || !moneyPagesMetrics.rows.length) {
          debugLog('getMoneyPagesPriority: No rows data', 'warn');
          return null;
        }
        
        const { rows, summaryByCategory, overview } = moneyPagesMetrics;
        const moneyImpressions = overview.moneyImpressions || 0;
        if (moneyImpressions === 0) {
          debugLog('getMoneyPagesPriority: No money impressions', 'warn');
          return null;
        }
        
        const high = summaryByCategory?.HIGH_OPPORTUNITY || { count: 0, impressions: 0 };
        const vis = summaryByCategory?.VISIBILITY_FIX || { count: 0, impressions: 0 };
        
        const highCount = high.count || 0;
        const highImps = high.impressions || 0;
        const visCount = vis.count || 0;
        const visImps = vis.impressions || 0;
        
        debugLog(`getMoneyPagesPriority: high=${highCount} pages/${highImps} imps, vis=${visCount} pages/${visImps} imps, total=${moneyImpressions}`, 'info');
        
        const totalFocusImps = highImps + visImps;
        if (totalFocusImps === 0) {
          debugLog('getMoneyPagesPriority: No focus impressions (high+vis)', 'warn');
          return null;
        }
        
        const sharePct = (totalFocusImps / moneyImpressions) * 100;
        
        let severity = 'medium';
        if (sharePct >= 60) severity = 'high';
        else if (sharePct <= 25) severity = 'low';
        
        const topExamples = rows
          .filter((r) => r.category === 'HIGH_OPPORTUNITY' || r.category === 'VISIBILITY_FIX')
          .slice(0, 3)
          .map((r) => {
            try {
              const urlObj = new URL(r.url);
              return urlObj.pathname.split('/').filter(p => p).pop() || r.url;
            } catch (e) {
              return r.url;
            }
          });
        
        const description =
          `Money pages: ${highCount} high-opportunity and ${visCount} visibility-fix URLs ` +
          `account for ${sharePct.toFixed(1)}% of money-page impressions. ` +
          `Prioritise improving titles/meta, "best" framing, and FAQs on these pages.`;
        
        const detail =
          topExamples.length
            ? `Examples: ${topExamples.join(', ')}`
            : '';
        
        const priority = {
          pillar: 'Money Pages',
          severity, // 'high' | 'medium' | 'low'
          message: description,
          detail: detail,
          link: '#money-pages-section'
        };
        
        debugLog(` Money pages priority created: ${JSON.stringify(priority)}`, 'success');
        return priority;
      }
      
      const getPriorities = (scoresObj, schemaAuditData, localSignalsData, authorityComponents) => {
        const priorities = [];
        
        // Authority priorities
        if (authorityComponents) {
          if (authorityComponents.behaviour < 30) {
            priorities.push({
              pillar: 'Authority',
              severity: 'high',
              message: 'Improve Top-10 CTR on money pages (Authority  Behaviour table, status = Poor)',
              link: '#authority-top-pages-section'
            });
          }
          if (authorityComponents.ranking < 30) {
            priorities.push({
              pillar: 'Authority',
              severity: 'medium',
              message: 'Improve average position and top-10 impression share',
              link: '#authority-top-pages-section'
            });
          }
        }
        
        // Content/Schema priorities
        if (schemaAuditData && schemaAuditData.status === 'ok' && schemaAuditData.data) {
          const schemaData = schemaAuditData.data;
          if (schemaData.coverage < 100) {
            // Use missingSchemaCount if available, otherwise calculate from coverage
            const missingCount = schemaData.missingSchemaCount || 
              (schemaData.totalPages ? Math.round((100 - schemaData.coverage) / 100 * schemaData.totalPages) : 0);
            priorities.push({
              pillar: 'Content',
              severity: 'medium',
              message: `Add schema to ${missingCount > 0 ? missingCount : 'remaining'} pages (Content/Schema  coverage ${schemaData.coverage != null ? schemaData.coverage.toFixed(0) : 'N/A'}%)`,
              link: '#pillarCards'
            });
          }
          const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
          // PRIORITY: Use foundation object first (most reliable source) - same logic as Content/Schema card
          let foundationPresent = 0;
          if (schemaData.foundation && typeof schemaData.foundation === 'object') {
            // Use foundation object directly - count how many are true (same as Content/Schema card)
            foundationPresent = foundationTypes.filter(type => schemaData.foundation[type] === true).length;
          } else {
            // Fallback: check allDetectedTypes or schemaTypes
            const allTypes = new Set();
            if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
              schemaData.allDetectedTypes.forEach(type => {
                if (type) allTypes.add(type);
              });
            } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
              schemaData.schemaTypes.forEach(item => {
                if (item && typeof item === 'object' && item.type) {
                  allTypes.add(item.type);
                } else if (typeof item === 'string') {
                  allTypes.add(item);
                }
              });
            }
            foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
          }
          
          if (foundationPresent < 4) {
            // Determine missing types based on which data structure was used
            const missingTypes = schemaData.foundation && typeof schemaData.foundation === 'object'
              ? foundationTypes.filter(t => schemaData.foundation[t] !== true)
              : foundationTypes.filter(t => {
                  // Fallback: check allTypes set if foundation object not available
                  const allTypes = new Set();
                  if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
                    schemaData.allDetectedTypes.forEach(type => { if (type) allTypes.add(type); });
                  } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
                    schemaData.schemaTypes.forEach(item => {
                      if (item && typeof item === 'object' && item.type) allTypes.add(item.type);
                      else if (typeof item === 'string') allTypes.add(item);
                    });
                  }
                  return !allTypes.has(t);
                });
            
            priorities.push({
              pillar: 'Content',
              severity: 'high',
              message: `Add missing foundation schemas: ${missingTypes.join(', ')}`,
              link: '#pillarCards'
            });
          }
        }
        
        // Locations priorities
        if (localSignalsData) {
          if (localSignalsData.napConsistencyScore < 100) {
            priorities.push({
              pillar: 'Locations',
              severity: 'medium',
              message: `Improve NAP consistency (currently ${localSignalsData.napConsistencyScore}%)`,
              link: '#pillarCards'
            });
          }
          const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
          if (serviceAreasCount < 5) {
            priorities.push({
              pillar: 'Locations',
              severity: 'low',
              message: `Add more service areas to Google Business Profile (currently ${serviceAreasCount}, target: 5+)`,
              link: '#pillarCards'
            });
          }
        }
        
        // Phase 2: Add brand priority if applicable
        const brandPriority = getBrandPriority ? getBrandPriority({ brandOverlay: scoresObj.brandOverlay }) : null;
        if (brandPriority) {
          priorities.push(brandPriority);
        }
        
        // Phase 2: Add money pages priority if applicable
        debugLog(`Checking for money pages priority - moneyPagesMetrics exists: ${!!scoresObj.moneyPagesMetrics}`, 'info');
        if (scoresObj.moneyPagesMetrics) {
          debugLog(`Money pages metrics: rows=${scoresObj.moneyPagesMetrics.rows?.length || 0}, summaryByCategory=${!!scoresObj.moneyPagesMetrics.summaryByCategory}`, 'info');
        }
        const moneyPriority = getMoneyPagesPriority(scoresObj.moneyPagesMetrics);
        if (moneyPriority) {
          debugLog(` Adding money pages priority: ${moneyPriority.message}`, 'success');
          priorities.push(moneyPriority);
        } else {
          debugLog(' No money pages priority generated', 'warn');
        }
        
        // Sort by severity (high > medium > low) and limit to top items
        const severityOrder = { high: 3, medium: 2, low: 1 };
        const sorted = priorities.sort((a, b) => severityOrder[b.severity] - severityOrder[a.severity]);
        
        // Allow up to 4 items when brand or money pages priorities are present, or 5 otherwise
        const hasOverlayPriorities = brandPriority || moneyPriority;
        const maxItems = hasOverlayPriorities ? 4 : 5;
        return sorted.slice(0, maxItems);
      };
      
      const priorities = getPriorities(scores, schemaAudit, localSignalsData, scores.authorityComponents);
      
      healthDashboard.innerHTML = `
        <!-- Updated: 2024 - Site AI Health title, 0% marker removed -->
        <div style="background: white; padding: 2rem; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-bottom: 2rem;">
          <!-- GAIO Health Top Card -->
          <div style="text-align: center; margin-bottom: 3rem; padding: 2rem 0; border-bottom: 2px solid #e2e8f0;">
            <div style="display: flex; align-items: flex-start; justify-content: center; gap: 4rem; margin-bottom: 2rem; flex-wrap: wrap;">
              <!-- Dial Section with Title -->
              <div style="display: flex; flex-direction: column; align-items: center;">
                <!-- Section Title - Centered over dial -->
                <h2 style="font-size: 2rem; font-weight: 700; color: #1e293b; margin-bottom: 1.5rem; letter-spacing: -0.02em; text-align: center; width: 100%;">
                  Site AI Health
                </h2>
                <!-- Circular Progress Ring - Speedometer Style -->
                <div style="position: relative; width: 520px; height: 520px; margin: 0 auto; overflow: visible;">
                ${(() => {
                  const score = aiGeoHealth.aiGeoScore;
                  const center = 260;
                  const radius = 195;
                  const strokeWidth = 26;
                  const normalizedRadius = radius - strokeWidth / 2;
                  
                  // Determine colors based on status
                  const color = aiGeoHealth.aiGeoStatus === 'green' ? '#10b981' : 
                               aiGeoHealth.aiGeoStatus === 'amber' ? '#f59e0b' : '#ef4444';
                  const bgColor = aiGeoHealth.aiGeoStatus === 'green' ? '#d1fae5' : 
                                 aiGeoHealth.aiGeoStatus === 'amber' ? '#fef3c7' : '#fee2e2';
                  
                  // Angle calculations: 0% at 12:05 (-85), 50% at 6pm (90), 100% at 12pm (-90)
                  const startAngle = -85; // 12:05 position
                  const endAngle = -90;   // 12pm position
                  const angleRange = 360 - 5; // Full circle minus 5 gap
                  
                  // Helper function to create arc path
                  const createArc = (start, end, r) => {
                    const startRad = (start * Math.PI) / 180;
                    const endRad = (end * Math.PI) / 180;
                    const largeArc = Math.abs(end - start) > 180 ? 1 : 0;
                    const x1 = center + r * Math.cos(startRad);
                    const y1 = center + r * Math.sin(startRad);
                    const x2 = center + r * Math.cos(endRad);
                    const y2 = center + r * Math.sin(endRad);
                    return `M ${x1} ${y1} A ${r} ${r} 0 ${largeArc} 1 ${x2} ${y2}`;
                  };
                  
                  // Calculate segment angles
                  const angle0 = startAngle;
                  const angle50 = startAngle + angleRange * 0.5;
                  const angle70 = startAngle + angleRange * 0.7;
                  const angle100 = startAngle + angleRange;
                  
                  // Calculate current score angle
                  const scoreAngle = startAngle + (score / 100) * angleRange;
                  const scoreRad = (scoreAngle * Math.PI) / 180;
                  
                  return `
                    <svg width="520" height="520" style="filter: drop-shadow(0 4px 12px rgba(0,0,0,0.08)); overflow: visible;">
                      <!-- Background circle -->
                      <circle
                        cx="${center}"
                        cy="${center}"
                        r="${normalizedRadius}"
                        fill="none"
                        stroke="#f1f5f9"
                        stroke-width="${strokeWidth}"
                      />
                      
                      <!-- Red segment: 0-50% -->
                      <path
                        d="${createArc(angle0, angle50, normalizedRadius)}"
                        fill="none"
                        stroke="#ef4444"
                        stroke-width="${strokeWidth}"
                        stroke-linecap="round"
                      />
                      
                      <!-- Amber segment: 50-70% -->
                      <path
                        d="${createArc(angle50, angle70, normalizedRadius)}"
                        fill="none"
                        stroke="#f59e0b"
                        stroke-width="${strokeWidth}"
                        stroke-linecap="round"
                      />
                      
                      <!-- Green segment: 70-100% -->
                      <path
                        d="${createArc(angle70, angle100, normalizedRadius)}"
                        fill="none"
                        stroke="#10b981"
                        stroke-width="${strokeWidth}"
                        stroke-linecap="round"
                      />
                      
                      <!-- Tick marks for GAIO Score, AI Summary Likelihood, and Brand & Entity -->
                      <g>
                        ${(() => {
                          // Get all three scores
                          const aiGeoScoreValue = score; // Already calculated
                          const brandScore = scores?.brandOverlay?.score || 0;
                          const aiSummaryScore = aiGeoHealth?.aiSummary?.score || 0;
                          
                          // Calculate angles for each score
                          const aiGeoAngle = startAngle + (aiGeoScoreValue / 100) * angleRange;
                          const brandAngle = startAngle + (brandScore / 100) * angleRange;
                          const aiSummaryAngle = startAngle + (aiSummaryScore / 100) * angleRange;
                          
                          const aiGeoRad = (aiGeoAngle * Math.PI) / 180;
                          const brandRad = (brandAngle * Math.PI) / 180;
                          const aiSummaryRad = (aiSummaryAngle * Math.PI) / 180;
                          
                          // GAIO Score tick mark (solid, thick) - scaled 30% larger
                          const aiGeoTickLength = 31.2;
                          const aiGeoTickWidth = 5.2;
                          const aiGeoTickX1 = center + (normalizedRadius - aiGeoTickLength) * Math.cos(aiGeoRad);
                          const aiGeoTickY1 = center + (normalizedRadius - aiGeoTickLength) * Math.sin(aiGeoRad);
                          const aiGeoTickX2 = center + (normalizedRadius + aiGeoTickLength) * Math.cos(aiGeoRad);
                          const aiGeoTickY2 = center + (normalizedRadius + aiGeoTickLength) * Math.sin(aiGeoRad);
                          
                          // AI Summary Likelihood tick mark (solid, medium) - scaled 30% larger
                          const aiSummaryTickLength = 26;
                          const aiSummaryTickWidth = 3.9;
                          const aiSummaryTickX1 = center + (normalizedRadius - aiSummaryTickLength) * Math.cos(aiSummaryRad);
                          const aiSummaryTickY1 = center + (normalizedRadius - aiSummaryTickLength) * Math.sin(aiSummaryRad);
                          const aiSummaryTickX2 = center + (normalizedRadius + aiSummaryTickLength) * Math.cos(aiSummaryRad);
                          const aiSummaryTickY2 = center + (normalizedRadius + aiSummaryTickLength) * Math.sin(aiSummaryRad);
                          
                          // Brand & Entity tick mark (dashed, medium) - scaled 30% larger
                          const brandTickLength = 23.4;
                          const brandTickWidth = 3.9;
                          const brandTickX1 = center + (normalizedRadius - brandTickLength) * Math.cos(brandRad);
                          const brandTickY1 = center + (normalizedRadius - brandTickLength) * Math.sin(brandRad);
                          const brandTickX2 = center + (normalizedRadius + brandTickLength) * Math.cos(brandRad);
                          const brandTickY2 = center + (normalizedRadius + brandTickLength) * Math.sin(brandRad);
                          
                          // Colors based on scores (consistent with badge logic)
                          // AI Summary uses same RAG bands as GAIO: 70 green, 50 amber, <50 red
                          const aiSummaryColor = aiSummaryScore >= 70 ? '#10b981' : aiSummaryScore >= 50 ? '#f59e0b' : '#ef4444';
                          const brandColor = brandScore >= 70 ? '#10b981' : brandScore >= 40 ? '#f59e0b' : '#ef4444';
                          
                          return `
                            <!-- GAIO Score tick mark (main score) -->
                            <line x1="${aiGeoTickX1}" y1="${aiGeoTickY1}" 
                                  x2="${aiGeoTickX2}" y2="${aiGeoTickY2}" 
                                  stroke="${color}" 
                                  stroke-width="${aiGeoTickWidth}" 
                                  stroke-linecap="round"
                                  style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));"/>
                            
                            <!-- AI Summary Likelihood tick mark -->
                            ${aiSummaryScore > 0 ? `
                            <line x1="${aiSummaryTickX1}" y1="${aiSummaryTickY1}" 
                                  x2="${aiSummaryTickX2}" y2="${aiSummaryTickY2}" 
                                  stroke="${aiSummaryColor}" 
                                  stroke-width="${aiSummaryTickWidth}" 
                                  stroke-linecap="round"
                                  style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));"/>
                            ` : ''}
                            
                            <!-- Brand & Entity score tick mark -->
                            ${brandScore > 0 ? `
                            <line x1="${brandTickX1}" y1="${brandTickY1}" 
                                  x2="${brandTickX2}" y2="${brandTickY2}" 
                                  stroke="${brandColor}" 
                                  stroke-width="${brandTickWidth}" 
                                  stroke-linecap="round"
                                  stroke-dasharray="4,2"
                                  style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));"/>
                            ` : ''}
                          `;
                        })()}
                      </g>
                      
                      <!-- Needle indicator for current score -->
                      <g>
                        <line
                          x1="${center}"
                          y1="${center}"
                          x2="${center + (normalizedRadius + 19.5) * Math.cos(scoreRad)}"
                          y2="${center + (normalizedRadius + 19.5) * Math.sin(scoreRad)}"
                          stroke="${color}"
                          stroke-width="5.2"
                          stroke-linecap="round"
                          style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2)); transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1);"
                        />
                        <!-- Needle center dot -->
                        <circle
                          cx="${center}"
                          cy="${center}"
                          r="10.4"
                          fill="${color}"
                          style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));"
                        />
                      </g>
                      
                      <!-- Labels: 50%, 100%, and all three score indicators -->
                      <g>
                        ${(() => {
                          // Get all three scores
                          const aiGeoScoreValue = score;
                          const brandScore = scores?.brandOverlay?.score || 0;
                          const aiSummaryScore = aiGeoHealth?.aiSummary?.score || 0;
                          
                          // Calculate angles
                          const aiGeoAngle = startAngle + (aiGeoScoreValue / 100) * angleRange;
                          const brandAngle = startAngle + (brandScore / 100) * angleRange;
                          const aiSummaryAngle = startAngle + (aiSummaryScore / 100) * angleRange;
                          
                          // Colors - AI Summary uses same RAG bands as GAIO: 70 green, 50 amber, <50 red
                          const aiSummaryColor = aiSummaryScore >= 70 ? '#10b981' : aiSummaryScore >= 50 ? '#f59e0b' : '#ef4444';
                          const brandColor = brandScore >= 70 ? '#10b981' : brandScore >= 40 ? '#f59e0b' : '#ef4444';
                          
                          const labels = [
                            { value: 100, angle: angle100, color: '#10b981' },  // Scale marker
                            { value: aiGeoScoreValue, angle: aiGeoAngle, color: color, label: 'GAIO' },  // Main score
                            ...(aiSummaryScore > 0 ? [{ value: aiSummaryScore, angle: aiSummaryAngle, color: aiSummaryColor, label: 'AI Summary' }] : []),
                            ...(brandScore > 0 ? [{ value: brandScore, angle: brandAngle, color: brandColor, label: 'Brand' }] : [])
                          ];
                          
                          return labels.map(m => {
                            const rad = (m.angle * Math.PI) / 180;
                            const labelOffset = 65;
                            const labelX = center + (normalizedRadius + labelOffset) * Math.cos(rad);
                            const labelY = center + (normalizedRadius + labelOffset) * Math.sin(rad);
                            
                            // For scores, show value with label below
                            if (m.label) {
                              return `
                                <g>
                                  <text x="${labelX}" y="${labelY - 10}" 
                                        text-anchor="middle" dominant-baseline="middle"
                                        fill="${m.color}" 
                                        font-size="18" font-weight="700"
                                        style="text-shadow: 0 1px 2px rgba(255,255,255,0.8);">${m.value}</text>
                                  <text x="${labelX}" y="${labelY + 13}" 
                                        text-anchor="middle" dominant-baseline="middle"
                                        fill="#64748b" 
                                        font-size="13" font-weight="500"
                                        style="text-shadow: 0 1px 2px rgba(255,255,255,0.8);">${m.label}</text>
                                </g>
                              `;
                            } else {
                              // Scale markers (50, 100)
                              return `
                                <text x="${labelX}" y="${labelY}" 
                                      text-anchor="middle" dominant-baseline="middle"
                                      fill="${m.color}" 
                                      font-size="21" font-weight="700"
                                      style="text-shadow: 0 1px 2px rgba(255,255,255,0.8);">${m.value}</text>
                              `;
                            }
                          }).join('');
                        })()}
                      </g>
                    </svg>
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; width: 100%; pointer-events: none;">
                      <div style="font-size: 5.5rem; font-weight: 800; color: ${color}; line-height: 1; margin-bottom: 0.5rem; letter-spacing: -0.03em; text-shadow: 0 2px 12px ${color}25;">
                        ${score}
                      </div>
                      <div style="font-size: 0.9rem; color: #64748b; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; margin-bottom: 0.75rem;">
                        GAIO Score
                      </div>
                      <div style="padding: 0.5rem 1rem; background: ${bgColor}; border-radius: 24px; display: inline-block;">
                        <span style="font-size: 0.875rem; color: ${color}; font-weight: 700;">
                          ${aiGeoHealth.aiGeoStatus === 'green' ? ' Excellent' : aiGeoHealth.aiGeoStatus === 'amber' ? ' Good' : ' Needs Work'}
                        </span>
                      </div>
                    </div>
                  `;
                })()}
                </div>
              </div>
              <div style="display: flex; flex-direction: column; align-items: center; gap: 1.5rem; justify-content: center;">
                <div style="text-align: center;">
                  <div style="font-size: 0.9rem; color: #64748b; margin-bottom: 0.5rem; font-weight: 500;">GAIO Status:</div>
                  ${(() => {
                    // Build GAIO score breakdown summary
                    const authorityScore = (typeof scores.authority === 'object' && scores.authority !== null) 
                      ? scores.authority.score 
                      : scores.authority || 0;
                    const contentScore = scores.contentSchema || 0;
                    const visibilityScore = scores.visibility || 0;
                    const localEntityScore = scores.localEntity || 0;
                    const serviceAreaScore = scores.serviceArea || 0;
                    
                    const aiGeoBreakdown = `GAIO Score Breakdown:
 Authority: ${Math.round(authorityScore)} (30% weight)
 Content/Schema: ${Math.round(contentScore)} (25% weight)
 Visibility: ${Math.round(visibilityScore)} (20% weight)
 Local Entity: ${Math.round(localEntityScore)} (15% weight)
 Service Area: ${Math.round(serviceAreaScore)} (10% weight)
Final Score: ${aiGeoHealth.aiGeoScore}/100`;
                    
                    return `
                      <div style="display: flex; align-items: flex-start; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                        <span class="rag-badge ${aiGeoHealth.aiGeoStatus}" style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: help; width: 170px; justify-content: center; flex-shrink: 0;" title="${aiGeoBreakdown}">
                          ${aiGeoHealth.aiGeoStatus === 'green' ? 'Green' : aiGeoHealth.aiGeoStatus === 'amber' ? 'Amber' : 'Red'} (${aiGeoHealth.aiGeoScore}/100)
                          <span style="display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 50%; background: #3b82f6; color: white; font-size: 0.75rem; font-weight: 700; cursor: help; flex-shrink: 0;" title="${aiGeoBreakdown}">i</span>
                        </span>
                        <div style="background: white; border: 1px solid #e2e8f0; border-radius: 6px; padding: 0.75rem 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 0.85rem; color: #1e293b; line-height: 1.6; width: 320px; min-height: 140px;">
                          <div style="font-weight: 600; margin-bottom: 0.5rem; color: #1e293b;">GAIO Score Breakdown:</div>
                          <div style="color: #64748b;">
                            <div> Authority: ${Math.round(authorityScore)} (30% weight)</div>
                            <div> Content/Schema: ${Math.round(contentScore)} (25% weight)</div>
                            <div> Visibility: ${Math.round(visibilityScore)} (20% weight)</div>
                            <div> Local Entity: ${Math.round(localEntityScore)} (15% weight)</div>
                            <div> Service Area: ${Math.round(serviceAreaScore)} (10% weight)</div>
                            <div style="margin-top: 0.5rem; font-weight: 600; color: #1e293b;">Final Score: ${aiGeoHealth.aiGeoScore}/100</div>
                          </div>
                        </div>
                      </div>
                    `;
                  })()}
                </div>
                <div style="text-align: center;">
                  <div style="display: flex; flex-direction: column; gap: 1rem;">
                    <div>
                      <div style="font-size: 0.9rem; color: #64748b; margin-bottom: 0.5rem; font-weight: 500;">AI summary likelihood:</div>
                      ${(() => {
                        // Phase 2: Use aiSummary.label if available, otherwise fallback to aiSummaryLikelihood
                        const aiSummary = aiGeoHealth.aiSummary || { label: aiGeoHealth.aiSummaryLikelihood || 'Low', score: 0 };
                        // Ensure label is capitalized correctly
                        let label = aiSummary.label || 'Low';
                        if (typeof label === 'string') {
                          label = label.charAt(0).toUpperCase() + label.slice(1).toLowerCase();
                        }
                        const score = aiSummary.score || 0;
                        // Use same RAG bands as GAIO Score: 70 green, 50 amber, <50 red
                        const bgColor = score >= 70 ? '#d1fae5' : score >= 50 ? '#fef3c7' : '#fee2e2';
                        const textColor = score >= 70 ? '#065f46' : score >= 50 ? '#92400e' : '#991b1b';
                        
                        // Build AI Summary breakdown
                        // Handle both number format (legacy) and object format (if it exists)
                        let snippetReadinessScore = typeof snippetReadiness === 'number' 
                          ? snippetReadiness 
                          : (snippetReadiness?.overallScore || 0);
                        
                        // CRITICAL FIX: If snippetReadiness is 0 but we have scores, recalculate it
                        // This ensures the displayed value matches the calculated AI summary score
                        if (snippetReadinessScore === 0 && scores && typeof calculateSnippetReadiness === 'function') {
                          snippetReadinessScore = calculateSnippetReadiness(scores, {});
                        }
                        
                        const visibilityScore = scores.visibility || 0;
                        const brandScore = scores.brandOverlay?.score || 0;
                        
                        const aiSummaryBreakdown = `AI Summary Likelihood Breakdown:
 Snippet Readiness: ${Math.round(snippetReadinessScore)}/100 (50% weight)
 Visibility: ${Math.round(visibilityScore)}/100 (30% weight)
 Brand & Entity: ${Math.round(brandScore)}/100 (20% weight)
Final Score: ${score}/100

Based on snippet-friendly content (FAQ / HowTo / Article / Event blocks), how often your content appears in rich results, and the strength of your brand & entity signals (branded searches, reviews, knowledge panel).`;
                        
                        return `
                          <div style="display: flex; align-items: flex-start; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                            <span style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 6px; font-size: 1rem; font-weight: 600; background: ${bgColor}; color: ${textColor}; cursor: help; width: 170px; justify-content: center; flex-shrink: 0;" title="${aiSummaryBreakdown}">
                              ${label} (${score}/100)
                              <span style="display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 50%; background: #3b82f6; color: white; font-size: 0.75rem; font-weight: 700; cursor: help; flex-shrink: 0;" title="${aiSummaryBreakdown}">i</span>
                            </span>
                            <div style="background: white; border: 1px solid #e2e8f0; border-radius: 6px; padding: 0.75rem 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 0.85rem; color: #1e293b; line-height: 1.6; width: 320px; min-height: 140px;">
                              <div style="font-weight: 600; margin-bottom: 0.5rem; color: #1e293b;">AI Summary Likelihood Breakdown:</div>
                              <div style="color: #64748b;">
                                <div> Snippet Readiness: ${Math.round(snippetReadinessScore)}/100 (50% weight)</div>
                                <div> Visibility: ${Math.round(visibilityScore)}/100 (30% weight)</div>
                                <div> Brand & Entity: ${Math.round(brandScore)}/100 (20% weight)</div>
                                <div style="margin-top: 0.5rem; font-weight: 600; color: #1e293b;">Final Score: ${score}/100</div>
                              </div>
                            </div>
                          </div>
                        `;
                      })()}
                    </div>
                    <div>
                      <div style="font-size: 0.9rem; color: #64748b; margin-bottom: 0.5rem; font-weight: 500;">Brand & entity:</div>
                      ${(() => {
                        // Brand & Entity chip - show even if missing (with N/A)
                        const brandOverlay = scores.brandOverlay;
                        if (brandOverlay) {
                          const score = brandOverlay.score || 0;
                          const label = brandOverlay.label || 'Weak';
                          const bgColor = score >= 70 ? '#d1fae5' : score >= 40 ? '#fef3c7' : '#fee2e2';
                          const textColor = score >= 70 ? '#065f46' : score >= 40 ? '#92400e' : '#991b1b';
                          const brandQueryShare = brandOverlay.brandQueryShare != null ? (brandOverlay.brandQueryShare * 100).toFixed(1) : 'N/A';
                          const brandCtr = brandOverlay.brandCtr != null ? (brandOverlay.brandCtr * 100).toFixed(1) : 'N/A';
                          const brandAvgPos = brandOverlay.brandAvgPosition != null ? brandOverlay.brandAvgPosition.toFixed(1) : 'N/A';
                          const reviewScore = brandOverlay.reviewScore != null ? brandOverlay.reviewScore : 'N/A';
                          const entityScore = brandOverlay.entityScore != null ? brandOverlay.entityScore : 'N/A';
                          const brandTooltip = `Brand & Entity Overlay Breakdown:
 Brand Query Share: ${brandQueryShare}% of impressions
 Brand CTR: ${brandCtr}%
 Avg Brand Position: ${brandAvgPos}
 Review Score: ${reviewScore}/100
 Entity Score: ${entityScore}/100
Final Score: ${score}/100`;
                          return `
                            <div style="display: flex; align-items: flex-start; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                              <span style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 6px; font-size: 1rem; font-weight: 600; background: ${bgColor}; color: ${textColor}; cursor: help; width: 170px; justify-content: center; flex-shrink: 0;" title="${brandTooltip}">
                                ${label} (${score}/100)
                                <span style="display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 50%; background: #3b82f6; color: white; font-size: 0.75rem; font-weight: 700; cursor: help; flex-shrink: 0;" title="${brandTooltip}">i</span>
                              </span>
                              <div style="background: white; border: 1px solid #e2e8f0; border-radius: 6px; padding: 0.75rem 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 0.85rem; color: #1e293b; line-height: 1.6; width: 320px; min-height: 140px;">
                                <div style="font-weight: 600; margin-bottom: 0.5rem; color: #1e293b;">Brand & Entity Overlay Breakdown:</div>
                                <div style="color: #64748b;">
                                  <div> Brand Query Share: ${brandQueryShare}% of impressions</div>
                                  <div> Brand CTR: ${brandCtr}%</div>
                                  <div> Avg Brand Position: ${brandAvgPos}</div>
                                  <div> Review Score: ${reviewScore}/100</div>
                                  <div> Entity Score: ${entityScore}/100</div>
                                  <div style="margin-top: 0.5rem; font-weight: 600; color: #1e293b;">Final Score: ${score}/100</div>
                                </div>
                              </div>
                            </div>
                          `;
                        } else {
                          // Show N/A if brandOverlay is missing
                          const brandTooltip = 'No brand overlay data available  run an audit with access to query data.';
                          return `
                            <div style="display: flex; align-items: flex-start; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                              <span style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 6px; font-size: 1rem; font-weight: 600; background: #e5e7eb; color: #6b7280; cursor: help; width: 170px; justify-content: center; flex-shrink: 0;" title="${brandTooltip}">
                                N/A
                                <span style="display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 50%; background: #3b82f6; color: white; font-size: 0.75rem; font-weight: 700; cursor: help; flex-shrink: 0;" title="${brandTooltip}">i</span>
                              </span>
                              <div style="background: white; border: 1px solid #e2e8f0; border-radius: 6px; padding: 0.75rem 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 0.85rem; color: #64748b; width: 320px; min-height: 140px; display: flex; align-items: center;">
                                No brand overlay data available  run an audit with access to query data.
                              </div>
                            </div>
                          `;
                        }
                      })()}
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <p style="margin: 0; font-size: 0.95rem; color: #475569; font-weight: 500;">
              Based on Authority, Content & Schema, Coverage, Diversity, Locations and Brand & entity signals.
            </p>
          </div>
          
          <!-- This Month's Priorities -->
          ${priorities.length > 0 ? `
          <div>
            <h3 style="margin: 0 0 1rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">This Month's Priorities</h3>
            <div style="background: #f8f9fa; border-radius: 8px; padding: 1rem; border-left: 4px solid #ef4444;">
              <ul style="margin: 0; padding-left: 1.5rem; list-style: none;">
                ${priorities.map((p, idx) => {
                  // Phase 2: For brand priorities, use brandOverlay score for color
                  let severityColor;
                  if (p.pillar === 'Brand & Entity' && p.score !== undefined) {
                    severityColor = p.score >= 70 ? '#10b981' : p.score >= 40 ? '#f59e0b' : '#ef4444';
                  } else {
                    severityColor = p.severity === 'high' ? '#ef4444' : p.severity === 'medium' ? '#f59e0b' : '#10b981';
                  }
                  return `
                    <li style="margin-bottom: ${idx < priorities.length - 1 ? '0.75rem' : '0'}; padding-left: 0.5rem; position: relative;">
                      <span style="position: absolute; left: -1.5rem; color: ${severityColor}; font-weight: 700;"></span>
                      <a href="${p.link}" style="color: #1e293b; text-decoration: none; font-weight: 500; border-bottom: 1px solid transparent; transition: border-color 0.2s;" onmouseover="this.style.borderBottomColor='#1e293b';" onmouseout="this.style.borderBottomColor='transparent';">
                        ${p.message}
                      </a>
                    </li>
                  `;
                }).join('')}
              </ul>
            </div>
          </div>
          ` : ''}
        </div>
      `;
      
      // Insert health dashboard before pillar cards
      const pillarCards = document.getElementById('pillarCards');
      if (!pillarCards) {
        debugLog(' Pillar cards container not found', 'error');
        console.error('Pillar cards container (id="pillarCards") not found in DOM');
        return;
      }
      debugLog(' Pillar cards container found', 'success');
      
      // Remove existing health dashboard if present
      const existingHealth = document.getElementById('ai-geo-health-dashboard');
      if (existingHealth) {
        existingHealth.remove();
      }
      
      // Insert health dashboard before pillar cards
      pillarCards.parentNode.insertBefore(healthDashboard, pillarCards);
      debugLog(' GAIO Health Dashboard created', 'success');
      
      // Circular progress ring is SVG-based, no additional drawing needed
      
      // Clear pillar cards for fresh render
      pillarCards.innerHTML = '';

      const orderedPillars = getOrderedPillars(scores);
      debugLog(`Creating ${orderedPillars.length} pillar cards from scores: ${JSON.stringify(scores)}`, 'info');
      
      if (orderedPillars.length === 0) {
        debugLog(' No pillars found in scores object!', 'warn');
        console.warn('No pillars found in scores:', scores);
      }
      
      orderedPillars.forEach(([key, scoreValue]) => {
        // Handle new Authority structure (object with score and bySegment) or legacy (number)
        // Note: getOrderedPillars extracts the score, so we need to get bySegment from original scores object
        let score = scoreValue;
        let authorityBySegment = null;
        if (key === 'authority') {
          // Get the original Authority object from scores (not from getOrderedPillars result)
          const authorityObj = scores.authority;
          if (typeof authorityObj === 'object' && authorityObj !== null) {
            score = authorityObj.score || 0;
            authorityBySegment = authorityObj.bySegment || null;
          }
        }
        
        const rag = getRAGStatus(score);
        const card = document.createElement('div');
        card.className = 'pillar-card';
        
        // Get pillar description with data source info (dynamic based on whether we have real data)
        // Use currentLocalSignals (from displayDashboard parameter) for pillar cards, not just health dashboard
        // Check both localSignals and localSignalsSnapshot (different storage formats)
        const pillarLocalSignals = currentLocalSignals || (saved && (saved.localSignals || saved.localSignalsSnapshot)) || null;
        // Handle both status/data structure and direct data structure
        const pillarLocalSignalsData = pillarLocalSignals?.data
          || (pillarLocalSignals && typeof pillarLocalSignals === 'object' && !pillarLocalSignals.status ? pillarLocalSignals : null);
        const pillarHasLocalSignals = !!pillarLocalSignalsData;
        
        // DEBUG: Log local signals status for pillar cards
        debugLog(`[Pillar Cards] Local signals in definitions: hasLocalSignals=${pillarHasLocalSignals}, currentLocalSignals=${JSON.stringify(pillarLocalSignals ? {status: pillarLocalSignals.status, hasData: !!pillarLocalSignals.data, hasLocations: !!pillarLocalSignals.data?.locations, locationsCount: pillarLocalSignals.data?.locations?.length || 0} : null)}`, 'info');
        if (pillarLocalSignals && pillarLocalSignals.data) {
          debugLog(`[Pillar Cards] pillarLocalSignals.data keys: ${Object.keys(pillarLocalSignals.data).join(', ')}`, 'info');
          debugLog(`[Pillar Cards] pillarLocalSignals.data.locations type: ${typeof pillarLocalSignals.data.locations}, isArray: ${Array.isArray(pillarLocalSignals.data.locations)}, length: ${pillarLocalSignals.data.locations?.length || 0}`, 'info');
        }
        
        let localEntityDesc, serviceAreaDesc;
        if (pillarHasLocalSignals && pillarLocalSignalsData) {
          const napScore = pillarLocalSignalsData.napConsistencyScore !== null ? pillarLocalSignalsData.napConsistencyScore : 'N/A';
          const serviceAreasCount = pillarLocalSignalsData.serviceAreas?.length || 0;
          const locationsCount = pillarLocalSignalsData.locations?.length || 0;
          localEntityDesc = `How clearly your business and you as a person are recognised as entities by AI search systems. <strong>Data Source:</strong>  Live data from Google Business Profile API. <strong>Data Checked:</strong> NAP consistency (${napScore}%), knowledge panel (${pillarLocalSignalsData.knowledgePanelDetected ? 'detected' : 'not detected'}), locations (${locationsCount}).`;
          serviceAreaDesc = `How well AI understands where you operate and which regions you serve. <strong>Data Source:</strong>  Live data from Google Business Profile API. <strong>Data Checked:</strong> Service areas (${serviceAreasCount}), NAP consistency (${napScore}%).`;
        } else {
          localEntityDesc = 'How clearly your business and you as a person are recognised as entities by AI search systems. <strong>Data Source:</strong>  Currently derived from search performance (GSC position/CTR). Real local signals API integration pending.';
          serviceAreaDesc = 'How well AI understands where you operate and which regions you serve. <strong>Data Source:</strong>  Currently derived from Local Entity score. Real service area data from Google Business Profile pending.';
        }
        
        const descriptions = {
          localEntity: localEntityDesc,
          serviceArea: serviceAreaDesc,
          authority: 'E-A-T (Experience, Expertise, Authoritativeness, Trustworthiness): Perceived expertise and trust in the topic space. <strong>Calculation:</strong> Behaviour (40%) + Ranking (20%) + Backlinks (20%) + Reviews (20%). <strong>Data Source:</strong>  Live data from Google Search Console, Google Business Profile API, historic Trustpilot reviews snapshot, and backlink CSV upload.',
          visibility: 'How prominently your content appears in AI-powered search results and featured snippets. <strong>Data Source:</strong>  Live data from Google Search Console (impressions, clicks, position, SERP features).',
          contentSchema: 'Quality and completeness of structured data markup across your domain. <strong>Data Source:</strong>  Live data from schema audit. <strong>Calculation:</strong> Foundation schemas (30%) + Rich Results (35%) + Coverage (20%) + Diversity (15%).'
        };
        
        // Build breakdown and details sections for all pillars (for consistency)
        let pillarBreakdown = '';
        let pillarDetails = '';
        let authorityBreakdown = '';
        let authorityDetails = '';
        let authorityModeToggle = '';
        
        // Get saved audit data for breakdown calculations (reuse saved from function start to avoid redeclaration)
        // Use schemaAudit parameter if available, otherwise fall back to saved
        const schemaAuditData = schemaAudit || saved?.schemaAudit;
        const searchDataForBreakdown = data || saved?.searchData;
        // Note: hasLocalSignals and localSignalsData are already defined at function level (line 3688-3689), reuse them
        
        if (key === 'authority') {
          const savedAudit = loadAuditResultsSync();
          // Try multiple sources for backlinkMetrics: savedAudit, then localStorage
          // Note: API call removed from here since forEach doesn't support async properly
          // Backlink metrics should be loaded during audit run and saved to savedAudit
          let backlinkMetrics = savedAudit?.backlinkMetrics || null;
          if (!backlinkMetrics) {
            try {
              const storedMetrics = localStorage.getItem('backlink_metrics');
              if (storedMetrics) {
                backlinkMetrics = JSON.parse(storedMetrics);
                window.latestBacklinkMetrics = backlinkMetrics;
                debugLog(' Backlink metrics loaded from localStorage for Authority card', 'info');
              }
            } catch (e) {
              debugLog(` Error reading backlink metrics from localStorage: ${e.message}`, 'warn');
            }
          }
          if (!backlinkMetrics && window.latestBacklinkMetrics) {
            backlinkMetrics = window.latestBacklinkMetrics;
            debugLog(' Using cached backlink metrics for Authority card', 'info');
          }
          // Use currentLocalSignals from displayDashboard parameter, or fallback to savedAudit
          const localSignals = currentLocalSignals || savedAudit?.localSignals || null;
          // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
          const siteReviews = getTrustpilotSnapshot(savedAudit?.siteReviews);
          const searchData = savedAudit?.searchData;
          
          // Authority mode state (stored per card instance)
          const modeId = `authority-mode-${Date.now()}`;
          let currentMode = 'all'; // Default mode
          
          // Get selected Authority scores based on mode
          const getAuthorityForMode = (mode) => {
            if (authorityBySegment && authorityBySegment[mode]) {
              return authorityBySegment[mode];
            }
            // Fallback to all or legacy structure
            if (authorityBySegment && authorityBySegment.all) {
              return authorityBySegment.all;
            }
            // Legacy fallback - ensure we use actual calculated scores, not 0
            const components = scores.authorityComponents || {};
            // CRITICAL: If components are all 0 but we have a total score, try to extract from authority object
            const hasValidComponents = (components.behaviour || components.ranking || components.backlinks || components.reviews) > 0;
            if (!hasValidComponents && scores.authority && typeof scores.authority === 'object') {
              // Try to get from authority object if it has component scores
              const authObj = scores.authority;
              return {
                total: score,
                behaviour: authObj.behaviour || components.behaviour || 0,
                ranking: authObj.ranking || components.ranking || 0,
                backlinks: authObj.backlinks || components.backlinks || 0,
                reviews: authObj.reviews || components.reviews || 0
              };
            }
            return {
              total: score,
              behaviour: components.behaviour !== undefined ? components.behaviour : 0,
              ranking: components.ranking !== undefined ? components.ranking : 0,
              backlinks: components.backlinks !== undefined ? components.backlinks : 0,
              reviews: components.reviews !== undefined ? components.reviews : 0
            };
          };
          
          // Get current Authority data
          let selectedAuthority = getAuthorityForMode(currentMode);
          
          // DEBUG: Log authority components and backlink metrics
          debugLog(`[Authority Card] Current authority components: ${JSON.stringify(selectedAuthority)}`, 'info');
          debugLog(`[Authority Card] Scores authorityComponents: ${JSON.stringify(scores.authorityComponents)}`, 'info');
          
          // Build mode toggle UI (only if bySegment is available)
          if (authorityBySegment) {
            authorityModeToggle = `
              <div class="authority-mode-toggle" style="margin-top: 0.5rem; margin-bottom: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem;">
                <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                  <span style="font-weight: 600; color: #666;">Mode:</span>
                  <button id="${modeId}-all" class="authority-mode-btn" data-mode="all" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: #10b981; color: white; cursor: pointer; font-size: 0.75rem;">
                    All pages
                  </button>
                  <button id="${modeId}-nonEducation" class="authority-mode-btn" data-mode="nonEducation" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
                    Exclude education
                  </button>
                  <button id="${modeId}-money" class="authority-mode-btn" data-mode="money" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
                    Money pages only
                  </button>
                </div>
              </div>
            `;
          }
          
          // Build breakdown display with color-coded scores (will be updated by mode toggle)
          const updateAuthorityDisplay = () => {
            const mode = card._authorityMode || currentMode;
            selectedAuthority = getAuthorityForMode(mode);
            const breakdownDiv = document.getElementById(`${modeId}-breakdown`);
            const scoreDiv = document.getElementById(`${modeId}-score`);
            if (breakdownDiv) {
              breakdownDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('Behaviour', selectedAuthority.behaviour)}
                  ${formatComponentScore('Ranking', selectedAuthority.ranking)}
                  ${formatComponentScore('Backlinks', selectedAuthority.backlinks)}
                  ${formatComponentScore('Reviews', selectedAuthority.reviews)}
                </div>
              `;
            }
            if (scoreDiv) {
              scoreDiv.textContent = Math.round(selectedAuthority.total);
              const newRag = getRAGStatus(selectedAuthority.total);
              scoreDiv.className = `pillar-score rag-${newRag.status}`;
            }
          };
          
          // Initial breakdown (with consistent spacing for alignment)
          authorityBreakdown = `
            <div id="${modeId}-breakdown" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                ${formatComponentScore('Behaviour', selectedAuthority.behaviour)}
                ${formatComponentScore('Ranking', selectedAuthority.ranking)}
                ${formatComponentScore('Backlinks', selectedAuthority.backlinks)}
                ${formatComponentScore('Reviews', selectedAuthority.reviews)}
              </div>
            </div>
          `;
          
          // Store update function for mode toggle handlers
          card._updateAuthorityDisplay = updateAuthorityDisplay;
          card._authorityMode = currentMode;
          card._authorityBySegment = authorityBySegment;
          card._modeId = modeId;
          
          // Build details panel (hidden by default, toggled by button)
          const detailsId = `authority-details-${Date.now()}`;
          const buttonId = `authority-details-btn-${Date.now()}`;
          
          // Get GSC metrics for details (segment-aware)
          // Store queryPages and searchData on card for access in update functions
          card._queryPages = searchData?.queryPages || [];
          card._topQueries = searchData?.topQueries || [];
          const queryPages = card._queryPages;
          const topQueries = card._topQueries;
          
          // Function to calculate GSC metrics for a specific segment
          const getGSCMetricsForSegment = (mode, queryPagesData, topQueriesData) => {
            let dataToUse = [];
            
            // Use the passed data (from card storage) to ensure we have latest
            const qp = queryPagesData || queryPages;
            const tq = topQueriesData || topQueries;
            
            if (qp && qp.length > 0) {
              // Use queryPages with segmentation
              let filtered = qp;
              if (mode === 'nonEducation') {
                filtered = qp.filter(row => {
                  const segment = classifyPageSegment(row.page || row.url || '/');
                  return segment !== PageSegment.EDUCATION;
                });
              } else if (mode === 'money') {
                filtered = qp.filter(row => {
                  const segment = classifyPageSegment(row.page || row.url || '/');
                  return segment === PageSegment.MONEY;
                });
              }
              
              debugLog(` GSC Metrics for ${mode}: Filtered ${filtered.length} rows from ${qp.length} total queryPages`, 'info');
              
              // Convert to query format for calculation
              dataToUse = filtered.map(row => ({
                query: row.query || '',
                clicks: row.clicks || 0,
                impressions: row.impressions || 0,
                ctr: (row.ctr || 0) / 100,
                position: row.position || 0
              }));
            } else {
              // Fallback to topQueries (all pages)
              dataToUse = tq.map(q => ({
                query: q.query || '',
                clicks: q.clicks || 0,
                impressions: q.impressions || 0,
                ctr: (q.ctr || 0) / 100,
                position: q.position || 0
              }));
            }
            
            const rankingQueries = dataToUse.filter(q => q.position > 0 && q.position <= 20 && q.impressions > 0);
            const top10Queries = rankingQueries.filter(q => q.position <= 10);
            
            let siteCtr = 0;
            let top10Ctr = 0;
            let avgPosition = 0;
            let top10ImpressionShare = 0;
            
            if (rankingQueries.length > 0) {
              const totalClicks = rankingQueries.reduce((s, q) => s + (q.clicks || 0), 0);
              const totalImpr = rankingQueries.reduce((s, q) => s + (q.impressions || 0), 0);
              siteCtr = totalImpr > 0 ? (totalClicks / totalImpr) * 100 : 0;
              
              const top10Clicks = top10Queries.reduce((s, q) => s + (q.clicks || 0), 0);
              const top10Impr = top10Queries.reduce((s, q) => s + (q.impressions || 0), 0);
              top10Ctr = top10Impr > 0 ? (top10Clicks / top10Impr) * 100 : 0;
              
              avgPosition = totalImpr > 0
                ? rankingQueries.reduce((s, q) => s + (q.position || 0) * (q.impressions || 0), 0) / totalImpr
                : 0;
              
              top10ImpressionShare = totalImpr > 0 ? (top10Impr / totalImpr) * 100 : 0;
            }
            
            return { siteCtr, top10Ctr, avgPosition, top10ImpressionShare };
          };
          
          // Get initial metrics (all pages)
          let gscMetrics = getGSCMetricsForSegment(currentMode, queryPages, topQueries);
          let siteCtr = gscMetrics.siteCtr;
          let top10Ctr = gscMetrics.top10Ctr;
          let avgPosition = gscMetrics.avgPosition;
          let top10ImpressionShare = gscMetrics.top10ImpressionShare;
          
          // Function to update GSC metrics display
          const updateGSCMetrics = (mode) => {
            // Get fresh data from card storage
            const qp = card._queryPages || [];
            const tq = card._topQueries || [];
            const metrics = getGSCMetricsForSegment(mode, qp, tq);
            const metricsDiv = document.getElementById(`${modeId}-gsc-metrics`);
            if (metricsDiv) {
              const siteCtrStr = (metrics.siteCtr != null && typeof metrics.siteCtr === 'number' && !isNaN(metrics.siteCtr)) ? metrics.siteCtr.toFixed(2) : 'N/A';
              const avgPosStr = (metrics.avgPosition != null && typeof metrics.avgPosition === 'number' && !isNaN(metrics.avgPosition)) ? metrics.avgPosition.toFixed(1) : 'N/A';
              debugLog(` Updating GSC metrics for mode ${mode}: CTR=${siteCtrStr}%, Position=${avgPosStr}`, 'info');
              const top10CtrStr = (metrics.top10Ctr != null && typeof metrics.top10Ctr === 'number' && !isNaN(metrics.top10Ctr)) ? metrics.top10Ctr.toFixed(2) : 'N/A';
              const top10ShareStr = (metrics.top10ImpressionShare != null && typeof metrics.top10ImpressionShare === 'number' && !isNaN(metrics.top10ImpressionShare)) ? metrics.top10ImpressionShare.toFixed(1) : 'N/A';
              metricsDiv.innerHTML = `
                <div style="margin-bottom: 0.5rem;"><strong>Behaviour & Ranking:</strong></div>
                <div style="margin-bottom: 0.25rem; font-size: 0.7rem; color: #999;">Segment: ${mode === 'all' ? 'All pages' : mode === 'nonEducation' ? 'Exclude education (blogs / free course)' : 'Money pages only'}</div>
                <div>Site CTR (ranking queries): ${siteCtrStr}%</div>
                <div>Top-10 CTR: ${top10CtrStr}%</div>
                <div>Avg position (ranking): ${avgPosStr}</div>
                <div>Top-10 impression share: ${top10ShareStr}%</div>
              `;
            } else {
              debugLog(` GSC metrics div not found: ${modeId}-gsc-metrics`, 'warn');
            }
          };
          
          // Store update function and data
          card._updateGSCMetrics = updateGSCMetrics;
          card._getGSCMetricsForSegment = getGSCMetricsForSegment;
          
          // Get review data - check multiple possible data structures
          let gbpRating = null;
          let gbpReviewCount = null;
          
          if (localSignals) {
            // Handle both direct data structure and wrapped response structure
            const signalsStatus = localSignals.status;
            const signalsData = localSignals.data
              || (localSignals && typeof localSignals === 'object' && !localSignals.status ? localSignals : null);
            const hasGbpFallback = signalsData && (signalsData.gbpRating != null || signalsData.gbpReviewCount != null);
            const canUseSignals = !!signalsData && (signalsStatus === 'ok' || hasGbpFallback || signalsStatus == null);
            
            debugLog(`[Authority Card] Local signals status: ${signalsStatus}, has data: ${!!signalsData}, structure: ${JSON.stringify(Object.keys(localSignals))}`, 'info');
            
            if (canUseSignals) {
              // Enhanced logging for GBP data
              debugLog(`[Authority Card] signalsData keys: ${Object.keys(signalsData).join(', ')}`, 'info');
              debugLog(`[Authority Card] signalsData.gbpRating raw: ${JSON.stringify(signalsData.gbpRating)} (type: ${typeof signalsData.gbpRating})`, 'info');
              debugLog(`[Authority Card] signalsData.gbpReviewCount raw: ${JSON.stringify(signalsData.gbpReviewCount)} (type: ${typeof signalsData.gbpReviewCount})`, 'info');
              
              gbpRating = signalsData.gbpRating !== null && signalsData.gbpRating !== undefined 
                ? signalsData.gbpRating 
                : null;
              gbpReviewCount = signalsData.gbpReviewCount !== null && signalsData.gbpReviewCount !== undefined 
                ? signalsData.gbpReviewCount 
                : null;
              debugLog(`[Authority Card] GBP data extracted: rating=${gbpRating}, count=${gbpReviewCount}`, gbpRating !== null ? 'info' : 'warn');
            } else {
              debugLog(`[Authority Card] Local signals not OK or missing data. Status: ${signalsStatus}, data keys: ${signalsData ? Object.keys(signalsData).join(', ') : 'no data'}, full object keys: ${Object.keys(localSignals).join(', ')}`, 'warn');
            }
          } else {
            debugLog(`[Authority Card] No localSignals available`, 'warn');
          }
          const siteRating = siteReviews?.siteRating !== null ? siteReviews?.siteRating : null;
          const siteReviewCount = siteReviews?.siteReviewCount !== null ? siteReviews?.siteReviewCount : null;
          
          authorityDetails = `
            <div style="margin-top: 0.5rem;">
              <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                Show details
              </button>
              <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                <div id="${modeId}-gsc-metrics">
                  <div style="margin-bottom: 0.5rem;"><strong>Behaviour & Ranking:</strong></div>
                  <div style="margin-bottom: 0.25rem; font-size: 0.7rem; color: #999;">Segment: ${currentMode === 'all' ? 'All pages' : currentMode === 'nonEducation' ? 'Exclude education (blogs / free course)' : 'Money pages only'}</div>
                  <div>Site CTR (ranking queries): ${(siteCtr != null && typeof siteCtr === 'number' && !isNaN(siteCtr)) ? siteCtr.toFixed(1) : 'N/A'}%</div>
                  <div>Top-10 CTR: ${(top10Ctr != null && typeof top10Ctr === 'number' && !isNaN(top10Ctr)) ? top10Ctr.toFixed(1) : 'N/A'}%</div>
                  <div>Avg position (ranking): ${(avgPosition != null && typeof avgPosition === 'number' && !isNaN(avgPosition)) ? avgPosition.toFixed(1) : 'N/A'}</div>
                  <div>Top-10 impression share: ${(top10ImpressionShare != null && typeof top10ImpressionShare === 'number' && !isNaN(top10ImpressionShare)) ? top10ImpressionShare.toFixed(1) : 'N/A'}%</div>
                </div>
                ${(() => {
                  // Use authorityComponents.backlinks to determine if backlinks exist
                  // Also try to get backlinkMetrics for detailed display if available
                  const hasBacklinkScore = selectedAuthority.backlinks > 0 || (scores.authorityComponents && scores.authorityComponents.backlinks > 0);
                  const hasBacklinkMetrics = backlinkMetrics && (backlinkMetrics.referringDomains > 0 || backlinkMetrics.totalBacklinks > 0);
                  
                  // Only show "No backlink data uploaded" if both score and metrics are missing
                  if (!hasBacklinkScore && !hasBacklinkMetrics) {
                    return `
                      <div style="margin-top: 0.75rem; margin-bottom: 0.5rem;"><strong>Backlink Metrics:</strong></div>
                      <div>No backlink data uploaded</div>
                    `;
                  }
                  
                  // Show backlink metrics if available, otherwise show score-based info
                  if (hasBacklinkMetrics) {
                    return `
                      <div style="margin-top: 0.75rem; margin-bottom: 0.5rem;"><strong>Backlink Metrics:</strong></div>
                      <div>Referring domains: ${backlinkMetrics.referringDomains || 0}</div>
                      <div>Total backlinks: ${backlinkMetrics.totalBacklinks || 0}</div>
                      <div>Follow ratio: ${backlinkMetrics.followRatio ? Math.round(backlinkMetrics.followRatio * 100) : 50}%</div>
                      <div style="margin-top: 0.25rem; font-size: 0.7rem; color: #999;">Backlink score: ${(selectedAuthority && typeof selectedAuthority.backlinks === 'number' && !isNaN(selectedAuthority.backlinks)) ? selectedAuthority.backlinks.toFixed(0) : '0'}</div>
                    `;
                  } else {
                    const backlinksScore = (selectedAuthority && typeof selectedAuthority.backlinks === 'number' && !isNaN(selectedAuthority.backlinks)) ? selectedAuthority.backlinks : 0;
                    return `
                      <div style="margin-top: 0.75rem; margin-bottom: 0.5rem;"><strong>Backlink Metrics:</strong></div>
                      <div>Backlink score: ${(backlinksScore !== null && typeof backlinksScore === 'number' && !isNaN(backlinksScore)) ? backlinksScore.toFixed(0) : '0'}</div>
                      <div style="font-size: 0.7rem; color: #999;">Detailed metrics not available</div>
                    `;
                  }
                })()}
                <div style="margin-top: 0.75rem; margin-bottom: 0.5rem;"><strong>Review Metrics:</strong></div>
                <div>GBP rating: ${(gbpRating !== null && typeof gbpRating === 'number' && !isNaN(gbpRating)) ? gbpRating.toFixed(2) : 'N/A'} (${gbpReviewCount !== null ? gbpReviewCount : 'N/A'} reviews)</div>
                <div>Trustpilot (snapshot): ${(siteRating !== null && typeof siteRating === 'number' && !isNaN(siteRating)) ? siteRating.toFixed(2) : 'N/A'} (${siteReviewCount !== null ? siteReviewCount : 'N/A'} reviews)</div>
              </div>
            </div>
          `;
          
          // Store topPages data on card for access in update functions
          card._topPages = {
            all: authorityBySegment?.all?.topPages || [],
            nonEducation: authorityBySegment?.nonEducation?.topPages || [],
            money: authorityBySegment?.money?.topPages || []
          };
          
          // Function to render top pages table
          function renderTopPagesTable(mode, authorityBySegment) {
            const topPages = mode === 'all' 
              ? (authorityBySegment?.all?.topPages || [])
              : mode === 'nonEducation'
              ? (authorityBySegment?.nonEducation?.topPages || [])
              : (authorityBySegment?.money?.topPages || []);
            
            if (!topPages || topPages.length === 0) {
              return '<div style="font-size: 0.75rem; color: #999;">No page data available for this segment.</div>';
            }
            
            const segmentLabel = mode === 'all' 
              ? 'All pages'
              : mode === 'nonEducation'
              ? 'Exclude education (blogs / free course)'
              : 'Money pages only';
            
            const copyButtonId = `${modeId}-copy-urls`;
            
            let tableHtml = `
              <div style="margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                <h4 style="margin: 0; font-size: 0.95rem; font-weight: 600;">Top pages in this segment (by impressions)</h4>
                <button id="${copyButtonId}" type="button" style="font-size: 0.8rem; padding: 0.35rem 0.6rem; border-radius: 4px; border: 1px solid #ddd; background: white; cursor: pointer; color: #666;">
                  Copy URLs
                </button>
              </div>
              <p style="margin: 0 0 0.5rem 0; font-size: 0.75rem; color: #999;">Segment: ${segmentLabel}</p>
              <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse; font-size: 0.75rem;">
                  <thead>
                    <tr style="border-bottom: 1px solid #e2e8f0;">
                      <th style="text-align: left; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">#</th>
                      <th style="text-align: left; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">URL</th>
                      <th style="text-align: right; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">CTR</th>
                      <th style="text-align: right; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">Impr.</th>
                      <th style="text-align: right; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">Clicks</th>
                      <th style="text-align: right; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">Avg pos.</th>
                    </tr>
                  </thead>
                  <tbody>
            `;
            
            topPages.forEach((page, idx) => {
              // CRITICAL FIX: Add defensive checks for null/undefined and ensure values are numbers before calling toFixed
              const ctrValue = (page && typeof page.ctr === 'number' && !isNaN(page.ctr)) ? page.ctr : null;
              const posValue = (page && typeof page.avgPosition === 'number' && !isNaN(page.avgPosition)) ? page.avgPosition : null;
              const ctrStr = ctrValue !== null ? ctrValue.toFixed(1) : 'N/A';
              const posStr = posValue !== null ? posValue.toFixed(1) : 'N/A';
              const impressionsStr = (page && page.impressions != null) ? page.impressions.toLocaleString() : 'N/A';
              const clicksStr = (page && page.clicks != null) ? page.clicks.toLocaleString() : 'N/A';
              tableHtml += `
                <tr style="border-bottom: 1px solid #f1f5f9;">
                  <td style="padding: 0.25rem 0.4rem; color: #666;">${idx + 1}</td>
                  <td style="padding: 0.25rem 0.4rem; word-break: break-all; color: #333;">${page.url || 'N/A'}</td>
                  <td style="padding: 0.25rem 0.4rem; text-align: right; color: #666;">${ctrStr}%</td>
                  <td style="padding: 0.25rem 0.4rem; text-align: right; color: #666;">${impressionsStr}</td>
                  <td style="padding: 0.25rem 0.4rem; text-align: right; color: #666;">${clicksStr}</td>
                  <td style="padding: 0.25rem 0.4rem; text-align: right; color: #666;">${posStr}</td>
                </tr>
              `;
            });
            
            tableHtml += `
                  </tbody>
                </table>
              </div>
            `;
            
            // Store copy button ID and current mode for later event handler attachment
            card._copyButtonId = copyButtonId;
            card._topPagesForCopy = topPages;
            card._currentTopPagesMode = mode;
            
            return tableHtml;
          }
          
          // Function to update top pages table when mode changes
          const updateTopPagesTable = (mode) => {
            const topPagesDiv = document.getElementById(`${modeId}-top-pages`);
            if (topPagesDiv && authorityBySegment) {
              topPagesDiv.innerHTML = renderTopPagesTable(mode, authorityBySegment);
              
              // Re-attach copy button handler
              setTimeout(() => {
                const copyBtn = document.getElementById(card._copyButtonId);
                if (copyBtn) {
                  // Remove existing listener if any
                  const newCopyBtn = copyBtn.cloneNode(true);
                  copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
                  
                  newCopyBtn.addEventListener('click', async () => {
                    const currentTopPages = mode === 'all'
                      ? (authorityBySegment?.all?.topPages || [])
                      : mode === 'nonEducation'
                      ? (authorityBySegment?.nonEducation?.topPages || [])
                      : (authorityBySegment?.money?.topPages || []);
                    
                    const text = currentTopPages.map(p => p.url).join('\n');
                    try {
                      await navigator.clipboard.writeText(text);
                      newCopyBtn.textContent = 'Copied!';
                      newCopyBtn.style.color = '#10b981';
                      setTimeout(() => {
                        newCopyBtn.textContent = 'Copy URLs';
                        newCopyBtn.style.color = '#666';
                      }, 2000);
                    } catch (err) {
                      console.error('Failed to copy URLs:', err);
                      newCopyBtn.textContent = 'Copy failed';
                      setTimeout(() => {
                        newCopyBtn.textContent = 'Copy URLs';
                      }, 2000);
                    }
                  });
                }
              }, 0);
            }
          };
          
          // Store update function
          card._updateTopPagesTable = updateTopPagesTable;
          
          // Add click handlers for details toggle and mode toggle
          setTimeout(() => {
            const btn = document.getElementById(buttonId);
            const details = document.getElementById(detailsId);
            if (btn && details) {
              btn.addEventListener('click', () => {
                const isVisible = details.style.display !== 'none';
                details.style.display = isVisible ? 'none' : 'block';
                btn.textContent = isVisible ? 'Show details' : 'Hide details';
              });
            }
            
            // Add initial copy button handler
            const copyBtn = document.getElementById(card._copyButtonId);
            if (copyBtn) {
              copyBtn.addEventListener('click', async () => {
                const currentTopPages = currentMode === 'all'
                  ? (authorityBySegment?.all?.topPages || [])
                  : currentMode === 'nonEducation'
                  ? (authorityBySegment?.nonEducation?.topPages || [])
                  : (authorityBySegment?.money?.topPages || []);
                
                const text = currentTopPages.map(p => p.url).join('\n');
                try {
                  await navigator.clipboard.writeText(text);
                  copyBtn.textContent = 'Copied!';
                  copyBtn.style.color = '#10b981';
                  setTimeout(() => {
                    copyBtn.textContent = 'Copy URLs';
                    copyBtn.style.color = '#666';
                  }, 2000);
                } catch (err) {
                  console.error('Failed to copy URLs:', err);
                  copyBtn.textContent = 'Copy failed';
                  setTimeout(() => {
                    copyBtn.textContent = 'Copy URLs';
                  }, 2000);
                }
              });
            }
            
            // Add mode toggle handlers
            if (authorityBySegment) {
              ['all', 'nonEducation', 'money'].forEach(mode => {
                const modeBtn = document.getElementById(`${modeId}-${mode}`);
                if (modeBtn) {
                  modeBtn.addEventListener('click', () => {
                    // Update current mode
                    currentMode = mode;
                    card._authorityMode = mode;
                    
                    // Update button styles
                    ['all', 'nonEducation', 'money'].forEach(m => {
                      const btn = document.getElementById(`${modeId}-${m}`);
                      if (btn) {
                        if (m === mode) {
                          btn.style.background = '#10b981';
                          btn.style.color = 'white';
                        } else {
                          btn.style.background = 'white';
                          btn.style.color = '#666';
                        }
                      }
                    });
                    
                    // Update Authority score and breakdown
                    if (card._updateAuthorityDisplay) {
                      card._updateAuthorityDisplay();
                    }
                    
                    // Update GSC metrics
                    if (card._updateGSCMetrics) {
                      card._updateGSCMetrics(mode);
                    }
                    
                    // Update top pages section (full width, below pillars)
                    window.currentAuthorityMode = mode;
                    if (window.updateTopPagesSection) {
                      window.updateTopPagesSection(mode);
                    }
                    
                    debugLog(` Authority mode changed to: ${mode === 'all' ? 'All pages' : mode === 'nonEducation' ? 'Exclude education' : 'Money pages only'}`, 'info');
                  });
                }
              });
            }
          }, 0);
        }
        
        // Build breakdown and details for other pillars (Content/Schema, Visibility, Local Entity, Service Area)
        if (key !== 'authority') {
          const breakdownId = `${key}-breakdown-${Date.now()}`;
          const detailsId = `${key}-details-${Date.now()}`;
          const buttonId = `${key}-details-btn-${Date.now()}`;
          
          if (key === 'contentSchema' && schemaAuditData && schemaAuditData.status === 'ok' && schemaAuditData.data) {
            const schemaData = schemaAuditData.data;
            const allTypes = new Set();
            
            // PRIORITY: Use foundation object first (most reliable source)
            if (schemaData.foundation && typeof schemaData.foundation === 'object') {
              Object.keys(schemaData.foundation).forEach(type => {
                if (schemaData.foundation[type] === true) {
                  allTypes.add(type);
                }
              });
            }
            
            // Also add types from allDetectedTypes if available (for complete type list)
            if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
              schemaData.allDetectedTypes.forEach(type => { if (type) allTypes.add(type); });
            }
            
            // Also add from richEligible for complete type list
            if (schemaData.richEligible && typeof schemaData.richEligible === 'object') {
              Object.keys(schemaData.richEligible).forEach(type => {
                if (schemaData.richEligible[type] === true) {
                  allTypes.add(type);
                }
              });
            }
            
            // Fallback: collect from schemaTypes array (but filter out page objects)
            if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
              schemaData.schemaTypes.forEach(item => {
                // Skip page objects (have 'url' property) - these are NOT schema types
                if (item && typeof item === 'object' && item.url) {
                  return; // Skip page objects
                }
                // Only process valid schema type objects or strings
                if (typeof item === 'string') {
                  allTypes.add(item);
                } else if (item && typeof item === 'object' && item.type && typeof item.type === 'string' && !item.url) {
                  allTypes.add(item.type);
                }
              });
            }
            
            // Foundation detection: Use foundation object directly (most reliable)
            const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
            let foundationPresent = 0;
            if (schemaData.foundation && typeof schemaData.foundation === 'object') {
              // Use foundation object directly - count how many are true
              foundationPresent = foundationTypes.filter(type => schemaData.foundation[type] === true).length;
            } else {
              // Fallback: check allTypes set
              foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
            }
            const foundationScore = (foundationPresent / foundationTypes.length) * 100;
            
            const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
            const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
            const richResultScore = (richEligibleCount / richResultTypes.length) * 100;
            
            const coverageScore = schemaData.coverage || 0;
            const uniqueTypesCount = allTypes.size;
            const diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
            
            // Get schema types list for display (properly formatted to avoid [object Object])
            let schemaTypesList = [];
            if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
              schemaTypesList = schemaData.allDetectedTypes.slice(0, 20).filter(t => t && typeof t === 'string');
            } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
              schemaTypesList = schemaData.schemaTypes
                .filter(t => {
                  // Skip null/undefined
                  if (!t) return false;
                  // Skip page objects (have 'url' property) - these are pages, not types!
                  if (typeof t === 'object' && ('url' in t || ('title' in t && 'metaDescription' in t))) return false;
                  // Only keep valid type objects or strings
                  return typeof t === 'string' || (typeof t === 'object' && t.type && typeof t.type === 'string' && !t.url);
                })
                .map(t => {
                  if (typeof t === 'string') return t.trim();
                  if (t && typeof t === 'object' && t.type && typeof t.type === 'string') {
                    return `${t.type}${t.count ? ` (${t.count})` : ''}`;
                  }
                  return null;
                })
                .filter(t => t !== null && t !== undefined && t !== '' && typeof t === 'string')
                .slice(0, 20);
            }
            const schemaTypesDisplay = schemaTypesList.length > 0 ? schemaTypesList.join(', ') : 'None detected';
            
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('Foundation', foundationScore)}
                  ${formatComponentScore('Rich Results', richResultScore)}
                  ${formatComponentScore('Coverage', coverageScore)}
                  ${formatComponentScore('Diversity', diversityScore)}
                </div>
              </div>
            `;
            
            pillarDetails = `
              <div style="margin-top: 0.5rem;">
                <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                  Show details
                </button>
                <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                  <div style="margin-bottom: 0.5rem;"><strong>Schema Details:</strong></div>
                  <div>Foundation schemas: ${foundationPresent}/4 (${foundationTypes.filter(t => (schemaData.foundation && schemaData.foundation[t] === true) || allTypes.has(t)).join(', ') || 'none'})</div>
                  <div>Rich result types: ${richEligibleCount}/${richResultTypes.length} eligible</div>
                  <div>Coverage: ${coverageScore != null ? coverageScore.toFixed(1) : 'N/A'}% (${Array.isArray(schemaData.pagesWithSchema) ? schemaData.pagesWithSchema.length : (typeof schemaData.pagesWithSchema === 'number' ? schemaData.pagesWithSchema : 0)}/${Array.isArray(schemaData.pages) ? schemaData.pages.length : (typeof schemaData.totalPages === 'number' ? schemaData.totalPages : (Array.isArray(schemaData.pages) ? schemaData.pages.length : 0))} pages)</div>
                  <div>Type diversity: ${uniqueTypesCount} unique types</div>
                  <div style="margin-top: 0.5rem;"><strong>Schema types found:</strong> ${schemaTypesDisplay}${schemaTypesList.length >= 20 ? '...' : ''}</div>
                </div>
              </div>
            `;
            
            setTimeout(() => {
              const btn = document.getElementById(buttonId);
              const details = document.getElementById(detailsId);
              if (btn && details) {
                btn.addEventListener('click', () => {
                  const isVisible = details.style.display !== 'none';
                  details.style.display = isVisible ? 'none' : 'block';
                  btn.textContent = isVisible ? 'Show details' : 'Hide details';
                });
              }
            }, 0);
          } else if (key === 'visibility' && searchDataForBreakdown) {
            const avgPos = searchDataForBreakdown.averagePosition || 40;
            const clampedPos = Math.max(1, Math.min(40, avgPos));
            const scale = (clampedPos - 1) / 39;
            const posScore = 100 - scale * 90;
            
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('Position', clampScore(posScore))}
                  ${formatComponentScore('CTR', Math.min((searchDataForBreakdown.ctr || 0) / 0.10 * 100, 100))}
                </div>
              </div>
            `;
            
            pillarDetails = `
              <div style="margin-top: 0.5rem;">
                <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                  Show details
                </button>
                <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                  <div style="margin-bottom: 0.5rem;"><strong>GSC Metrics:</strong></div>
                  <div>Average position: ${avgPos != null ? avgPos.toFixed(1) : 'N/A'}</div>
                  <div>CTR: ${(searchDataForBreakdown.ctr || 0).toFixed(1)}%</div>
                  <div>Total clicks: ${(searchDataForBreakdown.totalClicks || 0).toLocaleString()}</div>
                  <div>Total impressions: ${(searchDataForBreakdown.totalImpressions || 0).toLocaleString()}</div>
                </div>
              </div>
            `;
            
            setTimeout(() => {
              const btn = document.getElementById(buttonId);
              const details = document.getElementById(detailsId);
              if (btn && details) {
                btn.addEventListener('click', () => {
                  const isVisible = details.style.display !== 'none';
                  details.style.display = isVisible ? 'none' : 'block';
                  btn.textContent = isVisible ? 'Show details' : 'Hide details';
                });
              }
            }, 0);
          } else if (key === 'localEntity' && pillarHasLocalSignals && pillarLocalSignalsData) {
            // DEBUG: Log locations data structure
            debugLog(`[Local Entity Card] pillarLocalSignalsData keys: ${Object.keys(pillarLocalSignalsData).join(', ')}`, 'info');
            debugLog(`[Local Entity Card] locations type: ${typeof pillarLocalSignalsData.locations}, isArray: ${Array.isArray(pillarLocalSignalsData.locations)}, length: ${pillarLocalSignalsData.locations?.length || 0}`, 'info');
            if (pillarLocalSignalsData.locations && pillarLocalSignalsData.locations.length > 0) {
              debugLog(`[Local Entity Card] First location: ${JSON.stringify(pillarLocalSignalsData.locations[0]).substring(0, 200)}`, 'info');
            } else {
              debugLog(`[Local Entity Card]  locations is missing or empty!`, 'warn');
            }
            const napScore = pillarLocalSignalsData.napConsistencyScore || 0;
            const knowledgePanelScore = pillarLocalSignalsData.knowledgePanelDetected ? 100 : 0;
            const locationsScore = (pillarLocalSignalsData.locations?.length || 0) > 0 ? 100 : 0;
            
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('NAP Consistency', napScore)}
                  ${formatComponentScore('Knowledge Panel', knowledgePanelScore)}
                  ${formatComponentScore('Locations', locationsScore)}
                </div>
              </div>
            `;
            
            pillarDetails = `
              <div style="margin-top: 0.5rem;">
                <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                  Show details
                </button>
                <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                  <div style="margin-bottom: 0.5rem;"><strong>Business Profile Data:</strong></div>
                  <div>NAP consistency: ${napScore}%</div>
                  <div>Knowledge panel: ${pillarLocalSignalsData.knowledgePanelDetected ? 'detected' : 'not detected'}</div>
                  <div>Locations: ${pillarLocalSignalsData.locations?.length || 0}</div>
                </div>
              </div>
            `;
            
            setTimeout(() => {
              const btn = document.getElementById(buttonId);
              const details = document.getElementById(detailsId);
              if (btn && details) {
                btn.addEventListener('click', () => {
                  const isVisible = details.style.display !== 'none';
                  details.style.display = isVisible ? 'none' : 'block';
                  btn.textContent = isVisible ? 'Show details' : 'Hide details';
                });
              }
            }, 0);
          } else if (key === 'serviceArea' && pillarHasLocalSignals && pillarLocalSignalsData) {
            const serviceAreasCount = pillarLocalSignalsData.serviceAreas?.length || 0;
            const serviceAreasScore = serviceAreasCount >= 8 ? 100 : Math.min(100, serviceAreasCount * 12.5);
            const napScore = pillarLocalSignalsData.napConsistencyScore || 0;
            
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('Service Areas', serviceAreasScore)}
                  ${formatComponentScore('NAP Consistency', napScore)}
                </div>
              </div>
            `;
            
            pillarDetails = `
              <div style="margin-top: 0.5rem;">
                <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                  Show details
                </button>
                <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                  <div style="margin-bottom: 0.5rem;"><strong>Service Area Data:</strong></div>
                  <div>Service areas: ${serviceAreasCount}</div>
                  <div>NAP consistency: ${napScore}%</div>
                </div>
              </div>
            `;
            
            setTimeout(() => {
              const btn = document.getElementById(buttonId);
              const details = document.getElementById(detailsId);
              if (btn && details) {
                btn.addEventListener('click', () => {
                  const isVisible = details.style.display !== 'none';
                  details.style.display = isVisible ? 'none' : 'block';
                  btn.textContent = isVisible ? 'Show details' : 'Hide details';
                });
              }
            }, 0);
          } else {
            // No breakdown available - add empty section for consistent spacing
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
              </div>
            `;
            pillarDetails = `
              <div style="margin-top: 0.5rem; min-height: 1.5rem;">
              </div>
            `;
          }
        }
        
        // Define pillar colors for consistency across all reports
        const pillarColors = {
          localEntity: 'rgba(147, 51, 234, 1)', // Purple
          serviceArea: '#00FFFF', // Cyan (not RAG color)
          authority: '#99004C', // Dark pink/magenta
          visibility: 'rgba(37, 99, 235, 1)', // Blue
          contentSchema: 'rgba(107, 114, 128, 1)' // Grey
        };
        
        const pillarColor = pillarColors[key] || '#666';
        
        card.innerHTML = `
          <div style="flex: 1; display: flex; flex-direction: column; position: relative;">
            <div style="position: absolute; top: 0; right: 0; width: 20px; height: 20px; background: ${pillarColor}; border-radius: 3px; border: 1px solid rgba(0,0,0,0.1);" title="Color key for ${pillarNames[key]} in all reports"></div>
          <h3>${pillarNames[key]}</h3>
            <div id="${key === 'authority' ? card._modeId + '-score' : ''}" class="pillar-score rag-${rag.status}">${Math.round(score)}</div>
          <div class="rag-badge ${rag.status}">${rag.label}</div>
          <p style="font-size: 0.85rem; color: #666; margin-top: 0.5rem; line-height: 1.5; flex-grow: 1;">${descriptions[key] || ''}</p>
            ${key === 'authority' ? authorityModeToggle : '<div style="min-height: 2.5rem;"></div>'}
            ${key === 'authority' ? authorityBreakdown : pillarBreakdown}
          </div>
          <div style="margin-top: auto;">
            ${key === 'authority' ? authorityDetails : pillarDetails}
          </div>
        `;
        pillarCards.appendChild(card);
        debugLog(` Added pillar card for ${key} (score: ${score})`, 'info');
      });
      
      debugLog(` Created ${orderedPillars.length} pillar cards total`, 'success');
      
      // Shared functions for Top Pages section (used by both createTopPagesSection functions)
      
      // Classification functions for metric status
      function classifySiteCtr(v) {
        // v is already a percentage (0-100), not a decimal
        if (v < 1) return 'poor';      // <1%
        if (v < 3) return 'ok';        // 1-3%
        return 'strong';                  // 3%+
      }
      
      function classifyTop10Ctr(v) {
        // v is already a percentage (0-100), not a decimal
        if (v < 2) return 'poor';      // <2%
        if (v < 5) return 'ok';        // 2-5%
        return 'strong';                  // 5%+
      }
      
      function classifyAvgPos(p) {
        if (p > 10) return 'poor';        // mostly bottom of page 1 / page 2
        if (p > 5) return 'ok';           // mid-page 1
        return 'strong';                  // positions 1-5
      }
      
      function classifyTop10Share(v) {
        // v is stored as decimal (0-1), needs to be converted to percentage for comparison
        const pct = v * 100;
        if (pct < 60) return 'poor';       // <60% of impressions in top 10
        if (pct < 80) return 'ok';         // 60-80%
        return 'strong';                  // 80%+
      }
      
      // Helper to format percentage
      // For CTR values: already percentages (0-100), just format
      // For top10Share: stored as decimal (0-1), convert to percentage
      function pct(v, isDecimal = false) {
        if (isDecimal) {
          return `${(v * 100).toFixed(2)}%`;
        }
        return `${v.toFixed(2)}%`;
      }
      
      // Helper to extract target value from target text
      function extractTargetValue(targetText, metricType) {
        if (metricType === 'ctr' || metricType === 'percentage') {
          // Extract range like "23%+" or "7585%+"
          const match = targetText.match(/(\d+(?:\.\d+)?)[-](\d+(?:\.\d+)?)%/);
          if (match) {
            const min = parseFloat(match[1]);
            const max = parseFloat(match[2]);
            return (min + max) / 2; // Return midpoint
          }
        } else if (metricType === 'position') {
          // Extract range like "36"
          const match = targetText.match(/(\d+(?:\.\d+)?)[-](\d+(?:\.\d+)?)/);
          if (match) {
            const min = parseFloat(match[1]);
            const max = parseFloat(match[2]);
            return (min + max) / 2; // Return midpoint
          }
        }
        return null;
      }
      
      // Build recommendation rows from segment metrics
      function buildBehaviourRankingRecommendations(segment, m) {
        const rows = [];
        
        // Site CTR recommendation
        const siteStatus = classifySiteCtr(m.siteCtr);
        const siteCurrent = m.siteCtr;
        const siteTargetText = 'Aim for 23%+ overall CTR';
        const siteTargetValue = extractTargetValue(siteTargetText, 'ctr'); // 2.5%
        const siteDiff = siteTargetValue ? (siteCurrent - siteTargetValue) : null; // Keep sign for display
        rows.push({
          metric: 'Overall CTR (all ranking queries)',
          status: siteStatus,
          value: pct(m.siteCtr),
          currentValue: siteCurrent,
          target: siteTargetText,
          targetValue: siteTargetValue,
          difference: siteDiff,
          action: siteStatus === 'poor'
            ? (segment === 'money'
                ? 'Rewrite titles and descriptions on the top money pages (table above). Add intent phrases ("workshop", "course", "near me") and stronger benefits to lift clicks for your money pages.'
                : 'Focus on high-impression pages with weak CTR in this segment. Tighten titles and descriptions so they clearly answer the search intent and highlight the benefit.')
            : siteStatus === 'ok'
            ? (segment === 'money'
                ? 'CTR is reasonable for your money pages. Prioritise the worst pages in the table above for A/B-style tests on titles and descriptions.'
                : 'CTR is reasonable for this segment. Prioritise the worst pages in the table above for A/B-style tests on titles and descriptions.')
            : 'CTR is strong for this segment. Keep monitoring but prioritise ranking and impression share improvements.'
        });
        
        // Top-10 CTR recommendation
        const top10Status = classifyTop10Ctr(m.top10Ctr);
        const top10Current = m.top10Ctr;
        const top10TargetText = 'Aim for 35%+ in top-10';
        const top10TargetValue = extractTargetValue(top10TargetText, 'ctr'); // 4%
        const top10Diff = top10TargetValue ? (top10Current - top10TargetValue) : null; // Keep sign for display
        rows.push({
          metric: 'Top-10 CTR (positions 110)',
          status: top10Status,
          value: pct(m.top10Ctr),
          currentValue: top10Current,
          target: top10TargetText,
          targetValue: top10TargetValue,
          difference: top10Diff,
          action: top10Status === 'poor'
            ? (segment === 'money'
                ? 'When your money pages are already in positions 110 but clicks are low, re-write titles/meta to be more specific: include location, level (beginner/advanced), and outcome ("learn to", "master").'
                : 'When you are already in positions 110 but clicks are low, re-write titles/meta to be more specific: include location, level (beginner/advanced), and outcome ("learn to", "master").')
            : top10Status === 'ok'
            ? (segment === 'money'
                ? 'Identify top-10 money pages with below-average CTR and iterate on their SERP snippet (titles, descriptions, rich results where available).'
                : 'Identify top-10 pages with below-average CTR and iterate on their SERP snippet (titles, descriptions, rich results where available).')
            : 'Top-10 CTR is healthy. Focus on pushing more queries into the top-10 (see avg position & top-10 share).'
        });
        
        // Average position recommendation
        const posStatus = classifyAvgPos(m.avgPosition);
        const posCurrent = m.avgPosition;
        const posTargetText = 'Aim for average position 36 on core queries';
        const posTargetValue = extractTargetValue(posTargetText, 'position'); // 4.5
        const posDiff = posTargetValue ? (posCurrent - posTargetValue) : null; // Keep sign for display (positive = worse)
        rows.push({
          metric: 'Average position (ranking queries)',
          status: posStatus,
          value: m.avgPosition != null ? m.avgPosition.toFixed(1) : 'N/A',
          currentValue: posCurrent,
          target: posTargetText,
          targetValue: posTargetValue,
          difference: posDiff,
          action: posStatus === 'poor'
            ? (segment === 'money'
                ? 'Most impressions for money pages are coming from low positions. Strengthen internal links to money pages, add more supporting content, and build links from relevant blogs/assignments into these URLs.'
                : 'Most impressions are coming from low positions. Strengthen internal links to key pages, add more supporting content, and build links from relevant blogs/assignments into these URLs.')
            : posStatus === 'ok'
            ? (segment === 'money'
                ? 'Your money pages are mid-page 1 on average. Use on-page tuning (H1, sub-heads, FAQs) and internal links from strong blogs to nudge key money URLs into positions 13.'
                : 'You are mid-page 1 on average. Use on-page tuning (H1, sub-heads, FAQs) and internal links from strong blogs to nudge key URLs into positions 13.')
            : 'Positions are strong overall. Concentrate on CTR and expanding coverage to more relevant queries.'
        });
        
        // Top-10 share recommendation
        const shareStatus = classifyTop10Share(m.top10Share);
        const shareCurrent = m.top10Share * 100; // Convert to percentage
        const shareTargetText = 'Aim for 7585%+ of impressions in top-10';
        const shareTargetValue = extractTargetValue(shareTargetText, 'percentage'); // 80%
        const shareDiff = shareTargetValue ? (shareCurrent - shareTargetValue) : null; // Keep sign for display
        rows.push({
          metric: 'Top-10 impression share',
          status: shareStatus,
          value: pct(m.top10Share, true), // top10Share is stored as decimal (0-1)
          currentValue: shareCurrent,
          target: shareTargetText,
          targetValue: shareTargetValue,
          difference: shareDiff,
          action: shareStatus === 'poor'
            ? (segment === 'money'
                ? 'Large share of impressions for money pages are outside the top-10. Review which queries are generating impressions but no clicks and decide: improve those money pages or deliberately de-optimise low-value queries.'
                : 'Large share of impressions are outside the top-10. Review which queries are generating impressions but no clicks and decide: improve those pages or deliberately de-optimise low-value queries.')
            : shareStatus === 'ok'
            ? (segment === 'money'
                ? 'Gradually push more money page impressions into the top-10 by strengthening key hub pages (workshops, courses, tuition) and consolidating thin or overlapping content.'
                : 'Gradually push more impressions into the top-10 by strengthening key hub pages (workshops, courses, tuition) and consolidating thin or overlapping content.')
            : 'Most impressions are already top-10. Shift effort to CTR and conversion on the URLs listed above.'
        });
        
        return rows;
      }
      
      // Render recommendations table
      function renderRecommendationsTable(segment, metrics, segmentLabel, dateRangeText = '28 days') {
        if (!metrics) {
          return '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">No metrics available for recommendations.</div>';
        }
        
        const recommendations = buildBehaviourRankingRecommendations(segment, metrics);
        
        // Determine priority row: poor status first, or largest gap if no poor
        let priorityIdx = -1;
        const poorRows = recommendations.map((r, i) => ({ idx: i, row: r })).filter(({ row }) => row.status === 'poor');
        if (poorRows.length > 0) {
          // Find poor row with largest gap (use absolute value for comparison)
          priorityIdx = poorRows.reduce((max, curr) => {
            const currGap = Math.abs(curr.row.difference || 0);
            const maxGap = Math.abs(max.row.difference || 0);
            return currGap > maxGap ? curr : max;
          }, poorRows[0]).idx;
        } else {
          // No poor rows, find row with largest gap (use absolute value)
          priorityIdx = recommendations.reduce((maxIdx, row, idx) => {
            const currGap = Math.abs(row.difference || 0);
            const maxGap = Math.abs(recommendations[maxIdx]?.difference || 0);
            return currGap > maxGap ? idx : maxIdx;
          }, 0);
        }
        
        const getStatusPill = (status) => {
          const colors = {
            poor: { bg: '#fee2e2', text: '#991b1b', label: 'Poor' },
            ok: { bg: '#fef3c7', text: '#92400e', label: 'OK' },
            strong: { bg: '#d1fae5', text: '#065f46', label: 'Strong' }
          };
          const color = colors[status] || colors.ok;
          return `<span style="display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; background: ${color.bg}; color: ${color.text}; font-size: 0.75rem; font-weight: 600;">${color.label}</span>`;
        };
        
        // Get segment display name
        const segmentDisplayName = segmentLabel || (segment === 'all' ? 'All pages' : segment === 'nonEducation' ? 'Exclude education (blogs / free course)' : 'Money pages only');
        
        let tableHtml = `
          <div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
            <h4 style="margin: 0 0 0.25rem 0; font-size: 1.2rem; font-weight: 700; color: #1e293b;">Recommended actions for this segment</h4>
            <p style="margin: 0 0 0.5rem 0; font-size: 0.9rem; color: #334155; font-weight: 500;">Segment: <strong>${segmentDisplayName}</strong> (last ${dateRangeText})</p>
            <p style="margin: 0; font-size: 0.9rem; color: #334155; font-weight: 400;">Based on last ${dateRangeText} of Google Search Console data for the currently selected segment.</p>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 1rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">Metric</th>
                  <th style="text-align: center; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">Status</th>
                  <th style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">Current</th>
                  <th style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">Target</th>
                  <th style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">To Target</th>
                  <th style="text-align: left; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">Suggested action</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        recommendations.forEach((row, idx) => {
          const isEven = idx % 2 === 0;
          const isPriority = idx === priorityIdx;
          
          // Determine metric type and format accordingly
          let currentDisplay = row.value;
          let targetDisplay = row.target;
          let diffDisplay = '';
          
          if (row.metric.includes('CTR')) {
            // CTR metrics: show as percentages (1 decimal)
            currentDisplay = `${row.currentValue.toFixed(1)}%`;
            if (row.targetValue !== null && row.targetValue !== undefined) {
              targetDisplay = `${row.targetValue.toFixed(1)}%`;
              if (row.difference !== null && row.difference !== undefined) {
                // Show sign and color based on status
                const gap = row.difference; // Already calculated as current - target
                if (gap >= 0) {
                  // At or above target
                  diffDisplay = '<span style="color: #10b981; font-weight: 600;"> On target</span>';
                } else {
                  // Below target - show with sign
                  const gapColor = row.status === 'poor' ? '#ef4444' : row.status === 'ok' ? '#f59e0b' : '#10b981';
                  diffDisplay = `<span style="color: ${gapColor}; font-weight: 600;">${gap.toFixed(2)}%</span>`;
                }
              }
            }
          } else if (row.metric.includes('position')) {
            // Position metrics: show as numbers (1 decimal)
            currentDisplay = row.currentValue.toFixed(1);
            if (row.targetValue !== null && row.targetValue !== undefined) {
              targetDisplay = row.targetValue.toFixed(1);
              if (row.difference !== null && row.difference !== undefined) {
                // For position, lower is better, so if current <= target, we're good
                const gap = row.difference; // Already calculated as current - target
                if (gap <= 0) {
                  // At or better than target
                  diffDisplay = '<span style="color: #10b981; font-weight: 600;"> On target</span>';
                } else {
                  // Above target (worse position) - show with sign
                  const gapColor = row.status === 'poor' ? '#ef4444' : row.status === 'ok' ? '#f59e0b' : '#10b981';
                  diffDisplay = `<span style="color: ${gapColor}; font-weight: 600;">+${gap.toFixed(1)}</span>`;
                }
              }
            }
          } else if (row.metric.includes('impression share')) {
            // Share metrics: show as percentages (1 decimal)
            currentDisplay = `${row.currentValue.toFixed(1)}%`;
            if (row.targetValue !== null && row.targetValue !== undefined) {
              targetDisplay = `${row.targetValue.toFixed(1)}%`;
              if (row.difference !== null && row.difference !== undefined) {
                // For share, higher is better
                const gap = row.difference; // Already calculated as current - target
                if (gap >= 0) {
                  // At or above target
                  diffDisplay = '<span style="color: #10b981; font-weight: 600;"> On target</span>';
                } else {
                  // Below target - show with sign
                  const gapColor = row.status === 'poor' ? '#ef4444' : row.status === 'ok' ? '#f59e0b' : '#10b981';
                  diffDisplay = `<span style="color: ${gapColor}; font-weight: 600;">${gap.toFixed(2)}%</span>`;
                }
              }
            }
          }
          
          // Priority row styling: left border and optional priority badge
          const priorityStyle = isPriority ? 'border-left: 4px solid #ef4444; background: #fef2f2;' : '';
          const priorityBadge = isPriority ? '<span style="display: inline-block; margin-left: 0.5rem; padding: 0.15rem 0.4rem; background: #ef4444; color: white; border-radius: 4px; font-size: 0.8rem; font-weight: 600;">Priority</span>' : '';
          
          tableHtml += `
            <tr style="border-bottom: 1px solid #f1f5f9; background: ${isEven ? '#ffffff' : '#fafafa'}; ${priorityStyle} transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa';" onmouseout="this.style.background='${isEven ? '#ffffff' : '#fafafa'}';">
              <td style="padding: 0.9rem; color: #0f172a; font-weight: 600; font-size: 1rem;">${row.metric}${priorityBadge}</td>
              <td style="padding: 0.9rem; text-align: center; font-size: 1rem;">${getStatusPill(row.status)}</td>
              <td style="padding: 0.9rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 1rem;">${currentDisplay}</td>
              <td style="padding: 0.9rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 1rem;">${targetDisplay}</td>
              <td style="padding: 0.9rem; text-align: right; font-weight: 600; font-size: 1rem;">${diffDisplay}</td>
              <td style="padding: 0.9rem; color: #0f172a; font-weight: 400; line-height: 1.5; font-size: 1rem;">${row.action}</td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        return tableHtml;
      }
      
      // Function to render full-width top pages table (shared by both createTopPagesSection functions)
      function renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText = '28 days') {
        if (!topPages || topPages.length === 0) {
          return '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">No page data available for this segment. This table shows the latest snapshot from your most recent audit (static data, not affected by time period selections). If you see this message, the data may not have been computed during the last audit. Make sure your audit includes Google Search Console query+page metrics (queryPages dimension) and that you have uploaded site-urls.csv for segmentation.</div>';
        }
        
        // Store original data for sorting
        if (!window.topPagesData) {
          window.topPagesData = topPages;
          window.topPagesSortColumn = null;
          window.topPagesSortDirection = 'desc';
        }
        
        // Sort data if needed
        let sortedPages = [...topPages];
        if (window.topPagesSortColumn) {
          sortedPages.sort((a, b) => {
            let aVal, bVal;
            switch(window.topPagesSortColumn) {
              case 'ctr':
                aVal = a.ctr || 0;
                bVal = b.ctr || 0;
                break;
              case 'impressions':
                aVal = a.impressions || 0;
                bVal = b.impressions || 0;
                break;
              case 'clicks':
                aVal = a.clicks || 0;
                bVal = b.clicks || 0;
                break;
              case 'position':
                aVal = a.avgPosition || 0;
                bVal = b.avgPosition || 0;
                break;
              default:
                return 0;
            }
            const diff = aVal - bVal;
            return window.topPagesSortDirection === 'asc' ? diff : -diff;
          });
        }
        
        // Helper function to get sort icon (must be defined before use in template)
        const getSortIcon = (column) => {
          if (!window.topPagesSortColumn || window.topPagesSortColumn !== column) {
            return '<span style="color: #475569; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 600;"></span>';
          }
          return window.topPagesSortDirection === 'asc' 
            ? '<span style="color: #99004C; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 700;"></span>'
            : '<span style="color: #99004C; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 700;"></span>';
        };
        
        let tableHtml = `
          <div style="margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
            <div>
              <h4 style="margin: 0 0 0.25rem 0; font-size: 1.2rem; font-weight: 700; color: #1e293b;">Top 10 pages by impressions</h4>
              <span style="font-size: 0.9rem; color: #334155; font-weight: 500;">Data period: Last ${dateRangeText}</span>
            </div>
            <button id="top-pages-copy-urls" type="button" style="font-size: 0.95rem; padding: 0.6rem 0.9rem; border-radius: 6px; border: 1px solid #2563eb; background: #2563eb; cursor: pointer; color: white; font-weight: 600; transition: all 0.2s; box-shadow: 0 1px 2px rgba(0,0,0,0.1);" onmouseover="this.style.background='#1d4ed8'; this.style.borderColor='#1d4ed8';" onmouseout="this.style.background='#2563eb'; this.style.borderColor='#2563eb';">
              Copy URLs
            </button>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 1rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">#</th>
                  <th style="text-align: left; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">URL</th>
                  <th id="sort-ctr" style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by CTR">
                    CTR${getSortIcon('ctr')}
                  </th>
                  <th id="sort-impressions" style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Impressions">
                    Impressions${getSortIcon('impressions')}
                  </th>
                  <th id="sort-clicks" style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Clicks">
                    Clicks${getSortIcon('clicks')}
                  </th>
                  <th id="sort-position" style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Avg Position">
                    Avg Position${getSortIcon('position')}
                  </th>
                </tr>
              </thead>
              <tbody>
        `;
        
        sortedPages.forEach((page, idx) => {
          const isEven = idx % 2 === 0;
          const safeCtr = page.ctr != null ? page.ctr : 0;
          const safePos = page.avgPosition != null ? page.avgPosition : 0;
          const ctrColor = safeCtr >= 2 ? '#10b981' : safeCtr >= 1 ? '#f59e0b' : '#ef4444';
          const posColor = safePos <= 5 ? '#10b981' : safePos <= 10 ? '#f59e0b' : '#ef4444';
          const ctrStr = page.ctr != null ? page.ctr.toFixed(1) : 'N/A';
          const posStr = page.avgPosition != null ? page.avgPosition.toFixed(1) : 'N/A';
          tableHtml += `
            <tr style="border-bottom: 1px solid #f1f5f9; background: ${isEven ? '#ffffff' : '#fafafa'}; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa';" onmouseout="this.style.background='${isEven ? '#ffffff' : '#fafafa'}';">
              <td style="padding: 0.9rem; color: #0f172a; font-weight: 600; font-size: 1rem;">${idx + 1}</td>
              <td style="padding: 0.9rem; word-break: break-all; font-size: 1rem;">
                <a href="${page.url}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none; font-weight: 500; border-bottom: 1px solid transparent; transition: all 0.2s;" onmouseover="this.style.color='#1d4ed8'; this.style.borderBottomColor='#1d4ed8';" onmouseout="this.style.color='#2563eb'; this.style.borderBottomColor='transparent';" title="Open ${page.url} in new tab">${page.url}</a>
              </td>
              <td style="padding: 0.9rem; text-align: right; color: ${ctrColor}; font-weight: 600; font-size: 1rem;">${ctrStr}%</td>
              <td style="padding: 0.9rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 1rem;">${page.impressions.toLocaleString()}</td>
              <td style="padding: 0.9rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 1rem;">${page.clicks.toLocaleString()}</td>
              <td style="padding: 0.9rem; text-align: right; color: ${posColor}; font-weight: 600; font-size: 1rem;">${page.avgPosition != null ? page.avgPosition.toFixed(1) : 'N/A'}</td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        return tableHtml;
      }
      
      // Helper to attach sort handlers after table is in DOM (shared by both createTopPagesSection functions)
      function attachSortHandlers() {
        setTimeout(() => {
          ['ctr', 'impressions', 'clicks', 'position'].forEach(col => {
            const th = document.getElementById(`sort-${col}`);
            if (th) {
              // Remove existing listeners by cloning
              const newTh = th.cloneNode(true);
              th.parentNode.replaceChild(newTh, th);
              newTh.addEventListener('click', () => {
                if (window.handleSort) {
                  window.handleSort(col);
                } else {
                  console.error('window.handleSort is not defined');
                }
              });
            } else {
              console.warn(`Sort header not found: sort-${col}`);
            }
          });
        }, 50);
      }
      
      // Make handleSort available globally (shared by both createTopPagesSection functions)
      if (!window.handleSort) {
        window.handleSort = function(column) {
          console.log('handleSort called with column:', column);
          if (window.topPagesSortColumn === column) {
            window.topPagesSortDirection = window.topPagesSortDirection === 'asc' ? 'desc' : 'asc';
          } else {
            window.topPagesSortColumn = column;
            window.topPagesSortDirection = 'desc';
          }
          
          // Get current data from stored source
          const currentMode = window.currentAuthorityMode || 'all';
          let topPages = window.topPagesData || [];
          
          // If no stored data, try to get from authorityBySegment
          if (!topPages || topPages.length === 0) {
            const segData = window.authorityBySegment;
            if (segData) {
              topPages = currentMode === 'all'
                ? (segData.all?.topPages || [])
                : currentMode === 'nonEducation'
                ? (segData.nonEducation?.topPages || [])
                : (segData.money?.topPages || []);
              window.topPagesData = topPages;
            }
          }
          
          const segmentLabel = currentMode === 'all'
            ? 'All pages'
            : currentMode === 'nonEducation'
            ? 'Exclude education (blogs / free course)'
            : 'Money pages only';
          
          // Get date range for display
          const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28', 10);
          const dateRangeText = dateRange === 28 ? '28 days' : dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
          
          const tableContainer = document.getElementById('top-pages-table-container');
          if (tableContainer) {
            tableContainer.innerHTML = renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText);
            // attachCopyButtonHandler and attachSortHandlers are in shared scope, so they're accessible
            attachSortHandlers();
            // attachCopyButtonHandler is defined inside createTopPagesSection, so we need to find it or define it globally
            // For now, attach the copy button handler directly
            setTimeout(() => {
              const copyBtn = document.getElementById('top-pages-copy-urls');
              if (copyBtn) {
                const newCopyBtn = copyBtn.cloneNode(true);
                copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
                newCopyBtn.addEventListener('click', async () => {
                  const currentMode = window.currentAuthorityMode || 'all';
                  const segData = window.authorityBySegment;
                  const currentTopPages = currentMode === 'all'
                    ? (segData?.all?.topPages || [])
                    : currentMode === 'nonEducation'
                    ? (segData?.nonEducation?.topPages || [])
                    : (segData?.money?.topPages || []);
                  const text = currentTopPages.map(p => p.url).join('\n');
                  try {
                    await navigator.clipboard.writeText(text);
                    newCopyBtn.textContent = 'Copied!';
                    newCopyBtn.style.color = '#10b981';
                    setTimeout(() => {
                      newCopyBtn.textContent = 'Copy URLs';
                      newCopyBtn.style.color = '#666';
                    }, 2000);
                  } catch (err) {
                    console.error('Failed to copy URLs:', err);
                    newCopyBtn.textContent = 'Copy failed';
                    setTimeout(() => {
                      newCopyBtn.textContent = 'Copy URLs';
                    }, 2000);
                  }
                });
              }
            }, 50);
          } else {
            console.error('top-pages-table-container not found');
          }
        };
      }
      
      // Function to render segment comparison table (shared by both createTopPagesSection functions)
      function renderSegmentComparisonTable(authorityBySegment, currentMode) {
        const segments = [
          { key: 'all', label: 'All pages', data: authorityBySegment.all },
          { key: 'nonEducation', label: 'Exclude education (blogs / free course)', data: authorityBySegment.nonEducation },
          { key: 'money', label: 'Money pages only', data: authorityBySegment.money }
        ];
        
        let tableHtml = `
          <div style="margin-bottom: 0.5rem;">
            <h4 style="margin: 0 0 0.5rem 0; font-size: 1.15rem; font-weight: 700; color: #1e293b;">Segment overview (CTR & ranking)</h4>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.95rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Segment</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Site CTR</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Top-10 CTR</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Avg pos.</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Top-10 share</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Behaviour</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Ranking</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        segments.forEach(({ key, label, data }, idx) => {
          const isActive = key === currentMode;
          const siteCtr = data?.siteCtr || 0;
          const top10Ctr = data?.top10Ctr || 0;
          const avgPosition = data?.avgPosition || 0;
          const top10Share = (data?.top10Share || 0) * 100;
          const behaviourScore = data?.behaviour || 0;
          const rankingScore = data?.ranking || 0;
          
          tableHtml += `
            <tr 
              onclick="window.currentAuthorityMode = '${key}'; if(window.updateTopPagesSection) window.updateTopPagesSection('${key}');"
              style="
                cursor: pointer;
                border-bottom: 1px solid #f1f5f9;
                background: ${isActive ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : (idx % 2 === 0 ? '#ffffff' : '#fafafa')};
                transition: all 0.2s;
              "
              onmouseover="this.style.background='${isActive ? 'linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%)' : '#f8f9fa'}';"
              onmouseout="this.style.background='${isActive ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : (idx % 2 === 0 ? '#ffffff' : '#fafafa')}';"
            >
              <td style="padding: 0.75rem 1rem; font-weight: ${isActive ? '600' : '500'}; color: #0f172a; font-size: 0.95rem;">
                ${label}
                ${isActive ? '<span style="margin-left: 0.5rem; font-size: 0.8rem; padding: 0.15rem 0.5rem; border-radius: 999px; background: #10b981; color: white; font-weight: 600;">current</span>' : ''}
              </td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${siteCtr != null ? siteCtr.toFixed(1) : 'N/A'}%</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${top10Ctr != null ? top10Ctr.toFixed(1) : 'N/A'}%</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${avgPosition != null ? avgPosition.toFixed(1) : 'N/A'}</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${top10Share != null ? top10Share.toFixed(1) : 'N/A'}%</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 0.95rem;">${behaviourScore != null ? Math.round(behaviourScore) : 'N/A'}</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 0.95rem;">${rankingScore != null ? Math.round(rankingScore) : 'N/A'}</td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        return tableHtml;
      }
      
      // Function to create Top Pages section (full width, below pillar cards)
      function createTopPagesSection(scores, saved) {
        // Get Authority segment data from current scores (latest snapshot, not historical)
        // This uses the most recent audit data, not historical Supabase data
        const authorityObj = scores?.authority;
        let authorityBySegment = (typeof authorityObj === 'object' && authorityObj !== null) 
          ? authorityObj.bySegment 
          : null;
        
        // If no segment data in scores, try to get from saved audit (latest audit data from localStorage)
        if (!authorityBySegment && saved) {
          const savedScores = saved.scores;
          if (savedScores && savedScores.authority) {
            const savedAuthorityObj = savedScores.authority;
            if (typeof savedAuthorityObj === 'object' && savedAuthorityObj !== null) {
              authorityBySegment = savedAuthorityObj.bySegment || null;
              debugLog(' Top Pages: Using Authority segment data from saved audit (latest snapshot)', 'info');
            }
          }
        }
        
        if (!authorityBySegment) {
          debugLog(' No Authority segment data available for Top Pages table. This requires GSC queryPages data from your most recent audit.', 'warn');
          // Still create the section but show a helpful message - don't return early
        }
        
        // Remove existing top pages section if it exists
        const existingTopPages = document.getElementById('authority-top-pages-section');
        if (existingTopPages) {
          existingTopPages.remove();
        }
        
        // Create new section
        const topPagesSection = document.createElement('div');
        topPagesSection.id = 'authority-top-pages-section';
        topPagesSection.className = 'section-break';
        topPagesSection.style.marginTop = '2rem';
        topPagesSection.style.marginBottom = '2rem';
        
        // Get current mode from Authority card toggle (default to 'all')
        let currentMode = 'all';
        const authorityCard = Array.from(document.querySelectorAll('.pillar-card')).find(card => {
          const h3 = card.querySelector('h3');
          return h3 && h3.textContent === 'Authority';
        });
        
        if (authorityCard && authorityCard._authorityMode) {
          currentMode = authorityCard._authorityMode;
        }
        
        // Get top pages for current mode
        const topPages = currentMode === 'all'
          ? (authorityBySegment?.all?.topPages || [])
          : currentMode === 'nonEducation'
          ? (authorityBySegment?.nonEducation?.topPages || [])
          : (authorityBySegment?.money?.topPages || []);
        
        const segmentLabel = currentMode === 'all'
          ? 'All pages'
          : currentMode === 'nonEducation'
          ? 'Exclude education (blogs / free course)'
          : 'Money pages only';
        
        debugLog(` Top Pages: Found ${topPages.length} pages for segment "${currentMode}"`, 'info');
        if (topPages.length > 0) {
          debugLog(` Top Pages: First page URL: ${topPages[0].url}, Impressions: ${topPages[0].impressions}`, 'info');
        }
        
        // Get brand queries for mini-table
        const topQueries = saved?.searchData?.topQueries || [];
        const brandQueries = topQueries
          .filter(q => isBrandQuery(q.query || ''))
          .sort((a, b) => (b.impressions || 0) - (a.impressions || 0))
          .slice(0, 10);
        
        // Create section HTML
        topPagesSection.innerHTML = `
          <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 1rem 0; color: var(--brand-dark); font-size: 1.5rem;">Authority - Behaviour & Ranking</h3>
            <div style="margin-bottom: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 4px; font-size: 1rem; line-height: 1.6; color: #666;">
              <p style="margin: 0 0 0.75rem 0;"><strong>Behaviour:</strong> Measures click-through rate (CTR) performance. Combines Overall CTR (50% weight) for all ranking search terms and Top-10 Ranked Search Terms CTR (50% weight) for queries ranking in positions 1-10. Indicates how well your titles and descriptions convert impressions to clicks. Data source: Google Search Console query+page metrics.</p>
              <p style="margin: 0;"><strong>Ranking:</strong> Measures search visibility and position quality. Combines Average Position Score (50% weight) and Top-10 Impression Share (50% weight). Shows how high you rank on average and what percentage of impressions appear in positions 1-10. Data source: Google Search Console query+page metrics.</p>
            </div>
            <div style="margin-bottom: 1rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; font-size: 0.9rem;">
              <span style="font-weight: 600; color: #666;">Current Segment:</span>
              <span id="top-pages-segment-label" style="color: #333; margin-left: 0.5rem;">${segmentLabel}</span>
            </div>
            <div id="top-pages-table-container">
              ${renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText)}
            </div>
            
            ${authorityBySegment && authorityBySegment[currentMode] ? `
            <div id="top-pages-recommendations-container" style="margin-top: 2rem;">
              ${renderRecommendationsTable(currentMode, {
                siteCtr: authorityBySegment[currentMode].siteCtr || 0,
                top10Ctr: authorityBySegment[currentMode].top10Ctr || 0,
                avgPosition: authorityBySegment[currentMode].avgPosition || 0,
                top10Share: authorityBySegment[currentMode].top10Share || 0,
                behaviourScore: authorityBySegment[currentMode].behaviour || 0,
                rankingScore: authorityBySegment[currentMode].ranking || 0
              }, segmentLabel, dateRangeText)}
            </div>
            ` : ''}
            
            ${brandQueries.length > 0 ? `
            <div style="margin-top: 2rem; padding: 1rem; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #f59e0b;">
              <h4 style="margin: 0 0 0.75rem 0; color: #92400e; font-size: 1rem; font-weight: 600;">Top Branded Queries</h4>
              <p style="margin: 0 0 1rem 0; font-size: 0.85rem; color: #666; line-height: 1.5;">Branded search queries (e.g., "Alan Ranger Photography") with CTR and position metrics.</p>
              <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                  <thead>
                    <tr style="background: #e5e7eb; border-bottom: 2px solid #d1d5db;">
                      <th style="padding: 0.5rem; text-align: left; font-weight: 600; color: #374151;">Query</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Impressions</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Clicks</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">CTR</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Position</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${brandQueries.map((q, idx) => {
                      const ctr = q.impressions > 0 ? ((q.clicks || 0) / q.impressions * 100) : 0;
                      const ctrColor = ctr >= 25 ? '#10b981' : ctr >= 10 ? '#f59e0b' : '#ef4444';
                      const posColor = (q.position || 0) <= 3 ? '#10b981' : (q.position || 0) <= 5 ? '#f59e0b' : '#ef4444';
                      return `
                      <tr style="border-bottom: 1px solid #e5e7eb; ${idx % 2 === 0 ? 'background: #ffffff;' : 'background: #f9fafb;'}">
                        <td style="padding: 0.5rem; color: #1f2937; font-weight: 500;">${(q.query || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</td>
                        <td style="padding: 0.5rem; text-align: right; color: #6b7280;">${(q.impressions || 0).toLocaleString()}</td>
                        <td style="padding: 0.5rem; text-align: right; color: #6b7280;">${(q.clicks || 0).toLocaleString()}</td>
                        <td style="padding: 0.5rem; text-align: right; color: ${ctrColor}; font-weight: 600;">${ctr.toFixed(1)}%</td>
                        <td style="padding: 0.5rem; text-align: right; color: ${posColor}; font-weight: 600;">${(q.position || 0).toFixed(1)}</td>
                      </tr>
                    `;
                    }).join('')}
                  </tbody>
                </table>
              </div>
            </div>
            ` : ''}
          </div>
        `;
        
        // Insert into Authority panel instead of Overview
        const authorityPanel = document.querySelector('.aigeo-panel[data-panel="authority"]');
        if (authorityPanel) {
          // Clear any existing content
          const existing = document.getElementById('authority-top-pages-section');
          if (existing) existing.remove();
          authorityPanel.appendChild(topPagesSection);
          debugLog(' Authority section inserted into Authority panel', 'success');
        } else {
          // Fallback: insert after pillar cards (old behavior)
        pillarCards.parentNode.insertBefore(topPagesSection, pillarCards.nextSibling);
          debugLog(' Authority section inserted after pillar cards (fallback)', 'info');
        }
        
        // Store authorityBySegment globally so updateTopPagesSection can access it
        window.authorityBySegment = authorityBySegment;
        
        // Store update function globally so Authority mode toggle can call it
        window.updateTopPagesSection = function(mode) {
          const topPages = mode === 'all'
            ? (authorityBySegment?.all?.topPages || [])
            : mode === 'nonEducation'
            ? (authorityBySegment?.nonEducation?.topPages || [])
            : (authorityBySegment?.money?.topPages || []);
          
          const segmentLabel = mode === 'all'
            ? 'All pages'
            : mode === 'nonEducation'
            ? 'Exclude education (blogs / free course)'
            : 'Money pages only';
          
          debugLog(` Top Pages: Updating to segment "${mode}", found ${topPages.length} pages`, 'info');
          
          // Update segment label
          const labelEl = document.getElementById('top-pages-segment-label');
          if (labelEl) labelEl.textContent = segmentLabel;
          
          // Update summary if available
          const getSegmentSummary = (m) => {
            if (!authorityBySegment || !authorityBySegment[m]) return null;
            const segmentData = authorityBySegment[m];
            return {
              behaviour: segmentData.behaviour || 0,
              ranking: segmentData.ranking || 0,
              total: segmentData.total || segmentData.score || 0
            };
          };
          
          const summary = getSegmentSummary(mode);
          const summaryDiv = document.getElementById('top-pages-segment-summary');
          if (summary && summaryDiv) {
            const rag = getRAGStatus(summary.total);
            summaryDiv.innerHTML = `
              ${formatComponentScore('Behaviour', summary.behaviour)}
              ${formatComponentScore('Ranking', summary.ranking)}
            `;
            // Update RAG badge and score
            const ragBadge = summaryDiv.parentElement.querySelector('.rag-badge');
            const scoreSpan = summaryDiv.parentElement.querySelector('span[style*="font-size: 1.5rem"]');
            if (ragBadge) {
              ragBadge.className = `rag-badge ${rag.status}`;
              ragBadge.textContent = rag.label;
            }
            if (scoreSpan) {
              scoreSpan.textContent = Math.round(summary.total);
              scoreSpan.style.color = rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444';
            }
          }
          
          // Update toggle buttons
          ['all', 'nonEducation', 'money'].forEach(m => {
            const btn = document.getElementById(`top-pages-mode-${m}`);
            if (btn) {
              if (m === mode) {
                btn.style.background = '#10b981';
                btn.style.color = 'white';
                btn.style.fontWeight = '600';
              } else {
                btn.style.background = 'white';
                btn.style.color = '#666';
                btn.style.fontWeight = '400';
              }
            }
          });
          
          // Update comparison table
          const comparisonDiv = document.getElementById('top-pages-comparison-table');
          if (comparisonDiv && authorityBySegment) {
            comparisonDiv.innerHTML = renderSegmentComparisonTable(authorityBySegment, mode);
          }
          
          // Get date range for display
          const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28', 10);
          const dateRangeText = dateRange === 28 ? '28 days' : dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
          
          // Update table (reset sort when switching segments)
          window.topPagesData = topPages;
          window.topPagesSortColumn = null;
          window.topPagesSortDirection = 'desc';
          const tableContainer = document.getElementById('top-pages-table-container');
          if (tableContainer) {
            tableContainer.innerHTML = renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText);
            attachCopyButtonHandler();
            attachSortHandlers();
          }
          
          // Update recommendations table
          const recommendationsContainer = document.getElementById('top-pages-recommendations-container');
          if (recommendationsContainer && authorityBySegment && authorityBySegment[mode]) {
            const segmentLabel = mode === 'all'
              ? 'All pages'
              : mode === 'nonEducation'
              ? 'Exclude education (blogs / free course)'
              : 'Money pages only';
            const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28', 10);
            const dateRangeText = dateRange === 28 ? '28 days' : dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
            recommendationsContainer.innerHTML = renderRecommendationsTable(mode, {
              siteCtr: authorityBySegment[mode].siteCtr || 0,
              top10Ctr: authorityBySegment[mode].top10Ctr || 0,
              avgPosition: authorityBySegment[mode].avgPosition || 0,
              top10Share: authorityBySegment[mode].top10Share || 0,
              behaviourScore: authorityBySegment[mode].behaviour || 0,
              rankingScore: authorityBySegment[mode].ranking || 0
            }, segmentLabel, dateRangeText);
          }
        };
        
        // window.handleSort is now defined in shared scope above
        
        // Attach toggle button handlers
        setTimeout(() => {
          ['all', 'nonEducation', 'money'].forEach(mode => {
            const btn = document.getElementById(`top-pages-mode-${mode}`);
            if (btn) {
              btn.addEventListener('click', () => {
                window.currentAuthorityMode = mode;
                window.updateTopPagesSection(mode);
                // Also update Authority pillar card if it exists
                const authorityCard = Array.from(document.querySelectorAll('.pillar-card')).find(card => {
                  const h3 = card.querySelector('h3');
                  return h3 && h3.textContent === 'Authority';
                });
                if (authorityCard && authorityCard._updateAuthorityDisplay) {
                  authorityCard._authorityMode = mode;
                  authorityCard._updateAuthorityDisplay();
                  // Update Authority pillar toggle buttons
                  const modeId = authorityCard._modeId;
                  ['all', 'nonEducation', 'money'].forEach(m => {
                    const authBtn = document.getElementById(`${modeId}-${m}`);
                    if (authBtn) {
                      if (m === mode) {
                        authBtn.style.background = '#10b981';
                        authBtn.style.color = 'white';
                      } else {
                        authBtn.style.background = 'white';
                        authBtn.style.color = '#666';
                      }
                    }
                  });
                }
              });
            }
          });
        }, 0);
        
        // Attach initial copy button handler
        attachCopyButtonHandler();
        
        function attachCopyButtonHandler() {
          setTimeout(() => {
            const copyBtn = document.getElementById('top-pages-copy-urls');
            if (copyBtn) {
              // Remove existing listener
              const newCopyBtn = copyBtn.cloneNode(true);
              copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
              
              newCopyBtn.addEventListener('click', async () => {
                const currentMode = window.currentAuthorityMode || 'all';
                const currentTopPages = currentMode === 'all'
                  ? (authorityBySegment?.all?.topPages || [])
                  : currentMode === 'nonEducation'
                  ? (authorityBySegment?.nonEducation?.topPages || [])
                  : (authorityBySegment?.money?.topPages || []);
                
                const text = currentTopPages.map(p => p.url).join('\n');
                try {
                  await navigator.clipboard.writeText(text);
                  newCopyBtn.textContent = 'Copied!';
                  newCopyBtn.style.color = '#10b981';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                    newCopyBtn.style.color = '#666';
                  }, 2000);
                } catch (err) {
                  console.error('Failed to copy URLs:', err);
                  newCopyBtn.textContent = 'Copy failed';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                  }, 2000);
                }
              });
            }
          }, 0);
        }
        // renderFullWidthTopPagesTable is now defined in shared scope above
      }
      
      // Helper to set sort and re-apply filters from anywhere (header clicks)
      window.moneyPagesSetSort = function(column) {
        if (window.moneyPagesSortColumn === column) {
          window.moneyPagesSortDirection = window.moneyPagesSortDirection === 'asc' ? 'desc' : 'asc';
        } else {
          window.moneyPagesSortColumn = column;
          window.moneyPagesSortDirection = 'asc';
        }
        window.moneyPagesCurrentPage = 1;
        if (typeof window.moneyPagesApplyFilters === 'function') {
          window.moneyPagesApplyFilters();
        }
      };

      // Show inline performance cards for Money Pages rows (replaces modal)
      if (typeof window.showMoneyPagePerformanceInline !== 'function') {
        window.showMoneyPagePerformanceInline = async function(pageUrl, pageTitle, rowElement) {
          try {
            if (!window.moneyPagesRowDataByUrl || window.moneyPagesRowDataByUrl.size === 0) {
              alert('No page data available yet. Please wait for the table to finish loading.');
              return;
            }
            const normalized = normalizeUrlForDedupe ? normalizeUrlForDedupe(pageUrl) : pageUrl.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
            const row = window.moneyPagesRowDataByUrl.get(normalized);
            if (!row) {
              alert('Page data not found yet. Please try again after the table loads.');
              return;
            }

            // Find the row element if not provided
            let currentRow = rowElement;
            if (!currentRow) {
              const allRows = document.querySelectorAll('#money-pages-table-container tbody tr');
              currentRow = Array.from(allRows).find(tr => {
                const aiCell = tr.querySelector('.ai-citation-cell-opportunity');
                if (aiCell) {
                  const cellUrl = aiCell.getAttribute('data-page-url');
                  return cellUrl === pageUrl;
                }
                return false;
              });
            }
            if (!currentRow) {
              console.error('[Money Pages] Could not find row element for inline cards');
              return;
            }

            // Check if cards already exist for this row (check next sibling row)
            const nextRow = currentRow.nextElementSibling;
            if (nextRow && nextRow.querySelector('.money-page-inline-cards')) {
              // Toggle: remove if already showing
              nextRow.remove();
              return;
            }

            // Normalize URL helper (same as API endpoint)
            const normalizeUrl = (url) => {
              if (!url) return '';
              let normalized = String(url).toLowerCase().trim();
              normalized = normalized.replace(/^https?:\/\//, '');
              normalized = normalized.replace(/^www\./, '');
              normalized = normalized.split('?')[0].split('#')[0];
              const parts = normalized.split('/');
              if (parts.length > 1) {
                normalized = parts.slice(1).join('/');
              }
              normalized = normalized.replace(/^\/+/, '').replace(/\/+$/, '');
              return normalized;
            };

            const targetUrlNormalized = normalizeUrl(pageUrl);

            // ============================================
            // CARD 1: Performance Trends (28d + 90d average from Supabase)
            // ============================================
            const clicks28d = row.clicks || 0;
            const impressions28d = row.impressions || 0;
            const ctr28d = impressions28d > 0 ? (clicks28d / impressions28d) * 100 : ((row.ctr || 0) * 100);
            const pos28d = row.avgPosition != null ? row.avgPosition : (row.position || null);

            // Fetch 90-day average from Supabase historical audits
            let clicks90d = null, impressions90d = null, ctr90d = null, pos90d = null;
            let trendData = null;
            let historicalError = null;
            try {
              const propertyUrl = document.getElementById('propertyUrl')?.value || localStorage.getItem('property_url') || '';
              if (propertyUrl) {
                // Fetch historical money pages data from Supabase (last 90 days)
                const apiEndpoint = apiUrl(`/api/supabase/money-pages-historical?property_url=${encodeURIComponent(propertyUrl)}&target_url=${encodeURIComponent(pageUrl)}&days=90`);
                console.log('[Money Pages Card 1] Fetching 90-day data from:', apiEndpoint);
                const response = await fetch(apiEndpoint);
                console.log('[Money Pages Card 1] Response status:', response.status);
                if (response.ok) {
                  const historicalData = await response.json();
                  console.log('[Money Pages Card 1] Historical data response:', historicalData);
                  if (historicalData.status === 'ok' && historicalData.data) {
                    clicks90d = historicalData.data.clicks_90d || null;
                    impressions90d = historicalData.data.impressions_90d || null;
                    ctr90d = historicalData.data.ctr_90d || null;
                    pos90d = historicalData.data.avg_position_90d || null;
                    
                    console.log('[Money Pages Card 1] Parsed 90-day data:', { clicks90d, impressions90d, ctr90d, pos90d });
                    
                    if (clicks90d !== null && impressions90d !== null) {
                      trendData = {
                        clicks28d: clicks28d,
                        clicks90d: clicks90d,
                        clicksChange: clicks90d - clicks28d,
                        impressions28d: impressions28d,
                        impressions90d: impressions90d,
                        impressionsChange: impressions90d - impressions28d,
                        ctr28d: ctr28d,
                        ctr90d: ctr90d || (impressions90d > 0 ? (clicks90d / impressions90d) * 100 : 0),
                        pos28d: pos28d,
                        pos90d: pos90d
                      };
                      console.log('[Money Pages Card 1] Trend data calculated:', trendData);
                    } else {
                      console.warn('[Money Pages Card 1] 90-day data missing clicks or impressions');
                    }
                  } else {
                    console.warn('[Money Pages Card 1] API returned non-ok status or missing data:', historicalData);
                    historicalError = historicalData.message || historicalData.error || 'No data available';
                  }
                } else {
                  let errorText = 'Unknown error';
                  try {
                    errorText = await response.text();
                  } catch (e) {
                    // Ignore
                  }
                  console.warn('[Money Pages Card 1] API request failed:', response.status, errorText);
                  historicalError = `API error: ${response.status}`;
                  
                  // Fallback: Try to get from timeseries in localStorage
                  const lastAuditResults = localStorage.getItem('last_audit_results');
                  if (lastAuditResults) {
                    const auditData = JSON.parse(lastAuditResults);
                    if (auditData.gscData && auditData.gscData.timeseries) {
                      const timeseries = auditData.gscData.timeseries;
                      if (timeseries.pages && Array.isArray(timeseries.pages)) {
                        const pageData = timeseries.pages.find(p => {
                          const pUrl = normalizeUrl(p.page || p.url || '');
                          return pUrl === targetUrlNormalized;
                        });
                        if (pageData && pageData.data && Array.isArray(pageData.data)) {
                          const now = new Date();
                          const days90Ago = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
                          
                          let clicks90 = 0, impressions90 = 0;
                          let positionSum90 = 0, positionCount90 = 0;
                          
                          pageData.data.forEach(point => {
                            const pointDate = new Date(point.date || point.day);
                            if (pointDate >= days90Ago) {
                              clicks90 += point.clicks || 0;
                              impressions90 += point.impressions || 0;
                              if (point.position != null && point.impressions > 0) {
                                positionSum90 += point.position * point.impressions;
                                positionCount90 += point.impressions;
                              }
                            }
                          });
                          
                          if (impressions90 > 0) {
                            clicks90d = clicks90;
                            impressions90d = impressions90;
                            ctr90d = (clicks90 / impressions90) * 100;
                            pos90d = positionCount90 > 0 ? positionSum90 / positionCount90 : null;
                            
                            trendData = {
                              clicks28d: clicks28d,
                              clicks90d: clicks90,
                              clicksChange: clicks90 - clicks28d,
                              impressions28d: impressions28d,
                              impressions90d: impressions90,
                              impressionsChange: impressions90 - impressions28d,
                              ctr28d: ctr28d,
                              ctr90d: ctr90d,
                              pos28d: pos28d,
                              pos90d: pos90d
                            };
                          }
                        }
                      }
                    }
                  }
                }
              }
            } catch (e) {
              console.warn('[Money Pages] Error getting 90-day historical data:', e);
            }

            // ============================================
            // CARD 2: AI Citations with Keywords & Search Volumes
            // ============================================
            // Use the same API endpoint that the table uses to get accurate data
            let citingKeywords = [];
            let totalCitationCount = 0; // Track total citations (not just unique keywords)
            try {
              const propertyUrl = document.getElementById('propertyUrl')?.value || localStorage.getItem('property_url') || '';
              if (propertyUrl) {
                // Use the same API endpoint as populateMoneyPagesAiCitations
                const apiResponse = await fetch(apiUrl(`/api/supabase/query-keywords-citing-url?property_url=${encodeURIComponent(propertyUrl)}&target_url=${encodeURIComponent(pageUrl)}`));
                if (apiResponse.ok) {
                  const apiData = await apiResponse.json();
                  if (apiData.status === 'ok' && Array.isArray(apiData.data)) {
                    // Get total citation count from API (sum across all keywords)
                    totalCitationCount = typeof apiData.count === 'number' ? apiData.count : apiData.data.reduce((sum, k) => sum + (k.citation_count || 1), 0);
                    // Get search volumes from combinedRows in localStorage
                    const lastAuditResults = localStorage.getItem('last_audit_results');
                    let combinedRows = [];
                    if (lastAuditResults) {
                      const auditData = JSON.parse(lastAuditResults);
                      if (auditData?.ranking_ai_data?.combinedRows) {
                        combinedRows = auditData.ranking_ai_data.combinedRows;
                      } else if (auditData?.searchData?.ranking_ai_data?.combinedRows) {
                        combinedRows = auditData.searchData.ranking_ai_data.combinedRows;
                      } else if (Array.isArray(auditData?.ranking_ai_data)) {
                        combinedRows = auditData.ranking_ai_data;
                      } else if (Array.isArray(auditData?.searchData?.ranking_ai_data)) {
                        combinedRows = auditData.searchData.ranking_ai_data;
                      }
                    }
                    
                    // Create lookup map for search volumes
                    const keywordLookup = new Map();
                    if (Array.isArray(combinedRows)) {
                      combinedRows.forEach(kwRow => {
                        if (kwRow.keyword) {
                          keywordLookup.set(kwRow.keyword.toLowerCase(), {
                            searchVolume: kwRow.searchVolume || kwRow.volume || kwRow.monthly_search_volume || null,
                            bestRank: kwRow.best_rank || kwRow.rank || null,
                            hasAiOverview: kwRow.has_ai_overview || false
                          });
                        }
                      });
                    }
                    
                    // Map API response to keywords with search volumes
                    // API now returns search_volume directly, but also check combinedRows as fallback
                    apiData.data.forEach(kw => {
                      const keyword = kw.keyword || '';
                      if (keyword) {
                        const lookup = keywordLookup.get(keyword.toLowerCase()) || {};
                        // Prefer API response search_volume, fallback to combinedRows lookup
                        const searchVolume = kw.search_volume !== undefined && kw.search_volume !== null 
                          ? kw.search_volume 
                          : (lookup.searchVolume || null);
                        citingKeywords.push({
                          keyword: keyword,
                          searchVolume: searchVolume,
                          bestRank: kw.best_rank || kw.best_rank_group || lookup.bestRank || null,
                          hasAiOverview: kw.has_ai_overview !== undefined ? kw.has_ai_overview : lookup.hasAiOverview || false
                        });
                      }
                    });
                  }
                }
              }
            } catch (e) {
              console.warn('[Money Pages] Error getting AI citation keywords:', e);
            }

            // Sort by search volume (descending), then by keyword
            citingKeywords.sort((a, b) => {
              const volDiff = (b.searchVolume || 0) - (a.searchVolume || 0);
              return volDiff !== 0 ? volDiff : (a.keyword || '').localeCompare(b.keyword || '');
            });

            // ============================================
            // CARD 3: Competitor Ranking (placeholder for now)
            // ============================================
            let competitorData = null;
            // TODO: Implement competitor data fetching when available

            // ============================================
            // Build Cards HTML
            // ============================================
            const cardsContainer = document.createElement('td');
            cardsContainer.colSpan = 13;
            cardsContainer.className = 'money-page-inline-cards';
            cardsContainer.style.cssText = 'padding: 1.25rem; background: #f8fafc; border-top: 2px solid #e2e8f0;';

            // Card 1: Performance Trends
            let card1Html = `
              <div style="background: white; padding: 1.25rem; border-radius: 8px; border: 1px solid #e2e8f0; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                <div style="font-size: 0.75rem; color: #64748b; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 700; margin-bottom: 0.75rem;">Performance Trends</div>
                <div style="margin-bottom: 1rem;">
                  <div style="font-size: 0.7rem; color: #94a3b8; margin-bottom: 0.25rem;">Last 28 days</div>
                  <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; font-size: 0.85rem;">
                    <div><strong>Clicks:</strong> ${clicks28d.toLocaleString()}</div>
                    <div><strong>Impressions:</strong> ${impressions28d.toLocaleString()}</div>
                    <div><strong>CTR:</strong> ${ctr28d.toFixed(2)}%</div>
                    <div><strong>Position:</strong> ${pos28d ? pos28d.toFixed(1) : ''}</div>
                  </div>
                </div>
            `;
            
            if (trendData && clicks90d !== null) {
              const clicksChange = trendData.clicksChange;
              const impressionsChange = trendData.impressionsChange;
              const ctrChange = trendData.ctr28d - trendData.ctr90d;
              const posChange = trendData.pos28d && trendData.pos90d ? trendData.pos90d - trendData.pos28d : 0;
              
              card1Html += `
                <div style="border-top: 1px solid #e2e8f0; padding-top: 0.75rem; margin-top: 0.75rem;">
                  <div style="font-size: 0.7rem; color: #94a3b8; margin-bottom: 0.25rem;">90-day average</div>
                  <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; font-size: 0.85rem;">
                    <div><strong>Clicks:</strong> ${clicks90d.toLocaleString()} <span style="color: ${clicksChange >= 0 ? '#10b981' : '#ef4444'}; font-size: 0.75rem;">(${clicksChange >= 0 ? '+' : ''}${clicksChange.toLocaleString()} vs 28d)</span></div>
                    <div><strong>Impressions:</strong> ${impressions90d.toLocaleString()} <span style="color: ${impressionsChange >= 0 ? '#10b981' : '#ef4444'}; font-size: 0.75rem;">(${impressionsChange >= 0 ? '+' : ''}${impressionsChange.toLocaleString()})</span></div>
                    <div><strong>CTR:</strong> ${ctr90d.toFixed(2)}% <span style="color: ${ctrChange >= 0 ? '#10b981' : '#ef4444'}; font-size: 0.75rem;">(${ctrChange >= 0 ? '+' : ''}${ctrChange.toFixed(2)}% vs 28d)</span></div>
                    <div><strong>Position:</strong> ${pos90d ? pos90d.toFixed(1) : ''} <span style="color: ${posChange < 0 ? '#10b981' : posChange > 0 ? '#ef4444' : '#94a3b8'}; font-size: 0.75rem;">${posChange < 0 ? '' : posChange > 0 ? '' : ''} ${posChange !== 0 ? Math.abs(posChange).toFixed(1) : ''}</span></div>
                  </div>
                </div>
              `;
            } else {
              let fallbackMessage = '90-day average will appear when historical audit data is available in Supabase';
              if (historicalError) {
                fallbackMessage = `90-day data unavailable: ${historicalError}`;
              }
              card1Html += `
                <div style="border-top: 1px solid #e2e8f0; padding-top: 0.75rem; margin-top: 0.75rem; font-size: 0.75rem; color: #94a3b8; font-style: italic;">
                  ${fallbackMessage}
                </div>
              `;
            }
            card1Html += `</div>`;

            // Card 2: AI Citations with Keywords
            let card2Html = `
              <div style="background: white; padding: 1.25rem; border-radius: 8px; border: 1px solid #e2e8f0; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                <div style="font-size: 0.75rem; color: #64748b; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 700; margin-bottom: 0.75rem;">AI Citations</div>
            `;
            
            if (citingKeywords.length > 0) {
              card2Html += `
                <div style="font-size: 0.85rem; color: #0f172a; margin-bottom: 0.5rem; font-weight: 600;">${totalCitationCount} total citation${totalCitationCount !== 1 ? 's' : ''} from ${citingKeywords.length} keyword${citingKeywords.length !== 1 ? 's' : ''}</div>
                <div style="max-height: 200px; overflow-y: auto; font-size: 0.8rem;">
              `;
              
              citingKeywords.slice(0, 10).forEach(kw => {
                const volume = kw.searchVolume ? kw.searchVolume.toLocaleString() : '';
                card2Html += `
                  <div style="padding: 0.4rem 0; border-bottom: 1px solid #f1f5f9; display: flex; justify-content: space-between; align-items: center;">
                    <div style="flex: 1; color: #1e293b;">
                      <div style="font-weight: 500;">${kw.keyword}</div>
                      ${kw.bestRank ? `<div style="font-size: 0.7rem; color: #64748b;">Rank: #${kw.bestRank}</div>` : ''}
                    </div>
                    <div style="text-align: right; color: #475569; font-weight: 600; margin-left: 1rem;">
                      ${volume} <span style="font-size: 0.7rem; color: #94a3b8; font-weight: 400;">vol</span>
                    </div>
                  </div>
                `;
              });
              
              if (citingKeywords.length > 10) {
                card2Html += `<div style="padding: 0.4rem 0; font-size: 0.7rem; color: #94a3b8; font-style: italic;">+ ${citingKeywords.length - 10} more keywords</div>`;
              }
              
              card2Html += `</div>`;
            } else {
              card2Html += `
                <div style="font-size: 0.85rem; color: #94a3b8; font-style: italic; padding: 1rem 0;">
                  No AI citations found for this URL in the latest audit
                </div>
              `;
            }
            card2Html += `</div>`;

            // Card 3: Recommended Actions
            // Generate recommendations based on Card 1 (performance) and Card 2 (AI citations)
            // Priority: Performance issues first, then AI citation opportunities
            const recommendations = [];
            
            // ============================================
            // PERFORMANCE-BASED RECOMMENDATIONS (Priority 1)
            // ============================================
            
            // Check for declining clicks/impressions
            if (trendData && trendData.clicksChange < 0) {
              const declinePercent = clicks28d > 0 ? Math.abs((trendData.clicksChange / clicks28d) * 100) : 0;
              if (declinePercent >= 20) {
                recommendations.push({
                  priority: 'High',
                  title: 'Traffic Declining',
                  nextSteps: 'Refresh content, build backlinks, or check for technical issues',
                  estimatedImpact: `Could recover ${Math.abs(trendData.clicksChange).toLocaleString()} clicks/month if trend reverses`,
                  reason: `Clicks down ${declinePercent.toFixed(0)}% vs 90-day average`
                });
              } else if (declinePercent >= 10) {
                recommendations.push({
                  priority: 'Medium',
                  title: 'Traffic Slightly Declining',
                  nextSteps: 'Monitor closely and consider content updates or link building',
                  estimatedImpact: `Could recover ${Math.abs(trendData.clicksChange).toLocaleString()} clicks/month`,
                  reason: `Clicks down ${declinePercent.toFixed(0)}% vs 90-day average`
                });
              }
            }
            
            // Check for low CTR
            if (ctr28d < 2.0 && impressions28d > 100) {
              const ctrGap = 2.0 - ctr28d;
              const potentialClicks = Math.round(impressions28d * (ctrGap / 100));
              recommendations.push({
                priority: ctr28d < 1.0 ? 'High' : 'Medium',
                title: 'Low Click-Through Rate',
                nextSteps: 'Optimize title tags and meta descriptions to improve CTR',
                estimatedImpact: `Could gain ~${potentialClicks.toLocaleString()} additional clicks/month with better CTR`,
                reason: `Current CTR ${ctr28d.toFixed(2)}% is below 2% benchmark`
              });
            }
            
            // Check for position issues
            if (pos28d && pos28d > 10 && impressions28d > 100) {
              const positionGap = pos28d - 10;
              recommendations.push({
                priority: pos28d > 20 ? 'High' : 'Medium',
                title: 'Ranking Below Top 10',
                nextSteps: 'Improve on-page SEO, build authority, or optimize for target keywords',
                estimatedImpact: `Moving to top 10 could increase clicks by 50-100%`,
                reason: `Current position ${pos28d.toFixed(1)} is outside top 10`
              });
            }
            
            // Check for declining position
            if (trendData && trendData.pos28d && trendData.pos90d && trendData.pos28d > trendData.pos90d) {
              const positionDecline = trendData.pos28d - trendData.pos90d;
              if (positionDecline >= 3) {
                recommendations.push({
                  priority: 'High',
                  title: 'Position Declining',
                  nextSteps: 'Check for content quality issues, competitor changes, or algorithm updates',
                  estimatedImpact: `Could recover ${positionDecline.toFixed(1)} positions with optimization`,
                  reason: `Position dropped ${positionDecline.toFixed(1)} positions vs 90-day average`
                });
              }
            }
            
            // Check for improving trends (positive reinforcement)
            if (trendData && trendData.clicksChange > 0 && trendData.clicksChange > clicks28d * 0.1) {
              recommendations.push({
                priority: 'Low',
                title: 'Traffic Improving',
                nextSteps: 'Continue current strategy and double down on what\'s working',
                estimatedImpact: 'Maintain growth trajectory',
                reason: `Clicks up ${((trendData.clicksChange / clicks28d) * 100).toFixed(0)}% vs 90-day average`
              });
            }
            
            // ============================================
            // AI CITATION RECOMMENDATIONS (Priority 2)
            // ============================================
            
            // Check for missing AI citations
            if (citingKeywords.length === 0) {
              recommendations.push({
                priority: 'Medium',
                title: 'No AI Citations',
                nextSteps: 'Add structured data (Schema.org) and optimize content for AI overview eligibility',
                estimatedImpact: 'Could capture AI overview features for high-value keywords',
                reason: 'This URL has no AI citations in search results'
              });
            } else {
              // Check for high search volume keywords that could benefit from better rankings
              const highVolumeKeywords = citingKeywords.filter(kw => kw.searchVolume && kw.searchVolume >= 1000);
              const lowRankingHighVolume = highVolumeKeywords.filter(kw => kw.bestRank && kw.bestRank > 10);
              
              if (lowRankingHighVolume.length > 0) {
                const totalVolume = lowRankingHighVolume.reduce((sum, kw) => sum + (kw.searchVolume || 0), 0);
                recommendations.push({
                  priority: 'Medium',
                  title: 'High-Value Keywords Below Top 10',
                  nextSteps: `Optimize content for "${lowRankingHighVolume[0].keyword}" and similar high-volume terms`,
                  estimatedImpact: `Could capture ${Math.round(totalVolume * 0.1).toLocaleString()}+ monthly impressions by ranking in top 10`,
                  reason: `${lowRankingHighVolume.length} high-volume keyword${lowRankingHighVolume.length > 1 ? 's' : ''} ranking below position 10`
                });
              }
              
              // Check if we have citations but they're for low-volume keywords
              const lowVolumeKeywords = citingKeywords.filter(kw => !kw.searchVolume || kw.searchVolume < 100);
              if (lowVolumeKeywords.length > citingKeywords.length * 0.5) {
                recommendations.push({
                  priority: 'Low',
                  title: 'Focus on Higher Volume Keywords',
                  nextSteps: 'Expand content to target keywords with 100+ monthly search volume',
                  estimatedImpact: 'Could increase potential traffic by targeting higher-volume opportunities',
                  reason: `Most citations are for low-volume keywords (<100 searches/month)`
                });
              }
            }
            
            // Sort recommendations: High priority first, then by type (performance before citations)
            recommendations.sort((a, b) => {
              const priorityOrder = { 'High': 3, 'Medium': 2, 'Low': 1 };
              const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority];
              if (priorityDiff !== 0) return priorityDiff;
              // If same priority, performance recommendations come first
              const aIsPerformance = a.title.includes('Traffic') || a.title.includes('CTR') || a.title.includes('Position') || a.title.includes('Ranking');
              const bIsPerformance = b.title.includes('Traffic') || b.title.includes('CTR') || b.title.includes('Position') || b.title.includes('Ranking');
              if (aIsPerformance && !bIsPerformance) return -1;
              if (!aIsPerformance && bIsPerformance) return 1;
              return 0;
            });
            
            // Limit to top 3 recommendations
            const topRecommendations = recommendations.slice(0, 3);
            
            // Build Card 3 HTML
            let card3Html = `
              <div style="background: white; padding: 1.25rem; border-radius: 8px; border: 1px solid #e2e8f0; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                <div style="font-size: 0.75rem; color: #64748b; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 700; margin-bottom: 0.75rem;">Recommended Actions</div>
            `;
            
            if (topRecommendations.length > 0) {
              topRecommendations.forEach((rec, idx) => {
                const priorityColors = {
                  'High': { bg: '#fee2e2', border: '#ef4444', text: '#991b1b', badge: '#ef4444' },
                  'Medium': { bg: '#fef3c7', border: '#f59e0b', text: '#92400e', badge: '#f59e0b' },
                  'Low': { bg: '#dbeafe', border: '#3b82f6', text: '#1e40af', badge: '#3b82f6' }
                };
                const colors = priorityColors[rec.priority] || priorityColors['Medium'];
                
                card3Html += `
                  <div style="margin-bottom: ${idx < topRecommendations.length - 1 ? '1rem' : '0'}; padding: 0.875rem; background: ${colors.bg}; border-left: 3px solid ${colors.border}; border-radius: 4px;">
                    <div style="display: flex; align-items: center; margin-bottom: 0.5rem;">
                      <span style="display: inline-block; padding: 0.25rem 0.5rem; background: ${colors.badge}; color: #1e293b; border-radius: 4px; font-size: 0.75rem; font-weight: 700; text-transform: uppercase; margin-right: 0.5rem;">${rec.priority}</span>
                      <div style="font-weight: 600; color: ${colors.text}; font-size: 0.85rem;">${rec.title}</div>
                    </div>
                    <div style="font-size: 0.95rem; color: #0f172a; margin-bottom: 0.5rem; line-height: 1.4;">
                      <strong>Next steps:</strong> ${rec.nextSteps}
                    </div>
                    <div style="font-size: 0.9rem; color: #0f172a; font-style: italic; margin-bottom: 0.25rem;">
                      ${rec.estimatedImpact}
                    </div>
                    <div style="font-size: 0.85rem; color: #0f172a;">
                      ${rec.reason}
                    </div>
                  </div>
                `;
              });
            } else {
              card3Html += `
                <div style="font-size: 0.85rem; color: #94a3b8; font-style: italic; padding: 1rem 0; text-align: center;">
                  No specific recommendations at this time. Performance metrics look good!
                </div>
              `;
            }
            card3Html += `</div>`;

            cardsContainer.innerHTML = `
              <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1.25rem;">
                ${card1Html}
                ${card2Html}
                ${card3Html}
              </div>
              <div style="display: flex; justify-content: flex-end; margin-top: 1rem;">
                <button type="button" onclick="this.closest('tr').remove()" style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid #cbd5e1; background: white; color: #475569; font-weight: 600; font-size: 0.8rem; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#f1f5f9';" onmouseout="this.style.background='white';">
                  Close
                </button>
              </div>
            `;

            // Insert after the current row
            if (currentRow) {
              const newRow = document.createElement('tr');
              newRow.appendChild(cardsContainer);
              currentRow.parentNode.insertBefore(newRow, currentRow.nextSibling);
            }
          } catch (err) {
            console.error('[Money Pages] Error showing inline performance cards:', err);
            alert('Unable to show performance cards. See console for details.');
          }
        };
      }

      // Lightweight performance cards for Money Pages rows (kept globally so buttons don't error) - MODAL VERSION (kept for backward compatibility)
      if (typeof window.showMoneyPagePerformance !== 'function') {
        window.showMoneyPagePerformance = function(pageUrl, pageTitle) {
          try {
            if (!window.moneyPagesRowDataByUrl || window.moneyPagesRowDataByUrl.size === 0) {
              alert('No page data available yet. Please wait for the table to finish loading.');
              return;
            }
            const normalized = normalizeUrlForDedupe ? normalizeUrlForDedupe(pageUrl) : pageUrl.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
            const row = window.moneyPagesRowDataByUrl.get(normalized);
            if (!row) {
              alert('Page data not found yet. Please try again after the table loads.');
              return;
            }

            let modal = document.getElementById('money-page-performance-modal');
            if (!modal) {
              modal = document.createElement('div');
              modal.id = 'money-page-performance-modal';
              modal.style.cssText = 'position: fixed; inset: 0; background: rgba(15,23,42,0.45); display: flex; align-items: center; justify-content: center; z-index: 9999;';
              modal.innerHTML = `
                <div style="background: white; max-width: 820px; width: 92%; border-radius: 10px; box-shadow: 0 10px 40px rgba(0,0,0,0.25); overflow: hidden; font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;">
                  <div style="padding: 1rem 1.25rem; background: linear-gradient(135deg, #e0f2fe 0%, #d1fae5 100%); display: flex; align-items: center; justify-content: space-between;">
                    <div>
                      <div id="mp-perf-title" style="font-size: 1rem; font-weight: 800; color: #0f172a;"></div>
                      <div id="mp-perf-url" style="font-size: 0.8rem; color: #475569; margin-top: 0.25rem;"></div>
                    </div>
                    <button id="mp-perf-close" style="border: none; background: #0f172a; color: white; padding: 0.35rem 0.65rem; border-radius: 6px; font-weight: 700; cursor: pointer;">Close</button>
                  </div>
                  <div id="mp-perf-body" style="padding: 1rem 1.25rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 0.75rem; font-size: 0.9rem; color: #0f172a;">
                  </div>
                  <div id="mp-perf-meta" style="padding: 0 1.25rem 1rem 1.25rem; font-size: 0.85rem; color: #475569;"></div>
                </div>
              `;
              document.body.appendChild(modal);
              modal.querySelector('#mp-perf-close').onclick = () => { modal.remove(); };
              modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
            }

            const clicks = row.clicks || 0;
            const impressions = row.impressions || 0;
            const ctr = impressions > 0 ? (clicks / impressions) * 100 : ((row.ctr || 0) * 100);
            const pos = row.avgPosition != null ? row.avgPosition : (row.position || null);
            const ai = typeof row._aiCitations === 'number' ? row._aiCitations : '';
            const recommendation = row.recommendation || 'No recommendation available';
            const schema = (row.schemaTypes || []).join(', ') || 'None';

            modal.querySelector('#mp-perf-title').textContent = pageTitle || row.title || row.url || 'Money Page';
            modal.querySelector('#mp-perf-url').textContent = row.url || '';

            modal.querySelector('#mp-perf-body').innerHTML = `
              <div style="background:#f8fafc; padding:0.85rem; border-radius:8px; border:1px solid #e2e8f0;">
                <div style="font-size:0.8rem; color:#475569; text-transform: uppercase; letter-spacing: 0.4px; font-weight:700;">Clicks (28d)</div>
                <div style="font-size:1.35rem; font-weight:800; color:#0f172a;">${clicks.toLocaleString()}</div>
              </div>
              <div style="background:#f8fafc; padding:0.85rem; border-radius:8px; border:1px solid #e2e8f0;">
                <div style="font-size:0.8rem; color:#475569; text-transform: uppercase; letter-spacing: 0.4px; font-weight:700;">Impressions (28d)</div>
                <div style="font-size:1.35rem; font-weight:800; color:#0f172a;">${impressions.toLocaleString()}</div>
              </div>
              <div style="background:#f8fafc; padding:0.85rem; border-radius:8px; border:1px solid #e2e8f0;">
                <div style="font-size:0.8rem; color:#475569; text-transform: uppercase; letter-spacing: 0.4px; font-weight:700;">CTR (28d)</div>
                <div style="font-size:1.35rem; font-weight:800; color:#0f172a;">${ctr.toFixed(2)}%</div>
              </div>
              <div style="background:#f8fafc; padding:0.85rem; border-radius:8px; border:1px solid #e2e8f0;">
                <div style="font-size:0.8rem; color:#475569; text-transform: uppercase; letter-spacing: 0.4px; font-weight:700;">Avg position</div>
                <div style="font-size:1.35rem; font-weight:800; color:#0f172a;">${pos ? pos.toFixed(1) : ''}</div>
              </div>
              <div style="background:#f8fafc; padding:0.85rem; border-radius:8px; border:1px solid #e2e8f0;">
                <div style="font-size:0.8rem; color:#475569; text-transform: uppercase; letter-spacing: 0.4px; font-weight:700;">AI citations</div>
                <div style="font-size:1.35rem; font-weight:800; color:#0f172a;">${ai}</div>
              </div>
            `;

            modal.querySelector('#mp-perf-meta').innerHTML = `
              <div style="margin-bottom:0.35rem;"><strong>Schema:</strong> ${schema}</div>
              <div><strong>Recommendation:</strong> ${recommendation}</div>
            `;

          } catch (err) {
            console.error('[Money Pages] Error opening performance view:', err);
            alert('Unable to open performance cards. See console for details.');
          }
        };
      }


      // Function to render Money Pages table (with pagination and sorting, matching Top Pages format)
      async function renderMoneyPagesTable(moneyRows, currentPage = 1, rowsPerPage = 10) {
        try {
          if (!moneyRows || moneyRows.length === 0) {
            return '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">No money-page data available for this audit period. Check that your money pages have impressions in the selected date range.</div>';
          }
        
        // Define normalizeUrl function locally to avoid scope issues
        const normalizeUrl = (url) => {
          if (!url) return '';
          let normalized = String(url).toLowerCase().trim();
          normalized = normalized.replace(/^https?:\/\//, '');
          normalized = normalized.replace(/^www\./, '');
          normalized = normalized.split('?')[0].split('#')[0];
          const parts = normalized.split('/');
          if (parts.length > 1) {
            normalized = parts.slice(1).join('/');
          }
          normalized = normalized.replace(/^\/+/, '').replace(/\/+$/, '');
          return normalized;
        };
        
        // Store original data for sorting (across all pages) - update if new data provided
        window.moneyPagesData = moneyRows;
        if (window.moneyPagesSortColumn === undefined) {
          window.moneyPagesSortColumn = 'clicks';
          window.moneyPagesSortDirection = 'desc';
        }
        
        // Sort data if needed (sort ALL rows, not just current page)
        let sortedRows = [...moneyRows];
        if (window.moneyPagesSortColumn) {
          // For AI citations, use cache (trusted source) - don't read from cells which may have wrong values
          if (window.moneyPagesSortColumn === 'aiCitations') {
            // Use cache as source of truth (same as cards use API which populates cache)
            // Don't read from cells - they may have stale or incorrect values from API overwrites
            sortedRows.forEach(row => {
              // First check global cache (populated by populateMoneyPagesAiCitations or cards)
              const cached = window.moneyPagesCitationCache && window.moneyPagesCitationCache[row.url];
              if (typeof cached === 'number' && cached >= 0) {
                row._aiCitations = cached;
              } else if (typeof row._aiCitations !== 'number') {
                // If no cache and no existing value, default to 0 for sorting
                row._aiCitations = 0;
              }
              // Don't overwrite existing _aiCitations if it's already a valid number
            });
          }
          
          sortedRows.sort((a, b) => {
            let aVal, bVal;
            switch(window.moneyPagesSortColumn) {
              case 'ctr':
                aVal = (a.ctr || 0) * 100;
                bVal = (b.ctr || 0) * 100;
                break;
              case 'type': {
                const order = { PRODUCT: 0, EVENT: 1, LANDING: 2 };
                const aType = String(a.subSegment || a.segmentType || '').toUpperCase();
                const bType = String(b.subSegment || b.segmentType || '').toUpperCase();
                aVal = order[aType] ?? 99;
                bVal = order[bType] ?? 99;
                break;
              }
              case 'impressions':
                aVal = a.impressions || 0;
                bVal = b.impressions || 0;
                break;
              case 'clicks':
                aVal = a.clicks || 0;
                bVal = b.clicks || 0;
                break;
              case 'clickPotential': {
                const aImpr = Number(a.impressions || 0) || 0;
                const bImpr = Number(b.impressions || 0) || 0;
                const aClk = Number(a.clicks || 0) || 0;
                const bClk = Number(b.clicks || 0) || 0;
                aVal = Math.max(0, (aImpr * 0.025) - aClk);
                bVal = Math.max(0, (bImpr * 0.025) - bClk);
                break;
              }
              case 'position':
                aVal = a.avgPosition || 99;
                bVal = b.avgPosition || 99;
                break;
              case 'aiCitations':
                // Use _aiCitations which should now be set from cells or cache
                aVal = typeof a._aiCitations === 'number' ? a._aiCitations : 0;
                bVal = typeof b._aiCitations === 'number' ? b._aiCitations : 0;
                break;
              case 'opportunity':
                // Sort by category priority: HIGH_OPPORTUNITY=0, VISIBILITY_FIX=1, MAINTAIN=2
                const categoryOrder = { HIGH_OPPORTUNITY: 0, VISIBILITY_FIX: 1, MAINTAIN: 2 };
                aVal = categoryOrder[a.category] ?? 99;
                bVal = categoryOrder[b.category] ?? 99;
                break;
              default:
                return 0;
            }
            const diff = aVal - bVal;
            return window.moneyPagesSortDirection === 'asc' ? diff : -diff;
          });
        }
        
        // Update stored sorted data
        window.moneyPagesData = sortedRows;
        
        // Helper function to get sort icon
        const getSortIcon = (column) => {
          if (!window.moneyPagesSortColumn || window.moneyPagesSortColumn !== column) {
            return '<span style="color: #475569; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 600;"></span>';
          }
          return window.moneyPagesSortDirection === 'asc' 
            ? '<span style="color: #99004C; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 700;"></span>'
            : '<span style="color: #99004C; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 700;"></span>';
        };
        
        // Get date range for display
        const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28', 10);
        const dateRangeText = dateRange === 28 ? '28 days' : dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
        
        // Get current filter values (stored globally) - normalize for robustness
        const currentCategoryFilter = String(window.moneyPagesCategoryFilter || 'ALL').toUpperCase();
        const currentSubSegmentFilter = String(window.moneyPagesSubSegmentFilter || 'ALL').toUpperCase();
        const currentMinImpressions = Number(window.moneyPagesMinImpressions || 0) || 0;
        
        // Get zero impressions filter (default to true - include zero impressions)
        const includeZero = window.moneyPagesIncludeZero !== false;
        
        // Apply filters before sorting/pagination
        let filteredRows = sortedRows.filter(row => {
          const rowCat = String(row.category || '').toUpperCase();
          const rowSub = String(row.subSegment || row.segmentType || '').toUpperCase();
          const matchCat = currentCategoryFilter === 'ALL' || rowCat === currentCategoryFilter;
          const matchSubSeg = currentSubSegmentFilter === 'ALL' || rowSub === currentSubSegmentFilter;
          const matchImp = (row.impressions || 0) >= currentMinImpressions;
          const matchZero = includeZero || (row.impressions || 0) > 0; // Include zero impressions if checkbox is checked
          return matchCat && matchSubSeg && matchImp && matchZero;
        });

        // Expose current filtered Opportunity rows so Suggested Top 10 can align with the table.
        window.moneyPagesOpportunityFilteredRows = filteredRows;
        
        // Update pagination based on filtered rows
        const filteredTotalPages = Math.ceil(filteredRows.length / rowsPerPage);
        const filteredStartIdx = (currentPage - 1) * rowsPerPage;
        const filteredEndIdx = filteredStartIdx + rowsPerPage;
        const pageRows = filteredRows.slice(filteredStartIdx, filteredEndIdx);
        
        let tableHtml = `
          <div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem;">
              <div>
                <h4 style="margin: 0 0 0.25rem 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Money Pages Opportunity Table</h4>
                <p class="table-subtitle" style="margin: 0 0 0.5rem 0; font-size: 0.75rem; color: #64748b;">
                  Filter by opportunity type and impressions to focus optimisation work.
                </p>
                <span style="font-size: 0.75rem; color: #334155; font-weight: 500;">Data period: Last 28 days  Showing ${filteredStartIdx + 1}-${Math.min(filteredEndIdx, filteredRows.length)} of ${filteredRows.length}</span>
              </div>
              <div class="table-controls" style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  Category:
                  <select id="money-pages-filter-category" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; background: white; cursor: pointer;">
                    <option value="ALL" ${currentCategoryFilter === 'ALL' ? 'selected' : ''}>All categories</option>
                    <option value="HIGH_OPPORTUNITY" ${currentCategoryFilter === 'HIGH_OPPORTUNITY' ? 'selected' : ''}>High opportunity</option>
                    <option value="VISIBILITY_FIX" ${currentCategoryFilter === 'VISIBILITY_FIX' ? 'selected' : ''}>Visibility fix</option>
                    <option value="MAINTAIN" ${currentCategoryFilter === 'MAINTAIN' ? 'selected' : ''}>Maintain</option>
                  </select>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  Sub-segment:
                  <select id="money-pages-filter-subsegment" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; background: white; cursor: pointer;">
                    <option value="ALL" ${currentSubSegmentFilter === 'ALL' ? 'selected' : ''} id="money-subsegment-all">All sub-segments</option>
                    <option value="PRODUCT" ${currentSubSegmentFilter === 'PRODUCT' ? 'selected' : ''} id="money-subsegment-product">Product Pages</option>
                    <option value="EVENT" ${currentSubSegmentFilter === 'EVENT' ? 'selected' : ''} id="money-subsegment-event">Event Pages</option>
                    <option value="LANDING" ${currentSubSegmentFilter === 'LANDING' ? 'selected' : ''} id="money-subsegment-landing">Landing Pages</option>
                  </select>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  Min impressions:
                  <input type="number" id="money-pages-min-impressions" min="0" step="50" value="${currentMinImpressions}" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; width: 100px;" />
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  <input type="checkbox" id="money-pages-include-zero" ${window.moneyPagesIncludeZero !== false ? 'checked' : ''} style="cursor: pointer;" />
                  Include zero impressions
                </label>
                <button id="money-pages-copy-urls" type="button" style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #2563eb; background: #2563eb; cursor: pointer; color: white; font-weight: 600; transition: all 0.2s; box-shadow: 0 1px 2px rgba(0,0,0,0.1);" onmouseover="this.style.background='#1d4ed8'; this.style.borderColor='#1d4ed8';" onmouseout="this.style.background='#2563eb'; this.style.borderColor='#2563eb';">
                  Copy current URLs
                </button>
              </div>
            </div>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem; table-layout: fixed;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; width: 40px;">#</th>
                  <th style="text-align: left; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; width: 380px;">URL / Title / Meta</th>
                  <th style="text-align: center; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; width: 60px;">Details</th>
                  <th id="money-sort-type" style="text-align: left; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; white-space: normal; line-height: 1.1; width: 60px;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Page type (money sub-segment). Click to sort.">
                    <div>Page</div><div>type</div>${getSortIcon('type')}
                  </th>
                  <th id="money-sort-clicks" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; white-space: nowrap;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Clicks">
                    Clicks${getSortIcon('clicks')}
                  </th>
                  <th id="money-sort-impressions" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; white-space: nowrap;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Impressions">
                    Impressions${getSortIcon('impressions')}
                  </th>
                  <th id="money-sort-ctr" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; white-space: nowrap;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by CTR">
                    CTR${getSortIcon('ctr')}
                  </th>
                  <th id="money-sort-clickPotential" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; white-space: normal; line-height: 1.1; width: 100px; min-width: 100px;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click potential = expected additional clicks in this period if CTR hit 2.5%: max(0, impressions  0.025  clicks). Click to sort.">
                    <div>Click</div><div>potential</div>${getSortIcon('clickPotential')}
                  </th>
                  <th id="money-sort-position" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; line-height: 1.2;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Avg Position" onclick="window.moneyPagesSetSort('position')">
                    <div>Avg</div><div>Position</div>${getSortIcon('position')}
                  </th>
                  <th id="money-sort-ai-citations" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; white-space: normal; line-height: 1.15; cursor: pointer; user-select: none;" title="AI citations (unique keywords that cite this URL in AI Overview). Latest audit only; fetched on demand." onclick="window.moneyPagesSetSort('aiCitations')">
                    <div>AI citations</div>${getSortIcon('aiCitations')}
                  </th>
                  <th id="money-sort-opportunity" style="text-align: center; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; white-space: nowrap;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Opportunity">
                    Opportunity${getSortIcon('opportunity')}
                  </th>
                  <th style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; width: 120px; min-width: 120px; white-space: normal; line-height: 1.2;">
                    <div>Schema</div><div>Types</div>
                  </th>
                  <th style="text-align: left; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; width: 260px;">Recommended action</th>
                  <th style="text-align: center; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; width: 120px; min-width: 120px;">Track / Manage</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        // ============================================
        // STEP 3: Fetch optimisation statuses from database (ALWAYS fetch, don't rely on cache)
        // ============================================
        // Store row data by normalized URL for Track button access
        // Always initialize the map if it doesn't exist
        if (!window.moneyPagesRowDataByUrl) {
          window.moneyPagesRowDataByUrl = new Map();
        }
        
        // CRITICAL: DO NOT fetch statuses here - the caller should fetch before calling renderMoneyPagesTable
        // Fetching here causes the cache to be cleared every time the table renders, losing status information
        // Instead, we rely on the cache that was populated by the caller
        debugLog(`[Money Pages Opportunity] Rendering table using existing cache: cacheSize=${window.optimisationStatusCache?.size || 0}, rowsCount=${moneyRows.length}`, 'info');
        
        pageRows.forEach((row, idx) => {
          const isEven = idx % 2 === 0;
          const rowBg = isEven ? '#ffffff' : '#fafafa';
          const ctrPct = (row.ctr || 0) * 100;
          const ctrColor = ctrPct >= 2 ? '#10b981' : ctrPct >= 1 ? '#f59e0b' : '#ef4444';
          const posColor = row.avgPosition <= 5 ? '#10b981' : row.avgPosition <= 10 ? '#f59e0b' : '#ef4444';
          const categoryColor = row.categoryColor === 'green' ? '#10b981' : row.categoryColor === 'amber' ? '#f59e0b' : '#ef4444';
          
          // Extract title from row data or generate from URL
          const pageTitle = row.title || (() => {
            try {
              const urlObj = new URL(row.url);
              const pathParts = urlObj.pathname.split('/').filter(p => p);
              if (pathParts.length > 0) {
                // Convert last path segment to title case
                const lastPart = pathParts[pathParts.length - 1];
                return lastPart.split('-').map(word => 
                  word.charAt(0).toUpperCase() + word.slice(1)
                ).join(' ');
              }
            } catch (e) {}
            return null; // Will show URL if no title
          })();
          
          // Meta description from row data
          const metaDescription = row.metaDescription || null;
          
          // Store row data by normalized URL for Track button access
          // Ensure we store a complete copy with all metrics
          const normalizedRowUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(row.url) : row.url.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
          const rowDataToStore = {
            url: row.url,
            title: row.title,
            clicks: row.clicks || 0,
            impressions: row.impressions || 0,
            ctr: row.ctr || 0,
            avgPosition: row.avgPosition != null ? row.avgPosition : (row.position || null),
            position: row.position || row.avgPosition || null,
            segment: row.segment || 'money_pages',
            metaDescription: row.metaDescription || null,
            category: row.category,
            categoryLabel: row.categoryLabel,
            categoryColor: row.categoryColor,
            recommendation: row.recommendation,
            schemaTypes: row.schemaTypes || [],
            _aiCitations: typeof row._aiCitations === 'number' ? row._aiCitations : (row.aiCitations || 0)
          };
          window.moneyPagesRowDataByUrl.set(normalizedRowUrl, rowDataToStore);
          // Debug: Log if this is the landscape page
          if (row.url && row.url.includes('landscape-photography-workshops')) {
            console.log('[Money Pages] Stored row data for landscape page:', rowDataToStore);
          }
          
          // Safe strings for inline handlers
          const safeUrl = String(row.url || '').replace(/'/g, "\\'").replace(/\"/g, '&quot;');
          const safeTitle = String(pageTitle || row.url || 'Untitled').replace(/'/g, "\\'").replace(/\"/g, '&quot;');

          tableHtml += `
            <tr style="border-bottom: 1px solid #f1f5f9; background: ${rowBg}; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa';" onmouseout="this.style.background='${rowBg}';">
              <td style="padding: 0.75rem; color: #0f172a; font-weight: 600; vertical-align: top; width: 40px;">${filteredStartIdx + idx + 1}</td>
              <td style="padding: 0.55rem 0.75rem; vertical-align: top; width: 380px; cursor: pointer;" onclick="const row = this.closest('tr'); if (row) window.showMoneyPagePerformanceInline('${safeUrl}', '${safeTitle}', row);">
                <a href="${row.url}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none; font-weight: 500; border-bottom: 1px solid transparent; transition: all 0.2s;" onmouseover="this.style.color='#1d4ed8'; this.style.borderBottomColor='#1d4ed8';" onmouseout="this.style.color='#2563eb'; this.style.borderBottomColor='transparent';" onclick="event.stopPropagation();" title="Open ${row.url} in new tab">
                  <div style="font-size: 0.85rem; color: #64748b; margin-bottom: 0.25rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${row.url}</div>
                </a>
                ${pageTitle ? `<div style="font-weight: 600; color: #1e293b; font-size: 0.9rem; margin-top: 0.4rem; margin-bottom: 0.2rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${pageTitle}</div>` : ''}
                ${metaDescription ? `<div style="font-size: 0.8rem; color: #64748b; line-height: 1.35; margin-top: ${pageTitle ? '0.2rem' : '0.4rem'}; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">${metaDescription}</div>` : '<div style="font-size: 0.8rem; color: #94a3b8; font-style: italic; margin-top: 0.4rem;">No meta description available</div>'}
              </td>
              <td style="padding: 0.55rem 0.35rem; vertical-align: top; text-align: center;">
                <button type="button" onclick="event.stopPropagation(); const row = this.closest('tr'); if (row) window.showMoneyPagePerformanceInline('${safeUrl}', '${safeTitle}', row);" style="padding: 0.35rem 0.6rem; border-radius: 6px; border: 1px solid #cbd5e1; background: #f8fafc; color: #1e293b; font-weight: 600; font-size: 0.75rem; cursor: pointer;" title="Show performance cards inline for this page">
                  View
                </button>
              </td>
              <td style="padding: 0.55rem 0.5rem; vertical-align: top; white-space: nowrap; width: 60px;">
                ${(() => {
                  const sub = String(row.subSegment || row.segmentType || '').toLowerCase();
                  const label = sub === 'product' ? 'product' : sub === 'event' ? 'event' : sub === 'landing' ? 'landing' : (sub || '');
                  const bg = label === 'landing' ? '#dbeafe' : label === 'event' ? '#fee2e2' : label === 'product' ? '#dcfce7' : '#e5e7eb';
                  const color = label === 'landing' ? '#1d4ed8' : label === 'event' ? '#991b1b' : label === 'product' ? '#166534' : '#374151';
                  return `<span style="display:inline-block; padding: 0.15rem 0.35rem; border-radius: 999px; font-size: 0.7rem; font-weight: 700; background:${bg}; color:${color}; border: 1px solid rgba(0,0,0,0.06); text-transform: lowercase;">${label}</span>`;
                })()}
              </td>
              <td style="padding: 0.75rem; text-align: right; color: #0f172a; font-weight: 500; vertical-align: top; white-space: nowrap;">${(row.clicks || 0).toLocaleString()}</td>
              <td style="padding: 0.75rem; text-align: right; color: #0f172a; font-weight: 500; vertical-align: top; white-space: nowrap;">${(row.impressions || 0).toLocaleString()}</td>
              <td style="padding: 0.75rem; text-align: right; color: ${ctrColor}; font-weight: 600; vertical-align: top; white-space: nowrap;">${ctrPct.toFixed(1)}%</td>
              <td style="padding: 0.75rem; text-align: right; color: #0f172a; font-weight: 600; vertical-align: top; white-space: nowrap;" title="Click potential to hit 2.5% CTR in this period: max(0, impressions  0.025  clicks)">
                ${(() => {
                  const impr = Number(row.impressions || 0) || 0;
                  const clk = Number(row.clicks || 0) || 0;
                  const potential = Math.max(0, Math.round((impr * 0.025) - clk));
                  return potential.toLocaleString('en-GB');
                })()}
              </td>
              <td style="padding: 0.75rem; text-align: right; color: ${posColor}; font-weight: 600; vertical-align: top; white-space: nowrap;">${row.avgPosition ? row.avgPosition.toFixed(1) : ''}</td>
              <td style="padding: 0.75rem; text-align: right; font-weight: 600; vertical-align: top; white-space: nowrap;" class="ai-citation-cell-opportunity" data-page-url="${row.url || ''}">${(() => {
                // Use cache if available (same source as cards) - prevents flickering
                // Check exact URL match first
                let cached = window.moneyPagesCitationCache && window.moneyPagesCitationCache[row.url];
                
                // If not found, try normalized URL matching (in case cache key format differs)
                if (typeof cached !== 'number' && window.moneyPagesCitationCache) {
                  const normalizeUrl = (url) => {
                    if (!url) return '';
                    let normalized = String(url).toLowerCase().trim();
                    normalized = normalized.replace(/^https?:\/\//, '');
                    normalized = normalized.replace(/^www\./, '');
                    normalized = normalized.split('?')[0].split('#')[0];
                    const parts = normalized.split('/');
                    if (parts.length > 1) {
                      normalized = parts.slice(1).join('/');
                    }
                    normalized = normalized.replace(/^\/+/, '').replace(/\/+$/, '');
                    return normalized;
                  };
                  const rowUrlNormalized = normalizeUrl(row.url || '');
                  const cacheKey = Object.keys(window.moneyPagesCitationCache).find(key => {
                    const keyNormalized = normalizeUrl(key);
                    return keyNormalized === rowUrlNormalized || key === row.url;
                  });
                  if (cacheKey && typeof window.moneyPagesCitationCache[cacheKey] === 'number') {
                    cached = window.moneyPagesCitationCache[cacheKey];
                  }
                }
                
                if (typeof cached === 'number' && cached >= 0) {
                  row._aiCitations = cached; // Set on row for sorting
                  return cached.toLocaleString();
                }
                // Also check row._aiCitations if already set
                if (typeof row._aiCitations === 'number' && row._aiCitations >= 0) {
                  return row._aiCitations.toLocaleString();
                }
                // Placeholder if no cache yet
                return '';
              })()}</td>
              <td style="padding: 0.75rem; text-align: center; vertical-align: top;">
                ${(() => {
                  // Split categoryLabel into main part and bracketed part
                  const label = row.categoryLabel || '';
                  const bracketMatch = label.match(/^(.+?)\s*\((.+?)\)$/);
                  if (bracketMatch) {
                    const mainPart = bracketMatch[1].trim();
                    const bracketPart = bracketMatch[2].trim();
                    return `<span style="display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; background: ${categoryColor}20; color: ${categoryColor}; border: 1px solid ${categoryColor}40; line-height: 1.3;">
                      <div>${mainPart}</div>
                      <div style="font-size: 0.7rem; font-weight: 500; opacity: 0.9;">(${bracketPart})</div>
                    </span>`;
                  }
                  // If no brackets, just show the label
                  return `<span style="display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; background: ${categoryColor}20; color: ${categoryColor}; border: 1px solid ${categoryColor}40;">
                    ${label}
                  </span>`;
                })()}
              </td>
              <td style="padding: 0.75rem; text-align: right; vertical-align: top; width: 120px; min-width: 120px;">
                ${(() => {
                  const schemaTypes = row.schemaTypes || [];
                  if (schemaTypes.length === 0) {
                    return '<span style="color: #94a3b8; font-style: italic; font-size: 0.8rem;">0</span>';
                  }
                  // Ensure schemaTypes are strings (handle both string arrays and object arrays)
                  const typeStrings = schemaTypes.map(t => {
                    if (typeof t === 'string') return t;
                    if (typeof t === 'object' && t !== null) {
                      // Handle objects like {type: 'FAQPage', count: 5}
                      return t.type || String(t);
                    }
                    return String(t);
                  }).filter(Boolean);
                  
                  if (typeStrings.length === 0) {
                    return '<span style="color: #94a3b8; font-style: italic; font-size: 0.8rem;">0</span>';
                  }
                  
                  // Show just the count with hover tooltip showing full list
                  const count = typeStrings.length;
                  const fullList = typeStrings.join(', ');
                  const countText = count === 1 ? '1 schema type' : `${count} schema types`;
                  return `<span style="color: #475569; font-size: 0.85rem; font-weight: 600; cursor: help; text-decoration: underline; text-decoration-style: dotted; text-underline-offset: 2px;" title="${fullList}">${countText}</span>`;
                })()}
              </td>
              <td style="padding: 0.55rem 0.75rem; color: #475569; font-size: 0.8rem; line-height: 1.35; vertical-align: top;">
                <div title="${String(row.recommendation || '').replace(/\"/g, '&quot;')}" style="overflow: hidden; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical;">
                  ${row.recommendation}
                </div>
              </td>
              <td style="padding: 0.75rem; text-align: center; vertical-align: top;">
                ${(() => {
                  // Use the same status lookup as Ranking & AI for consistency
                  const taskType = 'on_page';
                  // Create a row-like object for getOptimisationStatus (it expects keyword and best_url/targetUrl)
                  const statusRow = {
                    keyword: '', // Empty for page-level tasks
                    best_url: row.url,
                    targetUrl: row.url,
                    ranking_url: row.url
                  };
                  
                  // First check the main cache
                  let status = window.getOptimisationStatus ? window.getOptimisationStatus(statusRow, taskType) : null;
                  
                  // Debug: Log status lookup for ALL pages (not just landscape) to trace the issue
                  if (status) {
                    console.log('[Money Pages] Status lookup result:', {
                      url: row.url,
                      hasId: 'id' in status,
                      hasTaskId: 'task_id' in status,
                      id: status.id,
                      task_id: status.task_id,
                      status: status.status,
                      allKeys: Object.keys(status).slice(0, 10) // First 10 keys
                    });
                    
                    // CRITICAL: Ensure id field exists - if not, try to get it from task_id or log error
                    if (!status.id) {
                      console.error('[Money Pages] Status object missing id field:', {
                        url: row.url,
                        status,
                        hasTaskId: 'task_id' in status,
                        task_id: status.task_id
                      });
                      // Try to use task_id as fallback
                      if (status.task_id) {
                        status.id = status.task_id;
                        console.warn('[Money Pages] Using task_id as fallback for id');
                      }
                    }
                  } else {
                    // Log when status is not found
                    const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(row.url) : row.url.toLowerCase().trim();
                    const expectedKey = `::${urlKey}::on_page`;
                    const cacheHasKey = window.optimisationStatusCache ? window.optimisationStatusCache.has(expectedKey) : false;
                    console.log('[Money Pages] Status not found for:', {
                      url: row.url,
                      urlKey,
                      expectedKey,
                      cacheHasKey,
                      cacheSize: window.optimisationStatusCache?.size || 0
                    });
                  }
                  
                  // If not found, check temporary cache (for newly created tasks)
                  if (!status && window.moneyPagesTaskCache) {
                    const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(row.url) : row.url.toLowerCase().trim();
                    const tempTask = window.moneyPagesTaskCache.get(urlKey);
                    if (tempTask) {
                      // Build a status object from the temporary cache
                      status = {
                        id: tempTask.id,
                        status: tempTask.status || 'planned',
                        cycle_number: tempTask.cycle_number || 1,
                        cycle_id: tempTask.cycle_id || null,
                        objective_state: 'on_track'
                      };
                      console.log('[Money Pages] Using temporary cache for:', row.url, status);
                    }
                  }
                  
                  // Debug logging for landscape page
                  if (row.url && row.url.includes('landscape-photography-workshops')) {
                    const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(row.url) : row.url.toLowerCase().trim();
                    const expectedKey = `::${urlKey}::on_page`;
                    const cacheHasKey = window.optimisationStatusCache ? window.optimisationStatusCache.has(expectedKey) : false;
                    const allKeys = window.optimisationStatusCache ? Array.from(window.optimisationStatusCache.keys()) : [];
                    const matchingKeys = allKeys.filter(k => k.includes(urlKey) || k.includes('landscape'));
                    
                    console.log('[Money Pages] Status lookup for landscape page:', {
                      url: row.url,
                      urlKey,
                      expectedKey,
                      found: !!status,
                      status: status?.status,
                      taskId: status?.id,
                      cacheSize: window.optimisationStatusCache ? window.optimisationStatusCache.size : 0,
                      tempCacheSize: window.moneyPagesTaskCache ? window.moneyPagesTaskCache.size : 0,
                      cacheHasKey,
                      matchingKeys: matchingKeys.slice(0, 5)
                    });
                  }
                  
                  if (!status || typeof status !== 'object' || !status.status) {
                    // Not tracked - show Track button
                    return `
                      <div style="display: flex; flex-direction: column; gap: 0.25rem; align-items: center;">
                        <span style="display: inline-block; padding: 0.125rem 0.5rem; border-radius: 4px; font-size: 0.7rem; font-weight: 600; background: #94a3b820; color: #94a3b8; border: 1px solid #94a3b840;">
                          Not tracked
                        </span>
                        <button 
                          onclick="event.stopPropagation(); window.trackMoneyPage('${row.url.replace(/'/g, "\\'")}', '${(row.title || row.url).replace(/'/g, "\\'")}')"
                          data-row-url="${row.url.replace(/"/g, '&quot;')}"
                          style="font-size: 0.75rem; padding: 0.375rem 0.75rem; border-radius: 4px; border: 1px solid #10b981; background: #10b981; cursor: ${window.isShareMode ? 'not-allowed' : 'pointer'}; color: white; font-weight: 600; transition: all 0.2s; white-space: nowrap; opacity: ${window.isShareMode ? '0.5' : '1'};"
                          ${window.isShareMode ? 'disabled' : ''}
                          onmouseover="${window.isShareMode ? '' : "this.style.background='#059669'; this.style.borderColor='#059669';"}"
                          onmouseout="${window.isShareMode ? '' : "this.style.background='#10b981'; this.style.borderColor='#10b981';"}"
                          title="${window.isShareMode ? 'Not available in share mode (read-only)' : `Create optimisation task for ${row.url} (CTR  2.5%)`}">
                          Track
                        </button>
                      </div>
                    `;
                  }
                  
                  // Tracked - show status pill + cycle info + Manage button (same as Ranking & AI)
                  const statusText = {
                    'planned': 'Planned',
                    'in_progress': 'In progress',
                    'monitoring': 'Monitoring',
                    'done': 'Done',
                    'paused': 'Paused',
                    'cancelled': 'Cancelled'
                  }[status.status] || status.status;
                  
                  // Status colors (matching Ranking & AI)
                  let statusBg, statusColor;
                  if (status.status === 'planned') {
                    statusBg = '#e9d5ff';
                    statusColor = '#6b21a8';
                  } else if (status.status === 'in_progress') {
                    statusBg = '#fed7aa';
                    statusColor = '#9a3412';
                  } else if (status.status === 'monitoring') {
                    statusBg = '#dbeafe';
                    statusColor = '#1e40af';
                  } else if (status.status === 'done') {
                    statusBg = '#dcfce7';
                    statusColor = '#166534';
                  } else if (status.status === 'paused') {
                    statusBg = '#e5e7eb';
                    statusColor = '#374151';
                  } else if (status.status === 'cancelled') {
                    statusBg = '#fee2e2';
                    statusColor = '#991b1b';
                  } else {
                    statusBg = '#f9fafb';
                    statusColor = '#4b5563';
                  }
                  
                  // Cycle info
                  const cycleNo = status.cycle_active || 1;
                  let cycleText = 'Cycle ' + cycleNo;
                  if (status.last_activity_at) {
                    const lastActivity = new Date(status.last_activity_at);
                    const now = new Date();
                    const daysAgo = Math.floor((now - lastActivity) / (1000 * 60 * 60 * 24));
                    const timeText = daysAgo === 0 ? 'Today' : daysAgo === 1 ? '1 day ago' : daysAgo + ' days ago';
                    cycleText += ' ' + timeText;
                  }
                  
                  const taskId = status.id || status.task_id;
                  
                  // Validate taskId exists
                  if (!taskId) {
                    console.error('[Money Pages] Task ID missing in status object:', {
                      status,
                      hasId: 'id' in status,
                      hasTaskId: 'task_id' in status,
                      statusKeys: Object.keys(status),
                      url: row.url
                    });
                    return '<div style="display: flex; flex-direction: column; gap: 0.25rem; align-items: center;"><span style="color: #ef4444; font-size: 0.7rem;">Error: Task ID missing</span></div>';
                  }
                  
                  // Debug: Log taskId extraction for landscape page
                  if (row.url && row.url.includes('landscape-photography-workshops')) {
                    console.log('[Money Pages] TaskId extraction for landscape page:', {
                      url: row.url,
                      statusId: status.id,
                      statusTaskId: status.task_id,
                      extractedTaskId: taskId,
                      statusType: typeof taskId,
                      statusObject: {
                        id: status.id,
                        task_id: status.task_id,
                        hasId: 'id' in status,
                        hasTaskId: 'task_id' in status,
                        allKeys: Object.keys(status).slice(0, 15)
                      }
                    });
                  }
                  
                  // Escape taskId for use in onclick attribute (it's a UUID string, so needs quotes)
                  const taskIdEscaped = String(taskId).replace(/'/g, "\\'").replace(/"/g, '&quot;');
                  
                  // DEBUG: Log the onclick handler that will be generated
                  if (row.url && row.url.includes('landscape-photography-workshops')) {
                    const onclickHandler = `window.openOptimisationTaskDrawer('${taskIdEscaped}')`;
                    console.log('[Money Pages] Generated onclick handler for landscape page:', {
                      taskId: taskId,
                      taskIdEscaped: taskIdEscaped,
                      onclickHandler: onclickHandler,
                      onclickLength: onclickHandler.length
                    });
                  }
                  return '<div style="display: flex; flex-direction: column; gap: 0.25rem; align-items: center;">' +
                    '<span style="display: inline-block; padding: 0.125rem 0.5rem; border-radius: 4px; font-size: 0.7rem; font-weight: 600; background: ' + statusBg + '; color: ' + statusColor + '; border: 1px solid ' + statusColor + '40; text-transform: capitalize;">' +
                      escapeHtml(statusText) +
                    '</span>' +
                    '<div style="font-size: 0.65rem; color: #64748b; margin: 0.125rem 0;">' +
                      escapeHtml(cycleText) +
                    '</div>' +
                    '<button ' +
                      'onclick="event.stopPropagation(); window.openOptimisationTaskDrawer(\'' + taskIdEscaped + '\')" ' +
                      'style="font-size: 0.75rem; padding: 0.375rem 0.75rem; border-radius: 4px; border: 1px solid #a3d977; background: #E5FFCC; cursor: pointer; color: #000000; font-weight: 600; transition: all 0.2s; white-space: nowrap;" ' +
                      'onmouseover="this.style.background=\'#d4f5a8\'; this.style.borderColor=\'#8bc34a\';" ' +
                      'onmouseout="this.style.background=\'#E5FFCC\'; this.style.borderColor=\'#a3d977\';" ' +
                      'title="Open task details, update status, add notes, record measurements, start new cycle.">' +
                      'Manage' +
                    '</button>' +
                  '</div>';
                })()}
              </td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        // Pagination controls and total count (using filtered data)
        tableHtml += `
          <div style="margin-top: 1rem; display: flex; justify-content: space-between; align-items: center; padding-top: 1rem; border-top: 1px solid #e2e8f0; flex-wrap: wrap; gap: 1rem;">
            <div style="font-size: 0.85rem; color: #64748b;">
              ${filteredTotalPages > 1 ? `Page ${currentPage} of ${filteredTotalPages}  ` : ''}Total URLs: ${filteredRows.length}${filteredRows.length !== sortedRows.length ? ` (filtered from ${sortedRows.length})` : ''}
            </div>
            <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
              <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                Rows per page:
                <select id="money-pages-rows-per-page" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; background: white; cursor: pointer;">
                  <option value="10" ${rowsPerPage === 10 ? 'selected' : ''}>10</option>
                  <option value="25" ${rowsPerPage === 25 ? 'selected' : ''}>25</option>
                  <option value="50" ${rowsPerPage === 50 ? 'selected' : ''}>50</option>
                  <option value="100" ${rowsPerPage === 100 ? 'selected' : ''}>100</option>
                  <option value="200" ${rowsPerPage === 200 ? 'selected' : ''}>200</option>
                </select>
              </label>
              ${filteredTotalPages > 1 ? `
              <button id="money-pages-prev" type="button" ${currentPage === 1 ? 'disabled' : ''} style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cbd5e1; background: ${currentPage === 1 ? '#f1f5f9' : 'white'}; cursor: ${currentPage === 1 ? 'not-allowed' : 'pointer'}; color: ${currentPage === 1 ? '#94a3b8' : '#475569'}; font-weight: 600; transition: all 0.2s;" ${currentPage === 1 ? '' : 'onmouseover="this.style.background=\'#f8f9fa\'; this.style.borderColor=\'#94a3b8\';" onmouseout="this.style.background=\'white\'; this.style.borderColor=\'#cbd5e1\';"'}>
                Previous
              </button>
              <button id="money-pages-next" type="button" ${currentPage === filteredTotalPages ? 'disabled' : ''} style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cbd5e1; background: ${currentPage === filteredTotalPages ? '#f1f5f9' : 'white'}; cursor: ${currentPage === filteredTotalPages ? 'not-allowed' : 'pointer'}; color: ${currentPage === filteredTotalPages ? '#94a3b8' : '#475569'}; font-weight: 600; transition: all 0.2s;" ${currentPage === filteredTotalPages ? '' : 'onmouseover="this.style.background=\'#f8f9fa\'; this.style.borderColor=\'#94a3b8\';" onmouseout="this.style.background=\'white\'; this.style.borderColor=\'#cbd5e1\';"'}>
                Next
              </button>
              ` : ''}
            </div>
          </div>
        `;
        
        return tableHtml;
        } catch (error) {
          debugLog(`Error in renderMoneyPagesTable: ${error.message}`, 'error');
          return '<div style="font-size: 0.85rem; color: #ef4444; padding: 1rem; text-align: center; border: 1px solid #fecaca; border-radius: 4px; background: #fef2f2;">Error rendering table. Please refresh the page.</div>';
        }
      }
      
      // Get filtered money pages metrics based on current filter state
      // (canonical implementation lives later in the file; this old duplicate was removed)
      
      // Update summary metrics with sub-segment filtering
      function updateMoneyPagesSummaryMetrics(moneyPagesMetrics) {
        if (!moneyPagesMetrics) return;
        
        // Use the new function that applies all filters
        const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
        if (!filteredMetrics) return;
        
        const { overview } = filteredMetrics;
        const summaryClickEl = document.getElementById('money-summary-click-share');
        const summaryCtrEl = document.getElementById('money-summary-ctr');
        const summaryPosEl = document.getElementById('money-summary-position');
        const summaryCovEl = document.getElementById('money-summary-coverage');
        
        if (!overview || !summaryClickEl || !summaryCtrEl || !summaryPosEl || !summaryCovEl) {
          return;
        }
        
        const moneyClicks = overview.moneyClicks || 0;
        const moneyImpressions = overview.moneyImpressions || 0;
        const siteClicks = overview.siteTotalClicks || 0;
        const siteImpressions = overview.siteTotalImpressions || 0;
        
        // Summary metrics
        const clickSharePct = siteClicks && siteClicks > 0 ? (moneyClicks / siteClicks) * 100 : null;
        const moneyCtrPct = (overview.moneyCtr || 0) * 100;
        const siteCtrPct = (overview.siteCtr || 0) * 100;
        const moneyPos = overview.moneyAvgPosition;
        const sitePos = overview.siteAvgPosition;
        const coverageCount = overview.moneyCoverageCount || 0;
        
        // Helper for RAG label class
        function labelClass(score) {
          if (score == null) return 'pill pill-muted';
          if (score >= 70) return 'pill pill-success';
          if (score >= 40) return 'pill pill-warning';
          return 'pill pill-danger';
        }
        
        // Update cards
        summaryClickEl.innerHTML =
          `<div class="metric-label">Share of site clicks</div>
           <div class="metric-value">
             ${clickSharePct != null ? clickSharePct.toFixed(1) + '%' : ''}
           </div>
           <div class="metric-sub">
             Money pages clicks: ${moneyClicks.toLocaleString()}
             ${siteClicks ? ` of ${siteClicks.toLocaleString()} total` : ''}
           </div>`;
        
        let ctrScore = null;
        if (siteCtrPct > 0) {
          ctrScore = moneyCtrPct >= siteCtrPct ? 75 : 30;
        }
        summaryCtrEl.innerHTML =
          `<div class="metric-label">CTR vs site</div>
           <div class="metric-value">
             ${moneyCtrPct.toFixed(2)}%
             <span class="metric-sub">vs ${siteCtrPct.toFixed(1)}% site</span>
           </div>`;
        summaryCtrEl.className = 'metric-card ' + labelClass(ctrScore);
        
        let posScore = null;
        if (moneyPos && sitePos) {
          posScore = moneyPos <= sitePos ? 70 : 30;
        }
        summaryPosEl.innerHTML =
          `<div class="metric-label">Average position</div>
           <div class="metric-value">
             ${moneyPos ? moneyPos.toFixed(1) : ''}
             <span class="metric-sub">vs ${sitePos ? sitePos.toFixed(1) : ''} site</span>
           </div>`;
        summaryPosEl.className = 'metric-card ' + labelClass(posScore);
        
        summaryCovEl.innerHTML =
          `<div class="metric-label">Money pages with impressions</div>
           <div class="metric-value">
             ${coverageCount}
           </div>
           <div class="metric-sub">
             Based on GSC pages only
           </div>`;
      }
      
      // Update sub-segment dropdown counts
      function updateMoneyPagesSubSegmentCounts(moneyPagesMetrics) {
        if (!moneyPagesMetrics || !moneyPagesMetrics.rows) return;
        
        const rows = moneyPagesMetrics.rows || [];
        
        // Count by sub-segment
        const counts = {
          ALL: rows.length,
          PRODUCT: 0,
          EVENT: 0,
          LANDING: 0
        };
        
        rows.forEach(row => {
          const subSegment = row.subSegment || row.segmentType || 'LANDING';
          if (subSegment === 'PRODUCT' || subSegment === 'product') {
            counts.PRODUCT++;
          } else if (subSegment === 'EVENT' || subSegment === 'event') {
            counts.EVENT++;
          } else if (subSegment === 'LANDING' || subSegment === 'landing') {
            counts.LANDING++;
          }
        });
        
        // Update dropdown options with counts
        const allOption = document.getElementById('money-subsegment-all');
        const productOption = document.getElementById('money-subsegment-product');
        const eventOption = document.getElementById('money-subsegment-event');
        const landingOption = document.getElementById('money-subsegment-landing');
        
        if (allOption) allOption.textContent = `All sub-segments (${counts.ALL})`;
        if (productOption) productOption.textContent = `Product Pages (${counts.PRODUCT})`;
        if (eventOption) eventOption.textContent = `Event Pages (${counts.EVENT})`;
        if (landingOption) landingOption.textContent = `Landing Pages (${counts.LANDING})`;
      }
      
      // Update type filter dropdown counts (for Priority & Actions)
      function updateMoneyPagesTypeFilterCounts(sourcePages) {
        if (!sourcePages || !Array.isArray(sourcePages)) return;
        
        // Count by segment type
        const counts = {
          all: sourcePages.length,
          authority: 0,
          landing: 0,
          event: 0,
          product: 0
        };
        
        sourcePages.forEach(page => {
          const segmentType = page.segmentType || 'landing';
          if (segmentType === 'authority') {
            counts.authority++;
          } else if (segmentType === 'landing') {
            counts.landing++;
          } else if (segmentType === 'event') {
            counts.event++;
          } else if (segmentType === 'product') {
            counts.product++;
          }
        });
        
        // Update dropdown options with counts
        const typeFilterEl = document.getElementById('money-pages-type-filter');
        if (typeFilterEl) {
          const options = typeFilterEl.querySelectorAll('option');
          options.forEach(opt => {
            const value = opt.value;
            if (value === 'all') {
              opt.textContent = `All money pages (${counts.all})`;
            } else if (value === 'authority') {
              opt.textContent = `Authority (${counts.authority})`;
            } else if (value === 'landing') {
              opt.textContent = `Landing pages (${counts.landing})`;
            } else if (value === 'event') {
              opt.textContent = `Event pages (${counts.event})`;
            } else if (value === 'product') {
              opt.textContent = `Product pages (${counts.product})`;
            }
          });
        }
      }
      
      // Function to populate AI citations for Money Pages table
      async function populateMoneyPagesAiCitations(rows) {
        try {
          // If no rows provided, try to get from window.moneyPagesData
          if (!rows || rows.length === 0) {
            rows = window.moneyPagesData || [];
          }
          
          if (!rows || rows.length === 0) {
            return;
          }
          
          // Wait a bit for DOM to be ready
          await new Promise(resolve => setTimeout(resolve, 300));
          
          // Check if table container exists
          let tableContainer = document.getElementById('money-pages-table-container');
          if (!tableContainer) {
            return;
          }
          
          // Verify tableContainer is a valid DOM element
          if (typeof tableContainer.querySelectorAll !== 'function') {
            console.error('[Money Pages AI Citations] tableContainer is not a valid DOM element');
            return;
          }
        
        // Check if cells exist in the table
        const cells = tableContainer.querySelectorAll('.ai-citation-cell-opportunity');
        
        if (!cells || cells.length === 0) {
          console.warn('[Money Pages AI Citations] No cells found in table');
          return;
        }
        
        console.log(`[Money Pages AI Citations] Found ${cells.length} cells to populate`);
        
        // Get property URL for API calls
        const propertyUrl = document.getElementById('propertyUrl')?.value || localStorage.getItem('property_url') || '';
        
        if (!propertyUrl) {
          return;
        }
        
        // Normalize URL helper function (same as API endpoint)
        const normalizeUrl = (url) => {
          if (!url) return '';
          let normalized = String(url).toLowerCase().trim();
          normalized = normalized.replace(/^https?:\/\//, '');
          normalized = normalized.replace(/^www\./, '');
          normalized = normalized.split('?')[0].split('#')[0];
          // Extract path portion
          const parts = normalized.split('/');
          if (parts.length > 1) {
            normalized = parts.slice(1).join('/');
          }
          normalized = normalized.replace(/^\/+/, '').replace(/\/+$/, '');
          return normalized;
        };
        
        // Try to get citation counts from localStorage cache first
        let citationCache = {};
        // Store cache globally for sorting to access
        if (!window.moneyPagesCitationCache) {
          window.moneyPagesCitationCache = {};
        }
        try {
          const lastAuditResults = localStorage.getItem('last_audit_results');
          if (lastAuditResults) {
            const auditData = JSON.parse(lastAuditResults);
            
            // Try multiple paths to find ranking_ai_data
            let combinedRows = [];
            if (auditData?.ranking_ai_data?.combinedRows) {
              combinedRows = auditData.ranking_ai_data.combinedRows;
            } else if (auditData?.searchData?.ranking_ai_data?.combinedRows) {
              combinedRows = auditData.searchData.ranking_ai_data.combinedRows;
            } else if (Array.isArray(auditData?.ranking_ai_data)) {
              combinedRows = auditData.ranking_ai_data;
            } else if (Array.isArray(auditData?.searchData?.ranking_ai_data)) {
              combinedRows = auditData.searchData.ranking_ai_data;
            }
            
            if (Array.isArray(combinedRows) && combinedRows.length > 0) {
              // Build cache: for each URL, count TOTAL citations (sum across all keywords)
              // Use computeAiMetricsForPageUrl for consistent counting logic
              rows.forEach((row) => {
                const targetUrl = row.url || '';
                if (!targetUrl) return;
                
                // Use computeAiMetricsForPageUrl to get accurate citation count (total citations, not unique keywords)
                if (typeof window.computeAiMetricsForPageUrl === 'function') {
                  try {
                    const result = window.computeAiMetricsForPageUrl(targetUrl, combinedRows);
                    const citationCount = result?.ai_citations != null ? Number(result.ai_citations) : 0;
                    
                    // Cache the result (even if 0) for this URL
                    citationCache[targetUrl] = citationCount;
                    window.moneyPagesCitationCache[targetUrl] = citationCount;
                    // Also set on row object for immediate sorting
                    row._aiCitations = citationCount;
                  } catch (err) {
                    console.error('[Money Pages AI Citations] Error computing citations for', targetUrl, err);
                    citationCache[targetUrl] = 0;
                    window.moneyPagesCitationCache[targetUrl] = 0;
                    row._aiCitations = 0;
                  }
                } else {
                  // Fallback: manual counting (same logic as computeAiMetricsForPageUrl)
                  const targetNormalized = normalizeUrl(targetUrl);
                  let citationCount = 0;
                  
                  combinedRows.forEach(keywordRow => {
                    const citations = keywordRow.ai_alan_citations || [];
                    if (Array.isArray(citations) && citations.length > 0) {
                      citations.forEach(citation => {
                        let citedUrl = '';
                        if (typeof citation === 'string') {
                          citedUrl = citation;
                        } else if (citation && typeof citation === 'object') {
                          citedUrl = citation.url || citation.URL || citation.link || citation.href || citation.page || citation.pageUrl || citation.target || citation.targetUrl || citation.best_url || citation.bestUrl || '';
                        }
                        
                        if (citedUrl) {
                          const citedNormalized = normalizeUrl(citedUrl);
                          // Strict URL matching: exact match or same path segments (not substring matching)
                          // This prevents matching "photography-workshops" when looking for "landscape-photography-workshops"
                          const targetPathParts = targetNormalized.split('/').filter(p => p);
                          const citedPathParts = citedNormalized.split('/').filter(p => p);
                          
                          // Exact match
                          let matches = citedNormalized === targetNormalized;
                          
                          // If not exact, check if paths match (same segments, allowing query/fragment variants)
                          // Only match if the citation path starts with the target path (not substring matching)
                          if (!matches && targetPathParts.length > 0 && citedPathParts.length >= targetPathParts.length) {
                            // Check if citation path starts with target path segments
                            matches = targetPathParts.every((part, idx) => citedPathParts[idx] === part);
                          }
                          
                          if (matches) {
                            citationCount++;
                          }
                        }
                      });
                    }
                  });
                  
                  // Cache the result (even if 0) for this URL
                  citationCache[targetUrl] = citationCount;
                  window.moneyPagesCitationCache[targetUrl] = citationCount;
                  // Also set on row object for immediate sorting
                  row._aiCitations = citationCount;
                }
              });
            }
          }
        } catch (err) {
          console.error('[Money Pages AI Citations] Error reading localStorage:', err);
        }
        
        // Update cells with cached data first
        // Build a normalized URL lookup map for efficient matching
        const normalizedCache = {};
        Object.keys(citationCache).forEach(url => {
          const normalized = normalizeUrl(url);
          normalizedCache[normalized] = citationCache[url];
        });
        
        cells.forEach((cell) => {
          const pageUrl = cell.getAttribute('data-page-url');
          if (!pageUrl) return;
          
          // Try exact match first, then normalized match
          let cachedCount = citationCache[pageUrl];
          if (typeof cachedCount !== 'number') {
            const pageUrlNormalized = normalizeUrl(pageUrl);
            cachedCount = normalizedCache[pageUrlNormalized];
          }
          
          // If cached value exists, render it and store on the row for sorting
          if (typeof cachedCount === 'number') {
            cell.textContent = cachedCount.toLocaleString();
            cell.style.color = '#0f172a';
            cell.style.fontWeight = '600';
            const pageUrlNormalized = normalizeUrl(pageUrl);
            const row = rows.find(r => {
              const rowUrl = r.url || '';
              return rowUrl === pageUrl || normalizeUrl(rowUrl) === pageUrlNormalized;
            });
            if (row) {
              row._aiCitations = cachedCount;
            }
            return;
          }
          
          // No cache: Check if cell already has a valid numeric value from initial render
          // This prevents clearing valid values when table is re-rendered after sorting
          const existingText = String(cell.textContent || '').trim();
          const existingNumeric = parseInt(existingText.replace(/,/g, ''), 10);
          
          // If cell has a valid number (not  or ), preserve it and update cache
          if (!Number.isNaN(existingNumeric) && existingNumeric >= 0 && existingText !== '' && existingText !== '') {
            // Preserve the displayed value and set it on the row for sorting
            const pageUrlNormalized = normalizeUrl(pageUrl);
            const row = rows.find(r => {
              const rowUrl = r.url || '';
              return rowUrl === pageUrl || normalizeUrl(rowUrl) === pageUrlNormalized;
            });
            if (row) {
              // Set on row for sorting
              row._aiCitations = existingNumeric;
              // Update cache to prevent API overwrite
              citationCache[pageUrl] = existingNumeric;
              window.moneyPagesCitationCache[pageUrl] = existingNumeric;
            }
            // Return early - don't clear valid displayed values
            return;
          }
          
          // Also check global cache one more time with normalized URL (in case key format differs)
          const pageUrlNormalized = normalizeUrl(pageUrl);
          const globalCached = window.moneyPagesCitationCache && Object.keys(window.moneyPagesCitationCache).find(key => {
            const keyNormalized = normalizeUrl(key);
            return keyNormalized === pageUrlNormalized || key === pageUrl;
          });
          if (globalCached && typeof window.moneyPagesCitationCache[globalCached] === 'number') {
            const globalCount = window.moneyPagesCitationCache[globalCached];
            cell.textContent = globalCount.toLocaleString();
            cell.style.color = '#0f172a';
            cell.style.fontWeight = '600';
            const row = rows.find(r => {
              const rowUrl = r.url || '';
              return rowUrl === pageUrl || normalizeUrl(rowUrl) === pageUrlNormalized;
            });
            if (row) {
              row._aiCitations = globalCount;
            }
            // Also update local cache
            citationCache[pageUrl] = globalCount;
            return;
          }
          
          // Only set placeholder if we truly have no cache and no existing value
          if (existingText === '' || existingText === '' || existingText === '') {
            cell.textContent = '';
            cell.style.color = '#94a3b8';
            cell.style.fontWeight = '500';
          }
          // Otherwise, preserve whatever is already displayed
        });
        
        // For URLs not in cache (or showing 0), fetch from API to get accurate counts
        // Check both local citationCache and global window.moneyPagesCitationCache
        const urlsToFetch = rows
          .map(row => row.url)
          .filter(url => {
            if (!url) return false;
            const localCache = citationCache[url];
            const globalCache = window.moneyPagesCitationCache?.[url];
            // Only fetch if both caches are missing or 0
            const hasValidCache = (typeof localCache === 'number' && localCache > 0) || 
                                  (typeof globalCache === 'number' && globalCache > 0);
            return !hasValidCache;
          });
        
        if (urlsToFetch.length > 0) {
          // Build cell map ONCE before processing batches (more efficient)
          const currentTableContainer = document.getElementById('money-pages-table-container');
          if (!currentTableContainer || typeof currentTableContainer.querySelectorAll !== 'function') {
            console.warn('[Money Pages AI Citations] Table container not found when building cell map');
            return;
          }
          const allCells = currentTableContainer.querySelectorAll('.ai-citation-cell-opportunity');
          
          // Create a map: URL (exact and normalized) -> cell element
          const cellMap = new Map();
          Array.from(allCells).forEach(cell => {
            const cellUrl = cell.getAttribute('data-page-url');
            if (cellUrl) {
              // Store exact URL
              cellMap.set(cellUrl, cell);
              // Also store normalized version for flexible matching
              const cellUrlNormalized = normalizeUrl(cellUrl);
              if (cellUrlNormalized !== cellUrl && !cellMap.has(cellUrlNormalized)) {
                cellMap.set(cellUrlNormalized, cell);
              }
            }
          });
          
          console.log(`[Money Pages AI Citations] Built cell map with ${cellMap.size} entries from ${allCells.length} cells`);
          
          // Debug: Log sample cell URLs to understand format
          if (allCells.length > 0) {
            const sampleCellUrls = Array.from(allCells).slice(0, 5).map(c => c.getAttribute('data-page-url'));
            console.log(`[Money Pages AI Citations] Sample cell URLs (first 5):`, sampleCellUrls);
          }
          
          // Debug: Log sample row URLs we'll be searching for
          if (rows.length > 0) {
            const sampleRowUrls = rows.slice(0, 5).map(r => r.url);
            console.log(`[Money Pages AI Citations] Sample row URLs to search (first 5):`, sampleRowUrls);
          }
          
          // Fetch citations for all URLs in parallel (limit to 10 at a time)
          const batchSize = 10;
          let cellNotFoundCount = 0;
          for (let i = 0; i < urlsToFetch.length; i += batchSize) {
            const batch = urlsToFetch.slice(i, i + batchSize);
            
            const promises = batch.map(async (url) => {
              try {
                // Use the same API endpoint as the cards (which are working correctly)
                // Skip client-side computation which has URL matching bugs
                // This ensures table and cards use the same source of truth
                const apiUrlFull = apiUrl(`/api/supabase/query-keywords-citing-url?property_url=${encodeURIComponent(propertyUrl)}&target_url=${encodeURIComponent(url)}`);
                const response = await fetch(apiUrlFull);
                if (response.ok) {
                  const result = await response.json();
                  if (result.status === 'ok' && typeof result.count === 'number') {
                    return { url, count: result.count };
                  }
                }
              } catch (err) {
                // Silently handle fetch errors
              }
              // Return null instead of 0 to indicate "unknown" - don't overwrite valid values
              return { url, count: null };
            });
            
            const results = await Promise.all(promises);
            
            results.forEach(({ url, count }) => {
              // Only update if we got a valid count (not null)
              if (count === null) {
                // Unknown - don't overwrite existing values
                return;
              }
              
              // Don't overwrite a valid cached value (prevent flickering and incorrect overwrites)
              // The cache is built from localStorage (latest audit data) and is more reliable than API
              // Only update if cache is missing/undefined/0 - never overwrite a valid cached value
              const existingCache = citationCache[url];
              if (typeof existingCache === 'number' && existingCache > 0) {
                // We have a valid cached value from localStorage - trust it over API response
                // This prevents overwriting correct values (e.g., 2) with incorrect API responses (e.g., 5 from historical data or URL matching issues)
                console.log(`[Money Pages AI Citations] Preserving cached count ${existingCache} for ${url} (API returned ${count}, but cache is trusted)`);
                return;
              }
              
              // Only update if cache is missing/0 - API is fallback for missing data
              citationCache[url] = count;
              // Also store in global cache for sorting
              window.moneyPagesCitationCache[url] = count;
              
              // Try to find cell: exact match first, then normalized, then flexible matching
              const urlNormalized = normalizeUrl(url);
              let cell = cellMap.get(url) || cellMap.get(urlNormalized);
              
              // If still not found, try iterating through cells with flexible matching
              if (!cell) {
                // Try multiple matching strategies
                cell = Array.from(allCells).find(c => {
                  const cellUrl = c.getAttribute('data-page-url');
                  if (!cellUrl) return false;
                  
                  // Strategy 1: Exact match
                  if (cellUrl === url) return true;
                  
                  // Strategy 2: Normalized match
                  const cellUrlNormalized = normalizeUrl(cellUrl);
                  if (cellUrlNormalized === urlNormalized) return true;
                  
                  // Strategy 3: Partial match (either contains the other)
                  if (cellUrlNormalized && urlNormalized) {
                    if (cellUrlNormalized.includes(urlNormalized) || urlNormalized.includes(cellUrlNormalized)) {
                      return true;
                    }
                  }
                  
                  // Strategy 4: Match by path segment (last meaningful part of URL)
                  const urlPath = urlNormalized.split('/').filter(p => p).pop() || '';
                  const cellPath = cellUrlNormalized.split('/').filter(p => p).pop() || '';
                  if (urlPath && cellPath && urlPath === cellPath && urlPath.length > 5) {
                    return true;
                  }
                  
                  return false;
                });
              }
              
              if (cell) {
                // Check if we have a valid cached value first (trust cache over API)
                const cachedValue = citationCache[url] || window.moneyPagesCitationCache?.[url];
                if (typeof cachedValue === 'number' && cachedValue > 0) {
                  // We have a valid cached value - don't overwrite with API response
                  console.log(`[Money Pages AI Citations] Preserving cached count ${cachedValue} for ${url} (API returned ${count}, but cache is trusted)`);
                  // Ensure cell displays cached value
                  if (parseInt(String(cell.textContent || '').replace(/,/g, ''), 10) !== cachedValue) {
                    cell.textContent = cachedValue.toLocaleString();
                    cell.style.color = '#0f172a';
                    cell.style.fontWeight = '600';
                  }
                  // Update row even if we don't update cell
                  const urlNormalized = normalizeUrl(url);
                  const row = rows.find(r => {
                    const rowUrl = r.url || '';
                    const rowUrlNormalized = normalizeUrl(rowUrl);
                    return rowUrl === url || rowUrlNormalized === urlNormalized;
                  });
                  if (row) {
                    row._aiCitations = cachedValue;
                  }
                  return;
                }
                
                // Don't overwrite a valid displayed value with 0 or null
                const existingText = String(cell.textContent || '').trim();
                const existingDisplay = parseInt(existingText.replace(/,/g, ''), 10);
                if (!Number.isNaN(existingDisplay) && existingDisplay > 0) {
                  if (count === 0 || count === null) {
                    console.log(`[Money Pages AI Citations] Preserving displayed count ${existingDisplay} for ${url} (API returned ${count})`);
                    // Still update row with existing value
                    const urlNormalized = normalizeUrl(url);
                    const row = rows.find(r => {
                      const rowUrl = r.url || '';
                      const rowUrlNormalized = normalizeUrl(rowUrl);
                      return rowUrl === url || rowUrlNormalized === urlNormalized;
                    });
                    if (row) {
                      row._aiCitations = existingDisplay;
                    }
                    return;
                  }
                }
                
                // Only update if we have a valid count from API
                if (count !== null && count !== undefined) {
                  cell.textContent = count.toLocaleString();
                  cell.style.color = '#0f172a';
                  cell.style.fontWeight = '600';
                  
                  // Update row - use flexible matching to find the row
                  const urlNormalized = normalizeUrl(url);
                  let row = rows.find(r => {
                    const rowUrl = r.url || '';
                    const rowUrlNormalized = normalizeUrl(rowUrl);
                    // Strict matching: exact match or normalized match only (no substring)
                    return rowUrl === url || rowUrlNormalized === urlNormalized;
                  });
                  
                  // If not found with strict matching, try matching by cell's data-page-url
                  if (!row) {
                    const cellUrl = cell.getAttribute('data-page-url');
                    if (cellUrl) {
                      const cellUrlNormalized = normalizeUrl(cellUrl);
                      row = rows.find(r => {
                        const rowUrl = r.url || '';
                        const rowUrlNormalized = normalizeUrl(rowUrl);
                        return rowUrl === cellUrl || rowUrlNormalized === cellUrlNormalized;
                      });
                    }
                  }
                  
                  if (row) {
                    row._aiCitations = count;
                  }
                }
              } else {
                cellNotFoundCount++;
                // Suppress all console warnings - URL matching is complex and warnings are not actionable
              }
            });
          }
          
          // Suppress console warnings - URL matching issues are expected and not actionable
        }
        } catch (err) {
          console.error('[Money Pages AI Citations] CRITICAL ERROR in function:', err);
          console.error('[Money Pages AI Citations] Error stack:', err.stack);
          debugLog(`[Money Pages] Critical error in populateMoneyPagesAiCitations: ${err.message}`, 'error');
        }
      }
      
      // Debug function: manually test AI citations population
      window.testMoneyPagesAiCitations = function() {
        const tableContainer = document.getElementById('money-pages-table-container');
        if (!tableContainer) {
          console.error('Table container not found');
          return;
        }
        const cells = tableContainer.querySelectorAll('.ai-citation-cell-opportunity');
        console.log('Found', cells.length, 'cells');
        cells.forEach((cell, idx) => {
          const url = cell.getAttribute('data-page-url');
          console.log(`Cell ${idx}:`, url, 'Current text:', cell.textContent);
        });
        
        // Get rows from window.moneyPagesData
        const rows = window.moneyPagesData || [];
        console.log('Available rows:', rows.length);
        if (rows.length > 0) {
          console.log('First 3 row URLs:', rows.slice(0, 3).map(r => r.url));
          populateMoneyPagesAiCitations(rows);
        } else {
          console.error('No rows data available');
        }
      };

      // Function to render Money Pages Performance section
      async function renderMoneyPagesSection(moneyPagesMetrics) {
        // CRITICAL: Fetch optimisation statuses BEFORE rendering tables to ensure cache is populated.
        // Only do this when an admin key is present; otherwise the endpoint returns 401 and clears cache.
        const canFetchOptimisationStatuses =
          typeof window.fetchOptimisationStatuses === 'function' &&
          typeof window.hasAdminKey === 'function' &&
          window.hasAdminKey();

        if (canFetchOptimisationStatuses) {
          const allStatusRows = [];
          
          // Add Opportunity table rows
          if (moneyPagesMetrics && moneyPagesMetrics.rows && moneyPagesMetrics.rows.length > 0) {
            moneyPagesMetrics.rows.forEach(row => {
              allStatusRows.push({
                keyword: '', // Empty for page-level tasks
                best_url: row.url,
                targetUrl: row.url,
                ranking_url: row.url
              });
            });
          }
          
          // Add Priority table rows
          if (window.moneyPagePriorityData && window.moneyPagePriorityData.length > 0) {
            window.moneyPagePriorityData.forEach(p => {
              allStatusRows.push({
                keyword: '', // Empty for page-level tasks
                best_url: p.url,
                targetUrl: p.url,
                ranking_url: p.url
              });
            });
          }
          
          if (allStatusRows.length > 0) {
            debugLog(`[Money Pages] Fetching statuses for ${allStatusRows.length} rows before initial render`, 'info');
            try {
              await window.fetchOptimisationStatuses(allStatusRows);
              debugLog(`[Money Pages] Status cache populated: ${window.optimisationStatusCache?.size || 0} entries`, 'success');
            } catch (err) {
              debugLog(`[Money Pages] Error fetching statuses before render: ${err.message}`, 'error');
            }
          }
        } else {
          if (moneyPagesMetrics?.rows?.length) {
            debugLog('[Money Pages] Skipping optimisation status fetch (admin key not set)', 'info');
          }
        }
        
        // Get or create the Money Pages panel
        const moneyPanel = document.querySelector('.aigeo-panel[data-panel="money"]');
        if (!moneyPanel) {
          debugLog(' Money Pages panel not found', 'warn');
          return;
        }
        
        // Get or create the money-pages-section element
        let section = document.getElementById('money-pages-section');
        if (!section) {
          debugLog(' Money Pages section element not found, creating it...', 'warn');
          // Create the Money Pages HTML structure if it doesn't exist
          section = document.createElement('div');
          section.id = 'money-pages-section';
          section.style.display = 'block';
          moneyPanel.appendChild(section);
        }
        
        // Check if full structure already exists (created by displayDashboard)
        const existingHeader = section.querySelector('h3[style*="color: var(--brand-dark)"]');
        const existingContainer = section.querySelector('#money-pages-suggested-top10-container');
        if (existingHeader && existingHeader.textContent.includes('Money Pages Performance & Actions') && existingContainer) {
          debugLog(' Money Pages full structure already exists including Suggested Top 10 container, skipping HTML recreation', 'info');
          // Don't overwrite - just ensure section is visible
          section.style.display = 'block';
        } else {
          // Always update the HTML structure to ensure it has the latest canvas IDs
          // Create the full Money Pages HTML structure with all sections
          section.innerHTML = `
          <div style="padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); background: rgba(204, 255, 229, 0.3); border-left: 4px solid #10b981;">
            <h3 style="margin: 0 0 1rem 0; color: var(--brand-dark);">Money Pages Performance & Actions</h3>
            <p style="margin: 0 0 1.5rem 0; font-size: 0.9rem; color: #666; line-height: 1.6;">
              Focused view of your money pages: how much traffic they capture,
              how they convert clicks, and which URLs to improve first.
              This section uses 30-day Google Search Console data and historical audits to show how your commercial pages perform over time and how much they contribute to your overall Authority behaviour score.
            </p>
            
            <!-- Top-level filter for Performance Metrics, Behaviour, and Opportunity Mix -->
            <div style="display: flex; justify-content: flex-start; align-items: center; margin-bottom: 1.5rem; padding: 1rem 1.25rem; background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%); border-radius: 8px; border: 2px solid #0ea5e9; box-shadow: 0 2px 4px rgba(14, 165, 233, 0.2);">
              <label style="display: flex; align-items: center; gap: 0.75rem; font-size: 0.95rem; color: #0c4a6e; font-weight: 700;" title="Filter Performance Metrics, Behaviour, and Opportunity Mix by sub-segment type">
                <span style="font-weight: 700;">Sub-segment Filter:</span>
                <select id="money-top-level-filter-subsegment" style="padding: 0.6rem 1rem; border: 2px solid #0ea5e9; border-radius: 6px; font-size: 0.95rem; background: white; cursor: pointer; font-weight: 600; color: #0c4a6e; min-width: 150px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);" title="Filter money pages by sub-segment type. Landing pages are collection/category pages, Event pages are workshop/event listings, Product pages are service/product offerings. This filter controls Performance Metrics, Behaviour, and Opportunity Mix sections.">
                  <option value="ALL">All</option>
                  <option value="PRODUCT">Product</option>
                  <option value="EVENT">Event</option>
                  <option value="LANDING">Landing</option>
                </select>
              </label>
            </div>
            
            <!-- Performance Metrics -->
            <div style="margin-bottom: 1.5rem;">
              <h4 style="margin: 0 0 1rem 0; font-size: 0.95rem; font-weight: 600; color: #1e293b;">Performance Metrics</h4>
            </div>
            <div id="money-pages-summary" class="metrics-row" style="display: flex; gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap;">
              <div class="metric-card" id="money-summary-click-share" style="flex: 1; min-width: 200px; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
              <div class="metric-card" id="money-summary-ctr" style="flex: 1; min-width: 200px; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
              <div class="metric-card" id="money-summary-position" style="flex: 1; min-width: 200px; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
              <div class="metric-card" id="money-summary-coverage" style="flex: 1; min-width: 200px; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
            </div>
            
            <!-- Explanation text -->
            <div style="margin-bottom: 1.5rem; padding: 1rem; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #64748b; font-size: 0.85rem; line-height: 1.6; color: #475569;">
              <p style="margin: 0 0 0.5rem 0;"><strong>Note:</strong> These metrics include <strong>all money pages</strong> regardless of ranking position (positions 1-20 and beyond). This provides a complete view of your money page performance, including pages that need improvement.</p>
              <p style="margin: 0;"><strong>Difference from Segment Overview:</strong> The "Segment overview (CTR & ranking)" table above shows metrics for money pages ranking in <strong>positions 1-20 only</strong> (used for Authority scoring). The Money Pages Performance section shows <strong>all money pages</strong> to help identify opportunities across your entire money page portfolio.</p>
            </div>
            
            <!-- Money Pages Behaviour KPIs -->
            <div style="margin-bottom: 1rem;">
              <h3 style="margin: 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Money Pages Behaviour</h3>
            </div>
            <div class="money-behaviour-kpis" id="money-behaviour-kpis" style="display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 1.5rem;">
              <div class="kpi-card" id="money-behaviour-card" style="flex: 1 1 180px; background: #fff; border-radius: 6px; padding: 8px 12px; box-shadow: 0 0 0 1px rgba(0,0,0,0.04);">
                <div class="kpi-label" style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">Money pages behaviour</div>
                <div class="kpi-value" id="money-behaviour-score" style="font-size: 1.5rem; font-weight: 700; color: #1e293b;"></div>
                <div class="kpi-sub" id="money-behaviour-status" style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;">CTR and ranking for money pages only.</div>
              </div>
              <div class="kpi-card" style="flex: 1 1 180px; background: #fff; border-radius: 6px; padding: 8px 12px; box-shadow: 0 0 0 1px rgba(0,0,0,0.04);">
                <div class="kpi-label" style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">CTR (ranking queries)</div>
                <div class="kpi-value" id="money-ctr-value" style="font-size: 1.5rem; font-weight: 700; color: #1e293b;"></div>
                <div class="kpi-sub" style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;">Target 2.5%</div>
              </div>
              <div class="kpi-card" style="flex: 1 1 180px; background: #fff; border-radius: 6px; padding: 8px 12px; box-shadow: 0 0 0 1px rgba(0,0,0,0.04);">
                <div class="kpi-label" style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">Top-10 CTR</div>
                <div class="kpi-value" id="money-top10-ctr-value" style="font-size: 1.5rem; font-weight: 700; color: #1e293b;"></div>
                <div class="kpi-sub" style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;">Target 4.0%</div>
              </div>
            </div>
            <p class="chart-subtitle" style="margin: 0 0 1.5rem 0; font-size: 0.85rem; color: #64748b; padding: 0 0.5rem;">
              Behaviour score here is calculated the same way as <strong>Authority  Behaviour</strong>,
              but only for money pages. Improvements you make on these URLs will move both this score
              and the Authority pillar.
            </p>
            
            <!-- Chart row (Phase 2) -->
            <div class="chart-row" id="money-pages-chart-row" style="margin-bottom: 1.5rem; display: block; visibility: visible;">
              <div class="chart-card" style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: flex; gap: 1.5rem; align-items: flex-start;">
                <div style="flex: 1;">
                  <div style="margin-bottom: 0.5rem;">
                  <h3 id="money-pages-chart-title" style="margin: 0 0 0.5rem 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Money Pages Opportunity Mix</h3>
                  <p class="chart-subtitle" style="margin: 0 0 1rem 0; font-size: 0.85rem; color: #64748b;">
                    How your money pages are distributed across improvement categories in this audit window.
                  </p>
                  </div>
                  <div style="position: relative; width: 500px; height: 300px; margin: 0 auto; overflow: hidden;">
                    <canvas id="money-pages-category-chart" width="500" height="300" style="display: block; max-width: 500px; max-height: 300px;"></canvas>
                  </div>
                  <div id="money-pages-category-summary" class="chart-summary" style="margin-top: 8px; font-size: 0.9rem; color: #1e293b; font-weight: 500; text-align: center;"></div>
                  <div id="money-pages-category-breakdown" class="chart-breakdown-row" style="margin-top: 4px; display: flex; flex-wrap: wrap; gap: 0.5rem; font-size: 0.85rem; justify-content: center;"></div>
                </div>
                <div id="money-pages-chart-summary-box" style="flex: 0 0 320px; background: #f8fafc; padding: 1.5rem; border-radius: 8px; border: 1px solid #e2e8f0; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                  <h4 style="margin: 0 0 1rem 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Filtered Summary</h4>
                  <div style="display: flex; flex-direction: column; gap: 0.75rem; font-size: 0.9rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span style="color: #64748b; font-size: 0.9rem;">Pages:</span>
                      <span id="summary-pages-count" style="font-weight: 700; color: #1e293b; font-size: 1rem;">-</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span style="color: #64748b; font-size: 0.9rem;">Impressions:</span>
                      <span id="summary-impressions" style="font-weight: 700; color: #1e293b; font-size: 1rem;">-</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span style="color: #64748b; font-size: 0.9rem;">Clicks:</span>
                      <span id="summary-clicks" style="font-weight: 700; color: #1e293b; font-size: 1rem;">-</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span style="color: #64748b; font-size: 0.9rem;">CTR:</span>
                      <span id="summary-ctr" style="font-weight: 700; font-size: 1rem;">-</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0.5rem; padding-top: 0.75rem; border-top: 2px solid #e2e8f0;">
                      <span style="color: #64748b; font-size: 0.9rem;">Behaviour Score:</span>
                      <span id="summary-behaviour" style="font-weight: 700; font-size: 1.1rem;">-</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Phase 3: Money Pages Trend Chart -->
            <section id="money-pages-trend" class="card card--full" style="margin-top: 2rem; background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div class="card-header" style="margin-bottom: 1rem;">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Money Pages Performance Trends (last 28 days)</h3>
                <p class="card-subtitle" style="margin: 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
                  Weekly trends calculated from actual Google Search Console data for the last 28 days. Shows money pages clicks, impressions, CTR, and behaviour score over time.
                </p>
              </div>
              <div class="card-body" style="min-height: 300px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                  <div>
                    <h4 style="font-size: 0.95rem; font-weight: 600; color: #1e293b; margin-bottom: 0.5rem;">Volume Metrics</h4>
                    <div style="position: relative; height: 300px;">
                      <canvas id="moneyPagesVolumeChart"></canvas>
                    </div>
                  </div>
                  <div>
                    <h4 style="font-size: 0.95rem; font-weight: 600; color: #1e293b; margin-bottom: 0.5rem;">Rate & Score Metrics</h4>
                    <div style="position: relative; height: 300px;">
                      <canvas id="moneyPagesRateChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              <div class="card-footer small" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e2e8f0; font-size: 0.85rem; color: #64748b;">
                Data calculated from Google Search Console timeseries for the last 28 days, displayed as 8 weekly data points. Metrics are calculated using money page proportions from the latest audit.
              </div>
            </section>
            
            <!-- Phase: 12-Month KPI Tracker -->
            <section id="money-pages-kpi-card" class="card card--full" style="margin-top: 2rem; background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div class="card-header" style="margin-bottom: 1rem;">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Money Pages KPI Tracker (last 28 days)</h3>
                <p class="card-subtitle" style="margin: 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
                  Weekly KPI trends by money-page segment (All, Landing, Event, Product) calculated from actual Google Search Console data for the last 28 days.
                </p>
              </div>

              <div class="controls-row" style="margin-bottom: 1.5rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem;" title="Select which metric to display in the KPI tracker chart and table. CTR shows click-through rate, Impressions shows search visibility, Clicks shows actual traffic, and Avg position shows average ranking.">
                  Metric:
                  <select id="money-kpi-metric-select" style="padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px;" title="Select which metric to display in the KPI tracker chart and table. CTR shows click-through rate, Impressions shows search visibility, Clicks shows actual traffic, and Avg position shows average ranking.">
                    <option value="ctr">CTR</option>
                    <option value="impressions">Impressions</option>
                    <option value="clicks">Clicks</option>
                    <option value="avgPosition">Avg position</option>
                  </select>
                </label>
              </div>

              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                <div class="sparkline-wrapper" style="height: 400px; width: 100%;">
                  <canvas id="money-kpi-sparkline" style="width: 100% !important;"></canvas>
                </div>

                <div class="table-wrapper" style="overflow-x: auto; max-width: 100%; width: 100%;">
                  <table id="money-kpi-table" style="width: max-content; min-width: 100%; border-collapse: collapse; table-layout: fixed;">
                    <thead>
                      <tr id="money-kpi-header-row" style="background: #f1f5f9;">
                        <!-- Filled by JS -->
                      </tr>
                    </thead>
                    <tbody>
                      <!-- JS rows -->
                    </tbody>
                  </table>
                </div>
              </div>
            </section>
            
            <!-- Phase: Money Pages Priority Matrix + Action List -->
            <section id="money-pages-priority-card" class="card card--full" style="margin-top: 2rem; background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div class="card-header" style="margin-bottom: 1rem;">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Money Pages  Priority & Actions</h3>
                <p class="card-subtitle" style="margin: 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
                  Landing, event and product pages that drive revenue. Triaged by impact, difficulty and priority.
                </p>
              </div>

              <!-- Summary strip -->
              <div class="summary-strip" id="money-pages-summary-strip" style="display: flex; gap: 2rem; padding: 1rem; background: #f8fafc; border-radius: 4px; margin-bottom: 1.5rem;">
                <!-- Filled by JS -->
              </div>

              <!-- Controls -->
              <div class="controls-row" style="display: flex; gap: 1.5rem; margin-bottom: 1.5rem; align-items: center;">
                <label style="display: flex; align-items: center; gap: 0.5rem;" title="Filter money pages by segment type. Landing pages are collection/category pages, Event pages are workshop/event listings, Product pages are service/product offerings.">
                  Page type:
                  <select id="money-pages-type-filter" style="padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px;" title="Filter money pages by segment type. Landing pages are collection/category pages, Event pages are workshop/event listings, Product pages are service/product offerings.">
                    <option value="all" id="money-pages-type-all">All money pages</option>
                    <option value="authority" id="money-pages-type-authority">Authority</option>
                    <option value="landing" id="money-pages-type-landing">Landing pages</option>
                    <option value="event" id="money-pages-type-event">Event pages</option>
                    <option value="product" id="money-pages-type-product">Product pages</option>
                  </select>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem;" title="Filter out pages with fewer impressions than this threshold. Helps focus on pages with meaningful search visibility.">
                  Min impressions:
                  <input type="number" id="money-pages-min-impr" value="0" min="0" step="10" style="padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px; width: 120px;" title="Filter out pages with fewer impressions than this threshold. Helps focus on pages with meaningful search visibility.">
                </label>
              </div>

              <div class="matrix-and-table" style="display: grid; grid-template-columns: 1fr 2fr; gap: 2rem;">
                <div class="priority-matrix" id="money-pages-matrix" style="background: #f8fafc; padding: 1rem; border-radius: 8px;">
                  <!-- 3x3 grid rendered by JS -->
                </div>

                <div class="priority-table-wrapper" style="overflow-x: auto;">
                  <table id="money-pages-priority-table" style="width: 100%; border-collapse: collapse;">
                    <thead>
                      <tr style="background: #f1f5f9;">
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="The URL or page title of the money page. Click to open in a new tab.">Keyword or Page</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Segment type: Landing (collection/category pages), Event (workshop/event listings), or Product (service/product offerings).">Type</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Priority level (HIGH/MEDIUM/LOW) based on impact and difficulty. HIGH priority = high impact + low/medium difficulty. Click column header to sort.">Priority</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Impact level based on lost clicks (expected CTR minus actual CTR). HIGH = significant opportunity to improve clicks. Click column header to sort.">Impact</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Difficulty level based on current ranking position and schema effort required. LOW = easy to improve, HIGH = requires more work. Click column header to sort.">Difficulty</th>
                        <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;" title="Click-through rate: percentage of impressions that resulted in clicks. Higher is better. Click column header to sort.">CTR</th>
                        <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;" title="Total impressions: number of times this page appeared in search results. Click column header to sort.">Impr.</th>
                        <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;" title="Average position: average ranking position in search results (1 = best, lower numbers are better). Click column header to sort.">Avg pos.</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Recommended action based on priority level. HIGH = Fix CTR & strengthen content, MEDIUM = Improve SERP snippet & schema, LOW = Monitor & maintain.">Action</th>
                      </tr>
                    </thead>
                    <tbody>
                      <!-- JS rows -->
                    </tbody>
                  </table>
                  <div id="money-pages-priority-pagination"></div>
                  <button id="money-pages-copy-urls-btn" type="button" class="btn btn-small" style="margin-top: 1rem;" title="Copy all filtered page URLs to clipboard. URLs are copied one per line, ready to paste into spreadsheets or other tools.">Copy URLs</button>
                </div>
              </div>
            </section>

            <!-- Money Pages Opportunity Table (moved to sit directly above Suggested Top 10) -->
            <div id="money-pages-table-container" style="margin-top: 2rem;">
              <!-- Table will be rendered here -->
            </div>
            
            <!-- Suggested (Top 10) Section -->
            <section id="money-pages-suggested-top10" class="card card--full" style="margin-top: 2rem; background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div class="card-header" style="margin-bottom: 1rem;">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Suggested (Top 10)</h3>
                <p class="card-subtitle" style="margin: 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
                  Top priority pages ranked by impact and difficulty. Click 'Create Task' to start optimization tracking.
                </p>
              </div>
              
              <div id="money-pages-suggested-top10-container" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem;">
                <!-- Cards will be rendered here by JS -->
              </div>
            </section>
            
            <p class="card-footnote" style="margin-top: 1rem; font-size: 0.85rem; color: #666;">
              Based on the current audit date range and money-page segment only.
              Categories and actions are data-driven and will update each time you run a new audit.
            </p>
          </div>
        `;
        }
          
        debugLog(' Money Pages section HTML structure created/updated', 'success');
        
        // Add Create Tasks button to Priority & Actions header if not already present
        const priorityCard = document.getElementById('money-pages-priority-card');
        if (priorityCard) {
          const cardHeader = priorityCard.querySelector('.card-header');
          if (cardHeader && !document.getElementById('money-pages-create-tasks-btn')) {
            // Check if header already has flex layout
            if (!cardHeader.style.display || cardHeader.style.display !== 'flex') {
              cardHeader.style.display = 'flex';
              cardHeader.style.justifyContent = 'space-between';
              cardHeader.style.alignItems = 'flex-start';
            }
            
            // Wrap existing content in a div
            const existingContent = Array.from(cardHeader.childNodes);
            const contentWrapper = document.createElement('div');
            contentWrapper.style.flex = '1';
            existingContent.forEach(node => {
              if (node.nodeType === Node.ELEMENT_NODE || node.nodeType === Node.TEXT_NODE) {
                contentWrapper.appendChild(node.cloneNode(true));
              }
            });
            cardHeader.innerHTML = '';
            cardHeader.appendChild(contentWrapper);
            
            // Add bulk create button (secondary/advanced)
            const createBtn = document.createElement('button');
            createBtn.id = 'money-pages-create-tasks-btn';
            createBtn.type = 'button';
            createBtn.className = 'btn btn-secondary';
            createBtn.textContent = 'Bulk create';
            createBtn.title = ' BULK OPERATION: Creates optimisation tasks for ALL money pages (CTR  2.5%). This will create hundreds of tasks. Use row-level Track buttons for individual pages instead.';
            createBtn.style.cssText = 'margin-left: 1rem; padding: 0.5rem 1rem; background: #f59e0b; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; white-space: nowrap; font-size: 0.875rem;';
            cardHeader.appendChild(createBtn);
            
            // Wire up button
            wireMoneyPagesCreateTasksButton();
          } else if (document.getElementById('money-pages-create-tasks-btn')) {
            // Button exists, just wire it up
            wireMoneyPagesCreateTasksButton();
          }
        }
        
        // Always show section, even if no data (will show "No data" message)
        section.style.display = 'block';
        
        if (!moneyPagesMetrics) {
          debugLog(' Money Pages Metrics: No data provided', 'warn');
          // Show "No data" message in table and summary cards
          const tableContainer = document.getElementById('money-pages-table-container');
          if (tableContainer) {
            tableContainer.innerHTML = '<div style="font-size: 0.85rem; color: #999; padding: 2rem; text-align: center;">No money-page data available. Run an audit with GSC data to see money pages performance.</div>';
          }
          // Populate summary cards with ""
          const summaryClickEl = document.getElementById('money-summary-click-share');
          const summaryCtrEl = document.getElementById('money-summary-ctr');
          const summaryPosEl = document.getElementById('money-summary-position');
          const summaryCovEl = document.getElementById('money-summary-coverage');
          if (summaryClickEl) summaryClickEl.innerHTML = `<div class="metric-label">Share of site clicks</div><div class="metric-value"></div><div class="metric-sub">No data</div>`;
          if (summaryCtrEl) summaryCtrEl.innerHTML = `<div class="metric-label">CTR vs site</div><div class="metric-value"></div><div class="metric-sub">No data</div>`;
          if (summaryPosEl) summaryPosEl.innerHTML = `<div class="metric-label">Average position</div><div class="metric-value"></div><div class="metric-sub">No data</div>`;
          if (summaryCovEl) summaryCovEl.innerHTML = `<div class="metric-label">Money pages with impressions</div><div class="metric-value">0</div><div class="metric-sub">No data</div>`;
          return;
        }
        
        const { rows } = moneyPagesMetrics;
        const tableContainer = document.getElementById('money-pages-table-container');
        
        if (!tableContainer) {
          return;
        }
        
        // Store data globally for sorting/pagination
        // Ensure we're using the most up-to-date metrics
        window.currentMoneyPagesMetrics = moneyPagesMetrics || window.currentMoneyPagesMetrics;
        
        // Initialize pagination state if not set
        if (window.moneyPagesCurrentPage === undefined) {
          window.moneyPagesCurrentPage = 1;
        }
        if (window.moneyPagesRowsPerPage === undefined) {
          window.moneyPagesRowsPerPage = 10;
        }
        
        // Store full rows array for filtering
        window.moneyPagesAllRows = rows;
        
        // Initialize filter state if not set
        if (window.moneyPagesCategoryFilter === undefined) {
          window.moneyPagesCategoryFilter = 'ALL';
        }
        if (window.moneyPagesSubSegmentFilter === undefined) {
          window.moneyPagesSubSegmentFilter = 'ALL';
        }
        
        // Update summary metrics with current filters
        updateMoneyPagesSummaryMetrics(moneyPagesMetrics);
        if (window.moneyPagesMinImpressions === undefined) {
          window.moneyPagesMinImpressions = 0;
        }
        
        // Update sub-segment dropdown counts
        updateMoneyPagesSubSegmentCounts(moneyPagesMetrics);
        
        // Function to apply filters and re-render ALL sections (table, chart, KPIs, summaries)
        const applyFiltersAndRender = async () => {
          const moneyPagesMetrics = window.currentMoneyPagesMetrics;
          const queryPages = window.currentQueryPages || null;
          
          if (!moneyPagesMetrics) return;
          
          // Get filtered metrics based on current filters FIRST
          const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
          if (!filteredMetrics) return;
          
          const filteredRows = filteredMetrics.rows || [];
          
          // Update table with FILTERED rows
          const currentPage = window.moneyPagesCurrentPage || 1;
          const rowsPerPage = window.moneyPagesRowsPerPage || 10;
          const tableHtml = await renderMoneyPagesTable(filteredRows, currentPage, rowsPerPage);
          if (tableHtml && typeof tableHtml === 'string' && tableHtml.trim().length > 0) {
            tableContainer.innerHTML = tableHtml;
            // Populate AI citations per URL (latest audit only) - async, non-blocking
            // Use longer delay and retry mechanism to ensure cells are rendered
            let retryCount = 0;
            const maxRetries = 3;
            const tryPopulate = () => {
              const cells = document.querySelectorAll('.ai-citation-cell-opportunity');
              if (cells.length === 0 && retryCount < maxRetries) {
                retryCount++;
                setTimeout(tryPopulate, 200);
                return;
              }
              try {
                populateMoneyPagesAiCitations(filteredRows).catch(err => {
                  debugLog(`[Money Pages] Error populating AI citations: ${err.message}`, 'warn');
                });
              } catch (err) {
                debugLog(`[Money Pages] Error calling populateMoneyPagesAiCitations: ${err.message}`, 'warn');
              }
            };
            setTimeout(tryPopulate, 300);
          } else {
            debugLog(` renderMoneyPagesTable returned invalid value: ${typeof tableHtml}, length: ${tableHtml?.length || 0}`, 'warn');
            tableContainer.innerHTML = '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">Error rendering table. Please refresh the page.</div>';
          }
          
          // Re-attach all handlers after re-render
          // Use filtered rows for pagination/copy, but use original rows for filter handlers
          // (filter handlers need the full dataset to filter from)
          attachMoneyPagesSortHandlers();
          attachMoneyPagesPaginationHandlers(filteredRows);
          attachMoneyPagesCopyHandler(filteredRows);
          attachMoneyPagesFilterHandlers(rows, applyFiltersAndRender);
          
          // Wire up Create Tasks button if it exists
          if (typeof wireMoneyPagesCreateTasksButton === 'function') {
            wireMoneyPagesCreateTasksButton();
          }
          
          // Update all other sections with filtered data
          setTimeout(() => {
            // Update doughnut chart with filtered data
            renderMoneyPagesCategoryChart(moneyPagesMetrics, 0);
            
            // Recalculate behaviour for filtered pages
            debugLog(` Filter change: Recalculating behaviour for ${filteredRows.length} filtered rows`, 'info');
            debugLog(` Filter change: queryPages available: ${!!queryPages}, length: ${queryPages?.length || 0}`, 'info');
            
            const filteredBehaviour = window.computeMoneyPagesBehaviour ? 
              window.computeMoneyPagesBehaviour(queryPages, filteredRows, true) : null;
            
            debugLog(` Filter change: filteredBehaviour calculated: ${!!filteredBehaviour}, impressions: ${filteredBehaviour?.impressions || 0}`, 'info');
            
          // Update all sections
          renderMoneyPagesBehaviourKpis(filteredBehaviour, filteredMetrics, queryPages);
          updateMoneyPagesSummaryMetrics(moneyPagesMetrics); // Pass original metrics so function can apply filters internally
          updateMoneyPagesChartSummary(filteredMetrics);
          
          // Update dropdown counts after filtering (both table and top-level)
          updateMoneyPagesSubSegmentCounts(moneyPagesMetrics);
          }, 100);

          // Keep Suggested Top 10 aligned with Opportunity table filters
          if (typeof window.renderMoneyPagesSuggestedTop10 === 'function') {
            window.renderMoneyPagesSuggestedTop10();
          }
        };

        // Expose for header sort clicks
        window.moneyPagesApplyFilters = applyFiltersAndRender;
        
        // CRITICAL: Fetch optimisation statuses for ALL rows before initial render
        // (only if admin key set; otherwise will 401 and clear cache)
        if (canFetchOptimisationStatuses && rows.length > 0) {
          console.log('[Money Pages] Fetching optimisation statuses for all rows on page load...', rows.length);
          const allStatusRows = rows.map(row => ({
            keyword: '', // Empty for page-level tasks
            best_url: row.url,
            targetUrl: row.url,
            ranking_url: row.url
          }));
          await window.fetchOptimisationStatuses(allStatusRows);
          console.log('[Money Pages]  Status cache populated on page load:', window.optimisationStatusCache?.size || 0, 'entries');
        }
        
        // Initial render
        const currentPage = window.moneyPagesCurrentPage || 1;
        const rowsPerPage = window.moneyPagesRowsPerPage || 10;
        const tableHtml = await renderMoneyPagesTable(rows, currentPage, rowsPerPage);
        if (tableHtml && typeof tableHtml === 'string' && tableHtml.trim().length > 0) {
          tableContainer.innerHTML = tableHtml;
          // Populate AI citations after table is rendered (async, non-blocking)
          // Use retry mechanism to ensure cells are rendered
          let retryCountInitial = 0;
          const maxRetriesInitial = 3;
          const tryPopulateInitial = () => {
            const cells = document.querySelectorAll('.ai-citation-cell-opportunity');
            if (cells.length === 0 && retryCountInitial < maxRetriesInitial) {
              retryCountInitial++;
              setTimeout(tryPopulateInitial, 200);
              return;
            }
            try {
              populateMoneyPagesAiCitations(rows).catch(err => {
                debugLog(`[Money Pages] Error populating AI citations: ${err.message}`, 'warn');
                console.error('[Money Pages] AI citations population error:', err);
              });
            } catch (err) {
              debugLog(`[Money Pages] Error calling populateMoneyPagesAiCitations: ${err.message}`, 'warn');
              console.error('[Money Pages] AI citations function error:', err);
            }
          };
          setTimeout(tryPopulateInitial, 300);
        } else {
          debugLog(` renderMoneyPagesTable returned invalid value: ${typeof tableHtml}, length: ${tableHtml?.length || 0}`, 'warn');
          tableContainer.innerHTML = '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">Error rendering table. Please refresh the page.</div>';
        }
        
        // Attach sort handlers
        attachMoneyPagesSortHandlers();
        
        // Attach pagination handlers
        attachMoneyPagesPaginationHandlers(rows);
        
        // Attach copy button handler
        attachMoneyPagesCopyHandler(rows);
        
        // Attach filter handlers (Phase 2)
        attachMoneyPagesFilterHandlers(rows, applyFiltersAndRender);
        
        // Show section
        section.style.display = 'block';
      }
      
      // Attach sort handlers for Money Pages table
      function attachMoneyPagesSortHandlers() {
        // Use event delegation so sorting keeps working across any table re-render path.
        ensureMoneyPagesOpportunitySortDelegation();
      }

      // One-time delegated sort handler for the Money Pages Opportunity table headers.
      function ensureMoneyPagesOpportunitySortDelegation() {
        if (window.__moneyPagesOpportunitySortDelegationAttached) return;
        window.__moneyPagesOpportunitySortDelegationAttached = true;

        document.addEventListener('click', (e) => {
          const th = e?.target?.closest ? e.target.closest('th[id^="money-sort-"]') : null;
          if (!th || !th.id) return;
          const col = String(th.id).replace('money-sort-', '');
          if (!['type', 'clicks', 'impressions', 'ctr', 'clickPotential', 'position', 'opportunity', 'aiCitations'].includes(col)) return;
          try {
            handleMoneyPagesSort(col);
          } catch (err) {
            console.warn('[Money Pages Opportunity] Sort handler error:', err);
          }
        });
      }
      
      // Handle sorting for Money Pages table
      async function handleMoneyPagesSort(column) {
        if (window.moneyPagesSortColumn === column) {
          window.moneyPagesSortDirection = window.moneyPagesSortDirection === 'asc' ? 'desc' : 'asc';
        } else {
          window.moneyPagesSortColumn = column;
          window.moneyPagesSortDirection = 'desc';
        }
        
        // Reset to page 1 when sorting
        window.moneyPagesCurrentPage = 1;
        
        // Get current data from stored source
        const allRows = window.moneyPagesData || [];
        if (allRows.length > 0) {
          const tableContainer = document.getElementById('money-pages-table-container');
          if (tableContainer) {
            const rowsPerPage = window.moneyPagesRowsPerPage || 10;
            tableContainer.innerHTML = await renderMoneyPagesTable(allRows, 1, rowsPerPage);
            setTimeout(() => {
              try {
                populateMoneyPagesAiCitations(allRows).catch(err => {
                  debugLog(`[Money Pages] Error populating AI citations: ${err.message}`, 'warn');
                });
              } catch (err) {
                debugLog(`[Money Pages] Error calling populateMoneyPagesAiCitations: ${err.message}`, 'warn');
              }
            }, 100);
            attachMoneyPagesSortHandlers();
            attachMoneyPagesPaginationHandlers(allRows);
            attachMoneyPagesCopyHandler(allRows);
          }
        }
      }
      
      // Attach pagination handlers
      function attachMoneyPagesPaginationHandlers(allRows) {
        setTimeout(() => {
          const prevBtn = document.getElementById('money-pages-prev');
          const nextBtn = document.getElementById('money-pages-next');
          const rowsPerPageSelect = document.getElementById('money-pages-rows-per-page');
          
          // Use stored sorted data for pagination
          const sortedRows = window.moneyPagesData || allRows || [];
          const rowsPerPage = window.moneyPagesRowsPerPage || 10;
          
          // Handle rows-per-page change
          if (rowsPerPageSelect) {
            const newSelect = rowsPerPageSelect.cloneNode(true);
            rowsPerPageSelect.parentNode.replaceChild(newSelect, rowsPerPageSelect);
            newSelect.addEventListener('change', async () => {
              const newRowsPerPage = parseInt(newSelect.value, 10);
              window.moneyPagesRowsPerPage = newRowsPerPage;
              window.moneyPagesCurrentPage = 1; // Reset to first page when changing rows per page
              const tableContainer = document.getElementById('money-pages-table-container');
              if (tableContainer) {
                tableContainer.innerHTML = await renderMoneyPagesTable(sortedRows, 1, newRowsPerPage);
                setTimeout(() => {
                  try {
                    populateMoneyPagesAiCitations(sortedRows).catch(err => {
                      debugLog(`[Money Pages] Error populating AI citations: ${err.message}`, 'warn');
                    });
                  } catch (err) {
                    debugLog(`[Money Pages] Error calling populateMoneyPagesAiCitations: ${err.message}`, 'warn');
                  }
                }, 100);
                attachMoneyPagesSortHandlers();
                attachMoneyPagesPaginationHandlers(sortedRows);
                attachMoneyPagesCopyHandler(sortedRows);
              }
            });
          }
          
          if (prevBtn) {
            const newPrevBtn = prevBtn.cloneNode(true);
            prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
              newPrevBtn.addEventListener('click', async () => {
              if (window.moneyPagesCurrentPage > 1) {
                window.moneyPagesCurrentPage--;
                const tableContainer = document.getElementById('money-pages-table-container');
                if (tableContainer) {
                  const currentRowsPerPage = window.moneyPagesRowsPerPage || 10;
                  tableContainer.innerHTML = await renderMoneyPagesTable(sortedRows, window.moneyPagesCurrentPage, currentRowsPerPage);
                  setTimeout(() => {
                    try {
                      populateMoneyPagesAiCitations(sortedRows).catch(err => {
                        debugLog(`[Money Pages] Error populating AI citations: ${err.message}`, 'warn');
                      });
                    } catch (err) {
                      debugLog(`[Money Pages] Error calling populateMoneyPagesAiCitations: ${err.message}`, 'warn');
                    }
                  }, 100);
                  attachMoneyPagesSortHandlers();
                  attachMoneyPagesPaginationHandlers(sortedRows);
                  attachMoneyPagesCopyHandler(sortedRows);
                }
              }
            });
          }
          
          if (nextBtn) {
            const newNextBtn = nextBtn.cloneNode(true);
            nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
            newNextBtn.addEventListener('click', async () => {
              const currentRowsPerPage = window.moneyPagesRowsPerPage || 10;
              const totalPages = Math.ceil(sortedRows.length / currentRowsPerPage);
              if (window.moneyPagesCurrentPage < totalPages) {
                window.moneyPagesCurrentPage++;
                const tableContainer = document.getElementById('money-pages-table-container');
                if (tableContainer) {
                  tableContainer.innerHTML = await renderMoneyPagesTable(sortedRows, window.moneyPagesCurrentPage, currentRowsPerPage);
                  setTimeout(() => {
                    try {
                      populateMoneyPagesAiCitations(sortedRows).catch(err => {
                        debugLog(`[Money Pages] Error populating AI citations: ${err.message}`, 'warn');
                      });
                    } catch (err) {
                      debugLog(`[Money Pages] Error calling populateMoneyPagesAiCitations: ${err.message}`, 'warn');
                    }
                  }, 100);
                  attachMoneyPagesSortHandlers();
                  attachMoneyPagesPaginationHandlers(sortedRows);
                  attachMoneyPagesCopyHandler(sortedRows);
                }
              }
            });
          }
        }, 50);
      }
      
      // Attach copy button handler
      function attachMoneyPagesCopyHandler(allRows) {
        setTimeout(() => {
          const copyBtn = document.getElementById('money-pages-copy-urls');
          if (copyBtn) {
            const newCopyBtn = copyBtn.cloneNode(true);
            copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
            newCopyBtn.addEventListener('click', async () => {
              const urls = (allRows || []).slice(0, 10).map((r) => r.url).join('\n');
              if (urls) {
                try {
                  await navigator.clipboard.writeText(urls);
                  newCopyBtn.textContent = 'Copied!';
                  newCopyBtn.style.color = '#10b981';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                    newCopyBtn.style.color = 'white';
                  }, 2000);
                } catch (err) {
                  newCopyBtn.textContent = 'Copy failed';
                  newCopyBtn.style.color = '#ef4444';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                    newCopyBtn.style.color = 'white';
                  }, 2000);
                }
              }
            });
          }
        }, 50);
      }
      
      // Attach filter handlers for Money Pages table (Phase 2)
      function attachMoneyPagesFilterHandlers(allRows, onFilterChange) {
        // Keep latest dataset + callback; use delegation so filters survive table re-renders.
        window.__moneyPagesOpportunityAllRows = allRows || window.__moneyPagesOpportunityAllRows || [];
        window.__moneyPagesOpportunityOnFilterChange = onFilterChange || window.__moneyPagesOpportunityOnFilterChange || null;

        if (!window.__moneyPagesOpportunityFiltersDelegationAttached) {
          window.__moneyPagesOpportunityFiltersDelegationAttached = true;

          document.addEventListener('change', async (e) => {
            const t = e && e.target ? e.target : null;
            if (!t || !t.id) return;

            const isFilter =
              t.id === 'money-pages-filter-category' ||
              t.id === 'money-pages-filter-subsegment' ||
              t.id === 'money-pages-min-impressions' ||
              t.id === 'money-pages-include-zero';
            if (!isFilter) return;

            const categoryEl = document.getElementById('money-pages-filter-category');
            const subSegEl = document.getElementById('money-pages-filter-subsegment');
            const minImpEl = document.getElementById('money-pages-min-impressions');
            const includeZeroEl = document.getElementById('money-pages-include-zero');
            if (!categoryEl || !subSegEl || !minImpEl) return;

            const filterCat = categoryEl.value || 'ALL';
            const filterSubSeg = subSegEl.value || 'ALL';
            const minImp = parseInt(minImpEl.value, 10) || 0;
            const includeZero = includeZeroEl ? !!includeZeroEl.checked : true;

            window.moneyPagesCategoryFilter = filterCat;
            window.moneyPagesSubSegmentFilter = filterSubSeg;
            window.moneyPagesMinImpressions = minImp;
            window.moneyPagesIncludeZero = includeZero;
            window.moneyPagesCurrentPage = 1;

            // Sync top-level filter when table filter changes.
            if (t.id === 'money-pages-filter-subsegment') {
              const topLevelFilterEl = document.getElementById('money-top-level-filter-subsegment');
              if (topLevelFilterEl && topLevelFilterEl.value !== filterSubSeg) {
                topLevelFilterEl.value = filterSubSeg;
              }
            }

            if (typeof window.__moneyPagesOpportunityOnFilterChange === 'function') {
              await window.__moneyPagesOpportunityOnFilterChange();
            }

            if (typeof window.renderMoneyPagesSuggestedTop10 === 'function') {
              window.renderMoneyPagesSuggestedTop10();
            }
          });

          document.addEventListener('click', async (e) => {
            const t = e && e.target ? e.target : null;
            if (!t || t.id !== 'money-pages-copy-urls') return;

            const categoryEl = document.getElementById('money-pages-filter-category');
            const subSegEl = document.getElementById('money-pages-filter-subsegment');
            const minImpEl = document.getElementById('money-pages-min-impressions');
            const includeZeroEl = document.getElementById('money-pages-include-zero');

            const filterCat = categoryEl ? (categoryEl.value || 'ALL') : (window.moneyPagesCategoryFilter || 'ALL');
            const filterSubSeg = subSegEl ? (subSegEl.value || 'ALL') : (window.moneyPagesSubSegmentFilter || 'ALL');
            const minImp = minImpEl ? (parseInt(minImpEl.value, 10) || 0) : (window.moneyPagesMinImpressions || 0);
            const includeZero = includeZeroEl ? !!includeZeroEl.checked : (window.moneyPagesIncludeZero !== false);

            const all = Array.isArray(window.__moneyPagesOpportunityAllRows) ? window.__moneyPagesOpportunityAllRows : [];
            const filtered = all.filter(row => {
              const matchCat = filterCat === 'ALL' || row.category === filterCat;
              const matchSubSeg = filterSubSeg === 'ALL' || row.subSegment === filterSubSeg;
              const matchImp = (row.impressions || 0) >= minImp;
              const matchZero = includeZero || (row.impressions || 0) > 0;
              return matchCat && matchSubSeg && matchImp && matchZero;
            });

            const urls = filtered.map(r => r.url).join('\n');
            if (!urls) return;

            const btn = t;
            const prevText = btn.textContent;
            try {
              await navigator.clipboard.writeText(urls);
              btn.textContent = 'Copied!';
              setTimeout(() => { btn.textContent = prevText; }, 1500);
            } catch (err) {
              btn.textContent = 'Copy failed';
              setTimeout(() => { btn.textContent = prevText; }, 1500);
            }
          });
        }

        // Wire up Create Tasks button after rendering completes
        setTimeout(() => {
          if (typeof wireMoneyPagesCreateTasksButton === 'function') {
            wireMoneyPagesCreateTasksButton();
          }
        }, 100);
      }
      
      // Make renderMoneyPagesSection globally available
      window.renderMoneyPagesSection = renderMoneyPagesSection;
      
      // ========================================
      // Money Pages  Create Optimisation Tasks Feature
      // ========================================
      
      // Step 2: Fetch all Money Pages segment (ignores current UI filters)
      // Returns array of rows with: url, page_type, ctr, impressions, clicks, avg_position
      async function fetchMoneyPagesSegmentAll() {
        // Money Pages data is stored in window.moneyPagesMetrics or from localStorage/Supabase
        // Get the raw data source (before any filtering)
        let moneyPagesData = null;
        
        // Try window.moneyPagesMetrics first (if already loaded)
        if (window.moneyPagesMetrics && window.moneyPagesMetrics.rows) {
          moneyPagesData = window.moneyPagesMetrics;
        } else {
          // Try localStorage - check last_audit_results first, then fallback to aigeo_audit_data
          let savedAudit = localStorage.getItem('last_audit_results');
          if (!savedAudit) {
            savedAudit = localStorage.getItem('aigeo_audit_data');
          }
          if (savedAudit) {
            try {
              const parsed = JSON.parse(savedAudit);
              moneyPagesData = parsed.scores?.moneyPagesMetrics || parsed.moneyPagesMetrics || null;
            } catch (e) {
              debugLog('[Money Pages Tasks] Error parsing localStorage: ' + (e.message || e), 'error');
            }
          }
        }
        
        if (!moneyPagesData || !moneyPagesData.rows || moneyPagesData.rows.length === 0) {
          console.warn('[Money Pages Tasks] No money pages data available');
          return [];
        }
        
        // Return all rows (ignoring filters)
        return moneyPagesData.rows.map(row => ({
          url: row.url || row.page_url || '',
          page_type: row.page_type || row.type || '',
          ctr: row.ctr || row.ctr_28d || null,
          impressions: row.impressions || row.impressions_28d || null,
          clicks: row.clicks || row.clicks_28d || null,
          avg_position: row.avg_position || row.position || null,
          page_title: row.page_title || row.title || row.slug || null
        }));
      }
      
      // Step 4: Fetch existing optimisation task URLs for de-dupe
      async function fetchExistingOptimizationTaskUrls() {
        try {
          const adminKey = window.getAdminKey ? window.getAdminKey() : (sessionStorage.getItem('arp_admin_key') || localStorage.getItem('arp_admin_key') || '');
          if (!adminKey) {
            throw new Error('Admin key required');
          }
          
          const response = await fetch('/api/optimisation/tasks', {
            headers: {
              'x-arp-admin-key': adminKey
            }
          });
          
          if (!response.ok) {
            throw new Error(`Failed to fetch tasks: ${response.statusText}`);
          }
          
          const data = await response.json();
          const tasks = data.tasks || [];
          
          // Normalize URLs and return as Set
          const urlSet = new Set();
          for (const task of tasks) {
            if (task.target_url) {
              const normalized = normalizeUrlForDedupe(task.target_url);
              urlSet.add(normalized);
            }
          }
          
          return urlSet;
        } catch (error) {
          console.error('[Money Pages Tasks] Error fetching existing tasks:', error);
          return new Set(); // Return empty set on error
        }
      }
      
      // Normalize URL for de-dupe matching (reusable helper)
      function normalizeUrlForDedupe(url) {
        if (!url) return '';
        
        let normalized = url.trim();
        
        // Ensure leading https://www.alanranger.com if stored as path
        if (normalized.startsWith('/')) {
          normalized = 'https://www.alanranger.com' + normalized;
        } else if (!normalized.startsWith('http')) {
          normalized = 'https://www.alanranger.com/' + normalized;
        }
        
        // Remove trailing slash (except root)
        if (normalized.endsWith('/') && normalized !== 'https://www.alanranger.com/') {
          normalized = normalized.slice(0, -1);
        }
        
        // Lowercase hostname only (keep path case as-is)
        try {
          const urlObj = new URL(normalized);
          normalized = urlObj.origin.toLowerCase() + urlObj.pathname + urlObj.search + urlObj.hash;
        } catch (e) {
          // If URL parsing fails, just lowercase the whole thing
          normalized = normalized.toLowerCase();
        }
        
        return normalized;
      }
      
      // Normalize GSC page URL for page key matching (dedicated helper for page-level totals)
      // This avoids mismatches caused by full URL vs path-only, trailing slashes, query strings/fragments
      function normalizeGscPageKey(inputUrl) {
        if (!inputUrl) return "";

        let u = ("" + inputUrl).trim();

        // Accept path-only
        if (u.startsWith("/")) u = "https://www.alanranger.com" + u;
        else if (!u.startsWith("http")) u = "https://www.alanranger.com/" + u.replace(/^\/+/, "");

        try {
          const urlObj = new URL(u);
          let path = urlObj.pathname || "/";
          // remove trailing slash (except root)
          if (path.length > 1) path = path.replace(/\/+$/, "");
          return urlObj.origin.toLowerCase() + path;
        } catch (e) {
          // fallback: best-effort normalise
          return u.toLowerCase().replace(/\/+$/, "");
        }
      }
      
      // Get task identity key for Money Page (reusable helper)
      function getMoneyPageTaskKey(pageUrl) {
        return normalizeUrlForDedupe(pageUrl);
      }
      
      // Find existing optimisation task for URL (reusable helper)
      function findExistingOptimisationTaskForUrl(tasks, pageUrl) {
        if (!tasks || !Array.isArray(tasks)) return null;
        const normalizedUrl = normalizeUrlForDedupe(pageUrl);
        return tasks.find(task => {
          if (!task.target_url) return false;
          return normalizeUrlForDedupe(task.target_url) === normalizedUrl;
        }) || null;
      }
      
      // Make helper functions globally available (reusable by Ranking & AI and Money Pages)
      window.getMoneyPageTaskKey = getMoneyPageTaskKey;
      window.findExistingOptimisationTaskForUrl = findExistingOptimisationTaskForUrl;
      window.normalizeUrlForDedupe = normalizeUrlForDedupe;
      window.normalizeGscPageKey = normalizeGscPageKey;
      
      // Create optimisation task for URL (reusable helper - used by both Money Pages and Ranking & AI)
      async function createOptimisationTaskForUrl(pageUrl, pageTitle, source = 'money_pages') {
        const adminKey = window.getAdminKey ? window.getAdminKey() : (sessionStorage.getItem('arp_admin_key') || localStorage.getItem('arp_admin_key') || '');
        if (!adminKey) {
          throw new Error('Admin key required');
        }
        
        const normalizedUrl = normalizeUrlForDedupe(pageUrl);
        const title = pageTitle || normalizedUrl;
        
        // Build task payload
        const taskPayload = {
          keyword_text: normalizedUrl, // API requires non-empty, use URL as placeholder for page-level tasks
          target_url: normalizedUrl,
          task_type: 'on_page',
          status: 'planned',
          title: source === 'money_pages' ? `MP: ${title}` : title,
          source: source,
          is_test: false
        };
        
        // Create task
        const taskResponse = await fetch('/api/optimisation/task', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-arp-admin-key': adminKey
          },
          body: JSON.stringify(taskPayload)
        });
        
        if (!taskResponse.ok) {
          const errorText = await taskResponse.text();
          throw new Error(`Failed to create task: ${errorText}`);
        }
        
        const taskData = await taskResponse.json();
        const taskId = taskData.task?.id || taskData.id;
        
        if (!taskId) {
          throw new Error('Task created but no ID returned');
        }
        
        // Create Cycle 1 with absolute CTR objective (2.5% = 0.025 ratio)
        await createCycleWithAbsoluteCtrObjective(taskId, adminKey);
        
        return taskData;
      }
      
      // Make createOptimisationTaskForUrl globally available
      window.createOptimisationTaskForUrl = createOptimisationTaskForUrl;
      
      // Open Track Money Page Modal (reuses Ranking & AI modal pattern)
      window.openTrackMoneyPageModal = function openTrackMoneyPageModal(row) {
        const modal = document.getElementById('optimisation-track-modal');
        if (!modal) {
          console.error('[Money Pages] Track modal not found');
          alert('Track modal not found. Please refresh the page.');
          return;
        }

        // Get and clean URL
        const rawUrl = row.url || '';
        const cleanedUrl = window.cleanUrlForDisplay ? window.cleanUrlForDisplay(rawUrl) : rawUrl;
        
        // For Money Pages, keyword is empty (page-level task)
        document.getElementById('track-keyword-text').textContent = '(Page-level task)';
        
        // Make URL clickable in Track modal
        const trackUrlContainer = document.getElementById('track-url-text');
        trackUrlContainer.innerHTML = '';
        if (cleanedUrl) {
          let fullUrl = cleanedUrl;
          if (!fullUrl.startsWith('http://') && !fullUrl.startsWith('https://')) {
            fullUrl = 'https://' + fullUrl;
          }
          const urlLink = document.createElement('a');
          urlLink.href = fullUrl;
          urlLink.target = '_blank';
          urlLink.rel = 'noopener noreferrer';
          urlLink.textContent = cleanedUrl;
          urlLink.style.color = '#0284c7';
          urlLink.style.textDecoration = 'none';
          urlLink.style.fontWeight = '600';
          urlLink.style.wordBreak = 'break-all';
          urlLink.addEventListener('mouseenter', () => {
            urlLink.style.textDecoration = 'underline';
          });
          urlLink.addEventListener('mouseleave', () => {
            urlLink.style.textDecoration = 'none';
          });
          trackUrlContainer.appendChild(urlLink);
        } else {
          trackUrlContainer.textContent = 'No URL available';
        }
        
        // Set task type to on_page
        document.getElementById('track-task-type').value = 'on_page';
        document.getElementById('track-status').value = 'planned';
        
        // Prefill title
        const pageTitle = row.title || cleanedUrl;
        document.getElementById('track-title').value = `MP: ${pageTitle}`;
        document.getElementById('track-notes').value = '';
        
        // Prefill objective for Money Pages (CTR  2.5%)
        document.getElementById('track-objective-title').value = 'CTR  2.5%';
        document.getElementById('track-primary-kpi').value = 'ctr_28d';
        document.getElementById('track-target-direction').value = 'at_least';
        document.getElementById('track-target-value').value = '2.5';
        document.getElementById('track-timeframe-days').value = '';
        
        // Store row data for baseline metrics (needed in submitTrackKeyword)
        modal.dataset.rowKeyword = ''; // Empty for page-level tasks
        modal.dataset.rowUrl = cleanedUrl;
        modal.dataset.taskType = 'on_page';
        modal.dataset.source = 'money_pages';
        modal.dataset.rowData = JSON.stringify(row);
        
        // Build recommendations from row data and populate Plan / Hypothesis field
        let planText = '';
        try {
          debugLog('[Money Pages] Building recommendations from row data', 'info');
          debugLog('[Money Pages] Row data: ' + JSON.stringify({
            clicks: row.clicks,
            impressions: row.impressions,
            ctr: row.ctr,
            avgPosition: row.avgPosition || row.position,
            aiCitations: row._aiCitations || row.aiCitations,
            url: row.url
          }));
          
          const recommendations = [];
          const clicks = row.clicks || 0;
          const impressions = row.impressions || 0;
          const ctr = row.ctr || 0;
          const avgPosition = row.avgPosition != null ? row.avgPosition : (row.position || null);
          const aiCitations = row._aiCitations || row.aiCitations || 0;
          
          debugLog('[Money Pages] Building recommendations: clicks=' + clicks + ', impressions=' + impressions + ', ctr=' + ctr + ', position=' + avgPosition + ', aiCitations=' + aiCitations);
          
          // High Priority: Low Click-Through Rate (shown first in View Details)
          const ctrPercent = (ctr > 1 ? ctr : ctr * 100);
          if (ctrPercent < 2 && impressions > 0) {
            const potentialClicks = Math.round(impressions * 0.02);
            const additionalClicks = Math.max(0, potentialClicks - clicks);
            recommendations.push({
              priority: 'High',
              title: 'Low Click-Through Rate',
              nextSteps: 'Optimize title tags and meta descriptions to improve CTR',
              estimatedImpact: `Could gain ~${additionalClicks} additional clicks/month with better CTR`,
              reason: `Current CTR ${ctrPercent.toFixed(2)}% is below 2% benchmark`
            });
            debugLog('[Money Pages] Added High priority: Low Click-Through Rate');
          }
          
          // Medium Priority: Ranking Below Top 10
          if (avgPosition != null && avgPosition > 10) {
            const potentialClicksLow = Math.round(impressions * 0.025);
            const potentialClicksHigh = Math.round(impressions * 0.05);
            recommendations.push({
              priority: 'Medium',
              title: 'Ranking Below Top 10',
              nextSteps: 'Improve on-page SEO, build authority, or optimize for target keywords',
              estimatedImpact: `Moving to top 10 could increase clicks by ${potentialClicksLow} - ${potentialClicksHigh}`,
              reason: `Current position ${avgPosition.toFixed(1)} is outside top 10`
            });
            debugLog('[Money Pages] Added Medium priority: Ranking Below Top 10');
          }
          
          // Low Priority: Focus on Higher Volume Keywords (if AI citations exist but are low volume)
          if (aiCitations > 0 && impressions < 1000) {
            recommendations.push({
              priority: 'Low',
              title: 'Focus on Higher Volume Keywords',
              nextSteps: 'Expand content to target keywords with 100+ monthly search volume',
              estimatedImpact: 'Could increase potential traffic by targeting higher-volume opportunities',
              reason: 'Most citations are for low-volume keywords (<100 searches/month)'
            });
            debugLog('[Money Pages] Added Low priority: Focus on Higher Volume Keywords');
          }
          
          // Sort by priority: High first, then Medium, then Low
          recommendations.sort((a, b) => {
            const priorityOrder = { 'High': 3, 'Medium': 2, 'Low': 1 };
            return (priorityOrder[b.priority] || 0) - (priorityOrder[a.priority] || 0);
          });
          
          debugLog('[Money Pages] Generated ' + recommendations.length + ' recommendations');
          
          // Build plan text from recommendations
          if (recommendations.length > 0) {
            const planLines = [];
            planLines.push('CTR target:  2.5%');
            planLines.push('');
            
            // Limit to top 3 recommendations
            const topRecs = recommendations.slice(0, 3);
            
            topRecs.forEach((rec, idx) => {
              planLines.push(`${rec.priority.toUpperCase()} PRIORITY: ${rec.title}`);
              planLines.push(`Next steps: ${rec.nextSteps}`);
              planLines.push(`Estimated impact: ${rec.estimatedImpact}`);
              planLines.push(`Reason: ${rec.reason}`);
              if (idx < topRecs.length - 1) planLines.push('');
            });
            
            planText = planLines.join('\n');
            debugLog('[Money Pages] Plan text generated (length: ' + planText.length + '): ' + planText.substring(0, 200) + '...');
          } else {
            planText = 'CTR target:  2.5%';
            debugLog('[Money Pages] No recommendations generated, using default plan text');
          }
        } catch (e) {
          console.error('[Money Pages] Error generating plan from recommendations:', e);
          debugLog('[Money Pages] Error generating plan: ' + e.message + ' - ' + e.stack, 'error');
          planText = 'CTR target:  2.5%';
        }
        
        // Set the plan field with generated recommendations
        const planField = document.getElementById('track-plan');
        if (planField) {
          planField.value = planText;
          debugLog('[Money Pages] Plan field updated successfully');
        } else {
          debugLog('[Money Pages] ERROR: track-plan field not found!', 'error');
        }
        
        // Update modal title and subtitle to indicate Money Pages
        const modalTitle = modal.querySelector('h3');
        if (modalTitle) {
          modalTitle.textContent = 'Create optimisation task';
          // Add subtitle if it doesn't exist
          let subtitle = modal.querySelector('#money-pages-modal-subtitle');
          if (!subtitle) {
            subtitle = document.createElement('div');
            subtitle.id = 'money-pages-modal-subtitle';
            subtitle.style.cssText = 'margin: -0.5rem 0 1rem 0; font-size: 0.875rem; color: #64748b; font-weight: 400;';
            modalTitle.insertAdjacentElement('afterend', subtitle);
          }
          subtitle.textContent = 'Money Pages  CTR target (absolute):  2.5%';
        }
        
        // Add baseline preview section if it doesn't exist
        let baselinePreview = modal.querySelector('#money-pages-baseline-preview');
        if (!baselinePreview) {
          baselinePreview = document.createElement('div');
          baselinePreview.id = 'money-pages-baseline-preview';
          baselinePreview.style.cssText = 'margin-bottom: 1.5rem; padding: 1rem; background: #fef3c7; border-radius: 4px; border: 1px solid #fbbf24;';
          const objectiveSection = modal.querySelector('#track-objective-title').closest('div').parentElement;
          objectiveSection.insertAdjacentElement('beforebegin', baselinePreview);
        }
        
        // Populate baseline preview
        // Debug: Log row data to see what we have
        console.log('[Money Pages Modal] Row data for baseline:', {
          clicks: row.clicks,
          impressions: row.impressions,
          ctr: row.ctr,
          avgPosition: row.avgPosition,
          position: row.position,
          url: row.url
        });
        
        const ctrPct = (row.ctr || 0) * 100;
        const clicks = row.clicks || row.clicks_28d || 0;
        const impressions = row.impressions || row.impressions_28d || 0;
        const ctr = row.ctr != null ? row.ctr : (row.ctr_28d || 0);
        const position = row.avgPosition != null ? row.avgPosition : (row.position || row.position_28d || null);
        
        baselinePreview.innerHTML = `
          <div style="font-weight: 600; color: #92400e; margin-bottom: 0.5rem; font-size: 0.875rem;">Baseline that will be captured on create:</div>
          <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.75rem; font-size: 0.875rem; color: #78350f;">
            <div><strong>Clicks (28d):</strong> ${clicks.toLocaleString()}</div>
            <div><strong>Impressions (28d):</strong> ${impressions.toLocaleString()}</div>
            <div><strong>CTR (28d):</strong> ${(ctr * 100).toFixed(2)}%</div>
            <div><strong>Avg position (28d):</strong> ${position ? position.toFixed(1) : 'N/A'}</div>
          </div>
        `;
        
        modal.style.display = 'flex';
      };
      
      // Track Money Page - per-row function (opens modal instead of auto-creating)
      window.trackMoneyPage = function(pageUrl, pageTitle) {
        try {
          // Check share mode first
          if (window.isShareMode) {
            alert('Write operations are not available in share mode (read-only).');
            return;
          }
          
          // Check admin key
          if (!window.hasAdminKey || !window.hasAdminKey()) {
            alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
            return;
          }
          
          console.log('[Money Pages] trackMoneyPage called', { pageUrl, pageTitle });
          debugLog(` Opening Track modal for Money Page: ${pageUrl}`, 'info');
          
          // Ensure the map exists (initialize if needed)
          if (!window.moneyPagesRowDataByUrl) {
            window.moneyPagesRowDataByUrl = new Map();
            console.log('[Money Pages] Initialized window.moneyPagesRowDataByUrl map');
          }
          
          // Look up row data from stored map (most reliable - populated during table render)
          let rowData = null;
          const normalizedUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(pageUrl) : pageUrl.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
          console.log('[Money Pages] Looking up row data for normalized URL:', normalizedUrl);
          
          if (window.moneyPagesRowDataByUrl.size > 0) {
            rowData = window.moneyPagesRowDataByUrl.get(normalizedUrl);
            console.log('[Money Pages] Row data from map:', rowData ? ' FOUND' : ' NOT FOUND');
            if (rowData) {
              console.log('[Money Pages]  Row data metrics from map:', {
                clicks: rowData.clicks,
                impressions: rowData.impressions,
                ctr: rowData.ctr,
                avgPosition: rowData.avgPosition,
                position: rowData.position,
                url: rowData.url
              });
              
              // Validate that we have actual metrics (not all zeros)
              if (rowData.clicks === 0 && rowData.impressions === 0) {
                console.warn('[Money Pages]  WARNING: Row data has 0 clicks and 0 impressions! This might be incorrect.');
                debugLog(` Row data has 0 metrics - clicks=${rowData.clicks}, impressions=${rowData.impressions}`, 'warn');
              } else {
                console.log('[Money Pages]  Row data has valid metrics');
              }
            } else {
              console.log('[Money Pages] Row data not found in map. Map size:', window.moneyPagesRowDataByUrl.size);
              // Log sample keys for debugging
              const sampleKeys = Array.from(window.moneyPagesRowDataByUrl.keys()).slice(0, 5);
              console.log('[Money Pages] Sample keys in map:', sampleKeys);
            }
          } else {
            console.log('[Money Pages] Map is empty, will search in moneyPagesMetrics.rows');
          }
          
          // Method 2: If not found in map, search directly in moneyPagesMetrics.rows
          if (!rowData && window.moneyPagesMetrics && window.moneyPagesMetrics.rows) {
            console.log('[Money Pages] Searching in moneyPagesMetrics.rows...');
            const normalizedUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(pageUrl) : pageUrl.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
            const matchingRow = window.moneyPagesMetrics.rows.find(row => {
              const rowNormalized = normalizeUrlForDedupe ? normalizeUrlForDedupe(row.url) : row.url.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
              return rowNormalized === normalizedUrl;
            });
            
            if (matchingRow) {
              console.log('[Money Pages] Found row in moneyPagesMetrics.rows:', matchingRow);
              rowData = {
                url: matchingRow.url,
                title: matchingRow.title || pageTitle,
                clicks: matchingRow.clicks || 0,
                impressions: matchingRow.impressions || 0,
                ctr: matchingRow.ctr || 0,
                avgPosition: matchingRow.avgPosition != null ? matchingRow.avgPosition : (matchingRow.position || null),
                position: matchingRow.position || matchingRow.avgPosition || null,
                segment: matchingRow.segment || 'money_pages',
                metaDescription: matchingRow.metaDescription || null,
                _aiCitations: typeof matchingRow._aiCitations === 'number' ? matchingRow._aiCitations : (matchingRow.aiCitations || 0)
              };
              console.log('[Money Pages] Extracted row data:', rowData);
            } else {
              console.log('[Money Pages] Row not found in moneyPagesMetrics.rows. Total rows:', window.moneyPagesMetrics.rows.length);
              // Log sample URLs for debugging
              const sampleUrls = window.moneyPagesMetrics.rows.slice(0, 5).map(r => r.url);
              console.log('[Money Pages] Sample URLs in rows:', sampleUrls);
            }
          }
          
          // Method 3: Fallback - create minimal row data
          if (!rowData) {
            console.warn('[Money Pages]  Row data not found anywhere! Using fallback with 0 metrics.');
            debugLog(` Row data not found for ${pageUrl}, using fallback data (metrics will be 0)`, 'warn');
            rowData = {
              url: pageUrl,
              title: pageTitle,
              clicks: 0,
              impressions: 0,
              ctr: 0,
              avgPosition: null,
              _aiCitations: 0
            };
          }
          
          // Open modal with row data
          if (window.openTrackMoneyPageModal) {
            console.log('[Money Pages] Opening modal with row data:', rowData);
            window.openTrackMoneyPageModal(rowData);
          } else {
            console.error('[Money Pages] openTrackMoneyPageModal function not found!');
            alert('Error: Modal function not found. Please refresh the page.');
          }
        } catch (error) {
          console.error('[Money Pages] Error in trackMoneyPage:', error);
          debugLog(` Error opening Track modal: ${error.message}`, 'error');
          showStatus(` Failed to open modal: ${error.message}`, 'error');
        }
      };
      
      // Step 5: Build optimisation task payload from Money Page row
      // CTR target: 2.5% absolute (stored as 0.025 ratio)
      function buildOptimizationTaskFromMoneyPage(row) {
        const normalizedUrl = normalizeUrlForDedupe(row.url);
        const title = row.page_title || row.slug || normalizedUrl;
        
        return {
          keyword_text: normalizedUrl, // Use URL as keyword (API requires non-empty, but task is page-level)
          target_url: normalizedUrl,
          task_type: 'on_page',
          status: 'planned',
          title: `MP: ${title}`,
          // Don't provide objective fields here - we'll create Cycle 1 manually with proper objective
          // This avoids creating a cycle with legacy fields
        };
      }
      
      // Create cycle with absolute CTR objective
      async function createCycleWithAbsoluteCtrObjective(taskId, adminKey) {
        // CTR target: 2.5% = 0.025 as ratio (CTR is stored as 0-1 in DB)
        const ctrTargetRatio = 0.025;
        
        const objectiveData = {
          title: 'CTR  2.5%',
          kpi: 'ctr_28d',
          target: ctrTargetRatio,
          target_type: 'absolute',
          due_at: null,
          plan: 'Created from Money Pages segment (CTR target:  2.5%).'
        };
        
        const response = await fetch(`/api/optimisation/task/${taskId}/cycle`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-arp-admin-key': adminKey
          },
          body: JSON.stringify({
            objective: objectiveData
          })
        });
        
        if (!response.ok) {
          const error = await response.text();
          throw new Error(`Failed to create cycle: ${error}`);
        }
        
        return await response.json();
      }
      
      // Step 3 & 5: Create optimisation tasks for Money Pages
      async function createOptimizationTasksFromMoneyPages() {
        try {
          // Step 1: Fetch all Money Pages (ignoring filters)
          console.info('[Money Pages Tasks] Fetching all money pages...');
          const moneyPages = await fetchMoneyPagesSegmentAll();
          console.info(`[Money Pages Tasks] Found ${moneyPages.length} money pages`);
          
          if (moneyPages.length === 0) {
            alert('No money pages data available. Please run an audit first.');
            return;
          }
          
          // Step 2: Fetch existing task URLs for de-dupe
          console.info('[Money Pages Tasks] Fetching existing task URLs...');
          const existingUrls = await fetchExistingOptimizationTaskUrls();
          console.info(`[Money Pages Tasks] Found ${existingUrls.size} existing tasks`);
          
          // Step 3: Filter out duplicates
          const newPages = [];
          const skippedPages = [];
          
          for (const page of moneyPages) {
            const normalizedUrl = normalizeUrlForDedupe(page.url);
            if (existingUrls.has(normalizedUrl)) {
              skippedPages.push(page);
            } else {
              newPages.push(page);
            }
          }
          
          console.info(`[Money Pages Tasks] ${newPages.length} new tasks to create, ${skippedPages.length} duplicates to skip`);
          
          // Show confirmation modal
          const confirmed = await showCreateTasksModal(newPages.length, skippedPages.length);
          if (!confirmed) {
            return;
          }
          
          // Step 4: Create tasks
          const adminKey = window.getAdminKey ? window.getAdminKey() : (sessionStorage.getItem('arp_admin_key') || localStorage.getItem('arp_admin_key') || '');
          if (!adminKey) {
            throw new Error('Admin key required. Please set your admin key in the configuration section.');
          }
          
          let createdCount = 0;
          let errorCount = 0;
          const createdTasks = [];
          
          for (const page of newPages) {
            try {
              const taskPayload = buildOptimizationTaskFromMoneyPage(page);
              
              // Create task
              const taskResponse = await fetch('/api/optimisation/task', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-arp-admin-key': adminKey
                },
                body: JSON.stringify(taskPayload)
              });
              
              if (!taskResponse.ok) {
                const error = await taskResponse.text();
                throw new Error(`Failed to create task: ${error}`);
              }
              
              const taskResult = await taskResponse.json();
              const taskId = taskResult.task?.id;
              
              if (taskId) {
                // Create Cycle 1 with absolute CTR objective
                // Task creation API doesn't create a cycle if we don't provide objective fields
                try {
                  await createCycleWithAbsoluteCtrObjective(taskId, adminKey);
                } catch (cycleError) {
                  console.warn(`[Money Pages Tasks] Cycle creation failed for task ${taskId}, but task was created:`, cycleError);
                  // Continue - task is created even if cycle creation fails
                }
                
                createdCount++;
                if (createdTasks.length < 3) {
                  createdTasks.push(taskPayload);
                }
              }
            } catch (error) {
              console.error(`[Money Pages Tasks] Error creating task for ${page.url}:`, error);
              errorCount++;
            }
          }
          
          // Step 7: Show toast and refresh
          showCreateTasksToast(createdCount, skippedPages.length, errorCount);
          
          // Log summary (dev-only)
          console.info('[Money Pages Tasks] Summary:', {
            totalMoneyPages: moneyPages.length,
            duplicatesFound: skippedPages.length,
            insertedCount: createdCount,
            errorCount: errorCount,
            firstThreePayloads: createdTasks
          });
          
          // Refresh Optimisation Tracking if available
          if (typeof window.loadAllOptimisationTasks === 'function') {
            await window.loadAllOptimisationTasks();
          }
          
        } catch (error) {
          console.error('[Money Pages Tasks] Error:', error);
          alert(`Error creating tasks: ${error.message}`);
        }
      }
      
      // Show confirmation modal
      function showCreateTasksModal(newCount, skippedCount) {
        return new Promise((resolve) => {
          const modal = document.createElement('div');
          modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;';
          
          modal.innerHTML = `
            <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 500px; width: 90%; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
              <h3 style="margin: 0 0 1rem 0; font-size: 1.25rem; font-weight: 700; color: #1e293b;">Create optimisation tasks for ${newCount} money pages</h3>
              <div style="margin-bottom: 1.5rem; font-size: 0.95rem; color: #475569; line-height: 1.6;">
                <p style="margin: 0 0 0.75rem 0;">This will create one optimisation task per money page with:</p>
                <ul style="margin: 0 0 0.75rem 0; padding-left: 1.5rem;">
                  <li>CTR objective (absolute target:  2.5%)</li>
                  <li>No keyword (page-level optimisation)</li>
                  <li>Status: Planned</li>
                </ul>
                <p style="margin: 0;"><strong>Existing tasks are skipped:</strong> ${skippedCount} duplicate${skippedCount !== 1 ? 's' : ''} found.</p>
              </div>
              <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                <button id="create-tasks-cancel" style="padding: 0.5rem 1.5rem; background: #e2e8f0; color: #475569; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">Cancel</button>
                <button id="create-tasks-confirm" style="padding: 0.5rem 1.5rem; background: #3b82f6; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">Create</button>
              </div>
            </div>
          `;
          
          document.body.appendChild(modal);
          
          modal.querySelector('#create-tasks-cancel').onclick = () => {
            document.body.removeChild(modal);
            resolve(false);
          };
          
          modal.querySelector('#create-tasks-confirm').onclick = () => {
            document.body.removeChild(modal);
            resolve(true);
          };
        });
      }
      
      // Show toast notification
      function showCreateTasksToast(created, skipped, errors) {
        const toast = document.createElement('div');
        toast.style.cssText = 'position: fixed; bottom: 2rem; right: 2rem; background: #10b981; color: white; padding: 1rem 1.5rem; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 10001; max-width: 400px;';
        
        let message = `Created ${created} task${created !== 1 ? 's' : ''}`;
        if (skipped > 0) {
          message += `  Skipped ${skipped} duplicate${skipped !== 1 ? 's' : ''}`;
        }
        if (errors > 0) {
          message += `  ${errors} error${errors !== 1 ? 's' : ''}`;
        }
        
        toast.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem;">
            <span style="font-weight: 600;">${message}</span>
            <button id="toast-view-tasks" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 0.25rem 0.75rem; border-radius: 4px; cursor: pointer; font-size: 0.875rem; font-weight: 600;">View in Optimisation Tracking</button>
            <button id="toast-close" style="background: none; border: none; color: white; cursor: pointer; font-size: 1.25rem; padding: 0; line-height: 1;"></button>
          </div>
        `;
        
        document.body.appendChild(toast);
        
        toast.querySelector('#toast-close').onclick = () => {
          document.body.removeChild(toast);
        };
        
        toast.querySelector('#toast-view-tasks').onclick = () => {
          // Navigate to Optimisation Tracking module
          if (typeof setActivePanel === 'function') {
            setActivePanel('optimisation');
          }
          document.body.removeChild(toast);
        };
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
          if (document.body.contains(toast)) {
            document.body.removeChild(toast);
          }
        }, 5000);
      }
      
      // Wire up button click handler (called after Money Pages section is rendered)
      function wireMoneyPagesCreateTasksButton() {
        const btn = document.getElementById('money-pages-create-tasks-btn');
        if (btn && !btn.dataset.wired) {
          btn.dataset.wired = 'true';
          btn.addEventListener('click', () => {
            createOptimizationTasksFromMoneyPages();
          });
        }
      }
      
      // Helper function to filter money pages data by sub-segment
      // Apply all filters and calculate filtered metrics
      function getFilteredMoneyPagesMetrics(moneyPagesMetrics) {
        if (!moneyPagesMetrics || !moneyPagesMetrics.rows) {
          return null;
        }

        const currentCategoryFilter = String(window.moneyPagesCategoryFilter || 'ALL').toUpperCase();
        const currentSubSegmentFilter = String(window.moneyPagesSubSegmentFilter || 'ALL').toUpperCase();
        const currentMinImpressions = Number(window.moneyPagesMinImpressions || 0) || 0;
        const includeZero = window.moneyPagesIncludeZero !== false;

        // Apply all filters
        const filteredRows = moneyPagesMetrics.rows.filter(row => {
          const rowCat = String(row.category || '').toUpperCase();
          const rowSub = String(row.subSegment || row.segmentType || '').toUpperCase();
          const matchCat = currentCategoryFilter === 'ALL' || rowCat === currentCategoryFilter;
          const matchSubSeg = currentSubSegmentFilter === 'ALL' || rowSub === currentSubSegmentFilter;
          const matchImp = (row.impressions || 0) >= currentMinImpressions;
          const matchZero = includeZero || (row.impressions || 0) > 0;
          return matchCat && matchSubSeg && matchImp && matchZero;
        });
        
        // Recalculate summaryByCategory from filtered rows
        const filteredSummaryByCategory = {
          HIGH_OPPORTUNITY: { count: 0, impressions: 0, clicks: 0 },
          VISIBILITY_FIX: { count: 0, impressions: 0, clicks: 0 },
          MAINTAIN: { count: 0, impressions: 0, clicks: 0 }
        };
        
        let filteredClicks = 0;
        let filteredImpressions = 0;
        let filteredWeightedPosSum = 0;
        
        filteredRows.forEach(row => {
          const bucket = filteredSummaryByCategory[row.category];
          if (bucket) {
            bucket.count += 1;
            bucket.impressions += row.impressions || 0;
            bucket.clicks += row.clicks || 0;
          }
          filteredClicks += row.clicks || 0;
          filteredImpressions += row.impressions || 0;
          filteredWeightedPosSum += (row.avgPosition || 0) * (row.impressions || 0);
        });
        
        const filteredCtr = filteredImpressions > 0 ? filteredClicks / filteredImpressions : 0;
        const filteredAvgPosition = filteredImpressions > 0 ? filteredWeightedPosSum / filteredImpressions : null;
        
        return {
          ...moneyPagesMetrics,
          rows: filteredRows,
          summaryByCategory: filteredSummaryByCategory,
          overview: {
            ...moneyPagesMetrics.overview,
            moneyClicks: filteredClicks,
            moneyImpressions: filteredImpressions,
            moneyCtr: filteredCtr,
            moneyAvgPosition: filteredAvgPosition,
            moneyCoverageCount: filteredRows.length
          }
        };
      }
      
      // Get filter description for chart title
      function getFilterDescription() {
        const categoryFilter = window.moneyPagesCategoryFilter || 'ALL';
        const subSegmentFilter = window.moneyPagesSubSegmentFilter || 'ALL';
        const minImpressions = window.moneyPagesMinImpressions || 0;
        const includeZero = window.moneyPagesIncludeZero !== false;
        
        const parts = [];
        
        if (categoryFilter !== 'ALL') {
          const categoryLabels = {
            'HIGH_OPPORTUNITY': 'High opportunity',
            'VISIBILITY_FIX': 'Visibility fix',
            'MAINTAIN': 'Maintain'
          };
          parts.push(categoryLabels[categoryFilter] || categoryFilter);
        }
        
        if (subSegmentFilter !== 'ALL') {
          const subSegmentLabels = {
            'PRODUCT': 'Product',
            'EVENT': 'Event',
            'LANDING': 'Landing'
          };
          parts.push(subSegmentLabels[subSegmentFilter] || subSegmentFilter);
        }
        
        if (minImpressions > 0) {
          parts.push(`${minImpressions} impressions`);
        }
        
        if (!includeZero) {
          parts.push('with impressions');
        }
        
        if (parts.length === 0) {
          return 'Money Pages';
        }
        
        return parts.join(' ') + ' Pages';
      }
      
      // Ensure this helper exists in the global scope (Money tab can run before other sections)
      if (!window.computeMoneyPagesBehaviourFromPageAggregates) {
        window.computeMoneyPagesBehaviourFromPageAggregates = function(moneyPages) {
          if (!Array.isArray(moneyPages) || moneyPages.length === 0) return null;

          let clicks = 0;
          let impressions = 0;
          let weightedPosSum = 0;
          let weightedPosImps = 0;
          let top10Clicks = 0;
          let top10Impressions = 0;

          moneyPages.forEach(p => {
            const imps = p.impressions || 0;
            const cls = p.clicks || 0;
            const pos = typeof p.avgPosition === 'number' ? p.avgPosition : (p.avgPosition ? Number.parseFloat(p.avgPosition) : null);
            if (!imps || !pos || pos <= 0) return;

            clicks += cls;
            impressions += imps;
            weightedPosSum += pos * imps;
            weightedPosImps += imps;
            if (pos <= 10) {
              top10Clicks += cls;
              top10Impressions += imps;
            }
          });

          if (!impressions || !weightedPosImps) return null;

          const siteCtr = clicks / impressions;
          const top10Ctr = top10Impressions > 0 ? (top10Clicks / top10Impressions) : 0;
          const avgPos = weightedPosSum / weightedPosImps;
          const top10Share = impressions > 0 ? (top10Impressions / impressions) : 0;

          const scoreCtrAll = Math.min(siteCtr / 0.05, 1) * 100;
          const scoreCtrTop10 = Math.min(top10Ctr / 0.10, 1) * 100;
          const behaviourScore = 0.5 * scoreCtrAll + 0.5 * scoreCtrTop10;

          return {
            score: behaviourScore,
            siteCtr,
            top10Ctr,
            avgPos,
            top10Share,
            clicks,
            impressions
          };
        };
      }

      // Update chart title and summary box
      function updateMoneyPagesChartSummary(filteredMetrics) {
        if (!filteredMetrics) return;
        
        // Update chart title
        const titleEl = document.getElementById('money-pages-chart-title');
        if (titleEl) {
          const filterDesc = getFilterDescription();
          titleEl.textContent = (filterDesc || 'Money Pages') + ' Opportunity Mix';
        }
        
        // Calculate behaviour score for filtered pages
        const queryPages = window.currentQueryPages || [];
        const filteredRows = filteredMetrics.rows || [];
        let filteredBehaviour = window.computeMoneyPagesBehaviour ? 
          window.computeMoneyPagesBehaviour(queryPages, filteredRows, true) : null;
        if (!filteredBehaviour || !filteredBehaviour.impressions) {
          const aggFn = window.computeMoneyPagesBehaviourFromPageAggregates;
          filteredBehaviour = typeof aggFn === 'function' ? aggFn(filteredRows) : null;
        }
        
        // Update summary box
        const overview = filteredMetrics.overview || {};
        const pagesCount = filteredRows.length;
        const impressions = overview.moneyImpressions || 0;
        const clicks = overview.moneyClicks || 0;
        const ctr = overview.moneyCtr || 0;
        const behaviourScore = filteredBehaviour ? filteredBehaviour.score : null;
        
        const pagesEl = document.getElementById('summary-pages-count');
        const impressionsEl = document.getElementById('summary-impressions');
        const clicksEl = document.getElementById('summary-clicks');
        const ctrEl = document.getElementById('summary-ctr');
        const behaviourEl = document.getElementById('summary-behaviour');
        
        if (pagesEl) pagesEl.textContent = pagesCount.toLocaleString();
        if (impressionsEl) impressionsEl.textContent = impressions.toLocaleString();
        if (clicksEl) clicksEl.textContent = clicks.toLocaleString();
        
        // Update CTR with RAG color coding
        if (ctrEl) {
          if (impressions > 0) {
            const ctrPercent = ctr * 100;
            ctrEl.textContent = `${ctrPercent.toFixed(1)}%`;
            // Apply RAG color: Green >= 2.5%, Amber 1.0-2.49%, Red < 1.0%
            if (ctrPercent >= 2.5) {
              ctrEl.style.color = '#10b981'; // green
            } else if (ctrPercent >= 1.0) {
              ctrEl.style.color = '#f59e0b'; // amber
            } else {
              ctrEl.style.color = '#ef4444'; // red
            }
          } else {
            ctrEl.textContent = '-';
            ctrEl.style.color = '#64748b';
          }
        }
        
        // Update Behaviour Score with RAG color coding
        if (behaviourEl) {
          if (behaviourScore !== null && behaviourScore !== undefined) {
            behaviourEl.textContent = Math.round(behaviourScore);
            // Apply RAG color: Green >= 70, Amber 40-69, Red < 40
            if (behaviourScore >= 70) {
              behaviourEl.style.color = '#10b981'; // green
            } else if (behaviourScore >= 40) {
              behaviourEl.style.color = '#f59e0b'; // amber
            } else {
              behaviourEl.style.color = '#ef4444'; // red
            }
          } else {
            behaviourEl.textContent = 'N/A';
            behaviourEl.style.color = '#64748b';
          }
        }
      }
      
      // Render Money Pages category chart (Phase 2)
      let moneyPagesCategoryChart = null;
      
      function renderMoneyPagesCategoryChart(moneyPagesMetrics, retryCount = 0) {
        const summaryEl = document.getElementById('money-pages-category-summary');
        const breakdownEl = document.getElementById('money-pages-category-breakdown');

        // Show loading placeholder early (prevents blank card)
        if (retryCount === 0 && summaryEl && !summaryEl.textContent) {
          summaryEl.textContent = 'Loading opportunity mix';
        }

        // Prevent excessive retries (show user-facing message instead of blank canvas)
        if (retryCount > 8) {
          debugLog(' Max retries reached for Money Pages Opportunity Mix chart', 'warn');
          if (summaryEl) {
            summaryEl.textContent = 'Could not render Opportunity Mix chart. Try switching tabs or refreshing.';
            summaryEl.style.color = '#b45309';
          }
          if (breakdownEl) breakdownEl.innerHTML = '';
          return;
        }

        debugLog(`renderMoneyPagesCategoryChart called (attempt ${retryCount + 1})`, 'info');
        
        // Check if Chart.js is available
        if (typeof Chart === 'undefined') {
          debugLog(' Chart.js not loaded, cannot render money pages chart', 'warn');
          // Retry after a delay if Chart.js might still be loading
          if (retryCount < 3) {
            setTimeout(() => renderMoneyPagesCategoryChart(moneyPagesMetrics, retryCount + 1), 500);
          }
          return;
        }
        
        const canvas = document.getElementById('money-pages-category-chart');
        if (!canvas) {
          debugLog(` Money pages chart canvas not found (attempt ${retryCount + 1})`, 'warn');
          // Retry if canvas doesn't exist yet (DOM might not be ready)
          if (retryCount < 5) {
            setTimeout(() => renderMoneyPagesCategoryChart(moneyPagesMetrics, retryCount + 1), 200);
          }
          return;
        }
        
        if (!moneyPagesMetrics || !moneyPagesMetrics.summaryByCategory) {
          debugLog(' Money pages metrics or summaryByCategory missing', 'warn');
          // Hide chart row if no data
          const chartRow = document.getElementById('money-pages-chart-row');
          if (chartRow) {
            chartRow.style.display = 'none';
          }
          if (summaryEl) summaryEl.textContent = 'No opportunity mix data available for this audit.';
          return;
        }
        
        // Apply all filters
        const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
        if (!filteredMetrics) {
          debugLog(' No filtered metrics available', 'warn');
          return;
        }
        
        const { summaryByCategory } = filteredMetrics;
        debugLog(`Money pages summaryByCategory: ${JSON.stringify(summaryByCategory)}`, 'info');
        
        const labels = [
          'High opportunity',
          'Visibility fix',
          'Maintain'
        ];
        const keys = ['HIGH_OPPORTUNITY', 'VISIBILITY_FIX', 'MAINTAIN'];
        
        const counts = keys.map(k => (summaryByCategory[k]?.count || 0));
        const impressions = keys.map(k => (summaryByCategory[k]?.impressions || 0));
        
        debugLog(`Money pages chart data - counts: [${counts.join(', ')}], impressions: [${impressions.join(', ')}]`, 'info');
        
        // Check for no data
        const totalPages = counts.reduce((a, b) => a + b, 0);
        const totalImpressions = impressions.reduce((a, b) => a + b, 0);
        function setNoDataMessage() {
          if (summaryEl) {
            summaryEl.textContent = 'No meaningful money-page impressions found for this audit period.';
          }
          if (breakdownEl) {
            breakdownEl.innerHTML = '';
          }
        }
        
        if (!totalPages || !totalImpressions) {
          debugLog(' No money pages data for chart', 'warn');
          const chartRow = document.getElementById('money-pages-chart-row');
          if (chartRow) {
            const canvas = chartRow.querySelector('#money-pages-category-chart');
            if (canvas) canvas.remove();
            setNoDataMessage();
          }
          return;
        }
        
        // Show chart row and ensure it's visible
        const chartRow = document.getElementById('money-pages-chart-row');
        if (!chartRow) {
          debugLog(' Chart row element not found', 'warn');
          // Retry if chart row doesn't exist yet
          if (retryCount < 3) {
            setTimeout(() => renderMoneyPagesCategoryChart(moneyPagesMetrics, retryCount + 1), 200);
          }
          return;
        }
        
        // Ensure chart row is visible
        chartRow.style.display = 'block';
        chartRow.style.visibility = 'visible';
        debugLog(' Chart row is visible', 'success');
        
        // Re-check canvas after ensuring row is visible (in case it wasn't accessible before)
        const canvasCheck = document.getElementById('money-pages-category-chart');
        if (!canvasCheck) {
          debugLog(' Canvas still not found after showing row, retrying...', 'warn');
          if (retryCount < 3) {
            setTimeout(() => renderMoneyPagesCategoryChart(moneyPagesMetrics, retryCount + 1), 200);
          }
          return;
        }
        
        // Destroy existing chart if it exists to prevent memory leaks
        // Also check Chart.js registry to ensure canvas is not already in use
        if (moneyPagesCategoryChart) {
          try {
            moneyPagesCategoryChart.destroy();
            moneyPagesCategoryChart = null;
          } catch (e) {
            debugLog('Error destroying existing chart: ' + e.message, 'warn');
          }
        }
        
        // Also check Chart.js registry and destroy any existing chart on this canvas
        if (typeof Chart !== 'undefined' && Chart.getChart) {
          const existingChart = Chart.getChart(canvas);
          if (existingChart) {
            try {
              existingChart.destroy();
              debugLog('Destroyed existing Chart.js instance from registry', 'info');
            } catch (e) {
              debugLog('Error destroying chart from registry: ' + e.message, 'warn');
            }
          }
        }
        
        // Clear canvas context to ensure clean slate
        const tempCtx = canvas.getContext('2d');
        if (tempCtx) {
          tempCtx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // Set explicit canvas dimensions FIRST to ensure it has size
        // This must happen before checking dimensions
        const parentContainer = canvas.parentElement;
        if (parentContainer) {
          const containerWidth = parentContainer.clientWidth || parentContainer.offsetWidth || 500;
          const containerHeight = 300; // Fixed height for consistency
          canvas.width = containerWidth;
          canvas.height = containerHeight;
        } else {
          canvas.width = 500;
          canvas.height = 300;
        }
        
        // Check if panel/canvas are actually visible and have dimensions AFTER setting them
        const moneyPanel = canvas.closest('.aigeo-panel[data-panel="money"]');
        const isPanelActive = !moneyPanel || moneyPanel.classList.contains('is-active');
        const isPanelVisible = !moneyPanel || (isPanelActive && window.getComputedStyle(moneyPanel).display !== 'none');
        
        const canvasRect = canvas.getBoundingClientRect();
        const hasDimensions = canvasRect.width > 0 && canvasRect.height > 0;
        
        if (!isPanelActive) {
          debugLog(` Money Pages Opportunity Mix: panel not active yet, waiting`, 'warn');
          if (summaryEl) summaryEl.textContent = 'Loading opportunity mix';
          if (moneyPanel) {
            const observer = new MutationObserver(() => {
              if (moneyPanel.classList.contains('is-active')) {
                observer.disconnect();
                requestAnimationFrame(() => renderMoneyPagesCategoryChart(moneyPagesMetrics, 0));
              }
            });
            observer.observe(moneyPanel, { attributes: true, attributeFilter: ['class'] });
          }
          return;
        }

        if (!hasDimensions || !isPanelVisible) {
          debugLog(` Money Pages Opportunity Mix chart: panelVisible=${isPanelVisible} or canvas ${canvasRect.width}${canvasRect.height} (width=${canvasRect.width}, height=${canvasRect.height}, display=${moneyPanel ? window.getComputedStyle(moneyPanel).display : 'N/A'}), retrying`, 'warn');
          setTimeout(() => renderMoneyPagesCategoryChart(moneyPagesMetrics, retryCount + 1), 300);
          return;
        }
        
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          debugLog(' Could not get canvas context', 'warn');
          return;
        }
        
        // Use impressions as weight for the chart slices
        const dataValues = impressions;
        
        debugLog(`Creating money pages category chart with data: [${dataValues.join(', ')}]`, 'info');
        
        try {
          moneyPagesCategoryChart = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels,
            datasets: [
              {
                data: dataValues,
                backgroundColor: [
                  '#f59e0b', // Amber for High opportunity
                  '#ef4444', // Red for Visibility fix
                  '#10b981'  // Green for Maintain
                ],
                borderColor: [
                  '#d97706',
                  '#dc2626',
                  '#059669'
                ],
                borderWidth: 2
              }
            ]
          },
          options: {
            responsive: false,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  padding: 15,
                  font: {
                    size: 12
                  }
                }
              },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    const label = context.label || '';
                    const value = context.raw || 0;
                    const total = dataValues.reduce((a, b) => a + b, 0) || 1;
                    const pct = (value / total) * 100;
                    const count = counts[context.dataIndex] || 0;
                    return `${label}: ${value.toLocaleString()} impressions, ` +
                           `${count} pages (${pct.toFixed(1)}%)`;
                  }
                }
              }
            },
            cutout: '60%'
          }
        });
        debugLog(' Money pages category chart created successfully', 'success');
        
        // Update chart title and summary box with filtered data
        updateMoneyPagesChartSummary(filteredMetrics);
        
        // Populate summary and breakdown after chart is created
        const totalPages = counts.reduce((a, b) => a + b, 0);
        const totalImpressions = impressions.reduce((a, b) => a + b, 0);
        
        const summaryEl = document.getElementById('money-pages-category-summary');
        const breakdownEl = document.getElementById('money-pages-category-breakdown');
        
        // 1) Summary line
        if (summaryEl && totalPages > 0 && totalImpressions > 0) {
          const highImps = impressions[0] || 0;
          const visImps = impressions[1] || 0;
          const mainImps = impressions[2] || 0;
          const mainBucket =
            highImps >= visImps && highImps >= mainImps
              ? 'high-opportunity'
              : visImps >= mainImps
                ? 'visibility-fix'
                : 'maintain';
          
          const focusShare = (Math.max(highImps, visImps, mainImps) / totalImpressions) * 100;
          
          summaryEl.textContent =
            `${totalPages} money pages, ${totalImpressions.toLocaleString()} impressions. ` +
            `Largest share is ${mainBucket} pages ` +
            `(${focusShare.toFixed(1)}% of impressions).`;
        }
        
        // 2) Category pills row
        if (breakdownEl && totalImpressions > 0) {
          breakdownEl.innerHTML = ''; // clear
          
          const colors = ['pill-warning', 'pill-danger', 'pill-success']; // high, vis, maintain
          
          impressions.forEach((imps, idx) => {
            if (!imps) return;
            const count = counts[idx] || 0;
            const pct = (imps / totalImpressions) * 100;
            
            const pill = document.createElement('span');
            pill.className = `pill pill-small ${colors[idx]}`;
            pill.style.cssText = 'display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.8rem; font-weight: 600; margin: 0.125rem;';
            if (colors[idx] === 'pill-warning') {
              pill.style.background = '#fef3c7'; pill.style.color = '#92400e';
            } else if (colors[idx] === 'pill-danger') {
              pill.style.background = '#fee2e2'; pill.style.color = '#991b1b';
            } else {
              pill.style.background = '#d1fae5'; pill.style.color = '#065f46';
            }
            pill.textContent =
              `${labels[idx]}: ${count} pages, ` +
              `${imps.toLocaleString()} imps (${pct.toFixed(1)}%)`;
            
            breakdownEl.appendChild(pill);
          });
        }
        
        } catch (error) {
          debugLog(` Error creating money pages chart: ${error.message}`, 'error');
          console.error('Error creating money pages category chart:', error);
        }
      }
      
      // Phase 3: Render Money Pages Trend Chart
      function renderMoneyPagesTrendChart(history) {
        const ctx = document.getElementById('moneyPagesTrendChart');
        if (!ctx) {
          debugLog(' Money Pages trend chart canvas not found', 'warn');
          return;
        }
        
        if (!history || !history.length) {
          debugLog(' No history data for Money Pages trend chart', 'warn');
          // Show message in chart container
          const cardBody = ctx.closest('.card-body');
          if (cardBody) {
            cardBody.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b; font-size: 0.9rem;">No historical audit data available. Run multiple audits to see trends over time.</div>';
          }
          return;
        }
        
        // Check if Chart.js is available
        if (typeof Chart === 'undefined') {
          debugLog(' Chart.js not loaded, cannot render Money Pages trend chart', 'warn');
          return;
        }
        
        // Destroy existing chart if it exists
        if (window.moneyPagesTrendChart) {
          try {
            // Check if it's a Chart.js instance before calling destroy
            if (window.moneyPagesTrendChart && typeof window.moneyPagesTrendChart.destroy === 'function') {
            window.moneyPagesTrendChart.destroy();
            }
            window.moneyPagesTrendChart = null;
          } catch (e) {
            debugLog('Error destroying existing trend chart: ' + e.message, 'warn');
          }
        }
        
        // Extract money pages history from audit history
        const moneyHistory = history.map(row => ({
          date: row.date,
          dateLabel: row.date ? new Date(row.date).toLocaleDateString('en-GB', { month: 'short', day: 'numeric' }) : row.date,
          behaviourScore: row.moneyPagesBehaviourScore ?? null,
          shareOfImpressions: row.moneyPagesSummary?.shareOfImpressions ?? null,
          shareOfClicks: row.moneyPagesSummary?.shareOfClicks ?? null,
          ctr: row.moneyPagesSummary?.ctr ?? null
        })).filter(h => h.date); // Filter out entries without dates
        
        debugLog(` Money Pages Trend: Extracted ${moneyHistory.length} history entries from ${history.length} total records`, 'info');
        if (moneyHistory.length > 0) {
          const sample = moneyHistory[0];
          debugLog(` Sample entry: date=${sample.date}, behaviourScore=${sample.behaviourScore}, shareOfImpressions=${sample.shareOfImpressions}, shareOfClicks=${sample.shareOfClicks}, ctr=${sample.ctr}`, 'info');
          debugLog(` Sample entry moneyPagesSummary: ${JSON.stringify(sample.moneyPagesSummary || 'missing')}`, 'info');
        } else {
          debugLog(` Money Pages Trend: No valid history entries extracted. History records: ${history.length}`, 'warn');
          if (history.length > 0) {
            debugLog(` Sample history record keys: ${Object.keys(history[0]).join(', ')}`, 'warn');
            debugLog(` Sample history record: ${JSON.stringify(history[0])}`, 'warn');
          }
        }
        
        // Add current audit data if available
        const currentMoneyPagesMetrics = window.currentMoneyPagesMetrics || (window.saved && window.saved.scores && window.saved.scores.moneyPagesMetrics);
        const currentSearchData = window.currentSearchData || (window.saved && window.saved.searchData);
        
        if (currentMoneyPagesMetrics && currentMoneyPagesMetrics.behaviour && currentMoneyPagesMetrics.behaviour.score != null) {
          const today = new Date().toISOString().split('T')[0];
          const currentSummary = window.buildMoneyPagesSummary ? window.buildMoneyPagesSummary(currentMoneyPagesMetrics, currentSearchData?.overview || null) : null;
          
          // Check if today's data is already in history
          const todayInHistory = moneyHistory.find(h => h.date === today);
          if (!todayInHistory && currentSummary) {
            debugLog(` Adding current audit data to Money Pages trend: date=${today}, behaviourScore=${currentMoneyPagesMetrics.behaviour.score}, shareOfImpressions=${currentSummary.shareOfImpressions}, ctr=${currentSummary.ctr}`, 'info');
            debugLog(` Current overview: ${JSON.stringify(currentSearchData?.overview || 'missing')}`, 'info');
            moneyHistory.push({
              date: today,
              dateLabel: new Date(today).toLocaleDateString('en-GB', { month: 'short', day: 'numeric' }),
              behaviourScore: currentMoneyPagesMetrics.behaviour.score,
              shareOfImpressions: currentSummary.shareOfImpressions,
              shareOfClicks: currentSummary.shareOfClicks,
              ctr: currentSummary.ctr
            });
          } else if (todayInHistory && currentMoneyPagesMetrics.behaviour.score != null) {
            // Update today's entry with current data if it exists but is missing behaviour score
            if (todayInHistory.behaviourScore == null) {
              debugLog(` Updating today's entry with current behaviour score: ${currentMoneyPagesMetrics.behaviour.score}`, 'info');
              todayInHistory.behaviourScore = currentMoneyPagesMetrics.behaviour.score;
              if (currentSummary) {
                todayInHistory.shareOfImpressions = currentSummary.shareOfImpressions;
                todayInHistory.shareOfClicks = currentSummary.shareOfClicks;
                todayInHistory.ctr = currentSummary.ctr;
              }
            }
          }
        }
        
        // Sort by date
        moneyHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        // Forward-fill missing values: use last available value for each metric
        let lastValues = {
          behaviourScore: null,
          shareOfImpressions: null,
          shareOfClicks: null,
          ctr: null
        };
        
        for (const entry of moneyHistory) {
          // Forward-fill missing values
          if (entry.behaviourScore == null && lastValues.behaviourScore != null) {
            entry.behaviourScore = lastValues.behaviourScore;
          }
          if (entry.shareOfImpressions == null && lastValues.shareOfImpressions != null) {
            entry.shareOfImpressions = lastValues.shareOfImpressions;
          }
          if (entry.shareOfClicks == null && lastValues.shareOfClicks != null) {
            entry.shareOfClicks = lastValues.shareOfClicks;
          }
          if (entry.ctr == null && lastValues.ctr != null) {
            entry.ctr = lastValues.ctr;
          }
          
          // Update last values if we have new ones
          if (entry.behaviourScore != null) lastValues.behaviourScore = entry.behaviourScore;
          if (entry.shareOfImpressions != null) lastValues.shareOfImpressions = entry.shareOfImpressions;
          if (entry.shareOfClicks != null) lastValues.shareOfClicks = entry.shareOfClicks;
          if (entry.ctr != null) lastValues.ctr = entry.ctr;
        }
        
        if (moneyHistory.length === 0) {
          debugLog(' No money pages history data after filtering', 'warn');
          const cardBody = ctx.closest('.card-body');
          if (cardBody) {
            cardBody.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b; font-size: 0.9rem;">No money pages historical data available. Run audits to build trend data.</div>';
          }
          return;
        }
        
        // Filter to only entries with at least one non-null value
        const validHistory = moneyHistory.filter(h => 
          h.behaviourScore != null || 
          h.shareOfImpressions != null || 
          h.ctr != null
        );
        
        if (validHistory.length === 0) {
          debugLog(' No money pages history data with valid values', 'warn');
          const cardBody = ctx.closest('.card-body');
          if (cardBody) {
            cardBody.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b; font-size: 0.9rem;">No money pages historical data available. Run audits to build trend data.</div>';
          }
          return;
        }
        
        debugLog(` Money Pages Trend: Using ${validHistory.length} entries with valid data`, 'info');
        
        const labels = validHistory.map(p => p.dateLabel || p.date);
        const behaviour = validHistory.map(p => p.behaviourScore ?? null);
        const shareImps = validHistory.map(p =>
          p.shareOfImpressions != null ? p.shareOfImpressions * 100 : null
        );
        const ctr = validHistory.map(p =>
          p.ctr != null ? p.ctr * 100 : null
        );
        
        debugLog(` Chart data: ${labels.length} labels, behaviour=${behaviour.filter(v => v != null).length} values, shareImps=${shareImps.filter(v => v != null).length} values, ctr=${ctr.filter(v => v != null).length} values`, 'info');
        
        // Set canvas dimensions FIRST
        const parentContainer = ctx.parentElement;
        if (parentContainer) {
          const containerWidth = parentContainer.clientWidth || parentContainer.offsetWidth || 500;
          ctx.width = containerWidth;
          ctx.height = 300;
        } else {
          ctx.width = 500;
          ctx.height = 300;
        }
        
        // Check if canvas is visible and panel is active AFTER setting dimensions
        const moneyPanel = ctx.closest('.aigeo-panel[data-panel="money"]');
        const isPanelActive = moneyPanel && moneyPanel.classList.contains('is-active');
        const panelStyle = moneyPanel ? window.getComputedStyle(moneyPanel) : null;
        const isPanelVisible = !moneyPanel || (isPanelActive && panelStyle && panelStyle.display !== 'none' && panelStyle.visibility !== 'hidden');
        const canvasRect = ctx.getBoundingClientRect();
        
        // Wait a bit for layout to settle if panel was just activated
        if (!isPanelVisible || canvasRect.width === 0 || canvasRect.height === 0) {
          // Only log warning if panel is not active (to reduce noise)
          if (!isPanelActive) {
            debugLog(` Money Pages trend chart: Panel hidden or canvas has zero dimensions (width=${canvasRect.width}, height=${canvasRect.height}, panelVisible=${isPanelVisible}). Chart will render when panel is shown.`, 'warn');
            // Schedule retry when panel becomes visible
            if (moneyPanel && !moneyPanel.classList.contains('is-active')) {
              // Use a one-time observer
              const observer = new MutationObserver((mutations) => {
                if (moneyPanel.classList.contains('is-active')) {
                  observer.disconnect();
                  // Wait a bit longer for layout to settle
                  setTimeout(() => renderMoneyPagesTrendChart(history), 200);
                }
              });
              observer.observe(moneyPanel, { attributes: true, attributeFilter: ['class'] });
              // Also set a timeout fallback (max 5 seconds)
              setTimeout(() => {
                observer.disconnect();
                if (moneyPanel.classList.contains('is-active')) {
                  renderMoneyPagesTrendChart(history);
                }
              }, 5000);
            }
          } else {
            // Panel is active but canvas still has zero dimensions - retry after a short delay
            setTimeout(() => renderMoneyPagesTrendChart(history), 200);
          }
          return;
        }
        
        try {
          window.moneyPagesTrendChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  label: 'Behaviour score (money pages)',
                  data: behaviour,
                  yAxisID: 'yScore',
                  borderColor: 'rgb(59, 130, 246)',
                  backgroundColor: 'rgba(59, 130, 246, 0.1)',
                  borderWidth: 2,
                  spanGaps: true,
                  tension: 0.1
                },
                {
                  label: 'Share of impressions (%)',
                  data: shareImps,
                  yAxisID: 'yPct',
                  borderColor: 'rgb(16, 185, 129)',
                  backgroundColor: 'rgba(16, 185, 129, 0.1)',
                  borderWidth: 2,
                  borderDash: [4, 4],
                  spanGaps: true,
                  tension: 0.1
                },
                {
                  label: 'CTR on money pages (%)',
                  data: ctr,
                  yAxisID: 'yPct',
                  borderColor: 'rgb(245, 158, 11)',
                  backgroundColor: 'rgba(245, 158, 11, 0.1)',
                  borderWidth: 2,
                  borderDash: [2, 2],
                  spanGaps: true,
                  tension: 0.1
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              aspectRatio: 2,
              scales: {
                yScore: {
                  type: 'linear',
                  position: 'left',
                  min: 0,
                  max: 100,
                  title: { display: true, text: 'Behaviour score' },
                  grid: {
                    color: 'rgba(0, 0, 0, 0.05)'
                  }
                },
                yPct: {
                  type: 'linear',
                  position: 'right',
                  min: 0,
                  max: 100,
                  grid: { drawOnChartArea: false },
                  title: { display: true, text: 'Percent' }
                }
              },
              plugins: {
                title: {
                  display: false // Don't show title - it's already in the HTML
                },
                legend: { position: 'bottom' },
                tooltip: { 
                  mode: 'index', 
                  intersect: false,
                  callbacks: {
                    label: function(context) {
                      let label = context.dataset.label || '';
                      if (label) {
                        label += ': ';
                      }
                      const value = context.parsed.y;
                      if (value === null || value === undefined) {
                        label += 'N/A';
                      } else {
                        label += value.toFixed(2);
                        if (context.dataset.yAxisID === 'yPct') {
                          label += '%';
                        }
                      }
                      return label;
                    }
                  }
                }
              }
            }
          });
          
          debugLog(` Money Pages trend chart rendered with ${moneyHistory.length} data points`, 'success');
        } catch (error) {
          debugLog(` Error creating Money Pages trend chart: ${error.message}`, 'error');
          console.error('Error creating Money Pages trend chart:', error);
        }
      }
      
      // ============================================================================
      // Money Pages Priority Matrix Rendering Functions
      // ============================================================================
      
      /**
       * Render summary strip for Money Pages Priority section
       * @param {Array<MoneyPageMetrics>} moneyPages
       * @param {Object} summary - Overview data with totalClicks and totalImpressions
       * @param {HTMLElement} container
       */
      function renderMoneyPagesSummaryStrip(moneyPages, summary, container) {
        if (!moneyPages || !moneyPages.length) {
          container.innerHTML = '<div style="padding: 1rem; text-align: center; color: #64748b;">No money pages data available.</div>';
          return;
        }
        
        const totalClicks = summary?.overview?.totalClicks || summary?.totalClicks || 0;
        const totalImpressions = summary?.overview?.totalImpressions || summary?.totalImpressions || 0;

        const mpClicks = moneyPages.reduce((sum, p) => sum + (p.clicks || 0), 0);
        const mpImpr = moneyPages.reduce((sum, p) => sum + (p.impressions || 0), 0);

        const shareClicks = totalClicks > 0 ? (mpClicks / totalClicks) * 100 : 0;
        const ctr = mpImpr > 0 ? (mpClicks / mpImpr) * 100 : 0;
        const avgPos = moneyPages.length
          ? moneyPages.reduce((sum, p) => sum + (p.avgPosition || 0), 0) / moneyPages.length
          : 0;

        container.innerHTML = `
          <div class="summary-item" style="flex: 1;">
            <span class="label" style="display: block; font-size: 0.85rem; color: #64748b; margin-bottom: 0.25rem;">Money pages share of clicks</span>
            <span class="value" style="display: block; font-size: 1.5rem; font-weight: 700; color: #1e293b;">${shareClicks.toFixed(1)}%</span>
          </div>
          <div class="summary-item" style="flex: 1;">
            <span class="label" style="display: block; font-size: 0.85rem; color: #64748b; margin-bottom: 0.25rem;">Money pages CTR</span>
            <span class="value" style="display: block; font-size: 1.5rem; font-weight: 700; color: #1e293b;">${ctr.toFixed(1)}%</span>
          </div>
          <div class="summary-item" style="flex: 1;">
            <span class="label" style="display: block; font-size: 0.85rem; color: #64748b; margin-bottom: 0.25rem;">Avg position (money pages)</span>
            <span class="value" style="display: block; font-size: 1.5rem; font-weight: 700; color: #1e293b;">${avgPos ? avgPos.toFixed(1) : ""}</span>
          </div>
        `;
      }
      
      /**
       * Render Priority Matrix (3x3 grid: Impact  Difficulty)
       * @param {Array<MoneyPageMetrics>} moneyPages
       * @param {HTMLElement} container
       * @param {Function} onCellClick - Callback(impact, difficulty)
       */
      function renderMoneyPagesMatrix(moneyPages, container, onCellClick, activeFilter = null) {
        if (!moneyPages || !moneyPages.length) {
          container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b;">No money pages data available.</div>';
          return;
        }
        
        const impacts = ["HIGH", "MEDIUM", "LOW"];
        const diffs = ["LOW", "MEDIUM", "HIGH"];

        const totalClicks = moneyPages.reduce((sum, p) => sum + (p.clicks || 0), 0) || 1;

        let html = `
          <div class="matrix-header" style="margin-bottom: 1rem;">
            <div class="axis-label impact" style="text-align: center; font-weight: 600; margin-bottom: 0.5rem;">Impact </div>
            <div class="matrix-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem;">
        `;

        for (const impact of impacts) {
          for (const diff of diffs) {
            const cellPages = moneyPages.filter(
              p => p.impactLevel === impact && p.difficultyLevel === diff
            );
            const count = cellPages.length;
            const clickShare = cellPages.reduce((s, p) => s + (p.clicks || 0), 0) / totalClicks * 100;

            const ragClass =
              impact === "HIGH" && (diff === "LOW" || diff === "MEDIUM") ? "rag-high" :
              impact === "HIGH" && diff === "HIGH" ? "rag-medium" :
              "rag-low";
            
            // Check if this cell is active
            const isActive = activeFilter && activeFilter.impact === impact && activeFilter.diff === diff;
            
            // Active state styling: thicker border, darker background
            const borderColor = isActive 
              ? '#2563eb' 
              : (ragClass === 'rag-high' ? '#10b981' : ragClass === 'rag-medium' ? '#f59e0b' : '#e5e7eb');
            const borderWidth = isActive ? '4px' : '2px';
            const backgroundColor = isActive
              ? '#dbeafe'
              : (ragClass === 'rag-high' ? '#ecfdf5' : ragClass === 'rag-medium' ? '#fffbeb' : '#f9fafb');

            html += `
              <button
                class="matrix-cell ${ragClass} ${isActive ? 'active' : ''}"
                data-impact="${impact}"
                data-diff="${diff}"
                type="button"
                style="padding: 1rem; border: ${borderWidth} solid ${borderColor}; border-radius: 8px; background: ${backgroundColor}; cursor: pointer; text-align: center; transition: all 0.2s; box-shadow: ${isActive ? '0 4px 8px rgba(37, 99, 235, 0.3)' : 'none'};"
                onmouseover="this.style.transform='scale(1.05)'"
                onmouseout="this.style.transform='scale(1)'"
              >
                <div class="cell-title" style="font-weight: 600; font-size: 0.75rem; margin-bottom: 0.5rem; color: #1e293b;">${impact} / ${diff}</div>
                <div class="cell-count" style="font-size: 1.25rem; font-weight: 700; color: #1e293b; margin-bottom: 0.25rem;">${count}</div>
                <div class="cell-share" style="font-size: 0.75rem; color: #64748b;">${clickShare.toFixed(1)}% of clicks</div>
              </button>
            `;
          }
        }

        html += `
            </div>
            <div class="axis-label difficulty" style="text-align: center; font-weight: 600; margin-top: 0.5rem;">Difficulty </div>
          </div>
          <p class="matrix-legend" style="font-size: 0.75rem; color: #64748b; margin-top: 1rem; line-height: 1.5;">
            Click a cell to filter the money page action list.
            Impact is based on lost clicks (expected CTR  actual). Difficulty is based on rank and schema effort.
          </p>
        `;

        container.innerHTML = html;

        container.querySelectorAll(".matrix-cell").forEach(btn => {
          btn.addEventListener("click", () => {
            const impact = /** @type {ImpactLevel} */ (btn.getAttribute("data-impact"));
            const diff = /** @type {DifficultyLevel} */ (btn.getAttribute("data-diff"));
            if (onCellClick) onCellClick(impact, diff);
          });
        });
      }
      
      // Make functions globally available
      window.renderMoneyPagesMatrix = renderMoneyPagesMatrix;
      window.renderMoneyPagesTable = renderMoneyPagesTable;
      window.renderMoneyPagesCategoryChart = renderMoneyPagesCategoryChart;
      window.updateMoneyPagesSummaryMetrics = updateMoneyPagesSummaryMetrics;
      
      /**
       * Render Money Pages Priority Table
       * @param {Array<MoneyPageMetrics>} moneyPages
       * @param {Object} filters - { typeFilter, minImpr, matrixFilter: {impact, diff} }
       */
      /**
       * Sort money pages table rows
       * @param {Array<MoneyPageMetrics>} rows
       * @param {string} column - Column to sort by
       * @param {string} direction - 'asc' or 'desc'
       */
      function sortMoneyPagesRows(rows, column, direction) {
        const priorityRank = { HIGH: 0, MEDIUM: 1, LOW: 2 };
        const impactRank = { HIGH: 0, MEDIUM: 1, LOW: 2 };
        const difficultyRank = { HIGH: 0, MEDIUM: 1, LOW: 2 };
        
        const sorted = rows.slice().sort((a, b) => {
          let comparison = 0;
          
          switch (column) {
            case 'page':
              comparison = (a.title || a.url || '').localeCompare(b.title || b.url || '');
              break;
            case 'type':
              const typeA = a.segmentType === "landing" ? "Landing" : a.segmentType === "event" ? "Event" : a.segmentType === "product" ? "Product" : "Money";
              const typeB = b.segmentType === "landing" ? "Landing" : b.segmentType === "event" ? "Event" : b.segmentType === "product" ? "Product" : "Money";
              comparison = typeA.localeCompare(typeB);
              break;
            case 'priority':
              const pa = priorityRank[a.priorityLevel] ?? 99;
              const pb = priorityRank[b.priorityLevel] ?? 99;
              comparison = pa - pb;
              break;
            case 'impact':
              const ia = impactRank[a.impactLevel] ?? 99;
              const ib = impactRank[b.impactLevel] ?? 99;
              comparison = ia - ib;
              break;
            case 'difficulty':
              const da = difficultyRank[a.difficultyLevel] ?? 99;
              const db = difficultyRank[b.difficultyLevel] ?? 99;
              comparison = da - db;
              break;
            case 'ctr':
              comparison = (a.ctr || 0) - (b.ctr || 0);
              break;
            case 'impressions':
              comparison = (a.impressions || 0) - (b.impressions || 0);
              break;
            case 'avgPosition':
              comparison = (a.avgPosition || 999) - (b.avgPosition || 999);
              break;
            case 'action':
              const actionA = (a.priorityLevel || "LOW") === "HIGH" ? "Fix CTR & strengthen content" : (a.priorityLevel || "LOW") === "MEDIUM" ? "Improve SERP snippet & schema" : "Monitor & maintain";
              const actionB = (b.priorityLevel || "LOW") === "HIGH" ? "Fix CTR & strengthen content" : (b.priorityLevel || "LOW") === "MEDIUM" ? "Improve SERP snippet & schema" : "Monitor & maintain";
              comparison = actionA.localeCompare(actionB);
              break;
            default:
              // Default: priority then lost clicks
              const paDefault = priorityRank[a.priorityLevel] ?? 99;
              const pbDefault = priorityRank[b.priorityLevel] ?? 99;
              if (paDefault !== pbDefault) {
                comparison = paDefault - pbDefault;
              } else {
                comparison = (b._lostClicks || 0) - (a._lostClicks || 0);
              }
          }
          
          return direction === 'asc' ? comparison : -comparison;
        });
        
        return sorted;
      }
      
      // Initialize pagination state for Money Pages Priority table
      if (window.moneyPagesPriorityCurrentPage === undefined) {
        window.moneyPagesPriorityCurrentPage = 1;
      }
      if (window.moneyPagesPriorityRowsPerPage === undefined) {
        window.moneyPagesPriorityRowsPerPage = 10;
      }

      async function renderMoneyPagesPriorityTable(moneyPages, filters = {}) {
        const tbody = document.querySelector("#money-pages-priority-table tbody");
        const thead = document.querySelector("#money-pages-priority-table thead");
        if (!tbody || !thead) {
          debugLog(' renderMoneyPagesPriorityTable: Table elements not found, table may not be rendered yet', 'warn');
          // Return empty string instead of undefined to prevent error message
          return '';
        }

        // Use window.moneyPagePriorityData if moneyPages is not provided or empty
        const sourcePages = (moneyPages && moneyPages.length > 0) ? moneyPages : (window.moneyPagePriorityData || []);
        if (!sourcePages || sourcePages.length === 0) {
          debugLog(' renderMoneyPagesPriorityTable: No money pages data available', 'warn');
          tbody.innerHTML = '<tr><td colspan="11" style="padding: 2rem; text-align: center; color: #64748b;">No money pages data available. Run an audit to generate priority matrix data.</td></tr>';
          // Clear pagination if no data
          const paginationContainer = document.getElementById('money-pages-priority-pagination');
          if (paginationContainer) {
            paginationContainer.innerHTML = '';
          }
          return '';
        }

        const typeFilter = filters.typeFilter || "all";
        const minImpr = filters.minImpr || 0;
        const matrixFilter = filters.matrixFilter || null;

        let rows = sourcePages.slice();

        // Min impressions filter should not hide domain-level authority actions.
        rows = rows.filter(p => p.segmentType === 'authority' || (p.impressions || 0) >= minImpr);

        if (typeFilter !== "all") {
          rows = rows.filter(p => p.segmentType === typeFilter);
        }

        // Matrix filter is only meaningful for money page rows; exclude authority rows unless explicitly filtering for them.
        if (matrixFilter && typeFilter !== "authority") {
          rows = rows.filter(
            p =>
              p.segmentType !== 'authority' &&
              p.impactLevel === matrixFilter.impact &&
              p.difficultyLevel === matrixFilter.diff
          );
        }

        // Apply sorting
        rows = sortMoneyPagesRows(rows, moneyPagesTableSort.column, moneyPagesTableSort.direction);
        
        // Store filtered rows for pagination and copy button
        window.moneyPagesPriorityFilteredRows = rows;
        
        // Update dropdown counts - use base data (after min impressions, before type filter)
        // Get base data for counting
        const base = window.moneyPagePriorityData || [];
        const authority = window.authorityActionRows || [];
        const allRows = base.concat(authority);
        // Apply min impressions filter for counting (but not type filter)
        const pagesForCounting = allRows.filter(p => p.segmentType === 'authority' || (p.impressions || 0) >= minImpr);
        updateMoneyPagesTypeFilterCounts(pagesForCounting);
        
        // Pagination logic
        const rowsPerPage = window.moneyPagesPriorityRowsPerPage || 10;
        const totalRows = rows.length;
        const totalPages = Math.max(1, Math.ceil(totalRows / rowsPerPage));
        let currentPage = window.moneyPagesPriorityCurrentPage || 1;
        
        // Ensure currentPage is within valid range
        if (currentPage > totalPages) {
          currentPage = totalPages;
          window.moneyPagesPriorityCurrentPage = currentPage;
        }
        if (currentPage < 1) {
          currentPage = 1;
          window.moneyPagesPriorityCurrentPage = currentPage;
        }
        
        // Slice rows for current page
        const startIndex = (currentPage - 1) * rowsPerPage;
        const endIndex = startIndex + rowsPerPage;
        const pageRows = rows.slice(startIndex, endIndex);
        
        // CRITICAL: DO NOT fetch statuses here - the caller should fetch before calling renderMoneyPagesPriorityTable
        // Fetching here causes the cache to be cleared every time the table renders, losing status information
        // Instead, we rely on the cache that was populated by the caller
        const allSourcePages = sourcePages || [];
        console.log('[Money Pages Priority] Rendering table using existing cache:', {
          cacheSize: window.optimisationStatusCache?.size || 0,
          sourcePagesCount: allSourcePages.length,
          filteredRowsCount: rows.length
        });
        
        // Render sortable header with Ranking & AI styling
        const sortClass = (col) => {
          if (moneyPagesTableSort.column === col) {
            return moneyPagesTableSort.direction === 'asc' ? 'sort-asc' : 'sort-desc';
          }
          return '';
        };
        
        thead.innerHTML = `
          <tr style="background: #f1f5f9;">
            <th data-sort="page" class="sortable ${sortClass('page')}" style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="The URL or page title of the money page. Click to open in a new tab.">
              <div>Keyword or Page <span class="sort-indicator"></span></div>
              <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="The URL or page title of the money page. Click to open in a new tab."></div>
            </th>
            <th data-sort="type" class="sortable ${sortClass('type')}" style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Segment type: Landing (collection/category pages), Event (workshop/event listings), or Product (service/product offerings).">
              <div>Type <span class="sort-indicator"></span></div>
              <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Segment type: Landing (collection/category pages), Event (workshop/event listings), or Product (service/product offerings)."></div>
            </th>
            <th data-sort="priority" class="sortable ${sortClass('priority')}" style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Priority level (HIGH/MEDIUM/LOW) based on impact and difficulty. HIGH priority = high impact + low/medium difficulty. Click column header to sort.">
              <div>Priority <span class="sort-indicator"></span></div>
              <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Priority level (HIGH/MEDIUM/LOW) based on impact and difficulty. HIGH priority = high impact + low/medium difficulty. Click column header to sort."></div>
            </th>
            <th data-sort="impact" class="sortable ${sortClass('impact')}" style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Impact level based on lost clicks (expected CTR minus actual CTR). HIGH = significant opportunity to improve clicks. Click column header to sort.">
              <div>Impact <span class="sort-indicator"></span></div>
              <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Impact level based on lost clicks (expected CTR minus actual CTR). HIGH = significant opportunity to improve clicks. Click column header to sort."></div>
            </th>
            <th data-sort="difficulty" class="sortable ${sortClass('difficulty')}" style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Difficulty level based on current ranking position and schema effort required. LOW = easy to improve, HIGH = requires more work. Click column header to sort.">
              <div>Difficulty <span class="sort-indicator"></span></div>
              <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Difficulty level based on current ranking position and schema effort required. LOW = easy to improve, HIGH = requires more work. Click column header to sort."></div>
            </th>
            <th data-sort="ctr" class="sortable ${sortClass('ctr')}" style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;" title="Click-through rate: percentage of impressions that resulted in clicks. Higher is better. Click column header to sort.">
              <div style="text-align: right;">CTR <span class="sort-indicator"></span></div>
              <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Click-through rate: percentage of impressions that resulted in clicks. Higher is better. Click column header to sort."></div>
            </th>
            <th data-sort="impressions" class="sortable ${sortClass('impressions')}" style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;" title="Total impressions: number of times this page appeared in search results. Click column header to sort.">
              <div style="text-align: right;">Impr. <span class="sort-indicator"></span></div>
              <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Total impressions: number of times this page appeared in search results. Click column header to sort."></div>
            </th>
            <th data-sort="avgPosition" class="sortable ${sortClass('avgPosition')}" style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;" title="Average position: average ranking position in search results (1 = best, lower numbers are better). Click column header to sort.">
              <div style="text-align: right;">Avg pos. <span class="sort-indicator"></span></div>
              <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Average position: average ranking position in search results (1 = best, lower numbers are better). Click column header to sort."></div>
            </th>
            <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;" title="AI citations (unique keywords that cite this URL in AI Overview). Latest audit only.">
              <div style="text-align: right;">AI citations</div>
              <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="AI citations (unique keywords that cite this URL in AI Overview). Latest audit only; fetched on demand."></div>
            </th>
            <th data-sort="action" class="sortable ${sortClass('action')}" style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Recommended action based on priority level. HIGH = Fix CTR & strengthen content, MEDIUM = Improve SERP snippet & schema, LOW = Monitor & maintain.">
              <div>Action <span class="sort-indicator"></span></div>
              <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Recommended action based on priority level. HIGH = Fix CTR & strengthen content, MEDIUM = Improve SERP snippet & schema, LOW = Monitor & maintain."></div>
            </th>
            <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Optimisation tracking status for this page. Shows whether optimisation work is planned, in progress, being monitored, or completed.">
              <div>Optimisation</div>
              <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Optimisation tracking status for this page. Shows whether optimisation work is planned, in progress, being monitored, or completed."></div>
            </th>
          </tr>
        `;
        
        // Add click handlers to header cells
        thead.querySelectorAll('th[data-sort]').forEach(th => {
          th.addEventListener('click', () => {
            const col = th.getAttribute('data-sort');
            if (moneyPagesTableSort.column === col) {
              moneyPagesTableSort.direction = moneyPagesTableSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
              moneyPagesTableSort.column = col;
              moneyPagesTableSort.direction = 'asc';
            }
            // Reset to page 1 when sorting changes
            window.moneyPagesPriorityCurrentPage = 1;
            (async () => {
              await renderMoneyPagesPriorityTable(moneyPages, filters);
            })();
          });
          
          th.addEventListener('mouseenter', () => {
            th.style.backgroundColor = '#e2e8f0';
          });
          th.addEventListener('mouseleave', () => {
            th.style.backgroundColor = '';
          });
        });

        tbody.innerHTML = pageRows
          .map(p => {
            // Safety checks for undefined values
            const priorityLevel = p.priorityLevel || "LOW";
            const impactLevel = p.impactLevel || "LOW";
            const difficultyLevel = p.difficultyLevel || "MEDIUM";
            const isAuthorityAction = p.segmentType === "authority";
            
            const typeLabel =
              isAuthorityAction ? "Authority" :
              p.segmentType === "landing" ? "Landing" :
              p.segmentType === "event" ? "Event" :
              p.segmentType === "product" ? "Product" :
              "Money";

            const action =
              isAuthorityAction ? "Authority building" :
              priorityLevel === "HIGH"
                ? "Fix CTR & strengthen content"
                : priorityLevel === "MEDIUM"
                ? "Improve SERP snippet & schema"
                : "Monitor & maintain";
            
            const priorityColor = priorityLevel === "HIGH" ? "#ef4444" : priorityLevel === "MEDIUM" ? "#f59e0b" : "#64748b";
            const priorityBg = priorityLevel === "HIGH" ? "#fee2e2" : priorityLevel === "MEDIUM" ? "#fef3c7" : "#f1f5f9";
            const priorityBorder = priorityLevel === "HIGH" ? "#ef4444" : priorityLevel === "MEDIUM" ? "#f59e0b" : "#94a3b8";

            const authMeta = isAuthorityAction ? (p._authorityMeta || null) : null;
            const authScore = authMeta && typeof authMeta.score === 'number' ? authMeta.score : null;
            const authBand = authMeta && typeof authMeta.band === 'string' ? authMeta.band : null;
            const authSegment = authMeta && typeof authMeta.segment === 'string' ? authMeta.segment : null;
            const domainStrengthLine =
              isAuthorityAction
                ? `Domain strength: ${authScore != null ? authScore.toFixed(1) : ''}${authBand ? ` (${authBand})` : ''}`
                : null;

            // Get optimisation status for this page
            const taskType = 'on_page';
            const optimisationStatus = window.getOptimisationStatus ? window.getOptimisationStatus({ targetUrl: p.url, keyword: '' }, taskType) : null;
            const hasTask = optimisationStatus && optimisationStatus.status && optimisationStatus.status !== 'deleted';
            
            // Debug logging for landscape page
            if (p.url && p.url.includes('landscape-photography-workshops')) {
              const urlKey = window.cleanUrlForKey ? window.cleanUrlForKey(p.url) : p.url.toLowerCase().trim();
              const expectedKey = `::${urlKey}::${taskType}`;
              const cacheValue = window.optimisationStatusCache?.get(expectedKey);
              debugLog(`[Money Pages Priority] Landscape page status lookup: url="${p.url}", urlKey="${urlKey}", expectedKey="${expectedKey}", found=${!!optimisationStatus}, status="${optimisationStatus?.status || 'null'}", id="${optimisationStatus?.id || 'null'}", cacheSize=${window.optimisationStatusCache?.size || 0}, cacheHasKey=${window.optimisationStatusCache?.has(expectedKey)}, cachedId="${cacheValue?.id || 'null'}", cachedStatus="${cacheValue?.status || 'null'}"`, optimisationStatus ? 'success' : 'warn');
            }
            // CRITICAL: Use id field (not taskId) - API returns 'id', not 'taskId'
            const taskId = hasTask ? (optimisationStatus.id || optimisationStatus.task_id || null) : null;
            const statusText = hasTask ? (optimisationStatus.status || 'planned') : null;
            
            // Debug: Log status lookup for troubleshooting
            if (p.url && p.url.includes('landscape-photography-workshops')) {
              console.log('[Money Pages Priority] Status lookup for landscape page:', {
                url: p.url,
                hasStatus: !!optimisationStatus,
                hasId: optimisationStatus ? ('id' in optimisationStatus) : false,
                hasTaskId: optimisationStatus ? ('task_id' in optimisationStatus) : false,
                id: optimisationStatus?.id,
                task_id: optimisationStatus?.task_id,
                extractedTaskId: taskId,
                status: optimisationStatus?.status,
                statusObject: optimisationStatus ? {
                  id: optimisationStatus.id,
                  task_id: optimisationStatus.task_id,
                  allKeys: Object.keys(optimisationStatus).slice(0, 15)
                } : null
              });
              
              // Also log the onclick handler that will be generated
              if (taskId) {
                const taskIdEscaped = String(taskId).replace(/'/g, "\\'").replace(/"/g, '&quot;');
                const onclickHandler = `window.openOptimisationTaskDrawer('${taskIdEscaped}')`;
                console.log('[Money Pages Priority] Generated onclick handler:', {
                  taskId: taskId,
                  taskIdEscaped: taskIdEscaped,
                  onclickHandler: onclickHandler
                });
              }
            }
            
            // Validate taskId exists before rendering Manage button
            if (hasTask && !taskId) {
              console.error('[Money Pages Priority] Task exists but missing id field:', {
                url: p.url,
                optimisationStatus,
                statusKeys: optimisationStatus ? Object.keys(optimisationStatus) : []
              });
            }
            
            // Build optimisation column HTML
            let optimisationHtml = '';
            if (!hasTask || statusText === 'done' || statusText === 'cancelled') {
              // Not tracked or done/cancelled - show Track button
              const statusLabel = !hasTask ? 'Not tracked' : (statusText === 'done' ? 'Done' : 'Cancelled');
              optimisationHtml = `
                <td style="padding: 0.75rem;" data-page-url="${p.url}" data-page-title="${p.title || p.url || 'Untitled'}">
                  <span class="ranking-badge ranking-badge--segment-general" style="margin-right: 0.5rem; display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; background: #f1f5f9; color: #64748b; font-size: 0.75rem; font-weight: 600;">${statusLabel}</span>
                  <button onclick="window.trackMoneyPage('${p.url.replace(/'/g, "\\'")}', '${(p.title || p.url || 'Untitled').replace(/'/g, "\\'")}')" style="padding: 0.15rem 0.4rem; font-size: 0.75rem; font-weight: 550; background: #2563eb; color: #ffffff; border: 1px solid #1e40af; border-radius: 4px; cursor: pointer;" title="Create optimisation task for ${p.url} (CTR  2.5%)">${!hasTask ? 'Track' : 'Track again'}</button>
                </td>
              `;
            } else {
              // Tracked - show status badge + Manage button
              const statusLabels = {
                'planned': 'Planned',
                'in_progress': 'In progress',
                'monitoring': 'Monitoring',
                'done': 'Done',
                'cancelled': 'Cancelled'
              };
              const statusColors = {
                'planned': '#64748b',
                'in_progress': '#2563eb',
                'monitoring': '#2563eb',
                'done': '#10b981',
                'cancelled': '#ef4444'
              };
              const statusBg = {
                'planned': '#f1f5f9',
                'in_progress': '#dbeafe',
                'monitoring': '#dbeafe',
                'done': '#ecfdf5',
                'cancelled': '#fee2e2'
              };
              const statusLabel = statusLabels[statusText] || statusText;
              const statusColor = statusColors[statusText] || '#64748b';
              const statusBgColor = statusBg[statusText] || '#f1f5f9';
              // Validate taskId before rendering Manage button
              if (!taskId) {
                console.error('[Money Pages Priority] Cannot render Manage button - taskId is missing:', {
                  url: p.url,
                  optimisationStatus
                });
                optimisationHtml = `
                  <td style="padding: 0.75rem;" data-page-url="${p.url}">
                    <span style="color: #ef4444; font-size: 0.7rem;">Error: Task ID missing</span>
                  </td>
                `;
              } else {
                // Escape taskId for use in onclick attribute
                const taskIdEscaped = String(taskId).replace(/'/g, "\\'").replace(/"/g, '&quot;');
                optimisationHtml = `
                  <td style="padding: 0.75rem;" data-page-url="${p.url}" data-task-id="${taskIdEscaped}">
                    <span class="ranking-badge ranking-badge--segment-general" style="margin-right: 0.5rem; display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; background: ${statusBgColor}; color: ${statusColor}; font-size: 0.75rem; font-weight: 600;">${statusLabel}</span>
                    <button class="btn btn-small money-pages-manage-btn" style="padding: 0.15rem 0.4rem; font-size: 0.75rem; font-weight: 550; background: #10b981; color: #ffffff; border: 1px solid #059669; border-radius: 4px; cursor: pointer;" onclick="window.openOptimisationTaskDrawer('${taskIdEscaped}')" data-task-id="${taskIdEscaped}" data-page-url="${p.url}">Manage</button>
                  </td>
                `;
              }
            }

            return `
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.75rem;">
                  <a href="${p.url || '#'}" target="_blank" rel="noopener" style="color: #2563eb; text-decoration: none;">${p.title || p.url || 'Untitled'}</a>
                  ${domainStrengthLine ? `<div style="margin-top: 0.25rem; font-size: 0.8rem; color: #64748b;">${domainStrengthLine}</div>` : ''}
                </td>
                <td style="padding: 0.75rem;">${typeLabel}${isAuthorityAction && authSegment ? `  <span style="color:#64748b;">${authSegment}</span>` : ''}</td>
                <td style="padding: 0.75rem;"><span class="badge badge-priority-${priorityLevel.toLowerCase()}" style="display: inline-block; padding: 0.35rem 0.75rem; border-radius: 6px; background: ${priorityBg}; color: ${priorityColor}; border: 1.5px solid ${priorityBorder}; font-weight: 700; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px;">${priorityLevel}</span></td>
                <td style="padding: 0.75rem;">${impactLevel}</td>
                <td style="padding: 0.75rem;">${difficultyLevel}</td>
                <td style="padding: 0.75rem; text-align: right;">${isAuthorityAction ? '' : (() => {
                  const clicks = Number(p.clicks || 0);
                  const imps = Number(p.impressions || 0);
                  if (imps > 0) return `${((clicks / imps) * 100).toFixed(1)}%`;
                  const raw = Number(p.ctr || 0);
                  const ratio = raw > 1 ? raw / 100 : raw;
                  return `${((ratio || 0) * 100).toFixed(1)}%`;
                })()}</td>
                <td style="padding: 0.75rem; text-align: right;">${isAuthorityAction ? '' : `${(p.impressions || 0).toLocaleString()}`}</td>
                <td style="padding: 0.75rem; text-align: right;">${isAuthorityAction ? '' : (p.avgPosition ? p.avgPosition.toFixed(1) : "")}</td>
                <td style="padding: 0.75rem; text-align: right;" class="ai-citation-cell" data-page-url="${p.url || ''}"></td>
                <td style="padding: 0.75rem;">${action}</td>
                ${optimisationHtml}
              </tr>
            `;
          })
          .join("");

        // Populate AI citations (latest audit) with per-URL caching
        (async () => {
          if (!window.moneyPagesAiCitationCache) {
            window.moneyPagesAiCitationCache = new Map();
          }
          // Load from localStorage if available to prime cache
          try {
            const stored = localStorage.getItem('moneyPagesAiCitationCache');
            if (stored) {
              const parsed = JSON.parse(stored);
              if (parsed && typeof parsed === 'object') {
                Object.entries(parsed).forEach(([k,v]) => {
                  window.moneyPagesAiCitationCache.set(k, v);
                });
              }
            }
          } catch (e) {
            debugLog(`[Money Pages] Failed to load cached citations: ${e.message}`, 'warn');
          }

          const propertyUrl =
            document.getElementById('propertyUrl')?.value ||
            localStorage.getItem('gsc_property_url') ||
            localStorage.getItem('last_property_url') ||
            'https://www.alanranger.com';

          const renderCitation = (cell, count, keywords, errorText = null) => {
            cell.textContent = typeof count === 'number' ? count.toString() : '';
            if (keywords && keywords.length) {
              cell.title = `Keywords citing this URL: ${keywords.join(', ')}`;
            } else if (errorText) {
              cell.title = errorText;
            }
            // Write back to underlying row for sorting
            const url = cell.getAttribute('data-page-url');
            if (url && window.moneyPagesData) {
              const match = window.moneyPagesData.find(r => (r.url || '').toLowerCase() === url.toLowerCase());
              if (match) {
                match._aiCitations = typeof count === 'number' ? count : null;
              }
            }
          };

          const cells = tbody.querySelectorAll('.ai-citation-cell');
          cells.forEach(cell => {
            const url = cell.getAttribute('data-page-url');
            if (!url) {
              cell.textContent = '';
              return;
            }
            const cacheKey = url.toLowerCase();
            if (window.moneyPagesAiCitationCache.has(cacheKey)) {
              const cached = window.moneyPagesAiCitationCache.get(cacheKey);
              renderCitation(cell, cached.count, cached.keywords);
              return;
            }

            cell.textContent = '';
            const endpoint = apiUrl(
              `/api/supabase/query-keywords-citing-url?property_url=${encodeURIComponent(propertyUrl)}&target_url=${encodeURIComponent(url)}`
            );

            fetch(endpoint)
              .then(async res => {
                if (!res.ok) {
                  const txt = await res.text().catch(() => 'error');
                  throw new Error(`HTTP ${res.status}: ${txt}`);
                }
                return res.json();
              })
              .then(data => {
                const keywords = Array.isArray(data?.data) ? data.data.map(k => k.keyword).filter(Boolean) : [];
                const count = typeof data?.count === 'number' ? data.count : keywords.length;
                window.moneyPagesAiCitationCache.set(cacheKey, { count, keywords });
                try {
                  const obj = Object.fromEntries(window.moneyPagesAiCitationCache.entries());
                  localStorage.setItem('moneyPagesAiCitationCache', JSON.stringify(obj));
                } catch (e) {
                  debugLog(`[Money Pages] Failed to persist citations cache: ${e.message}`, 'warn');
                }
                renderCitation(cell, count, keywords);
              })
              .catch(err => {
                debugLog(`[Money Pages] AI citations fetch failed for ${url}: ${err.message}`, 'warn');
                renderCitation(cell, 0, [], err.message);
              });
          });
        })();

        // Copy URLs button - copy all filtered rows, not just current page
        const copyBtn = document.getElementById("money-pages-copy-urls-btn");
        if (copyBtn) {
          copyBtn.onclick = () => {
            const urls = rows.map(p => p.url).join("\n");
            navigator.clipboard.writeText(urls).then(() => {
              copyBtn.textContent = "Copied!";
              setTimeout(() => { copyBtn.textContent = "Copy URLs"; }, 2000);
            }).catch(() => {
              copyBtn.textContent = "Copy failed";
            });
          };
        }
        
        // Wire Track/Manage buttons after table is rendered
        // NOTE: The new renderMoneyPagesTable function uses onclick attributes directly
        // This old handler is only for legacy table rendering that uses .money-pages-track-btn class
        // If you see "Old handler detected" warnings, it means there's a button with the old class
        // that should be using onclick="window.trackMoneyPage(...)" instead
        setTimeout(() => {
          // Track buttons (legacy - should not be used in new table rendering)
          tbody.querySelectorAll('.money-pages-track-btn').forEach(btn => {
            btn.addEventListener('click', async (e) => {
              e.stopPropagation();
              e.preventDefault(); // Prevent any default behavior
              
              if (window.isShareMode) {
                alert('Write operations are not available in share mode (read-only).');
                return;
              }
              if (!window.hasAdminKey()) {
                alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
                return;
              }
              
              const pageUrl = btn.getAttribute('data-page-url');
              const pageTitle = btn.getAttribute('data-page-title');
              
              console.warn('[Money Pages]  Legacy .money-pages-track-btn handler triggered. This should not happen with new table rendering.');
              debugLog(` Legacy handler detected for ${pageUrl}, redirecting to modal`, 'warn');
              
              // Immediately redirect to the new modal path
              // Look up row data from stored map
              let rowData = null;
              if (window.moneyPagesRowDataByUrl && pageUrl) {
                const normalizedUrl = normalizeUrlForDedupe ? normalizeUrlForDedupe(pageUrl) : pageUrl.toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');
                rowData = window.moneyPagesRowDataByUrl.get(normalizedUrl);
                console.log('[Money Pages] Legacy handler: Found row data from map:', !!rowData);
              }
              
              // If row data not found, create minimal fallback
              if (!rowData) {
                rowData = {
                  url: pageUrl,
                  title: pageTitle,
                  clicks: 0,
                  impressions: 0,
                  ctr: 0,
                  avgPosition: null
                };
                console.warn('[Money Pages] Legacy handler: Row data not found, using fallback (metrics will be 0)');
              }
              
              // Use the new modal path
              if (window.openTrackMoneyPageModal) {
                window.openTrackMoneyPageModal(rowData);
              } else if (window.trackMoneyPage) {
                window.trackMoneyPage(pageUrl, pageTitle);
              } else {
                alert('Error: Modal function not found. Please refresh the page.');
              }
            });
          });
          
          // Manage buttons
          tbody.querySelectorAll('.money-pages-manage-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
              e.stopPropagation();
              const taskId = btn.getAttribute('data-task-id');
              if (!taskId) {
                alert('Task ID not found');
                return;
              }
              
              // Open task drawer
              if (window.openOptimisationTaskDrawer && typeof window.openOptimisationTaskDrawer === 'function') {
                window.openOptimisationTaskDrawer(taskId);
              } else {
                // Fallback: navigate to Optimisation Tracking
                const optimisationTab = document.querySelector('[data-panel="optimisation"]');
                if (optimisationTab) {
                  const tabBtn = document.querySelector(`button[data-tab="optimisation"]`);
                  if (tabBtn) tabBtn.click();
                  setTimeout(() => {
                    if (window.openOptimisationTaskDrawer && typeof window.openOptimisationTaskDrawer === 'function') {
                      window.openOptimisationTaskDrawer(taskId);
                    }
                  }, 500);
                }
              }
            });
          });
        }, 100);
        
        // Render pagination controls
        renderMoneyPagesPriorityPagination(totalRows, currentPage, totalPages, rowsPerPage);
        
        // Return empty string since this function manipulates DOM directly
        return '';
      }
      
      function renderMoneyPagesPriorityPagination(totalRows, currentPage, totalPages, rowsPerPage) {
        const paginationContainer = document.getElementById('money-pages-priority-pagination');
        if (!paginationContainer) {
          debugLog(' Pagination container not found', 'warn');
          return;
        }
        
        if (totalRows === 0) {
          paginationContainer.innerHTML = '';
          return;
        }
        
        const startRow = totalRows === 0 ? 0 : (currentPage - 1) * rowsPerPage + 1;
        const endRow = Math.min(currentPage * rowsPerPage, totalRows);
        
        paginationContainer.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e5e7eb; flex-wrap: wrap; gap: 1rem;">
            <div style="font-size: 0.875rem; color: #374151;">
              Showing ${startRow}-${endRow} of ${totalRows.toLocaleString()}
            </div>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
              <button 
                id="money-pages-priority-pagination-first" 
                type="button" 
                style="padding: 0.5rem 1rem; border: 1px solid #d1d5db; border-radius: 6px; background: #ffffff; cursor: pointer; color: #374151; font-size: 0.875rem;"
                ${currentPage === 1 ? 'disabled' : ''}
              >First</button>
              <button 
                id="money-pages-priority-pagination-prev" 
                type="button" 
                style="padding: 0.5rem 1rem; border: 1px solid #d1d5db; border-radius: 6px; background: #ffffff; cursor: pointer; color: #374151; font-size: 0.875rem;"
                ${currentPage === 1 ? 'disabled' : ''}
              >Previous</button>
              <span style="padding: 0 0.5rem; font-size: 0.875rem; color: #374151;">Page ${currentPage} of ${totalPages}</span>
              <button 
                id="money-pages-priority-pagination-next" 
                type="button" 
                style="padding: 0.5rem 1rem; border: 1px solid #d1d5db; border-radius: 6px; background: #ffffff; cursor: pointer; color: #374151; font-size: 0.875rem;"
                ${currentPage === totalPages ? 'disabled' : ''}
              >Next</button>
              <button 
                id="money-pages-priority-pagination-last" 
                type="button" 
                style="padding: 0.5rem 1rem; border: 1px solid #d1d5db; border-radius: 6px; background: #ffffff; cursor: pointer; color: #374151; font-size: 0.875rem;"
                ${currentPage === totalPages ? 'disabled' : ''}
              >Last</button>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <label style="font-size: 0.875rem; color: #374151; white-space: nowrap;">Rows per page:</label>
              <select 
                id="money-pages-priority-rows-per-page" 
                style="padding: 0.5rem 0.75rem; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.875rem; background: #ffffff; cursor: pointer;"
              >
                <option value="10" ${rowsPerPage === 10 ? 'selected' : ''}>10</option>
                <option value="25" ${rowsPerPage === 25 ? 'selected' : ''}>25</option>
                <option value="50" ${rowsPerPage === 50 ? 'selected' : ''}>50</option>
                <option value="100" ${rowsPerPage === 100 ? 'selected' : ''}>100</option>
                <option value="200" ${rowsPerPage === 200 ? 'selected' : ''}>200</option>
              </select>
            </div>
          </div>
        `;
        
        // Wire up pagination buttons
        const firstBtn = document.getElementById('money-pages-priority-pagination-first');
        const prevBtn = document.getElementById('money-pages-priority-pagination-prev');
        const nextBtn = document.getElementById('money-pages-priority-pagination-next');
        const lastBtn = document.getElementById('money-pages-priority-pagination-last');
        const rowsPerPageSelect = document.getElementById('money-pages-priority-rows-per-page');
        
        if (firstBtn) {
          firstBtn.addEventListener('click', () => {
            window.moneyPagesPriorityCurrentPage = 1;
            const filters = {
              typeFilter: window.moneyPagesTypeFilter || 'all',
              minImpr: window.moneyPagesMinImpr || 0,
              matrixFilter: window.moneyPagesMatrixFilter || null
            };
            (async () => {
              await renderMoneyPagesPriorityTable(null, filters);
            })();
          });
        }
        
        if (prevBtn) {
          prevBtn.addEventListener('click', () => {
            if (window.moneyPagesPriorityCurrentPage > 1) {
              window.moneyPagesPriorityCurrentPage--;
              const filters = {
                typeFilter: window.moneyPagesTypeFilter || 'all',
                minImpr: window.moneyPagesMinImpr || 0,
                matrixFilter: window.moneyPagesMatrixFilter || null
              };
              (async () => {
              await renderMoneyPagesPriorityTable(null, filters);
            })();
            }
          });
        }
        
        if (nextBtn) {
          nextBtn.addEventListener('click', () => {
            const totalRows = window.moneyPagesPriorityFilteredRows?.length || 0;
            const rowsPerPage = window.moneyPagesPriorityRowsPerPage || 10;
            const totalPages = Math.max(1, Math.ceil(totalRows / rowsPerPage));
            if (window.moneyPagesPriorityCurrentPage < totalPages) {
              window.moneyPagesPriorityCurrentPage++;
              const filters = {
                typeFilter: window.moneyPagesTypeFilter || 'all',
                minImpr: window.moneyPagesMinImpr || 0,
                matrixFilter: window.moneyPagesMatrixFilter || null
              };
              (async () => {
              await renderMoneyPagesPriorityTable(null, filters);
            })();
            }
          });
        }
        
        if (lastBtn) {
          lastBtn.addEventListener('click', () => {
            const totalRows = window.moneyPagesPriorityFilteredRows?.length || 0;
            const rowsPerPage = window.moneyPagesPriorityRowsPerPage || 10;
            const totalPages = Math.max(1, Math.ceil(totalRows / rowsPerPage));
            window.moneyPagesPriorityCurrentPage = totalPages;
            const filters = {
              typeFilter: window.moneyPagesTypeFilter || 'all',
              minImpr: window.moneyPagesMinImpr || 0,
              matrixFilter: window.moneyPagesMatrixFilter || null
            };
            (async () => {
              await renderMoneyPagesPriorityTable(null, filters);
            })();
          });
        }
        
        if (rowsPerPageSelect) {
          rowsPerPageSelect.addEventListener('change', (e) => {
            const newRowsPerPage = parseInt(e.target.value, 10);
            window.moneyPagesPriorityRowsPerPage = newRowsPerPage;
            window.moneyPagesPriorityCurrentPage = 1; // Reset to first page
            const filters = {
              typeFilter: window.moneyPagesTypeFilter || 'all',
              minImpr: window.moneyPagesMinImpr || 0,
              matrixFilter: window.moneyPagesMatrixFilter || null
            };
            (async () => {
              await renderMoneyPagesPriorityTable(null, filters);
            })();
          });
        }
      }
      
      // Make Priority table renderer globally available (avoid clobbering Opportunity table renderer)
      window.renderMoneyPagesPriorityTable = renderMoneyPagesPriorityTable;
      
      function applyMoneyPagesTopLevelSubSegmentFilter(value) {
        const subSeg = value || 'ALL';
        debugLog(` Top-level filter changed to: ${subSeg}`, 'info');
        window.moneyPagesSubSegmentFilter = subSeg;

        // Keep table filter in sync (if present)
        const tableSubSegFilter = document.getElementById('money-pages-filter-subsegment');
        if (tableSubSegFilter && tableSubSegFilter.value !== subSeg) {
          tableSubSegFilter.value = subSeg;
        }

        const moneyPagesMetrics = window.currentMoneyPagesMetrics || window.moneyPagesMetrics;
        if (!moneyPagesMetrics) {
          debugLog(' Top-level filter: No moneyPagesMetrics available', 'warn');
          return;
        }

        if (typeof updateMoneyPagesSummaryMetrics === 'function') {
          updateMoneyPagesSummaryMetrics(moneyPagesMetrics);
        }

        const filteredMetrics = typeof getFilteredMoneyPagesMetrics === 'function'
          ? getFilteredMoneyPagesMetrics(moneyPagesMetrics)
          : null;
        const filteredRows = filteredMetrics?.rows || [];
        const queryPages = window.currentQueryPages || null;

        // Update dropdown counts (both table and top-level filters)
        updateMoneyPagesSubSegmentCounts(moneyPagesMetrics);
        
        // Also update top-level filter dropdown counts
        const topLevelFilterEl = document.getElementById('money-top-level-filter-subsegment');
        if (topLevelFilterEl && moneyPagesMetrics && moneyPagesMetrics.rows) {
          const rows = moneyPagesMetrics.rows || [];
          const counts = {
            ALL: rows.length,
            PRODUCT: 0,
            EVENT: 0,
            LANDING: 0
          };
          
          rows.forEach(row => {
            const subSegment = row.subSegment || row.segmentType || 'LANDING';
            if (subSegment === 'PRODUCT' || subSegment === 'product') {
              counts.PRODUCT++;
            } else if (subSegment === 'EVENT' || subSegment === 'event') {
              counts.EVENT++;
            } else if (subSegment === 'LANDING' || subSegment === 'landing') {
              counts.LANDING++;
            }
          });
          
          // Update top-level filter options
          const options = topLevelFilterEl.querySelectorAll('option');
          options.forEach(opt => {
            const value = opt.value;
            if (value === 'ALL') {
              opt.textContent = `All sub-segments (${counts.ALL})`;
            } else if (value === 'PRODUCT') {
              opt.textContent = `Product Pages (${counts.PRODUCT})`;
            } else if (value === 'EVENT') {
              opt.textContent = `Event Pages (${counts.EVENT})`;
            } else if (value === 'LANDING') {
              opt.textContent = `Landing Pages (${counts.LANDING})`;
            }
          });
        }

        if (typeof renderMoneyPagesBehaviourKpis === 'function') {
          const behaviour = (queryPages && typeof window.computeMoneyPagesBehaviour === 'function')
            ? window.computeMoneyPagesBehaviour(queryPages, filteredRows, true)
            : null;
          renderMoneyPagesBehaviourKpis(behaviour, filteredMetrics || moneyPagesMetrics, queryPages);
        }

        if (typeof updateMoneyPagesChartSummary === 'function' && filteredMetrics) {
          updateMoneyPagesChartSummary(filteredMetrics);
        }

        if (typeof renderMoneyPagesCategoryChart === 'function') {
          renderMoneyPagesCategoryChart(moneyPagesMetrics, 0);
        }

        // Re-render Performance Trends to reflect the selected sub-segment (ALL/LANDING/EVENT/PRODUCT).
        // Uses cached timeseries loaded by the KPI tracker.
        if (typeof window.renderMoneyPagesTrendChart === 'function') {
          const ts = window.__moneyPagesTimeseriesCache;
          if (Array.isArray(ts) && ts.length > 0) {
            window.renderMoneyPagesTrendChart([], ts);
          }
        }

        // Re-render Suggested Top 10 to reflect the selected sub-segment.
        if (typeof window.renderMoneyPagesSuggestedTop10 === 'function') {
          window.renderMoneyPagesSuggestedTop10();
        }
      }

      // Wire up top-level filter (independent of table section)
      function wireTopLevelFilter(retryCount = 0) {
        setTimeout(() => {
          const topLevelFilterEl = document.getElementById('money-top-level-filter-subsegment');
          
          if (!topLevelFilterEl) {
            debugLog(` Top-level filter not found (may not be rendered yet) (attempt ${retryCount + 1})`, 'warn');
            if (retryCount < 10) {
              setTimeout(() => wireTopLevelFilter(retryCount + 1), 200);
            }
            return;
          }
          
          // Remove existing listener by cloning
          const newFilter = topLevelFilterEl.cloneNode(true);
          topLevelFilterEl.parentNode.replaceChild(newFilter, topLevelFilterEl);
          
          // Initialize to match global state
          const currentSubSeg = window.moneyPagesSubSegmentFilter || 'ALL';
          newFilter.value = currentSubSeg;
          
          // Update counts when first wiring up
          const moneyPagesMetrics = window.currentMoneyPagesMetrics || window.moneyPagesMetrics;
          if (moneyPagesMetrics && moneyPagesMetrics.rows) {
            const rows = moneyPagesMetrics.rows || [];
            const counts = {
              ALL: rows.length,
              PRODUCT: 0,
              EVENT: 0,
              LANDING: 0
            };
            
            rows.forEach(row => {
              const subSegment = row.subSegment || row.segmentType || 'LANDING';
              if (subSegment === 'PRODUCT' || subSegment === 'product') {
                counts.PRODUCT++;
              } else if (subSegment === 'EVENT' || subSegment === 'event') {
                counts.EVENT++;
              } else if (subSegment === 'LANDING' || subSegment === 'landing') {
                counts.LANDING++;
              }
            });
            
            // Update top-level filter options with counts
            const options = newFilter.querySelectorAll('option');
            options.forEach(opt => {
              const value = opt.value;
              if (value === 'ALL') {
                opt.textContent = `All sub-segments (${counts.ALL})`;
              } else if (value === 'PRODUCT') {
                opt.textContent = `Product Pages (${counts.PRODUCT})`;
              } else if (value === 'EVENT') {
                opt.textContent = `Event Pages (${counts.EVENT})`;
              } else if (value === 'LANDING') {
                opt.textContent = `Landing Pages (${counts.LANDING})`;
              }
            });
          }
          
          debugLog(` Top-level filter found and initialized to: ${currentSubSeg}`, 'success');
          
          // When top-level filter changes, update all sections
          newFilter.addEventListener('change', () => applyMoneyPagesTopLevelSubSegmentFilter(newFilter.value));
          
          // CRITICAL: Apply the current filter once on initial wire-up so Behaviour KPIs / summary
          // don't stay as placeholder "" until the user changes the dropdown.
          if (typeof applyMoneyPagesTopLevelSubSegmentFilter === 'function') {
            applyMoneyPagesTopLevelSubSegmentFilter(currentSubSeg);
          }
          
          debugLog(' Top-level filter wired up successfully', 'success');
        }, 200);
      }
      
      // Make function globally available
      window.wireTopLevelFilter = wireTopLevelFilter;

      // Suggested (Top 10) cards renderer
      // Renders from `window.moneyPagePriorityData` (built during score calculation / loaded from Supabase).
      window.renderMoneyPagesSuggestedTop10 = function renderMoneyPagesSuggestedTop10() {
        const container = document.getElementById('money-pages-suggested-top10-container');
        if (!container) return;

        // Source of truth for Suggested: align to Opportunity table's CURRENT filtered rows.
        const tableRows = Array.isArray(window.moneyPagesOpportunityFilteredRows) ? window.moneyPagesOpportunityFilteredRows : [];
        const priorityRows = Array.isArray(window.moneyPagePriorityData) ? window.moneyPagePriorityData : [];

        const norm = (u) => normalizeUrlForDedupe
          ? normalizeUrlForDedupe(u)
          : String(u || '').toLowerCase().replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '');

        const priorityByUrl = new Map(priorityRows.filter(p => p && p.url).map(p => [norm(p.url), p]));

        const candidates = (tableRows && tableRows.length > 0)
          ? tableRows
              .filter(r => r && r.url)
              .map(r => {
                const p = priorityByUrl.get(norm(r.url)) || null;
                const segmentType = (p?.segmentType || r.subSegment || r.segmentType || 'landing');

                // If priority data exists, use it. Otherwise derive basic levels.
                const derivedDifficulty = (() => {
                  const pos = Number(r.avgPosition || 0);
                  if (pos <= 6) return 'LOW';
                  if (pos <= 12) return 'MEDIUM';
                  return 'HIGH';
                })();

                const derivedPriority = (() => {
                  // Use category from Opportunity table if available.
                  const cat = String(r.category || '').toUpperCase();
                  if (cat === 'HIGH_OPPORTUNITY') return 'HIGH';
                  if (cat === 'VISIBILITY_FIX') return 'MEDIUM';
                  return 'LOW';
                })();

                return {
                  url: r.url,
                  title: r.title || p?.title || r.url,
                  segmentType: String(segmentType).toLowerCase(),
                  impressions: Number(r.impressions || 0),
                  clicks: Number(r.clicks || 0),
                  ctr: r.ctr != null ? Number(r.ctr) : null,
                  avgPosition: r.avgPosition != null ? Number(r.avgPosition) : null,
                  // Levels used by the card renderer
                  difficultyLevel: (p?.difficultyLevel || derivedDifficulty),
                  priorityLevel: (p?.priorityLevel || derivedPriority),
                  impactLevel: (p?.impactLevel || 'MEDIUM'),
                  suggestion: (p?.suggestion || r.recommendedAction || r.opportunityText || null)
                };
              })
          : priorityRows
              .filter(p => p && p.url && p.segmentType !== 'authority');

        if (candidates.length === 0) {
          container.innerHTML = '<p style="padding: 1.5rem; text-align: center; color: #64748b;">No suggested pages for this filter.</p>';
          return;
        }

        const rank = (v, map) => map[String(v || '').toUpperCase()] ?? 99;
        const priorityRank = { HIGH: 0, MEDIUM: 1, LOW: 2 };
        const impactRank = { HIGH: 0, MEDIUM: 1, LOW: 2 };
        const diffRank = { LOW: 0, MEDIUM: 1, HIGH: 2 };

        // Rank Suggested primarily by impressions (matches Opportunity table expectation),
        // with secondary tie-breaks for priority/impact/difficulty when available.
        const top10 = candidates
          .slice()
          .sort((a, b) => {
            const ia = Number(a.impressions || 0);
            const ib = Number(b.impressions || 0);
            if (ib !== ia) return ib - ia;

            const pa = rank(a.priorityLevel, priorityRank);
            const pb = rank(b.priorityLevel, priorityRank);
            if (pa !== pb) return pa - pb;

            const impa = rank(a.impactLevel, impactRank);
            const impb = rank(b.impactLevel, impactRank);
            if (impa !== impb) return impa - impb;

            const da = rank(a.difficultyLevel, diffRank);
            const db = rank(b.difficultyLevel, diffRank);
            if (da !== db) return da - db;

            return Number(b.clicks || 0) - Number(a.clicks || 0);
          })
          .slice(0, 10);

        const TARGET_CTR = 0.025; // 2.5% target used by Money Pages optimisation tasks

        const ctrPct = (p) => {
          const clicks = Number(p.clicks || 0);
          const imps = Number(p.impressions || 0);
          if (imps > 0) return (clicks / imps) * 100;
          const raw = Number(p.ctr || 0);
          const ratio = raw > 1 ? raw / 100 : raw;
          return (ratio || 0) * 100;
        };

        const ctrRatio = (p) => {
          const clicks = Number(p.clicks || 0);
          const imps = Number(p.impressions || 0);
          if (imps > 0) return clicks / imps;
          const raw = Number(p.ctr || 0);
          const ratio = raw > 1 ? raw / 100 : raw;
          return ratio || 0;
        };

        const expectedIncreaseClicks28dToTargetCtr = (p) => {
          const imps = Number(p.impressions || 0);
          if (!(imps > 0)) return 0;
          const gap = Math.max(0, TARGET_CTR - ctrRatio(p));
          return Math.round(imps * gap);
        };

        const maxExpectedUp = Math.max(1, ...top10.map(p => expectedIncreaseClicks28dToTargetCtr(p) || 0));
        const impactScore100 = (p) => {
          const up = expectedIncreaseClicks28dToTargetCtr(p) || 0;
          return Math.max(0, Math.min(100, Math.round((up / maxExpectedUp) * 100)));
        };

        container.innerHTML = top10.map((p) => {
          const status = window.getOptimisationStatus
            ? window.getOptimisationStatus({ targetUrl: p.url, keyword: '' }, 'on_page')
            : null;
          const statusText = status?.status || null;
          const hasTask = !!statusText && statusText !== 'deleted' && statusText !== 'done' && statusText !== 'cancelled';
          const taskId = hasTask ? (status.id || status.task_id || null) : null;

          const pri = String(p.priorityLevel || '').toUpperCase() || 'MED';
          const diff = String(p.difficultyLevel || '').toUpperCase() || 'MEDIUM';
          const imp = String(p.impactLevel || '').toUpperCase() || 'MEDIUM';

          const diffColors = { LOW: '#10b981', MEDIUM: '#f59e0b', HIGH: '#ef4444' };
          const diffColor = diffColors[diff] || '#64748b';

          const priColors = { LOW: '#10b981', MEDIUM: '#f59e0b', HIGH: '#ef4444' };
          const priColor = priColors[pri] || '#64748b';

          const title = p.title || p.url;
          const safeUrl = String(p.url).replace(/'/g, "\\'");
          const safeTitle = String(title).replace(/'/g, "\\'");
          const expectedUp = expectedIncreaseClicks28dToTargetCtr(p);
          const impact100 = impactScore100(p);
          const typeTag = String(p.segmentType || 'landing').toLowerCase();
          const typeColors = {
            landing: { bg: '#dbeafe', fg: '#1d4ed8' },
            event: { bg: '#fee2e2', fg: '#b91c1c' },
            product: { bg: '#d1fae5', fg: '#065f46' }
          };
          const typeStyle = typeColors[typeTag] || { bg: '#e2e8f0', fg: '#334155' };

          return `
            <div class="suggested-card" style="background: white; border: 1px solid #e2e8f0; border-radius: 8px; padding: 1.25rem; box-shadow: 0 2px 4px rgba(0,0,0,0.06); ${hasTask ? 'border-left: 4px solid #10b981;' : ''}">
              ${hasTask ? `<div style="background: #dcfce7; color: #166534; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 700; margin-bottom: 0.75rem;"> Being Optimised</div>` : ''}
              <div style="display:flex; justify-content: space-between; gap: 0.75rem; align-items: flex-start; margin-bottom: 0.5rem;">
                <div style="flex:1;">
                  <div style="font-weight:700; color:#1e293b; line-height:1.35; margin-bottom:0.35rem;">${escapeHtml(title)}</div>
                  <a href="${p.url}" target="_blank" style="font-size:0.85rem; color:#2563eb; text-decoration:none; word-break:break-all;">${p.url}</a>
                  <div style="margin-top: 0.5rem;">
                    <span style="display:inline-block; padding: 0.15rem 0.5rem; background:${typeStyle.bg}; color:${typeStyle.fg}; border-radius: 6px; font-size: 0.75rem; font-weight: 700;">${escapeHtml(typeTag)}</span>
                  </div>
                </div>
                <div style="display:flex; flex-direction:column; align-items:flex-end; gap:0.35rem; min-width:72px;">
                  <span style="padding: 0.2rem 0.55rem; border-radius: 999px; background:${priColor}20; color:${priColor}; font-size:0.75rem; font-weight:800; border: 1px solid ${priColor}40;">${pri}</span>
                </div>
              </div>

              <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 0.35rem 1rem; font-size:0.85rem; color:#475569; margin: 0.75rem 0 0.75rem; padding-bottom: 0.6rem; border-bottom: 1px solid #e5e7eb;">
                <div><span style="color:#64748b;">Pos:</span> <span style="font-weight:700; color:#1e293b;">${Number(p.avgPosition || 0).toFixed(1)}</span></div>
                <div><span style="color:#64748b;">CTR:</span> <span style="font-weight:700; color:#1e293b;">${ctrPct(p).toFixed(1)}%</span></div>
                <div><span style="color:#64748b;">Impr:</span> <span style="font-weight:700; color:#1e293b;">${Number(p.impressions || 0).toLocaleString()}</span></div>
                <div><span style="color:#64748b;">Upside:</span> <span style="font-weight:700; color:#1e293b;">${Number(expectedUp || 0).toLocaleString()}</span></div>
                <div><span style="color:#64748b;">Impact:</span> <span style="font-weight:700; color:#1e293b;">${impact100}</span></div>
                <div><span style="color:#64748b;">Difficulty:</span> <span style="font-weight:700; color:${diffColor};">${diff}</span></div>
              </div>

              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.35rem 1rem; font-size:0.85rem; color:#475569; margin: 0.35rem 0 0.35rem; padding-bottom: 0.6rem; border-bottom: 1px solid #e5e7eb;">
                <div><span style="color:#64748b;">AI cites:</span>
                  <span class="ai-citation-value" data-citation-url="${p.url.replace(/'/g, "\\'")}" style="font-weight:700; color:#1e293b; float:right;"></span>
                </div>
              </div>

              <div style="margin-bottom: 0.5rem; font-size:0.85rem; color:#64748b;">
                Potential impact clicks 28d: <strong style="color:#1e293b;">${Number(expectedUp || 0).toLocaleString()}</strong>
              </div>

              <div style="font-size:0.85rem; color:#64748b; line-height:1.5; margin-bottom:0.75rem;">
                ${escapeHtml(p.suggestion || 'Improve relevance + internal links to lift rank')}
              </div>

              <button type="button" style="width:100%; padding:0.65rem; border:none; border-radius:6px; font-weight:700; cursor:pointer; background:${hasTask ? '#10b981' : '#2563eb'}; color:white;"
                onclick="${hasTask && taskId ? `window.openOptimisationTaskDrawer('${String(taskId).replace(/'/g, "\\'").replace(/\"/g, '&quot;')}')` : `window.trackMoneyPage('${safeUrl}', '${safeTitle}')`}">
                ${hasTask ? 'Manage Task' : 'Create Task'}
              </button>
            </div>
          `;
        }).join('');
        
        // Populate AI citations in cards after rendering (similar to table)
        setTimeout(() => {
          const citationElements = container.querySelectorAll('.ai-citation-value');
          if (citationElements.length === 0) return;
          
          // Use the same cache and API logic as populateMoneyPagesAiCitations
          const normalizeUrl = (url) => {
            if (!url) return '';
            let normalized = String(url).toLowerCase().trim();
            normalized = normalized.replace(/^https?:\/\//, '');
            normalized = normalized.replace(/^www\./, '');
            normalized = normalized.split('?')[0].split('#')[0];
            const parts = normalized.split('/');
            if (parts.length > 1) {
              normalized = parts.slice(1).join('/');
            }
            normalized = normalized.replace(/^\/+/, '').replace(/\/+$/, '');
            return normalized;
          };
          
          citationElements.forEach((el) => {
            const url = el.getAttribute('data-citation-url');
            if (!url) return;
            
            // Check cache first (same as table)
            const cached = window.moneyPagesCitationCache && window.moneyPagesCitationCache[url];
            if (typeof cached === 'number' && cached > 0) {
              el.textContent = cached;
              return;
            }
            
            // Check normalized cache
            const normalizedUrl = normalizeUrl(url);
            let cachedValue = null;
            if (window.moneyPagesCitationCache) {
              for (const [key, value] of Object.entries(window.moneyPagesCitationCache)) {
                if (normalizeUrl(key) === normalizedUrl) {
                  cachedValue = value;
                  break;
                }
              }
            }
            
            if (typeof cachedValue === 'number' && cachedValue > 0) {
              el.textContent = cachedValue;
              if (!window.moneyPagesCitationCache) window.moneyPagesCitationCache = {};
              window.moneyPagesCitationCache[url] = cachedValue;
              return;
            }
            
            // Fetch from API (same endpoint as table)
            const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
            if (!propertyUrl) return;
            
            const endpoint = apiUrl(`/api/supabase/query-keywords-citing-url?property_url=${encodeURIComponent(propertyUrl)}&target_url=${encodeURIComponent(url)}`);
            
            fetch(endpoint)
              .then(async res => {
                if (!res.ok) {
                  const txt = await res.text().catch(() => 'error');
                  throw new Error(`HTTP ${res.status}: ${txt}`);
                }
                return res.json();
              })
              .then(data => {
                const count = typeof data?.count === 'number' ? data.count : (Array.isArray(data?.data) ? data.data.length : 0);
                if (!window.moneyPagesCitationCache) window.moneyPagesCitationCache = {};
                window.moneyPagesCitationCache[url] = count;
                el.textContent = count;
              })
              .catch(err => {
                debugLog(`[Money Pages Cards] AI citations fetch failed for ${url}: ${err.message}`, 'warn');
                el.textContent = '';
              });
          });
        }, 100);
      };
      
      // Wire up Priority & Actions filters
      function wirePriorityActionsFilters() {
        setTimeout(() => {
          const typeFilterEl = document.getElementById('money-pages-type-filter');
          const minImprEl = document.getElementById('money-pages-min-impr');
          const matrixEl = document.getElementById('money-pages-matrix');
          
          if (!typeFilterEl || !minImprEl) {
            debugLog(' Priority & Actions filters not found (may not be rendered yet)', 'warn');
            return;
          }
          
          debugLog(' Priority & Actions filter elements found', 'success');
          
          // Remove existing listeners by cloning elements
          const newTypeFilter = typeFilterEl.cloneNode(true);
          const newMinImpr = minImprEl.cloneNode(true);
          typeFilterEl.parentNode.replaceChild(newTypeFilter, typeFilterEl);
          minImprEl.parentNode.replaceChild(newMinImpr, minImprEl);
          
          // Update counts initially when wiring up (apply min impressions filter if set)
          const base = window.moneyPagePriorityData || [];
          const authority = window.authorityActionRows || [];
          const allRows = base.concat(authority);
          if (allRows && allRows.length > 0) {
            // Get current min impressions value
            const initialMinImpr = parseInt(newMinImpr.value, 10) || 0;
            // Apply min impressions filter for counting
            const pagesForCounting = allRows.filter(p => p.segmentType === 'authority' || (p.impressions || 0) >= initialMinImpr);
            updateMoneyPagesTypeFilterCounts(pagesForCounting);
          }
          
          // Function to update matrix and table when filters change
          const updatePriorityActions = () => {
            const typeFilter = newTypeFilter.value || 'all';
            const minImpr = parseInt(newMinImpr.value, 10) || 0;
            
            // Store filter state globally
            window.moneyPagesTypeFilter = typeFilter;
            window.moneyPagesMinImpr = minImpr;
            
            debugLog(` Priority & Actions filter changed: type=${typeFilter}, minImpr=${minImpr}`, 'info');
            
            // Get current data
            const base = window.moneyPagePriorityData || [];
            const authority = window.authorityActionRows || [];
            const allRows = base.concat(authority);
            if (!allRows || allRows.length === 0) {
              debugLog(' No moneyPagePriorityData available for Priority & Actions', 'warn');
              return;
            }
            
            debugLog(` Priority & Actions: Found ${allRows.length} rows (money + authority)`, 'success');
            
            // Apply min impressions filter first (for counting purposes)
            let pagesForCounting = allRows.filter(p => p.segmentType === 'authority' || (p.impressions || 0) >= minImpr);
            
            // Update dropdown counts with filtered data (after min impressions filter)
            updateMoneyPagesTypeFilterCounts(pagesForCounting);
            
            // Apply type filter to get final filtered pages
            let filteredPages = pagesForCounting;
            if (typeFilter !== 'all') {
              filteredPages = filteredPages.filter(p => p.segmentType === typeFilter);
            }
            
            debugLog(` Priority & Actions: Filtered to ${filteredPages.length} pages`, 'success');
            
            // Re-render matrix with filtered data
            if (matrixEl && typeof renderMoneyPagesMatrix === 'function') {
              const pagesOnly = filteredPages.filter(p => p.segmentType !== 'authority');
              const activeFilter = window.moneyMatrixFilterState?.impact && window.moneyMatrixFilterState?.diff
                ? { impact: window.moneyMatrixFilterState.impact, diff: window.moneyMatrixFilterState.diff }
                : null;
              
              const handleMatrixCellClick = (impact, diff) => {
                // Toggle filter: if clicking the same cell, clear the filter
                const currentFilter = window.moneyMatrixFilterState;
                if (currentFilter && currentFilter.impact === impact && currentFilter.diff === diff) {
                  // Same cell clicked - clear filter
                  window.moneyMatrixFilterState = null;
                } else {
                  // Different cell clicked - set new filter
                window.moneyMatrixFilterState = { impact, diff };
                }
                
                // Re-render matrix with updated active filter
                const newActiveFilter = window.moneyMatrixFilterState && window.moneyMatrixFilterState.impact && window.moneyMatrixFilterState.diff
                  ? { impact: window.moneyMatrixFilterState.impact, diff: window.moneyMatrixFilterState.diff }
                  : null;
                renderMoneyPagesMatrix(pagesOnly, matrixEl, handleMatrixCellClick, newActiveFilter);
                
                // Re-render table with matrix filter (or no filter if cleared)
                const filters = {
                  typeFilter,
                  minImpr,
                  matrixFilter: newActiveFilter
                };
                if (typeof window.renderMoneyPagesPriorityTable === 'function') {
                  (async () => {
                    // Render the Priority & Actions table (not the opportunity table)
                    await window.renderMoneyPagesPriorityTable(filteredPages, filters);
                  })();
                }
              };
              
              renderMoneyPagesMatrix(pagesOnly, matrixEl, handleMatrixCellClick, activeFilter);
            } else {
              debugLog(' renderMoneyPagesMatrix function or matrix element not found', 'warn');
            }
            
            // Re-render table with filters
            if (typeof window.renderMoneyPagesPriorityTable === 'function') {
              const filters = {
                typeFilter,
                minImpr,
                matrixFilter: window.moneyMatrixFilterState?.impact && window.moneyMatrixFilterState?.diff
                  ? { impact: window.moneyMatrixFilterState.impact, diff: window.moneyMatrixFilterState.diff }
                  : null
              };
              (async () => {
                await window.renderMoneyPagesPriorityTable(filteredPages, filters);
              })();
            } else {
              debugLog(' renderMoneyPagesPriorityTable function not found', 'warn');
            }
          };
          
          // Attach event listeners
          newTypeFilter.addEventListener('change', updatePriorityActions);
          newMinImpr.addEventListener('input', updatePriorityActions);
          
          debugLog(' Priority & Actions filters wired up', 'success');
        }, 200);
      }
      
      // Make function globally available
      window.wirePriorityActionsFilters = wirePriorityActionsFilters;
      
      // ============================================================================
      // 12-Month KPI Tracker Functions
      // ============================================================================
      
      let moneyKpiChart = null;
      let cachedAuditHistory = null;
      
      // Sort state for tables
      let moneyPagesTableSort = { column: 'priority', direction: 'asc' }; // 'asc' or 'desc'
      let moneyKpiTableSort = { column: 'segment', direction: 'asc' }; // 'asc' or 'desc'
      
      /**
       * Build KPI history structure from audit history
       * @param {Array<{date: string, moneySegmentMetrics: MoneySegmentMetricsByAudit | null}>} history
       * @param {string} metricKey - 'ctr', 'impressions', 'clicks', or 'avgPosition'
       * @returns {{ labels: string[], segments: Record<string, number[]> }}
       */
      function buildMoneyKpiHistory(history, metricKey, timeseries = [], latestMoneySegmentMetrics = null, latestMoneyPagePriorityData = []) {
        // Use last 28 days (matching Performance Trends charts) with 8 weekly date points (28 days / 4 = 7 weeks)
        // Get the last GSC timeseries date from actual timeseries data
        let lastGscTimeseriesDate = null;
        if (timeseries.length > 0) {
          const timeseriesDates = timeseries.map(ts => ts.date).filter(Boolean).sort().reverse();
          if (timeseriesDates.length > 0) {
            lastGscTimeseriesDate = timeseriesDates[0];
          }
        }
        
        // Fallback to window value if timeseries not provided
        if (!lastGscTimeseriesDate) {
          lastGscTimeseriesDate = window.lastGscTimeseriesDate || null;
        }
        
        // Calculate 28-day range ending at last GSC date (inclusive of end date, so go back 27 days)
        const endDate = lastGscTimeseriesDate ? new Date(lastGscTimeseriesDate + 'T00:00:00') : new Date();
        const startDate = new Date(endDate);
        startDate.setDate(startDate.getDate() - 27); // 27 days back + end date = 28 days total
        startDate.setHours(0, 0, 0, 0);
        endDate.setHours(0, 0, 0, 0);
        
        // Generate 8 weekly date points across the 28-day range (28 days / 4 = 7 weeks, so 8 points)
        // Range is from startDate to endDate (inclusive) = 28 days total
        const datePoints = [];
        const totalDays = 28; // startDate to endDate inclusive
        const numPoints = 8; // Weekly points: 7 intervals of 4 days each
        const step = (totalDays - 1) / (numPoints - 1); // 8 points = 7 intervals across 28 days
        
        for (let i = 0; i < numPoints; i++) {
          const date = new Date(startDate);
          date.setDate(date.getDate() + Math.round(i * step));
          date.setHours(0, 0, 0, 0);
          const dateStr = date.toISOString().split('T')[0];
          datePoints.push(dateStr);
        }
        
        // Ensure last point is exactly endDate
        if (datePoints.length > 0) {
          datePoints[datePoints.length - 1] = endDate.toISOString().split('T')[0];
        }
        
        // Build rolling 28-day site totals from daily GSC timeseries.
        // This avoids mixing 28d metrics (moneySegmentMetrics) with 1-day metrics (gsc_timeseries).
        const tsSorted = (Array.isArray(timeseries) ? timeseries : [])
          .filter(ts => ts && ts.date)
          .slice()
          .sort((a, b) => String(a.date).localeCompare(String(b.date)));

        const rolling28d = (endDateStr) => {
          if (!endDateStr || tsSorted.length === 0) return { clicks: 0, impressions: 0, days: 0, posWeight: 0, posImpr: 0 };
          const end = new Date(endDateStr + 'T00:00:00');
          if (Number.isNaN(end.getTime())) return { clicks: 0, impressions: 0, days: 0, posWeight: 0, posImpr: 0 };
          const start = new Date(end);
          start.setDate(start.getDate() - 27);
          const startStr = start.toISOString().split('T')[0];
          let clicks = 0;
          let impressions = 0;
          let days = 0;
          let posWeight = 0;
          let posImpr = 0;
          for (const ts of tsSorted) {
            const d = String(ts.date);
            if (d < startStr) continue;
            if (d > endDateStr) break;
            clicks += Number(ts.clicks || 0);
            impressions += Number(ts.impressions || 0);
            days += 1;
            const impr = Number(ts.impressions || 0);
            const pos = Number(ts.position);
            if (impr > 0 && !Number.isNaN(pos) && isFinite(pos) && pos > 0) {
              posWeight += pos * impr;
              posImpr += impr;
            }
          }
          return { clicks, impressions, days, posWeight, posImpr };
        };

        const clamp01 = (x) => Math.max(0, Math.min(1, x));

        // Prefer moneySegmentMetrics if present; otherwise fall back to the latest Money Pages overview.
        // (Some audits may not have `moneySegmentMetrics` persisted, but we still have moneyClicks/impressions.)
        const overview = window.moneyPagesMetrics?.overview || null;

        const refAllMoney =
          latestMoneySegmentMetrics?.allMoney ||
          (history.slice().reverse().find(r => r && r.moneySegmentMetrics)?.moneySegmentMetrics?.allMoney) ||
          window.moneySegmentMetrics?.allMoney ||
          (overview ? {
            clicks: Number(overview.moneyClicks || 0),
            impressions: Number(overview.moneyImpressions || 0),
            avgPosition: (typeof overview.moneyAvgPosition === 'number' ? overview.moneyAvgPosition : null),
            behaviourScore: (typeof window.moneyPagesMetrics?.behaviour?.score === 'number' ? window.moneyPagesMetrics.behaviour.score : null)
          } : null);

        const siteRollAtEnd = rolling28d(endDate.toISOString().split('T')[0]);

        const moneyClicks28d = Number(refAllMoney?.clicks || overview?.moneyClicks || 0);
        const moneyImpressions28d = Number(refAllMoney?.impressions || overview?.moneyImpressions || 0);

        const moneyClicksShare =
          siteRollAtEnd.clicks > 0 && moneyClicks28d > 0 ? clamp01(moneyClicks28d / siteRollAtEnd.clicks) : 0;
        const moneyImpressionsShare =
          siteRollAtEnd.impressions > 0 && moneyImpressions28d > 0 ? clamp01(moneyImpressions28d / siteRollAtEnd.impressions) : 0;

        // Segment split within money pages (Landing/Event/Product)  use any available segment metrics.
        const segSource =
          latestMoneySegmentMetrics ||
          (history.slice().reverse().find(r => r && r.moneySegmentMetrics)?.moneySegmentMetrics) ||
          window.moneySegmentMetrics ||
          null;

        const segmentProportions = {
          landingPages: { clicks: 0, impressions: 0 },
          eventPages: { clicks: 0, impressions: 0 },
          productPages: { clicks: 0, impressions: 0 }
        };

        if (segSource && segSource.allMoney) {
          const allClicks = Number(segSource.allMoney.clicks || moneyClicks28d || 0);
          const allImps = Number(segSource.allMoney.impressions || moneyImpressions28d || 0);
          if (allClicks > 0) {
            segmentProportions.landingPages.clicks = Number(segSource.landingPages?.clicks || 0) / allClicks;
            segmentProportions.eventPages.clicks = Number(segSource.eventPages?.clicks || 0) / allClicks;
            segmentProportions.productPages.clicks = Number(segSource.productPages?.clicks || 0) / allClicks;
          }
          if (allImps > 0) {
            segmentProportions.landingPages.impressions = Number(segSource.landingPages?.impressions || 0) / allImps;
            segmentProportions.eventPages.impressions = Number(segSource.eventPages?.impressions || 0) / allImps;
            segmentProportions.productPages.impressions = Number(segSource.productPages?.impressions || 0) / allImps;
          }
        }

        debugLog(
          `[KPI Tracker] Rolling-28d shares: clicksShare=${(moneyClicksShare * 100).toFixed(2)}%, imprShare=${(moneyImpressionsShare * 100).toFixed(2)}% (siteRollAtEnd clicks=${siteRollAtEnd.clicks}, imps=${siteRollAtEnd.impressions})`,
          'info'
        );
        
        // Create labels using same format as Performance Trends charts (e.g., "17 Nov", "15 Dec")
        const labels = datePoints.map(dateStr => {
          const date = new Date(dateStr + 'T00:00:00');
          return date.toLocaleDateString('en-GB', { month: 'short', day: 'numeric' });
        });
        
        const segments = {
          allMoney: [],
          landingPages: [],
          eventPages: [],
          productPages: []
        };
        
        const refAvgPos =
          (typeof refAllMoney?.avgPosition === 'number' ? refAllMoney.avgPosition : null) ??
          (typeof overview?.moneyAvgPosition === 'number' ? overview.moneyAvgPosition : null);

        const siteAvgPos28d =
          (typeof overview?.siteAvgPosition === 'number' && isFinite(overview.siteAvgPosition) && overview.siteAvgPosition > 0)
            ? overview.siteAvgPosition
            : null;
        const moneyAvgPos28d =
          (typeof overview?.moneyAvgPosition === 'number' && isFinite(overview.moneyAvgPosition) && overview.moneyAvgPosition > 0)
            ? overview.moneyAvgPosition
            : null;
        const moneyPosRatio = (siteAvgPos28d && moneyAvgPos28d) ? (moneyAvgPos28d / siteAvgPos28d) : null;
        const refBehaviour = typeof refAllMoney?.behaviourScore === 'number'
          ? refAllMoney.behaviourScore
          : (typeof window.moneyPagesMetrics?.behaviour?.score === 'number' ? window.moneyPagesMetrics.behaviour.score : null);

        if (tsSorted.length === 0 || (!moneyClicksShare && !moneyImpressionsShare)) {
          debugLog(`[KPI Tracker] Cannot calculate rolling series: tsSorted=${tsSorted.length}, clicksShare=${moneyClicksShare}, imprShare=${moneyImpressionsShare}`, 'warn');
          for (const _ of datePoints) {
            for (const key of Object.keys(segments)) segments[key].push(null);
          }
        } else {
          for (const datePoint of datePoints) {
            const siteRoll = rolling28d(datePoint);
            // If we don't have a full 28 days ending at this date, show nulls (matches UI expectation).
            if (siteRoll.days < 28) {
              for (const key of Object.keys(segments)) segments[key].push(null);
              continue;
            }

            const moneyClicks = Math.round(siteRoll.clicks * moneyClicksShare);
            const moneyImpressions = Math.round(siteRoll.impressions * moneyImpressionsShare);

            const segmentTotals = {
              allMoney: { clicks: moneyClicks, impressions: moneyImpressions },
              landingPages: {
                clicks: Math.round(moneyClicks * (segmentProportions.landingPages.clicks || 0)),
                impressions: Math.round(moneyImpressions * (segmentProportions.landingPages.impressions || 0))
              },
              eventPages: {
                clicks: Math.round(moneyClicks * (segmentProportions.eventPages.clicks || 0)),
                impressions: Math.round(moneyImpressions * (segmentProportions.eventPages.impressions || 0))
              },
              productPages: {
                clicks: Math.round(moneyClicks * (segmentProportions.productPages.clicks || 0)),
                impressions: Math.round(moneyImpressions * (segmentProportions.productPages.impressions || 0))
              }
            };

            for (const key of Object.keys(segments)) {
              const cls = segmentTotals[key]?.clicks ?? null;
              const imps = segmentTotals[key]?.impressions ?? null;
              let v = null;
              if (metricKey === 'clicks') v = cls;
              else if (metricKey === 'impressions') v = imps;
              else if (metricKey === 'ctr') v = imps > 0 ? (cls / imps) * 100 : 0;
              else if (metricKey === 'avgPosition') {
                const sitePos = (siteRoll.posImpr > 0) ? (siteRoll.posWeight / siteRoll.posImpr) : null;
                v = (sitePos && moneyPosRatio) ? (sitePos * moneyPosRatio) : refAvgPos;
              }
              else if (metricKey === 'behaviourScore') v = refBehaviour;
              segments[key].push(v);
            }
          }
        }

        return { labels, segments, datePoints };
      }
      
      /**
       * Render KPI table with trend arrows
       * @param {{ labels: string[], segments: Record<string, number[]> }} historyData
       * @param {string} metricKey
       */
      function renderMoneyKpiTable(historyData, metricKey) {
        const tableHead = document.getElementById("money-kpi-header-row");
        const tbody = document.querySelector("#money-kpi-table tbody");
        if (!tableHead || !tbody) return;

        const { labels, segments, datePoints = [] } = historyData;
        
        // Show message if no data
        if (!labels || labels.length === 0) {
          tbody.innerHTML = '<tr><td colspan="100%" style="padding: 2rem; text-align: center; color: #64748b;">No data available. Run audits to build KPI history.</td></tr>';
          return;
        }

        const segmentLabels = {
          allMoney: "All money pages",
          landingPages: "Landing pages",
          eventPages: "Event pages",
          productPages: "Product pages"
        };
        
        // Convert segments to array for sorting
        let segmentEntries = Object.entries(segments).map(([key, values]) => {
          // Calculate trend value for sorting
          const first = values.find(v => v != null);
          const last = [...values].reverse().find(v => v != null);
          let trendValue = 0;
          if (first != null && last != null) {
            let diff = last - first;
            if (metricKey === "avgPosition") diff = -diff; // lower is better
            trendValue = diff;
          }
          
          return {
            key,
            label: segmentLabels[key],
            values,
            trendValue,
            latestValue: last
          };
        });
        
        // Apply sorting
        const sortArrow = (col) => {
          if (moneyKpiTableSort.column === col) {
            return moneyKpiTableSort.direction === 'asc' ? ' ' : ' ';
          }
          return '';
        };
        
        if (moneyKpiTableSort.column === 'segment') {
          segmentEntries.sort((a, b) => {
            const comparison = a.label.localeCompare(b.label);
            return moneyKpiTableSort.direction === 'asc' ? comparison : -comparison;
          });
        } else if (moneyKpiTableSort.column === 'trend') {
          segmentEntries.sort((a, b) => {
            const comparison = a.trendValue - b.trendValue;
            return moneyKpiTableSort.direction === 'asc' ? comparison : -comparison;
          });
        } else if (moneyKpiTableSort.column.startsWith('month_')) {
          const monthIndex = parseInt(moneyKpiTableSort.column.replace('month_', ''));
          segmentEntries.sort((a, b) => {
            const aVal = a.values[monthIndex] ?? (metricKey === 'avgPosition' ? 999 : -1);
            const bVal = b.values[monthIndex] ?? (metricKey === 'avgPosition' ? 999 : -1);
            const comparison = aVal - bVal;
            return moneyKpiTableSort.direction === 'asc' ? comparison : -comparison;
          });
        } else if (moneyKpiTableSort.column === 'latest') {
          segmentEntries.sort((a, b) => {
            const aVal = a.latestValue ?? (metricKey === 'avgPosition' ? 999 : -1);
            const bVal = b.latestValue ?? (metricKey === 'avgPosition' ? 999 : -1);
            const comparison = aVal - bVal;
            return moneyKpiTableSort.direction === 'asc' ? comparison : -comparison;
          });
        }

        // Header with sortable columns - use same format as chart labels (e.g., "17 Nov")
        tableHead.innerHTML = `
          <th style="padding: 0.5rem 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0; cursor: pointer; user-select: none; white-space: nowrap;" data-sort="segment" title="Money page segment type: All money pages, Landing pages (collection/category), Event pages (workshops/events), or Product pages (services/products). Click to sort.">Segment${sortArrow('segment')}</th>
          ${labels.map((label, idx) => {
            // Labels are in "17 Nov" format - split into two lines for compact display
            const parts = label.split(' ');
            const day = parts[0] || '';
            const month = parts[1] || '';
            // Use datePoints if available, otherwise just use label for tooltip
            const fullDate = (datePoints && datePoints[idx]) ? datePoints[idx] : label;
            return `<th style="padding: 0.4rem 0.2rem; text-align: center; border-bottom: 2px solid #e2e8f0; cursor: pointer; user-select: none; font-size: 0.7rem; min-width: 35px; max-width: 40px; line-height: 1.2; position: relative;" data-sort="month_${idx}" title="Value for ${fullDate}. Click to sort by this date."><div style="display: block;">${day}</div><div style="display: block; font-size: 0.65rem; color: #64748b;">${month}</div><span style="position: absolute; top: 2px; right: 2px; font-size: 0.6rem;">${sortArrow(`month_${idx}`)}</span></th>`;
          }).join("")}
          <th style="padding: 0.5rem 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0; cursor: pointer; user-select: none; white-space: nowrap;" data-sort="trend" title="Overall trend from first to last data point.  = improving,  = declining,  = stable. For Avg Position, lower is better so trend is inverted. Click to sort.">Trend${sortArrow('trend')}</th>
        `;
        
        // Add click handlers to header cells
        tableHead.querySelectorAll('th[data-sort]').forEach(th => {
          th.addEventListener('click', () => {
            const col = th.getAttribute('data-sort');
            if (moneyKpiTableSort.column === col) {
              moneyKpiTableSort.direction = moneyKpiTableSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
              moneyKpiTableSort.column = col;
              moneyKpiTableSort.direction = 'asc';
            }
            renderMoneyKpiTable(historyData, metricKey);
          });
          
          th.addEventListener('mouseenter', () => {
            th.style.backgroundColor = '#e2e8f0';
          });
          th.addEventListener('mouseleave', () => {
            th.style.backgroundColor = '';
          });
        });

        tbody.innerHTML = segmentEntries
          .map(({ key, label, values, trendValue }) => {
            if (!values.length) return "";

            let trendArrow = "";
            let trendClass = "kpi-trend-flat";
            let trendText = "";

            const first = values.find(v => v != null);
            const last = [...values].reverse().find(v => v != null);

            if (first != null && last != null) {
              let diff = last - first;
              if (metricKey === "avgPosition") diff = -diff; // lower is better
              if (diff > 0.02 * Math.abs(first || 1)) {
                trendArrow = "";
                trendClass = "kpi-trend-up";
              } else if (diff < -0.02 * Math.abs(first || 1)) {
                trendArrow = "";
                trendClass = "kpi-trend-down";
              }
              // For CTR, values are already percentages (0-100), so diff is already in percentage points
              // For other metrics, show the raw difference
              trendText = (metricKey === "ctr" ? `${diff.toFixed(1)}pp` : diff.toFixed(1));
            } else {
              trendText = "";
            }

            const cells = values
              .map((v, idx) => {
                if (v == null) return `<td style="padding: 0.4rem 0.3rem; text-align: right; font-size: 0.75rem; min-width: 50px;"></td>`;

                // arrow vs previous non-null
                let arrow = "";
                let arrowClass = "kpi-trend-flat";
                let prev = null;
                for (let j = idx - 1; j >= 0; j--) {
                  if (values[j] != null) {
                    prev = values[j];
                    break;
                  }
                }
                if (prev != null) {
                  let d = v - prev;
                  if (metricKey === "avgPosition") d = -d;
                  if (d > 0.02 * Math.abs(prev || 1)) {
                    arrow = "";
                    arrowClass = "kpi-trend-up";
                  } else if (d < -0.02 * Math.abs(prev || 1)) {
                    arrow = "";
                    arrowClass = "kpi-trend-down";
                  }
                }

                let formatted;
                const arrowHtml = `<span class="${arrowClass}">${arrow}</span>`;
                if (metricKey === "ctr") formatted = `${v.toFixed(1)}% ${arrowHtml}`; // v is already a percentage (0-100)
                else if (metricKey === "avgPosition") formatted = `${v.toFixed(1)} ${arrowHtml}`;
                else formatted = `${Math.round(v).toLocaleString()} ${arrowHtml}`;

                return `<td style="padding: 0.4rem 0.3rem; text-align: right; font-size: 0.75rem; min-width: 50px;">${formatted}</td>`;
              })
              .join("");

            return `
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.75rem; font-weight: 600;">${label}</td>
                ${cells}
                <td style="padding: 0.75rem; text-align: right; font-weight: 600;">
                  <span class="${trendClass}">${trendArrow}</span> ${trendText}
                </td>
              </tr>
            `;
          })
          .join("");
      }
      
      /**
       * Render sparkline chart for KPI tracker
       * @param {{ labels: string[], segments: Record<string, number[]> }} historyData
       * @param {string} metricKey
       */
      function renderMoneyKpiSparkline(historyData, metricKey, retryCount = 0) {
        const ctx = document.getElementById("money-kpi-sparkline");
        if (!ctx) return;

        const { labels, segments } = historyData;
        
        // Don't set canvas dimensions manually - let Chart.js handle it with fixed container
        // The parent container now has a fixed height (300px) set in HTML
        
        // Check if panel is visible AFTER setting dimensions
        const moneyPanel = ctx.closest('.aigeo-panel[data-panel="money"]');
        const isPanelActive = moneyPanel && moneyPanel.classList.contains('is-active');
        const panelStyle = moneyPanel ? window.getComputedStyle(moneyPanel) : null;
        const isPanelVisible = !moneyPanel || (isPanelActive && panelStyle && panelStyle.display !== 'none' && panelStyle.visibility !== 'hidden');
        const canvasRect = ctx.getBoundingClientRect();
        
        // Wait a bit for layout to settle if panel was just activated
        if (!isPanelVisible || canvasRect.width === 0 || canvasRect.height === 0) {
          if (retryCount >= 10) {
            const wrapper = ctx.closest('.sparkline-wrapper');
            if (wrapper) {
              wrapper.innerHTML = '<div style="padding: 1.5rem; text-align: center; color: #b45309; background: #fffbeb; border-left: 3px solid #f59e0b; border-radius: 6px; font-size: 0.9rem;">Could not render KPI chart (canvas still 00). Try switching tabs or refreshing.</div>';
            }
            return;
          }
          // Only log warning if panel is not active (to reduce noise)
          if (!isPanelActive) {
            debugLog(` Money KPI sparkline: Panel hidden or canvas has zero dimensions (width=${canvasRect.width}, height=${canvasRect.height}, panelVisible=${isPanelVisible}). Chart will render when panel is shown.`, 'warn');
            // Schedule retry when panel becomes visible
            if (moneyPanel && !moneyPanel.classList.contains('is-active')) {
              // Use a one-time observer
              const observer = new MutationObserver((mutations) => {
                if (moneyPanel.classList.contains('is-active')) {
                  observer.disconnect();
                  // Wait a bit longer for layout to settle
                  setTimeout(() => renderMoneyKpiSparkline(historyData, metricKey, retryCount + 1), 200);
                }
              });
              observer.observe(moneyPanel, { attributes: true, attributeFilter: ['class'] });
              // Also set a timeout fallback (max 5 seconds)
              setTimeout(() => {
                observer.disconnect();
                if (moneyPanel.classList.contains('is-active')) {
                  renderMoneyKpiSparkline(historyData, metricKey, retryCount + 1);
                }
              }, 5000);
            }
          } else {
            // Panel is active but canvas still has zero dimensions - retry after a short delay
            setTimeout(() => renderMoneyKpiSparkline(historyData, metricKey, retryCount + 1), 200);
          }
          return;
        }
        
        // Check if we have data
        const hasData = labels.length > 0 && segments.allMoney.length > 0;
        
        if (!hasData || labels.length === 0) {
          // Show message if no data
          const wrapper = ctx.closest('.sparkline-wrapper');
          if (wrapper) {
            wrapper.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b;">No data available. Run audits to build KPI history.</div>';
          }
          if (moneyKpiChart) {
            moneyKpiChart.destroy();
            moneyKpiChart = null;
          }
          return;
        }
        
        // Show info message if only 1 data point
        if (labels.length === 1) {
          const wrapper = ctx.closest('.sparkline-wrapper');
          if (wrapper && !wrapper.querySelector('.single-point-message')) {
            const message = document.createElement('div');
            message.className = 'single-point-message';
            message.style.cssText = 'padding: 0.5rem; margin-bottom: 0.5rem; background: #fef3c7; border-left: 3px solid #f59e0b; border-radius: 4px; font-size: 0.85rem; color: #92400e;';
            message.textContent = 'Only 1 audit available. Run more audits to see trends over time.';
            wrapper.insertBefore(message, ctx);
          }
        } else {
          // Remove message if we have multiple data points
          const wrapper = ctx.closest('.sparkline-wrapper');
          if (wrapper) {
            const message = wrapper.querySelector('.single-point-message');
            if (message) message.remove();
          }
        }

        const datasets = [
          { key: "allMoney", label: "All", values: segments.allMoney, color: "#3b82f6" },
          { key: "landingPages", label: "Landing", values: segments.landingPages, color: "#10b981" },
          { key: "eventPages", label: "Event", values: segments.eventPages, color: "#f59e0b" },
          { key: "productPages", label: "Product", values: segments.productPages, color: "#ef4444" }
        ];

        // Always destroy existing chart to allow re-rendering (e.g., when metric changes)
        // Also check Chart.js registry to ensure canvas is not already in use
        if (moneyKpiChart) {
          try {
            moneyKpiChart.destroy();
            moneyKpiChart = null;
          } catch (e) {
            debugLog('Error destroying moneyKpiChart: ' + e.message, 'warn');
            moneyKpiChart = null;
          }
        }
        
        // Also check Chart.js registry and destroy any existing chart on this canvas
        if (typeof Chart !== 'undefined' && Chart.getChart) {
          const existingChart = Chart.getChart(ctx);
          if (existingChart) {
            try {
              existingChart.destroy();
              debugLog('Destroyed existing Chart.js instance from registry for moneyKpiChart', 'info');
            } catch (e) {
              debugLog('Error destroying chart from registry: ' + e.message, 'warn');
            }
          }
        }
        
        // Clear canvas context to ensure clean slate
        const tempCtx = ctx.getContext('2d');
        if (tempCtx) {
          tempCtx.clearRect(0, 0, ctx.width, ctx.height);
        }

        // Ensure we have at least 2 points for line chart, or show points only
        const minPoints = labels.length === 1 ? 1 : 2;
        
        // Calculate Y-axis bounds to prevent infinite expansion
        const allValues = segments.allMoney.concat(
          segments.landingPages || [],
          segments.eventPages || [],
          segments.productPages || []
        ).filter(v => v != null && !isNaN(v));
        
        let minValue = allValues.length > 0 ? Math.min(...allValues) : 0;
        let maxValue = allValues.length > 0 ? Math.max(...allValues) : 100;
        
        // Calculate padding based on data range
        const range = maxValue - minValue;
        const padding = range > 0 ? Math.max(range * 0.1, range * 0.05) : (maxValue > 0 ? maxValue * 0.1 : 0.01);
        
        try {
          moneyKpiChart = new Chart(ctx, {
            type: "line",
            data: {
              labels,
              datasets: datasets.map(d => ({
                label: d.label,
                data: d.values,
                fill: false,
                tension: labels.length > 1 ? 0.3 : 0, // No tension for single point
                pointRadius: labels.length === 1 ? 5 : 3, // Larger point for single data point
                pointHoverRadius: 6,
                borderWidth: 2,
                borderColor: d.color,
                backgroundColor: d.color
              }))
            },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            plugins: {
              legend: { display: true, position: 'top' },
              tooltip: { 
                enabled: true,
                callbacks: {
                  label: function(context) {
                    const label = context.dataset.label || '';
                    const value = context.parsed.y;
                    let formatted = '';
                    if (metricKey === 'ctr') {
                      formatted = `${value.toFixed(2)}%`; // value is already a percentage (0-100)
                    } else if (metricKey === 'avgPosition') {
                      formatted = value.toFixed(1);
                    } else {
                      formatted = Math.round(value).toLocaleString();
                    }
                    return `${label}: ${formatted}`;
                  }
                }
              }
            },
            scales: {
              x: { 
                display: true,
                title: {
                  display: true,
                  font: {
                    size: 14,
                    weight: 'bold'
                  },
                  text: 'Month'
                },
                ticks: {
                  font: {
                    size: 12,
                    weight: 'bold'
                  },
                  maxRotation: 45,
                  minRotation: 45,
                  autoSkip: true,
                  maxTicksLimit: 12,
                  callback: function(value, index) {
                    // Return shorter date format to prevent overflow
                    const label = this.getLabelForValue(value);
                    if (label && label.length > 10) {
                      // If label is too long, use shorter format (e.g., "12-15" instead of "2025-12-15")
                      const parts = label.split('-');
                      if (parts.length >= 3) {
                        return `${parts[1]}-${parts[2]}`;
                      }
                    }
                    return label;
                  }
                }
              },
              y: { 
                display: true,
                title: {
                  display: true,
                  font: {
                    size: 14,
                    weight: 'bold'
                  },
                  text: metricKey === 'ctr' ? 'CTR (%)' : 
                        metricKey === 'avgPosition' ? 'Avg Position' :
                        metricKey === 'impressions' ? 'Impressions' :
                        metricKey === 'clicks' ? 'Clicks' :
                        (metricKey ? metricKey.charAt(0).toUpperCase() + metricKey.slice(1) : 'Value')
                },
                // Let Chart.js auto-scale - don't force min/max as it can cause issues with small ranges
                // The maintainAspectRatio and fixed container height will prevent infinite expansion
                ticks: {
                  font: {
                    size: 12,
                    weight: 'bold'
                  },
                  callback: function(value) {
                    const v = typeof value === 'number' ? value : parseFloat(value);
                    if (Number.isNaN(v)) return value;
                    if (metricKey === 'ctr') return `${v.toFixed(1)}%`; // v is already a percentage (0-100)
                    if (metricKey === 'avgPosition') return v.toFixed(1);
                    return Math.round(v).toLocaleString();
                  }
                }
              }
            },
            elements: {
              point: { radius: labels.length === 1 ? 5 : 3 }
            }
          }
        });
        debugLog(` Money KPI sparkline chart created successfully with ${labels.length} data points`, 'success');
        } catch (error) {
          debugLog(` Error creating Money KPI sparkline chart: ${error.message}`, 'error');
          debugLog(`Error stack: ${error.stack}`, 'error');
          const wrapper = ctx.closest('.sparkline-wrapper');
          if (wrapper) {
            wrapper.innerHTML = `<div style="padding: 2rem; text-align: center; color: #ef4444;">Error rendering chart: ${error.message}</div>`;
          }
        }
      }
      
      /**
       * Load audit history and render KPI tracker
       * @param {string} propertyUrl
       */
      // OLD FUNCTION - Using audit history (deprecated, use window.loadAuditHistoryAndRenderKpis instead)
      async function loadAuditHistoryAndRenderKpis_OLD(propertyUrl) {
        if (!propertyUrl) return;
        
        const endDate = new Date().toISOString().split('T')[0];
        const startDate = new Date();
        startDate.setFullYear(startDate.getFullYear() - 1);
        const startDateStr = startDate.toISOString().split('T')[0];
        
        try {
          // Use window.apiUrl if available (for functions outside the main scope)
          const urlHelper = window.apiUrl || ((path) => {
            const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
            if (!baseUrl) {
              return path.startsWith('/') ? path : `/${path}`;
            }
            const cleanPath = path.startsWith('/') ? path : `/${path}`;
            return `${baseUrl}${cleanPath}`;
          });
          const res = await fetch(urlHelper(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDate}`));
          const json = await res.json();
          if (json.status !== "ok") {
            debugLog(' Could not load audit history for KPI tracker', 'warn');
            return;
          }

          const history = json.data || [];
          const timeseries = json.timeseries || [];
          cachedAuditHistory = history;
          
          debugLog(`[KPI Tracker] Loaded ${history.length} audit records and ${timeseries.length} timeseries records`, 'info');
          debugLog(`[KPI Tracker] API response structure: hasData=${!!json.data}, hasTimeseries=${!!json.timeseries}, timeseriesType=${typeof json.timeseries}, timeseriesIsArray=${Array.isArray(json.timeseries)}`, 'info');
          if (timeseries.length > 0) {
            debugLog(`[KPI Tracker] Timeseries sample: first=${JSON.stringify(timeseries[0])}, last=${JSON.stringify(timeseries[timeseries.length - 1])}`, 'info');
          } else {
            debugLog(`[KPI Tracker] WARNING: timeseries is empty. API response keys: ${Object.keys(json).join(', ')}`, 'warn');
          }
          
          if (history.length === 0) {
            const card = document.getElementById("money-pages-kpi-card");
            if (card) {
              const tableWrapper = card.querySelector('.table-wrapper');
              if (tableWrapper) {
                tableWrapper.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b;">No audit history available. Run audits to build KPI data.</div>';
              }
              const tbody = card.querySelector('#money-kpi-table tbody');
              if (tbody) {
                tbody.innerHTML = '<tr><td colspan="100%" style="padding: 2rem; text-align: center; color: #64748b;">No audit history available. Run audits to build KPI data.</td></tr>';
              }
            }
            debugLog(' Money Pages KPI Tracker: No audit history available', 'warn');
            return;
          }
          
          // Get the last GSC timeseries date (Money Pages metrics are GSC-derived, so should only show up to last GSC date)
          let lastGscTimeseriesDate = null;
          
          // Try to get from window first (if renderTrendChart already ran and set it)
          if (window.lastGscTimeseriesDate) {
            lastGscTimeseriesDate = window.lastGscTimeseriesDate;
            debugLog(`Money Pages KPI: Using last GSC timeseries date from window: ${lastGscTimeseriesDate}`, 'info');
          } else {
            // Extract from timeseries data in the API response
            // The API response should include timeseries data with dates
            if (json.timeseries && Array.isArray(json.timeseries) && json.timeseries.length > 0) {
              // Get the latest date from timeseries (dates are in YYYY-MM-DD format)
              const timeseriesDates = json.timeseries
                .map(ts => ts.date)
                .filter(date => date)
                .sort()
                .reverse();
              if (timeseriesDates.length > 0) {
                lastGscTimeseriesDate = timeseriesDates[0];
                window.lastGscTimeseriesDate = lastGscTimeseriesDate; // Store globally
                debugLog(`Money Pages KPI: Extracted last GSC timeseries date from API response: ${lastGscTimeseriesDate}`, 'info');
              }
            }
          }
          
          // Filter history to only include dates up to the last GSC timeseries date
          // Money Pages metrics (clicks, impressions, CTR, position) are GSC-derived, so should only show up to last GSC date
          let filteredHistory = history;
          if (lastGscTimeseriesDate) {
            const beforeFilter = history.length;
            filteredHistory = history.filter(record => {
              const recordDate = record.date || record.audit_date || record.auditDate;
              if (!recordDate) return false;
              // Compare dates as strings (YYYY-MM-DD format)
              const comparison = recordDate.localeCompare(lastGscTimeseriesDate);
              const include = comparison <= 0;
              if (!include) {
                debugLog(`Money Pages KPI: Excluding record with date ${recordDate} (last GSC date: ${lastGscTimeseriesDate})`, 'info');
              }
              return include;
            });
            debugLog(`Money Pages KPI: Filtered history from ${beforeFilter} to ${filteredHistory.length} records (last GSC date: ${lastGscTimeseriesDate})`, 'info');
            debugLog(`Money Pages KPI: Filtered dates: ${filteredHistory.map(r => r.date || r.audit_date || r.auditDate).join(', ')}`, 'info');
          } else {
            debugLog(`Money Pages KPI: No last GSC timeseries date found, using all history records`, 'warn');
          }
          
          // Check if any history records have moneySegmentMetrics (API returns camelCase)
          const hasMetrics = filteredHistory.some(record => record.moneySegmentMetrics);
          if (!hasMetrics) {
            debugLog(` Money Pages KPI Tracker: No moneySegmentMetrics in audit history. History length: ${filteredHistory.length}`, 'warn');
            debugLog(` Sample record keys: ${filteredHistory.length > 0 ? Object.keys(filteredHistory[0]).join(', ') : 'no records'}`, 'warn');
            const card = document.getElementById("money-pages-kpi-card");
            if (card) {
              const tableWrapper = card.querySelector('.table-wrapper');
              if (tableWrapper) {
                tableWrapper.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b;">No money segment metrics found in audit history. Run a new audit to generate KPI data.</div>';
              }
              const tbody = card.querySelector('#money-kpi-table tbody');
              if (tbody) {
                tbody.innerHTML = '<tr><td colspan="100%" style="padding: 2rem; text-align: center; color: #64748b;">No money segment metrics found. Run a new audit to generate KPI data.</td></tr>';
              }
            }
            return;
          }
          
          debugLog(` Money Pages KPI Tracker: Found ${filteredHistory.filter(r => r.moneySegmentMetrics).length} records with moneySegmentMetrics`, 'success');
          debugLog(` Money Pages KPI Tracker: Total history records: ${filteredHistory.length}`, 'info');

          // Use timeseries data from API response (already extracted above)
          if (timeseries.length === 0) {
            debugLog(` Money Pages KPI Tracker: No timeseries data returned from API. Check API logs.`, 'warn');
            debugLog(` API response keys: ${Object.keys(json).join(', ')}`, 'warn');
            debugLog(` API response status: ${json.status}`, 'warn');
          } else {
          debugLog(` Money Pages KPI Tracker: Using ${timeseries.length} timeseries data points from GSC`, 'info');
            debugLog(` Timeseries date range: ${timeseries[0]?.date} to ${timeseries[timeseries.length - 1]?.date}`, 'info');
          }

          // Cache for re-rendering charts on filter changes without re-fetching.
          window.__moneyPagesTimeseriesCache = timeseries;
          
          // IMPORTANT: Do NOT use `filteredHistory` to pick the "latest audit" for money shares.
          // GSC data is typically 12 days behind, so filtering audits to <= lastGscTimeseriesDate can
          // accidentally drop the most recent audit run (audit_date = today), which is exactly where
          // we get the latest moneyClicks/moneyImpressions proportions from.
          const latestAuditForShares =
            history.slice().reverse().find(r => r && (r.moneySegmentMetrics || r.moneyPagePriorityData)) ||
            (history.length > 0 ? history[history.length - 1] : null);

          const latestMoneyPagePriorityData =
            latestAuditForShares?.moneyPagePriorityData || window.moneyPagePriorityData || [];
          const latestMoneySegmentMetrics =
            latestAuditForShares?.moneySegmentMetrics || null;
          
          const metricKey = document.getElementById("money-kpi-metric-select")?.value || "ctr";
          debugLog(` Money Pages KPI Tracker: Using metricKey="${metricKey}"`, 'info');
          const historyData = buildMoneyKpiHistory(history, metricKey, timeseries, latestMoneySegmentMetrics, latestMoneyPagePriorityData);
          debugLog(` Money Pages KPI Tracker: Built history with ${historyData.labels.length} labels`, 'info');
          
          renderMoneyKpiTable(historyData, metricKey);
          renderMoneyKpiSparkline(historyData, metricKey);

          // Keep the Money Pages Performance Trends in sync with the KPI tracker.
          // We pass `timeseries` so the trend charts can use rolling-28d derivation (avoids spikes and
          // avoids relying on sparse portfolio snapshot rows).
          if (typeof renderMoneyPagesTrendChart === 'function') {
            renderMoneyPagesTrendChart([], timeseries);
          }
        } catch (error) {
          debugLog(` Error loading KPI history: ${error.message}`, 'warn');
        }
      }

      // Use the timeseries-based KPI loader as the canonical Money Pages KPI implementation.
      // (Portfolio snapshot rows can be sparse/irregular, which collapses the KPI table to a single week.)
      window.loadAuditHistoryAndRenderKpis = loadAuditHistoryAndRenderKpis_OLD;

      // Canonical implementation: KPI Tracker should be based on GSC timeseries + audit-derived proportions,
      // not portfolio segment snapshot rows (which may only exist for a single audit date).
      // NOTE: Do not override `window.loadAuditHistoryAndRenderKpis` here.
      // The canonical implementation is defined later and uses portfolio segment metrics.
      
      // Wire up KPI metric selector to reload on change
      function wireMoneyKpiMetricSelector() {
        setTimeout(() => {
          const metricSelect = document.getElementById('money-kpi-metric-select');
          if (metricSelect) {
            const newSelect = metricSelect.cloneNode(true);
            metricSelect.parentNode.replaceChild(newSelect, metricSelect);
            newSelect.addEventListener('change', () => {
              const propertyUrl = document.getElementById('propertyUrl')?.value;
              if (propertyUrl) {
                window.loadAuditHistoryAndRenderKpis(propertyUrl);
              }
            });
            debugLog(' Money KPI metric selector wired up', 'success');
          }
        }, 200);
      }
      
      // Render Money Pages Performance Trends charts (split into Volume and Rate charts)
      function renderMoneyPagesTrendChart(history, timeseries = null) {
        const volumeCanvas = document.getElementById('moneyPagesVolumeChart');
        const rateCanvas = document.getElementById('moneyPagesRateChart');
        
        if (!volumeCanvas || !rateCanvas) {
          debugLog(` Money Pages trend chart canvas(es) not found - volumeCanvas: ${!!volumeCanvas}, rateCanvas: ${!!rateCanvas}`, 'warn');
          debugLog(` Looking for canvas elements - volumeCanvas ID: moneyPagesVolumeChart, rateCanvas ID: moneyPagesRateChart`, 'warn');
          // Try to find any canvas elements in the Money Pages section
          const moneySection = document.getElementById('money-pages-section');
          if (moneySection) {
            const allCanvases = moneySection.querySelectorAll('canvas');
            debugLog(` Found ${allCanvases.length} canvas elements in money-pages-section`, 'warn');
            allCanvases.forEach((canvas, idx) => {
              debugLog(` Canvas ${idx}: id=${canvas.id}, tagName=${canvas.tagName}`, 'warn');
            });
          }
          return;
        }

        // IMPORTANT: Only render Money Pages Performance Trends from GSC daily timeseries.
        // This prevents "stale then flip" on load caused by other parts of the dashboard calling
        // `renderMoneyPagesTrendChart(history)` for unrelated charts (history-only), which would
        // paint these canvases before the KPI loader provides the canonical timeseries.
        if (!Array.isArray(timeseries) || timeseries.length === 0) {
          // Clear canvases to avoid showing stale previous chart instances.
          [volumeCanvas, rateCanvas].forEach(canvas => {
            try {
              const ctx = canvas.getContext('2d');
              if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
            } catch (e) {
              // ignore
            }
          });
          window.moneyPagesChartsRendering = false;
          return;
        }
        
        // Destroy existing charts if they exist
        // Also check if charts are already being rendered to prevent loops
        if (window.moneyPagesVolumeChart) {
          try {
            // Check if chart is still valid before destroying
            if (window.moneyPagesVolumeChart.canvas && window.moneyPagesVolumeChart.canvas.id === 'moneyPagesVolumeChart') {
              window.moneyPagesVolumeChart.destroy();
            }
          } catch (e) {
            // Ignore destroy errors
          }
          window.moneyPagesVolumeChart = null;
        }
        if (window.moneyPagesRateChart) {
          try {
            // Check if chart is still valid before destroying
            if (window.moneyPagesRateChart.canvas && window.moneyPagesRateChart.canvas.id === 'moneyPagesRateChart') {
              window.moneyPagesRateChart.destroy();
            }
          } catch (e) {
            // Ignore destroy errors
          }
          window.moneyPagesRateChart = null;
        }
        
        // Prevent re-rendering loops: if a render is in progress, queue the latest request and run it after.
        if (window.moneyPagesChartsRendering) {
          window.moneyPagesChartsPending = { history, timeseries };
          return;
        }
        window.moneyPagesChartsRendering = true;
        
        const hasTimeseries = Array.isArray(timeseries) && timeseries.length > 0;
        if ((!history || !Array.isArray(history) || history.length === 0) && !hasTimeseries) {
          debugLog(' Money Pages trend chart: No history data available', 'warn');
          // Set canvas dimensions before drawing text
          [volumeCanvas, rateCanvas].forEach(canvas => {
            if (canvas) {
              canvas.width = canvas.offsetWidth || 800;
              canvas.height = canvas.offsetHeight || 400;
              const ctx = canvas.getContext('2d');
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.font = '14px Arial';
              ctx.fillStyle = '#64748b';
              ctx.textAlign = 'center';
              ctx.fillText('No trend data available. Run audits to build trend data.', canvas.width / 2, canvas.height / 2);
            }
          });
          return;
        }

        // Current top-level sub-segment filter (ALL/LANDING/EVENT/PRODUCT).
        const subSegRaw =
          (document.getElementById('money-top-level-filter-subsegment')?.value ||
            window.moneyPagesSubSegmentFilter ||
            'ALL');
        const subSeg = String(subSegRaw).toUpperCase();
        const segmentKey =
          subSeg === 'PRODUCT' ? 'productPages' :
          subSeg === 'EVENT' ? 'eventPages' :
          subSeg === 'LANDING' ? 'landingPages' :
          'allMoney';

        // Behaviour score: recompute from the same derived CTR series (plus a segment-specific top10CTR anchor from page aggregates).
        const aggFn = window.computeMoneyPagesBehaviourFromPageAggregates;
        const rowsAll = (window.currentMoneyPagesMetrics || window.moneyPagesMetrics)?.rows || [];
        const rowsForSubSeg = (seg) => {
          if (!Array.isArray(rowsAll) || rowsAll.length === 0) return [];
          if (seg === 'ALL') return rowsAll;
          return rowsAll.filter(r => {
            const s = (r?.subSegment || r?.segmentType || 'LANDING');
            return String(s).toUpperCase() === seg;
          });
        };
        const top10CtrByKey = {
          allMoney: (typeof aggFn === 'function' ? aggFn(rowsForSubSeg('ALL'))?.top10Ctr : null),
          landingPages: (typeof aggFn === 'function' ? aggFn(rowsForSubSeg('LANDING'))?.top10Ctr : null),
          eventPages: (typeof aggFn === 'function' ? aggFn(rowsForSubSeg('EVENT'))?.top10Ctr : null),
          productPages: (typeof aggFn === 'function' ? aggFn(rowsForSubSeg('PRODUCT'))?.top10Ctr : null)
        };
        const behaviourFromCtr = (ctrRatio, top10CtrRatio) => {
          if (!ctrRatio || !top10CtrRatio) return null;
          const scoreCtrAll = Math.min(ctrRatio / 0.05, 1) * 100;    // 05% => 0100
          const scoreCtrTop10 = Math.min(top10CtrRatio / 0.10, 1) * 100; // 010% => 0100
          return 0.5 * scoreCtrAll + 0.5 * scoreCtrTop10;
        };

        // IMPORTANT: Money Pages Trend charts are "last 28 days (rolling)" metrics.
        // We have daily site totals in `gsc_timeseries`, so compute rolling-28d site totals and apply
        // the current money-page share to avoid discontinuities from older audits that used different
        // segmentation/aggregation logic.
        if (Array.isArray(timeseries) && timeseries.length > 0) {
          try {
            const tsSorted = timeseries
              .filter(ts => ts && ts.date)
              .slice()
              .sort((a, b) => String(a.date).localeCompare(String(b.date)));

            const clamp01 = (x) => Math.max(0, Math.min(1, x));

            const rolling28d = (endDateStr) => {
              const end = new Date(endDateStr + 'T00:00:00');
              if (Number.isNaN(end.getTime())) return { clicks: 0, impressions: 0, days: 0 };
              const start = new Date(end);
              start.setDate(start.getDate() - 27);
              const startStr = start.toISOString().split('T')[0];
              let clicks = 0;
              let impressions = 0;
              let days = 0;
              for (const ts of tsSorted) {
                const d = String(ts.date);
                if (d < startStr) continue;
                if (d > endDateStr) break;
                clicks += Number(ts.clicks || 0);
                impressions += Number(ts.impressions || 0);
                days += 1;
              }
              return { clicks, impressions, days };
            };

            const endDateStr = tsSorted[tsSorted.length - 1].date;
            const siteRollAtEnd = rolling28d(endDateStr);

            const overview = window.moneyPagesMetrics?.overview || null;
            const moneyClicks28d = Number(overview?.moneyClicks ?? 0);
            const moneyImpressions28d = Number(overview?.moneyImpressions ?? 0);

            const clicksShare = siteRollAtEnd.clicks > 0 ? clamp01(moneyClicks28d / siteRollAtEnd.clicks) : 0;
            const imprShare = siteRollAtEnd.impressions > 0 ? clamp01(moneyImpressions28d / siteRollAtEnd.impressions) : 0;

            const behaviourScore = typeof window.moneyPagesMetrics?.behaviour?.score === 'number'
              ? window.moneyPagesMetrics.behaviour.score
              : null;

            // Split money totals into sub-segments using latest money segment proportions if available.
            const segSource = window.moneySegmentMetrics || null;
            const segAll = segSource?.allMoney || null;
            const allClicks = Number(segAll?.clicks || moneyClicks28d || 0);
            const allImps = Number(segAll?.impressions || moneyImpressions28d || 0);
            const segPropClicks = {
              landingPages: allClicks > 0 ? Number(segSource?.landingPages?.clicks || 0) / allClicks : 0,
              eventPages: allClicks > 0 ? Number(segSource?.eventPages?.clicks || 0) / allClicks : 0,
              productPages: allClicks > 0 ? Number(segSource?.productPages?.clicks || 0) / allClicks : 0
            };
            const segPropImps = {
              landingPages: allImps > 0 ? Number(segSource?.landingPages?.impressions || 0) / allImps : 0,
              eventPages: allImps > 0 ? Number(segSource?.eventPages?.impressions || 0) / allImps : 0,
              productPages: allImps > 0 ? Number(segSource?.productPages?.impressions || 0) / allImps : 0
            };

            const derivedHistory = tsSorted.map(ts => {
              const roll = rolling28d(ts.date);
              if (roll.days < 28) {
                return {
                  date: ts.date,
                  isPartial: false,
                  moneySegmentMetrics: {
                    allMoney: { clicks: null, impressions: null, ctr: null, avgPosition: null, behaviourScore: null },
                    landingPages: { clicks: null, impressions: null, ctr: null, avgPosition: null, behaviourScore: null },
                    eventPages: { clicks: null, impressions: null, ctr: null, avgPosition: null, behaviourScore: null },
                    productPages: { clicks: null, impressions: null, ctr: null, avgPosition: null, behaviourScore: null }
                  }
                };
              }
              const clicks = Math.round(roll.clicks * clicksShare);
              const imps = Math.round(roll.impressions * imprShare);
              const ctr = imps > 0 ? (clicks / imps) : 0;

              const landingClicks = Math.round(clicks * (segPropClicks.landingPages || 0));
              const eventClicks = Math.round(clicks * (segPropClicks.eventPages || 0));
              const productClicks = Math.round(clicks * (segPropClicks.productPages || 0));
              const landingImps = Math.round(imps * (segPropImps.landingPages || 0));
              const eventImps = Math.round(imps * (segPropImps.eventPages || 0));
              const productImps = Math.round(imps * (segPropImps.productPages || 0));

              const landingCtr = landingImps > 0 ? (landingClicks / landingImps) : 0;
              const eventCtr = eventImps > 0 ? (eventClicks / eventImps) : 0;
              const productCtr = productImps > 0 ? (productClicks / productImps) : 0;

              const avgPos = (typeof overview?.moneyAvgPosition === 'number' ? overview.moneyAvgPosition : null);
              return {
                date: ts.date,
                isPartial: false,
                moneySegmentMetrics: {
                  allMoney: {
                    clicks,
                    impressions: imps,
                    ctr,
                    avgPosition: avgPos,
                    behaviourScore: null
                  },
                  landingPages: {
                    clicks: landingClicks,
                    impressions: landingImps,
                    ctr: landingCtr,
                    avgPosition: avgPos,
                    behaviourScore: null
                  },
                  eventPages: {
                    clicks: eventClicks,
                    impressions: eventImps,
                    ctr: eventCtr,
                    avgPosition: avgPos,
                    behaviourScore: null
                  },
                  productPages: {
                    clicks: productClicks,
                    impressions: productImps,
                    ctr: productCtr,
                    avgPosition: avgPos,
                    behaviourScore: null
                  }
                }
              };
            });

            history = derivedHistory;
            debugLog(
              ` Money Pages trend chart: using rolling-28d derived history (${derivedHistory.length} pts, clicksShare=${(clicksShare * 100).toFixed(2)}%, imprShare=${(imprShare * 100).toFixed(2)}%)`,
              'success'
            );
          } catch (e) {
            debugLog(` Money Pages trend chart: rolling derivation failed (${e.message}), falling back to historical history`, 'warn');
          }
        }
        
        // Get the last GSC timeseries date (Money Pages metrics are GSC-derived)
        // Use actual GSC data date, not audit date - GSC data is typically 2-3 days behind
        let lastGscTimeseriesDate = window.lastGscTimeseriesDate || null;
        
        // If not set, try to get from the latest history record's actual GSC date
        if (!lastGscTimeseriesDate && history.length > 0) {
          // Find the latest date that has moneySegmentMetrics (actual GSC data)
          const recordsWithMetrics = history
            .filter(r => r.moneySegmentMetrics && !r.isPartial)
            .map(r => r.date || r.audit_date || r.auditDate)
            .filter(Boolean)
            .sort()
            .reverse();
          
          if (recordsWithMetrics.length > 0) {
            // Use the latest date that has actual GSC metrics
            lastGscTimeseriesDate = recordsWithMetrics[0];
            debugLog(`Money Pages Trend Chart: Using latest date with GSC metrics: ${lastGscTimeseriesDate}`, 'info');
          }
        }
        
        debugLog(`Money Pages Trend Chart: Starting with ${history.length} history records, lastGscTimeseriesDate: ${lastGscTimeseriesDate}`, 'info');
        
        // Calculate the cutoff date for last 28 days (matches GSC data window)
        // Use the last GSC date if available, otherwise use today
        // Go back 27 days to get 28 days total (inclusive of end date)
        const cutoffDate = lastGscTimeseriesDate ? new Date(lastGscTimeseriesDate) : new Date();
        const twentyEightDaysAgo = new Date(cutoffDate);
        twentyEightDaysAgo.setDate(twentyEightDaysAgo.getDate() - 27); // 27 days back + end date = 28 days total
        const twentyEightDaysAgoStr = twentyEightDaysAgo.toISOString().split('T')[0];
        
        debugLog(`Money Pages Trend Chart: Showing last 28 days up to ${cutoffDate.toISOString().split('T')[0]} (from ${twentyEightDaysAgoStr})`, 'info');
        
        // Filter history to only include:
        // 1. Dates up to the last GSC timeseries date
        // 2. Dates within the last 28 days
        // 3. EXCLUDE partial audits (isPartial=true) to prevent unnatural spikes
        let filteredHistory = history;
        if (lastGscTimeseriesDate) {
          const beforeFilter = history.length;
          filteredHistory = history.filter(record => {
            const recordDate = record.date || record.audit_date || record.auditDate;
            if (!recordDate) return false;
            
            // Exclude partial audits - they can have incomplete/incorrect data
            if (record.isPartial === true) {
              debugLog(`Money Pages Trend: Excluding partial audit ${recordDate} to prevent spikes`, 'info');
              return false;
            }
            
            // Check if date is within last 28 days
            const isWithin28Days = recordDate.localeCompare(twentyEightDaysAgoStr) >= 0;
            
            // Check if date is up to last GSC date
            const isUpToGscDate = recordDate.localeCompare(lastGscTimeseriesDate) <= 0;
            
            const include = isWithin28Days && isUpToGscDate;
            if (!include) {
              debugLog(`Money Pages Trend: Excluding record with date ${recordDate} (28-day cutoff: ${twentyEightDaysAgoStr}, last GSC date: ${lastGscTimeseriesDate})`, 'info');
            }
            return include;
          });
          debugLog(`Money Pages Trend: Filtered history from ${beforeFilter} to ${filteredHistory.length} records (last 28 days up to GSC date: ${lastGscTimeseriesDate}, excluding partial audits)`, 'info');
          debugLog(`Money Pages Trend: Filtered dates: ${filteredHistory.map(r => r.date || r.audit_date || r.auditDate).join(', ')}`, 'info');
        } else {
          // If no GSC date, just filter by last 28 days and exclude partial audits
          const beforeFilter = history.length;
          filteredHistory = history.filter(record => {
            const recordDate = record.date || record.audit_date || record.auditDate;
            if (!recordDate) return false;
            
            // Exclude partial audits - they can have incomplete/incorrect data
            if (record.isPartial === true) {
              debugLog(`Money Pages Trend: Excluding partial audit ${recordDate} to prevent spikes`, 'info');
              return false;
            }
            
            const isWithin28Days = recordDate.localeCompare(twentyEightDaysAgoStr) >= 0;
            return isWithin28Days;
          });
          debugLog(`Money Pages Trend: Filtered history from ${beforeFilter} to ${filteredHistory.length} records (last 28 days, no GSC date limit, excluding partial audits)`, 'info');
        }
        
        // Create a map of date -> record for quick lookup
        const historyMap = new Map();
        filteredHistory.forEach(record => {
          const dateStr = record.date || record.audit_date || record.auditDate;
          if (dateStr) {
            historyMap.set(dateStr, record);
            // Debug: log records with money pages data
            if (record.moneySegmentMetrics || record.moneyPagesSummary) {
              debugLog(`Money Pages Trend: Found record for ${dateStr} with data: clicks=${record.moneySegmentMetrics?.allMoney?.clicks || 'null'}, impressions=${record.moneySegmentMetrics?.allMoney?.impressions || 'null'}`, 'info');
            }
          }
        });
        debugLog(`Money Pages Trend: Created historyMap with ${historyMap.size} entries`, 'info');
        
        // Generate 8 weekly date points for last 28 days (up to GSC date)
        // 28 days / 4 = 7 weeks, so 8 points (one per week including start and end)
        const endDate = lastGscTimeseriesDate ? new Date(lastGscTimeseriesDate + 'T00:00:00') : new Date();
        const startDate = new Date(twentyEightDaysAgo);
        const allDates = [];
        const numPoints = 8; // Weekly points: 7 intervals of 4 days each
        const totalDays = 28;
        const step = (totalDays - 1) / (numPoints - 1); // 8 points = 7 intervals
        
        // Ensure we're comparing dates correctly (set time to midnight)
        endDate.setHours(0, 0, 0, 0);
        startDate.setHours(0, 0, 0, 0);
        
        // Generate weekly date points
        for (let i = 0; i < numPoints; i++) {
          const date = new Date(startDate);
          date.setDate(date.getDate() + Math.round(i * step));
          date.setHours(0, 0, 0, 0);
          const dateStr = date.toISOString().split('T')[0];
          allDates.push(dateStr);
        }
        
        // Ensure last point is exactly endDate
        if (allDates.length > 0) {
          allDates[allDates.length - 1] = endDate.toISOString().split('T')[0];
        }
        
        debugLog(`Money Pages Trend: Generated ${allDates.length} weekly date points in range (${allDates[0]} to ${allDates[allDates.length - 1]})`, 'info');
        debugLog(`Money Pages Trend: Date range: startDate=${startDate.toISOString().split('T')[0]}, endDate=${endDate.toISOString().split('T')[0]}, twentyEightDaysAgoStr=${twentyEightDaysAgoStr}`, 'info');
        
        // Extract money pages trend data, filling in weekly dates
        const labels = [];
        const clicksData = [];
        const impressionsData = [];
        const ctrData = [];
        const behaviourData = [];
        
        // Track first available values (for backward-filling) and last known values (for forward-filling)
        let firstClicks = null;
        let firstImpressions = null;
        let firstCtr = null;
        let firstBehaviour = null;
        let lastClicks = null;
        let lastImpressions = null;
        let lastCtr = null;
        let lastBehaviour = null;
        
        // Find the first available audit record (for backward-filling the first point)
        let firstAvailableRecord = null;
        let firstAvailableDateStr = null;
        for (const [dateStr, record] of historyMap.entries()) {
          if (!record.isPartial) {
            const segmentMetrics = record.moneySegmentMetrics || {};
            const seg = segmentMetrics[segmentKey] || {};
            const hasZeroMetrics = (seg.clicks === 0 && seg.impressions === 0 && (seg.ctr === 0 || seg.ctr == null));
            if (!hasZeroMetrics) {
              firstAvailableRecord = record;
              firstAvailableDateStr = dateStr;
              break;
            }
          }
        }
        
        allDates.forEach((dateStr, dateIndex) => {
          const date = new Date(dateStr);
          labels.push(date.toLocaleDateString('en-GB', { month: 'short', day: 'numeric' }));
          
          // For weekly points, find the nearest audit record (exact match or closest before this date)
          let record = historyMap.get(dateStr);
          if (!record) {
            // Find the closest audit date before or on this weekly point date
            const weeklyDate = new Date(dateStr);
            let closestDate = null;
            let closestRecord = null;
            
            historyMap.forEach((rec, recDateStr) => {
              const recDate = new Date(recDateStr);
              if (recDate <= weeklyDate && (!closestDate || recDate > closestDate)) {
                closestDate = recDate;
                closestRecord = rec;
              }
            });
            
            record = closestRecord;
          }
          
          // If still no record found and this is the first date point, use the first available record (backward-fill)
          if (!record && dateIndex === 0 && firstAvailableRecord) {
            record = firstAvailableRecord;
            debugLog(`Money Pages Trend: First date point ${dateStr} has no data, backward-filling from first available audit ${firstAvailableDateStr}`, 'info');
          }
          
          if (record) {
            // Skip partial audits or audits with all-zero metrics (like Dec 15)
            // Check if this is a partial audit or has invalid zero data
            const isPartial = record.isPartial === true;
            const segmentMetrics = record.moneySegmentMetrics || {};
            const seg = segmentMetrics[segmentKey] || {};
            const hasZeroMetrics = (seg.clicks === 0 && seg.impressions === 0 && (seg.ctr === 0 || seg.ctr == null));
            
            // If partial audit or has all zeros, skip this record and forward-fill from last known value
            if (isPartial || hasZeroMetrics) {
              debugLog(`Money Pages Trend: Skipping ${dateStr} (isPartial=${isPartial}, hasZeroMetrics=${hasZeroMetrics}), forward-filling`, 'info');
              clicksData.push(lastClicks);
              impressionsData.push(lastImpressions);
              ctrData.push(lastCtr);
              behaviourData.push(lastBehaviour);
              return; // Use return instead of continue in forEach
            }
            
            // Get money pages summary data (shareOfImpressions, shareOfClicks, ctr)
            const summary = record.moneyPagesSummary || {};
            
            // Get behaviour score
            let behaviourScore = (typeof seg.behaviourScore === 'number' ? seg.behaviourScore : null);
            
            // For clicks and impressions, use moneySegmentMetrics if available
            const clicks = (seg.clicks != null ? seg.clicks : null);
            const impressions = (seg.impressions != null ? seg.impressions : null);
            // Calculate CTR directly from clicks/impressions for accuracy
            // If clicks and impressions are available, calculate CTR as percentage
            // Otherwise fall back to stored values (assuming they're in decimal format 0-1)
            let ctr = null;
            if (clicks != null && impressions != null && impressions > 0) {
              ctr = (clicks / impressions) * 100;
            } else if (summary.ctr != null) {
              // summary.ctr might be decimal (0.015) or percentage (1.5)
              // If > 1, assume it's already a percentage; otherwise multiply by 100
              ctr = summary.ctr > 1 ? summary.ctr : summary.ctr * 100;
            } else if ((segmentMetrics.allMoney || {}).ctr != null) {
              // allMoney.ctr might be decimal (0.015) or percentage (1.5)
              // If > 1, assume it's already a percentage; otherwise multiply by 100
              const fallbackAll = segmentMetrics.allMoney || {};
              ctr = fallbackAll.ctr > 1 ? fallbackAll.ctr : fallbackAll.ctr * 100;
            }

            if (behaviourScore == null && clicks != null && impressions != null && impressions > 0) {
              const ctrRatio = clicks / impressions;
              const top10Ctr = top10CtrByKey[segmentKey] ?? top10CtrByKey.allMoney;
              const derived = behaviourFromCtr(ctrRatio, top10Ctr);
              if (derived != null) behaviourScore = derived;
            }
            
            // (Removed noisy Dec 14 debug logging that referenced undefined locals and could crash rendering)
            
            // Track first available values (for backward-filling)
            if (firstClicks == null && clicks != null) firstClicks = clicks;
            if (firstImpressions == null && impressions != null) firstImpressions = impressions;
            if (firstCtr == null && ctr != null) firstCtr = ctr;
            if (firstBehaviour == null && behaviourScore != null) firstBehaviour = behaviourScore;
            
            // Update last known values
            if (clicks != null) lastClicks = clicks;
            if (impressions != null) lastImpressions = impressions;
            if (ctr != null) lastCtr = ctr;
            if (behaviourScore != null) lastBehaviour = behaviourScore;
            
            clicksData.push(clicks);
            impressionsData.push(impressions);
            ctrData.push(ctr);
            behaviourData.push(behaviourScore);
          } else {
            // No audit data for this date - forward-fill from last known value
            clicksData.push(lastClicks);
            impressionsData.push(lastImpressions);
            ctrData.push(lastCtr);
            behaviourData.push(lastBehaviour);
          }
        });
        
        // Backward-fill from first available value
        // This ensures dates before the first data point also get filled
        if (firstClicks != null || firstImpressions != null || firstCtr != null || firstBehaviour != null) {
          for (let i = 0; i < clicksData.length; i++) {
            if (clicksData[i] == null && firstClicks != null) clicksData[i] = firstClicks;
            if (impressionsData[i] == null && firstImpressions != null) impressionsData[i] = firstImpressions;
            if (ctrData[i] == null && firstCtr != null) ctrData[i] = firstCtr;
            if (behaviourData[i] == null && firstBehaviour != null) behaviourData[i] = firstBehaviour;
          }
          debugLog(`Money Pages Trend: Backward-filled from first values (clicks: ${firstClicks}, impressions: ${firstImpressions}, ctr: ${firstCtr}, behaviour: ${firstBehaviour})`, 'info');
        }
        
        debugLog(`Money Pages Trend: Populated ${labels.length} dates with data (${clicksData.filter(v => v != null).length} clicks values, ${impressionsData.filter(v => v != null).length} impressions values)`, 'info');
        debugLog(`Money Pages Trend: Sample data - First 5 dates: ${labels.slice(0, 5).join(', ')}, Last 5 dates: ${labels.slice(-5).join(', ')}`, 'info');
        debugLog(`Money Pages Trend: Sample clicks - First 5: ${clicksData.slice(0, 5).map(v => v != null ? v : 'null').join(', ')}, Last 5: ${clicksData.slice(-5).map(v => v != null ? v : 'null').join(', ')}`, 'info');
        
        if (labels.length === 0) {
          debugLog(' Money Pages trend chart: No valid data points after filtering', 'warn');
          // Set canvas dimensions before drawing text
          canvas.width = canvas.offsetWidth || 800;
          canvas.height = canvas.offsetHeight || 400;
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.font = '14px Arial';
          ctx.fillStyle = '#64748b';
          ctx.textAlign = 'center';
          ctx.fillText('No trend data available. Run audits to build trend data.', canvas.width / 2, canvas.height / 2);
          return;
        }
        
        // Ensure canvases have dimensions before creating charts
        // Use parent container dimensions (Chart.js will handle responsive sizing)
        [volumeCanvas, rateCanvas].forEach(canvas => {
          if (canvas) {
            const parentContainer = canvas.parentElement;
            if (parentContainer) {
              // Don't set canvas.width/height directly - let Chart.js handle it
              // Just ensure the parent has a height
              if (!parentContainer.style.height) {
                parentContainer.style.height = '300px';
              }
            }
          }
        });
        
        debugLog(`Money Pages Trend Chart: Creating chart with ${labels.length} data points`, 'info');
        debugLog(`Money Pages Trend Chart: Clicks data: ${clicksData.filter(v => v != null).length} values, Impressions: ${impressionsData.filter(v => v != null).length} values, CTR: ${ctrData.filter(v => v != null).length} values, Behaviour: ${behaviourData.filter(v => v != null).length} values`, 'info');
        debugLog(`Money Pages Trend Chart: Labels: ${labels.join(', ')}`, 'info');
        
        // Check if Chart.js is available
        if (typeof Chart === 'undefined') {
          debugLog(' Money Pages trend chart: Chart.js not loaded', 'warn');
          [volumeCanvas, rateCanvas].forEach(canvas => {
            if (canvas) {
              canvas.width = canvas.offsetWidth || 800;
              canvas.height = canvas.offsetHeight || 300;
              const ctx = canvas.getContext('2d');
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.font = '14px Arial';
              ctx.fillStyle = '#ef4444';
              ctx.textAlign = 'center';
              ctx.fillText('Chart.js library not loaded', canvas.width / 2, canvas.height / 2);
            }
          });
          return;
        }
        
        try {
          const volumeCtx = volumeCanvas.getContext('2d');
          const rateCtx = rateCanvas.getContext('2d');
          
          if (!volumeCtx || !rateCtx) {
            debugLog(' Money Pages trend chart: Could not get canvas context', 'warn');
            return;
          }
          
          debugLog(`Money Pages Trend Chart: Creating two Chart.js instances (Volume and Rate)...`, 'info');
          
          // Chart 1: Volume Metrics (Clicks + Impressions)
          window.moneyPagesVolumeChart = new Chart(volumeCtx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [
                {
                  label: 'Clicks',
                  data: clicksData,
                  borderColor: '#2563eb',
                  backgroundColor: 'rgba(37, 99, 235, 0.1)',
                  yAxisID: 'y',
                  tension: 0.4,
                  spanGaps: true
                },
                {
                  label: 'Impressions',
                  data: impressionsData,
                  borderColor: '#10b981',
                  backgroundColor: 'rgba(16, 185, 129, 0.1)',
                  yAxisID: 'y1',
                  tension: 0.4,
                  spanGaps: true
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              aspectRatio: 2.5,
              interaction: {
                mode: 'index',
                intersect: false
              },
              plugins: {
                legend: {
                  display: true,
                  position: 'top'
                },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      let label = context.dataset.label || '';
                      if (label) {
                        label += ': ';
                      }
                      label += context.parsed.y.toLocaleString();
                      return label;
                    }
                  }
                }
              },
              scales: {
                x: {
                  display: true,
                  title: {
                    display: true,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    text: 'Audit Date'
                  },
                  ticks: {
                    font: {
                      size: 12,
                      weight: 'bold'
                    },
                    maxRotation: 45,
                    minRotation: 45,
                    autoSkip: true,
                    maxTicksLimit: 15
                  }
                },
                y: {
                  type: 'linear',
                  display: true,
                  position: 'left',
                  title: {
                    display: true,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    text: 'Clicks'
                  },
                  ticks: {
                    font: {
                      size: 12,
                      weight: 'bold'
                    },
                    callback: function(value) {
                      return value.toLocaleString();
                    }
                  }
                },
                y1: {
                  type: 'linear',
                  display: true,
                  position: 'right',
                  title: {
                    display: true,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    text: 'Impressions'
                  },
                  grid: {
                    drawOnChartArea: false
                  },
                  ticks: {
                    font: {
                      size: 12,
                      weight: 'bold'
                    },
                    callback: function(value) {
                      return value.toLocaleString();
                    }
                  }
                }
              }
            }
          });
          
          // Chart 2: Rate & Score Metrics (CTR + Behaviour Score)
          window.moneyPagesRateChart = new Chart(rateCtx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [
                {
                  label: 'CTR (%)',
                  data: ctrData,
                  borderColor: '#f59e0b',
                  backgroundColor: 'rgba(245, 158, 11, 0.1)',
                  yAxisID: 'y',
                  tension: 0.4,
                  spanGaps: true
                },
                {
                  label: 'Behaviour Score',
                  data: behaviourData,
                  borderColor: '#8b5cf6',
                  backgroundColor: 'rgba(139, 92, 246, 0.1)',
                  yAxisID: 'y1',
                  tension: 0.4,
                  spanGaps: true
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              aspectRatio: 2.5,
              interaction: {
                mode: 'index',
                intersect: false
              },
              plugins: {
                legend: {
                  display: true,
                  position: 'top'
                },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      let label = context.dataset.label || '';
                      if (label) {
                        label += ': ';
                      }
                      const value = context.parsed.y;
                      // Use 2 decimal places for CTR to match axis precision
                      if (context.dataset.label === 'CTR (%)') {
                        label += value.toFixed(2) + '%';
                      } else {
                        label += value.toFixed(1);
                      }
                      return label;
                    }
                  }
                }
              },
              scales: {
                x: {
                  display: true,
                  title: {
                    display: true,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    text: 'Audit Date'
                  },
                  ticks: {
                    font: {
                      size: 12,
                      weight: 'bold'
                    },
                    maxRotation: 45,
                    minRotation: 45,
                    autoSkip: true,
                    maxTicksLimit: 15
                  }
                },
                y: {
                  type: 'linear',
                  display: true,
                  position: 'left',
                  title: {
                    display: true,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    text: 'CTR (%)'
                  },
                  ticks: {
                    font: {
                      size: 12,
                      weight: 'bold'
                    },
                    stepSize: 0.02,
                    precision: 2,
                    callback: function(value) {
                      return value.toFixed(2) + '%';
                    }
                  },
                  grid: {
                    color: 'rgba(0, 0, 0, 0.1)'
                  }
                },
                y1: {
                  type: 'linear',
                  display: true,
                  position: 'right',
                  title: {
                    display: true,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    text: 'Behaviour Score'
                  },
                  grid: {
                    drawOnChartArea: false
                  },
                  ticks: {
                    font: {
                      size: 12,
                      weight: 'bold'
                    },
                    callback: function(value) {
                      return value.toFixed(1);
                    }
                  }
                }
              }
            }
          });
          
          debugLog(' Money Pages trend charts rendered successfully', 'success');
          window.moneyPagesChartsRendering = false;

          if (window.moneyPagesChartsPending) {
            const pending = window.moneyPagesChartsPending;
            window.moneyPagesChartsPending = null;
            setTimeout(() => {
              try {
                renderMoneyPagesTrendChart(pending.history, pending.timeseries);
              } catch (e) {
                // ignore
              }
            }, 0);
          }
        } catch (error) {
          window.moneyPagesChartsRendering = false;
          debugLog(` Error creating Money Pages trend charts: ${error.message}`, 'error');
          debugLog(`Money Pages trend chart error details: ${error.stack || error.toString()}`, 'error');
          // Show error message on canvases
          [volumeCanvas, rateCanvas].forEach(canvas => {
            if (canvas) {
              const ctx = canvas.getContext('2d');
              if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = '14px Arial';
                ctx.fillStyle = '#ef4444';
                ctx.textAlign = 'center';
                ctx.fillText(`Error rendering chart: ${error.message}`, canvas.width / 2, canvas.height / 2);
              }
            }
          });
        }
      }
      
      // Make functions globally available
      window.renderMoneyPagesTrendChart = renderMoneyPagesTrendChart;
      window.wireMoneyKpiMetricSelector = wireMoneyKpiMetricSelector;
      
      // Recalculate behaviour for filtered sub-segment
      function recalculateMoneyPagesBehaviour(moneyPagesMetrics, queryPages, subSegmentFilter) {
        if (!moneyPagesMetrics || !moneyPagesMetrics.rows || !queryPages || subSegmentFilter === 'ALL') {
          return moneyPagesMetrics?.behaviour || null;
        }
        
        // Get filtered money page URLs
        const filteredRows = moneyPagesMetrics.rows.filter(row => row.subSegment === subSegmentFilter);
        
        if (filteredRows.length === 0) return null;
        
        // Recalculate behaviour for filtered URLs only (use all positions for filtered calculations)
        return window.computeMoneyPagesBehaviour(queryPages, filteredRows, true);
      }
      
      // Render Money Pages Behaviour KPIs
      // behaviour: pre-calculated behaviour object (already filtered if needed)
      // moneyPagesMetrics: optional, for backward compatibility
      // queryPages: optional, for backward compatibility
      function renderMoneyPagesBehaviourKpis(behaviour, moneyPagesMetrics = null, queryPages = null) {
        const scoreEl = document.getElementById('money-behaviour-score');
        const statusEl = document.getElementById('money-behaviour-status');
        const ctrEl = document.getElementById('money-ctr-value');
        const top10El = document.getElementById('money-top10-ctr-value');
        const cardEl = document.getElementById('money-behaviour-card');

        debugLog(` renderMoneyPagesBehaviourKpis called: behaviour=${!!behaviour}, moneyPagesMetrics=${!!moneyPagesMetrics}, queryPages=${!!queryPages}`, 'info');
        debugLog(` DOM elements found: scoreEl=${!!scoreEl}, statusEl=${!!statusEl}, ctrEl=${!!ctrEl}, top10El=${!!top10El}`, 'info');

        // Use the behaviour passed in (should already be filtered)
        // Only recalculate if behaviour is null and we have the data to calculate it
        let filteredBehaviour = behaviour;
        
        // Fallback: if no behaviour passed but we have metrics and queryPages, try to calculate
        if (!filteredBehaviour && moneyPagesMetrics && queryPages) {
          debugLog(` No behaviour passed, attempting to calculate from filtered metrics`, 'info');
          // Get filtered metrics based on ALL current filters
          const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
          if (filteredMetrics && filteredMetrics.rows && filteredMetrics.rows.length > 0) {
            debugLog(` Calculating behaviour for ${filteredMetrics.rows.length} filtered rows`, 'info');
            filteredBehaviour = window.computeMoneyPagesBehaviour ? 
              window.computeMoneyPagesBehaviour(queryPages, filteredMetrics.rows, true) : null;
            debugLog(` Calculated behaviour: ${!!filteredBehaviour}, impressions: ${filteredBehaviour?.impressions || 0}`, 'info');
          } else {
            debugLog(` No filtered metrics or rows available`, 'warn');
          }
        }

        // Fallback #2: compute from page-level aggregates when queryPages is missing/truncated
        if ((!filteredBehaviour || !filteredBehaviour.impressions) && moneyPagesMetrics) {
          const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
          if (filteredMetrics && Array.isArray(filteredMetrics.rows) && filteredMetrics.rows.length > 0) {
            const aggFn = window.computeMoneyPagesBehaviourFromPageAggregates;
            const aggBehaviour = typeof aggFn === 'function' ? aggFn(filteredMetrics.rows) : null;
            if (aggBehaviour && aggBehaviour.impressions) {
              filteredBehaviour = aggBehaviour;
              debugLog(` Fallback behaviour (page aggregates): impressions=${aggBehaviour.impressions}, clicks=${aggBehaviour.clicks}`, 'info');
            }
          }
        }

        if (!scoreEl) {
          debugLog(`  scoreEl not found in DOM`, 'warn');
          return;
        }

        if (!filteredBehaviour || !filteredBehaviour.impressions) {
          debugLog(`  No valid behaviour data: filteredBehaviour=${!!filteredBehaviour}, impressions=${filteredBehaviour?.impressions || 0}`, 'warn');
          if (scoreEl) scoreEl.textContent = 'N/A';
          if (statusEl) statusEl.textContent = 'Not enough data for money pages in this window.';
          if (ctrEl) ctrEl.textContent = '';
          if (top10El) top10El.textContent = '';
          if (cardEl) {
            cardEl.classList.remove('status-green', 'status-amber', 'status-red');
            cardEl.style.borderLeft = '';
            cardEl.style.background = '';
          }
          return;
        }

        const score = Math.round(filteredBehaviour.score);
        const ctrPct = (filteredBehaviour.siteCtr * 100);
        const top10Pct = (filteredBehaviour.top10Ctr * 100);

        scoreEl.textContent = `${score}/100`;
        ctrEl.textContent = `${ctrPct.toFixed(1)}%`;
        top10El.textContent = `${top10Pct.toFixed(2)}%`;

        let label, ragClass;
        if (score >= 70) { 
          label = 'Good  money pages aren\'t holding Authority back.'; 
          ragClass = 'status-green'; 
        } else if (score >= 40) { 
          label = 'Amber  money pages behaviour is the main Authority constraint.'; 
          ragClass = 'status-amber'; 
        } else { 
          label = 'Red  poor CTR on money pages is strongly dragging Authority down.'; 
          ragClass = 'status-red'; 
        }

        if (statusEl) statusEl.textContent = label;
        if (cardEl) {
          cardEl.classList.remove('status-green', 'status-amber', 'status-red');
          cardEl.classList.add(ragClass);
          // Apply RAG colors
          if (ragClass === 'status-green') {
            cardEl.style.borderLeft = '3px solid #10b981';
            cardEl.style.background = '#f0fdf4';
          } else if (ragClass === 'status-amber') {
            cardEl.style.borderLeft = '3px solid #f59e0b';
            cardEl.style.background = '#fffbeb';
          } else {
            cardEl.style.borderLeft = '3px solid #ef4444';
            cardEl.style.background = '#fef2f2';
          }
        }
      }

      // Create Top Pages section (full width, below pillar cards)
      createTopPagesSection(scores, saved);
      
      // Create Money Pages Performance section (right after Top Pages section)
      // Use setTimeout to ensure Top Pages section is inserted first
      setTimeout(() => {
        // IMPORTANT: Do NOT rebuild/overwrite the Money Pages HTML here.
        // That caused the top-level filter to "flip" a few seconds later (dropdown replaced),
        // removed the Suggested Top 10 container, and orphaned KPI elements (tiles reverting to ).
        // The canonical builder is `renderMoneyPagesSection()`.
        if (typeof renderMoneyPagesSection === 'function') {
          debugLog(' Money Pages: using renderMoneyPagesSection() (skip legacy HTML builder)', 'info');
        }
        
        // Always render money pages section (will show "No data" if empty)
        // Get Money Pages metrics - prioritize passed scores, then saved data, then global
        let moneyPagesMetricsToRender = scores.moneyPagesMetrics || window.currentMoneyPagesMetrics || window.moneyPagesMetrics;
        
        if (!moneyPagesMetricsToRender && saved) {
          // Try multiple locations in saved data
          if (saved.scores && saved.scores.moneyPagesMetrics) {
            debugLog('Money Pages: Loading from saved.scores.moneyPagesMetrics', 'info');
          moneyPagesMetricsToRender = saved.scores.moneyPagesMetrics;
            scores.moneyPagesMetrics = moneyPagesMetricsToRender;
          } else if (saved.moneyPagesMetrics) {
            debugLog('Money Pages: Loading from saved.moneyPagesMetrics', 'info');
            moneyPagesMetricsToRender = saved.moneyPagesMetrics;
          scores.moneyPagesMetrics = moneyPagesMetricsToRender;
          }
        }
        
        // Store globally for other functions
        if (moneyPagesMetricsToRender) {
          window.currentMoneyPagesMetrics = moneyPagesMetricsToRender;
          window.moneyPagesMetrics = moneyPagesMetricsToRender;
          debugLog(` Money Pages metrics stored globally: ${moneyPagesMetricsToRender.rows?.length || 0} rows`, 'success');
        }
        
        debugLog(`Money Pages Metrics available: ${moneyPagesMetricsToRender ? 'yes' : 'no'}`, 'info');
        if (moneyPagesMetricsToRender) {
          debugLog(`Money Pages: Rendering ${moneyPagesMetricsToRender.rows?.length || 0} money pages`, 'info');
          if (moneyPagesMetricsToRender.rows && moneyPagesMetricsToRender.rows.length > 0) {
            debugLog(`Money Pages: First row sample: ${JSON.stringify(moneyPagesMetricsToRender.rows[0]).substring(0, 100)}...`, 'info');
          } else {
            debugLog(' Money Pages: moneyPagesMetrics exists but has no rows', 'warn');
          }
        } else {
          debugLog(' Money Pages: No metrics data available, will show "No data" message', 'warn');
          debugLog(`Money Pages: scores.moneyPagesMetrics=${!!scores.moneyPagesMetrics}, saved.scores.moneyPagesMetrics=${!!(saved && saved.scores && saved.scores.moneyPagesMetrics)}, saved.moneyPagesMetrics=${!!(saved && saved.moneyPagesMetrics)}`, 'warn');
        }
        
        // Ensure the Money Pages panel exists, then render the section.
        // IMPORTANT: `renderMoneyPagesSection()` is responsible for creating `#money-pages-section`
        // and the container IDs (top-level filter, charts, suggested top10, KPI selector).
        const ensureMoneyPagesRendered = (attempt = 0) => {
          const moneyPanel = document.querySelector('.aigeo-panel[data-panel="money"]');
          if (!moneyPanel) {
            if (attempt < 20) {
              debugLog(` Money Pages panel not ready yet (attempt ${attempt + 1})`, 'warn');
              setTimeout(() => ensureMoneyPagesRendered(attempt + 1), 100);
            } else {
              debugLog(' Money Pages panel not found after retries - cannot render Money Pages section', 'error');
            }
            return;
          }

          (async () => {
            await renderMoneyPagesSection(moneyPagesMetricsToRender || null);

            // Wire the top-level filter AFTER the section HTML exists.
            if (typeof window.wireTopLevelFilter === 'function') {
              window.wireTopLevelFilter();
            }

            // Wire KPI metric selector AFTER the section HTML exists.
            if (typeof window.wireMoneyKpiMetricSelector === 'function') {
              window.wireMoneyKpiMetricSelector();
            }

            // Now that the Money Pages DOM exists, initialize dependent sections (Priority table, KPI tracker, etc).
            if (typeof window.__initMoneyPagesPanelAfterRender === 'function') {
              window.__initMoneyPagesPanelAfterRender();
            }
          })();
        };

        ensureMoneyPagesRendered(0);
        
        // Define a post-render initializer that must only run after `renderMoneyPagesSection()`
        // has created the Money Pages DOM (tables/canvases/selectors).
        // It is invoked from inside `ensureMoneyPagesRendered()` after the section render completes.
        window.__initMoneyPagesPanelAfterRender = function __initMoneyPagesPanelAfterRender() {
        // Phase: Render Money Pages Priority Matrix & Action List
        const priorityCard = document.getElementById('money-pages-priority-card');
        if (priorityCard) {
          if (window.moneyPagePriorityData && Array.isArray(window.moneyPagePriorityData) && window.moneyPagePriorityData.length > 0) {
            priorityCard.style.display = 'block';
            
            // Initialize state for matrix filter
            window.moneyMatrixFilterState = window.moneyMatrixFilterState || { impact: null, diff: null };

            // Domain-level authority actions (read-only; from Supabase domain_strength_snapshots via /api/actions)
            window.authorityActionRows = window.authorityActionRows || [];
            if (typeof window.refreshAuthorityActionsForMoneyPages !== 'function') {
              window.refreshAuthorityActionsForMoneyPages = async function refreshAuthorityActionsForMoneyPages() {
                try {
                  const resp = await fetch('/api/actions');
                  const json = await resp.json();
                  const actions = resp.ok && json && json.status === 'ok' && Array.isArray(json.actions) ? json.actions : [];

                  const toUpperLevel = (v, fallback) => {
                    const s = String(v || '').toUpperCase();
                    return s === 'HIGH' || s === 'MEDIUM' || s === 'LOW' ? s : fallback;
                  };

                  window.authorityActionRows = actions
                    .filter(a => a && a.type === 'authority' && a.level === 'domain' && a.domain)
                    .map(a => ({
                      url: `https://${String(a.domain).replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0]}`,
                      title: a.title || 'Build domain authority',
                      segmentType: 'authority',
                      clicks: 0,
                      impressions: 0,
                      ctr: 0,
                      avgPosition: null,
                      impactLevel: toUpperLevel(a.impact, 'LOW'),
                      difficultyLevel: toUpperLevel(a.difficulty, 'HIGH'),
                      priorityLevel: toUpperLevel(a.priority, 'LOW'),
                      _authorityMeta: {
                        domain: a.domain,
                        segment: a.segment || null,
                        score: a.metrics && typeof a.metrics.domainStrengthScore === 'number' ? a.metrics.domainStrengthScore : null,
                        band: a.metrics && typeof a.metrics.domainStrengthBand === 'string' ? a.metrics.domainStrengthBand : null
                      }
                    }));
                } catch (e) {
                  // Non-fatal: keep existing authorityActionRows (or empty).
                  window.authorityActionRows = window.authorityActionRows || [];
                }
              };
            }
            
            // Helper function to get filtered pages based on current filters (defined before use)
            const getFilteredPages = () => {
              const typeFilter = document.getElementById('money-pages-type-filter')?.value || 'all';
              const minImpr = Number(document.getElementById('money-pages-min-impr')?.value) || 0;
              
              const base = (window.moneyPagePriorityData || []).slice();
              const authority = (window.authorityActionRows || []).slice();
              let filtered = base.concat(authority);
              
              // Apply type filter
              if (typeFilter !== 'all') {
                filtered = filtered.filter(p => p.segmentType === typeFilter);
              }
              
              // Apply min impressions filter
              filtered = filtered.filter(p => p.segmentType === 'authority' || (p.impressions || 0) >= minImpr);
              
              return filtered;
            };
            
            // Helper function to update summary strip, matrix, and table
            const updateMatrixAndTable = async () => {
              const typeFilter = document.getElementById('money-pages-type-filter')?.value || 'all';
              const minImpr = Number(document.getElementById('money-pages-min-impr')?.value) || 0;
              
              // Get base data for counting (before type filter, but after min impressions)
              const base = (window.moneyPagePriorityData || []).slice();
              const authority = (window.authorityActionRows || []).slice();
              const allRows = base.concat(authority);
              
              // Apply min impressions filter for counting (but not type filter)
              const pagesForCounting = allRows.filter(p => p.segmentType === 'authority' || (p.impressions || 0) >= minImpr);
              
              // Update dropdown counts with filtered data (after min impressions, before type filter)
              updateMoneyPagesTypeFilterCounts(pagesForCounting);
              
              // Now get fully filtered pages (with type filter applied)
              const filteredPages = getFilteredPages();
              
              debugLog(`Money Pages Update: Filtered to ${filteredPages.length} pages (type: ${typeFilter}, minImpr: ${minImpr})`, 'info');
              
              // Reset pagination to page 1 when filters change
              window.moneyPagesPriorityCurrentPage = 1;
              
              // Re-render summary strip with filtered pages
              const pagesOnly = filteredPages.filter(p => p.segmentType !== 'authority');
              const summaryStrip = document.getElementById('money-pages-summary-strip');
              if (summaryStrip && typeof renderMoneyPagesSummaryStrip === 'function') {
                renderMoneyPagesSummaryStrip(pagesOnly, data || {}, summaryStrip);
              }
              
              // Re-render matrix with filtered pages
              const matrixEl = document.getElementById('money-pages-matrix');
              if (matrixEl && typeof renderMoneyPagesMatrix === 'function') {
                const handleMatrixCellClick = async (impact, diff) => {
                  // Toggle filter: if clicking the same cell, clear the filter
                  const currentFilter = window.moneyMatrixFilterState;
                  if (currentFilter && currentFilter.impact === impact && currentFilter.diff === diff) {
                    // Same cell clicked - clear filter
                    window.moneyMatrixFilterState = null;
                    debugLog(`Money Pages Matrix: Cell clicked again - clearing filter`, 'info');
                  } else {
                    // Different cell clicked - set new filter
                    window.moneyMatrixFilterState = { impact, diff };
                    debugLog(`Money Pages Matrix: Cell clicked - Impact: ${impact}, Difficulty: ${diff}`, 'info');
                  }
                  window.moneyPagesPriorityCurrentPage = 1; // Reset pagination when matrix cell clicked
                    // Re-render matrix to show active state
                    await updateMatrixAndTable();
                };
                
                renderMoneyPagesMatrix(
                  pagesOnly,
                  matrixEl,
                  handleMatrixCellClick,
                  window.moneyMatrixFilterState && window.moneyMatrixFilterState.impact && window.moneyMatrixFilterState.diff
                    ? window.moneyMatrixFilterState
                    : null
                );
              }
              
              // Store filter state globally for pagination
              window.moneyPagesTypeFilter = typeFilter;
              window.moneyPagesMinImpr = minImpr;
              window.moneyPagesMatrixFilter = window.moneyMatrixFilterState;
              
              // Re-render Priority & Actions table (NOT the opportunity table renderer)
              if (typeof window.renderMoneyPagesPriorityTable === 'function') {
                console.log('[Money Pages Priority] updateMatrixAndTable: Re-rendering Priority & Actions table');
                await window.renderMoneyPagesPriorityTable(filteredPages, {
                  typeFilter: typeFilter,
                  minImpr: minImpr,
                  matrixFilter: window.moneyMatrixFilterState
                });
              }
            };
            
            // Render summary strip
            const summaryStrip = document.getElementById('money-pages-summary-strip');
            if (summaryStrip) {
              renderMoneyPagesSummaryStrip(window.moneyPagePriorityData, data || {}, summaryStrip);
            }
            
            // Render matrix initially
            const matrixEl = document.getElementById('money-pages-matrix');
            if (matrixEl && typeof renderMoneyPagesMatrix === 'function') {
              renderMoneyPagesMatrix(
                window.moneyPagePriorityData,
                matrixEl,
                async (impact, diff) => {
                  window.moneyMatrixFilterState = { impact, diff };
                  debugLog(`Money Pages Matrix: Cell clicked - Impact: ${impact}, Difficulty: ${diff}`, 'info');
                  await updateMatrixAndTable();
                },
                null // No active filter initially
              );
            }
            
            // Initialize filter state
            window.moneyPagesTypeFilter = 'all';
            window.moneyPagesMinImpr = 0;
            window.moneyPagesMatrixFilter = null;
            
            // Render initial Priority & Actions table
            if (typeof window.renderMoneyPagesPriorityTable === 'function') {
              (async () => {
                await window.renderMoneyPagesPriorityTable(window.moneyPagePriorityData, {
                  typeFilter: 'all',
                  minImpr: 0,
                  matrixFilter: null
                });
                console.log('[Money Pages Priority]  Initial Priority & Actions table rendered');
              })();
            }

            // Render Suggested (Top 10) cards once Money Pages DOM exists.
            if (typeof window.renderMoneyPagesSuggestedTop10 === 'function') {
              window.renderMoneyPagesSuggestedTop10();
            }

            // Load authority actions async and refresh table (non-blocking).
            window.refreshAuthorityActionsForMoneyPages()
              .then(async () => {
                await updateMatrixAndTable();
              })
              .catch(() => {
                // ignore
              });
            
            // Wire up filter controls (functions already defined above)
            const typeFilter = document.getElementById('money-pages-type-filter');
            const minImprFilter = document.getElementById('money-pages-min-impr');
            
            if (typeFilter) {
              typeFilter.addEventListener('change', () => {
                const selectedType = typeFilter.value;
                debugLog(`Money Pages Filter: Type changed to "${selectedType}"`, 'info');
                // Store filter state globally for pagination
                window.moneyPagesTypeFilter = selectedType;
                // Clear matrix filter when type filter changes
                window.moneyMatrixFilterState = { impact: null, diff: null };
                window.moneyPagesMatrixFilter = null;
                (async () => {
                  await updateMatrixAndTable();
                })();
              });
            }
            
            if (minImprFilter) {
              minImprFilter.addEventListener('change', () => {
                const minImpr = Number(minImprFilter.value) || 0;
                debugLog(`Money Pages Filter: Min impressions changed to ${minImpr}`, 'info');
                // Store filter state globally for pagination
                window.moneyPagesMinImpr = minImpr;
                // Clear matrix filter when min impressions filter changes
                window.moneyMatrixFilterState = { impact: null, diff: null };
                window.moneyPagesMatrixFilter = null;
                (async () => {
                  await updateMatrixAndTable();
                })();
              });
            }
          } else {
            // Show card but with "no data" message
            priorityCard.style.display = 'block';
            const summaryStrip = document.getElementById('money-pages-summary-strip');
            if (summaryStrip) {
              summaryStrip.innerHTML = '<div style="padding: 1rem; text-align: center; color: #64748b;">No money pages data available. Run an audit to generate priority matrix data.</div>';
            }
            const matrixEl = document.getElementById('money-pages-matrix');
            if (matrixEl) {
              matrixEl.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b;">No data available</div>';
            }
            const tbody = document.querySelector('#money-pages-priority-table tbody');
            if (tbody) {
              tbody.innerHTML = '<tr><td colspan="9" style="padding: 2rem; text-align: center; color: #64748b;">No money pages data available. Run an audit to generate priority matrix data.</td></tr>';
            }
            debugLog(' Money Pages Priority Matrix: No data available', 'warn');
          }
        }
        
        // Phase: Load and render 12-month KPI Tracker
        const propertyUrl = document.getElementById('propertyUrl')?.value || localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url');
        if (propertyUrl) {
          window.loadAuditHistoryAndRenderKpis(propertyUrl);
          
          // Wire up metric selector
          const metricSelect = document.getElementById('money-kpi-metric-select');
          if (metricSelect) {
            metricSelect.addEventListener('change', (e) => {
              const metricKey = e.target.value;
              if (cachedAuditHistory) {
                // Reload full history with timeseries when metric changes
                const propertyUrl = document.getElementById('propertyUrl')?.value;
                if (propertyUrl) {
                  window.loadAuditHistoryAndRenderKpis(propertyUrl);
                } else {
                  // Fallback: use cached data but still need timeseries
                  debugLog(' Metric selector: No propertyUrl available, cannot reload timeseries', 'warn');
                }
              }
            });
          }
        }
        
        // Store queryPages globally for filtering
        // Use data parameter (searchData) first, then fallback to saved data
        if (data && data.queryPages) {
          window.currentQueryPages = data.queryPages;
        } else if (saved && saved.searchData && saved.searchData.queryPages) {
          window.currentQueryPages = saved.searchData.queryPages;
        }
        // Render behaviour KPIs and chart after a delay to ensure DOM and Chart.js are ready
        // Apply filters and update all sections with filtered data
        if (moneyPagesMetricsToRender) {
          setTimeout(() => {
            const queryPages = window.currentQueryPages || null;
            const moneyPagesMetrics = moneyPagesMetricsToRender;
            
            // Use saved behaviour data if available (from Supabase/localStorage)
            let savedBehaviour = null;
            if (moneyPagesMetrics && moneyPagesMetrics.behaviour) {
              savedBehaviour = moneyPagesMetrics.behaviour;
              debugLog(` Using saved behaviour data: score=${savedBehaviour.score}, impressions=${savedBehaviour.impressions}`, 'info');
            }
            
            // Get filtered metrics based on current filters (defaults to 'ALL' on initial load)
            const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
            if (filteredMetrics) {
              // Try to recalculate behaviour for filtered pages, but use saved if calculation fails
              const filteredRows = filteredMetrics.rows || [];
              let filteredBehaviour = null;
              
              if (window.computeMoneyPagesBehaviour && queryPages && filteredRows.length > 0) {
                filteredBehaviour = window.computeMoneyPagesBehaviour(queryPages, filteredRows, true);
                debugLog(` Recalculated behaviour for filtered pages: ${!!filteredBehaviour}, impressions=${filteredBehaviour?.impressions || 0}`, 'info');
              }
              
              // Use saved behaviour as fallback if recalculation failed or returned no data
              if (!filteredBehaviour || !filteredBehaviour.impressions) {
                if (savedBehaviour && savedBehaviour.impressions) {
                  debugLog(` Using saved behaviour as fallback (recalculation had no data)`, 'info');
                  filteredBehaviour = savedBehaviour;
                }
              }
              
              // Update all sections with filtered data
              renderMoneyPagesBehaviourKpis(filteredBehaviour, filteredMetrics, queryPages);
              updateMoneyPagesSummaryMetrics(moneyPagesMetrics); // Pass original metrics so function can apply filters internally
              updateMoneyPagesChartSummary(filteredMetrics);
              
              // Render chart with filtered data
              // Always re-render chart to ensure it uses current filters
                renderMoneyPagesCategoryChart(moneyPagesMetrics, 0);
            } else {
              // Fallback: render with unfiltered data if filtering fails
              renderMoneyPagesBehaviourKpis(savedBehaviour || moneyPagesMetrics.behaviour, moneyPagesMetrics, queryPages);
              if (!moneyPagesCategoryChart) {
                renderMoneyPagesCategoryChart(moneyPagesMetrics, 0);
              }
            }
          }, 200);
        }
        };
      }, 100);
      
      // Remove existing scorecard table if it exists
      const existingScorecard = pillarCards.parentNode.querySelector('.scorecard-section');
      if (existingScorecard) {
        existingScorecard.remove();
      }
      
      // Function to render segment comparison table (shared by both createTopPagesSection functions)
      function renderSegmentComparisonTable(authorityBySegment, currentMode) {
        const segments = [
          { key: 'all', label: 'All pages', data: authorityBySegment.all },
          { key: 'nonEducation', label: 'Exclude education (blogs / free course)', data: authorityBySegment.nonEducation },
          { key: 'money', label: 'Money pages only', data: authorityBySegment.money }
        ];
        
        let tableHtml = `
          <div style="margin-bottom: 0.5rem;">
            <h4 style="margin: 0 0 0.5rem 0; font-size: 1.15rem; font-weight: 700; color: #1e293b;">Segment overview (CTR & ranking)</h4>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.95rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Segment</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Site CTR</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Top-10 CTR</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Avg pos.</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Top-10 share</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Behaviour</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Ranking</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        segments.forEach(({ key, label, data }, idx) => {
          const isActive = key === currentMode;
          const siteCtr = data?.siteCtr || 0;
          const top10Ctr = data?.top10Ctr || 0;
          const avgPosition = data?.avgPosition || 0;
          const top10Share = (data?.top10Share || 0) * 100;
          const behaviourScore = data?.behaviour || 0;
          const rankingScore = data?.ranking || 0;
          
          tableHtml += `
            <tr 
              onclick="window.currentAuthorityMode = '${key}'; if(window.updateTopPagesSection) window.updateTopPagesSection('${key}');"
              style="
                cursor: pointer;
                border-bottom: 1px solid #f1f5f9;
                background: ${isActive ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : (idx % 2 === 0 ? '#ffffff' : '#fafafa')};
                transition: all 0.2s;
              "
              onmouseover="this.style.background='${isActive ? 'linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%)' : '#f8f9fa'}';"
              onmouseout="this.style.background='${isActive ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : (idx % 2 === 0 ? '#ffffff' : '#fafafa')}';"
            >
              <td style="padding: 0.75rem 1rem; font-weight: ${isActive ? '600' : '500'}; color: #0f172a; font-size: 0.95rem;">
                ${label}
                ${isActive ? '<span style="margin-left: 0.5rem; font-size: 0.8rem; padding: 0.15rem 0.5rem; border-radius: 999px; background: #10b981; color: white; font-weight: 600;">current</span>' : ''}
              </td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${siteCtr != null ? siteCtr.toFixed(1) : 'N/A'}%</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${top10Ctr != null ? top10Ctr.toFixed(1) : 'N/A'}%</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${avgPosition != null ? avgPosition.toFixed(1) : 'N/A'}</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${top10Share != null ? top10Share.toFixed(1) : 'N/A'}%</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 0.95rem;">${behaviourScore != null ? Math.round(behaviourScore) : 'N/A'}</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 0.95rem;">${rankingScore != null ? Math.round(rankingScore) : 'N/A'}</td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        return tableHtml;
      }

      // NOTE: Duplicate populateMoneyPagesAiCitations function removed - using the one at line ~30217 that takes 'rows' parameter
      
      // Function to create Top Pages section (full width, below pillar cards)
      function createTopPagesSection(scores, saved) {
        // Get Authority segment data from current scores (latest snapshot, not historical)
        // This uses the most recent audit data, not historical Supabase data
        const authorityObj = scores?.authority;
        let authorityBySegment = (typeof authorityObj === 'object' && authorityObj !== null) 
          ? authorityObj.bySegment 
          : null;
        
        // If no segment data in scores, try to get from saved audit (latest audit data from localStorage)
        if (!authorityBySegment && saved) {
          const savedScores = saved.scores;
          if (savedScores && savedScores.authority) {
            const savedAuthorityObj = savedScores.authority;
            if (typeof savedAuthorityObj === 'object' && savedAuthorityObj !== null) {
              authorityBySegment = savedAuthorityObj.bySegment || null;
              debugLog(' Top Pages: Using Authority segment data from saved audit (latest snapshot)', 'info');
            }
          }
        }
        
        if (!authorityBySegment) {
          debugLog(' No Authority segment data available for Top Pages table. This requires GSC queryPages data from your most recent audit.', 'warn');
          // Still create the section but show a helpful message - don't return early
        }
        
        // Remove existing top pages section if it exists
        const existingTopPages = document.getElementById('authority-top-pages-section');
        if (existingTopPages) {
          existingTopPages.remove();
        }
        
        // Create new section
        const topPagesSection = document.createElement('div');
        topPagesSection.id = 'authority-top-pages-section';
        topPagesSection.className = 'section-break';
        topPagesSection.style.marginTop = '2rem';
        topPagesSection.style.marginBottom = '2rem';
        
        // Get current mode from Authority card toggle (default to 'all')
        let currentMode = 'all';
        const authorityCard = Array.from(document.querySelectorAll('.pillar-card')).find(card => {
          const h3 = card.querySelector('h3');
          return h3 && h3.textContent === 'Authority';
        });
        
        if (authorityCard && authorityCard._authorityMode) {
          currentMode = authorityCard._authorityMode;
        }
        
        // Get top pages for current mode
        const topPages = currentMode === 'all'
          ? (authorityBySegment?.all?.topPages || [])
          : currentMode === 'nonEducation'
          ? (authorityBySegment?.nonEducation?.topPages || [])
          : (authorityBySegment?.money?.topPages || []);
        
        const segmentLabel = currentMode === 'all'
          ? 'All pages'
          : currentMode === 'nonEducation'
          ? 'Exclude education (blogs / free course)'
          : 'Money pages only';
        
        // Get segment metrics for summary display
        const getSegmentSummary = (mode) => {
          if (!authorityBySegment || !authorityBySegment[mode]) return null;
          const segmentData = authorityBySegment[mode];
          return {
            behaviour: segmentData.behaviour || 0,
            ranking: segmentData.ranking || 0,
            total: segmentData.total || segmentData.score || 0
          };
        };
        
        const currentSummary = getSegmentSummary(currentMode);
        const rag = currentSummary ? getRAGStatus(currentSummary.total) : { status: 'amber', label: 'N/A' };
        
        // Get date range for display
        const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
        const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
        
        // Get brand queries for mini-table
        const topQueries = saved?.searchData?.topQueries || [];
        const brandQueries = topQueries
          .filter(q => isBrandQuery(q.query || ''))
          .sort((a, b) => (b.impressions || 0) - (a.impressions || 0))
          .slice(0, 10);
        
        // Create section HTML with improved styling and pastel background
        topPagesSection.innerHTML = `
          <div style="background: #F5F0F5; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border-left: 4px solid #99004C;">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem;">
              <div style="flex: 1;">
                <h3 style="margin: 0 0 0.5rem 0; color: var(--brand-dark); font-size: 1.25rem; font-weight: 700;">Authority - Behaviour & Ranking</h3>
                <div style="margin-bottom: 1rem; padding: 1rem; background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-radius: 6px; font-size: 0.85rem; line-height: 1.6; color: #555; border-left: 3px solid #99004C;">
                  <p style="margin: 0 0 0.75rem 0;"><strong style="color: #99004C;">Behaviour:</strong> Measures click-through rate (CTR) performance. Combines Overall CTR (50% weight) for all ranking search terms and Top-10 Ranked Search Terms CTR (50% weight) for queries ranking in positions 1-10. Indicates how well your titles and descriptions convert impressions to clicks. Data source: Google Search Console query+page metrics.</p>
                  <p style="margin: 0;"><strong style="color: #99004C;">Ranking:</strong> Measures search visibility and position quality. Combines Average Position Score (50% weight) and Top-10 Impression Share (50% weight). Shows how high you rank on average and what percentage of impressions appear in positions 1-10. Data source: Google Search Console query+page metrics.</p>
                </div>
              </div>
            </div>
            
            ${currentSummary ? `
            <div style="margin-bottom: 1rem; padding: 1rem; background: rgba(221, 160, 221, 0.2); border-radius: 6px; border: 1px solid #e2e8f0;">
              <div style="text-align: center; margin-bottom: 0.75rem;">
                <span style="font-weight: 600; color: #333; font-size: 1.08rem;">Segment Summary: </span>
                <span id="top-pages-segment-label" style="color: #666; font-size: 0.85rem; padding: 0.25rem 0.75rem; background: #f1f5f9; border-radius: 4px;">${segmentLabel}</span>
              </div>
              <div style="display: flex; justify-content: center; align-items: center; gap: 1.5rem; flex-wrap: wrap;">
                <div id="top-pages-segment-summary" style="display: flex; align-items: center; gap: 1.5rem; font-size: 1rem;">
                  ${formatComponentScore('Behaviour', currentSummary.behaviour)}
                  ${formatComponentScore('Ranking', currentSummary.ranking)}
                </div>
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                  <span style="font-size: 1.5rem; font-weight: 700; color: ${rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444'};">${Math.round(currentSummary.total)}</span>
                  <span class="rag-badge ${rag.status}" style="display: inline-block; padding: 0.35rem 0.85rem; border-radius: 4px; font-size: 0.85rem; font-weight: 600;">${rag.label}</span>
                </div>
              </div>
            </div>
            ` : `
            <div style="margin-bottom: 1rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem;">
              <span style="font-weight: 600; color: #666;">Current Segment:</span>
              <span id="top-pages-segment-label" style="color: #333; margin-left: 0.5rem;">${segmentLabel}</span>
            </div>
            `}
            
            ${authorityBySegment ? `
            <div style="margin-bottom: 1rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem;">
              <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                <span style="font-weight: 600; color: #666;">View:</span>
                <button id="top-pages-mode-all" class="authority-mode-btn" data-mode="all" style="padding: 0.35rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: ${currentMode === 'all' ? '#10b981' : 'white'}; color: ${currentMode === 'all' ? 'white' : '#666'}; cursor: pointer; font-size: 0.75rem; font-weight: ${currentMode === 'all' ? '600' : '400'}; transition: all 0.2s;">
                  All pages
                </button>
                <button id="top-pages-mode-nonEducation" class="authority-mode-btn" data-mode="nonEducation" style="padding: 0.35rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: ${currentMode === 'nonEducation' ? '#10b981' : 'white'}; color: ${currentMode === 'nonEducation' ? 'white' : '#666'}; cursor: pointer; font-size: 0.75rem; font-weight: ${currentMode === 'nonEducation' ? '600' : '400'}; transition: all 0.2s;">
                  Exclude education
                </button>
                <button id="top-pages-mode-money" class="authority-mode-btn" data-mode="money" style="padding: 0.35rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: ${currentMode === 'money' ? '#10b981' : 'white'}; color: ${currentMode === 'money' ? 'white' : '#666'}; cursor: pointer; font-size: 0.75rem; font-weight: ${currentMode === 'money' ? '600' : '400'}; transition: all 0.2s;">
                  Money pages only
                </button>
              </div>
            </div>
            ` : ''}
            
            ${authorityBySegment ? `
            <div id="top-pages-comparison-table" style="margin-bottom: 1.5rem;">
              ${renderSegmentComparisonTable(authorityBySegment, currentMode)}
            </div>
            ` : ''}
            
            <div id="top-pages-table-container">
              ${renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText)}
            </div>
            
            ${authorityBySegment && authorityBySegment[currentMode] ? `
            <div id="top-pages-recommendations-container" style="margin-top: 2rem;">
              ${renderRecommendationsTable(currentMode, {
                siteCtr: authorityBySegment[currentMode].siteCtr || 0,
                top10Ctr: authorityBySegment[currentMode].top10Ctr || 0,
                avgPosition: authorityBySegment[currentMode].avgPosition || 0,
                top10Share: authorityBySegment[currentMode].top10Share || 0,
                behaviourScore: authorityBySegment[currentMode].behaviour || 0,
                rankingScore: authorityBySegment[currentMode].ranking || 0
              }, segmentLabel, dateRangeText)}
            </div>
            ` : ''}
            
            ${brandQueries.length > 0 ? `
            <div style="margin-top: 2rem; padding: 1rem; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #f59e0b;">
              <h4 style="margin: 0 0 0.75rem 0; color: #92400e; font-size: 1rem; font-weight: 600;">Top Branded Queries</h4>
              <p style="margin: 0 0 1rem 0; font-size: 0.85rem; color: #666; line-height: 1.5;">Branded search queries (e.g., "Alan Ranger Photography") with CTR and position metrics.</p>
              <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                  <thead>
                    <tr style="background: #e5e7eb; border-bottom: 2px solid #d1d5db;">
                      <th style="padding: 0.5rem; text-align: left; font-weight: 600; color: #374151;">Query</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Impressions</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Clicks</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">CTR</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Position</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${brandQueries.map((q, idx) => {
                      const ctr = q.impressions > 0 ? ((q.clicks || 0) / q.impressions * 100) : 0;
                      const ctrColor = ctr >= 25 ? '#10b981' : ctr >= 10 ? '#f59e0b' : '#ef4444';
                      const posColor = (q.position || 0) <= 3 ? '#10b981' : (q.position || 0) <= 5 ? '#f59e0b' : '#ef4444';
                      return `
                      <tr style="border-bottom: 1px solid #e5e7eb; ${idx % 2 === 0 ? 'background: #ffffff;' : 'background: #f9fafb;'}">
                        <td style="padding: 0.5rem; color: #1f2937; font-weight: 500;">${(q.query || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</td>
                        <td style="padding: 0.5rem; text-align: right; color: #6b7280;">${(q.impressions || 0).toLocaleString()}</td>
                        <td style="padding: 0.5rem; text-align: right; color: #6b7280;">${(q.clicks || 0).toLocaleString()}</td>
                        <td style="padding: 0.5rem; text-align: right; color: ${ctrColor}; font-weight: 600;">${ctr.toFixed(1)}%</td>
                        <td style="padding: 0.5rem; text-align: right; color: ${posColor}; font-weight: 600;">${(q.position || 0).toFixed(1)}</td>
                      </tr>
                    `;
                    }).join('')}
                  </tbody>
                </table>
              </div>
            </div>
            ` : ''}
          </div>
        `;
        
        // Insert into Authority panel instead of Overview
        const authorityPanel = document.querySelector('.aigeo-panel[data-panel="authority"]');
        if (authorityPanel) {
          // Clear any existing content
          const existing = document.getElementById('authority-top-pages-section');
          if (existing) existing.remove();
          authorityPanel.appendChild(topPagesSection);
          debugLog(' Authority section inserted into Authority panel', 'success');
        } else {
          // Fallback: insert after pillar cards (old behavior)
        pillarCards.parentNode.insertBefore(topPagesSection, pillarCards.nextSibling);
          debugLog(' Authority section inserted after pillar cards (fallback)', 'info');
        }
        
        // Store authorityBySegment globally so updateTopPagesSection can access it
        window.authorityBySegment = authorityBySegment;
        
        // Attach toggle button handlers
        setTimeout(() => {
          ['all', 'nonEducation', 'money'].forEach(mode => {
            const btn = document.getElementById(`top-pages-mode-${mode}`);
            if (btn) {
              // Remove existing listeners by cloning
              const newBtn = btn.cloneNode(true);
              btn.parentNode.replaceChild(newBtn, btn);
              
              newBtn.addEventListener('click', () => {
                window.currentAuthorityMode = mode;
                if (window.updateTopPagesSection) {
                  window.updateTopPagesSection(mode);
                }
                // Also update Authority pillar card if it exists
                const authorityCard = Array.from(document.querySelectorAll('.pillar-card')).find(card => {
                  const h3 = card.querySelector('h3');
                  return h3 && h3.textContent === 'Authority';
                });
                if (authorityCard && authorityCard._updateAuthorityDisplay) {
                  authorityCard._authorityMode = mode;
                  authorityCard._updateAuthorityDisplay();
                  // Update Authority pillar toggle buttons
                  const modeId = authorityCard._modeId;
                  ['all', 'nonEducation', 'money'].forEach(m => {
                    const authBtn = document.getElementById(`${modeId}-${m}`);
                    if (authBtn) {
                      if (m === mode) {
                        authBtn.style.background = '#10b981';
                        authBtn.style.color = 'white';
                      } else {
                        authBtn.style.background = 'white';
                        authBtn.style.color = '#666';
                      }
                    }
                  });
                }
              });
            }
          });
        }, 100);
        
        // Store update function globally so Authority mode toggle can call it
        window.updateTopPagesSection = function(mode) {
          // Get fresh authorityBySegment from global or try to get from current scores
          let segData = window.authorityBySegment;
          if (!segData) {
            // Try to get from current scores
            const authorityObj = scores?.authority;
            segData = (typeof authorityObj === 'object' && authorityObj !== null) 
              ? authorityObj.bySegment 
              : null;
          }
          
          const topPages = mode === 'all'
            ? (segData?.all?.topPages || [])
            : mode === 'nonEducation'
            ? (segData?.nonEducation?.topPages || [])
            : (segData?.money?.topPages || []);
          
          const segmentLabel = mode === 'all'
            ? 'All pages'
            : mode === 'nonEducation'
            ? 'Exclude education (blogs / free course)'
            : 'Money pages only';
          
          debugLog(` Top Pages: Updating to segment "${mode}", found ${topPages.length} pages`, 'info');
          
          // Update segment label
          const labelEl = document.getElementById('top-pages-segment-label');
          if (labelEl) labelEl.textContent = segmentLabel;
          
          // Update summary if available
          const getSegmentSummary = (m) => {
            if (!segData || !segData[m]) return null;
            const segmentData = segData[m];
            return {
              behaviour: segmentData.behaviour || 0,
              ranking: segmentData.ranking || 0,
              total: segmentData.total || segmentData.score || 0
            };
          };
          
          const summary = getSegmentSummary(mode);
          const summaryDiv = document.getElementById('top-pages-segment-summary');
          if (summary && summaryDiv) {
            const rag = getRAGStatus(summary.total);
            summaryDiv.innerHTML = `
              ${formatComponentScore('Behaviour', summary.behaviour)}
              ${formatComponentScore('Ranking', summary.ranking)}
            `;
            // Update RAG badge and score
            const ragBadge = summaryDiv.parentElement.querySelector('.rag-badge');
            const scoreSpan = summaryDiv.parentElement.querySelector('span[style*="font-size: 1.5rem"]');
            if (ragBadge) {
              ragBadge.className = `rag-badge ${rag.status}`;
              ragBadge.textContent = rag.label;
            }
            if (scoreSpan) {
              scoreSpan.textContent = Math.round(summary.total);
              scoreSpan.style.color = rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444';
            }
          }
          
          // Update toggle buttons
          ['all', 'nonEducation', 'money'].forEach(m => {
            const btn = document.getElementById(`top-pages-mode-${m}`);
            if (btn) {
              if (m === mode) {
                btn.style.background = '#10b981';
                btn.style.color = 'white';
                btn.style.fontWeight = '600';
              } else {
                btn.style.background = 'white';
                btn.style.color = '#666';
                btn.style.fontWeight = '400';
              }
            }
          });
          
          // Update comparison table
          const comparisonDiv = document.getElementById('top-pages-comparison-table');
          if (comparisonDiv && segData) {
            comparisonDiv.innerHTML = renderSegmentComparisonTable(segData, mode);
          }
          
          // Get date range for display
          const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28', 10);
          const dateRangeText = dateRange === 28 ? '28 days' : dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
          
          // Update table (reset sort when switching segments)
          window.topPagesData = topPages;
          window.topPagesSortColumn = null;
          window.topPagesSortDirection = 'desc';
          const tableContainer = document.getElementById('top-pages-table-container');
          if (tableContainer) {
            tableContainer.innerHTML = renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText);
            attachCopyButtonHandler();
            attachSortHandlers();
          }
          
          // Update recommendations table
          const recommendationsContainer = document.getElementById('top-pages-recommendations-container');
          if (recommendationsContainer && segData && segData[mode]) {
            const segmentLabel = mode === 'all'
              ? 'All pages'
              : mode === 'nonEducation'
              ? 'Exclude education (blogs / free course)'
              : 'Money pages only';
            const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28', 10);
            const dateRangeText = dateRange === 28 ? '28 days' : dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
            recommendationsContainer.innerHTML = renderRecommendationsTable(mode, {
              siteCtr: segData[mode].siteCtr || 0,
              top10Ctr: segData[mode].top10Ctr || 0,
              avgPosition: segData[mode].avgPosition || 0,
              top10Share: segData[mode].top10Share || 0,
              behaviourScore: segData[mode].behaviour || 0,
              rankingScore: segData[mode].ranking || 0
            }, segmentLabel, dateRangeText);
          }
        };
        
        // Helper to attach sort handlers after table is in DOM
        function attachSortHandlers() {
          setTimeout(() => {
            ['ctr', 'impressions', 'clicks', 'position'].forEach(col => {
              const th = document.getElementById(`sort-${col}`);
              if (th) {
                // Remove existing listeners by cloning
                const newTh = th.cloneNode(true);
                th.parentNode.replaceChild(newTh, th);
                newTh.addEventListener('click', () => {
                  if (window.handleSort) {
                    window.handleSort(col);
                  }
                });
              }
            });
          }, 50);
        }
        
        // Attach initial handlers after section is created
        setTimeout(() => {
          attachCopyButtonHandler();
          attachSortHandlers();
        }, 150);
        
        function attachCopyButtonHandler() {
          setTimeout(() => {
            const copyBtn = document.getElementById('top-pages-copy-urls');
            if (copyBtn) {
              // Remove existing listener
              const newCopyBtn = copyBtn.cloneNode(true);
              copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
              
              newCopyBtn.addEventListener('click', async () => {
                const currentMode = window.currentAuthorityMode || 'all';
                const currentTopPages = currentMode === 'all'
                  ? (authorityBySegment?.all?.topPages || [])
                  : currentMode === 'nonEducation'
                  ? (authorityBySegment?.nonEducation?.topPages || [])
                  : (authorityBySegment?.money?.topPages || []);
                
                const text = currentTopPages.map(p => p.url).join('\n');
                try {
                  await navigator.clipboard.writeText(text);
                  newCopyBtn.textContent = 'Copied!';
                  newCopyBtn.style.color = '#10b981';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                    newCopyBtn.style.color = '#666';
                  }, 2000);
                } catch (err) {
                  console.error('Failed to copy URLs:', err);
                  newCopyBtn.textContent = 'Copy failed';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                  }, 2000);
                }
              });
            }
          }, 0);
        }
      }
      
      // Add pillar scorecard table
      // Use current audit data (from function parameters) instead of stale localStorage data
      const auditTimestamp = saved?.timestamp;
      
      // Define schemaAuditData in scope accessible to scorecard table
      const schemaAuditData = schemaAudit || saved?.schemaAudit;
      
      // Fetch historical scores for the last date in chart range to ensure scorecard matches chart
      // This fixes the issue where scorecard shows latest audit score but chart shows historical score
      let historicalScoresForLastDate = {};
      const propertyUrlForHistorical = document.getElementById('propertyUrl')?.value || data?.propertyUrl || propertyUrl || '';
      if (propertyUrlForHistorical) {
        try {
          // Get the last date from timeseries or maps
          let lastChartDate = null;
          if (data && data.timeseries && Array.isArray(data.timeseries) && data.timeseries.length > 0) {
            lastChartDate = data.timeseries[data.timeseries.length - 1].date;
          } else if (window.lastGscTimeseriesDate) {
            lastChartDate = window.lastGscTimeseriesDate;
          } else if (window.authorityMap && window.authorityMap.size > 0) {
            const authorityDates = Array.from(window.authorityMap.keys()).sort();
            lastChartDate = authorityDates[authorityDates.length - 1];
          }
          
          if (lastChartDate) {
            debugLog(`[Scorecard] Fetching historical scores for last chart date: ${lastChartDate}`, 'info');
            const historicalResponse = await fetch(apiUrl(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrlForHistorical)}&startDate=${lastChartDate}&endDate=${lastChartDate}`));
            if (historicalResponse.ok) {
              const historicalData = await historicalResponse.json();
              if (historicalData.status === 'ok' && historicalData.data && Array.isArray(historicalData.data) && historicalData.data.length > 0) {
                // Get the latest audit for this date (in case of multiple audits per day)
                const auditsForDate = historicalData.data.filter(r => r.date === lastChartDate);
                if (auditsForDate.length > 0) {
                  // Sort by timestamp/updated_at to get the latest
                  auditsForDate.sort((a, b) => {
                    const aTime = a.updated_at || a.timestamp || 0;
                    const bTime = b.updated_at || b.timestamp || 0;
                    return bTime - aTime;
                  });
                  const latestAudit = auditsForDate[0];
                  historicalScoresForLastDate = {
                    authority: latestAudit.authorityScore,
                    contentSchema: latestAudit.contentSchemaScore,
                    localEntity: latestAudit.localEntityScore,
                    serviceArea: latestAudit.serviceAreaScore,
                    visibility: latestAudit.visibilityScore
                  };
                  debugLog(`[Scorecard] Found historical scores for ${lastChartDate}: Authority=${historicalScoresForLastDate.authority}, Content/Schema=${historicalScoresForLastDate.contentSchema}`, 'info');
                }
              }
            }
          }
        } catch (e) {
          debugLog(`[Scorecard] Error fetching historical scores: ${e.message}`, 'warn');
        }
      }
      
      // Get last GSC data date from current data (for Authority, Visibility, and Brand & Entity)
      // CRITICAL: Always fetch fresh from Supabase to get the actual last timeseries date
      // data.timeseries may be stale (from localStorage), so we can't rely on it for the Data Date
      let gscLastDate = null;
      
      // Always fetch fresh from Supabase to ensure we have the latest date
      const propertyUrl = document.getElementById('propertyUrl')?.value || data?.propertyUrl || '';
      if (propertyUrl) {
        try {
          // Try window first (if renderTrendChart already ran and set it)
          if (window.lastGscTimeseriesDate) {
            gscLastDate = window.lastGscTimeseriesDate;
            debugLog(`Using last GSC timeseries date from window: ${gscLastDate}`, 'info');
          } else {
            // Fetch from Supabase API to get the last timeseries date
            const endDate = new Date().toISOString().split('T')[0];
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 30); // Last 30 days
            const startDateStr = startDate.toISOString().split('T')[0];
            
            debugLog(`Fetching last GSC timeseries date from Supabase for Data Date...`, 'info');
            const timeseriesResponse = await fetch(apiUrl(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDate}`));
            if (timeseriesResponse.ok) {
              const timeseriesData = await timeseriesResponse.json();
              if (timeseriesData.status === 'ok' && timeseriesData.timeseries && Array.isArray(timeseriesData.timeseries) && timeseriesData.timeseries.length > 0) {
                const lastPoint = timeseriesData.timeseries[timeseriesData.timeseries.length - 1];
                if (lastPoint && lastPoint.date) {
                  gscLastDate = lastPoint.date;
                  debugLog(` Using last GSC timeseries date from Supabase API: ${gscLastDate}`, 'success');
                } else {
                  debugLog(` Supabase timeseries response missing date in last point`, 'warn');
                }
              } else {
                debugLog(` Supabase timeseries response missing data: status=${timeseriesData.status}, hasTimeseries=${!!timeseriesData.timeseries}`, 'warn');
              }
            } else {
              debugLog(` Failed to fetch timeseries from Supabase: ${timeseriesResponse.status}`, 'warn');
            }
          }
        } catch (e) {
          debugLog(`Error fetching GSC date: ${e.message}`, 'warn');
        }
      }
      
      // Fallback to data.timeseries only if Supabase fetch failed
      if (!gscLastDate && data && data.timeseries && Array.isArray(data.timeseries) && data.timeseries.length > 0) {
        const lastTimeseriesPoint = data.timeseries[data.timeseries.length - 1];
        if (lastTimeseriesPoint && lastTimeseriesPoint.date) {
          gscLastDate = lastTimeseriesPoint.date;
          debugLog(`Using last GSC timeseries date from data (fallback): ${gscLastDate}`, 'warn');
        }
      }
      
      // Fallback to global maps, but filter to only dates <= last timeseries date if available
      if (!gscLastDate) {
        // Try to get from maps, but only if we can verify it's <= last timeseries date
        // For now, use the latest from maps but log a warning
        if (window.visibilityMap && window.visibilityMap.size > 0) {
          const visibilityDates = Array.from(window.visibilityMap.keys()).sort();
          const latestMapDate = visibilityDates[visibilityDates.length - 1];
          // Only use if we don't have a timeseries date to compare against
          // If we have window.lastGscTimeseriesDate, use that instead
          if (window.lastGscTimeseriesDate) {
            gscLastDate = window.lastGscTimeseriesDate;
            debugLog(`Using last GSC timeseries date from window (filtered): ${gscLastDate}`, 'info');
          } else {
            gscLastDate = latestMapDate;
            debugLog(`Using last GSC date from visibilityMap (fallback): ${gscLastDate}`, 'warn');
          }
        } else if (window.authorityMap && window.authorityMap.size > 0) {
          const authorityDates = Array.from(window.authorityMap.keys()).sort();
          const latestMapDate = authorityDates[authorityDates.length - 1];
          if (window.lastGscTimeseriesDate) {
            gscLastDate = window.lastGscTimeseriesDate;
            debugLog(`Using last GSC timeseries date from window (filtered): ${gscLastDate}`, 'info');
          } else {
            gscLastDate = latestMapDate;
            debugLog(`Using last GSC date from authorityMap (fallback): ${gscLastDate}`, 'warn');
          }
        }
      }
      
      // Final fallback to date from current data if available
      if (!gscLastDate && data && data.date) {
        gscLastDate = data.date;
        debugLog(`Using GSC data date (fallback): ${gscLastDate}`, 'info');
      }
      
      // If still no date, try to get it from saved audit data
      if (!gscLastDate && saved && saved.searchData && saved.searchData.date) {
        gscLastDate = saved.searchData.date;
        debugLog(`Using saved GSC data date (fallback): ${gscLastDate}`, 'info');
      }
      
      // Format date for display
      function formatDataDate(dateStr) {
        if (!dateStr) return '';
        const date = new Date(dateStr + 'T00:00:00'); // Add time to avoid timezone issues
        return date.toLocaleDateString('en-GB', {
          day: '2-digit',
          month: 'short',
          year: 'numeric'
        });
      }
      
      // Format timestamp for display
      function formatTimestamp(timestamp) {
        if (!timestamp) return '';
        const date = new Date(timestamp);
        return date.toLocaleString('en-GB', {
          day: '2-digit',
          month: 'short',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
      }
      
      // Get data date for each pillar
      function getPillarDataDate(pillarKey) {
        if (pillarKey === 'authority' || pillarKey === 'visibility' || pillarKey === 'brandOverlay') {
          // GSC-based pillars - use last GSC data date (Brand & Entity uses GSC query data)
          return gscLastDate ? formatDataDate(gscLastDate) : (auditTimestamp ? formatTimestamp(auditTimestamp) : '');
        } else {
          // Business Profile and schema audit - use audit timestamp
          return auditTimestamp ? formatTimestamp(auditTimestamp) : '';
        }
      }
      
      // Prevent duplicate scorecards on refresh/re-render
      document.querySelectorAll('.scorecard-section').forEach((node) => {
        node.remove();
      });

      const scorecardTable = document.createElement('div');
      scorecardTable.className = 'scorecard-section';
      scorecardTable.innerHTML = `
        <h3 style="margin: 0 0 1rem 0; color: var(--brand-orange);">Pillar Scorecard</h3>
        <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow-x: auto;">
          <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
            <thead>
              <tr style="background: #f5f5f5;">
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 10%;">Pillar</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 6%;">Score</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 6%;">Weight</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 8%;">Status</th>
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 42%;">Description</th>
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 22%;">Improvement Suggestions</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 6%;">Data Date</th>
              </tr>
            </thead>
            <tbody>
              ${(() => {
                // Phase 3: Insert Brand & Entity row after Authority
                const orderedPillars = getOrderedPillars(scores);
                const brandOverlay = scores.brandOverlay;
                const brandRowIndex = orderedPillars.findIndex(([key]) => key === 'authority');
                
                // Insert Brand row after Authority if it exists
                if (brandRowIndex >= 0 && brandOverlay) {
                  orderedPillars.splice(brandRowIndex + 1, 0, ['brandOverlay', brandOverlay.score || 0]);
                }
                
                // Use historical scores for the last date in chart range (if available)
                // This ensures scorecard matches what's shown in the trend chart
                // Priority: 1) Fetched historical scores, 2) Window maps, 3) Current scores
                const lastChartDate = window.latestAuditDateStr || window.lastGscTimeseriesDate || 
                  (data && data.timeseries && data.timeseries.length > 0 ? data.timeseries[data.timeseries.length - 1].date : null);
                
                if (lastChartDate) {
                  // Override scores with historical values if available
                  orderedPillars.forEach(([key, currentScore], idx) => {
                    let historicalScore = null;
                    
                    // First, try fetched historical scores
                    if (key === 'authority' && historicalScoresForLastDate.authority !== null && historicalScoresForLastDate.authority !== undefined) {
                      historicalScore = historicalScoresForLastDate.authority;
                    } else if (key === 'contentSchema' && historicalScoresForLastDate.contentSchema !== null && historicalScoresForLastDate.contentSchema !== undefined) {
                      historicalScore = historicalScoresForLastDate.contentSchema;
                    } else if (key === 'localEntity' && historicalScoresForLastDate.localEntity !== null && historicalScoresForLastDate.localEntity !== undefined) {
                      historicalScore = historicalScoresForLastDate.localEntity;
                    } else if (key === 'serviceArea' && historicalScoresForLastDate.serviceArea !== null && historicalScoresForLastDate.serviceArea !== undefined) {
                      historicalScore = historicalScoresForLastDate.serviceArea;
                    } else if (key === 'visibility' && historicalScoresForLastDate.visibility !== null && historicalScoresForLastDate.visibility !== undefined) {
                      historicalScore = historicalScoresForLastDate.visibility;
                    }
                    // Fallback to window maps if fetched scores not available
                    else if (key === 'authority' && window.authorityMap && window.authorityMap.has(lastChartDate)) {
                      historicalScore = window.authorityMap.get(lastChartDate);
                    } else if (key === 'contentSchema' && window.contentSchemaMap && window.contentSchemaMap.has(lastChartDate)) {
                      historicalScore = window.contentSchemaMap.get(lastChartDate);
                    } else if (key === 'localEntity' && window.localEntityMap && window.localEntityMap.has(lastChartDate)) {
                      historicalScore = window.localEntityMap.get(lastChartDate);
                    } else if (key === 'serviceArea' && window.serviceAreaMap && window.serviceAreaMap.has(lastChartDate)) {
                      historicalScore = window.serviceAreaMap.get(lastChartDate);
                    } else if (key === 'visibility' && window.visibilityMap && window.visibilityMap.has(lastChartDate)) {
                      historicalScore = window.visibilityMap.get(lastChartDate);
                    }
                    
                    if (historicalScore !== null && historicalScore !== undefined) {
                      orderedPillars[idx][1] = historicalScore;
                      debugLog(`[Scorecard] Using historical ${key} score (${historicalScore}) for ${lastChartDate} instead of current (${currentScore})`, 'info');
                    } else {
                      debugLog(`[Scorecard] No historical ${key} score found for ${lastChartDate}, using current (${currentScore})`, 'info');
                    }
                  });
                } else {
                  debugLog(`[Scorecard] No last chart date available, using current audit scores`, 'info');
                }
                
                return orderedPillars;
              })().map(([key, score], index) => {
                const rag = getRAGStatus(score);
                
                // Define pillar colors for scorecard table (matching charts)
                const scorecardPillarColors = {
                  localEntity: 'rgba(147, 51, 234, 1)', // Purple
                  serviceArea: '#00FFFF', // Cyan
                  authority: '#99004C', // Dark pink/magenta
                  visibility: 'rgba(37, 99, 235, 1)', // Blue
                  contentSchema: 'rgba(107, 114, 128, 1)' // Grey
                };
                
                const pillarColor = scorecardPillarColors[key] || '#666';
                
                // Build Content/Schema description with schema audit data
                let contentSchemaDesc = 'Quality and completeness of structured data markup across your domain.<br><strong>AI Importance:</strong> Structured data is the primary way AI understands your content. Schema markup directly feeds AI systems, enabling them to extract facts, relationships, and context for use in AI Overviews and answer generation.<br><strong>Diversity:</strong> Measures how varied your structured content is  different schema types (Article, Event, Course, FAQPage, HowTo, Product, Review, VideoObject, ImageObject, ItemList, LocalBusiness) and formats across the site. A broader mix of types gives AI more reliable, context-rich signals for understanding what you do and for building accurate summaries.<br><strong>Data Source:</strong>  <span style="color: #10b981;">Live data</span> from schema audit (crawls actual website pages for JSON-LD markup).<br><strong>Calculation:</strong> Weighted score based on Foundation schemas (30%), Rich Result eligibility (35%), Coverage (20%), and Type Diversity (15%).';
                
                if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
                  const schemaData = schemaAudit.data;
                  const { coverage, totalPages, pagesWithSchema, missingSchemaCount, missingSchemaPages, schemaTypes } = schemaData;
                  
                  // Handle pagesWithSchema - it might be an array or a number
                  const pagesWithSchemaCount = Array.isArray(pagesWithSchema) ? pagesWithSchema.length : (typeof pagesWithSchema === 'number' ? pagesWithSchema : 0);
                  const totalPagesCount = typeof totalPages === 'number' ? totalPages : (Array.isArray(schemaData.pages) ? schemaData.pages.length : 0);
                  let coverageValue = 'N/A';
                  if (typeof coverage === 'number' && !isNaN(coverage)) {
                    coverageValue = coverage.toFixed(1);
                  } else if (totalPagesCount > 0) {
                    coverageValue = ((pagesWithSchemaCount / totalPagesCount) * 100).toFixed(1);
                  }
                  
                  // Calculate foundation schemas - PRIORITY: use schemaData.foundation object first (most reliable)
                  // foundation object has {Organization: true, Person: true, WebSite: true, BreadcrumbList: true}
                  const allTypes = new Set();
                  
                  // First, use foundation object if available (most reliable source)
                  if (schemaData.foundation && typeof schemaData.foundation === 'object') {
                    Object.keys(schemaData.foundation).forEach(type => {
                      if (schemaData.foundation[type] === true) {
                        allTypes.add(type);
                      }
                    });
                  }
                  
                  // Also add types from allDetectedTypes if available (for complete type list)
                  if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
                    schemaData.allDetectedTypes.forEach(type => {
                      if (type) allTypes.add(type);
                    });
                  }
                  
                  // Fallback: collect from schemaTypes array (contains all types, sorted by count)
                  // IMPORTANT: schemaTypes might be the pages array, so filter carefully
                  if (schemaTypes && Array.isArray(schemaTypes) && allTypes.size === 0) {
                    schemaTypes.forEach(item => {
                      // Skip page objects (have 'url' property) - these are NOT schema types
                      if (item && typeof item === 'object' && item.url) {
                        return; // Skip page objects
                      }
                      // Only process valid schema type objects (not page objects with url property)
                      if (item && typeof item === 'object' && item.type && typeof item.type === 'string' && !item.url) {
                        allTypes.add(item.type);
                      } else if (typeof item === 'string') {
                        allTypes.add(item);
                      }
                    });
                  }
                  const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
                  const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
                  
                  // Count rich result types
                  const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
                  const uniqueTypesCount = allTypes.size;
                  
                  const richResultTypesList = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
                  const richTypesPresent = richResultTypesList.filter(type => allTypes.has(type));
                  contentSchemaDesc += ` <strong>Data Checked:</strong> Foundation schemas: ${foundationPresent}/4 (${foundationTypes.filter(t => allTypes.has(t)).join(', ') || 'none'}), Rich result types: ${richEligibleCount}/${richResultTypesList.length} eligible, Coverage: ${coverageValue}% (${pagesWithSchemaCount}/${totalPagesCount} pages), Type diversity: ${richTypesPresent.length}/${richResultTypesList.length} rich result types present (${richTypesPresent.join(', ') || 'none'}), ${uniqueTypesCount} total unique types across the site. `;
                  
                  // Display schema types - use allDetectedTypes if available, otherwise try schemaTypes (but filter out pages)
                  let schemaTypesToDisplay = [];
                  if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
                    schemaTypesToDisplay = schemaData.allDetectedTypes.slice(0, 15);
                  } else if (schemaTypes && Array.isArray(schemaTypes)) {
                    // Filter out page objects (those with 'url' property) - these are NOT schema types
                    schemaTypesToDisplay = schemaTypes
                      .filter(t => {
                        // Skip null/undefined
                        if (!t) return false;
                        // Skip page objects (have 'url' property) - these are pages, not types!
                        if (typeof t === 'object' && ('url' in t || ('title' in t && 'metaDescription' in t))) return false;
                        // Only keep valid type objects or strings
                        return typeof t === 'string' || (typeof t === 'object' && t.type && typeof t.type === 'string' && !t.url);
                      })
                      .slice(0, 15);
                  }
                  
                  if (schemaTypesToDisplay.length > 0) {
                    // Convert to display strings
                    const topTypes = schemaTypesToDisplay
                      .map(t => {
                        if (typeof t === 'string' && t.trim()) {
                          return t.trim();
                        } else if (t && typeof t === 'object' && t.type && typeof t.type === 'string') {
                          return `${t.type}${t.count ? ` (${t.count})` : ''}`;
                        } else {
                          // Skip objects without a valid type property - don't convert to [object Object]
                          return null;
                        }
                      })
                      .filter(t => t !== null && t !== undefined && t !== '' && typeof t === 'string' && !t.includes('[object Object]'))
                      .join(', ');
                    if (topTypes) {
                      contentSchemaDesc += `Schema types found: ${topTypes}${schemaTypesToDisplay.length > 15 ? '...' : ''}. `;
                    }
                  }
                  
                  if (schemaData.missingTypes && Array.isArray(schemaData.missingTypes) && schemaData.missingTypes.length > 0) {
                    // Ensure all items are strings - properly handle objects
                    const missingTypesList = schemaData.missingTypes
                      .map(t => {
                        if (typeof t === 'string') return t;
                        if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type;
                        // Skip objects that can't be converted
                        return null;
                      })
                      .filter(t => t !== null && t !== undefined && typeof t === 'string');
                    if (missingTypesList.length > 0) {
                      contentSchemaDesc += `Missing foundation types: ${missingTypesList.join(', ')}. `;
                    }
                  }
                  
                  const richTypes = Object.entries(schemaData.richEligible || {})
                    .filter(([type, eligible]) => eligible)
                    .map(([type]) => type);
                  if (richTypes.length > 0) {
                    contentSchemaDesc += `Rich result eligible: ${richTypes.join(', ')}. `;
                  }
                  
                  // Check if Review schema is detected (even if not in top 10 types)
                  const hasReviewSchema = allTypes.has('Review');
                  if (hasReviewSchema) {
                    // Try to get count from schemaTypes array first, otherwise check schemaData for actual count
                    let reviewCount = schemaTypes?.find(t => t.type === 'Review')?.count || 0;
                    // If not in top 10, check if we have schemaData with all types info
                    if (reviewCount === 0 && schemaData.schemaTypes) {
                      // schemaTypes in response is top 10, but we need to check if Review exists
                      // Since it's in allTypes, it exists, but we don't have the exact count
                      // Just indicate it's detected without showing 0
                      contentSchemaDesc += `Review schema detected - matches GSC review snippets data. `;
                    } else if (reviewCount > 0) {
                      contentSchemaDesc += `Review schema detected (${reviewCount} instances) - matches GSC review snippets data. `;
                } else {
                      contentSchemaDesc += `Review schema detected - matches GSC review snippets data. `;
                    }
                  }
                } else {
                  contentSchemaDesc += ' <strong>Data Checked:</strong> Foundation schemas (Organization, Person, WebSite, BreadcrumbList), Rich result eligibility (Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList), schema coverage percentage, schema type diversity.';
                }
                
                // Build Local Entity and Service Area descriptions based on whether we have real Business Profile data
                let localEntityDesc, serviceAreaDesc;
                if (hasLocalSignals && localSignalsData) {
                  const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                  const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
                  const locationsCount = localSignalsData.locations?.length || 0;
                  const knowledgePanel = localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected';
                  localEntityDesc = `Consistency and clarity of brand, person and business entity signals.<br><strong>AI Importance:</strong> AI systems rely on clear entity signals to understand who you are and connect your brand across platforms. Strong entity recognition helps AI include you in knowledge panels and entity-based results.<br><strong>Data Source:</strong>  <span style="color: #10b981;">Live data</span> from Google Business Profile API.<br><strong>Data Checked:</strong> NAP consistency (${napScore}%), knowledge panel (${knowledgePanel}), locations (${locationsCount}), LocalBusiness schema presence, Google Business Profile data.`;
                  serviceAreaDesc = `How clearly AI understands where lessons/workshops run and which regions you cover.<br><strong>AI Importance:</strong> AI uses geographic signals to match queries with local intent. Clear service area data helps AI surface your content for location-specific searches and local AI Overviews.<br><strong>Data Source:</strong>  <span style="color: #10b981;">Live data</span> from Google Business Profile API.<br><strong>Data Checked:</strong> Service areas (${serviceAreasCount}), NAP consistency (${napScore}%), Google Business Profile service areas.`;
                } else {
                  localEntityDesc = 'Consistency and clarity of brand, person and business entity signals.<br><strong>AI Importance:</strong> AI systems rely on clear entity signals to understand who you are and connect your brand across platforms. Strong entity recognition helps AI include you in knowledge panels and entity-based results.<br><strong>Data Source:</strong>  <span style="color: #f59e0b;">Derived calculation</span> from GSC position/CTR (not using real local signals yet).<br><strong>Data Checked:</strong> Currently calculated from search performance metrics. Real data pending: LocalBusiness schema presence, NAP consistency, Google Business Profile data, knowledge panel detection.';
                  serviceAreaDesc = 'How clearly AI understands where lessons/workshops run and which regions you cover.<br><strong>AI Importance:</strong> AI uses geographic signals to match queries with local intent. Clear service area data helps AI surface your content for location-specific searches and local AI Overviews.<br><strong>Data Source:</strong>  <span style="color: #f59e0b;">Derived calculation</span> from Local Entity score (not using real service area data yet).<br><strong>Data Checked:</strong> Currently calculated from Local Entity. Real data pending: ServiceArea schema markup, Google Business Profile service areas, geographic keywords, location pages.';
                }
                
                // Format GSC data for display - use current data parameter
                const currentGSCData = data || searchDataForBreakdown || {};
                const ctr = currentGSCData.ctr || 0;
                const avgPosition = currentGSCData.averagePosition || 0;
                const totalClicks = currentGSCData.totalClicks || 0;
                const totalImpressions = currentGSCData.totalImpressions || 0;
                
                // Phase 3: Build Brand & Entity description
                let brandDesc = '';
                if (key === 'brandOverlay') {
                  const brand = scores.brandOverlay;
                  if (brand) {
                    const share = brand.brandQueryShare || 0;
                    const brandCtr = brand.brandCtr || 0;
                    const pos = brand.brandAvgPosition || 0;
                    const reviewScore = brand.reviewScore || 0;
                    const entityScore = brand.entityScore || 0;
                    
                    brandDesc = `E-A-T overlay for brand demand, reviews, and entity strength. Shows how clearly "Alan Ranger / Alan Ranger Photography" is recognised as a distinct brand in search and AI systems.<br><strong>AI Importance:</strong> Strong branded signals make it easier for AI to trust and summarise you correctly. High branded search share, strong review footprint and a clear entity graph (GBP + knowledge panel) all increase the chance of accurate AI overviews.<br><strong>Calculation:</strong> Combined overlay score from:<br> Brand search: share of branded queries, CTR, and average position<br> Reviews: Google Business Profile + on-site review scores and volumes<br> Entity: NAP consistency, locations, and knowledge panel detection<br><strong>Data Source:</strong> Live data from Google Search Console (brand queries), Google Business Profile API (rating, reviews, locations, service areas), and site reviews snapshot.`;
                    
                    // Show metrics when available
                    if (share > 0 || brandCtr > 0 || pos > 0) {
                      const sharePct = share != null ? (share * 100).toFixed(1) : 'N/A';
                      const brandCtrPct = brandCtr != null ? (brandCtr * 100).toFixed(1) : 'N/A';
                      const posStr = pos != null ? pos.toFixed(1) : 'N/A';
                      brandDesc += ` <strong>Current Metrics:</strong> Brand queries: ${sharePct}% of impressions, brand CTR ${brandCtrPct}%, avg brand position ${posStr}.`;
                    }
                  } else {
                    brandDesc = 'No brand overlay data available  run an audit with access to query data.';
                  }
                }
                
                const descriptions = {
                  localEntity: localEntityDesc,
                  serviceArea: serviceAreaDesc,
                  authority: `E-A-T (Experience, Expertise, Authoritativeness, Trustworthiness): Perceived expertise and trust in the topic space. Authority measures how much the outside world and searchers trust and choose you, not just content quality.<br><strong>AI Importance:</strong> E-A-T is critical for AI systems - they prioritize authoritative, trustworthy sources. Strong E-A-T signals help AI confidently feature your content in AI Overviews and answer boxes.<br><strong>Calculation:</strong> Behaviour Score (40%): CTR for ranking queries (position 20) + top-10 CTR. Ranking Score (20%): Average position + top-10 impression share. Backlink Score (20%): Referring domains + quality ratio. Review Score (20%): Combined ratings and counts from GBP + Trustpilot snapshot.<br><strong>Data Source:</strong>  <span style="color: #10b981;">Live data</span> from Google Search Console API, Google Business Profile API, historic Trustpilot reviews snapshot, and backlink CSV upload.<br><strong>Data Checked:</strong> CTR ${ctr.toFixed(1)}%, average position ${avgPosition.toFixed(1)}, clicks ${totalClicks.toLocaleString()}, impressions ${totalImpressions.toLocaleString()}, ranking query performance (position 20), backlink metrics (referring domains, follow ratio), review ratings and counts.`,
                  visibility: `Frequency and prominence in organic search, local pack, snippets and AI Overviews.<br><strong>AI Importance:</strong> AI systems learn from existing search performance. Higher visibility signals quality and relevance, making AI more likely to surface your content in AI-powered results and featured snippets.<br><strong>Data Source:</strong>  <span style="color: #10b981;">Live data</span> from Google Search Console API.<br><strong>Data Checked:</strong> Average position ${avgPosition.toFixed(1)}, CTR ${ctr.toFixed(1)}%, total clicks ${totalClicks.toLocaleString()}, total impressions ${totalImpressions.toLocaleString()}, SERP feature appearances.`,
                  contentSchema: contentSchemaDesc,
                  brandOverlay: brandDesc
                };
                
                // Generate dynamic next steps based on actual data and scores
                // Use current data from function parameters
                const getNextSteps = (pillarKey, pillarScore, gscData, schemaData) => {
                  // Use the schemaData parameter passed to this function
                  const currentSchemaData = schemaData;
                  const steps = [];
                  
                  switch(pillarKey) {
                    case 'contentSchema':
                      if (schemaData && schemaData.status === 'ok' && schemaData.data) {
                        const schemaAuditData = schemaData.data;
                        const { coverage, missingSchemaCount, totalPages, pagesWithSchema, schemaTypes, richEligible, missingTypes } = schemaAuditData;
                        
                        // Collect all types for analysis - use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
                        const allTypes = new Set();
                        if (schemaAuditData.allDetectedTypes && Array.isArray(schemaAuditData.allDetectedTypes)) {
                          // Use all detected types for accurate calculation
                          schemaAuditData.allDetectedTypes.forEach(type => {
                            if (type) allTypes.add(type);
                          });
                        } else if (schemaTypes && Array.isArray(schemaTypes)) {
                          // Fallback: collect from schemaTypes array (contains all types, sorted by count)
                          schemaTypes.forEach(item => {
                            if (item.type) allTypes.add(item.type);
                          });
                        }
                        
                        // 1. Foundation Schemas (30% weight)
                        const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
                        const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
                        const foundationMissing = foundationTypes.filter(type => !allTypes.has(type));
                        
                        if (foundationPresent < 4) {
                          steps.push(`<strong>Foundation schemas (30%):</strong> ${foundationPresent}/4 present. Add: ${foundationMissing.join(', ')}`);
                        } else {
                          steps.push(`<strong>Foundation schemas (30%):</strong>  All 4 present (Organization, Person, WebSite, BreadcrumbList)`);
                        }
                        
                        // 2. Rich Result Eligibility (35% weight)
                        const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
                        const richEligibleCount = Object.values(richEligible || {}).filter(eligible => eligible === true).length;
                        const richMissing = richResultTypes.filter(type => !richEligible[type]);
                        
                        // Check for failed crawls that might affect rich result detection
                        const failedPages = schemaAuditData.missingSchemaPages ? schemaAuditData.missingSchemaPages.filter(p => p.error).length : 0;
                        const hasFailedCrawls = failedPages > 0;
                        
                        if (richEligibleCount < richResultTypes.length) {
                          let richResultMsg = `<strong>Rich results (35%):</strong> ${richEligibleCount}/${richResultTypes.length} eligible.`;
                          if (richMissing.length > 0) {
                            richResultMsg += ` Missing: ${richMissing.slice(0, 3).join(', ')}${richMissing.length > 3 ? '...' : ''}`;
                            if (hasFailedCrawls) {
                              richResultMsg += ` <em>(Note: ${failedPages} page${failedPages !== 1 ? 's' : ''} failed to crawl - missing types may exist but weren't detected)</em>`;
                            }
                          }
                          steps.push(richResultMsg);
                        } else {
                          steps.push(`<strong>Rich results (35%):</strong>  All ${richResultTypes.length} types eligible`);
                        }
                        
                        // 3. Coverage (20% weight)
                        if (coverage < 100) {
                          steps.push(`<strong>Coverage (20%):</strong> ${coverage}% - Add schema to ${missingSchemaCount || 0} pages without markup`);
                        } else {
                          steps.push(`<strong>Coverage (20%):</strong>  100% - All pages have schema`);
                        }
                        
                        // 4. Type Diversity (15% weight)
                        const uniqueTypesCount = allTypes.size;
                        if (uniqueTypesCount < 15) {
                          steps.push(`<strong>Diversity (15%):</strong> ${uniqueTypesCount} unique types. Add more schema types to reach 15+ for maximum score`);
                        } else {
                          steps.push(`<strong>Diversity (15%):</strong>  ${uniqueTypesCount} unique types (excellent diversity)`);
                        }
                      } else {
                        steps.push(`<strong>Status:</strong> Schema audit data not available - run audit to see detailed metrics`);
                      }
                      break;
                      
                    case 'visibility':
                      // Use current data from function parameters
                      const currentGSCForVisibility = data || searchDataForBreakdown || {};
                      if (currentGSCForVisibility) {
                        const position = currentGSCForVisibility.averagePosition || 0;
                        const ctr = currentGSCForVisibility.ctr || 0;
                        
                        if (position > 10) {
                          steps.push(`<strong>Average position: ${position.toFixed(1)}</strong> - Target top 10 positions (currently ranking ${position > 20 ? 'below' : 'in'} page ${Math.ceil(position / 10)})`);
                        } else {
                          steps.push(`<strong>Average position: ${position.toFixed(1)}</strong> - Excellent! Maintain top 10 rankings`);
                        }
                        
                        if (ctr < 2.0) {
                          steps.push(`<strong>CTR: ${ctr.toFixed(1)}%</strong> - Improve click-through rate (target: 2%+) with better titles/meta descriptions`);
                        } else {
                          steps.push(`<strong>CTR: ${ctr.toFixed(1)}%</strong> - Good CTR! Continue optimizing for featured snippets`);
                        }
                        
                        if (currentGSCForVisibility.totalImpressions < 1000) {
                          steps.push(`<strong>Impressions: ${currentGSCForVisibility.totalImpressions}</strong> - Increase visibility by targeting more keywords`);
                        }
                      }
                      break;
                      
                    case 'authority':
                      // Use current data from function parameters, not stale localStorage
                      const currentGSCForAuthority = data || searchDataForBreakdown || {};
                      if (currentGSCForAuthority) {
                        const ctr = currentGSCForAuthority.ctr || 0;
                        const position = currentGSCForAuthority.averagePosition || 0;
                        // Use current saved data (already loaded at function start)
                        const authorityComponents = scores?.authorityComponents;
                        const backlinkMetrics = saved?.backlinkMetrics;
                        const localSignals = saved?.localSignals;
                        // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
                        const siteReviews = getTrustpilotSnapshot(saved?.siteReviews);
                        
                        // Show component-specific suggestions
                        if (authorityComponents) {
                          if (authorityComponents.behaviour < 50) {
                            steps.push(`<strong>Behaviour Score (${Math.round(authorityComponents.behaviour)}):</strong> Improve CTR for ranking queries. Target 5%+ CTR for all queries, 10%+ for top-10 positions`);
                          }
                          
                          if (authorityComponents.ranking < 50) {
                            steps.push(`<strong>Ranking Score (${Math.round(authorityComponents.ranking)}):</strong> Improve average position and increase top-10 impression share`);
                          }
                          
                          if (authorityComponents.backlinks < 50) {
                            if (backlinkMetrics && backlinkMetrics.referringDomains > 0) {
                              steps.push(`<strong>Backlink Score (${Math.round(authorityComponents.backlinks)}):</strong> Increase referring domains (current: ${backlinkMetrics.referringDomains}, target: 100+) and improve follow ratio (current: ${Math.round((backlinkMetrics.followRatio || 0) * 100)}%)`);
                            } else {
                              steps.push(`<strong>Backlink Score (${Math.round(authorityComponents.backlinks)}):</strong> Upload backlink CSV to measure domain authority`);
                            }
                          }
                          
                          if (authorityComponents.reviews < 50) {
                            const gbpRating = (localSignals && localSignals.status === 'ok' && localSignals.data) ? localSignals.data.gbpRating : null;
                            const gbpCount = (localSignals && localSignals.status === 'ok' && localSignals.data) ? localSignals.data.gbpReviewCount : null;
                            const siteRating = siteReviews?.siteRating || null;
                            const siteCount = siteReviews?.siteReviewCount || null;
                            
                            if (!gbpRating && !siteRating) {
                              steps.push(`<strong>Review Score (${Math.round(authorityComponents.reviews)}):</strong> Add GBP and Trustpilot reviews to build trust signals`);
                            } else {
                              steps.push(`<strong>Review Score (${Math.round(authorityComponents.reviews)}):</strong> Increase review count and maintain high ratings (target: 4.5+ rating, 100+ reviews)`);
                            }
                          }
                        } else {
                          // Fallback to general suggestions if components not available
                          if (ctr < 1.5) {
                            steps.push(`<strong>CTR: ${ctr.toFixed(1)}%</strong> - Low click-through indicates trust issues. Improve E-A-T signals`);
                          }
                          
                          if (position > 15) {
                            steps.push(`<strong>Position: ${position.toFixed(1)}</strong> - Improve rankings through comprehensive, expert content`);
                          }
                        }
                      }
                      break;
                      
                    case 'localEntity':
                      if (hasLocalSignals && localSignalsData) {
                        const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                        const locationsCount = localSignalsData.locations?.length || 0;
                        const knowledgePanel = localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected';
                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using real Business Profile data`);
                        steps.push(`<strong>Data:</strong> NAP consistency: ${napScore}%, Knowledge panel: ${knowledgePanel}, Locations: ${locationsCount}`);
                        if (pillarScore < 70) {
                          if (napScore < 100) {
                            steps.push(`<strong>Action:</strong> Improve NAP consistency (currently ${napScore}%) - ensure Name, Address, and Phone are consistent across all platforms`);
                          }
                          if (!localSignalsData.knowledgePanelDetected) {
                            steps.push(`<strong>Action:</strong> Work on knowledge panel detection - improve entity signals and citations`);
                          }
                          if (locationsCount === 0) {
                            steps.push(`<strong>Action:</strong> Add business location to Google Business Profile`);
                          }
                        } else {
                          steps.push(`<strong>Status:</strong>  Strong local entity signals detected`);
                        }
                      } else {
                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using derived calculation from search performance`);
                        steps.push(`<strong>Priority:</strong> Integrate Google Business Profile API to use real local signals data`);
                        if (pillarScore < 70) {
                          steps.push(`<strong>Action:</strong> Add LocalBusiness schema markup and ensure NAP consistency`);
                        }
                      }
                      break;
                      
                    case 'serviceArea':
                      if (hasLocalSignals && localSignalsData) {
                        const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
                        const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using real Business Profile data`);
                        steps.push(`<strong>Data:</strong> Service areas: ${serviceAreasCount}, NAP consistency: ${napScore}%`);
                        if (pillarScore < 70) {
                          if (serviceAreasCount < 5) {
                            steps.push(`<strong>Action:</strong> Add more service areas to Google Business Profile (currently ${serviceAreasCount}, target: 5+)`);
                          }
                          if (napScore < 100) {
                            steps.push(`<strong>Action:</strong> Improve NAP consistency to boost service area score (currently ${napScore}%)`);
                          }
                        } else {
                          steps.push(`<strong>Status:</strong>  Good service area coverage`);
                        }
                      } else {
                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using derived calculation from Local Entity`);
                        steps.push(`<strong>Priority:</strong> Integrate Google Business Profile API to get real service area data`);
                        if (pillarScore < 70) {
                          steps.push(`<strong>Action:</strong> Add ServiceArea schema and create location-specific pages`);
                        }
                      }
                      break;
                  }
                  
                  // If no specific steps generated, add generic ones
                  if (steps.length === 0) {
                    if (pillarScore >= 70) {
                      steps.push('Maintain current performance');
                      steps.push('Monitor for any score drops');
                    } else if (pillarScore >= 40) {
                      steps.push('Focus on improving this pillar');
                      steps.push('Review specific metrics above');
                    } else {
                      steps.push('Critical: Immediate action required');
                      steps.push('Review all data sources and implement fixes');
                    }
                  }
                  
                  return steps.slice(0, 3).map(s => ` ${s}`).join('<br>') || 'No next steps available';
                };
                
                // Generate suggestions based on pillar and score (fallback)
                const getSuggestions = (pillarKey, pillarScore) => {
                  const suggestions = {
                    localEntity: {
                      high: ['Maintain consistent NAP (Name, Address, Phone) across all platforms', 'Continue building personal brand mentions and citations', 'Monitor entity recognition in knowledge panels'],
                      medium: ['Add LocalBusiness schema markup to all location pages', 'Ensure consistent business name and person name across website', 'Build more local citations and directory listings', 'Create an About page with clear entity information', 'Add author markup to content'],
                      low: ['Implement LocalBusiness schema markup immediately', 'Create consistent NAP (Name, Address, Phone) across all platforms', 'Build local citations in relevant directories', 'Add clear About page with entity information', 'Ensure consistent branding across all touchpoints']
                    },
                    serviceArea: {
                      high: ['Continue maintaining clear service area information', 'Update location pages as service areas expand'],
                      medium: ['Add ServiceArea schema markup to location pages', 'Create dedicated pages for each service area/region', 'Include clear geographic information in content', 'Add location-specific keywords naturally', 'Update Google Business Profile with service areas'],
                      low: ['Implement ServiceArea schema markup immediately', 'Create location-specific landing pages', 'Add clear geographic service information to homepage', 'Update all location pages with service area details', 'Include city/region names in page titles and content']
                    },
                    authority: {
                      high: ['Continue producing in-depth, expert content', 'Maintain citation and backlink building efforts', 'Seek opportunities for expert quotes and mentions', 'Keep author bios and credentials up to date'],
                      medium: ['Create more comprehensive, long-form content (2000+ words)', 'Build backlinks from authoritative photography/education sites', 'Seek guest posting opportunities on relevant blogs', 'Collect and display customer reviews/testimonials', 'Create case studies and detailed tutorials', 'Get cited in industry publications', 'Add author bylines with credentials and experience', 'Display certifications, qualifications, and awards', 'Showcase real-world experience and portfolio work', 'Build trust signals (secure site, clear contact info, privacy policy)'],
                      low: ['Produce comprehensive, expert-level content immediately', 'Build backlinks from authoritative sources', 'Create detailed case studies and tutorials', 'Seek media mentions and expert quotes', 'Display customer reviews prominently', 'Build relationships with industry publications', 'Add clear author credentials and experience to all content', 'Display qualifications, certifications, and professional memberships', 'Create About page highlighting expertise and experience', 'Build trust signals (HTTPS, clear contact, privacy policy, terms)']
                    },
                    visibility: {
                      high: ['Continue optimizing for featured snippets', 'Maintain strong ranking positions', 'Monitor SERP feature opportunities'],
                      medium: ['Optimize content for featured snippets (answer boxes)', 'Target long-tail keywords with lower competition', 'Improve page load speed and Core Web Vitals', 'Create FAQ schema for common questions', 'Optimize for "People Also Ask" sections', 'Build internal linking structure'],
                      low: ['Optimize for featured snippets immediately', 'Target low-competition long-tail keywords', 'Improve page speed and mobile experience', 'Add FAQ schema markup', 'Create content targeting "People Also Ask" queries', 'Build strong internal linking structure']
                    },
                    contentSchema: {
                      high: ['Continue maintaining all foundation schemas (Organization, Person, WebSite, BreadcrumbList)', 'Expand rich result eligible types (Article, Event, Course, FAQ, HowTo)', 'Monitor schema validation errors', 'Add more schema type diversity'],
                      medium: ['Add missing foundation schemas (Organization, Person, WebSite, BreadcrumbList)', 'Add rich result eligible types (Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList)', 'Ensure 100% schema coverage across all pages', 'Increase schema type diversity (target 15+ unique types)', 'Validate all schema using Google Rich Results Test'],
                      low: ['Implement foundation schemas immediately (Organization, Person, WebSite, BreadcrumbList)', 'Add rich result eligible schemas (Article, Event, Course, FAQ, HowTo)', 'Ensure schema coverage reaches 100%', 'Add schema type diversity (target 15+ unique types)', 'Validate all schema using Google Rich Results Test']
                    }
                  };
                  
                  const pillarSuggestions = suggestions[pillarKey];
                  if (!pillarSuggestions) return 'No suggestions available';
                  
                  let selectedSuggestions = [];
                  if (pillarScore >= 70) {
                    selectedSuggestions = pillarSuggestions.high || [];
                  } else if (pillarScore >= 40) {
                    selectedSuggestions = pillarSuggestions.medium || [];
                  } else {
                    selectedSuggestions = pillarSuggestions.low || [];
                  }
                  
                  // Return top 3-4 suggestions as bullet points
                  return selectedSuggestions.slice(0, 4).map(s => ` ${s}`).join('<br>') || 'No suggestions available';
                };
                
                // Phase 3: Handle Brand & Entity overlay row
                if (key === 'brandOverlay') {
                  const brand = scores.brandOverlay;
                  const brandScore = brand?.score ?? 0;
                  let brandStatus = 'red';
                  let brandLabel = 'Red';
                  if (brandScore >= 70) {
                    brandStatus = 'green';
                    brandLabel = 'Green';
                  } else if (brandScore >= 40) {
                    brandStatus = 'amber';
                    brandLabel = 'Amber';
                  }
                  
                  // Get brand priority for improvement suggestions
                  const brandPriority = getBrandPriority({ brandOverlay: brand });
                  let brandSuggestion = '';
                  if (brandPriority) {
                    brandSuggestion = brandPriority.message;
                  } else if (brandScore >= 70) {
                    brandSuggestion = 'Brand & entity signals are strong. Maintain a steady flow of new reviews and consistent use of your full brand name across site and off-site mentions.';
                  } else if (!brand) {
                    brandSuggestion = 'No brand overlay data available  run an audit with access to query data.';
                  } else {
                    brandSuggestion = 'No immediate brand actions  focus on Authority behaviour first.';
                  }
                  
                  const brandDataDate = getPillarDataDate('authority'); // Use same date as Authority (GSC-based)
                  const brandDataDateDisplay = brandDataDate 
                    ? `<span style="font-size: 0.8rem; color: #666;">${brandDataDate}</span>`
                    : '<span style="font-size: 0.8rem; color: #999;">N/A</span>';
                  
                  return `
                    <tr style="border-bottom: 1px solid #eee; background: ${index % 2 === 0 ? '#ffffff' : '#fafafa'};">
                      <td style="padding: 0.75rem; font-weight: 500;">
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                          <div style="width: 16px; height: 16px; background: #f59e0b; border-radius: 2px; border: 1px solid rgba(0,0,0,0.1); flex-shrink: 0;" title="Brand & Entity overlay"></div>
                          <span>Brand & Entity <span style="color: #999; font-size: 0.85em;">(overlay)</span></span>
                        </div>
                      </td>
                      <td style="padding: 0.75rem; text-align: center; font-size: 1.1rem; font-weight: 600; color: ${brandStatus === 'green' ? '#10b981' : brandStatus === 'amber' ? '#f59e0b' : '#ef4444'};">
                        ${brand ? Math.round(brandScore) : 0}
                      </td>
                      <td style="padding: 0.75rem; text-align: center; font-size: 0.9rem; font-weight: 600; color: #999;" title="Overlay only - does not affect GAIO score">
                        <span style="color: #999;"></span>
                      </td>
                      <td style="padding: 0.75rem; text-align: center;">
                        ${brand ? `
                          <span class="rag-badge ${brandStatus}" style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.8rem;">
                            ${brandLabel}
                          </span>
                        ` : `
                          <span style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.8rem; background: #e5e7eb; color: #6b7280;">
                            N/A
                          </span>
                        `}
                      </td>
                      <td style="padding: 0.75rem; color: #666; font-size: 0.85rem; line-height: 1.6; width: 42%;">${descriptions.brandOverlay || ''}</td>
                      <td style="padding: 0.75rem; color: #555; font-size: 0.85rem; line-height: 1.6; width: 22%;">${brandSuggestion || 'No suggestions available'}</td>
                      <td style="padding: 0.75rem; text-align: center; width: 6%;">${brandDataDateDisplay}</td>
                    </tr>
                  `;
                }
                
                const weight = pillarWeights[key] || 0;
                const isEven = index % 2 === 0;
                
                // Add CSV download button for Content/Schema
                let descriptionCell = descriptions[key] || '';
                if (key === 'contentSchema' && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
                  const schemaData = schemaAudit.data;
                  const missingSchemaCount = schemaData.missingSchemaCount || 0;
                  const missingSchemaPages = schemaData.missingSchemaPages || [];
                  
                  // Always show button, but disable if no missing pages
                  const buttonDisabled = missingSchemaCount === 0;
                  const buttonStyle = buttonDisabled 
                    ? 'padding: 0.4rem 0.8rem; font-size: 0.8rem; background: #9ca3af; color: white; border: none; border-radius: 4px; cursor: not-allowed; opacity: 0.6;'
                    : 'padding: 0.4rem 0.8rem; font-size: 0.8rem; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;';
                  const buttonText = missingSchemaCount > 0 
                    ? `Download pages without schema (CSV) - ${missingSchemaCount} pages`
                    : 'Download pages without schema (CSV) - No missing pages';
                  
                  const downloadTooltip = missingSchemaCount > 0 
                    ? `Download a CSV file containing ${missingSchemaCount} page URLs that are missing schema markup. Use this list to prioritize which pages need schema added.`
                    : 'All pages have schema markup. No download available.';
                  descriptionCell += `<div style="margin-top: 0.75rem;"><button id="download-missing-schema" class="btn-small" style="${buttonStyle}" ${buttonDisabled ? 'disabled' : ''} title="${downloadTooltip}">${buttonText}</button></div>`;
                }
                
                // Get data date for this pillar
                const pillarDataDate = getPillarDataDate(key);
                const dataDateDisplay = pillarDataDate 
                  ? `<span style="font-size: 0.8rem; color: #666;">${pillarDataDate}</span>`
                  : '<span style="font-size: 0.8rem; color: #999;">N/A</span>';
                
                return `
                  <tr style="border-bottom: 1px solid #eee; background: ${isEven ? '#ffffff' : '#fafafa'};">
                    <td style="padding: 0.75rem; font-weight: 500;">
                      <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <div style="width: 16px; height: 16px; background: ${pillarColor}; border-radius: 2px; border: 1px solid rgba(0,0,0,0.1); flex-shrink: 0;" title="Color key for ${pillarNames[key]} in all reports"></div>
                        <span>${pillarNames[key]}</span>
                      </div>
                    </td>
                    <td style="padding: 0.75rem; text-align: center; font-size: 1.1rem; font-weight: 600; color: ${rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444'};">
                      ${Math.round(score)}
                    </td>
                    <td style="padding: 0.75rem; text-align: center; font-size: 0.9rem; font-weight: 600; color: #666;">
                      ${(weight * 100).toFixed(0)}%
                    </td>
                    <td style="padding: 0.75rem; text-align: center;">
                      <span class="rag-badge ${rag.status}" style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.8rem;">
                        ${rag.label}
                      </span>
                    </td>
                    <td style="padding: 0.75rem; color: #666; font-size: 0.85rem; line-height: 1.6; width: 42%;">${descriptionCell}</td>
                    <td style="padding: 0.75rem; color: #555; font-size: 0.85rem; line-height: 1.6; width: 22%;">${getNextSteps(key, score, currentGSCData, schemaAuditData)}</td>
                    <td style="padding: 0.75rem; text-align: center; width: 6%;">${dataDateDisplay}</td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
        <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-top: 1rem; border-left: 4px solid var(--brand-orange);">
          <p style="margin: 0; font-size: 0.9rem; color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
            <strong>RAG Status Guide:</strong> 
            <span style="color: #10b981; font-weight: 600;">Green (70-100)</span> = Strong performance, 
            <span style="color: #f59e0b; font-weight: 600;">Amber (40-69)</span> = Needs improvement, 
            <span style="color: #ef4444; font-weight: 600;">Red (0-39)</span> = Critical issues
          </p>
          <p style="margin: 0; font-size: 0.9rem; color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
            <strong>Weighting:</strong> Pillars are weighted by their importance for AI search systems. Authority (30%) and Content/Schema (25%) are most critical, as AI relies heavily on E-A-T signals and structured data. Visibility (20%) reflects how AI learns from existing performance, while Local Entity (15%) and Service Area (10%) are less critical for AI-powered results. Brand & Entity is treated as an overlay metric  it does not change the GAIO score but influences how AI systems attribute your content and build summaries.
          </p>
          <p style="margin: 0; font-size: 0.85rem; color: #666; line-height: 1.6; font-style: italic;">
            <strong>Note:</strong> Scores shown are for the last date in the trend chart range. If different audits were run on different days with different page counts or data scopes, scores may vary even if the underlying content didn't change. The "Data Date" column shows when the data was collected for each pillar.
          </p>
        </div>
      `;
      // Insert scorecard table after Score Trends chart (at the end)
      const trendChart = document.getElementById('trendChart');
      if (trendChart && trendChart.parentElement && trendChart.parentElement.parentNode) {
        // Find the chart container (parent of canvas) and insert after it
        const trendChartContainer = trendChart.parentElement;
        trendChartContainer.parentNode.insertBefore(scorecardTable, trendChartContainer.nextSibling);
      } else {
        // Fallback: insert at end of dashboard container
        const dashboardContainer = document.getElementById('dashboard');
        if (dashboardContainer) {
          dashboardContainer.appendChild(scorecardTable);
        } else {
          // Last resort: insert after pillar cards
          pillarCards.parentNode.insertBefore(scorecardTable, pillarCards.nextSibling);
        }
      }

      // Add CSV download handler for missing schema pages
      const downloadBtn = document.getElementById('download-missing-schema');
      if (downloadBtn && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        const missingSchemaCount = schemaData.missingSchemaCount || 0;
        const missingSchemaPages = schemaData.missingSchemaPages || [];
        
        debugLog(`Missing schema pages: count=${missingSchemaCount}, pages=${missingSchemaPages.length}`, 'info');
        debugLog(`Missing schema data: ${JSON.stringify(missingSchemaPages)}`, 'info');
        
        if (missingSchemaCount > 0 && missingSchemaPages.length > 0) {
          downloadBtn.addEventListener('click', () => {
            // Check if any pages have error field to determine CSV columns
            const hasErrors = missingSchemaPages.some(p => p.error);
            const headers = hasErrors ? ['url', 'parentUrl', 'error'] : ['url', 'parentUrl'];
            
            const rows = [
              headers,
              ...missingSchemaPages.map(p => [
                p.url, 
                p.parentUrl || '', 
                ...(hasErrors ? [p.error || ''] : [])
              ]),
            ];
            
            const csv = rows
              .map(r => r.map(v => `"${(v || '').replace(/"/g, '""')}"`).join(','))
              .join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ai-geo-missing-schema-pages.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          });
        } else {
          // Button is already disabled in the HTML, just log
          debugLog(`No missing schema pages to download (count: ${missingSchemaCount})`, 'info');
        }
      } else if (!downloadBtn) {
        debugLog('Download button not found in DOM', 'warn');
      }

      // Display snippet readiness with pie chart visualization
      const snippetScoreElement = document.getElementById('snippetReadinessScore');
      const gaugeStatus = document.getElementById('gaugeStatus');
      const legendElement = document.getElementById('snippetReadinessLegend');
      
      // Normalize snippetReadiness: handle both number and object formats
      let overallSnippetReadiness = 0;
      
      debugLog(`[Snippet Readiness] Input: snippetReadiness=${snippetReadiness} (type: ${typeof snippetReadiness}), scores=${scores ? 'present' : 'missing'}, contentSchema=${scores?.contentSchema}, visibility=${scores?.visibility}, authority=${scores?.authority}`, 'info');
      
      if (typeof snippetReadiness === 'number' && snippetReadiness > 0) {
        overallSnippetReadiness = snippetReadiness;
        debugLog(`[Snippet Readiness] Using provided number: ${overallSnippetReadiness}`, 'info');
      } else if (snippetReadiness && typeof snippetReadiness === 'object' && snippetReadiness.overallScore != null) {
        overallSnippetReadiness = snippetReadiness.overallScore;
        debugLog(`[Snippet Readiness] Using object.overallScore: ${overallSnippetReadiness}`, 'info');
      } else if (scores) {
        // ALWAYS recalculate if we have scores, even if snippetReadiness is 0
        // This ensures we show the correct value even if snippetReadiness wasn't saved properly
        const contentSchema = scores.contentSchema || 0;
        const visibility = scores.visibility || 0;
        const authority = typeof scores.authority === 'object' ? (scores.authority?.score || 0) : (scores.authority || 0);
        
        overallSnippetReadiness = calculateSnippetReadiness(scores, {});
        debugLog(`[Snippet Readiness] Recalculated from scores: ${overallSnippetReadiness} (contentSchema=${contentSchema}, visibility=${visibility}, authority=${authority})`, 'info');
      } else {
        debugLog(`[Snippet Readiness]  Cannot calculate: snippetReadiness=${snippetReadiness}, scores=${scores ? 'present' : 'missing'}`, 'warn');
      }
      
      if (snippetScoreElement) {
        snippetScoreElement.textContent = Math.round(overallSnippetReadiness);
        
        // Color code overall score based on value
        let colorClass = '#ef4444'; // red
        let statusText = 'Critical';
        if (overallSnippetReadiness >= 70) {
          colorClass = '#10b981'; // green
          statusText = 'Strong';
        } else if (overallSnippetReadiness >= 40) {
          colorClass = '#f59e0b'; // amber
          statusText = 'Needs Improvement';
        }
        
        snippetScoreElement.style.color = colorClass;
        
        // Update status text
        if (gaugeStatus) {
          gaugeStatus.textContent = statusText;
          gaugeStatus.style.color = colorClass;
        }
      }
      
      // Create pie chart showing weighted components
      const pieChartCanvas = document.getElementById('snippetReadinessPieChart');
      if (pieChartCanvas && scores) {
        // Destroy existing chart if it exists
        if (window.snippetReadinessChart) {
          window.snippetReadinessChart.destroy();
        }
        
        const contentSchemaScore = Math.round(scores.contentSchema || 0);
        const visibilityScore = Math.round(scores.visibility || 0);
        const authorityScore = Math.round(typeof scores.authority === 'object' ? (scores.authority.score || 0) : (scores.authority || 0));
        
        // Generate top 5 actionable levers to improve snippet readiness
        const explanationDiv = document.getElementById('snippetReadinessExplanation');
        const topActionsList = document.getElementById('topActionsList');
        if (explanationDiv && topActionsList && scores) {
          const contentSchemaScore = Math.round(scores.contentSchema || 0);
          const visibilityScore = Math.round(scores.visibility || 0);
          const authorityScore = Math.round(typeof scores.authority === 'object' ? (scores.authority.score || 0) : (scores.authority || 0));
          
          const actions = [];
          
          // Authority (25% weight) - usually lowest, highest impact potential
          if (authorityScore < 70) {
            const potentialGain = (70 - authorityScore) * 0.25; // Max potential points if improved to 70
            if (data && data.ctr !== undefined) {
              const ctr = data.ctr || 0;
              if (ctr < 1.5) {
                actions.push({
                  priority: 1,
                  impact: potentialGain,
                  text: `Improve Authority (currently ${authorityScore}%): Increase CTR from ${ctr.toFixed(1)}% to 2%+ by optimizing titles and meta descriptions. Potential gain: +${potentialGain.toFixed(1)} points.`
                });
              } else {
                actions.push({
                  priority: 1,
                  impact: potentialGain,
                  text: `Improve Authority (currently ${authorityScore}%): Build backlinks and improve E-A-T signals. Potential gain: +${potentialGain.toFixed(1)} points.`
                });
              }
            } else {
              actions.push({
                priority: 1,
                impact: potentialGain,
                text: `Improve Authority (currently ${authorityScore}%): Build backlinks, improve E-A-T signals, and optimize CTR. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            }
          }
          
          // Content/Schema (40% weight) - highest weight
          if (contentSchemaScore < 100 && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
            const schemaData = schemaAudit.data;
            const allTypes = new Set();
            // Use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
            if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
              schemaData.allDetectedTypes.forEach(type => {
                if (type) allTypes.add(type);
              });
            } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
              schemaData.schemaTypes.forEach(item => {
                if (item.type) allTypes.add(item.type);
              });
            }
            
            const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
            const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
            const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
            const uniqueTypesCount = allTypes.size;
            
            // Calculate potential improvements
            if (foundationPresent < 4) {
              const missingFoundation = foundationTypes.filter(type => !allTypes.has(type));
              const potentialGain = ((4 - foundationPresent) / 4) * 30 * 0.4; // 30% weight of 40% total
              actions.push({
                priority: 2,
                impact: potentialGain,
                text: `Add missing foundation schemas: ${missingFoundation.join(', ')}. Currently ${foundationPresent}/4. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            }
            
            // Get list of all rich result types (must match api/schema-audit.js)
            const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
            const totalRichResultTypes = richResultTypes.length;
            
            if (richEligibleCount < totalRichResultTypes) {
              const potentialGain = ((totalRichResultTypes - richEligibleCount) / totalRichResultTypes) * 35 * 0.4; // 35% weight of 40% total
              
              // Get list of which rich result types are missing
              const applicableMissingTypes = richResultTypes.filter(type => {
                return !schemaData.richEligible || !schemaData.richEligible[type];
              });
              
              // Check for failed crawls that might affect rich result detection
              const failedPages = schemaData.missingSchemaPages ? schemaData.missingSchemaPages.filter(p => p.error).length : 0;
              const hasFailedCrawls = failedPages > 0;
              
              // Build suggestion text
              let suggestionText;
              if (applicableMissingTypes.length > 0) {
                suggestionText = `Add more rich result types. Currently ${richEligibleCount}/${totalRichResultTypes} eligible. Add: ${applicableMissingTypes.join(', ')} schemas.`;
                if (hasFailedCrawls) {
                  suggestionText += ` Note: ${failedPages} page${failedPages !== 1 ? 's' : ''} failed to crawl - missing types may exist but weren't detected.`;
                }
                suggestionText += ` Potential gain: +${potentialGain.toFixed(1)} points.`;
              } else {
                suggestionText = `Add more rich result types. Currently ${richEligibleCount}/${totalRichResultTypes} eligible. Potential gain: +${potentialGain.toFixed(1)} points.`;
              }
              
              actions.push({
                priority: 3,
                impact: potentialGain,
                text: suggestionText
              });
            }
            
            if (uniqueTypesCount < 15) {
              const potentialGain = ((15 - uniqueTypesCount) / 15) * 15 * 0.4; // 15% weight of 40% total
              actions.push({
                priority: 4,
                impact: potentialGain,
                text: `Increase schema diversity. Currently ${uniqueTypesCount} types (target: 15+). Add more schema types across different page types. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            }
          }
          
          // Visibility (35% weight)
          if (visibilityScore < 90 && data && data.averagePosition !== undefined) {
            const position = data.averagePosition || 0;
            const ctr = data.ctr || 0;
            const potentialGain = (90 - visibilityScore) * 0.35;
            
            if (position > 10) {
              actions.push({
                priority: 5,
                impact: potentialGain,
                text: `Improve Visibility (currently ${visibilityScore}%): Target top 10 positions. Current average position: ${position.toFixed(1)}. Optimize for featured snippets. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            } else if (ctr < 2.0) {
              actions.push({
                priority: 5,
                impact: potentialGain,
                text: `Improve Visibility (currently ${visibilityScore}%): Increase CTR from ${ctr.toFixed(1)}% to 2%+ with better titles and meta descriptions. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            }
          }
          
          // Sort by impact (highest first) and take top 5
          actions.sort((a, b) => b.impact - a.impact);
          const top5Actions = actions.slice(0, 5);
          
          // Update the list
          topActionsList.innerHTML = top5Actions.map((action, index) => 
            `<li style="margin: 0.5rem 0; line-height: 1.5; color: #78350f;">${action.text}</li>`
          ).join('');
          
          if (top5Actions.length === 0) {
            topActionsList.innerHTML = '<li style="margin: 0.5rem 0;">All components are performing well! Maintain current performance.</li>';
          }
          
          explanationDiv.style.display = 'block';
        } else if (explanationDiv) {
          explanationDiv.style.display = 'none';
        }
        
        // Calculate weighted contribution of each component
        const contentSchemaContribution = (contentSchemaScore * 0.4).toFixed(1);
        const visibilityContribution = (visibilityScore * 0.35).toFixed(1);
        const authorityContribution = (authorityScore * 0.25).toFixed(1);
        
        // Create nested pie chart with fill percentages
        // Outer ring: Weighting (40%, 35%, 25%)
        // Inner fill: Score percentage within each segment (like fuel gauge)
        
        const weights = [40, 35, 25];
        const scoresArray = [contentSchemaScore, visibilityScore, authorityScore];
        // Match trend chart colors (avoid red/amber/green to prevent RAG confusion)
        const colors = ['#6b7280', '#2563eb', '#99004C']; // Grey (Content/Schema), Blue (Visibility), Dark pink/magenta (Authority)
        
        // Calculate outer ring data (weighting percentages)
        const outerData = weights;
        
        // Inner ring: Same segment sizes as outer, but we'll use custom drawing to fill only the score percentage
        // The inner data must match outer segment sizes so they align
        const innerData = weights; // Same sizes as outer
        
        // Create chart with custom drawing for inner fill segments
        window.snippetReadinessChart = new Chart(pieChartCanvas, {
          type: 'doughnut',
          data: {
            labels: [
              `Content/Schema`,
              `Visibility`,
              `Authority`
            ],
            datasets: [
              {
                // Outer ring: Weighting percentages (40%, 35%, 25%)
                label: 'Weight',
                data: outerData,
                backgroundColor: colors,
                borderWidth: 4,
                borderColor: '#ffffff',
                cutout: '60%' // Leave room for inner fill
              },
              {
                // Inner ring: Same segment sizes, but will be custom-drawn to show score fill
                label: 'Score Fill',
                data: innerData,
                backgroundColor: colors.map((color, i) => {
                  // Use darker version of segment color for unfilled portion
                  return color + '40'; // Add transparency
                }),
                borderWidth: 4,
                borderColor: '#ffffff',
                cutout: '75%' // Inner ring showing fill
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                display: false // We'll use custom legend
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const datasetIndex = context.datasetIndex;
                    const index = context.dataIndex;
                    
                    if (datasetIndex === 0) {
                      // Outer ring: Show weighting
                      return `Weight: ${weights[index]}%`;
                    } else {
                      // Inner fill: Show score and fill percentage
                      const score = scoresArray[index];
                      const fillPercent = (score / 100) * 100;
                      return `Score: ${score}% (${fillPercent.toFixed(0)}% of segment filled)`;
                    }
                  }
                }
              }
            }
          },
          plugins: [{
            id: 'innerFillAndLabels',
            afterDraw: (chart) => {
              const ctx = chart.ctx;
              const outerMeta = chart.getDatasetMeta(0); // Outer ring
              const innerMeta = chart.getDatasetMeta(1); // Inner ring
              const centerX = chart.chartArea.left + (chart.chartArea.right - chart.chartArea.left) / 2;
              const centerY = chart.chartArea.top + (chart.chartArea.bottom - chart.chartArea.top) / 2;
              const outerRadius = (chart.chartArea.right - chart.chartArea.left) / 2;
              const innerRadius = outerRadius * 0.75; // 75% cutout
              const outerInnerRadius = outerRadius * 0.60; // 60% cutout (where inner ring starts)
              
              // First, clear the inner ring segments (they're drawn by Chart.js but we'll redraw them)
              // Then draw custom filled portions based on scores
              
              outerMeta.data.forEach((outerSegment, index) => {
                const score = scoresArray[index];
                const scorePercent = score / 100; // 0 to 1
                const startAngle = outerSegment.startAngle;
                const endAngle = outerSegment.endAngle;
                const segmentAngle = endAngle - startAngle;
                const filledAngle = segmentAngle * scorePercent;
                const filledEndAngle = startAngle + filledAngle;
                
                // Get RAG color for fill
                let fillColor;
                if (score >= 70) fillColor = '#10b981'; // Green
                else if (score >= 40) fillColor = '#f59e0b'; // Amber
                else fillColor = '#ef4444'; // Red
                
                // Draw the filled portion of this inner segment (fuel gauge effect)
                ctx.save();
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerInnerRadius, startAngle, filledEndAngle, false);
                ctx.arc(centerX, centerY, innerRadius, filledEndAngle, startAngle, true);
                ctx.closePath();
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.restore();
                
                // Draw weight percentage in outer segment (larger, white for grey and blue segments, black for yellow)
                const outerSegmentMidAngle = (startAngle + endAngle) / 2;
                // Position closer to outer edge but still inside segment (about 75% of outer ring width)
                const outerSegmentTextRadius = outerRadius - ((outerRadius - outerInnerRadius) * 0.25);
                const weightTextX = centerX + Math.cos(outerSegmentMidAngle) * outerSegmentTextRadius;
                const weightTextY = centerY + Math.sin(outerSegmentMidAngle) * outerSegmentTextRadius;
                
                ctx.save();
                // Use white text for grey (Content/Schema), blue (Visibility), and dark pink (Authority) segments
                const textColor = (colors[index] === '#6b7280' || colors[index] === '#2563eb' || colors[index] === '#99004C') ? '#ffffff' : '#000000';
                ctx.fillStyle = textColor;
                ctx.font = 'bold 18px system-ui'; // Increased from 14px to 18px
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // Add shadow for readability (dark shadow for white text, light shadow for black text)
                if (textColor === '#ffffff') {
                  ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                } else {
                  ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
                }
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.fillText(`${weights[index]}%`, weightTextX, weightTextY);
                ctx.restore();
                
                // Draw label in the center area, aligned to segment
                const midAngle = (startAngle + endAngle) / 2;
                // Position label in center area (about 30% from center, well inside the 75% cutout)
                const labelRadius = outerRadius * 0.25; // Position in center area
                const labelX = centerX + Math.cos(midAngle) * labelRadius;
                const labelY = centerY + Math.sin(midAngle) * labelRadius;
                
                // Get component names
                const componentNames = ['Content/Schema', 'Visibility', 'Authority'];
                const weight = weights[index];
                
                // Calculate text bounds to avoid arrow overlap
                // Estimate text height: 3 lines with spacing  45px total height
                const textHeight = 45;
                const textWidth = 80; // Approximate max text width
                
                // Draw dotted arrow from label to segment edge, routing around text
                ctx.save();
                ctx.strokeStyle = colors[index];
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // Dotted line
                ctx.beginPath();
                
                // Start arrow from edge of text area with more padding to avoid overlap
                // Calculate perpendicular offset to route around text
                const perpAngle = midAngle + Math.PI / 2; // Perpendicular to segment angle
                const textOffset = 35; // Increased from 25 to 35 - more padding from text edge
                const perpOffset = (textHeight / 2) + 8; // Increased padding perpendicular to text
                const arrowStartX = labelX + Math.cos(midAngle) * textOffset + Math.cos(perpAngle) * perpOffset;
                const arrowStartY = labelY + Math.sin(midAngle) * textOffset + Math.sin(perpAngle) * perpOffset;
                
                // End at inner ring edge
                const segmentEdgeX = centerX + Math.cos(midAngle) * innerRadius;
                const segmentEdgeY = centerY + Math.sin(midAngle) * innerRadius;
                
                // Draw curved path around text (simple two-segment path)
                const midX = (arrowStartX + segmentEdgeX) / 2;
                const midY = (arrowStartY + segmentEdgeY) / 2;
                // Offset midpoint further outward to curve around text with more clearance
                const curveOffset = 25; // Increased from 15 to 25 for more clearance
                const curveMidX = midX + Math.cos(perpAngle) * curveOffset;
                const curveMidY = midY + Math.sin(perpAngle) * curveOffset;
                
                ctx.moveTo(arrowStartX, arrowStartY);
                ctx.quadraticCurveTo(curveMidX, curveMidY, segmentEdgeX, segmentEdgeY);
                ctx.stroke();
                
                // Draw arrowhead
                const arrowLength = 8;
                const arrowAngle = Math.atan2(segmentEdgeY - curveMidY, segmentEdgeX - curveMidX);
                ctx.setLineDash([]); // Solid for arrowhead
                ctx.beginPath();
                ctx.moveTo(segmentEdgeX, segmentEdgeY);
                ctx.lineTo(
                  segmentEdgeX - arrowLength * Math.cos(arrowAngle - Math.PI / 6),
                  segmentEdgeY - arrowLength * Math.sin(arrowAngle - Math.PI / 6)
                );
                ctx.moveTo(segmentEdgeX, segmentEdgeY);
                ctx.lineTo(
                  segmentEdgeX - arrowLength * Math.cos(arrowAngle + Math.PI / 6),
                  segmentEdgeY - arrowLength * Math.sin(arrowAngle + Math.PI / 6)
                );
                ctx.stroke();
                ctx.restore();
                
                // Draw text labels without circles (to prevent overlap)
                ctx.save();
                // Add text shadow for better readability without background
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Draw text with readable fonts
                ctx.fillStyle = colors[index];
                ctx.font = 'bold 13px system-ui';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // First line: Component name
                ctx.fillText(`${componentNames[index]}`, labelX, labelY - 8);
                // Second line: Score percentage (colored) - weight removed, now in outer segment
                ctx.fillStyle = fillColor;
                ctx.font = 'bold 15px system-ui';
                ctx.fillText(`Score: ${score}%`, labelX, labelY + 8);
                
                ctx.restore();
              });
            }
          }]
        });
        
        // Create custom legend with scores
        if (legendElement) {
          const getRAGColor = (score) => {
            if (score >= 70) return '#10b981';
            if (score >= 40) return '#f59e0b';
            return '#ef4444';
          };
          
          const getRAGLabel = (score) => {
            if (score >= 70) return 'Green';
            if (score >= 40) return 'Amber';
            return 'Red';
          };
          
          legendElement.innerHTML = `
            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #6b7280;">
              <div style="width: 12px; height: 12px; background: #6b7280; border-radius: 2px; flex-shrink: 0;"></div>
              <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Content/Schema</div>
                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 40%<br>Score: <strong style="color: ${getRAGColor(contentSchemaScore)};">${contentSchemaScore}</strong> (${getRAGLabel(contentSchemaScore)})<br>Contribution: ${contentSchemaContribution} pts</div>
              </div>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #2563eb;">
              <div style="width: 12px; height: 12px; background: #2563eb; border-radius: 2px; flex-shrink: 0;"></div>
              <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Visibility</div>
                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 35%<br>Score: <strong style="color: ${getRAGColor(visibilityScore)};">${visibilityScore}</strong> (${getRAGLabel(visibilityScore)})<br>Contribution: ${visibilityContribution} pts</div>
              </div>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #99004C;">
              <div style="width: 12px; height: 12px; background: #99004C; border-radius: 2px; flex-shrink: 0;"></div>
              <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Authority</div>
                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 25%<br>Score: <strong style="color: ${getRAGColor(authorityScore)};">${authorityScore}</strong> (${getRAGLabel(authorityScore)})<br>Contribution: ${authorityContribution} pts</div>
              </div>
            </div>
          `;
        }
      }

      // Format numbers for display
      const formatNumber = (num) => {
        if (num >= 1000000) {
          return (num / 1000000).toFixed(2) + 'M';
        } else if (num >= 1000) {
          return (num / 1000).toFixed(2) + 'K';
        }
        return num.toLocaleString();
      };

      // Display metrics
      const metricsGrid = document.getElementById('metricsGrid');
      metricsGrid.innerHTML = `
        <div class="metric-card">
          <div class="value">${formatNumber(data.totalClicks)}</div>
          <div class="label">Total Clicks</div>
        </div>
        <div class="metric-card">
          <div class="value">${formatNumber(data.totalImpressions)}</div>
          <div class="label">Total Impressions</div>
        </div>
        <div class="metric-card">
          <div class="value">${data.averagePosition.toFixed(1)}</div>
          <div class="label">Avg Position</div>
        </div>
        <div class="metric-card">
          <div class="value">${(data.ctr || 0).toFixed(1)}%</div>
          <div class="label">CTR</div>
        </div>
      `;

      // Wait a moment for DOM to update, then create charts (charts need visible canvas)
      setTimeout(async () => {
        debugLog('Starting chart creation (setTimeout callback)...', 'info');
        
        // Check if Chart.js is loaded
        debugLog('Checking Chart.js availability...', 'info');
        if (typeof Chart === 'undefined') {
          debugLog(' Chart.js library not loaded', 'error');
          console.error('Chart.js library not loaded');
          showStatus('Chart.js library failed to load. Please refresh the page.', 'error');
          return;
        }
        debugLog(' Chart.js library available', 'success');
        debugLog(`Chart constructor: ${typeof Chart}`, 'info');

        // Create radar chart
        debugLog('Creating radar chart...', 'info');
        const radarCanvas = document.getElementById('radarChart');
        if (!radarCanvas) {
          debugLog(' Radar chart canvas not found', 'error');
          console.error('Radar chart canvas not found');
          return;
        }
        debugLog(' Radar chart canvas found', 'success');
        
        // Safely destroy existing chart if it exists
        debugLog(`Checking for existing radarChart: ${window.radarChart ? 'exists' : 'null'}`, 'info');
        try {
          if (window.radarChart) {
            debugLog(`radarChart type: ${typeof window.radarChart}`, 'info');
            debugLog(`radarChart instanceof Chart: ${window.radarChart instanceof Chart}`, 'info');
            debugLog(`radarChart.destroy type: ${typeof window.radarChart.destroy}`, 'info');
            
            // Check if it's actually a Chart instance
            if (window.radarChart instanceof Chart && typeof window.radarChart.destroy === 'function') {
              debugLog('Destroying existing radar chart...', 'info');
              window.radarChart.destroy();
              debugLog(' Existing radar chart destroyed', 'success');
            } else {
              debugLog('Existing radarChart is not a valid Chart instance, clearing...', 'info');
            }
            window.radarChart = null;
          } else {
            debugLog('No existing radar chart to destroy', 'info');
          }
        } catch (e) {
          debugLog(` Error destroying existing radar chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.warn('Error destroying existing radar chart:', e);
          window.radarChart = null;
        }
        
        const radarCtx = radarCanvas.getContext('2d');
        debugLog('Creating new Chart instance for radar chart...', 'info');
        try {
          // Use ordered pillars for consistent ordering
          const orderedPillars = getOrderedPillars(scores);
          const orderedLabels = orderedPillars.map(([key]) => pillarNames[key]);
          const orderedData = orderedPillars.map(([, score]) => score);
          
          // Define pillar colors for radar chart (matching trend chart)
          const radarPillarColors = {
            'Local Entity': 'rgba(147, 51, 234, 1)', // Purple
            'Service Area': '#00FFFF', // Cyan (not RAG color)
            'Authority': '#99004C', // Dark pink/magenta
            'Visibility': 'rgba(37, 99, 235, 1)', // Blue
            'Content / Schema': 'rgba(107, 114, 128, 1)' // Grey
          };
          
          window.radarChart = new Chart(radarCtx, {
            type: 'radar',
            data: {
              labels: orderedLabels,
              datasets: [{
                label: 'Current Scores',
                data: orderedData,
                backgroundColor: 'rgba(59, 130, 246, 0.2)',
                borderColor: 'rgba(37, 99, 235, 1)',
                pointBackgroundColor: 'rgba(37, 99, 235, 1)',
                pointBorderColor: '#fff',
                pointHoverBackgroundColor: '#fff',
                pointHoverBorderColor: 'rgba(37, 99, 235, 1)'
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              layout: {
                padding: {
                  top: 20,
                  bottom: 20,
                  left: 20,
                  right: 20
                }
              },
              scales: {
                r: {
                  beginAtZero: false,
                  min: 20,
                  max: 100,
                  ticks: {
                    stepSize: 20,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    color: '#1e293b'
                  },
                  pointLabels: {
                    font: {
                      size: 16,
                      weight: 'bold'
                    },
                    color: '#1e293b',
                    padding: 20
                  },
                  grid: {
                    color: 'rgba(100, 116, 139, 0.2)'
                  },
                  angleLines: {
                    color: 'rgba(100, 116, 139, 0.3)'
                  }
                }
              },
              plugins: {
                legend: {
                  labels: {
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    padding: 15
                  }
                }
              }
            },
            plugins: [{
              id: 'radarScoreLabels',
              afterDraw: (chart) => {
                const ctx = chart.ctx;
                const scale = chart.scales.r;
                const pointLabelItems = scale._pointLabelItems || [];
                const dataset = chart.data.datasets[0];
                const meta = chart.getDatasetMeta(0);
                
                // Color each point with its pillar color (Chart.js already draws the lines)
                pointLabelItems.forEach((item, index) => {
                  if (item && orderedData[index] !== undefined) {
                    const score = orderedData[index];
                    const label = orderedLabels[index];
                    const color = radarPillarColors[label] || 'rgba(37, 99, 235, 1)';
                    
                    // Get the point for this index
                    const point = meta.data[index];
                    if (point) {
                      // Draw point in pillar color (Chart.js already draws the connecting lines)
                      ctx.save();
                      ctx.fillStyle = color;
                      ctx.beginPath();
                      ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                      ctx.fill();
                      ctx.strokeStyle = '#fff';
                      ctx.lineWidth = 2;
                      ctx.stroke();
                      ctx.restore();
                    }
                    
                    // Get RAG color based on score for text
                    let ragColor = '#1e293b'; // Default dark
                    if (score >= 70) ragColor = '#10b981'; // Green
                    else if (score >= 40) ragColor = '#f59e0b'; // Amber
                    else ragColor = '#ef4444'; // Red
                    
                    // Draw the score percentage directly below the label
                    ctx.save();
                    ctx.fillStyle = ragColor;
                    ctx.font = 'bold 14px system-ui';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
                    ctx.shadowBlur = 4;
                    // Position it 20px below the label
                    const scoreY = item.y + 20;
                    ctx.fillText(`${Math.round(score)}%`, item.x, scoreY);
                    ctx.restore();
                  }
                });
              }
            }]
          });
          debugLog(' Radar chart created successfully', 'success');
          debugLog(`radarChart type after creation: ${typeof window.radarChart}`, 'info');
          debugLog(`radarChart instanceof Chart: ${window.radarChart instanceof Chart}`, 'info');
        } catch (e) {
          debugLog(` Error creating radar chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.error('Error creating radar chart:', e);
        }

        // Create trend chart (mock data for now)
        debugLog('Creating trend chart...', 'info');
        const trendCanvas = document.getElementById('trendChart');
        if (!trendCanvas) {
          debugLog(' Trend chart canvas not found', 'error');
          console.error('Trend chart canvas not found');
          return;
        }
        debugLog(' Trend chart canvas found', 'success');
        
        // Show loading state while fetching data
        const trendChartContainer = trendCanvas.parentElement;
        if (trendChartContainer) {
          // Remove any existing error messages
          const existingError = trendChartContainer.querySelector('.trend-chart-error');
          if (existingError) existingError.remove();
          
          // Show loading spinner
          const loadingDiv = document.createElement('div');
          loadingDiv.className = 'trend-chart-loading';
          loadingDiv.style.cssText = 'text-align: center; padding: 2rem; color: #64748b; font-size: 0.9rem;';
          loadingDiv.innerHTML = '<div style="display: inline-block; width: 20px; height: 20px; border: 3px solid #e2e8f0; border-top-color: #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 0.5rem;"></div>Loading historical data from Supabase...';
          // Add spin animation if not already in stylesheet
          if (!document.getElementById('trend-chart-spin-style')) {
            const style = document.createElement('style');
            style.id = 'trend-chart-spin-style';
            style.textContent = '@keyframes spin { to { transform: rotate(360deg); } }';
            document.head.appendChild(style);
          }
          trendChartContainer.insertBefore(loadingDiv, trendCanvas);
        }
        
        // Safely destroy existing chart if it exists
        debugLog(`Checking for existing trendChart: ${window.trendChart ? 'exists' : 'null'}`, 'info');
        try {
          if (window.trendChart) {
            debugLog(`trendChart type: ${typeof window.trendChart}`, 'info');
            debugLog(`trendChart instanceof Chart: ${window.trendChart instanceof Chart}`, 'info');
            debugLog(`trendChart.destroy type: ${typeof window.trendChart.destroy}`, 'info');
            // Check if it's actually a Chart instance
            if (window.trendChart instanceof Chart && typeof window.trendChart.destroy === 'function') {
              debugLog('Destroying existing trend chart...', 'info');
              window.trendChart.destroy();
              debugLog(' Existing trend chart destroyed', 'success');
            } else {
              debugLog('Existing trendChart is not a valid Chart instance, clearing...', 'info');
            }
            window.trendChart = null;
          } else {
            debugLog('No existing trend chart to destroy', 'info');
          }
        } catch (e) {
          debugLog(` Error destroying existing trend chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.warn('Error destroying existing trend chart:', e);
          window.trendChart = null;
        }
        
        const trendCtx = trendCanvas.getContext('2d');
        const dateRange = parseInt(document.getElementById('dateRange').value) || 30;
        debugLog(`Creating trend chart for date range: ${dateRange} days`, 'info');
        
        // Determine number of data points and label frequency based on date range
        let numDataPoints, labelStep, dateFormat;
        if (dateRange <= 30) {
          // For 30 days or less: show daily data, all labels
          numDataPoints = dateRange;
          labelStep = 1;
          dateFormat = { month: 'short', day: 'numeric' };
        } else if (dateRange <= 90) {
          // For 90 days: show daily data, label every 3-5 days
          numDataPoints = dateRange;
          labelStep = Math.ceil(dateRange / 20); // ~20 labels max
          dateFormat = { month: 'short', day: 'numeric' };
        } else if (dateRange <= 180) {
          // For 6 months: show weekly data, label every week
          numDataPoints = Math.ceil(dateRange / 7);
          labelStep = 1;
          dateFormat = { month: 'short', day: 'numeric' };
        } else {
          // For 12 months: show weekly data, label every 2-4 weeks
          numDataPoints = Math.ceil(dateRange / 7);
          labelStep = Math.ceil(numDataPoints / 15); // ~15 labels max
          dateFormat = { month: 'short', day: 'numeric' };
        }
        
        // Generate date labels and store Date objects
        const allDates = Array.from({ length: numDataPoints }, (_, i) => {
          const d = new Date();
          if (dateRange <= 90) {
            // Daily data
            d.setDate(d.getDate() - (numDataPoints - 1 - i));
          } else {
            // Weekly data
            d.setDate(d.getDate() - ((numDataPoints - 1 - i) * 7));
          }
          return d;
        });
        
        // Store Date objects for period detection (for mock data)
        const mockDateObjects = allDates.slice();
        
        // Create labels array with appropriate spacing and year detection
        let lastVisibleYear = null;
        const dates = allDates.map((d, i) => {
          if (i % labelStep === 0 || i === allDates.length - 1) {
            const currentYear = d.getFullYear();
            const formattedDate = d.toLocaleDateString('en-GB', dateFormat);
            
            // Add year if it changed from the last visible label
            if (lastVisibleYear !== null && currentYear !== lastVisibleYear) {
              lastVisibleYear = currentYear;
              return `${formattedDate} ${currentYear}`;
            }
            
            lastVisibleYear = currentYear;
            return formattedDate;
          }
          return ''; // Empty string for labels we don't want to show
        });
        
        // Store date objects for mock data (will be updated if timeseries data exists)
        chartDateObjects = mockDateObjects;
        debugLog('Creating new Chart instance for trend chart...', 'info');
        try {
          // CRITICAL FIX: Always fetch fresh timeseries from Supabase instead of using stale data.timeseries
          // This ensures we have the latest GSC data, not just what was saved during the last audit
          let timeseries = [];
          const propertyUrl = document.getElementById('propertyUrl')?.value || data?.propertyUrl || '';
          if (propertyUrl) {
            try {
              const endDate = new Date().toISOString().split('T')[0];
              const startDate = new Date();
              startDate.setDate(startDate.getDate() - dateRange); // Use chart's date range
              const startDateStr = startDate.toISOString().split('T')[0];
              
              debugLog(`Fetching fresh timeseries from Supabase for date range: ${startDateStr} to ${endDate}`, 'info');
              const timeseriesResponse = await fetch(apiUrl(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDate}`));
              if (timeseriesResponse.ok) {
                const timeseriesData = await timeseriesResponse.json();
                if (timeseriesData.status === 'ok' && timeseriesData.timeseries && Array.isArray(timeseriesData.timeseries)) {
                  timeseries = timeseriesData.timeseries;
                  debugLog(` Fetched ${timeseries.length} fresh timeseries data points from Supabase (last date: ${timeseries.length > 0 ? timeseries[timeseries.length - 1].date : 'none'})`, 'success');
                } else {
                  debugLog(` Supabase timeseries response missing data, falling back to data.timeseries`, 'warn');
                  timeseries = data.timeseries || [];
                }
              } else {
                debugLog(` Failed to fetch timeseries from Supabase (${timeseriesResponse.status}), falling back to data.timeseries`, 'warn');
                timeseries = data.timeseries || [];
              }
            } catch (fetchError) {
              debugLog(` Error fetching fresh timeseries: ${fetchError.message}, falling back to data.timeseries`, 'warn');
              timeseries = data.timeseries || [];
            }
          } else {
            debugLog(` No property URL found, using data.timeseries`, 'warn');
            timeseries = data.timeseries || [];
          }
          
          debugLog(`Using ${timeseries.length} timeseries data points (last date: ${timeseries.length > 0 ? timeseries[timeseries.length - 1].date : 'none'})`, 'info');
          
          // Check if we have data
          if (!timeseries || timeseries.length === 0) {
            debugLog(' No timeseries data available. Chart will show mock data. Run a new audit to get real GSC historical data.', 'warn');
            // Show message to user (only if message doesn't already exist)
            const trendCanvas = document.getElementById('trendChart');
            if (trendCanvas && trendCanvas.parentElement) {
              // Check if message already exists
              const existingMessage = trendCanvas.parentElement.querySelector('.trend-chart-warning');
              if (!existingMessage) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'trend-chart-warning';
                messageDiv.style.cssText = 'background: #fff3cd; padding: 1rem; border-radius: 4px; border-left: 3px solid #f59e0b; margin-bottom: 1rem; font-size: 0.9rem; color: #856404;';
                messageDiv.innerHTML = '<strong>No historical data available.</strong> The trend chart requires timeseries data from Google Search Console. Please run a new audit to populate the chart with real historical data.';
                trendCanvas.parentElement.insertBefore(messageDiv, trendCanvas);
              }
            }
          }
          
          // If we have timeseries data, use it; otherwise fall back to mock data
          let localEntityData, serviceAreaData, authorityData, visibilityData, contentSchemaData, brandOverlayData;
          let contentSchemaDataEstimated = []; // Declare in outer scope for use in chart creation
          let chartDates = dates;
          let chartDateObjects = []; // Store Date objects for period detection
          
          // Declare maps in outer scope so they're accessible everywhere
          // Also make them global so displayDashboard can access them for Data Date display
          let contentSchemaHistory = [];
          let contentSchemaMap = new Map();
          let localEntityMap = new Map();
          let serviceAreaMap = new Map();
          let authorityMap = new Map(); // Store historical Authority scores from Supabase (legacy: single value)
          let authorityBySegmentMap = new Map(); // Store historical segmented Authority scores from Supabase (new: {all, nonEducation, money})
          let visibilityMap = new Map(); // Store historical Visibility scores from Supabase
          let brandOverlayMap = new Map(); // Store historical Brand Overlay scores from Supabase
          
          // Make maps global for access by displayDashboard
          window.visibilityMap = visibilityMap;
          window.authorityMap = authorityMap;
          window.brandOverlayMap = brandOverlayMap;
          const currentContentSchema = scores.contentSchema || 0;
          const currentBrandOverlay = scores.brandOverlay?.score || null;
          
          // Declare latestAuditDateStr and latestAuditDate in outer scope so they're accessible in timeseries.forEach
          let today = new Date();
          today.setHours(0, 0, 0, 0);
          let todayStr = today.toISOString().split('T')[0];
          let latestAuditDateStr = todayStr; // Default to today if no audit found
          let latestAuditDate = null; // Will be set from historical data
          
          if (timeseries.length > 0) {
            // Fetch historical Content/Schema data from Supabase (async operation)
            const propertyUrl = document.getElementById('propertyUrl')?.value || '';
            // Use the actual date range from timeseries data (not calculated from today)
            // This ensures we query the correct year (2024 vs 2025)
            const timeseriesStartDate = timeseries[0].date; // First date in timeseries
            const timeseriesEndDate = timeseries[timeseries.length - 1].date; // Last date in timeseries
            // CRITICAL: Query ALL historical audit data, not just timeseries range
            // The user manually added 18 months of historical data, so we need to fetch all of it
            // Query from 2 years ago to today to ensure we get all historical data
            // Don't limit to timeseries range - fetch all available historical audit data
            const historicalStartDate = new Date();
            historicalStartDate.setFullYear(historicalStartDate.getFullYear() - 2);
            const startDate = historicalStartDate.toISOString().split('T')[0]; // 2 years ago
            const endDate = todayStr; // Use today, not timeseries end date
            
            debugLog(`Fetching Content/Schema history from Supabase: ${startDate} to ${endDate} (ALL historical data)`, 'info');
            debugLog(`Timeseries date range: ${timeseriesStartDate} to ${timeseriesEndDate}`, 'info');
            
            // Fetch historical data asynchronously (includes Content/Schema AND Business Profile data)
            if (propertyUrl) {
              try {
                contentSchemaHistory = await fetchContentSchemaHistory(propertyUrl, startDate, endDate);
                
                // Handle multiple audits per day: only keep the latest audit for each date
                // Group by date and keep only the most recent one (by timestamp if available, or last in array)
                const auditsByDate = new Map();
                contentSchemaHistory.forEach(record => {
                  let normalizedDate = null;
                  if (record.date) {
                    if (typeof record.date === 'string') {
                      normalizedDate = record.date.split('T')[0];
                    } else if (record.date instanceof Date) {
                      normalizedDate = record.date.toISOString().split('T')[0];
                    } else {
                      normalizedDate = String(record.date).split('T')[0];
                    }
                  }
                  
                  if (normalizedDate) {
                    // If we already have an audit for this date, keep the one with later timestamp
                    const existing = auditsByDate.get(normalizedDate);
                    if (!existing || (record.timestamp && existing.timestamp && record.timestamp > existing.timestamp)) {
                      auditsByDate.set(normalizedDate, record);
                    }
                  }
                });
                
                // Use only the latest audit per date
                const deduplicatedHistory = Array.from(auditsByDate.values());
                debugLog(`Deduplicated ${contentSchemaHistory.length} audits to ${deduplicatedHistory.length} unique dates (removed ${contentSchemaHistory.length - deduplicatedHistory.length} duplicate dates)`, 'info');
                contentSchemaHistory = deduplicatedHistory;
                
                // CRITICAL: Validate audits for partial/failed data (for non-GSC pillars only)
                // Detect audits with suspiciously low page counts compared to recent audits
                // This prevents using partial audit data for Content/Schema and Local Entity/Service Area
                const validateAuditQuality = (records) => {
                  if (records.length === 0) return records;
                  
                  // Sort by date to find baseline
                  const sortedRecords = [...records].sort((a, b) => {
                    const dateA = a.date ? (typeof a.date === 'string' ? a.date.split('T')[0] : String(a.date).split('T')[0]) : '';
                    const dateB = b.date ? (typeof b.date === 'string' ? b.date.split('T')[0] : String(b.date).split('T')[0]) : '';
                    return dateA.localeCompare(dateB);
                  });
                  
                  // Find the median page count from recent audits (last 10 audits or all if < 10)
                  const recentAudits = sortedRecords.slice(-10);
                  const pageCounts = recentAudits
                    .map(r => r.schemaTotalPages || r.schema_total_pages || 0)
                    .filter(count => count > 0)
                    .sort((a, b) => a - b);
                  
                  if (pageCounts.length === 0) {
                    debugLog(`[Audit Validation] No page count data available, skipping validation`, 'info');
                    return records;
                  }
                  
                  // Use median as baseline (more robust than mean for outliers)
                  const medianPageCount = pageCounts[Math.floor(pageCounts.length / 2)];
                  const minAcceptablePages = Math.max(10, medianPageCount * 0.1); // At least 10% of median, minimum 10 pages
                  
                  debugLog(`[Audit Validation] Median page count: ${medianPageCount}, Minimum acceptable: ${minAcceptablePages}`, 'info');
                  
                  // Mark records with suspiciously low page counts
                  const validatedRecords = records.map(record => {
                    const alreadyPartial =
                      record?.isPartial === true ||
                      record?.is_partial === true ||
                      record?._isPartialAudit === true;
                    if (alreadyPartial) {
                      record._isPartialAudit = true;
                      record._partialReason = record?.partial_reason || record?._partialReason || 'Partial audit';
                      return record;
                    }
                    const pageCount = record.schemaTotalPages || record.schema_total_pages || 0;
                    const isSuspicious = pageCount > 0 && pageCount < minAcceptablePages;
                    
                    if (isSuspicious) {
                      // De-noise: only log each suspicious date once per page load.
                      window.__auditValidationWarnedDates = window.__auditValidationWarnedDates || new Set();
                      const k = String(record.date || '').split('T')[0];
                      if (!window.__auditValidationWarnedDates.has(k)) {
                        window.__auditValidationWarnedDates.add(k);
                        debugLog(`[Audit Validation]  Marking audit ${record.date} as suspicious: ${pageCount} pages (expected ~${medianPageCount})`, 'warn');
                      }
                      record._isPartialAudit = true;
                      record._partialReason = `Low page count: ${pageCount} pages (expected ~${medianPageCount})`;
                    }
                    
                    return record;
                  });
                  
                  return validatedRecords;
                };
                
                // Validate audit quality
                contentSchemaHistory = validateAuditQuality(contentSchemaHistory);
                
                // CRITICAL: Sort by date to ensure chronological processing
                // This ensures we always have a "last good value" to fall back to for partial audits
                contentSchemaHistory.sort((a, b) => {
                  const dateA = a.date ? (typeof a.date === 'string' ? a.date.split('T')[0] : String(a.date).split('T')[0]) : '';
                  const dateB = b.date ? (typeof b.date === 'string' ? b.date.split('T')[0] : String(b.date).split('T')[0]) : '';
                  return dateA.localeCompare(dateB);
                });
                
                // CRITICAL: Validate and smooth Authority scores
                // Backlink scores can drop to 0 if CSV isn't loaded, causing Authority to fluctuate wildly
                // Use last known good backlink score if current one is suspiciously low
                let lastGoodBacklinkScore = null;
                contentSchemaHistory.forEach(record => {
                  const backlinkScore = record.authorityBacklinkScore || record.authority_backlink_score;
                  if (backlinkScore !== null && backlinkScore !== undefined && backlinkScore > 0) {
                    lastGoodBacklinkScore = backlinkScore;
                  } else if (lastGoodBacklinkScore !== null && backlinkScore === 0) {
                    // Backlink score dropped to 0 - likely CSV not loaded, use last good value
                    record._useLastGoodBacklink = true;
                    record._lastGoodBacklinkScore = lastGoodBacklinkScore;
                    debugLog(`[Authority Validation]  Backlink score is 0 for ${record.date}, using last good value (${lastGoodBacklinkScore})`, 'warn');
                  }
                });
                
                // Recalculate Authority scores with smoothed backlink data
                contentSchemaHistory.forEach(record => {
                  if (record._useLastGoodBacklink && record.authorityScore !== null && record.authorityScore !== undefined) {
                    const behaviour = record.authorityBehaviourScore || record.authority_behaviour_score || 0;
                    const ranking = record.authorityRankingScore || record.authority_ranking_score || 0;
                    const backlinks = record._lastGoodBacklinkScore || 0;
                    const reviews = record.authorityReviewScore || record.authority_review_score || 0;
                    
                    // Recalculate Authority with smoothed backlink score
                    const recalculated = Math.round(
                      0.4 * behaviour +
                      0.2 * ranking +
                      0.2 * backlinks +
                      0.2 * reviews
                    );
                    
                    if (recalculated !== record.authorityScore) {
                      debugLog(`[Authority Validation] Recalculated Authority for ${record.date}: ${record.authorityScore}  ${recalculated} (using last good backlink score ${backlinks})`, 'info');
                      record._recalculatedAuthorityScore = recalculated; // Store separately, don't overwrite original
                    }
                  }
                });
                
                // Create maps of dates to scores from Supabase
                // Normalize dates to YYYY-MM-DD format (Supabase might return with timezone)
                // latestAuditDate is already tracked from the deduplication loop above
                // CRITICAL: Skip partial audits for non-GSC pillars (Content/Schema, Local Entity, Service Area)
                let lastGoodContentSchema = null;
                let lastGoodContentSchemaDate = null;
                let lastGoodLocalEntity = null;
                let lastGoodLocalEntityDate = null;
                let lastGoodServiceArea = null;
                let lastGoodServiceAreaDate = null;
                let lastGoodAuthority = null;
                let lastGoodAuthorityDate = null;
                
                contentSchemaHistory.forEach(record => {
                  // Ensure date is in YYYY-MM-DD format (strip time if present)
                  // Handle both date strings and Date objects
                  let normalizedDate = null;
                  if (record.date) {
                    if (typeof record.date === 'string') {
                      normalizedDate = record.date.split('T')[0];
                    } else if (record.date instanceof Date) {
                      normalizedDate = record.date.toISOString().split('T')[0];
                    } else {
                      normalizedDate = String(record.date).split('T')[0];
                    }
                  }
                  
                  if (normalizedDate) {
                    // Update latestAuditDate if this date is newer
                    if (!latestAuditDate || normalizedDate > latestAuditDate) {
                      latestAuditDate = normalizedDate;
                      latestAuditDateStr = normalizedDate;
                    }
                    // Content/Schema data - SKIP if partial audit
                    if (record.contentSchemaScore !== null && record.contentSchemaScore !== undefined) {
                      if (record._isPartialAudit) {
                        debugLog(`[Audit Validation]  Skipping Content/Schema for ${normalizedDate} (partial audit: ${record._partialReason}), using last good value (${lastGoodContentSchema} from ${lastGoodContentSchemaDate || 'none'})`, 'warn');
                        // Use last good value instead
                        if (lastGoodContentSchema !== null && lastGoodContentSchema !== undefined) {
                          contentSchemaMap.set(normalizedDate, lastGoodContentSchema);
                        }
                      } else {
                        contentSchemaMap.set(normalizedDate, record.contentSchemaScore);
                        lastGoodContentSchema = record.contentSchemaScore;
                        lastGoodContentSchemaDate = normalizedDate;
                        debugLog(`Mapped Content/Schema: ${normalizedDate} = ${record.contentSchemaScore}`, 'info');
                      }
                    }
                    // Business Profile data (Local Entity and Service Area) - SKIP if partial audit
                    if (record.localEntityScore !== null && record.localEntityScore !== undefined) {
                      if (record._isPartialAudit) {
                        debugLog(`[Audit Validation]  Skipping Local Entity for ${normalizedDate} (partial audit: ${record._partialReason}), using last good value (${lastGoodLocalEntity} from ${lastGoodLocalEntityDate || 'none'})`, 'warn');
                        // Use last good value instead
                        if (lastGoodLocalEntity !== null && lastGoodLocalEntity !== undefined) {
                          localEntityMap.set(normalizedDate, lastGoodLocalEntity);
                        }
                      } else {
                        localEntityMap.set(normalizedDate, record.localEntityScore);
                        lastGoodLocalEntity = record.localEntityScore;
                        lastGoodLocalEntityDate = normalizedDate;
                        debugLog(`Mapped Local Entity: ${normalizedDate} = ${record.localEntityScore}`, 'info');
                      }
                    }
                    if (record.serviceAreaScore !== null && record.serviceAreaScore !== undefined) {
                      if (record._isPartialAudit) {
                        debugLog(`[Audit Validation]  Skipping Service Area for ${normalizedDate} (partial audit: ${record._partialReason}), using last good value (${lastGoodServiceArea} from ${lastGoodServiceAreaDate || 'none'})`, 'warn');
                        // Use last good value instead
                        if (lastGoodServiceArea !== null && lastGoodServiceArea !== undefined) {
                          serviceAreaMap.set(normalizedDate, lastGoodServiceArea);
                        }
                      } else {
                        serviceAreaMap.set(normalizedDate, record.serviceAreaScore);
                        lastGoodServiceArea = record.serviceAreaScore;
                        lastGoodServiceAreaDate = normalizedDate;
                        debugLog(`Mapped Service Area: ${normalizedDate} = ${record.serviceAreaScore}`, 'info');
                      }
                    }
                    // Authority data (use stored Authority score if available, calculated with new formula)
                    // CRITICAL: Use recalculated Authority score if backlink smoothing was applied
                    if (record.authorityScore !== null && record.authorityScore !== undefined) {
                      // Use recalculated score if available (from backlink smoothing)
                      const authorityScoreToUse = record._recalculatedAuthorityScore !== undefined 
                        ? record._recalculatedAuthorityScore 
                        : record.authorityScore;
                      if (record._isPartialAudit) {
                        debugLog(`[Audit Validation]  Skipping Authority for ${normalizedDate} (partial audit: ${record._partialReason}), using last good value (${lastGoodAuthority} from ${lastGoodAuthorityDate || 'none'})`, 'warn');
                        if (lastGoodAuthority !== null && lastGoodAuthority !== undefined) {
                          authorityMap.set(normalizedDate, lastGoodAuthority);
                        }
                      } else {
                        authorityMap.set(normalizedDate, authorityScoreToUse);
                        lastGoodAuthority = authorityScoreToUse;
                        lastGoodAuthorityDate = normalizedDate;
                        if (record._recalculatedAuthorityScore !== undefined) {
                          debugLog(`Mapped Authority (smoothed): ${normalizedDate} = ${authorityScoreToUse} (was ${record.authorityScore})`, 'info');
                        } else {
                          debugLog(`Mapped Authority: ${normalizedDate} = ${authorityScoreToUse}`, 'info');
                        }
                      }
                    }
                    // Segmented Authority data (new: store segmented scores for historical tracking)
                    if (record.authorityBySegment !== null && record.authorityBySegment !== undefined) {
                      // authorityBySegment is a JSON object: {all: {total, behaviour, ranking, backlinks, reviews}, nonEducation: {...}, money: {...}}
                      authorityBySegmentMap.set(normalizedDate, record.authorityBySegment);
                      debugLog(`Mapped Authority by Segment: ${normalizedDate} = ${JSON.stringify(record.authorityBySegment)}`, 'info');
                    }
                    // Visibility data (use stored Visibility score from Supabase)
                    if (record.visibilityScore !== null && record.visibilityScore !== undefined) {
                      visibilityMap.set(normalizedDate, record.visibilityScore);
                      debugLog(`Mapped Visibility: ${normalizedDate} = ${record.visibilityScore}`, 'info');
                    }
                    // Brand Overlay data (Phase 1: stored as brand_score)
                    if (record.brandScore !== null && record.brandScore !== undefined) {
                      brandOverlayMap.set(normalizedDate, record.brandScore);
                      debugLog(`Mapped Brand Overlay: ${normalizedDate} = ${record.brandScore}`, 'info');
                    }
                  }
                });
                
                const hasHistoricalData = contentSchemaHistory.length > 0;
                if (hasHistoricalData) {
                  debugLog(`Using ${contentSchemaHistory.length} historical audit records from Supabase`, 'info');
                  // Debug: Show what data we have for each pillar
                  const contentSchemaCount = Array.from(contentSchemaMap.values()).filter(v => v !== null && v !== undefined).length;
                  const localEntityCount = Array.from(localEntityMap.values()).filter(v => v !== null && v !== undefined).length;
                  const serviceAreaCount = Array.from(serviceAreaMap.values()).filter(v => v !== null && v !== undefined).length;
                  const authorityCount = Array.from(authorityMap.values()).filter(v => v !== null && v !== undefined).length;
                  const visibilityCount = Array.from(visibilityMap.values()).filter(v => v !== null && v !== undefined).length;
                  const brandCount = Array.from(brandOverlayMap.values()).filter(v => v !== null && v !== undefined).length;
                  debugLog(`[Supabase Data] Content/Schema: ${contentSchemaCount} entries, Local Entity: ${localEntityCount} entries, Service Area: ${serviceAreaCount} entries, Authority: ${authorityCount} entries, Visibility: ${visibilityCount} entries, Brand: ${brandCount} entries`, 'info');
                  
                  // Debug: Show sample records to understand structure
                  if (contentSchemaHistory.length > 0) {
                    const sampleRecord = contentSchemaHistory[0];
                    debugLog(`[Sample Record] Keys: ${Object.keys(sampleRecord).join(', ')}, date: ${sampleRecord.date}, contentSchemaScore: ${sampleRecord.contentSchemaScore}, localEntityScore: ${sampleRecord.localEntityScore}, serviceAreaScore: ${sampleRecord.serviceAreaScore}`, 'info');
                  }
                  
                  // Show latest dates for each pillar
                  if (contentSchemaMap.size > 0) {
                    const latestContentSchemaDate = Array.from(contentSchemaMap.keys()).sort().reverse()[0];
                    debugLog(`[Supabase Data] Latest Content/Schema date: ${latestContentSchemaDate}`, 'info');
                  }
                  if (localEntityMap.size > 0) {
                    const latestLocalEntityDate = Array.from(localEntityMap.keys()).sort().reverse()[0];
                    debugLog(`[Supabase Data] Latest Local Entity date: ${latestLocalEntityDate}`, 'info');
                  }
                  if (serviceAreaMap.size > 0) {
                    const latestServiceAreaDate = Array.from(serviceAreaMap.keys()).sort().reverse()[0];
                    debugLog(`[Supabase Data] Latest Service Area date: ${latestServiceAreaDate}`, 'info');
                  }
                } else {
                  debugLog(`No historical data found. Will use current scores for all points.`, 'info');
                }
                
                // Phase 3: Render Money Pages trend chart
                if (typeof renderMoneyPagesTrendChart === 'function') {
                  setTimeout(() => {
                    renderMoneyPagesTrendChart(contentSchemaHistory);
                  }, 1000); // Delay to ensure DOM is ready and chart container exists
                } else {
                  debugLog(' renderMoneyPagesTrendChart function not found', 'warn');
                }
              } catch (error) {
                debugLog(` Error fetching historical data: ${error.message}`, 'warn');
                // Ensure latestAuditDateStr is still defined even if fetch fails
                // It's already set to todayStr as default, so it should be fine
                debugLog(`Using default latestAuditDateStr: ${latestAuditDateStr}`, 'info');
                contentSchemaHistory = [];
              }
            } else {
              debugLog(`No property URL found. Cannot fetch historical data.`, 'info');
            }
            
            // Get current Business Profile data for Local Entity and Service Area (fallback if no historical data)
            const hasLocalSignals = saved && saved.localSignals && saved.localSignals.status === 'ok' && saved.localSignals.data;
            const localSignalsData = hasLocalSignals ? saved.localSignals.data : null;
            
            // Calculate current Local Entity and Service Area scores from Business Profile data (if available)
            // These will be used as fallback when historical data is not available for a specific date
            let currentLocalEntity, currentServiceArea;
            if (hasLocalSignals && localSignalsData) {
              // Local Entity: NAP consistency + bonuses
              let baseScore = localSignalsData.napConsistencyScore || 0;
              if (localSignalsData.knowledgePanelDetected) {
                baseScore = Math.min(100, baseScore + 10);
              }
              if (localSignalsData.locations && localSignalsData.locations.length > 0) {
                baseScore = Math.min(100, baseScore + 5);
              }
              currentLocalEntity = clampScore(baseScore);
              
              // Service Area: based on service areas count
              const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
              if (serviceAreasCount === 0) {
                currentServiceArea = 0;
              } else if (serviceAreasCount >= 8) {
                // 8+ service areas = 100 (more reasonable threshold)
                currentServiceArea = 100;
              } else {
                // Linear scale: 1 area = 12.5 points (8 areas = 100)
                currentServiceArea = Math.min(100, serviceAreasCount * 12.5);
              }
              
              // Apply NAP consistency as a multiplier (if NAP is low, reduce service area score)
              if (localSignalsData.napConsistencyScore !== null && localSignalsData.napConsistencyScore < 100) {
                const napMultiplier = localSignalsData.napConsistencyScore / 100;
                currentServiceArea = Math.round(currentServiceArea * napMultiplier);
              }
              currentServiceArea = clampScore(currentServiceArea);
              
              debugLog(`Trend chart: Current Business Profile data - Local Entity=${currentLocalEntity}, Service Area=${currentServiceArea} (used as fallback)`, 'info');
            } else {
              // Fallback: use derived calculation
              currentLocalEntity = null;
              currentServiceArea = null;
              debugLog('Trend chart: No Business Profile data available, will use derived calculation for dates without historical data', 'warn');
            }
            
            // Calculate pillar scores for each timeseries point
            // For Local Entity and Service Area: use historical Business Profile data if available,
            // otherwise use calculated data from GSC (derived calculation)
            const calculatePillarFromMetrics = (position, ctr, dateStr = null, topQueries = null, backlinkMetrics = null, localSignals = null, siteReviews = null) => {
              // Position score (same formula as main calculation)
              const clampedPos = Math.max(1, Math.min(40, position));
              const scale = (clampedPos - 1) / 39;
              const posScore = 100 - scale * 90;
              
              // CTR score (needed for Local Entity calculation and Authority fallback)
              // Convert ctr from percentage (0-100) to decimal (0-1), then apply formula
              const ctrDecimal = ctr / 100; // Convert percentage to decimal (e.g., 10% -> 0.10)
              const ctrScore = Math.min((ctrDecimal / 0.10) * 100, 100);
              
              // Calculate each pillar (same formulas as main calculation)
              const visibility = clampScore(posScore);
              
              // Authority: New 4-component model
              // Check if we have stored Authority component scores for this date
              let authority;
              if (dateStr && authorityMap && authorityMap.has(dateStr)) {
                // Use stored Authority score from Supabase (calculated with new formula)
                authority = authorityMap.get(dateStr);
                debugLog(`Authority: Using stored score (${authority}) for ${dateStr}`, 'info');
              } else if (topQueries && Array.isArray(topQueries) && topQueries.length > 0) {
                // We have topQueries data - use full 4-component calculation
                const queriesForCalculation = topQueries.map(q => ({
                  clicks: q.clicks || 0,
                  impressions: q.impressions || 0,
                  ctr: (q.ctr || 0) / 100, // Convert percentage to decimal
                  position: q.position || 0
                }));
                
                const behaviourScore = computeBehaviourScore(queriesForCalculation);
                const rankingScore = computeRankingScore(queriesForCalculation);
                
                // Use real backlink and review scores if available (for today's date)
                const backlinkScore = computeBacklinkScore(backlinkMetrics);
                
                // Get review data
                const gbpRating = (localSignals && localSignals.status === 'ok' && localSignals.data) 
                  ? (localSignals.data.gbpRating !== null && localSignals.data.gbpRating !== undefined ? localSignals.data.gbpRating : null)
                  : null;
                const gbpCount = (localSignals && localSignals.status === 'ok' && localSignals.data) 
                  ? (localSignals.data.gbpReviewCount !== null && localSignals.data.gbpReviewCount !== undefined ? localSignals.data.gbpReviewCount : null)
                  : null;
                const siteRating = siteReviews?.siteRating !== null && siteReviews?.siteRating !== undefined ? siteReviews.siteRating : null;
                const siteCount = siteReviews?.siteReviewCount !== null && siteReviews?.siteReviewCount !== undefined ? siteReviews.siteReviewCount : null;
                
                const reviewScore = computeReviewScore({
                  gbpRating,
                  gbpCount,
                  siteRating,
                  siteCount
                });
                
                authority = clampScore(
                  0.4 * behaviourScore +
                  0.2 * rankingScore +
                  0.2 * backlinkScore +
                  0.2 * reviewScore
                );
                debugLog(`Authority: Calculated from topQueries for ${dateStr || 'current'}: Behaviour=${behaviourScore.toFixed(1)}, Ranking=${rankingScore.toFixed(1)}, Backlinks=${backlinkScore}, Reviews=${reviewScore}, Final=${authority}`, 'info');
              } else {
                // Fallback: Simplified Authority calculation from aggregate metrics
                // Estimate Behaviour and Ranking scores from aggregate metrics
                // Behaviour: Use aggregate CTR as proxy (simplified)
                const estimatedBehaviourScore = Math.min(ctrScore * 0.7, 70); // Max 70 points
                
                // Ranking: Use position score (simplified)
                const estimatedRankingScore = posScore * 0.6; // Max 60 points (position) + 40 (share estimate)
                const estimatedShareScore = 20; // Conservative estimate for top-10 share
                const estimatedRanking = estimatedRankingScore + estimatedShareScore;
                
                const backlinkScore = 50; // Placeholder
                const reviewScore = 50; // Placeholder
                
                authority = clampScore(
                  0.4 * estimatedBehaviourScore +
                  0.2 * estimatedRanking +
                  0.2 * backlinkScore +
                  0.2 * reviewScore
                );
                debugLog(`Authority: Using simplified calculation from aggregate metrics for ${dateStr || 'current'}: Estimated Behaviour=${estimatedBehaviourScore.toFixed(1)}, Estimated Ranking=${estimatedRanking.toFixed(1)}, Final=${authority}`, 'info');
              }
              
              // For Local Entity and Service Area:
              // 1. Check for historical Business Profile data for this specific date
              // 2. If no historical data, use calculated data from GSC (derived calculation)
              // 3. Only use current Business Profile data as last resort (for recent dates without historical data)
              let localEntity, serviceArea;
              
              if (dateStr) {
                const historicalLocalEntity = localEntityMap.get(dateStr);
                const historicalServiceArea = serviceAreaMap.get(dateStr);
                
                if (historicalLocalEntity !== null && historicalLocalEntity !== undefined) {
                  // Use historical Business Profile data
                  localEntity = historicalLocalEntity;
                } else {
                  // Use calculated data from GSC (derived calculation) for historical dates
                  localEntity = clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
                }
                
                if (historicalServiceArea !== null && historicalServiceArea !== undefined) {
                  // Use historical Business Profile data
                  serviceArea = historicalServiceArea;
                } else {
                  // Use calculated data from GSC (derived calculation) for historical dates
                  serviceArea = clampScore(localEntity - 5);
                }
              } else {
                // No date provided - use current Business Profile data if available, otherwise calculated
                localEntity = currentLocalEntity !== null 
                  ? currentLocalEntity 
                  : clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
                serviceArea = currentServiceArea !== null 
                  ? currentServiceArea 
                  : clampScore(localEntity - 5);
              }
              
              return { visibility, authority, localEntity, serviceArea };
            };
            
            // Extract data arrays from timeseries
            localEntityData = [];
            serviceAreaData = [];
            authorityData = [];
            visibilityData = [];
            contentSchemaData = [];
            brandOverlayData = [];
            contentSchemaDataEstimated = []; // Reset array for timeseries data
            const allDateObjects = []; // Store Date objects for year detection
            const allDates = [];
            
            debugLog(`Content/Schema map has ${contentSchemaMap.size} entries: ${Array.from(contentSchemaMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
            debugLog(`Local Entity map has ${localEntityMap.size} entries: ${Array.from(localEntityMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
            debugLog(`Service Area map has ${serviceAreaMap.size} entries: ${Array.from(serviceAreaMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
            debugLog(`Timeseries has ${timeseries.length} points`, 'info');
            
            // Get current audit data for today's full Authority calculation
            const savedAuditForTrend = loadAuditResults();
            const currentTopQueries = savedAuditForTrend?.searchData?.topQueries || null;
            const currentBacklinkMetrics = savedAuditForTrend?.backlinkMetrics || null;
            const currentLocalSignals = savedAuditForTrend?.localSignals || null;
            // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
            const currentSiteReviews = getTrustpilotSnapshot(savedAuditForTrend?.siteReviews || null);
            const currentScores = savedAuditForTrend?.scores;
            
            // Check if segmentation data is available and show/hide toggle
            const authorityBySegment = currentScores?.authority?.bySegment || null;
            const trendToggle = document.getElementById('trendAuthorityModeToggle');
            if (trendToggle) {
              if (authorityBySegment) {
                trendToggle.style.display = 'block';
                // Initialize mode if not set
                if (!window.trendAuthorityMode) {
                  window.trendAuthorityMode = 'all';
                }
              } else {
                trendToggle.style.display = 'none';
                window.trendAuthorityMode = 'all'; // Default to all
              }
            }
            
            // Get Authority score for selected mode
            const getAuthorityForMode = (mode) => {
              if (authorityBySegment && authorityBySegment[mode]) {
                return authorityBySegment[mode].total || authorityBySegment[mode].score || 0;
              }
              // Fallback to all or main score
              if (authorityBySegment && authorityBySegment.all) {
                return authorityBySegment.all.total || authorityBySegment.all.score || 0;
              }
              // Legacy fallback
              const authObj = currentScores?.authority;
              if (typeof authObj === 'object' && authObj !== null) {
                return authObj.score || 0;
              }
              return authObj || 0;
            };
            
            timeseries.forEach(point => {
              const pointDate = point.date; // YYYY-MM-DD format
              
              // Check if this is the latest audit date - if so, use stored scores from Supabase or current audit
              // Use latestAuditDateStr (from Supabase) instead of todayStr to ensure we use actual latest audit
              const isLatestAudit = pointDate === latestAuditDateStr;
              
              // Check if we have historical data from Supabase for Local Entity, Service Area, and Authority
              const historicalLocalEntity = localEntityMap.get(pointDate);
              const historicalServiceArea = serviceAreaMap.get(pointDate);
              const historicalAuthority = authorityMap.get(pointDate);
              
              // For latest audit date, use current topQueries, backlinkMetrics, and reviews for full calculation
              // For historical dates, pass null (will use simplified calculation)
              const topQueriesForDate = isLatestAudit ? currentTopQueries : null;
              const backlinkMetricsForDate = isLatestAudit ? currentBacklinkMetrics : null;
              const localSignalsForDate = isLatestAudit ? currentLocalSignals : null;
              const siteReviewsForDate = isLatestAudit ? currentSiteReviews : null;
              
              // Pass date to calculatePillarFromMetrics so it can check for historical data
              // For today, pass topQueries and other data for full calculation
              // For historical dates, pass null (will use simplified calculation)
              const pillarScores = calculatePillarFromMetrics(
                point.position, 
                point.ctr, 
                pointDate, 
                topQueriesForDate,
                backlinkMetricsForDate,
                localSignalsForDate,
                siteReviewsForDate
              );
              
              // Local Entity and Service Area: Use historical data from Supabase if available
              // These don't require GSC data, so should use latest available score for missing dates
              if (historicalLocalEntity !== undefined && historicalLocalEntity !== null) {
                localEntityData.push(historicalLocalEntity);
                debugLog(`Using historical Local Entity (${historicalLocalEntity}) for ${pointDate}`, 'info');
              } else {
                // For missing dates, use the most recent available score from the map
                let latestAvailableLocalEntity = null;
                let latestAvailableDate = null;
                localEntityMap.forEach((score, mapDate) => {
                  if (mapDate <= pointDate && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
                    latestAvailableDate = mapDate;
                    latestAvailableLocalEntity = score;
                  }
                });
                
                if (latestAvailableLocalEntity !== null && latestAvailableLocalEntity !== undefined) {
                  localEntityData.push(latestAvailableLocalEntity);
                  debugLog(`Using latest available Local Entity (${latestAvailableLocalEntity} from ${latestAvailableDate}) for ${pointDate}`, 'info');
                } else if (isLatestAudit) {
                  // For latest audit date, use current score
                  const savedAuditForLocal = loadAuditResultsSync();
                  const currentLocalEntity = savedAuditForLocal?.scores?.localEntity;
                  if (currentLocalEntity !== null && currentLocalEntity !== undefined && currentLocalEntity > 0) {
                    localEntityData.push(currentLocalEntity);
                    debugLog(`Using current Local Entity (${currentLocalEntity}) for ${pointDate} (latest audit)`, 'info');
                  } else {
                    localEntityData.push(null);
                    debugLog(`No Local Entity data for ${pointDate}`, 'warn');
                  }
                } else {
                  localEntityData.push(null);
                  debugLog(`No Local Entity data for ${pointDate} (no historical or current data)`, 'info');
                }
              }
              
              if (historicalServiceArea !== undefined && historicalServiceArea !== null) {
                serviceAreaData.push(historicalServiceArea);
                debugLog(`Using historical Service Area (${historicalServiceArea}) for ${pointDate}`, 'info');
              } else {
                // For missing dates, use the most recent available score from the map
                let latestAvailableServiceArea = null;
                let latestAvailableDate = null;
                serviceAreaMap.forEach((score, mapDate) => {
                  if (mapDate <= pointDate && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
                    latestAvailableDate = mapDate;
                    latestAvailableServiceArea = score;
                  }
                });
                
                if (latestAvailableServiceArea !== null && latestAvailableServiceArea !== undefined) {
                  serviceAreaData.push(latestAvailableServiceArea);
                  debugLog(`Using latest available Service Area (${latestAvailableServiceArea} from ${latestAvailableDate}) for ${pointDate}`, 'info');
                } else if (isLatestAudit) {
                  // For latest audit date, use current score
                  const savedAuditForService = loadAuditResultsSync();
                  const currentServiceArea = savedAuditForService?.scores?.serviceArea;
                  if (currentServiceArea !== null && currentServiceArea !== undefined && currentServiceArea > 0) {
                    serviceAreaData.push(currentServiceArea);
                    debugLog(`Using current Service Area (${currentServiceArea}) for ${pointDate} (latest audit)`, 'info');
                  } else {
                    serviceAreaData.push(null);
                    debugLog(`No Service Area data for ${pointDate}`, 'warn');
                  }
                } else {
                  serviceAreaData.push(null);
                  debugLog(`No Service Area data for ${pointDate} (no historical or current data)`, 'info');
                }
              }
              
              // Use Authority score based on selected mode, prioritizing segmented historical data when available
              // Check if we have segmented Authority data for this date in Supabase
              const historicalAuthorityBySegment = authorityBySegmentMap.get(pointDate);
              const selectedMode = window.trendAuthorityMode || 'all';
              
              if (historicalAuthorityBySegment && historicalAuthorityBySegment[selectedMode]) {
                // Use segmented Authority score from Supabase for the selected mode
                const modeScore = historicalAuthorityBySegment[selectedMode].total || historicalAuthorityBySegment[selectedMode].score || historicalAuthorityBySegment[selectedMode];
                authorityData.push(modeScore);
                debugLog(`Using historical segmented Authority (${modeScore}) for ${pointDate} (mode: ${selectedMode})`, 'info');
              } else if (isLatestAudit) {
                // For latest audit date, prioritize stored Authority score from current audit
                const savedAuditForAuthority = loadAuditResultsSync();
                const currentAuthority = savedAuditForAuthority?.scores?.authority;
                let authorityScoreToUse = null;
                
                // Try to get Authority score based on selected mode
                if (authorityBySegment) {
                  authorityScoreToUse = getAuthorityForMode(selectedMode);
                } else if (typeof currentAuthority === 'object' && currentAuthority !== null) {
                  authorityScoreToUse = currentAuthority.score || currentAuthority;
                } else if (typeof currentAuthority === 'number') {
                  authorityScoreToUse = currentAuthority;
                }
                
                if (authorityScoreToUse !== null && authorityScoreToUse !== undefined && authorityScoreToUse > 0) {
                  authorityData.push(authorityScoreToUse);
                  debugLog(`Using current stored Authority (${authorityScoreToUse}) for ${pointDate} (mode: ${selectedMode}, latest audit)`, 'info');
                } else {
                  // Fallback to calculated score if stored score not available
                  const authScore = typeof pillarScores.authority === 'object' ? pillarScores.authority.score : pillarScores.authority;
                  authorityData.push(authScore);
                  debugLog(`Using calculated Authority (${authScore}) for ${pointDate} (stored score not available)`, 'info');
                }
              } else if (historicalAuthority !== undefined && historicalAuthority !== null) {
                // Fallback: use legacy historical Authority from Supabase (single value, not segmented)
                authorityData.push(historicalAuthority);
                debugLog(`Using legacy historical Authority (${historicalAuthority}) for ${pointDate}`, 'info');
              } else {
                // For missing dates, use the most recent available score from Supabase (prevents artificial dips)
                let latestAvailableAuthority = null;
                let latestAvailableAuthorityDate = null;
                
                // Prefer segmented historical Authority if available (match selected mode)
                authorityBySegmentMap.forEach((seg, mapDate) => {
                  if (mapDate <= pointDate && (latestAvailableAuthorityDate === null || mapDate > latestAvailableAuthorityDate)) {
                    if (seg && seg[selectedMode] !== undefined && seg[selectedMode] !== null) {
                      const v = seg[selectedMode].total || seg[selectedMode].score || seg[selectedMode];
                      latestAvailableAuthorityDate = mapDate;
                      latestAvailableAuthority = v;
                    }
                  }
                });
                
                // Fallback to legacy Authority map if segmented isn't available
                if (latestAvailableAuthority === null || latestAvailableAuthority === undefined) {
                  authorityMap.forEach((score, mapDate) => {
                    if (mapDate <= pointDate && (latestAvailableAuthorityDate === null || mapDate > latestAvailableAuthorityDate)) {
                      latestAvailableAuthorityDate = mapDate;
                      latestAvailableAuthority = score;
                    }
                  });
                }
                
                if (latestAvailableAuthority !== null && latestAvailableAuthority !== undefined) {
                  authorityData.push(latestAvailableAuthority);
                  debugLog(`Using latest available Authority (${latestAvailableAuthority} from ${latestAvailableAuthorityDate}) for ${pointDate}`, 'info');
                } else {
                  // Final fallback: calculate from GSC metrics (only if we have valid data)
                  const hasValidGscData = point.position && point.position > 0 && point.ctr !== null && point.ctr >= 0;
                  if (hasValidGscData) {
                    const authScore = typeof pillarScores.authority === 'object' ? pillarScores.authority.score : pillarScores.authority;
                    authorityData.push(authScore);
                    debugLog(`Using calculated Authority (${authScore}) for ${pointDate}`, 'info');
                  } else {
                    authorityData.push(null);
                    debugLog(`No valid GSC data for Authority on ${pointDate} (position=${point.position}, ctr=${point.ctr}) - using null`, 'warn');
                  }
                }
              }
              
              // Visibility data (check historical data from Supabase FIRST, then use current audit score, then calculate only if missing and valid GSC data)
              const historicalVisibility = visibilityMap.get(pointDate);
              if (historicalVisibility !== undefined && historicalVisibility !== null) {
                // Use stored score from database (fast - no calculation needed)
                visibilityData.push(historicalVisibility);
                debugLog(`Using stored Visibility (${historicalVisibility}) for ${pointDate}`, 'info');
              } else if (isLatestAudit) {
                // For latest audit date, prioritize stored Visibility score from current audit
                const savedAuditForVisibility = loadAuditResultsSync();
                const currentVisibility = savedAuditForVisibility?.scores?.visibility;
                if (currentVisibility !== null && currentVisibility !== undefined && currentVisibility > 0) {
                  visibilityData.push(currentVisibility);
                  debugLog(`Using current stored Visibility (${currentVisibility}) for ${pointDate} (latest audit)`, 'info');
                } else {
                  // Fallback to calculated score if stored score not available
                  visibilityData.push(pillarScores.visibility);
                  debugLog(`Using calculated Visibility (${pillarScores.visibility}) for ${pointDate} (stored score not available)`, 'info');
                }
              } else {
                // For past dates: calculate from GSC data as fallback (only if stored score missing AND valid GSC data)
                const hasValidGscData = point.position && point.position > 0 && point.ctr !== null && point.ctr >= 0;
                if (hasValidGscData) {
                  visibilityData.push(pillarScores.visibility);
                  debugLog(`Calculated Visibility (${pillarScores.visibility}) for ${pointDate} - stored score missing, using GSC fallback`, 'info');
                } else {
                  visibilityData.push(null);
                  debugLog(`No valid GSC data for Visibility on ${pointDate} (position=${point.position}, ctr=${point.ctr}) - using null`, 'warn');
                }
              }
              
              // Check if we have real historical data for this date
              // Content/Schema doesn't require GSC data, so should always have values
              // NOTE: 0 is a valid score, so check for null/undefined only
              const realScore = contentSchemaMap.get(pointDate);
              
              if (realScore !== undefined && realScore !== null) {
                // We have real data for this date (including 0, which is valid)
                contentSchemaData.push(realScore);
                contentSchemaDataEstimated.push(null); // No estimated value
                debugLog(`Content/Schema: Added ${realScore} for ${pointDate} from Supabase`, 'info');
              } else {
                // For missing dates, use the most recent available score from the map
                let latestAvailableContentSchema = null;
                let latestAvailableDate = null;
                contentSchemaMap.forEach((score, mapDate) => {
                  if (mapDate <= pointDate && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
                    latestAvailableDate = mapDate;
                    latestAvailableContentSchema = score;
                  }
                });
                
                // If no historical data found, use current score for latest audit date
                // NOTE: 0 is a valid score, so check for null/undefined only
                if (latestAvailableContentSchema !== null && latestAvailableContentSchema !== undefined) {
                  contentSchemaData.push(latestAvailableContentSchema);
                  contentSchemaDataEstimated.push(null);
                  debugLog(`Content/Schema: Added ${latestAvailableContentSchema} for ${pointDate} from latest available (${latestAvailableDate})`, 'info');
                } else if (isLatestAudit) {
                  // For latest audit date, try multiple sources
                  const savedAuditForContentSchema = loadAuditResultsSync();
                  const savedContentSchema = savedAuditForContentSchema?.scores?.contentSchema;
                  // NOTE: 0 is a valid score, so check for null/undefined only
                  const scoreToUse = (currentContentSchema !== null && currentContentSchema !== undefined)
                    ? currentContentSchema
                    : (savedContentSchema !== null && savedContentSchema !== undefined)
                      ? savedContentSchema
                      : null;
                  
                  if (scoreToUse !== null && scoreToUse !== undefined) {
                    contentSchemaData.push(scoreToUse);
                    contentSchemaDataEstimated.push(null);
                    debugLog(`Content/Schema: Added ${scoreToUse} for ${pointDate} from ${scoreToUse === currentContentSchema ? 'current audit' : 'saved audit'} (latest)`, 'info');
                  } else {
                    contentSchemaData.push(null);
                    contentSchemaDataEstimated.push(null);
                    debugLog(`Content/Schema: No valid score for ${pointDate} (isLatestAudit=${isLatestAudit}, currentContentSchema=${currentContentSchema}, savedContentSchema=${savedContentSchema})`, 'warn');
                  }
                } else {
                  // No real data for this date - use null (don't show estimated line)
                  contentSchemaData.push(null);
                  contentSchemaDataEstimated.push(null);
                  debugLog(`Content/Schema: No data for ${pointDate} (not latest audit, map has ${contentSchemaMap.size} entries)`, 'info');
                }
              }
              
              // Brand Overlay data (prioritize Supabase; if missing for a date, carry-forward latest available)
              const historicalBrandOverlay = brandOverlayMap.get(pointDate);
              if (historicalBrandOverlay !== undefined && historicalBrandOverlay !== null) {
                brandOverlayData.push(historicalBrandOverlay);
                debugLog(` Added Brand Overlay score (${historicalBrandOverlay}) for ${pointDate} from Supabase (historical)`, 'info');
              } else {
                let latestAvailableBrand = null;
                let latestAvailableBrandDate = null;
                brandOverlayMap.forEach((score, mapDate) => {
                  if (mapDate <= pointDate && (latestAvailableBrandDate === null || mapDate > latestAvailableBrandDate)) {
                    latestAvailableBrandDate = mapDate;
                    latestAvailableBrand = score;
                  }
                });

                if (latestAvailableBrand !== null && latestAvailableBrand !== undefined) {
                  brandOverlayData.push(latestAvailableBrand);
                  debugLog(` Using latest available Brand Overlay (${latestAvailableBrand} from ${latestAvailableBrandDate}) for ${pointDate}`, 'info');
                } else if (isLatestAudit && currentBrandOverlay !== null) {
                  brandOverlayData.push(currentBrandOverlay);
                  debugLog(` Using current Brand Overlay score (${currentBrandOverlay}) for ${pointDate} - no historical data found in Supabase`, 'warn');
                } else {
                  // Final fallback: estimate from GSC metrics
                  const historicalRecord = contentSchemaHistory.find(r => {
                    const rDate = typeof r.date === 'string' ? r.date.split('T')[0] : (r.date instanceof Date ? r.date.toISOString().split('T')[0] : String(r.date).split('T')[0]);
                    return rDate === pointDate;
                  });
                  const historicalReviewScore = historicalRecord?.authorityReviewScore;
                  const historicalEntityScore = historicalLocalEntity !== undefined && historicalLocalEntity !== null ? historicalLocalEntity : null;

                  const reviewScore = historicalReviewScore !== undefined && historicalReviewScore !== null
                    ? historicalReviewScore
                    : (currentScores?.authorityComponents?.reviews || currentScores?.authority?.bySegment?.all?.reviews || 0);
                  const entityScore = historicalEntityScore !== null && historicalEntityScore !== undefined
                    ? historicalEntityScore
                    : (currentScores?.localEntity || 0);

                  const hasValidGscData = point.position && point.position > 0 && point.ctr !== null && point.ctr >= 0;
                  if (!hasValidGscData) {
                    brandOverlayData.push(null);
                    debugLog(`No valid GSC data for Brand Overlay on ${pointDate} (position=${point.position}, ctr=${point.ctr}) - using null`, 'warn');
                  } else {
                    const position = point.position || 40;
                    const ctr = point.ctr || 0;
                    const estimatedBrandCtr = Math.min(ctr * 1.5, 0.4);
                    const estimatedBrandPosition = Math.max(position * 0.7, 1);
                    const estimatedBrandShare = 0.02;

                    try {
                      const fallbackBrandOverlay = computeBrandOverlay({
                        brandQueryShare: estimatedBrandShare,
                        brandCtr: estimatedBrandCtr,
                        brandAvgPosition: estimatedBrandPosition,
                        reviewScore: reviewScore,
                        entityScore: entityScore
                      });
                      brandOverlayData.push(fallbackBrandOverlay.score);
                      debugLog(` Calculated fallback Brand Overlay score (${fallbackBrandOverlay.score}) for ${pointDate} from GSC timeseries data`, 'info');
                    } catch (e) {
                      debugLog(` Error calculating fallback Brand Overlay for ${pointDate}: ${e.message}`, 'warn');
                      brandOverlayData.push(null);
                    }
                  }
                }
              }
              
              // Format date for chart (timeseries dates are YYYY-MM-DD)
              const dateObj = new Date(point.date);
              allDateObjects.push(dateObj);
              allDates.push(dateObj.toLocaleDateString('en-GB', dateFormat));
            });
            
            // Log Content/Schema data array summary after timeseries loop
            const contentSchemaValid = contentSchemaData.filter(v => v !== null && v !== undefined);
            debugLog(`Content/Schema data after timeseries: ${contentSchemaValid.length} valid values out of ${contentSchemaData.length} total. Values: ${contentSchemaValid.join(', ')}`, 'info');
            
            // Fill in missing dates between last GSC date and latest audit date
            // GSC data is delayed by 2-3 days, but we want to show the latest audit date
            // Reuse 'today' and 'todayStr' variables (already declared above)
            today = new Date();
            today.setHours(0, 0, 0, 0); // Normalize to start of day
            todayStr = today.toISOString().split('T')[0];
            const lastTimeseriesDate = timeseries.length > 0 ? timeseries[timeseries.length - 1].date : null;
            
            // Store last timeseries date globally so displayDashboard can use it for Data Date
            window.lastGscTimeseriesDate = lastTimeseriesDate;
            if (lastTimeseriesDate) {
              debugLog(`Stored last GSC timeseries date globally: ${lastTimeseriesDate}`, 'info');
            }
            
            // Determine actual last GSC data date
            // CRITICAL: Only use dates from maps that are <= lastTimeseriesDate (actual GSC data)
            // Never forward-fill GSC data beyond the last actual GSC timeseries date
            // Maps may have dates after lastTimeseriesDate (from audits), but those aren't from actual GSC data
            const allGscDates = new Set();
            
            // Add all dates from timeseries (actual GSC API data)
            timeseries.forEach(point => {
              if (point.date) {
                allGscDates.add(point.date);
              }
            });
            
            // Add dates from historical maps ONLY if they're <= lastTimeseriesDate
            // This ensures we only use GSC-derived scores that are based on actual GSC data
            if (lastTimeseriesDate) {
              visibilityMap.forEach((score, date) => {
                if (date && date <= lastTimeseriesDate && score !== null && score !== undefined) {
                  allGscDates.add(date);
                }
              });
              authorityMap.forEach((score, date) => {
                if (date && date <= lastTimeseriesDate && score !== null && score !== undefined) {
                  allGscDates.add(date);
                }
              });
              brandOverlayMap.forEach((score, date) => {
                if (date && date <= lastTimeseriesDate && score !== null && score !== undefined) {
                  allGscDates.add(date);
                }
              });
            }
            
            // Use the latest date from timeseries OR valid map dates (all <= lastTimeseriesDate)
            // This is the definitive last GSC data date - never forward-fill beyond this
            let lastGscDateForRange = lastTimeseriesDate; // Default to timeseries date (most accurate)
            if (allGscDates.size > 0) {
              const sortedDates = Array.from(allGscDates).sort();
              const latestDate = sortedDates[sortedDates.length - 1];
              // Use the later of: lastTimeseriesDate or latest valid map date
              // But latestDate should never be > lastTimeseriesDate due to filtering above
              lastGscDateForRange = latestDate > lastTimeseriesDate ? lastTimeseriesDate : latestDate;
              debugLog(`Last GSC date: ${lastGscDateForRange} (timeseries: ${lastTimeseriesDate}, valid map dates: ${sortedDates.length})`, 'info');
              if (sortedDates.length > 0) {
                debugLog(`GSC date range: ${sortedDates[0]} to ${lastGscDateForRange}`, 'info');
              }
            } else {
              debugLog(`No GSC dates found, using lastTimeseriesDate: ${lastGscDateForRange}`, 'warn');
            }
            
            // Ensure latest audit date is included even if not in timeseries
            // Add it to the chart if it's after the last GSC date
            if (latestAuditDateStr && lastGscDateForRange && latestAuditDateStr > lastGscDateForRange) {
              debugLog(`Latest audit date (${latestAuditDateStr}) is after last GSC date (${lastGscDateForRange}), will add to chart`, 'info');
            }
            
            // Check if we're missing recent dates (likely due to GSC delay)
            let hasRecentMissingDates = false;
            if (lastTimeseriesDate) {
              const lastDate = new Date(lastTimeseriesDate);
              lastDate.setHours(0, 0, 0, 0);
              const daysSinceLastData = Math.floor((today - lastDate) / (1000 * 60 * 60 * 24));
              hasRecentMissingDates = daysSinceLastData > 1; // More than 1 day gap indicates GSC delay
              
              // Show a note about GSC delay if we're missing recent dates
              if (hasRecentMissingDates) {
                const trendCanvas = document.getElementById('trendChart');
                if (trendCanvas && trendCanvas.parentElement) {
                  // Check if note already exists
                  const existingNote = trendCanvas.parentElement.querySelector('.gsc-delay-note');
                  if (!existingNote) {
                    const noteDiv = document.createElement('div');
                    noteDiv.className = 'gsc-delay-note';
                    noteDiv.style.cssText = 'background: #e0f2fe; padding: 0.75rem; border-radius: 4px; border-left: 3px solid #0284c7; margin-bottom: 1rem; font-size: 0.85rem; color: #0c4a6e;';
                    noteDiv.innerHTML = `<strong>Note:</strong> Google Search Console data is typically delayed by 2-3 days. Recent dates (last ${daysSinceLastData} day${daysSinceLastData > 1 ? 's' : ''}) may show no data until GSC updates.`;
                    trendCanvas.parentElement.insertBefore(noteDiv, trendCanvas);
                  }
                }
              }
            }
            
            // Always extend chart to latestAuditDateStr (or today) for non-GSC pillars
            // GSC pillars will only show data up to lastGscDateForRange
            // CRITICAL: Use the last date from the timeseries array (what's already in the chart)
            // NOT from the maps, because the maps may have dates that aren't in the chart yet
            const lastTimeseriesDateStr = timeseries.length > 0 ? timeseries[timeseries.length - 1].date : null;
            
            // Find the latest date from all maps for fallback/validation
            const allMapDates = new Set();
            contentSchemaMap.forEach((score, date) => allMapDates.add(date));
            localEntityMap.forEach((score, date) => allMapDates.add(date));
            serviceAreaMap.forEach((score, date) => allMapDates.add(date));
            visibilityMap.forEach((score, date) => allMapDates.add(date));
            authorityMap.forEach((score, date) => allMapDates.add(date));
            brandOverlayMap.forEach((score, date) => allMapDates.add(date));
            const latestMapDateStr = allMapDates.size > 0 ? Array.from(allMapDates).sort().reverse()[0] : null;
            
            // Use the last date from timeseries (what's already in the chart) as the starting point
            // This ensures we fill dates from the last timeseries date to the latest audit date
            const lastDateInChartStr = lastTimeseriesDateStr || (timeseries.length === 0 && latestMapDateStr ? latestMapDateStr : null);
            const targetDateStr = latestAuditDateStr || latestMapDateStr || today.toISOString().split('T')[0];
            
            debugLog(`Chart extension: lastDateInChart=${lastDateInChartStr}, targetDate=${targetDateStr}, latestAuditDateStr=${latestAuditDateStr}, latestMapDate=${latestMapDateStr}`, 'info');
            debugLog(`Last GSC date: ${lastGscDateForRange} (from all sources, timeseries last: ${lastTimeseriesDate})`, 'info');
            debugLog(`Content/Schema map has ${contentSchemaMap.size} entries before filling missing dates`, 'info');
            debugLog(`Content/Schema map entries: ${Array.from(contentSchemaMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
            
            // Always fill dates from last date in chart to latest audit date
            // Use string comparison to ensure we extend the chart
            if (lastDateInChartStr && targetDateStr) {
              const dateComparison = lastDateInChartStr.localeCompare(targetDateStr);
              if (dateComparison < 0) {
              const lastDate = new Date(lastDateInChartStr);
              lastDate.setHours(0, 0, 0, 0);
              const currentDate = new Date(lastDate);
              currentDate.setDate(currentDate.getDate() + 1); // Start from day after last date
              
              debugLog(`Filling missing dates from ${currentDate.toISOString().split('T')[0]} to ${targetDateStr} (latest audit: ${latestAuditDateStr})`, 'info');
              
              while (currentDate.toISOString().split('T')[0] <= targetDateStr) {
                const dateStr = currentDate.toISOString().split('T')[0];
                const dateObj = new Date(dateStr);
                
                allDateObjects.push(dateObj);
                allDates.push(dateObj.toLocaleDateString('en-GB', dateFormat));
                
                // For GSC-based pillars (Authority, Visibility), only use data from Supabase if it exists for that specific date
                // These rely on GSC data being fetched and stored, so NO forward-filling
                // CRITICAL: Only show data for dates <= lastGscDateForRange (last GSC data date from maps or timeseries)
                // Never show data for dates after lastGscDateForRange, even if an audit was run on that date
                const isDateWithinGscRange = lastGscDateForRange && dateStr <= lastGscDateForRange;
                const historicalVisibility = visibilityMap.get(dateStr);
                const historicalAuthority = authorityMap.get(dateStr);
                
                // Visibility: only use historical data from Supabase if date is within GSC data range
                if (isDateWithinGscRange && historicalVisibility !== undefined && historicalVisibility !== null) {
                  visibilityData.push(historicalVisibility);
                  debugLog(` Added Visibility score (${historicalVisibility}) for ${dateStr} from Supabase`, 'info');
                } else {
                  // No data for dates after last GSC data date - GSC-based metrics require real GSC data
                  visibilityData.push(null);
                  if (!isDateWithinGscRange) {
                    debugLog(`No Visibility data for ${dateStr} (date is after last GSC data date: ${lastGscDateForRange})`, 'info');
                  } else {
                    debugLog(`No Visibility data for ${dateStr} (no historical audit data)`, 'info');
                  }
                }
                
                // Authority: only use historical data from Supabase if date is within GSC data range
                if (isDateWithinGscRange && historicalAuthority !== undefined && historicalAuthority !== null) {
                  authorityData.push(historicalAuthority);
                  debugLog(` Added Authority score (${historicalAuthority}) for ${dateStr} from Supabase`, 'info');
                } else {
                  // No data for dates after last GSC data date - GSC-based metrics require real GSC data
                  authorityData.push(null);
                  if (!isDateWithinGscRange) {
                    debugLog(`No Authority data for ${dateStr} (date is after last GSC data date: ${lastGscDateForRange})`, 'info');
                  } else {
                    debugLog(`No Authority data for ${dateStr} (no historical audit data)`, 'info');
                  }
                }
                
                // For Local Entity and Service Area, check if we have historical data from Supabase
                // These don't require GSC data, so should always have values up to today
                const historicalLocalEntity = localEntityMap.get(dateStr);
                const historicalServiceArea = serviceAreaMap.get(dateStr);
                
                // Local Entity: use historical data, or latest available, or current score for today
                if (historicalLocalEntity !== undefined && historicalLocalEntity !== null) {
                  localEntityData.push(historicalLocalEntity);
                  debugLog(` Added Local Entity score (${historicalLocalEntity}) for ${dateStr} from Supabase`, 'info');
                } else {
                  // For missing dates, use the most recent available score from the map
                  let latestAvailableLocalEntity = null;
                  let latestAvailableDate = null;
                  localEntityMap.forEach((score, mapDate) => {
                    if (mapDate <= dateStr && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
                      latestAvailableDate = mapDate;
                      latestAvailableLocalEntity = score;
                    }
                  });
                  
                  // If no historical data found, use current score for today/latest audit
                  if (latestAvailableLocalEntity !== null && latestAvailableLocalEntity !== undefined) {
                    localEntityData.push(latestAvailableLocalEntity);
                    debugLog(` Added Local Entity score (${latestAvailableLocalEntity}) for ${dateStr} from latest available (${latestAvailableDate})`, 'info');
                  } else if (dateStr === latestAuditDateStr || dateStr >= todayStr) {
                    const savedAuditForLocal = loadAuditResultsSync();
                    const currentLocalEntity = savedAuditForLocal?.scores?.localEntity;
                    if (currentLocalEntity !== null && currentLocalEntity !== undefined && currentLocalEntity > 0) {
                      localEntityData.push(currentLocalEntity);
                      debugLog(` Added Local Entity score (${currentLocalEntity}) for ${dateStr} from current audit`, 'info');
                    } else {
                      localEntityData.push(null);
                      debugLog(`No Local Entity data for ${dateStr}`, 'warn');
                    }
                  } else {
                    localEntityData.push(null);
                    debugLog(`No Local Entity data for ${dateStr} (no historical or current data)`, 'info');
                  }
                }
                
                // Service Area: use historical data, or latest available, or current score for today
                if (historicalServiceArea !== undefined && historicalServiceArea !== null) {
                  serviceAreaData.push(historicalServiceArea);
                  debugLog(` Added Service Area score (${historicalServiceArea}) for ${dateStr} from Supabase`, 'info');
                } else {
                  // For missing dates, use the most recent available score from the map
                  let latestAvailableServiceArea = null;
                  let latestAvailableDate = null;
                  serviceAreaMap.forEach((score, mapDate) => {
                    if (mapDate <= dateStr && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
                      latestAvailableDate = mapDate;
                      latestAvailableServiceArea = score;
                    }
                  });
                  
                  // If no historical data found, use current score for today/latest audit
                  if (latestAvailableServiceArea !== null && latestAvailableServiceArea !== undefined) {
                    serviceAreaData.push(latestAvailableServiceArea);
                    debugLog(` Added Service Area score (${latestAvailableServiceArea}) for ${dateStr} from latest available (${latestAvailableDate})`, 'info');
                  } else if (dateStr === latestAuditDateStr || dateStr >= todayStr) {
                    const savedAuditForService = loadAuditResultsSync();
                    const currentServiceArea = savedAuditForService?.scores?.serviceArea;
                    if (currentServiceArea !== null && currentServiceArea !== undefined && currentServiceArea > 0) {
                      serviceAreaData.push(currentServiceArea);
                      debugLog(` Added Service Area score (${currentServiceArea}) for ${dateStr} from current audit`, 'info');
                    } else {
                      serviceAreaData.push(null);
                      debugLog(`No Service Area data for ${dateStr}`, 'warn');
                    }
                  } else {
                    serviceAreaData.push(null);
                    debugLog(`No Service Area data for ${dateStr} (no historical or current data)`, 'info');
                  }
                }
                
                // For Content/Schema, use latest audit score for dates after last GSC date
                // This ensures we show the latest audit data instead of intermediate values
                const isAfterLastTimeseries = lastGscDateForRange && dateStr > lastGscDateForRange;
                
                if (isAfterLastTimeseries && dateStr <= latestAuditDateStr) {
                  // For dates after last timeseries but up to latest audit, use latest audit score (forward-fill)
                  const savedAuditForContentSchema = loadAuditResultsSync();
                  const savedContentSchema = savedAuditForContentSchema?.scores?.contentSchema;
                  // NOTE: 0 is a valid score, so check for null/undefined only
                  const scoreToUse = (currentContentSchema !== null && currentContentSchema !== undefined)
                    ? currentContentSchema
                    : (savedContentSchema !== null && savedContentSchema !== undefined)
                      ? savedContentSchema
                      : null;
                  
                  if (scoreToUse !== null && scoreToUse !== undefined) {
                    contentSchemaData.push(scoreToUse);
                    contentSchemaDataEstimated.push(null);
                    debugLog(` Added Content/Schema score (${scoreToUse}) for ${dateStr} from latest audit (forward-filled from ${latestAuditDateStr})`, 'info');
                  } else {
                    // Fallback: use latest available from map
                    let latestAvailableContentSchema = null;
                    let latestAvailableDate = null;
                    contentSchemaMap.forEach((score, mapDate) => {
                      if (mapDate <= latestAuditDateStr && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
                        latestAvailableDate = mapDate;
                        latestAvailableContentSchema = score;
                      }
                    });
                    if (latestAvailableContentSchema !== null && latestAvailableContentSchema !== undefined) {
                      contentSchemaData.push(latestAvailableContentSchema);
                      contentSchemaDataEstimated.push(null);
                      debugLog(` Added Content/Schema score (${latestAvailableContentSchema}) for ${dateStr} from latest available (${latestAvailableDate})`, 'info');
                    } else {
                      contentSchemaData.push(null);
                      contentSchemaDataEstimated.push(null);
                      debugLog(`No Content/Schema data for ${dateStr}`, 'warn');
                    }
                  }
                } else {
                  // For dates within timeseries range, use actual database values
                  const realScore = contentSchemaMap.get(dateStr);
                  if (realScore !== undefined && realScore !== null) {
                    // We have real data for this date (including 0, which is valid)
                    contentSchemaData.push(realScore);
                    contentSchemaDataEstimated.push(null);
                    debugLog(` Added Content/Schema score (${realScore}) for ${dateStr} from Supabase`, 'info');
                  } else {
                    // For missing dates, use the most recent available score from the map
                    let latestAvailableContentSchema = null;
                    let latestAvailableDate = null;
                    contentSchemaMap.forEach((score, mapDate) => {
                      if (mapDate <= dateStr && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
                        latestAvailableDate = mapDate;
                        latestAvailableContentSchema = score;
                      }
                    });
                    
                    // If no historical data found, use current score for today/latest audit
                    if (latestAvailableContentSchema !== null && latestAvailableContentSchema !== undefined) {
                      contentSchemaData.push(latestAvailableContentSchema);
                      contentSchemaDataEstimated.push(null);
                      debugLog(` Added Content/Schema score (${latestAvailableContentSchema}) for ${dateStr} from latest available (${latestAvailableDate})`, 'info');
                    } else if (dateStr === latestAuditDateStr || dateStr >= todayStr) {
                      const savedAuditForContentSchema = loadAuditResultsSync();
                      const savedContentSchema = savedAuditForContentSchema?.scores?.contentSchema;
                      const scoreToUse = (currentContentSchema !== null && currentContentSchema !== undefined)
                        ? currentContentSchema
                        : (savedContentSchema !== null && savedContentSchema !== undefined)
                          ? savedContentSchema
                          : null;
                      
                      if (scoreToUse !== null && scoreToUse !== undefined) {
                        contentSchemaData.push(scoreToUse);
                        contentSchemaDataEstimated.push(null);
                        debugLog(` Added Content/Schema score (${scoreToUse}) for ${dateStr} from current/saved audit`, 'info');
                      } else {
                        contentSchemaData.push(null);
                        contentSchemaDataEstimated.push(null);
                        debugLog(`No Content/Schema data for ${dateStr} (latest date but no score available)`, 'warn');
                      }
                    } else {
                      // No real data - use null (don't show estimated)
                      contentSchemaData.push(null);
                      contentSchemaDataEstimated.push(null);
                      debugLog(`No Content/Schema data for ${dateStr} (no historical or current data)`, 'info');
                    }
                  }
                }
                
                // Brand Overlay data (check historical data from Supabase)
                // Brand Overlay is GSC-based, so only show data for dates <= lastTimeseriesDate
                const historicalBrandOverlay = brandOverlayMap.get(dateStr);
                if (isDateWithinGscRange && historicalBrandOverlay !== undefined && historicalBrandOverlay !== null) {
                  brandOverlayData.push(historicalBrandOverlay);
                  debugLog(` Added Brand Overlay score (${historicalBrandOverlay}) for ${dateStr} from Supabase`, 'info');
                } else {
                  // No data for dates after last GSC data date - Brand Overlay is GSC-based
                  brandOverlayData.push(null);
                  if (!isDateWithinGscRange) {
                    debugLog(`No Brand Overlay data for ${dateStr} (date is after last GSC data date: ${lastGscDateForRange})`, 'info');
                  } else {
                    debugLog(`No Brand Overlay data for ${dateStr} (no historical audit data)`, 'info');
                  }
                }
                
                // Move to next day
                currentDate.setDate(currentDate.getDate() + 1);
              }
              
              debugLog(`Filled missing dates: added ${allDateObjects.length - timeseries.length} additional dates`, 'info');
              } else {
                debugLog(`No dates to fill: lastDateInChart=${lastDateInChartStr}, targetDate=${targetDateStr}`, 'info');
              }
            } else {
              debugLog(`Cannot fill dates: lastDateInChart=${lastDateInChartStr}, targetDate=${targetDateStr}`, 'warn');
            }
            
            debugLog(`Chart date range: ${allDates[0]} to ${allDates[allDates.length - 1]} (${allDates.length} total dates)`, 'info');
            debugLog(`Latest audit date: ${latestAuditDateStr}`, 'info');
            debugLog(`Chart labels (first 5, last 5): ${allDates.slice(0, 5).join(', ')} ... ${allDates.slice(-5).join(', ')}`, 'info');
            
            if (timeseries.length === 0) {
              // No timeseries data at all - just add latest audit date or today
              const targetDateStr = latestAuditDateStr || todayStr;
              const targetDateObj = new Date(targetDateStr);
              allDateObjects.push(targetDateObj);
              allDates.push(targetDateObj.toLocaleDateString('en-GB', dateFormat));
              
              // For GSC-based pillars (Authority, Visibility), use current audit data if available
              if (savedAuditForTrend) {
                const currentSearchData = savedAuditForTrend?.searchData;
                const currentScores = savedAuditForTrend?.scores;
                
                if (currentSearchData) {
                  // Calculate Visibility from current position
                  const currentPosition = currentSearchData.averagePosition || 40;
                  const clampedPos = Math.max(1, Math.min(40, currentPosition));
                  const scale = (clampedPos - 1) / 39;
                  const posScore = 100 - scale * 90;
                  const visibility = clampScore(posScore);
                  visibilityData.push(visibility);
                  debugLog(` Added Visibility score (${visibility}) for today from current audit`, 'info');
                  
                  // Use current Authority score if available
                  const currentAuthority = currentScores?.authority || null;
                  if (currentAuthority !== null && currentAuthority !== undefined) {
                    authorityData.push(currentAuthority);
                    debugLog(` Added Authority score (${currentAuthority}) for today from current audit`, 'info');
                  } else {
                    // Fallback: calculate Authority from current data
                    const pillarScores = calculatePillarFromMetrics(
                      currentPosition,
                      currentSearchData.ctr || 0,
                      todayStr,
                      currentTopQueries,
                      currentBacklinkMetrics,
                      currentLocalSignals,
                        currentSiteReviews
                      );
                    const authScore = typeof pillarScores.authority === 'object' ? pillarScores.authority.score : pillarScores.authority;
                    authorityData.push(authScore);
                    debugLog(` Calculated Authority score (${authScore}) for today from current audit data`, 'info');
                  }
                } else {
                  // No current search data - use null
                  authorityData.push(null);
                  visibilityData.push(null);
                }
              } else {
                // No saved audit data - use null
                authorityData.push(null);
                visibilityData.push(null);
              }
              
              // For today, use current Business Profile data if available, otherwise calculated
              if (currentLocalEntity !== null) {
                localEntityData.push(currentLocalEntity);
              } else {
                localEntityData.push(null);
              }
              if (currentServiceArea !== null) {
                serviceAreaData.push(currentServiceArea);
              } else {
                serviceAreaData.push(null);
              }
              
              // For Content/Schema, check if we have real data for today
              const todayRealScore = contentSchemaMap.get(todayStr);
              if (todayRealScore !== undefined) {
                contentSchemaData.push(todayRealScore);
                contentSchemaDataEstimated.push(null);
                debugLog(` Added today's Content/Schema score (${todayRealScore}) from Supabase`, 'info');
              } else {
                contentSchemaData.push(null);
                contentSchemaDataEstimated.push(currentContentSchema);
                debugLog(`Using current Content/Schema score (${currentContentSchema}) as estimate for today`, 'info');
              }
              
              // For Brand Overlay, use current score if available
              if (currentBrandOverlay !== null) {
                brandOverlayData.push(currentBrandOverlay);
                debugLog(` Added Brand Overlay score (${currentBrandOverlay}) for today from current audit`, 'info');
              } else {
                brandOverlayData.push(null);
              }
            }
            
            // Apply label spacing to dates with year detection (show every labelStep-th label)
            let lastVisibleYear = null;
            chartDates = allDates.map((d, i) => {
              if (i % labelStep === 0 || i === allDates.length - 1) {
                const currentYear = allDateObjects[i].getFullYear();
                
                // Add year if it changed from the last visible label
                if (lastVisibleYear !== null && currentYear !== lastVisibleYear) {
                  lastVisibleYear = currentYear;
                  return `${d} ${currentYear}`;
                }
                
                lastVisibleYear = currentYear;
                return d;
              }
              return ''; // Empty string for labels we don't want to show
            });
            
            // Store date objects for timeseries data
            chartDateObjects = allDateObjects;
          } else {
            // No timeseries data available - use all nulls (no mock data)
            debugLog('No timeseries data available - chart will show empty with null values', 'warn');
            
            // Still fetch historical data for Money Pages trend chart even without timeseries
            const propertyUrl = document.getElementById('propertyUrl')?.value || '';
            if (propertyUrl) {
              try {
                // Calculate date range from saved audit or use default
                const dateRange = parseInt(document.getElementById('dateRange')?.value || '30', 10);
                const endDate = new Date().toISOString().split('T')[0];
                const startDate = new Date();
                startDate.setDate(startDate.getDate() - dateRange);
                const startDateStr = startDate.toISOString().split('T')[0];
                
                debugLog(`Fetching historical data for Money Pages trend (no timeseries): ${startDateStr} to ${endDate}`, 'info');
                const moneyPagesHistory = await fetchContentSchemaHistory(propertyUrl, startDateStr, endDate);
                
                // Phase 3: Render Money Pages trend chart
                if (typeof renderMoneyPagesTrendChart === 'function') {
                  setTimeout(() => {
                    renderMoneyPagesTrendChart(moneyPagesHistory);
                  }, 1000); // Delay to ensure DOM is ready and chart container exists
                } else {
                  debugLog(' renderMoneyPagesTrendChart function not found', 'warn');
                }
              } catch (error) {
                debugLog(` Error fetching historical data for Money Pages: ${error.message}`, 'warn');
                // Still try to render with empty history (will show current audit data if available)
                if (typeof renderMoneyPagesTrendChart === 'function') {
                  setTimeout(() => {
                    renderMoneyPagesTrendChart([]);
                  }, 1000);
                }
              }
            }
            
            // Use all null values - no mock/estimated data
            localEntityData = new Array(numDataPoints).fill(null);
            serviceAreaData = new Array(numDataPoints).fill(null);
            authorityData = new Array(numDataPoints).fill(null);
            visibilityData = new Array(numDataPoints).fill(null);
            contentSchemaData = new Array(numDataPoints).fill(null);
            contentSchemaDataEstimated = new Array(numDataPoints).fill(null);
            brandOverlayData = new Array(numDataPoints).fill(null);
            
            // Generate dates for the date range
            const fallbackDates = [];
            const fallbackDateObjects = [];
              for (let i = 0; i < numDataPoints; i++) {
              const dateObj = new Date();
              if (dateRange <= 90) {
                // Daily data
                dateObj.setDate(dateObj.getDate() - (numDataPoints - 1 - i));
              } else {
                // Weekly data
                dateObj.setDate(dateObj.getDate() - ((numDataPoints - 1 - i) * 7));
              }
              fallbackDateObjects.push(dateObj);
              fallbackDates.push(dateObj.toLocaleDateString('en-GB', dateFormat));
            }
            chartDates = fallbackDates;
            chartDateObjects = fallbackDateObjects;
          }
          
          // Calculate min and max across all datasets (filter out null values)
          const allData = [...localEntityData, ...serviceAreaData, ...authorityData, ...visibilityData, ...contentSchemaData, ...brandOverlayData].filter(v => v !== null && v !== undefined && !isNaN(v));
          const dataMin = allData.length > 0 ? Math.min(...allData) : 0;
          const dataMax = allData.length > 0 ? Math.max(...allData) : 100;
          const dataRange = dataMax - dataMin;
          
          // Debug: Log Content/Schema data to see what we have
          const contentSchemaValid = contentSchemaData.filter(v => v !== null && v !== undefined && !isNaN(v));
          debugLog(`Content/Schema dataset: ${contentSchemaValid.length} valid values out of ${contentSchemaData.length} total. Values: ${contentSchemaValid.join(', ')}`, 'info');
          debugLog(`Content/Schema data array length: ${contentSchemaData.length}, chart dates length: ${chartDates.length}`, 'info');
          debugLog(`Last few Content/Schema values: ${contentSchemaData.slice(-5).join(', ')}`, 'info');
          debugLog(`Content/Schema map size: ${contentSchemaMap.size}, map entries: ${Array.from(contentSchemaMap.entries()).slice(-10).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
          
          // Debug: Log Local Entity and Service Area data arrays
          const localEntityValid = localEntityData.filter(v => v !== null && v !== undefined && !isNaN(v));
          const serviceAreaValid = serviceAreaData.filter(v => v !== null && v !== undefined && !isNaN(v));
          debugLog(`Local Entity dataset: ${localEntityValid.length} valid values out of ${localEntityData.length} total. Last 5 values: ${localEntityData.slice(-5).join(', ')}`, 'info');
          debugLog(`Service Area dataset: ${serviceAreaValid.length} valid values out of ${serviceAreaData.length} total. Last 5 values: ${serviceAreaData.slice(-5).join(', ')}`, 'info');
          debugLog(`Local Entity map size: ${localEntityMap.size}, Service Area map size: ${serviceAreaMap.size}`, 'info');
          
          // If Content/Schema has no valid data, log a warning
          if (contentSchemaValid.length === 0) {
            debugLog(` WARNING: Content/Schema dataset has NO valid values! Map has ${contentSchemaMap.size} entries.`, 'error');
            debugLog(`Content/Schema history fetched: ${contentSchemaHistory.length} records`, 'info');
          }
          
          // Calculate dynamic Y-axis range
          // Minimum range of 30, or actual range + padding if larger
          const minRange = 30;
          const padding = 5; // Add 5 points padding above and below
          const actualRange = Math.max(minRange, dataRange + (padding * 2));
          
          // Calculate Y-axis min and max
          let yAxisMin = Math.max(0, Math.floor(dataMin - padding));
          // Ensure the red risk band (30-39) is always visible in the chart area
          // by never allowing the bottom of the axis to sit above 30.
          if (yAxisMin > 30) {
            yAxisMin = 30;
          }
          const yAxisMax = Math.max(105, Math.ceil(yAxisMin + actualRange));
          
          // Adjust step size based on range (smaller steps for smaller ranges)
          let stepSize = 10;
          if (actualRange <= 40) {
            stepSize = 5;
          } else if (actualRange <= 60) {
            stepSize = 10;
          } else {
            stepSize = 20;
          }
          
          debugLog(`Y-axis range: ${yAxisMin} to ${yAxisMax} (range: ${actualRange}, step: ${stepSize})`, 'info');
          
          // Calculate trend percentages for each dataset
          // Filter out null values to get actual first and last data points
          const calculateTrend = (data) => {
            // Filter out null/undefined values
            const validData = data.filter(v => v !== null && v !== undefined && !isNaN(v));
            if (validData.length < 2) return { percent: 0, isUp: false, isNeutral: true };
            
            const first = validData[0];
            const last = validData[validData.length - 1];
            
            // Handle division by zero (when first value is 0)
            if (first === 0) {
              // If first is 0 and last is also 0, no change
              if (last === 0) {
                return { percent: 0, isUp: false, isNeutral: true };
              }
              // If first is 0 but last has value, show as 100% increase
              return { percent: 100, isUp: true, isNeutral: false };
            }
            
            const percent = ((last - first) / first) * 100;
            
            // Handle NaN or infinite result
            if (isNaN(percent) || !isFinite(percent)) {
              return { percent: 0, isUp: false, isNeutral: true };
            }
            
            // Cap at 100% to avoid showing unrealistic percentages
            const cappedPercent = Math.min(Math.abs(percent), 100);
            // Consider values very close to 0 as neutral (within 0.1% threshold)
            const isNeutral = Math.abs(percent) < 0.1;
            return { 
              percent: cappedPercent, 
              isUp: percent > 0, 
              isNeutral: isNeutral 
            };
          };
          
          const localEntityTrend = calculateTrend(localEntityData);
          const serviceAreaTrend = calculateTrend(serviceAreaData);
          const authorityTrend = calculateTrend(authorityData);
          const visibilityTrend = calculateTrend(visibilityData);
          const contentSchemaTrend = calculateTrend(contentSchemaData);
          const brandOverlayTrend = calculateTrend(brandOverlayData);

          // Update HTML trend summary row
          const trendSummaryRow = document.getElementById('trendSummaryRow');
          if (trendSummaryRow) {
            const buildPill = (label, trend) => {
              let arrow, sign, cls;
              if (trend.isNeutral) {
                arrow = '';
                sign = '';
                cls = 'neutral';
              } else {
                arrow = trend.isUp ? '' : '';
                sign = trend.isUp ? '+' : '';
                cls = trend.isUp ? 'up' : 'down';
              }
              return `
                <div class="trend-pill">
                  <span class="label">${label}</span>
                  <span class="value ${cls}">${arrow} ${sign}${trend.percent.toFixed(1)}%</span>
                </div>
              `;
            };
            trendSummaryRow.innerHTML = [
              buildPill('Local Entity', localEntityTrend),
              buildPill('Service Area', serviceAreaTrend),
              buildPill('Authority', authorityTrend),
              buildPill('Visibility', visibilityTrend),
              buildPill('Content/Schema', contentSchemaTrend),
              buildPill('Brand & Entity', brandOverlayTrend)
            ].join('');
            
            // Add note explaining trend calculation
            const trendNote = trendSummaryRow.nextElementSibling;
            if (!trendNote || !trendNote.classList.contains('trend-calculation-note')) {
              const noteDiv = document.createElement('div');
              noteDiv.className = 'trend-calculation-note';
              noteDiv.style.cssText = 'font-size: 0.75rem; color: #64748b; margin-top: 0.5rem; font-style: italic;';
              noteDiv.textContent = 'Percentage changes are calculated from the first date to the last date in the selected range.';
              trendSummaryRow.parentElement.insertBefore(noteDiv, trendSummaryRow.nextSibling);
            }
          }
          
          // Plugin to make year transition labels bold
          const yearLabelBoldPlugin = {
            id: 'yearLabelBold',
            afterDraw: (chart) => {
              const xScale = chart.scales.x;
              const ctx = chart.ctx;
              const rotation = -45 * (Math.PI / 180); // -45 degrees in radians
              
              // Get the chart dates array from the chart's data labels (original labels before callback)
              const chartDates = chart.data.labels || [];
              
              // Iterate through all data points to find year labels
              chartDates.forEach((originalLabel, dataIndex) => {
                // Check if original label contains a year (4-digit number at the end)
                if (originalLabel && /\d{4}$/.test(originalLabel)) {
                  const label = originalLabel;
                  // Get pixel position for this data point
                  const tickPosition = xScale.getPixelForValue(dataIndex);
                  const yPosition = chart.chartArea.bottom + 25;
                  
                  // Save context
                  ctx.save();
                  
                  // Translate to tick position and rotate
                  ctx.translate(tickPosition, yPosition);
                  ctx.rotate(rotation);
                  
                  // Set bold font with larger size
                  ctx.font = 'bold 14px Arial';
                  ctx.fillStyle = '#000';
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  
                  // Measure text to clear area properly
                  const metrics = ctx.measureText(label);
                  const textWidth = metrics.width;
                  const textHeight = 18;
                  
                  // Clear a larger area to remove the original label
                  ctx.globalCompositeOperation = 'destination-out';
                  ctx.fillRect(-textWidth/2 - 6, -textHeight/2 - 3, textWidth + 12, textHeight + 6);
                  
                  // Switch back to normal drawing
                  ctx.globalCompositeOperation = 'source-over';
                  
                  // Draw bold label
                  ctx.fillText(label, 0, 0);
                  
                  // Restore context
                  ctx.restore();
                }
              });
            }
          };
          
          // Plugin to add RAG background bands with stronger contrast
          const ragBackgroundPlugin = {
            id: 'ragBackground',
            beforeDraw: (chart) => {
              const ctx = chart.ctx;
              const chartArea = chart.chartArea;
              const yScale = chart.scales.y;
              
              // Red zone (0-39) - increased opacity and saturation
              if (yAxisMin <= 39) {
                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(0, yAxisMin)));
                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(39, yAxisMax)));
                ctx.fillStyle = 'rgba(220, 38, 38, 0.18)'; // More saturated red, higher opacity
                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
              }
              
              // Amber zone (40-69) - increased opacity and saturation
              if (yAxisMin <= 69 && yAxisMax >= 40) {
                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(40, yAxisMin)));
                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(69, yAxisMax)));
                ctx.fillStyle = 'rgba(234, 179, 8, 0.18)'; // More saturated amber/yellow, higher opacity
                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
              }
              
              // Green zone (70-100) - increased opacity and saturation
              if (yAxisMax >= 70) {
                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(70, yAxisMin)));
                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(100, yAxisMax)));
                ctx.fillStyle = 'rgba(22, 163, 74, 0.18)'; // More saturated green, higher opacity
                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
              }
            }
          };
          
          // Plugin to draw vertical dividing lines at period transitions (months and years)
          const periodDividingLinePlugin = {
            id: 'periodDividingLine',
            afterDraw: (chart) => {
              const xScale = chart.scales.x;
              const ctx = chart.ctx;
              const chartArea = chart.chartArea;
              
              // Detect period transitions (month and year changes)
              const periodTransitions = [];
              let lastMonth = null;
              let lastYear = null;
              
              // Use stored date objects to detect month/year changes
              chartDateObjects.forEach((dateObj, index) => {
                if (dateObj instanceof Date) {
                  const currentMonth = dateObj.getMonth(); // 0-11
                  const currentYear = dateObj.getFullYear();
                  
                  // Check for month or year transition
                  if (lastMonth !== null && lastYear !== null) {
                    if (currentYear !== lastYear || currentMonth !== lastMonth) {
                      periodTransitions.push(index);
                    }
                  }
                  
                  lastMonth = currentMonth;
                  lastYear = currentYear;
                }
              });
              
              // Draw vertical dotted lines at period transitions
              periodTransitions.forEach((dataIndex) => {
                // Get pixel position for this data point
                const tickPosition = xScale.getPixelForValue(dataIndex);
                
                // Only draw if within chart area horizontally
                if (tickPosition >= chartArea.left && tickPosition <= chartArea.right) {
                  ctx.save();
                  ctx.strokeStyle = 'rgba(120, 120, 120, 0.7)'; // Medium grey, more visible
                  ctx.lineWidth = 3; // Thicker lines
                  ctx.setLineDash([3, 4]); // Dotted line pattern
                  ctx.beginPath();
                  // Extend line beyond chart area to reach axis labels
                  const lineTop = chartArea.top - 10; // Extend above chart
                  const lineBottom = chartArea.bottom + 50; // Extend below chart to reach axis labels
                  ctx.moveTo(tickPosition, lineTop);
                  ctx.lineTo(tickPosition, lineBottom);
                  ctx.stroke();
                  ctx.restore();
                }
              });
            }
          };
          
          // Debug: Log the actual data arrays being passed to the chart
          const brandOverlayValid = brandOverlayData.filter(v => v !== null && v !== undefined && !isNaN(v));
          debugLog(`Chart creation: Local Entity data length=${localEntityData.length}, last 3 values=${localEntityData.slice(-3).join(', ')}, Service Area data length=${serviceAreaData.length}, last 3 values=${serviceAreaData.slice(-3).join(', ')}, Brand & Entity data length=${brandOverlayData.length}, valid values=${brandOverlayValid.length}, last 3 values=${brandOverlayData.slice(-3).join(', ')}, all values=${brandOverlayData.join(', ')}`, 'info');
          
          // DEBUG: Log exact labels being passed to Chart.js
          debugLog(`[Trend Chart] Creating chart with ${chartDates.length} labels`, 'info');
          debugLog(`[Trend Chart] First 5 labels: ${chartDates.slice(0, 5).join(', ')}`, 'info');
          debugLog(`[Trend Chart] Last 5 labels: ${chartDates.slice(-5).join(', ')}`, 'info');
          debugLog(`[Trend Chart] Latest audit date: ${latestAuditDateStr}`, 'info');
          debugLog(`[Trend Chart] Data arrays length - Local Entity: ${localEntityData.length}, Service Area: ${serviceAreaData.length}, Authority: ${authorityData.length}, Visibility: ${visibilityData.length}, Content/Schema: ${contentSchemaData.length}`, 'info');
          
          // Remove inline loading spinner if it exists
          const existingLoading = trendChartContainer.querySelector('.trend-chart-loading');
          if (existingLoading) {
            existingLoading.remove();
            debugLog('Removed inline trend chart loading spinner', 'info');
          }
          
          // Hide full-screen loading overlay
          hideFullScreenLoading();
          
          // Destroy existing chart if it exists (prevent "Canvas is already in use" error)
          if (window.trendChart) {
            try {
              window.trendChart.destroy();
              debugLog(' Destroyed existing trend chart before creating new one', 'info');
            } catch (e) {
              debugLog(` Error destroying existing trend chart: ${e.message}`, 'warn');
            }
            window.trendChart = null;
          }
          
          // Also check if Chart.js has an instance registered for this canvas
          try {
            const existingChart = Chart.getChart(trendCtx);
            if (existingChart) {
              existingChart.destroy();
              debugLog(' Destroyed Chart.js registered instance for trendChart canvas', 'info');
            }
          } catch (e) {
            debugLog(` Error checking/destroying Chart.js instance: ${e.message}`, 'warn');
          }
          
          const applyOverlapOffsets = (series, step = 0.35) => {
            const adjusted = series.map(s => s.data.map(v => (v == null || Number.isNaN(v) ? v : Number(v))));
            const length = Math.max(...series.map(s => s.data.length));
            for (let i = 0; i < length; i++) {
              const valueMap = new Map();
              series.forEach((s, idx) => {
                const v = s.data[i];
                if (v == null || Number.isNaN(v)) return;
                const key = Number(v).toFixed(3);
                if (!valueMap.has(key)) valueMap.set(key, []);
                valueMap.get(key).push(idx);
              });
              valueMap.forEach((indices) => {
                if (indices.length <= 1) return;
                const center = (indices.length - 1) / 2;
                indices.forEach((seriesIdx, pos) => {
                  adjusted[seriesIdx][i] = Number(series[seriesIdx].data[i]) + ((pos - center) * step);
                });
              });
            }
            return adjusted;
          };

          const trendSeries = [
            { label: 'Local Entity', data: localEntityData },
            { label: 'Service Area', data: serviceAreaData },
            { label: 'Authority', data: authorityData },
            { label: 'Visibility', data: visibilityData },
            { label: 'Content / Schema', data: contentSchemaData },
            { label: 'Brand & Entity', data: brandOverlayData }
          ];

          const adjustedSeries = applyOverlapOffsets(trendSeries, 0.35);

          window.trendChart = new Chart(trendCtx, {
            type: 'line',
            data: {
              labels: chartDates,
              datasets: [
                {
                  label: 'Local Entity',
                  data: adjustedSeries[0],
                  rawData: trendSeries[0].data,
                  borderColor: 'rgba(147, 51, 234, 1)', // Purple
                  backgroundColor: 'rgba(147, 51, 234, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5,
                  spanGaps: true // Connect across null values to show continuous line
                },
                {
                  label: 'Service Area',
                  data: adjustedSeries[1],
                  rawData: trendSeries[1].data,
                  borderColor: '#00FFFF', // Cyan (not RAG color)
                  backgroundColor: 'rgba(0, 255, 255, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5,
                  spanGaps: true // Connect across null values to show continuous line
                },
                {
                  label: 'Authority',
                  data: adjustedSeries[2],
                  rawData: trendSeries[2].data,
                  borderColor: '#99004C', // Dark pink/magenta
                  backgroundColor: 'rgba(153, 0, 76, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5
                  // No spanGaps - stop at last available GSC data (Dec 4)
                },
                {
                  label: 'Visibility',
                  data: adjustedSeries[3],
                  rawData: trendSeries[3].data,
                  borderColor: 'rgba(37, 99, 235, 1)', // Blue
                  backgroundColor: 'rgba(59, 130, 246, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5
                  // No spanGaps - stop at last available GSC data (Dec 4)
                },
                {
                  label: 'Content / Schema',
                  data: adjustedSeries[4],
                  rawData: trendSeries[4].data,
                  borderColor: 'rgba(107, 114, 128, 1)', // Grey
                  backgroundColor: 'rgba(107, 114, 128, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0, // Hide points - show as solid line
                  pointHoverRadius: 5,
                  spanGaps: true, // Connect across null values to show continuous line
                  pointBackgroundColor: 'rgba(107, 114, 128, 1)',
                  pointBorderColor: '#ffffff',
                  pointBorderWidth: 2
                },
                {
                  label: 'Brand & Entity',
                  data: adjustedSeries[5].length === chartDates.length ? adjustedSeries[5] : (() => {
                    // Ensure data array matches labels length
                    const adjusted = [...adjustedSeries[5]];
                    while (adjusted.length < chartDates.length) {
                      adjusted.push(null);
                    }
                    return adjusted.slice(0, chartDates.length);
                  })(),
                  rawData: trendSeries[5].data,
                  borderColor: '#FFFF66', // Bright yellow
                  backgroundColor: 'rgba(255, 255, 102, 0.1)', // Bright yellow with transparency
                  borderWidth: 3, // Increased from 2 to make more visible
                  borderDash: [5, 5], // Dashed line to indicate overlay
                  tension: 0.4,
                  pointRadius: 3, // Show points to make line more visible
                  pointHoverRadius: 6,
                  pointBackgroundColor: '#FFFF66',
                  pointBorderColor: '#FFFF66',
                  spanGaps: true,
                  hidden: false // Explicitly ensure dataset is visible
                }
              ]
            },
            plugins: [ragBackgroundPlugin, yearLabelBoldPlugin, periodDividingLinePlugin],
            options: {
              responsive: true,
              maintainAspectRatio: false,
              animation: false, // Disable animation for better performance when changing periods
              layout: {
                padding: {
                  bottom: 100, // Extra padding for rotated 45-degree X-axis labels (need space for diagonal text)
                  left: 15, // Space for left Y-axis labels
                  right: 50, // Extra space for right Y-axis labels (100, 80, 60, 40, 29)
                  top: 10
                }
              },
              scales: {
                x: {
                  ticks: {
                    maxRotation: 45,
                    minRotation: 45,
                    font: {
                      size: 11,
                      weight: 'normal'
                    },
                    callback: function(value, index) {
                      // Only show non-empty labels
                      const label = this.getLabelForValue(value);
                      // Hide year labels (they'll be drawn by plugin in bold)
                      if (label && /\d{4}$/.test(label)) {
                        return ''; // Return empty to hide, plugin will draw it
                      }
                      return label || '';
                    }
                  },
                  grid: {
                    display: true,
                    color: 'rgba(0, 0, 0, 0.05)'
                  }
                },
                y: {
                  min: yAxisMin,
                  max: yAxisMax,
                  position: 'left',
                  ticks: {
                    stepSize: stepSize,
                    font: {
                      size: 12,
                      weight: 'bold'
                    }
                  },
                  grid: {
                    color: 'rgba(0, 0, 0, 0.1)',
                    drawBorder: true
                  }
                },
                y1: {
                  min: yAxisMin,
                  max: yAxisMax,
                  position: 'right',
                  ticks: {
                    stepSize: stepSize,
                    font: {
                      size: 12,
                      weight: 'bold'
                    }
                  },
                  grid: {
                    display: false,
                    drawBorder: false
                  }
                }
              },
              plugins: {
                legend: {
                  display: true,
                  position: 'top',
                  labels: {
                    font: {
                      size: 16,
                      weight: 'bold'
                    },
                    padding: 25,
                    usePointStyle: false,
                    boxWidth: 60,
                    boxHeight: 4,
                    // Use default legend labels (pillar names only, no trends)
                    generateLabels: function(chart) {
                      const original = Chart.defaults.plugins.legend.labels.generateLabels;
                      return original.call(this, chart);
                    }
                  }
                },
                tooltip: {
                  mode: 'index',
                  intersect: false,
                  callbacks: {
                    label: (context) => {
                      const label = context.dataset?.label || 'Series';
                      const raw = context.dataset?.rawData?.[context.dataIndex];
                      if (raw == null || Number.isNaN(raw)) {
                        return `${label}: `;
                      }
                      const value = Number(raw);
                      const display = Number.isFinite(value) ? value.toFixed(1).replace(/\.0$/, '') : '';
                      return `${label}: ${display}`;
                    }
                  }
                }
              }
            }
          });
          debugLog(' Trend chart created successfully', 'success');
          debugLog(`trendChart type after creation: ${typeof window.trendChart}`, 'info');
          debugLog(`trendChart instanceof Chart: ${window.trendChart instanceof Chart}`, 'info');
          debugLog(`Chart data points: Local Entity=${localEntityData.length}, Visibility=${visibilityData.length}, Authority=${authorityData.length}`, 'info');
          
          // Add event listeners for Authority mode toggle buttons (sync with KPI toggle)
          ['all', 'nonEducation', 'money'].forEach(mode => {
            const btn = document.getElementById(`trend-mode-${mode}`);
            if (btn) {
              btn.addEventListener('click', () => {
                // Update selected mode (shared with KPI toggle)
                window.trendAuthorityMode = mode;
                debugLog(` Trend chart Authority mode changed to: ${mode === 'all' ? 'All pages' : mode === 'nonEducation' ? 'Exclude education' : 'Money pages only'}`, 'info');
                
                // Update button styles for both KPI and trend toggles
                ['all', 'nonEducation', 'money'].forEach(m => {
                  // Update trend toggle buttons
                  const trendBtn = document.getElementById(`trend-mode-${m}`);
                  if (trendBtn) {
                    if (m === mode) {
                      trendBtn.style.background = '#10b981';
                      trendBtn.style.color = 'white';
                    } else {
                      trendBtn.style.background = 'white';
                      trendBtn.style.color = '#666';
                    }
                  }
                  // Update KPI toggle buttons
                  const kpiBtn = document.getElementById(`kpi-mode-${m}`);
                  if (kpiBtn) {
                    if (m === mode) {
                      kpiBtn.style.background = '#10b981';
                      kpiBtn.style.color = 'white';
                    } else {
                      kpiBtn.style.background = 'white';
                      kpiBtn.style.color = '#666';
                    }
                  }
                });
                
                // Redraw the chart with new Authority data
                if (window.trendChart && typeof displayDashboard === 'function') {
                  // Re-run displayDashboard to recalculate with new mode
                  displayDashboard();
                }
              });
            }
          });
          
          debugLog('=== DISPLAY DASHBOARD: Complete ===', 'success');
        } catch (e) {
          debugLog(` Error creating trend chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.error('Error creating trend chart:', e);
          
          // Hide full-screen loading overlay
          hideFullScreenLoading();
          
          // Show error message to user
          const trendCanvas = document.getElementById('trendChart');
          if (trendCanvas && trendCanvas.parentElement) {
            // Remove any existing error messages
            const existingError = trendCanvas.parentElement.querySelector('.trend-chart-error');
            if (existingError) existingError.remove();
            
            // Show error message to user
            const errorDiv = document.createElement('div');
            errorDiv.className = 'trend-chart-error';
            errorDiv.style.cssText = 'background: #fee2e2; padding: 1rem; border-radius: 4px; border-left: 3px solid #ef4444; margin-bottom: 1rem; font-size: 0.9rem; color: #991b1b;';
            errorDiv.innerHTML = `<strong>Error loading trend chart:</strong> ${e.message}. Please refresh the page or run a new audit.`;
            trendCanvas.parentElement.insertBefore(errorDiv, trendCanvas);
          }
        }
      }, 100);
    }

    // Function to load shared audit data
    async function loadSharedAudit(shareId) {
      try {
        debugLog(`Loading shared audit: ${shareId}`, 'info');
        const response = await fetch(apiUrl(`/api/supabase/get-shared-audit?shareId=${encodeURIComponent(shareId)}`));
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.message || 'Failed to load shared audit');
        }
        
        const result = await response.json();
        if (result.status === 'ok' && result.data) {
          debugLog(' Shared audit loaded successfully', 'success');
          return result.data;
        } else {
          throw new Error('Invalid shared audit data');
        }
      } catch (error) {
        debugLog(` Error loading shared audit: ${error.message}`, 'error');
        showStatus(`Failed to load shared audit: ${error.message}`, 'error');
        return null;
      }
    }

    // Function to create shareable link (exposed globally for onclick)
    window.createShareableLink = async function() {
      const savedAudit = await loadAuditResults();
      if (!savedAudit || !savedAudit.scores) {
        showStatus('No audit data available to share. Please run an audit first.', 'error');
        return;
      }

      try {
        showStatus('Creating shareable link...', 'info');
        const response = await fetch(apiUrl('/api/supabase/create-shared-audit'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            auditData: savedAudit
          })
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.message || 'Failed to create shareable link');
        }

        const result = await response.json();
        if (result.status === 'ok' && result.shareUrl) {
          // Copy to clipboard
          await navigator.clipboard.writeText(result.shareUrl);
          showStatus(`Shareable link created and copied to clipboard! Link expires in 30 days.`, 'success');
          
          // Show the link in an alert or modal
          alert(`Shareable link created!\n\n${result.shareUrl}\n\n(Link copied to clipboard)\n\nThis link expires in 30 days.`);
        } else {
          throw new Error('Invalid response from server');
        }
      } catch (error) {
        debugLog(` Error creating shareable link: ${error.message}`, 'error');
        showStatus(`Failed to create shareable link: ${error.message}`, 'error');
      }
    }

    // Initialize on load
    window.addEventListener('DOMContentLoaded', () => {
      debugLog('=== PAGE LOAD: DOMContentLoaded event fired ===', 'info');
      debugLog(`Window location: ${window.location.href}`, 'info');
      debugLog(`User agent: ${navigator.userAgent}`, 'info');
      loadConfig();
      
      // Check for share parameter in URL
      const urlParams = new URLSearchParams(window.location.search);
      const shareId = urlParams.get('share');
      
      // Load and display last audit results if available
      // Wait a tick to ensure loadConfig() has finished updating the date range input
      setTimeout(async () => {
        let auditToDisplay = null;
        
        if (shareId) {
          // Load shared audit
          debugLog(`Share ID detected: ${shareId}`, 'info');
          auditToDisplay = await loadSharedAudit(shareId);
          if (auditToDisplay) {
            // Save shared audit to localStorage temporarily for display
            safeSetLocalStorage('last_audit_results', auditToDisplay);
            // Show a banner indicating this is a shared view
            const banner = document.createElement('div');
            banner.style.cssText = 'background: #dbeafe; padding: 1rem; border-radius: 4px; border-left: 4px solid #3b82f6; margin-bottom: 1rem; font-size: 0.9rem; color: #1e40af;';
            banner.innerHTML = '<strong> Shared Audit View</strong> - This is a shared audit. You can view all results but cannot run new audits from this view.';
            const dashboard = document.getElementById('dashboard');
            if (dashboard) {
              dashboard.insertBefore(banner, dashboard.firstChild);
            }
            // Hide the run audit button
            const runAuditBtn = document.getElementById('runAudit');
            if (runAuditBtn) {
              runAuditBtn.style.display = 'none';
            }
          }
        }
        
        // If no shared audit or failed to load, try localStorage or Supabase
        if (!auditToDisplay) {
          auditToDisplay = await loadAuditResults();
        }
        
        // If still no audit data, try fetching from Supabase
        if (!auditToDisplay) {
          const propertyUrl = localStorage.getItem('gsc_property_url');
          if (propertyUrl) {
            debugLog('No audit data in localStorage, fetching from Supabase...', 'info');
            auditToDisplay = await fetchLatestAuditFromSupabase(propertyUrl);
            if (auditToDisplay) {
              // Save to localStorage for future use
              safeSetLocalStorage('last_audit_results', auditToDisplay);
              // Update timestamp display
              if (auditToDisplay.timestamp) {
                updateAuditTimestamp(auditToDisplay.timestamp);
              }
              debugLog(' Latest audit loaded from Supabase and saved to localStorage', 'success');
            } else {
              debugLog(' No audit data found in Supabase either', 'warn');
            }
          } else {
            debugLog(' Cannot fetch from Supabase: property URL not configured', 'warn');
          }
        }
        
        const savedAudit = auditToDisplay;
        if (savedAudit && savedAudit.scores && savedAudit.searchData) {
          // CRITICAL: Restore Money Pages Priority data FIRST before any rendering
          debugLog(`Checking saved audit for moneyPagePriorityData: ${!!savedAudit.moneyPagePriorityData}, type: ${Array.isArray(savedAudit.moneyPagePriorityData) ? 'array' : typeof savedAudit.moneyPagePriorityData}, length: ${Array.isArray(savedAudit.moneyPagePriorityData) ? savedAudit.moneyPagePriorityData.length : 'N/A'}, value: ${JSON.stringify(savedAudit.moneyPagePriorityData ? (Array.isArray(savedAudit.moneyPagePriorityData) ? `[${savedAudit.moneyPagePriorityData.length} items]` : savedAudit.moneyPagePriorityData) : 'null').substring(0, 100)}`, 'info');
          
          // Check if moneyPagePriorityData exists but is null/empty
          if (savedAudit.moneyPagePriorityData !== null && savedAudit.moneyPagePriorityData !== undefined) {
            if (Array.isArray(savedAudit.moneyPagePriorityData) && savedAudit.moneyPagePriorityData.length > 0) {
              window.moneyPagePriorityData = savedAudit.moneyPagePriorityData;
              debugLog(` Restored moneyPagePriorityData from saved audit: ${savedAudit.moneyPagePriorityData.length} pages`, 'success');
            } else if (Array.isArray(savedAudit.moneyPagePriorityData) && savedAudit.moneyPagePriorityData.length === 0) {
              debugLog(` moneyPagePriorityData exists but is empty array`, 'warn');
              window.moneyPagePriorityData = [];
            } else {
              debugLog(` moneyPagePriorityData exists but is not an array: ${typeof savedAudit.moneyPagePriorityData}`, 'warn');
              window.moneyPagePriorityData = [];
            }
          } else {
            debugLog(` moneyPagePriorityData is null/undefined in saved audit. Keys in savedAudit: ${Object.keys(savedAudit).join(', ')}`, 'warn');
            // Try to rebuild if we have moneyPagesMetrics
            if (savedAudit.scores?.moneyPagesMetrics?.rows && savedAudit.scores.moneyPagesMetrics.rows.length > 0) {
              debugLog(` Will try to rebuild moneyPagePriorityData from moneyPagesMetrics (${savedAudit.scores.moneyPagesMetrics.rows.length} rows)`, 'info');
            }
          }
          
          if (savedAudit.moneySegmentMetrics) {
            window.moneySegmentMetrics = savedAudit.moneySegmentMetrics;
            debugLog(` Restored moneySegmentMetrics from saved audit`, 'success');
          } else {
            debugLog(` moneySegmentMetrics NOT found in saved audit`, 'warn');
          }
          
          // Ensure moneyPagesMetrics is in scores if it exists in the audit data
          if (!savedAudit.scores.moneyPagesMetrics && savedAudit.moneyPagesMetrics) {
            savedAudit.scores.moneyPagesMetrics = savedAudit.moneyPagesMetrics;
            debugLog(' Moved moneyPagesMetrics from audit root to scores', 'success');
          }
          
          // Store globally for Money Pages sections
          if (savedAudit.scores.moneyPagesMetrics) {
            window.currentMoneyPagesMetrics = savedAudit.scores.moneyPagesMetrics;
            window.moneyPagesMetrics = savedAudit.scores.moneyPagesMetrics;
            debugLog(` Stored moneyPagesMetrics globally: ${savedAudit.scores.moneyPagesMetrics.rows?.length || 0} rows`, 'success');
          }
          
          // If saved audit has a date range, use it to set the input field and button
          // This ensures the UI matches the saved audit's date range
          if (savedAudit.dateRange) {
            const savedDateRange = savedAudit.dateRange;
            document.getElementById('dateRange').value = savedDateRange;
            // Update active button to match saved date range
            document.querySelectorAll('.date-range-btn').forEach(btn => {
              btn.classList.remove('active');
              const btnDays = parseInt(btn.getAttribute('data-days'));
              if (btnDays === savedDateRange) {
                btn.classList.add('active');
              }
            });
            // Update localStorage to match
            localStorage.setItem('gsc_date_range', savedDateRange);
            debugLog(`Set date range to ${savedDateRange} to match saved audit`, 'info');
          }
          
          // Now check if they match (they should, since we just set it)
          const currentDateRange = parseInt(document.getElementById('dateRange')?.value) || 30;
          const savedDateRange = savedAudit.dateRange || currentDateRange;
          
          debugLog(`Checking date range match: saved=${savedDateRange}, current=${currentDateRange}`, 'info');
          
          if (savedDateRange === currentDateRange) {
            debugLog('Loading last audit results from localStorage...', 'info');
            
            // CRITICAL: If moneyPagePriorityData is null but we have moneyPagesMetrics, try to rebuild it
            // But only if buildMoneyPageMetrics is available
            if ((!window.moneyPagePriorityData || window.moneyPagePriorityData.length === 0) && 
                savedAudit.scores?.moneyPagesMetrics?.rows && 
                savedAudit.scores.moneyPagesMetrics.rows.length > 0) {
              debugLog(`Attempting to rebuild moneyPagePriorityData from moneyPagesMetrics (${savedAudit.scores.moneyPagesMetrics.rows.length} rows)...`, 'info');
              
              // Wait for buildMoneyPageMetrics to be available (with timeout)
              let attempts = 0;
              const maxAttempts = 20; // 2 seconds total wait
              debugLog(`Waiting for buildMoneyPageMetrics... (currently: ${typeof window.buildMoneyPageMetrics})`, 'info');
              while (typeof window.buildMoneyPageMetrics !== 'function' && attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
                if (attempts % 5 === 0) {
                  debugLog(`Still waiting for buildMoneyPageMetrics... (attempt ${attempts}/${maxAttempts})`, 'info');
                }
              }
              
              debugLog(`buildMoneyPageMetrics check after wait: ${typeof window.buildMoneyPageMetrics}`, 'info');
              
              if (typeof window.buildMoneyPageMetrics === 'function') {
                try {
                  const topPagesForPriority = savedAudit.scores.moneyPagesMetrics.rows.map(row => ({
                    page: row.url,
                    url: row.url,
                    clicks: row.clicks || 0,
                    impressions: row.impressions || 0,
                    // row.ctr is already a ratio (0-1). Do not multiply by 100.
                    ctr: (row.ctr || 0),
                    position: row.avgPosition || 0,
                    avgPosition: row.avgPosition || 0,
                    title: row.title || row.url
                  }));
                  
                  window.moneyPagePriorityData = window.buildMoneyPageMetrics(topPagesForPriority, savedAudit.schemaAudit || null);
                  debugLog(` Rebuilt moneyPagePriorityData: ${window.moneyPagePriorityData.length} pages`, 'success');
                  
                  // Save rebuilt data back to localStorage
                  savedAudit.moneyPagePriorityData = window.moneyPagePriorityData;
                  safeSetLocalStorage('last_audit_results', savedAudit);
                } catch (error) {
                  debugLog(` Failed to rebuild moneyPagePriorityData: ${error.message}`, 'warn');
                }
              } else {
                debugLog(` buildMoneyPageMetrics still not available after ${maxAttempts * 100}ms wait`, 'warn');
              }
            }
            
            // Show dashboard immediately with saved results
            document.getElementById('dashboard').style.display = 'block';
            document.getElementById('loading').classList.remove('show');
            // Ensure searchData has timeseries if available
            const searchDataWithTimeseries = savedAudit.searchData || {};
            if (!searchDataWithTimeseries.timeseries) {
              // Try to load timeseries from saved audit
              if (savedAudit.timeseries) {
                searchDataWithTimeseries.timeseries = savedAudit.timeseries;
                debugLog(` Restored timeseries data from saved audit: ${savedAudit.timeseries.length} data points`, 'success');
              } else {
                // Try to fetch timeseries from Supabase gsc_timeseries table
                debugLog('Fetching timeseries data from Supabase for Score Trends chart...', 'info');
                try {
                  const propertyUrl = savedAudit.searchData?.propertyUrl || localStorage.getItem('gsc_property_url');
                  if (propertyUrl) {
                    const endDate = new Date().toISOString().split('T')[0];
                    const startDate = new Date();
                    startDate.setDate(startDate.getDate() - 30); // Last 30 days
                    const startDateStr = startDate.toISOString().split('T')[0];
                    
                    const timeseriesResponse = await fetch(apiUrl(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDate}`));
                    if (timeseriesResponse.ok) {
                      const timeseriesData = await timeseriesResponse.json();
                      if (timeseriesData.status === 'ok' && timeseriesData.timeseries && Array.isArray(timeseriesData.timeseries)) {
                        searchDataWithTimeseries.timeseries = timeseriesData.timeseries;
                        debugLog(` Loaded timeseries data from Supabase: ${timeseriesData.timeseries.length} data points`, 'success');
                      }
                    }
                  }
                } catch (error) {
                  debugLog(` Failed to load timeseries data: ${error.message}`, 'warn');
                }
              }
            }
            
            displayDashboard(
              savedAudit.scores,
              searchDataWithTimeseries,
              savedAudit.snippetReadiness || 0,
              savedAudit.schemaAudit || null,
              savedAudit.localSignals || null
            );
            debugLog(' Last audit results displayed', 'success');
          } else {
            debugLog(`Saved audit date range (${savedDateRange}) doesn't match current (${currentDateRange}). Dashboard not displayed.`, 'warn');
            // Don't show dashboard - user needs to run new audit
          }
        } else {
          // No audit data found - show empty state message
          debugLog(' No audit data found. Please run a new audit.', 'warn');
          const dashboard = document.getElementById('dashboard');
          if (dashboard) {
            dashboard.style.display = 'block';
            dashboard.innerHTML = `
              <div style="padding: 3rem; text-align: center; background: white; border-radius: 8px; margin: 2rem;">
                <h2 style="color: #1e293b; margin-bottom: 1rem;">No Audit Data Found</h2>
                <p style="color: #64748b; margin-bottom: 2rem;">Run your first audit to see the dashboard content.</p>
                <button id="runAudit" onclick="runAudit()" style="background: #f97316; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; font-size: 1rem; cursor: pointer; font-weight: 600;">
                  Run Audit
                </button>
              </div>
            `;
          }
          document.getElementById('loading').classList.remove('show');
        }
      }, 100); // Increased delay to ensure loadConfig completes
      
      debugLog('=== PAGE LOAD: Initialization complete ===', 'success');
    });

    // PDF Report Generation
    async function generatePDFReport() {
      console.log('[PDF] ===== PDF GENERATION STARTED =====');
      
      const btn = document.getElementById('generatePdfBtn');
      const statusDiv = document.getElementById('pdfStatus');
      
      if (!btn) {
        console.error('[PDF] Generate PDF button not found!');
        alert('Error: Generate PDF button not found. Please refresh the page.');
        return;
      }
      
      if (!statusDiv) {
        console.error('[PDF] PDF status div not found!');
      }
      
      // Check if html2pdf is available
      if (typeof html2pdf === 'undefined') {
        const errorMsg = ' PDF library not loaded. Please refresh the page.';
        if (statusDiv) {
          statusDiv.textContent = errorMsg;
          statusDiv.style.color = '#dc2626';
        }
        console.error('[PDF] html2pdf is not defined');
        alert(errorMsg);
        return;
      }
      
      console.log('[PDF] html2pdf library is available');
      
      // Check if dashboard has data
      const dashboard = document.getElementById('dashboard');
      if (!dashboard || dashboard.style.display === 'none') {
        const errorMsg = ' Please run an audit first to generate a report.';
        if (statusDiv) {
          statusDiv.textContent = errorMsg;
          statusDiv.style.color = '#dc2626';
        }
        console.warn('[PDF] Dashboard not available or hidden');
        return;
      }

      console.log('[PDF] Dashboard is available and visible');

      // Disable button and show status
      btn.disabled = true;
      btn.style.opacity = '0.6';
      if (statusDiv) {
        statusDiv.textContent = ' Generating PDF report...';
        statusDiv.style.color = '#2563eb';
      }
      
      console.log('[PDF] Starting PDF generation process...');

      try {
        // Load saved audit data
        const savedAudit = loadAuditResultsSync();
        if (!savedAudit || !savedAudit.scores) {
          throw new Error('No audit data available. Please run an audit first.');
        }

        // Get property URL and date range
        const propertyUrl = document.getElementById('propertyUrl')?.value || 'N/A';
        const dateRange = document.getElementById('dateRange')?.value || 30;
        const auditDate = savedAudit.auditDate || new Date().toISOString().split('T')[0];

        // Convert charts to images first (before creating HTML)
        console.log('[PDF] Converting charts to images...');
        
        // Create temporary canvas elements to capture charts
        const radarCanvas = document.getElementById('radarChart');
        const trendCanvas = document.getElementById('trendChart');
        const snippetCanvas = document.getElementById('snippetReadinessPieChart');
        
        let radarImgData = '';
        let trendImgData = '';
        let snippetImgData = '';
        
        if (radarCanvas && window.radarChart) {
          radarImgData = radarCanvas.toDataURL('image/png');
          console.log('[PDF] Radar chart converted to image');
        }
        
        if (trendCanvas && window.trendChart) {
          trendImgData = trendCanvas.toDataURL('image/png');
          console.log('[PDF] Trend chart converted to image');
        }
        
        if (snippetCanvas && window.snippetReadinessChart) {
          snippetImgData = snippetCanvas.toDataURL('image/png');
          console.log('[PDF] Snippet readiness chart converted to image');
        }

        // Create report HTML with embedded chart images
        console.log('[PDF] Creating report HTML...');
        const reportHTML = createReportHTML(savedAudit, propertyUrl, dateRange, auditDate, {
          radarChart: radarImgData,
          trendChart: trendImgData,
          snippetReadinessChart: snippetImgData
        });

        // Verify reportHTML has content
        if (!reportHTML || reportHTML.length < 100) {
          console.error('[PDF] Report HTML is empty or too short:', reportHTML ? reportHTML.length : 'null/undefined');
          throw new Error('Report HTML is empty or too short. Cannot generate PDF.');
        }
        
        console.log('[PDF] Report HTML created successfully');
        console.log('[PDF] Report HTML length:', reportHTML.length);
        console.log('[PDF] Report HTML starts with:', reportHTML.substring(0, 100));
        console.log('[PDF] Report HTML ends with:', reportHTML.substring(reportHTML.length - 100));
        
        // Check if reportHTML contains expected content
        if (!reportHTML.includes('GAIO Audit Report')) {
          console.warn('[PDF] Warning: Report HTML may not contain expected content');
        }
        
        // Use Workshop Planner approach: exactly match printJourney pattern from print-export-dialog.tsx
        const printWindow = window.open('', '_blank');
        if (!printWindow) {
          throw new Error('Could not open print window. Please allow popups for this site.');
        }
        
        console.log('[PDF] Print window opened');
        console.log('[PDF] Writing HTML content (length:', reportHTML.length, ')');
        
        // Write the complete report HTML directly (it already includes full HTML structure)
        printWindow.document.write(reportHTML);
        printWindow.document.close();
        
        console.log('[PDF] HTML written and document closed');
        
        // Add a slight delay before triggering print to ensure content is fully loaded (exactly like printJourney)
        setTimeout(function() {
          try {
            console.log('[PDF] Attempting to print styled report...');
            printWindow.focus();
            printWindow.print();
            console.log('[PDF] Print dialog triggered');
            
            if (statusDiv) {
              statusDiv.textContent = ' Print dialog opened. Save as PDF from the print dialog.';
              statusDiv.style.color = '#10b981';
              setTimeout(() => {
                statusDiv.textContent = '';
              }, 5000);
            }
          } catch (error) {
            console.error('[PDF] Print error:', error);
            if (statusDiv) {
              statusDiv.textContent = ' Error opening print dialog. Please try again.';
              statusDiv.style.color = '#dc2626';
            }
            alert('Failed to open print dialog: ' + error.message);
          }
        }, 1500); // Increased timeout to ensure content is fully loaded (matches printJourney)

      } catch (error) {
        console.error('[PDF] ===== PDF GENERATION ERROR =====');
        console.error('[PDF] Error message:', error.message);
        console.error('[PDF] Error stack:', error.stack);
        console.error('[PDF] Error object:', error);
        
        const errorMsg = ` Error: ${error.message}`;
        if (statusDiv) {
          statusDiv.textContent = errorMsg;
          statusDiv.style.color = '#dc2626';
        }
        
        // Also show alert so user definitely sees the error
        alert(`PDF Generation Failed:\n\n${error.message}\n\nCheck the browser console for more details.`);
      } finally {
        btn.disabled = false;
        btn.style.opacity = '1';
        console.log('[PDF] ===== PDF GENERATION COMPLETE =====');
      }
    }

    // Convert Chart.js charts to images
    async function convertChartsToImages(container) {
      console.log('[PDF] Converting charts to images...');
      
      // Convert radar chart
      const radarCanvas = document.getElementById('radarChart');
      if (radarCanvas && window.radarChart) {
        console.log('[PDF] Converting radar chart...');
        const radarImg = radarCanvas.toDataURL('image/png');
        const radarImgElement = container.querySelector('#radarChartImg');
        if (radarImgElement) {
          radarImgElement.src = radarImg;
          radarImgElement.style.display = 'block';
          console.log('[PDF] Radar chart image set, data URL length:', radarImg.length);
        } else {
          console.warn('[PDF] Radar chart image element not found in container');
        }
      } else {
        console.warn('[PDF] Radar chart canvas or chart instance not found');
      }

      // Convert trend chart
      const trendCanvas = document.getElementById('trendChart');
      if (trendCanvas && window.trendChart) {
        console.log('[PDF] Converting trend chart...');
        const trendImg = trendCanvas.toDataURL('image/png');
        const trendImgElement = container.querySelector('#trendChartImg');
        if (trendImgElement) {
          trendImgElement.src = trendImg;
          trendImgElement.style.display = 'block';
          console.log('[PDF] Trend chart image set, data URL length:', trendImg.length);
        } else {
          console.warn('[PDF] Trend chart image element not found in container');
        }
      } else {
        console.warn('[PDF] Trend chart canvas or chart instance not found');
      }

      // Convert snippet readiness chart
      const snippetCanvas = document.getElementById('snippetReadinessPieChart');
      if (snippetCanvas && window.snippetReadinessChart) {
        console.log('[PDF] Converting snippet readiness chart...');
        const snippetImg = snippetCanvas.toDataURL('image/png');
        const snippetImgElement = container.querySelector('#snippetReadinessChartImg');
        if (snippetImgElement) {
          snippetImgElement.src = snippetImg;
          snippetImgElement.style.display = 'block';
          console.log('[PDF] Snippet readiness chart image set, data URL length:', snippetImg.length);
        } else {
          console.warn('[PDF] Snippet readiness chart image element not found in container');
        }
      } else {
        console.warn('[PDF] Snippet readiness chart canvas or chart instance not found');
      }
      
      console.log('[PDF] Chart conversion complete');
    }

    // Create report HTML content
    function createReportHTML(auditData, propertyUrl, dateRange, auditDate, chartImages = {}) {
      const scores = auditData.scores || {};
      const searchData = auditData.searchData || {};
      const schemaAudit = auditData.schemaAudit || {};
      const snippetReadiness = auditData.snippetReadiness || 0;
      const localSignals = auditData.localSignals || null;
      const hasLocalSignals = localSignals && localSignals.status === 'ok' && localSignals.data;
      const localSignalsData = hasLocalSignals ? localSignals.data : null;

      // Helper function for RAG status
      const getRAGStatus = (score) => {
        if (score >= 70) return { color: '#10b981', label: 'Green', text: 'Good' };
        if (score >= 40) return { color: '#f59e0b', label: 'Amber', text: 'Needs Improvement' };
        return { color: '#ef4444', label: 'Red', text: 'Poor' };
      };

      // Get next steps (create a helper function similar to the one in displayDashboard)
      const getNextStepsForPDF = (scores, searchData, schemaAudit) => {
        const nextSteps = {};
        
        Object.entries(scores).forEach(([key, score]) => {
          const steps = [];
          
          switch(key) {
            case 'contentSchema':
              if (schemaAudit && schemaAudit.data) {
                const schemaData = schemaAudit.data;
                const { coverage, schemaTypes, richEligible } = schemaData;
                
                // Use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
                const allTypes = new Set();
                if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
                  // Use all detected types for accurate calculation
                  schemaData.allDetectedTypes.forEach(type => {
                    if (type) allTypes.add(type);
                  });
                } else if (schemaTypes && Array.isArray(schemaTypes)) {
                  // Fallback: collect from schemaTypes array (contains all types, sorted by count)
                  schemaTypes.forEach(item => {
                    if (item.type) allTypes.add(item.type);
                  });
                }
                
                const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
                const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
                const foundationMissing = foundationTypes.filter(type => !allTypes.has(type));
                
                if (foundationPresent < 4) {
                  steps.push(`Foundation schemas (30%): ${foundationPresent}/4 present. Add: ${foundationMissing.join(', ')}`);
                } else {
                  steps.push(`Foundation schemas (30%): All 4 present`);
                }
                
                const richEligibleCount = Object.values(richEligible || {}).filter(eligible => eligible === true).length;
                const richResultTypesCount = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'].length;
                if (richEligibleCount < richResultTypesCount) {
                  steps.push(`Rich results (35%): ${richEligibleCount}/${richResultTypesCount} eligible. Add more rich result types`);
                } else {
                  steps.push(`Rich results (35%): All ${richResultTypesCount} types eligible`);
                }
                
                if (coverage < 100) {
                  steps.push(`Coverage (20%): ${coverage.toFixed(1)}% - Add schema to pages without markup`);
                } else {
                  steps.push(`Coverage (20%): 100% - All pages have schema`);
                }
                
                const uniqueTypesCount = allTypes.size;
                if (uniqueTypesCount < 15) {
                  steps.push(`Diversity (15%): ${uniqueTypesCount} unique types. Add more schema types to reach 15+`);
                } else {
                  steps.push(`Diversity (15%): ${uniqueTypesCount} unique types (excellent)`);
                }
              } else {
                steps.push('Schema audit data not available - run audit to see detailed metrics');
              }
              break;
              
            case 'visibility':
              if (searchData) {
                const position = searchData.averagePosition || 0;
                const ctr = searchData.ctr || 0;
                
                if (position > 10) {
                  steps.push(`Average position: ${position.toFixed(1)} - Target top 10 positions`);
                } else {
                  steps.push(`Average position: ${position.toFixed(1)} - Excellent! Maintain top 10 rankings`);
                }
                
                if (ctr < 2.0) {
                  steps.push(`CTR: ${ctr.toFixed(1)}% - Improve click-through rate (target: 2%+)`);
                } else {
                  steps.push(`CTR: ${ctr.toFixed(1)}% - Good CTR! Continue optimizing`);
                }
              }
              break;
              
            case 'authority':
              if (searchData) {
                const ctr = searchData.ctr || 0;
                const position = searchData.averagePosition || 0;
                
                if (ctr < 1.5) {
                  steps.push(`CTR: ${ctr.toFixed(1)}% - Low click-through indicates trust issues. Improve E-A-T signals`);
                } else {
                  steps.push(`CTR: ${ctr.toFixed(1)}% - Good engagement. Build more backlinks to strengthen authority`);
                }
                
                if (position > 15) {
                  steps.push(`Position: ${position.toFixed(1)} - Improve rankings through comprehensive, expert content`);
                }
              }
              break;
              
            case 'localEntity':
              if (hasLocalSignals && localSignalsData) {
                const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                const locationsCount = localSignalsData.locations?.length || 0;
                const knowledgePanel = localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected';
                steps.push(`Current score: ${Math.round(score)} - Using real Business Profile data`);
                steps.push(`Data: NAP consistency: ${napScore}%, Knowledge panel: ${knowledgePanel}, Locations: ${locationsCount}`);
                if (score < 70) {
                  if (napScore < 100) {
                    steps.push(`Action: Improve NAP consistency (currently ${napScore}%)`);
                  }
                  if (!localSignalsData.knowledgePanelDetected) {
                    steps.push(`Action: Work on knowledge panel detection`);
                  }
                }
              } else {
                steps.push(`Current score: ${Math.round(score)} - Using derived calculation from search performance`);
                steps.push(`Priority: Integrate Google Business Profile API to use real local signals data`);
                if (score < 70) {
                  steps.push(`Action: Add LocalBusiness schema markup and ensure NAP consistency`);
                }
              }
              break;
              
            case 'serviceArea':
              if (hasLocalSignals && localSignalsData) {
                const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
                const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                steps.push(`Current score: ${Math.round(score)} - Using real Business Profile data`);
                steps.push(`Data: Service areas: ${serviceAreasCount}, NAP consistency: ${napScore}%`);
                if (score < 70) {
                  if (serviceAreasCount < 5) {
                    steps.push(`Action: Add more service areas (currently ${serviceAreasCount}, target: 5+)`);
                  }
                  if (napScore < 100) {
                    steps.push(`Action: Improve NAP consistency (currently ${napScore}%)`);
                  }
                }
              } else {
                steps.push(`Current score: ${Math.round(score)} - Using derived calculation from Local Entity`);
                steps.push(`Priority: Integrate Google Business Profile API to get real service area data`);
                if (score < 70) {
                  steps.push(`Action: Add ServiceArea schema and create location-specific pages`);
                }
              }
              break;
          }
          
          if (steps.length === 0) {
            if (score >= 70) {
              steps.push('Maintain current performance');
              steps.push('Monitor for any score drops');
            } else if (score >= 40) {
              steps.push('Focus on improving this pillar');
              steps.push('Review specific metrics above');
            } else {
              steps.push('Critical: Immediate action required');
              steps.push('Review all data sources and implement fixes');
            }
          }
          
          nextSteps[key] = steps;
        });
        
        return nextSteps;
      };
      
      const nextSteps = getNextStepsForPDF(scores, searchData, schemaAudit);

      return `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <style>
            body {
              font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
              color: #333;
              line-height: 1.6;
              margin: 0;
              padding: 0;
            }
            .report-header {
              text-align: center;
              border-bottom: 3px solid #f97316;
              padding-bottom: 20px;
              margin-bottom: 30px;
            }
            .report-header h1 {
              color: #f97316;
              margin: 0 0 10px 0;
              font-size: 28px;
            }
            .report-header .meta {
              color: #666;
              font-size: 14px;
            }
            .section {
              margin-bottom: 40px;
              page-break-inside: avoid;
            }
            .section-title {
              background: #f97316;
              color: white;
              padding: 12px 20px;
              margin: 0 0 20px 0;
              font-size: 20px;
              font-weight: bold;
              border-radius: 4px;
            }
            .pillar-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
              gap: 15px;
              margin-bottom: 30px;
            }
            .pillar-card {
              border: 2px solid #e2e8f0;
              border-radius: 8px;
              padding: 15px;
              background: #f8f9fa;
            }
            .pillar-card h3 {
              margin: 0 0 10px 0;
              font-size: 16px;
              color: #333;
            }
            .pillar-score {
              font-size: 36px;
              font-weight: bold;
              margin: 10px 0;
            }
            .rag-indicator {
              display: inline-block;
              width: 12px;
              height: 12px;
              border-radius: 50%;
              margin-right: 5px;
            }
            .metrics-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
              gap: 15px;
              margin-bottom: 30px;
            }
            .metric-card {
              border: 1px solid #e2e8f0;
              border-radius: 6px;
              padding: 15px;
              text-align: center;
              background: #ffffff;
            }
            .metric-value {
              font-size: 28px;
              font-weight: bold;
              color: #2563eb;
              margin: 10px 0;
            }
            .metric-label {
              color: #666;
              font-size: 14px;
            }
            .chart-container {
              text-align: center;
              margin: 30px 0;
              page-break-inside: avoid;
            }
            .chart-container img {
              max-width: 100%;
              height: auto;
              border: 1px solid #e2e8f0;
              border-radius: 4px;
            }
            .chart-title {
              font-size: 18px;
              font-weight: bold;
              margin-bottom: 15px;
              color: #333;
            }
            .definition-box {
              background: #f0f9ff;
              border-left: 4px solid #2563eb;
              padding: 15px;
              margin: 20px 0;
              border-radius: 4px;
            }
            .definition-box h4 {
              margin: 0 0 10px 0;
              color: #2563eb;
            }
            .next-steps {
              background: #fff7ed;
              border-left: 4px solid #f59e0b;
              padding: 15px;
              margin: 20px 0;
              border-radius: 4px;
            }
            .next-steps h4 {
              margin: 0 0 10px 0;
              color: #f59e0b;
            }
            .next-steps ul {
              margin: 10px 0;
              padding-left: 20px;
            }
            .next-steps li {
              margin: 8px 0;
            }
            table {
              width: 100%;
              border-collapse: collapse;
              margin: 20px 0;
            }
            table th, table td {
              border: 1px solid #e2e8f0;
              padding: 10px;
              text-align: left;
            }
            table th {
              background: #f8f9fa;
              font-weight: bold;
            }
            .footer {
              margin-top: 50px;
              padding-top: 20px;
              border-top: 1px solid #e2e8f0;
              text-align: center;
              color: #666;
              font-size: 12px;
            }
          </style>
        </head>
        <body>
          <div class="report-header">
            <h1>GAIO Audit Report</h1>
            <div class="meta">
              <strong>Property:</strong> ${propertyUrl}<br>
              <strong>Date Range:</strong> Last ${dateRange} days<br>
              <strong>Audit Date:</strong> ${new Date(auditDate).toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' })}
            </div>
          </div>

          <!-- Executive Summary -->
          <div class="section">
            <div class="section-title">Executive Summary</div>
            <div style="margin-bottom: 20px;">
              <p><strong>Overall Snippet Readiness:</strong> <span style="font-size: 24px; font-weight: bold; color: ${getRAGStatus(snippetReadiness).color};">${snippetReadiness}%</span> 
              <span class="rag-indicator" style="background-color: ${getRAGStatus(snippetReadiness).color};"></span>${getRAGStatus(snippetReadiness).text}</p>
              <p>The Snippet Readiness score indicates how likely your content is to appear in featured snippets and AI answers. It combines Content/Schema (40%), Visibility (35%), and Authority (25%).</p>
            </div>
          </div>

          <!-- Pillar Scores -->
          <div class="section">
            <div class="section-title">Pillar Scores Overview</div>
            <div class="pillar-grid">
              ${Object.entries(scores).map(([key, score]) => {
                const rag = getRAGStatus(score);
                const pillarNames = {
                  localEntity: 'Local Entity',
                  serviceArea: 'Service Area',
                  authority: 'Authority',
                  visibility: 'Visibility',
                  contentSchema: 'Content/Schema'
                };
                return `
                  <div class="pillar-card">
                    <h3>${pillarNames[key] || key}</h3>
                    <div class="pillar-score" style="color: ${rag.color};">${score}%</div>
                    <div>
                      <span class="rag-indicator" style="background-color: ${rag.color};"></span>
                      <strong>${rag.label}</strong> - ${rag.text}
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>

          <!-- Charts -->
          <div class="section">
            <div class="section-title">Visual Analytics</div>
            
            <div class="chart-container">
              <div class="chart-title">Pillar Scores Radar Chart</div>
              ${chartImages.radarChart ? '<img src="' + chartImages.radarChart + '" alt="Radar Chart" style="max-width: 600px; margin: 0 auto; display: block;">' : '<p style="color: #999;">Chart not available</p>'}
              <p style="color: #666; font-size: 14px; margin-top: 10px;">Radar chart showing current performance across all five pillars. The larger the area, the stronger your overall entity recognition.</p>
            </div>
            
            <div class="chart-container">
              <div class="chart-title">Performance Trends</div>
              ${chartImages.trendChart ? '<img src="' + chartImages.trendChart + '" alt="Trend Chart" style="max-width: 100%; margin: 0 auto; display: block;">' : '<p style="color: #999;">Chart not available</p>'}
              <p style="color: #666; font-size: 14px; margin-top: 10px;">Historical performance trends showing clicks, impressions, CTR, position, and Content/Schema scores over the selected date range.</p>
            </div>
            
            <div class="chart-container">
              <div class="chart-title">Snippet Readiness Gauge</div>
              ${chartImages.snippetReadinessChart ? '<img src="' + chartImages.snippetReadinessChart + '" alt="Snippet Readiness Chart" style="max-width: 500px; margin: 0 auto; display: block;">' : '<p style="color: #999;">Chart not available</p>'}
              <p style="color: #666; font-size: 14px; margin-top: 10px;">Nested doughnut chart showing weighted breakdown of snippet readiness components with actual performance scores.</p>
            </div>
          </div>

          <!-- Metrics -->
          <div class="section">
            <div class="section-title">Key Metrics</div>
            <div class="metrics-grid">
              <div class="metric-card">
                <div class="metric-value">${(searchData.totalClicks || 0).toLocaleString()}</div>
                <div class="metric-label">Total Clicks</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(searchData.totalImpressions || 0).toLocaleString()}</div>
                <div class="metric-label">Total Impressions</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(searchData.ctr || 0).toFixed(1)}%</div>
                <div class="metric-label">Average CTR</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(searchData.averagePosition || 0).toFixed(1)}</div>
                <div class="metric-label">Average Position</div>
              </div>
            </div>
          </div>

          <!-- Pillar Definitions -->
          <div class="section">
            <div class="section-title">Pillar Definitions & Current Status</div>
            ${Object.entries(scores).map(([key, score]) => {
              const rag = getRAGStatus(score);
              const pillarNames = {
                localEntity: 'Local Entity',
                serviceArea: 'Service Area',
                authority: 'Authority',
                visibility: 'Visibility',
                contentSchema: 'Content/Schema'
              };
              // Build definitions dynamically based on whether we have real Business Profile data
              let localEntityDef, serviceAreaDef;
              if (hasLocalSignals && localSignalsData) {
                const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
                const locationsCount = localSignalsData.locations?.length || 0;
                localEntityDef = `Measures how well your business is recognized as a local entity. Uses real data from Google Business Profile API: NAP consistency (${napScore}%), knowledge panel (${localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected'}), locations (${locationsCount}).`;
                serviceAreaDef = `Assesses your service area coverage and geographic relevance. Uses real data from Google Business Profile API: ${serviceAreasCount} service areas, NAP consistency (${napScore}%).`;
              } else {
                localEntityDef = 'Measures how well your business is recognized as a local entity. Based on LocalBusiness schema presence, NAP consistency, and knowledge panel detection. Currently uses derived calculations from GSC data.';
                serviceAreaDef = 'Assesses your service area coverage and geographic relevance. Derived from Local Entity score. Will use real service area data when Google Business Profile API is integrated.';
              }
              
              const definitions = {
                localEntity: localEntityDef,
                serviceArea: serviceAreaDef,
                authority: 'Evaluates your domain authority and trust signals. Calculated from four components: Behaviour Score (40%): CTR for ranking queries + top-10 CTR. Ranking Score (20%): Average position + top-10 impression share. Backlink Score (20%): Referring domains + quality from CSV upload. Review Score (20%): Combined ratings and counts from Google Business Profile + on-site/Trustpilot reviews.',
                visibility: 'Tracks your search visibility and ranking performance. Based on average position from Google Search Console (1 = best, 40 = worst). Score ranges from 10 to 100.',
                contentSchema: 'Measures schema markup quality and completeness. Weighted calculation: Foundation Schemas (30%), Rich Results (35%), Coverage (20%), Diversity (15%).'
              };
              return `
                <div class="definition-box">
                  <h4>${pillarNames[key] || key} - ${score}% 
                    <span class="rag-indicator" style="background-color: ${rag.color};"></span>${rag.label}
                  </h4>
                  <p>${definitions[key] || 'No definition available.'}</p>
                </div>
              `;
            }).join('')}
          </div>

          <!-- Next Steps -->
          <div class="section">
            <div class="section-title">Recommended Next Steps</div>
            ${Object.entries(nextSteps).map(([pillar, steps]) => {
              if (!steps || steps.length === 0) return '';
              const pillarNames = {
                localEntity: 'Local Entity',
                serviceArea: 'Service Area',
                authority: 'Authority',
                visibility: 'Visibility',
                contentSchema: 'Content/Schema'
              };
              return `
                <div class="next-steps">
                  <h4>${pillarNames[pillar] || pillar}</h4>
                  <ul>
                    ${steps.map(step => `<li>${step}</li>`).join('')}
                  </ul>
                </div>
              `;
            }).join('')}
          </div>

          <!-- Schema Audit Summary -->
          ${schemaAudit.data ? `
          <div class="section">
            <div class="section-title">Schema Audit Summary</div>
            <div class="metrics-grid">
              <div class="metric-card">
                <div class="metric-value">${schemaAudit.data.totalPages || 0}</div>
                <div class="metric-label">Total Pages Scanned</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${schemaAudit.data.pagesWithSchema || 0}</div>
                <div class="metric-label">Pages With Schema</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(schemaAudit.data.coverage || 0).toFixed(1)}%</div>
                <div class="metric-label">Schema Coverage</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(schemaAudit.data.schemaTypes || []).length}</div>
                <div class="metric-label">Schema Types Found</div>
              </div>
            </div>
            ${schemaAudit.data.missingSchemaPages && schemaAudit.data.missingSchemaPages.length > 0 ? `
              <div style="margin-top: 20px;">
                <h4>Pages Missing Schema (${schemaAudit.data.missingSchemaPages.length}):</h4>
                <ul style="font-size: 12px; max-height: 200px; overflow-y: auto;">
                  ${schemaAudit.data.missingSchemaPages.slice(0, 20).map(url => `<li>${url}</li>`).join('')}
                  ${schemaAudit.data.missingSchemaPages.length > 20 ? `<li><em>... and ${schemaAudit.data.missingSchemaPages.length - 20} more</em></li>` : ''}
                </ul>
              </div>
            ` : ''}
          </div>
          ` : ''}

          <!-- Top Queries -->
          ${searchData.topQueries && searchData.topQueries.length > 0 ? `
          <div class="section">
            <div class="section-title">Top Queries</div>
            <table>
              <thead>
                <tr>
                  <th>Query</th>
                  <th>Clicks</th>
                  <th>Impressions</th>
                  <th>CTR</th>
                  <th>Position</th>
                </tr>
              </thead>
              <tbody>
                ${searchData.topQueries.slice(0, 20).map(query => `
                  <tr>
                    <td>${query.query || 'N/A'}</td>
                    <td>${(query.clicks || 0).toLocaleString()}</td>
                    <td>${(query.impressions || 0).toLocaleString()}</td>
                    <td>${(query.ctr || 0).toFixed(1)}%</td>
                    <td>${(query.position || 0).toFixed(1)}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
          ` : ''}

          <div class="footer">
            <p>Generated by AIO Audit Dashboard on ${new Date().toLocaleString('en-GB')}</p>
            <p>This report contains data from Google Search Console API and schema audit results.</p>
          </div>
        </body>
        </html>
      `;
    }
    // ======================
    // Ranking & AI: Progress Modal Functions
    // ======================
    const RankingAiProgressModal = {
      steps: [
        { id: 'init', label: 'Initializing', narrative: 'Preparing to fetch ranking and AI data...' },
        { id: 'serp', label: 'Fetching SERP Rankings', narrative: 'Retrieving search engine rankings and search volume data...' },
        { id: 'ai', label: 'Fetching AI Overview Data', narrative: 'Checking AI Overview presence and citations...' },
        { id: 'process', label: 'Processing Results', narrative: 'Combining data and calculating metrics...' },
        { id: 'save', label: 'Saving Data', narrative: 'Storing results to database...' },
        { id: 'complete', label: 'Complete', narrative: 'Ranking & AI check completed successfully!' }
      ],
      
      show() {
        const modal = document.getElementById('rankingAiProgressModal');
        if (modal) {
          modal.style.display = 'block';
          this.updateProgress(0);
          this.renderSteps();
          
          // CRITICAL: Keep global run modal visible when individual task modals open
          // Don't hide the global run modal - they should be visible side-by-side
          const globalRunModal = document.getElementById('dashboardRunModal');
          if (globalRunModal && globalRunModal.style.display === 'block') {
            // Global run modal is already visible - keep it visible
            debugLog('[RankingAiProgressModal] Global run modal is visible - keeping it visible alongside this modal', 'info');
          }
          
          // Hide summary section when starting new scan
          const summaryEl = document.getElementById('rankingAiSummary');
          if (summaryEl) {
            summaryEl.style.display = 'none';
          }
          
          // Disable close button during processing
          const closeBtn = document.getElementById('rankingAiProgressClose');
          if (closeBtn) {
            closeBtn.disabled = true;
            closeBtn.style.opacity = '0.5';
            closeBtn.onclick = null;
          }
        }
      },
      
      hide() {
        const modal = document.getElementById('rankingAiProgressModal');
        if (modal) {
          modal.style.display = 'none';
        }
      },
      
      updateProgress(percent, stepIndex = null) {
        const fill = document.getElementById('rankingAiProgressFill');
        const text = document.getElementById('rankingAiProgressText');
        if (fill) fill.style.width = `${Math.min(100, Math.max(0, percent))}%`;
        if (text) text.textContent = `${Math.round(percent)}%`;
        
        if (stepIndex !== null) {
          this.setActiveStep(stepIndex);
        }
      },
      
      setActiveStep(stepIndex, isComplete = false) {
        const steps = document.querySelectorAll('.ranking-ai-step-item');
        const progressFill = document.getElementById('rankingAiProgressFill');
        const progressPercent = progressFill ? parseFloat(progressFill.style.width) || 0 : 0;
        const isFullyComplete = isComplete || (stepIndex === this.steps.length - 1 && progressPercent >= 100);
        
        steps.forEach((step, idx) => {
          step.classList.remove('active', 'completed', 'pending');
          const icon = step.querySelector('.ranking-ai-step-icon');
          if (idx < stepIndex || (idx === stepIndex && isFullyComplete)) {
            step.classList.add('completed');
            if (icon) icon.textContent = '';
          } else if (idx === stepIndex) {
            step.classList.add('active');
            if (icon) icon.textContent = idx + 1;
          } else {
            step.classList.add('pending');
            if (icon) icon.textContent = idx + 1;
          }
        });
        
        const step = this.steps[stepIndex];
        if (step) {
          const currentStepEl = document.getElementById('rankingAiCurrentStep');
          const narrativeEl = document.getElementById('rankingAiStepNarrative');
          if (currentStepEl) currentStepEl.textContent = step.label;
          if (narrativeEl) narrativeEl.textContent = step.narrative;
        }
      },
      
      updateCounts(text) {
        const countsEl = document.getElementById('rankingAiStepCounts');
        if (countsEl) countsEl.textContent = text;
      },
      
      renderSteps() {
        const listEl = document.getElementById('rankingAiStepsList');
        if (!listEl) return;
        
        listEl.innerHTML = this.steps.map((step, idx) => `
          <div class="ranking-ai-step-item pending">
            <div class="ranking-ai-step-icon">${idx + 1}</div>
            <div class="ranking-ai-step-label">${step.label}</div>
          </div>
        `).join('');
      },

      showSummary(summary) {
        const summaryEl = document.getElementById('rankingAiSummary');
        const summaryContentEl = document.getElementById('rankingAiSummaryContent');
        if (!summaryEl || !summaryContentEl) return;

        // Build summary HTML
        const summaryItems = [];
        
        // Handle error case
        if (summary.error) {
          summaryItems.push(`<div style="padding: 1rem; background: #fef2f2; border-radius: 6px; border-left: 3px solid #ef4444; margin-bottom: 1rem;"><strong style="color: #ef4444;">Error:</strong><br><span style="font-size: 1rem;">${summary.errorMessage || 'Unknown error occurred'}</span></div>`);
        }
        
        if (summary.totalKeywords !== undefined) {
          summaryItems.push(`<div style="padding: 0.75rem; background: #f0f9ff; border-radius: 6px; border-left: 3px solid #0284c7;"><strong style="color: #0284c7;">Total Keywords:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.totalKeywords}</span></div>`);
        }
        
        if (summary.keywordsWithRank !== undefined) {
          summaryItems.push(`<div style="padding: 0.75rem; background: #f0fdf4; border-radius: 6px; border-left: 3px solid #10b981;"><strong style="color: #10b981;">With Rankings:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.keywordsWithRank}</span></div>`);
        }
        
        if (summary.top10 !== undefined) {
          summaryItems.push(`<div style="padding: 0.75rem; background: #fffbeb; border-radius: 6px; border-left: 3px solid #f59e0b;"><strong style="color: #f59e0b;">Top 10 Rankings:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.top10}</span></div>`);
        }
        
        if (summary.top3 !== undefined) {
          summaryItems.push(`<div style="padding: 0.75rem; background: #fef3c7; border-radius: 6px; border-left: 3px solid #fbbf24;"><strong style="color: #fbbf24;">Top 3 Rankings:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.top3}</span></div>`);
        }
        
        if (summary.keywordsWithAiOverview !== undefined) {
          summaryItems.push(`<div style="padding: 0.75rem; background: #f5f3ff; border-radius: 6px; border-left: 3px solid #8b5cf6;"><strong style="color: #8b5cf6;">AI Overview Present:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.keywordsWithAiOverview}</span></div>`);
        }
        
        if (summary.keywordsWithAiCitations !== undefined) {
          summaryItems.push(`<div style="padding: 0.75rem; background: #ede9fe; border-radius: 6px; border-left: 3px solid #a78bfa;"><strong style="color: #a78bfa;">AI Citations:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.keywordsWithAiCitations}</span></div>`);
        }
        
        if (summary.avgPositionUnweighted !== null && summary.avgPositionUnweighted !== undefined) {
          const avgPosUnw = (typeof summary.avgPositionUnweighted === 'number' && !isNaN(summary.avgPositionUnweighted)) ? summary.avgPositionUnweighted.toFixed(1) : String(summary.avgPositionUnweighted);
          summaryItems.push(`<div style="padding: 0.75rem; background: #f0f9ff; border-radius: 6px; border-left: 3px solid #0284c7;"><strong style="color: #0284c7;">Avg Position (Unweighted):</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${avgPosUnw}</span></div>`);
        }
        
        if (summary.avgPositionVolumeWeighted !== null && summary.avgPositionVolumeWeighted !== undefined) {
          const avgPosW = (typeof summary.avgPositionVolumeWeighted === 'number' && !isNaN(summary.avgPositionVolumeWeighted)) ? summary.avgPositionVolumeWeighted.toFixed(1) : String(summary.avgPositionVolumeWeighted);
          summaryItems.push(`<div style="padding: 0.75rem; background: #f0f9ff; border-radius: 6px; border-left: 3px solid #0284c7;"><strong style="color: #0284c7;">Avg Position (Weighted):</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${avgPosW}</span></div>`);
        }
        
        if (summary.keywordsWithVolume !== undefined) {
          summaryItems.push(`<div style="padding: 0.75rem; background: #f0fdf4; border-radius: 6px; border-left: 3px solid #10b981;"><strong style="color: #10b981;">With Search Volume:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.keywordsWithVolume}</span></div>`);
        }

        summaryContentEl.innerHTML = summaryItems.join('');
        summaryEl.style.display = 'block';
      }
    };
    
    // Make progress modal globally available
    window.RankingAiProgressModal = RankingAiProgressModal;

    // ======================
    // Ranking & AI: Save data to Supabase and localStorage
    // ======================
    /**
     * Save a single batch of keywords incrementally to Supabase keyword_rankings table
     * This allows partial results to be saved even if later batches fail
     */
    async function saveRankingAiDataIncremental(batchRows, auditDate, propertyUrl) {
      try {
        if (!batchRows || batchRows.length === 0) {
          return { success: true, saved: 0 };
        }

        // Prepare keyword rows for insertion
        const keywordRows = batchRows.map(row => ({
          audit_date: auditDate,
          property_url: String(propertyUrl).trim(),
          keyword: String(row.keyword || '').trim(),
          best_rank_group: row.best_rank_group !== null && row.best_rank_group !== undefined ? parseInt(row.best_rank_group) : null,
          best_rank_absolute: row.best_rank_absolute !== null && row.best_rank_absolute !== undefined ? parseInt(row.best_rank_absolute) : null,
          best_url: row.best_url ? String(row.best_url).trim() : null,
          best_title: row.best_title ? String(row.best_title).trim() : null,
          search_volume: row.search_volume !== null && row.search_volume !== undefined ? parseInt(row.search_volume) : null,
          has_ai_overview: row.has_ai_overview === true,
          ai_total_citations: row.ai_total_citations !== null && row.ai_total_citations !== undefined ? parseInt(row.ai_total_citations) : null,
          ai_alan_citations_count: row.ai_alan_citations_count !== null && row.ai_alan_citations_count !== undefined ? parseInt(row.ai_alan_citations_count) : null,
          ai_alan_citations: row.ai_alan_citations ? (Array.isArray(row.ai_alan_citations) ? row.ai_alan_citations : []) : null,
          competitor_counts: row.competitor_counts ? (typeof row.competitor_counts === 'object' ? row.competitor_counts : {}) : null,
          serp_features: row.serp_features ? (typeof row.serp_features === 'object' ? row.serp_features : {}) : null,
          // New boolean fields for SERP feature coverage
          ai_overview_present_any: row.ai_overview_present_any === true || row.has_ai_overview === true,
          local_pack_present_any: row.local_pack_present_any === true || (row.serp_features && row.serp_features.local_pack === true),
          paa_present_any: row.paa_present_any === true || (row.serp_features && row.serp_features.people_also_ask === true),
          featured_snippet_present_any: row.featured_snippet_present_any === true || (row.serp_features && row.serp_features.featured_snippet === true),
          segment: row.segment ? String(row.segment).trim() : null,
          page_type: row.pageType ? String(row.pageType).trim() : null,
          demand_share: row.demand_share !== null && row.demand_share !== undefined ? parseFloat(row.demand_share) : null,
          opportunity_score: row.opportunityScore !== null && row.opportunityScore !== undefined ? parseInt(row.opportunityScore) : null,
          updated_at: new Date().toISOString()
        }));

        // Use upsert endpoint to save batch (will merge duplicates based on unique constraint)
        const response = await fetch(apiUrl('/api/supabase/save-keyword-batch'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            keywordRows,
            auditDate,
            propertyUrl
          })
        });

        if (response.ok) {
          const responseData = await response.json();
          debugLog(` Incremental save: ${batchRows.length} keywords saved to keyword_rankings`, 'success');
          return { success: true, saved: batchRows.length };
        } else {
          const errorText = await response.text();
          debugLog(` Incremental save failed: ${response.status} - ${errorText}`, 'warn');
          return { success: false, saved: 0, error: errorText };
        }
      } catch (err) {
        debugLog(` Error in incremental save: ${err.message}`, 'error');
        return { success: false, saved: 0, error: err.message };
      }
    }

    async function saveRankingAiData(combinedRows, summary) {
      try {
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (!propertyUrl) {
          debugLog(' Cannot save Ranking & AI data: property URL not set', 'warn');
          return { success: false, error: 'Property URL not set' };
        }

        // Save to localStorage first (with quota error handling)
        const rankingAiData = {
          combinedRows,
          summary,
          timestamp: new Date().toISOString()
        };
        let localStorageSuccess = false;
        try {
          const jsonStr = JSON.stringify(rankingAiData);
          const sizeKB = (new Blob([jsonStr]).size) / 1024;
          localStorage.setItem('rankingAiData', jsonStr);
          debugLog(` Ranking & AI data saved to localStorage (${sizeKB.toFixed(1)}KB)`, 'success');
          localStorageSuccess = true;
        } catch (localStorageErr) {
          if (localStorageErr.name === 'QuotaExceededError' || localStorageErr.message.includes('quota')) {
            const dataSizeKB = (new Blob([JSON.stringify(rankingAiData)]).size) / 1024;
            debugLog(` Data too large for localStorage (${dataSizeKB.toFixed(1)}KB). Supabase is source of truth.`, 'warn');
          } else {
            debugLog(` Error saving to localStorage: ${localStorageErr.message}`, 'warn');
          }
          // Continue to Supabase save even if localStorage fails
        }
        
        // Dashboard: refresh live dials/cards immediately when Ranking & AI saves
        if (typeof window.renderDashboardTab === 'function') {
          try { window.renderDashboardTab(); } catch (e) {}
        }

        // Save to Supabase
        const auditDate = new Date().toISOString().split('T')[0];
        const response = await fetch(apiUrl('/api/supabase/save-audit'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            propertyUrl,
            auditDate,
            rankingAiData // New field for ranking AI data
          })
        });

        if (response.ok) {
          const responseData = await response.json();
          debugLog(` Ranking & AI data saved to Supabase (${combinedRows.length} keywords)`, 'success');
          if (responseData.data) {
            debugLog(` Supabase confirmed save: ${JSON.stringify(responseData.data).substring(0, 200)}...`, 'info');
          }
          
          // Keep Portfolio AI metrics in sync: update portfolio_segment_metrics_28d AI fields from keyword_rankings
          // (important for single-URL segments like "Academy")
          try {
            const aiResp = await fetch(apiUrl('/api/supabase/backfill-ai-portfolio-segments'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                auditDate,
                siteUrl: propertyUrl
              })
            });
            if (aiResp.ok) {
              debugLog(' Portfolio AI metrics refreshed from keyword_rankings', 'success');
              if (typeof renderPortfolioTable === 'function') {
                renderPortfolioTable();
              }
            } else {
              const t = await aiResp.text();
              debugLog(` Portfolio AI metrics refresh failed: ${aiResp.status} - ${t}`, 'warn');
            }
          } catch (aiSyncErr) {
            debugLog(` Portfolio AI metrics refresh failed: ${aiSyncErr.message}`, 'warn');
          }
          
          return { success: true, localStorageSaved: localStorageSuccess };
        } else {
          const errorText = await response.text();
          debugLog(` Failed to save Ranking & AI data to Supabase: ${response.status} - ${errorText}`, 'warn');
          console.error('[Save Ranking & AI] Full error response:', errorText);
          return { success: false, error: `Supabase save failed: ${response.status} - ${errorText}` };
        }
      } catch (err) {
        debugLog(` Error saving Ranking & AI data: ${err.message}`, 'error');
        console.error('Save Ranking & AI data error:', err);
        return { success: false, error: err.message };
      }
    }

    function classifyPortfolioSegmentFromUrl(rawUrl) {
      if (!rawUrl) return null;
      const canonical = (typeof normalizeGscPageKey === 'function') ? normalizeGscPageKey(rawUrl) : String(rawUrl);
      const lower = String(canonical).toLowerCase();
      const isPathOnly = lower.startsWith('/');
      if (!isPathOnly && !lower.includes('alanranger.com')) return null;

      // Academy + Blog overrides (even though pageSegment marks academy as education)
      if (lower.includes('/free-online-photography-course')) return 'academy';
      if (lower.includes('/blog-on-photography/')) return 'blog';

      // Use the canonical page segment classifier for money vs non-money
      try {
        if (typeof classifyPageSegment === 'function' && typeof PageSegment !== 'undefined') {
          const seg = classifyPageSegment(canonical);
          if (seg !== PageSegment.MONEY) return 'other';
        }
      } catch (e) {
        // If classifier fails, treat as Other
        return 'other';
      }

      // Money  use the same sub-segment heuristics as backend (stable and not dependent on Ranking&AI pageType)
      // Event pages
      if (lower.includes('/beginners-photography-lessons') || lower.includes('/photographic-workshops-near-me')) {
        return 'event';
      }
      // Product pages
      if (lower.includes('/photo-workshops-uk') || lower.includes('/photography-services-near-me')) {
        return 'product';
      }
      // Default money bucket
      return 'landing';
    }

    function computeAiCitationsByCitedUrlSegment(rows) {

      const segCounts = {
        landing: 0,
        event: 0,
        product: 0,
        academy: 0,
        blog: 0,
        other: 0,
        money: 0,
        site: 0
      };

      const inferSegs = (url) => {
        const seg = classifyPortfolioSegmentFromUrl(url);
        if (!seg) return [];
        if (seg === 'landing' || seg === 'event' || seg === 'product') return [seg, 'money'];
        return [seg];
      };

      const extractCitedUrls = (row) => {
        const raw = row?.ai_alan_citations || row?.aiAlanCitations || [];
        if (!raw || !Array.isArray(raw)) return [];
        return raw
          .map(v => {
            if (!v) return null;
            if (typeof v === 'string') return v;
            if (typeof v === 'object' && v.url) return v.url;
            return null;
          })
          .filter(Boolean);
      };

      const safeRows = Array.isArray(rows) ? rows : [];
      safeRows.forEach(r => {
        const cCount = parseInt(r.ai_alan_citations_count ?? r.aiAlanCitationsCount ?? 0, 10) || 0;
        segCounts.site += cCount;
        const citedUrls = extractCitedUrls(r);
        citedUrls.forEach(u => {
          inferSegs(u).forEach(seg => {
            if (segCounts[seg] === undefined) return;
            segCounts[seg] += 1;
          });
        });
      });

      return segCounts;
    }

    function renderRankingAiMoneyCitationsTile(rankingAiData) {
      const pill = document.getElementById('ranking-card-ai-citations-money');
      if (!pill) return;
      const valueEl = pill.querySelector('[data-field="value"]');
      const statusEl = pill.querySelector('[data-field="status"]');
      const detailsEl = document.getElementById('ranking-card-ai-citations-money-details');

      const rows = rankingAiData?.combinedRows || [];
      const counts = computeAiCitationsByCitedUrlSegment(rows);

      const moneyCitations = counts.money || 0;
      const totalCitations = counts.site || 0;
      const share = totalCitations > 0 ? (moneyCitations / totalCitations) : 0;
      const sharePct = Math.round(share * 100);
      const sumFromUrls = (counts.landing || 0) + (counts.event || 0) + (counts.product || 0) + (counts.academy || 0) + (counts.blog || 0) + (counts.other || 0);
      const unattributed = Math.max(0, (totalCitations || 0) - sumFromUrls);
      const otherTotal = (counts.other || 0) + unattributed;

      if (valueEl) valueEl.textContent = `${moneyCitations}/${totalCitations} (${sharePct}%)`;

      // RAG thresholds (money share of citations):
      // - Green: >= 70%
      // - Amber: 50-69%
      // - Red: < 50%
      let ragClass = 'red';
      let statusLabel = 'Low';
      if (sharePct >= 70) { ragClass = 'green'; statusLabel = 'Strong'; }
      else if (sharePct >= 50) { ragClass = 'amber'; statusLabel = 'Moderate'; }
      pill.className = `metric-pill metric-pill--${ragClass}`;
      if (statusEl) statusEl.textContent = statusLabel;

      if (detailsEl) {
        detailsEl.innerHTML = `
          <div style="margin-top: 0.75rem;">
            <div style="margin-bottom: 0.5rem;">How many citations point to <strong>money pages</strong> (Landing/Event/Product), based on the <strong>cited URLs</strong>.</div>
            <div style="font-size: 0.9rem; line-height: 1.6;">
              <div><strong>Money citations:</strong> ${moneyCitations} (${sharePct}%)</div>
              <div><strong>Total citations:</strong> ${totalCitations}</div>
            </div>
            <div style="margin-top: 0.75rem; border-top: 1px solid #e2e8f0; padding-top: 0.75rem;">
              <div style="font-weight: 600; margin-bottom: 0.5rem;">Breakdown (cited URLs)</div>
              <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                <tbody>
                  <tr><td style="padding: 0.25rem 0;">Landing</td><td style="padding: 0.25rem 0; text-align: right;">${counts.landing || 0}</td></tr>
                  <tr><td style="padding: 0.25rem 0;">Event</td><td style="padding: 0.25rem 0; text-align: right;">${counts.event || 0}</td></tr>
                  <tr><td style="padding: 0.25rem 0;">Product</td><td style="padding: 0.25rem 0; text-align: right;">${counts.product || 0}</td></tr>
                  <tr><td style="padding: 0.25rem 0; border-top: 1px solid #e2e8f0;">Academy</td><td style="padding: 0.25rem 0; border-top: 1px solid #e2e8f0; text-align: right;">${counts.academy || 0}</td></tr>
                  <tr><td style="padding: 0.25rem 0;">Blog</td><td style="padding: 0.25rem 0; text-align: right;">${counts.blog || 0}</td></tr>
                  <tr><td style="padding: 0.25rem 0;">Other (non-money)</td><td style="padding: 0.25rem 0; text-align: right;">${otherTotal}</td></tr>
                </tbody>
              </table>
              <div style="margin-top: 0.5rem; color: #64748b; font-size: 0.8rem;">
                ${unattributed > 0 ? `Includes <strong>${unattributed}</strong> unattributed citations (counted in totals, but no URL captured).` : `All citations were attributed to captured URLs.`}
              </div>
            </div>
          </div>
        `;
      }
    }

    // ======================
    // Portfolio: Segment URLs modal (Segment pages + AI-cited pages)
    // ======================
    function ensurePortfolioSegmentUrlsModal() {
      if (document.getElementById('portfolio-segment-urls-modal')) return;
      const modalHtml = `
        <div id="portfolio-segment-urls-modal" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.55); z-index: 99999;">
          <div style="max-width: 980px; margin: 5vh auto; background: #0b1220; border: 1px solid rgba(148,163,184,0.35); border-radius: 10px; overflow: hidden;">
            <div style="display:flex; align-items:center; justify-content:space-between; padding: 12px 14px; background: rgba(15,23,42,0.85); border-bottom: 1px solid rgba(148,163,184,0.25);">
              <div>
                <div id="portfolio-segment-urls-modal-title" style="font-weight: 700; color: #e2e8f0;">Segment URLs</div>
                <div id="portfolio-segment-urls-modal-subtitle" style="font-size: 12px; color: #94a3b8; margin-top: 2px;">Latest snapshot</div>
              </div>
              <button id="portfolio-segment-urls-modal-close" type="button" style="background: transparent; color: #e2e8f0; border: 1px solid rgba(148,163,184,0.35); border-radius: 6px; padding: 6px 10px; cursor: pointer;">Close</button>
            </div>

            <div style="padding: 12px 14px; border-bottom: 1px solid rgba(148,163,184,0.25); display:flex; gap: 10px; flex-wrap: wrap; align-items: center;">
              <button type="button" class="portfolio-segment-tab-btn" data-tab="segment" style="padding: 6px 10px; border-radius: 6px; border: 1px solid rgba(148,163,184,0.35); background: #1f2a44; color: #e2e8f0; cursor: pointer;">Segment pages</button>
              <button type="button" class="portfolio-segment-tab-btn" data-tab="cited" style="padding: 6px 10px; border-radius: 6px; border: 1px solid rgba(148,163,184,0.35); background: transparent; color: #e2e8f0; cursor: pointer;">AI-cited pages</button>
              <div style="margin-left:auto; display:flex; gap: 8px; align-items:center;">
                <button type="button" id="portfolio-segment-urls-copy" style="padding: 6px 10px; border-radius: 6px; border: 1px solid rgba(148,163,184,0.35); background: transparent; color: #e2e8f0; cursor: pointer;">Copy list</button>
              </div>
            </div>

            <div id="portfolio-segment-urls-modal-body" style="padding: 12px 14px; max-height: 70vh; overflow: auto;">
              <div id="portfolio-segment-urls-modal-status" style="color:#94a3b8; font-size: 13px;">Loading</div>
              <div id="portfolio-segment-urls-modal-content" style="margin-top: 10px;"></div>
            </div>
          </div>
        </div>
      `;
      document.body.insertAdjacentHTML('beforeend', modalHtml);

      const modal = document.getElementById('portfolio-segment-urls-modal');
      const closeBtn = document.getElementById('portfolio-segment-urls-modal-close');
      if (closeBtn && modal) closeBtn.addEventListener('click', () => { modal.style.display = 'none'; });
      if (modal) {
        modal.addEventListener('click', (e) => {
          if (e.target === modal) modal.style.display = 'none';
        });
      }

      const tabBtns = Array.from(document.querySelectorAll('#portfolio-segment-urls-modal .portfolio-segment-tab-btn'));
      tabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          tabBtns.forEach(b => {
            const active = b === btn;
            b.style.background = active ? '#1f2a44' : 'transparent';
          });
          modal.dataset.activeTab = btn.dataset.tab;
          // Re-render from cached content
          if (typeof window.__renderPortfolioSegmentUrlsModalFromCache === 'function') {
            window.__renderPortfolioSegmentUrlsModalFromCache();
          }
        });
      });

      const copyBtn = document.getElementById('portfolio-segment-urls-copy');
      if (copyBtn) {
        copyBtn.addEventListener('click', async () => {
          const txt = modal?.dataset?.copyText || '';
          if (!txt) return;
          try {
            await navigator.clipboard.writeText(txt);
            copyBtn.textContent = 'Copied';
            setTimeout(() => { copyBtn.textContent = 'Copy list'; }, 900);
          } catch (e) {
            // ignore
          }
        });
      }
    }

    function getPortfolioSegmentLabel(seg) {
      const labels = {
        site: 'Entire site',
        money: 'Money Pages',
        money_tracked: 'Money Pages (tracked)',
        landing: 'Landing',
        event: 'Event',
        product: 'Product',
        academy: 'Academy',
        blog: 'Blog Pages',
        other: 'Other (non-money)',
        all_tracked: 'All tracked'
      };
      return labels[seg] || seg;
    }

    function inferPortfolioSegmentForPageUrl(pageUrl) {
      if (!pageUrl) return null;
      return classifyPortfolioSegmentFromUrl(pageUrl) || 'other';
    }

    async function openPortfolioSegmentUrlsModal(segmentKey) {
      ensurePortfolioSegmentUrlsModal();
      const modal = document.getElementById('portfolio-segment-urls-modal');
      if (!modal) return;
      modal.style.display = 'block';
      // Default tab based on the KPI context:
      // - When looking at AI metrics, users typically want the AI-cited URLs first.
      // - For traffic KPIs, segment pages are the natural default.
      const kpi = document.getElementById('portfolio-table-kpi-select')?.value || 'ctr_28d';
      modal.dataset.activeTab = (kpi === 'ai_citations' || kpi === 'ai_overview') ? 'cited' : 'segment';

      const titleEl = document.getElementById('portfolio-segment-urls-modal-title');
      const subtitleEl = document.getElementById('portfolio-segment-urls-modal-subtitle');
      const statusEl = document.getElementById('portfolio-segment-urls-modal-status');
      const contentEl = document.getElementById('portfolio-segment-urls-modal-content');
      if (titleEl) titleEl.textContent = `${getPortfolioSegmentLabel(segmentKey)}  URLs`;
      if (subtitleEl) subtitleEl.textContent = 'Loading latest snapshot';
      if (statusEl) statusEl.textContent = 'Loading';
      if (contentEl) contentEl.innerHTML = '';

      const propertyUrl = (window.getPropertyUrl ? window.getPropertyUrl() : '') || localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
      if (!propertyUrl) {
        if (statusEl) statusEl.textContent = 'No property URL found.';
        return;
      }

      // Fetch latest page snapshot from Supabase (server decides latest date range).
      const pagesResp = await fetch(apiUrl(`/api/supabase/get-gsc-page-metrics?siteUrl=${encodeURIComponent(propertyUrl)}`));
      if (!pagesResp.ok) {
        if (statusEl) statusEl.textContent = `Failed to load pages: ${pagesResp.status}`;
        return;
      }
      const pagesJson = await pagesResp.json();
      const pages = Array.isArray(pagesJson.pages) ? pagesJson.pages : [];
      const snapshotStart = pages[0]?.date_start ? String(pages[0].date_start).slice(0, 10) : null;
      const snapshotEnd = pages[0]?.date_end ? String(pages[0].date_end).slice(0, 10) : null;

      // Latest AI audit date (from keyword_rankings), via portfolio AI backfill endpoint logic is heavier; do a small API-less heuristic:
      // We rely on Ranking & AI audits being saved with auditDate=YYYY-MM-DD, and use today in UI.
      // Fallback: use today.
      const aiAuditDate = new Date().toISOString().slice(0, 10);

      modal.__cache = {
        segmentKey,
        snapshotStart,
        snapshotEnd,
        pages,
        aiAuditDate,
        citedUrls: null
      };

      if (subtitleEl) {
        subtitleEl.textContent = snapshotStart && snapshotEnd
          ? `Latest 28d snapshot: ${snapshotStart}  ${snapshotEnd}`
          : 'Latest 28d snapshot';
      }

      // Load cited urls lazily when needed
      window.__renderPortfolioSegmentUrlsModalFromCache = async () => {
        const cache = modal.__cache || {};
        const activeTab = modal.dataset.activeTab || 'segment';
        if (statusEl) statusEl.textContent = '';
        if (contentEl) contentEl.innerHTML = '';

        const renderList = (items, metaText) => {
          const list = Array.isArray(items) ? items : [];
          modal.dataset.copyText = list.join('\n');
          const meta = `<div style="color:#94a3b8; font-size: 12px; margin-bottom: 8px;">${metaText}</div>`;
          const rows = list.slice(0, 500).map(u => `<div style="padding: 6px 0; border-bottom: 1px solid rgba(148,163,184,0.15);"><a href="${u}" target="_blank" style="color:#93c5fd; text-decoration:none;">${u}</a></div>`).join('');
          const more = list.length > 500 ? `<div style="color:#94a3b8; margin-top: 8px;">Showing first 500 of ${list.length}. Use Copy list for full.</div>` : '';
          if (contentEl) contentEl.innerHTML = `${meta}${rows}${more}`;
        };

        if (activeTab === 'segment') {
          const seg = cache.segmentKey;
          const filtered = cache.pages
            .filter(p => inferPortfolioSegmentForPageUrl(p.page_url) === seg || (seg === 'money' && ['landing','event','product'].includes(inferPortfolioSegmentForPageUrl(p.page_url))))
            .sort((a, b) => (parseFloat(b.impressions_28d) || 0) - (parseFloat(a.impressions_28d) || 0))
            .map(p => String(p.page_url));
          const label = getPortfolioSegmentLabel(seg);
          renderList(filtered, `${label}: ${filtered.length.toLocaleString()} pages in latest snapshot (sorted by impressions).`);
          return;
        }

        // cited tab
        if (!cache.citedUrls) {
          if (statusEl) statusEl.textContent = 'Loading AI cited URLs';
          // Pull latest keyword_rankings from Supabase via existing data loader in localStorage if available
          let rows = [];
          try {
            const local = localStorage.getItem('rankingAiData');
            const parsed = local ? JSON.parse(local) : null;
            rows = Array.isArray(parsed?.combinedRows) ? parsed.combinedRows : [];
          } catch (e) {}

          // If no localStorage, we cant easily query keyword_rankings without an API endpoint; show a hint.
          if (!rows || rows.length === 0) {
            cache.citedUrls = [];
            if (statusEl) statusEl.textContent = 'No Ranking & AI data found in this browser. Run a Ranking & AI check, then re-open this modal.';
          } else {
            const urls = [];
            rows.forEach(r => {
              const cited = r.ai_alan_citations || r.aiAlanCitations || [];
              if (Array.isArray(cited)) {
                cited.forEach(v => {
                  const u = typeof v === 'string' ? v : (v && typeof v === 'object' ? v.url : null);
                  if (u) urls.push(String(u));
                });
              }
            });
            // Canonicalize so text fragments and tracking params don't break classification.
            const canonicalItems = urls
              .map(u => (typeof normalizeGscPageKey === 'function') ? normalizeGscPageKey(u) : u)
              .filter(Boolean);
            cache.citedUrlItems = canonicalItems; // may include duplicates (citation items)
            cache.citedUrls = Array.from(new Set(canonicalItems)); // unique URLs
            // Unattributed citations = keyword-reported citation counts with no URL captured
            try {
              const totalCitations = rows.reduce((s, r) => s + (parseInt(r.ai_alan_citations_count ?? r.aiAlanCitationsCount ?? 0, 10) || 0), 0);
              const urlItemCount = canonicalItems.length;
              cache.unattributedCitations = Math.max(0, totalCitations - urlItemCount);
            } catch (e) {
              cache.unattributedCitations = 0;
            }
          }
        }

        const seg = cache.segmentKey;
        const citedFiltered = (cache.citedUrls || [])
          .filter(u => {
            const s = inferPortfolioSegmentForPageUrl(u);
            if (seg === 'money') return ['landing','event','product'].includes(s);
            return s === seg;
          });
        const citedItemsCount = (cache.citedUrlItems || []).filter(u => {
          const s = inferPortfolioSegmentForPageUrl(u);
          if (seg === 'money') return ['landing','event','product'].includes(s);
          return s === seg;
        }).length;
        const label = getPortfolioSegmentLabel(seg);
        const extra = (seg === 'other' && (cache.unattributedCitations || 0) > 0)
          ? ` + ${(cache.unattributedCitations || 0).toLocaleString()} unattributed (no URL captured)`
          : '';
        const citedItemsWithUnattributed = seg === 'other'
          ? (citedItemsCount + (cache.unattributedCitations || 0))
          : citedItemsCount;
        renderList(
          citedFiltered,
          `${label}: ${citedFiltered.length.toLocaleString()} unique AI-cited URLs (${citedItemsWithUnattributed.toLocaleString()} citation items${extra}) from latest Ranking & AI data in this browser.`
        );
      };

      await window.__renderPortfolioSegmentUrlsModalFromCache();
    }

    // ======================
    // Ranking & AI: Normalize summary field names (snake_case to camelCase)
    // ======================
    function normalizeSummaryFields(summary) {
      if (!summary) return summary;
      // Convert snake_case to camelCase for display compatibility
      return {
        totalKeywords: summary.total_keywords ?? summary.totalKeywords,
        keywordsWithRank: summary.keywords_with_rank ?? summary.keywordsWithRank,
        keywordsWithAiOverview: summary.keywords_with_ai_overview ?? summary.keywordsWithAiOverview,
        keywordsWithAiCitations: summary.keywords_with_ai_citations ?? summary.keywordsWithAiCitations,
        top10: summary.top10,
        top3: summary.top3,
        avgPositionUnweighted: summary.avg_position_unweighted ?? summary.avgPositionUnweighted,
        avgPositionVolumeWeighted: summary.avg_position_volume_weighted ?? summary.avgPositionVolumeWeighted,
        keywordsUsedForAvg: summary.keywords_used_for_avg ?? summary.keywordsUsedForAvg,
        keywordsWithVolume: summary.keywords_with_volume ?? summary.keywordsWithVolume,
        // v1.4: Domain Strength context (read-only)
        domainStrength: summary.domainStrength ?? null,
        authorityPriority: summary.authorityPriority ?? null
      };
    }

    // ======================
    // Ranking & AI: Compute AI metrics for a page URL
    // ======================
    // This function looks up AI Overview and AI Citations for a given URL by matching against ranking data
    window.computeAiMetricsForPageUrl = function computeAiMetricsForPageUrl(pageUrl, rankingRows) {
      if (!pageUrl || !rankingRows || !Array.isArray(rankingRows) || rankingRows.length === 0) {
        return { ai_overview: false, ai_citations: null };
      }
      
      // Normalize the page URL for matching
      const normalizedPageUrl = (pageUrl || '').toLowerCase()
        .replace(/^https?:\/\//, '')
        .replace(/^www\./, '')
        .replace(/\/$/, '');
      
      // Try to find matching rows by URL
      const matchingRows = rankingRows.filter(row => {
        const rowUrl = (row.best_url || row.targetUrl || row.ranking_url || '').toLowerCase();
        const normalizedRowUrl = rowUrl
          .replace(/^https?:\/\//, '')
          .replace(/^www\./, '')
          .replace(/\/$/, '');
        return normalizedRowUrl === normalizedPageUrl;
      });
      
      // If no URL match, return default
      if (matchingRows.length === 0) {
        return { ai_overview: false, ai_citations: null };
      }
      
      // Use the first matching row (or aggregate if multiple)
      const bestMatch = matchingRows[0];
      const aiOverview = bestMatch.has_ai_overview === true || bestMatch.ai_overview_present_any === true;
      const aiCitations = bestMatch.ai_alan_citations_count != null 
        ? bestMatch.ai_alan_citations_count 
        : (bestMatch.ai_total_citations != null ? bestMatch.ai_total_citations : null);
      
      return {
        ai_overview: aiOverview,
        ai_citations: aiCitations
      };
    };

    // Ranking & AI: Domain Strength context (read-only)
    // ======================
    let __rankingAiAuthorityContext = null;
    async function fetchRankingAiAuthorityContext() {
      if (__rankingAiAuthorityContext) return __rankingAiAuthorityContext;
      try {
        const resp = await fetch(apiUrl('/api/ranking-ai/summary'));
        const json = await resp.json();
        if (!resp.ok || !json || json.status !== 'ok') {
          __rankingAiAuthorityContext = { domainStrength: null, authorityPriority: null };
          return __rankingAiAuthorityContext;
        }
        __rankingAiAuthorityContext = {
          domainStrength: json.domainStrength || null,
          authorityPriority: json.authorityPriority || null
        };
        return __rankingAiAuthorityContext;
      } catch (e) {
        __rankingAiAuthorityContext = { domainStrength: null, authorityPriority: null };
        return __rankingAiAuthorityContext;
      }
    }

    // ======================
    // Ranking & AI: Load data from localStorage or Supabase
    // ======================
    async function loadRankingAiDataFromStorage(forceCheckSupabase = false) {
      try {
        const propertyUrl = (window.getPropertyUrl ? window.getPropertyUrl() : '') || localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (!propertyUrl) {
          debugLog(' Cannot load Ranking & AI data: property URL not set', 'warn');
          return null;
        }

        // Store localStorage data as fallback (in case Supabase check fails)
        let localStorageFallback = null;
        
        // If forcing Supabase check, skip localStorage
        if (!forceCheckSupabase) {
          // Try localStorage first
          const localData = localStorage.getItem('rankingAiData');
          if (localData) {
            try {
              const parsed = JSON.parse(localData);
              if (parsed.combinedRows && parsed.summary) {
                debugLog(' Ranking & AI data found in localStorage', 'success');
                debugLog(`  Found ${parsed.combinedRows.length} keywords in localStorage`, 'info');
                
                // Re-classify pageType for all rows (fixes stale values)
                if (typeof window.classifyUrlForRankingAi === 'function') {
                  let reclassifiedCount = 0;
                  parsed.combinedRows.forEach(row => {
                    const bestUrl = row.best_url || row.bestUrl || null;
                    if (bestUrl) {
                      const oldPageType = row.pageType || 'Landing';
                      const classification = window.classifyUrlForRankingAi(bestUrl, row.keyword || null);
                      const newPageType = classification.pageType;
                      if (newPageType !== oldPageType) {
                        row.pageType = newPageType;
                        if (classification.segment && classification.segment !== row.segment) {
                          row.segment = classification.segment;
                        }
                        reclassifiedCount++;
                      }
                    }
                  });
                  if (reclassifiedCount > 0) {
                    debugLog(` Re-classified pageType for ${reclassifiedCount} keywords from localStorage`, 'info');
                  }
                }
                
                // Normalize summary field names for compatibility
                parsed.summary = normalizeSummaryFields(parsed.summary);
                // Store as fallback before checking Supabase
                localStorageFallback = parsed;
                
                // If citations exist but citation URLs are missing, treat as stale and check Supabase
                const hasCitations = parsed.combinedRows.some(r => (r.ai_alan_citations_count || 0) > 0);
                const hasCitationUrls = parsed.combinedRows.some(r => Array.isArray(r.ai_alan_citations) && r.ai_alan_citations.length > 0);
                
                // Check if localStorage data is missing search_volume (indicates stale data)
                const keywordsMissingVolume = parsed.combinedRows.filter(r => r.search_volume == null || r.search_volume === undefined).length;
                const hasMissingVolume = keywordsMissingVolume > 0;
                
                // Always check Supabase if localStorage has fewer than 10 keywords (likely stale data)
                if (parsed.combinedRows.length < 10) {
                  debugLog(` LocalStorage has only ${parsed.combinedRows.length} keywords, checking Supabase for more...`, 'info');
                  // Continue to Supabase check below
                } else if (hasMissingVolume || (hasCitations && !hasCitationUrls)) {
                  // Check Supabase if localStorage data is missing search_volume
                  if (hasMissingVolume) {
                    debugLog(` LocalStorage data is missing search_volume for ${keywordsMissingVolume}/${parsed.combinedRows.length} keywords, checking Supabase...`, 'info');
                  } else {
                    debugLog(` LocalStorage data is missing citation URLs (counts exist), checking Supabase...`, 'info');
                  }
                  // Continue to Supabase check below
                } else {
                  // Check if data is recent (within last 24 hours) - if older, check Supabase
                  if (parsed.timestamp) {
                    const localTime = new Date(parsed.timestamp);
                    const now = new Date();
                    const hoursDiff = (now - localTime) / (1000 * 60 * 60);
                    if (hoursDiff < 24) {
                      return parsed;
                    } else {
                      debugLog(` LocalStorage data is ${Math.round(hoursDiff)} hours old, checking Supabase for newer data...`, 'info');
                    }
                  } else {
                    return parsed;
                  }
                }
              }
            } catch (e) {
              debugLog(' Invalid Ranking & AI data in localStorage', 'warn');
            }
          }
        }

        // Try Supabase (either forced or as fallback)
        debugLog(` Loading Ranking & AI data from Supabase for propertyUrl: ${propertyUrl}`, 'info');
        const response = await fetch(apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`));
        debugLog(` API fetch response status: ${response.status} ${response.statusText}`, 'info');
        
        if (response.ok) {
          const json = await response.json();
          debugLog(` API response parsed: status=${json.status}`, 'info');
          debugLog(` Response has data object: ${!!json.data}`, 'info');
          debugLog(` Response has rankingAiData: ${!!json.data?.rankingAiData}`, 'info');
          
          if (json.status === 'ok' && json.data) {
            if (json.data.rankingAiData) {
              if (json.data.rankingAiData.combinedRows) {
                const keywordCount = json.data.rankingAiData.combinedRows.length;
                const summaryKeys = json.data.rankingAiData.summary ? Object.keys(json.data.rankingAiData.summary).join(', ') : 'none';
                debugLog(` Ranking & AI data loaded from Supabase: ${keywordCount} keywords`, 'success');
                debugLog(`  Summary fields: ${summaryKeys}`, 'info');
                debugLog(`  First keyword sample: ${json.data.rankingAiData.combinedRows[0]?.keyword || 'none'}`, 'info');
                
                // Compute opportunity scores if missing (for older data)
                const combinedRows = json.data.rankingAiData.combinedRows;
                
                // Re-classify pageType for all rows (fixes stale database values)
                // This ensures Event/Product pages are correctly identified even if DB has old values
                if (typeof window.classifyUrlForRankingAi === 'function') {
                  let reclassifiedCount = 0;
                  combinedRows.forEach(row => {
                    const bestUrl = row.best_url || row.bestUrl || null;
                    if (bestUrl) {
                      const oldPageType = row.pageType || 'Landing';
                      const classification = window.classifyUrlForRankingAi(bestUrl, row.keyword || null);
                      const newPageType = classification.pageType;
                      if (newPageType !== oldPageType) {
                        row.pageType = newPageType;
                        // Also update segment if it changed
                        if (classification.segment && classification.segment !== row.segment) {
                          row.segment = classification.segment;
                        }
                        reclassifiedCount++;
                      }
                    }
                  });
                  if (reclassifiedCount > 0) {
                    debugLog(` Re-classified pageType for ${reclassifiedCount} keywords (fixed stale DB values)`, 'info');
                  }
                }
                
                const needsOpportunityScore = combinedRows.some(r => r.opportunityScore == null);
                if (needsOpportunityScore) {
                  debugLog(` Computing opportunity scores for ${keywordCount} keywords (missing from Supabase)`, 'info');
                  const maxDemandShare = combinedRows.reduce((max, r) => {
                    const ds = r.demand_share ?? 0;
                    return ds > max ? ds : max;
                  }, 0);
                  combinedRows.forEach(row => {
                    if (row.opportunityScore == null) {
                      const oppResult = computeKeywordOpportunityScore(row, maxDemandShare);
                      row.opportunityScore = oppResult.score;
                      row.oppDemandComponent = oppResult.demandComponent;
                      row.oppRankComponent = oppResult.rankComponent;
                      row.oppAiComponent = oppResult.aiComponent;
                    }
                  });
                }
                
                // Normalize summary field names (convert snake_case to camelCase for compatibility)
                const normalizedSummary = normalizeSummaryFields(json.data.rankingAiData.summary);
                
                // Also save to localStorage for faster access next time
                try {
                  localStorage.setItem('rankingAiData', JSON.stringify({
                    combinedRows: combinedRows,
                    summary: normalizedSummary,
                    timestamp: new Date().toISOString()
                  }));
                  debugLog(` Saved ${keywordCount} keywords to localStorage`, 'success');
                } catch (storageErr) {
                  debugLog(` Failed to save rankingAiData to localStorage: ${storageErr.message}`, 'warn');
                }
                // Ensure window fallback is available for citation breakdowns
                window.rankingAiData = combinedRows;
                return { combinedRows, summary: normalizedSummary };
              } else {
                debugLog(' rankingAiData exists but missing combinedRows array', 'warn');
                debugLog(`  rankingAiData keys: ${Object.keys(json.data.rankingAiData || {}).join(', ')}`, 'warn');
              }
            } else {
              debugLog(' rankingAiData is null or undefined in Supabase response', 'warn');
              debugLog(`  Available data keys: ${Object.keys(json.data || {}).join(', ')}`, 'warn');
              if (json.data.rankingAiData === null) {
                debugLog('  rankingAiData is explicitly null - no keyword rows found in database', 'warn');
              }
            }
          } else {
            debugLog(` API returned error status: ${json.status}`, 'warn');
            debugLog(`  Error message: ${json.message || 'unknown'}`, 'warn');
            if (json.details) {
              debugLog(`  Error details: ${typeof json.details === 'string' ? json.details : JSON.stringify(json.details)}`, 'warn');
            }
          }
        } else {
          const errorText = await response.text();
          debugLog(` Failed to load from Supabase: HTTP ${response.status}`, 'error');
          debugLog(`  Error response: ${errorText.substring(0, 200)}`, 'error');
        }
        
        // If Supabase check failed or returned no data, fall back to localStorage if available
        if (localStorageFallback) {
          debugLog(` Falling back to localStorage data (${localStorageFallback.combinedRows.length} keywords)`, 'success');
          return localStorageFallback;
        }
      } catch (err) {
        debugLog(` Error loading Ranking & AI data from storage: ${err.message}`, 'error');
        // If error occurred but we have localStorage fallback, return it
        if (localStorageFallback) {
          debugLog(` Falling back to localStorage data after error (${localStorageFallback.combinedRows.length} keywords)`, 'success');
          return localStorageFallback;
        }
      }
      return null;
    }

    // ======================
    // Ranking & AI: Fetch and combine data
    // ======================
    async function loadRankingAiData(force = false) {
      debugLog(' loadRankingAiData called with force=' + force, 'info');
      
      // Get RankingAiModule from window (it should always be there)
      const mod = window.RankingAiModule;
      if (!mod) {
        debugLog(' RankingAiModule is not defined in window', 'error');
        debugLog(' Available window properties: ' + Object.keys(window).filter(k => k.includes('Ranking') || k.includes('AI')).join(', '), 'error');
        throw new Error('RankingAiModule is not defined. Please refresh the page.');
      }
      
      debugLog(' RankingAiModule found', 'success');
      debugLog(' RankingAiModule has TRACKED_KEYWORDS: ' + (mod.TRACKED_KEYWORDS ? mod.TRACKED_KEYWORDS.length + ' keywords' : 'missing'), 'success');
      const { hasLoadedOnce, isLoading } = mod.state();

      debugLog(` State check: hasLoadedOnce=${hasLoadedOnce}, isLoading=${isLoading}, force=${force}`, 'info');

      if (isLoading) {
        debugLog(' Already loading, skipping', 'warn');
        return;
      }

      // If not forcing, try to load from storage first
      // But if force=false and hasLoadedOnce=true, still check Supabase for newer data
      if (!force) {
        const storedData = await loadRankingAiDataFromStorage(hasLoadedOnce);
        debugLog(` loadRankingAiDataFromStorage returned: ${storedData ? 'data found' : 'null'}`, 'info');
        if (storedData) {
          debugLog(` Stored data has combinedRows: ${!!storedData.combinedRows}, count: ${storedData.combinedRows?.length || 0}`, 'info');
          debugLog(` Stored data has summary: ${!!storedData.summary}`, 'info');
        }
        
        if (storedData && storedData.combinedRows && storedData.summary) {
          debugLog(` Setting data in RankingAiModule: ${storedData.combinedRows.length} keywords`, 'success');
          // Normalize summary field names before setting
          const normalizedSummary = normalizeSummaryFields(storedData.summary);
          mod.setData(storedData.combinedRows, normalizedSummary);
          mod.setLoadedOnce(true);
          debugLog(` Calling renderRankingAiTab()`, 'info');
          renderRankingAiTab();
          const lastRunEl = document.getElementById("ranking-ai-last-run");
          if (lastRunEl && storedData.timestamp) {
            const date = new Date(storedData.timestamp);
            // Format in GMT/UTC: "DD MMM YYYY, HH:MM:SS GMT"
            const day = String(date.getUTCDate()).padStart(2, '0');
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const month = monthNames[date.getUTCMonth()];
            const year = date.getUTCFullYear();
            const hours = String(date.getUTCHours()).padStart(2, '0');
            const minutes = String(date.getUTCMinutes()).padStart(2, '0');
            const seconds = String(date.getUTCSeconds()).padStart(2, '0');
            const formatted = `${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
            lastRunEl.textContent = `Last run: ${formatted}`;
            debugLog(` Updated last run timestamp: ${formatted}`, 'info');
          }
          debugLog(` Ranking & AI data loaded from storage (${storedData.combinedRows.length} keywords)`, 'success');
          return;
        } else {
          debugLog(` Stored data incomplete or missing`, 'warn');
          if (storedData) {
            debugLog(`  Missing combinedRows: ${!storedData.combinedRows}`, 'warn');
            debugLog(`  Missing summary: ${!storedData.summary}`, 'warn');
          }
        }
      }
      
      if (hasLoadedOnce && !force) {
        debugLog(' Already loaded once and force=false, skipping', 'warn');
        return;
      }

      debugLog(' Starting data fetch from APIs...', 'info');
      mod.setLoading(true);
      const refreshBtn = document.getElementById("ranking-ai-refresh");
      if (refreshBtn) {
        refreshBtn.disabled = true;
        refreshBtn.textContent = "Loading";
      }

      // Show progress modal
      RankingAiProgressModal.show();
      RankingAiProgressModal.updateProgress(5, 0); // Initialize step
      RankingAiProgressModal.updateCounts('');

      // Declare variables outside try block for catch block access
      let allSerpResults = [];
      let keywords = [];
      let scanAborted = false; // Flag to track if scan should be aborted

      // Set up abort handler
      const stopBtn = document.getElementById('rankingAiProgressStop');
      if (stopBtn) {
        stopBtn.onclick = () => {
          scanAborted = true;
          stopBtn.disabled = true;
          stopBtn.textContent = 'Stopping...';
          debugLog(' Scan abort requested by user', 'warn');
          RankingAiProgressModal.updateCounts(' Scan abort requested...');
        };
      }

      try {
        // Load keywords from database instead of hardcoded list
        let keywordsFromDb = [];
        try {
          const keywordsResp = await fetch(apiUrl('/api/keywords/get'));
          if (keywordsResp.ok) {
            const keywordsData = await keywordsResp.json();
            if (keywordsData.status === 'ok' && Array.isArray(keywordsData.keywords) && keywordsData.keywords.length > 0) {
              keywordsFromDb = keywordsData.keywords;
              debugLog(` Loaded ${keywordsFromDb.length} keywords from database`, 'success');
            }
          }
        } catch (err) {
          debugLog(` Failed to load keywords from database: ${err.message}. Falling back to hardcoded list.`, 'warn');
        }
        
        // Use database keywords if available, otherwise fall back to hardcoded list
        // Filter out empty strings and ensure all keywords are valid
        const rawKeywords = keywordsFromDb.length > 0 ? keywordsFromDb : mod.TRACKED_KEYWORDS;
        keywords = rawKeywords
          .filter(kw => kw && typeof kw === 'string' && kw.trim().length > 0)
          .map(kw => kw.trim());
        
        const BATCH_SIZE = 20; // Match API limit

        // Show keyword count BEFORE starting scan
        const keywordCountEl = document.getElementById('rankingAiKeywordCount');
        const keywordCountValueEl = document.getElementById('rankingAiKeywordCountValue');
        if (keywordCountEl && keywordCountValueEl) {
          keywordCountValueEl.textContent = `${keywords.length} keyword${keywords.length !== 1 ? 's' : ''}`;
          keywordCountEl.style.display = 'block';
          RankingAiProgressModal.updateCounts(`Ready to scan ${keywords.length} keywords. Click "Start Scan" to begin.`);
        }

        // Wait for user confirmation before starting (show count for 2 seconds, then auto-start)
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Check if aborted during wait
        if (scanAborted) {
          throw new Error('Scan aborted by user');
        }

        // Hide keyword count and show stop button
        if (keywordCountEl) keywordCountEl.style.display = 'none';
        if (stopBtn) {
          stopBtn.style.display = 'block';
          stopBtn.disabled = false;
        }

        debugLog(` Fetching ranking & AI data for ${keywords.length} keywords`, 'info');
        debugLog(` Keywords: ${keywords.slice(0, 5).join(', ')}${keywords.length > 5 ? '... (+' + (keywords.length - 5) + ' more)' : ''}`, 'info');
        debugLog(` SERP endpoint: ${mod.SERP_RANK_ENDPOINT}`, 'info');
        debugLog(` AI endpoint: ${mod.AI_MODE_ENDPOINT}`, 'info');

        // Step 1: Fetch SERP Rankings (batched if needed) with incremental saving
        RankingAiProgressModal.updateProgress(15, 1);
        RankingAiProgressModal.updateCounts(`Processing ${keywords.length} keywords...`);
        RankingAiProgressModal.setActiveStep(1);
        
        debugLog(' Starting SERP fetch with incremental saving...', 'info');
        
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        const auditDate = new Date().toISOString().split('T')[0];
        
        // Batch keywords if needed
        allSerpResults = [];
        const batches = [];
        for (let i = 0; i < keywords.length; i += BATCH_SIZE) {
          batches.push(keywords.slice(i, i + BATCH_SIZE));
        }
        
        debugLog(` Processing ${batches.length} batch(es) of keywords`, 'info');
        
        // Accumulate combined rows for final summary calculation
        let allCombinedRows = [];
        
        for (let batchIdx = 0; batchIdx < batches.length; batchIdx++) {
          // Check if scan was aborted
          if (scanAborted) {
            throw new Error('Scan aborted by user');
          }
          
          const batch = batches[batchIdx];
          const queryParam = encodeURIComponent(batch.join(","));
          const progressPercent = 15 + Math.floor((batchIdx / batches.length) * 35);
          
          RankingAiProgressModal.updateProgress(progressPercent, 1);
          RankingAiProgressModal.updateCounts(`Processing batch ${batchIdx + 1}/${batches.length} (${batch.length} keywords)...`);
          
          debugLog(` Fetching batch ${batchIdx + 1}/${batches.length} (${batch.length} keywords)`, 'info');
          
          try {
            const serpRes = await fetch(`${mod.SERP_RANK_ENDPOINT}?keywords=${queryParam}`);
            debugLog(` SERP response status for batch ${batchIdx + 1}: ${serpRes.status}`, 'info');
            
            if (!serpRes.ok) {
              const errorText = await serpRes.text();
              debugLog(` SERP request failed for batch ${batchIdx + 1}: ${serpRes.status} - ${errorText}`, 'error');
              
              // If it's a timeout or server error, show warning but continue with partial results
              if (serpRes.status === 504 || serpRes.status === 500) {
                debugLog(` Batch ${batchIdx + 1} timed out or errored, continuing with remaining batches...`, 'warn');
                RankingAiProgressModal.updateCounts(` Batch ${batchIdx + 1} failed (${serpRes.status}), continuing...`);
                // Add error results for this batch
                batch.forEach(kw => {
                  allSerpResults.push({
                    keyword: kw,
                    best_rank_group: null,
                    best_rank_absolute: null,
                    best_url: null,
                    best_title: null,
                    has_ai_overview: false,
                    serp_features: { local_pack: false, featured_snippet: false, people_also_ask: false },
                    ai_overview_present_any: false,
                    local_pack_present_any: false,
                    paa_present_any: false,
                    featured_snippet_present_any: false,
                    search_volume: null,
                    error: `Batch request failed: ${serpRes.status}`
                  });
                });
                continue;
              } else {
                RankingAiProgressModal.updateCounts(`Error: ${serpRes.status}`);
                throw new Error(`SERP rank request failed: ${serpRes.status} - ${errorText}`);
              }
            }
            
            const serpJson = await serpRes.json();
            const batchResults = serpJson.per_keyword || [];
            allSerpResults.push(...batchResults);
            
            debugLog(` Batch ${batchIdx + 1} completed: ${batchResults.length} results`, 'success');
            
            // Save this batch incrementally (without AI data for now - will update later)
            // Create minimal combined rows for this batch
            const batchCombinedRows = batchResults.map(row => {
              const bestUrl = row.best_url || null;
              let classification = { segment: "Education", pageType: "Landing" };
              if (typeof window.classifyUrlForRankingAi === 'function') {
                classification = window.classifyUrlForRankingAi(bestUrl || '', row.keyword);
              }
              
              return {
                keyword: row.keyword,
                segment: classification.segment,
                pageType: classification.pageType,
                best_rank_group: row.best_rank_group,
                best_rank_absolute: row.best_rank_absolute,
                best_url: bestUrl,
                best_title: row.best_title || "",
                // Use SERP response's has_ai_overview (from DataForSEO) - AI fetch will add citation details later
                has_ai_overview: !!(row.has_ai_overview),
                ai_total_citations: 0,
                ai_alan_citations_count: 0,
                ai_alan_citations: [],
                ai_sample_citations: [],
                serp_features: row.serp_features || {
                  has_ai_overview: false,
                  has_local_pack: false,
                  has_featured_snippet: false,
                  has_people_also_ask: false
                },
                // New boolean fields for SERP feature coverage (from SERP API response)
                ai_overview_present_any: row.ai_overview_present_any === true || row.has_ai_overview === true,
                local_pack_present_any: row.local_pack_present_any === true || (row.serp_features && row.serp_features.local_pack === true),
                paa_present_any: row.paa_present_any === true || (row.serp_features && row.serp_features.people_also_ask === true),
                featured_snippet_present_any: row.featured_snippet_present_any === true || (row.serp_features && row.serp_features.featured_snippet === true),
                competitor_counts: {},
                search_volume: row.search_volume ?? null,
                demand_share: 0 // Will be recalculated after all batches
              };
            });
            
            // Save batch incrementally
            if (propertyUrl) {
              const saveResult = await saveRankingAiDataIncremental(batchCombinedRows, auditDate, propertyUrl);
              if (saveResult.success) {
                debugLog(` Batch ${batchIdx + 1} saved incrementally: ${saveResult.saved} keywords`, 'success');
                RankingAiProgressModal.updateCounts(` Batch ${batchIdx + 1} saved (${saveResult.saved} keywords)`);
              } else {
                debugLog(` Batch ${batchIdx + 1} incremental save failed: ${saveResult.error}`, 'warn');
              }
            }
            
            allCombinedRows.push(...batchCombinedRows);
          } catch (batchErr) {
            debugLog(` Error processing batch ${batchIdx + 1}: ${batchErr.message}`, 'error');
            
            // If it's a timeout, continue with remaining batches
            if (batchErr.message.includes('timeout') || batchErr.message.includes('504')) {
              debugLog(` Batch ${batchIdx + 1} timed out, continuing with remaining batches...`, 'warn');
              RankingAiProgressModal.updateCounts(` Batch ${batchIdx + 1} timed out, continuing...`);
              // Add error results for this batch
              batch.forEach(kw => {
                allSerpResults.push({
                  keyword: kw,
                  best_rank_group: null,
                  best_rank_absolute: null,
                  best_url: null,
                  best_title: null,
                  has_ai_overview: false,
                  serp_features: { local_pack: false, featured_snippet: false, people_also_ask: false },
                  ai_overview_present_any: false,
                  local_pack_present_any: false,
                  paa_present_any: false,
                  featured_snippet_present_any: false,
                  search_volume: null,
                  error: `Batch request timed out`
                });
              });
              continue;
            } else {
              throw batchErr;
            }
          }
        }
        
        RankingAiProgressModal.updateProgress(50, 1);
        RankingAiProgressModal.updateCounts(` Retrieved SERP data for ${allSerpResults.length}/${keywords.length} keywords (saved incrementally)`);
        
        // Step 2: Fetch AI Overview Data (batched to avoid server timeout)
        RankingAiProgressModal.updateProgress(55, 2);
        RankingAiProgressModal.setActiveStep(2);
        RankingAiProgressModal.updateCounts(`Checking AI Overview presence and citations...`);
        
        debugLog(' Starting AI fetch (batched)...', 'info');
        let aiRows = [];
        let aiFetchError = null;
        
        try {
          // Batch AI requests to avoid Vercel 300s timeout
          // Process 10 keywords per batch (each API call takes ~5s, so 10 keywords = ~50s per batch)
          const AI_BATCH_SIZE = 10;
          const aiBatches = [];
          for (let i = 0; i < keywords.length; i += AI_BATCH_SIZE) {
            aiBatches.push(keywords.slice(i, i + AI_BATCH_SIZE));
          }
          
          debugLog(` Processing AI data in ${aiBatches.length} batches of up to ${AI_BATCH_SIZE} keywords each`, 'info');
          
          // Process batches sequentially to avoid overwhelming the API
          for (let batchIdx = 0; batchIdx < aiBatches.length; batchIdx++) {
            // Check if scan was aborted
            if (scanAborted) {
              throw new Error('Scan aborted by user');
            }
            
            const batch = aiBatches[batchIdx];
            const batchProgress = 55 + Math.floor((batchIdx / aiBatches.length) * 20); // 55-75% progress
            
            RankingAiProgressModal.updateProgress(batchProgress, 2);
            RankingAiProgressModal.updateCounts(`Fetching AI data: batch ${batchIdx + 1}/${aiBatches.length} (${batch.length} keywords)...`);
            
            debugLog(` AI batch ${batchIdx + 1}/${aiBatches.length}: ${batch.length} keywords`, 'info');
            
            try {
              // Timeout per batch: 90 seconds (should be enough for 10 keywords)
              const aiFetchPromise = fetch(mod.AI_MODE_ENDPOINT, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ queries: batch })
              });
              
              // Increase timeout to 300 seconds (5 minutes) to match Vercel serverless function timeout
              const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error(`AI batch ${batchIdx + 1} timeout after 300 seconds`)), 300000)
              );
              
              const aiRes = await Promise.race([aiFetchPromise, timeoutPromise]);
              debugLog(` AI batch ${batchIdx + 1} response status: ${aiRes.status}`, 'info');

              if (!aiRes.ok) {
                const errorText = await aiRes.text();
                debugLog(` AI batch ${batchIdx + 1} failed: ${aiRes.status} - ${errorText}`, 'error');
                // Add empty results for this batch
                batch.forEach(keyword => {
                  aiRows.push({
                    query: keyword,
                    has_ai_overview: false,
                    total_citations: 0,
                    alanranger_citations_count: 0,
                    alanranger_citations: [],
                    sample_citations: [],
                    error: `Batch request failed: ${aiRes.status}`
                  });
                });
              } else {
                const aiJson = await aiRes.json();
                const batchResults = aiJson.per_query || [];
                aiRows.push(...batchResults);
                debugLog(` AI batch ${batchIdx + 1}: Retrieved ${batchResults.length} results`, 'success');
              }
            } catch (batchErr) {
              debugLog(` AI batch ${batchIdx + 1} error: ${batchErr.message}`, 'error');
              // Add empty results for this batch
              batch.forEach(keyword => {
                aiRows.push({
                  query: keyword,
                  has_ai_overview: false,
                  total_citations: 0,
                  alanranger_citations_count: 0,
                  alanranger_citations: [],
                  sample_citations: [],
                  error: batchErr.message
                });
              });
            }
            
            // Small delay between batches to avoid rate limiting
            if (batchIdx < aiBatches.length - 1) {
              await new Promise(resolve => setTimeout(resolve, 500));
            }
          }
          
          RankingAiProgressModal.updateProgress(75, 2);
          RankingAiProgressModal.updateCounts(` Retrieved AI Overview data for ${aiRows.length} keywords`);
          debugLog(` Retrieved ${aiRows.length} AI results total`, 'success');
          
        } catch (aiErr) {
          debugLog(` AI fetch error: ${aiErr.message}`, 'error');
          RankingAiProgressModal.updateCounts(` AI Overview check failed (${aiErr.message}), continuing with SERP data only...`);
          aiFetchError = aiErr.message;
          // Continue with empty AI data - UI will still show SERP results
        }
        
        // Step 3: Process Results and merge AI data
        RankingAiProgressModal.updateProgress(80, 3);
        RankingAiProgressModal.setActiveStep(3);
        RankingAiProgressModal.updateCounts(`Combining SERP and AI data...`);
        
        debugLog(' Parsing JSON responses...', 'info');
        debugLog(` SERP results: ${allSerpResults.length} keywords processed`, 'info');
        if (aiFetchError) {
          debugLog(` AI data unavailable: ${aiFetchError}`, 'warn');
        }

        const serpRows = allSerpResults; // Use batched results

        debugLog(`Received ${serpRows.length} SERP results and ${aiRows.length} AI results`, 'info');
        RankingAiProgressModal.updateCounts(`Processing ${serpRows.length} SERP results and ${aiRows.length} AI results...`);

        // Map AI rows by normalised query
        const aiByKeyword = {};
        aiRows.forEach(row => {
          const key = RankingAiModule.normaliseKeyword(row.query);
          aiByKeyword[key] = row;
        });

        // Update existing combined rows with AI data, or create new ones if needed
        // First, create a map of existing combined rows by keyword
        const combinedByKeyword = {};
        allCombinedRows.forEach(row => {
          const key = RankingAiModule.normaliseKeyword(row.keyword);
          combinedByKeyword[key] = row;
        });

        // First pass: classify all SERP rows and collect search volumes for demand_share calculation
        const rowsWithClassification = serpRows.map(row => {
          const key = RankingAiModule.normaliseKeyword(row.keyword);
          const aiRow = aiByKeyword[key] || null;
          const bestUrl = row.best_url || null;
          
          // Use intent-based classification (keyword text drives segment, not URL)
          const segment = RankingAiModule.classifyKeywordSegment(row.keyword, bestUrl);
          const pageType = RankingAiModule.classifyPageTypeForKeyword ? 
            RankingAiModule.classifyPageTypeForKeyword(bestUrl) : "Landing";
          const classification = { segment, pageType };
          
          return {
            ...row,
            aiRow,
            classification,
            search_volume: row.search_volume ?? null
          };
        });
        
        // Calculate total demand for demand_share
        const totalDemand = rowsWithClassification.reduce((sum, r) => {
          const vol = r.search_volume;
          return sum + (vol && vol > 0 ? vol : 0);
        }, 0);
        
        // Second pass: build combined rows with demand_share and AI data
        const combined = rowsWithClassification.map(row => {
          const key = RankingAiModule.normaliseKeyword(row.keyword);
          const aiRow = row.aiRow || null;
          const bestUrl = row.best_url || null;
          const { segment, pageType } = row.classification;

          const aiCitations = aiRow?.alanranger_citations || [];
          const aiOtherCitations = (aiRow?.sample_citations || []).filter(c => {
            const domain = (c.domain || "").toLowerCase();
            return domain && !domain.includes("alanranger.com");
          });

          // Count competitor domains
          const competitorCounts = {};
          aiOtherCitations.forEach(c => {
            const d = (c.domain || "").toLowerCase();
            if (!d) return;
            competitorCounts[d] = (competitorCounts[d] || 0) + 1;
          });

          // Calculate demand_share
          const searchVolume = row.search_volume;
          const demandShare = (searchVolume && searchVolume > 0 && totalDemand > 0) 
            ? searchVolume / totalDemand 
            : 0;

          // Debug: Log search volume for first few keywords
          if (serpRows.indexOf(row) < 3) {
            debugLog(`[DEBUG] Keyword "${row.keyword}": search_volume=${searchVolume}, demand_share=${(demandShare * 100).toFixed(1)}%, segment=${segment}, pageType=${pageType}`, 'info');
          }

          // Canonicalize URL - store both raw and canonical
          const rawTargetUrl = bestUrl || "";
          const canonicalTargetUrl = canonicalizeUrl(rawTargetUrl);
          
          return {
            keyword: row.keyword,
            segment: segment, // Keep capitalized: Brand/Money/Education/Other
            pageType,
            best_rank_group: row.best_rank_group,
            best_rank_absolute: row.best_rank_absolute,
            best_url: bestUrl, // Keep raw for backward compatibility
            rawTargetUrl: rawTargetUrl, // Explicit raw URL
            targetUrl: canonicalTargetUrl, // Canonical URL (single source of truth)
            best_title: row.best_title || "",
            // Use SERP response's has_ai_overview (from DataForSEO) as primary source,
            // fallback to AI API response if SERP doesn't have it
            has_ai_overview: !!(row.has_ai_overview || (aiRow && aiRow.has_ai_overview)),
            ai_total_citations: aiRow?.total_citations ?? 0,
            ai_alan_citations_count: aiRow?.alanranger_citations_count ?? 0,
            ai_alan_citations: aiCitations,
            ai_sample_citations: aiOtherCitations,
            serp_features: row.serp_features || {
              has_ai_overview: false,
              has_local_pack: false,
              has_featured_snippet: false,
              has_people_also_ask: false
            },
            // New boolean fields for SERP feature coverage (from SERP API response)
            ai_overview_present_any: row.ai_overview_present_any === true || row.has_ai_overview === true,
            local_pack_present_any: row.local_pack_present_any === true || (row.serp_features && row.serp_features.local_pack === true),
            paa_present_any: row.paa_present_any === true || (row.serp_features && row.serp_features.people_also_ask === true),
            featured_snippet_present_any: row.featured_snippet_present_any === true || (row.serp_features && row.serp_features.featured_snippet === true),
            competitor_counts: competitorCounts,
            search_volume: searchVolume,
            search_volume_trend: row.search_volume_trend || undefined,
            demand_share: demandShare
            // opportunityScore will be added after all rows are created (see below)
          };
        });
        
        // Compute maxDemandShare for opportunity score calculation
        const maxDemandShare = combined.reduce((max, r) => {
          const ds = r.demand_share ?? 0;
          return ds > max ? ds : max;
        }, 0);
        
        // Add opportunity score to each row
        combined.forEach(row => {
          const oppResult = computeKeywordOpportunityScore(row, maxDemandShare);
          row.opportunityScore = oppResult.score;
          row.oppDemandComponent = oppResult.demandComponent;
          row.oppRankComponent = oppResult.rankComponent;
          row.oppAiComponent = oppResult.aiComponent;
        });
        
        // Debug: Log opportunity scores for first few keywords
        if (combined.length > 0) {
          const sampleRows = combined.slice(0, 3);
          sampleRows.forEach(r => {
            console.debug(`[Opportunity Score] "${r.keyword}": score=${r.opportunityScore}, D=${(r.oppDemandComponent * 100).toFixed(0)}%, R=${(r.oppRankComponent * 100).toFixed(0)}%, A=${(r.oppAiComponent * 100).toFixed(0)}%`);
          });
        }

        // Summary metrics
        const totalKeywords = combined.length;
        const withRank = combined.filter(r => r.best_rank_group != null).length;
        const withAiOverview = combined.filter(r => r.has_ai_overview).length;
        const withAiCitation = combined.filter(r => r.ai_alan_citations_count > 0).length;
        const top10 = combined.filter(r => r.best_rank_group != null && r.best_rank_group <= 10).length;
        const top3 = combined.filter(r => r.best_rank_group != null && r.best_rank_group <= 3).length;
        // Count keywords with search volume (including 0, but not null/undefined)
        const withSearchVolume = combined.filter(r => r.search_volume != null && r.search_volume !== undefined).length;
        
        // Log search volume for each keyword
        combined.forEach(row => {
          const volume = row.search_volume != null && row.search_volume !== undefined
            ? row.search_volume.toLocaleString() 
            : 'none';
          debugLog(`Search volume for "${row.keyword}": ${volume}`, 'info');
        });
        
        debugLog(`Search volume summary: ${withSearchVolume}/${totalKeywords} keywords have search volume data`, 'info');
        RankingAiProgressModal.updateProgress(90, 3);
        RankingAiProgressModal.updateCounts(` Processed ${totalKeywords} keywords (${withRank} ranked, ${withAiOverview} with AI Overview, ${withSearchVolume} with search volume)`);

        // Calculate visibility metrics from combined results (Ranking API only - not part of AIO pillars)
        const validRankingRows = combined.filter(r => r.best_rank_group != null && typeof r.best_rank_group === 'number');
        let avgPositionUnweighted = null;
        let avgPositionVolumeWeighted = null;
        
        if (validRankingRows.length >= 1) {
          // Unweighted average position
          const sumRanks = validRankingRows.reduce((sum, k) => sum + k.best_rank_group, 0);
          avgPositionUnweighted = Math.round((sumRanks / validRankingRows.length) * 100) / 100;
          
          // Demand-weighted average position
          let sumWeightedRanks = 0;
          let sumVolumes = 0;
          
          for (const row of validRankingRows) {
            const vol = (row.search_volume !== null && row.search_volume !== undefined && row.search_volume > 0)
              ? row.search_volume
              : 10; // Fallback
            sumWeightedRanks += row.best_rank_group * vol;
            sumVolumes += vol;
          }
          
          if (sumVolumes > 0) {
            avgPositionVolumeWeighted = Math.round((sumWeightedRanks / sumVolumes) * 100) / 100;
          }
        }
        
        const summary = {
          total_keywords: totalKeywords,
          keywords_with_rank: withRank,
          keywords_with_ai_overview: withAiOverview,
          keywords_with_ai_citations: withAiCitation,
          top10,
          top3,
          // Include visibility metrics (Ranking API only - not part of AIO pillars)
          avg_position_unweighted: avgPositionUnweighted,
          avg_position_volume_weighted: avgPositionVolumeWeighted,
          keywords_used_for_avg: validRankingRows.length,
          keywords_with_volume: withSearchVolume
        };

        // Debug: Log AI citations for first few keywords
        const keywordsWithCitations = combined.filter(r => r.ai_alan_citations_count > 0);
        debugLog(` AI Citations Summary: ${keywordsWithCitations.length}/${totalKeywords} keywords have citations`, 'info');
        if (keywordsWithCitations.length > 0) {
          keywordsWithCitations.slice(0, 5).forEach(row => {
            debugLog(`   "${row.keyword}": ${row.ai_alan_citations_count} citations`, 'info');
          });
        } else {
          debugLog(`   No keywords have AI citations. AI fetch error: ${aiFetchError || 'none'}`, 'warn');
          if (aiRows.length > 0) {
            debugLog(`   AI rows received: ${aiRows.length}, checking first few...`, 'info');
            aiRows.slice(0, 3).forEach(aiRow => {
              debugLog(`    - "${aiRow.query}": alanranger_citations_count=${aiRow.alanranger_citations_count ?? 'undefined'}, total_citations=${aiRow.total_citations ?? 'undefined'}`, 'info');
            });
          }
        }

        // Normalize summary field names before setting (ensure camelCase for display)
        const normalizedSummary = normalizeSummaryFields(summary);
        mod.setData(combined, normalizedSummary);
        mod.setLoadedOnce(true);
        
        // Step 4: Save Data
        RankingAiProgressModal.updateProgress(95, 4);
        RankingAiProgressModal.setActiveStep(4);
        RankingAiProgressModal.updateCounts(`Saving to database...`);
        
        // Update incrementally saved rows with merged AI data
        if (propertyUrl && combined.length > 0) {
          debugLog(` Updating incrementally saved rows with merged AI data...`, 'info');
          const updateResult = await saveRankingAiDataIncremental(combined, auditDate, propertyUrl);
          if (updateResult.success) {
            debugLog(` Updated ${updateResult.saved} keyword rows with AI data`, 'success');
          } else {
            debugLog(` Failed to update rows with AI data: ${updateResult.error}`, 'warn');
          }
        }
        
        // Save to Supabase and localStorage
        const saveResult = await saveRankingAiData(combined, summary);
        
        if (!saveResult || !saveResult.success) {
          const errorMsg = saveResult?.error || 'Unknown error';
          debugLog(` CRITICAL: Save failed - ${errorMsg}`, 'error');
          RankingAiProgressModal.updateProgress(95, 4);
          RankingAiProgressModal.updateCounts(` Save failed: ${errorMsg.substring(0, 100)}`);
          RankingAiProgressModal.setActiveStep(4); // Keep on step 4 (Save Data)
          // Show error in summary
          RankingAiProgressModal.showSummary({
            error: true,
            errorMessage: `Failed to save data: ${errorMsg}. Please check the debug log for details.`,
            totalKeywords,
            keywordsWithRank: withRank,
            top10,
            top3,
            keywordsWithAiOverview: withAiOverview,
            keywordsWithAiCitations: withAiCitation,
            avgPositionUnweighted: summary.avg_position_unweighted,
            avgPositionVolumeWeighted: summary.avg_position_volume_weighted,
            keywordsWithVolume: summary.keywords_with_volume,
            aiFetchError: aiFetchError || null
          });
          return; // Stop here - don't mark as complete
        }
        
        // CRITICAL: Fetch and save queryTotals for all ranking keywords
        RankingAiProgressModal.updateProgress(96, 4);
        RankingAiProgressModal.updateCounts(`Fetching GSC query totals for ${combined.length} keywords...`);
        debugLog(` Fetching queryTotals for ${combined.length} ranking keywords...`, 'info');
        
        try {
          const allKeywords = combined.map(r => r.keyword).filter(k => k && k.trim());
          if (allKeywords.length > 0) {
            const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
            const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28');
            
            // Fetch queryTotals from GSC API
            const keywordsParam = encodeURIComponent(JSON.stringify(allKeywords));
            const propertyParam = encodeURIComponent(propertyUrl);
            const gscResponse = await fetch(apiUrl(`/api/aigeo/gsc-entity-metrics?property=${propertyParam}&keywords=${keywordsParam}&days=${dateRange}`));
            
            if (gscResponse.ok) {
              const gscData = await gscResponse.json();
              if (gscData.status === 'ok' && gscData.data && Array.isArray(gscData.data.queryTotals)) {
                const queryTotals = gscData.data.queryTotals;
                debugLog(` Fetched queryTotals for ${queryTotals.length} keywords from GSC`, 'success');
                
                // Load existing audit data
                const savedAudit = loadAuditResultsSync();
                if (savedAudit && savedAudit.searchData) {
                  // Merge queryTotals into searchData
                  savedAudit.searchData.queryTotals = queryTotals;
                  
                  // CRITICAL: Use the SAME audit_date as the existing audit, not today's date
                  // This ensures queryTotals are saved to the same audit record
                  let auditDate = new Date().toISOString().split('T')[0]; // Fallback to today
                  if (savedAudit.timestamp) {
                    try {
                      auditDate = new Date(savedAudit.timestamp).toISOString().split('T')[0];
                      debugLog(` Using existing audit date for queryTotals: ${auditDate}`, 'info');
                    } catch (e) {
                      debugLog(` Failed to parse saved audit timestamp, using today's date`, 'warn');
                    }
                  }
                  
                  // Save to Supabase
                  const saveResponse = await fetch(apiUrl('/api/supabase/save-audit'), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      propertyUrl: propertyUrl,
                      auditDate: auditDate,
                      searchData: savedAudit.searchData // Include updated searchData with queryTotals
                    })
                  });
                  
                  if (saveResponse.ok) {
                    debugLog(` Saved queryTotals to Supabase (${queryTotals.length} keywords) for audit_date: ${auditDate}`, 'success');
                    
                    // CRITICAL: Also update localStorage so loadAuditResultsSync() can find the data
                    try {
                      safeSetLocalStorage('last_audit_results', savedAudit);
                      debugLog(` Updated localStorage with queryTotals`, 'success');
                    } catch (localStorageErr) {
                      debugLog(` Failed to update localStorage: ${localStorageErr.message}`, 'warn');
                    }
                    
                    // Update audit date pill to reflect new scan
                    updateAuditTimestamp(new Date().toISOString());
                  } else {
                    const errorText = await saveResponse.text();
                    debugLog(` Failed to save queryTotals to Supabase: ${saveResponse.status} - ${errorText}`, 'warn');
                  }
                } else {
                  debugLog(` No existing audit data found, creating new audit record with queryTotals...`, 'warn');
                  // Create new audit record with queryTotals
                  const auditDate = new Date().toISOString().split('T')[0];
                  const saveResponse = await fetch(apiUrl('/api/supabase/save-audit'), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      propertyUrl: propertyUrl,
                      auditDate: auditDate,
                      searchData: { queryTotals: queryTotals }
                    })
                  });
                  
                  if (saveResponse.ok) {
                    debugLog(` Created new audit record with queryTotals (${queryTotals.length} keywords)`, 'success');
                    
                    // CRITICAL: Also save to localStorage so loadAuditResultsSync() can find the data
                    try {
                      const newAuditData = {
                        searchData: { queryTotals: queryTotals },
                        timestamp: new Date().toISOString(),
                        propertyUrl: propertyUrl
                      };
                      safeSetLocalStorage('last_audit_results', newAuditData);
                      debugLog(` Saved new audit record to localStorage with queryTotals`, 'success');
                    } catch (localStorageErr) {
                      debugLog(` Failed to save to localStorage: ${localStorageErr.message}`, 'warn');
                    }
                    
                    updateAuditTimestamp(new Date().toISOString());
                  } else {
                    const errorText = await saveResponse.text();
                    debugLog(` Failed to create audit record with queryTotals: ${saveResponse.status} - ${errorText}`, 'warn');
                  }
                }
              } else {
                debugLog(` GSC API did not return queryTotals data`, 'warn');
              }
            } else {
              const errorText = await gscResponse.text();
              debugLog(` Failed to fetch queryTotals from GSC: ${gscResponse.status} - ${errorText}`, 'warn');
            }
          } else {
            debugLog(` No keywords to fetch queryTotals for`, 'warn');
          }
        } catch (queryTotalsErr) {
          debugLog(` Error fetching/saving queryTotals: ${queryTotalsErr.message}`, 'error');
          // Don't fail the entire scan if queryTotals fetch fails
        }
        
        RankingAiProgressModal.updateProgress(98, 4);
        RankingAiProgressModal.updateCounts(` Data saved successfully`);
        
        // Step 5: Complete (only reached if save succeeded)
        RankingAiProgressModal.updateProgress(100, 5);
        RankingAiProgressModal.setActiveStep(5, true); // Mark as complete (green) not active (amber)
        
        // Show completion summary
        RankingAiProgressModal.showSummary({
          totalKeywords,
          keywordsWithRank: withRank,
          top10,
          top3,
          keywordsWithAiOverview: withAiOverview,
          keywordsWithAiCitations: withAiCitation,
          avgPositionUnweighted: summary.avg_position_unweighted,
          avgPositionVolumeWeighted: summary.avg_position_volume_weighted,
          keywordsWithVolume: summary.keywords_with_volume,
          aiFetchError: aiFetchError || null
        });
        
        RankingAiProgressModal.updateCounts(` Scan completed successfully!`);
        
        renderRankingAiTab();

        const lastRunEl = document.getElementById("ranking-ai-last-run");
        if (lastRunEl) {
          const now = new Date();
          // Format in GMT/UTC: "DD MMM YYYY, HH:MM:SS GMT"
          const day = String(now.getUTCDate()).padStart(2, '0');
          const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          const month = monthNames[now.getUTCMonth()];
          const year = now.getUTCFullYear();
          const hours = String(now.getUTCHours()).padStart(2, '0');
          const minutes = String(now.getUTCMinutes()).padStart(2, '0');
          const seconds = String(now.getUTCSeconds()).padStart(2, '0');
          const formatted = `${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
          lastRunEl.textContent = `Last run: ${formatted}`;
        }
        debugLog(` Ranking & AI data loaded: ${totalKeywords} keywords, ${withRank} with ranks, ${withAiOverview} with AI Overview`, 'success');
        
        // Prompt to update all optimisation tasks with the new data
        // Only prompt if admin key is set and we're not in share mode
        if (typeof window.hasAdminKey === 'function' && window.hasAdminKey() && !window.isShareMode) {
          // Small delay to let the modal render first
          setTimeout(async () => {
            const shouldUpdate = confirm(
              'Ranking & AI scan completed successfully!\n\n' +
              'Would you like to update all optimisation tasks with the latest data?\n\n' +
              'This will create a new measurement for each active task using the ranking and AI data you just collected.'
            );
            
            if (shouldUpdate && typeof window.bulkUpdateAllTasks === 'function') {
              try {
                debugLog('[Ranking & AI] User requested task update after scan completion', 'info');
                await window.bulkUpdateAllTasks(true); // Skip confirmation since user already confirmed
                debugLog('[Ranking & AI] Task update completed successfully', 'success');
              } catch (updateErr) {
                debugLog(`[Ranking & AI] Task update failed: ${updateErr.message}`, 'error');
                alert(`Failed to update tasks: ${updateErr.message}`);
              }
            }
          }, 1000); // 1 second delay to let modal render
        }
        
        // Don't hide modal - keep it visible with summary
      } catch (err) {
        console.error("Ranking & AI load error", err);
        const errorMsg = scanAborted ? 'Scan aborted by user' : err.message;
        debugLog(` Ranking & AI load error: ${errorMsg}`, 'error');
        
        // If aborted, show specific message
        if (scanAborted) {
          RankingAiProgressModal.updateCounts(' Scan aborted by user');
          RankingAiProgressModal.showSummary({
            error: true,
            errorMessage: 'Scan was aborted by user. No data was saved.',
            totalKeywords: keywords?.length || 0
          });
          return;
        }
        
        // Try to load any saved data from Supabase (SERP data may have been saved incrementally)
        debugLog(' Attempting to load saved data from Supabase after error...', 'info');
        try {
          const savedData = await loadRankingAiDataFromStorage(true); // Force Supabase check
          if (savedData && savedData.combinedRows && savedData.combinedRows.length > 0) {
            debugLog(` Loaded ${savedData.combinedRows.length} keywords from Supabase after error`, 'success');
            const normalizedSummary = normalizeSummaryFields(savedData.summary);
            mod.setData(savedData.combinedRows, normalizedSummary);
            mod.setLoadedOnce(true);
            renderRankingAiTab();
            RankingAiProgressModal.updateProgress(100, 5);
            RankingAiProgressModal.setActiveStep(5);
            RankingAiProgressModal.showSummary({
              error: true,
              errorMessage: `Scan encountered an error, but loaded ${savedData.combinedRows.length} saved keywords from database: ${err.message}`,
              totalKeywords: savedData.combinedRows.length,
              keywordsWithRank: savedData.summary?.keywords_with_rank || 0,
              top10: savedData.summary?.top10 || 0,
              top3: savedData.summary?.top3 || 0,
              keywordsWithAiOverview: savedData.summary?.keywords_with_ai_overview || 0,
              keywordsWithAiCitations: savedData.summary?.keywords_with_ai_citations || 0
            });
            RankingAiProgressModal.updateCounts(` Error occurred, but loaded saved data from database`);
            return; // Exit early since we loaded saved data
          }
        } catch (loadErr) {
          debugLog(` Failed to load saved data: ${loadErr.message}`, 'error');
        }
        
        const lastRunEl = document.getElementById("ranking-ai-last-run");
        if (lastRunEl) {
          lastRunEl.textContent = "Error loading ranking & AI data. See console for details.";
        }
        
        // Show error summary in modal instead of hiding
        RankingAiProgressModal.updateProgress(100, 5);
        RankingAiProgressModal.setActiveStep(5);
        RankingAiProgressModal.showSummary({
          error: true,
          errorMessage: err.message,
          totalKeywords: keywords?.length || 0,
          keywordsWithRank: allSerpResults?.filter(r => r.best_rank_group != null).length || 0
        });
        RankingAiProgressModal.updateCounts(` Error: ${err.message}`);
      } finally {
        RankingAiModule.setLoading(false);
        const refreshBtn = document.getElementById("ranking-ai-refresh");
        if (refreshBtn) {
          refreshBtn.disabled = false;
          refreshBtn.textContent = "Run ranking & AI check";
        }
        
        // Enable close button
        const closeBtn = document.getElementById('rankingAiProgressClose');
        if (closeBtn) {
          closeBtn.disabled = false;
          closeBtn.style.opacity = '1';
          closeBtn.onclick = () => RankingAiProgressModal.hide();
        }
      }
    }
    
    // Make loadRankingAiData globally available
    window.loadRankingAiData = loadRankingAiData;

    // ======================
    // Ranking & AI: Rendering functions
    // ======================
    // Filter and sort state
    let rankingFilterState = {
      segment: 'all',
      rank: 'all',
      volume: 'all',
      ctr: 'all',
      opportunity: 'all',
      aiOverview: 'all',
      aiCitation: 'all',
      pageType: 'all',
      serpFeatures: 'all',
      optimisationStatus: 'all',
      keyword: '',
      minOpportunity: null // number | null
    };
    let rankingSortState = {
      column: 'opportunityScore', // Default sort by opportunity score (descending)
      direction: 'desc'
    };
    let rankingPaginationState = {
      currentPage: 1,
      rowsPerPage: 10  // Default to 10 rows so all show without scrolling
    };
    let rankingPriorityFilter = null; // { impact: 'high'|'medium'|'low', difficulty: 'high'|'medium'|'low' } | null
    let selectedKeywordId = null; // Store selected keyword identifier (keyword + url combination)
    let activePreset = null; // Track which preset is currently active ('all', 'high-impact-money', etc.)

    // Impact and Difficulty bucket thresholds (constants for tuning)
    const IMPACT_THRESHOLDS = {
      HIGH: 0.20,   // >= 20% of tracked demand
      MEDIUM: 0.10  // 10-19.99% of tracked demand
    };
    const DIFFICULTY_THRESHOLDS = {
      LOW: { min: 4, max: 15 },      // Easy win: rank 4-15
      MEDIUM: { min: 16, max: 30 }   // Medium: rank 16-30
    };

    /**
     * Calculate impact bucket for a keyword based on demand_share
     * @param {number} demandShare - Fraction (0-1) of total demand
     * @returns {'high'|'medium'|'low'}
     */
    /**
     * Compute Keyword Opportunity Score (0-100) with component breakdown
     * @param {Object} row - Keyword row with demand_share, best_rank_group, has_ai_overview, etc.
     * @param {number} maxDemandShare - Maximum demand_share across all keywords (0-1)
     * @returns {Object} { score: 0-100, demandComponent: 0-1, rankComponent: 0-1, aiComponent: 0-1 }
     */
    function computeKeywordOpportunityScore(row, maxDemandShare) {
      // 2.1 Demand component D (0-1)
      const demandShare = (row.demand_share ?? 0) * 100; // Convert to 0-100 if stored as 0-1
      const maxShare = (maxDemandShare ?? 0) * 100; // Convert to 0-100 if stored as 0-1
      
      let D = 0;
      if (maxShare > 0) {
        D = demandShare / maxShare; // relative to biggest keyword
      }
      D = Math.min(Math.max(D, 0), 1);

      // 2.2 Rank component R (0-1)
      const rank = row.best_rank_group ?? row.best_rank_absolute ?? null;
      let R;
      
      if (rank == null) {
        R = 0.2;          // effectively not ranked
      } else if (rank <= 3) {
        R = 0.2;          // already very strong; little upside
      } else if (rank <= 10) {
        R = 1.0;          // page 1 but not top 3: sweet spot
      } else if (rank <= 20) {
        R = 0.8;          // page 2
      } else if (rank <= 50) {
        R = 0.5;          // visible but weaker
      } else {
        R = 0.2;          // very weak
      }

      // 2.3 AI leverage component A (0-1)
      const hasAi = row.has_ai_overview === true;
      const total = row.ai_total_citations ?? row.ai_citations_total ?? 0;
      const ours = row.ai_alan_citations_count ?? row.ai_citations_from_alan ?? 0;
      
      let A;
      
      if (!hasAi) {
        A = 0.5; // neutral: AI not helping or hurting yet
      } else if (!total) {
        A = 0.5; // overview present, but no citation info
      } else {
        const share = ours / total; // 0-1
        
        if (share < 0.33) {
          A = 1.0; // overview exists, you're under-represented
        } else if (share <= 0.66) {
          A = 0.7; // present but not owning it
        } else {
          A = 0.4; // you already dominate AI answers
        }
      }

      // 2.4 Combined score S (0-100)
      const opportunity0to1 =
        0.5 * D +   // demand is main driver
        0.3 * R +   // room to move in classic rank
        0.2 * A;    // AI leverage

      const keywordOpportunityScore = Math.round(opportunity0to1 * 100);

      return {
        score: keywordOpportunityScore,
        demandComponent: D,
        rankComponent: R,
        aiComponent: A
      };
    }

    function calculateImpactBucket(demandShare) {
      if (demandShare >= IMPACT_THRESHOLDS.HIGH) return 'high';
      if (demandShare >= IMPACT_THRESHOLDS.MEDIUM) return 'medium';
      return 'low';
    }

    /**
     * Calculate difficulty bucket for a keyword based on best_rank_group
     * @param {number|null} bestRankGroup - Best rank group (position)
     * @returns {'low'|'medium'|'high'}
     */
    function calculateDifficultyBucket(bestRankGroup) {
      // If already ranking in top 3, treat as low difficulty (already winning)
      if (bestRankGroup != null && bestRankGroup >= 1 && bestRankGroup <= 3) {
        return 'low';
      }
      
      // Low difficulty: rank 4-15 (easy win)
      if (bestRankGroup != null && 
          bestRankGroup >= DIFFICULTY_THRESHOLDS.LOW.min && 
          bestRankGroup <= DIFFICULTY_THRESHOLDS.LOW.max) {
        return 'low';
      }
      
      // Medium difficulty: rank 16-30
      if (bestRankGroup != null && 
          bestRankGroup >= DIFFICULTY_THRESHOLDS.MEDIUM.min && 
          bestRankGroup <= DIFFICULTY_THRESHOLDS.MEDIUM.max) {
        return 'medium';
      }
      
      // High difficulty: rank > 30 or null (no rank)
      return 'high';
    }

    /**
     * Build comprehensive scorecard data for a keyword row
     * @param {Object} row - Keyword row from combinedRows
     * @returns {Object} Enriched scorecard data
     */
    function buildKeywordScorecardData(row) {
      if (!row) return null;

      // Demand level from search_volume
      const searchVolume = row.search_volume;
      let demandLevel = 'Low';
      if (searchVolume != null && searchVolume >= 500) {
        demandLevel = 'High';
      } else if (searchVolume != null && searchVolume >= 200) {
        demandLevel = 'Medium';
      }

      // Rank bucket
      const rank = row.best_rank_group;
      let rankBucket = 'page2plus';
      let rankBucketLabel = 'beyond page 2';
      let positionStrength = 'Weak';
      if (rank != null) {
        if (rank >= 1 && rank <= 3) {
          rankBucket = 'top3';
          rankBucketLabel = 'page 1';
          positionStrength = 'Strong';
        } else if (rank >= 4 && rank <= 10) {
          rankBucket = 'top10';
          rankBucketLabel = 'page 1';
          positionStrength = 'OK';
        } else if (rank > 10) {
          rankBucket = 'page2plus';
          rankBucketLabel = 'beyond page 2';
          positionStrength = 'Weak';
        }
      }

      // AI status bucket
      const hasAiOverview = row.has_ai_overview || false;
      const aiCitationsOurs = row.ai_alan_citations_count || 0;
      const aiCitationsTotal = row.ai_total_citations || 0;
      let aiStatus = 'no_ai';
      let aiStatusLabel = 'No AI Overview';
      if (hasAiOverview) {
        if (aiCitationsOurs === 0) {
          aiStatus = 'ai_no_citation';
          aiStatusLabel = 'AI Overview present, not cited';
        } else {
          const ourShare = aiCitationsTotal > 0 ? (aiCitationsOurs / aiCitationsTotal) : 0;
          if (ourShare >= 0.25) {
            aiStatus = 'ai_cited_strong';
            aiStatusLabel = `AI Overview present, cited in ${aiCitationsOurs}/${aiCitationsTotal} citations (strong)`;
          } else {
            aiStatus = 'ai_cited_light';
            aiStatusLabel = `AI Overview present, cited in ${aiCitationsOurs}/${aiCitationsTotal} citations (light)`;
          }
        }
      }

      // Impact, Difficulty, and Priority from opportunity score components
      // Use opportunity score components if available, otherwise fall back to old logic
      let impact, difficulty, priorityLevel;
      
      if (row.opportunityScore != null && row.oppDemandComponent != null && row.oppRankComponent != null && row.oppAiComponent != null) {
        // Use opportunity score components (new logic)
        // Impact raw: 0.7 * D + 0.3 * A
        const impactRaw = 0.7 * row.oppDemandComponent + 0.3 * row.oppAiComponent;
        if (impactRaw >= 0.66) impact = 'high';
        else if (impactRaw >= 0.33) impact = 'medium';
        else impact = 'low';
        
        // Difficulty raw: 1 - R (harder if there is less room to move)
        const difficultyRaw = 1 - row.oppRankComponent;
        if (difficultyRaw <= 0.33) difficulty = 'low';
        else if (difficultyRaw <= 0.66) difficulty = 'medium';
        else difficulty = 'high';
        
        // Priority from numeric opportunity score
        if (row.opportunityScore >= 70) priorityLevel = 'High';
        else if (row.opportunityScore >= 40) priorityLevel = 'Medium';
        else priorityLevel = 'Low';
      } else {
        // Fallback to old logic if opportunity score not available
        impact = calculateImpactBucket(row.demand_share || 0);
        difficulty = calculateDifficultyBucket(rank);
        
        // Priority level from Impact + Difficulty
        priorityLevel = 'Low';
        if (impact === 'high' && (difficulty === 'low' || difficulty === 'medium')) {
          priorityLevel = 'High';
        } else if (impact === 'high' && difficulty === 'high' || 
                   impact === 'medium' && (difficulty === 'low' || difficulty === 'medium')) {
          priorityLevel = 'Medium';
        }
      }

      return {
        // Raw data
        keyword: row.keyword,
        segment: row.segment,
        best_rank_group: rank,
        search_volume: searchVolume,
        demand_share: row.demand_share || 0,
        has_ai_overview: hasAiOverview,
        ai_citations_total: aiCitationsTotal,
        ai_citations_ours: aiCitationsOurs,
        ai_alan_citations: row.ai_alan_citations || [], // Store citations for display
        serp_features: row.serp_features || {},
        // SERP feature boolean fields
        ai_overview_present_any: row.ai_overview_present_any === true || row.has_ai_overview === true,
        local_pack_present_any: row.local_pack_present_any === true || (row.serp_features && row.serp_features.local_pack === true),
        paa_present_any: row.paa_present_any === true || (row.serp_features && row.serp_features.people_also_ask === true),
        featured_snippet_present_any: row.featured_snippet_present_any === true || (row.serp_features && row.serp_features.featured_snippet === true),
        // Canonicalize URL - store both raw and canonical
        rawTargetUrl: row.rawTargetUrl || row.best_url || '',
        targetUrl: row.targetUrl || (row.best_url ? canonicalizeUrl(row.best_url) : ''),
        ranking_url: row.targetUrl || (row.best_url ? canonicalizeUrl(row.best_url) : ''), // Use canonical for ranking_url
        page_type: row.pageType || 'Landing',
        
        // Derived fields
        demand_level: demandLevel,
        rank_bucket: rankBucket,
        rank_bucket_label: rankBucketLabel,
        position_strength: positionStrength,
        ai_status: aiStatus,
        ai_status_label: aiStatusLabel,
        impact_bucket: impact,
        difficulty_bucket: difficulty,
        priority_level: priorityLevel,
        // Opportunity score fields
        opportunity_score: row.opportunityScore ?? null,
        opp_demand_component: row.oppDemandComponent ?? null,
        opp_rank_component: row.oppRankComponent ?? null,
        opp_ai_component: row.oppAiComponent ?? null
      };
    }

    /**
     * Generate summary sentence for keyword based on demand, rank, and AI status
     * @param {Object} scorecardData - Data from buildKeywordScorecardData
     * @returns {string} Summary sentence
     */
    function generateKeywordSummary(scorecardData) {
      const { demand_level, best_rank_group, has_ai_overview, ai_citations_ours, segment } = scorecardData;
      const parts = [];
      
      // Build summary sentence based on demand, rank, and AI status
      // Format: "[Demand level]-demand [segment] keyword currently ranking #[rank] and [AI status]. [Win assessment]."
      
      // Demand level prefix
      const demandPrefix = demand_level === 'High' ? 'High-demand' : 
                          demand_level === 'Medium' ? 'Medium-demand' : 
                          'Low-demand';
      
      // Segment context
      const segmentContext = segment && segment.toLowerCase() === 'education' ? 'education ' :
                            segment && segment.toLowerCase() === 'money' ? 'commercial ' : '';
      
      // Rank description
      if (best_rank_group != null && best_rank_group <= 10) {
        parts.push(`${demandPrefix} ${segmentContext}keyword currently ranking #${best_rank_group}`);
        
        // AI Overview status
        if (has_ai_overview && ai_citations_ours > 0) {
          parts.push('and cited in AI Overviews.');
        } else if (has_ai_overview) {
          parts.push('with AI Overview present but not cited.');
        } else {
          parts.push('but not yet cited in AI Overviews.');
        }
        
        // Win assessment for page 1 keywords
        if (demand_level === 'High' && has_ai_overview && ai_citations_ours > 0) {
          parts.push('Good win if you can improve CTR and schema.');
        } else if (demand_level === 'High') {
          parts.push('Good win potential if you can improve CTR, schema, and AI citations.');
        }
      } else {
        // Page 2+ keywords
        if (demand_level === 'High') {
          parts.push(`${demandPrefix} ${segmentContext}keyword currently on page 2+; big upside if you move into page 1.`);
        } else {
          parts.push(`${demandPrefix} ${segmentContext}keyword currently on page 2+; opportunity to improve ranking.`);
        }
        
        // Add AI status for page 2+ if present
        if (has_ai_overview && ai_citations_ours > 0) {
          parts.push('Cited in AI Overviews.');
        }
      }
      
      return parts.join(' ');
    }

    /**
     * Generate action bullets based on scorecard data (always returns 3 bullets)
     * @param {Object} scorecardData - Data from buildKeywordScorecardData
     * @returns {Array<string>} Array of exactly 3 action bullet strings
     */
    function generateActionBullets(scorecardData) {
      const { demand_level, rank_bucket, ai_status, segment, page_type, position_strength } = scorecardData;
      const standardActions = [];
      
      // Bullet 1: Classic ranking & CTR
      if (demand_level === 'High' && rank_bucket !== 'top3') {
        standardActions.push('Improve title and meta description for this page to win more clicks for this high-demand term.');
      } else if (position_strength === 'Weak') {
        standardActions.push('Improve title and meta description to improve CTR and push this page into top 10.');
      } else {
        standardActions.push('Continue optimizing title and meta description to maintain strong CTR for this keyword.');
      }
      
      // Bullet 2: AI usage / authority
      if (ai_status === 'ai_no_citation') {
        standardActions.push('Strengthen on-page answer content and schema so AI can confidently cite this page in AI Overviews.');
      } else if (ai_status === 'ai_cited_strong' || ai_status === 'ai_cited_light') {
        if (rank_bucket === 'page1' || rank_bucket === 'page2plus') {
          standardActions.push('You\'re already cited in AI Overviews  improve classic ranking (links and snippet) to capture more traffic.');
        } else {
          standardActions.push('You\'re already cited in AI Overviews  maintain strong ranking and authority signals.');
        }
      } else {
        standardActions.push('No AI Overview yet  improve content depth and schema to increase chances of AI citation.');
      }
      
      // Bullet 3: Commercialisation / internal links
      if (segment && segment.toLowerCase() === 'education' && page_type === 'Landing') {
        standardActions.push('Consider adding stronger calls-to-action and internal links from money pages to capture more commercial value from this educational query.');
      } else if (segment && segment.toLowerCase() === 'money') {
        standardActions.push('Strengthen internal links from high-authority pages and optimize conversion elements on this money page.');
      } else {
        standardActions.push('Consider internal linking strategy to boost authority and capture related commercial queries.');
      }
      
      return standardActions;
    }

    /**
     * Normalize page URL for GSC matching - strips query params, fragments, ensures canonical format
     * @param {string} url - URL to normalize
     * @returns {string} Normalized URL path
     */
    function normalizeGscPageUrl(url) {
      if (!url || typeof url !== 'string') return '';
      
      let cleanUrl = url.trim();
      
      // Strip query parameters (srsltid, utm_*, gclid, fbclid, etc.) and fragments
      cleanUrl = cleanUrl.split('?')[0].split('#')[0];
      
      try {
        // Handle relative URLs by adding base URL
        let urlToParse = cleanUrl;
        if (!cleanUrl.startsWith('http://') && !cleanUrl.startsWith('https://')) {
          urlToParse = 'https://www.alanranger.com' + (cleanUrl.startsWith('/') ? cleanUrl : '/' + cleanUrl);
        }
        const urlObj = new URL(urlToParse);
        // Use pathname (automatically excludes query params and hash)
        let normalized = urlObj.pathname.toLowerCase().replace(/\/$/, '').trim();
        // If pathname is empty or just '/', treat as homepage
        if (!normalized || normalized === '/') {
          normalized = '/';
        }
        return normalized;
      } catch (e) {
        // If URL parsing fails, use manually cleaned URL
        return cleanUrl.toLowerCase().replace(/\/$/, '').trim() || '/';
      }
    }

    /**
     * Get GSC metrics for a keyword row - unified helper for table and scorecard
     * Returns atomic bundle with clicks, impressions, CTR (decimal), scope, and normalized page URL
     * @param {Object} params - Object with query (keyword) and pageUrl
     * @returns {Object} { clicks, impressions, ctrDecimal, scope, pageUsed } or null if no data
     *   - scope: 'query+page' | 'query-only' | 'page-only' | 'none'
     *   - ctrDecimal: 0-1 (decimal format, e.g., 0.0117 for 1.17%)
     *   - impressions: must be > 0 for CTR to be valid
     */
    function getGscMetricsForKeywordRow(params) {
      try {
        const { query, pageUrl } = params || {};
        if (!query) {
          return null;
        }

        // Get audit data from localStorage
        const savedAudit = loadAuditResultsSync();
        if (!savedAudit?.searchData?.queryPages) {
          return null;
        }

        const queryPages = savedAudit.searchData.queryPages || [];
        if (!Array.isArray(queryPages) || queryPages.length === 0) {
          return null;
        }

        // Normalize keyword for matching
        const normalizedKeyword = (query || '').toLowerCase().trim();
        if (!normalizedKeyword) {
          return null;
        }

        // Normalize page URL (strip query params, fragments, ensure canonical format)
        const normalizedPageUrl = pageUrl ? normalizeGscPageUrl(pageUrl) : null;

        // First try: exact match on keyword + URL (query+page scope)
        if (normalizedPageUrl) {
          const exactMatches = queryPages.filter(p => {
            const pKeyword = (p.query || '').toLowerCase().trim();
            const pPage = normalizeGscPageUrl(p.page || p.url || '');
            return pKeyword === normalizedKeyword && pPage === normalizedPageUrl;
          });

          if (exactMatches.length > 0) {
            // Aggregate all matches for this query+page combination
            let totalImpressions = 0;
            let totalClicks = 0;
            exactMatches.forEach(m => {
              totalImpressions += (m.impressions || 0);
              totalClicks += (m.clicks || 0);
            });

            // Only return data if impressions > 0 (CTR requires impressions)
            if (totalImpressions > 0) {
              // CTR from GSC is stored as percentage (0-100), convert to decimal
              const ctrDecimal = totalImpressions > 0 ? (totalClicks / totalImpressions) : 0;
              return {
                clicks: totalClicks,
                impressions: totalImpressions,
                ctrDecimal: ctrDecimal,
                scope: 'query+page',
                pageUsed: normalizedPageUrl
              };
            }
          }
        }

        // Second try: match by keyword only (query-only scope)
        const keywordMatches = queryPages.filter(p => {
          const pKeyword = (p.query || '').toLowerCase().trim();
          return pKeyword === normalizedKeyword;
        });

        if (keywordMatches.length > 0) {
          let totalImpressions = 0;
          let totalClicks = 0;
          keywordMatches.forEach(m => {
            totalImpressions += (m.impressions || 0);
            totalClicks += (m.clicks || 0);
          });

          if (totalImpressions > 0) {
            const ctrDecimal = totalClicks / totalImpressions;
            return {
              clicks: totalClicks,
              impressions: totalImpressions,
              ctrDecimal: ctrDecimal,
              scope: 'query-only',
              pageUsed: null
            };
          }
        }

        // Third try: match by URL only (page-only scope)
        if (normalizedPageUrl) {
          const urlMatches = queryPages.filter(p => {
            const pPage = normalizeGscPageUrl(p.page || p.url || '');
            return pPage === normalizedPageUrl;
          });

          if (urlMatches.length > 0) {
            let totalImpressions = 0;
            let totalClicks = 0;
            urlMatches.forEach(m => {
              totalImpressions += (m.impressions || 0);
              totalClicks += (m.clicks || 0);
            });

            if (totalImpressions > 0) {
              const ctrDecimal = totalClicks / totalImpressions;
              return {
                clicks: totalClicks,
                impressions: totalImpressions,
                ctrDecimal: ctrDecimal,
                scope: 'page-only',
                pageUsed: normalizedPageUrl
              };
            }
          }
        }

        // No data found
        return null;
      } catch (err) {
        console.error('Error getting GSC metrics for keyword row:', err);
        return null;
      }
    }

    /**
     * Get CTR metrics for a keyword from GSC audit data
     * @deprecated Use getGscMetricsForKeywordRow instead for consistent behavior
     * @param {Object} key - Object with keyword and url
     * @returns {Object|null} CTR metrics or null if not found
     */
    function getCtrMetricsForKeyword(key) {
      // Use unified helper for consistency
      const metrics = getGscMetricsForKeywordRow({
        query: key.keyword,
        pageUrl: key.url
      });

      if (!metrics) {
        return null;
      }

      // Return in legacy format for backward compatibility
      return {
        ctr: metrics.ctrDecimal,
        impressions: metrics.impressions,
        clicks: metrics.clicks
      };
    }

    /**
     * Get position bucket from rank
     * @param {number|null} rank - Ranking position
     * @returns {string} Position bucket: 'top3', '4-10', '11-20', or '20+'
     */
    function getPositionBucket(rank) {
      if (rank == null) return '20+';
      if (rank <= 3) return 'top3';
      if (rank <= 10) return '4-10';
      if (rank <= 20) return '11-20';
      return '20+';
    }

    /**
     * Get expected CTR benchmark for a position bucket
     * @param {string} positionBucket - Position bucket: 'top3', '4-10', '11-20', or '20+'
     * @returns {number} Expected CTR as decimal (e.g., 0.15 for 15%)
     */
    function getCtrBenchmarkForPosition(positionBucket) {
      // Industry benchmarks for CTR by position
      const benchmarks = {
        'top3': 0.15,    // ~15% CTR for positions 1-3
        '4-10': 0.05,   // ~5% CTR for positions 4-10
        '11-20': 0.02,  // ~2% CTR for positions 11-20
        '20+': 0.01     // ~1% CTR for positions 21+
      };
      return benchmarks[positionBucket] || 0.01;
    }

    /**
     * Normalize URL by stripping query parameters, hash, and trailing slashes
     * Returns just the pathname for matching
     */
    function normalizeUrlForMatching(url) {
      if (!url || typeof url !== 'string') return '';
      
      // Explicitly strip everything from ? onwards (query parameters) and # onwards (hash)
      // This ensures URLs with Google SERP params like ?srsltid=... are matched correctly
      let cleanUrl = url.split('?')[0].split('#')[0];
      
      let normalized = cleanUrl.toLowerCase().trim();
      try {
        // Handle relative URLs by adding a base URL
        let urlToParse = normalized;
        if (!normalized.startsWith('http://') && !normalized.startsWith('https://')) {
          urlToParse = 'https://www.alanranger.com' + (normalized.startsWith('/') ? normalized : '/' + normalized);
        }
        const urlObj = new URL(urlToParse);
        // pathname automatically excludes query params and hash, but we already stripped them above
        normalized = urlObj.pathname.toLowerCase().replace(/\/$/, '').trim();
        // If pathname is empty or just '/', treat as homepage
        if (!normalized || normalized === '/') {
          normalized = '/';
        }
      } catch (e) {
        // If URL parsing fails, use the manually cleaned URL
        normalized = cleanUrl.toLowerCase().replace(/\/$/, '').trim();
        // Ensure it starts with / if it's a path
        if (normalized && !normalized.startsWith('/')) {
          normalized = '/' + normalized;
        }
        if (!normalized || normalized === '/') {
          normalized = '/';
        }
      }
      return normalized;
    }

    async function getSchemaCoverageForUrl(url) {
      try {
        // Get audit data from localStorage using loadAuditResultsSync
        let savedAudit = loadAuditResultsSync();
        if (!savedAudit) {
          debugLog('[Schema Coverage] No saved audit found in localStorage', 'warn');
          return null;
        }
        if (!savedAudit.schemaAudit || !savedAudit.schemaAudit.data) {
          debugLog('[Schema Coverage] No schemaAudit.data in saved audit', 'warn');
          return null;
        }

        let schemaData = savedAudit.schemaAudit.data;
        // Check both pages and pagesWithSchema arrays
        let pagesArray = schemaData.pages || [];
        let pagesWithSchema = schemaData.pagesWithSchema || [];
        
        // Use pages array if available (more reliable), otherwise use pagesWithSchema
        let allPages = Array.isArray(pagesArray) && pagesArray.length > 0 ? pagesArray : 
                       (Array.isArray(pagesWithSchema) && pagesWithSchema.length > 0 ? pagesWithSchema : []);
        
        // Normalize the input URL first to use for matching
        const normalizedUrl = normalizeUrlForMatching(url);
        debugLog('[Schema Coverage] Looking for normalized URL: ' + normalizedUrl + ' (original: ' + url + ')', 'info');
        
        // Try to find the page in the current array
        let pageData = allPages.find(p => {
          if (!p || !p.url) return false;
          const pNormalized = normalizeUrlForMatching(p.url);
          const exactMatch = pNormalized === normalizedUrl;
          const homepageMatch = (normalizedUrl === '/' || normalizedUrl === '') && (pNormalized === '/' || pNormalized === '');
          return exactMatch || homepageMatch;
        });
        
        const domPropertyUrl = document.getElementById('propertyUrl')?.value;
        const effectivePropertyUrl =
          domPropertyUrl ||
          savedAudit.propertyUrl ||
          localStorage.getItem('gsc_property_url') ||
          '';

        // If not found and we have a truncated array (200 items), try fetching from Supabase
        // The API truncates to 200, but the full data exists in Supabase
        if (!pageData && allPages.length === 200) {
          debugLog('[Schema Coverage] Page not found in truncated array (200 items), fetching full data from Supabase...', 'info');
          const propertyUrl = effectivePropertyUrl;
          try {
            const supabaseData = await fetchLatestAuditFromSupabase(propertyUrl);
            if (supabaseData && supabaseData.schemaAudit && supabaseData.schemaAudit.data) {
              schemaData = supabaseData.schemaAudit.data;
              pagesArray = schemaData.pages || [];
              pagesWithSchema = schemaData.pagesWithSchema || [];
              const supabasePages = Array.isArray(pagesArray) && pagesArray.length > 0 ? pagesArray : 
                                   (Array.isArray(pagesWithSchema) && pagesWithSchema.length > 0 ? pagesWithSchema : []);
              debugLog('[Schema Coverage] Loaded schema data from Supabase (' + supabasePages.length + ' pages, may still be truncated)', 'info');
              
              // Search in the Supabase data (may still be truncated, but worth trying)
              if (supabasePages.length > 0) {
                pageData = supabasePages.find(p => {
                  if (!p || !p.url) return false;
                  const pNormalized = normalizeUrlForMatching(p.url);
                  const exactMatch = pNormalized === normalizedUrl;
                  const homepageMatch = (normalizedUrl === '/' || normalizedUrl === '') && (pNormalized === '/' || pNormalized === '');
                  return exactMatch || homepageMatch;
                });
                
                if (pageData) {
                  debugLog('[Schema Coverage]  Found page in Supabase data', 'success');
                  allPages = supabasePages;
                } else if (supabasePages.length === 200) {
                  debugLog('[Schema Coverage]  Supabase data also truncated to 200 items. Querying full data from API...', 'info');
                  // Try the dedicated API endpoint that searches the full JSONB field
                  try {
                    const propertyUrl = effectivePropertyUrl;
                    const urlHelper = window.apiUrl || ((path) => {
                      const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || !window.location.hostname;
                      const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
                      const cleanPath = path.startsWith('/') ? path : `/${path}`;
                      return `${baseUrl}${cleanPath}`;
                    });
                    const apiUrl = urlHelper(`/api/supabase/get-schema-for-url?propertyUrl=${encodeURIComponent(propertyUrl)}&searchUrl=${encodeURIComponent(url)}`);
                    const apiRes = await fetch(apiUrl);
                    if (apiRes.ok) {
                      const apiData = await apiRes.json();
                      if (apiData.status === 'ok' && apiData.data) {
                        pageData = apiData.data;
                        debugLog('[Schema Coverage]  Found page in full Supabase data via API', 'success');
                      } else {
                        debugLog('[Schema Coverage] API returned: ' + (apiData.message || 'no data'), 'warn');
                      }
                    } else {
                      debugLog('[Schema Coverage] API request failed: ' + apiRes.status, 'warn');
                    }
                  } catch (apiErr) {
                    debugLog('[Schema Coverage] API request error: ' + apiErr.message, 'warn');
                  }
                }
              }
            }
          } catch (e) {
            debugLog('[Schema Coverage] Failed to fetch from Supabase: ' + e.message, 'warn');
          }
        }
        
        // If still not found, check if pagesWithSchema is just a count (not an array)
        if (!pageData && allPages.length === 0 && typeof pagesWithSchema === 'number') {
          debugLog('[Schema Coverage] pagesWithSchema is a count in localStorage, trying Supabase...', 'warn');
          const propertyUrl = effectivePropertyUrl;
          try {
            const supabaseData = await fetchLatestAuditFromSupabase(propertyUrl);
            if (supabaseData && supabaseData.schemaAudit && supabaseData.schemaAudit.data) {
              schemaData = supabaseData.schemaAudit.data;
              pagesArray = schemaData.pages || [];
              pagesWithSchema = schemaData.pagesWithSchema || [];
              const supabasePages = Array.isArray(pagesArray) && pagesArray.length > 0 ? pagesArray : 
                                   (Array.isArray(pagesWithSchema) && pagesWithSchema.length > 0 ? pagesWithSchema : []);
              debugLog('[Schema Coverage] Loaded detailed schema data from Supabase (' + supabasePages.length + ' pages)', 'info');
              // Update localStorage with the correct structure
              savedAudit.schemaAudit.data = schemaData;
              safeSetLocalStorage('last_audit_results', savedAudit);
              if (supabasePages.length > 0) {
                allPages = supabasePages;
                // Try to find the page in the newly loaded data
                pageData = allPages.find(p => {
                  if (!p || !p.url) return false;
                  const pNormalized = normalizeUrlForMatching(p.url);
                  const exactMatch = pNormalized === normalizedUrl;
                  const homepageMatch = (normalizedUrl === '/' || normalizedUrl === '') && (pNormalized === '/' || pNormalized === '');
                  return exactMatch || homepageMatch;
                });

                // If still not found and we only have a truncated 200-page array, query full JSONB via API
                if (!pageData && allPages.length === 200) {
                  debugLog('[Schema Coverage] Still not found after Supabase load (200 items). Querying full data from API...', 'info');
                  try {
                    const urlHelper = window.apiUrl || ((path) => {
                      const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || !window.location.hostname;
                      const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
                      const cleanPath = path.startsWith('/') ? path : `/${path}`;
                      return `${baseUrl}${cleanPath}`;
                    });
                    const apiUrl = urlHelper(`/api/supabase/get-schema-for-url?propertyUrl=${encodeURIComponent(propertyUrl)}&searchUrl=${encodeURIComponent(url)}`);
                    const apiRes = await fetch(apiUrl);
                    if (apiRes.ok) {
                      const apiData = await apiRes.json();
                      if (apiData.status === 'ok' && apiData.data) {
                        pageData = apiData.data;
                        debugLog('[Schema Coverage]  Found page in full Supabase data via API', 'success');
                      } else {
                        debugLog('[Schema Coverage] API returned: ' + (apiData.message || 'no data'), 'warn');
                      }
                    } else {
                      debugLog('[Schema Coverage] API request failed: ' + apiRes.status, 'warn');
                    }
                  } catch (apiErr) {
                    debugLog('[Schema Coverage] API request error: ' + apiErr.message, 'warn');
                  }
                }
              }
            }
          } catch (e) {
            debugLog('[Schema Coverage] Failed to fetch from Supabase: ' + e.message, 'warn');
          }
        }
        
        if (!Array.isArray(allPages) || allPages.length === 0) {
          debugLog('[Schema Coverage] No pages array available (length: ' + (Array.isArray(allPages) ? allPages.length : 'not array') + ')', 'warn');
          debugLog('[Schema Coverage] This usually means the schema audit hasn\'t been run yet, or the data is missing from localStorage/Supabase.', 'info');
          return null;
        }

        // If pageData wasn't found yet, search in allPages
        if (!pageData) {
          pageData = allPages.find(p => {
            if (!p || !p.url) return false;
            const pNormalized = normalizeUrlForMatching(p.url);
            
            // Exact match after normalization (both URLs stripped of query params, hash, trailing slashes)
            const exactMatch = pNormalized === normalizedUrl;
            
            // For homepage, also check if both are '/' or empty
            const homepageMatch = (normalizedUrl === '/' || normalizedUrl === '') && (pNormalized === '/' || pNormalized === '');
            
            if (exactMatch || homepageMatch) {
              debugLog('[Schema Coverage]  Exact URL match: ' + p.url + ' -> ' + pNormalized + ' (search: ' + normalizedUrl + ')', 'info');
              return true;
            }
            return false;
          });
        }

        if (!pageData) {
          // Enhanced debugging: show sample URLs and search for similar URLs
          debugLog('[Schema Coverage]  No page data found for URL: ' + url, 'warn');
          debugLog('[Schema Coverage] Normalized search URL: ' + normalizedUrl, 'warn');
          debugLog('[Schema Coverage] Total pages in array: ' + allPages.length, 'warn');
          if (allPages.length > 0) {
            debugLog('[Schema Coverage] Sample URLs in pages array (first 10):', 'warn');
            allPages.slice(0, 10).forEach((p, idx) => {
              const pNorm = normalizeUrlForMatching(p.url);
              debugLog(`  ${idx + 1}. ${p.url} -> ${pNorm}`, 'warn');
            });
            // Try to find similar URLs (contains photography-courses or courses-coventry)
            const similarUrls = allPages.filter(p => {
              const pNorm = normalizeUrlForMatching(p.url);
              return pNorm.includes('photography-courses') || 
                     pNorm.includes('courses-coventry') ||
                     normalizedUrl.includes(pNorm.split('/').pop() || '') ||
                     (pNorm.split('/').pop() || '').includes(normalizedUrl.split('/').pop() || '');
            });
            if (similarUrls.length > 0) {
              debugLog('[Schema Coverage] Found similar URLs that might match:', 'warn');
              similarUrls.forEach((p, idx) => {
                const pNorm = normalizeUrlForMatching(p.url);
                debugLog(`  ${idx + 1}. ${p.url} -> ${pNorm}`, 'warn');
              });
            }
          }
          return null;
        }
        
        if (!pageData.schemaTypes) {
          debugLog('[Schema Coverage]  Page found but no schemaTypes: ' + pageData.url, 'warn');
          return null;
        }

        // Extract schema types from array
        const schemaTypes = Array.isArray(pageData.schemaTypes) ? pageData.schemaTypes : [];
        
        // Check for specific schema types (case-insensitive)
        const typeStrings = schemaTypes.map(t => {
          if (typeof t === 'string') return t.toLowerCase();
          if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type.toLowerCase();
          return String(t).toLowerCase();
        }).filter(t => t && t !== '[object object]');
        
        return {
          hasFAQ: typeStrings.some(t => t.includes('faq') || t === 'faqpage'),
          hasHowTo: typeStrings.some(t => t.includes('howto') || t === 'howto'),
          hasEvent: typeStrings.some(t => t.includes('event') && !t.includes('product')),
          hasProduct: typeStrings.some(t => t.includes('product')),
          hasBreadcrumb: typeStrings.some(t => t.includes('breadcrumb') || t === 'breadcrumblist'),
          hasImageObject: typeStrings.some(t => t.includes('image') || t === 'imageobject'),
          schemaTypes: schemaTypes,
          url: pageData.url
        };
      } catch (err) {
        console.error('Error getting schema coverage:', err);
        return null;
      }
    }

    /**
     * Render Keyword Priority Matrix (3x3 grid: Impact  Difficulty)
     * @param {Array} filteredRows - Filtered keyword rows
     * @param {HTMLElement} container - Container element
     * @param {Function} onCellClick - Callback(filter)
     */
    function renderKeywordPriorityMatrix(filteredRows, container, onCellClick) {
      if (!filteredRows || !filteredRows.length) {
        container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b;">No keyword data available.</div>';
        return;
      }

      // Calculate impact and difficulty for each row
      const rowsWithBuckets = filteredRows.map(row => ({
        ...row,
        impact: calculateImpactBucket(row.demand_share || 0),
        difficulty: calculateDifficultyBucket(row.best_rank_group)
      }));

      // Calculate total demand share for percentages
      const totalDemandShare = filteredRows.reduce((sum, r) => {
        const share = r.demand_share || 0;
        return sum + share;
      }, 0) || 0.0001; // Avoid division by zero
      
      // Calculate total search volume for debug logging
      const totalSearchVolume = filteredRows.reduce((sum, r) => {
        const vol = r.search_volume || 0;
        return sum + (vol > 0 ? vol : 0);
      }, 0);

      const impacts = ['high', 'medium', 'low'];
      const difficulties = ['low', 'medium', 'high'];

      let html = `
        <div class="matrix-header" style="margin-bottom: 1rem;">
          <div class="axis-label impact" style="text-align: center; font-weight: 600; font-size: 1.1rem; margin-bottom: 0.5rem; color: #1e293b;">Impact </div>
          <div class="matrix-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem;">
      `;

      for (const impact of impacts) {
        for (const difficulty of difficulties) {
          const cellRows = rowsWithBuckets.filter(
            r => r.impact === impact && r.difficulty === difficulty
          );
          const count = cellRows.length;
          // Sum demand_share (0-1) for keywords in this cell
          const demandShareSum = cellRows.reduce((sum, r) => {
            const share = r.demand_share || 0;
            return sum + share;
          }, 0);
          // Convert to percentage
          const demandSharePct = totalDemandShare > 0 ? (demandShareSum / totalDemandShare) * 100 : 0;
          
          // Calculate average opportunity score for this cell
          const totalOpportunityScore = cellRows.reduce((sum, r) => {
            const score = r.opportunityScore ?? 0;
            return sum + score;
          }, 0);
          const avgOpportunityScore = count > 0 ? totalOpportunityScore / count : 0;

          // Background intensity based on avgOpportunityScore
          let backgroundColor;
          if (avgOpportunityScore >= 70) {
            backgroundColor = '#dcfce7'; // Strong green highlight (High)
          } else if (avgOpportunityScore >= 40) {
            backgroundColor = '#fef3c7'; // Medium amber highlight (Medium)
          } else {
            backgroundColor = '#f9fafb'; // Light/neutral background (Low)
          }
          
          // RAG styling: High impact + Low/Medium difficulty = high priority (green)
          const ragClass =
            impact === 'high' && (difficulty === 'low' || difficulty === 'medium') ? 'rag-high' :
            impact === 'high' && difficulty === 'high' ? 'rag-medium' :
            'rag-low';
          
          // Check if this cell is active
          const isActive = rankingPriorityFilter && 
            rankingPriorityFilter.impact === impact && 
            rankingPriorityFilter.difficulty === difficulty;
          
          // Active state styling
          const borderColor = isActive 
            ? '#2563eb' 
            : (ragClass === 'rag-high' ? '#10b981' : ragClass === 'rag-medium' ? '#f59e0b' : '#e5e7eb');
          const borderWidth = isActive ? '4px' : '2px';
          
          // Override background color if active
          if (isActive) {
            backgroundColor = '#dbeafe';
          }

          html += `
            <button
              class="matrix-cell ${ragClass} ${isActive ? 'active' : ''}"
              data-impact="${impact}"
              data-difficulty="${difficulty}"
              type="button"
              style="padding: 1.25rem; border: ${borderWidth} solid ${borderColor}; border-radius: 8px; background: ${backgroundColor}; cursor: pointer; text-align: center; transition: all 0.2s; box-shadow: ${isActive ? '0 4px 8px rgba(37, 99, 235, 0.3)' : 'none'};"
              onmouseover="this.style.transform='scale(1.05)'"
              onmouseout="this.style.transform='scale(1)'"
              title="${impact.toUpperCase()} / ${difficulty.toUpperCase()}"
            >
              <div class="cell-title" style="font-weight: 600; font-size: 0.9rem; margin-bottom: 0.5rem; color: #64748b; text-transform: uppercase;">${impact.toUpperCase()} / ${difficulty.toUpperCase()}</div>
              <div class="cell-count" style="font-size: 1.5rem; font-weight: 700; color: #1e293b; margin-bottom: 0.25rem;">${count}</div>
              <div class="cell-share" style="font-size: 0.9rem; color: #64748b; font-weight: 500;">${demandSharePct.toFixed(1)}% of demand</div>
            </button>
          `;
        }
      }

      html += `
          </div>
          <div class="axis-label difficulty" style="text-align: center; font-weight: 600; font-size: 1.1rem; margin-top: 0.5rem; color: #1e293b;">Difficulty </div>
        </div>
      `;

      container.innerHTML = html;

      // Wire up click handlers
      container.querySelectorAll('.matrix-cell').forEach(btn => {
        btn.addEventListener('click', () => {
          const impact = btn.getAttribute('data-impact');
          const difficulty = btn.getAttribute('data-difficulty');
          
          // Toggle: if clicking the same cell, clear filter; otherwise set it
          if (rankingPriorityFilter && 
              rankingPriorityFilter.impact === impact && 
              rankingPriorityFilter.difficulty === difficulty) {
            rankingPriorityFilter = null;
            selectedKeywordId = null; // Clear selection when clearing filter
          } else {
            rankingPriorityFilter = { impact, difficulty };
          }
          
          debugLog(`[RankingAI Scorecard] Priority grid cell clicked - impact: ${impact}, difficulty: ${difficulty}`, 'info');
          
          if (onCellClick) onCellClick(rankingPriorityFilter);
          
          // After filter is applied, check if exactly one row matches and auto-select it
          setTimeout(async () => {
            const { combinedRows } = RankingAiModule.state();
            const filteredAfterClick = applyRankingFilters(combinedRows);
            if (filteredAfterClick.length === 1) {
              const singleRow = filteredAfterClick[0];
              selectedKeywordId = `${singleRow.keyword}|${singleRow.best_url || ''}`;
              debugLog(`[RankingAI Scorecard] Auto-selecting single matching keyword: "${singleRow.keyword}"`, 'info');
              await renderKeywordScorecard(singleRow);
              // Also update table row selection
              const tbody = document.getElementById("ranking-ai-table-body");
              if (tbody) {
                tbody.querySelectorAll("tr").forEach(tr => {
                  tr.classList.remove("ranking-table-row--selected");
                  const idx = Number(tr.dataset.index || "-1");
                  if (!Number.isNaN(idx) && combinedRows[idx] === singleRow) {
                    tr.classList.add("ranking-table-row--selected");
                  }
                });
              }
            } else {
              selectedKeywordId = null; // Clear selection if multiple or no rows
            }
          }, 100); // Small delay to ensure renderRankingAiTab has completed
        });
      });

      // Debug logging
      debugLog(`[Keyword Priority Matrix] Rendered matrix with ${filteredRows.length} filtered rows`, 'info');
      rowsWithBuckets.forEach(row => {
        debugLog(`[Keyword Priority Matrix] "${row.keyword}": impact=${row.impact}, difficulty=${row.difficulty}, demand_share=${((row.demand_share || 0) * 100).toFixed(1)}%, rank=${row.best_rank_group ?? 'null'}`, 'info');
      });
      
      // Log cell totals
      for (const impact of impacts) {
        for (const difficulty of difficulties) {
          const cellRows = rowsWithBuckets.filter(r => r.impact === impact && r.difficulty === difficulty);
          const demandShareSum = cellRows.reduce((sum, r) => sum + ((r.search_volume && r.search_volume > 0 ? r.search_volume : 0)), 0);
          const demandSharePct = totalSearchVolume > 0 ? (demandShareSum / totalSearchVolume) * 100 : 0;
          debugLog(`[Keyword Priority Matrix] Cell ${impact}/${difficulty}: count=${cellRows.length}, demand_share=${demandSharePct.toFixed(1)}%`, 'info');
        }
      }
    }

    // Rank normalization helper
    function normalizeRank(rank) {
      const r = Number(rank);
      if (!Number.isFinite(r) || r <= 0) return null; // treat missing/unranked
      return r;
    }

    // Apply filters to rows
    function applyRankingFilters(rows, excludeFilter = null) {
      return rows.filter(row => {
        // Segment filter (normalize to lowercase for comparison)
        if (excludeFilter !== 'segment' && rankingFilterState.segment !== 'all') {
          const rowSegment = (row.segment || '').toLowerCase();
          const filterSegment = rankingFilterState.segment.toLowerCase();
          if (rowSegment !== filterSegment) {
            return false;
          }
        }

        // Rank bucket filter
        if (excludeFilter !== 'rank' && rankingFilterState.rank !== 'all') {
          const rank = normalizeRank(row.best_rank_group);
          if (rankingFilterState.rank === 'top3' && (rank === null || rank > 3)) return false;
          if (rankingFilterState.rank === '4-10' && (rank === null || rank < 4 || rank > 10)) return false;
          if (rankingFilterState.rank === '11-20' && (rank === null || rank < 11 || rank > 20)) return false;
          if (rankingFilterState.rank === '21+' && rank !== null && rank <= 20) return false;
          if (rankingFilterState.rank === 'not-top3' && rank !== null && rank <= 3) return false;
        }
        
        // Preset-specific rank predicates (when rank filter is 'all' but preset requires specific range)
        // Note: Most presets now use explicit rank filter values (e.g., 'not-top3'), so this is rarely needed
        // Keeping for backward compatibility if any presets still use 'all' with predicates
        if (excludeFilter !== 'rank' && rankingFilterState.rank === 'all' && activePreset) {
          const rank = normalizeRank(row.best_rank_group);
          // No preset-specific predicates needed - all presets now use explicit rank filter values
        }

        // Search volume filter
        if (excludeFilter !== 'volume' && rankingFilterState.volume !== 'all') {
          const volume = row.search_volume;
          if (rankingFilterState.volume === 'high' && (volume == null || volume < 200)) return false;
          if (rankingFilterState.volume === 'medium' && (volume == null || volume < 50 || volume >= 200)) return false;
          if (rankingFilterState.volume === 'low' && (volume == null || volume < 1 || volume >= 50)) return false;
          if (rankingFilterState.volume === 'none' && volume != null && volume > 0) return false;
          
        }

        // CTR filter
        if (excludeFilter !== 'ctr' && rankingFilterState.ctr !== 'all') {
          // Use canonical targetUrl for CTR metrics
          const urlForCtr = row.targetUrl || row.ranking_url || '';
          const ctrMetrics = getCtrMetricsForKeyword({ keyword: row.keyword, url: urlForCtr });
          const ctr = ctrMetrics && ctrMetrics.ctr != null ? (ctrMetrics.ctr * 100) : null;
          if (rankingFilterState.ctr === 'high' && (ctr == null || ctr < 5)) return false;
          if (rankingFilterState.ctr === 'medium' && (ctr == null || ctr < 2 || ctr >= 5)) return false;
          if (rankingFilterState.ctr === 'low' && (ctr == null || ctr >= 2)) return false;
          if (rankingFilterState.ctr === 'none' && ctr != null) return false;
        }

        // Demand share filter removed - replaced with Impressions (30d) column

        // Page type filter
        if (excludeFilter !== 'pageType' && rankingFilterState.pageType && rankingFilterState.pageType !== 'all') {
          const rowPageType = row.pageType || 'Landing';
          if (rowPageType !== rankingFilterState.pageType) {
            return false;
          }
        }

        // SERP features filter
        if (excludeFilter !== 'serpFeatures' && rankingFilterState.serpFeatures !== 'all') {
          const hasAiOverview = row.ai_overview_present_any === true;
          const hasLocalPack = row.local_pack_present_any === true;
          const hasPaa = row.paa_present_any === true;
          const hasFeaturedSnippet = row.featured_snippet_present_any === true;
          if (rankingFilterState.serpFeatures === 'ai-overview' && !hasAiOverview) return false;
          if (rankingFilterState.serpFeatures === 'local-pack' && !hasLocalPack) return false;
          if (rankingFilterState.serpFeatures === 'paa' && !hasPaa) return false;
          if (rankingFilterState.serpFeatures === 'featured-snippet' && !hasFeaturedSnippet) return false;
          if (rankingFilterState.serpFeatures === 'none' && (hasAiOverview || hasLocalPack || hasPaa || hasFeaturedSnippet)) return false;
        }

        // AI Overview filter
        if (excludeFilter !== 'aiOverview' && rankingFilterState.aiOverview !== 'all') {
          if (rankingFilterState.aiOverview === 'has' && !row.has_ai_overview) return false;
          if (rankingFilterState.aiOverview === 'no' && row.has_ai_overview) return false;
        }

        // AI Citation filter
        if (excludeFilter !== 'aiCitation' && rankingFilterState.aiCitation !== 'all') {
          const isCited = row.ai_alan_citations_count > 0;
          if (rankingFilterState.aiCitation === 'cited' && !isCited) return false;
          if (rankingFilterState.aiCitation === 'not-cited' && isCited) return false;
        }

        // Opportunity band constants
        const OP_BANDS = {
          highMin: 70,
          mediumMin: 40
        };

        // Opportunity Score filter
        if (excludeFilter !== 'opportunity' && rankingFilterState.opportunity !== 'all') {
          const oppScore = row.opportunityScore ?? -1; // Treat null as -1 (below low threshold)
          if (rankingFilterState.opportunity === 'high' && (oppScore < OP_BANDS.highMin || oppScore > 100)) return false;
          if (rankingFilterState.opportunity === 'medium' && (oppScore < OP_BANDS.mediumMin || oppScore >= OP_BANDS.highMin)) return false;
          if (rankingFilterState.opportunity === 'low' && (oppScore >= OP_BANDS.mediumMin || oppScore < 0)) return false;
        }

        // Min opportunity filter (applied after band filter if set)
        if (rankingFilterState.minOpportunity != null) {
          const oppScore = Number(row.opportunityScore) || 0;
          if (oppScore < rankingFilterState.minOpportunity) return false;
        }

        // Keyword search
        if (excludeFilter !== 'keyword' && rankingFilterState.keyword) {
          const kw = rankingFilterState.keyword.toLowerCase();
          if (!row.keyword.toLowerCase().includes(kw)) return false;
        }

        // Optimisation status filter
        if (excludeFilter !== 'optimisationStatus' && rankingFilterState.optimisationStatus !== 'all') {
          const taskType = 'on_page'; // Default task type
          const status = window.getOptimisationStatus ? window.getOptimisationStatus(row, taskType) : null;
          const rowStatus = status && status.status ? status.status : 'not-tracked';
          
          if (rankingFilterState.optimisationStatus === 'not-tracked' && rowStatus !== 'not-tracked') return false;
          if (rankingFilterState.optimisationStatus === 'planned' && rowStatus !== 'planned') return false;
          if (rankingFilterState.optimisationStatus === 'in_progress' && rowStatus !== 'in_progress') return false;
          if (rankingFilterState.optimisationStatus === 'monitoring' && rowStatus !== 'monitoring') return false;
          if (rankingFilterState.optimisationStatus === 'done' && rowStatus !== 'done') return false;
          if (rankingFilterState.optimisationStatus === 'paused' && rowStatus !== 'paused') return false;
          if (rankingFilterState.optimisationStatus === 'cancelled' && rowStatus !== 'cancelled') return false;
        }

        // Priority matrix filter (Impact  Difficulty)
        if (rankingPriorityFilter) {
          const impact = calculateImpactBucket(row.demand_share || 0);
          const difficulty = calculateDifficultyBucket(row.best_rank_group);
          if (impact !== rankingPriorityFilter.impact || difficulty !== rankingPriorityFilter.difficulty) {
            return false;
          }
        }

        return true;
      });
    }

    // Sort rows
    function sortRankingRows(rows) {
      const sorted = [...rows];
      sorted.sort((a, b) => {
        let aVal, bVal;
        switch (rankingSortState.column) {
          case 'keyword':
            aVal = a.keyword.toLowerCase();
            bVal = b.keyword.toLowerCase();
            break;
          case 'segment':
            aVal = a.segment;
            bVal = b.segment;
            break;
          case 'rank':
            aVal = a.best_rank_group ?? 999;
            bVal = b.best_rank_group ?? 999;
            break;
          case 'citations':
            aVal = a.ai_alan_citations_count ?? 0;
            bVal = b.ai_alan_citations_count ?? 0;
            break;
          case 'volume':
            aVal = a.search_volume ?? 0;
            bVal = b.search_volume ?? 0;
            break;
          case 'ctr':
            const aCtr = getCtrMetricsForKeyword({ keyword: a.keyword, url: a.ranking_url });
            const bCtr = getCtrMetricsForKeyword({ keyword: b.keyword, url: b.ranking_url });
            aVal = (aCtr && aCtr.ctr != null) ? aCtr.ctr : -1; // Put nulls at end
            bVal = (bCtr && bCtr.ctr != null) ? bCtr.ctr : -1;
            break;
          case 'impressions30d':
            aVal = a.impressions30d ?? -1; // Put nulls at end
            bVal = b.impressions30d ?? -1;
            break;
          case 'opportunityScore':
            aVal = a.opportunityScore ?? -1; // Put nulls at end
            bVal = b.opportunityScore ?? -1;
            break;
          case 'pageType':
            aVal = a.pageType || 'Landing';
            bVal = b.pageType || 'Landing';
            break;
          default:
            return 0;
        }
        if (aVal < bVal) return rankingSortState.direction === 'asc' ? -1 : 1;
        if (aVal > bVal) return rankingSortState.direction === 'asc' ? 1 : -1;
        
        // Secondary sort: for high-impact-money, sort by rank (asc) when opportunity scores are equal
        if (rankingSortState.column === 'opportunityScore' && activePreset === 'high-impact-money') {
          const aRank = normalizeRank(a.best_rank_group) ?? 999;
          const bRank = normalizeRank(b.best_rank_group) ?? 999;
          if (aRank < bRank) return -1;
          if (aRank > bRank) return 1;
        }
        
        return 0;
      });
      return sorted;
    }

    // Toggle metric pill details
    function toggleMetricPillDetails(cardId) {
      const card = document.getElementById(cardId);
      if (!card) return;
      
      const detailsEl = card.querySelector(".metric-pill-details");
      const toggleEl = card.querySelector(".metric-pill-toggle");
      
      if (detailsEl && toggleEl) {
        const isExpanded = detailsEl.classList.contains("expanded");
        if (isExpanded) {
          detailsEl.classList.remove("expanded");
          toggleEl.textContent = "Show details";
        } else {
          detailsEl.classList.add("expanded");
          toggleEl.textContent = "Hide details";
        }
      }
    }

    // Set all metric pill details to be expanded by default on desktop
    function expandAllMetricPillDetails() {
      const pillIds = ['ranking-card-ai-coverage', 'ranking-card-ai-citations', 'ranking-card-ai-citations-money', 'ranking-card-top10', 'ranking-card-serp-features'];
      pillIds.forEach(cardId => {
        const card = document.getElementById(cardId);
        if (card) {
          const detailsEl = card.querySelector(".metric-pill-details");
          const toggleEl = card.querySelector(".metric-pill-toggle");
          if (detailsEl && toggleEl && detailsEl.innerHTML.trim() !== '') {
            detailsEl.classList.add("expanded");
            toggleEl.textContent = "Hide details";
          }
        }
      });
    }

    // Update metric pills with RAG
    function updateMetricPills(filteredRows, allRows) {
      const totalKeywords = allRows.length;
      const filteredCount = filteredRows.length;
      
      // Check if filters are active (if filtered count differs from total, filters are active)
      const filtersActive = filteredCount !== totalKeywords;
      
      // Use filtered rows if filters are active, otherwise use all rows
      const rowsToUse = filtersActive ? filteredRows : allRows;
      const countToUse = filtersActive ? filteredCount : totalKeywords;

      // Calculate metrics from rowsToUse (filtered if filters active, all if not)
      const withAiOverview = rowsToUse.filter(r => r.has_ai_overview).length;
      const withAiCitation = rowsToUse.filter(r => r.ai_alan_citations_count > 0).length;
      const top10 = rowsToUse.filter(r => r.best_rank_group != null && r.best_rank_group <= 10).length;

      const aiCoveragePct = countToUse > 0 ? Math.round((withAiOverview / countToUse) * 100) : 0;
      const aiCitationPct = countToUse > 0 ? Math.round((withAiCitation / countToUse) * 100) : 0;
      const top10Pct = countToUse > 0 ? Math.round((top10 / countToUse) * 100) : 0;

      // AI Overview coverage
      const coverageCard = document.getElementById("ranking-card-ai-coverage");
      if (coverageCard) {
        const valueEl = coverageCard.querySelector(".metric-pill-value[data-field='value']");
        const statusEl = coverageCard.querySelector(".metric-pill-status[data-field='status']");
        const detailsEl = coverageCard.querySelector(".metric-pill-details");
        if (valueEl) valueEl.textContent = `${withAiOverview}/${countToUse} (${aiCoveragePct}%)`;
        
        let ragClass = 'red';
        let statusLabel = 'Low';
        if (aiCoveragePct >= 80) { ragClass = 'green'; statusLabel = 'Strong'; }
        else if (aiCoveragePct >= 40) { ragClass = 'amber'; statusLabel = 'Moderate'; }
        
        coverageCard.className = `metric-pill metric-pill--${ragClass}`;
        if (statusEl) statusEl.textContent = statusLabel;
        
        // Update details
        if (detailsEl) {
          const withoutOverview = countToUse - withAiOverview;
          const pctWithoutOverview = countToUse > 0 ? Math.round((withoutOverview / countToUse) * 100) : 0;
          detailsEl.innerHTML = `
            <p class="tile-details-title">How often any AI Overview appears for your tracked keywords.</p>
            <ul class="tile-details-list">
              <li>
                <strong>With AI Overview:</strong> ${withAiOverview}/${countToUse} (${aiCoveragePct}%)
              </li>
              <li>
                <strong>Without AI Overview:</strong> ${withoutOverview}/${countToUse} (${pctWithoutOverview}%)
              </li>
            </ul>
            <p class="tile-details-footnote">
              Counted per keyword. It does not matter which domains are cited.
            </p>
          `;
        }
      }

      // AI Citations
      const citationsCard = document.getElementById("ranking-card-ai-citations");
      if (citationsCard) {
        const valueEl = citationsCard.querySelector(".metric-pill-value[data-field='value']");
        const statusEl = citationsCard.querySelector(".metric-pill-status[data-field='status']");
        const detailsEl = citationsCard.querySelector(".metric-pill-details");
        if (valueEl) valueEl.textContent = `${withAiCitation}/${countToUse} (${aiCitationPct}%)`;
        
        let ragClass = 'red';
        let statusLabel = 'Not cited';
        if (aiCitationPct >= 60) { ragClass = 'green'; statusLabel = 'Strong'; }
        else if (aiCitationPct >= 30) { ragClass = 'amber'; statusLabel = 'Some'; }
        
        citationsCard.className = `metric-pill metric-pill--${ragClass}`;
        if (statusEl) statusEl.textContent = statusLabel;
        
        // Calculate total citations
        const totalCitations = rowsToUse.reduce((sum, r) => sum + (r.ai_alan_citations_count || 0), 0);
        
        // Calculate withOverviewNoCitation (keywords with AI Overview but no alanranger.com citation)
        const withOverviewNoCitation = rowsToUse.filter(r => r.has_ai_overview && r.ai_alan_citations_count === 0).length;
        const pctWithOverviewNoCitation = countToUse > 0 ? Math.round((withOverviewNoCitation / countToUse) * 100) : 0;
        
        // Update details
        if (detailsEl) {
          detailsEl.innerHTML = `
            <p class="tile-details-title">
              How often alanranger.com is actually cited inside the AI Overview.
            </p>
            <ul class="tile-details-list">
              <li>
                <strong>Keywords with citations:</strong> ${withAiCitation}/${countToUse} (${aiCitationPct}%)
              </li>
              <li>
                <strong>With AI Overview but no alanranger.com citation:</strong> ${withOverviewNoCitation}/${countToUse} (${pctWithOverviewNoCitation}%)
              </li>
              <li>
                <strong>Total citations across all keywords:</strong> ${totalCitations}
              </li>
            </ul>
            <p class="tile-details-footnote">
              A single keyword can cite alanranger.com multiple times; all those links are counted in "Total citations".
            </p>
          `;
        }
      }
      
      // AI Citations (Money pages)
      try {
        const rankingAiDataRaw = localStorage.getItem('rankingAiData');
        const parsed = rankingAiDataRaw ? JSON.parse(rankingAiDataRaw) : null;
        renderRankingAiMoneyCitationsTile(parsed);
      } catch (e) {
        // Ignore if localStorage missing/corrupt
      }

      // Top-10 coverage
      const top10Card = document.getElementById("ranking-card-top10");
      if (top10Card) {
        const valueEl = top10Card.querySelector(".metric-pill-value[data-field='value']");
        const statusEl = top10Card.querySelector(".metric-pill-status[data-field='status']");
        const detailsEl = top10Card.querySelector(".metric-pill-details");
        if (valueEl) valueEl.textContent = `${top10}/${countToUse} (${top10Pct}%)`;
        
        // Calculate rank buckets
        const top3 = rowsToUse.filter(r => r.best_rank_group != null && r.best_rank_group <= 3).length;
        const top3Pct = countToUse > 0 ? Math.round((top3 / countToUse) * 100) : 0;
        const rank11to20 = rowsToUse.filter(r => r.best_rank_group != null && r.best_rank_group >= 11 && r.best_rank_group <= 20).length;
        const rank11to20Pct = countToUse > 0 ? Math.round((rank11to20 / countToUse) * 100) : 0;
        const notRanked = rowsToUse.filter(r => r.best_rank_group == null || r.best_rank_group > 20).length;
        const notRankedPct = countToUse > 0 ? Math.round((notRanked / countToUse) * 100) : 0;
        
        let ragClass = 'red';
        let statusLabel = 'Weak';
        if (top10Pct >= 60) { ragClass = 'green'; statusLabel = 'Strong'; }
        else if (top10Pct >= 30) { ragClass = 'amber'; statusLabel = 'OK'; }
        
        top10Card.className = `metric-pill metric-pill--${ragClass}`;
        if (statusEl) statusEl.textContent = statusLabel;
        
        // Calculate top10Only (positions 4-10)
        const top10Only = top10 - top3;
        const pctTop10Only = countToUse > 0 ? Math.round((top10Only / countToUse) * 100) : 0;
        const pct11to20 = countToUse > 0 ? Math.round((rank11to20 / countToUse) * 100) : 0;
        const pctNotRanked = countToUse > 0 ? Math.round((notRanked / countToUse) * 100) : 0;
        
        // Update details
        if (detailsEl) {
          detailsEl.innerHTML = `
            <p class="tile-details-title">
              Distribution of best classic (blue-link) rankings across your tracked keywords.
            </p>
            <ul class="tile-details-list">
              <li>
                <strong>Top 3 (positions 13):</strong> ${top3}/${countToUse} (${top3Pct}%)
              </li>
              <li>
                <strong>Positions 410:</strong> ${top10Only}/${countToUse} (${pctTop10Only}%)
              </li>
              <li>
                <strong>Positions 1120:</strong> ${rank11to20}/${countToUse} (${pct11to20}%)
              </li>
              <li>
                <strong>Not ranked (21+):</strong> ${notRanked}/${countToUse} (${pctNotRanked}%)
              </li>
            </ul>
            <p class="tile-details-footnote">
              "Top 3" and "410" together make up your total Top-10 coverage.
            </p>
          `;
        }
      }

      // SERP feature coverage
      const serpFeaturesCard = document.getElementById("ranking-card-serp-features");
      if (serpFeaturesCard) {
        // Count keywords with each SERP feature
        const withAiOverview = rowsToUse.filter(r => r.ai_overview_present_any === true || r.has_ai_overview === true).length;
        const withLocalPack = rowsToUse.filter(r => r.local_pack_present_any === true || (r.serp_features && r.serp_features.local_pack === true)).length;
        const withPaa = rowsToUse.filter(r => r.paa_present_any === true || (r.serp_features && r.serp_features.people_also_ask === true)).length;
        const withFeaturedSnippet = rowsToUse.filter(r => r.featured_snippet_present_any === true || (r.serp_features && r.serp_features.featured_snippet === true)).length;
        
        // Calculate average feature presence (0-100%)
        const avgFeaturePresence = countToUse > 0 
          ? Math.round(((withAiOverview + withLocalPack + withPaa + withFeaturedSnippet) / (countToUse * 4)) * 100)
          : 0;
        
        // Calculate individual percentages
        const aiOverviewPct = countToUse > 0 ? Math.round((withAiOverview / countToUse) * 100) : 0;
        const localPackPct = countToUse > 0 ? Math.round((withLocalPack / countToUse) * 100) : 0;
        const paaPct = countToUse > 0 ? Math.round((withPaa / countToUse) * 100) : 0;
        const featuredSnippetPct = countToUse > 0 ? Math.round((withFeaturedSnippet / countToUse) * 100) : 0;
        
        const valueEl = serpFeaturesCard.querySelector(".metric-pill-value[data-field='value']");
        const statusEl = serpFeaturesCard.querySelector(".metric-pill-status[data-field='status']");
        const detailsEl = serpFeaturesCard.querySelector(".metric-pill-details");
        
        // Show as "X/4 features (Y%)" format
        const featuresPresent = [withAiOverview, withLocalPack, withPaa, withFeaturedSnippet].filter(count => count > 0).length;
        if (valueEl) valueEl.textContent = `${featuresPresent}/4 features (${avgFeaturePresence}%)`;
        
        let ragClass = 'red';
        let statusLabel = 'Low';
        if (avgFeaturePresence >= 70) { ragClass = 'green'; statusLabel = 'Strong'; }
        else if (avgFeaturePresence >= 40) { ragClass = 'amber'; statusLabel = 'Moderate'; }
        
        serpFeaturesCard.className = `metric-pill metric-pill--${ragClass}`;
        if (statusEl) statusEl.textContent = statusLabel;
        
        // Update details content
        if (detailsEl) {
          detailsEl.innerHTML = `
            <p class="tile-details-title">
              How often rich SERP features appear for your tracked keywords.
            </p>
            <ul class="tile-details-list">
              <li>
                <strong>AI Overview present:</strong> ${withAiOverview}/${countToUse} (${aiOverviewPct}%)
              </li>
              <li>
                <strong>Local pack present:</strong> ${withLocalPack}/${countToUse} (${localPackPct}%)
              </li>
              <li>
                <strong>People Also Ask present:</strong> ${withPaa}/${countToUse} (${paaPct}%)
              </li>
              <li>
                <strong>Featured snippet present:</strong> ${withFeaturedSnippet}/${countToUse} (${featuredSnippetPct}%)
              </li>
            </ul>
            <p class="tile-details-footnote">
              Counts are per keyword. A single SERP can contain multiple features (for example AI Overview + People Also Ask).
            </p>
          `;
        }
      }
    }

    // Update filter counts in dropdowns
    // Counts show how many items match each option given the current state of OTHER filters
    function updateFilterCounts(rows) {
      if (!rows || rows.length === 0) return;

      // For each filter, calculate counts based on rows that match all OTHER filters
      // Segment counts (excluding segment filter)
      const segmentRows = applyRankingFilters(rows, 'segment');
      const segmentCounts = { all: segmentRows.length, brand: 0, money: 0, education: 0, other: 0 };
      segmentRows.forEach(r => {
        const seg = (r.segment || '').toLowerCase();
        if (segmentCounts.hasOwnProperty(seg)) segmentCounts[seg]++;
        else segmentCounts.other++;
      });
      updateSelectCounts('ranking-filter-segment', segmentCounts);

      // Rank counts (excluding rank filter)
      const rankRows = applyRankingFilters(rows, 'rank');
      const rankCounts = { all: rankRows.length, top3: 0, '4-10': 0, '11-20': 0, '21+': 0, 'not-top3': 0 };
      rankRows.forEach(r => {
        const rank = normalizeRank(r.best_rank_group);
        if (rank !== null && rank <= 3) {
          rankCounts.top3++;
        } else {
          // Count rows that are NOT top 3 (rank > 3 or null)
          rankCounts['not-top3']++;
        }
        if (rank !== null && rank >= 4 && rank <= 10) rankCounts['4-10']++;
        if (rank !== null && rank >= 11 && rank <= 20) rankCounts['11-20']++;
        if (rank === null || rank >= 21) rankCounts['21+']++;
      });
      updateSelectCounts('ranking-filter-rank', rankCounts);

      // Volume counts (excluding volume filter)
      const volumeRows = applyRankingFilters(rows, 'volume');
      const volumeCounts = { all: volumeRows.length, high: 0, medium: 0, low: 0, none: 0 };
      volumeRows.forEach(r => {
        const vol = r.search_volume;
        if (vol == null || vol === 0) volumeCounts.none++;
        else if (vol < 50) volumeCounts.low++;
        else if (vol < 200) volumeCounts.medium++;
        else volumeCounts.high++;
      });
      updateSelectCounts('ranking-filter-volume', volumeCounts);

      // CTR counts (excluding CTR filter)
      const ctrRows = applyRankingFilters(rows, 'ctr');
      const ctrCounts = { all: ctrRows.length, high: 0, medium: 0, low: 0, none: 0 };
      ctrRows.forEach(r => {
        const ctrMetrics = getCtrMetricsForKeyword({ keyword: r.keyword, url: r.ranking_url });
        const ctr = ctrMetrics && ctrMetrics.ctr != null ? (ctrMetrics.ctr * 100) : null;
        if (ctr == null) ctrCounts.none++;
        else if (ctr < 2) ctrCounts.low++;
        else if (ctr < 5) ctrCounts.medium++;
        else ctrCounts.high++;
      });
      updateSelectCounts('ranking-filter-ctr', ctrCounts);

      // Demand share filter removed - replaced with Impressions (30d) column

      // Opportunity score counts (excluding opportunity filter)
      const oppRows = applyRankingFilters(rows, 'opportunity');
      const oppCounts = { all: oppRows.length, high: 0, medium: 0, low: 0 };
      oppRows.forEach(r => {
        const opp = r.opportunityScore ?? -1;
        if (opp >= 70) oppCounts.high++;
        else if (opp >= 40) oppCounts.medium++;
        else if (opp >= 0) oppCounts.low++;
      });
      updateSelectCounts('ranking-filter-opportunity', oppCounts);

      // AI Overview counts (excluding AI Overview filter)
      const aiOverviewRows = applyRankingFilters(rows, 'aiOverview');
      const aiOverviewCounts = { all: aiOverviewRows.length, has: 0, no: 0 };
      aiOverviewRows.forEach(r => {
        if (r.has_ai_overview) aiOverviewCounts.has++;
        else aiOverviewCounts.no++;
      });
      updateSelectCounts('ranking-filter-ai-overview', aiOverviewCounts);

      // AI Citation counts (excluding AI Citation filter)
      const aiCitationRows = applyRankingFilters(rows, 'aiCitation');
      const aiCitationCounts = { all: aiCitationRows.length, cited: 0, 'not-cited': 0 };
      aiCitationRows.forEach(r => {
        if (r.ai_alan_citations_count > 0) aiCitationCounts.cited++;
        else aiCitationCounts['not-cited']++;
      });
      updateSelectCounts('ranking-filter-ai-citation', aiCitationCounts);

      // Page type counts (excluding page type filter)
      const pageTypeRows = applyRankingFilters(rows, 'pageType');
      const pageTypeCounts = { all: pageTypeRows.length, GBP: 0, Blog: 0, Landing: 0, Event: 0, Product: 0, Other: 0 };
      pageTypeRows.forEach(r => {
        const pt = r.pageType || 'Landing';
        if (pageTypeCounts.hasOwnProperty(pt)) pageTypeCounts[pt]++;
        else pageTypeCounts.Other++;
      });
      updateSelectCounts('ranking-filter-page-type', pageTypeCounts);

      // SERP features counts (excluding SERP features filter)
      const serpRows = applyRankingFilters(rows, 'serpFeatures');
      const serpCounts = { all: serpRows.length, 'ai-overview': 0, 'local-pack': 0, paa: 0, 'featured-snippet': 0, none: 0 };
      serpRows.forEach(r => {
        const hasAi = r.ai_overview_present_any === true;
        const hasLocal = r.local_pack_present_any === true;
        const hasPaa = r.paa_present_any === true;
        const hasFeatured = r.featured_snippet_present_any === true;
        if (hasAi) serpCounts['ai-overview']++;
        if (hasLocal) serpCounts['local-pack']++;
        if (hasPaa) serpCounts.paa++;
        if (hasFeatured) serpCounts['featured-snippet']++;
        if (!hasAi && !hasLocal && !hasPaa && !hasFeatured) serpCounts.none++;
      });
      updateSelectCounts('ranking-filter-serp-features', serpCounts);

      // Optimisation status counts (excluding optimisation status filter)
      const optimisationRows = applyRankingFilters(rows, 'optimisationStatus');
      const optimisationCounts = { all: optimisationRows.length, 'not-tracked': 0, 'planned': 0, 'in_progress': 0, 'monitoring': 0, 'done': 0, 'paused': 0, 'cancelled': 0 };
      optimisationRows.forEach(r => {
        const taskType = 'on_page'; // Default task type
        const status = window.getOptimisationStatus ? window.getOptimisationStatus(r, taskType) : null;
        const rowStatus = status && status.status ? status.status : 'not-tracked';
        if (optimisationCounts.hasOwnProperty(rowStatus)) {
          optimisationCounts[rowStatus]++;
        } else {
          optimisationCounts['not-tracked']++;
        }
      });
      updateSelectCounts('ranking-filter-optimisation-status', optimisationCounts);
    }

    function updateSelectCounts(selectId, counts) {
      const select = document.getElementById(selectId);
      if (!select) return;
      // Store original labels (without counts) for each option
      const originalLabels = {};
      Array.from(select.options).forEach(opt => {
        const value = opt.value;
        if (!originalLabels[value]) {
          // Store original label (remove existing count if any)
          originalLabels[value] = opt.textContent.split(' (')[0].trim();
        }
      });
      // Update with counts - ensure ALL options get counts, even if 0
      Array.from(select.options).forEach(opt => {
        const value = opt.value;
        const label = originalLabels[value] || opt.textContent.split(' (')[0].trim();
        if (counts.hasOwnProperty(value)) {
          const count = counts[value];
          opt.textContent = value === 'all' ? `All (${count})` : `${label} (${count})`;
        } else {
          // If count not found, show 0 (for options that might not have been in the data)
          opt.textContent = value === 'all' ? `All (0)` : `${label} (0)`;
        }
      });
    }

    // Helper function to get query-only totals for a keyword (PATCH A2)
    // Helper function to normalize keywords for matching
    function normalizeKeywordForMatching(keyword) {
      if (!keyword) return '';
      // Normalize: lowercase, trim, collapse multiple spaces to single space
      return keyword.toLowerCase().trim().replace(/\s+/g, ' ');
    }
    
    function getQueryTotalForKeyword(keyword) {
      try {
        const savedAudit = loadAuditResultsSync();
        if (!savedAudit || !savedAudit.searchData) {
          debugLog(`getQueryTotalForKeyword: No queryTotals found for "${keyword}" - savedAudit=${!!savedAudit}, searchData=${!!savedAudit?.searchData}`, 'warn');
          return null;
        }
        
        // CRITICAL: Check if queryTotals exists and handle object vs array
        let queryTotals = savedAudit.searchData.queryTotals;
        if (!queryTotals) {
          debugLog(`getQueryTotalForKeyword: No queryTotals found for "${keyword}" - queryTotals is null/undefined`, 'warn');
          return null;
        }
        
        // If queryTotals is an object instead of an array, try to convert it
        if (typeof queryTotals === 'object' && !Array.isArray(queryTotals)) {
          debugLog(`getQueryTotalForKeyword: queryTotals is an object, not an array. Type: ${typeof queryTotals}, keys: ${Object.keys(queryTotals).join(', ')}`, 'warn');
          // Try to extract array from object
          if (Object.keys(queryTotals).every(key => !isNaN(parseInt(key)))) {
            // Array-like object with numeric keys
            queryTotals = Object.values(queryTotals);
            debugLog(`getQueryTotalForKeyword: Converted array-like object to array (${queryTotals.length} items)`, 'info');
          } else {
            // Check if there's an array property inside the object
            for (const key in queryTotals) {
              if (Array.isArray(queryTotals[key])) {
                queryTotals = queryTotals[key];
                debugLog(`getQueryTotalForKeyword: Extracted array from object at key '${key}' (${queryTotals.length} items)`, 'info');
                break;
              }
            }
          }
        }
        
        if (!Array.isArray(queryTotals)) {
          debugLog(`getQueryTotalForKeyword: queryTotals is still not an array after conversion attempt. Type: ${typeof queryTotals}`, 'warn');
          return null;
        }
        
        if (queryTotals.length === 0) {
          debugLog(`getQueryTotalForKeyword: queryTotals array is empty`, 'warn');
          return null;
        }
        
        // Normalize the search keyword
        const normalizedKeyword = normalizeKeywordForMatching(keyword);
        
        // Try exact match first (normalized)
        let queryTotal = queryTotals.find(
          qt => qt.query && normalizeKeywordForMatching(qt.query) === normalizedKeyword
        );
        
        // If no exact match, try fuzzy matching (check if keyword is contained in query or vice versa)
        if (!queryTotal) {
          queryTotal = queryTotals.find(
            qt => {
              if (!qt.query) return false;
              const normalizedQuery = normalizeKeywordForMatching(qt.query);
              // Check if normalized keyword is contained in normalized query or vice versa
              return normalizedQuery === normalizedKeyword || 
                     normalizedQuery.includes(normalizedKeyword) || 
                     normalizedKeyword.includes(normalizedQuery);
            }
          );
        }
        
        if (!queryTotal) {
          // Enhanced debugging: show sample queries from queryTotals to help diagnose mismatches
          const sampleQueries = queryTotals.slice(0, 10).map(qt => qt.query || '(no query)').join(', ');
          debugLog(`getQueryTotalForKeyword: No match found for "${keyword}" (normalized: "${normalizedKeyword}") in ${queryTotals.length} queryTotals. Sample queries: ${sampleQueries}${queryTotals.length > 10 ? '...' : ''}`, 'warn');
          
          // Also check if there are any queries with zero impressions (these might be the missing ones)
          const zeroImpressionQueries = queryTotals.filter(qt => qt.impressions === 0 || qt.impressions == null).slice(0, 5).map(qt => qt.query || '(no query)').join(', ');
          if (zeroImpressionQueries) {
            debugLog(`getQueryTotalForKeyword: Found ${queryTotals.filter(qt => qt.impressions === 0 || qt.impressions == null).length} queries with zero impressions. Sample: ${zeroImpressionQueries}`, 'info');
          }
        }
        
        return queryTotal || null;
      } catch (error) {
        debugLog(`Error in getQueryTotalForKeyword: ${error.message}`, 'warn');
        return null;
      }
    }

    async function renderRankingAiTab() {
      debugLog(' renderRankingAiTab() called', 'info');
      const { combinedRows, summary } = RankingAiModule.state();
      debugLog(` renderRankingAiTab: combinedRows=${combinedRows?.length || 0}, hasSummary=${!!summary}`, 'info');
      
      // Always render table, even if no data (will show empty state)
      const tbody = document.getElementById("ranking-ai-table-body");
      if (!tbody) {
        debugLog(' renderRankingAiTab: Table body not found', 'warn');
        return;
      }
      
      if (!summary || !Array.isArray(combinedRows) || combinedRows.length === 0) {
        debugLog(` renderRankingAiTab: No data - summary=${!!summary}, combinedRows is array=${Array.isArray(combinedRows)}, length=${combinedRows?.length || 0}`, 'warn');
        // Show empty state message
        tbody.innerHTML = '<tr><td colspan="11" class="ranking-table-empty">Click "Run ranking &amp; AI check" to load data.</td></tr>';
        const paginationControls = document.getElementById("ranking-pagination-controls");
        if (paginationControls) paginationControls.style.display = "none";
        return;
      }
      
      debugLog(` renderRankingAiTab: Proceeding with ${combinedRows.length} keywords`, 'success');

      // Apply filters first
      const filteredRows = applyRankingFilters(combinedRows);
      
      // Update filter counts based on all rows (before filtering)
      updateFilterCounts(combinedRows);
      
      // Update preset button active states and render criteria chips
      if (typeof updatePresetButtonActiveStates === 'function') {
        updatePresetButtonActiveStates();
      }
      if (typeof renderPresetCriteriaChips === 'function') {
        renderPresetCriteriaChips();
      }
      
      // Note: demand_share is no longer recalculated from filtered rows
      // It remains as originally calculated from all tracked keywords (global-fixed)
      // Used internally for opportunity score calculation only
      
      // Calculate visibility metrics from filtered subset
      const validRankingRows = filteredRows.filter(
        r => r.best_rank_group !== null && typeof r.best_rank_group === 'number'
      );
      
      let avgPositionUnweighted = null;
      let avgPositionVolumeWeighted = null;
      
      if (validRankingRows.length >= 1) {
        // Unweighted average position
        const sumRanks = validRankingRows.reduce((sum, r) => sum + r.best_rank_group, 0);
        avgPositionUnweighted = sumRanks / validRankingRows.length;
        
        // Demand-weighted average position
        let sumWeightedRanks = 0;
        let sumVolumes = 0;
        
        for (const row of validRankingRows) {
          const vol = (row.search_volume !== null && row.search_volume !== undefined && row.search_volume > 0)
            ? row.search_volume
            : 10; // Fallback
          
          sumWeightedRanks += row.best_rank_group * vol;
          sumVolumes += vol;
        }
        
        if (sumVolumes > 0) {
          avgPositionVolumeWeighted = sumWeightedRanks / sumVolumes;
        }
      }
      
      // Display tracked keyword visibility metrics (DataForSEO only - not part of AIO pillars)
      const visibilityMetricsSection = document.getElementById('ranking-visibility-metrics');
      const avgPositionWeightedEl = document.getElementById('ranking-avg-position-weighted');
      const avgPositionUnweightedEl = document.getElementById('ranking-avg-position-unweighted');
      
      if (visibilityMetricsSection) {
        // Always show the visibility metrics section (it's part of the side-by-side layout)
        visibilityMetricsSection.style.display = 'block';
        if (avgPositionVolumeWeighted !== null && avgPositionVolumeWeighted !== undefined) {
          visibilityMetricsSection.style.display = 'block';
          if (avgPositionWeightedEl) {
            avgPositionWeightedEl.textContent = avgPositionVolumeWeighted.toFixed(2);
          }
          if (avgPositionUnweightedEl && avgPositionUnweighted !== null && avgPositionUnweighted !== undefined) {
            avgPositionUnweightedEl.textContent = avgPositionUnweighted.toFixed(2);
          } else if (avgPositionUnweightedEl) {
            avgPositionUnweightedEl.textContent = '';
          }
        } else {
          visibilityMetricsSection.style.display = 'block';
          if (avgPositionWeightedEl) {
            avgPositionWeightedEl.textContent = '';
            avgPositionWeightedEl.title = 'Not enough valid keywords to calculate.';
          }
          if (avgPositionUnweightedEl) {
            avgPositionUnweightedEl.textContent = '';
            avgPositionUnweightedEl.title = 'Not enough valid keywords to calculate.';
          }
        }
      }
      
      // Update metric pills from filtered data
      updateMetricPills(filteredRows, combinedRows);
      
      // Expand all metric pill details by default
      setTimeout(() => expandAllMetricPillDetails(), 100);

      // Render Keyword Priority Matrix
      const matrixContainer = document.getElementById('ranking-keyword-priority-matrix');
      const matrixSection = document.getElementById('ranking-priority-matrix-section');
      if (matrixContainer && filteredRows.length > 0) {
        if (matrixSection) matrixSection.style.display = 'block';
        renderKeywordPriorityMatrix(filteredRows, matrixContainer, (filter) => {
          // Filter changed - re-render table
          renderRankingAiTab();
        });
      } else if (matrixSection) {
        matrixSection.style.display = 'none';
      }

      // Sort filtered rows
      const sortedRows = sortRankingRows(filteredRows);
      
      // Calculate pagination
      const totalRows = sortedRows.length;
      const rowsPerPage = rankingPaginationState.rowsPerPage === 'all' ? totalRows : rankingPaginationState.rowsPerPage;
      const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
      const currentPage = Math.min(Math.max(1, rankingPaginationState.currentPage), totalPages);
      rankingPaginationState.currentPage = currentPage;
      
      const startIdx = rowsPerPage === 'all' ? 0 : (currentPage - 1) * rowsPerPage;
      const endIdx = rowsPerPage === 'all' ? totalRows : Math.min(startIdx + rowsPerPage, totalRows);
      const paginatedRows = sortedRows.slice(startIdx, endIdx);

      // -------- Fetch optimisation statuses (Phase 2) --------
      if (typeof window.fetchOptimisationStatuses === 'function') {
        await window.fetchOptimisationStatuses(sortedRows);
      }

      // -------- Keyword table --------
      // tbody already declared at top of function, just clear it
      tbody.innerHTML = "";

      if (!sortedRows.length) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = 12; // Updated: 12 columns (Keyword, Segment, Best rank, Search volume, CTR, Impressions (30d), Opportunity score, AI Overview, AI citations, Classic Ranking URL, Page type, SERP features)
        td.className = "ranking-table-empty";
        td.textContent = filteredRows.length === 0 && combinedRows.length > 0
          ? "No rows match the current filters."
          : "No data returned from ranking / AI endpoints.";
        tr.appendChild(td);
        tbody.appendChild(tr);
        
        // Hide pagination when no data
        const paginationControls = document.getElementById("ranking-pagination-controls");
        if (paginationControls) paginationControls.style.display = "none";
        return;
      }

      // Store original index mapping for detail panel
      const originalIndexMap = new Map();
      paginatedRows.forEach((row, idx) => {
        const origIdx = combinedRows.indexOf(row);
        originalIndexMap.set(idx, origIdx >= 0 ? origIdx : idx);
      });

      paginatedRows.forEach((row, index) => {
        try {
        const tr = document.createElement("tr");
        tr.dataset.index = String(originalIndexMap.get(index));

        // Keyword
        const tdKeyword = document.createElement("td");
        tdKeyword.textContent = row.keyword;
        tr.appendChild(tdKeyword);

        // Segment
        const tdSegment = document.createElement("td");
        const segBadge = document.createElement("span");
        const segLower = (row.segment || "").toLowerCase();
        segBadge.className = "ranking-badge " + (
          segLower === "money" ? "ranking-badge--segment-money" :
          segLower === "education" ? "ranking-badge--segment-education" :
          segLower === "brand" ? "ranking-badge--segment-brand" :
          "ranking-badge--segment-general"
        );
        segBadge.textContent = row.segment || "Other";
        tdSegment.appendChild(segBadge);
        tr.appendChild(tdSegment);

        // Best rank with RAG badge
        const tdRank = document.createElement("td");
        if (row.best_rank_group == null) {
          const badge = document.createElement("span");
          badge.className = "ranking-badge-rank ranking-badge-rank--weak";
          badge.textContent = "";
          tdRank.appendChild(badge);
        } else {
          const badge = document.createElement("span");
          let ragClass = "ranking-badge-rank--weak";
          if (row.best_rank_group <= 10) ragClass = "ranking-badge-rank--good";
          else if (row.best_rank_group <= 20) ragClass = "ranking-badge-rank--ok";
          badge.className = `ranking-badge-rank ${ragClass}`;
          badge.textContent = `#${row.best_rank_group}`;
          tdRank.appendChild(badge);
        }
        tr.appendChild(tdRank);

        // Search volume with RAG badge
        const tdVolume = document.createElement("td");
        const volumeBadge = document.createElement("span");
        const searchVolume = row.search_volume;
        // IMPORTANT: Only treat as missing if null/undefined, not if 0 (0 is a valid value)
        if (searchVolume == null || searchVolume === undefined) {
          volumeBadge.className = "ranking-badge-volume ranking-badge-volume--none";
          volumeBadge.textContent = "";
        } else {
          const formatted = searchVolume.toLocaleString();
          let ragClass = "ranking-badge-volume--low";
          let label = "Low";
          if (searchVolume > 200) {
            ragClass = "ranking-badge-volume--high";
            label = "High";
          } else if (searchVolume > 50) {
            ragClass = "ranking-badge-volume--med";
            label = "Med";
          }
          volumeBadge.className = `ranking-badge-volume ${ragClass}`;
          volumeBadge.textContent = `${formatted} ${label}`;
        }
        tdVolume.appendChild(volumeBadge);
        tr.appendChild(tdVolume);

        // CTR (30d) - query-only from queryTotals
        const tdCtr = document.createElement("td");
        const queryTotal = getQueryTotalForKeyword(row.keyword);
        if (queryTotal && queryTotal.impressions > 0 && queryTotal.ctr != null) {
          // queryTotal.ctr is already a percentage (0-100) from API, not a decimal
          const ctrPercent = queryTotal.ctr.toFixed(1);
          tdCtr.textContent = `${ctrPercent}%`;
          tdCtr.style.color = '#1e293b';
          tdCtr.title = `Google Search Console. Query-only (keyword totals across all pages). Last 28 days (matches GSC UI).`;
        } else {
          tdCtr.textContent = "";
          tdCtr.style.color = '#94a3b8';
          tdCtr.title = `No query totals returned for this keyword in the last 28 days.`;
        }
        tr.appendChild(tdCtr);

        // Impressions (28d) - query-only from queryTotals
        const tdImpressions = document.createElement("td");
        if (queryTotal && queryTotal.impressions != null && queryTotal.impressions > 0) {
          tdImpressions.textContent = queryTotal.impressions.toLocaleString();
          tdImpressions.style.color = '#1e293b';
          tdImpressions.title = `Google Search Console. Query-only (keyword totals across all pages). Last 28 days (matches GSC UI).`;
        } else {
          tdImpressions.textContent = "";
          tdImpressions.style.color = '#94a3b8';
          tdImpressions.title = `No query totals returned for this keyword in the last 28 days.`;
        }
        tr.appendChild(tdImpressions);

        // Opportunity Score
        const tdOpportunity = document.createElement("td");
        const oppScore = row.opportunityScore ?? null;
        if (oppScore != null) {
          const oppBadge = document.createElement("span");
          let oppClass = "ranking-badge-opportunity--low";
          if (oppScore >= 70) {
            oppClass = "ranking-badge-opportunity--high";
          } else if (oppScore >= 40) {
            oppClass = "ranking-badge-opportunity--medium";
          }
          oppBadge.className = `ranking-badge-opportunity ${oppClass}`;
          oppBadge.textContent = `${oppScore}/100`;
          tdOpportunity.appendChild(oppBadge);
        } else {
          tdOpportunity.textContent = "";
        }
        tr.appendChild(tdOpportunity);

        // AI Overview
        const tdAi = document.createElement("td");
        const aiBadge = document.createElement("span");
        aiBadge.className =
          "ranking-badge " + (row.has_ai_overview ? "ranking-badge--ai-on" : "ranking-badge--ai-off");
        aiBadge.textContent = row.has_ai_overview ? "On" : "Off";
        tdAi.appendChild(aiBadge);
        tr.appendChild(tdAi);

        // AI citation with RAG badge
        const tdCitation = document.createElement("td");
        const citBadge = document.createElement("span");
        const isCited = row.ai_alan_citations_count > 0;
        const totalCits = row.ai_total_citations || 0;
        const label = isCited
          ? `${row.ai_alan_citations_count}/${totalCits || "?"}`
          : "0";
        citBadge.className = isCited
          ? "ranking-badge-citation ranking-badge-citation--good"
          : "ranking-badge-citation ranking-badge-citation--weak";
        citBadge.textContent = label;
        tdCitation.appendChild(citBadge);
        tr.appendChild(tdCitation);

        // Classic Ranking URL
        const tdUrl = document.createElement("td");
        if (row.best_url) {
          const a = document.createElement("a");
          a.href = row.targetUrl || row.ranking_url || row.best_url || '';
          a.target = "_blank";
          a.rel = "noopener noreferrer";
          a.textContent = row.best_title || row.best_url;
          tdUrl.appendChild(a);
        } else {
          tdUrl.textContent = "";
        }
        tr.appendChild(tdUrl);

        // Page type
        const tdType = document.createElement("td");
        const pageType = row.pageType || "Landing";
        const typeBadge = document.createElement("span");
        // Use similar styling to Money Pages matrix
        let typeClass = "ranking-badge-page-type";
        if (pageType === "Event") typeClass += " ranking-badge-page-type--event";
        else if (pageType === "Product") typeClass += " ranking-badge-page-type--product";
        else if (pageType === "Blog") typeClass += " ranking-badge-page-type--blog";
        else if (pageType === "GBP") typeClass += " ranking-badge-page-type--gbp";
        else typeClass += " ranking-badge-page-type--landing";
        typeBadge.className = typeClass;
        typeBadge.textContent = pageType;
        tdType.appendChild(typeBadge);
        tr.appendChild(tdType);

        // Optimisation column
        const tdOptimisation = document.createElement("td");
        tdOptimisation.style.position = "relative";
        
        // Ranking & AI tasks are keyword-level tasks, use 'content' task type
        // (not 'on_page' which is for page-level tasks without keywords)
        const taskType = 'content';
        const status = window.getOptimisationStatus(row, taskType);
        
        // Safety check: ensure status object has expected structure
        if (!status || typeof status !== 'object' || !status.status) {
          // Not tracked - show "Not tracked" pill + Track button
          const notTrackedBadge = document.createElement("span");
          notTrackedBadge.className = "ranking-badge ranking-badge--segment-general";
          notTrackedBadge.style.marginRight = "0.5rem";
          notTrackedBadge.textContent = "Not tracked";
          notTrackedBadge.title = "No optimisation task exists for this keyword + URL.";
          tdOptimisation.appendChild(notTrackedBadge);
          
          const trackBtn = document.createElement("button");
          trackBtn.className = "btn btn-small";
          trackBtn.style.padding = "0.15rem 0.4rem";
          trackBtn.style.fontSize = "0.3rem";
          trackBtn.style.fontWeight = "550";
          trackBtn.style.background = "#2563eb";
          trackBtn.style.color = "#ffffff";
          trackBtn.style.border = "1px solid #1e40af";
          trackBtn.textContent = "Track";
          trackBtn.title = "Create a task for this keyword + URL and capture baseline metrics.";
          if (window.isShareMode) {
            trackBtn.disabled = true;
            trackBtn.title = "Not available in share mode (read-only)";
            trackBtn.style.opacity = "0.5";
            trackBtn.style.cursor = "not-allowed";
          } else if (!window.hasAdminKey()) {
            trackBtn.disabled = true;
            trackBtn.title = "Admin key required - set your admin key in the configuration section";
            trackBtn.style.opacity = "0.5";
            trackBtn.style.cursor = "not-allowed";
          }
          trackBtn.onclick = (e) => {
            e.stopPropagation();
            if (window.isShareMode) {
              alert('Write operations are not available in share mode (read-only).');
              return;
            }
            if (!window.hasAdminKey()) {
              alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
              return;
            }
            window.openTrackKeywordModal(row, taskType);
          };
          tdOptimisation.appendChild(trackBtn);
        } else {
          // Tracked - check if status is 'done' or 'cancelled', show Track again button
          // Note: 'deleted' should never appear - if task is deleted, it won't exist in status map
          if (status.status === 'done' || status.status === 'cancelled') {
            // Show status pill + Track again button
            const statusBadge = document.createElement("span");
            statusBadge.className = "ranking-badge ranking-badge--segment-general";
            statusBadge.style.marginRight = "0.5rem";
            const statusLabels = {
              'done': 'Done',
              'cancelled': 'Cancelled'
            };
            statusBadge.textContent = statusLabels[status.status] || status.status;
            const statusTooltips = {
              'done': 'Cycle completed; start a new cycle if optimising again.',
              'cancelled': 'Tracking stopped; you can start a new cycle later.'
            };
            statusBadge.title = statusTooltips[status.status] || 'Click Track again to start a new cycle.';
            tdOptimisation.appendChild(statusBadge);
            
            const trackBtn = document.createElement("button");
            trackBtn.className = "btn btn-small";
            trackBtn.style.padding = "0.03rem 0.08rem";
            trackBtn.style.fontSize = "0.35rem";
            trackBtn.style.fontWeight = "550";
            trackBtn.style.background = "#2563eb";
            trackBtn.style.color = "#ffffff";
            trackBtn.style.border = "1px solid #1e40af";
            trackBtn.textContent = "Track again";
            trackBtn.title = "Start a new cycle for this keyword + URL.";
            if (window.isShareMode) {
              trackBtn.disabled = true;
              trackBtn.title = "Not available in share mode (read-only)";
              trackBtn.style.opacity = "0.5";
              trackBtn.style.cursor = "not-allowed";
            } else if (!window.hasAdminKey()) {
              trackBtn.disabled = true;
              trackBtn.title = "Admin key required - set your admin key in the configuration section";
              trackBtn.style.opacity = "0.5";
              trackBtn.style.cursor = "not-allowed";
            }
            trackBtn.onclick = (e) => {
              e.stopPropagation();
              if (window.isShareMode) {
                alert('Write operations are not available in share mode (read-only).');
                return;
              }
              if (!window.hasAdminKey()) {
                alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
                return;
              }
              window.openTrackKeywordModal(row, taskType);
            };
            tdOptimisation.appendChild(trackBtn);
            
            tr.appendChild(tdOptimisation);
            tbody.appendChild(tr);
            return; // Exit early, don't show Manage button
          }
          
          // Handle 'deleted' status gracefully (shouldn't happen with hard delete, but safety check)
          if (status.status === 'deleted') {
            // Show "Not tracked" + Track button
            const notTrackedBadge = document.createElement("span");
            notTrackedBadge.className = "ranking-badge ranking-badge--segment-general";
            notTrackedBadge.style.marginRight = "0.5rem";
            notTrackedBadge.textContent = "Not tracked";
            notTrackedBadge.title = "No optimisation task exists for this keyword + URL.";
            tdOptimisation.appendChild(notTrackedBadge);
            
            const trackBtn = document.createElement("button");
            trackBtn.className = "btn btn-small";
            trackBtn.style.padding = "0.03rem 0.08rem";
            trackBtn.style.fontSize = "0.35rem";
            trackBtn.style.fontWeight = "550";
            trackBtn.style.background = "#2563eb";
            trackBtn.style.color = "#ffffff";
            trackBtn.style.border = "1px solid #1e40af";
            trackBtn.textContent = "Track";
            trackBtn.title = "Create a task for this keyword + URL and capture baseline metrics.";
            if (!window.hasAdminKey()) {
              trackBtn.disabled = true;
              trackBtn.title = "Admin key required - set your admin key in the configuration section";
              trackBtn.style.opacity = "0.5";
              trackBtn.style.cursor = "not-allowed";
            }
            trackBtn.onclick = (e) => {
              e.stopPropagation();
              if (!window.hasAdminKey()) {
                alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
                return;
              }
              window.openTrackKeywordModal(row, taskType);
            };
            tdOptimisation.appendChild(trackBtn);
            tr.appendChild(tdOptimisation);
            tbody.appendChild(tr);
            return; // Exit early
          }
          
          // Tracked - show status pill + metadata + Manage button
          console.log('[Optimisation] Creating Manage button for tracked keyword:', row.keyword, 'Status:', status);
          const statusBadge = document.createElement("span");
          const statusText = {
            'planned': 'Planned',
            'in_progress': 'In progress',
            'monitoring': 'Monitoring',
            'done': 'Done',
            'paused': 'Paused',
            'cancelled': 'Cancelled'
          }[status.status] || status.status;
          
          // Distinct color scheme for optimization statuses (different from page type badges)
          statusBadge.className = "ranking-badge";
          
          // Apply status-specific colors
          if (status.status === 'planned') {
            // Light lavender - queued/upcoming
            statusBadge.style.background = "#e9d5ff";
            statusBadge.style.color = "#6b21a8";
          } else if (status.status === 'in_progress') {
            // Orange - active work
            statusBadge.style.background = "#fed7aa";
            statusBadge.style.color = "#9a3412";
          } else if (status.status === 'monitoring') {
            // Blue - watching/observing
            statusBadge.style.background = "#dbeafe";
            statusBadge.style.color = "#1e40af";
          } else if (status.status === 'done') {
            // Green - completed successfully
            statusBadge.style.background = "#dcfce7";
            statusBadge.style.color = "#166534";
          } else if (status.status === 'paused') {
            // Grey - on hold
            statusBadge.style.background = "#e5e7eb";
            statusBadge.style.color = "#374151";
          } else if (status.status === 'cancelled') {
            // Red - stopped/error
            statusBadge.style.background = "#fee2e2";
            statusBadge.style.color = "#991b1b";
          } else {
            // Default grey
            statusBadge.style.background = "#f9fafb";
            statusBadge.style.color = "#4b5563";
          }
          statusBadge.textContent = statusText;
          statusBadge.style.marginRight = "0.5rem";
          
          // Add tooltip based on status
          const statusTooltips = {
            'planned': 'Task created but work not started.',
            'in_progress': 'Currently being worked on.',
            'monitoring': 'Changes shippedmonitor metrics.',
            'done': 'Cycle completed; start a new cycle if optimising again.',
            'paused': 'Tracking stopped; you can start a new cycle later.',
            'cancelled': 'Tracking stopped; you can start a new cycle later.'
          };
          statusBadge.title = statusTooltips[status.status] || `Status: ${statusText}`;
          
          tdOptimisation.appendChild(statusBadge);
          
          // Metadata (cycle + last activity)
          const metadataDiv = document.createElement("div");
          metadataDiv.style.fontSize = "0.7rem";
          metadataDiv.style.color = "#64748b";
          metadataDiv.style.marginTop = "0.25rem";
          metadataDiv.style.marginBottom = "0.25rem";
          
          const cycleText = document.createElement("span");
          cycleText.textContent = `Cycle ${status.cycle_active || 1}`;
          cycleText.style.marginRight = "0.5rem";
          metadataDiv.appendChild(cycleText);
          
          if (status.last_activity_at) {
            const lastActivityText = document.createElement("span");
            const lastActivity = new Date(status.last_activity_at);
            const now = new Date();
            const daysAgo = Math.floor((now - lastActivity) / (1000 * 60 * 60 * 24));
            lastActivityText.textContent = daysAgo === 0 ? "Today" : daysAgo === 1 ? "1 day ago" : `${daysAgo} days ago`;
            metadataDiv.appendChild(lastActivityText);
          }
          
          tdOptimisation.appendChild(metadataDiv);
          
          // Manage button
          const manageBtn = document.createElement("button");
          manageBtn.className = "btn btn-small";
          manageBtn.style.padding = "0.15rem 0.4rem";
          manageBtn.style.fontSize = "0.3rem";
          manageBtn.style.fontWeight = "550";
          manageBtn.style.background = "#E5FFCC";
          manageBtn.style.color = "#000000";
          manageBtn.style.border = "1px solid #a3d977";
          manageBtn.textContent = "Manage";
          manageBtn.title = "Open task details, update status, add notes, record measurements, start new cycle.";
          manageBtn.style.position = "relative";
          manageBtn.style.zIndex = "100";
          manageBtn.style.pointerEvents = "auto";
          manageBtn.type = "button"; // Prevent form submission
          
          // Store status and row data on button for access in handler (closure safety)
          const statusId = status.id;
          const statusObj = status;
          const rowData = row;
          const taskTypeValue = taskType;
          
          console.log('[Optimisation] Setting up Manage button onclick, statusId:', statusId);
          
          if (!window.hasAdminKey()) {
            manageBtn.disabled = true;
            manageBtn.title = "Admin key required - set your admin key in the configuration section";
            manageBtn.style.opacity = "0.5";
            manageBtn.style.cursor = "not-allowed";
          }
          
          // Use onclick - simpler and more reliable
          manageBtn.onclick = async function(e) {
            e.stopPropagation();
            e.preventDefault();
            
            if (!window.hasAdminKey()) {
              alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
              return;
            }
            
            if (!statusId) {
              alert('No task ID found. Please try refreshing the page.');
              return;
            }
            
            // Open the drawer with the status ID
            // The drawer function will handle loading tasks if needed and switching tabs
            if (typeof window.openOptimisationTaskDrawer === 'function') {
              try {
                await window.openOptimisationTaskDrawer(statusId);
              } catch (error) {
                console.error('[Optimisation] Error opening drawer:', error);
                // Fallback to modal
                window.openManageOptimisationModal(rowData, statusObj, taskTypeValue);
              }
            } else {
              // Fallback to modal if drawer function doesn't exist
              window.openManageOptimisationModal(rowData, statusObj, taskTypeValue);
            }
          };
          
          tdOptimisation.appendChild(manageBtn);
        }
        
        tr.appendChild(tdOptimisation);

        tbody.appendChild(tr);
        } catch (error) {
          console.error(`[Ranking Table] Error rendering row ${index} for keyword "${row?.keyword || 'unknown'}":`, error);
          // Continue to next row instead of stopping the loop
        }
      });

      // Update sort indicators
      document.querySelectorAll('.ranking-table th.sortable').forEach(th => {
        th.classList.remove('sort-asc', 'sort-desc');
        if (th.dataset.sort === rankingSortState.column) {
          th.classList.add(`sort-${rankingSortState.direction}`);
        }
      });

      // Update pagination controls
      updatePaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx);
      
      // Re-wire sorting after render completes
      wireRankingSorting();

      // Row click  scorecard panel
      tbody.querySelectorAll("tr").forEach(tr => {
        tr.addEventListener("click", async () => {
          tbody.querySelectorAll("tr").forEach(r => r.classList.remove("ranking-table-row--selected"));
          tr.classList.add("ranking-table-row--selected");
          const idx = Number(tr.dataset.index || "-1");
          if (!Number.isNaN(idx) && combinedRows[idx]) {
            const row = combinedRows[idx];
            // Create unique identifier for selected keyword
            selectedKeywordId = `${row.keyword}|${row.best_url || ''}`;
            debugLog(`[RankingAI Scorecard] Row clicked - keyword: "${row.keyword}", selectedKeywordId: "${selectedKeywordId}"`, 'info');
            await renderKeywordScorecard(row);
          }
        });
      });

      // Competitors (use filtered rows)
      renderRankingAiCompetitors(filteredRows);
      
      // Insights (use all rows for global insights across all tracked keywords)
      renderRankingAiInsights(combinedRows, summary);
    }
    
    function updatePaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx) {
      const paginationControls = document.getElementById("ranking-pagination-controls");
      const paginationInfo = document.getElementById("ranking-pagination-info");
      const pageInfo = document.getElementById("ranking-pagination-page-info");
      const firstBtn = document.getElementById("ranking-pagination-first");
      const prevBtn = document.getElementById("ranking-pagination-prev");
      const nextBtn = document.getElementById("ranking-pagination-next");
      const lastBtn = document.getElementById("ranking-pagination-last");
      const rowsPerPageSelect = document.getElementById("ranking-rows-per-page");
      
      if (!paginationControls) return;
      
      if (totalRows === 0) {
        paginationControls.style.display = "none";
        return;
      }
      
      paginationControls.style.display = "flex";
      
      if (paginationInfo) {
        paginationInfo.textContent = `Showing ${startIdx + 1}-${endIdx} of ${totalRows}`;
      }
      
      if (pageInfo) {
        pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
      }
      
      if (firstBtn) {
        firstBtn.disabled = currentPage === 1;
      }
      if (prevBtn) {
        prevBtn.disabled = currentPage === 1;
      }
      if (nextBtn) {
        nextBtn.disabled = currentPage === totalPages;
      }
      if (lastBtn) {
        lastBtn.disabled = currentPage === totalPages;
      }
      
      if (rowsPerPageSelect) {
        rowsPerPageSelect.value = rankingPaginationState.rowsPerPage;
      }
    }

    /**
     * Render Keyword Scorecard Panel
     * @param {Object} row - Keyword row from combinedRows
     */
    async function renderKeywordScorecard(row) {
      const emptyEl = document.getElementById("ranking-ai-detail-empty");
      const contentEl = document.getElementById("ranking-ai-detail-content");
      if (!emptyEl || !contentEl) return;

      if (!row) {
        emptyEl.hidden = false;
        contentEl.hidden = true;
        emptyEl.textContent = "Select a keyword in the table or a cell in the priority grid to see a detailed scorecard.";
        
        // Hide citations section
        const citationsEmpty = document.getElementById("ranking-ai-citations-empty");
        const citationsContent = document.getElementById("ranking-ai-citations-content");
        if (citationsEmpty) citationsEmpty.hidden = false;
        if (citationsContent) citationsContent.hidden = true;
        
        return;
      }

      const scorecardData = buildKeywordScorecardData(row);
      if (!scorecardData) {
        emptyEl.hidden = false;
        contentEl.hidden = true;
        return;
      }
      
      // Fetch authority context for authority-building block (v1.4)
      const authorityContext = await fetchRankingAiAuthorityContext();
      const authorityPriority = authorityContext?.authorityPriority ?? null;
      const domainStrength = authorityContext?.domainStrength ?? null;

      debugLog(`[RankingAI Scorecard] Rendering scorecard for keyword: "${scorecardData.keyword}"`, 'info');
      debugLog(`[RankingAI Scorecard] Demand: ${scorecardData.demand_level}, Rank: ${scorecardData.rank_bucket_label}, AI: ${scorecardData.ai_status}, Priority: ${scorecardData.priority_level}`, 'info');

      emptyEl.hidden = true;
      contentEl.hidden = false;

      // Apply RAG color class to content element based on priority
      contentEl.classList.remove('scorecard-priority-high', 'scorecard-priority-medium', 'scorecard-priority-low');
      if (scorecardData.priority_level === 'High') {
        contentEl.classList.add('scorecard-priority-high');
      } else if (scorecardData.priority_level === 'Medium') {
        contentEl.classList.add('scorecard-priority-medium');
      } else {
        contentEl.classList.add('scorecard-priority-low');
      }

      // Build HTML for scorecard
      let html = '';

      // Impact & Difficulty summary line (under card header) - RAG color-coded
      const impactLabel = scorecardData.impact_bucket.charAt(0).toUpperCase() + scorecardData.impact_bucket.slice(1);
      const difficultyLabel = scorecardData.difficulty_bucket.charAt(0).toUpperCase() + scorecardData.difficulty_bucket.slice(1);
      const priorityLabel = scorecardData.priority_level;
      
      // RAG colors for each level
      const getRagColor = (level) => {
        const lower = level.toLowerCase();
        if (lower === 'high') return '#ef4444'; // Red
        if (lower === 'medium') return '#f59e0b'; // Amber
        return '#10b981'; // Green (Low)
      };
      
      const impactColor = getRagColor(impactLabel);
      const difficultyColor = getRagColor(difficultyLabel);
      const priorityColor = getRagColor(priorityLabel);
      
      // Opportunity Score (under header title, in same section as Impact/Difficulty/Priority)
      const oppScore = scorecardData.opportunity_score ?? null;
      let oppColor = '#b91c1c'; // Red (Low)
      let oppClass = 'low';
      if (oppScore != null) {
        if (oppScore >= 70) {
          oppColor = '#166534'; // Green (High)
          oppClass = 'high';
        } else if (oppScore >= 40) {
          oppColor = '#92400e'; // Amber (Medium)
          oppClass = 'medium';
        }
      }
      
      html += `<div style="margin-bottom: 1.25rem; padding-bottom: 0.75rem; border-bottom: 1px solid #e5e7eb;">`;
      if (oppScore != null) {
        html += `<p style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: ${oppColor}; line-height: 1.4;">`;
        html += `Keyword opportunity score: <span style="color: ${oppColor};">${oppScore}/100</span>`;
        html += ` <span title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10; Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10; Classic ranking strength (page 1 vs page 2+ and current position).&#10; AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first." style="opacity: 0.6; cursor: help; font-size: 0.875rem;"></span>`;
        html += `</p>`;
      }
      html += `<p style="margin: 0; font-size: 1.1rem; font-weight: 700; color: #1e293b; line-height: 1.4;">`;
      html += `<span>Impact: <span style="color: ${impactColor};">${impactLabel}</span></span>  `;
      html += `<span>Difficulty: <span style="color: ${difficultyColor};">${difficultyLabel}</span></span>  `;
      html += `<span>Priority: <span style="color: ${priorityColor};">${priorityLabel}</span></span>`;
      html += `</p>`;
      
      // Add derived summary sentence
      const summarySentence = generateKeywordSummary(scorecardData);
      html += `<p style="margin: 0.5rem 0 0 0; font-size: 0.875rem; font-weight: 400; color: #64748b; line-height: 1.5;">${summarySentence}</p>`;
      html += `</div>`;

      // Keyword & URL header - Keyword as prominent nameplate
      html += `<div style="margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 2px solid #e5e7eb;">`;
      // Keyword nameplate - large and prominent
      html += `<div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-left: 6px solid #f59e0b; padding: 1.25rem 1.5rem; margin-bottom: 1rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);">`;
      html += `<h4 style="font-size: 1.75rem; font-weight: 800; color: #92400e; margin: 0; letter-spacing: 0.02em; line-height: 1.2;">${scorecardData.keyword}</h4>`;
      html += `</div>`;
      // Use canonical targetUrl for display
      const displayUrl = scorecardData.targetUrl || scorecardData.ranking_url || '';
      if (displayUrl) {
        html += `<p style="margin: 0.25rem 0; font-size: 0.875rem;"><a href="${displayUrl}" target="_blank" rel="noopener noreferrer" style="color: #0284c7; text-decoration: none;">${displayUrl}</a></p>`;
      }
      html += `<div style="display: flex; gap: 1rem; margin-top: 0.5rem; flex-wrap: wrap;">`;
      html += `<span class="ranking-badge ${scorecardData.segment === 'money' ? 'ranking-badge--segment-money' : scorecardData.segment === 'education' ? 'ranking-badge--segment-education' : scorecardData.segment === 'brand' ? 'ranking-badge--segment-brand' : 'ranking-badge--segment-general'}" style="font-size: 0.875rem;">${scorecardData.segment || 'Other'}</span>`;
      html += `<span style="font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">${scorecardData.page_type}</span>`;
      html += `</div>`;
      
      // Grey meta line (under chips)
      const metaParts = [];
      if (row.best_rank_group != null) {
        metaParts.push(`Classic rank: #${row.best_rank_group}`);
      } else {
        metaParts.push("Classic rank: not in top 50");
      }
      if (row.has_ai_overview) {
        const total = row.ai_total_citations || 0;
        const ours = row.ai_alan_citations_count || 0;
        metaParts.push(`AI Overview: present (${ours}/${total || "?"} citations from alanranger.com)`);
      } else {
        metaParts.push("AI Overview: not present");
      }
      const segLabel = row.segment === "money" ? "Money page (commercial intent)" :
                      row.segment === "education" ? "Education content" :
                      row.segment === "brand" ? "Brand query" : "General / other";
      metaParts.push(`Segment: ${segLabel}`);
      html += `<p style="margin: 0.5rem 0 0 0; font-size: 0.875rem; color: #3d3d3d; line-height: 1.6; font-weight: 400;">${metaParts.join("  ")}</p>`;
      html += `</div>`;

      // Priority & Next Actions (moved to top, before Demand and Classic ranking)
      html += `<div class="scorecard-section" style="background: #fcfcfc !important;">`;
      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">Priority & Next Actions</h5>`;
      const priorityBg = scorecardData.priority_level === 'High' ? '#fef2f2' : 
                        scorecardData.priority_level === 'Medium' ? '#fffbeb' : '#f0fdf4';
      const priorityBorder = scorecardData.priority_level === 'High' ? '#ef4444' : 
                            scorecardData.priority_level === 'Medium' ? '#f59e0b' : '#10b981';
      html += `<p style="margin-bottom: 0.75rem; font-size: 0.875rem; color: #3d3d3d; line-height: 1.6; font-weight: 400;">Overall priority: <span style="padding: 0.25rem 0.5rem; border-radius: 4px; font-weight: 600; background: ${priorityBg}; border-left: 3px solid ${priorityBorder}; color: #1e293b;">${scorecardData.priority_level}</span></p>`;
      
      // Authority-building block (v1.4: Domain Strength integration)
      const opportunityScore = scorecardData.opportunity_score ?? 0;
      const currentRank = scorecardData.best_rank_group ?? null;
      const isAuthorityLimited = authorityPriority === 'high' && 
                                 opportunityScore >= 60 && 
                                 (currentRank === null || currentRank > 10);
      
      if (isAuthorityLimited) {
        html += `<div style="margin-bottom: 1rem; padding: 0.75rem; background: #fef3c7; border-left: 3px solid #f59e0b; border-radius: 4px;">`;
        html += `<h6 style="font-size: 0.875rem; font-weight: 600; color: #92400e; margin: 0 0 0.5rem 0;">Authority & external signals</h6>`;
        html += `<ul style="margin: 0; padding-left: 1.25rem; list-style-type: disc; font-size: 0.875rem; line-height: 1.6; color: #3d3d3d; font-weight: 400;">`;
        const domainStrengthScore = domainStrength?.score ?? null;
        const scoreText = domainStrengthScore !== null ? `~${domainStrengthScore.toFixed(1)}` : 'unknown';
        const bandText = domainStrength?.band ?? 'unknown';
        html += `<li style="margin-bottom: 0.25rem;">Overall domain strength is currently ${bandText} (score ${scoreText}).</li>`;
        html += `<li style="margin-bottom: 0.25rem;">For this high-impact keyword on page 2+, focus on authority-building: relevant backlinks, citations, PR, and mentions from trusted sites in the same topic.</li>`;
        html += `</ul>`;
        html += `</div>`;
      } else if (authorityPriority === 'medium' && opportunityScore >= 60 && (currentRank === null || currentRank > 10)) {
        // Medium priority - softer wording
        html += `<div style="margin-bottom: 1rem; padding: 0.75rem; background: #fef3c7; border-left: 3px solid #f59e0b; border-radius: 4px;">`;
        html += `<h6 style="font-size: 0.875rem; font-weight: 600; color: #92400e; margin: 0 0 0.5rem 0;">Authority & external signals</h6>`;
        html += `<ul style="margin: 0; padding-left: 1.25rem; list-style-type: disc; font-size: 0.875rem; line-height: 1.6; color: #1e293b;">`;
        const domainStrengthScore = domainStrength?.score ?? null;
        const scoreText = domainStrengthScore !== null ? `~${domainStrengthScore.toFixed(1)}` : 'unknown';
        html += `<li style="margin-bottom: 0.25rem;">Domain strength is moderate (score ${scoreText}). Also consider authority-building alongside on-page improvements for this high-impact keyword.</li>`;
        html += `</ul>`;
        html += `</div>`;
      }
      
      const actions = generateActionBullets(scorecardData);
      // Always show 3 bullets (function now guarantees 3)
      html += `<ul style="margin: 0; padding-left: 1.5rem; list-style-type: disc; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">`;
      actions.forEach(action => {
        html += `<li style="margin-bottom: 0.5rem; color: #3d3d3d;">${action}</li>`;
      });
      html += `</ul>`;
      html += `</div>`;

      // 1. Target page totals and 2. Classic ranking - side by side with equal height/width/padding
      html += `<div style="display: flex; gap: 1rem; margin-bottom: 1.0rem; align-items: stretch;">`;
      
      // 1. Target page totals (left half) - page-only GSC data
      html += `<div class="scorecard-section" style="flex: 1 1 50%; min-width: 0; display: flex; flex-direction: column; height: 100%;">`;
      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">1. Target page totals (GSC, 28d) <span title="All queries to this page, last 28 days (matches GSC Pages tab with no query filter)." style="opacity: 0.6; cursor: help; font-size: 0.75rem;"></span></h5>`;
      // Display target page URL (clickable) - use canonical targetUrl
      const canonicalUrl = scorecardData.targetUrl || scorecardData.ranking_url || '';
      if (canonicalUrl) {
        // URL is already canonicalized, just use it directly
        const cleanUrl = canonicalUrl;
        html += `<div style="margin-bottom: 0.75rem; padding-left: 0.75rem;">`;
        html += `<div style="font-size: 0.8125rem; color: #64748b; margin-bottom: 0.25rem;">Target page (all queries):</div>`;
        html += `<a href="${canonicalUrl}" target="_blank" rel="noopener noreferrer" style="font-size: 0.8125rem; color: #2563eb; text-decoration: underline; word-break: break-all; display: inline-block; max-width: 100%;" title="Open target page in new tab">${cleanUrl}</a>`;
        html += `<div style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;" title="Totals for this page across all search queries (not just this keyword)."> Totals for this page across all search queries (not just this keyword).</div>`;
        html += `</div>`;
      }
      html += `<div style="padding-left: 0.75rem;" id="scorecard-page-totals-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}">`;
      html += `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">Loading page totals...</div>`;
      html += `</div></div>`;

      // 2. Classic ranking (right half)
      html += `<div class="scorecard-section" style="flex: 1 1 50%; min-width: 0; display: flex; flex-direction: column; height: 100%;">`;
      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">2. Classic ranking</h5>`;
      html += `<div style="padding-left: 0.75rem;">`;
      let rankText = '';
      if (scorecardData.best_rank_group != null) {
        const rankBucket = scorecardData.rank_bucket || scorecardData.rank_bucket_label || '';
        // Format: "Currently ranking #24 (page 2+ / Not ranked)"
        if (rankBucket === 'top3' || rankBucket === 'page 1') {
          rankText = `Currently ranking #${scorecardData.best_rank_group} (page 1)`;
        } else if (rankBucket === 'top10' || rankBucket === 'page 1') {
          rankText = `Currently ranking #${scorecardData.best_rank_group} (page 1)`;
        } else if (rankBucket === 'page2plus' || rankBucket === 'beyond page 2') {
          rankText = `Currently ranking #${scorecardData.best_rank_group} (page 2+)`;
        } else {
          rankText = `Currently ranking #${scorecardData.best_rank_group} (${rankBucket || 'beyond page 2'})`;
        }
      } else {
        rankText = 'Currently ranking (beyond page 2 / Not ranked)';
      }
      html += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.8125rem; line-height: 1.5; color: #1e293b; font-weight: 400;">${rankText}</div>`;
      const strengthClass = scorecardData.position_strength === 'Strong' ? 'status-green' : 
                         scorecardData.position_strength === 'OK' ? 'status-amber' : 'status-red';
      const strengthBg = scorecardData.position_strength === 'Strong' ? '#f0fdf4' : 
                        scorecardData.position_strength === 'OK' ? '#fffbeb' : '#fef2f2';
      const strengthBorder = scorecardData.position_strength === 'Strong' ? '#10b981' : 
                            scorecardData.position_strength === 'OK' ? '#f59e0b' : '#ef4444';
      html += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.5; color: #3d3d3d; font-weight: 400;">Position strength: <span style="padding: 0.25rem 0.5rem; border-radius: 4px; font-weight: 600; background: ${strengthBg}; border-left: 3px solid ${strengthBorder}; color: #1e293b;">${scorecardData.position_strength}</span></div>`;
      html += `</div></div>`;
      
      html += `</div>`; // Close flex container

      // 3. CTR & snippet (query-only)
      html += `<div class="scorecard-section">`;
      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">3. CTR & snippet (GSC, 28d) <span title="Query-only totals for this keyword (matches GSC Queries tab)." style="opacity: 0.6; cursor: help; font-size: 0.75rem;"></span></h5>`;
      html += `<div style="padding-left: 0.75rem;">`;
      
      // Get query-only totals from queryTotals
      const queryTotal = getQueryTotalForKeyword(scorecardData.keyword);
      
      // Only show CTR if impressions > 0 (CTR requires impressions)
      if (queryTotal && queryTotal.impressions > 0 && queryTotal.ctr != null) {
        // Real CTR data available (query-only)
        // queryTotal.ctr is already a percentage (0-100) from API, not a decimal
        const ctrPercent = queryTotal.ctr.toFixed(1);
        const impressionsFormatted = queryTotal.impressions.toLocaleString();
        const clicksFormatted = queryTotal.clicks.toLocaleString();
        const positionBucket = getPositionBucket(scorecardData.best_rank_group);
        const ctrBenchmark = getCtrBenchmarkForPosition(positionBucket);
        const benchmarkPercent = (ctrBenchmark * 100).toFixed(1);
        
        // Determine CTR performance label
        let ctrPerformance = 'OK';
        let ctrPerformanceColor = '#f59e0b'; // Amber
        let ctrPerformanceBg = '#fffbeb';
        if (queryTotal.ctr >= ctrBenchmark * 1.1) {
          ctrPerformance = 'Strong';
          ctrPerformanceColor = '#10b981'; // Green
          ctrPerformanceBg = '#f0fdf4';
        } else if (queryTotal.ctr < ctrBenchmark * 0.8) {
          ctrPerformance = 'Weak';
          ctrPerformanceColor = '#ef4444'; // Red
          ctrPerformanceBg = '#fef2f2';
        }
        
        html += `<div style="margin-bottom: 0.75rem;">`;
        html += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">`;
        html += `<span>CTR (last 28 days): <strong style="color: #1e293b;">${ctrPercent}%</strong></span>`;
        html += `<span></span>`;
        html += `<span>Impressions: <strong style="color: #1e293b;">${impressionsFormatted}</strong></span>`;
        html += `<span></span>`;
        html += `<span>Clicks: <strong style="color: #1e293b;">${clicksFormatted}</strong></span>`;
        html += `<span style="font-size: 0.75rem; color: #64748b;">(query-only)</span>`;
        html += `</div>`;
        html += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">`;
        html += `<span>Expected CTR at this position: <strong style="color: #64748b;">${benchmarkPercent}%</strong> <span title="Heuristic benchmark based on rank position (not from GSC)." style="opacity: 0.6; cursor: help; font-size: 0.75rem;"></span></span>`;
        html += `</div>`;
        html += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.75rem;">`;
        html += `<span style="font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">CTR performance: <span style="padding: 0.25rem 0.5rem; border-radius: 4px; font-weight: 600; background: ${ctrPerformanceBg}; border-left: 3px solid ${ctrPerformanceColor}; color: #1e293b;">${ctrPerformance}</span></span>`;
        html += `</div>`;
        html += `</div>`;
        
        // Explanatory text based on performance
        if (ctrPerformance === 'Weak') {
          html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">CTR is weak for this position. Improving the snippet (title, meta description and rich results) should unlock more clicks for this keyword.</p>`;
        } else if (ctrPerformance === 'Strong') {
          html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">CTR is in line with expectations for this position. Further gains are more likely to come from improving rank (links and authority) than snippet tweaks alone.</p>`;
        } else {
          // OK performance
          html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">CTR is in line with expectations for this position. Further gains are more likely to come from improving rank (links and authority) than snippet tweaks alone.</p>`;
        }
      } else {
        // No query-only data found for last 28 days
        html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">No query-only totals returned for this keyword in the last 28 days.</p>`;
      }
      html += `</div></div>`;
      
      // Advanced: Pages with impressions for this keyword (querypages breakdown)
      html += `<div class="scorecard-section" style="margin-top: 1rem;">`;
      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">Advanced: Pages with impressions for this keyword (GSC) <span title="Pages with impressions for this keyword (GSC querypages breakdown)." style="opacity: 0.6; cursor: help; font-size: 0.75rem;"></span></h5>`;
      html += `<div style="padding-left: 0.75rem;" id="scorecard-query-pages-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}">`;
      html += `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">Loading pages breakdown...</div>`;
      html += `</div></div>`;

      // 4. Schema & rich results
      html += `<div class="scorecard-section" data-scorecard-section="schema">`;
      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">4. Schema & rich results</h5>`;
      html += `<div style="padding-left: 0.75rem;">`;
      
      // Get schema coverage if available
      // Try to use the async getSchemaCoverageForUrl function which handles Supabase fallback
      let schemaCoverage = null;
      let schemaSummary = null;
      try {
        // First try sync (localStorage) for immediate display
        const savedAudit = loadAuditResultsSync();
        if (savedAudit && savedAudit.schemaAudit && savedAudit.schemaAudit.data) {
          const schemaData = savedAudit.schemaAudit.data;
          // Lightweight debug for the object used in this card
          try {
            const pagesWithSchemaCount = Array.isArray(schemaData.pagesWithSchema)
              ? schemaData.pagesWithSchema.length
              : (typeof schemaData.pagesWithSchema === 'number' ? schemaData.pagesWithSchema : 0);
            const totalPagesCount = typeof schemaData.totalPages === 'number'
              ? schemaData.totalPages
              : (Array.isArray(schemaData.pages) ? schemaData.pages.length : 0);
            const coveragePct = (typeof schemaData.coverage === 'number' && !Number.isNaN(schemaData.coverage))
              ? schemaData.coverage
              : (totalPagesCount > 0 ? (pagesWithSchemaCount / totalPagesCount) * 100 : 0);

            const allTypes = new Set();
            if (Array.isArray(schemaData.allDetectedTypes)) {
              schemaData.allDetectedTypes.forEach(t => t && allTypes.add(t));
            } else if (Array.isArray(schemaData.schemaTypes)) {
              schemaData.schemaTypes.forEach(item => {
                if (typeof item === 'string') allTypes.add(item);
                else if (item && typeof item === 'object' && item.type) allTypes.add(item.type);
              });
            }

            schemaSummary = {
              pagesWithSchemaCount,
              totalPagesCount,
              coveragePct,
              uniqueTypesCount: allTypes.size
            };

            debugLog(
              `Ranking&AI schemaAuditForCard: totalPages=${totalPagesCount}, pagesWithSchema=${pagesWithSchemaCount}, coverage=${coveragePct.toFixed(1)}%, uniqueTypes=${allTypes.size}`,
              'info'
            );
          } catch (e) {
            // Ignore summary extraction errors; per-page logic may still work
          }
          
          // PRIORITY: Check pages first (original array from schema audit API - most reliable)
          // Then check pagesWithSchema ONLY if it's an array (from Supabase schema_pages_detail)
          // Note: pagesWithSchema might be a number (count) instead of an array
          let pagesArray = null;
          if (Array.isArray(schemaData.pages) && schemaData.pages.length > 0) {
            pagesArray = schemaData.pages;
            debugLog('[Schema Coverage] Using schemaData.pages array (' + pagesArray.length + ' pages)', 'info');
          } else if (Array.isArray(schemaData.pagesWithSchema) && schemaData.pagesWithSchema.length > 0) {
            pagesArray = schemaData.pagesWithSchema;
            debugLog('[Schema Coverage] Using schemaData.pagesWithSchema array from Supabase (' + pagesArray.length + ' pages)', 'info');
          } else {
            debugLog('[Schema Coverage] No pages array found. pages=' + typeof schemaData.pages + ' (isArray=' + Array.isArray(schemaData.pages) + '), pagesWithSchema=' + typeof schemaData.pagesWithSchema + ' (isArray=' + Array.isArray(schemaData.pagesWithSchema) + ')', 'warn');
          }
          
          if (pagesArray && pagesArray.length > 0) {
            // Normalize URL: remove query params and trailing slashes for matching
            const rankingUrl = scorecardData.ranking_url || '';
            const normalizedUrl = normalizeUrlForMatching(rankingUrl);
            
            debugLog('[Schema Coverage] Looking for URL: ' + normalizedUrl + ' (original: ' + rankingUrl + ')', 'info');
            
            // Fallback matching: some ranking URLs include redirect/variant slugs (e.g. "121" vs "1-2-1")
            // If exact pathname match fails, compare a "loose" slug that strips non-alphanumerics.
            const normalizeLooseSlug = (pathname) => {
              const p = (pathname || '').toString().toLowerCase().trim();
              const last = p.split('/').filter(Boolean).pop() || '';
              return last.replace(/[^a-z0-9]/g, '');
            };
            const normalizedLoose = normalizeLooseSlug(normalizedUrl);
            
            // Exact matching only - normalize both URLs identically (strips query params, hash, trailing slashes)
            let looseMatchedUrl = null;
            const pageData = pagesArray.find(p => {
              if (!p || !p.url) return false;
              const pNormalized = normalizeUrlForMatching(p.url);
              
              // Exact match after normalization (both URLs stripped of query params, hash, trailing slashes)
              const exactMatch = pNormalized === normalizedUrl;
              
              // For homepage, also check if both are '/' or empty
              const homepageMatch = (normalizedUrl === '/' || normalizedUrl === '') && (pNormalized === '/' || pNormalized === '');
              
              if (exactMatch || homepageMatch) {
                debugLog('[Schema Coverage]  Exact URL match: ' + p.url + ' -> ' + pNormalized + ' (search: ' + normalizedUrl + ')', 'info');
                return true;
              }

              // Fallback: loose slug match (handles minor slug variants)
              if (!exactMatch && normalizedLoose) {
                const pLoose = normalizeLooseSlug(pNormalized);
                if (pLoose && pLoose === normalizedLoose) {
                  looseMatchedUrl = p.url;
                  debugLog('[Schema Coverage]  Loose slug match: ' + p.url + ' -> ' + pNormalized + ' (search: ' + normalizedUrl + ')', 'warn');
                  return true;
                }
              }
              return false;
            });
            
            if (pageData) {
              debugLog('[Schema Coverage]  Found page data for URL: ' + scorecardData.ranking_url, 'info');
              debugLog('[Schema Coverage] Matched page URL: ' + (pageData.url || 'missing'), 'info');
              if (looseMatchedUrl) {
                debugLog('[Schema Coverage] Note: match used loose slug fallback (ranking URL likely redirected or variant slug).', 'warn');
              }
              if (pageData.schemaTypes) {
                const schemaTypes = Array.isArray(pageData.schemaTypes) ? pageData.schemaTypes : [];
                const typeStrings = schemaTypes.map(t => {
                  if (typeof t === 'string') return t.toLowerCase();
                  if (t && typeof t === 'object' && t.type) return String(t.type).toLowerCase();
                  return String(t).toLowerCase();
                });
                const typeDisplay = schemaTypes.map(t => {
                  if (typeof t === 'string') return t;
                  if (t && typeof t === 'object' && t.type) return t.type;
                  return String(t);
                }).join(', ');
                debugLog('[Schema Coverage] Schema types found (' + schemaTypes.length + '): ' + typeDisplay, 'info');
                schemaCoverage = {
                  hasFAQ: typeStrings.some(t => t.includes('faq') || t === 'faqpage'),
                  hasHowTo: typeStrings.some(t => t.includes('howto') || t === 'howto'),
                  hasEvent: typeStrings.some(t => t.includes('event') && !t.includes('product')),
                  hasProduct: typeStrings.some(t => t.includes('product')),
                  hasBreadcrumb: typeStrings.some(t => t.includes('breadcrumb') || t === 'breadcrumblist'),
                  hasImageObject: typeStrings.some(t => t.includes('image') || t === 'imageobject')
                };
                debugLog('[Schema Coverage] Coverage result: ' + JSON.stringify(schemaCoverage), 'info');
              } else {
                debugLog('[Schema Coverage]  Page data found but no schemaTypes property', 'warn');
                debugLog('[Schema Coverage] Page data keys: ' + Object.keys(pageData).join(', '), 'warn');
              }
            } else {
              debugLog('[Schema Coverage]  No page data found for URL: ' + scorecardData.ranking_url, 'warn');
              debugLog('[Schema Coverage] Normalized search URL: ' + normalizedUrl, 'warn');
              if (pagesArray && pagesArray.length > 0) {
                debugLog('[Schema Coverage] Sample URLs in pages array (first 3):', 'warn');
                pagesArray.slice(0, 3).forEach((p, i) => {
                  let pNorm = (p.url || '').toLowerCase().trim();
                  try {
                    const pUrlObj = p.url ? new URL(p.url) : null;
                    if (pUrlObj) {
                      pNorm = pUrlObj.pathname.toLowerCase().replace(/\/$/, '').trim();
                    }
                  } catch (e) {}
                  debugLog(`  ${i + 1}. ${p.url} -> ${pNorm}`, 'warn');
                });
              }
            }
          } else {
            debugLog('[Schema Coverage] No pages array available in schemaData', 'warn');
            debugLog('[Schema Coverage] This usually means the schema audit hasn\'t been run yet, or the data is missing from localStorage/Supabase.', 'info');
          }
        } else {
          debugLog('[Schema Coverage] No schemaAudit.data in saved audit, trying async fetch...', 'warn');
        }
        
        // Always try async fetch to ensure we have the latest schema data
        // This will update the schema section even if sync data was found
        if (typeof getSchemaCoverageForUrl === 'function' && scorecardData.ranking_url) {
          getSchemaCoverageForUrl(scorecardData.ranking_url).then(coverage => {
            // Re-render just the schema section
            const schemaSection = contentEl.querySelector('[data-scorecard-section="schema"]');
            if (schemaSection) {
              let schemaHtml = '';
              schemaHtml += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">4. Schema & rich results</h5>`;
              schemaHtml += `<div style="padding-left: 0.75rem;">`;
              
              if (coverage) {
                schemaHtml += `<div style="margin-bottom: 0.75rem;">`;
                schemaHtml += `<div style="font-size: 0.875rem; color: #1e293b; margin-bottom: 0.5rem; font-weight: 500;">Schema coverage for this page:</div>`;
                schemaHtml += `<div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.875rem; color: #1e293b;">`;
                schemaHtml += `<span>FAQ: ${coverage.hasFAQ ? '' : ''}</span>`;
                schemaHtml += `<span>HowTo: ${coverage.hasHowTo ? '' : ''}</span>`;
                schemaHtml += `<span>Event/Product: ${(coverage.hasEvent || coverage.hasProduct) ? '' : ''}</span>`;
                schemaHtml += `<span>Breadcrumb: ${coverage.hasBreadcrumb ? '' : ''}</span>`;
                schemaHtml += `<span>ImageObject: ${coverage.hasImageObject ? '' : ''}</span>`;
                schemaHtml += `</div></div>`;
                
                let schemaInterpretation = '';
                if (scorecardData.segment && scorecardData.segment.toLowerCase() === 'education' && !coverage.hasFAQ) {
                  schemaInterpretation = 'This education page has no FAQ schema. Adding an FAQ block could help snippet richness for this keyword.';
                } else if ((scorecardData.page_type === 'Event' || scorecardData.page_type === 'Product') && !coverage.hasEvent && !coverage.hasProduct) {
                  schemaInterpretation = 'This looks like a money page but no Event/Product schema was detected. Adding Event or Product schema could improve visibility in commercial results.';
                } else if (coverage.hasFAQ && (coverage.hasEvent || coverage.hasProduct) && coverage.hasBreadcrumb) {
                  schemaInterpretation = 'Core schema types are already present for this page. Further gains are more likely to come from authority/behaviour than new schema types.';
                } else {
                  schemaInterpretation = 'Some schema types are present. Review the Content/Schema pillar for a complete assessment.';
                }
                schemaHtml += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">${schemaInterpretation}</p>`;
                debugLog('[Schema Coverage]  Updated schema section with async data', 'success');
              } else {
                // No coverage data found - show helpful message explaining data coverage gap
                const rankingUrl = scorecardData.ranking_url || 'unknown';
                const normalizedUrl = normalizeUrlForMatching(rankingUrl);
                debugLog(`[Schema Coverage]  No schema audit data found for ranking URL: ${rankingUrl} (normalized: ${normalizedUrl})`, 'warn');
                debugLog(`[Schema Coverage] This usually means the URL wasn't in the last schema crawl. The page may have schema, but it wasn't scanned in the most recent audit.`, 'info');
                schemaHtml += `<p style="color: #1e293b; font-size: 0.8125rem; line-height: 1.6; font-weight: 400;">Schema coverage data not available for this URL. This usually means the URL wasn't included in the last schema crawl. Check the Content/Schema pillar for a full schema audit, or run a new schema audit to include this page.</p>`;
              }
              
              schemaHtml += `</div></div>`;
              schemaSection.innerHTML = schemaHtml;
            }
          }).catch(err => {
            const rankingUrl = scorecardData.ranking_url || 'unknown';
            debugLog(`[Schema Coverage] Async fetch failed for URL ${rankingUrl}: ${err.message}`, 'warn');
            debugLog(`[Schema Coverage] This usually means the URL wasn't in the last schema crawl. The page may have schema, but it wasn't scanned in the most recent audit.`, 'info');
            // Update the loading message to show error
            const schemaSection = contentEl.querySelector('[data-scorecard-section="schema"]');
            if (schemaSection) {
              const loadingMsg = schemaSection.querySelector('[id^="schema-coverage-loading-"]');
              if (loadingMsg) {
                loadingMsg.textContent = 'Unable to load schema coverage. This usually means the URL wasn\'t included in the last schema crawl. Check the Content/Schema pillar for a full schema audit, or run a new schema audit to include this page.';
              }
            }
          });
        }
      } catch (e) {
        debugLog('[Schema Coverage] Error in sync check: ' + e.message, 'warn');
      }
      
      if (schemaCoverage) {
        // Show checklist
        html += `<div style="margin-bottom: 0.75rem;">`;
        html += `<div style="font-size: 0.875rem; color: #3d3d3d; margin-bottom: 0.5rem; font-weight: 500;">Schema coverage for this page:</div>`;
        html += `<div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">`;
        html += `<span>FAQ: ${schemaCoverage.hasFAQ ? '' : ''}</span>`;
        html += `<span>HowTo: ${schemaCoverage.hasHowTo ? '' : ''}</span>`;
        html += `<span>Event/Product: ${(schemaCoverage.hasEvent || schemaCoverage.hasProduct) ? '' : ''}</span>`;
        html += `<span>Breadcrumb: ${schemaCoverage.hasBreadcrumb ? '' : ''}</span>`;
        html += `<span>ImageObject: ${schemaCoverage.hasImageObject ? '' : ''}</span>`;
        html += `</div>`;
        html += `</div>`;
        
        // Interpretation based on schema coverage
        let schemaInterpretation = '';
        if (scorecardData.segment && scorecardData.segment.toLowerCase() === 'education' && !schemaCoverage.hasFAQ) {
          schemaInterpretation = 'This education page has no FAQ schema. Adding an FAQ block could help snippet richness for this keyword.';
        } else if ((scorecardData.page_type === 'Event' || scorecardData.page_type === 'Product') && !schemaCoverage.hasEvent && !schemaCoverage.hasProduct) {
          schemaInterpretation = 'This looks like a money page but no Event/Product schema was detected. Adding Event or Product schema could improve visibility in commercial results.';
        } else if (schemaCoverage.hasFAQ && (schemaCoverage.hasEvent || schemaCoverage.hasProduct) && schemaCoverage.hasBreadcrumb) {
          schemaInterpretation = 'Core schema types are already present for this page. Further gains are more likely to come from authority/behaviour than new schema types.';
        } else {
          schemaInterpretation = 'Some schema types are present. Review the Content/Schema pillar for a complete assessment.';
        }
        html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">${schemaInterpretation}</p>`;
      } else if (schemaSummary && schemaSummary.totalPagesCount > 0) {
        // We have schema audit snapshot, but no per-URL schemaTypes mapping available for this keyword URL
        html += `<div style="margin-bottom: 0.75rem;">`;
        html += `<div style="font-size: 0.875rem; color: #3d3d3d; margin-bottom: 0.5rem; font-weight: 500;">Site-wide schema snapshot (from latest audit):</div>`;
        html += `<div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">`;
        html += `<span>Coverage: <strong>${schemaSummary.coveragePct.toFixed(1)}%</strong></span>`;
        html += `<span></span>`;
        html += `<span>Pages with schema: <strong>${schemaSummary.pagesWithSchemaCount.toLocaleString()}</strong> / ${schemaSummary.totalPagesCount.toLocaleString()}</span>`;
        if (schemaSummary.uniqueTypesCount > 0) {
          html += `<span></span>`;
          html += `<span>Types detected: <strong>${schemaSummary.uniqueTypesCount}</strong></span>`;
        }
        html += `</div>`;
        html += `</div>`;
        html += `<p style="color: #64748b; font-size: 0.875rem; line-height: 1.5;">Per-page schema types arent available for this specific URL in the current snapshot. Run a fresh schema crawl (or include this URL in the crawl set) to get URL-level rich-result flags here.</p>`;
      } else {
        // Show loading state if async fetch is in progress, otherwise show fallback
        // The async fetch will update this section if data is found
        const rankingUrl = scorecardData.ranking_url || 'unknown';
        debugLog(`[Schema Coverage] No schema data found in sync check for URL: ${rankingUrl}. Trying async fetch...`, 'info');
        html += `<p style="color: #64748b; font-size: 0.875rem; line-height: 1.5;" id="schema-coverage-loading-${Date.now()}">Checking schema coverage...</p>`;
      }
      html += `</div></div>`;

      // 5. AI usage
      html += `<div class="scorecard-section">`;
      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">5. AI usage</h5>`;
      html += `<div style="padding-left: 0.75rem;">`;
      
      // Format AI status with citation details
      const aiTotal = row.ai_total_citations || 0;
      const aiOurs = row.ai_alan_citations_count || 0;
      let aiStatusText = '';
      if (row.has_ai_overview) {
        if (aiOurs > 0) {
          aiStatusText = `AI Overview present, cited in ${aiOurs}/${aiTotal} citation${aiTotal !== 1 ? 's' : ''}`;
          if (aiOurs / aiTotal < 0.33) {
            aiStatusText += ' (light)';
          }
        } else {
          aiStatusText = 'AI Overview present, not cited';
        }
      } else {
        aiStatusText = 'AI Overview not present';
      }
      
      html += `<p style="font-size: 0.875rem; color: #3d3d3d; line-height: 1.6; margin-bottom: 0.5rem; font-weight: 400;">${aiStatusText}</p>`;
      
      // Show cited pages list
      if (scorecardData.ai_citations_ours > 0 && scorecardData.ai_alan_citations && scorecardData.ai_alan_citations.length > 0) {
        html += `<div style="font-size: 0.875rem; color: #3d3d3d; margin-bottom: 0.25rem; font-weight: 500;">Your cited pages:</div>`;
        html += `<ul style="margin-top: 0.25rem; padding-left: 1.5rem; font-size: 0.875rem; line-height: 1.6; color: #3d3d3d; font-weight: 400;">`;
        scorecardData.ai_alan_citations.forEach(c => {
          html += `<li><a href="${c.url}" target="_blank" rel="noopener noreferrer" style="color: #0284c7;">${c.title || c.url}</a></li>`;
        });
        html += `</ul>`;
      }
      html += `</div></div>`;

      // 6. SERP features
      html += `<div class="scorecard-section">`;
      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">6. SERP features</h5>`;
      html += `<div style="padding-left: 0.75rem;">`;
      
      // Get SERP feature presence from scorecardData
      const hasAiOverview = scorecardData.ai_overview_present_any === true;
      const hasLocalPack = scorecardData.local_pack_present_any === true;
      const hasPaa = scorecardData.paa_present_any === true;
      const hasFeaturedSnippet = scorecardData.featured_snippet_present_any === true;
      
      // Count features present
      const featuresPresent = [hasAiOverview, hasLocalPack, hasPaa, hasFeaturedSnippet].filter(Boolean).length;
      
      html += `<div style="margin-bottom: 0.75rem;">`;
      html += `<div style="font-size: 0.875rem; color: #1e293b; margin-bottom: 0.5rem; font-weight: 500;">SERP features present for this keyword:</div>`;
      html += `<div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.875rem; color: #1e293b;">`;
      html += `<span>AI Overview: ${hasAiOverview ? '' : ''}</span>`;
      html += `<span>Local pack: ${hasLocalPack ? '' : ''}</span>`;
      html += `<span>People Also Ask: ${hasPaa ? '' : ''}</span>`;
      html += `<span>Featured snippet: ${hasFeaturedSnippet ? '' : ''}</span>`;
      html += `</div>`;
      html += `<div style="margin-top: 0.5rem; font-size: 0.875rem; color: #64748b;">${featuresPresent}/4 features present</div>`;
      html += `</div>`;
      
      // Interpretation based on SERP features
      let serpInterpretation = '';
      if (featuresPresent === 4) {
        serpInterpretation = 'All major SERP features are present for this keyword. This indicates strong competition and multiple opportunities for visibility.';
      } else if (featuresPresent >= 2) {
        serpInterpretation = 'Multiple SERP features are present. Focus on optimizing for the features where you\'re not yet visible.';
      } else if (hasAiOverview && !hasLocalPack && !hasPaa && !hasFeaturedSnippet) {
        serpInterpretation = 'Only AI Overview is present. This keyword may benefit from local optimization (if applicable) or FAQ schema to trigger People Also Ask.';
      } else if (hasLocalPack && !hasAiOverview) {
        serpInterpretation = 'Local pack is present but no AI Overview. This suggests local intent; ensure your local entity is optimized.';
      } else {
        serpInterpretation = 'Few SERP features are present. This keyword may have lower competition or less rich result potential.';
      }
      html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">${serpInterpretation}</p>`;
      html += `</div></div>`;

      // Summary line is now included in the keyword header section above

      // Update the content element - everything is now in one container
      const kwEl = document.getElementById("ranking-ai-detail-keyword");
      if (kwEl) kwEl.innerHTML = html;
      
      // Hide the separate summary element since it's now included in the main HTML
      const sumEl = document.getElementById("ranking-ai-detail-summary");
      if (sumEl) sumEl.style.display = 'none';
      
      // Fetch page totals and querypages breakdown asynchronously
      const pageTotalsEl = document.getElementById(`scorecard-page-totals-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}`);
      const queryPagesEl = document.getElementById(`scorecard-query-pages-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}`);
      
      // Fetch page-only totals for best_url
      if (pageTotalsEl && scorecardData.ranking_url) {
        (async () => {
          try {
            const savedAudit = loadAuditResultsSync();
            const propertyUrl = savedAudit?.propertyUrl || window.lastAuditPropertyUrl || 'https://www.alanranger.com';
            
            // Calculate date range using centralized helper (last 28 days, ending yesterday - matches GSC UI)
            const { startDate, endDate } = getGscDateRange(GSC_WINDOW_DAYS, 2);
            
            // Use canonical targetUrl for GSC page filter
            const pageUrlForGsc = scorecardData.targetUrl || scorecardData.ranking_url || '';
            const response = await fetch(apiUrl(`/api/aigeo/gsc-page-totals?property=${encodeURIComponent(propertyUrl)}&pageUrl=${encodeURIComponent(pageUrlForGsc)}&startDate=${startDate}&endDate=${endDate}`));
            
            if (response.ok) {
              const data = await response.json();
              if (data.status === 'ok' && data.data) {
                const pageData = data.data;
                let pageHtml = '';
                pageHtml += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.5; color: #3d3d3d; font-weight: 400;">`;
                pageHtml += `<span>Clicks: <strong style="color: #1e293b;">${pageData.clicks.toLocaleString()}</strong></span>`;
                pageHtml += `</div>`;
                pageHtml += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.5; color: #3d3d3d; font-weight: 400;">`;
                pageHtml += `<span>Impressions: <strong style="color: #1e293b;">${pageData.impressions.toLocaleString()}</strong></span>`;
                pageHtml += `</div>`;
                pageHtml += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.5; color: #3d3d3d; font-weight: 400;">`;
                pageHtml += `<span>CTR: <strong style="color: #1e293b;">${(pageData.ctr).toFixed(1)}%</strong></span>`;
                pageHtml += `</div>`;
                pageHtml += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.5; color: #3d3d3d; font-weight: 400;">`;
                pageHtml += `<span>Avg position: <strong style="color: #1e293b;">${Math.round(pageData.position)}</strong></span>`;
                pageHtml += `</div>`;
                pageTotalsEl.innerHTML = pageHtml;
              } else {
                pageTotalsEl.innerHTML = `<div style="color: #64748b; font-size: 0.875rem;">No page totals returned for this URL in the last 28 days.</div>`;
              }
            } else {
              pageTotalsEl.innerHTML = `<div style="color: #64748b; font-size: 0.875rem;">Unable to load page totals.</div>`;
            }
          } catch (err) {
            console.error('Error fetching page totals:', err);
            pageTotalsEl.innerHTML = `<div style="color: #64748b; font-size: 0.875rem;">Error loading page totals: ${err.message}</div>`;
          }
        })();
      }
      
      // Fetch querypages breakdown
      if (queryPagesEl) {
        (async () => {
          try {
            const savedAudit = loadAuditResultsSync();
            const propertyUrl = savedAudit?.propertyUrl || window.lastAuditPropertyUrl || 'https://www.alanranger.com';
            
            // Calculate date range using centralized helper (last 28 days, ending yesterday - matches GSC UI)
            const { startDate, endDate } = getGscDateRange(GSC_WINDOW_DAYS, 2);
            
            const response = await fetch(apiUrl(`/api/aigeo/gsc-query-pages?property=${encodeURIComponent(propertyUrl)}&query=${encodeURIComponent(scorecardData.keyword)}&startDate=${startDate}&endDate=${endDate}`));
            
            if (response.ok) {
              const data = await response.json();
              if (data.status === 'ok' && data.data && data.data.pages) {
                const pages = data.data.pages;
                // Use canonical targetUrl for matching
                const bestUrl = scorecardData.targetUrl || scorecardData.ranking_url || '';
                const normalizedBestUrl = bestUrl ? normalizeGscPageUrl(bestUrl) : null;
                
                let pagesHtml = '';
                if (pages.length === 0) {
                  pagesHtml = `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">No pages found with impressions for this keyword.</div>`;
                } else {
                  // Separate best URL from other pages
                  const bestUrlPage = pages.find(page => {
                    const normalizedPageUrl = normalizeGscPageUrl(page.page);
                    return normalizedBestUrl && normalizedPageUrl === normalizedBestUrl;
                  });
                  const otherPages = pages.filter(page => {
                    const normalizedPageUrl = normalizeGscPageUrl(page.page);
                    return !normalizedBestUrl || normalizedPageUrl !== normalizedBestUrl;
                  });
                  
                  const tableId = `query-pages-table-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}`;
                  const collapsedRowsId = `query-pages-collapsed-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}`;
                  
                  pagesHtml += `<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem; margin-top: 0.5rem;" id="${tableId}">`;
                  pagesHtml += `<thead><tr style="border-bottom: 1px solid #e5e7eb;">`;
                  pagesHtml += `<th style="text-align: left; padding: 0.5rem; font-weight: 600; color: #374151;">Page URL</th>`;
                  pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Clicks</th>`;
                  pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Impressions</th>`;
                  pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">CTR</th>`;
                  pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Position</th>`;
                  pagesHtml += `</tr></thead><tbody>`;
                  
                  // Always show best URL row (yellow highlighted)
                  if (bestUrlPage) {
                    pagesHtml += `<tr style="background: #fef3c7; border-left: 3px solid #f59e0b; border-bottom: 1px solid #e5e7eb;">`;
                    pagesHtml += `<td style="padding: 0.5rem; word-break: break-word;">`;
                    pagesHtml += `<strong style="color: #92400e;">${bestUrlPage.page}</strong> <span style="font-size: 0.75rem; color: #64748b;">(DataForSEO best URL)</span>`;
                    pagesHtml += `</td>`;
                    pagesHtml += `<td style="text-align: right; padding: 0.5rem;">${bestUrlPage.clicks.toLocaleString()}</td>`;
                    pagesHtml += `<td style="text-align: right; padding: 0.5rem;">${bestUrlPage.impressions.toLocaleString()}</td>`;
                    pagesHtml += `<td style="text-align: right; padding: 0.5rem;">${(bestUrlPage.ctr).toFixed(1)}%</td>`;
                    pagesHtml += `<td style="text-align: right; padding: 0.5rem;">${Math.round(bestUrlPage.position)}</td>`;
                    pagesHtml += `</tr>`;
                  }
                  
                  // Collapsible section for other pages
                  if (otherPages.length > 0) {
                    pagesHtml += `</tbody></table>`;
                    pagesHtml += `<div style="margin-top: 0.5rem;">`;
                    pagesHtml += `<button onclick="const el = document.getElementById('${collapsedRowsId}'); el.style.display = el.style.display === 'none' ? 'table' : 'none'; this.textContent = el.style.display === 'none' ? 'Show ' + ${otherPages.length} + ' other page' + (${otherPages.length} !== 1 ? 's' : '') : 'Hide other pages';" style="background: #f3f4f6; border: 1px solid #d1d5db; border-radius: 4px; padding: 0.375rem 0.75rem; font-size: 0.875rem; color: #3d3d3d; cursor: pointer; font-weight: 400;">Show ${otherPages.length} other page${otherPages.length !== 1 ? 's' : ''}</button>`;
                    pagesHtml += `</div>`;
                    pagesHtml += `<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem; margin-top: 0.5rem; display: none;" id="${collapsedRowsId}">`;
                    pagesHtml += `<thead><tr style="border-bottom: 1px solid #e5e7eb;">`;
                    pagesHtml += `<th style="text-align: left; padding: 0.5rem; font-weight: 600; color: #374151;">Page URL</th>`;
                    pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Clicks</th>`;
                    pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Impressions</th>`;
                    pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">CTR</th>`;
                    pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Position</th>`;
                    pagesHtml += `</tr></thead><tbody>`;
                    
                    otherPages.forEach(page => {
                      pagesHtml += `<tr style="border-bottom: 1px solid #e5e7eb;">`;
                      pagesHtml += `<td style="padding: 0.5rem; word-break: break-word; color: #3d3d3d;">${page.page}</td>`;
                      pagesHtml += `<td style="text-align: right; padding: 0.5rem; color: #3d3d3d;">${page.clicks.toLocaleString()}</td>`;
                      pagesHtml += `<td style="text-align: right; padding: 0.5rem; color: #3d3d3d;">${page.impressions.toLocaleString()}</td>`;
                      pagesHtml += `<td style="text-align: right; padding: 0.5rem; color: #3d3d3d;">${(page.ctr).toFixed(1)}%</td>`;
                      pagesHtml += `<td style="text-align: right; padding: 0.5rem; color: #3d3d3d;">${Math.round(page.position)}</td>`;
                      pagesHtml += `</tr>`;
                    });
                    
                    pagesHtml += `</tbody></table>`;
                  } else {
                    pagesHtml += `</tbody></table>`;
                  }
                }
                queryPagesEl.innerHTML = pagesHtml;
              } else {
                queryPagesEl.innerHTML = `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">No pages found with impressions for this keyword.</div>`;
              }
            } else {
              queryPagesEl.innerHTML = `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">Unable to load pages breakdown.</div>`;
            }
          } catch (err) {
            console.error('Error fetching querypages breakdown:', err);
            queryPagesEl.innerHTML = `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">Error loading pages breakdown: ${err.message}</div>`;
          }
        })();
      }

      // Update AI citations section in right panel
      const citationsEmpty = document.getElementById("ranking-ai-citations-empty");
      const citationsContent = document.getElementById("ranking-ai-citations-content");
      const ourList = document.getElementById("ranking-ai-detail-our-pages");
      const compTbody = document.getElementById("ranking-ai-detail-competitors-body");

      if (citationsEmpty && citationsContent) {
        citationsEmpty.hidden = true;
        citationsContent.hidden = false;

        if (ourList) {
          ourList.innerHTML = "";
          if (!row.ai_alan_citations || !row.ai_alan_citations.length) {
            const li = document.createElement("li");
            li.textContent = "No alanranger.com citations found for this AI Overview.";
            ourList.appendChild(li);
          } else {
            row.ai_alan_citations.forEach(c => {
              const li = document.createElement("li");
              const a = document.createElement("a");
              a.href = c.url;
              a.target = "_blank";
              a.rel = "noopener noreferrer";
              a.textContent = c.title || c.url;
              li.appendChild(a);
              ourList.appendChild(li);
            });
          }
        }

        if (compTbody) {
          compTbody.innerHTML = "";
          const entries = Object.entries(row.competitor_counts || {}).sort((a, b) => b[1] - a[1]);
          if (!entries.length) {
            const tr = document.createElement("tr");
            const td = document.createElement("td");
            td.colSpan = 5;
            td.style.padding = "1rem 0.75rem";
            td.style.color = "#64748b";
            td.style.fontSize = "0.875rem";
            td.textContent = "No competing domains recorded from AI citations for this keyword.";
            tr.appendChild(td);
            compTbody.appendChild(tr);
          } else {
            const makeDomainHref = (domain) => {
              if (!domain) return null;
              const d = String(domain).trim();
              if (!d) return null;
              if (d.startsWith('http://') || d.startsWith('https://')) return d;
              return `https://${d}`;
            };
            
            // Fetch domain metadata for all domains
            const domainsList = entries.map(([d]) => d);
            (async () => {
              const domainMetadata = await fetchDomainMetadataForDomains(domainsList);
              
              entries.forEach(([domain, count]) => {
                const tr = document.createElement("tr");
                tr.style.borderTop = "1px solid #e2e8f0";

                const normalizedDomain = normalizeDomainForStrength(domain);
                const meta = domainMetadata[normalizedDomain] || { domain_type: 'unmapped', is_competitor: false };

                const tdDomain = document.createElement("td");
                tdDomain.style.padding = "0.5rem 0.4rem";
                tdDomain.style.fontSize = "0.8rem";
                tdDomain.style.wordWrap = "break-word";
                tdDomain.style.overflowWrap = "break-word";
                const domainContainer = document.createElement("div");
                domainContainer.style.display = "flex";
                domainContainer.style.flexDirection = "column";
                domainContainer.style.alignItems = "flex-start";
                domainContainer.style.gap = "0.25rem";
                
                const domainLinkWrapper = document.createElement("div");
                domainLinkWrapper.style.width = "100%";
                const href = makeDomainHref(domain);
                if (href) {
                  const a = document.createElement("a");
                  a.href = href;
                  a.target = "_blank";
                  a.rel = "noopener noreferrer";
                  a.style.color = "#0284c7";
                  a.style.textDecoration = "none";
                  a.style.wordBreak = "break-word";
                  a.style.overflowWrap = "break-word";
                  a.textContent = domain;
                  domainLinkWrapper.appendChild(a);
                } else {
                  domainLinkWrapper.appendChild(document.createTextNode(String(domain || '')));
                }
                domainContainer.appendChild(domainLinkWrapper);

        // Add competitor badge if is_competitor is true - below the domain
        if (meta.is_competitor) {
          const badge = document.createElement("span");
          badge.textContent = "Competitor";
          badge.setAttribute('data-competitor-badge', 'true');
          badge.style.display = "inline-block";
          badge.style.padding = "0.125rem 0.5rem";
          badge.style.fontSize = "0.65rem";
          badge.style.fontWeight = "600";
          badge.style.color = "#dc2626";
          badge.style.backgroundColor = "#fee2e2";
          badge.style.borderRadius = "4px";
          badge.style.border = "1px solid #fecaca";
          badge.style.marginTop = "0.125rem";
          domainContainer.appendChild(badge);
        }

        tdDomain.appendChild(domainContainer);

                const tdCount = document.createElement("td");
                tdCount.style.padding = "0.5rem 0.4rem";
                tdCount.style.textAlign = "center";
                tdCount.style.fontWeight = "700";
                tdCount.style.color = "#1e293b";
                tdCount.style.fontSize = "0.8rem";
                tdCount.textContent = `${count}`;

                const tdRank = document.createElement("td");
                tdRank.style.padding = "0.5rem 0.4rem";
                tdRank.style.textAlign = "right";
                tdRank.style.color = "#64748b";
                tdRank.style.fontSize = "0.8rem";
                tdRank.textContent = "";
                tdRank.dataset.domain = normalizedDomain;

                const tdDomainType = document.createElement("td");
                tdDomainType.style.padding = "0.5rem 0.4rem";
                tdDomainType.style.fontSize = "0.8rem";
                tdDomainType.style.wordWrap = "break-word";
                tdDomainType.style.overflowWrap = "break-word";
                // Show domain type, but hide "unmapped" (show blank instead)
                const displayType = meta.domain_type && meta.domain_type !== 'unmapped' ? meta.domain_type : '';
                tdDomainType.textContent = displayType;
                tdDomainType.style.color = displayType ? '#475569' : '#94a3b8';

                const tdCompetitor = document.createElement("td");
                tdCompetitor.style.padding = "0.5rem 0.4rem";
                tdCompetitor.style.textAlign = "center";
                tdCompetitor.style.fontSize = "0.8rem";
                tdCompetitor.style.minWidth = "80px";
                const competitorCheckbox = document.createElement("input");
                competitorCheckbox.type = "checkbox";
                competitorCheckbox.checked = meta.is_competitor === true;
                competitorCheckbox.style.cursor = "pointer";
                competitorCheckbox.dataset.domain = normalizedDomain;
                
                competitorCheckbox.addEventListener('change', async (e) => {
                  const isCompetitor = e.target.checked;
                  const domain = e.target.dataset.domain;
                  try {
                    const resp = await fetch(apiUrl('/api/domain-strength/update-domain'), {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ domain, is_competitor: isCompetitor })
                    });
                    if (resp.ok) {
                      // Clear cache
                      __domainMetadataCache.delete(domain);
                      // Update badge - find domainContainer first
                      const domainContainer = tdDomain.querySelector('div[style*="flex-direction: column"]') || tdDomain.querySelector('div');
                      let badge = tdDomain.querySelector('span[data-competitor-badge]');
                      if (isCompetitor && !badge && domainContainer) {
                        badge = document.createElement("span");
                        badge.textContent = "Competitor";
                        badge.setAttribute('data-competitor-badge', 'true');
                        badge.style.display = "inline-block";
                        badge.style.padding = "0.125rem 0.5rem";
                        badge.style.fontSize = "0.65rem";
                        badge.style.fontWeight = "600";
                        badge.style.color = "#dc2626";
                        badge.style.backgroundColor = "#fee2e2";
                        badge.style.borderRadius = "4px";
                        badge.style.border = "1px solid #fecaca";
                        badge.style.marginTop = "0.125rem";
                        domainContainer.appendChild(badge);
                      } else if (!isCompetitor && badge) {
                        badge.remove();
                      }
                    } else {
                      // Revert on error
                      e.target.checked = !isCompetitor;
                      alert('Failed to update competitor flag. Please try again.');
                    }
                  } catch (err) {
                    e.target.checked = !isCompetitor;
                    alert('Failed to update competitor flag. Please try again.');
                  }
                });
                
                tdCompetitor.appendChild(competitorCheckbox);

                tr.appendChild(tdDomain);
                tr.appendChild(tdCount);
                tr.appendChild(tdRank);
                tr.appendChild(tdDomainType);
                tr.appendChild(tdCompetitor);
                compTbody.appendChild(tr);
              });
              
              // Fill Domain Rank column AFTER all rows are appended to DOM
              try {
                const selfDomain = typeof getSelfDomainForDomainStrength === "function" ? getSelfDomainForDomainStrength() : "alanranger.com";
                const domains = [
                  selfDomain,
                  ...entries.map(([d]) => d),
                ].map(normalizeDomainForStrength).filter(Boolean);
                const strengthByDomain = await fetchLatestDomainStrengthForDomains(domains);
                const rankCells = compTbody.querySelectorAll("td[data-domain]");
                if (rankCells.length === 0) {
                  debugLog(' No Domain Rank cells found with data-domain attribute in AI Citations table', 'warn');
                } else {
                  debugLog(` Filling Domain Rank for ${rankCells.length} domains in AI Citations table`, 'info');
                }
                rankCells.forEach((cell) => {
                  const d = normalizeDomainForStrength(cell.dataset.domain || "");
                  const strength = strengthByDomain[d] || null;
                  cell.innerHTML = renderDomainRankCellHtml(strength);
                });
              } catch (err) {
                debugLog(` Error filling Domain Rank in AI Citations table: ${err.message}`, 'error');
              }
            })();
          }
        }
      } else if (citationsEmpty) {
        citationsEmpty.hidden = false;
      }
    }

    // Keep renderRankingAiDetail as alias for backward compatibility
    async function renderRankingAiDetail(row) {
      await renderKeywordScorecard(row);
    }

    // ======================
    // Domain Rank (Domain Strength snapshots) for Keyword tables
    // ======================
    const __domainStrengthLatestCache = new Map(); // domain -> { score, band, snapshotDate }
    const __domainMetadataCache = new Map(); // domain -> { domain_type, is_competitor }

    function normalizeDomainForStrength(input) {
      const raw = String(input || "").trim().toLowerCase();
      if (!raw) return "";
      try {
        if (raw.includes("://")) return new URL(raw).hostname.replace(/^www\./, "");
      } catch (e) {
        // ignore
      }
      return raw.replace(/^www\./, "").split("/")[0];
    }

    function renderDomainStrengthBandPillOriginal(band) {
      const label = String(band || "").trim();
      if (!label) return "";
      const key = typeof domainStrengthBandKey === "function" ? domainStrengthBandKey(label) : "na";
      return `<span class="domain-strength-badge domain-strength-badge--${key}">${label}</span>`;
    }

    function renderDomainRankCellHtml(strength) {
      if (!strength || typeof strength !== "object") {
        return `<span title="No domain strength snapshot yet"></span>`;
      }
      const score = typeof strength.score === "number" && isFinite(strength.score) ? strength.score : null;
      const band = typeof strength.band === "string" ? strength.band : "";
      if (score === null) {
        return `<span title="No domain strength snapshot yet"></span>`;
      }
      const pill = renderDomainStrengthBandPillOriginal(band);
      const scoreRounded = Math.round(score);
      // Left-align numbers in fixed-width container so they line up vertically
      return `<div style="display:flex; justify-content:flex-start; gap:0.25rem; align-items:center;">
        <span style="display:inline-block; width:2.5rem; text-align:left; font-weight:800; color:#0f172a; font-size: 0.8rem;">${scoreRounded}</span>
        ${pill || ""}
      </div>`;
    }

    async function fetchLatestDomainStrengthForDomains(domains) {
      const list = Array.isArray(domains) ? domains.map(normalizeDomainForStrength).filter(Boolean) : [];
      const unique = Array.from(new Set(list)).slice(0, 30);
      if (!unique.length) return {};

      // Serve from cache when available
      const out = {};
      const missing = [];
      for (const d of unique) {
        if (__domainStrengthLatestCache.has(d)) {
          out[d] = __domainStrengthLatestCache.get(d);
        } else {
          missing.push(d);
        }
      }
      if (!missing.length) return out;

      try {
        const qs = encodeURIComponent(missing.join(","));
        const resp = await fetch(apiUrl(`/api/domain-strength/history?domains=${qs}`));
        if (!resp.ok) return out;
        const json = await resp.json();
        const rows = json?.status === "ok" ? (json.data || []) : [];

        // Build latest per domain (google engine only)
        const latestByDomain = {};
        for (const r of rows) {
          const d = normalizeDomainForStrength(r?.domain);
          if (!d) continue;
          if (String(r?.engine || "google").toLowerCase() !== "google") continue;
          const date = String(r?.snapshot_date || "");
          const score = typeof r?.score === "number" ? r.score : parseFloat(r?.score);
          const band = typeof r?.band === "string" ? r.band : "";
          if (!date) continue;
          const prev = latestByDomain[d];
          if (!prev || String(prev.snapshotDate) < date) {
            latestByDomain[d] = { score: isFinite(score) ? score : null, band: band || null, snapshotDate: date };
          }
        }

        for (const d of missing) {
          const v = latestByDomain[d] || { score: null, band: null, snapshotDate: null };
          __domainStrengthLatestCache.set(d, v);
          out[d] = v;
        }
      } catch (e) {
        // fail silently
      }

      return out;
    }

    async function fetchDomainMetadataForDomains(domains) {
      const list = Array.isArray(domains) ? domains.map(normalizeDomainForStrength).filter(Boolean) : [];
      const unique = Array.from(new Set(list));
      if (!unique.length) return {};

      // Serve from cache when available
      const out = {};
      const missing = [];
      for (const d of unique) {
        if (__domainMetadataCache.has(d)) {
          out[d] = __domainMetadataCache.get(d);
        } else {
          missing.push(d);
        }
      }
      if (!missing.length) return out;

      try {
        // Fetch metadata from domain_strength_domains via overview API
        const qs = encodeURIComponent(missing.join(","));
        const resp = await fetch(apiUrl(`/api/domain-strength/overview?domains=${qs}`));
        if (!resp.ok) {
          // If API fails, return defaults
          for (const d of missing) {
            out[d] = { domain_type: 'unmapped', is_competitor: false };
            __domainMetadataCache.set(d, out[d]);
          }
          return out;
        }
        const json = await resp.json();
        const items = json?.status === "ok" ? (json.items || []) : [];

        // Build metadata map
        for (const item of items) {
          const d = normalizeDomainForStrength(item?.domain);
          if (!d) continue;
          const meta = {
            domain_type: item?.domain_type || item?.segment || 'unmapped',
            is_competitor: item?.isCompetitor === true || false
          };
          __domainMetadataCache.set(d, meta);
          out[d] = meta;
        }

        // Fill in missing domains with defaults
        for (const d of missing) {
          if (!out[d]) {
            out[d] = { domain_type: 'unmapped', is_competitor: false };
            __domainMetadataCache.set(d, out[d]);
          }
        }
      } catch (e) {
        // If fetch fails, return defaults
        for (const d of missing) {
          out[d] = { domain_type: 'unmapped', is_competitor: false };
          __domainMetadataCache.set(d, out[d]);
        }
      }

      return out;
    }

    /**
     * Backfill missing Domain Ranks for domains currently showing ""
     * Collects domains from "Other cited domains" table and competitor tables that have missing ranks
     */
    async function backfillMissingDomainRanks() {
      const btn = document.getElementById('backfill-domain-ranks-btn');
      if (!btn) return;
      
      // Disable button and show loading state
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Backfilling...';
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      
      try {
        // Collect domains with missing ranks from "Other cited domains" table
        const compTbody = document.getElementById('ranking-ai-detail-competitors-body');
        const missingDomains = new Set();
        
        if (compTbody) {
          const rankCells = compTbody.querySelectorAll('td[data-domain]');
          rankCells.forEach(cell => {
            // Check if cell shows "" (missing rank)
            const cellText = cell.textContent.trim();
            if (cellText === '' || cellText === '') {
              const domain = cell.dataset.domain;
              if (domain) {
                const normalized = normalizeDomainForStrength(domain);
                if (normalized) {
                  missingDomains.add(normalized);
                }
              }
            }
          });
        }
        
        // Also check competitor tables in main ranking view
        const competitorTbody = document.getElementById('ranking-ai-competitors-body');
        if (competitorTbody) {
          const competitorCells = competitorTbody.querySelectorAll('td[data-domain]');
          competitorCells.forEach(cell => {
            const cellText = cell.textContent.trim();
            if (cellText === '' || cellText === '') {
              const domain = cell.dataset.domain;
              if (domain) {
                const normalized = normalizeDomainForStrength(domain);
                if (normalized) {
                  missingDomains.add(normalized);
                }
              }
            }
          });
        }
        
        const domainsToBackfill = Array.from(missingDomains);
        
        if (domainsToBackfill.length === 0) {
          alert('No domains with missing ranks found. All domains already have Domain Rank values.');
          return;
        }
        
        debugLog(` Backfilling Domain Rank for ${domainsToBackfill.length} domains: ${domainsToBackfill.slice(0, 10).join(', ')}${domainsToBackfill.length > 10 ? '...' : ''}`, 'info');
        
        // Call backfill API
        const adminToken = localStorage.getItem('admin_token') || '';
        const response = await fetch(apiUrl('/api/domain-strength/backfill'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-admin-token': adminToken
          },
          body: JSON.stringify({
            mode: 'list',
            domains: domainsToBackfill,
            maxNewDomains: domainsToBackfill.length,
            dryRun: false,
            source: 'ui-backfill'
          })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Backfill failed: ${errorText}`);
        }
        
        const result = await response.json();
        
        if (result.status === 'ok') {
          debugLog(` Backfill complete: ${result.processed} processed, ${result.skipped_existing} skipped, ${result.errors?.length || 0} errors`, 'success');
          
          // Clear domain strength cache for backfilled domains
          domainsToBackfill.forEach(d => {
            __domainStrengthLatestCache.delete(d);
          });
          
          // Refresh domain rank cells
          if (compTbody) {
            const rankCells = compTbody.querySelectorAll('td[data-domain]');
            const domains = Array.from(rankCells).map(cell => normalizeDomainForStrength(cell.dataset.domain || '')).filter(Boolean);
            if (domains.length > 0) {
              const strengthByDomain = await fetchLatestDomainStrengthForDomains(domains);
              rankCells.forEach(cell => {
                const d = normalizeDomainForStrength(cell.dataset.domain || '');
                const strength = strengthByDomain[d] || null;
                cell.innerHTML = renderDomainRankCellHtml(strength);
              });
            }
          }
          
          // Also refresh competitor table if visible
          if (competitorTbody) {
            const competitorCells = competitorTbody.querySelectorAll('td[data-domain]');
            const competitorDomains = Array.from(competitorCells).map(cell => normalizeDomainForStrength(cell.dataset.domain || '')).filter(Boolean);
            if (competitorDomains.length > 0) {
              const strengthByDomain = await fetchLatestDomainStrengthForDomains(competitorDomains);
              competitorCells.forEach(cell => {
                const d = normalizeDomainForStrength(cell.dataset.domain || '');
                const strength = strengthByDomain[d] || null;
                cell.innerHTML = renderDomainRankCellHtml(strength);
              });
            }
          }
          
          alert(`Domain Rank backfill complete!\n\nProcessed: ${result.processed}\nSkipped (already exist): ${result.skipped_existing}\nErrors: ${result.errors?.length || 0}`);
        } else {
          throw new Error(result.message || 'Backfill failed');
        }
      } catch (err) {
        debugLog(` Domain Rank backfill error: ${err.message}`, 'error');
        alert(`Failed to backfill Domain Ranks: ${err.message}`);
      } finally {
        // Restore button state
        btn.disabled = false;
        btn.textContent = originalText;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
      }
    }

    function renderRankingAiCompetitors(rows) {
      const tbody = document.getElementById("ranking-ai-competitors-body");
      if (!tbody) return;

      tbody.innerHTML = "";
      const aggregate = {};

      rows.forEach(row => {
        Object.entries(row.competitor_counts || {}).forEach(([domain, count]) => {
          aggregate[domain] = (aggregate[domain] || 0) + count;
        });
      });

      const entries = Object.entries(aggregate).sort((a, b) => b[1] - a[1]).slice(0, 8);

        if (!entries.length) {
          const tr = document.createElement("tr");
          const td = document.createElement("td");
            td.colSpan = 5;
            td.style.padding = "1rem 0.75rem";
            td.style.color = "#64748b";
            td.style.fontSize = "0.875rem";
            td.textContent = "No competitor citations recorded across tracked keywords.";
          tr.appendChild(td);
          tbody.appendChild(tr);
          return;
        }

      const makeDomainHref = (domain) => {
        if (!domain) return null;
        const d = String(domain).trim();
        if (!d) return null;
        if (d.startsWith('http://') || d.startsWith('https://')) return d;
        return `https://${d}`;
      };

      // Fetch domain metadata for all domains (async)
      const domainsList = entries.map(([d]) => d);
      (async () => {
        const domainMetadata = await fetchDomainMetadataForDomains(domainsList);

        entries.forEach(([domain, count]) => {
        const tr = document.createElement("tr");
        tr.style.borderTop = "1px solid #e2e8f0";

        const normalizedDomain = normalizeDomainForStrength(domain);
        const meta = domainMetadata[normalizedDomain] || { domain_type: 'unmapped', is_competitor: false };

        const tdDomain = document.createElement("td");
        tdDomain.style.padding = "0.5rem 0.4rem";
        tdDomain.style.fontSize = "0.8rem";
        tdDomain.style.wordWrap = "break-word";
        tdDomain.style.overflowWrap = "break-word";
        const domainContainer = document.createElement("div");
        domainContainer.style.display = "flex";
        domainContainer.style.flexDirection = "column";
        domainContainer.style.alignItems = "flex-start";
        domainContainer.style.gap = "0.25rem";
        
        const domainLinkWrapper = document.createElement("div");
        domainLinkWrapper.style.width = "100%";
        const href = makeDomainHref(domain);
        if (href) {
          const a = document.createElement("a");
          a.href = href;
          a.target = "_blank";
          a.rel = "noopener noreferrer";
          a.style.color = "#0284c7";
          a.style.textDecoration = "none";
          a.style.wordBreak = "break-word";
          a.style.overflowWrap = "break-word";
          a.textContent = domain;
          domainLinkWrapper.appendChild(a);
        } else {
          domainLinkWrapper.appendChild(document.createTextNode(String(domain || '')));
        }
        domainContainer.appendChild(domainLinkWrapper);

        // Add competitor badge if is_competitor is true - below the domain
        if (meta.is_competitor) {
          const badge = document.createElement("span");
          badge.textContent = "Competitor";
          badge.setAttribute('data-competitor-badge', 'true');
          badge.style.display = "inline-block";
          badge.style.padding = "0.125rem 0.5rem";
          badge.style.fontSize = "0.65rem";
          badge.style.fontWeight = "600";
          badge.style.color = "#dc2626";
          badge.style.backgroundColor = "#fee2e2";
          badge.style.borderRadius = "4px";
          badge.style.border = "1px solid #fecaca";
          badge.style.marginTop = "0.125rem";
          domainContainer.appendChild(badge);
        }

        tdDomain.appendChild(domainContainer);

        const tdCount = document.createElement("td");
        tdCount.style.padding = "0.5rem 0.4rem";
        tdCount.style.textAlign = "center";
        tdCount.style.fontWeight = "700";
        tdCount.style.color = "#1e293b";
        tdCount.style.fontSize = "0.8rem";
        tdCount.textContent = `${count}`;

        const tdRank = document.createElement("td");
        tdRank.style.padding = "0.5rem 0.4rem";
        tdRank.style.textAlign = "right";
        tdRank.style.color = "#64748b";
        tdRank.style.fontSize = "0.8rem";
        tdRank.textContent = "";
        tdRank.dataset.domain = normalizedDomain;

        const tdDomainType = document.createElement("td");
        tdDomainType.style.padding = "0.5rem 0.4rem";
        tdDomainType.style.fontSize = "0.8rem";
        tdDomainType.style.wordWrap = "break-word";
        tdDomainType.style.overflowWrap = "break-word";
        // Show domain type, but hide "unmapped" (show blank instead)
        const displayType = meta.domain_type && meta.domain_type !== 'unmapped' ? meta.domain_type : '';
        tdDomainType.textContent = displayType;
        tdDomainType.style.color = displayType ? '#475569' : '#94a3b8';

        const tdCompetitor = document.createElement("td");
        tdCompetitor.style.padding = "0.5rem 0.4rem";
        tdCompetitor.style.textAlign = "center";
        tdCompetitor.style.fontSize = "0.8rem";
        tdCompetitor.style.minWidth = "40px";
        const competitorCheckbox = document.createElement("input");
        competitorCheckbox.type = "checkbox";
        competitorCheckbox.checked = meta.is_competitor === true;
        competitorCheckbox.style.cursor = "pointer";
        competitorCheckbox.dataset.domain = normalizedDomain;
        
        competitorCheckbox.addEventListener('change', async (e) => {
          const isCompetitor = e.target.checked;
          const domain = e.target.dataset.domain;
          try {
            const resp = await fetch(apiUrl('/api/domain-strength/update-domain'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ domain, is_competitor: isCompetitor })
            });
            if (resp.ok) {
              // Clear cache
              __domainMetadataCache.delete(domain);
              // Update badge - find domainContainer first
              const domainContainer = tdDomain.querySelector('div[style*="flex-direction: column"]') || tdDomain.querySelector('div');
              let badge = tdDomain.querySelector('span[data-competitor-badge]');
              if (isCompetitor && !badge && domainContainer) {
                badge = document.createElement("span");
                badge.textContent = "Competitor";
                badge.setAttribute('data-competitor-badge', 'true');
                badge.style.display = "inline-block";
                badge.style.padding = "0.125rem 0.5rem";
                badge.style.fontSize = "0.65rem";
                badge.style.fontWeight = "600";
                badge.style.color = "#dc2626";
                badge.style.backgroundColor = "#fee2e2";
                badge.style.borderRadius = "4px";
                badge.style.border = "1px solid #fecaca";
                badge.style.marginTop = "0.125rem";
                domainContainer.appendChild(badge);
              } else if (!isCompetitor && badge) {
                badge.remove();
              }
            } else {
              // Revert on error
              e.target.checked = !isCompetitor;
              alert('Failed to update competitor flag. Please try again.');
            }
          } catch (err) {
            e.target.checked = !isCompetitor;
            alert('Failed to update competitor flag. Please try again.');
          }
        });
        
        tdCompetitor.appendChild(competitorCheckbox);

        tr.appendChild(tdDomain);
        tr.appendChild(tdCount);
        tr.appendChild(tdRank);
        tr.appendChild(tdDomainType);
        tr.appendChild(tdCompetitor);
        tbody.appendChild(tr);
        });

        // Fill Domain Rank column using latest domain_strength snapshots (read-only)
        try {
          const selfDomain = typeof getSelfDomainForDomainStrength === "function" ? getSelfDomainForDomainStrength() : "alanranger.com";
          const domains = [
            selfDomain,
            ...entries.map(([d]) => d),
          ].map(normalizeDomainForStrength).filter(Boolean);
          const strengthByDomain = await fetchLatestDomainStrengthForDomains(domains);
          tbody.querySelectorAll("td[data-domain]").forEach((cell) => {
            const d = normalizeDomainForStrength(cell.dataset.domain || "");
            const strength = strengthByDomain[d] || null;
            cell.innerHTML = renderDomainRankCellHtml(strength);
          });
        } catch (e) {
          // fail silently
        }
      })();
    }


    function renderRankingAiInsights(rows, summary) {
      const container = document.getElementById("ranking-ai-insights-list-global");
      if (!container) return;

      container.innerHTML = "";
      if (!rows.length) return;

      // Calculate goodRankWithOverviewNoCitation: keywords with good rank (top-10), AI Overview, but no citations
      const goodRankWithOverviewNoCitation = rows.filter(
        r => r.best_rank_group != null && r.best_rank_group <= 10 && r.has_ai_overview && r.ai_alan_citations_count === 0
      ).length;

      // Calculate weakRankWithCitation: keywords with weaker rank (21+), but alanranger.com is cited
      const weakRankWithCitation = rows.filter(
        r => (r.best_rank_group == null || r.best_rank_group > 20) && r.ai_alan_citations_count > 0
      ).length;

      // Create card pills for the two main insights
      if (goodRankWithOverviewNoCitation > 0) {
        const pill = document.createElement("div");
        pill.className = "card-pill";
        pill.innerHTML = `
          <p>
            <strong>[Visibility, Content/Schema]</strong> ${goodRankWithOverviewNoCitation} keyword(s) have strong classic rankings and an AI Overview, but no citations for alanranger.com. Improving snippet-friendly content blocks and structured data on those pages can help convert existing Visibility into AI citations.
          </p>
        `;
        container.appendChild(pill);
      }

      if (weakRankWithCitation > 0) {
        const pill = document.createElement("div");
        pill.className = "card-pill";
        pill.innerHTML = `
          <p>
            <strong>[Authority, Visibility]</strong> ${weakRankWithCitation} keyword(s) already cite your content in AI Overviews despite weaker classic rankings. This indicates strong topical Authority; improving backlinks and on-page optimisation could lift classic Visibility for these terms.
          </p>
        `;
        container.appendChild(pill);
      }

      // Authority priority insight (v1.4: Domain Strength integration)
      const authorityPriority = summary?.authorityPriority ?? null;
      const domainStrength = summary?.domainStrength ?? null;
      
      if (authorityPriority !== null) {
        const pill = document.createElement("div");
        pill.className = "card-pill";
        
        let authorityText = '';
        if (authorityPriority === 'high') {
          authorityText = 'Domain authority: Low. Overall domain strength is limiting how far your pages can climb, especially for high-impact keywords. Treat "authority building" (links, citations, brand searches) as a high-priority task over the next few months.';
        } else if (authorityPriority === 'medium') {
          authorityText = 'Domain authority: Medium. Authority is "good enough" but still a constraint on some high-impact keywords. Mix authority-building with on-page improvements.';
        } else {
          // authorityPriority === 'low'
          authorityText = 'Domain authority: Strong relative to your current scale. Most gains are likely to come from on-page content, snippets, and conversion rather than more links alone.';
        }
        
        pill.innerHTML = `
          <p>
            <strong>[Authority]</strong> ${authorityText}
          </p>
        `;
        container.appendChild(pill);
      }

      // If no insights, show a general message
      if (goodRankWithOverviewNoCitation === 0 && weakRankWithCitation === 0 && authorityPriority === null) {
        const pill = document.createElement("div");
        pill.className = "card-pill";
        pill.innerHTML = `
          <p>
            Current ranking and AI signals are broadly aligned. Focus on incremental improvements to Money-page CTR, schema coverage, and consolidating reviews to keep Authority and Content/Schema strong.
          </p>
        `;
        container.appendChild(pill);
      }
    }

    // Tab switching for sidebar navigation - Optimized for performance (INP)
    (function() {
      // Restore tab state on page load (from sessionStorage or URL hash)
      function restoreTabState() {
        // Check URL hash first (more reliable)
        const hash = window.location.hash;
        if (hash && hash.startsWith('#')) {
          const panelId = hash.substring(1);
          const panel = document.querySelector(`[data-panel="${panelId}"]`);
          if (panel) {
            setActivePanel(panelId);
            ensurePanelRendered(panelId);
            return;
          }
        }
        
        // Fallback to sessionStorage
        const savedTab = sessionStorage.getItem('activeTab');
        if (savedTab) {
          const panel = document.querySelector(`[data-panel="${savedTab}"]`);
          if (panel) {
            setActivePanel(savedTab);
            ensurePanelRendered(savedTab);
            // Update URL hash to match
            window.location.hash = '#' + savedTab;
            return;
          }
        }
      }
      
      // Restore tab state when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', restoreTabState);
      } else {
        // DOM already loaded, restore immediately
        restoreTabState();
      }

      const navItems = document.querySelectorAll(".aigeo-nav-item");

      navItems.forEach(btn => {
        btn.addEventListener("click", () => {
          const panelId = btn.getAttribute("data-panel");
          if (!panelId) return;

          // Store active tab in sessionStorage
          sessionStorage.setItem('activeTab', panelId);
          window.location.hash = '#' + panelId;

          // Fast UI switch first - no heavy work here
          setActivePanel(panelId);

          // Defer heavy work so the click paints immediately
          requestAnimationFrame(() => {
            defer(() => {
              // Try to refresh audit data from Supabase when switching tabs (if data seems stale or missing)
              const propertyUrl = localStorage.getItem('gsc_property_url');
              const savedAudit = loadAuditResultsSync();
              const savedTimestamp = savedAudit?.timestamp;
              const hoursSinceLastAudit = savedTimestamp ? (Date.now() - savedTimestamp) / (1000 * 60 * 60) : Infinity;
              
              // If no data or data is more than 1 hour old, try to refresh from Supabase
              if ((!savedAudit || hoursSinceLastAudit > 1) && propertyUrl) {
                (async () => {
                  debugLog(` Tab switch: Attempting to refresh audit data from Supabase (${hoursSinceLastAudit > 1 ? 'data is stale' : 'no data found'})...`, 'info');
                  try {
                    const freshData = await fetchLatestAuditFromSupabase(propertyUrl);
                    if (freshData && freshData.timestamp) {
                      const freshTimestamp = freshData.timestamp;
                      // Only update if fresh data is newer
                      if (!savedTimestamp || freshTimestamp > savedTimestamp) {
                        safeSetLocalStorage('last_audit_results', freshData);
                        updateAuditTimestamp(freshTimestamp);
                        debugLog(` Tab switch: Refreshed audit data from Supabase (newer timestamp)`, 'success');
                        // Dashboard: refresh live dials/cards if we just pulled newer audit data.
                        if (typeof window.renderDashboardTab === 'function') {
                          try { window.renderDashboardTab(); } catch (e) {}
                        }
                      } else {
                        debugLog(` Tab switch: Supabase data is not newer than cached data`, 'info');
                      }
                    }
                  } catch (error) {
                    debugLog(` Tab switch: Failed to refresh from Supabase: ${error.message}`, 'warn');
                  }
                })();
              }

              // Lazy-render panel content (only first time)
              ensurePanelRendered(panelId);
            });
          });
        });
      });
    })();

      // Function to refresh only GSC queryTotals (CTR/Impressions) without running full audit
      window.refreshGSCDataOnly = async function refreshGSCDataOnly() {
        try {
          debugLog(' Refreshing GSC data only (CTR & Impressions)...', 'info');
          
          const savedAudit = loadAuditResultsSync() || {};
          if (!savedAudit.searchData || typeof savedAudit.searchData !== 'object') {
            savedAudit.searchData = {};
          }

          // CRITICAL: Fetch keywords from Supabase FIRST (source of truth)
          let rankingData = [];
          const propertyUrl = localStorage.getItem('gsc_property_url') || 
                              localStorage.getItem('last_property_url') || 
                              document.getElementById('propertyUrl')?.value || '';
          
          if (propertyUrl) {
            try {
              debugLog(' Fetching keywords from Supabase (source of truth)...', 'info');
              const supabaseResponse = await fetch(apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`));
              if (supabaseResponse.ok) {
                const supabaseData = await supabaseResponse.json();
                if (supabaseData.status === 'ok' && supabaseData.data?.rankingAiData?.combinedRows) {
                  rankingData = supabaseData.data.rankingAiData.combinedRows;
                  debugLog(` Fetched ${rankingData.length} keywords from Supabase`, 'success');
                  // Update localStorage with fresh data
                  try {
                    localStorage.setItem('rankingAiData', JSON.stringify({ combinedRows: rankingData }));
                  } catch (e) {
                    debugLog(` Failed to update localStorage: ${e.message}`, 'warn');
                  }
                }
              }
            } catch (supabaseErr) {
              debugLog(` Failed to fetch keywords from Supabase: ${supabaseErr.message}`, 'warn');
            }
          }
          
          // Fallback 1: Try to get from RankingAiModule state (may have been updated)
          if (!rankingData || rankingData.length === 0) {
            if (window.RankingAiModule && typeof window.RankingAiModule.state === 'function') {
              const state = window.RankingAiModule.state();
              rankingData = state.combinedRows || [];
              if (rankingData.length > 0) {
                debugLog(` Found ${rankingData.length} keywords from RankingAiModule state`, 'info');
              }
            }
          }
          
          // Fallback 2: Try to get from localStorage (check both possible keys)
          if (!rankingData || rankingData.length === 0) {
            try {
              let storedData = localStorage.getItem('rankingAiData'); // Primary key
              if (!storedData) {
                storedData = localStorage.getItem('ranking_ai_data'); // Alternative key
              }
              if (storedData) {
                const parsed = JSON.parse(storedData);
                if (parsed && parsed.combinedRows && Array.isArray(parsed.combinedRows)) {
                  rankingData = parsed.combinedRows;
                  debugLog(` Found ${rankingData.length} keywords from localStorage`, 'info');
                }
              }
            } catch (e) {
              debugLog(` Failed to parse ranking data from localStorage: ${e.message}`, 'warn');
            }
          }
          
          // Fallback 3: Try to get from saved audit's keyword_rankings (localStorage)
          if (!rankingData || rankingData.length === 0) {
            try {
              const savedAudit = loadAuditResultsSync();
              if (savedAudit && savedAudit.keywordRankings && Array.isArray(savedAudit.keywordRankings)) {
                rankingData = savedAudit.keywordRankings;
                debugLog(` Found ${rankingData.length} keywords from saved audit (localStorage)`, 'info');
              }
            } catch (e) {
              debugLog(` Failed to read saved audit from localStorage: ${e.message}`, 'warn');
            }
          }
          
          if (!rankingData || rankingData.length === 0) {
            debugLog(' No ranking keywords found. Please run the ranking scan first.', 'warn');
            alert('No ranking keywords found. Please run the ranking scan first.');
            return;
          }
          
          const allKeywords = rankingData.map(r => r.keyword).filter(k => k && k.trim());
          if (allKeywords.length === 0) {
            debugLog(' No valid keywords found.', 'warn');
            alert('No valid keywords found.');
            return;
          }
          
          debugLog(` Fetching GSC queryTotals for ${allKeywords.length} keywords...`, 'info');
          
          // propertyUrl is already declared at the top of the function (line ~49946)
          if (!propertyUrl) {
            debugLog(' No property URL found.', 'warn');
            alert('No property URL found. Please configure GSC settings first.');
            return;
          }
          
          const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28');
          
          // Fetch queryTotals from GSC API
          const keywordsParam = encodeURIComponent(JSON.stringify(allKeywords));
          const propertyParam = encodeURIComponent(propertyUrl);
          const gscResponse = await fetch(apiUrl(`/api/aigeo/gsc-entity-metrics?property=${propertyParam}&keywords=${keywordsParam}&days=${dateRange}`));
          
          if (!gscResponse.ok) {
            const errorText = await gscResponse.text();
            debugLog(` Failed to fetch queryTotals from GSC: ${gscResponse.status} - ${errorText}`, 'error');
            alert(`Failed to fetch GSC data: ${gscResponse.status}`);
            return;
          }
          
          const gscData = await gscResponse.json();
          if (gscData.status !== 'ok' || !gscData.data || !Array.isArray(gscData.data.queryTotals)) {
            debugLog(` GSC API did not return queryTotals data`, 'warn');
            alert('GSC API did not return queryTotals data.');
            return;
          }
          
          const queryTotals = gscData.data.queryTotals;
          debugLog(` Fetched queryTotals for ${queryTotals.length} keywords from GSC`, 'success');
          
          // Merge queryTotals into searchData
          savedAudit.searchData.queryTotals = queryTotals;
          
          // Use the SAME audit_date as the existing audit
          let auditDate = new Date().toISOString().split('T')[0];
          if (savedAudit.timestamp) {
            try {
              auditDate = new Date(savedAudit.timestamp).toISOString().split('T')[0];
              debugLog(` Using existing audit date for queryTotals: ${auditDate}`, 'info');
            } catch (e) {
              debugLog(` Failed to parse saved audit timestamp, using today's date`, 'warn');
            }
          }
          
          // Save to Supabase
          const saveResponse = await fetch(apiUrl('/api/supabase/save-audit'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              propertyUrl: propertyUrl,
              auditDate: auditDate,
              searchData: savedAudit.searchData
            })
          });
          
          if (!saveResponse.ok) {
            const errorText = await saveResponse.text();
            debugLog(` Failed to save queryTotals to Supabase: ${saveResponse.status} - ${errorText}`, 'error');
            alert(`Failed to save to Supabase: ${saveResponse.status}`);
            return;
          }
          
          debugLog(` Saved queryTotals to Supabase (${queryTotals.length} keywords) for audit_date: ${auditDate}`, 'success');
          
          // Update localStorage
          try {
            safeSetLocalStorage('last_audit_results', savedAudit);
            debugLog(` Updated localStorage with queryTotals`, 'success');
          } catch (localStorageErr) {
            debugLog(` Failed to update localStorage: ${localStorageErr.message}`, 'warn');
          }
          
          // CRITICAL: Reload ranking data from Supabase to get latest search_volume values
          // The UI might be showing old localStorage data that doesn't have search_volume
          debugLog(' Reloading ranking data from Supabase to get latest search_volume...', 'info');
          try {
            const refreshedRankingData = await loadRankingAiDataFromStorage(true); // Force Supabase check
            if (refreshedRankingData && refreshedRankingData.combinedRows) {
              const mod = window.RankingAiModule;
              if (mod && typeof mod.setData === 'function') {
                const normalizedSummary = normalizeSummaryFields(refreshedRankingData.summary);
                mod.setData(refreshedRankingData.combinedRows, normalizedSummary);
                debugLog(` Reloaded ${refreshedRankingData.combinedRows.length} keywords from Supabase with latest search_volume`, 'success');
                
                // Check how many keywords now have search_volume
                const keywordsWithVolume = refreshedRankingData.combinedRows.filter(r => r.search_volume != null && r.search_volume !== undefined).length;
                debugLog(`  Keywords with search_volume: ${keywordsWithVolume}/${refreshedRankingData.combinedRows.length}`, 'info');
              }
            }
          } catch (reloadErr) {
            debugLog(` Failed to reload ranking data from Supabase: ${reloadErr.message}`, 'warn');
            // Continue anyway - at least GSC data was refreshed
          }
          
          // Re-render the table to show updated CTR/Impressions and search_volume
          if (typeof renderRankingAiTab === 'function') {
            renderRankingAiTab();
            debugLog(' Table re-rendered with updated GSC data and search_volume', 'success');
          }
          
          // Update last run timestamp
          updateAuditTimestamp(new Date().toISOString());
          
          debugLog(' GSC data refresh completed successfully!', 'success');
          alert(`Successfully refreshed GSC data for ${queryTotals.length} keywords!`);
          
        } catch (error) {
          debugLog(` Error refreshing GSC data: ${error.message}`, 'error');
          console.error('GSC refresh error:', error);
          alert(`Error refreshing GSC data: ${error.message}`);
        }
      }

      // Manual refresh button for Ranking & AI
      function wireRankingAiButton() {
        const refreshBtn = document.getElementById("ranking-ai-refresh");
        if (refreshBtn) {
          // Remove existing listener by cloning
          const newBtn = refreshBtn.cloneNode(true);
          refreshBtn.parentNode.replaceChild(newBtn, refreshBtn);
          
          newBtn.addEventListener("click", async () => {
            debugLog(' Ranking & AI button clicked', 'info');
            
            // Update UI immediately to show progress
            const lastRunEl = document.getElementById("ranking-ai-last-run");
            if (lastRunEl) {
              lastRunEl.textContent = "Starting...";
            }
            newBtn.disabled = true;
            newBtn.textContent = "Loading";
            
            try {
              if (typeof loadRankingAiData === 'function') {
                debugLog(' Calling loadRankingAiData (local)', 'info');
                await loadRankingAiData(true); // force re-run
              } else if (typeof window.loadRankingAiData === 'function') {
                debugLog(' Calling loadRankingAiData (window)', 'info');
                await window.loadRankingAiData(true); // force re-run
              } else {
                debugLog(' loadRankingAiData function not found', 'error');
                if (lastRunEl) {
                  lastRunEl.textContent = "Error: loadRankingAiData function not found";
                }
                newBtn.disabled = false;
                newBtn.textContent = "Run ranking & AI check";
              }
            } catch (err) {
              debugLog(` Error calling loadRankingAiData: ${err.message}`, 'error');
              console.error('Ranking & AI button error:', err);
              if (lastRunEl) {
                lastRunEl.textContent = `Error: ${err.message}`;
              }
              newBtn.disabled = false;
              newBtn.textContent = "Run ranking & AI check";
            }
          });
          debugLog(' Ranking & AI button wired up', 'success');
        } else {
          debugLog(' Ranking & AI button not found', 'warn');
        }
        
        // Wire up GSC refresh button
        const gscRefreshBtn = document.getElementById("ranking-gsc-refresh");
        if (gscRefreshBtn) {
          // Remove existing listener by cloning
          const newGscBtn = gscRefreshBtn.cloneNode(true);
          gscRefreshBtn.parentNode.replaceChild(newGscBtn, gscRefreshBtn);
          
          newGscBtn.addEventListener("click", async () => {
            debugLog(' GSC refresh button clicked', 'info');
            
            // Update UI immediately to show progress
            const lastRunEl = document.getElementById("ranking-ai-last-run");
            if (lastRunEl) {
              lastRunEl.textContent = "Refreshing GSC data...";
            }
            newGscBtn.disabled = true;
            newGscBtn.textContent = "Refreshing...";
            
            try {
              await window.refreshGSCDataOnly();
            } catch (err) {
              debugLog(` Error refreshing GSC data: ${err.message}`, 'error');
              console.error('GSC refresh button error:', err);
              if (lastRunEl) {
                lastRunEl.textContent = `Error: ${err.message}`;
              }
            } finally {
              newGscBtn.disabled = false;
              newGscBtn.textContent = "Refresh GSC Data";
              if (lastRunEl) {
                const now = new Date();
                const day = String(now.getUTCDate()).padStart(2, '0');
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const month = monthNames[now.getUTCMonth()];
                const year = now.getUTCFullYear();
                const hours = String(now.getUTCHours()).padStart(2, '0');
                const minutes = String(now.getUTCMinutes()).padStart(2, '0');
                const seconds = String(now.getUTCSeconds()).padStart(2, '0');
                lastRunEl.textContent = `Last refreshed: ${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
              }
            }
          });
          debugLog(' GSC refresh button wired up', 'success');
        } else {
          debugLog(' GSC refresh button not found', 'warn');
        }
      }

      // ======================
      // Domain Strength (manual monthly snapshot)
      // ======================
      function getSelfDomainForDomainStrength() {
        const propertyUrl =
          document.getElementById('propertyUrl')?.value ||
          localStorage.getItem('gsc_property_url') ||
          'https://www.alanranger.com';
        try {
          return new URL(propertyUrl).hostname.replace(/^www\./, '');
        } catch (e) {
          return String(propertyUrl).replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0];
        }
      }

      function domainStrengthBandKey(band) {
        const b = String(band || '').trim();
        if (b === 'Very strong') return 'very-strong';
        if (b === 'Strong') return 'strong';
        if (b === 'Moderate') return 'moderate';
        if (b === 'Weak') return 'weak';
        if (b === 'Very weak') return 'very-weak';
        return 'na';
      }

      function renderDomainStrengthBandPill(band) {
        const original = String(band || '');
        const key = domainStrengthBandKey(original);
        // v1.3 UI label mapping: Low / Medium / High / Very High (derived from stored band)
        let label = '';
        if (original === 'Very strong') label = 'Very High';
        else if (original === 'Strong') label = 'High';
        else if (original === 'Moderate') label = 'Medium';
        else if (original === 'Weak' || original === 'Very weak') label = 'Low';
        else label = original;
        return `<span class="domain-strength-badge domain-strength-badge--${key}">${label}</span>`;
      }

      function formatDomainStrengthScore(score) {
        const n = typeof score === 'number' ? score : parseFloat(score);
        if (!isFinite(n)) return '';
        return Number(n).toFixed(1);
      }

      function computeDomainStrengthDelta(sortedAscRows) {
        const list = Array.isArray(sortedAscRows) ? sortedAscRows : [];
        if (list.length < 2) return null;
        const last = list[list.length - 1];
        const lastScore = typeof last?.score === 'number' ? last.score : parseFloat(last?.score);
        if (!isFinite(lastScore)) return null;
        
        // Find the last snapshot with a different score (not just the previous one)
        // This handles cases where multiple snapshots have the same score
        let prevScore = null;
        for (let i = list.length - 2; i >= 0; i--) {
          const prev = list[i];
          const score = typeof prev?.score === 'number' ? prev.score : parseFloat(prev?.score);
          if (isFinite(score) && score !== lastScore) {
            prevScore = score;
            break;
          }
        }
        
        if (prevScore === null) return null;
        return lastScore - prevScore;
      }

      function getDomainStrengthDomainList(maxCompetitors = 20) {
        const domains = [];
        const seen = new Set();
        const self = getSelfDomainForDomainStrength();
        if (self) {
          seen.add(self);
          domains.push(self);
        }

        // Use Ranking AI combined rows as the source of competitor domains
        const mod = window.RankingAiModule;
        const combinedRows = mod?.state?.().combinedRows || [];
        const counts = {};

        for (const row of combinedRows) {
          const cc = row?.competitor_counts;
          if (!cc || typeof cc !== 'object') continue;
          for (const [domain, count] of Object.entries(cc)) {
            const d = String(domain || '').trim().replace(/^www\./, '');
            if (!d || seen.has(d)) continue;
            counts[d] = (counts[d] || 0) + (Number(count) || 0);
          }
        }

        const sorted = Object.entries(counts)
          .sort((a, b) => b[1] - a[1])
          .slice(0, Math.max(0, maxCompetitors))
          .map(([d]) => d);

        for (const d of sorted) {
          if (seen.has(d)) continue;
          seen.add(d);
          domains.push(d);
        }

        return domains;
      }

      const domainStrengthSparklineCharts = new Map();

      function safeDestroyDomainStrengthSparklines() {
        for (const ch of domainStrengthSparklineCharts.values()) {
          try { ch.destroy(); } catch (e) { /* ignore */ }
        }
        domainStrengthSparklineCharts.clear();
      }

      function renderDomainStrengthSparklineChart(canvas, labels, scores) {
        if (!canvas) return;
        if (!window.Chart) {
          canvas.replaceWith(document.createTextNode(''));
          return;
        }
        const id = canvas.id || '';
        const existing = id ? domainStrengthSparklineCharts.get(id) : null;
        if (existing) {
          try { existing.destroy(); } catch (e) { /* ignore */ }
          domainStrengthSparklineCharts.delete(id);
        }

        const pts = Array.isArray(scores) ? scores.map((v) => (typeof v === 'number' ? v : parseFloat(v))).filter((v) => isFinite(v)) : [];
        const labs = Array.isArray(labels) ? labels : [];
        if (pts.length === 0) {
          canvas.replaceWith(document.createTextNode(''));
          return;
        }

        const ctx = canvas.getContext('2d');
        const chart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labs,
            datasets: [{
              data: pts,
              borderColor: '#0284c7',
              backgroundColor: 'rgba(2, 132, 199, 0.15)',
              borderWidth: 2,
              pointRadius: pts.length === 1 ? 2.5 : 0,
              pointHoverRadius: 0,
              fill: false,
              tension: 0.35,
            }]
          },
          options: {
            responsive: false,
            maintainAspectRatio: false,
            animation: false,
            plugins: {
              legend: { display: false },
              tooltip: { enabled: false },
            },
            scales: {
              x: { display: false },
              y: { display: false, min: 0, max: 100 }
            },
            elements: { point: { hitRadius: 0 } }
          }
        });

        if (id) domainStrengthSparklineCharts.set(id, chart);
      }

      async function fetchDomainStrengthOverview() {
        const resp = await fetch(apiUrl('/api/domain-strength/overview'));
        const json = await resp.json();
        return json?.status === 'ok' ? (json.items || []) : [];
      }

      function formatIntegerOrDash(v) {
        const n = typeof v === 'number' ? v : parseFloat(v);
        if (!isFinite(n)) return '';
        return Math.round(n).toLocaleString();
      }

      function formatEtvDollars(v) {
        const n = typeof v === 'number' ? v : parseFloat(v);
        if (!isFinite(n)) return '';
        return '$' + Math.round(n).toLocaleString();
      }

      function formatDelta(delta) {
        if (delta === null || !isFinite(delta)) return '';
        const sign = delta > 0 ? '+' : '';
        return `${sign}${delta.toFixed(1)}`;
      }

      // Domain Strength sorting and pagination state
      let domainStrengthSortState = {
        column: 'name', // Default sort by name (alphabetical)
        direction: 'asc'
      };
      let domainStrengthPaginationState = {
        currentPage: 1,
        rowsPerPage: 10
      };
      let domainStrengthFilterState = {
        segment: null // Show all domains by default
      };
      let domainStrengthExpanded = false; // Collapsed by default

      // Sort domain strength rows
      function sortDomainStrengthRows(rows) {
        const sorted = [...rows];
        sorted.sort((a, b) => {
          let aVal, bVal;
          switch (domainStrengthSortState.column) {
            case 'name':
              aVal = (a?.label || a?.domain || '').toLowerCase();
              bVal = (b?.label || b?.domain || '').toLowerCase();
              break;
            case 'segment':
              aVal = a?.segment || '';
              bVal = b?.segment || '';
              break;
            case 'score':
              const as = a?.latest?.score;
              const bs = b?.latest?.score;
              aVal = typeof as === 'number' ? as : (isFinite(parseFloat(as)) ? parseFloat(as) : -1);
              bVal = typeof bs === 'number' ? bs : (isFinite(parseFloat(bs)) ? parseFloat(bs) : -1);
              break;
            case 'band':
              aVal = a?.latest?.band || '';
              bVal = b?.latest?.band || '';
              break;
            case 'etv':
              aVal = a?.latest?.organicEtv ?? 0;
              bVal = b?.latest?.organicEtv ?? 0;
              break;
            case 'top10':
              aVal = a?.latest?.top10Keywords ?? 0;
              bVal = b?.latest?.top10Keywords ?? 0;
              break;
            case 'change':
              aVal = a?.trend?.deltaLatest ?? -999;
              bVal = b?.trend?.deltaLatest ?? -999;
              break;
            default:
              return 0;
          }
          if (aVal < bVal) return domainStrengthSortState.direction === 'asc' ? -1 : 1;
          if (aVal > bVal) return domainStrengthSortState.direction === 'asc' ? 1 : -1;
          return 0;
        });
        return sorted;
      }

      async function renderDomainStrengthSection() {
        debugLog('[DomainStrength] renderDomainStrengthSection() called', 'info');
        const card = document.getElementById('domain-strength-summary-card');
        const tbody = document.getElementById('domain-strength-table-body');
        if (!tbody || !card) {
          debugLog('[DomainStrength] Missing card or tbody element', 'warn');
          return;
        }

        card.innerHTML = `<div style="color:#64748b; font-size:0.95rem;">Loading domain strength</div>`;
        tbody.innerHTML = '<tr><td colspan="8" class="ranking-table-empty">Loading</td></tr>';

        let items = [];
        try {
          debugLog('[DomainStrength] Fetching domain strength overview...', 'info');
          items = await fetchDomainStrengthOverview();
          debugLog(`[DomainStrength] Fetched ${items.length} items from API`, 'info');
        } catch (e) {
          const msg = e?.message || String(e);
          card.innerHTML = `<div style="color:#b91c1c;">Failed to load: ${msg}</div>`;
          tbody.innerHTML = `<tr><td colspan="8" class="ranking-table-empty">Failed to load: ${msg}</td></tr>`;
          return;
        }

        // v1.3: keep current single-engine view unless you add Bing later
        const engine = 'google';
        items = items.filter((it) => String(it?.searchEngine || '').toLowerCase() === engine);

        if (!items.length) {
          card.innerHTML = `
            <div style="font-weight:700; color:#0f172a; margin-bottom:0.25rem;">Domain Strength</div>
            <div style="color:#64748b; font-size:0.95rem;">No domain strength snapshots yet. Run a snapshot to populate this panel.</div>
          `;
          tbody.innerHTML = '<tr><td colspan="9" class="ranking-table-empty">No domain strength snapshots yet. Click "Run Domain Strength Snapshot".</td></tr>';
          return;
        }

        safeDestroyDomainStrengthSparklines();

        const coerceDomainStrengthDelta = (rawDelta, points) => {
          const deltaNum = (typeof rawDelta === 'number')
            ? rawDelta
            : (rawDelta == null ? null : parseFloat(rawDelta));
          if (deltaNum != null && isFinite(deltaNum)) return deltaNum;
          if (Array.isArray(points) && points.length > 1) {
            const lastPoint = points[points.length - 1];
            const prevPoint = points[points.length - 2];
            const lastScore = parseFloat(lastPoint?.score);
            const prevScore = parseFloat(prevPoint?.score);
            if (isFinite(lastScore) && isFinite(prevScore)) {
              return lastScore - prevScore;
            }
          }
          return null;
        };

        const selfDomain = getSelfDomainForDomainStrength();
        debugLog(`[DomainStrength] Self domain: ${selfDomain}`, 'info');
        
        // Don't filter - show all domains
        // Separate your site from competitors
        const selfItem = items.find((it) => String(it?.domain || '') === selfDomain) || null;
        // Only show domains EXPLICITLY marked as competitors (checkbox checked)
        // isCompetitor must be explicitly true, not just truthy
        const competitorItems = items.filter((it) => {
          const isCompetitor = it?.isCompetitor === true; // Only true, not just truthy
          const isNotSelf = String(it?.domain || '') !== selfDomain;
          return isCompetitor && isNotSelf;
        });
        
        console.log('[DomainStrength] Total items:', items.length, 'Competitors found:', competitorItems.length);
        
        if (selfItem && selfItem.latest) {
          debugLog(`[DomainStrength] Self item found: domain=${selfItem.domain}, score=${selfItem.latest.score}, snapshotDate=${selfItem.latest.snapshotDate}, createdAt=${selfItem.latest.createdAt}`, 'info');
        } else {
          debugLog(`[DomainStrength] Self item NOT found for domain: ${selfDomain}`, 'warn');
        }

        // Quick insight summary (your primary domain)
        if (selfItem && selfItem.latest) {
          const latest = selfItem.latest;
          debugLog(`[DomainStrength] Latest data: score=${latest.score}, snapshotDate=${latest.snapshotDate}, createdAt=${latest.createdAt}`, 'info');
          const selfPoints = Array.isArray(selfItem?.trend?.points) ? selfItem.trend.points : [];
          const delta = coerceDomainStrengthDelta(selfItem?.trend?.deltaLatest, selfPoints);
          if (selfPoints.length) {
            const lastPoint = selfPoints[selfPoints.length - 1];
            const prevPoint = selfPoints.length > 1 ? selfPoints[selfPoints.length - 2] : null;
            debugLog(
              `[DomainStrength] Self delta check: raw=${selfItem?.trend?.deltaLatest}, points=${selfPoints.length}, last=${lastPoint?.score}, prev=${prevPoint?.score}, computed=${delta}`,
              'info'
            );
          }
          const arrow = delta > 0.5 ? '' : (delta < -0.5 ? '' : '');
          const cls = delta > 0.5 ? 'kpi-trend-up' : (delta < -0.5 ? 'kpi-trend-down' : 'kpi-trend-flat');
          const changeText = delta === null ? '' : formatDelta(delta);
          const bandPill = renderDomainStrengthBandPill(latest.band);
          const label = selfItem.label || selfDomain;

          // Format last fetched timestamp (prefer createdAt, fallback to snapshotDate) in GMT
          let lastFetchedText = '';
          const timestampToUse = latest.createdAt || latest.snapshotDate;
          if (timestampToUse) {
            try {
              const timestamp = new Date(timestampToUse);
              if (!isNaN(timestamp.getTime())) {
                // Convert to GMT/UTC
                lastFetchedText = timestamp.toLocaleString('en-GB', {
                  timeZone: 'UTC',
                  year: 'numeric',
                  month: 'short',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                  hour12: false
                }) + ' GMT';
              }
            } catch (e) {
              // If date parsing fails, use raw string
              lastFetchedText = String(timestampToUse);
            }
          }

          card.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.35rem;">
              <div style="font-weight:700; color:#0f172a;">${label}</div>
              <div style="font-size: 0.75rem; color: #64748b; text-align: right;">
                <div style="font-weight: 600; color: #475569; margin-bottom: 0.125rem;">Last Fetched</div>
                <div>${lastFetchedText}</div>
              </div>
            </div>
            <div class="domain-strength-summary-top">
              <div class="domain-strength-summary-score">${formatDomainStrengthScore(latest.score)}</div>
              <div>${bandPill}</div>
            </div>
            <div style="margin-top:0.35rem; font-size:0.95rem;">
              <span class="${cls}" title="Change vs last snapshot: ${changeText}">${arrow} ${delta === null ? 'No previous snapshot data yet' : `${changeText} vs last snapshot`}</span>
            </div>
            <div class="domain-strength-summary-subtitle">
              Domain strength ${formatDomainStrengthScore(latest.score)} on Google  ${delta === null ? 'no previous snapshot yet' : `${changeText} vs last snapshot`};
              ${formatIntegerOrDash(latest.top10Keywords)} top10 keywords and estimated traffic ${formatEtvDollars(latest.organicEtv)}/month.
            </div>
          `;
        } else {
          card.innerHTML = `
            <div style="font-weight:700; color:#0f172a; margin-bottom:0.25rem;">${selfDomain || 'Your site'}</div>
            <div style="color:#64748b; font-size:0.95rem;">No domain strength snapshots yet. Run a snapshot to populate this card.</div>
          `;
        }

        // Sort competitors by strength score (highest to lowest) - ALWAYS by score desc
        // This ensures competitors are shown in order of strength (highest first)
        const sortedCompetitors = [...competitorItems].sort((a, b) => {
          const aScore = typeof a?.latest?.score === 'number' ? a.latest.score : (parseFloat(a?.latest?.score) || 0);
          const bScore = typeof b?.latest?.score === 'number' ? b.latest.score : (parseFloat(b?.latest?.score) || 0);
          return bScore - aScore; // Descending - highest score first
        });
        
        console.log('[DomainStrength] Competitors found:', sortedCompetitors.length, 'sorted by strength score (highest first)');

        // Build final sorted array: your site first, then top competitors
        let sorted = [];
        if (selfItem) {
          sorted.push(selfItem);
        }
        sorted.push(...sortedCompetitors);

        // Calculate pagination
        const totalRows = sorted.length;
        const rowsPerPage = domainStrengthPaginationState.rowsPerPage === 'all' ? totalRows : domainStrengthPaginationState.rowsPerPage;
        const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
        const currentPage = Math.min(Math.max(1, domainStrengthPaginationState.currentPage), totalPages);
        domainStrengthPaginationState.currentPage = currentPage;
        
        const startIdx = rowsPerPage === 'all' ? 0 : (currentPage - 1) * rowsPerPage;
        const endIdx = rowsPerPage === 'all' ? totalRows : Math.min(startIdx + rowsPerPage, totalRows);
        const paginatedRows = sorted.slice(startIdx, endIdx);

        // Determine visible rows based on expand/collapse state
        // Always show your site (first row), then top 2 competitors = 3 rows total
        // If your site is not in paginated rows, show first 3 rows
        const selfRowIndex = paginatedRows.findIndex((it) => String(it?.domain || '') === selfDomain);
        let visibleRows;
        if (domainStrengthExpanded) {
          visibleRows = paginatedRows;
        } else {
          if (selfRowIndex >= 0) {
            // Your site is in the paginated rows
            // Show your site + next 2 rows (competitors)
            visibleRows = paginatedRows.slice(0, Math.min(selfRowIndex + 3, paginatedRows.length));
          } else {
            // Your site not in current page, just show first 3
            visibleRows = paginatedRows.slice(0, 3);
          }
        }
        const hiddenRowsCount = paginatedRows.length - visibleRows.length;

        tbody.innerHTML = '';
        let visibleIndex = 0;
        for (const it of visibleRows) {
          const latest = it?.latest || null;
          const points = Array.isArray(it?.trend?.points) ? it.trend.points : [];
          const delta = coerceDomainStrengthDelta(it?.trend?.deltaLatest, points);
          if (visibleIndex < 3) {
            const lastPoint = points.length ? points[points.length - 1] : null;
            const prevPoint = points.length > 1 ? points[points.length - 2] : null;
            debugLog(
              `[DomainStrength] Row delta check: domain=${it?.domain || ''}, raw=${it?.trend?.deltaLatest}, points=${points.length}, last=${lastPoint?.score}, prev=${prevPoint?.score}, computed=${delta}`,
              'info'
            );
          }
          visibleIndex += 1;
          const last12 = points.slice(-12);
          const labels = last12.map((p) => p.date);
          const scores = last12.map((p) => p.score);

          const safeId = String(it?.domain || '')
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/(^-|-$)/g, '');
          const canvasId = `domain-strength-spark-${safeId || Math.random().toString(36).slice(2)}`;

          const arrow = delta > 0.5 ? '' : (delta < -0.5 ? '' : '');
          const cls = delta > 0.5 ? 'kpi-trend-up' : (delta < -0.5 ? 'kpi-trend-down' : 'kpi-trend-flat');
          const changeTitle = delta === null ? 'No previous snapshot yet' : `Change vs last snapshot: ${formatDelta(delta)}`;

          // Check if this is the self domain row
          const isSelfDomain = String(it?.domain || '') === selfDomain;
          const rowStyle = isSelfDomain ? 'font-weight: 700; background-color: #fefce8;' : '';

          const tr = document.createElement('tr');
          if (isSelfDomain) {
            tr.id = 'domain-strength-self-row';
            tr.style.fontWeight = '700';
            tr.style.backgroundColor = '#fefce8';
          }
          // Create clickable domain link
          const domainName = it?.domain || '';
          const displayName = it?.label || it?.domain || '';
          const domainLink = domainName ? `<a href="https://${domainName}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none; ${isSelfDomain ? 'font-weight: 700;' : ''}" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${displayName}</a>` : displayName;
          
          // Get domain type and competitor flag - use domain_type directly, fallback to segment, only default to 'unmapped' if both are missing
          const domainType = it?.domain_type || it?.segment || 'unmapped';
          const isCompetitor = it?.isCompetitor === true;
          const normalizedDomain = normalizeDomainForStrength(domainName);
          
          tr.innerHTML = `
            <td style="text-align:left; ${isSelfDomain ? 'font-weight: 700;' : ''}">${domainLink}</td>
            <td style="${isSelfDomain ? 'font-weight: 700;' : ''}"><span data-domain-type-display="${normalizedDomain}">${domainType}</span></td>
            <td style="text-align:center; ${isSelfDomain ? 'font-weight: 700;' : ''}">${latest ? formatDomainStrengthScore(latest.score) : ''}</td>
            <td style="${isSelfDomain ? 'font-weight: 700;' : ''}">${latest ? renderDomainStrengthBandPill(latest.band) : ''}</td>
            <td style="text-align:right; white-space: nowrap; ${isSelfDomain ? 'font-weight: 700;' : ''}">${latest ? formatEtvDollars(latest.organicEtv) : ''}</td>
            <td style="text-align:right; white-space: nowrap; ${isSelfDomain ? 'font-weight: 700;' : ''}">${latest ? formatIntegerOrDash(latest.top10Keywords) : ''}</td>
            <td style="text-align:center; ${isSelfDomain ? 'font-weight: 700;' : ''}"><span class="${cls}" title="${changeTitle}">${delta === null ? '' : `${arrow} ${formatDelta(delta)}`}</span></td>
            <td style="text-align:center;">
              <canvas class="domain-strength-sparkline" id="${canvasId}" width="140" height="28" aria-label="12 month score trend"></canvas>
            </td>
            <td style="text-align:center;"></td>
          `;
          tbody.appendChild(tr);
          
          // Add domain type dropdown to the Domain type cell
          const domainTypeCell = tr.querySelector(`td:nth-child(2)`);
          const domainTypeDisplay = domainTypeCell.querySelector(`[data-domain-type-display="${normalizedDomain}"]`);
          if (domainTypeDisplay && domainTypeCell) {
            domainTypeCell.innerHTML = '';
            const domainTypeSelect = document.createElement('select');
            domainTypeSelect.style.padding = '0.4rem 0.6rem';
            domainTypeSelect.style.border = '1px solid #cbd5e1';
            domainTypeSelect.style.borderRadius = '4px';
            domainTypeSelect.style.fontSize = '0.85rem';
            domainTypeSelect.style.background = 'white';
            domainTypeSelect.style.cursor = 'pointer';
            domainTypeSelect.style.minWidth = '120px';
            domainTypeSelect.dataset.domain = normalizedDomain;
            
            const domainTypes = [
              { value: 'unmapped', label: 'Unmapped' },
              { value: 'your_site', label: 'Your site' },
              { value: 'platform', label: 'Platform' },
              { value: 'directory', label: 'Directory' },
              { value: 'publisher', label: 'Publisher' },
              { value: 'vendor', label: 'Vendor' },
              { value: 'institution', label: 'Institution' },
              { value: 'government', label: 'Government' },
              { value: 'site', label: 'Site' }
            ];
            
            // Get the actual domain_type from the data - check both domain_type and segment fields
            let actualDomainType = 'unmapped';
            if (it?.domain_type && typeof it.domain_type === 'string' && it.domain_type.trim()) {
              actualDomainType = it.domain_type.trim();
            } else if (it?.segment && typeof it.segment === 'string' && it.segment.trim()) {
              actualDomainType = it.segment.trim();
            }
            
            // Ensure the value matches one of the valid options
            const validValues = domainTypes.map(dt => dt.value);
            if (!validValues.includes(actualDomainType)) {
              actualDomainType = 'unmapped';
            }
            
            // Create options first, then set the value
            domainTypes.forEach(({ value, label }) => {
              const option = document.createElement('option');
              option.value = value;
              option.textContent = label;
              if (value === actualDomainType) {
                option.selected = true;
              }
              domainTypeSelect.appendChild(option);
            });
            
            // Explicitly set the value after options are added
            domainTypeSelect.value = actualDomainType;
            
            domainTypeSelect.addEventListener('change', async (e) => {
              const newType = e.target.value;
              const domain = e.target.dataset.domain;
              try {
                const resp = await fetch(apiUrl('/api/domain-strength/update-domain'), {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ domain, domain_type: newType })
                });
                if (resp.ok) {
                  __domainMetadataCache.delete(domain);
                  // Refresh the table to show updated values
                  await renderDomainStrengthSection();
                } else {
                  e.target.value = domainType;
                  alert('Failed to update domain type. Please try again.');
                }
              } catch (err) {
                e.target.value = domainType;
                alert('Error updating domain type: ' + err.message);
              }
            });
            
            domainTypeCell.appendChild(domainTypeSelect);
          }
          
          // Add competitor checkbox to the Competitor cell
          const competitorCell = tr.querySelector(`td:nth-child(9)`);
          if (competitorCell) {
            const competitorCheckbox = document.createElement('input');
            competitorCheckbox.type = 'checkbox';
            competitorCheckbox.checked = isCompetitor;
            competitorCheckbox.style.cursor = 'pointer';
            competitorCheckbox.dataset.domain = normalizedDomain;
            
            competitorCheckbox.addEventListener('change', async (e) => {
              const isComp = e.target.checked;
              const domain = e.target.dataset.domain;
              try {
                const resp = await fetch(apiUrl('/api/domain-strength/update-domain'), {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ domain, is_competitor: isComp })
                });
                if (resp.ok) {
                  __domainMetadataCache.delete(domain);
                  // Refresh the table to show updated values
                  await renderDomainStrengthSection();
                } else {
                  e.target.checked = !isComp;
                  alert('Failed to update competitor flag. Please try again.');
                }
              } catch (err) {
                e.target.checked = !isComp;
                alert('Error updating competitor flag: ' + err.message);
              }
            });
            
            competitorCell.appendChild(competitorCheckbox);
          }

          const canvas = document.getElementById(canvasId);
          renderDomainStrengthSparklineChart(canvas, labels, scores);
        }

        // Add expand/collapse row if there are hidden rows
        if (!domainStrengthExpanded && hiddenRowsCount > 0) {
          const expandRow = document.createElement('tr');
          expandRow.id = 'domain-strength-expand-row';
          expandRow.style.cursor = 'pointer';
          expandRow.style.backgroundColor = '#f8fafc';
          expandRow.style.borderTop = '2px solid #e2e8f0';
          expandRow.innerHTML = `
            <td colspan="9" style="text-align: center; padding: 1rem; color: #2563eb; font-weight: 600; font-size: 0.95rem;">
              <span style="display: inline-flex; align-items: center; gap: 0.5rem;">
                <span style="font-size: 1.1rem;"></span>
                <span>Show ${hiddenRowsCount} more row${hiddenRowsCount !== 1 ? 's' : ''}</span>
              </span>
            </td>
          `;
          expandRow.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            domainStrengthExpanded = true;
            renderDomainStrengthSection();
          });
          expandRow.addEventListener('mouseenter', () => {
            expandRow.style.backgroundColor = '#e0f2fe';
          });
          expandRow.addEventListener('mouseleave', () => {
            expandRow.style.backgroundColor = '#f8fafc';
          });
          tbody.appendChild(expandRow);
        } else if (domainStrengthExpanded && paginatedRows.length > 3) {
          const collapseRow = document.createElement('tr');
          collapseRow.id = 'domain-strength-collapse-row';
          collapseRow.style.cursor = 'pointer';
          collapseRow.style.backgroundColor = '#f8fafc';
          collapseRow.style.borderTop = '2px solid #e2e8f0';
          collapseRow.innerHTML = `
            <td colspan="9" style="text-align: center; padding: 1rem; color: #2563eb; font-weight: 600; font-size: 0.95rem;">
              <span style="display: inline-flex; align-items: center; gap: 0.5rem;">
                <span style="font-size: 1.1rem;"></span>
                <span>Show less</span>
              </span>
            </td>
          `;
          collapseRow.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            domainStrengthExpanded = false;
            renderDomainStrengthSection();
          });
          collapseRow.addEventListener('mouseenter', () => {
            collapseRow.style.backgroundColor = '#e0f2fe';
          });
          collapseRow.addEventListener('mouseleave', () => {
            collapseRow.style.backgroundColor = '#f8fafc';
          });
          tbody.appendChild(collapseRow);
        }

        // Update sort indicators
        document.querySelectorAll('#domain-strength-table th.sortable').forEach(th => {
          th.classList.remove('sort-asc', 'sort-desc');
          if (th.dataset.sort === domainStrengthSortState.column) {
            th.classList.add(`sort-${domainStrengthSortState.direction}`);
          }
        });

        // Update pagination controls
        const paginationInfo = document.getElementById('domain-strength-pagination-info');
        const prevBtn = document.getElementById('domain-strength-pagination-prev');
        const nextBtn = document.getElementById('domain-strength-pagination-next');
        const rowsPerPageSelect = document.getElementById('domain-strength-rows-per-page');
        
        if (paginationInfo) {
          paginationInfo.textContent = totalPages > 1 
            ? `Page ${currentPage} of ${totalPages}  Showing ${startIdx + 1}-${endIdx} of ${totalRows}`
            : `Total: ${totalRows}`;
        }
        
        if (prevBtn) {
          prevBtn.disabled = currentPage === 1;
          prevBtn.style.background = currentPage === 1 ? '#f1f5f9' : 'white';
          prevBtn.style.cursor = currentPage === 1 ? 'not-allowed' : 'pointer';
          prevBtn.style.color = currentPage === 1 ? '#94a3b8' : '#475569';
        }
        
        if (nextBtn) {
          nextBtn.disabled = currentPage === totalPages;
          nextBtn.style.background = currentPage === totalPages ? '#f1f5f9' : 'white';
          nextBtn.style.cursor = currentPage === totalPages ? 'not-allowed' : 'pointer';
          nextBtn.style.color = currentPage === totalPages ? '#94a3b8' : '#475569';
        }
        
        if (rowsPerPageSelect) {
          rowsPerPageSelect.value = domainStrengthPaginationState.rowsPerPage;
        }

        // Re-wire sorting and pagination after render
        wireDomainStrengthSorting();
        wireDomainStrengthPagination();
      }

      async function runDomainStrengthSnapshot() {
        debugLog('[DomainStrength] runDomainStrengthSnapshot() called', 'info');
        const statusEl = document.getElementById('domain-strength-run-status');
        const btn = document.getElementById('domain-strength-run-btn');
        const overlay = document.getElementById('domain-strength-overlay');
        const overlayStatus = document.getElementById('domain-strength-overlay-status');

        // Don't send core domains - API will handle alanranger.com + pending queue
        // This ensures cost control: only fetch domains that don't have snapshots this month
        const domains = [];

        // Show overlay
        if (overlay) {
          overlay.classList.add('show');
        }
        if (overlayStatus) {
          overlayStatus.textContent = `Fetching alanranger.com + up to 100 pending domains (skipping domains already processed this month)...`;
        }

        if (btn) {
          btn.disabled = true;
          btn.textContent = 'Running';
        }
        if (statusEl) statusEl.textContent = `Running snapshot (alanranger.com + pending queue)...`;

        try {
          const apiEndpoint = apiUrl('/api/domain-strength/snapshot');
          debugLog(`[DomainStrength] Calling API: ${apiEndpoint}`, 'info');
          debugLog(`[DomainStrength] Request: mode=run, includePending=true`, 'info');
          
          if (overlayStatus) {
            overlayStatus.textContent = `Calling DataForSEO API (alanranger.com + pending domains)...`;
          }
          
          const resp = await fetch(apiEndpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ mode: 'run', domains: [], includePending: true })
          });
          
          debugLog(`[DomainStrength] API response status: ${resp.status} ${resp.statusText}`, 'info');
          
          if (overlayStatus) {
            overlayStatus.textContent = 'Processing response and saving to database...';
          }
          
          let json;
          try {
            const responseText = await resp.text();
            debugLog(`[DomainStrength] API response text (first 200 chars): ${responseText.substring(0, 200)}`, 'info');
            json = JSON.parse(responseText);
          } catch (parseError) {
            debugLog(`[DomainStrength] Failed to parse JSON response: ${parseError.message}`, 'error');
            throw new Error(`API returned invalid JSON (status ${resp.status}). Response may be an error page.`);
          }
          
          debugLog(`[DomainStrength] API response: status=${json?.status}, inserted=${json?.inserted}, snapshot_date=${json?.snapshot_date}, domains_processed=${json?.domains_processed}`, 'info');
          debugLog(`[DomainStrength] Debug info: ${JSON.stringify(json?.debug || {})}`, 'info');
          
          // Update overlay message with actual domain count from API (includes pending domains)
          const actualDomainCount = json?.domains_processed || 1;
          if (overlayStatus) {
            overlayStatus.textContent = `Calling DataForSEO API for ${actualDomainCount} domains (alanranger.com + ${actualDomainCount - 1} pending)...`;
          }
          
          if (json?.status !== 'ok') {
            const errorMsg = json?.message || json?.details || 'Snapshot failed';
            debugLog(`[DomainStrength] API returned error: ${errorMsg}`, 'error');
            throw new Error(errorMsg);
          }
          
          debugLog(`[DomainStrength]  Snapshot successful: ${json.inserted || 0} domains saved (date: ${json.snapshot_date})`, 'success');
          
          // Clear domain strength caches so latest snapshot is reflected everywhere
          try {
            if (typeof __domainStrengthLatestCache !== 'undefined' && __domainStrengthLatestCache?.clear) {
              __domainStrengthLatestCache.clear();
            }
          } catch (e) {}
          try {
            ['dashboard_domain_strength_cache_v4', 'dashboard_domain_strength_cache_v3', 'dashboard_domain_strength_cache_v2', 'dashboard_domain_strength_cache_v1']
              .forEach((key) => localStorage.removeItem(key));
          } catch (e) {}
          
          // Fetch remaining pending count
          let remainingPending = 0;
          try {
            const pendingResp = await fetch(apiUrl('/api/domain-strength/pending-count'));
            if (pendingResp.ok) {
              const pendingData = await pendingResp.json();
              remainingPending = pendingData.count || 0;
            }
          } catch (e) {
            debugLog(`[DomainStrength] Could not fetch pending count: ${e.message}`, 'warn');
          }
          
          // Hide progress overlay
          if (overlay) {
            overlay.classList.remove('show');
          }
          
          // Show completion modal
          const completionModal = document.getElementById('domain-strength-completion-modal');
          const completionStats = document.getElementById('domain-strength-completion-stats');
          if (completionModal && completionStats) {
            const domainsProcessed = json.domains_processed || 0;
            const domainsInserted = json.inserted || 0;
            const domainsFetched = json.fetched || 0;
            
            completionStats.innerHTML = `
              <div style="margin-bottom: 1rem; padding: 1rem; background: #f0f9ff; border-radius: 8px; border-left: 4px solid #0ea5e9;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                  <span style="font-weight: 600; color: #0c4a6e;">Domains Processed:</span>
                  <span style="font-size: 1.25rem; font-weight: 700; color: #0284c7;">${domainsProcessed}</span>
                </div>
                <div style="font-size: 0.875rem; color: #075985;">
                  ${domainsFetched} fetched from DataForSEO  ${domainsInserted} snapshots saved
                </div>
              </div>
              <div style="padding: 1rem; background: ${remainingPending > 0 ? '#fef3c7' : '#f0fdf4'}; border-radius: 8px; border-left: 4px solid ${remainingPending > 0 ? '#f59e0b' : '#10b981'};">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                  <span style="font-weight: 600; color: ${remainingPending > 0 ? '#92400e' : '#065f46'};">Remaining in Queue:</span>
                  <span style="font-size: 1.25rem; font-weight: 700; color: ${remainingPending > 0 ? '#d97706' : '#059669'};">${remainingPending}</span>
                </div>
                ${remainingPending > 0 ? '<div style="font-size: 0.875rem; color: #78350f; margin-top: 0.5rem;">Run snapshot again to process more domains</div>' : '<div style="font-size: 0.875rem; color: #047857; margin-top: 0.5rem;">All domains have been processed!</div>'}
              </div>
            `;
            
            completionModal.style.display = 'flex';
            
            // Wire up close button
            const closeBtn = document.getElementById('domain-strength-completion-close');
            if (closeBtn) {
              closeBtn.onclick = () => {
                completionModal.style.display = 'none';
              };
            }
          }
          
          if (statusEl) statusEl.textContent = ` Snapshot saved for ${json.inserted || 0} domains (date: ${json.snapshot_date}).`;
          showStatus(` Domain strength snapshot saved (${json.snapshot_date})`, 'success');
          
          debugLog('[DomainStrength] Refreshing domain strength section...', 'info');
          await renderDomainStrengthSection();
          debugLog('[DomainStrength]  Domain strength section refreshed', 'success');

          // Dashboard: refresh live dials/cards after a domain strength snapshot
          if (typeof window.renderDashboardTab === 'function') {
            try { window.renderDashboardTab(); } catch (e) {}
          }
          // Ranking & AI: re-render to refresh domain strength trend line
          if (typeof window.renderRankingAiTab === 'function') {
            try { window.renderRankingAiTab(); } catch (e) {}
          }
        } catch (e) {
          const msg = e?.message || String(e);
          debugLog(`[DomainStrength]  Snapshot error: ${msg}`, 'error');
          if (overlayStatus) {
            overlayStatus.textContent = ` Error: ${msg}`;
          }
          if (statusEl) statusEl.textContent = ` Snapshot failed: ${msg}`;
          showStatus(` Domain strength snapshot failed: ${msg}`, 'error');
          // Keep overlay visible for a moment to show error
          await new Promise(resolve => setTimeout(resolve, 2000));
          
          // Hide overlay on error
          if (overlay) {
            overlay.classList.remove('show');
          }
        } finally {
          if (btn) {
            btn.disabled = false;
            btn.textContent = 'Run Domain Strength Snapshot (Google)';
          }
        }
      }

      function wireDomainStrengthButton() {
        const btn = document.getElementById('domain-strength-run-btn');
        if (!btn) return;
        const newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);
        newBtn.addEventListener('click', () => {
          runDomainStrengthSnapshot();
        });

        // Render current view (if history exists) once the ranking module has data
        try {
          renderDomainStrengthSection();
        } catch (e) {
          // ignore
        }
      }

      function wireDomainStrengthSorting() {
        const sortableHeaders = document.querySelectorAll('#domain-strength-table th.sortable');
        if (!sortableHeaders || sortableHeaders.length === 0) return;
        
        // Remove existing listeners by cloning (preserve innerHTML structure)
        sortableHeaders.forEach(th => {
          if (th.dataset.sortWired === 'true') {
            const newTh = th.cloneNode(true);
            th.parentNode.replaceChild(newTh, th);
          }
        });
        
        // Re-query after cloning to get fresh elements
        const freshHeaders = document.querySelectorAll('#domain-strength-table th.sortable');
        
        freshHeaders.forEach(th => {
          th.dataset.sortWired = 'true';
          
          // Use a named function to make debugging easier
          const handleSortClick = function(e) {
            e.stopPropagation();
            e.preventDefault();
            const column = this.dataset.sort;
            if (!column) {
              console.warn('[DomainStrength] No sort column found on clicked header');
              return;
            }
            
            console.log('[DomainStrength] Sort clicked:', column, 'Current state:', domainStrengthSortState);
            
            if (domainStrengthSortState.column === column) {
              // Toggle direction if clicking the same column
              domainStrengthSortState.direction = domainStrengthSortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
              // New column, start with ascending
              domainStrengthSortState.column = column;
              domainStrengthSortState.direction = 'asc';
            }
            
            console.log('[DomainStrength] New sort state:', domainStrengthSortState);
            
            domainStrengthPaginationState.currentPage = 1;
            renderDomainStrengthSection();
          };
          
          th.addEventListener('click', handleSortClick);
        });
        
        console.log('[DomainStrength] Wired', freshHeaders.length, 'sortable headers');
      }

      function wireDomainStrengthPagination() {
        const prevBtn = document.getElementById('domain-strength-pagination-prev');
        const nextBtn = document.getElementById('domain-strength-pagination-next');
        const rowsPerPageSelect = document.getElementById('domain-strength-rows-per-page');
        
        if (prevBtn) {
          const newPrevBtn = prevBtn.cloneNode(true);
          prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
          newPrevBtn.addEventListener('click', () => {
            if (domainStrengthPaginationState.currentPage > 1) {
              domainStrengthPaginationState.currentPage--;
              renderDomainStrengthSection();
            }
          });
        }
        
        if (nextBtn) {
          const newNextBtn = nextBtn.cloneNode(true);
          nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
          newNextBtn.addEventListener('click', () => {
            // Re-fetch items to get accurate total
            fetchDomainStrengthOverview().then(items => {
              const engine = 'google';
              const filtered = items.filter((it) => String(it?.searchEngine || '').toLowerCase() === engine);
              const totalRows = filtered.length;
              const rowsPerPage = domainStrengthPaginationState.rowsPerPage === 'all' ? totalRows : domainStrengthPaginationState.rowsPerPage;
              const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
              if (domainStrengthPaginationState.currentPage < totalPages) {
                domainStrengthPaginationState.currentPage++;
                renderDomainStrengthSection();
              }
            }).catch(() => {
              // If fetch fails, just increment and re-render
              domainStrengthPaginationState.currentPage++;
              renderDomainStrengthSection();
            });
          });
        }
        
        if (rowsPerPageSelect) {
          const newSelect = rowsPerPageSelect.cloneNode(true);
          rowsPerPageSelect.parentNode.replaceChild(newSelect, rowsPerPageSelect);
          newSelect.value = domainStrengthPaginationState.rowsPerPage;
          newSelect.addEventListener('change', (e) => {
            const value = e.target.value;
            domainStrengthPaginationState.rowsPerPage = value === 'all' ? 'all' : parseInt(value, 10);
            domainStrengthPaginationState.currentPage = 1;
            renderDomainStrengthSection();
          });
        }
      }
      
      // Wire button immediately
      wireRankingAiButton();
      // Wire domain strength button immediately
      if (typeof wireDomainStrengthButton === 'function') wireDomainStrengthButton();
      wireRankingFilters();
      wireRankingSorting();
      wireRankingPagination();
      wireDomainStrengthSorting();
      wireDomainStrengthPagination();
      
      // Make functions globally available for panel switching
      window.wireRankingAiButton = wireRankingAiButton;
      window.wireDomainStrengthButton = wireDomainStrengthButton;
      window.wireRankingFilters = wireRankingFilters;
      window.wireRankingSorting = wireRankingSorting;
      window.wireDomainStrengthSorting = wireDomainStrengthSorting;
      window.wireDomainStrengthPagination = wireDomainStrengthPagination;

      function wireRankingFilters() {
        const segmentFilter = document.getElementById("ranking-filter-segment");
        const rankFilter = document.getElementById("ranking-filter-rank");
        const volumeFilter = document.getElementById("ranking-filter-volume");
        const ctrFilter = document.getElementById("ranking-filter-ctr");
        const aiOverviewFilter = document.getElementById("ranking-filter-ai-overview");
        const aiCitationFilter = document.getElementById("ranking-filter-ai-citation");
        const opportunityFilter = document.getElementById("ranking-filter-opportunity");
        const pageTypeFilter = document.getElementById("ranking-filter-page-type");
        const serpFeaturesFilter = document.getElementById("ranking-filter-serp-features");
        const optimisationStatusFilter = document.getElementById("ranking-filter-optimisation-status");
        const keywordFilter = document.getElementById("ranking-filter-keyword");
        const clearBtn = document.getElementById("ranking-filter-clear");

        // Update active state styling for filters
        const updateFilterActiveStates = () => {
          const filterControls = [
            { el: segmentFilter, value: rankingFilterState.segment },
            { el: rankFilter, value: rankingFilterState.rank },
            { el: volumeFilter, value: rankingFilterState.volume },
            { el: ctrFilter, value: rankingFilterState.ctr },
            { el: aiOverviewFilter, value: rankingFilterState.aiOverview },
            { el: aiCitationFilter, value: rankingFilterState.aiCitation },
            { el: opportunityFilter, value: rankingFilterState.opportunity },
            { el: pageTypeFilter, value: rankingFilterState.pageType },
            { el: serpFeaturesFilter, value: rankingFilterState.serpFeatures },
            { el: optimisationStatusFilter, value: rankingFilterState.optimisationStatus }
          ];

          filterControls.forEach(({ el, value }) => {
            if (el) {
              if (value && value !== 'all') {
                el.classList.add('filter-active');
              } else {
                el.classList.remove('filter-active');
              }
            }
          });

          // Handle keyword filter separately (active if not empty)
          if (keywordFilter) {
            if (rankingFilterState.keyword && rankingFilterState.keyword.trim() !== '') {
              keywordFilter.classList.add('filter-active');
            } else {
              keywordFilter.classList.remove('filter-active');
            }
          }
        };

        const minOpportunityInput = document.getElementById("ranking-filter-min-opportunity");
        const minOpportunityNote = document.getElementById("ranking-filter-min-opportunity-note");

        const updateFilters = () => {
          if (segmentFilter) rankingFilterState.segment = segmentFilter.value;
          if (rankFilter) rankingFilterState.rank = rankFilter.value;
          if (volumeFilter) rankingFilterState.volume = volumeFilter.value;
          if (ctrFilter) rankingFilterState.ctr = ctrFilter.value;
          if (aiOverviewFilter) rankingFilterState.aiOverview = aiOverviewFilter.value;
          if (aiCitationFilter) rankingFilterState.aiCitation = aiCitationFilter.value;
          if (opportunityFilter) rankingFilterState.opportunity = opportunityFilter.value;
          if (pageTypeFilter) rankingFilterState.pageType = pageTypeFilter.value;
          if (serpFeaturesFilter) rankingFilterState.serpFeatures = serpFeaturesFilter.value;
          if (optimisationStatusFilter) rankingFilterState.optimisationStatus = optimisationStatusFilter.value;
          if (keywordFilter) rankingFilterState.keyword = keywordFilter.value.trim();
          
          // Min opportunity filter
          if (minOpportunityInput) {
            const minOppValue = minOpportunityInput.value.trim();
            if (minOppValue === '') {
              rankingFilterState.minOpportunity = null;
              if (minOpportunityNote) minOpportunityNote.style.display = 'none';
            } else {
              const numValue = Number(minOppValue);
              if (Number.isFinite(numValue) && numValue >= 0 && numValue <= 100) {
                rankingFilterState.minOpportunity = numValue;
                if (minOpportunityNote) minOpportunityNote.style.display = 'block';
              } else {
                rankingFilterState.minOpportunity = null;
                if (minOpportunityNote) minOpportunityNote.style.display = 'none';
              }
            }
          }
          
          // Update active states
          updateFilterActiveStates();
          
          rankingPaginationState.currentPage = 1; // Reset to first page on filter change
          renderRankingAiTab();
        };

        // Debounce function for keyword filter to improve performance
        let keywordFilterTimeout = null;
        const debouncedUpdateFilters = () => {
          // Update the keyword value immediately for active state
          if (keywordFilter) {
            rankingFilterState.keyword = keywordFilter.value.trim();
            updateFilterActiveStates();
          }
          
          // Clear existing timeout
          if (keywordFilterTimeout) {
            clearTimeout(keywordFilterTimeout);
          }
          
          // Set new timeout to actually apply the filter after user stops typing
          keywordFilterTimeout = setTimeout(() => {
            updateFilters();
            keywordFilterTimeout = null;
          }, 300); // 300ms delay
        };

        if (segmentFilter) segmentFilter.addEventListener("change", updateFilters);
        if (rankFilter) rankFilter.addEventListener("change", updateFilters);
        if (volumeFilter) volumeFilter.addEventListener("change", updateFilters);
        if (ctrFilter) ctrFilter.addEventListener("change", updateFilters);
        if (aiOverviewFilter) aiOverviewFilter.addEventListener("change", updateFilters);
        if (aiCitationFilter) aiCitationFilter.addEventListener("change", updateFilters);
        if (opportunityFilter) opportunityFilter.addEventListener("change", updateFilters);
        if (pageTypeFilter) pageTypeFilter.addEventListener("change", updateFilters);
        if (serpFeaturesFilter) serpFeaturesFilter.addEventListener("change", updateFilters);
        if (optimisationStatusFilter) optimisationStatusFilter.addEventListener("change", updateFilters);
        if (keywordFilter) keywordFilter.addEventListener("input", debouncedUpdateFilters);
        if (minOpportunityInput) {
          minOpportunityInput.addEventListener("input", debouncedUpdateFilters);
          minOpportunityInput.addEventListener("blur", updateFilters);
        }

        if (clearBtn) {
          clearBtn.addEventListener("click", () => {
            // Cancel any pending debounced keyword filter updates
            if (keywordFilterTimeout) {
              clearTimeout(keywordFilterTimeout);
              keywordFilterTimeout = null;
            }
            
            rankingFilterState = {
              segment: 'all',
              rank: 'all',
              volume: 'all',
              ctr: 'all',
              opportunity: 'all',
              aiOverview: 'all',
              aiCitation: 'all',
              pageType: 'all',
              serpFeatures: 'all',
              optimisationStatus: 'all',
              keyword: '',
              minOpportunity: null
            };
            activePreset = null; // Clear active preset
            rankingPriorityFilter = null; // Clear priority matrix filter
            selectedKeywordId = null; // Clear selected keyword
            if (segmentFilter) segmentFilter.value = 'all';
            if (rankFilter) rankFilter.value = 'all';
            if (volumeFilter) volumeFilter.value = 'all';
            if (ctrFilter) ctrFilter.value = 'all';
            if (aiOverviewFilter) aiOverviewFilter.value = 'all';
            if (aiCitationFilter) aiCitationFilter.value = 'all';
            if (opportunityFilter) opportunityFilter.value = 'all';
            if (pageTypeFilter) pageTypeFilter.value = 'all';
            if (serpFeaturesFilter) serpFeaturesFilter.value = 'all';
            if (optimisationStatusFilter) optimisationStatusFilter.value = 'all';
            if (keywordFilter) keywordFilter.value = '';
            if (minOpportunityInput) {
              minOpportunityInput.value = '';
              if (minOpportunityNote) minOpportunityNote.style.display = 'none';
            }
            updateFilterActiveStates();
            if (typeof updatePresetButtonActiveStates === 'function') {
              updatePresetButtonActiveStates();
            }
            if (typeof renderPresetCriteriaChips === 'function') {
              renderPresetCriteriaChips();
            }
            rankingPaginationState.currentPage = 1; // Reset to first page on clear
            rankingSortState.column = 'opportunityScore'; // Reset sort
            rankingSortState.direction = 'desc';
            renderRankingAiTab();
          });
        }

        // Default filter state (single source of truth)
        const DEFAULT_FILTERS = {
          segment: 'all',
          rank: 'all',
          volume: 'all',
          ctr: 'all',
          opportunity: 'all',
          minOpportunity: null,
          aiOverview: 'all',
          aiCitation: 'all',
          pageType: 'all',
          serpFeatures: 'all',
          keyword: ''
        };

        // Default sort state
        const DEFAULT_SORT = {
          column: 'opportunityScore',
          direction: 'desc'
        };

        // Preset definitions (data-driven)
        const PRESETS = {
          'all': {
            label: 'All keywords',
            filters: { ...DEFAULT_FILTERS },
            sort: { ...DEFAULT_SORT }
          },
          'high-impact-money': {
            label: 'High-impact money',
            filters: {
              ...DEFAULT_FILTERS,
              segment: 'money',
              volume: 'high',
              rank: '11-20',
              minOpportunity: 65
            },
            sort: {
              column: 'opportunityScore',
              direction: 'desc'
            }
          },
          'ai-overview-not-cited': {
            label: 'AI Overview, not cited',
            filters: {
              ...DEFAULT_FILTERS,
              aiOverview: 'has',
              aiCitation: 'not-cited',
              minOpportunity: 50
            },
            sort: {
              column: 'volume',
              direction: 'desc'
            }
          },
          'brand-safety': {
            label: 'Brand safety',
            filters: {
              ...DEFAULT_FILTERS,
              segment: 'brand',
              rank: 'not-top3'
            },
            sort: {
              column: 'rank',
              direction: 'asc'
            }
          },
          'education-growth': {
            label: 'Blog opportunities',
            filters: {
              ...DEFAULT_FILTERS,
              pageType: 'Blog',
              rank: 'not-top3',
              minOpportunity: 30
            },
            sort: {
              column: 'opportunityScore',
              direction: 'desc'
            }
          },
          'local-visibility': {
            label: 'Local visibility',
            filters: {
              ...DEFAULT_FILTERS,
              pageType: 'GBP',
              rank: 'not-top3',
              minOpportunity: 30
            },
            sort: {
              column: 'opportunityScore',
              direction: 'desc'
            }
          },
          'top-10-opportunities': {
            label: 'Top 10 opportunities',
            filters: {
              ...DEFAULT_FILTERS,
              rank: 'not-top3',
              minOpportunity: 50
            },
            sort: {
              column: 'opportunityScore',
              direction: 'desc'
            },
            rowsPerPage: 10
          }
        };

        // Preset button handlers
        function applyPreset(presetKey) {
          // Cancel any pending debounced keyword filter updates
          if (keywordFilterTimeout) {
            clearTimeout(keywordFilterTimeout);
            keywordFilterTimeout = null;
          }

          // Clear priority matrix filter and selected keyword
          rankingPriorityFilter = null;
          selectedKeywordId = null;

          // Get preset definition
          const preset = PRESETS[presetKey];
          if (!preset) {
            console.warn(`Unknown preset: ${presetKey}`);
            return;
          }

          // HARD RESET: Apply preset filters (don't merge with existing state)
          rankingFilterState = { ...preset.filters };
          rankingSortState = { ...preset.sort };

          // Set rows per page if specified in preset
          if (preset.rowsPerPage) {
            const rowsPerPageSelect = document.getElementById('ranking-rows-per-page');
            if (rowsPerPageSelect) {
              rowsPerPageSelect.value = preset.rowsPerPage;
              rankingPaginationState.rowsPerPage = preset.rowsPerPage;
            }
          }

          // Set active preset (null for 'all')
          activePreset = presetKey === 'all' ? null : presetKey;

          // Update UI elements to match filter state
          if (segmentFilter) segmentFilter.value = rankingFilterState.segment;
          if (rankFilter) rankFilter.value = rankingFilterState.rank;
          if (volumeFilter) volumeFilter.value = rankingFilterState.volume;
          if (ctrFilter) ctrFilter.value = rankingFilterState.ctr;
          if (aiOverviewFilter) aiOverviewFilter.value = rankingFilterState.aiOverview;
          if (aiCitationFilter) aiCitationFilter.value = rankingFilterState.aiCitation;
          if (opportunityFilter) opportunityFilter.value = rankingFilterState.opportunity;
          if (pageTypeFilter) pageTypeFilter.value = rankingFilterState.pageType;
          if (serpFeaturesFilter) serpFeaturesFilter.value = rankingFilterState.serpFeatures;
          if (keywordFilter) keywordFilter.value = rankingFilterState.keyword;
          
          // Update minOpportunity input
          const minOppInput = document.getElementById("ranking-filter-min-opportunity");
          const minOppNote = document.getElementById("ranking-filter-min-opportunity-note");
          if (minOppInput) {
            if (rankingFilterState.minOpportunity != null) {
              minOppInput.value = String(rankingFilterState.minOpportunity);
              if (minOppNote) minOppNote.style.display = 'block';
            } else {
              minOppInput.value = '';
              if (minOppNote) minOppNote.style.display = 'none';
            }
          }

          updateFilterActiveStates();
          updatePresetButtonActiveStates();
          rankingPaginationState.currentPage = 1;
          renderPresetCriteriaChips();
          renderRankingAiTab();
        }

        // Update preset button active states
        function updatePresetButtonActiveStates() {
          const presetButtons = document.querySelectorAll('.ranking-preset-btn');
          presetButtons.forEach(btn => {
            const presetKey = btn.getAttribute('data-preset');
            if (activePreset === presetKey || (presetKey === 'all' && activePreset === null)) {
              btn.classList.add('preset-active');
              btn.style.background = '#047857'; // Darker green background for active (emerald-800)
              btn.style.borderColor = '#065f46'; // Darker border
              btn.style.color = '#ffffff';
              btn.style.fontWeight = '600';
            } else {
              btn.classList.remove('preset-active');
              btn.style.background = 'rgb(229, 255, 204)';
              btn.style.borderColor = '#cbd5e1';
              btn.style.color = '#475569';
              btn.style.fontWeight = '500';
            }
          });
        }

        // Get active criteria chips based on filter state
        function getActiveCriteriaChips() {
          const chips = [];
          
          if (rankingFilterState.segment !== 'all') {
            const segmentLabel = rankingFilterState.segment.charAt(0).toUpperCase() + rankingFilterState.segment.slice(1);
            chips.push({
              label: `Segment: ${segmentLabel}`,
              onRemove: () => {
                rankingFilterState.segment = 'all';
                const segmentFilter = document.getElementById("ranking-filter-segment");
                if (segmentFilter) segmentFilter.value = 'all';
                activePreset = null;
                updateFilters();
              }
            });
          }
          
          if (rankingFilterState.rank !== 'all') {
            let rankLabel = '';
            if (rankingFilterState.rank === 'top3') rankLabel = 'Top 3';
            else if (rankingFilterState.rank === '4-10') rankLabel = '410';
            else if (rankingFilterState.rank === '11-20') rankLabel = '1120';
            else if (rankingFilterState.rank === '21+') rankLabel = '21+ / Not ranked';
            else if (rankingFilterState.rank === 'not-top3') rankLabel = 'Not top 3';
            chips.push({
              label: `Best rank: ${rankLabel}`,
              onRemove: () => {
                rankingFilterState.rank = 'all';
                const rankFilter = document.getElementById("ranking-filter-rank");
                if (rankFilter) rankFilter.value = 'all';
                activePreset = null;
                updateFilters();
              }
            });
          }
          
          if (rankingFilterState.pageType && rankingFilterState.pageType !== 'all') {
            chips.push({
              label: `Page type: ${rankingFilterState.pageType}`,
              onRemove: () => {
                rankingFilterState.pageType = 'all';
                const pageTypeFilter = document.getElementById("ranking-filter-page-type");
                if (pageTypeFilter) pageTypeFilter.value = 'all';
                activePreset = null;
                updateFilters();
              }
            });
          }
          
          if (rankingFilterState.volume !== 'all') {
            const volumeLabel = rankingFilterState.volume.charAt(0).toUpperCase() + rankingFilterState.volume.slice(1);
            chips.push({
              label: `Search volume: ${volumeLabel}`,
              onRemove: () => {
                rankingFilterState.volume = 'all';
                const volumeFilter = document.getElementById("ranking-filter-volume");
                if (volumeFilter) volumeFilter.value = 'all';
                activePreset = null;
                updateFilters();
              }
            });
          }
          
          if (rankingFilterState.aiOverview !== 'all') {
            const aiLabel = rankingFilterState.aiOverview === 'has' ? 'On' : 'Off';
            chips.push({
              label: `AI Overview: ${aiLabel}`,
              onRemove: () => {
                rankingFilterState.aiOverview = 'all';
                const aiOverviewFilter = document.getElementById("ranking-filter-ai-overview");
                if (aiOverviewFilter) aiOverviewFilter.value = 'all';
                activePreset = null;
                updateFilters();
              }
            });
          }
          
          if (rankingFilterState.aiCitation !== 'all') {
            const citationLabel = rankingFilterState.aiCitation === 'cited' ? 'Cited' : 'Not cited';
            chips.push({
              label: `AI citation: ${citationLabel}`,
              onRemove: () => {
                rankingFilterState.aiCitation = 'all';
                const aiCitationFilter = document.getElementById("ranking-filter-ai-citation");
                if (aiCitationFilter) aiCitationFilter.value = 'all';
                activePreset = null;
                updateFilters();
              }
            });
          }
          
          if (rankingFilterState.minOpportunity != null) {
            chips.push({
              label: `Min opportunity:  ${rankingFilterState.minOpportunity}`,
              onRemove: () => {
                rankingFilterState.minOpportunity = null;
                const minOppInput = document.getElementById("ranking-filter-min-opportunity");
                const minOppNote = document.getElementById("ranking-filter-min-opportunity-note");
                if (minOppInput) minOppInput.value = '';
                if (minOppNote) minOppNote.style.display = 'none';
                activePreset = null;
                updateFilters();
              }
            });
          }
          
          // Add sort chip if not default
          if (rankingSortState.column && (rankingSortState.column !== 'opportunityScore' || rankingSortState.direction !== 'desc')) {
            const sortLabel = rankingSortState.column === 'rank' ? 'Rank' : 
                             rankingSortState.column === 'volume' ? 'Volume' : 
                             rankingSortState.column === 'opportunityScore' ? 'Opportunity' : 
                             rankingSortState.column;
            const sortDir = rankingSortState.direction === 'asc' ? '' : '';
            chips.push({
              label: `Sort: ${sortLabel} ${sortDir}`,
              onRemove: () => {
                rankingSortState.column = 'opportunityScore';
                rankingSortState.direction = 'desc';
                activePreset = null;
                renderRankingAiTab();
              }
            });
          }
          
          return chips;
        }

        // Render criteria chips
        function renderPresetCriteriaChips() {
          const chipsContainer = document.getElementById('ranking-preset-criteria-chips');
          if (!chipsContainer) return;
          
          const chips = getActiveCriteriaChips();
          
          if (chips.length === 0 || activePreset === null) {
            chipsContainer.style.display = 'none';
            return;
          }
          
          chipsContainer.style.display = 'block';
          const chipsInner = chipsContainer.querySelector('div');
          if (!chipsInner) return;
          
          chipsInner.innerHTML = chips.map(chip => {
            // Create a wrapper function to handle the removal and update
            const removeHandler = () => {
              chip.onRemove();
              updatePresetButtonActiveStates();
              renderPresetCriteriaChips();
            };
            return `
              <span style="display: inline-flex; align-items: center; gap: 0.375rem; padding: 0.375rem 0.75rem; background: #e5e7eb; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.875rem; color: #374151;">
                ${chip.label}
                <button type="button" onclick="(${removeHandler.toString()})()" style="background: none; border: none; cursor: pointer; color: #6b7280; font-size: 1rem; line-height: 1; padding: 0; margin-left: 0.25rem;" title="Remove this filter"></button>
              </span>
            `;
          }).join('');
        }

        // Wire up preset buttons (re-wire on each call to handle DOM updates)
        function wirePresetButtons() {
          // Remove existing listeners by cloning buttons
          const presetButtons = document.querySelectorAll('.ranking-preset-btn');
          presetButtons.forEach(btn => {
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
          });
          
          // Re-query to get fresh elements
          const freshPresetButtons = document.querySelectorAll('.ranking-preset-btn');
          freshPresetButtons.forEach(btn => {
            btn.addEventListener('click', () => {
              const presetKey = btn.getAttribute('data-preset');
              if (presetKey) {
                applyPreset(presetKey);
              }
            });
          });
        }
        
        // Wire preset buttons immediately
        wirePresetButtons();
        
        // Make wirePresetButtons globally available
        window.wirePresetButtons = wirePresetButtons;

        // Initialize active states on page load
        updateFilterActiveStates();
      }

      function wireRankingSorting() {
        // Find all sortable headers
        const sortableHeaders = document.querySelectorAll('.ranking-table th.sortable');
        if (!sortableHeaders || sortableHeaders.length === 0) {
          console.log('[Sort] No sortable headers found');
          return;
        }
        
        console.log('[Sort] Found', sortableHeaders.length, 'sortable headers');
        
        // Remove any existing data attribute markers
        sortableHeaders.forEach(th => {
          if (th.dataset.sortWired === 'true') {
            // Clone to remove all listeners
            const newTh = th.cloneNode(true);
            th.parentNode.replaceChild(newTh, th);
          }
        });
        
        // Re-query after cloning
        const freshHeaders = document.querySelectorAll('.ranking-table th.sortable');
        
        // Attach listeners directly to each header
        freshHeaders.forEach(th => {
          th.dataset.sortWired = 'true'; // Mark as wired
          
          th.addEventListener('click', function(e) {
            e.stopPropagation();
            const column = this.dataset.sort;
            if (!column) {
              console.log('[Sort] No sort column found');
              return;
            }
            
            console.log('[Sort] Clicked column:', column, 'Current:', rankingSortState.column, rankingSortState.direction);
            
            if (rankingSortState.column === column) {
              // Toggle direction if clicking the same column
              rankingSortState.direction = rankingSortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
              // New column, start with ascending
              rankingSortState.column = column;
              rankingSortState.direction = 'asc';
            }
            
            console.log('[Sort] New state:', rankingSortState.column, rankingSortState.direction);
            
            rankingPaginationState.currentPage = 1;
            renderRankingAiTab();
          });
        });
        
        console.log('[Sort] Wired', freshHeaders.length, 'headers');
      }
      
      function wireRankingPagination() {
        const firstBtn = document.getElementById("ranking-pagination-first");
        const prevBtn = document.getElementById("ranking-pagination-prev");
        const nextBtn = document.getElementById("ranking-pagination-next");
        const lastBtn = document.getElementById("ranking-pagination-last");
        const rowsPerPageSelect = document.getElementById("ranking-rows-per-page");
        
        if (firstBtn) {
          firstBtn.addEventListener("click", () => {
            rankingPaginationState.currentPage = 1;
            renderRankingAiTab();
          });
        }
        
        if (prevBtn) {
          prevBtn.addEventListener("click", () => {
            if (rankingPaginationState.currentPage > 1) {
              rankingPaginationState.currentPage--;
              renderRankingAiTab();
            }
          });
        }
        
        if (nextBtn) {
          nextBtn.addEventListener("click", () => {
            rankingPaginationState.currentPage++;
            renderRankingAiTab();
          });
        }
        
        if (lastBtn) {
          lastBtn.addEventListener("click", () => {
            // Calculate total pages from current data
            const { combinedRows } = RankingAiModule.state();
            if (!combinedRows || !Array.isArray(combinedRows)) return;
            const filteredRows = applyRankingFilters(combinedRows);
            const totalRows = filteredRows.length;
            const rowsPerPage = rankingPaginationState.rowsPerPage === 'all' ? totalRows : rankingPaginationState.rowsPerPage;
            const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
            rankingPaginationState.currentPage = totalPages;
            renderRankingAiTab();
          });
        }
        
        if (rowsPerPageSelect) {
          rowsPerPageSelect.addEventListener("change", () => {
            const value = rowsPerPageSelect.value;
            rankingPaginationState.rowsPerPage = value === 'all' ? 'all' : parseInt(value, 10);
            rankingPaginationState.currentPage = 1; // Reset to first page
            renderRankingAiTab();
          });
        }
      }

      // ============================================
      // AI Sources & Influence Tab Functions
      // ============================================

      /**
       * Classify domain source type based on domain pattern
       * @param {string} domain - Domain name (e.g., "visualeducation.com")
       * @returns {string} Source type classification
       */
      function classifyDomainSourceType(domain) {
        if (!domain) return 'Other';
        const lower = domain.toLowerCase();
        
        // Directory patterns
        if (lower.includes('yell.com') || lower.includes('tripadvisor') || 
            lower.includes('facebook.com/pages') || lower.includes('thomsonlocal') ||
            lower.includes('yell.co.uk') || lower.includes('freeindex')) {
          return 'Directory';
        }
        
        // Review platform patterns
        if (lower.includes('trustpilot') || lower.includes('google.com/maps') ||
            lower.includes('reviews.co.uk') || lower.includes('feefo')) {
          return 'Review platform';
        }
        
        // Course marketplace / education patterns
        if (lower.includes('udemy') || lower.includes('coursera') ||
            lower.includes('visualeducation') || lower.includes('skillshare') ||
            lower.includes('edx') || lower.includes('futurelearn')) {
          return 'Course marketplace / education';
        }
        
        // Publisher / blog patterns (common content domains)
        if (lower.includes('blog') || lower.includes('medium.com') ||
            lower.includes('wordpress.com') || lower.includes('blogger.com')) {
          return 'Publisher / blog';
        }
        
        return 'Other';
      }

      /**
       * Aggregate AI citation data by domain
       * @param {Array} combinedRows - Array of keyword rows with AI citation data
       * @param {string} targetDomain - Target domain (e.g., "alanranger.com")
       * @returns {Array} Array of domain stats objects
       */
      function aggregateAiDomainStats(combinedRows, targetDomain = 'alanranger.com') {
        if (!combinedRows || !Array.isArray(combinedRows)) {
          debugLog(' aggregateAiDomainStats: No combinedRows provided', 'warn');
          return [];
        }

        const domainMap = new Map();
        const targetDomainLower = targetDomain.toLowerCase();

        // Track total citations across all keywords
        let totalAllCitations = 0;

        combinedRows.forEach(row => {
          // Get AI citations for this keyword
          const aiCitations = row.ai_alan_citations || [];
          const competitorCounts = row.competitor_counts || {};
          const aiTotalCitations = row.ai_total_citations || 0;

          totalAllCitations += aiTotalCitations;

          // Process our own citations
          if (aiCitations && aiCitations.length > 0) {
            aiCitations.forEach(citation => {
              if (!citation || !citation.url) return;
              
              try {
                const urlObj = new URL(citation.url);
                const domain = urlObj.hostname.toLowerCase();
                
                if (!domainMap.has(domain)) {
                  domainMap.set(domain, {
                    domain,
                    is_self: domain.includes(targetDomainLower),
                    total_citations: 0,
                    keyword_count: 0,
                    keywords: new Set(),
                    example_urls: []
                  });
                }
                
                const stats = domainMap.get(domain);
                stats.total_citations += 1;
                if (!stats.keywords.has(row.keyword)) {
                  stats.keywords.add(row.keyword);
                  stats.keyword_count += 1;
                }
                if (stats.example_urls.length < 2) {
                  stats.example_urls.push(citation.url);
                }
              } catch (e) {
                // Invalid URL, skip
              }
            });
          }

          // Process competitor citations from competitor_counts (per keyword)
          Object.entries(competitorCounts).forEach(([domain, count]) => {
            if (!domain || !count) return;
            
            const domainLower = domain.toLowerCase();
            
            if (!domainMap.has(domainLower)) {
              domainMap.set(domainLower, {
                domain: domainLower,
                is_self: domainLower.includes(targetDomainLower),
                total_citations: 0,
                keyword_count: 0,
                keywords: new Set(),
                example_urls: []
              });
            }
            
            const stats = domainMap.get(domainLower);
            stats.total_citations += count;
            if (!stats.keywords.has(row.keyword)) {
              stats.keywords.add(row.keyword);
              stats.keyword_count += 1;
            }
          });
        });

        // Convert to array and calculate share_of_citations
        const domainStats = Array.from(domainMap.values()).map(stats => {
          const share_of_citations = totalAllCitations > 0 
            ? (stats.total_citations / totalAllCitations) * 100 
            : 0;
          
          return {
            domain: stats.domain,
            is_self: stats.is_self,
            total_citations: stats.total_citations,
            keyword_count: stats.keyword_count,
            share_of_citations,
            source_type: classifyDomainSourceType(stats.domain),
            example_urls: stats.example_urls.slice(0, 2),
            keywords: Array.from(stats.keywords)
          };
        });

        // Sort by total_citations descending
        domainStats.sort((a, b) => b.total_citations - a.total_citations);

        debugLog(` Aggregated ${domainStats.length} domains from AI citations`, 'info');
        return domainStats;
      }

      /**
       * Render AI Sources & Influence tab
       */
      function renderAiSourcesTab() {
        debugLog(' renderAiSourcesTab() called', 'info');
        
        const { combinedRows } = RankingAiModule.state();
        if (!combinedRows || combinedRows.length === 0) {
          debugLog(' renderAiSourcesTab: No keyword data available', 'warn');
          const tilesContainer = document.getElementById('ai-sources-tiles');
          const tableBody = document.getElementById('ai-sources-table-body');
          if (tilesContainer) tilesContainer.innerHTML = '<div class="card"><p style="padding: 2rem; text-align: center; color: #64748b;">No AI citation data available. Run a Ranking & AI check first.</p></div>';
          if (tableBody) tableBody.innerHTML = '<tr><td colspan="6" class="ranking-table-empty">No data available. Run a Ranking & AI check first.</td></tr>';
          return;
        }

        // Get target domain from property URL
        const propertyUrl = localStorage.getItem('gsc_property_url') || 'https://www.alanranger.com';
        let targetDomain = 'alanranger.com';
        try {
          const urlObj = new URL(propertyUrl);
          targetDomain = urlObj.hostname.replace('www.', '');
        } catch (e) {
          debugLog(` Could not parse property URL: ${propertyUrl}, using default domain`, 'warn');
        }

        // Aggregate domain stats
        const domainStats = aggregateAiDomainStats(combinedRows, targetDomain);
        
        // Store globally for filtering/sorting
        window.aiSourcesDomainStats = domainStats;

        // Render tiles
        renderAiSourcesTiles(domainStats, combinedRows.length);

        // Render source types breakdown
        renderAiSourcesTypesBreakdown(domainStats);

        // Render domain table
        renderAiSourcesTable(domainStats).catch(err => {
          console.error('Error rendering AI sources table:', err);
        });
      }

      /**
       * Render summary tiles for AI Sources & Influence
       */
      function renderAiSourcesTiles(domainStats, totalKeywords) {
        const tilesContainer = document.getElementById('ai-sources-tiles');
        if (!tilesContainer) return;

        // Calculate metrics
        const selfDomain = domainStats.find(d => d.is_self);
        const selfCitations = selfDomain ? selfDomain.total_citations : 0;
        const totalCitations = domainStats.reduce((sum, d) => sum + d.total_citations, 0);
        const selfShare = totalCitations > 0 ? (selfCitations / totalCitations) * 100 : 0;
        const keywordsWithSelfCitations = selfDomain ? selfDomain.keyword_count : 0;
        const externalDomains = domainStats.filter(d => !d.is_self).length;

        const pctKeywordsWithCitations = totalKeywords > 0
          ? (keywordsWithSelfCitations / totalKeywords) * 100
          : 0;

        const ragForShare = () => {
          if (totalCitations <= 0) return 'neutral';
          if (selfShare >= 20) return 'green';
          if (selfShare >= 10) return 'amber';
          return 'red';
        };

        const ragForKeywordCoverage = () => {
          if (totalKeywords <= 0) return 'neutral';
          if (pctKeywordsWithCitations >= 60) return 'green';
          if (pctKeywordsWithCitations >= 30) return 'amber';
          return 'red';
        };

        const statusForRag = (rag) => {
          if (rag === 'green') return 'Strong';
          if (rag === 'amber') return 'Moderate';
          if (rag === 'red') return 'Weak';
          return 'Info';
        };

        const makePill = ({ rag, value, label, status, footer }) => `
          <div class="metric-pill metric-pill--${rag}">
            <div class="metric-pill-value">${value}</div>
            <div class="metric-pill-label">${label}</div>
            <div class="metric-pill-status">${status}</div>
            <div class="metric-pill-footer">${footer}</div>
          </div>
        `;

        const shareRag = ragForShare();
        const coverageRag = ragForKeywordCoverage();

        const html = `
          ${makePill({
            rag: shareRag,
            value: `${selfCitations}/${totalCitations}`,
            label: 'Your AI citations',
            status: statusForRag(shareRag),
            footer: 'Share of AI citations that reference your site across tracked keywords.'
          })}
          ${makePill({
            rag: 'neutral',
            value: `${externalDomains}`,
            label: 'Top external domains',
            status: 'Info',
            footer: 'Domains most often cited alongside you in AI answers.'
          })}
          ${makePill({
            rag: coverageRag,
            value: `${keywordsWithSelfCitations}/${totalKeywords}`,
            label: 'Keywords with your citations',
            status: statusForRag(coverageRag),
            footer: 'How often AI can already see your site as a source for your tracked queries.'
          })}
          ${makePill({
            rag: shareRag,
            value: `${selfShare.toFixed(1)}%`,
            label: 'Your share of AI citations',
            status: statusForRag(shareRag),
            footer: 'Higher values mean AI relies more on your content instead of competitors or directories.'
          })}
        `;

        tilesContainer.innerHTML = html;
      }

      /**
       * Render source types breakdown
       */
      function renderAiSourcesTypesBreakdown(domainStats) {
        const container = document.getElementById('ai-sources-types-breakdown');
        if (!container) return;

        // Group by source type
        const typeGroups = {};
        domainStats.forEach(stat => {
          const type = stat.source_type;
          if (!typeGroups[type]) {
            typeGroups[type] = {
              domains: 0,
              citations: 0
            };
          }
          typeGroups[type].domains += 1;
          typeGroups[type].citations += stat.total_citations;
        });

        const totalCitations = domainStats.reduce((sum, d) => sum + d.total_citations, 0);

        let html = '<ul style="list-style: none; padding: 0; margin: 0;">';
        Object.entries(typeGroups).forEach(([type, data]) => {
          const pct = totalCitations > 0 ? (data.citations / totalCitations) * 100 : 0;
          html += `<li style="padding: 0.75rem 0; border-bottom: 1px solid #e5e7eb;">
            <strong>${type}:</strong> ${data.domains} domains (${pct.toFixed(1)}% of citations)
          </li>`;
        });
        html += '</ul>';

        container.innerHTML = html;
      }

      /**
       * Render domain influence table
       */
      async function renderAiSourcesTable(domainStats, filters = {}) {
        const tableBody = document.getElementById('ai-sources-table-body');
        if (!tableBody) return;

        // Fetch domain metadata and domain strength for all domains (same as Ranking & AI module)
        const allDomains = domainStats.map(stat => stat.domain);
        const domainMetadata = await fetchDomainMetadataForDomains(allDomains);
        const normalizedDomains = allDomains.map(normalizeDomainForStrength).filter(Boolean);
        // Fetch domain strength for all domains (not just first 30)
        // Note: fetchLatestDomainStrengthForDomains has a 30 domain limit, so we need to batch if needed
        const domainStrength = await fetchLatestDomainStrengthForDomains(normalizedDomains);
        
        // If we have more than 30 domains, fetch in batches
        if (normalizedDomains.length > 30) {
          const batches = [];
          for (let i = 0; i < normalizedDomains.length; i += 30) {
            batches.push(normalizedDomains.slice(i, i + 30));
          }
          for (const batch of batches.slice(1)) {
            const batchStrength = await fetchLatestDomainStrengthForDomains(batch);
            Object.assign(domainStrength, batchStrength);
          }
        }

        // Separate alanranger.com (self) from others
        // Self domain is always shown regardless of filters (sticky first row)
        const selfDomain = domainStats.find(stat => stat.is_self);
        const otherDomains = domainStats.filter(stat => !stat.is_self);

        // Apply filters to other domains (self domain always shown, filtered separately if needed)
        let filtered = otherDomains.filter(stat => {
          if (filters.type && filters.type !== 'all' && stat.source_type !== filters.type) {
            return false;
          }
          if (filters.domainType && filters.domainType !== 'all') {
            const normalizedDomain = normalizeDomainForStrength(stat.domain);
            const meta = domainMetadata[normalizedDomain] || { domain_type: 'unmapped' };
            const domainType = meta.domain_type && meta.domain_type !== 'unmapped' ? meta.domain_type : 'unmapped';
            
            if (filters.domainType === 'self' || filters.domainType === 'your_site') {
              // Filter is 'self' or 'your_site', but this is a competitor domain, so exclude it
              return false;
            } else if (filters.domainType === 'competitor') {
              // Filter is 'competitor', show all non-self domains (already filtered)
              // No additional filtering needed
            } else {
              // Filter by specific domain_type value (e.g., 'site', 'platform', 'directory', 'unmapped', etc.)
              if (domainType !== filters.domainType) {
                return false;
              }
            }
          }
          if (filters.domain && !stat.domain.toLowerCase().includes(filters.domain.toLowerCase())) {
            return false;
          }
          return true;
        });

        // Apply sorting (default: competitor - competitors first)
        const sortColumn = window.aiSourcesSortState?.column || 'competitor';
        const sortDirection = window.aiSourcesSortState?.direction || 'desc';
        filtered.sort((a, b) => {
          let aVal, bVal;
          switch (sortColumn) {
            case 'domain':
              aVal = a.domain.toLowerCase();
              bVal = b.domain.toLowerCase();
              break;
            case 'domain_type':
              // Sort by domain_type string value from metadata (using mapped labels for consistent sorting)
              const aNorm = normalizeDomainForStrength(a.domain);
              const bNorm = normalizeDomainForStrength(b.domain);
              const aMeta = domainMetadata[aNorm] || { domain_type: 'unmapped' };
              const bMeta = domainMetadata[bNorm] || { domain_type: 'unmapped' };
              // For self domains, use "your_site" if unmapped, otherwise use domain_type
              if (a.is_self) {
                const aDomainType = aMeta.domain_type && aMeta.domain_type !== 'unmapped' ? aMeta.domain_type : 'your_site';
                aVal = getDomainTypeLabel(aDomainType);
              } else {
                const aDomainType = aMeta.domain_type && aMeta.domain_type !== 'unmapped' ? aMeta.domain_type : 'zzz_unmapped';
                aVal = getDomainTypeLabel(aDomainType) || 'zzz_unmapped';
              }
              if (b.is_self) {
                const bDomainType = bMeta.domain_type && bMeta.domain_type !== 'unmapped' ? bMeta.domain_type : 'your_site';
                bVal = getDomainTypeLabel(bDomainType);
              } else {
                const bDomainType = bMeta.domain_type && bMeta.domain_type !== 'unmapped' ? bMeta.domain_type : 'zzz_unmapped';
                bVal = getDomainTypeLabel(bDomainType) || 'zzz_unmapped';
              }
              break;
            case 'competitor':
              // Sort by competitor status (competitors first, then non-competitors)
              const aNormComp = normalizeDomainForStrength(a.domain);
              const bNormComp = normalizeDomainForStrength(b.domain);
              const aMetaComp = domainMetadata[aNormComp] || { is_competitor: false };
              const bMetaComp = domainMetadata[bNormComp] || { is_competitor: false };
              aVal = aMetaComp.is_competitor ? 1 : 0;
              bVal = bMetaComp.is_competitor ? 1 : 0;
              break;
            case 'rank':
              // Sort by domain rank score
              const aNormRank = normalizeDomainForStrength(a.domain);
              const bNormRank = normalizeDomainForStrength(b.domain);
              const aStrength = domainStrength[aNormRank] || { score: null };
              const bStrength = domainStrength[bNormRank] || { score: null };
              aVal = aStrength.score !== null ? aStrength.score : -1;
              bVal = bStrength.score !== null ? bStrength.score : -1;
              break;
            case 'type':
              aVal = a.source_type;
              bVal = b.source_type;
              break;
            case 'citations':
              aVal = a.total_citations;
              bVal = b.total_citations;
              break;
            case 'keywords':
              aVal = a.keyword_count;
              bVal = b.keyword_count;
              break;
            case 'share':
              aVal = a.share_of_citations;
              bVal = b.share_of_citations;
              break;
            default:
              return 0;
          }
          if (aVal < bVal) return sortDirection === 'asc' ? -1 : 1;
          if (aVal > bVal) return sortDirection === 'asc' ? 1 : -1;
          return 0;
        });

        if (filtered.length === 0 && !selfDomain) {
          tableBody.innerHTML = '<tr><td colspan="8" class="ranking-table-empty">No domains match the current filters.</td></tr>';
          return;
        }

        tableBody.innerHTML = '';
        
        // Always render self domain first with yellow highlight (regardless of filters, but respect domain search and domain type filter)
        if (selfDomain) {
          // Check if self domain should be shown based on filters
          const normalizedDomain = normalizeDomainForStrength(selfDomain.domain);
          const meta = domainMetadata[normalizedDomain] || { domain_type: 'unmapped', is_competitor: false };
          const domainType = meta.domain_type && meta.domain_type !== 'unmapped' ? meta.domain_type : 'your_site';
          
          let showSelf = true;
          if (filters.domain && !selfDomain.domain.toLowerCase().includes(filters.domain.toLowerCase())) {
            showSelf = false;
          }
          if (filters.domainType && filters.domainType !== 'all') {
            if (filters.domainType === 'self' || filters.domainType === 'your_site') {
              // Show self domain
              showSelf = showSelf && true;
            } else if (filters.domainType === 'competitor') {
              // Hide self domain when filtering for competitors
              showSelf = false;
            } else {
              // Filter by specific domain_type value
              showSelf = showSelf && (domainType === filters.domainType);
            }
          }
          
          if (showSelf) {
            const strength = domainStrength[normalizedDomain] || null;
            const selfRow = createDomainRow(selfDomain, true, meta, strength);
            tableBody.appendChild(selfRow);
          }
        }
        
        // Render filtered other domains
        filtered.forEach(stat => {
          const normalizedDomain = normalizeDomainForStrength(stat.domain);
          const meta = domainMetadata[normalizedDomain] || { domain_type: 'unmapped', is_competitor: false };
          const strength = domainStrength[normalizedDomain] || null;
          const row = createDomainRow(stat, false, meta, strength);
          tableBody.appendChild(row);
        });
        
        // Re-attach sort listeners after table is rendered
        if (typeof window.attachAiSourcesSortListeners === 'function') {
          setTimeout(() => {
            window.attachAiSourcesSortListeners();
          }, 50);
        }
      }

      /**
       * Map domain_type value to display label (same as Ranking & AI module)
       */
      function getDomainTypeLabel(domainType) {
        const domainTypeMap = {
          'unmapped': 'Unmapped',
          'your_site': 'Your site',
          'platform': 'Platform',
          'directory': 'Directory',
          'publisher': 'Publisher',
          'vendor': 'Vendor',
          'institution': 'Institution',
          'government': 'Government',
          'site': 'Site'
        };
        return domainTypeMap[domainType] || domainType || '';
      }

      /**
       * Create a table row for a domain stat
       */
      function createDomainRow(stat, isSelf, meta, strength) {
          const tr = document.createElement('tr');
          tr.dataset.domain = stat.domain;
        
        // Make self domain row sticky and highlight in yellow (below header)
        if (isSelf) {
          tr.style.position = 'sticky';
          tr.style.top = '40px'; // Below sticky header (approximate header height)
          tr.style.zIndex = '15';
          tr.style.backgroundColor = '#ffffcc';
          tr.style.fontWeight = '600';
        }
          
          // Domain
          const tdDomain = document.createElement('td');
          tdDomain.textContent = stat.domain;
          if (stat.is_self) {
            tdDomain.style.fontWeight = '700';
            tdDomain.style.color = '#166534';
          tdDomain.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
          }
          tr.appendChild(tdDomain);

        // Domain type (use same categorization as Ranking & AI module)
        const tdDomainType = document.createElement('td');
        tdDomainType.style.padding = '0.5rem 0.4rem';
        tdDomainType.style.fontSize = '0.8rem';
        tdDomainType.style.wordWrap = 'break-word';
        tdDomainType.style.overflowWrap = 'break-word';
        if (stat.is_self) {
          tdDomainType.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
        }
        
        // Map domain_type value to display label (same as Ranking & AI)
        // Always show domain_type for all rows
        let displayType = '';
        if (stat.is_self) {
          // For self domain, show mapped label or "Your site" if unmapped
          const domainType = meta.domain_type && meta.domain_type !== 'unmapped' ? meta.domain_type : 'your_site';
          displayType = getDomainTypeLabel(domainType);
        } else {
          // For non-self domains, show mapped label if available, otherwise show "Unmapped"
          if (meta.domain_type && meta.domain_type !== 'unmapped') {
            displayType = getDomainTypeLabel(meta.domain_type);
          } else {
            // Show "Unmapped" so user knows domain exists but type not assigned yet
            displayType = 'Unmapped';
          }
        }
        tdDomainType.textContent = displayType;
        tdDomainType.style.color = displayType ? '#475569' : '#94a3b8';
        if (stat.is_self) {
          tdDomainType.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
        }
        tr.appendChild(tdDomainType);

        // Competitor column (separate from domain type)
        const tdCompetitor = document.createElement('td');
        tdCompetitor.style.padding = '0.5rem 0.4rem';
        tdCompetitor.style.fontSize = '0.8rem';
        tdCompetitor.style.textAlign = 'center';
        if (stat.is_self) {
          tdCompetitor.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
        }
        
        // Show competitor badge if is_competitor is true (same as Ranking & AI module)
        if (meta.is_competitor) {
          const badge = document.createElement('span');
          badge.textContent = 'Competitor';
          badge.setAttribute('data-competitor-badge', 'true');
          badge.style.display = 'inline-block';
          badge.style.padding = '0.125rem 0.5rem';
          badge.style.fontSize = '0.65rem';
          badge.style.fontWeight = '600';
          badge.style.color = '#dc2626';
          badge.style.backgroundColor = '#fee2e2';
          badge.style.borderRadius = '4px';
          badge.style.border = '1px solid #fecaca';
          tdCompetitor.appendChild(badge);
        } else {
          tdCompetitor.textContent = '';
          tdCompetitor.style.color = '#94a3b8';
        }
        tr.appendChild(tdCompetitor);

        // Domain Rank
        const tdRank = document.createElement('td');
        tdRank.style.textAlign = 'right';
        tdRank.style.padding = '0.5rem 0.4rem';
        tdRank.style.fontSize = '0.8rem';
        if (stat.is_self) {
          tdRank.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
        }
        tdRank.innerHTML = renderDomainRankCellHtml(strength);
        tr.appendChild(tdRank);

          // Citations
          const tdCitations = document.createElement('td');
          tdCitations.textContent = stat.total_citations;
        if (stat.is_self) {
          tdCitations.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
        }
          tr.appendChild(tdCitations);

          // Keywords
          const tdKeywords = document.createElement('td');
          tdKeywords.textContent = stat.keyword_count;
        if (stat.is_self) {
          tdKeywords.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
        }
          tr.appendChild(tdKeywords);

          // Citation share
          const tdShare = document.createElement('td');
          tdShare.textContent = `${stat.share_of_citations.toFixed(1)}%`;
        if (stat.is_self) {
          tdShare.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
        }
          tr.appendChild(tdShare);

          // Example page
          const tdExample = document.createElement('td');
        if (stat.is_self) {
          tdExample.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
        }
          if (stat.example_urls && stat.example_urls.length > 0) {
            const a = document.createElement('a');
            a.href = stat.example_urls[0];
            a.target = '_blank';
            a.rel = 'noopener noreferrer';
            a.textContent = stat.is_self ? new URL(stat.example_urls[0]).pathname : stat.example_urls[0];
            a.style.color = '#0284c7';
            a.style.textDecoration = 'none';
            tdExample.appendChild(a);
          } else {
            tdExample.textContent = '';
          }
          tr.appendChild(tdExample);

          // Click handler
          tr.style.cursor = 'pointer';
          tr.addEventListener('click', () => {
            document.querySelectorAll('#ai-sources-table-body tr').forEach(r => r.classList.remove('ranking-table-row--selected'));
            tr.classList.add('ranking-table-row--selected');
            renderAiSourcesDetail(stat);
          });

        return tr;
      }

      /**
       * Render domain detail panel
       */
      function renderAiSourcesDetail(stat) {
        const panel = document.getElementById('ai-sources-detail-panel');
        const domainEl = document.getElementById('ai-sources-detail-domain');
        const metaEl = document.getElementById('ai-sources-detail-meta');
        const contentEl = document.getElementById('ai-sources-detail-content');

        if (!panel || !domainEl || !metaEl || !contentEl) return;

        panel.style.display = 'block';
        domainEl.textContent = stat.domain;
        metaEl.textContent = `Cited in ${stat.total_citations} AI answer${stat.total_citations !== 1 ? 's' : ''} across ${stat.keyword_count} tracked keyword${stat.keyword_count !== 1 ? 's' : ''} (${stat.share_of_citations.toFixed(1)}% of all citations).`;

        let html = '';

        // Why this domain matters
        html += '<div class="scorecard-section">';
        html += '<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">Why this domain matters</h5>';
        
        if (stat.is_self) {
          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This is your own site. AI is using your content in ' + stat.total_citations + ' answer' + (stat.total_citations !== 1 ? 's' : '') + ' across ' + stat.keyword_count + ' keyword' + (stat.keyword_count !== 1 ? 's' : '') + '. Increasing citations here usually comes from stronger schema, internal linking and coverage on key topics.</p>';
        } else if (stat.source_type === 'Directory') {
          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This is a directory / listing site. Repeated citations suggest AI trusts this listing as a key reference in your niche. Ensure your profile, NAP details and reviews are complete and consistent.</p>';
        } else if (stat.source_type === 'Review platform') {
          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This is a review platform. AI often surfaces businesses with strong, consistent reviews from here. Make sure your profile is claimed, reviews are encouraged, and descriptions match your positioning.</p>';
        } else if (stat.source_type === 'Course marketplace / education') {
          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This is an education or course marketplace. AI is seeing it as an alternative source for photography learning. Consider whether partnering, listing, or differentiating your on-site course pages against this platform makes sense.</p>';
        } else if (stat.source_type === 'Publisher / blog') {
          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This is a content publisher. Repeated citations suggest AI trusts their articles for informational queries. Collaborations, guest posts, or references from this domain can help strengthen your topical authority.</p>';
        } else {
          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This domain is frequently cited, but doesn\'t fall into a specific category. Review its content and decide if it\'s a directory, partner, competitor or something to monitor.</p>';
        }
        html += '</div>';

        // Keywords where this domain appears
        html += '<div class="scorecard-section">';
        html += '<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">Keywords where this domain appears</h5>';
        html += '<ul style="font-size: 0.875rem; color: #1e293b; line-height: 1.8; padding-left: 1.5rem;">';
        const keywordsToShow = stat.keywords.slice(0, 10);
        keywordsToShow.forEach(keyword => {
          html += `<li>${keyword}</li>`;
        });
        if (stat.keywords.length > 10) {
          html += `<li style="color: #64748b; font-style: italic;">... and ${stat.keywords.length - 10} more</li>`;
        }
        html += '</ul></div>';

        // Suggested next steps
        html += '<div class="scorecard-section">';
        html += '<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">Suggested next steps</h5>';
        html += '<ul style="font-size: 0.875rem; color: #1e293b; line-height: 1.8; padding-left: 1.5rem;">';
        
        if (stat.is_self) {
          const selfShare = stat.share_of_citations;
          if (selfShare < 30) {
            html += '<li>Strengthen schema and content coverage on high-demand keywords where you\'re not cited yet.</li>';
            html += '<li>Revisit internal linking from money pages to these informational topics to raise their prominence.</li>';
          }
        } else if (stat.source_type === 'Directory' || stat.source_type === 'Review platform') {
          html += '<li>Audit your listing/profile on this domain (NAP details, description, categories).</li>';
          html += '<li>Encourage satisfied students/clients to leave reviews here to reinforce Authority.</li>';
        } else if (stat.source_type === 'Course marketplace / education') {
          html += '<li>Review how your offerings compare to what\'s listed here. Decide whether to list on this platform or create on-site content addressing the same needs.</li>';
        } else if (stat.source_type === 'Publisher / blog') {
          html += '<li>Identify relevant articles and consider outreach for mentions, interviews or guest content pointing back to your key pages.</li>';
        }
        
        html += '</ul></div>';

        contentEl.innerHTML = html;
      }

      // Edit Keywords functionality
      (function() {
        // Wait for DOM to be ready
        function initEditKeywords() {
          const modal = document.getElementById('edit-keywords-modal');
          const openBtn = document.getElementById('edit-keywords-btn');
          const closeBtn = document.getElementById('edit-keywords-close');
          const cancelBtn = document.getElementById('edit-keywords-cancel');
          const saveBtn = document.getElementById('edit-keywords-save');
          const textarea = document.getElementById('edit-keywords-textarea');
          const statusEl = document.getElementById('edit-keywords-status');

          if (!modal || !openBtn) {
            // Elements not found yet, try again later
            setTimeout(initEditKeywords, 100);
            return;
          }

          // Ensure modal is hidden initially - use !important to override any other styles
          modal.style.setProperty('display', 'none', 'important');
          
          // Force close on any click outside or escape - emergency close
          const forceClose = () => {
            modal.style.setProperty('display', 'none', 'important');
          };
          
          // Make forceClose available globally for emergency
          window.forceCloseEditKeywordsModal = forceClose;

          function showModal() {
            if (typeof debugLog === 'function') debugLog('[Edit Keywords] showModal() called', 'info');
            if (modal) {
              if (typeof debugLog === 'function') debugLog('[Edit Keywords] Modal found, showing...', 'info');
              modal.style.setProperty('display', 'flex', 'important');
              if (typeof debugLog === 'function') debugLog('[Edit Keywords] Calling loadKeywords()...', 'info');
              loadKeywords();
            } else {
              if (typeof debugLog === 'function') debugLog('[Edit Keywords] Modal element not found!', 'error');
            }
          }

          function hideModal() {
            if (modal) {
              modal.style.display = 'none';
              modal.style.setProperty('display', 'none', 'important');
              if (statusEl) statusEl.textContent = '';
              if (textarea) {
                textarea.value = '';
                textarea.disabled = false;
              }
            }
          }

          async function loadKeywords() {
            if (typeof debugLog === 'function') debugLog('[Edit Keywords] loadKeywords() called', 'info');
            if (!textarea) {
              if (typeof debugLog === 'function') debugLog('[Edit Keywords] Textarea not found', 'error');
              if (statusEl) {
                statusEl.textContent = 'ERROR: Textarea element not found';
                statusEl.style.color = '#dc2626';
                statusEl.style.fontWeight = 'bold';
              }
              return;
            }
            
            if (typeof debugLog === 'function') debugLog('[Edit Keywords] Setting loading state...', 'info');
            textarea.value = 'Loading keywords...';
            textarea.disabled = true;
            textarea.style.color = '#1e293b';
            textarea.style.backgroundColor = '#ffffff';
            if (statusEl) {
              statusEl.textContent = 'Loading keywords from server...';
              statusEl.style.color = '#64748b';
              statusEl.style.fontWeight = 'normal';
            }
            
            try {
              // First try to get from localStorage as fallback
              let keywordsFromStorage = [];
              try {
                const storedData = localStorage.getItem('rankingAiData');
                if (storedData) {
                  const parsed = JSON.parse(storedData);
                  if (parsed.combinedRows && Array.isArray(parsed.combinedRows)) {
                    keywordsFromStorage = [...new Set(parsed.combinedRows.map(r => r?.keyword).filter(Boolean))].sort();
                    if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Found ${keywordsFromStorage.length} keywords in localStorage`, 'info');
                  }
                }
              } catch (e) {
                if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Could not read from localStorage: ${e.message}`, 'warn');
              }
              
              const apiEndpoint = apiUrl('/api/keywords/get');
              if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Fetching from: ${apiEndpoint}`, 'info');
              
              const resp = await fetch(apiEndpoint);
              if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Response status: ${resp.status} ${resp.statusText}`, 'info');
              
              if (!resp.ok) {
                const errorText = await resp.text();
                if (typeof debugLog === 'function') debugLog(`[Edit Keywords] API error response: ${errorText}`, 'error');
                // Fallback to localStorage if API fails
                if (keywordsFromStorage.length > 0) {
                  if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Using localStorage fallback due to API error`, 'warn');
                  textarea.value = keywordsFromStorage.join('\n');
                  textarea.disabled = false;
                  textarea.style.color = '#1e293b';
                  textarea.style.backgroundColor = '#ffffff';
                  if (statusEl) {
                    statusEl.textContent = ` Loaded ${keywordsFromStorage.length} keywords from cache (API error: ${resp.status})`;
                    statusEl.style.color = '#f59e0b';
                    statusEl.style.fontWeight = '600';
                  }
                  return;
                }
                throw new Error(`HTTP ${resp.status}: ${errorText.substring(0, 100)}`);
              }
              
              const data = await resp.json();
              if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Response: status=${data.status}, keywords count=${data.keywords?.length || 0}, reason=${data.meta?.reason || 'none'}`, 'info');
              
              if (data.status === 'ok' && Array.isArray(data.keywords)) {
                if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Found ${data.keywords.length} keywords from API`, 'info');
                if (data.keywords.length > 0) {
                  const keywordsText = data.keywords.join('\n');
                  if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Setting textarea value, length: ${keywordsText.length}`, 'info');
                  textarea.value = keywordsText;
                  textarea.disabled = false;
                  textarea.style.color = '#1e293b';
                  textarea.style.backgroundColor = '#ffffff';
                  textarea.focus();
                  if (statusEl) {
                    statusEl.textContent = ` Loaded ${data.keywords.length} keywords`;
                    statusEl.style.color = '#10b981';
                    statusEl.style.fontWeight = '600';
                  }
                  if (typeof debugLog === 'function') debugLog('[Edit Keywords] Keywords loaded successfully', 'success');
                } else {
                  if (typeof debugLog === 'function') debugLog('[Edit Keywords] No keywords found in API response', 'warn');
                  // Try localStorage fallback
                  if (keywordsFromStorage.length > 0) {
                    if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Using localStorage fallback (${keywordsFromStorage.length} keywords)`, 'warn');
                    textarea.value = keywordsFromStorage.join('\n');
                    textarea.disabled = false;
                    textarea.style.color = '#1e293b';
                    textarea.style.backgroundColor = '#ffffff';
                    if (statusEl) {
                      statusEl.textContent = ` Loaded ${keywordsFromStorage.length} keywords from cache (not found in latest audit)`;
                      statusEl.style.color = '#f59e0b';
                      statusEl.style.fontWeight = '600';
                    }
                  } else {
                    textarea.value = '';
                    textarea.disabled = false;
                    textarea.style.color = '#1e293b';
                    textarea.style.backgroundColor = '#ffffff';
                    if (statusEl) {
                      statusEl.textContent = ' No keywords found. You can add keywords below (one per line).';
                      statusEl.style.color = '#f59e0b';
                      statusEl.style.fontWeight = '600';
                    }
                  }
                }
              } else {
                if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Invalid response format. Status: ${data.status}, Keywords type: ${typeof data.keywords}, Is array: ${Array.isArray(data.keywords)}`, 'error');
                textarea.value = '';
                textarea.disabled = false;
                textarea.style.color = '#1e293b';
                textarea.style.backgroundColor = '#ffffff';
                if (statusEl) {
                  statusEl.textContent = ' Invalid response format from server. Check debug log for details.';
                  statusEl.style.color = '#dc2626';
                  statusEl.style.fontWeight = 'bold';
                }
              }
            } catch (err) {
              if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Exception: ${err.message}`, 'error');
              textarea.value = '';
              textarea.disabled = false;
              textarea.style.color = '#1e293b';
              textarea.style.backgroundColor = '#ffffff';
              if (statusEl) {
                statusEl.textContent = ' Error loading keywords: ' + err.message + ' (Check debug log for details)';
                statusEl.style.color = '#dc2626';
                statusEl.style.fontWeight = 'bold';
                statusEl.style.fontSize = '0.9rem';
              }
            }
          }

          async function saveKeywords() {
            if (!textarea || !saveBtn) return;
            
            const keywordsText = textarea.value.trim();
            const keywords = keywordsText.split('\n')
              .map(k => k.trim())
              .filter(k => k.length > 0);
            
            if (keywords.length === 0) {
              if (statusEl) {
                statusEl.textContent = 'Please enter at least one keyword.';
                statusEl.style.color = '#dc2626';
              }
              return;
            }

            saveBtn.disabled = true;
            saveBtn.textContent = 'Saving...';
            if (statusEl) {
              statusEl.textContent = 'Saving keywords...';
              statusEl.style.color = '#64748b';
            }

            try {
              const resp = await fetch(apiUrl('/api/keywords/save'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ keywords })
              });

              // Check if response is JSON before parsing
              const contentType = resp.headers.get('content-type');
              let data;
              
              if (contentType && contentType.includes('application/json')) {
                data = await resp.json();
              } else {
                // Non-JSON response (likely an error page or plain text)
                const errorText = await resp.text();
                throw new Error(`Server returned non-JSON response (${resp.status}): ${errorText.substring(0, 200)}`);
              }
              
              if (resp.ok && data.status === 'ok') {
                if (statusEl) {
                  statusEl.textContent = ` Successfully saved ${data.count || keywords.length} keywords. Keywords will be updated on the next Ranking & AI check.`;
                  statusEl.style.color = '#10b981';
                }
                
                // Close modal after showing success message (don't trigger a new scan)
                setTimeout(() => {
                  hideModal();
                }, 2000);
              } else {
                throw new Error(data.message || data.details || 'Failed to save keywords');
              }
            } catch (err) {
              console.error('[Edit Keywords] Save error:', err);
              if (statusEl) {
                statusEl.textContent = 'Error saving keywords: ' + err.message;
                statusEl.style.color = '#dc2626';
              }
              saveBtn.disabled = false;
              saveBtn.textContent = 'Save Keywords';
            }
          }

          // CSV upload handler
          const csvUpload = document.getElementById('csv-upload');
          if (csvUpload) {
            csvUpload.addEventListener('change', async (e) => {
              const file = e.target.files[0];
              if (!file) return;

              try {
                const text = await file.text();
                // Parse CSV and populate textarea
                const lines = text.split('\n');
                const keywords = [];
                for (const line of lines) {
                  const trimmed = line.trim();
                  if (!trimmed || trimmed.startsWith('#')) continue;
                  const firstColumn = trimmed.includes(',') ? trimmed.split(',')[0].trim() : trimmed;
                  if (firstColumn) keywords.push(firstColumn);
                }

                if (keywords.length === 0) {
                  if (statusEl) {
                    statusEl.textContent = 'No keywords found in CSV file';
                    statusEl.style.color = '#dc2626';
                  }
                  return;
                }

                textarea.value = keywords.join('\n');
                if (statusEl) {
                  statusEl.textContent = ` Loaded ${keywords.length} keywords from CSV`;
                  statusEl.style.color = '#10b981';
                }

                // Reset file input
                e.target.value = '';
              } catch (err) {
                console.error('[Edit Keywords] CSV upload error:', err);
                if (statusEl) {
                  statusEl.textContent = 'Error reading CSV file: ' + err.message;
                  statusEl.style.color = '#dc2626';
                }
              }
            });
          }

          // Only attach event listeners - modal should NOT open automatically
          openBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            showModal();
          });
          
          // Close buttons - make sure they work
          if (closeBtn) {
            closeBtn.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              hideModal();
            });
          }
          
          if (cancelBtn) {
            cancelBtn.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              hideModal();
            });
          }
          
          if (saveBtn) {
            saveBtn.addEventListener('click', saveKeywords);
          }
          
          // Close modal when clicking outside
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              e.preventDefault();
              e.stopPropagation();
              hideModal();
            }
          });

          // Close modal with Escape key - make it work globally
          const escapeHandler = (e) => {
            if (e.key === 'Escape' && modal) {
              const currentDisplay = window.getComputedStyle(modal).display;
              if (currentDisplay === 'flex' || currentDisplay === 'block') {
                e.preventDefault();
                e.stopPropagation();
                hideModal();
              }
            }
          };
          document.addEventListener('keydown', escapeHandler);
          
          // Also add a global function to force close
          window.closeEditKeywordsModal = hideModal;
        }

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initEditKeywords);
        } else {
          initEditKeywords();
        }
      })();

      // Initialize AI Sources sort state (default: sort by competitor - competitors first)
      if (!window.aiSourcesSortState) {
        window.aiSourcesSortState = { column: 'competitor', direction: 'desc' };
      }

      // Wire up AI Sources tab filters and sorting
      function wireAiSourcesFilters() {
        const typeFilter = document.getElementById('ai-sources-filter-type');
        const domainTypeFilter = document.getElementById('ai-sources-filter-domain-type');
        const domainFilter = document.getElementById('ai-sources-filter-domain');
        const clearBtn = document.getElementById('ai-sources-filter-clear');

        const updateFilters = async () => {
          const filters = {
            type: typeFilter ? typeFilter.value : 'all',
            domainType: domainTypeFilter ? domainTypeFilter.value : 'all',
            domain: domainFilter ? domainFilter.value.trim() : ''
          };
          if (window.aiSourcesDomainStats) {
            await renderAiSourcesTable(window.aiSourcesDomainStats, filters).catch(err => {
              console.error('Error rendering AI sources table:', err);
            });
          }
        };

        if (typeFilter) typeFilter.addEventListener('change', updateFilters);
        if (domainTypeFilter) domainTypeFilter.addEventListener('change', updateFilters);
        if (domainFilter) domainFilter.addEventListener('input', updateFilters);
        if (clearBtn) {
          clearBtn.addEventListener('click', () => {
            if (typeFilter) typeFilter.value = 'all';
            if (domainTypeFilter) domainTypeFilter.value = 'all';
            if (domainFilter) domainFilter.value = '';
            updateFilters();
          });
        }

        // Wire up table sorting - attach listeners after table is rendered
        window.attachAiSourcesSortListeners = function attachSortListeners() {
          const table = document.getElementById('ai-sources-table');
          if (!table) return;
          
          // Remove any existing listeners by removing and re-adding the event listener
          // Use a single delegated listener on the table
          const handleSortClick = (e) => {
            const th = e.target.closest('th.sortable');
            if (!th) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            const column = th.dataset.sort;
            if (!column) return;

            if (window.aiSourcesSortState.column === column) {
              window.aiSourcesSortState.direction = window.aiSourcesSortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
              window.aiSourcesSortState.column = column;
              window.aiSourcesSortState.direction = 'desc';
            }

            // Update sort indicators
            const allHeaders = table.querySelectorAll('th.sortable');
            allHeaders.forEach(h => {
              h.classList.remove('sort-asc', 'sort-desc');
              if (h.dataset.sort === window.aiSourcesSortState.column) {
                h.classList.add(`sort-${window.aiSourcesSortState.direction}`);
              }
            });

            // Re-render table with new sort
            const filters = {
              type: typeFilter ? typeFilter.value : 'all',
              domainType: domainTypeFilter ? domainTypeFilter.value : 'all',
              domain: domainFilter ? domainFilter.value.trim() : ''
            };
            if (window.aiSourcesDomainStats) {
              renderAiSourcesTable(window.aiSourcesDomainStats, filters).then(() => {
                // Re-attach listeners after re-render
                if (typeof window.attachAiSourcesSortListeners === 'function') {
                  window.attachAiSourcesSortListeners();
                }
              }).catch(err => {
                console.error('Error rendering AI sources table:', err);
              });
            }
          };
          
          // Remove old listener if it exists
          if (table._sortHandler) {
            table.removeEventListener('click', table._sortHandler);
          }
          table._sortHandler = handleSortClick;
          table.addEventListener('click', handleSortClick, true); // Use capture phase to catch events early
          
          // Set initial sort indicator on headers and add cursor style
          const sortableHeaders = table.querySelectorAll('th.sortable');
          sortableHeaders.forEach(h => {
            h.style.cursor = 'pointer';
            h.classList.remove('sort-asc', 'sort-desc');
            if (h.dataset.sort === window.aiSourcesSortState.column) {
              h.classList.add(`sort-${window.aiSourcesSortState.direction}`);
            }
          });
        }
        
        // Attach sort listeners initially
        window.attachAiSourcesSortListeners();
      }

      // Make functions globally available
      window.renderAiSourcesTab = renderAiSourcesTab;
      window.wireAiSourcesFilters = wireAiSourcesFilters;

      // =========================
      // Dashboard (Global Summary)
      // =========================

      const DASHBOARD_RUNS_KEY = 'dashboard_global_runs_v1';

      function dashboardSafeJsonParse(text, fallback = null) {
        try {
          if (!text) return fallback;
          return JSON.parse(text);
        } catch (e) {
          return fallback;
        }
      }

      function formatUtcTimestamp(iso) {
        if (!iso) return '';
        const d = new Date(iso);
        if (Number.isNaN(d.getTime())) return '';
        const day = String(d.getUTCDate()).padStart(2, '0');
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const month = monthNames[d.getUTCMonth()];
        const year = d.getUTCFullYear();
        const hh = String(d.getUTCHours()).padStart(2, '0');
        const mm = String(d.getUTCMinutes()).padStart(2, '0');
        const ss = String(d.getUTCSeconds()).padStart(2, '0');
        return `${day} ${month} ${year}, ${hh}:${mm}:${ss} GMT`;
      }

      function scoreToRag(score, { greenAt = 70, amberAt = 50 } = {}) {
        const s = typeof score === 'number' ? score : null;
        if (s === null) return 'neutral';
        if (s >= greenAt) return 'green';
        if (s >= amberAt) return 'amber';
        return 'red';
      }

      function ragToAccent(rag) {
        if (rag === 'green') return '#10b981';
        if (rag === 'amber') return '#f59e0b';
        if (rag === 'red') return '#ef4444';
        return 'rgba(148, 163, 184, 0.6)';
      }

      function getDashboardRuns() {
        const runs = dashboardSafeJsonParse(localStorage.getItem(DASHBOARD_RUNS_KEY), []);
        return Array.isArray(runs) ? runs : [];
      }

      function saveDashboardRun(run) {
        try {
          const existing = getDashboardRuns();
          const next = [...existing, run].slice(-50);
          // Try to save, but reduce history if quota exceeded
          try {
            localStorage.setItem(DASHBOARD_RUNS_KEY, JSON.stringify(next));
          } catch (quotaError) {
            // If quota exceeded, try saving with fewer runs
            console.warn('[Dashboard] localStorage quota exceeded, reducing run history...');
            const reduced = next.slice(-10); // Keep only last 10 runs
            try {
              localStorage.setItem(DASHBOARD_RUNS_KEY, JSON.stringify(reduced));
            } catch (retryError) {
              // If still failing, try saving just the current run
              try {
                localStorage.setItem(DASHBOARD_RUNS_KEY, JSON.stringify([run]));
              } catch (finalError) {
                console.error('[Dashboard] Failed to save dashboard run to localStorage:', finalError);
                // Non-critical: continue without saving
              }
            }
          }
        } catch (error) {
          console.error('[Dashboard] Error in saveDashboardRun:', error);
          // Non-critical: continue without saving
        }
      }

      function getRankingAiRowsFromStorage() {
        const local = dashboardSafeJsonParse(localStorage.getItem('rankingAiData'), null);
        if (local && Array.isArray(local.combinedRows)) return local.combinedRows;
        if (Array.isArray(window.rankingAiData)) return window.rankingAiData;
        return [];
      }

      function computeMoneyCitationsShareFromRankingRows(rows) {
        const fn = typeof window.computeAiCitationsByCitedUrlSegment === 'function'
          ? window.computeAiCitationsByCitedUrlSegment
          : null;
        if (!fn) return { money: null, total: null, pct: null };
        const counts = fn(rows || []);
        const money = (counts.money || 0);
        const total = (counts.site || 0);
        const pct = total > 0 ? Math.round((money / total) * 100) : 0;
        return { money, total, pct };
      }

      function computeMoneyCitationsSplitFromRankingRows(rows) {
        const fn = typeof window.computeAiCitationsByCitedUrlSegment === 'function'
          ? window.computeAiCitationsByCitedUrlSegment
          : null;
        if (!fn) return null;
        const counts = fn(rows || []);
        const moneyTotal = (counts.money || 0);
        const landing = (counts.landing || 0);
        const event = (counts.event || 0);
        const product = (counts.product || 0);
        const denom = moneyTotal > 0 ? moneyTotal : 0;
        return {
          moneyTotal,
          landing,
          event,
          product,
          landingPct: denom > 0 ? Math.round((landing / denom) * 100) : 0,
          eventPct: denom > 0 ? Math.round((event / denom) * 100) : 0,
          productPct: denom > 0 ? Math.round((product / denom) * 100) : 0
        };
      }

      function toNum(v) {
        const n = typeof v === 'number' ? v : (v == null ? NaN : Number(v));
        return Number.isFinite(n) ? n : null;
      }

      function safeDiv(a, b) {
        const na = toNum(a);
        const nb = toNum(b);
        if (na == null || nb == null || nb === 0) return null;
        return na / nb;
      }

      function formatInt(v) {
        const n = toNum(v);
        if (n == null) return '';
        return Math.round(n).toLocaleString();
      }

      function formatFixed(v, decimals = 1) {
        const n = toNum(v);
        if (n == null) return '';
        return n.toFixed(decimals);
      }

      function formatPct(v, decimals = 1) {
        const n = toNum(v);
        if (n == null) return '';
        return `${n.toFixed(decimals)}%`;
      }

      function deltaDir(curr, prev, { betterLower = false } = {}) {
        const c = toNum(curr);
        const p = toNum(prev);
        if (c == null || p == null) return 'flat';
        if (c === p) return 'flat';
        // If lower is better (e.g., avg position), then a decrease is "up" (good).
        // Example: position 12.4 < 14.3 means improvement, so return 'up' (green)
        if (betterLower) {
          const dir = (c < p) ? 'up' : 'down';
          debugLog(`[Dashboard] deltaDir betterLower: current=${c}, previous=${p}, dir=${dir}`, 'info');
          return dir;
        }
        const dir = (c > p) ? 'up' : 'down';
        return dir;
      }

      function formatDeltaNumber(curr, prev, { decimals = 0, betterLower = false, pp = false } = {}) {
        const c = toNum(curr);
        const p = toNum(prev);
        if (c == null || p == null) return '';
        const raw = betterLower ? (p - c) : (c - p);
        const d = Number.isFinite(raw) ? raw : 0;
        const sign = d > 0 ? '+' : '';
        const base = decimals > 0 ? d.toFixed(decimals) : String(Math.round(d));
        return pp ? `${sign}${base}pp` : `${sign}${base}`;
      }

      function formatDeltaLabel(label, curr, prev, { decimals = 0, pp = false, betterLower = false } = {}) {
        const deltaText = formatDeltaNumber(curr, prev, { decimals, pp, betterLower });
        if (deltaText === '') return label;
        return `${label} (${deltaText})`;
      }

      function deltaLabelColor(curr, prev, { betterLower = false } = {}) {
        const c = toNum(curr);
        const p = toNum(prev);
        if (c == null || p == null) return 'rgba(226,232,240,0.9)';
        if (c === p) return 'rgba(226,232,240,0.9)';
        if (betterLower) return (c < p) ? '#10b981' : '#ef4444';
        return (c > p) ? '#10b981' : '#ef4444';
      }

      function formatSignedPp(value, decimals = 1) {
        const n = toNum(value);
        if (n == null) return '';
        const sign = n > 0 ? '+' : '';
        return `${sign}${n.toFixed(decimals)}pp`;
      }

      function shortenMiddle(text, maxLen = 42) {
        if (!text || text.length <= maxLen) return text;
        const keep = Math.max(8, Math.floor((maxLen - 3) / 2));
        return `${text.slice(0, keep)}...${text.slice(-keep)}`;
      }

      const dashboardRadarLabelPlugin = {
        id: 'dashboardRadarLabels',
        afterDraw(chart, args, pluginOptions) {
          const opts = pluginOptions || {};
          const labels = opts.labels || [];
          const deltas = opts.deltaTexts || [];
          const deltaColors = opts.deltaColors || [];
          const scale = chart?.scales?.r;
          if (!scale || labels.length === 0) return;
          const lineGap = typeof opts.lineGap === 'number' ? opts.lineGap : 12;
          const deltaGap = typeof opts.deltaGap === 'number' ? opts.deltaGap : 10;
          const labelPadding = typeof opts.labelPadding === 'number' ? opts.labelPadding : 8;
          const ctx = chart.ctx;
          ctx.save();
          for (let i = 0; i < labels.length; i += 1) {
            const label = labels[i] || '';
            const deltaRaw = deltas[i];
            const deltaText = (deltaRaw == null || deltaRaw === '') ? '' : String(deltaRaw);
            const pos = (typeof scale.getPointLabelPosition === 'function')
              ? scale.getPointLabelPosition(i)
              : null;
            if (!pos) continue;
            const angle = Math.atan2(pos.y - (scale.yCenter || 0), pos.x - (scale.xCenter || 0));
            const x = pos.x + Math.cos(angle) * labelPadding;
            const y = pos.y + Math.sin(angle) * labelPadding;

            const labelLines = (() => {
              if (label.includes(' / ')) {
                const parts = label.split(' / ').filter(Boolean);
                if (parts.length >= 2) return [parts[0], parts.slice(1).join(' / ')];
              }
              const words = label.split(' ').filter(Boolean);
              if (words.length === 2) return words;
              return [label];
            })();

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '600 11px system-ui, -apple-system, Segoe UI, sans-serif';
            ctx.fillStyle = 'rgba(226,232,240,0.9)';
            const startY = y - ((labelLines.length - 1) * lineGap) / 2;
            for (let j = 0; j < labelLines.length; j += 1) {
              ctx.fillText(labelLines[j], x, startY + (j * lineGap));
            }

            ctx.font = '700 10px system-ui, -apple-system, Segoe UI, sans-serif';
            ctx.fillStyle = (deltaRaw === '' || deltaRaw == null || deltaRaw === '')
              ? 'rgba(226,232,240,0.6)'
              : (deltaColors[i] || 'rgba(226,232,240,0.9)');
            ctx.fillText(deltaText, x, startY + (labelLines.length * lineGap) + deltaGap);
          }
          ctx.restore();
        }
      };

      function setDialDeltaDir(dialEl, curr, prev, { betterLower = false } = {}) {
        if (!dialEl) return;
        const deltaEl = dialEl.querySelector('[data-field="delta"]');
        if (!deltaEl) return;
        const dir = deltaDir(curr, prev, { betterLower });
        deltaEl.setAttribute('data-dir', dir);
      }

      function clearDeltaBreakdown(hostId) {
        const host = document.getElementById(hostId);
        if (host) host.innerHTML = '';
      }

      function renderDeltaBreakdown(hostId, items, { title = 'Change drivers' } = {}) {
        const host = document.getElementById(hostId);
        if (!host) return;
        if (!Array.isArray(items) || items.length === 0) {
          host.innerHTML = '';
          return;
        }
        const hasDelta = items.some(it => toNum(it?.curr) != null && toNum(it?.prev) != null);
        if (!hasDelta) {
          host.innerHTML = `<div class="dashboard-mini-note">No prior snapshot yet.</div>`;
          return;
        }
        const rows = items.map(it => {
          const deltaText = formatDeltaNumber(it.curr, it.prev, {
            decimals: it.decimals ?? 0,
            betterLower: it.betterLower ?? false,
            pp: it.pp ?? false
          });
          const dir = deltaDir(it.curr, it.prev, { betterLower: it.betterLower ?? false });
          return `
            <div class="dashboard-delta-row">
              <span class="dashboard-delta-label">${it.label}</span>
              <span class="dashboard-kpi-delta" data-dir="${dir}">${deltaText}</span>
            </div>
          `;
        }).join('');
        host.innerHTML = `
          <div class="dashboard-delta-breakdown">
            <div class="dashboard-delta-breakdown-title">${title}</div>
            ${rows}
          </div>
        `;
      }

      function computePillarScoresFromAudit(audit) {
        const scores = audit?.scores || null;
        if (!scores) return null;
        return {
          authority: toNum(scores.authority?.score ?? scores.authority) ?? null,
          contentSchema: toNum(scores.contentSchema) ?? null,
          visibility: toNum(scores.visibility) ?? null,
          localEntity: toNum(scores.localEntity) ?? null,
          serviceArea: toNum(scores.serviceArea) ?? null,
        };
      }

      function computeAuditKpisFromAudit(audit) {
        const sd = audit?.searchData || null;
        if (!sd) return null;
        return {
          clicks: toNum(sd.totalClicks) ?? 0,
          impressions: toNum(sd.totalImpressions) ?? 0,
          avgPosition: toNum(sd.averagePosition),
          ctrPct: toNum(sd.ctr),
        };
      }

      function getRankFromRow(row) {
        const candidates = [
          // Ranking & AI module uses these fields
          row?.best_rank_group,
          row?.best_rank_absolute,
          row?.current_rank,
          // Common alternatives
          row?.rank,
          row?.rank_position,
          row?.rankPosition,
          row?.position,
          row?.avgPosition,
          row?.gsc_avg_position,
        ];
        for (const v of candidates) {
          const n = toNum(v);
          if (n != null && n > 0) return n;
        }
        return null;
      }

      function computeRankingKpisFromRows(rows) {
        const list = Array.isArray(rows) ? rows : [];
        let ranked = 0;
        let top3 = 0;
        let top10 = 0;
        let citationsTotal = 0;
        let aiOverviews = 0;
        for (const r of list) {
          const rank = getRankFromRow(r);
          if (rank != null) {
            ranked += 1;
            if (rank <= 3) top3 += 1;
            if (rank <= 10) top10 += 1;
          }
          const cit = toNum(r?.ai_alan_citations_count ?? r?.aiAlanCitationsCount);
          if (cit != null) citationsTotal += cit;
          const hasAio = (r?.ai_overview_present_any ?? r?.aiOverviewPresentAny ?? r?.has_ai_overview ?? r?.hasAiOverview);
          if (hasAio === true) aiOverviews += 1;
        }
        const top3SharePct = ranked > 0 ? Math.round((top3 / ranked) * 100) : null;
        const top10SharePct = ranked > 0 ? Math.round((top10 / ranked) * 100) : null;
        return { ranked, top3SharePct, top10SharePct, citationsTotal, aiOverviews };
      }

      function computeMoneyPagesAggregateFromMetrics(moneyMetrics) {
        const rows = moneyMetrics?.rows;
        if (!Array.isArray(rows) || rows.length === 0) return null;
        let clicks = 0;
        let impressions = 0;
        let weightedPosImps = 0;
        for (const r of rows) {
          const c = toNum(r?.clicks) ?? 0;
          const i = toNum(r?.impressions) ?? 0;
          const p = toNum(r?.avgPosition ?? r?.position);
          clicks += c;
          impressions += i;
          if (p != null && i > 0) weightedPosImps += (p * i);
        }
        const ctrPct = impressions > 0 ? (clicks / impressions) * 100 : null;
        const avgPosition = (impressions > 0 && weightedPosImps > 0) ? (weightedPosImps / impressions) : null;

        // CTR targets (provide both so you can choose later)
        const targetCtrAbsPct = 2.5; // absolute
        const targetCtrPlusPp = (ctrPct != null) ? (ctrPct + 0.3) : null; // +0.3pp

        const extraClicksAbs = (ctrPct != null && impressions > 0)
          ? Math.max(0, Math.round((impressions * (targetCtrAbsPct / 100)) - clicks))
          : null;
        const extraClicksPlus = (targetCtrPlusPp != null && impressions > 0)
          ? Math.max(0, Math.round((impressions * (targetCtrPlusPp / 100)) - clicks))
          : null;

        // Position targets (also provide two)
        const targetPosAbs = 10;
        const targetPosMinus2 = (avgPosition != null) ? Math.max(1, avgPosition - 2) : null;

        return {
          clicks,
          impressions,
          ctrPct,
          avgPosition,
          targets: {
            ctrAbsPct: targetCtrAbsPct,
            ctrPlusPp: targetCtrPlusPp,
            posAbs: targetPosAbs,
            posMinus2: targetPosMinus2
          },
          uplift: {
            extraClicksAbs,
            extraClicksPlus
          }
        };
      }

      function isOptimisationDataLoadedForDashboard() {
        const state = window.optimisationModuleState;
        // optimisationModuleState exists even before tasks are actually loaded, so avoid treating
        // an empty default state as "loaded" (otherwise dashboard shows misleading 0s / 100%).
        const hasKey = (typeof window.hasAdminKey === 'function') ? window.hasAdminKey() : false;
        const hasState = !!state && Array.isArray(state.allTasks);
        const hasTasks = hasState && state.allTasks.length > 0;
        // Consider loaded if we have tasks OR if dashboard tiles/impact/timeseries are available
        // (dashboard tiles might not always be available, but tasks are the important part)
        const loadedViaApi = !!state && (
          hasTasks ||
          state.dashboardTiles !== null ||
          state.dashboardImpact !== null ||
          state.dashboardTimeseries !== null
        );
        return !!hasState && !!hasKey && !state.authError && loadedViaApi;
      }

      function getOptimisationTasksForDashboard() {
        const state = window.optimisationModuleState;
        if (!state || !Array.isArray(state.allTasks)) return [];

        let tasks = state.allTasks;
        const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
        if (!includeTestCheckbox || !includeTestCheckbox.checked) {
          tasks = tasks.filter(t => !t.is_test_task);
        }
        return tasks;
      }

      function computeExecutionFromTasks(tasks, isLoaded) {
        if (!isLoaded) {
          return { active: null, updated28d: null, pct: null };
        }
        const activeStatuses = ['planned', 'in_progress', 'monitoring'];
        const activeTasks = (tasks || []).filter(t => activeStatuses.includes(t.status));

        const scope = window.optimisationModuleState?.scope || 'active_cycle';
        const getLatest = typeof window.getLatestMeasurementInScope === 'function'
          ? window.getLatestMeasurementInScope
          : null;

        if (!getLatest) {
          return { active: activeTasks.length, updated28d: null, pct: null };
        }

        const twentyEightDaysAgo = new Date();
        twentyEightDaysAgo.setDate(twentyEightDaysAgo.getDate() - 28);

        let updated = 0;
        for (const task of activeTasks) {
          const latest = getLatest(task, scope);
          if (!latest || !latest.captured_at) continue;
          const d = new Date(latest.captured_at);
          if (!Number.isNaN(d.getTime()) && d >= twentyEightDaysAgo) updated += 1;
        }

        // If there are no active tasks, don't pretend it's "100% updated"  show neutral.
        if (activeTasks.length === 0) {
          return { active: 0, updated28d: 0, pct: null };
        }

        const pct = Math.round((updated / activeTasks.length) * 100);
        return { active: activeTasks.length, updated28d: updated, pct };
      }

      function computeEeatConfidence({ hasBacklinks, hasDomainStrength, hasAiCitations, hasLocalSignals }) {
        const signals = [hasBacklinks, hasDomainStrength, hasAiCitations, hasLocalSignals].filter(Boolean).length;
        if (signals >= 3) return 'High';
        if (signals >= 2) return 'Medium';
        return 'Low';
      }

      function computeEeatScore({ audit, pillars, rankingKpis, domainStrength }) {
        const ac = audit?.scores?.authorityComponents || audit?.authorityComponents || null;
        const behaviour = toNum(ac?.behaviour);
        const reviews = toNum(ac?.reviews);

        // Backlinks: only treat as "measured" if backlinkMetrics exist (otherwise computeBacklinkScore returns 0)
        const hasBacklinks = !!audit?.backlinkMetrics;
        const backlinksRaw = toNum(ac?.backlinks);
        const backlinks = hasBacklinks ? backlinksRaw : 50;

        // Local signals / NAP
        const localSignals = audit?.localSignals || audit?.localSignalsSnapshot || null;
        const localData = localSignals
          ? ((localSignals.status && localSignals.status === 'ok' && localSignals.data) ? localSignals.data : (localSignals.data || localSignals))
          : null;
        const nap = toNum(localData?.napConsistencyScore);
        const hasLocalSignals = nap != null || localData?.knowledgePanelDetected === true || (Array.isArray(localData?.locations) && localData.locations.length > 0);

        // Core pillar scores
        const localEntity = toNum(pillars?.localEntity);
        const contentSchema = toNum(pillars?.contentSchema);
        const snippet = toNum((audit?.snippetReadiness && typeof audit.snippetReadiness === 'object') ? audit.snippetReadiness.overallScore : audit?.snippetReadiness);

        // Domain Strength (0100)
        const domainScoreRaw = toNum(domainStrength?.selfScore);
        const hasDomainStrength = typeof domainScoreRaw === 'number';
        const domainScore = hasDomainStrength ? clampScore(domainScoreRaw) : 50;

        // AI citations signal (cap 0100)
        const citationsTotal = toNum(rankingKpis?.citationsTotal);
        const hasAiCitations = typeof citationsTotal === 'number';
        const citationsSignal = hasAiCitations ? Math.max(0, Math.min(100, citationsTotal)) : 50;

        // Sub-scores (EEAT v1)
        const safe50 = (v) => (typeof v === 'number' ? v : 50);
        const trustNap = (typeof nap === 'number') ? clampScore(nap) : safe50(localEntity);
        const experience = clampScore(0.5 * safe50(reviews) + 0.3 * safe50(behaviour) + 0.2 * safe50(localEntity));
        const expertise = clampScore(0.6 * safe50(contentSchema) + 0.4 * safe50(snippet));
        const authoritativeness = clampScore(0.5 * safe50(backlinks) + 0.3 * safe50(domainScore) + 0.2 * safe50(citationsSignal));
        const trustworthiness = clampScore(0.6 * trustNap + 0.4 * safe50(reviews));

        const eeat = clampScore(
          0.2 * experience +
          0.25 * expertise +
          0.3 * authoritativeness +
          0.25 * trustworthiness
        );

        const confidence = computeEeatConfidence({
          hasBacklinks,
          hasDomainStrength,
          hasAiCitations,
          hasLocalSignals
        });

        return {
          score: Math.round(eeat),
          confidence,
          subscores: {
            experience: Math.round(experience),
            expertise: Math.round(expertise),
            authoritativeness: Math.round(authoritativeness),
            trustworthiness: Math.round(trustworthiness)
          }
        };
      }

      function computeDashboardSnapshot() {
        const audit = dashboardSafeJsonParse(localStorage.getItem('last_audit_results'), null);
        const hasAudit = audit && audit.scores;

        let gaioScore = null;
        let aiSummaryScore = null;
        let aiSummaryComponents = null;
        if (hasAudit && typeof window.calculateAiGeoScore === 'function') {
          const health = window.calculateAiGeoScore(audit.scores, audit.schemaAudit || null, audit.snippetReadiness || null);
          gaioScore = typeof health.aiGeoScore === 'number' ? health.aiGeoScore : null;
          aiSummaryScore = typeof health.aiSummary?.score === 'number' ? Math.round(health.aiSummary.score) : null;
          
          // Extract AI Summary components for radar chart
          let snippetReadinessScore = typeof audit.snippetReadiness === 'number' 
            ? audit.snippetReadiness 
            : (audit.snippetReadiness?.overallScore || 0);
          
          // If snippetReadiness is 0 or invalid but we have component scores, recalculate it
          // (Same logic as in snippet readiness gauge display)
          if (snippetReadinessScore === 0 && audit.scores && 
              (audit.scores.contentSchema != null || audit.scores.visibility != null || audit.scores.authority != null) &&
              typeof calculateSnippetReadiness === 'function') {
            snippetReadinessScore = calculateSnippetReadiness(audit.scores, audit.searchData || {});
            console.log('[Dashboard] Recalculated snippetReadiness from scores:', snippetReadinessScore);
          }
          
          // Get visibility score directly from audit (pillars computed later)
          const visibilityScore = (typeof audit.scores?.visibility === 'number') ? audit.scores.visibility : null;
          const brandScore = (typeof audit.scores?.brandOverlay?.score === 'number') ? audit.scores.brandOverlay.score : null;
          if (snippetReadinessScore > 0 || visibilityScore != null || brandScore != null) {
            aiSummaryComponents = {
              snippetReadiness: snippetReadinessScore,
              visibility: visibilityScore,
              brand: brandScore
            };
          }
        }

        const rankingRows = getRankingAiRowsFromStorage();
        const moneyShare = computeMoneyCitationsShareFromRankingRows(rankingRows);
        const moneyShareSplit = computeMoneyCitationsSplitFromRankingRows(rankingRows);
        const rankingKpis = computeRankingKpisFromRows(rankingRows);

        const pillars = computePillarScoresFromAudit(audit);
        const auditKpis = computeAuditKpisFromAudit(audit);

        const moneyMetricsFromAudit = audit?.scores?.moneyPagesMetrics || audit?.moneyPagesMetrics || null;
        const moneyAgg = computeMoneyPagesAggregateFromMetrics(moneyMetricsFromAudit);

        const tasks = getOptimisationTasksForDashboard();
        const exec = computeExecutionFromTasks(tasks, isOptimisationDataLoadedForDashboard());

        const optLoaded = isOptimisationDataLoadedForDashboard();
        const estimateFn = (typeof window.computeEstimatedExtraClicks28d === 'function') ? window.computeEstimatedExtraClicks28d : null;
        let optimisationPotentialClicks = null;
        if (optLoaded && estimateFn) {
          const activeStatuses = ['planned', 'in_progress', 'monitoring'];
          let sum = 0;
          for (const t of tasks) {
            if (!activeStatuses.includes(t.status)) continue;
            const v = toNum(estimateFn(t));
            if (v != null) sum += v;
          }
          optimisationPotentialClicks = Math.round(sum);
        }

        // Fetch domain strength data with rolling 28-day deltas
        let domainCache = dashboardSafeJsonParse(localStorage.getItem('dashboard_domain_strength_cache_v4'), null)
          || dashboardSafeJsonParse(localStorage.getItem('dashboard_domain_strength_cache_v3'), null)
          || dashboardSafeJsonParse(localStorage.getItem('dashboard_domain_strength_cache_v2'), null)
          || dashboardSafeJsonParse(localStorage.getItem('dashboard_domain_strength_cache_v1'), null);
        
        // If cache doesn't have deltas, fetch from overview + history APIs to calculate rolling 28-day delta (non-blocking - don't await)
        // This ensures dashboard still renders even if API call fails or is slow
        // Use a flag to prevent infinite loops
        // Also check if delta is null/undefined (not just missing) - if it's "0" that's valid
        const hasValidDelta = domainCache && domainCache.deltas && domainCache.deltas.selfScore !== undefined && domainCache.deltas.selfScore !== null;
        if (!hasValidDelta) {
          // Check if we're already fetching to prevent multiple simultaneous calls
          // Also check if we've already fetched recently (within last 10 seconds) to prevent loops
          const lastFetchTime = window.__domainStrengthLastFetchTime || 0;
          const timeSinceLastFetch = Date.now() - lastFetchTime;
          if (!window.__domainStrengthFetching && timeSinceLastFetch > 10000) {
            window.__domainStrengthFetching = true;
            window.__domainStrengthLastFetchTime = Date.now();
            // Start async fetch but don't block - dashboard will render with cached data
            (async () => {
              try {
                const selfDomain = (typeof window.getSelfDomainForDomainStrength === 'function' 
                  ? window.getSelfDomainForDomainStrength() 
                  : null) || localStorage.getItem('gsc_property_url') || 'https://www.alanranger.com';
                const normalizedDomain = String(selfDomain).replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0];
                
                const urlHelper = typeof window.apiUrl === 'function' ? window.apiUrl : ((path) => {
                  const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                  const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
                  const cleanPath = path.startsWith('/') ? path : `/${path}`;
                  return baseUrl ? `${baseUrl}${cleanPath}` : cleanPath;
                });
                
                // Fetch both overview (for latest score) and history (for rolling 28-day delta)
                const [overviewResp, historyResp] = await Promise.all([
                  fetch(urlHelper(`/api/domain-strength/overview`)),
                  fetch(urlHelper(`/api/domain-strength/history?domains=${encodeURIComponent(normalizedDomain)}`))
                ]);
                
                if (overviewResp.ok && historyResp.ok) {
                  const overviewJson = await overviewResp.json();
                  const historyJson = await historyResp.json();
                  
                  if (overviewJson?.status === 'ok' && Array.isArray(overviewJson.items)) {
                    // Find our domain in the overview response
                    const ourItem = overviewJson.items.find(item => {
                      const itemDomain = String(item?.domain || '').replace(/^www\./, '').toLowerCase();
                      return itemDomain === normalizedDomain.toLowerCase();
                    });
                    
                    if (ourItem && ourItem.latest) {
                      const latest = ourItem.latest;
                      const ourScore = typeof latest.score === 'number' ? latest.score : null;
                      const latestSnapshotDate = latest.snapshotDate || null;
                      
                      // Calculate rolling 28-day delta from history
                      let rolling28DayDelta = null;
                      if (historyJson?.status === 'ok' && Array.isArray(historyJson.data) && latestSnapshotDate && ourScore !== null) {
                        // Calculate target date: 27 days before latest snapshot date
                        const latestDate = new Date(latestSnapshotDate);
                        const targetDate = new Date(latestDate);
                        targetDate.setUTCDate(targetDate.getUTCDate() - 27);
                        const targetDateStr = targetDate.toISOString().slice(0, 10);
                        
                        // Find snapshot closest to target date (27 days ago)
                        const snapshots = historyJson.data
                          .filter(s => s.domain === normalizedDomain && s.engine === 'google')
                          .map(s => ({
                            snapshot_date: s.snapshot_date,
                            score: typeof s.score === 'number' ? s.score : null
                          }))
                          .filter(s => s.score !== null)
                          .sort((a, b) => {
                            const dateA = new Date(a.snapshot_date);
                            const dateB = new Date(b.snapshot_date);
                            return dateB - dateA; // Descending (newest first)
                          });
                        
                        // Find snapshot closest to target date (prefer on or before target)
                        let bestMatch = null;
                        let bestDiff = Infinity;
                        for (const snap of snapshots) {
                          const snapDate = new Date(snap.snapshot_date);
                          const diff = Math.abs(snapDate - targetDate);
                          if (diff < bestDiff) {
                            bestDiff = diff;
                            bestMatch = snap;
                          }
                          // Prefer snapshots on or before target date
                          if (snapDate <= targetDate) {
                            bestMatch = snap;
                            break;
                          }
                        }
                        
                        if (bestMatch && bestMatch.score !== null) {
                          rolling28DayDelta = ourScore - bestMatch.score;
                          const daysDiff = Math.round((latestDate - new Date(bestMatch.snapshot_date)) / (1000 * 60 * 60 * 24));
                          debugLog(`[Dashboard] Domain strength rolling 28-day delta: ${rolling28DayDelta.toFixed(1)} (from ${bestMatch.snapshot_date}, ${daysDiff} days ago)`, 'info');
                        }
                      }
                      
                      // Fallback to API's deltaLatest if rolling 28-day calculation failed
                      if (rolling28DayDelta === null && ourItem.trend) {
                        rolling28DayDelta = typeof ourItem.trend.deltaLatest === 'number' ? ourItem.trend.deltaLatest : null;
                        if (rolling28DayDelta !== null) {
                          debugLog('[Dashboard] Domain strength using API deltaLatest as fallback', 'info');
                        }
                      }
                      
                      // Calculate gap to top and stronger domains count
                      const allScores = overviewJson.items
                        .map(item => typeof item.latest?.score === 'number' ? item.latest.score : null)
                        .filter(score => score !== null)
                        .sort((a, b) => b - a);
                      
                      const topScore = allScores.length > 0 ? allScores[0] : null;
                      const gapTop = (topScore !== null && ourScore !== null) ? (topScore - ourScore) : null;
                      const strongerCount = ourScore !== null ? allScores.filter(s => s > ourScore).length : null;
                      
                      // Calculate rank vs set
                      const ourRank = ourScore !== null ? allScores.filter(s => s > ourScore).length + 1 : null;
                      const totalDomains = allScores.length;
                      const rankVs = (ourRank !== null && totalDomains > 0) ? `${ourRank}/${totalDomains}` : null;
                      
                      // Format rolling 28-day delta
                      let deltaText = null;
                      if (rolling28DayDelta !== null && isFinite(rolling28DayDelta)) {
                        const sign = rolling28DayDelta > 0 ? '+' : '';
                        deltaText = `${sign}${rolling28DayDelta.toFixed(1)}`;
                      }
                      
                      // Build cache object with rolling 28-day deltas
                      const newCache = {
                        selfScore: ourScore,
                        gapTop: gapTop,
                        stronger: strongerCount,
                        rankVs: rankVs,
                        snapshotDate: latestSnapshotDate,
                        kpis: {
                          selfScore: ourScore !== null ? ourScore.toFixed(1) : null,
                          gapTop: gapTop !== null ? `+${gapTop.toFixed(1)}` : null,
                          stronger: strongerCount !== null ? String(strongerCount) : null,
                          rankVs: rankVs
                        },
                        deltas: {
                          selfScore: deltaText,
                          gapTop: null, // Gap to top delta would need previous gap calculation
                          stronger: null // Stronger count delta would need previous count
                        },
                        dirs: {
                          selfScore: rolling28DayDelta !== null ? (rolling28DayDelta > 0 ? 'up' : rolling28DayDelta < 0 ? 'down' : 'flat') : 'flat',
                          gapTop: 'flat',
                          stronger: 'flat'
                        }
                      };
                      
                      // Save to cache
                      localStorage.setItem('dashboard_domain_strength_cache_v4', JSON.stringify(newCache));
                      
                      // Update domain strength tile directly without re-rendering entire dashboard
                      // This prevents infinite loops while still showing updated delta
                      // The tile will update on next manual refresh or when dashboard is re-rendered for other reasons
                      debugLog('[Dashboard] Domain strength cache updated with rolling 28-day deltas', 'success');
                    }
                  }
                }
              } catch (err) {
                debugLog(`[Dashboard] Failed to fetch domain strength for rolling 28-day delta: ${err.message}`, 'warn');
              } finally {
                window.__domainStrengthFetching = false;
              }
            })();
          }
        }

        const eeat = computeEeatScore({
          audit,
          pillars,
          rankingKpis,
          domainStrength: domainCache
        });

        return {
          gaioScore,
          aiSummaryScore,
          aiSummaryComponents,
          eeatScore: eeat?.score ?? null,
          eeatConfidence: eeat?.confidence ?? null,
          eeatSubscores: eeat?.subscores ?? null,
          pillars,
          auditKpis,
          rankingKpis,
          moneyCitations: moneyShare.money,
          totalCitations: moneyShare.total,
          moneySharePct: moneyShare.pct,
          moneyShareSplit,
          moneyAgg,
          execActive: exec.active,
          execUpdated28d: exec.updated28d,
          execPct: exec.pct,
          optimisationPotentialClicks,
          domainStrength: domainCache,
          moneyPagesRows: moneyMetricsFromAudit?.rows || null
        };
      }

      function setDial(el, { valueText, pct, rag, deltaText }) {
        if (!el) return;
        const safePct = Math.max(0, Math.min(100, typeof pct === 'number' ? pct : 0));
        el.style.setProperty('--pct', String(safePct));
        el.style.setProperty('--accent', ragToAccent(rag));
        const valueEl = el.querySelector('[data-field="value"]');
        const deltaEl = el.querySelector('[data-field="delta"]');
        if (valueEl) valueEl.textContent = valueText || '';
        if (deltaEl) deltaEl.textContent = deltaText || '';
      }

      function updateDeltaIndicator(elId, curr, prev, { betterLower = false, decimals = 0, pp = false } = {}) {
        const el = document.getElementById(elId);
        if (!el) return;
        
        // If no current value, hide indicator
        if (typeof curr !== 'number') {
          el.style.display = 'none';
          return;
        }
        
        // If no previous value, show "N/A" or ""
        if (typeof prev !== 'number') {
          el.setAttribute('data-dir', 'flat');
          el.innerHTML = `<span class="delta-arrow"></span> N/A`;
          el.style.display = 'inline-flex';
          return;
        }
        
        const delta = curr - prev;
        
        // If delta is 0, show "0" with flat styling
        if (delta === 0) {
          el.setAttribute('data-dir', 'flat');
          el.innerHTML = `<span class="delta-arrow"></span> 0`;
          el.style.display = 'inline-flex';
          return;
        }
        
        const isBetter = betterLower ? delta < 0 : delta > 0;
        const dir = isBetter ? 'up' : 'down';
        const arrow = isBetter ? '' : '';
        
        let deltaText = '';
        if (pp) {
          deltaText = `${delta > 0 ? '+' : ''}${delta.toFixed(decimals)}pp`;
        } else {
          deltaText = `${delta > 0 ? '+' : ''}${delta.toFixed(decimals)}`;
        }
        
        el.setAttribute('data-dir', dir);
        el.innerHTML = `<span class="delta-arrow">${arrow}</span> ${deltaText}`;
        el.style.display = 'inline-flex';
      }

      function formatDelta(curr, prev) {
        if (typeof curr !== 'number' || typeof prev !== 'number') return '';
        const d = curr - prev;
        if (d === 0) return '0';
        const sign = d > 0 ? '+' : '';
        return `${sign}${Math.round(d)}`;
      }

      function computeFreshnessBadge(timestampIso, { warnDays = 3, staleDays = 7 } = {}) {
        if (!timestampIso) {
          return { rag: 'neutral', label: 'Not run', daysOld: null };
        }
        const d = new Date(timestampIso);
        if (Number.isNaN(d.getTime())) {
          return { rag: 'neutral', label: 'Not run', daysOld: null };
        }
        const ms = Date.now() - d.getTime();
        const daysOld = Math.floor(ms / (1000 * 60 * 60 * 24));
        if (daysOld >= staleDays) return { rag: 'red', label: `Stale (${daysOld}d)`, daysOld };
        if (daysOld >= warnDays) return { rag: 'amber', label: `Stale (${daysOld}d)`, daysOld };
        return { rag: 'green', label: 'Fresh', daysOld };
      }

      function renderDashboardSummaryCards({ audit, ranking, moneyPages, optimisation, domainStrength }) {
        const grid = document.getElementById('dashboard-summary-grid');
        if (!grid) return;

        const jumpBtn = (label, panelId) => `
          <button type="button" class="btn" style="padding: 0.45rem 0.85rem; font-size: 0.9rem;"
            onclick="if (typeof setActivePanel === 'function') setActivePanel('${panelId}')">
            ${label}
          </button>
        `;

        const runBtn = (label, onClick, title = '') => `
          <button type="button" class="btn" style="padding: 0.45rem 0.85rem; font-size: 0.9rem; background:#0f172a; border:1px solid rgba(148,163,184,0.25);"
            title="${title || ''}"
            onclick="${onClick}">
            ${label}
          </button>
        `;

        const ragPill = (rag, label) => `
          <span class="dashboard-rag-pill" data-rag="${rag}">
            ${label}
          </span>
        `;

        const tile = (label, value, deltaText, dir = 'flat', title = '') => {
          // Only show top-right corner indicator if delta is NOT shown in tile content (i.e., when deltaText is empty/N/A)
          // This prevents duplicate delta displays
          let indicatorHtml = '';
          const hasDeltaInTile = deltaText && deltaText !== '' && deltaText !== '' && deltaText !== '0';
          
          // Only show corner indicator when there's no delta in the tile content
          if (!hasDeltaInTile) {
            if (deltaText === '0') {
              indicatorHtml = `<div class="dashboard-kpi-tile-indicator" data-dir="flat"><span class="delta-arrow"></span> 0</div>`;
            } else {
              // Show N/A when no delta data available
              indicatorHtml = `<div class="dashboard-kpi-tile-indicator" data-dir="flat"><span class="delta-arrow"></span> N/A</div>`;
            }
          }
          
          return `
            <div class="dashboard-kpi-tile" title="${title || ''}">
              ${indicatorHtml}
              <div class="dashboard-kpi-label">${label}</div>
              <div class="dashboard-kpi-value">${value}</div>
              ${hasDeltaInTile ? `<div class="dashboard-kpi-delta" data-dir="${dir}">${deltaText}</div>` : ''}
            </div>
          `;
        };

        const trafficTile = (label, counts, title = '') => {
          const c = counts || {};
          const w = (typeof c.worse === 'number') ? c.worse : '';
          const s = (typeof c.same === 'number') ? c.same : '';
          const b = (typeof c.better === 'number') ? c.better : '';
          return `
            <div class="dashboard-kpi-tile" title="${title || ''}">
              <div class="dashboard-kpi-label">${label}</div>
              <div class="dashboard-traffic-row">
                <span class="dashboard-traffic-pill" data-bucket="worse">${w} Worse</span>
                <span class="dashboard-traffic-pill" data-bucket="same">${s} Same</span>
                <span class="dashboard-traffic-pill" data-bucket="better">${b} Better</span>
              </div>
            </div>
          `;
        };

        grid.innerHTML = `
          <div class="card dashboard-summary-card" data-rag="${audit?.rag || 'neutral'}" title="Audit Scan: latest GSC clicks/impressions/avg position/CTR for the whole site. Deltas compare vs the previous global run.">
            <div class="dashboard-summary-header">
              <div>
                <div class="dashboard-summary-title"> Audit Scan</div>
                <div class="dashboard-summary-subtitle">${audit?.timestamp ? `Last audit: ${formatUtcTimestamp(audit.timestamp)}` : 'No audit data yet'}</div>
              </div>
              <div style="display:flex; gap:0.5rem; flex-wrap: wrap; align-items: center;">
                ${ragPill(audit?.rag || 'neutral', audit?.ragLabel || 'Unknown')}
                ${jumpBtn('Open', 'overview')}
              </div>
            </div>
            <div class="dashboard-kpi-grid">
              ${tile('Clicks (28d)', audit?.kpis?.clicks ?? '', audit?.deltas?.clicks ?? '', audit?.dirs?.clicks ?? 'flat', 'Total Google Search Console clicks over the last 28 days.')}
              ${tile('Impressions (28d)', audit?.kpis?.impressions ?? '', audit?.deltas?.impressions ?? '', audit?.dirs?.impressions ?? 'flat', 'Total Google Search Console impressions over the last 28 days.')}
              ${tile('Avg position', audit?.kpis?.avgPosition ?? '', audit?.deltas?.avgPosition ?? '', audit?.dirs?.avgPosition ?? 'flat', 'Average Search Console position (lower is better).')}
              ${tile('CTR', audit?.kpis?.ctr ?? '', audit?.deltas?.ctr ?? '', audit?.dirs?.ctr ?? 'flat', 'Clicks  impressions (last 28 days).')}
            </div>
          </div>

          <div class="card dashboard-summary-card" data-rag="${ranking?.rag || 'neutral'}" title="Keyword Ranking and AI: top-3/top-10 share plus AI citations signals from the latest keyword scan.">
            <div class="dashboard-summary-header">
              <div>
                <div class="dashboard-summary-title"> Keyword Ranking and AI</div>
                <div class="dashboard-summary-subtitle">${ranking?.timestamp ? `Last scan: ${formatUtcTimestamp(ranking.timestamp)}` : 'No Keyword Ranking and AI data yet'}</div>
              </div>
              <div style="display:flex; gap:0.5rem; flex-wrap: wrap; align-items: center;">
                ${ragPill(ranking?.rag || 'neutral', ranking?.ragLabel || 'Unknown')}
                ${ranking?.run ? runBtn(ranking.run.label || 'Run scan', ranking.run.onClick || '', ranking.run.title || '') : ''}
                ${jumpBtn('Open', 'ranking')}
              </div>
            </div>
            <div class="dashboard-kpi-grid">
              ${tile('Top 3 share', ranking?.kpis?.top3Share ?? '', ranking?.deltas?.top3Share ?? '', ranking?.dirs?.top3Share ?? 'flat', 'Share of ranked tracked keywords currently in positions 13.')}
              ${tile('Top 10 share', ranking?.kpis?.top10Share ?? '', ranking?.deltas?.top10Share ?? '', ranking?.dirs?.top10Share ?? 'flat', 'Share of ranked tracked keywords currently in positions 110.')}
              ${tile('AI citations', ranking?.kpis?.citations ?? '', ranking?.deltas?.citations ?? '', ranking?.dirs?.citations ?? 'flat', 'Total AI citations found across tracked keywords in the latest scan.')}
              ${tile('Money share', ranking?.kpis?.moneyShare ?? '', ranking?.deltas?.moneyShare ?? '', ranking?.dirs?.moneyShare ?? 'flat', 'Percent of AI citations that land on Money Pages.')}
            </div>
          </div>

          <div class="card dashboard-summary-card" data-rag="${moneyPages?.rag || 'neutral'}" title="URL Money Pages: business-impact metrics for your Money Pages segment (last 28 days) and the CTR-gap uplift estimate.">
            <div class="dashboard-summary-header">
              <div>
                <div class="dashboard-summary-title"> URL Money Pages</div>
                <div class="dashboard-summary-subtitle">${moneyPages?.note || 'Uses latest URL Money Pages metrics from the latest audit'}</div>
              </div>
              <div style="display:flex; gap:0.5rem; flex-wrap: wrap; align-items: center;">
                ${ragPill(moneyPages?.rag || 'neutral', moneyPages?.ragLabel || 'Unknown')}
                ${moneyPages?.run ? runBtn(moneyPages.run.label || 'Run scan', moneyPages.run.onClick || '', moneyPages.run.title || '') : ''}
                ${jumpBtn('Open', 'money')}
              </div>
            </div>
            <div class="dashboard-kpi-grid">
              ${tile('Money clicks (28d)', moneyPages?.kpis?.clicks ?? '', moneyPages?.deltas?.clicks ?? '', moneyPages?.dirs?.clicks ?? 'flat', 'Total clicks to Money Pages over the last 28 days.')}
              ${tile('Money CTR', moneyPages?.kpis?.ctr ?? '', moneyPages?.deltas?.ctr ?? '', moneyPages?.dirs?.ctr ?? 'flat', 'CTR across Money Pages (last 28 days).')}
              ${tile('Money avg pos', moneyPages?.kpis?.avgPosition ?? '', moneyPages?.deltas?.avgPosition ?? '', moneyPages?.dirs?.avgPosition ?? 'flat', 'Average position across Money Pages (lower is better).')}
              ${tile('Uplift remaining', moneyPages?.kpis?.uplift ?? '', moneyPages?.deltas?.uplift ?? '', moneyPages?.dirs?.uplift ?? 'flat', 'Estimated extra clicks available if Money Pages CTR reaches the target.')}
            </div>
          </div>

          <div class="card dashboard-summary-card" data-rag="${optimisation?.rag || 'neutral'}" title="Optimisation: live task movement using the Optimisation module traffic-light logic (worse/same/better) plus remaining uplift.">
            <div class="dashboard-summary-header">
              <div>
                <div class="dashboard-summary-title"> Optimisation</div>
                <div class="dashboard-summary-subtitle">${optimisation?.note || 'Uses tasks loaded in this browser session'}</div>
              </div>
              <div style="display:flex; gap:0.5rem; flex-wrap: wrap; align-items: center;">
                ${ragPill(optimisation?.rag || 'neutral', optimisation?.ragLabel || 'Unknown')}
                ${jumpBtn('Open', 'optimisation')}
              </div>
            </div>
            <div class="dashboard-kpi-grid">
              ${tile('Potential uplift (28d)', optimisation?.kpis?.potential ?? '', optimisation?.deltas?.potential ?? '', optimisation?.dirs?.potential ?? 'flat', 'Sum of estimated extra clicks (28d) across active optimisation tasks (CTR gap logic).')}
              ${trafficTile('Tasks (All metrics)', optimisation?.kpis?.trafficAll ?? null, 'Worse/Same/Better for active tasks (majority outcome across their objective KPI).')}
              ${trafficTile('CTR', optimisation?.kpis?.trafficCtr ?? null, 'Worse/Same/Better for tasks whose objective KPI is CTR (28d).')}
              ${trafficTile('AI citations', optimisation?.kpis?.trafficCitations ?? null, 'Worse/Same/Better for tasks whose objective KPI is AI citations.')}
            </div>
          </div>

          <div class="card dashboard-summary-card" data-rag="${domainStrength?.rag || 'neutral'}" title="Domain Strength: your latest monthly score and the gap vs the strongest competitor in the snapshot set.">
            <div class="dashboard-summary-header">
              <div>
                <div class="dashboard-summary-title"> Domain Strength</div>
                <div class="dashboard-summary-subtitle">${domainStrength?.note || 'Latest snapshot (this month) + competitor gap'}</div>
              </div>
              <div style="display:flex; gap:0.5rem; flex-wrap: wrap; align-items: center;">
                ${ragPill(domainStrength?.rag || 'neutral', domainStrength?.ragLabel || 'Unknown')}
                ${domainStrength?.run ? runBtn(domainStrength.run.label || 'Run snapshot', domainStrength.run.onClick || '', domainStrength.run.title || '') : ''}
                ${jumpBtn('Open', 'ranking')}
              </div>
            </div>
            <div class="dashboard-kpi-grid">
              ${tile('Your score', domainStrength?.kpis?.selfScore ?? '', domainStrength?.deltas?.selfScore ?? '', domainStrength?.dirs?.selfScore ?? 'flat', 'Your domain strength score (0100).')}
              ${tile('Gap to top', domainStrength?.kpis?.gapTop ?? '', domainStrength?.deltas?.gapTop ?? '', domainStrength?.dirs?.gapTop ?? 'flat', 'Difference between the strongest competitor score and your score (lower is better).')}
              ${tile('# stronger domains', domainStrength?.kpis?.stronger ?? '', domainStrength?.deltas?.stronger ?? '', domainStrength?.dirs?.stronger ?? 'flat', 'How many competitors in the snapshot set have a higher score than you.')}
              ${tile('Rank vs set', domainStrength?.kpis?.rankVs ?? '', '', 'flat', 'Your rank among the comparison set (you + competitors). Example: 1/16 means strongest in the set.')}
            </div>
          </div>
        `;
      }

      function renderDashboardGaioPillarsAndRadar(pillars, prevPillars) {
        const host = document.getElementById('dashboard-gaio-pillars');
        if (!host) return;

        const p = pillars || {};
        const prev = prevPillars || {};
        const items = [
          { key: 'authority', label: 'Authority', score: p.authority, prevScore: prev.authority },
          { key: 'contentSchema', label: 'Content / Schema', score: p.contentSchema, prevScore: prev.contentSchema },
          { key: 'visibility', label: 'Visibility', score: p.visibility, prevScore: prev.visibility },
          { key: 'localEntity', label: 'Local Entity', score: p.localEntity, prevScore: prev.localEntity },
          { key: 'serviceArea', label: 'Service Area', score: p.serviceArea, prevScore: prev.serviceArea },
        ];

        const rowsHtml = items.map(it => {
          const s = toNum(it.score);
          const pct = s == null ? 0 : Math.max(0, Math.min(100, s));
          const rag = scoreToRag(s, { greenAt: 70, amberAt: 50 });
          const delta = formatDeltaNumber(it.score, it.prevScore, { decimals: 0 });
          const dir = deltaDir(it.score, it.prevScore, { betterLower: false });
          return `
            <div class="dashboard-pillar-row" data-key="${it.key}">
              <div class="dashboard-pillar-label">${it.label}</div>
              <div class="dashboard-pillar-bar" title="${it.label}: ${s == null ? '' : `${Math.round(s)}/100`} ( ${delta})">
                <span style="width:${pct}%; background:${ragToAccent(rag)};"></span>
              </div>
              <div class="dashboard-pillar-score">${s == null ? '' : Math.round(s)}</div>
            </div>
          `;
        }).join('');

        host.innerHTML = `<div class="dashboard-pillar-strip">${rowsHtml}</div>`;

        // Radar / web diagram
        const canvas = document.getElementById('dashboard-gaio-radar');
        if (!canvas || typeof Chart === 'undefined') return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        const labels = items.map(i => i.label);
        const values = items.map(i => (toNum(i.score) ?? 0));
        const labelDeltas = items.map(i => formatDeltaNumber(i.score, i.prevScore, { decimals: 0 }));
        const labelColors = items.map(i => deltaLabelColor(i.score, i.prevScore));

        try {
          if (window.__dashboardGaioRadarChart) {
            window.__dashboardGaioRadarChart.destroy();
            window.__dashboardGaioRadarChart = null;
          }
        } catch (e) {
          // ignore
        }

        try {
          window.__dashboardGaioRadarChart = new Chart(ctx, {
            type: 'radar',
            data: {
              labels,
              datasets: [{
                label: 'Pillars',
                data: values,
                borderColor: 'rgba(59, 130, 246, 0.85)',
                backgroundColor: 'rgba(59, 130, 246, 0.18)',
                borderWidth: 2,
                pointBackgroundColor: '#ffffff',
                pointBorderColor: 'rgba(59, 130, 246, 0.85)',
                pointRadius: 3
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              layout: { padding: 16 },
              plugins: {
                legend: { display: false },
                dashboardRadarLabels: {
                  labels,
                  deltaTexts: labelDeltas,
                  deltaColors: labelColors,
                  lineGap: 12,
                  deltaGap: 8,
                  labelPadding: 10
                }
              },
              scales: {
                r: {
                  min: 0,
                  max: 100,
                  ticks: { display: false },
                  grid: { color: 'rgba(148, 163, 184, 0.20)' },
                  angleLines: { color: 'rgba(148, 163, 184, 0.20)' },
                  pointLabels: { display: false }
                }
              }
            },
            plugins: [dashboardRadarLabelPlugin]
          });
        } catch (e) {
          // ignore
        }
      }

      async function refreshDashboardDomainStrengthCacheIfNeeded() {
        const now = Date.now();
        // v4: cache key bump to ensure rank/gap are computed against competitor-only set (isCompetitor=true)
        const cacheV4 = dashboardSafeJsonParse(localStorage.getItem('dashboard_domain_strength_cache_v4'), null);
        const cacheV3 = dashboardSafeJsonParse(localStorage.getItem('dashboard_domain_strength_cache_v3'), null);
        const cacheV2 = dashboardSafeJsonParse(localStorage.getItem('dashboard_domain_strength_cache_v2'), null);
        const cacheV1 = dashboardSafeJsonParse(localStorage.getItem('dashboard_domain_strength_cache_v1'), null);
        const cache = cacheV4 || cacheV3 || cacheV2 || cacheV1 || null;
        const lastMs = cache?.fetchedAtMs ? Number(cache.fetchedAtMs) : 0;
        // If the user has an older cache but not v4 yet, force an upgrade pass
        const needsUpgradeToV4 = !cacheV4 && (cacheV3 || cacheV2 || cacheV1);
        const hasUsefulValues = (() => {
          const selfScore = toNum(cache?.selfScore);
          const topScore = toNum(cache?.topCompetitorScore);
          const stronger = toNum(cache?.strongerCount);
          const competitorsCount = toNum(cache?.competitorsCount);
          const snapshotDate = cache?.snapshotDate || null;
          // Treat null-valued caches as stale (common when older code wrote "fresh" cache with nulls).
          return (typeof selfScore === 'number' || typeof topScore === 'number' || typeof stronger === 'number')
            && !!snapshotDate
            && (typeof competitorsCount === 'number'); // needed for rank tile
        })();
        const stale = needsUpgradeToV4 || !lastMs || (now - lastMs) > (6 * 60 * 60 * 1000) || !hasUsefulValues; // 6 hours
        if (!stale) return { cache, updated: false };
        if (window.__dashboardDomainStrengthRefreshing) return { cache, updated: false };
        window.__dashboardDomainStrengthRefreshing = true;
        try {
          if (typeof fetchDomainStrengthOverview !== 'function') return { cache, updated: false };
          const items = await fetchDomainStrengthOverview();
          if (!Array.isArray(items) || items.length === 0) return { cache, updated: false };
          const self = (typeof getSelfDomainForDomainStrength === 'function') ? getSelfDomainForDomainStrength() : 'alanranger.com';
          const normalizedSelf = normalizeDomainForStrength(self);
          const normItems = items
            .map(it => ({
              domain: normalizeDomainForStrength(it.domain || it.root_domain || it.rootDomain || ''),
              // API shape: overview items expose metrics under `latest` (but support flat fields too).
              score: toNum(it?.latest?.score ?? it.score),
              band: (it?.latest?.band ?? it.band ?? it.label) || null,
              snapshotDate: it?.latest?.snapshotDate || it.snapshotDate || it.snapshot_date || null,
              isCompetitor: (it?.isCompetitor === true) || (it?.is_competitor === true) || (it?.domain_type === 'competitor')
            }))
            .filter(it => it.domain);
          const selfItem = normItems.find(it => it.domain === normalizedSelf) || null;
          // Only compare against explicitly marked competitors
          const competitors = normItems.filter(it => it.isCompetitor === true && it.domain !== normalizedSelf && typeof it.score === 'number');
          const selfScore = selfItem?.score ?? null;
          const topCompetitor = competitors.slice().sort((a, b) => (b.score ?? -1) - (a.score ?? -1))[0] || null;
          const topCompetitorScore = topCompetitor?.score ?? null;
          const strongerCount = (typeof selfScore === 'number')
            ? competitors.filter(it => typeof it.score === 'number' && it.score > selfScore).length
            : null;
          const competitorsCount = competitors.length; // competitor-only denominator

          const next = {
            fetchedAtMs: now,
            snapshotDate: selfItem?.snapshotDate || topCompetitor?.snapshotDate || null,
            selfDomain: normalizedSelf,
            selfScore,
            topCompetitorScore,
            strongerCount,
            competitorsCount
          };
          localStorage.setItem('dashboard_domain_strength_cache_v4', JSON.stringify(next));
          return { cache: next, updated: true };
        } catch (e) {
          return { cache, updated: false };
        } finally {
          window.__dashboardDomainStrengthRefreshing = false;
        }
      }

      function renderDashboardEeatRadar(eeatSubscores, prevSubscores) {
        const canvas = document.getElementById('dashboard-eeat-radar');
        if (!canvas || typeof Chart === 'undefined') return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        const s = eeatSubscores || {};
        const prev = prevSubscores || {};
        const labels = ['Experience', 'Expertise', 'Authoritativeness', 'Trustworthiness'];
        const values = [
          toNum(s.experience) ?? 0,
          toNum(s.expertise) ?? 0,
          toNum(s.authoritativeness) ?? 0,
          toNum(s.trustworthiness) ?? 0
        ];
        const labelDeltas = [
          formatDeltaNumber(s.experience, prev.experience, { decimals: 0 }),
          formatDeltaNumber(s.expertise, prev.expertise, { decimals: 0 }),
          formatDeltaNumber(s.authoritativeness, prev.authoritativeness, { decimals: 0 }),
          formatDeltaNumber(s.trustworthiness, prev.trustworthiness, { decimals: 0 })
        ];
        const labelColors = [
          deltaLabelColor(s.experience, prev.experience),
          deltaLabelColor(s.expertise, prev.expertise),
          deltaLabelColor(s.authoritativeness, prev.authoritativeness),
          deltaLabelColor(s.trustworthiness, prev.trustworthiness)
        ];

        try {
          if (window.__dashboardEeatRadarChart) {
            window.__dashboardEeatRadarChart.destroy();
            window.__dashboardEeatRadarChart = null;
          }
        } catch (e) {
          // ignore
        }

        try {
          window.__dashboardEeatRadarChart = new Chart(ctx, {
            type: 'radar',
            data: {
              labels,
              datasets: [{
                label: 'EEAT',
                data: values,
                borderColor: 'rgba(16, 185, 129, 0.9)',
                backgroundColor: 'rgba(16, 185, 129, 0.16)',
                borderWidth: 2,
                pointBackgroundColor: '#ffffff',
                pointBorderColor: 'rgba(16, 185, 129, 0.9)',
                pointRadius: 3
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              layout: { padding: 16 },
              plugins: {
                legend: { display: false },
                dashboardRadarLabels: {
                  labels,
                  deltaTexts: labelDeltas,
                  deltaColors: labelColors,
                  lineGap: 12,
                  deltaGap: 8,
                  labelPadding: 10
                }
              },
              scales: {
                r: {
                  beginAtZero: true,
                  min: 0,
                  max: 100,
                  ticks: { display: false },
                  grid: { color: 'rgba(148,163,184,0.25)' },
                  angleLines: { color: 'rgba(148,163,184,0.25)' },
                  pointLabels: { display: false }
                }
              }
            },
            plugins: [dashboardRadarLabelPlugin]
          });
        } catch (e) {
          // ignore
        }
      }

      function renderDashboardAiSummaryRadar(aiSummaryComponents, prevComponents) {
        const canvas = document.getElementById('dashboard-ai-summary-radar');
        if (!canvas) {
          console.warn('[Dashboard] AI Summary radar canvas not found');
          return;
        }
        if (typeof Chart === 'undefined') {
          console.warn('[Dashboard] Chart.js not loaded, will retry');
          // Retry after a short delay if Chart.js loads
          setTimeout(() => {
            if (typeof Chart !== 'undefined') {
              renderDashboardAiSummaryRadar(aiSummaryComponents, prevComponents);
            }
          }, 500);
          return;
        }
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          console.warn('[Dashboard] Could not get 2d context for AI Summary radar');
          return;
        }

        // Debounce: prevent re-rendering if chart was just rendered recently
        const now = Date.now();
        const lastRender = window.__dashboardAiSummaryRadarLastRender || 0;
        if (now - lastRender < 500 && window.__dashboardAiSummaryRadarChart) {
          return; // Skip if rendered within last 500ms
        }
        window.__dashboardAiSummaryRadarLastRender = now;

        const c = aiSummaryComponents || {};
        const prev = prevComponents || {};
        const labels = ['Snippet Readiness', 'Visibility', 'Brand'];
        const values = [
          toNum(c.snippetReadiness) ?? 0,
          toNum(c.visibility) ?? 0,
          toNum(c.brand) ?? 0
        ];
        const labelDeltas = [
          formatDeltaNumber(c.snippetReadiness, prev.snippetReadiness, { decimals: 0 }),
          formatDeltaNumber(c.visibility, prev.visibility, { decimals: 0 }),
          formatDeltaNumber(c.brand, prev.brand, { decimals: 0 })
        ];
        const labelColors = [
          deltaLabelColor(c.snippetReadiness, prev.snippetReadiness),
          deltaLabelColor(c.visibility, prev.visibility),
          deltaLabelColor(c.brand, prev.brand)
        ];

        // Always destroy existing chart before creating new one
        try {
          if (window.__dashboardAiSummaryRadarChart) {
            window.__dashboardAiSummaryRadarChart.destroy();
            window.__dashboardAiSummaryRadarChart = null;
          }
        } catch (e) {
          // ignore
        }

        const title = c
          ? `AI Summary components: Snippet Readiness ${Math.round(values[0])}, Visibility ${Math.round(values[1])}, Brand ${Math.round(values[2])}`
          : 'AI Summary components: run audit scan to populate';
        canvas.title = title;

        try {
          window.__dashboardAiSummaryRadarChart = new Chart(ctx, {
            type: 'radar',
            data: {
              labels,
              datasets: [{
                label: 'Components',
                data: values,
                borderColor: 'rgba(16, 185, 129, 0.9)',
                backgroundColor: 'rgba(16, 185, 129, 0.16)',
                borderWidth: 2,
                pointBackgroundColor: '#ffffff',
                pointBorderColor: 'rgba(16, 185, 129, 0.9)',
                pointRadius: 3
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              layout: { padding: 16 },
              plugins: {
                legend: { display: false },
                dashboardRadarLabels: {
                  labels,
                  deltaTexts: labelDeltas,
                  deltaColors: labelColors,
                  lineGap: 12,
                  deltaGap: 8,
                  labelPadding: 10
                }
              },
              scales: {
                r: {
                  beginAtZero: true,
                  min: 0,
                  max: 100,
                  ticks: { display: false },
                  grid: { color: 'rgba(148,163,184,0.25)' },
                  angleLines: { color: 'rgba(148,163,184,0.25)' },
                  pointLabels: { display: false }
                }
              }
            },
            plugins: [dashboardRadarLabelPlugin]
          });
        } catch (err) {
          console.error('[Dashboard] Error rendering AI Summary radar:', err);
        }
      }

      function renderDashboardUpliftChart(moneyPagesRows, targetCtr, prevRows) {
        const canvas = document.getElementById('dashboard-uplift-chart');
        if (!canvas) {
          console.warn('[Dashboard] Uplift chart canvas not found');
          return;
        }
        if (typeof Chart === 'undefined') {
          console.warn('[Dashboard] Chart.js not loaded, will retry');
          // Retry after a short delay if Chart.js loads
          setTimeout(() => {
            if (typeof Chart !== 'undefined') {
              renderDashboardUpliftChart(moneyPagesRows, targetCtr, prevRows);
            }
          }, 500);
          return;
        }
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          console.warn('[Dashboard] Could not get 2d context for Uplift chart');
          return;
        }

        if (!Array.isArray(moneyPagesRows) || moneyPagesRows.length === 0) {
          // Clear chart if no data
          try {
            if (window.__dashboardUpliftChart) {
              window.__dashboardUpliftChart.destroy();
              window.__dashboardUpliftChart = null;
            }
          } catch (e) {
            // ignore
          }
          return;
        }

        const targetCtrPct = targetCtr || 2.5;
        const targetCtrRatio = targetCtrPct / 100;
        const prevByUrl = new Map();
        if (Array.isArray(prevRows)) {
          for (const row of prevRows) {
            const key = String(row?.url || row?.page_url || '').toLowerCase();
            if (key) prevByUrl.set(key, row);
          }
        }

        // Calculate potential extra clicks for each page
        const pagesWithUplift = moneyPagesRows
          .map(row => {
            const clicks = toNum(row.clicks || row.clicks_28d) || 0;
            const impressions = toNum(row.impressions || row.impressions_28d) || 0;
            const currentCtr = impressions > 0 ? clicks / impressions : 0;
            const potentialClicks = impressions > 0 ? Math.max(0, Math.round(impressions * targetCtrRatio - clicks)) : 0;
            const urlKey = String(row.url || row.page_url || '').toLowerCase();
            const prevRow = prevByUrl.get(urlKey) || null;
            const prevClicks = prevRow ? (toNum(prevRow.clicks || prevRow.clicks_28d) || 0) : null;
            const prevImpressions = prevRow ? (toNum(prevRow.impressions || prevRow.impressions_28d) || 0) : null;
            const prevCtr = (prevImpressions && prevImpressions > 0) ? (prevClicks / prevImpressions) : null;
            const currentCtrPct = currentCtr * 100;
            const gapToTargetPp = targetCtrPct - currentCtrPct;
            const gapText = formatSignedPp(gapToTargetPp, 1);
            return {
              url: row.url || row.page_url || 'Unknown',
              potentialClicks,
              currentClicks: clicks,
              impressions,
              currentCtrPct,
              gapText
            };
          })
          .filter(p => p.potentialClicks > 0)
          .sort((a, b) => b.potentialClicks - a.potentialClicks)
          .slice(0, 8); // Top 8 pages

        if (pagesWithUplift.length === 0) {
          try {
            if (window.__dashboardUpliftChart) {
              window.__dashboardUpliftChart.destroy();
              window.__dashboardUpliftChart = null;
            }
          } catch (e) {
            // ignore
          }
          return;
        }

        // Debounce: prevent re-rendering if chart was just rendered recently
        const now = Date.now();
        const lastRender = window.__dashboardUpliftLastRender || 0;
        if (now - lastRender < 500 && window.__dashboardUpliftChart) {
          return; // Skip if rendered within last 500ms
        }
        window.__dashboardUpliftLastRender = now;

        // Truncate URLs for display - remove domain, show only path
        const labels = pagesWithUplift.map(p => {
          let url = p.url.replace(/^https?:\/\//, '').replace(/^www\./, '');
          // Remove domain (everything before first slash)
          const pathMatch = url.match(/\/(.+)$/);
          if (pathMatch) {
            url = '/' + pathMatch[1];
          } else if (url.includes('/')) {
            // If there's a slash but no leading slash, extract path
            url = '/' + url.split('/').slice(1).join('/');
          } else {
            // If no path, show as root
            url = '/';
          }
          // Truncate if too long
          const base = shortenMiddle(url, 48);
          return base;
        });
        const data = pagesWithUplift.map(p => p.potentialClicks);

        // Always destroy existing chart before creating new one
        try {
          if (window.__dashboardUpliftChart) {
            window.__dashboardUpliftChart.destroy();
            window.__dashboardUpliftChart = null;
          }
        } catch (e) {
          // ignore
        }

        canvas.title = '';

        try {
          window.__dashboardUpliftChart = new Chart(ctx, {
            type: 'bar',
            data: {
              labels,
              datasets: [{
                label: 'Potential Extra Clicks',
                data,
                backgroundColor: 'rgba(239, 68, 68, 0.7)',
                borderColor: 'rgba(239, 68, 68, 0.9)',
                borderWidth: 1
              }]
            },
            options: {
              indexAxis: 'y',
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      const idx = context.dataIndex;
                      const page = pagesWithUplift[idx];
                      return [
                        `Potential: +${page.potentialClicks} clicks`,
                        `Current CTR: ${formatPct(page.currentCtrPct, 1)}`,
                        `Gap to target: ${page.gapText}`,
                        `Current: ${page.currentClicks} clicks`,
                        `Impressions: ${formatInt(page.impressions)}`
                      ];
                    }
                  }
                }
              },
              scales: {
                x: {
                  beginAtZero: true,
                  ticks: {
                    color: 'rgba(226,232,240,0.7)',
                    font: { size: 10 }
                  },
                  title: {
                    display: true,
                    text: 'Potential extra clicks (28d)',
                    color: 'rgba(226,232,240,0.65)',
                    font: { size: 10, weight: '600' }
                  },
                  grid: { color: 'rgba(148,163,184,0.15)' }
                },
                y: {
                  ticks: {
                    color: 'rgba(226,232,240,0.7)',
                    font: { size: 10 }
                  },
                  grid: { display: false }
                }
              }
            },
            plugins: [{
              id: 'dashboardUpliftBarLabels',
              afterDatasetsDraw(chart) {
                const ctx = chart.ctx;
                const meta = chart.getDatasetMeta(0);
                if (!meta) return;
                ctx.save();
                ctx.font = '700 10px system-ui, -apple-system, Segoe UI, sans-serif';
                ctx.fillStyle = '#f8fafc';
                ctx.textBaseline = 'middle';
                for (let i = 0; i < meta.data.length; i += 1) {
                  const bar = meta.data[i];
                  const page = pagesWithUplift[i];
                  if (!bar || !page) continue;
                  const text = `+${page.potentialClicks} | CTR ${formatPct(page.currentCtrPct, 1)} | gap ${page.gapText}`;
                  const x = Math.max(bar.x - 6, chart.chartArea.left + 6);
                  ctx.textAlign = 'right';
                  ctx.fillText(text, x, bar.y);
                }
                ctx.restore();
              }
            }]
          });
        } catch (err) {
          console.error('[Dashboard] Error rendering Uplift chart:', err);
        }
      }

      function renderDashboardMoneyShareRadar(moneyShareSplit, prevSplit) {
        const canvas = document.getElementById('dashboard-money-share-radar');
        if (!canvas) {
          console.warn('[Dashboard] Money Share radar canvas not found');
          return;
        }
        if (typeof Chart === 'undefined') {
          console.warn('[Dashboard] Chart.js not loaded, will retry');
          // Retry after a short delay if Chart.js loads
          setTimeout(() => {
            if (typeof Chart !== 'undefined') {
              renderDashboardMoneyShareRadar(moneyShareSplit, prevSplit);
            }
          }, 500);
          return;
        }
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          console.warn('[Dashboard] Could not get 2d context for Money Share radar');
          return;
        }

        const s = moneyShareSplit || null;
        const prev = prevSplit || {};
        const labels = ['Landing', 'Event', 'Service'];
        const values = [
          toNum(s?.landingPct) ?? 0,
          toNum(s?.eventPct) ?? 0,
          toNum(s?.productPct) ?? 0
        ];
        const labelDeltas = [
          formatDeltaNumber(s?.landingPct, prev.landingPct, { decimals: 0, pp: true }),
          formatDeltaNumber(s?.eventPct, prev.eventPct, { decimals: 0, pp: true }),
          formatDeltaNumber(s?.productPct, prev.productPct, { decimals: 0, pp: true })
        ];
        const labelColors = [
          deltaLabelColor(s?.landingPct, prev.landingPct),
          deltaLabelColor(s?.eventPct, prev.eventPct),
          deltaLabelColor(s?.productPct, prev.productPct)
        ];

        // Debounce: prevent re-rendering if chart was just rendered recently
        const now = Date.now();
        const lastRender = window.__dashboardMoneyShareLastRender || 0;
        if (now - lastRender < 500 && window.__dashboardMoneyShareRadarChart) {
          return; // Skip if rendered within last 500ms
        }
        window.__dashboardMoneyShareLastRender = now;

        // Always destroy existing chart before creating new one
        try {
          if (window.__dashboardMoneyShareRadarChart) {
            window.__dashboardMoneyShareRadarChart.destroy();
            window.__dashboardMoneyShareRadarChart = null;
          }
        } catch (e) {
          // ignore
        }

        const title = s
          ? `Money citations split (of ${s.moneyTotal || 0}): Landing ${s.landing || 0}, Event ${s.event || 0}, Service ${s.product || 0}`
          : 'Money citations split: run Ranking & AI scan to populate';
        canvas.title = title;

        try {
          window.__dashboardMoneyShareRadarChart = new Chart(ctx, {
            type: 'radar',
            data: {
              labels,
              datasets: [{
                label: '% of Money citations',
                data: values,
                borderColor: 'rgba(245, 158, 11, 0.95)',
                backgroundColor: 'rgba(245, 158, 11, 0.16)',
                borderWidth: 2,
                pointBackgroundColor: '#ffffff',
                pointBorderColor: 'rgba(245, 158, 11, 0.95)',
                pointRadius: 3
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              layout: { padding: 16 },
              plugins: {
                legend: { display: false },
                dashboardRadarLabels: {
                  labels,
                  deltaTexts: labelDeltas,
                  deltaColors: labelColors,
                  lineGap: 12,
                  deltaGap: 8,
                  labelPadding: 10
                }
              },
              scales: {
                r: {
                  beginAtZero: true,
                  min: 0,
                  max: 100,
                  ticks: { display: false },
                  grid: { color: 'rgba(148,163,184,0.25)' },
                  angleLines: { color: 'rgba(148,163,184,0.25)' },
                  pointLabels: { display: false }
                }
              }
            },
            plugins: [dashboardRadarLabelPlugin]
          });
        } catch (err) {
          console.error('[Dashboard] Error rendering Money Share radar:', err);
        }
      }

      // Helper function to compute dashboard snapshot from audit data
      function computeDashboardSnapshotFromAuditData(auditData) {
        if (!auditData) {
          debugLog(`[Dashboard] computeDashboardSnapshotFromAuditData: auditData is null/undefined`, 'warn');
          return null;
        }
        
        const scores = auditData.scores || {};
        const searchData = auditData.searchData || {};
        const rankingAiData = auditData.rankingAiData || {};
        
        // Compute GAIO score from pillar scores
        const pillars = {
          visibility: scores.visibility || null,
          authority: typeof scores.authority === 'object' ? scores.authority.score : (scores.authority || null),
          contentSchema: scores.contentSchema || null,
          localEntity: scores.localEntity || null,
          serviceArea: scores.serviceArea || null
        };
        
        const weights = { visibility: 0.20, authority: 0.30, contentSchema: 0.25, localEntity: 0.15, serviceArea: 0.10 };
        let gaioScore = null;
        if (Object.values(pillars).some(v => typeof v === 'number')) {
          const weightedSum = (pillars.visibility || 0) * weights.visibility +
                             (pillars.authority || 0) * weights.authority +
                             (pillars.contentSchema || 0) * weights.contentSchema +
                             (pillars.localEntity || 0) * weights.localEntity +
                             (pillars.serviceArea || 0) * weights.serviceArea;
          gaioScore = Math.round(weightedSum);
        }
        
        // Compute Money Pages aggregate from metrics (needed for Money Pages tile deltas)
        const moneyMetricsFromAudit = scores.moneyPagesMetrics || auditData.moneyPagesMetrics || null;
        const moneyAgg = (typeof computeMoneyPagesAggregateFromMetrics === 'function') 
          ? computeMoneyPagesAggregateFromMetrics(moneyMetricsFromAudit)
          : null;
        
        // Compute ranking KPIs from ranking AI data (needed for Ranking tile deltas)
        const rankingRows = rankingAiData.combinedRows || [];
        const rankingKpis = (typeof computeRankingKpisFromRows === 'function' && rankingRows.length > 0)
          ? computeRankingKpisFromRows(rankingRows)
          : null;
        
        // Compute money share from ranking data (same calculation as computeDashboardSnapshot)
        // This calculates the percentage of AI citations that are on money pages
        const moneyShare = (typeof computeMoneyCitationsShareFromRankingRows === 'function' && rankingRows.length > 0)
          ? computeMoneyCitationsShareFromRankingRows(rankingRows)
          : { money: null, total: null, pct: null };
        const moneySharePct = moneyShare.pct; // This is the percentage (0-100)
        
        // Extract AI Summary components (needed for AI Summary radar chart deltas)
        let aiSummaryComponents = auditData.aiSummaryComponents || null;
        
        // If aiSummaryComponents is missing or has snippetReadiness=0, try to recalculate it
        if (!aiSummaryComponents || (aiSummaryComponents.snippetReadiness === 0 && 
            (scores.contentSchema != null || scores.visibility != null || scores.authority != null))) {
          let snippetReadinessScore = 0;
          // Try to get from auditData.snippetReadiness first
          if (auditData.snippetReadiness) {
            snippetReadinessScore = typeof auditData.snippetReadiness === 'number' 
              ? auditData.snippetReadiness 
              : (auditData.snippetReadiness?.overallScore || 0);
          }
          
          // If still 0, recalculate from component scores
          if (snippetReadinessScore === 0 && typeof calculateSnippetReadiness === 'function') {
            snippetReadinessScore = calculateSnippetReadiness(scores, searchData);
            console.log('[Dashboard] computeDashboardSnapshotFromAuditData: Recalculated snippetReadiness from scores:', snippetReadinessScore);
          }
          
          const visibilityScore = (typeof scores.visibility === 'number') ? scores.visibility : null;
          const brandScore = (typeof scores.brandOverlay?.score === 'number') ? scores.brandOverlay.score : null;
          
          if (snippetReadinessScore > 0 || visibilityScore != null || brandScore != null) {
            aiSummaryComponents = {
              snippetReadiness: snippetReadinessScore,
              visibility: visibilityScore,
              brand: brandScore
            };
          }
        }
        
        // Extract domain strength (needed for Domain Strength tile deltas)
        const domainStrength = auditData.domainStrength || null;
        
        // Extract EEAT data (needed for EEAT tile deltas)
        let eeatScore = auditData.eeatScore ?? null;
        let eeatConfidence = auditData.eeatConfidence ?? null;
        let eeatSubscores = auditData.eeatSubscores || null;
        if ((eeatScore == null || eeatConfidence == null || !eeatSubscores) && typeof computeEeatScore === 'function') {
          const eeatComputed = computeEeatScore({
            audit: auditData,
            pillars,
            rankingKpis,
            domainStrength
          });
          if (eeatScore == null) eeatScore = eeatComputed?.score ?? null;
          if (eeatConfidence == null) eeatConfidence = eeatComputed?.confidence ?? null;
          if (!eeatSubscores) eeatSubscores = eeatComputed?.subscores ?? null;
        }
        
        // Extract optimisation potential clicks (needed for Optimisation tile deltas)
        const optimisationPotentialClicks = auditData.optimisationPotentialClicks ?? null;
        
        debugLog(`[Dashboard] computeDashboardSnapshotFromAuditData: GAIO=${gaioScore}, AI Summary=${scores.aiSummaryScore || auditData.ai_summary_score || 'null'}, rankingKpis=${rankingKpis ? 'present' : 'null'}, moneySharePct=${moneySharePct ?? 'null'}, aiSummaryComponents=${aiSummaryComponents ? 'present' : 'null'}, domainStrength=${domainStrength ? 'present' : 'null'}, eeatScore=${eeatScore ?? 'null'}`, 'info');
        
        return {
          gaioScore,
          aiSummaryScore: scores.aiSummaryScore || (typeof auditData.ai_summary_score === 'number' ? auditData.ai_summary_score : null),
          aiSummaryComponents, // Added for AI Summary radar chart deltas
          pillars,
          auditKpis: searchData.overview ? {
            clicks: searchData.overview.clicks || searchData.totalClicks || 0,
            impressions: searchData.overview.impressions || searchData.totalImpressions || 0,
            avgPosition: searchData.overview.position || searchData.averagePosition || null,
            ctrPct: searchData.overview.ctr || searchData.ctr || 0
          } : null,
          moneyCitations: moneyShare.money,
          totalCitations: moneyShare.total,
          moneySharePct: moneySharePct, // Calculated from ranking data (money citations / total citations)
          moneyAgg: moneyAgg, // Add moneyAgg for Money Pages tile deltas
          rankingKpis, // Added for Ranking tile deltas
          domainStrength, // Added for Domain Strength tile deltas
          eeatScore, // Added for EEAT tile deltas
          eeatConfidence, // Added for EEAT tile deltas
          eeatSubscores, // Added for EEAT tile deltas
          optimisationPotentialClicks // Added for Optimisation tile deltas
        };
      }

      // Helper function to fetch audit from ~27 days ago for rolling 28-day delta calculations
      // This ensures consistent time-period comparisons across all dashboard tiles
      async function fetchPreviousAuditForDeltas(propertyUrl, currentAuditDate) {
        if (!propertyUrl || !currentAuditDate) {
          debugLog(`[Dashboard] fetchPreviousAuditForDeltas: Missing params - propertyUrl=${!!propertyUrl}, currentAuditDate=${currentAuditDate}`, 'warn');
          return null;
        }
        
        try {
          debugLog(`[Dashboard] fetchPreviousAuditForDeltas: Starting - propertyUrl=${propertyUrl}, currentAuditDate=${currentAuditDate}`, 'info');
          
          const urlHelper = window.apiUrl || ((path) => {
            const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
            const cleanPath = path.startsWith('/') ? path : `/${path}`;
            return baseUrl ? `${baseUrl}${cleanPath}` : cleanPath;
          });
          
          // Calculate target date: 27 days before current audit date (rolling 28-day window)
          const currentDate = new Date(currentAuditDate);
          const targetDate = new Date(currentDate);
          targetDate.setUTCDate(targetDate.getUTCDate() - 27);
          const targetDateStr = targetDate.toISOString().slice(0, 10);
          
          debugLog(`[Dashboard] fetchPreviousAuditForDeltas: Target date (27 days ago) = ${targetDateStr}`, 'info');
          
          // Fetch audit history to find the audit closest to 27 days ago
          const historyUrl = urlHelper(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}`);
          debugLog(`[Dashboard] fetchPreviousAuditForDeltas: Fetching history from ${historyUrl}`, 'info');
          
          const historyResponse = await fetch(historyUrl);
          if (!historyResponse.ok) {
            const errorText = await historyResponse.text().catch(() => 'Unable to read error');
            debugLog(`[Dashboard] Audit history fetch failed: ${historyResponse.status} - ${errorText}`, 'warn');
            return null;
          }
          
          const historyResult = await historyResponse.json();
          debugLog(`[Dashboard] fetchPreviousAuditForDeltas: History response status=${historyResult.status}, data length=${historyResult.data?.length || 0}`, 'info');
          
          if (historyResult.status === 'ok' && Array.isArray(historyResult.data) && historyResult.data.length >= 1) {
            // Sort audits by date descending (most recent first)
            const sortedAudits = historyResult.data
              .map(a => ({
                audit_date: a.audit_date || a.auditDate || a.date,
                data: a
              }))
              .filter(a => a.audit_date) // Filter out any without dates
              .sort((a, b) => {
                const dateA = new Date(a.audit_date);
                const dateB = new Date(b.audit_date);
                return dateB - dateA; // Descending order (newest first)
              });
            
            debugLog(`[Dashboard] fetchPreviousAuditForDeltas: Found ${sortedAudits.length} audits. Dates: ${sortedAudits.map(a => a.audit_date).join(', ')}`, 'info');
            
            // Find current audit index
            const currentIndex = sortedAudits.findIndex(a => a.audit_date === currentAuditDate);
            debugLog(`[Dashboard] fetchPreviousAuditForDeltas: Current audit index=${currentIndex}, currentAuditDate=${currentAuditDate}`, 'info');
            
            // Find audit closest to target date (27 days ago)
            // Prefer audits before target date, but accept closest if none exist before
            // Also filter out anomalous audits (e.g., 2025-12-13 with double impressions)
            let bestMatch = null;
            let bestDiff = Infinity;
            
            // Known anomalous audit dates to skip (data collection errors)
            // NOTE: Dec 13 data was fixed via migration, so it can now be used for comparisons
            const anomalousAuditDates = new Set([]); // Dec 13 was fixed, no longer skipping
            
            for (let i = 0; i < sortedAudits.length; i++) {
              // Skip current audit
              if (sortedAudits[i].audit_date === currentAuditDate) continue;
              
              // Skip known anomalous audits
              if (anomalousAuditDates.has(sortedAudits[i].audit_date)) {
                debugLog(`[Dashboard] Skipping anomalous audit: ${sortedAudits[i].audit_date}`, 'info');
                continue;
              }
              
              const auditDate = new Date(sortedAudits[i].audit_date);
              const diff = Math.abs(auditDate - targetDate);
              
              // Prefer audits on or before target date (but accept closest if needed)
              if (diff < bestDiff) {
                bestDiff = diff;
                bestMatch = sortedAudits[i];
              }
              
              // If we find an audit exactly on or before target date, prefer it
              if (auditDate <= targetDate) {
                bestMatch = sortedAudits[i];
                break;
              }
            }
            
            // If no audit found close to target date, use oldest available audit as fallback
            if (!bestMatch && sortedAudits.length > 0) {
              debugLog(`[Dashboard] fetchPreviousAuditForDeltas: No audit found close to target date ${targetDateStr}, trying fallback to oldest audit`, 'info');
              // Find oldest audit (last in descending sorted list)
              for (let i = sortedAudits.length - 1; i >= 0; i--) {
                if (sortedAudits[i].audit_date !== currentAuditDate) {
                  bestMatch = sortedAudits[i];
                  debugLog(`[Dashboard] No audit near 27 days ago, using oldest available: ${bestMatch.audit_date}`, 'info');
                  break;
                }
              }
            }
            
            if (bestMatch && bestMatch.audit_date !== currentAuditDate) {
              const prevAuditDate = bestMatch.audit_date;
              
              // Calculate days difference for logging
              const daysDiff = Math.round((currentDate - new Date(prevAuditDate)) / (1000 * 60 * 60 * 24));
              
              debugLog(`[Dashboard]  Found rolling 28-day audit date: ${prevAuditDate} (${daysDiff} days ago, target: ${targetDateStr})`, 'success');
              
              // CRITICAL: Fetch FULL audit data for this date to get all fields needed for delta calculations
              // This includes: rankingAiData, aiSummaryComponents, domainStrength, eeatScore, etc.
              const fullAuditUrl = urlHelper(`/api/supabase/get-audit-by-date?propertyUrl=${encodeURIComponent(propertyUrl)}&auditDate=${prevAuditDate}`);
              debugLog(`[Dashboard] fetchPreviousAuditForDeltas: Fetching full audit from ${fullAuditUrl}`, 'info');
              
              try {
                const fullAuditResponse = await fetch(fullAuditUrl);
                debugLog(`[Dashboard] fetchPreviousAuditForDeltas: Full audit response status=${fullAuditResponse.status}`, 'info');
                
                if (fullAuditResponse.ok) {
                  const fullAuditResult = await fullAuditResponse.json();
                  debugLog(`[Dashboard] fetchPreviousAuditForDeltas: Full audit result status=${fullAuditResult.status}, hasData=${!!fullAuditResult.data}`, 'info');
                  
                  if (fullAuditResult.status === 'ok' && fullAuditResult.data) {
                    const auditData = fullAuditResult.data;
                    
                    // Check if critical fields are missing and try fallback to nearby dates
                    const hasRankingData = auditData.rankingAiData && auditData.rankingAiData.combinedRows && Array.isArray(auditData.rankingAiData.combinedRows) && auditData.rankingAiData.combinedRows.length > 0;
                    const hasGscData = auditData.searchData && auditData.searchData.overview && (auditData.searchData.overview.clicks > 0 || auditData.searchData.overview.impressions > 0);
                    
                    // If missing critical data, try nearby dates (1, 2 days)
                    if (!hasRankingData || !hasGscData) {
                      debugLog(`[Dashboard] Audit ${prevAuditDate} missing critical data (rankingData=${hasRankingData}, gscData=${hasGscData}), trying nearby dates`, 'info');
                      
                      // Try 1 day, then 2 days
                      for (const dayOffset of [1, -1, 2, -2]) {
                        const tryDate = new Date(prevAuditDate);
                        tryDate.setDate(tryDate.getDate() + dayOffset);
                        const tryDateStr = tryDate.toISOString().split('T')[0];
                        
                        // Check if this date exists in sortedAudits and is not current
                        const tryMatch = sortedAudits.find(a => a.audit_date === tryDateStr && a.audit_date !== currentAuditDate);
                        if (!tryMatch) continue;
                        
                        // Skip if anomalous
                        if (anomalousAuditDates.has(tryDateStr)) continue;
                        
                        debugLog(`[Dashboard] Trying fallback date ${tryDateStr} (${dayOffset > 0 ? '+' : ''}${dayOffset} days)`, 'info');
                        
                        try {
                          const tryAuditUrl = urlHelper(`/api/supabase/get-audit-by-date?propertyUrl=${encodeURIComponent(propertyUrl)}&auditDate=${tryDateStr}`);
                          const tryResponse = await fetch(tryAuditUrl);
                          if (tryResponse.ok) {
                            const tryResult = await tryResponse.json();
                            if (tryResult.status === 'ok' && tryResult.data) {
                              const tryData = tryResult.data;
                              const tryHasRanking = tryData.rankingAiData && tryData.rankingAiData.combinedRows && Array.isArray(tryData.rankingAiData.combinedRows) && tryData.rankingAiData.combinedRows.length > 0;
                              const tryHasGsc = tryData.searchData && tryData.searchData.overview && (tryData.searchData.overview.clicks > 0 || tryData.searchData.overview.impressions > 0);
                              
                              // Use this date if it has the missing data
                              if ((!hasRankingData && tryHasRanking) || (!hasGscData && tryHasGsc)) {
                                debugLog(`[Dashboard]  Using fallback date ${tryDateStr} (has ranking=${tryHasRanking}, has gsc=${tryHasGsc})`, 'success');
                                return tryData;
                              }
                            }
                          }
                        } catch (tryErr) {
                          // Continue to next date
                          debugLog(`[Dashboard] Error trying fallback date ${tryDateStr}: ${tryErr?.message || tryErr}`, 'info');
                        }
                      }
                    }
                    
                    debugLog(`[Dashboard]  Fetched full audit data for ${prevAuditDate}`, 'success');
                    return auditData; // Return full audit data structure
                  } else {
                    debugLog(`[Dashboard] Full audit result missing data: status=${fullAuditResult.status}, message=${fullAuditResult.message || 'none'}`, 'warn');
                  }
                } else {
                  const errorText = await fullAuditResponse.text().catch(() => 'Unable to read error');
                  debugLog(`[Dashboard] Failed to fetch full audit for ${prevAuditDate}: ${fullAuditResponse.status} - ${errorText}`, 'warn');
                }
              } catch (fetchErr) {
                debugLog(`[Dashboard] Error fetching full audit for ${prevAuditDate}: ${fetchErr?.message || fetchErr}`, 'warn');
              }
              
              // Fallback: Reconstruct minimal audit data structure from history record
              // This is less complete but better than nothing
              // NOTE: History API returns camelCase fields (visibilityScore, not visibility_score)
              const prevAuditFromHistory = bestMatch.data;
              const prevAuditData = {
                auditDate: prevAuditDate,
                scores: {
                  visibility: prevAuditFromHistory.visibilityScore || prevAuditFromHistory.visibility_score || null,
                  authority: prevAuditFromHistory.authorityScore || prevAuditFromHistory.authority_score || null,
                  contentSchema: prevAuditFromHistory.contentSchemaScore || prevAuditFromHistory.content_schema_score || null,
                  localEntity: prevAuditFromHistory.localEntityScore || prevAuditFromHistory.local_entity_score || null,
                  serviceArea: prevAuditFromHistory.serviceAreaScore || prevAuditFromHistory.service_area_score || null,
                  aiSummaryScore: prevAuditFromHistory.aiSummaryScore || prevAuditFromHistory.ai_summary_score || null
                },
                searchData: {
                  overview: {
                    clicks: prevAuditFromHistory.gsc_clicks || prevAuditFromHistory.gscClicks || 0,
                    impressions: prevAuditFromHistory.gsc_impressions || prevAuditFromHistory.gscImpressions || 0,
                    position: prevAuditFromHistory.gsc_avg_position || prevAuditFromHistory.gscAvgPosition || null,
                    ctr: prevAuditFromHistory.gsc_ctr || prevAuditFromHistory.gscCtr || 0
                  }
                },
                moneyPagesMetrics: prevAuditFromHistory.moneySegmentMetrics || prevAuditFromHistory.money_pages_metrics || (prevAuditFromHistory.moneyPagesSummary || prevAuditFromHistory.money_pages_summary ? {
                  overview: prevAuditFromHistory.moneyPagesSummary || prevAuditFromHistory.money_pages_summary
                } : null)
              };
              
              debugLog(`[Dashboard] Using fallback minimal audit data for ${prevAuditDate} - visibility: ${prevAuditData.scores.visibility}, authority: ${prevAuditData.scores.authority}, clicks: ${prevAuditData.searchData.overview.clicks}, impressions: ${prevAuditData.searchData.overview.impressions}`, 'info');
              return prevAuditData;
            } else if (currentIndex === -1 && sortedAudits.length > 0) {
              // Current audit not found in history, use the most recent one as fallback
              const mostRecentDate = sortedAudits[0].audit_date;
              if (mostRecentDate !== currentAuditDate) {
                const mostRecentData = sortedAudits[0].data;
                const prevAuditData = {
                  auditDate: mostRecentDate,
                  scores: {
                    visibility: mostRecentData.visibility_score,
                    authority: mostRecentData.authority_score,
                    contentSchema: mostRecentData.content_schema_score,
                    localEntity: mostRecentData.local_entity_score,
                    serviceArea: mostRecentData.service_area_score,
                    aiSummaryScore: mostRecentData.ai_summary_score
                  },
                  searchData: {
                    overview: {
                      clicks: mostRecentData.gsc_clicks || 0,
                      impressions: mostRecentData.gsc_impressions || 0,
                      position: mostRecentData.gsc_avg_position || null,
                      ctr: mostRecentData.gsc_ctr || 0
                    }
                  },
                  moneyPagesMetrics: mostRecentData.money_pages_metrics || (mostRecentData.money_pages_summary ? {
                    overview: mostRecentData.money_pages_summary
                  } : null)
                };
                debugLog(`[Dashboard] Using most recent audit as fallback: ${mostRecentDate}`, 'info');
                return prevAuditData;
              }
            }
          } else {
            debugLog(`[Dashboard] fetchPreviousAuditForDeltas: Not enough audit history (found ${historyResult.data?.length || 0} audits, status=${historyResult.status})`, 'warn');
          }
          
          debugLog(`[Dashboard] fetchPreviousAuditForDeltas: Returning null - no suitable previous audit found`, 'warn');
          return null;
        } catch (err) {
          debugLog(`[Dashboard] fetchPreviousAuditForDeltas: Exception - ${err?.message || err}`, 'error');
          console.error('[Dashboard] fetchPreviousAuditForDeltas error:', err);
          return null;
        }
      }

      window.renderDashboardTab = async function renderDashboardTab() {
        // CRITICAL: Fetch latest audit from Supabase to ensure we have fresh data
        // This ensures Audit Scan and Money Pages tiles show the latest data after global audit
        try {
          const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
          if (propertyUrl) {
            let latestAuditFromSupabase = null;
            if (typeof window.fetchLatestAuditFromSupabase === 'function') {
              latestAuditFromSupabase = await window.fetchLatestAuditFromSupabase(propertyUrl, false);
            } else {
              // Fallback: fetch directly from API
              try {
                const apiBase = window.apiUrl ? window.apiUrl('') : (window.location.origin.includes('localhost') ? 'http://localhost:3000' : 'https://ai-geo-audit.vercel.app');
                const response = await fetch(`${apiBase}/api/supabase/get-latest-audit?property_url=${encodeURIComponent(propertyUrl)}`);
                if (response.ok) {
                  latestAuditFromSupabase = await response.json();
                }
              } catch (apiErr) {
                debugLog(`[Dashboard] Error fetching latest audit from API: ${apiErr.message || apiErr}`, 'warn');
              }
            }
            
            if (latestAuditFromSupabase) {
              // Update localStorage with latest audit data to ensure snapshot uses fresh data
              localStorage.setItem('last_audit_results', JSON.stringify(latestAuditFromSupabase));
              debugLog(`[Dashboard] Updated localStorage with latest audit from Supabase (audit_date: ${latestAuditFromSupabase.auditDate || latestAuditFromSupabase.audit_date || 'unknown'})`, 'info');
              // Also update window.moneyPagesMetrics if available
              if (latestAuditFromSupabase.scores?.moneyPagesMetrics || latestAuditFromSupabase.moneyPagesMetrics) {
                window.moneyPagesMetrics = latestAuditFromSupabase.scores?.moneyPagesMetrics || latestAuditFromSupabase.moneyPagesMetrics;
                window.currentMoneyPagesMetrics = window.moneyPagesMetrics;
              }
            }
          }
        } catch (fetchErr) {
          debugLog(`[Dashboard] Error fetching latest audit for dashboard refresh: ${fetchErr.message || fetchErr}`, 'warn');
          // Continue with localStorage data as fallback
        }
        
        // Always show LIVE latest-available metrics (from the latest independent audits).
        // Deltas are computed using rolling 28-day window (audit ~27 days ago vs current) for consistency.
        const liveSnapshot = computeDashboardSnapshot();

        // If admin key exists, auto-load optimisation tasks so the dashboard isn't blank.
        // Throttle to avoid hammering the API and to avoid loops (loadAllOptimisationTasks also triggers renderDashboardTab).
        try {
          const hasKey = (typeof window.hasAdminKey === 'function') ? window.hasAdminKey() : false;
          const canLoad = (typeof window.loadAllOptimisationTasks === 'function');
          const notLoadedYet = !isOptimisationDataLoadedForDashboard();
          const lastAutoMs = window.__dashboardAutoLoadOptimisationMs || 0;
          const allow = Date.now() - lastAutoMs > 60 * 1000; // 60s throttle
          if (hasKey && canLoad && notLoadedYet && allow) {
            window.__dashboardAutoLoadOptimisationMs = Date.now();
            setTimeout(() => {
              try { window.loadAllOptimisationTasks(); } catch (e) {}
            }, 0);
          }
        } catch (e) {
          // ignore
        }

        const runs = getDashboardRuns();
        const lastGlobal = runs.length ? runs[runs.length - 1] : null;
        const prevGlobal = runs.length > 1 ? runs[runs.length - 2] : null;

        const lastRunEl = document.getElementById('dashboard-last-run');
        const lastStatusEl = document.getElementById('dashboard-last-status');
        if (lastRunEl) lastRunEl.textContent = lastGlobal ? formatUtcTimestamp(lastGlobal.timestamp) : '';
        if (lastStatusEl) lastStatusEl.textContent = lastGlobal ? (lastGlobal.status || 'ok') : '';

        // Update "Last Audit" pills at the top of each module page to use consistent timestamp
        // updateAuditTimestamp() now automatically uses lastGlobal.timestamp internally, so we just need to call it
        updateAuditTimestamp(null); // Pass null - function will fetch lastGlobal.timestamp internally

        // CRITICAL: Fetch audit from ~27 days ago for rolling 28-day delta calculations
        // This ensures consistent time-period comparisons across all dashboard tiles
        let prevMetricsFromRolling28d = null;
        try {
          const currentAudit = dashboardSafeJsonParse(localStorage.getItem('last_audit_results'), null);
          // Try both auditDate and audit_date (different APIs use different field names)
          const currentAuditDate = currentAudit?.auditDate || currentAudit?.audit_date || null;
          if (currentAudit && currentAuditDate) {
            const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
            if (propertyUrl) {
              debugLog(`[Dashboard] Fetching previous audit for deltas - currentAuditDate=${currentAuditDate}, propertyUrl=${propertyUrl}`, 'info');
              const prevAuditData = await fetchPreviousAuditForDeltas(propertyUrl, currentAuditDate);
              if (prevAuditData) {
                // Compute snapshot from rolling 28-day audit data
                const prevSnapshot = computeDashboardSnapshotFromAuditData(prevAuditData);
                prevMetricsFromRolling28d = prevSnapshot;
                debugLog(`[Dashboard]  Computed prevMetrics from audit ${prevAuditData.auditDate || prevAuditData.audit_date || 'unknown'}: GAIO=${prevSnapshot?.gaioScore ?? 'null'}, AI Summary=${prevSnapshot?.aiSummaryScore ?? 'null'}, Clicks=${prevSnapshot?.auditKpis?.clicks ?? 'null'}, Impressions=${prevSnapshot?.auditKpis?.impressions ?? 'null'}, RankingKpis=${prevSnapshot?.rankingKpis ? 'present' : 'null'}, DomainStrength=${prevSnapshot?.domainStrength ? 'present' : 'null'}`, 'success');
              } else {
                debugLog(`[Dashboard]  No previous audit found for rolling 28-day delta calculation (fetchPreviousAuditForDeltas returned null)`, 'warn');
              }
            } else {
              debugLog(`[Dashboard]  No property URL found for rolling 28-day delta calculation`, 'warn');
            }
          } else {
            debugLog(`[Dashboard]  No current audit or auditDate found in localStorage for rolling 28-day delta calculation - currentAudit=${!!currentAudit}, currentAuditDate=${currentAuditDate}`, 'warn');
          }
        } catch (err) {
          debugLog(`[Dashboard]  Error fetching rolling 28-day audit for deltas: ${err?.message || err}`, 'error');
          console.error('[Dashboard] Error fetching rolling 28-day audit:', err);
        }

        // Use rolling 28-day deltas if available, otherwise fall back to global run snapshots
        const prevMetrics = prevMetricsFromRolling28d || prevGlobal?.metrics || null;
        if (!prevMetrics) {
          debugLog(`[Dashboard]  No previous metrics available for delta calculations (prevMetricsFromRolling28d: ${!!prevMetricsFromRolling28d}, prevGlobal: ${!!prevGlobal})`, 'warn');
        } else {
          debugLog(`[Dashboard]  prevMetrics ready - GAIO: ${prevMetrics?.gaioScore ?? 'null'}, AI Summary: ${prevMetrics?.aiSummaryScore ?? 'null'}, Audit KPIs: ${prevMetrics?.auditKpis ? `Clicks=${prevMetrics.auditKpis.clicks}, Impressions=${prevMetrics.auditKpis.impressions}` : 'null'}`, 'success');
        }
        const metrics = liveSnapshot;
        debugLog(`[Dashboard] Current metrics - GAIO: ${metrics?.gaioScore ?? 'null'}, AI Summary: ${metrics?.aiSummaryScore ?? 'null'}, Audit KPIs: ${metrics?.auditKpis ? `Clicks=${metrics.auditKpis.clicks}, Impressions=${metrics.auditKpis.impressions}` : 'null'}`, 'info');

        // Dial: GAIO
        {
          const v = metrics?.gaioScore ?? null;
          const p = typeof v === 'number' ? v : null;
          const rag = scoreToRag(p, { greenAt: 70, amberAt: 50 });
          const prevGaio = prevMetrics?.gaioScore ?? null;
          const deltaText = formatDelta(v, prevGaio);
          debugLog(`[Dashboard] GAIO delta calculation: current=${v}, previous=${prevGaio}, deltaText="${deltaText}"`, 'info');
          setDial(document.getElementById('dashboard-dial-gaio'), {
            valueText: typeof v === 'number' ? `${v}/100` : '',
            pct: p,
            rag,
            deltaText: deltaText
          });
          setDialDeltaDir(document.getElementById('dashboard-dial-gaio'), v, prevGaio, { betterLower: false });
          updateDeltaIndicator('dashboard-delta-gaio', v, prevGaio, { betterLower: false, decimals: 0 });
          clearDeltaBreakdown('dashboard-gaio-breakdown');
          renderDashboardGaioPillarsAndRadar(metrics?.pillars || null, prevMetrics?.pillars || null);
        }

        // Dial: AI Summary
        {
          const v = metrics?.aiSummaryScore ?? null;
          const p = typeof v === 'number' ? v : null;
          const rag = scoreToRag(p, { greenAt: 70, amberAt: 50 });
          setDial(document.getElementById('dashboard-dial-ai-summary'), {
            valueText: typeof v === 'number' ? `${v}/100` : '',
            pct: p,
            rag,
            deltaText: formatDelta(metrics?.aiSummaryScore, prevMetrics?.aiSummaryScore)
          });
          setDialDeltaDir(document.getElementById('dashboard-dial-ai-summary'), v, prevMetrics?.aiSummaryScore ?? null, { betterLower: false });
          updateDeltaIndicator('dashboard-delta-ai-summary', v, prevMetrics?.aiSummaryScore ?? null, { betterLower: false, decimals: 0 });
          clearDeltaBreakdown('dashboard-ai-summary-breakdown');
          const host = document.getElementById('dashboard-ai-summary-mini');
          if (host) {
            const markerLeft = (typeof p === 'number') ? Math.max(0, Math.min(100, Math.round(p))) : null;
            host.innerHTML = `
              <div class="dashboard-mini-gauge" title="Quick view of where the score sits on the 0100 scale (redambergreen).">
                <div class="fill"></div>
                ${markerLeft == null ? '' : `<div class="marker" style="left: calc(${markerLeft}% - 1px);"></div>`}
              </div>
              <div class="dashboard-mini-note">Higher = more likely AI systems summarise your brand pages confidently.</div>
            `;
          }
          // Render chart - always call, function will handle Chart.js check
          renderDashboardAiSummaryRadar(metrics?.aiSummaryComponents || null, prevMetrics?.aiSummaryComponents || null);
        }

        // Dial: Money share
        {
          const pct = metrics?.moneySharePct ?? null;
          const money = metrics?.moneyCitations ?? null;
          const total = metrics?.totalCitations ?? null;
          const rag = scoreToRag(typeof pct === 'number' ? pct : null, { greenAt: 70, amberAt: 50 });
          const text = (typeof money === 'number' && typeof total === 'number')
            ? `${money}/${total} (${pct ?? 0}%)`
            : '';
          setDial(document.getElementById('dashboard-dial-money-share'), {
            valueText: text,
            pct: typeof pct === 'number' ? pct : null,
            rag,
            deltaText: formatDelta(metrics?.moneySharePct, prevMetrics?.moneySharePct)
          });
          setDialDeltaDir(document.getElementById('dashboard-dial-money-share'), pct, prevMetrics?.moneySharePct ?? null, { betterLower: false });
          updateDeltaIndicator('dashboard-delta-money-share', pct, prevMetrics?.moneySharePct ?? null, { betterLower: false, decimals: 0, pp: true });
          clearDeltaBreakdown('dashboard-money-share-breakdown');
          const host = document.getElementById('dashboard-money-share-mini');
          if (host) {
            const m = (typeof money === 'number') ? money : null;
            const t = (typeof total === 'number') ? total : null;
            const share = (m != null && t != null && t > 0) ? Math.max(0, Math.min(1, m / t)) : null;
            const leftPct = (share == null) ? null : Math.round(share * 100);
            host.innerHTML = `
              <div class="dashboard-mini-gauge" title="Stacked view: money-page citations share (marker shows percent).">
                <div class="fill" style="background: linear-gradient(90deg, rgba(16,185,129,0.85), rgba(245,158,11,0.85), rgba(239,68,68,0.75));"></div>
                ${leftPct == null ? '' : `<div class="marker" style="left: calc(${leftPct}% - 1px);"></div>`}
              </div>
              <div class="dashboard-mini-note">Goal: move citations toward Money Pages (commercial intent).</div>
            `;
          }
          // Render chart - always call, function will handle Chart.js check
          renderDashboardMoneyShareRadar(metrics?.moneyShareSplit || null, prevMetrics?.moneyShareSplit || null);
        }

        // Dial: Uplift remaining (Money Pages CTR target)
        {
          const extra = metrics?.moneyAgg?.uplift?.extraClicksAbs ?? null;
          const prevExtra = prevMetrics?.moneyAgg?.uplift?.extraClicksAbs ?? null;
          const currCtr = metrics?.moneyAgg?.ctrPct ?? null;
          const targetCtr = metrics?.moneyAgg?.targets?.ctrAbsPct ?? 2.5;
          const progressPct = (typeof currCtr === 'number' && typeof targetCtr === 'number' && targetCtr > 0)
            ? Math.max(0, Math.min(100, Math.round((currCtr / targetCtr) * 100)))
            : null;
          const rag = scoreToRag(typeof progressPct === 'number' ? progressPct : null, { greenAt: 70, amberAt: 50 });
          const valueText = (typeof extra === 'number')
            ? `+${formatInt(extra)}`
            : '';
          const deltaText = formatDeltaNumber(extra, prevExtra, { decimals: 0, betterLower: true });
          setDial(document.getElementById('dashboard-dial-uplift'), {
            valueText,
            pct: typeof progressPct === 'number' ? progressPct : null,
            rag,
            deltaText: (typeof extra === 'number' && typeof prevExtra === 'number') ? deltaText : ''
          });
          setDialDeltaDir(document.getElementById('dashboard-dial-uplift'), extra, prevExtra ?? null, { betterLower: true });
          updateDeltaIndicator('dashboard-delta-uplift', extra, prevExtra ?? null, { betterLower: true, decimals: 0 });
          clearDeltaBreakdown('dashboard-uplift-breakdown');
          const host = document.getElementById('dashboard-uplift-mini');
          if (host) {
            const markerLeft = (typeof progressPct === 'number') ? Math.max(0, Math.min(100, Math.round(progressPct))) : null;
            host.innerHTML = `
              <div class="dashboard-mini-gauge" title="Progress toward the Money Pages CTR target. Marker = current CTR vs target.">
                <div class="fill"></div>
                ${markerLeft == null ? '' : `<div class="marker" style="left: calc(${markerLeft}% - 1px);"></div>`}
              </div>
              <div class="dashboard-mini-note">Based on CTR gap: current ${typeof currCtr === 'number' ? formatPct(currCtr, 1) : ''} vs target ${targetCtr}%.</div>
            `;
          }
          // Render chart - always call, function will handle Chart.js check
          renderDashboardUpliftChart(metrics?.moneyPagesRows || null, targetCtr, prevMetrics?.moneyPagesRows || null);
        }

        // Dial: EEAT (placeholder)
        {
          const v = metrics?.eeatScore ?? null;
          const p = typeof v === 'number' ? v : null;
          const rag = scoreToRag(p, { greenAt: 70, amberAt: 50 });
          setDial(document.getElementById('dashboard-dial-eeat'), {
            valueText: typeof v === 'number' ? `${v}/100` : '',
            pct: p,
            rag,
            deltaText: formatDelta(metrics?.eeatScore, prevMetrics?.eeatScore)
          });
          setDialDeltaDir(document.getElementById('dashboard-dial-eeat'), v, prevMetrics?.eeatScore ?? null, { betterLower: false });
          updateDeltaIndicator('dashboard-delta-eeat', v, prevMetrics?.eeatScore ?? null, { betterLower: false, decimals: 0 });
          clearDeltaBreakdown('dashboard-eeat-breakdown');
          const host = document.getElementById('dashboard-eeat-mini');
          if (host) {
            const c = metrics?.eeatConfidence || '';
            const s = metrics?.eeatSubscores || {};
            const breakdown = `EEAT v1 (proxy) breakdown:
Experience: ${toNum(s.experience) ?? ''}/100
Expertise: ${toNum(s.expertise) ?? ''}/100
Authoritativeness: ${toNum(s.authoritativeness) ?? ''}/100
Trustworthiness: ${toNum(s.trustworthiness) ?? ''}/100
Confidence: ${c}

Signals used (where available): reviews+behaviour+local signals, content/schema+snippet readiness, backlinks+domain strength+AI citations, NAP consistency.`;
            host.innerHTML = `
              <div class="dashboard-mini-gauge" title="${breakdown.replace(/"/g, '&quot;')}">
                <div class="fill"></div>
              </div>
              <div class="dashboard-mini-note">Confidence: <strong>${c}</strong>  E ${toNum(s.experience) ?? ''}  Ex ${toNum(s.expertise) ?? ''}  A ${toNum(s.authoritativeness) ?? ''}  T ${toNum(s.trustworthiness) ?? ''}</div>
            `;
          }
          renderDashboardEeatRadar(metrics?.eeatSubscores || null, prevMetrics?.eeatSubscores || null);
        }

        // Summary cards (use latest available data from localStorage/window)
        const audit = dashboardSafeJsonParse(localStorage.getItem('last_audit_results'), null);
        const rankingStore = dashboardSafeJsonParse(localStorage.getItem('rankingAiData'), null);
        const rankingRows = (rankingStore && Array.isArray(rankingStore.combinedRows)) ? rankingStore.combinedRows : [];

        const rankingFresh = computeFreshnessBadge(rankingStore?.timestamp || null, { warnDays: 3, staleDays: 7 });
        const moneyFresh = computeFreshnessBadge(audit?.timestamp || null, { warnDays: 3, staleDays: 7 });

        const gaioRag = scoreToRag(metrics?.gaioScore ?? null, { greenAt: 70, amberAt: 50 });
        const moneyShareRag = scoreToRag(metrics?.moneySharePct ?? null, { greenAt: 70, amberAt: 50 });

        const auditCard = audit ? {
          timestamp: lastGlobal?.timestamp || audit.timestamp || null,
          rag: gaioRag,
          ragLabel: (typeof metrics?.gaioScore === 'number') ? `${gaioRag.toUpperCase()} (${metrics.gaioScore}/100)` : 'Unknown',
          kpis: audit.searchData ? {
            clicks: formatInt(metrics?.auditKpis?.clicks),
            impressions: formatInt(metrics?.auditKpis?.impressions),
            avgPosition: (typeof metrics?.auditKpis?.avgPosition === 'number') ? formatFixed(metrics.auditKpis.avgPosition, 1) : '',
            ctr: (typeof metrics?.auditKpis?.ctrPct === 'number') ? formatPct(metrics.auditKpis.ctrPct, 1) : ''
          } : null
          ,
          deltas: {
            clicks: (prevMetrics?.auditKpis ? formatDeltaNumber(metrics?.auditKpis?.clicks, prevMetrics.auditKpis.clicks, { decimals: 0 }) : ''),
            impressions: (prevMetrics?.auditKpis ? formatDeltaNumber(metrics?.auditKpis?.impressions, prevMetrics.auditKpis.impressions, { decimals: 0 }) : ''),
            avgPosition: (prevMetrics?.auditKpis ? formatDeltaNumber(metrics?.auditKpis?.avgPosition, prevMetrics.auditKpis.avgPosition, { decimals: 1, betterLower: true }) : ''),
            ctr: (prevMetrics?.auditKpis ? formatDeltaNumber(metrics?.auditKpis?.ctrPct, prevMetrics.auditKpis.ctrPct, { decimals: 1, pp: true }) : '')
          },
          dirs: {
            clicks: deltaDir(metrics?.auditKpis?.clicks, prevMetrics?.auditKpis?.clicks, { betterLower: false }),
            impressions: deltaDir(metrics?.auditKpis?.impressions, prevMetrics?.auditKpis?.impressions, { betterLower: false }),
            avgPosition: (() => {
              const curr = metrics?.auditKpis?.avgPosition;
              const prev = prevMetrics?.auditKpis?.avgPosition;
              const dir = deltaDir(curr, prev, { betterLower: true });
              debugLog(`[Dashboard] Avg Position delta dir: current=${curr}, previous=${prev}, dir=${dir}`, 'info');
              return dir;
            })(),
            ctr: deltaDir(metrics?.auditKpis?.ctrPct, prevMetrics?.auditKpis?.ctrPct, { betterLower: false })
          }
        } : null;

        const rankingK = metrics?.rankingKpis || null;
        const prevRankingK = prevMetrics?.rankingKpis || null;
        const hasRanking = !!(rankingStore && rankingStore.timestamp);
        const rankingRag = hasRanking ? scoreToRag(rankingK?.top3SharePct ?? null, { greenAt: 70, amberAt: 50 }) : 'neutral';
        const rankingCard = {
          timestamp: lastGlobal?.timestamp || rankingStore?.timestamp || null,
          rag: rankingRag,
          ragLabel: hasRanking
            ? (rankingK?.top3SharePct != null ? `Top 3 share: ${rankingK.top3SharePct}%` : 'Rankings loaded')
            : rankingFresh.label,
          run: {
            label: 'Run scan',
            title: 'Runs the Ranking & AI check now (uses existing keywords list).',
            onClick: "if (typeof window.dashboardRunRankingAiScan === 'function') window.dashboardRunRankingAiScan();",
            title: 'Runs the Keyword Ranking and AI check now (uses existing keywords list).'
          },
          kpis: {
            top3Share: (rankingK?.top3SharePct != null) ? formatPct(rankingK.top3SharePct, 0) : '',
            top10Share: (rankingK?.top10SharePct != null) ? formatPct(rankingK.top10SharePct, 0) : '',
            citations: formatInt(rankingK?.citationsTotal),
            moneyShare: (typeof metrics?.moneySharePct === 'number') ? formatPct(metrics.moneySharePct, 0) : ''
          },
          deltas: {
            top3Share: (prevRankingK ? formatDeltaNumber(rankingK?.top3SharePct, prevRankingK.top3SharePct, { decimals: 0, pp: true }) : ''),
            top10Share: (prevRankingK ? formatDeltaNumber(rankingK?.top10SharePct, prevRankingK.top10SharePct, { decimals: 0, pp: true }) : ''),
            citations: (prevRankingK ? formatDeltaNumber(rankingK?.citationsTotal, prevRankingK.citationsTotal, { decimals: 0 }) : ''),
            moneyShare: (typeof prevMetrics?.moneySharePct === 'number' ? formatDeltaNumber(metrics?.moneySharePct, prevMetrics.moneySharePct, { decimals: 0, pp: true }) : '')
          },
          dirs: {
            top3Share: deltaDir(rankingK?.top3SharePct, prevRankingK?.top3SharePct, { betterLower: false }),
            top10Share: deltaDir(rankingK?.top10SharePct, prevRankingK?.top10SharePct, { betterLower: false }),
            citations: deltaDir(rankingK?.citationsTotal, prevRankingK?.citationsTotal, { betterLower: false }),
            moneyShare: deltaDir(metrics?.moneySharePct, prevMetrics?.moneySharePct, { betterLower: false })
          }
        };

        const moneyMetricsFromAudit = audit?.scores?.moneyPagesMetrics || audit?.moneyPagesMetrics || null;
        const moneyAgg = metrics?.moneyAgg || null;
        const prevMoneyAgg = prevMetrics?.moneyAgg || null;
        const hasMoneyPages = !!moneyAgg;
        const moneyCtrTarget = moneyAgg?.targets?.ctrAbsPct ?? 2.5;
        const moneyCtrProgressPct = (moneyAgg?.ctrPct != null && moneyCtrTarget > 0) ? Math.round((moneyAgg.ctrPct / moneyCtrTarget) * 100) : null;
        const moneyRag = scoreToRag((typeof moneyCtrProgressPct === 'number') ? Math.min(100, moneyCtrProgressPct) : null, { greenAt: 70, amberAt: 50 });
        const moneyPagesCard = {
          note: hasMoneyPages && lastGlobal?.timestamp
            ? `Last audit: ${formatUtcTimestamp(lastGlobal.timestamp)}  CTR target:  ${moneyCtrTarget}% (alt: +0.3pp)  Position targets: 10 (alt: -2)`
            : (lastGlobal?.timestamp ? `No Money Pages metrics in latest audit (last: ${formatUtcTimestamp(lastGlobal.timestamp)})` : 'No Money Pages metrics yet'),
          timestamp: lastGlobal?.timestamp || audit?.timestamp || null,
          rag: hasMoneyPages ? moneyRag : 'neutral',
          ragLabel: hasMoneyPages ? `CTR: ${formatPct(moneyAgg?.ctrPct, 1)} (target ${moneyCtrTarget}%)` : 'Not run',
          run: {
            label: 'Run scan',
            title: 'Refreshes Money Pages using the latest audit in Supabase (does not run a new audit).',
            onClick: "if (typeof window.dashboardRunMoneyPagesScan === 'function') window.dashboardRunMoneyPagesScan();"
          },
          kpis: {
            clicks: formatInt(moneyAgg?.clicks),
            ctr: (typeof moneyAgg?.ctrPct === 'number') ? formatPct(moneyAgg.ctrPct, 1) : '',
            avgPosition: (typeof moneyAgg?.avgPosition === 'number') ? formatFixed(moneyAgg.avgPosition, 1) : '',
            uplift: (typeof moneyAgg?.uplift?.extraClicksAbs === 'number') ? `+${formatInt(moneyAgg.uplift.extraClicksAbs)}` : ''
          },
          deltas: {
            clicks: (prevMoneyAgg ? formatDeltaNumber(moneyAgg?.clicks, prevMoneyAgg.clicks, { decimals: 0 }) : ''),
            ctr: (prevMoneyAgg ? formatDeltaNumber(moneyAgg?.ctrPct, prevMoneyAgg.ctrPct, { decimals: 1, pp: true }) : ''),
            avgPosition: (prevMoneyAgg ? formatDeltaNumber(moneyAgg?.avgPosition, prevMoneyAgg.avgPosition, { decimals: 1, betterLower: true }) : ''),
            uplift: (prevMoneyAgg ? formatDeltaNumber(moneyAgg?.uplift?.extraClicksAbs, prevMoneyAgg.uplift?.extraClicksAbs, { decimals: 0, betterLower: true }) : '')
          },
          dirs: {
            clicks: deltaDir(moneyAgg?.clicks, prevMoneyAgg?.clicks, { betterLower: false }),
            ctr: deltaDir(moneyAgg?.ctrPct, prevMoneyAgg?.ctrPct, { betterLower: false }),
            avgPosition: (() => {
              const curr = moneyAgg?.avgPosition;
              const prev = prevMoneyAgg?.avgPosition;
              const dir = deltaDir(curr, prev, { betterLower: true });
              debugLog(`[Dashboard] Money Pages avgPosition delta dir: current=${curr}, previous=${prev}, dir=${dir}`, 'info');
              return dir;
            })(),
            uplift: deltaDir(moneyAgg?.uplift?.extraClicksAbs, prevMoneyAgg?.uplift?.extraClicksAbs, { betterLower: true })
          }
        };

        const optLoaded = isOptimisationDataLoadedForDashboard();
        const optPotential = metrics?.optimisationPotentialClicks ?? null;
        const prevOptPotential = prevMetrics?.optimisationPotentialClicks ?? null;
        const optScope = window.optimisationModuleState?.scope || 'active_cycle';
        const trafficCounts = (optLoaded && typeof computeTrafficLightCounts === 'function')
          ? computeTrafficLightCounts(getOptimisationTasksForDashboard(), optScope)
          : null;
        const optCard = {
          note: optLoaded ? 'Uses optimisation tasks loaded in this browser session (admin key required)' : 'Not loaded (set admin key + open Optimisation tab or run global run)',
          rag: optLoaded ? scoreToRag((toNum(metrics?.execPct) ?? null), { greenAt: 70, amberAt: 50 }) : 'neutral',
          ragLabel: optLoaded ? (typeof metrics?.execPct === 'number' ? `Updated (28d): ${metrics.execPct}%` : 'Loaded') : 'Not loaded',
          kpis: {
            potential: (typeof optPotential === 'number') ? `+${formatInt(optPotential)}` : '',
            trafficAll: trafficCounts?.all_metrics || null,
            trafficCtr: trafficCounts?.ctr_28d || null,
            trafficCitations: trafficCounts?.ai_citations || null
          },
          deltas: {
            potential: (typeof optPotential === 'number' && typeof prevOptPotential === 'number') ? formatDeltaNumber(optPotential, prevOptPotential, { decimals: 0, betterLower: true }) : '',
            updated: (typeof metrics?.execPct === 'number' && typeof prevMetrics?.execPct === 'number') ? formatDeltaNumber(metrics.execPct, prevMetrics.execPct, { decimals: 0, pp: true }) : ''
          },
          dirs: {
            potential: deltaDir(optPotential, prevOptPotential, { betterLower: true }),
            updated: deltaDir(metrics?.execPct, prevMetrics?.execPct, { betterLower: false })
          }
        };

        const ds = metrics?.domainStrength || null;
        const prevDs = prevMetrics?.domainStrength || null;
        const selfScore = toNum(ds?.selfScore);
        const topScore = toNum(ds?.topCompetitorScore);
        const gapTop = (selfScore != null && topScore != null) ? (topScore - selfScore) : null;
        const strongerCount = toNum(ds?.strongerCount);
        const competitorsCount = toNum(ds?.competitorsCount);
        const rank = (typeof strongerCount === 'number') ? (strongerCount + 1) : null;
        const rankDenom = (typeof competitorsCount === 'number') ? competitorsCount : null; // competitor-only set
        const domainRag = scoreToRag(selfScore, { greenAt: 70, amberAt: 50 });
        const domainCard = {
          note: ds?.snapshotDate ? `Snapshot date: ${ds.snapshotDate}` : 'Run snapshot to populate (Ranking & AI tab)',
          timestamp: lastGlobal?.timestamp || null,
          rag: (typeof selfScore === 'number') ? domainRag : 'neutral',
          ragLabel: (typeof selfScore === 'number') ? `Score: ${formatFixed(selfScore, 1)}` : 'Not run',
          run: {
            label: 'Run snapshot',
            title: 'Runs a Domain Strength snapshot now.',
            onClick: "if (typeof window.runDomainStrengthSnapshot === 'function') window.runDomainStrengthSnapshot();"
          },
          kpis: {
            selfScore: (typeof selfScore === 'number') ? formatFixed(selfScore, 1) : '',
            gapTop: (typeof gapTop === 'number') ? `+${formatFixed(Math.max(0, gapTop), 1)}` : '',
            stronger: (typeof strongerCount === 'number') ? formatInt(strongerCount) : '',
            rankVs: (typeof rank === 'number' && typeof rankDenom === 'number') ? `${formatInt(rank)}/${formatInt(rankDenom)}` : ''
          },
          deltas: {
            selfScore: (prevDs ? formatDeltaNumber(selfScore, prevDs.selfScore, { decimals: 1 }) : ''),
            gapTop: (prevDs ? formatDeltaNumber(gapTop, (toNum(prevDs?.topCompetitorScore) != null && toNum(prevDs?.selfScore) != null) ? (toNum(prevDs.topCompetitorScore) - toNum(prevDs.selfScore)) : null, { decimals: 1, betterLower: true }) : ''),
            stronger: (prevDs ? formatDeltaNumber(strongerCount, prevDs.strongerCount, { decimals: 0, betterLower: true }) : '')
          },
          dirs: {
            selfScore: deltaDir(selfScore, prevDs?.selfScore, { betterLower: false }),
            gapTop: deltaDir(gapTop, (toNum(prevDs?.topCompetitorScore) != null && toNum(prevDs?.selfScore) != null) ? (toNum(prevDs.topCompetitorScore) - toNum(prevDs.selfScore)) : null, { betterLower: true }),
            stronger: deltaDir(strongerCount, prevDs?.strongerCount, { betterLower: true })
          }
        };

        renderDashboardSummaryCards({
          audit: auditCard,
          ranking: rankingCard,
          moneyPages: moneyPagesCard,
          optimisation: optCard,
          domainStrength: domainCard
        });

        // Async: refresh Domain Strength cache occasionally so the tile isn't stale.
        // Keep it non-blocking and avoid loops.
        setTimeout(() => {
          refreshDashboardDomainStrengthCacheIfNeeded().then((res) => {
            if (!res || res.updated !== true) return;
            // Only re-render if we're still on the dashboard tab.
            const active = document.querySelector('.aigeo-panel.is-active');
            if (active && active.dataset && active.dataset.panel === 'dashboard') {
              try { window.renderDashboardTab(); } catch (e) {}
            }
          });
        }, 0);
      };

      function dashboardRunModalSetProgress(pct) {
        const fill = document.getElementById('dashboardRunProgressFill');
        const text = document.getElementById('dashboardRunProgressText');
        const p = Math.max(0, Math.min(100, pct));
        if (fill) fill.style.width = `${p}%`;
        if (text) text.textContent = `${p}%`;
      }

      function dashboardRunModalSetStep(title, narrative) {
        const elTitle = document.getElementById('dashboardRunCurrentStep');
        const elNarr = document.getElementById('dashboardRunNarrative');
        if (elTitle) elTitle.textContent = title || '';
        if (elNarr) elNarr.textContent = narrative || '';
      }

      function dashboardRunModalRenderSteps(steps) {
        const list = document.getElementById('dashboardRunStepsList');
        if (!list) return;
        list.innerHTML = '';
        steps.forEach(s => {
          const row = document.createElement('div');
          row.style.display = 'flex';
          row.style.justifyContent = 'space-between';
          row.style.gap = '0.75rem';
          row.style.padding = '0.5rem 0.75rem';
          row.style.border = '1px solid var(--dark-border)';
          row.style.borderRadius = '8px';
          row.style.background = 'rgba(15, 20, 25, 0.35)';

          const left = document.createElement('div');
          left.style.display = 'flex';
          left.style.flexDirection = 'column';
          left.style.gap = '0.25rem';
          const labelDiv = document.createElement('div');
          labelDiv.textContent = s.label;
          labelDiv.style.fontWeight = '700';
          left.appendChild(labelDiv);
          if (s.elapsedTime !== undefined) {
            const timeDiv = document.createElement('div');
            timeDiv.textContent = ` ${s.elapsedTime}`;
            timeDiv.style.fontSize = '0.75rem';
            timeDiv.style.color = 'var(--dark-text-muted)';
            left.appendChild(timeDiv);
          }

          const right = document.createElement('div');
          right.style.display = 'flex';
          right.style.flexDirection = 'column';
          right.style.alignItems = 'flex-end';
          right.style.gap = '0.25rem';
          const statusDiv = document.createElement('div');
          statusDiv.textContent = s.status;
          statusDiv.style.fontWeight = '800';
          statusDiv.style.color = s.status === 'Done' ? '#10b981' : (s.status === 'Running' ? '#f59e0b' : (s.status === 'Failed' ? '#ef4444' : 'var(--dark-text-muted)'));
          right.appendChild(statusDiv);
          if (s.errorMessage) {
            const errorDiv = document.createElement('div');
            errorDiv.textContent = s.errorMessage;
            errorDiv.style.fontSize = '0.75rem';
            errorDiv.style.color = '#ef4444';
            errorDiv.style.maxWidth = '300px';
            errorDiv.style.textAlign = 'right';
            right.appendChild(errorDiv);
          }

          row.appendChild(left);
          row.appendChild(right);
          list.appendChild(row);
        });
      }

      function showDashboardRunModal() {
        const modal = document.getElementById('dashboardRunModal');
        const closeBtn = document.getElementById('dashboardRunClose');
        const summary = document.getElementById('dashboardRunSummary');
        if (summary) summary.style.display = 'none';
        if (modal) modal.style.display = 'block';
        if (closeBtn) closeBtn.disabled = true;
        dashboardRunModalSetProgress(0);
      }

      function finishDashboardRunModal({ ok, summaryHtml }) {
        const closeBtn = document.getElementById('dashboardRunClose');
        const closeBtnBottom = document.getElementById('dashboardRunCloseBottom');
        const summary = document.getElementById('dashboardRunSummary');
        const content = document.getElementById('dashboardRunSummaryContent');
        if (content) content.innerHTML = summaryHtml || '';
        if (summary) summary.style.display = 'block';
        if (closeBtn) {
          closeBtn.disabled = false;
          closeBtn.style.opacity = '1';
          closeBtn.style.cursor = 'pointer';
          closeBtn.title = 'Close';
          // Re-attach click handler in case it was lost
          closeBtn.onclick = () => {
            const modal = document.getElementById('dashboardRunModal');
            if (modal) modal.style.display = 'none';
          };
        }
        // Set up bottom close button handler
        if (closeBtnBottom) {
          closeBtnBottom.onclick = () => {
            const modal = document.getElementById('dashboardRunModal');
            if (modal) modal.style.display = 'none';
          };
        }
      }

      window.runDashboardGlobalRun = async function runDashboardGlobalRun() {
        debugLog('[Global Run] ========================================', 'info');
        debugLog('[Global Run] Starting Global Audit Run', 'info');
        debugLog('[Global Run] ========================================', 'info');
        
        const runBtn = document.getElementById('dashboard-run-all-btn');
        if (runBtn) runBtn.disabled = true;

        // Warn if admin key missing (task update step will likely fail)
        if (typeof window.hasAdminKey === 'function' && !window.hasAdminKey()) {
          const proceed = confirm('Admin key is not set. The "Update All Tasks" step will likely fail.\n\nRun anyway?');
          if (!proceed) {
            debugLog('[Global Run] Cancelled by user (admin key missing)', 'warn');
            if (runBtn) runBtn.disabled = false;
            return;
          }
        }

        const startIso = new Date().toISOString();
        debugLog(`[Global Run] Start time: ${startIso}`, 'info');
        
        const stepDefs = [
          { key: 'sync_csv', label: 'Sync CSV', runner: async () => { 
            debugLog('[Global Run] [Sync CSV] Starting...', 'info');
            if (typeof window.syncCsv === 'function') {
              const result = await window.syncCsv();
              debugLog(`[Global Run] [Sync CSV] Completed. Result: ${JSON.stringify(result || 'undefined')}`, 'info');
              return result;
            } else {
              throw new Error('syncCsv function not available');
            }
          } },
          { key: 'audit_scan', label: 'GSC & Backlink Audit', runner: async () => { 
            debugLog('[Global Run] [GSC & Backlink Audit] Starting...', 'info');
            if (typeof window.runAudit === 'function') {
              const result = await window.runAudit();
              debugLog(`[Global Run] [GSC & Backlink Audit] Completed. Result: ${JSON.stringify(result || 'undefined')}`, 'info');
              // Verify audit was saved by checking localStorage or Supabase
              const savedAudit = loadAuditResultsSync();
              if (savedAudit && savedAudit.timestamp) {
                debugLog(`[Global Run] [GSC & Backlink Audit]  Verified: Audit saved with timestamp ${new Date(savedAudit.timestamp).toISOString()}`, 'success');
              } else {
                debugLog('[Global Run] [GSC & Backlink Audit]  Warning: Could not verify audit save', 'warn');
              }
              return result;
            } else {
              throw new Error('runAudit function not available');
            }
          } },
          { key: 'ranking_ai', label: 'Run Ranking & AI Scan', runner: async () => { 
            debugLog('[Global Run] [Ranking & AI Scan] Starting...', 'info');
            if (typeof window.loadRankingAiData === 'function') {
              const result = await window.loadRankingAiData(true);
              debugLog(`[Global Run] [Ranking & AI Scan] Data loaded. Result: ${JSON.stringify(result || 'undefined')}`, 'info');
              
              // Verify Ranking & AI data was saved
              const savedRankingData = localStorage.getItem('rankingAiData');
              if (savedRankingData) {
                try {
                  const parsed = JSON.parse(savedRankingData);
                  debugLog(`[Global Run] [Ranking & AI Scan]  Verified: Data saved to localStorage (${parsed.combinedRows?.length || 0} keywords)`, 'success');
                } catch (e) {
                  debugLog('[Global Run] [Ranking & AI Scan]  Warning: Could not parse saved data', 'warn');
                }
              } else {
                debugLog('[Global Run] [Ranking & AI Scan]  Warning: No data found in localStorage (may be in Supabase only)', 'warn');
              }
              
              // CRITICAL: Wait for Ranking & AI data to be fully saved to Supabase before proceeding
              // This ensures bulkUpdateAllTasks can access the data when it runs
              debugLog('[Global Run] [Ranking & AI Scan] Waiting for data to be saved to Supabase...', 'info');
              const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || 'https://www.alanranger.com';
              let retries = 0;
              const maxRetries = 10;
              const retryDelay = 2000; // 2 seconds between retries
              
              while (retries < maxRetries) {
                try {
                  // Verify via keyword_rankings (lightweight, avoids full audit payload)
                  const checkUrl = apiUrl(`/api/supabase/get-keyword-rankings?propertyUrl=${encodeURIComponent(propertyUrl)}&latestOnly=true`);
                  const checkResponse = await fetch(checkUrl);
                  
                  if (checkResponse.ok) {
                    const checkData = await checkResponse.json();
                    const latestAuditDate = checkData?.data?.latestAuditDate;
                    const latestTimestamp = checkData?.data?.latestTimestamp;
                    if (checkData.status === 'ok' && (latestTimestamp || latestAuditDate)) {
                      debugLog(`[Global Run] [Ranking & AI Scan]  Verified: keyword_rankings saved (audit_date=${latestAuditDate || 'unknown'})`, 'success');
                      break; // Data is in Supabase, proceed
                    }
                  }
                  
                  retries++;
                  if (retries < maxRetries) {
                    debugLog(`[Global Run] [Ranking & AI Scan] Waiting for Supabase save... (attempt ${retries}/${maxRetries})`, 'info');
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                  } else {
                    debugLog('[Global Run] [Ranking & AI Scan]  Warning: Could not verify Supabase save after all retries. Proceeding anyway...', 'warn');
                  }
                } catch (e) {
                  debugLog(`[Global Run] [Ranking & AI Scan] Error checking Supabase: ${e?.message || e}`, 'warn');
                  retries++;
                  if (retries < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                  }
                }
              }
              
              // Ensure Ranking & AI tab is refreshed after data loads
              if (typeof window.renderRankingAiTab === 'function') {
                await new Promise(resolve => setTimeout(resolve, 500)); // Small delay to ensure data is set
                window.renderRankingAiTab();
              }
              return result;
            } else {
              throw new Error('loadRankingAiData function not available');
            }
          } },
          { key: 'money_pages', label: 'Run Money Pages Scan', runner: async () => { 
            debugLog('[Global Run] [Money Pages Scan] Starting...', 'info');
            if (typeof window.dashboardRunMoneyPagesScan === 'function') {
              const result = await window.dashboardRunMoneyPagesScan();
              debugLog(`[Global Run] [Money Pages Scan] Completed. Result: ${JSON.stringify(result || 'undefined')}`, 'info');
              return result;
            } else {
              throw new Error('dashboardRunMoneyPagesScan function not available');
            }
          } },
          { key: 'domain_strength', label: 'Run Domain Strength Snapshot (All Batches)', runner: async () => {
            // Loop through all batches until queue is empty
            let remainingPending = 1; // Start with 1 to enter loop
            let batchCount = 0;
            const maxBatches = 20; // Safety limit to prevent infinite loops
            
            while (remainingPending > 0 && batchCount < maxBatches) {
              batchCount++;
              debugLog(`[Global Run] Domain Strength batch ${batchCount}...`, 'info');
              
              if (typeof window.runDomainStrengthSnapshot === 'function') {
                await window.runDomainStrengthSnapshot();
              }
              
              // Check remaining pending count
              try {
                const pendingResp = await fetch(apiUrl('/api/domain-strength/pending-count'));
                if (pendingResp.ok) {
                  const pendingData = await pendingResp.json();
                  remainingPending = pendingData.count || 0;
                  debugLog(`[Global Run] Domain Strength: ${remainingPending} domains remaining in queue`, 'info');
                } else {
                  remainingPending = 0; // Stop if API fails
                }
              } catch (e) {
                debugLog(`[Global Run] Failed to check pending count: ${e?.message || e}`, 'warn');
                remainingPending = 0; // Stop on error
              }
              
              // Small delay between batches
              if (remainingPending > 0) {
                await new Promise(resolve => setTimeout(resolve, 1000));
              }
            }
            
            if (batchCount >= maxBatches) {
              debugLog(`[Global Run] Domain Strength: Reached max batches limit (${maxBatches})`, 'warn');
            }
          } },
          { key: 'update_tasks', label: 'Update All Tasks with Latest Data', runner: async () => {
            debugLog('[Global Run] [Update All Tasks] Starting...', 'info');
            // Use unified data fetching utility (Phase 4)
            const auditData = await fetchAuditDataUnified(null, {
              minimalOnly: false,
              localStorageKey: 'last_audit_results',
              context: 'Global Run',
              updateLocalStorage: true
            });
            
            if (!auditData || !auditData.searchData) {
              debugLog('[Global Run] [Update All Tasks]  Audit data not available from Supabase or localStorage, but continuing with task update...', 'warn');
            } else {
              debugLog('[Global Run] [Update All Tasks]  Audit data loaded successfully', 'success');
            }
            
            // Ensure tasks are actually loaded before/after bulk update so the dashboard reflects real outcomes.
            if (typeof window.loadAllOptimisationTasks === 'function') {
              try { 
                await window.loadAllOptimisationTasks();
                // Wait for tasks to fully load
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Verify tasks are loaded
                if (!window.optimisationModuleState || !window.optimisationModuleState.allTasks) {
                  throw new Error('Tasks failed to load - optimisationModuleState.allTasks is empty');
                }
              } catch (err) {
                debugLog(`[Global Run] Failed to load tasks: ${err?.message || err}`, 'error');
                throw new Error(`Failed to load optimisation tasks: ${err?.message || err}`);
              }
            } else {
              throw new Error('loadAllOptimisationTasks function not available');
            }
            
            if (typeof window.bulkUpdateAllTasks === 'function') {
              try {
                debugLog('[Global Run] [Update All Tasks] Running bulk update...', 'info');
                // Pass skipConfirmation=true to bypass confirmation dialog in global run
                const bulkUpdateResult = await window.bulkUpdateAllTasks(true);
                debugLog(`[Global Run] [Update All Tasks] Bulk update completed. Result: ${JSON.stringify(bulkUpdateResult || 'undefined')}`, 'info');
                
                // Verify tasks were updated by checking if measurements were created
                if (bulkUpdateResult && typeof bulkUpdateResult === 'object') {
                  if (bulkUpdateResult.updated !== undefined) {
                    debugLog(`[Global Run] [Update All Tasks]  Verified: ${bulkUpdateResult.updated} tasks updated`, 'success');
                  }
                  if (bulkUpdateResult.errors && bulkUpdateResult.errors.length > 0) {
                    debugLog(`[Global Run] [Update All Tasks]  Warning: ${bulkUpdateResult.errors.length} errors during bulk update`, 'warn');
                  }
                }
              } catch (err) {
                debugLog(`[Global Run] [Update All Tasks]  Bulk update failed: ${err?.message || err}`, 'error');
                throw new Error(`Bulk update failed: ${err?.message || err}`);
              }
            } else {
              throw new Error('bulkUpdateAllTasks function not available');
            }
            
            // Reload tasks to reflect updates
            if (typeof window.loadAllOptimisationTasks === 'function') {
              try { 
                debugLog('[Global Run] [Update All Tasks] Reloading tasks to reflect updates...', 'info');
                await window.loadAllOptimisationTasks();
                debugLog('[Global Run] [Update All Tasks]  Tasks reloaded', 'success');
              } catch (err) {
                debugLog(`[Global Run] [Update All Tasks]  Failed to reload tasks after update: ${err?.message || err}`, 'warn');
              }
            }
          } }
        ];

        const steps = stepDefs.map(s => ({ key: s.key, label: s.label, status: 'Pending', elapsedTime: undefined, errorMessage: undefined }));
        const results = { ok: true, errors: [] };
        const overallStartTime = Date.now();
        let timeUpdateInterval = null;

        // Helper function to format elapsed time
        const formatElapsedTime = (ms) => {
          const totalSeconds = Math.floor(ms / 1000);
          const minutes = Math.floor(totalSeconds / 60);
          const seconds = totalSeconds % 60;
          return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        };

        // Update time display periodically
        const updateTimeDisplay = () => {
          const elapsed = Date.now() - overallStartTime;
          const elapsedEl = document.getElementById('dashboardRunElapsedTime');
          if (elapsedEl) elapsedEl.textContent = formatElapsedTime(elapsed);
        };

        showDashboardRunModal();
        dashboardRunModalRenderSteps(steps);
        
        // Start time update interval
        timeUpdateInterval = setInterval(updateTimeDisplay, 1000);
        updateTimeDisplay();

        // Set up close button handlers - ensure they work even after completion
        const closeBtn = document.getElementById('dashboardRunClose');
        const closeBtnBottom = document.getElementById('dashboardRunCloseBottom');
        const closeHandler = () => {
          if (timeUpdateInterval) clearInterval(timeUpdateInterval);
          const modal = document.getElementById('dashboardRunModal');
          if (modal) modal.style.display = 'none';
        };
        if (closeBtn) {
          closeBtn.onclick = closeHandler;
        }
        if (closeBtnBottom) {
          closeBtnBottom.onclick = closeHandler;
        }

        for (let i = 0; i < stepDefs.length; i++) {
          const s = stepDefs[i];
          const stepStartTime = Date.now();
          steps[i].status = 'Running';
          steps[i].elapsedTime = undefined;
          steps[i].errorMessage = undefined;
          dashboardRunModalRenderSteps(steps);
          dashboardRunModalSetProgress(Math.round((i / stepDefs.length) * 100));
          dashboardRunModalSetStep(s.label, 'Working');
          
          // Update step time display
          const updateStepTime = () => {
            const stepElapsed = Date.now() - stepStartTime;
            const stepTimeEl = document.getElementById('dashboardRunStepTime');
            if (stepTimeEl) stepTimeEl.textContent = formatElapsedTime(stepElapsed);
          };
          const stepTimeInterval = setInterval(updateStepTime, 100);
          updateStepTime();

          try {
            debugLog(`[Global Run] Starting step: ${s.label} (${s.key})`, 'info');
            const stepResult = await s.runner();
            
            // Verify save succeeded if runner returns a result
            if (stepResult !== undefined && stepResult !== null) {
              if (typeof stepResult === 'object') {
                if (stepResult.success === false) {
                  throw new Error(stepResult.error || stepResult.message || 'Step reported failure');
                }
                if (stepResult.saved !== undefined && stepResult.saved === 0 && stepResult.success !== true) {
                  debugLog(`[Global Run]  Step ${s.label} completed but may not have saved data`, 'warn');
                }
              }
            }
            
            const stepElapsed = Date.now() - stepStartTime;
            steps[i].status = 'Done';
            steps[i].elapsedTime = formatElapsedTime(stepElapsed);
            debugLog(`[Global Run]  Step completed: ${s.label} (${formatElapsedTime(stepElapsed)})`, 'success');
          } catch (err) {
            const stepElapsed = Date.now() - stepStartTime;
            steps[i].status = 'Failed';
            steps[i].elapsedTime = formatElapsedTime(stepElapsed);
            steps[i].errorMessage = err?.message || String(err);
            results.ok = false;
            results.errors.push({ step: s.key, message: err?.message || String(err) });
            debugLog(`[Global Run]  Step failed: ${s.label} - ${err?.message || String(err)} (${formatElapsedTime(stepElapsed)})`, 'error');
            
            // STOP EXECUTION ON FAILURE - user requirement
            clearInterval(stepTimeInterval);
            if (timeUpdateInterval) clearInterval(timeUpdateInterval);
            dashboardRunModalSetStep('Failed', `Step "${s.label}" failed. Process stopped.`);
            dashboardRunModalRenderSteps(steps);
            break; // Exit loop immediately
          }

          clearInterval(stepTimeInterval);
          dashboardRunModalRenderSteps(steps);
        }
        
        // Clear time update interval
        if (timeUpdateInterval) clearInterval(timeUpdateInterval);

        const totalElapsed = Date.now() - overallStartTime;
        dashboardRunModalSetProgress(100);
        const finalMessage = results.ok 
          ? `All steps completed in ${formatElapsedTime(totalElapsed)}.` 
          : `Process stopped due to errors. Total time: ${formatElapsedTime(totalElapsed)}.`;
        dashboardRunModalSetStep('Done', finalMessage);
        
        // Update final elapsed time display
        const elapsedEl = document.getElementById('dashboardRunElapsedTime');
        if (elapsedEl) elapsedEl.textContent = formatElapsedTime(totalElapsed);
        const stepTimeEl = document.getElementById('dashboardRunStepTime');
        if (stepTimeEl) stepTimeEl.textContent = '';
        
        // Final summary logging
        debugLog('[Global Run] ========================================', 'info');
        debugLog(`[Global Run] Global Audit Run ${results.ok ? 'COMPLETED' : 'FAILED'}`, results.ok ? 'success' : 'error');
        debugLog(`[Global Run] Total time: ${formatElapsedTime(totalElapsed)}`, 'info');
        debugLog(`[Global Run] Steps completed: ${steps.filter(s => s.status === 'Done').length}/${steps.length}`, 'info');
        if (results.errors.length > 0) {
          const errorMessages = results.errors.map(e => e.step + ': ' + e.message).join('; ');
          debugLog(`[Global Run] Errors: ${errorMessages}`, 'error');
        }
        debugLog('[Global Run] ========================================', 'info');

        // Refresh optimisation tasks so execution dial reflects latest measurements
        try {
          if (typeof window.loadAllOptimisationTasks === 'function') {
            await window.loadAllOptimisationTasks();
            // Small delay to ensure tasks are fully processed
            await new Promise(resolve => setTimeout(resolve, 500));
          }
        } catch (e) {
          // ignore
        }

        const snapshot = computeDashboardSnapshot();
        const runRecord = {
          timestamp: startIso,
          status: results.ok ? 'ok' : 'partial',
          steps,
          metrics: snapshot
        };
        saveDashboardRun(runRecord);

        // Wait a moment to ensure audit data is fully saved to Supabase before refreshing dashboard
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Refresh all tabs to ensure they show fresh data
        // CRITICAL: Await renderDashboardTab to ensure it fetches latest audit from Supabase
        if (typeof window.renderDashboardTab === 'function') {
          try {
            await window.renderDashboardTab();
          } catch (e) {
            debugLog(`[Global Run] Failed to refresh Dashboard tab: ${e?.message || e}`, 'warn');
          }
        }
        
        // Explicitly update audit timestamp badge after global audit completes
        // This ensures the badge shows the latest GSC and Ranking & AI audit dates
        // Wait an additional moment to ensure Supabase has fully committed the data
        await new Promise(resolve => setTimeout(resolve, 3000));
        
        if (typeof window.updateAuditTimestamp === 'function') {
          try {
            debugLog('[Global Run] Calling updateAuditTimestamp to refresh badge...', 'info');
            await window.updateAuditTimestamp();
            debugLog('[Global Run]  Updated audit timestamp badge', 'info');
          } catch (e) {
            debugLog(`[Global Run]  Failed to update audit timestamp: ${e?.message || e}`, 'error');
            console.error('[Global Run] Failed to update audit timestamp:', e);
          }
        } else {
          debugLog('[Global Run]  updateAuditTimestamp function not found', 'error');
        }
        
        // Explicitly refresh other module tabs to ensure they're updated
        if (typeof window.renderRankingAiTab === 'function') {
          try {
            window.renderRankingAiTab();
          } catch (e) {
            debugLog(`[Global Run] Failed to refresh Ranking & AI tab: ${e?.message || e}`, 'warn');
          }
        }
        
        // Money Pages tab is refreshed by dashboardRunMoneyPagesScan, but ensure it's rendered if needed
        if (typeof window.renderMoneyPagesSection === 'function' && window.currentMoneyPagesMetrics) {
          try {
            await window.renderMoneyPagesSection(window.currentMoneyPagesMetrics);
            if (typeof window.wireTopLevelFilter === 'function') window.wireTopLevelFilter();
            if (typeof window.wireMoneyKpiMetricSelector === 'function') window.wireMoneyKpiMetricSelector();
            if (typeof window.__initMoneyPagesPanelAfterRender === 'function') window.__initMoneyPagesPanelAfterRender();
          } catch (e) {
            debugLog(`[Global Run] Failed to refresh Money Pages tab: ${e?.message || e}`, 'warn');
          }
        }

        const summaryHtml = results.ok
          ? `<div>Saved a new global run snapshot.</div>`
          : `<div><strong>Saved a partial global run snapshot.</strong><div style="margin-top:0.5rem; color: var(--dark-text-muted);">Errors: ${results.errors.map(e => `${e.step}: ${e.message}`).join(' | ')}</div></div>`;

        finishDashboardRunModal({ ok: results.ok, summaryHtml });

        if (runBtn) runBtn.disabled = false;
      };

      window.dashboardRunRankingAiScan = async function dashboardRunRankingAiScan() {
        try {
          if (typeof window.loadRankingAiData !== 'function') {
            alert('Ranking & AI scan is not available on this page.');
            return;
          }
          await window.loadRankingAiData(true);
          if (typeof window.renderDashboardTab === 'function') window.renderDashboardTab();
        } catch (e) {
          alert(`Ranking & AI scan failed: ${e?.message || e}`);
        }
      };

      window.dashboardRunMoneyPagesScan = async function dashboardRunMoneyPagesScan() {
        try {
          const propertyUrl =
            (window.getPropertyUrl ? window.getPropertyUrl() : '') ||
            localStorage.getItem('gsc_property_url') ||
            localStorage.getItem('last_property_url') ||
            '';

          if (!propertyUrl) {
            alert('Property URL not set. Go to Configuration & Reporting and set it first.');
            return;
          }

          // Reuse the existing Supabase fetch helper (loads timestamp first, then full data).
          const latest = await fetchLatestAuditFromSupabase(propertyUrl, false);
          if (!latest) {
            alert('No latest audit found in Supabase for this property.');
            return;
          }

          // Store as current audit snapshot (so Dashboard cards have a timestamp baseline).
          try {
            localStorage.setItem('last_audit_results', JSON.stringify(latest));
          } catch (storageErr) {
            // Non-fatal: continue without localStorage.
          }

          const metrics = latest?.scores?.moneyPagesMetrics || latest?.moneyPagesMetrics || null;
          window.currentMoneyPagesMetrics = metrics;
          window.moneyPagesMetrics = metrics;

          // If Money Pages panel exists and renderer is available, rebuild it now.
          if (typeof window.renderMoneyPagesSection === 'function') {
            await window.renderMoneyPagesSection(metrics);
            if (typeof window.wireTopLevelFilter === 'function') window.wireTopLevelFilter();
            if (typeof window.wireMoneyKpiMetricSelector === 'function') window.wireMoneyKpiMetricSelector();
            if (typeof window.__initMoneyPagesPanelAfterRender === 'function') window.__initMoneyPagesPanelAfterRender();
          }

          if (typeof window.renderDashboardTab === 'function') window.renderDashboardTab();
        } catch (e) {
          alert(`Money Pages refresh failed: ${e?.message || e}`);
        }
      };

      window.addEventListener('DOMContentLoaded', () => {
        const btn = document.getElementById('dashboard-run-all-btn');
        if (btn) {
          btn.addEventListener('click', () => {
            if (typeof window.runDashboardGlobalRun === 'function') window.runDashboardGlobalRun();
          });
        }
        const closeBtn = document.getElementById('dashboardRunClose');
        if (closeBtn) {
          closeBtn.onclick = () => {
            const modal = document.getElementById('dashboardRunModal');
            if (modal) modal.style.display = 'none';
          };
        }
        if (typeof window.renderDashboardTab === 'function') {
          window.renderDashboardTab();
        }
      });
  </script>

  <!-- Optimisation Tracking Modals (Phase 2) -->
  <!-- Track Keyword Modal -->
  <div id="optimisation-track-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
    <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 1000px; width: 90%; max-height: 90vh; overflow-y: auto;">
      <h3 style="margin: 0 0 1.5rem 0; font-size: 1.25rem; color: #1e293b;">Track Keyword</h3>
      
      <div style="margin-bottom: 1rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Keyword:</label>
        <div id="track-keyword-text" style="padding: 0.5rem; background: #f8fafc; border-radius: 4px; color: #0284c7; font-weight: 600; font-size: 1rem;"></div>
      </div>
      
      <div style="margin-bottom: 1rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Target URL:</label>
        <div id="track-url-text" style="padding: 0.5rem; background: #f8fafc; border-radius: 4px; color: #0284c7; font-weight: 600; word-break: break-all; font-size: 0.95rem;"></div>
      </div>
      
      <div style="margin-bottom: 1rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Task type:</label>
        <select id="track-task-type" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px;">
          <option value="on_page">On-page</option>
          <option value="content">Content</option>
          <option value="internal_links">Internal links</option>
          <option value="links_pr">Links/PR</option>
          <option value="technical">Technical</option>
          <option value="local">Local</option>
          <option value="other">Other</option>
        </select>
      </div>
      
      <div style="margin-bottom: 1rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Status: <span title="Status meanings:&#10; Planned: Task created but work not started&#10; In Progress: Currently being worked on&#10; Monitoring: Changes deployedmonitor metrics" style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></label>
        <select id="track-status" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px;">
          <option value="planned" title="Task created but work not started">Planned</option>
          <option value="in_progress" title="Currently being worked on">In progress</option>
          <option value="monitoring" title="Changes deployedmonitor metrics">Monitoring</option>
        </select>
      </div>
      
      <div style="margin-bottom: 1rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Title (optional):</label>
        <input type="text" id="track-title" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px;" placeholder="e.g. Rewrite title/H1 + FAQ schema">
      </div>
      
      <div style="margin-bottom: 1.5rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Notes (optional):</label>
        <textarea id="track-notes" rows="3" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-family: inherit;" placeholder="Additional notes..."></textarea>
      </div>

      <!-- Objective Section (Cycle 1) -->
      <div style="margin-bottom: 1.5rem; padding: 1rem; background: #f8fafc; border-radius: 4px; border: 1px solid #e2e8f0;">
        <h4 style="margin: 0 0 1rem 0; font-size: 1rem; color: #1e293b; font-weight: 600;">Objective (Cycle 1)</h4>
        
        <div style="margin-bottom: 0.75rem;">
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Objective Title:</label>
          <input type="text" id="track-objective-title" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. Improve CTR by 20%">
        </div>

        <div style="margin-bottom: 0.75rem;">
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Primary KPI:</label>
          <select id="track-primary-kpi" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
            <option value="">Select KPI...</option>
            <option value="ctr_28d">CTR (28d)</option>
            <option value="rank">Rank</option>
            <option value="clicks">Clicks</option>
            <option value="impressions">Impressions</option>
            <option value="ai_citations">AI Citations</option>
          </select>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
          <div>
            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Direction:</label>
            <select id="track-target-direction" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
              <option value="">Select...</option>
              <option value="increase">Increase</option>
              <option value="decrease">Decrease</option>
              <option value="at_least">At least</option>
              <option value="at_most">At most</option>
            </select>
          </div>
          <div>
            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Value:</label>
            <input type="number" id="track-target-value" step="0.01" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. 20">
          </div>
        </div>

        <div style="margin-bottom: 0.75rem;">
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Timeframe (days):</label>
          <select id="track-timeframe-days" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
            <option value="">Select timeframe...</option>
            <option value="30">30 days</option>
            <option value="60">60 days</option>
            <option value="90">90 days</option>
          </select>
        </div>

        <div style="margin-bottom: 0.75rem;">
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Plan / Hypothesis (optional):</label>
          <textarea id="track-plan" rows="2" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-family: inherit; font-size: 0.875rem;" placeholder="Describe your plan or hypothesis..."></textarea>
        </div>
      </div>
      
      <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
        <button type="button" onclick="document.getElementById('optimisation-track-modal').style.display='none'" style="padding: 0.5rem 1rem; border: 1px solid #cbd5e1; border-radius: 4px; background: white; cursor: pointer;">Cancel</button>
        <button type="button" onclick="window.submitTrackKeyword()" style="padding: 0.5rem 1rem; border: none; border-radius: 4px; background: #2563eb; color: white; cursor: pointer; font-weight: 500;">Create</button>
      </div>
    </div>
  </div>

  <!-- Manage Optimisation Modal -->
  <div id="optimisation-manage-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
    <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto;">
      <h3 style="margin: 0 0 1.5rem 0; font-size: 1.25rem; color: #1e293b;">Manage Optimisation</h3>
      
      <div style="margin-bottom: 1rem; padding: 1rem; background: #f8fafc; border-radius: 4px;">
        <div style="margin-bottom: 0.75rem;">
          <strong style="color: #475569;">Keyword:</strong>
          <div id="manage-keyword-text" style="padding: 0.5rem; background: #f8fafc; border-radius: 4px; color: #0284c7; font-weight: 600; font-size: 1rem; margin-top: 0.25rem;"></div>
        </div>
        <div style="margin-bottom: 0.75rem;">
          <strong style="color: #475569;">Target URL:</strong>
          <div id="manage-url-text" style="padding: 0.5rem; background: #f8fafc; border-radius: 4px; margin-top: 0.25rem; word-break: break-all;"></div>
        </div>
        <div style="margin-bottom: 0.75rem;">
          <strong style="color: #475569;">Task type:</strong>
          <div id="manage-task-type-text" style="color: #1e293b; margin-top: 0.25rem;"></div>
        </div>
        <div style="margin-bottom: 0.75rem;">
          <strong style="color: #475569;">Current status:</strong>
          <div id="manage-status-text" style="color: #1e293b; margin-top: 0.25rem;"></div>
        </div>
        <div style="margin-bottom: 0.75rem;">
          <strong style="color: #475569;">Cycle:</strong>
          <div id="manage-cycle-text" style="color: #1e293b; margin-top: 0.25rem;"></div>
        </div>
        <div>
          <strong style="color: #475569;">Last activity:</strong>
          <div id="manage-last-activity-text" style="color: #1e293b; margin-top: 0.25rem;"></div>
        </div>
      </div>
      
      <div style="margin-bottom: 1.5rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Change status:</label>
        <select id="manage-status-select" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px;">
          <option value="planned">Planned</option>
          <option value="in_progress">In progress</option>
          <option value="monitoring">Monitoring</option>
          <option value="done">Done</option>
          <option value="paused">Paused</option>
          <option value="cancelled">Cancelled</option>
        </select>
      </div>
      
      <div style="display: flex; flex-direction: column; gap: 0.75rem; margin-bottom: 1.5rem;">
        <button type="button" onclick="window.submitStatusChange()" style="padding: 0.5rem 1rem; border: none; border-radius: 4px; background: #2563eb; color: white; cursor: pointer; font-weight: 500;">Save Status Change</button>
        <button type="button" onclick="window.startNewCycle()" style="padding: 0.5rem 1rem; border: 1px solid #2563eb; border-radius: 4px; background: white; color: #2563eb; cursor: pointer; font-weight: 500;">Start New Cycle</button>
        <button type="button" onclick="window.stopTracking()" style="padding: 0.5rem 1rem; border: 1px solid #ef4444; border-radius: 4px; background: white; color: #ef4444; cursor: pointer; font-weight: 500;">Stop Tracking</button>
      </div>
      
      <div style="display: flex; justify-content: flex-end;">
        <button type="button" onclick="document.getElementById('optimisation-manage-modal').style.display='none'" style="padding: 0.5rem 1rem; border: 1px solid #cbd5e1; border-radius: 4px; background: white; cursor: pointer;">Close</button>
      </div>
    </div>
  </div>

  <!-- New Cycle Modal -->
  <div id="optimisation-new-cycle-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10001; align-items: center; justify-content: center;">
    <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto;">
      <h3 style="margin: 0 0 1.5rem 0; font-size: 1.25rem; color: #1e293b;">Start New Cycle: <span id="new-cycle-cycle-no">Cycle 2</span></h3>
      
      <div style="margin-bottom: 1rem; padding: 0.75rem; background: #f0f9ff; border-radius: 4px; border: 1px solid #bae6fd;">
        <div style="font-size: 0.875rem; color: #0369a1;">
          <strong>Tip:</strong> The form is pre-filled with the previous cycle's objective. You can modify it for this new cycle.
        </div>
      </div>

      <div style="margin-bottom: 0.75rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Objective Title:</label>
        <input type="text" id="new-cycle-objective-title" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. Improve CTR by 20%">
      </div>

      <div style="margin-bottom: 0.75rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Primary KPI:</label>
        <select id="new-cycle-primary-kpi" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
          <option value="">Select KPI...</option>
          <option value="ctr_28d">CTR (28d)</option>
          <option value="rank">Rank</option>
          <option value="clicks">Clicks</option>
          <option value="impressions">Impressions</option>
          <option value="ai_citations">AI Citations</option>
        </select>
      </div>

      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
        <div>
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Direction:</label>
          <select id="new-cycle-target-direction" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
            <option value="">Select...</option>
            <option value="increase">Increase</option>
            <option value="decrease">Decrease</option>
            <option value="at_least">At least</option>
            <option value="at_most">At most</option>
          </select>
        </div>
        <div>
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Value:</label>
          <input type="number" id="new-cycle-target-value" step="0.01" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. 20">
        </div>
      </div>

      <div style="margin-bottom: 0.75rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Timeframe (days):</label>
        <select id="new-cycle-timeframe-days" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
          <option value="">Select timeframe...</option>
          <option value="30">30 days</option>
          <option value="60">60 days</option>
          <option value="90">90 days</option>
        </select>
      </div>

      <div style="margin-bottom: 1.5rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Plan / Hypothesis (optional):</label>
        <textarea id="new-cycle-plan" rows="3" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-family: inherit; font-size: 0.875rem;" placeholder="Describe your plan or hypothesis..."></textarea>
      </div>
      
      <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
        <button type="button" onclick="document.getElementById('optimisation-new-cycle-modal').style.display='none'" style="padding: 0.5rem 1rem; border: 1px solid #cbd5e1; border-radius: 4px; background: white; cursor: pointer;">Cancel</button>
        <button type="button" onclick="window.submitNewCycle()" style="padding: 0.5rem 1rem; border: none; border-radius: 4px; background: #2563eb; color: white; cursor: pointer; font-weight: 500;">Start Cycle</button>
      </div>
    </div>
  </div>

  <!-- Edit Objective Modal -->
  <div id="optimisation-edit-objective-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10001; align-items: center; justify-content: center;">
    <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto;">
      <h3 style="margin: 0 0 1.5rem 0; font-size: 1.25rem; color: #1e293b;">Edit Objective</h3>

      <div style="margin-bottom: 0.75rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Objective Title:</label>
        <input type="text" id="edit-objective-title" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. Improve CTR by 20%">
      </div>

      <div style="margin-bottom: 0.75rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Primary KPI:</label>
        <select id="edit-objective-primary-kpi" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
          <option value="">Select KPI...</option>
          <option value="ctr_28d">CTR (28d)</option>
          <option value="rank">Rank</option>
          <option value="clicks">Clicks</option>
          <option value="impressions">Impressions</option>
          <option value="ai_citations">AI Citations</option>
        </select>
      </div>

      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
        <div>
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Direction:</label>
          <select id="edit-objective-target-direction" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
            <option value="">Select...</option>
            <option value="increase">Increase</option>
            <option value="decrease">Decrease</option>
            <option value="at_least">At least</option>
            <option value="at_most">At most</option>
          </select>
        </div>
        <div>
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Value:</label>
          <input type="number" id="edit-objective-target-value" step="0.01" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. 20">
        </div>
      </div>

      <div style="margin-bottom: 0.75rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Timeframe (days):</label>
        <select id="edit-objective-timeframe-days" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
          <option value="">Select timeframe...</option>
          <option value="30">30 days</option>
          <option value="60">60 days</option>
          <option value="90">90 days</option>
        </select>
      </div>

      <div style="margin-bottom: 1.5rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Plan / Hypothesis (optional):</label>
        <textarea id="edit-objective-plan" rows="3" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-family: inherit; font-size: 0.875rem;" placeholder="Describe your plan or hypothesis..."></textarea>
      </div>
      
      <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
        <button type="button" onclick="document.getElementById('optimisation-edit-objective-modal').style.display='none'" style="padding: 0.5rem 1rem; border: 1px solid #cbd5e1; border-radius: 4px; background: white; cursor: pointer;">Cancel</button>
        <button type="button" onclick="window.submitEditObjective()" style="padding: 0.5rem 1rem; border: none; border-radius: 4px; background: #2563eb; color: white; cursor: pointer; font-weight: 500;">Save Objective</button>
      </div>
    </div>
  </div>

</body>
</html>




</html>



<!-- CACHE BUST: 2026-01-13 14:46:33 -->
C a c h e - b u s t :   2 0 2 6 - 0 1 - 1 3   1 8 : 0 5 : 3 9 
 
 
 





