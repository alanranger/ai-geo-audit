<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>GAIO (Generative AI Optimization) Audit Dashboard - Automated GAIO Performance Tracking</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script>
    // Try to load config.js if it exists (for local development)
    // Note: config.js is gitignored and won't be deployed to Vercel
    // Silently fail if config.js doesn't exist (expected on Vercel)
    try {
      // First check if file exists via fetch to avoid syntax errors
      fetch('config.js')
        .then(response => {
          if (response.ok && response.headers.get('content-type')?.includes('javascript')) {
      const configScript = document.createElement('script');
      configScript.src = 'config.js';
            configScript.type = 'text/javascript';
      configScript.onerror = function() {
              // Silently ignore
      };
      document.head.appendChild(configScript);
          }
        })
        .catch(() => {
          // Silently ignore - config.js is optional
        });
    } catch (e) {
      // Silently ignore - config.js is optional
    }
  </script>
  <style>
    :root {
      --brand-orange: #E57200;
      --brand-dark: #222222;
      --brand-grey: #555555;
      --bg-page: #f2f2f2;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg-page);
      color: var(--brand-dark);
      line-height: 1.5;
    }
    .header {
      background: linear-gradient(135deg, var(--brand-orange) 0%, #ff8c42 100%);
      color: white;
      padding: 2rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .header h1 {
      margin: 0 0 0.5rem 0;
      font-size: 2rem;
    }
    .header p {
      margin: 0;
      opacity: 0.9;
    }
    .container {
      max-width: 1800px;
      margin: 0 auto;
      padding: 2rem;
      padding-bottom: 60px; /* Space for debug panel */
    }
    .config-panel {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      margin-bottom: 2rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .config-panel h2 {
      margin: 0 0 1rem 0;
      color: var(--brand-dark);
      font-size: 1.25rem;
    }
    .form-group {
      margin-bottom: 1rem;
    }
    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      color: var(--brand-grey);
    }
    .form-group input {
      width: 100%;
      padding: 0.75rem;
      border: 2px solid #e2e8f0;
      border-radius: 6px;
      font-size: 1rem;
    }
    .form-group input:focus {
      outline: none;
      border-color: var(--brand-orange);
    }
    .btn {
      background: var(--brand-orange);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    .btn:hover {
      background: #d46200;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    .btn-secondary {
      background: var(--brand-grey);
    }
    .btn-secondary:hover {
      background: #444;
    }
    .status {
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      display: none;
    }
    .status.success {
      background: #d1fae5;
      color: #065f46;
      border-left: 4px solid var(--success);
    }
    .status.error {
      background: #fee2e2;
      color: #991b1b;
      border-left: 4px solid var(--danger);
    }
    .status.info {
      background: #dbeafe;
      color: #1e40af;
      border-left: 4px solid #3b82f6;
    }
    .status.show {
      display: block;
    }
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    .pillar-card {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: relative;
      display: flex;
      flex-direction: column;
      min-height: 100%; /* Ensure all cards have same minimum height */
    }
    .pillar-card h3 {
      margin: 0 0 0.75rem 0;
      color: var(--brand-dark);
      font-size: 1.1rem;
    }
    .pillar-score {
      font-size: 3rem;
      font-weight: 700;
      margin: 0.5rem 0;
      line-height: 1;
    }
    .pillar-score.rag-red {
      color: var(--danger);
    }
    .pillar-score.rag-amber {
      color: var(--warning);
    }
    .pillar-score.rag-green {
      color: var(--success);
    }
    .rag-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.875rem;
      font-weight: 600;
      margin-top: 0.75rem;
      margin-bottom: 0.5rem;
    }
    .rag-badge.red {
      background: #fee2e2;
      color: #991b1b;
    }
    .rag-badge.amber {
      background: #fef3c7;
      color: #92400e;
    }
    .rag-badge.green {
      background: #d1fae5;
      color: #065f46;
    }
    .chart-container {
      background: linear-gradient(135deg, #f0f4f8 0%, #e2e8f0 100%);
      padding: 1.5rem;
      padding-bottom: 12rem; /* Extra padding at bottom for rotated 45-degree axis labels - need significant space for diagonal labels */
      padding-right: 3rem; /* Extra padding on right for Y-axis labels */
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 6rem; /* extra breathing room below charts */
      height: 1000px; /* Doubled from 500px to 1000px for better chart visibility and less bunching */
      min-height: 1000px; /* Ensure minimum height */
      border: 1px solid rgba(100, 116, 139, 0.2);
      overflow: hidden; /* Change to hidden to clip content that extends beyond container */
    }
    .chart-container.large {
      height: 1200px;
      min-height: 1200px;
      padding: 2rem;
    }
    .dashboard-two-column {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-three-column {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-four-column {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    @media (max-width: 1200px) {
      .dashboard-four-column {
        grid-template-columns: repeat(2, 1fr);
      }
      .dashboard-three-column {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    @media (max-width: 768px) {
      .dashboard-two-column,
      .dashboard-three-column,
      .dashboard-four-column {
        grid-template-columns: 1fr;
      }
    }
    .chart-container h3 {
      margin: 0 0 0.5rem 0;
      color: var(--brand-dark);
    }
    .chart-container p {
      margin: 0 0 1rem 0;
    }
    .trend-summary-row {
      display: flex;
      gap: 1.5rem;
      font-size: 0.9rem;
      margin-bottom: 0.75rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .trend-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.7);
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.06);
      border: 1px solid rgba(148, 163, 184, 0.3);
    }
    .trend-pill span.label {
      font-weight: 600;
      color: #374151;
    }
    .trend-pill span.value.up {
      font-weight: 700;
      color: #10b981; /* green */
    }
    .trend-pill span.value.down {
      font-weight: 700;
      color: #ef4444; /* red */
    }
    .trend-pill span.value.neutral {
      font-weight: 700;
      color: #1f2937; /* black/dark gray for no change */
    }
    .metrics-section {
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border: 1px solid rgba(59, 130, 246, 0.1);
    }
    .scorecard-section {
      margin-top: 4rem;  /* push scorecard further below charts */
      margin-bottom: 3rem;
    }
    
    /* Override for scorecard sections inside ranking-ai-detail-content */
    .ranking-ai-detail-content .scorecard-section {
      margin-top: 0;
      margin-bottom: 1.0rem !important;
    }
    
    .ranking-ai-detail-content .scorecard-section:last-child {
      margin-bottom: 0 !important;
    }
    .scorecard-section h3 {
      margin-bottom: 1.5rem;
    }
    .metrics-section {
      margin-top: 3rem;
      margin-bottom: 3rem;
    }
    .metrics-section h3 {
      margin-bottom: 1.5rem;
    }
    .section-break {
      margin-top: 4rem;
      margin-bottom: 4rem;
      border-top: 2px solid #e2e8f0;
      padding-top: 2rem;
    }
    .calculation-explanation {
      background: #f8f9fa;
      border: 2px solid var(--brand-orange);
      border-radius: 8px;
      margin-bottom: 2rem;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(229, 114, 0, 0.15);
    }
    .calculation-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: linear-gradient(135deg, #fff5f0 0%, #ffe8d6 100%);
      border-bottom: 2px solid var(--brand-orange);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    .calculation-explanation.collapsed .calculation-header {
      border-bottom: none;
    }
    .calculation-header:hover {
      background: linear-gradient(135deg, #ffe8d6 0%, #ffd9b3 100%);
    }
    .calculation-header h4 {
      margin: 0;
      color: var(--brand-orange);
      font-size: 1.1rem;
      font-weight: 600;
    }
    .calculation-toggle {
      font-size: 1.2rem;
      color: var(--brand-orange);
      font-weight: bold;
      transition: transform 0.3s;
    }
    .calculation-explanation.collapsed .calculation-toggle {
      transform: rotate(-90deg);
    }
    .calculation-content {
      padding: 1.5rem;
      color: #555;
      line-height: 1.8;
    }
    .calculation-content.collapsed {
      display: none;
    }
    .csv-upload-section {
      background: #f8f9fa;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      margin-bottom: 1rem;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .csv-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: #f8f9fa;
      border-bottom: 2px solid #e2e8f0;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    .csv-upload-section.collapsed .csv-section-header {
      border-bottom: none;
    }
    .csv-section-header:hover {
      background: #f0f0f0;
    }
    .csv-section-header h3 {
      margin: 0;
      color: #1e293b;
      font-size: 1rem;
      font-weight: 600;
    }
    .csv-section-toggle {
      font-size: 1rem;
      color: #64748b;
      font-weight: bold;
      transition: transform 0.3s;
    }
    .csv-upload-section.collapsed .csv-section-toggle {
      transform: rotate(-90deg);
    }
    .csv-section-content {
      padding: 1rem;
    }
    .csv-section-content.collapsed {
      display: none;
    }
    .calculation-content h5 {
      color: var(--brand-dark);
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-size: 1rem;
      font-weight: 600;
      border-bottom: 2px solid var(--brand-orange);
      padding-bottom: 0.5rem;
    }
    .calculation-content h5:first-child {
      margin-top: 0;
    }
    .calculation-content ul {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
    }
    .calculation-content li {
      margin: 0.5rem 0;
    }
    .calculation-content code {
      background: #e2e8f0;
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #c53030;
    }
    .calculation-content .formula {
      background: #f0f4f8;
      padding: 0.75rem;
      border-left: 3px solid var(--brand-orange);
      margin: 0.75rem 0;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
    }
    .calculation-content .note {
      background: #fff3cd;
      border-left: 3px solid #f59e0b;
      padding: 0.75rem;
      margin: 1rem 0;
      font-size: 0.9rem;
    }
    .date-range-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .date-range-btn {
      padding: 0.5rem 1rem;
      border: 2px solid #e2e8f0;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    .date-range-btn:hover {
      border-color: var(--brand-orange);
      background: #fff5f0;
    }
    .date-range-btn.active {
      background: var(--brand-orange);
      color: white;
      border-color: var(--brand-orange);
    }
    .snippet-readiness-gauge {
      background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 3rem;
      border: 1px solid rgba(16, 185, 129, 0.1);
    }
    .gauge-container {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      flex: 1;
      position: relative;
    }
    .gauge-wrapper {
      position: relative;
      width: 300px;
      height: 300px;
    }
    .gauge-svg {
      transform: rotate(-90deg);
      width: 100%;
      height: 100%;
    }
    .gauge-background {
      fill: none;
      stroke: #e2e8f0;
      stroke-width: 20;
    }
    .gauge-fill {
      fill: none;
      stroke-width: 20;
      stroke-linecap: round;
      transition: stroke-dashoffset 1s ease-in-out;
    }
    .gauge-fill.green {
      stroke: #10b981;
    }
    .gauge-fill.amber {
      stroke: #f59e0b;
    }
    .gauge-fill.red {
      stroke: #ef4444;
    }
    .gauge-value {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      font-weight: 700;
      text-align: center;
      z-index: 10;
    }
    .gauge-value.green {
      color: #10b981;
    }
    .gauge-value.amber {
      color: #f59e0b;
    }
    .gauge-value.red {
      color: #ef4444;
    }
    .gauge-label {
      text-align: center;
      color: var(--brand-grey);
      margin-top: 1rem;
      font-size: 1rem;
      font-weight: 600;
    }
    .gauge-status {
      text-align: center;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      font-weight: 500;
    }
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }
    .metric-card {
      background: white;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
    }
    .metric-card .value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--brand-orange);
      margin: 0.5rem 0;
    }
    .metric-card .label {
      color: var(--brand-grey);
      font-size: 0.875rem;
    }
    .metric-label {
      color: var(--brand-grey);
      font-size: 0.875rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    .metric-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--brand-orange);
      margin: 0.5rem 0;
    }
    .metric-sub {
      color: var(--brand-grey);
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }
    .url-cell {
      max-width: 300px;
    }
    .url-main {
      font-weight: 600;
      color: #333;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .url-sub {
      font-size: 0.75rem;
      color: #666;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-top: 0.25rem;
    }
    .money-recommendation {
      font-size: 0.875rem;
      line-height: 1.5;
      color: #555;
      max-width: 400px;
    }
    .loading {
      display: none;
      text-align: center;
      padding: 2rem;
    }
    .loading.show {
      display: block;
    }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--brand-orange);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .progress-container {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1rem 0;
    }
    .progress-bar-wrapper {
      width: 100%;
      background: #e2e8f0;
      border-radius: 10px;
      height: 24px;
      overflow: hidden;
      margin: 1rem 0;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--brand-orange), #ff8c42);
      border-radius: 10px;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 0.85rem;
      min-width: 0;
    }
    .progress-status {
      font-size: 0.95rem;
      color: #555;
      margin-top: 0.5rem;
      font-weight: 500;
    }
    /* Full-page overlay for domain strength snapshot */
    .domain-strength-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      z-index: 9999;
      display: none;
      align-items: center;
      justify-content: center;
    }
    .domain-strength-overlay.show {
      display: flex;
    }
    .domain-strength-overlay-content {
      background: white;
      border-radius: 12px;
      padding: 2.5rem 3rem;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      text-align: center;
      max-width: 400px;
    }
    .domain-strength-overlay-content .spinner {
      width: 48px;
      height: 48px;
      border-width: 5px;
      margin: 0 auto 1.5rem;
    }
    .domain-strength-overlay-content h3 {
      margin: 0 0 0.75rem 0;
      font-size: 1.25rem;
      font-weight: 700;
      color: #1e293b;
    }
    .domain-strength-overlay-content p {
      margin: 0;
      font-size: 0.95rem;
      color: #64748b;
      line-height: 1.6;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      overflow: auto;
    }
    .modal-content {
      background-color: white;
      margin: 5% auto;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      animation: modalSlideIn 0.3s ease;
    }
    @keyframes modalSlideIn {
      from {
        transform: translateY(-50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    .ranking-ai-step-item {
      display: flex;
      align-items: center;
      padding: 0.75rem;
      border-radius: 6px;
      background-color: #f9fafb;
      transition: all 0.2s ease;
    }
    .ranking-ai-step-item.active {
      background-color: #fef3c7;
      border-left: 4px solid var(--brand-orange);
    }
    .ranking-ai-step-item.completed {
      background-color: #d1fae5;
      border-left: 4px solid #10b981;
    }
    .ranking-ai-step-item.pending {
      opacity: 0.5;
    }
    .ranking-ai-step-icon {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 0.75rem;
      font-weight: bold;
      font-size: 0.85rem;
    }
    .ranking-ai-step-item.pending .ranking-ai-step-icon {
      background-color: #e5e7eb;
      color: #9ca3af;
    }
    .ranking-ai-step-item.active .ranking-ai-step-icon {
      background-color: var(--brand-orange);
      color: white;
      animation: pulse 1.5s ease-in-out infinite;
    }
    .ranking-ai-step-item.completed .ranking-ai-step-icon {
      background-color: #10b981;
      color: white;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    .ranking-ai-step-label {
      flex: 1;
      font-size: 0.9rem;
      color: #374151;
    }
    .ranking-ai-step-item.completed .ranking-ai-step-label {
      color: #059669;
    }
    .ranking-ai-step-item.active .ranking-ai-step-label {
      color: #92400e;
      font-weight: 600;
    }
    .help-text {
      font-size: 0.875rem;
      color: var(--brand-grey);
      margin-top: 0.25rem;
    }

    .debug-panel-bottom {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1a1a1a;
      border-top: 3px solid #E57200;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      z-index: 1000;
      box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.5);
      max-height: 50vh;
      display: flex;
      flex-direction: column;
    }

    .debug-panel-bottom.collapsed {
      max-height: 50px;
    }

    .debug-panel-bottom.collapsed .debug-content {
      display: none !important;
    }

    .debug-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #333;
      background: #252525;
      user-select: none;
    }

    .debug-header h3 {
      margin: 0;
      color: #fff;
      font-size: 1rem;
    }

    .debug-actions {
      display: flex;
      gap: 0.5rem;
    }

    .btn-small {
      padding: 0.25rem 0.75rem;
      font-size: 0.75rem;
      background: #333;
      color: #fff;
      border: 1px solid #555;
    }

    .btn-small:hover {
      background: #444;
    }

    .debug-content {
      color: #fff;
      line-height: 1.6;
      padding: 1rem;
      overflow-y: auto;
      flex: 1;
      max-height: calc(50vh - 60px);
    }

    .debug-log-entry {
      margin-bottom: 0.25rem;
      padding: 0.25rem 0;
      border-left: 2px solid transparent;
      padding-left: 0.5rem;
    }

    .debug-log-entry.error {
      color: #f44;
      border-left-color: #f44;
    }

    .debug-log-entry.warn {
      color: #fa4;
      border-left-color: #fa4;
    }

    .debug-log-entry.info {
      color: #9cf;
      border-left-color: #4af;
    }

    .debug-log-entry.success {
      color: #9f9;
      border-left-color: #4f4;
    }

    .debug-timestamp {
      color: #aaa;
      margin-right: 0.5rem;
    }

    /* Sidebar Layout */
    .aigeo-layout {
      display: flex;
      min-height: calc(100vh - 120px); /* Account for header */
    }

    .aigeo-sidebar {
      width: 260px;
      background: linear-gradient(180deg, #ffffff 0%, #f8f9fa 100%);
      border-right: 2px solid #e2e8f0;
      padding: 1.5rem 0;
      position: sticky;
      top: 0;
      height: calc(100vh - 120px);
      overflow-y: auto;
      flex-shrink: 0;
      box-shadow: 2px 0 8px rgba(0,0,0,0.05);
    }

    .aigeo-nav-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      width: 100%;
      padding: 0.875rem 1.5rem;
      background: none;
      border: none;
      text-align: left;
      font-size: 0.95rem;
      font-weight: 500;
      color: #64748b;
      cursor: pointer;
      transition: all 0.2s ease;
      border-left: 4px solid transparent;
      position: relative;
    }

    .aigeo-nav-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0;
      background: var(--brand-orange);
      transition: width 0.2s ease;
    }

    .aigeo-nav-item:hover {
      background: linear-gradient(90deg, #fff5f0 0%, #ffffff 100%);
      color: var(--brand-dark);
      padding-left: 1.75rem;
    }

    .aigeo-nav-item.is-active {
      background: linear-gradient(90deg, #fff5f0 0%, #ffffff 100%);
      color: var(--brand-orange);
      border-left-color: var(--brand-orange);
      font-weight: 600;
      box-shadow: inset 0 0 0 1px rgba(229, 114, 0, 0.1);
    }

    .aigeo-nav-item.is-active::before {
      width: 4px;
    }

    .aigeo-nav-icon {
      font-size: 1.25rem;
      width: 24px;
      text-align: center;
      flex-shrink: 0;
    }

    .aigeo-main {
      flex: 1;
      overflow-y: auto;
      padding: 2rem;
      padding-bottom: 60px; /* Space for debug panel */
    }

    .aigeo-panel {
      display: none;
    }

    .aigeo-panel.is-active {
      display: block;
    }

    /* Ensure ranking panel uses block layout when active, not flex */
    .aigeo-panel[data-panel="ranking"].is-active {
      display: block !important;
    }

    /* Ensure ranking panel children stack vertically, but allow metric pills, side-by-side cards, and details grid to use their layouts */
    .aigeo-panel[data-panel="ranking"] > .ranking-metric-pills {
      display: grid !important;
    }

    .aigeo-panel[data-panel="ranking"] > .ranking-details-grid {
      display: grid !important;
    }

    .aigeo-panel[data-panel="ranking"] > .ranking-cards-side-by-side {
      display: flex !important;
    }

    .aigeo-panel[data-panel="ranking"] > *:not(.ranking-metric-pills):not(.ranking-cards-side-by-side):not(.ranking-priority-matrix-section):not(.ranking-table-section):not(.ranking-details-grid) {
      width: 100% !important;
      display: block !important;
      clear: both !important;
      float: none !important;
    }

    /* Ranking & AI Tab Styles */
    .ranking-pillars-note {
      font-size: 0.9rem;
      color: #64748b;
      margin: 0.75rem 0;
      line-height: 1.6;
    }

    .ranking-intro {
      margin-top: 0.25rem;
      font-size: 1rem;
      color: #4b5563;
      max-width: 56rem;
    }

    .ranking-intro-bullets {
      margin: 0.25rem 0 0.5rem;
      padding-left: 1.25rem;
      font-size: 0.95rem;
      color: #6b7280;
    }

    .ranking-intro-bullets li {
      margin-bottom: 0.1rem;
    }

    .ranking-header-actions {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-top: 0.4rem;
    }

    /* Section B: Metric pills - all 5 on one row */
    .ranking-metric-pills {
      display: grid !important;
      grid-template-columns: repeat(5, 1fr) !important;
      gap: 1rem;
      margin-top: 1rem;
      margin-bottom: 1.5rem;
      width: 100%;
      grid-auto-flow: row;
    }

    .ranking-metric-pills > .metric-pill {
      display: block;
      width: 100%;
      min-width: 0;
    }

    /* For medium screens, reduce gap but keep all 5 in one row */
    @media (min-width: 769px) and (max-width: 1400px) {
      .ranking-metric-pills {
        grid-template-columns: repeat(5, 1fr);
        gap: 0.75rem;
      }
    }

    /* Only wrap on very small screens */
    @media (max-width: 768px) {
      .ranking-metric-pills {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    .metric-pill {
      background: #ffffff;
      border-radius: 8px;
      padding: 1rem 1.25rem;
      box-shadow: 0 1px 3px rgba(15, 23, 42, 0.06);
      border-left: 4px solid transparent;
    }

    .metric-pill--green {
      background: #f0fdf4;
      border-left-color: #16a34a;
    }

    .metric-pill--amber {
      background: #fffbeb;
      border-left-color: #f59e0b;
    }

    .metric-pill--red {
      background: #fef2f2;
      border-left-color: #dc2626;
    }

    .metric-pill--neutral {
      background: #f9fafb;
      border-left-color: #6b7280;
    }

    .metric-pill-value {
      font-size: 2rem;
      font-weight: 700;
      margin: 0.25rem 0;
      color: #1e293b;
    }

    .metric-pill-label {
      font-size: 1rem;
      font-weight: 600;
      color: #374151;
      margin-bottom: 0.25rem;
    }

    .metric-pill-status {
      font-size: 0.85rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.7rem;
      border-radius: 999px;
      margin: 0.25rem 0;
    }

    .metric-pill--green .metric-pill-status {
      background: #dcfce7;
      color: #166534;
    }

    .metric-pill--amber .metric-pill-status {
      background: #fef3c7;
      color: #92400e;
    }

    .metric-pill--red .metric-pill-status {
      background: #fee2e2;
      color: #b91c1c;
    }

    .metric-pill--neutral .metric-pill-status {
      background: #e5e7eb;
      color: #4b5563;
    }

    .metric-pill-footer {
      font-size: 0.85rem;
      color: #6b7280;
      margin-top: 0.5rem;
      line-height: 1.4;
    }

    .metric-pill-toggle {
      font-size: 0.85rem;
      color: #0284c7;
      cursor: pointer;
      margin-top: 0.5rem;
      text-decoration: underline;
      user-select: none;
    }

    .metric-pill-toggle:hover {
      color: #0369a1;
    }

    .metric-pill-details {
      display: none;
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid #e5e7eb;
    }

    .metric-pill-details.expanded {
      display: block;
    }

    /* ============================================
       AI Sources & Influence tab: layout styling
       ============================================ */
    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer {
      background: #fffbeb;
      border-left: 4px solid #f59e0b;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer .card-header {
      padding: 1.25rem 1.5rem 0.75rem 1.5rem;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer .card-header h3 {
      color: #92400e;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer .card-body {
      padding: 1.25rem 1.5rem;
      color: #78350f;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer ul {
      padding-left: 1.5rem;
      margin: 0.25rem 0;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-domain-table-card {
      background: rgba(204, 255, 255, 0.15);
      border-left: 4px solid #CCFFFF;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-domain-table-card .card-header {
      background: transparent;
    }

    /* AI sources table: alignment + hover highlight */
    #ai-sources-table th:nth-child(1),
    #ai-sources-table td:nth-child(1),
    #ai-sources-table th:nth-child(2),
    #ai-sources-table td:nth-child(2),
    #ai-sources-table th:nth-child(6),
    #ai-sources-table td:nth-child(6) {
      text-align: left !important;
    }

    #ai-sources-table th:nth-child(3),
    #ai-sources-table td:nth-child(3),
    #ai-sources-table th:nth-child(4),
    #ai-sources-table td:nth-child(4),
    #ai-sources-table th:nth-child(5),
    #ai-sources-table td:nth-child(5) {
      text-align: right !important;
    }

    #ai-sources-table tbody tr:hover td {
      background: #eff6ff !important;
    }

    /* Tile details styling */
    .tile-details-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: #374151;
      margin: 0 0 0.75rem 0;
      line-height: 1.5;
    }

    .tile-details-list {
      list-style: none;
      padding: 0;
      margin: 0 0 0.75rem 0;
    }

    .tile-details-list li {
      font-size: 0.875rem;
      color: #4b5563;
      line-height: 1.8;
      margin-bottom: 0.5rem;
    }

    .tile-details-list li strong {
      color: #1f2937;
      font-weight: 600;
    }

    .tile-details-footnote {
      font-size: 0.8rem;
      color: #6b7280;
      margin: 0.75rem 0 0 0;
      font-style: italic;
      line-height: 1.5;
    }

    /* Insights card styling */
    /* Side-by-side container for insights and visibility cards - 50% each */
    .ranking-cards-side-by-side {
      display: flex !important;
      flex-direction: row !important;
      gap: 1.5rem;
      margin: 1.5rem 0;
      align-items: flex-start;
      flex-wrap: wrap !important;
      width: 100%;
      overflow: visible;
    }

    .ranking-cards-side-by-side > *:first-child,
    .ranking-cards-side-by-side > *:nth-child(2) {
      flex: 0 0 calc(50% - 0.75rem) !important;
      min-width: 0;
      max-width: calc(50% - 0.75rem) !important;
      width: calc(50% - 0.75rem) !important;
      display: block !important;
    }

    /* Force all other children to be full width and on new rows */
    .ranking-cards-side-by-side > *:nth-child(n+3) {
      flex: 0 0 100% !important;
      width: 100% !important;
      max-width: 100% !important;
      clear: both !important;
      display: block !important;
      margin-top: 1.5rem;
    }

    .ranking-visibility-metrics-section {
      display: block !important;
    }

    /* Ensure sections after side-by-side cards are full width and stacked on new row */
    .ranking-cards-side-by-side ~ .ranking-priority-matrix-section,
    .ranking-cards-side-by-side ~ .ranking-table-section {
      width: 100% !important;
      display: block !important;
      clear: both !important;
      flex: none !important;
      margin-left: 0 !important;
      margin-right: 0 !important;
      float: none !important;
      position: relative !important;
    }

    @media (max-width: 1024px) {
      .ranking-cards-side-by-side {
        flex-direction: column;
      }
    }

    .card--insights {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin: 0;
      padding: 1.25rem 1.5rem;
    }

    .card--insights h2 {
      font-weight: 600;
      color: #92400e;
      margin: 0 0 0.5rem 0;
      font-size: 0.95rem;
    }

    .card--insights .card-subtitle {
      font-weight: 400;
      color: #78350f;
      margin: 0 0 1rem 0;
      font-size: 0.8rem;
      line-height: 1.5;
    }

    .card-pill-container {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .card-pill {
      background: #fffbeb;
      border: 1px solid #fde68a;
      border-radius: 6px;
      padding: 0.875rem;
      margin-bottom: 0.75rem;
    }

    .card-pill p {
      margin: 0;
      font-size: 0.8rem;
      line-height: 1.5;
      color: #78350f;
    }

    .card-pill strong {
      color: #92400e;
      font-weight: 600;
    }

    /* Visibility metrics card styling */
    .ranking-visibility-metrics-section .card {
      padding: 1.25rem 1.5rem;
    }

    .ranking-visibility-metrics-section h4 {
      font-size: 0.95rem !important;
      font-weight: 600 !important;
      margin-bottom: 0.5rem !important;
    }

    .ranking-visibility-metrics-section p,
    .ranking-visibility-metrics-section ul,
    .ranking-visibility-metrics-section li {
      font-size: 0.8rem !important;
    }

    .ranking-visibility-metrics-section strong {
      font-weight: 600 !important;
    }

    /* Section C: Filters */
    .ranking-filters-section {
      margin-bottom: 1rem;
      background: rgba(204, 255, 255, 0.15) !important;
      border-left: 4px solid #CCFFFF !important;
      border-radius: 8px;
      padding: 1rem 1.25rem;
      font-size: 0.75rem !important;
    }

    .ranking-filter-bar {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 0.75rem 1rem;
      align-items: end;
      padding: 0;
      background: transparent;
    }

    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 0.375rem;
      min-width: 0;
    }

    .filter-group label {
      font-size: 0.65rem !important;
      font-weight: 600;
      color: #374151;
      white-space: nowrap;
      margin: 0;
      line-height: 1.2;
    }

    .filter-control {
      padding: 0.35rem 0.55rem;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.85rem !important;
      background: #ffffff;
      width: 100%;
      min-width: 110px;
      transition: all 0.2s ease;
    }
    
    .filter-control option {
      font-size: 0.85rem;
    }

    /* Active filter state - when value is not "all" */
    .filter-control.filter-active {
      background: #eff6ff !important;
      border-color: #3b82f6 !important;
      color: #1e40af !important;
      font-weight: 600;
    }

    .filter-control:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.15);
    }

    #ranking-filter-keyword {
      min-width: 300px;
    }

    /* Search filter group should be wider */
    .filter-group-search {
      grid-column: span 2;
      min-width: 300px;
    }

    /* Clear filters button */
    #ranking-filter-clear {
      font-size: 0.7rem !important;
      padding: 0.4rem 0.75rem;
      align-self: end;
    }

    /* Keyword Priority Matrix section - full width, stacked layout */
    .ranking-priority-matrix-section {
      width: 100% !important;
      clear: both !important;
      display: block !important;
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
      flex: none !important;
      flex-basis: 100% !important;
      max-width: 100% !important;
      float: none !important;
      position: relative !important;
      box-sizing: border-box !important;
      order: 999 !important;
    }

    /* Section C: Table section - separate card */
    .ranking-table-section {
      margin: 2rem 0;
      width: 100% !important;
      clear: both !important;
      display: block !important;
      flex: none !important;
      max-width: 100% !important;
      float: none !important;
      position: relative !important;
      box-sizing: border-box !important;
      background: rgba(204, 255, 255, 0.2) !important;
      border-left: 4px solid #CCFFFF !important;
      border-radius: 8px;
      padding: 1.5rem;
      font-size: 14pt !important;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .ranking-table-section .card {
      background: transparent;
      box-shadow: none;
      padding: 0;
    }
    
    /* Apply 14pt to section elements but exclude table */
    .ranking-table-section .card-header,
    .ranking-table-section .card-subtitle,
    .ranking-table-section .filter-group,
    .ranking-table-section .filter-control,
    .ranking-table-section .btn {
      font-size: 14pt !important;
    }
    
    /* Table font size - must come after to override any universal selectors */
    .ranking-table-section .ranking-table,
    .ranking-table-section .ranking-table th,
    .ranking-table-section .ranking-table td,
    .ranking-table-section .ranking-table-wrapper .ranking-table,
    .ranking-table-section .ranking-table-wrapper .ranking-table th,
    .ranking-table-section .ranking-table-wrapper .ranking-table td {
      font-size: 0.875rem !important;
    }
    
    /* Pagination controls */
    .ranking-pagination-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #e5e7eb;
      flex-wrap: wrap;
      gap: 1rem;
    }
    
    .ranking-pagination-info {
      font-size: 14pt !important;
      color: #374151;
    }
    
    .ranking-pagination-buttons {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    
    .ranking-pagination-buttons button {
      padding: 0.5rem 1rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      background: #ffffff;
      font-size: 14pt !important;
      cursor: pointer;
      color: #374151;
    }
    
    .ranking-pagination-buttons button:hover:not(:disabled) {
      background: #f3f4f6;
      border-color: #9ca3af;
    }
    
    .ranking-pagination-buttons button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .ranking-rows-per-page {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .ranking-rows-per-page label {
      font-size: 14pt !important;
      color: #374151;
      white-space: nowrap;
    }
    
    .ranking-rows-per-page select {
      padding: 0.5rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 14pt !important;
      background: #ffffff;
    }

    /* Section D: Details grid - three columns (33% each) */
    .ranking-details-grid {
      display: grid !important;
      grid-template-columns: repeat(3, 1fr) !important;
      gap: 1rem;
      margin-top: 2rem;
      background: rgba(204, 255, 255, 0.15) !important;
      border-left: 4px solid #CCFFFF !important;
      border-radius: 8px;
      padding: 1.5rem;
    }
    
    .ranking-details-grid .card {
      min-width: 0;
      overflow: hidden;
    }
    
    .ranking-details-grid table {
      width: 100%;
      table-layout: fixed;
      font-size: 0.8rem;
    }
    
    .ranking-details-grid table th,
    .ranking-details-grid table td {
      padding: 0.5rem 0.4rem;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    .ranking-details-grid table th:first-child,
    .ranking-details-grid table td:first-child {
      width: 35%;
      max-width: 35%;
    }
    
    .ranking-details-grid table th:nth-child(2),
    .ranking-details-grid table td:nth-child(2) {
      width: 15%;
      max-width: 15%;
    }
    
    .ranking-details-grid table th:nth-child(3),
    .ranking-details-grid table td:nth-child(3) {
      width: 20%;
      max-width: 20%;
    }
    
    .ranking-details-grid table th:nth-child(4),
    .ranking-details-grid table td:nth-child(4) {
      width: 20%;
      max-width: 20%;
    }
    
    .ranking-details-grid table th:nth-child(5),
    .ranking-details-grid table td:nth-child(5) {
      width: 10%;
      max-width: 10%;
    }

    .ranking-details-grid .card {
      background: #ffffff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 0;
      margin-bottom: 0.75rem;
      border-radius: 6px;
      border: 1px solid #e5e7eb;
    }

    .ranking-details-grid .card:last-child {
      margin-bottom: 0;
    }

    /* Card header and body padding for consistent spacing */
    .ranking-details-grid .card-header {
      padding: 1.25rem 1.25rem 0.75rem 1.25rem;
    }

    .ranking-details-grid .card-body,
    .ranking-details-grid .ranking-ai-detail-body {
      padding: 0 1.25rem 1.25rem 1.25rem;
      font-size: 0.95rem;
      font-weight: 400;
      color: #1e293b;
      line-height: 1.6;
    }

    /* Typography hierarchy for cards */
    .ranking-details-grid .card-header h3 {
      font-size: 1.25rem;
      font-weight: 700;
      color: #1e293b;
      margin: 0 0 0.5rem 0;
      line-height: 1.4;
    }

    .ranking-details-grid .card-header h2 {
      font-size: 1.1rem;
      font-weight: 600;
      color: #374151;
      margin: 0 0 0.5rem 0;
      line-height: 1.4;
    }

    .ranking-details-grid .card-header p,
    .ranking-details-grid .card-subtitle {
      font-size: 0.9rem;
      font-weight: 400;
      color: #64748b;
      line-height: 1.5;
      margin: 0;
    }

    .ranking-details-grid .card-header h5 {
      font-size: 1rem;
      font-weight: 600;
      color: #374151;
      margin: 1rem 0 0.5rem 0;
    }

    /* List padding to match card body */
    .ranking-details-grid .ranking-ai-detail-list {
      padding: 0 1.25rem 1.25rem 1.25rem;
      margin: 0;
    }

    @media (max-width: 1200px) {
      .ranking-details-grid {
        grid-template-columns: 1fr;
      }
    }


    .ranking-table-wrapper {
      max-height: 540px;
      overflow: auto;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
    }

    .ranking-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.875rem !important;
    }

    /* Table header styling */
    .ranking-table th {
      text-align: center !important;
      vertical-align: middle;
      position: relative;
    }

    .ranking-table th > div:first-child {
      font-weight: 700 !important;
      text-align: center;
      margin-bottom: 0.25rem;
    }

    .ranking-table th > div:last-child {
      text-align: center !important;
      color: #2563eb !important;
      opacity: 1 !important;
    }

    .ranking-table th .sort-indicator {
      color: #1e40af !important;
      font-weight: 700 !important;
      margin-left: 0.25rem;
      opacity: 1 !important;
    }

    .ranking-table th.sortable {
      cursor: pointer;
    }

    .ranking-table th.sortable:hover {
      background-color: #f3f4f6;
    }

    /* Dynamic column widths - adjust based on content */
    .ranking-table {
      table-layout: auto;
      width: 100%;
    }

    .ranking-table th,
    .ranking-table td {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #e5e7eb;
      text-align: center;
      font-size: 0.875rem !important;
    }

    .ranking-table th {
      position: sticky;
      top: 0;
      background: #f3f4f6;
      z-index: 10;
      font-weight: 600;
      font-size: 0.875rem !important;
      vertical-align: top;
    }

    .ranking-table th > div:first-child {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
    }

    .ranking-table th.sortable {
      cursor: pointer;
      user-select: none;
      position: sticky;
      top: 0;
    }

    .ranking-table th.sortable:hover {
      background: #e5e7eb;
      position: sticky;
      top: 0;
    }

    .sort-indicator {
      display: inline-block;
      margin-left: 0.25rem;
      font-size: 0.85rem;
      opacity: 0.5;
    }

    .sort-indicator::after {
      content: "↕";
    }

    .ranking-table th.sort-asc .sort-indicator::after {
      content: "↑";
      opacity: 1;
    }

    .ranking-table th.sort-desc .sort-indicator::after {
      content: "↓";
      opacity: 1;
    }

    .ranking-table tr:nth-child(even) td {
      background: #f9fafb;
    }

    .ranking-table tr:hover {
      cursor: pointer;
    }

    .ranking-table-row--selected td {
      background: #eef2ff !important;
    }

    .ranking-row-good td {
      box-shadow: inset 3px 0 0 #16a34a;
    }

    .ranking-row-ok td {
      box-shadow: inset 3px 0 0 #f59e0b;
    }

    .ranking-row-weak td {
      box-shadow: inset 3px 0 0 #dc2626;
    }

    .ranking-table-empty {
      text-align: center;
      padding: 1rem;
      color: #6b7280;
    }


    .ranking-subtitle-tight {
      font-size: 0.875rem !important;
      max-width: 48rem;
    }

    /* RAG badges in table */
    .ranking-badge-rank {
      display: inline-flex;
      align-items: center;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .ranking-badge-rank--good {
      background: #dcfce7;
      color: #166534;
    }

    .ranking-badge-rank--ok {
      background: #fef3c7;
      color: #92400e;
    }

    .ranking-badge-rank--weak {
      background: #fee2e2;
      color: #b91c1c;
    }

    .ranking-badge-volume {
      display: inline-flex;
      align-items: center;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }
    
    .ranking-badge-volume--high {
      background: #dcfce7;
      color: #166534;
    }
    
    .ranking-badge-volume--med {
      background: #fef3c7;
      color: #92400e;
    }
    
    .ranking-badge-volume--low {
      background: #fee2e2;
      color: #b91c1c;
    }
    
    .ranking-badge-volume--none {
      background: #f3f4f6;
      color: #6b7280;
    }

    .ranking-badge-citation {
      display: inline-flex;
      align-items: center;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .ranking-badge-citation--good {
      background: #dcfce7;
      color: #166534;
    }

    .ranking-badge-citation--weak {
      background: #fee2e2;
      color: #b91c1c;
    }

    .ranking-ai-detail-body {
      padding: 1rem 0;
    }

    .ranking-ai-detail-content {
      /* Make scorecard stand out as separate object */
      margin: 0.75rem 0;
      padding: 1.5rem 1.5rem;
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      border-top: 1px solid #e5e7eb;
      border-right: 1px solid #e5e7eb;
      border-bottom: 1px solid #e5e7eb;
      /* Left border will be set dynamically based on priority */
    }

    .ranking-ai-detail-content.scorecard-priority-high {
      border-left: 6px solid #ef4444; /* Red for High priority */
      background: #fef2f2;
    }

    .ranking-ai-detail-content.scorecard-priority-medium {
      border-left: 6px solid #f59e0b; /* Amber for Medium priority */
      background: #fffbeb;
    }

    .ranking-ai-detail-content.scorecard-priority-low {
      border-left: 6px solid #10b981; /* Green for Low priority */
      background: #f0fdf4;
    }

    .ranking-ai-detail-content h4 {
      margin: 0 0 0.5rem 0;
      font-size: 1.25rem;
      font-weight: 700;
      color: #1e293b;
    }

    .ranking-ai-detail-content h5 {
      margin: 1rem 0 0.5rem 0;
      font-size: 1rem;
      font-weight: 600;
      color: #374151;
    }

    /* Section breaks for scorecard components */
    .ranking-ai-detail-content .scorecard-section {
      padding: 1rem 1.25rem;
      margin-bottom: 1.0rem !important;
      background: #f5f5f5;
      border-left: 3px solid #cbd5e1;
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .ranking-ai-detail-content .scorecard-section:last-child {
      margin-bottom: 0 !important;
    }

    .ranking-ai-detail-list {
      list-style: none;
      padding-left: 0;
      margin: 0.5rem 0 0;
    }

    .ranking-ai-detail-list li {
      margin-bottom: 0.4rem;
      padding: 0.5rem 0.75rem;
      background: #f9fafb;
      border-radius: 4px;
      font-size: 0.95rem;
    }

    .ranking-ai-detail-list li a {
      color: #2563eb;
      text-decoration: none;
    }

    .ranking-ai-detail-list li a:hover {
      text-decoration: underline;
    }

    .ranking-ai-last-run {
      margin-left: 0.75rem;
      font-size: 0.95rem;
      color: #6b7280;
    }

    .ranking-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 500;
    }

    .ranking-badge--ai-on { background: #ecfdf5; color: #059669; }
    .ranking-badge--ai-off { background: #f9fafb; color: #6b7280; }
    .ranking-badge--cited { background: #eff6ff; color: #1d4ed8; }
    .ranking-badge--not-cited { background: #fef2f2; color: #b91c1c; }
    .ranking-badge--segment-money { background: #fef3c7; color: #92400e; }
    .ranking-badge--segment-education { background: #e0f2fe; color: #075985; }
    .ranking-badge--segment-brand { background: #f5f3ff; color: #6d28d9; }
    .ranking-badge--segment-general { background: #f9fafb; color: #4b5563; }
    .ranking-badge--rank-good { background: #dcfce7; color: #166534; }
    .ranking-badge--rank-mid { background: #fef3c7; color: #92400e; }
    .ranking-badge--rank-weak { background: #fee2e2; color: #b91c1c; }
    
    /* Demand share styling */
    .ranking-badge-demand-share--high { color: #059669; font-weight: 600; }
    .ranking-badge-demand-share--med { color: #d97706; font-weight: 500; }
    .ranking-badge-demand-share--low { color: #6b7280; font-weight: 400; }
    .ranking-badge-demand-share--none { color: #9ca3af; }
    
    /* Opportunity score styling (RAG colors matching Money Pages priority matrix) */
    .ranking-badge-opportunity {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.9rem;
      font-weight: 600;
    }
    .ranking-badge-opportunity--high { background: #dcfce7; color: #166534; } /* Green - High */
    .ranking-badge-opportunity--medium { background: #fef3c7; color: #92400e; } /* Amber - Medium */
    .ranking-badge-opportunity--low { background: #fee2e2; color: #b91c1c; } /* Red - Low */
    
    /* Page type badge styling (matching Money Pages matrix) */
    .ranking-badge-page-type {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 500;
    }
    .ranking-badge-page-type--landing { background: #fef3c7; color: #92400e; }
    .ranking-badge-page-type--event { background: #dbeafe; color: #1e40af; }
    .ranking-badge-page-type--product { background: #fce7f3; color: #9f1239; }
    .ranking-badge-page-type--blog { background: #e0f2fe; color: #075985; }
    .ranking-badge-page-type--gbp { background: #f5f3ff; color: #6d28d9; }

    /* Money Pages KPI trend arrow colors */
    .kpi-trend-up { color: #10b981; font-weight: 700; }
    .kpi-trend-down { color: #ef4444; font-weight: 700; }
    .kpi-trend-flat { color: #64748b; font-weight: 700; }

    /* Domain Strength (Ranking & AI) */
    .domain-strength-badge {
      display: inline-flex;
      padding: 0.125rem 0.375rem !important;
      font-size: 0.65rem !important;
      line-height: 1.2 !important;
      align-items: center;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 600;
      white-space: nowrap;
    }
    .domain-strength-badge--very-strong { background: #dcfce7; color: #166534; }
    .domain-strength-badge--strong { background: #ecfdf5; color: #059669; }
    .domain-strength-badge--moderate { background: #fef3c7; color: #92400e; }
    .domain-strength-badge--weak { background: #fde68a; color: #92400e; }
    .domain-strength-badge--very-weak { background: #fee2e2; color: #b91c1c; }
    .domain-strength-badge--na { background: #f9fafb; color: #6b7280; }

    .domain-strength-summary-row {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      align-items: stretch;
      margin-top: 1rem;
    }
    .domain-strength-summary-card {
      flex: 1 1 280px;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 1rem 1.25rem;
      min-width: 280px;
    }
    .domain-strength-summary-top {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .domain-strength-summary-score {
      font-size: 2rem;
      font-weight: 800;
      letter-spacing: -0.02em;
      color: #0f172a;
      line-height: 1;
    }
    .domain-strength-summary-subtitle {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #64748b;
      line-height: 1.45;
    }
    .domain-strength-legend {
      flex: 1 1 320px;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      align-content: flex-start;
      padding: 1rem 1.25rem;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      min-width: 280px;
    }
    .domain-strength-help {
      margin-left: 0.4rem;
      opacity: 0.7;
      cursor: help;
      font-size: 0.95rem;
      border: 1px solid rgba(100, 116, 139, 0.35);
      border-radius: 999px;
      width: 20px;
      height: 20px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      background: rgba(248, 250, 252, 0.8);
    }
    .domain-strength-sparkline {
      display: inline-block;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>GAIO (Generative AI Optimization) Audit Dashboard</h1>
    <p>Automated GAIO Performance Tracking & Optimisation</p>
    <p style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 1; background: rgba(0,0,0,0.3); padding: 0.25rem 0.5rem; border-radius: 4px; display: inline-block;">
      <strong>Version: <span id="gitVersion">37685db</span></strong> | Built: <span id="buildDate"></span> | 
      <span id="loadTime" style="color: #4f4;">Loaded: <span id="loadTimeValue"></span></span>
    </p>
    <script>
      // Set build date to today in GMT
      const now = new Date();
      const gmtDate = now.toISOString().split('T')[0]; // YYYY-MM-DD
      const gmtTime = now.toISOString().split('T')[1].split('.')[0]; // HH:MM:SS
      document.getElementById('buildDate').textContent = gmtDate + ' ' + gmtTime + ' GMT';
      document.getElementById('loadTimeValue').textContent = now.toLocaleTimeString();
    </script>
  </div>

  <div class="aigeo-layout">
    <aside class="aigeo-sidebar">
      <button class="aigeo-nav-item" data-panel="config">
        <span class="aigeo-nav-icon">⚙️</span>
        <span>Configuration & Reporting</span>
      </button>
      <button class="aigeo-nav-item is-active" data-panel="overview">
        <span class="aigeo-nav-icon">📊</span>
        <span>Overview</span>
      </button>
      <button class="aigeo-nav-item" data-panel="authority">
        <span class="aigeo-nav-icon">🎯</span>
        <span>Authority</span>
      </button>
      <button class="aigeo-nav-item" data-panel="money">
        <span class="aigeo-nav-icon">💰</span>
        <span>Money Pages</span>
      </button>
      <button class="aigeo-nav-item" data-panel="ranking">
        <span class="aigeo-nav-icon">🔍</span>
        <span>Ranking & AI</span>
      </button>
      <button class="aigeo-nav-item" data-panel="ai-sources">
        <span class="aigeo-nav-icon">🤖</span>
        <span>AI Sources & Influence</span>
      </button>
      <button class="aigeo-nav-item" data-panel="local">
        <span class="aigeo-nav-icon">📍</span>
        <span>Local & Reviews</span>
      </button>
      <button class="aigeo-nav-item" data-panel="history">
        <span class="aigeo-nav-icon">📈</span>
        <span>History</span>
      </button>
    </aside>
    <main class="aigeo-main">
  <div class="container">

    <div class="status" id="status"></div>

    <div class="loading" id="loading">
      <div class="progress-container">
        <div class="spinner"></div>
        <div class="progress-bar-wrapper">
          <div class="progress-bar" id="progressBar" style="width: 0%;">0%</div>
        </div>
        <div class="progress-status" id="progressStatus">Initializing audit scan...</div>
      </div>
    </div>

    <!-- Completion Summary Modal -->
    <div id="completionModal" class="modal" style="display: none;">
      <div class="modal-content" style="max-width: 600px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Audit Complete</h2>
          <button onclick="closeCompletionModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;" title="Close the audit completion summary modal">&times;</button>
        </div>
        <div id="completionSummaryContent"></div>
        <div style="margin-top: 1.5rem; text-align: right;">
          <button class="btn" onclick="closeCompletionModal()" style="background: var(--brand-orange); color: white; border-color: var(--brand-orange);" title="Close the audit completion summary modal and return to the dashboard">Close</button>
        </div>
      </div>
    </div>

    <!-- Ranking & AI Progress Modal -->
    <div id="rankingAiProgressModal" class="modal" style="display: none;">
      <div class="modal-content" style="max-width: 700px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Running Ranking & AI Check</h2>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <button id="rankingAiProgressStop" style="display: none; padding: 0.5rem 1rem; background: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 600;" title="Stop the scan">Stop Scan</button>
            <button id="rankingAiProgressClose" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666; opacity: 0.5;" disabled title="Cannot close during processing">&times;</button>
          </div>
        </div>
        
        <!-- Keyword Count Display (shown before scan starts) -->
        <div id="rankingAiKeywordCount" style="display: none; margin-bottom: 1rem; padding: 1rem; background: #fef3c7; border: 1px solid #fbbf24; border-radius: 6px;">
          <div style="font-weight: 600; color: #92400e; margin-bottom: 0.5rem;">Ready to scan:</div>
          <div style="font-size: 1.2rem; font-weight: 700; color: #78350f;" id="rankingAiKeywordCountValue">0 keywords</div>
          <div style="font-size: 0.85rem; color: #78350f; margin-top: 0.5rem;">Click "Start Scan" below to begin, or close this modal to cancel.</div>
        </div>
        
        <!-- Progress Bar -->
        <div style="margin-bottom: 2rem;">
          <div id="rankingAiProgressBar" style="width: 100%; height: 24px; background-color: #e5e7eb; border-radius: 12px; overflow: hidden; position: relative;">
            <div id="rankingAiProgressFill" style="width: 0%; height: 100%; background: linear-gradient(90deg, var(--brand-orange), #ff8c42); transition: width 0.3s ease; border-radius: 12px;"></div>
          </div>
          <div id="rankingAiProgressText" style="margin-top: 0.5rem; text-align: center; font-size: 0.9rem; color: #6b7280; font-weight: 500;">0%</div>
        </div>

        <!-- Step Details -->
        <div id="rankingAiStepDetails" style="margin-bottom: 1.5rem;">
          <div id="rankingAiCurrentStep" style="font-size: 1.1rem; font-weight: 600; color: #1f2937; margin-bottom: 0.75rem;">
            Initializing...
          </div>
          <div id="rankingAiStepNarrative" style="font-size: 0.95rem; color: #6b7280; line-height: 1.6; margin-bottom: 1rem;">
            Preparing to fetch ranking and AI data...
          </div>
          <div id="rankingAiStepCounts" style="font-size: 0.9rem; color: #9ca3af; font-style: italic;">
            <!-- Counts will be populated here -->
          </div>
        </div>

        <!-- Step List -->
        <div style="border-top: 1px solid #e5e7eb; padding-top: 1rem;">
          <div style="font-size: 0.85rem; font-weight: 600; color: #6b7280; margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Progress Steps</div>
          <div id="rankingAiStepsList" style="display: flex; flex-direction: column; gap: 0.5rem;">
            <!-- Steps will be populated here -->
          </div>
        </div>

        <!-- Completion Summary (hidden by default) -->
        <div id="rankingAiSummary" style="display: none; border-top: 2px solid #10b981; padding-top: 1.5rem; margin-top: 1.5rem;">
          <h3 style="margin: 0 0 1rem 0; color: #10b981; font-size: 1.2rem; font-weight: 600;">✓ Scan Complete</h3>
          <div id="rankingAiSummaryContent" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; font-size: 0.95rem;">
            <!-- Summary content will be populated here -->
          </div>
        </div>
      </div>
    </div>

    <div id="dashboard" style="display: none;">
      <div id="auditTimestamp" style="background: #e8f5e9; padding: 0.75rem 1rem; border-radius: 6px; margin-bottom: 1rem; border-left: 4px solid #10b981; font-size: 0.9rem; color: #555;">
        <strong>Last Audit:</strong> <span id="lastAuditTime">Not yet run</span>
      </div>

      <!-- Configuration & Reporting Panel -->
      <section class="aigeo-panel" data-panel="config">
    <div class="config-panel">
      <h2>Configuration</h2>
      <div class="info-box" style="background: #e8f4f8; border-left: 4px solid #2196F3; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #1565C0;"><strong>Entity-Level Audit:</strong> This dashboard analyzes <strong>www.alanranger.com</strong> as a global entity, tracking AI-powered search visibility, entity recognition, and SERP behavior across the entire domain.</p>
      </div>
      <div class="form-group">
        <label for="propertyUrl">Property URL</label>
        <input type="text" id="propertyUrl" placeholder="https://yourwebsite.com" value="https://www.alanranger.com">
        <div class="help-text">The domain being audited (entity-level analysis)</div>
      </div>
      <div style="background: #f0f0f0; padding: 0.75rem; border-radius: 4px; margin-bottom: 1rem; font-size: 0.85rem; color: #555;">
        <strong>API Key:</strong> Loaded automatically from Vercel environment variables. No manual entry required.
      </div>
      <!-- Manual URL List Section (Collapsible) -->
      <div class="csv-upload-section collapsed" id="urlListSection">
        <div class="csv-section-header" onclick="toggleCsvSection('urlListSection')">
          <h3>Manual URL List (Optional)</h3>
          <span class="csv-section-toggle" id="urlListToggle">▶</span>
        </div>
        <div class="csv-section-content collapsed" id="urlListContent">
          <div class="form-group" style="margin-bottom: 0;">
        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">
          Load list of site URLs from a CSV file
        </div>
        <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
          <input type="file" id="urlListFile" accept=".csv" style="flex: 1; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem;">
              <button class="btn btn-small" onclick="loadUrlListFromFile()" style="padding: 0.5rem 1rem;" title="Load a CSV file containing site URLs. The CSV must have a 'url' column in the header row. URLs will be used for schema audit instead of the default CSV source.">Load CSV</button>
              <button class="btn btn-small" onclick="clearManualUrlList()" style="padding: 0.5rem 1rem; background: #ef4444; color: white; border-color: #ef4444;" title="Clear the manually loaded URL list and revert to using the default CSV source for schema audit">Clear</button>
        </div>
        <textarea id="manualUrlList" placeholder="Or paste CSV content here (must include 'url' column in header row)..." style="width: 100%; min-height: 100px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace; resize: vertical;"></textarea>
        <div class="help-text">
          <strong>Required column:</strong> <code>url</code> (case-insensitive). CSV must have a header row. URLs will be extracted from the 'url' column.
        </div>
        <div id="urlListStatus" style="margin-top: 0.5rem; font-size: 0.85rem;"></div>
          </div>
        </div>
      </div>
      
      <!-- Backlink CSV Upload Section (Collapsible) -->
      <div class="csv-upload-section collapsed" id="backlinkCsvSection">
        <div class="csv-section-header" onclick="toggleCsvSection('backlinkCsvSection')">
          <h3>Backlink CSV Upload (Optional)</h3>
          <span class="csv-section-toggle" id="backlinkCsvToggle">▶</span>
        </div>
        <div class="csv-section-content collapsed" id="backlinkCsvContentWrapper">
          <div class="form-group" style="margin-bottom: 0;">
            <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">
              Upload backlink data CSV file for Authority score calculation. Can be uploaded independently of site URLs CSV.
            </div>
            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
              <input type="file" id="backlinkCsvFile" accept=".csv" style="flex: 1; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem;">
                  <button class="btn btn-small" onclick="loadBacklinkCsvFromFile()" style="padding: 0.5rem 1rem;" title="Load a CSV file containing backlink data. The CSV must have 'source_url' and 'target_url' columns in the header row. Backlinks will be used for Authority score calculation.">Load CSV</button>
                  <button class="btn btn-small" onclick="clearBacklinkCsv()" style="padding: 0.5rem 1rem; background: #ef4444; color: white; border-color: #ef4444;" title="Clear the backlink CSV data">Clear</button>
            </div>
                <textarea id="backlinkCsvContent" placeholder="Or paste CSV content here (must include 'source_url' and 'target_url' columns in header row)..." style="width: 100%; min-height: 100px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace; resize: vertical;"></textarea>
            <div class="help-text">
                  <strong>Required columns:</strong> <code>source_url</code> and <code>target_url</code> (case-insensitive). CSV must have a header row. Backlinks will be extracted from these columns.
            </div>
            <div id="backlinkCsvStatus" style="margin-top: 0.5rem; font-size: 0.85rem;"></div>
          </div>
        </div>
      </div>
          
          <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-top: 1.5rem;">
        <button class="btn" onclick="runAudit()" title="Start a comprehensive audit scan. Fetches Google Search Console data, performs schema audit (if site URLs CSV loaded), and uses backlink data (if backlink CSV uploaded). Results will appear in the dashboard below.">Run Audit Scan</button>
            <button class="btn btn-secondary" onclick="shareAudit()" title="Generate a shareable link to your current audit results. The link will allow others to view your audit data without running a new scan.">Share Audit</button>
        <button class="btn btn-secondary" onclick="saveConfig()" title="Save your current configuration (property URL and date range) to browser localStorage. Settings will be restored when you reload the page.">Save Configuration</button>
            <button class="btn btn-success" onclick="syncCsv()" title="Sync CSV data from the configured source. This will update your URL list and backlink data from the remote CSV file.">Sync CSV</button>
      </div>
    </div>

    <!-- Admin Key Configuration (Phase A - Security) -->
    <div class="config-panel" style="margin-top: 2rem;">
      <h2>Optimisation Tracking Security</h2>
      <div class="info-box" style="background: #e0f2fe; border-left: 4px solid #0284c7; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #0c4a6e;">
          <strong>Admin Key Required:</strong> Set your admin key to enable optimisation tracking actions (Track, Manage, Cycle). 
          The key is stored in your browser session and sent with API requests.
        </p>
      </div>
      <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-bottom: 1rem;">
        <input 
          type="password" 
          id="admin-key-input" 
          placeholder="Enter admin key (32+ characters)" 
          style="flex: 1; min-width: 300px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace;"
          value=""
        />
        <button 
          class="btn" 
          onclick="saveAdminKey()" 
          title="Save admin key to session storage. Required for optimisation tracking actions."
        >
          Save Admin Key
        </button>
        <button 
          class="btn btn-secondary" 
          onclick="clearAdminKeyUI()" 
          title="Clear admin key from session storage."
        >
          Clear
        </button>
      </div>
      <div id="admin-key-status" style="font-size: 0.85rem; color: #64748b; margin-top: 0.5rem;"></div>
      <script>
        // Admin key UI functions
        function saveAdminKey() {
          const input = document.getElementById('admin-key-input');
          const key = input.value.trim();
          if (!key) {
            alert('Please enter an admin key');
            return;
          }
          if (key.length < 32) {
            if (!confirm('Admin key should be at least 32 characters. Save anyway?')) {
              return;
            }
          }
          window.setAdminKey(key);
          updateAdminKeyStatus();
          input.value = ''; // Clear input for security
          
          // Re-render Ranking & AI table to enable Track buttons
          // Check if Ranking & AI tab is active
          const rankingTab = document.querySelector('[data-panel="ranking"]');
          if (rankingTab && rankingTab.classList.contains('is-active')) {
            // Tab is active, try to refresh the table
            if (typeof renderRankingAiTab === 'function') {
              renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
            } else if (typeof window.renderRankingAiTab === 'function') {
              window.renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
            } else {
              // Fallback: reload the page
              if (confirm('Admin key saved! Refresh the page to enable Track buttons?')) {
                location.reload();
              }
            }
          } else {
            alert('Admin key saved! Switch to the "Ranking & AI" tab to see enabled Track buttons.');
          }
        }

        function clearAdminKeyUI() {
          if (confirm('Clear admin key? Optimisation tracking actions will be disabled.')) {
            window.clearAdminKey();
            document.getElementById('admin-key-input').value = '';
            updateAdminKeyStatus();
            
            // Re-render Ranking & AI table to disable Track buttons
            const rankingTab = document.querySelector('[data-panel="ranking"]');
            if (rankingTab && rankingTab.classList.contains('is-active')) {
              if (typeof renderRankingAiTab === 'function') {
                renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
              } else if (typeof window.renderRankingAiTab === 'function') {
                window.renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
              }
            }
          }
        }

        function updateAdminKeyStatus() {
          const statusEl = document.getElementById('admin-key-status');
          if (!statusEl) return;
          
          const hasKey = window.hasAdminKey();
          if (hasKey) {
            const key = window.getAdminKey();
            statusEl.innerHTML = `<span style="color: #10b981;">✓ Admin key set</span> (${key.length} characters, stored in session)`;
          } else {
            statusEl.innerHTML = '<span style="color: #ef4444;">⚠ Admin key not set — tracking actions disabled</span>';
          }
        }

        // Update status on load
        if (typeof window !== 'undefined' && document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', updateAdminKeyStatus);
        } else {
          updateAdminKeyStatus();
        }
      </script>
    </div>

    <div class="config-panel" style="margin-top: 2rem;">
      <h2>Reporting</h2>
      <div class="info-box" style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #856404;"><strong>Generate Reports:</strong> Create comprehensive PDF reports containing all audit data, charts, and pillar score definitions.</p>
      </div>
      <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
        <button class="btn" onclick="try { console.log('[PDF] Button clicked!'); generatePDFReport(); } catch(e) { console.error('[PDF] Error in onclick:', e); alert('Error generating PDF: ' + e.message); }" id="generatePdfBtn" style="background: #dc2626; color: white; border-color: #dc2626;" title="Generate a comprehensive PDF report containing all audit data, charts, pillar scores, definitions, and metrics. The report will include all sections from the dashboard.">
          📄 Generate PDF Report
        </button>
        <div id="pdfStatus" style="font-size: 0.85rem; color: #666; margin-left: 0.5rem;"></div>
      </div>
    </div>
      </section>

      <!-- Authority Panel -->
      <section class="aigeo-panel" data-panel="authority">
        <!-- Authority - Behaviour & Ranking section will be inserted here by JS -->
      </section>

      <!-- Overview Panel -->
      <section class="aigeo-panel is-active" data-panel="overview">

      <!-- Five-Pillar Framework (collapsed by default) -->
      <div class="calculation-explanation collapsed" id="frameworkExplanation">
        <div class="calculation-header" onclick="toggleFrameworkExplanation()">
          <h4>🧱 Five-Pillar Framework</h4>
          <span class="calculation-toggle" id="frameworkToggle">▶</span>
        </div>
        <div class="calculation-content collapsed" id="frameworkContent">
          <p style="margin-top: 0; color: #555; line-height: 1.6; margin-bottom: 1rem;">
            This audit analyzes <strong>www.alanranger.com</strong> as a global entity using a five-pillar framework to assess AI-powered search visibility, entity recognition, and SERP behavior. Each pillar is scored 0-100 and assigned a RAG (Red/Amber/Green) status based on performance thresholds.
          </p>
          <p style="color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
            <strong>Data Sources:</strong> Scores are calculated using data from Google Search Console API (impressions, clicks, position, queries), Google Business Profile API (ratings, reviews, locations, service areas), schema markup validation, backlink CSV upload, and Trustpilot reviews snapshot.
          </p>
          <p style="color: #555; line-height: 1.6; margin-bottom: 0;">
            <strong>Score Calculation:</strong> The GAIO score combines five weighted pillars: Authority (30%: Behaviour 40% + Ranking 20% + Backlinks 20% + Reviews 20%), Content/Schema (25%: Foundation schemas 30% + Rich Results 35% + Coverage 20% + Diversity 15%), Visibility (20%: average position mapping), Local Entity (15%: NAP consistency + knowledge panel + locations), and Service Area (10%: service areas count with NAP multiplier). Brand & Entity Overlay and AI Summary Likelihood are overlay metrics that do not affect the GAIO score but provide additional insights. Scores are normalized to 0-100 scale with thresholds: Green (≥70), Amber (40-69), Red (&lt;40). Money pages behaviour is tracked separately and stored per audit, so you can see whether Authority improvements are coming from better CTR on commercial pages or from broader site-wide changes.
          </p>
        </div>
      </div>

      <div class="calculation-explanation collapsed" id="calculationExplanation">
        <div class="calculation-header" onclick="toggleCalculationExplanation()">
          <h4>📊 Detailed Calculation Explanation</h4>
          <span class="calculation-toggle" id="calculationToggle">▶</span>
        </div>
        <div class="calculation-content collapsed" id="calculationContent">
          <h5>1. Visibility</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Primary: Average position from Google Search Console (1-40 mapped to 100-10)</li>
            <li>Formula: <code>posScore = 100 - ((clampedPosition - 1) / 39) * 90</code> where clampedPosition is constrained to 1-40</li>
            <li>Visibility score = clamped posScore (0-100)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: impressions, clicks, average position, CTR</li>
            <li>Real-time data from GSC API for the selected date range</li>
          </ul>
          <p><strong>Data Checked:</strong> Search Console impressions/clicks, average position, CTR, ranking distribution.</p>

          <h5>2. Authority (E-E-A-T)</h5>
          <p><strong>What Authority Represents:</strong></p>
          <p>Authority is not "how good the content is", it's "how much the outside world and searchers trust and choose you". It approximates E-E-A-T using four ingredients:</p>
          <ul>
            <li><strong>Behavioural signals</strong> – do people click your results when they see them?</li>
            <li><strong>Ranking strength</strong> – how often do you show near the top of organic results?</li>
            <li><strong>Off-site credibility</strong> – backlinks from other domains (Phase 3)</li>
            <li><strong>Reputation & reviews</strong> – ratings and review volume across GBP + website</li>
          </ul>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Four-component model: Behaviour (40%), Ranking (20%), Backlinks (20%), Reviews (20%)</li>
            <li>Formula: <code>authority = 0.4 * behaviourScore + 0.2 * rankingScore + 0.2 * backlinkScore + 0.2 * reviewScore</code></li>
            <li>Each sub-score is normalized to 0-100, then combined with weights above</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>2.1 Behaviour Score (40%):</strong></p>
          <ul>
            <li>From Google Search Console: Only uses queries where average position ≤ 20</li>
            <li>Computes: ctrAll = CTR for all ranking queries, ctrTop10 = CTR for impressions where position ≤ 10</li>
            <li>Maps: ctrAll 0-5% → 0-100 (values >5% capped at 100), ctrTop10 0-10% → 0-100</li>
            <li>Combines: <code>BehaviourScore = 0.5 * score(ctrAll) + 0.5 * score(ctrTop10)</code></li>
            <li>This stops long-tail / low-rank pages dragging the whole site down</li>
          </ul>
          <p><strong>2.2 Ranking Score (20%):</strong></p>
          <ul>
            <li>From GSC, again only for position ≤ 20</li>
            <li>avgPos = impression-weighted average position</li>
            <li>top10Share = % of impressions where position ≤ 10</li>
            <li>posScore = map(avgPos, 1 → 100, 20 → 0) (clamped)</li>
            <li>top10Score = top10Share as a % (0-100)</li>
            <li>Combines: <code>RankingScore = 0.5 * posScore + 0.5 * top10Score</code></li>
          </ul>
          <p><strong>2.3 Review Score (20%):</strong></p>
          <ul>
            <li>Inputs: From GBP API (gbpRating 0-5, gbpReviewCount) and Trustpilot snapshot (siteRating 4.6, siteReviewCount 610)</li>
            <li>Per source: ratingScore = (rating/5)*100, countScore = min(reviewCount, 500)/500*100</li>
            <li>sourceScore = 0.6 * ratingScore + 0.4 * countScore</li>
            <li>Final: <code>ReviewScore = 0.6 * gbpSourceScore + 0.4 * siteSourceScore</code></li>
            <li>If one source missing, falls back to the other; if both missing, uses neutral default (50)</li>
          </ul>
          <p><strong>2.4 Backlink Score (20%):</strong></p>
          <ul>
            <li>Phase 3 – using CSVs: refDomainCount, qualityDomains, qualityRatio</li>
            <li>countScore = map(refDomainCount, 0 → 0, N → 100) where N is cap (e.g. 150-200)</li>
            <li>qualityScore = qualityRatio * 100</li>
            <li>Combines: <code>BacklinkScore = 0.5 * countScore + 0.5 * qualityScore</code></li>
            <li>Currently placeholder (50) until Phase 3 is implemented</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API (CTR, position, impressions by position bucket)</li>
            <li>Google Business Profile API (ratings, review count)</li>
            <li>Trustpilot reviews (historic snapshot: rating 4.6, count 610)</li>
            <li>Backlink CSV upload (referring domains, quality metrics) - Phase 3</li>
          </ul>
          <p><strong>How to Improve Authority:</strong></p>
          <ul>
            <li><strong>Behaviour:</strong> Improve titles/meta descriptions on pages already in top 10-20. Focus on high-impression queries in GSC.</li>
            <li><strong>Ranking:</strong> Push more core pages into top 10 (content refreshes, internal links, stronger schema).</li>
            <li><strong>Reviews:</strong> Keep growing GBP and Trustpilot reviews; higher rating and more volume both help.</li>
            <li><strong>Backlinks:</strong> Acquire more distinct linking domains, favouring sites with real traffic/authority (Phase 3).</li>
          </ul>

          <h5>3. Local Entity</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li><strong>Primary method (when Business Profile data available):</strong> Base score from NAP consistency (0-100), with bonuses:
              <ul>
                <li>Knowledge panel detected: +10 points</li>
                <li>At least one location: +5 points</li>
                <li>Final score capped at 100</li>
              </ul>
            </li>
            <li><strong>Fallback method (no Business Profile data):</strong> Derived from search performance:
              <ul>
            <li>Formula: <code>localEntity = 60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50)</code></li>
                <li>Uses position score and CTR score from GSC</li>
              </ul>
            </li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>✅ <strong>Primary:</strong> Google Business Profile API: NAP consistency score, knowledge panel detection, locations count</li>
            <li>⚠️ <strong>Fallback:</strong> Google Search Console API: position, CTR (when Business Profile data unavailable)</li>
          </ul>
          <p><strong>Data Checked:</strong> NAP consistency percentage, knowledge panel presence, locations count, LocalBusiness schema presence, entity recognition signals.</p>

          <h5>4. Service Area</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li><strong>Primary method (when Business Profile data available):</strong>
              <ul>
                <li>Base score from service areas count: 0 areas = 0, 1 area = 12.5, 2 areas = 25, ..., 8+ areas = 100</li>
                <li>Formula: <code>baseScore = min(serviceAreasCount * 12.5, 100)</code></li>
                <li>NAP consistency multiplier applied: <code>serviceArea = baseScore * (napConsistencyScore / 100)</code></li>
                <li>If NAP consistency is low, service area score is reduced proportionally</li>
              </ul>
            </li>
            <li><strong>Fallback method (no Business Profile data):</strong> Derived from Local Entity score (when Business Profile unavailable)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>✅ <strong>Primary:</strong> Google Business Profile API: service areas count, NAP consistency score</li>
            <li>⚠️ <strong>Fallback:</strong> Derived from Local Entity (when Business Profile data unavailable)</li>
          </ul>
          <p><strong>Data Checked:</strong> Service areas count from Business Profile, NAP consistency percentage, geographic coverage signals.</p>

          <h5>5. Content/Schema</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Weighted calculation based on four components: Foundation schemas, Rich Results, Coverage, and Diversity</li>
            <li>Formula: <code>contentSchema = (Foundation × 30%) + (Rich Results × 35%) + (Coverage × 20%) + (Diversity × 15%)</code></li>
            <li><strong>Foundation Schemas (30%):</strong> Organization, Person, WebSite, BreadcrumbList presence. Score = (types present / 4) × 100</li>
            <li><strong>Rich Results (35%):</strong> Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList eligibility. Score = (eligible types / 11) × 100</li>
            <li><strong>Coverage (20%):</strong> Pages with schema / total pages. Score = coverage percentage</li>
            <li><strong>Diversity (15%):</strong> Number of unique schema types across site. Score = min((unique types / 15) × 100, 100)</li>
            <li><strong>Data Source:</strong> Schema audit API (crawls actual pages for JSON-LD markup)</li>
            <li>Uses real schema coverage from CSV-based audit (when available)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Schema Audit API: CSV-based domain crawl of all site URLs</li>
            <li>Schema markup detection and type counting</li>
            <li>Foundation schema presence detection (Organization, Person, WebSite, BreadcrumbList)</li>
            <li>Rich result eligibility detection (Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList)</li>
          </ul>
          <p><strong>Data Checked:</strong> Total pages scanned, pages with schema, schema coverage percentage, schema types present (Organization, Person, LocalBusiness, Article, Course, Event, FAQ, HowTo, etc.), missing schema types, rich result eligibility (Article, Event, FAQ, Product, LocalBusiness, Course, Review, HowTo).</p>

          <h5>6. Brand & Entity Overlay</h5>
          <p><strong>What Brand Overlay Represents:</strong></p>
          <p>Brand & Entity Overlay measures how strongly your brand is recognized in search and how well entity signals support AI understanding. It combines branded search performance, review signals, and entity recognition. <strong>Note:</strong> This is an overlay metric and does not directly affect the GAIO score calculation.</p>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li><strong>Brand Search Component (40% of brand search score):</strong>
              <ul>
                <li>Brand Query Share: % of impressions that are branded queries (30%+ share = 100 points)</li>
                <li>Brand CTR: Click-through rate on branded queries (40%+ CTR = 100 points)</li>
                <li>Brand Avg Position: Average position for branded queries (normalized 1-10 → 100-0)</li>
                <li>Formula: <code>brandSearchScore = 0.4 * shareScore + 0.3 * ctrScore + 0.3 * posScore</code></li>
              </ul>
            </li>
            <li><strong>Combined Score:</strong>
              <ul>
                <li>Formula: <code>brandOverlay = 0.4 * brandSearchScore + 0.3 * reviewScore + 0.3 * entityScore</code></li>
                <li>Label thresholds: &lt;40 = Weak, 40-69 = Developing, ≥70 = Strong</li>
              </ul>
            </li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: Branded query identification, brand impressions, brand clicks, brand CTR, brand average position</li>
            <li>Google Business Profile API: Review score (reused from Authority pillar)</li>
            <li>Local Entity score: Entity recognition signals (reused from Local Entity pillar)</li>
          </ul>
          <p><strong>Data Checked:</strong> Brand query share (% of total impressions), branded CTR, average brand position, review signals, entity recognition strength.</p>

          <h5>7. AI Summary Likelihood</h5>
          <p><strong>What AI Summary Likelihood Represents:</strong></p>
          <p>AI Summary Likelihood indicates how likely AI systems (like Google's AI Overviews) are to provide accurate, comprehensive summaries about your brand and content. It combines snippet readiness, visibility, and brand strength signals.</p>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Three-component model: Snippet Readiness (50%), Visibility (30%), Brand & Entity (20%)</li>
            <li>Formula: <code>aiSummary = 0.5 * snippetReadinessScore + 0.3 * visibilityScore + 0.2 * brandScore</code></li>
            <li>Label thresholds: &lt;50 = Low, 50-69 = Medium, ≥70 = High</li>
            <li>Uses same RAG bands as GAIO Score (≥70 green, ≥50 amber, &lt;50 red)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Snippet Readiness score: From snippet readiness gauge (FAQ/HowTo/Article blocks, schema, rich results)</li>
            <li>Visibility score: Current Visibility pillar score (average position from GSC)</li>
            <li>Brand score: Brand & Entity Overlay score</li>
          </ul>
          <p><strong>Data Checked:</strong> Snippet-friendly content blocks, schema markup for rich results, average search position, branded search performance, entity recognition.</p>

          <div class="note">
            <strong>Current Implementation Status:</strong><br>
            <strong>✅ Fully Implemented:</strong><br>
            • Google Search Console API integration (real-time data) - Total clicks, Total impressions, Average position, CTR calculation, Top queries, Brand query classification<br>
            • Schema markup validation and analysis - Full site crawl, coverage analysis, type diversity, rich result eligibility (11 types), foundation schema detection<br>
            • Backlink quality/quantity analysis - CSV upload support, domain rating, referring domains tracking<br>
            • Review aggregation - Trustpilot integration (snapshot), Google Business Profile reviews, review score calculation<br>
            • Knowledge panel tracking - Detection and scoring (part of Local Entity pillar)<br>
            • Local pack visibility metrics - Service Area pillar with NAP consistency, location coverage<br>
            • SERP feature detection - Rich result eligibility checks, snippet readiness scoring<br>
            • Brand overlay metrics - Brand query share, branded CTR, brand position, entity strength<br>
            • AI Summary Likelihood - Composite score based on snippet readiness, visibility, and brand signals<br>
            • Historical trend tracking - Supabase integration for all pillars, trend charts with segmented Authority data<br>
            • Shareable audit links - Public sharing with 30-day expiration<br><br>
            <strong>Future Enhancements:</strong><br>
            • Real-time SERP feature monitoring and alerts<br>
            • Advanced backlink analysis with automated discovery<br>
            • Competitive analysis and benchmarking<br>
            • Automated action recommendations engine<br>
            • Export capabilities (PDF, CSV reports)<br><br>
            <strong>Note:</strong> All five core pillars (Authority, Content/Schema, Visibility, Local Entity, Service Area) are fully implemented with real data sources. Brand & Entity and AI Summary Likelihood are overlay metrics that enhance the core scoring without changing the GAIO score calculation.
          </div>
        </div>
      </div>

      <!-- Date Range Selector -->
      <div class="config-panel" style="margin-bottom: 2rem; background: #f8f9fa; padding: 1.5rem; border-radius: 8px; border: 1px solid #e2e8f0;">
        <div class="form-group">
          <label for="dateRange">Date Range</label>
          <div class="date-range-selector">
            <button class="date-range-btn active" onclick="setDateRange(30)" data-days="30" title="Analyze search performance data from the last 30 days">Last 30 Days</button>
            <button class="date-range-btn" onclick="setDateRange(60)" data-days="60" title="Analyze search performance data from the last 60 days">Last 60 Days</button>
            <button class="date-range-btn" onclick="setDateRange(90)" data-days="90" title="Analyze search performance data from the last 90 days">Last 90 Days</button>
            <button class="date-range-btn" onclick="setDateRange(120)" data-days="120" title="Analyze search performance data from the last 120 days">Last 120 Days</button>
            <button class="date-range-btn" onclick="setDateRange(180)" data-days="180" title="Analyze search performance data from the last 6 months (180 days)">Last 6 Months</button>
            <button class="date-range-btn" onclick="setDateRange(365)" data-days="365" title="Analyze search performance data from the last 12 months (365 days)">Last 12 Months</button>
            <button class="date-range-btn" onclick="setDateRange(540)" data-days="540" title="Analyze search performance data from the last 18 months (540 days)">Last 18 Months</button>
            <button class="date-range-btn" onclick="showCustomDateRange()" id="customDateBtn" title="Set a custom date range for analysis (enter number of days)">Custom</button>
        </div>
          <input type="number" id="dateRange" value="30" min="1" style="display: none;">
          <div id="customDateRange" style="display: none; margin-top: 0.5rem;">
            <input type="number" id="customDays" placeholder="Enter days" min="1" style="width: 150px; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px;">
            <button class="btn btn-small" onclick="applyCustomDateRange()" style="margin-left: 0.5rem; padding: 0.5rem 1rem;" title="Apply the custom date range you entered">Apply</button>
      </div>
          <div class="help-text">Analysis period for historical data</div>
      </div>
    </div>

      <div class="dashboard-grid" id="pillarCards"></div>

      <div class="section-break"></div>

      <div class="metrics-section">
        <h3 style="color: var(--brand-orange); margin-bottom: 0.5rem;">Key Performance Indicators</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Core metrics from Google Search Console showing overall search performance for the entity. <strong>Note:</strong> Small differences from live GSC may occur due to data processing delays (up to 48 hours) and exact date range calculations.</p>
        <div class="metrics-grid" id="metricsGrid"></div>
      </div>

      <div class="section-break"></div>

      <div class="dashboard-two-column">
        <div class="chart-container large">
          <h3>Pillar Scores Overview</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Radar chart showing current performance across all five pillars. The larger the area, the stronger your overall entity recognition.</p>
          
          <!-- Audit Timestamp for Radar Chart -->
          <div id="radarChartTimestamp" style="background: #fff3cd; padding: 0.5rem 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #f59e0b; font-size: 0.8rem; color: #856404; display: none;">
            <strong>Current data as of:</strong> <span id="radarChartAuditTime">-</span> <span style="color: #666; font-size: 0.75rem;">(Not historical - reflects last audit scan)</span>
          </div>
          
          <canvas id="radarChart"></canvas>
        </div>

        <div class="snippet-readiness-gauge">
          <h3 style="margin-top: 0; color: var(--brand-orange);">Snippet Readiness Gauge</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Snippet readiness summarises how likely your content is to be lifted into featured snippets and AI answers. It reflects three ingredients: snippet-friendly answer blocks, suitable schema (FAQ/HowTo/Article/Course/Event) and existing rich-result behaviour.</p>
          
          <!-- Audit Timestamp for Snippet Readiness -->
          <div id="snippetReadinessTimestamp" style="background: #fff3cd; padding: 0.5rem 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #f59e0b; font-size: 0.8rem; color: #856404; display: none;">
            <strong>Current data as of:</strong> <span id="snippetReadinessAuditTime">-</span> <span style="color: #666; font-size: 0.75rem;">(Not historical - reflects last audit scan)</span>
            </div>
          
          <div id="snippetReadinessExplanation" style="display: none; background: #fde68a; border-left: 4px solid #f59e0b; padding: 1rem; margin-bottom: 1rem; border-radius: 4px; font-size: 0.85rem; color: #78350f;">
            <strong id="explanationTitle" style="color: #78350f;">Top 5 Actions to Improve Snippet Readiness</strong>
            <p style="margin: 0.5rem 0; color: #78350f;">Prioritized actions based on your current scores and their impact on overall snippet readiness:</p>
            <ol id="topActionsList" style="margin: 0.5rem 0 0 1.5rem; padding: 0; list-style-type: decimal;">
              <!-- Top 5 actions will be populated dynamically -->
            </ol>
            </div>
          
          <!-- Overall Combined Score -->
          <div style="text-align: center; margin-bottom: 1.5rem;">
            <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">Overall Snippet Readiness</div>
            <div id="snippetReadinessScore" style="font-size: 3rem; font-weight: 700; color: var(--brand-orange); line-height: 1;">0</div>
            <div id="gaugeStatus" style="font-size: 0.9rem; color: #666; margin-top: 0.25rem;">Calculating...</div>
          </div>
          
          <!-- Pie Chart Container -->
          <div style="display: flex; align-items: center; justify-content: center; gap: 1.5rem; flex-wrap: wrap;">
            <div style="flex: 2; min-width: 400px; max-width: 500px;">
              <canvas id="snippetReadinessPieChart"></canvas>
            </div>
            <div style="flex: 1; min-width: 180px; max-width: 250px;">
              <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--brand-dark);">Component Breakdown:</div>
              <div id="snippetReadinessLegend" style="display: flex; flex-direction: column; gap: 0.5rem;">
                <!-- Legend will be populated by JavaScript -->
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="section-break"></div>

      <div class="chart-container">
        <h3>Score Trends</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Historical performance tracking for all five pillars (Local Entity, Service Area, Authority, Visibility, Content/Schema) over the selected date range.</p>
        <div id="trendAuthorityModeToggle" class="authority-mode-toggle" style="margin-bottom: 1rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; display: none;">
          <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
            <span style="font-weight: 600; color: #666;">Authority Mode:</span>
            <button id="trend-mode-all" class="authority-mode-btn" data-mode="all" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: #10b981; color: white; cursor: pointer; font-size: 0.75rem;">
              All pages
            </button>
            <button id="trend-mode-nonEducation" class="authority-mode-btn" data-mode="nonEducation" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
              Exclude education
            </button>
            <button id="trend-mode-money" class="authority-mode-btn" data-mode="money" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
              Money pages only
            </button>
          </div>
        </div>
        <div id="trendSummaryRow" class="trend-summary-row"></div>
        <canvas id="trendChart"></canvas>
      </div>
      </section>

      <!-- Money Pages Panel -->
      <section class="aigeo-panel" data-panel="money">
        <!-- Money Pages content will be inserted here by JS -->
      </section>

      <!-- Ranking & AI Panel -->
      <section class="aigeo-panel" data-panel="ranking">
        <div class="card card--section-header">
          <h2>Ranking &amp; AI Visibility</h2>
          <p class="ranking-intro">
            Keyword-level view of how search engines and AI systems see you. This is an overlay on the
            <strong>Visibility</strong>, <strong>Authority</strong>, <strong>Content/Schema</strong> and
            <strong>Local Entity</strong> pillars – it does not change their weights or scores.
          </p>

          <ul class="ranking-intro-bullets">
            <li><strong>Classic rankings</strong> → Visibility + Authority (Ranking component).</li>
            <li><strong>AI Overviews &amp; citations</strong> → Content/Schema + Authority.</li>
            <li><strong>Local packs</strong> → Local Entity + Service Area.</li>
          </ul>

          <div class="ranking-header-actions" style="display: flex; align-items: center; gap: 1rem;">
            <button id="ranking-ai-refresh" class="btn btn-secondary" type="button">
              Run ranking &amp; AI check
            </button>
            <button id="ranking-gsc-refresh" class="btn btn-secondary" type="button" style="background: #10b981; color: white; border: 1px solid #10b981; font-weight: 600; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;" title="Refresh CTR & Impressions from Google Search Console (no API costs)">
              Refresh GSC Data
            </button>
            <button id="edit-keywords-btn" class="btn btn-secondary" type="button" style="background: #2563eb; color: white; border: 1px solid #2563eb; font-weight: 600; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">
              Edit Keywords
            </button>
            <span id="ranking-ai-last-run" class="ranking-ai-last-run"></span>
          </div>
        </div>

        <!-- Edit Keywords Modal -->
        <div id="edit-keywords-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 10000; align-items: center; justify-content: center;">
          <div style="background: white; border-radius: 8px; padding: 2rem; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
              <h3 style="margin: 0; font-size: 1.5rem; color: #1e293b;">Edit Keywords</h3>
              <button id="edit-keywords-close" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #64748b; padding: 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;">&times;</button>
            </div>
            
            <!-- Warning and Instructions Box -->
            <div style="background: #fef3c7; border: 1px solid #fbbf24; border-radius: 6px; padding: 1rem; margin-bottom: 1.5rem;">
              <div style="display: flex; align-items: start; gap: 0.75rem;">
                <div style="color: #d97706; font-size: 1.25rem; line-height: 1; margin-top: 0.125rem;">⚠️</div>
                <div style="flex: 1;">
                  <div style="font-weight: 600; color: #92400e; font-size: 0.9rem; margin-bottom: 0.5rem;">Important: Data Loss Warning</div>
                  <ul style="margin: 0; padding-left: 1.25rem; color: #78350f; font-size: 0.85rem; line-height: 1.6;">
                    <li><strong>Removing keywords:</strong> All historical data (rankings, AI citations, SERP features) will be permanently deleted.</li>
                    <li><strong>Changing/renaming keywords:</strong> Treated as removing the old keyword and adding a new one. All data is lost and cannot be recovered.</li>
                    <li><strong>New keywords:</strong> Will appear in the list but won't have data until you run a "Ranking & AI check".</li>
                  </ul>
                  <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #fbbf24; color: #78350f; font-size: 0.85rem;">
                    <strong>Instructions:</strong> Enter one keyword per line. Changes will be saved immediately. Keywords will be updated on the next Ranking & AI check.
                    <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                      <label for="csv-upload" style="display: inline-flex; align-items: center; padding: 0.375rem 0.75rem; background: #3b82f6; color: white; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                        📄 Upload CSV
                        <input type="file" id="csv-upload" accept=".csv,.txt" style="display: none;" />
                      </label>
                      <span style="color: #78350f; font-size: 0.8rem;">Upload a CSV file (one keyword per line, first column)</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <textarea id="edit-keywords-textarea" style="width: 100%; min-height: 300px; padding: 0.75rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.9rem; font-family: inherit; resize: vertical; box-sizing: border-box; color: #1e293b; background: white;"></textarea>
            <div style="display: flex; justify-content: flex-end; gap: 0.75rem; margin-top: 1.5rem;">
              <button id="edit-keywords-cancel" style="padding: 0.5rem 1rem; background: #f1f5f9; color: #475569; border: 1px solid #cbd5e1; border-radius: 4px; cursor: pointer; font-size: 0.9rem;">Cancel</button>
              <button id="edit-keywords-save" style="padding: 0.5rem 1rem; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; font-weight: 600;">Save Keywords</button>
            </div>
            <div id="edit-keywords-status" style="margin-top: 1rem; font-size: 0.85rem; color: #475569; min-height: 1.5rem;"></div>
          </div>
        </div>

        <!-- Section B: Metric pills row -->
        <div class="ranking-metric-pills">
          <div class="metric-pill metric-pill--neutral" id="ranking-card-tracked">
            <div class="metric-pill-value" data-field="value">–</div>
            <div class="metric-pill-label">Tracked keywords</div>
            <div class="metric-pill-status" data-field="status">Info only</div>
            <div class="metric-pill-footer">Used across Visibility &amp; Authority behaviour/ranking.</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-tracked')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-tracked-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-ai-coverage">
            <div class="metric-pill-value" data-field="value">–</div>
            <div class="metric-pill-label">AI Overview coverage</div>
            <div class="metric-pill-status" data-field="status">–</div>
            <div class="metric-pill-footer">Pillars: Visibility, Content/Schema</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-ai-coverage')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-ai-coverage-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-ai-citations">
            <div class="metric-pill-value" data-field="value">–</div>
            <div class="metric-pill-label">AI citations (alanranger.com)</div>
            <div class="metric-pill-status" data-field="status">–</div>
            <div class="metric-pill-footer">Pillars: Authority (Reviews), Content/Schema</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-ai-citations')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-ai-citations-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-top10">
            <div class="metric-pill-value" data-field="value">–</div>
            <div class="metric-pill-label">Top-10 rank coverage</div>
            <div class="metric-pill-status" data-field="status">–</div>
            <div class="metric-pill-footer">Pillars: Visibility, Authority (Ranking)</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-top10')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-top10-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-serp-features">
            <div class="metric-pill-value" data-field="value">–</div>
            <div class="metric-pill-label">SERP feature coverage</div>
            <div class="metric-pill-status" data-field="status">–</div>
            <div class="metric-pill-footer">Pillars: Content/Schema, Local Entity</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-serp-features')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-serp-features-details"></div>
          </div>
        </div>

        <!-- Global Insights & actions and Visibility metrics side by side (underneath summary tiles) -->
        <div class="ranking-cards-side-by-side">
          <!-- Global Insights & actions (all tracked keywords) -->
          <section class="card card--insights" id="ranking-ai-insights-card-global">
            <div class="card-header">
              <h2>Insights &amp; actions (all tracked keywords)</h2>
              <p class="card-subtitle">
                Recommendations based on how your tracked keywords currently rank in classic search and appear in AI Overviews.
                These insights are global, not tied to the selected keyword.
              </p>
            </div>
            <div class="card-pill-container" id="ranking-ai-insights-list-global">
              <!-- Content populated by renderRankingAiInsights -->
            </div>
          </section>

          <!-- Tracked keyword visibility metrics (DataForSEO only - not part of GAIO pillars) -->
          <div class="ranking-visibility-metrics-section" id="ranking-visibility-metrics">
            <div class="card" style="background: rgba(204, 255, 255, 0.15); border-left: 4px solid #CCFFFF;">
            <div class="card-header">
              <h4 style="font-size: 14pt !important; margin-bottom: 0.5rem;">Tracked keyword visibility (DataForSEO)</h4>
              <div style="font-size: 12pt !important; color: #666; margin-bottom: 0.75rem; line-height: 1.5;">
                <p style="margin-bottom: 0.5rem;">
                  These metrics use DataForSEO live rankings and Google Ads search volume for your tracked keyword set only.
                </p>
                <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                  <li><strong>Demand-weighted avg position</strong> – average Google rank where each keyword is weighted by its monthly search volume (high-demand terms pull this number more).</li>
                  <li><strong>Unweighted avg position</strong> – simple average rank across all tracked keywords, with each keyword counted equally.</li>
                </ul>
                <p style="margin-top: 0.5rem; margin-bottom: 0;">
                  These are diagnostic metrics for your tracked set; the main Visibility and Authority pillar scores are still calculated from full Google Search Console data across all queries and pages.
                </p>
              </div>
              <div style="display: flex; gap: 2rem; flex-wrap: wrap; font-size: 14pt !important; align-items: baseline;">
                <div>
                  <strong style="font-size: 13pt !important;">Demand-weighted avg position:</strong>
                  <span id="ranking-avg-position-weighted" style="font-weight: bold; color: #0284c7; font-size: 16pt !important; margin-left: 0.5rem;">—</span>
                  <span title="Average rank for tracked keywords where each rank is weighted by the keyword's monthly search volume from DataForSEO." style="margin-left: 0.25rem; opacity: 0.6; cursor: help; font-size: 12pt !important;">ℹ</span>
                </div>
                <div style="font-size: 12pt !important; color: #666;">
                  <strong>Unweighted avg position:</strong>
                  <span id="ranking-avg-position-unweighted" style="font-weight: normal; margin-left: 0.5rem;">—</span>
                  <span title="Simple average rank for all tracked keywords from DataForSEO, each keyword counted once." style="margin-left: 0.25rem; opacity: 0.6; cursor: help;">ℹ</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Keyword Priority Matrix (Impact × Difficulty) - Full width below side-by-side cards -->
        <div class="ranking-priority-matrix-section" id="ranking-priority-matrix-section" style="display: none; width: 100%; clear: both; float: none;">
          <div class="card" style="background: rgba(204, 255, 255, 0.15); border-left: 4px solid #CCFFFF; padding: 1.5rem;">
            <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Keyword Priority – Impact & Difficulty</h3>
            <p style="margin: 0 0 1rem 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
              Uses search volume share and current rank to surface the highest-impact keywords to work on.
              Impact is driven mainly by search volume share (global, not filter-relative) and opportunity score. Difficulty reflects current rank bucket (page 1 vs page 2+).
            </p>
            <div id="ranking-keyword-priority-matrix" style="background: #f8fafc; padding: 1rem; border-radius: 8px;">
              <!-- 3x3 grid rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Domain Strength (manual monthly snapshots) -->
        <div class="ranking-domain-strength-section" id="ranking-domain-strength-section" style="width: 100%; clear: both; float: none; margin: 1.5rem 0;">
          <div class="card" style="background: rgba(204, 255, 255, 0.15); border-left: 4px solid #CCFFFF; padding: 1.5rem;">
            <div style="display: flex; align-items: center; justify-content: space-between; gap: 1rem; flex-wrap: wrap;">
              <div>
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">
                  Domain Strength (Google – DataForSEO Labs)
                  <span
                    class="domain-strength-help"
                    title="Domain Strength (0–100) is a composite score based on DataForSEO Labs. It combines:&#10;• Estimated organic traffic value (visibility)&#10;• Total organic keywords (breadth)&#10;• Share of keywords ranking in Google’s top 10 (quality)&#10;We calculate it monthly and store history so you can see trends over time."
                  >?</span>
                </h3>
                <p style="margin: 0; font-size: 0.9rem; color: #64748b; line-height: 1.6;">
                  Manual monthly snapshots based on DataForSEO Labs <code style="font-size: 0.85rem;">domain_rank_overview</code>.
                  Uses visibility (ETV), breadth (ranking keywords), and top‑10 share to produce a 0–100 score.
                </p>
              </div>
              <div style="display: flex; gap: 0.75rem; align-items: center;">
                <button id="domain-strength-run-btn" class="btn btn-secondary" type="button">
                  Run Domain Strength Snapshot (Google)
                </button>
              </div>
            </div>

            <!-- Full-page progress overlay -->
            <div id="domain-strength-overlay" class="domain-strength-overlay">
              <div class="domain-strength-overlay-content">
                <div class="spinner"></div>
                <h3>Running Domain Strength Snapshot</h3>
                <p id="domain-strength-overlay-status">Fetching domain data from DataForSEO...</p>
              </div>
            </div>

            <!-- Completion modal -->
            <div id="domain-strength-completion-modal" class="domain-strength-overlay" style="display: none;">
              <div class="domain-strength-overlay-content" style="max-width: 500px;">
                <h3 style="margin: 0 0 1rem 0; font-size: 1.5rem; font-weight: 700; color: #1e293b;">✓ Snapshot Complete</h3>
                <div id="domain-strength-completion-stats" style="text-align: left; margin: 1.5rem 0;">
                  <!-- Stats will be inserted here -->
                </div>
                <button id="domain-strength-completion-close" class="btn btn-primary" style="margin-top: 1rem; width: 100%;">Close</button>
              </div>
            </div>

            <div class="domain-strength-summary-row">
              <div class="domain-strength-summary-card" id="domain-strength-summary-card">
                <div style="color:#64748b; font-size:0.95rem;">Loading domain strength…</div>
              </div>
              <div style="font-size: 0.875rem; color: #64748b; line-height: 1.6;">
                <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #475569;">Understanding Domain Strength:</p>
                <ul style="margin: 0; padding-left: 1.25rem; list-style-type: disc;">
                  <li style="margin-bottom: 0.25rem;"><strong>Strength score (0-100):</strong> Composite metric combining estimated organic traffic value (visibility), total organic keywords (breadth), and share of keywords ranking in Google's top 10 (quality).</li>
                  <li style="margin-bottom: 0.25rem;"><strong>Band:</strong> Qualitative classification: Very weak (0-19), Weak (20-39), Moderate (40-59), Strong (60-79), Very strong (80-100).</li>
                  <li style="margin-bottom: 0.25rem;"><strong>ETV:</strong> Estimated Traffic Value in USD. DataForSEO's estimate of monthly organic traffic value based on keyword rankings and search volume.</li>
                  <li style="margin-bottom: 0.25rem;"><strong>Top-10 keywords:</strong> Number of keywords ranking in Google's top 10 positions. Higher counts indicate broader keyword coverage.</li>
                  <li style="margin-bottom: 0.25rem;"><strong>Change:</strong> Change in Strength score compared to the previous snapshot. Positive values (green ↑) indicate improvement.</li>
                  <li><strong>12-month trend:</strong> Visual graph showing Strength score over the last 12 months. Each point represents a monthly snapshot.</li>
                </ul>
              </div>
            </div>

            <div id="domain-strength-run-status" style="margin-top: 0.75rem; font-size: 0.875rem; color: #64748b;"></div>
            <div class="ranking-table-wrapper" style="margin-top: 1rem; max-height: none;">
              <table class="ranking-table" id="domain-strength-table">
                <thead>
                  <tr>
                    <th data-sort="name" class="sortable" title="Domain name or label for this site">
                      <div>Name <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Domain name or label for this site">ℹ</div>
                    </th>
                    <th data-sort="segment" class="sortable" title="Category or ownership segment (e.g., 'Your site' for your primary domain, or competitor segment)">
                      <div>Domain type <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Category or ownership segment (e.g., 'Your site' for your primary domain, or competitor segment)">ℹ</div>
                    </th>
                    <th data-sort="score" class="sortable" title="Domain Strength score (0-100). Composite metric combining: Estimated organic traffic value (visibility), Total organic keywords (breadth), and Share of keywords ranking in Google's top 10 (quality). Higher scores indicate stronger domain authority.">
                      <div>Strength score <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Domain Strength score (0-100). Composite metric combining: Estimated organic traffic value (visibility), Total organic keywords (breadth), and Share of keywords ranking in Google's top 10 (quality). Higher scores indicate stronger domain authority.">ℹ</div>
                    </th>
                    <th data-sort="band" class="sortable" title="Qualitative band based on Strength score: Very weak (0-19), Weak (20-39), Moderate (40-59), Strong (60-79), Very strong (80-100)">
                      <div>Band <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Qualitative band based on Strength score: Very weak (0-19), Weak (20-39), Moderate (40-59), Strong (60-79), Very strong (80-100)">ℹ</div>
                    </th>
                    <th data-sort="etv" class="sortable" style="text-align:right;" title="Estimated Traffic Value (ETV). DataForSEO's estimate of monthly organic traffic value in USD based on keyword rankings and search volume. Higher values indicate more valuable organic traffic potential.">
                      <div style="text-align:right;">ETV <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Estimated Traffic Value (ETV). DataForSEO's estimate of monthly organic traffic value in USD based on keyword rankings and search volume. Higher values indicate more valuable organic traffic potential.">ℹ</div>
                    </th>
                    <th data-sort="top10" class="sortable" style="text-align:right;" title="Number of keywords ranking in Google's top 10 positions. Higher counts indicate broader keyword coverage and stronger domain authority across multiple search terms.">
                      <div style="text-align:right; line-height: 1.2;">Top‑10<br>keywords <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Number of keywords ranking in Google's top 10 positions. Higher counts indicate broader keyword coverage and stronger domain authority across multiple search terms.">ℹ</div>
                    </th>
                    <th data-sort="change" class="sortable" style="text-align:center;" title="Change in Strength score compared to the previous snapshot. Positive values (green ↑) indicate improvement, negative values (red ↓) indicate decline. Shows how domain strength is trending between snapshots.">
                      <div>Change <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Change in Strength score compared to the previous snapshot. Positive values (green ↑) indicate improvement, negative values (red ↓) indicate decline. Shows how domain strength is trending between snapshots.">ℹ</div>
                    </th>
                    <th style="text-align:center;" title="Visual trend graph showing Strength score over the last 12 months. Each point represents a monthly snapshot. Helps identify long-term trends and patterns in domain authority changes.">
                      <div>12‑month trend</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Visual trend graph showing Strength score over the last 12 months. Each point represents a monthly snapshot. Helps identify long-term trends and patterns in domain authority changes.">ℹ</div>
                    </th>
                    <th style="text-align:center;" title="Mark this domain as a competitor">
                      <div>Competitor</div>
                    </th>
                  </tr>
                </thead>
                <tbody id="domain-strength-table-body">
                  <tr><td colspan="9" class="ranking-table-empty">No domain strength snapshots yet. Click "Run Domain Strength Snapshot".</td></tr>
                </tbody>
              </table>
            </div>
            <div id="domain-strength-pagination-controls" style="margin-top: 1rem; display: flex; justify-content: space-between; align-items: center; padding-top: 1rem; border-top: 1px solid #e2e8f0; flex-wrap: wrap; gap: 1rem;">
              <div style="font-size: 0.85rem; color: #64748b;">
                <span id="domain-strength-pagination-info">Page 1 of 1 • Total: 0</span>
              </div>
              <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  Rows per page:
                  <select id="domain-strength-rows-per-page" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; background: white; cursor: pointer;">
                    <option value="10" selected>10</option>
                    <option value="25">25</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                    <option value="all">All</option>
                  </select>
                </label>
                <button id="domain-strength-pagination-prev" type="button" disabled style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cbd5e1; background: #f1f5f9; cursor: not-allowed; color: #94a3b8; font-weight: 600;">
                  Previous
                </button>
                <button id="domain-strength-pagination-next" type="button" disabled style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cbd5e1; background: #f1f5f9; cursor: not-allowed; color: #94a3b8; font-weight: 600;">
                  Next
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Section C: Filters + full-width table -->
        <div class="ranking-table-section" style="width: 100%; clear: both; float: none;">
          <div class="card">
            <div class="card-header">
              <h3>Keyword rankings &amp; AI usage</h3>
              <p class="card-subtitle ranking-subtitle-tight" style="max-width: 100%; width: 100%;">
                Keyword-level inputs to <strong>Visibility</strong> and the <strong>Authority → Behaviour / Ranking</strong> components. Search volume shows demand for each tracked keyword (Visibility pillar). Combined with AI citations, it also highlights topics where you have strong or weak Authority. AI columns show where <strong>Content/Schema</strong> helps make you a source.
              </p>
            </div>
            <!-- Preset buttons -->
            <div class="ranking-presets-section" style="padding: 1rem 1.5rem; border-bottom: 1px solid #e2e8f0; background: #f8fafc;">
              <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center;">
                <span style="font-size: 0.875rem; font-weight: 600; color: #475569; margin-right: 0.5rem;">Presets:</span>
                <button type="button" class="ranking-preset-btn" data-preset="all" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Reset all filters and restore default sort">
                  All keywords
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="high-impact-money" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Segment: Money | Best rank: 11–20 | Search volume: High | Min opportunity: ≥ 65 | Sort: Opportunity ↓">
                  High-impact money
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="ai-overview-not-cited" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="AI Overview: On | AI citation: Not cited | Min opportunity: ≥ 50 | Sort: Volume ↓">
                  AI Overview, not cited
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="brand-safety" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Segment: Brand | Best rank: Not top 3 | Sort: Rank ↑ (worst first)">
                  Brand safety
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="education-growth" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Page type: Blog | Best rank: Not top 3 | Min opportunity: ≥ 30 | Sort: Opportunity ↓">
                  Blog opportunities
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="local-visibility" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Page type: GBP | Best rank: Not top 3 | Min opportunity: ≥ 30 | Sort: Opportunity ↓">
                  Local visibility
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="top-10-opportunities" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Best rank: Not top 3 | Min opportunity: ≥ 50 | Sort: Opportunity ↓ | Shows top 10 results">
                  Top 10 opportunities
                </button>
              </div>
              <!-- Criteria chips (shown when preset is active) -->
              <div id="ranking-preset-criteria-chips" style="display: none; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0;">
                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center;">
                  <!-- Chips will be inserted here by JavaScript -->
                </div>
              </div>
            </div>
            <div class="ranking-filters-section" style="padding: 1rem 1.5rem; border-bottom: 1px solid #e2e8f0;">
              <div class="ranking-filter-bar" style="display: flex; flex-wrap: nowrap; gap: 0.75rem; align-items: flex-end; margin-bottom: 0.75rem;">
                <div class="filter-group">
                  <label>Segment:</label>
                  <select id="ranking-filter-segment" class="filter-control">
                    <option value="all">All</option>
                    <option value="brand">Brand</option>
                    <option value="money">Money</option>
                    <option value="education">Education</option>
                    <option value="other">Other</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Best rank:</label>
                  <select id="ranking-filter-rank" class="filter-control">
                    <option value="all">All</option>
                    <option value="top3">Top 3</option>
                    <option value="4-10">4–10</option>
                    <option value="11-20">11–20</option>
                    <option value="21+">21+ / Not ranked</option>
                    <option value="not-top3">Not top 3</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Search volume:</label>
                  <select id="ranking-filter-volume" class="filter-control">
                    <option value="all">All</option>
                    <option value="high">High (200+)</option>
                    <option value="medium">Medium (50-199)</option>
                    <option value="low">Low (1-49)</option>
                    <option value="none">None</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>CTR:</label>
                  <select id="ranking-filter-ctr" class="filter-control">
                    <option value="all">All</option>
                    <option value="high">High (≥5%)</option>
                    <option value="medium">Medium (2-4.9%)</option>
                    <option value="low">Low (<2%)</option>
                    <option value="none">No data</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Opportunity score: <span title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10;• Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10;• Classic ranking strength (page 1 vs page 2+ and current position).&#10;• AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first.&#10;&#10;Bands: Low <40 · Medium 40–69 · High ≥70" style="opacity: 0.6; cursor: help;">ℹ</span></label>
                  <select id="ranking-filter-opportunity" class="filter-control">
                    <option value="all">All</option>
                    <option value="high">High (≥ 70)</option>
                    <option value="medium">Medium (40–69)</option>
                    <option value="low">Low (< 40)</option>
                  </select>
                </div>
                <div class="filter-group">
                  <label>Min opportunity:</label>
                  <input type="number" id="ranking-filter-min-opportunity" class="filter-control" placeholder="e.g. 65" min="0" max="100" step="1" style="width: 80px;">
                  <div id="ranking-filter-min-opportunity-note" style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem; display: none;">
                    Min opportunity overrides band selection.
                  </div>
                </div>

                <div class="filter-group">
                  <label>AI Overview:</label>
                  <select id="ranking-filter-ai-overview" class="filter-control">
                    <option value="all">All</option>
                    <option value="has">Has AI Overview</option>
                    <option value="no">No AI Overview</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>AI citation:</label>
                  <select id="ranking-filter-ai-citation" class="filter-control">
                    <option value="all">All</option>
                    <option value="cited">Cited in AI</option>
                    <option value="not-cited">Not cited</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Page type:</label>
                  <select id="ranking-filter-page-type" class="filter-control">
                    <option value="all">All</option>
                    <option value="GBP">GBP</option>
                    <option value="Blog">Blog</option>
                    <option value="Landing">Landing</option>
                    <option value="Event">Event</option>
                    <option value="Product">Product</option>
                    <option value="Other">Other</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>SERP features:</label>
                  <select id="ranking-filter-serp-features" class="filter-control">
                    <option value="all">All</option>
                    <option value="ai-overview">AI Overview</option>
                    <option value="local-pack">Local pack</option>
                    <option value="paa">People Also Ask</option>
                    <option value="featured-snippet">Featured snippet</option>
                    <option value="none">None</option>
                  </select>
                </div>
              </div>

              <div style="display: flex; gap: 0.75rem; align-items: flex-end;">
                <div class="filter-group filter-group-search" style="flex: 1; min-width: 300px;">
                  <label>Search:</label>
                  <input type="text" id="ranking-filter-keyword" class="filter-control" placeholder="Filter by keyword...">
                </div>

                <div class="filter-group filter-group-button" style="align-items: end;">
                  <button id="ranking-filter-clear" class="btn btn-small" style="width: 100%;">Clear filters</button>
                </div>
              </div>
            </div>
            <div class="ranking-table-wrapper" style="max-height: none;">
              <table class="ranking-table" id="ranking-ai-table">
                <thead>
                  <tr>
                    <th data-sort="keyword" class="sortable" title="The tracked keyword or search query.">
                      <div>Keyword <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="The tracked keyword or search query.">ℹ</div>
                    </th>
                    <th data-sort="segment" class="sortable" title="Keyword intent segment: Brand (branded queries), Money (commercial intent), Education (informational), or Other.">
                      <div>Segment <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Keyword intent segment: Brand (branded queries), Money (commercial intent), Education (informational), or Other.">ℹ</div>
                    </th>
                    <th data-sort="rank" class="sortable" title="Current organic search ranking position for this keyword. Lower numbers are better (1 is the top position).">
                      <div>Current organic rank <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Current organic search ranking position for this keyword. Lower numbers are better (1 is the top position).">ℹ</div>
                    </th>
                    <th data-sort="volume" class="sortable" title="Average monthly Google search volume for this keyword in the UK. Source: DataForSEO Labs – Keyword Overview.">
                      <div>Search volume <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Average monthly Google search volume for this keyword in the UK. Source: DataForSEO Labs – Keyword Overview.">ℹ</div>
                    </th>
                    <th data-sort="ctr" class="sortable" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days.">
                      <div>CTR (28d) <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days (matches GSC UI).">ℹ</div>
                    </th>
                    <th data-sort="impressions30d" class="sortable" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days.">
                      <div>Impressions (28d) <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days (matches GSC UI).">ℹ</div>
                    </th>
                    <th data-sort="opportunityScore" class="sortable" title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10;• Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10;• Classic ranking strength (page 1 vs page 2+ and current position).&#10;• AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first.">
                      <div>Opportunity score <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10;• Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10;• Classic ranking strength (page 1 vs page 2+ and current position).&#10;• AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first.">ℹ</div>
                    </th>
                    <th title="Whether Google AI Overview is present in SERP results for this keyword.">
                      <div>AI Overview</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Whether Google AI Overview is present in SERP results for this keyword.">ℹ</div>
                    </th>
                    <th data-sort="citations" class="sortable" title="Number of citations from your domain (alanranger.com) out of total citations in AI Overview for this keyword.">
                      <div>AI citations <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Number of citations from your domain (alanranger.com) out of total citations in AI Overview for this keyword.">ℹ</div>
                    </th>
                    <th title="This is the traditional blue link in SERP results.">
                      <div>Classic Ranking URL</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="This is the traditional blue link in SERP results.">ℹ</div>
                    </th>
                    <th data-sort="pageType" class="sortable" title="Type of page that ranks for this keyword: GBP (Google Business Profile), Landing (landing page), Event (event/workshop page), Product (product/service page), or Other.">
                      <div>Page type <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Type of page that ranks for this keyword: GBP (Google Business Profile), Landing (landing page), Event (event/workshop page), Product (product/service page), or Other.">ℹ</div>
                    </th>
                    <th title="Optimisation tracking status for this keyword and target URL. Shows whether optimisation work is planned, in progress, being monitored, or completed.">
                      <div>Optimisation</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Optimisation tracking status for this keyword and target URL. Shows whether optimisation work is planned, in progress, being monitored, or completed.">ℹ</div>
                    </th>
                  </tr>
                </thead>
                <tbody id="ranking-ai-table-body">
                  <tr><td colspan="12" class="ranking-table-empty">Click "Run ranking &amp; AI check" to load data.</td></tr>
                </tbody>
              </table>
            </div>
            <div class="ranking-pagination-controls" id="ranking-pagination-controls" style="display: none;">
              <div class="ranking-pagination-info" id="ranking-pagination-info">
                Showing 0-0 of 0
              </div>
              <div class="ranking-pagination-buttons">
                <button id="ranking-pagination-first" type="button">First</button>
                <button id="ranking-pagination-prev" type="button">Previous</button>
                <span id="ranking-pagination-page-info" style="padding: 0 0.5rem; font-size: 0.875rem;">Page 1 of 1</span>
                <button id="ranking-pagination-next" type="button">Next</button>
                <button id="ranking-pagination-last" type="button">Last</button>
              </div>
              <div class="ranking-rows-per-page">
                <label>Rows per page:</label>
                <select id="ranking-rows-per-page">
                  <option value="10" selected>10</option>
                  <option value="25">25</option>
                  <option value="50">50</option>
                  <option value="100">100</option>
                  <option value="all">All</option>
                </select>
              </div>
            </div>
          </div>
        </div>

        <!-- Section D: Keyword details & insights (three columns: 33% each) -->
        <div class="ranking-details-grid">
          <div class="card" id="ranking-ai-detail-card">
            <div class="card-header">
              <h3>Keyword Scorecard</h3>
              <p class="card-subtitle ranking-subtitle-tight">
                Detailed analysis of the selected keyword's impact, difficulty, and recommended actions. Shows demand, ranking strength, AI usage, and priority.
              </p>
            </div>
            <div class="ranking-ai-detail-body">
              <p id="ranking-ai-detail-empty">
                Select a keyword in the table or a cell in the priority grid to see a detailed scorecard.
              </p>
              <div id="ranking-ai-detail-content" class="ranking-ai-detail-content" hidden>
                <h4 id="ranking-ai-detail-keyword"></h4>
                <p id="ranking-ai-detail-summary"></p>
              </div>
            </div>
          </div>

          <div class="card" id="ranking-ai-competitors-card">
            <div class="card-header">
              <h3>Competitors in AI &amp; SERPs</h3>
              <p class="card-subtitle ranking-subtitle-tight">
                Domains that appear repeatedly in AI citations and/or classic top-10 rankings. Competitive backdrop for <strong>Authority</strong> and <strong>Visibility</strong>.
              </p>
            </div>
            <div style="padding: 0 1.25rem 1.25rem 1.25rem;">
              <div style="overflow-x: auto; max-width: 100%;">
                <table id="ranking-ai-competitors-table" style="width: 100%; border-collapse: collapse; table-layout: fixed; font-size: 0.8rem;">
                  <thead>
                    <tr style="background: #f1f5f9;">
                      <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 35%; word-wrap: break-word;">Domain</th>
                      <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 20%;">AI citations</th>
                      <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 25%;">Domain Rank</th>
                      <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 15%; word-wrap: break-word; line-height: 1.2;">
                        <div style="display: flex; flex-direction: column; align-items: flex-start;">
                          <span>Domain</span>
                          <span>type</span>
                        </div>
                      </th>
                      <th style="text-align: center; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 5%;">C</th>
                    </tr>
                  </thead>
                  <tbody id="ranking-ai-competitors-body"></tbody>
                </table>
              </div>
              <p style="margin: 0.75rem 0 0 0; font-size: 0.8rem; color: #64748b;">
                Domain Rank is sourced from your latest Domain Strength snapshot (0–100).
              </p>
            </div>
          </div>

          <div class="card" id="ranking-ai-citations-card">
            <div class="card-header">
              <h3>AI Citations for Selected Keyword</h3>
              <p class="card-subtitle ranking-subtitle-tight">
                Pages from alanranger.com and other domains cited in AI Overviews for the selected keyword.
              </p>
            </div>
            <div class="ranking-ai-detail-body">
              <p id="ranking-ai-citations-empty">
                Select a keyword in the table to see AI citations.
              </p>
              <div id="ranking-ai-citations-content" hidden>
                <p class="card-subtitle ranking-subtitle-tight" style="margin-bottom: 1rem;">
                  Pages from alanranger.com and other domains cited in AI Overviews for the selected keyword.
                </p>
                <h5>Your cited pages</h5>
                <ul id="ranking-ai-detail-our-pages" class="ranking-ai-detail-list"></ul>

                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                  <h5 style="margin: 0;">Other cited domains</h5>
                  <button id="backfill-domain-ranks-btn" onclick="backfillMissingDomainRanks()" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;" title="Fetch Domain Rank for domains currently showing '—'">Backfill Missing Ranks</button>
                </div>
                <div style="overflow-x: auto; margin-top: 0.5rem; max-width: 100%;">
                  <table id="ranking-ai-detail-competitors-table" style="width: 100%; border-collapse: collapse; table-layout: fixed; font-size: 0.8rem;">
                    <thead>
                      <tr style="background: #f1f5f9;">
                        <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 28%; word-wrap: break-word;">Domain</th>
                        <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 12%;">Citations</th>
                        <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 18%;">Domain Rank</th>
                        <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 16%; word-wrap: break-word; line-height: 1.2;">
                          <div style="display: flex; flex-direction: column; align-items: flex-start;">
                            <span>Domain</span>
                            <span>type</span>
                          </div>
                        </th>
                        <th style="text-align: center; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 26%;">Competitor</th>
                      </tr>
                    </thead>
                    <tbody id="ranking-ai-detail-competitors-body"></tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- AI Sources & Influence Panel -->
      <section class="aigeo-panel" data-panel="ai-sources">
        <div class="container" style="max-width: 1400px; margin: 0 auto; padding: 2rem;">
          <div class="card" style="margin-bottom: 2rem;">
            <div class="card-header">
              <h2>AI Sources & Influence</h2>
              <p class="card-subtitle">
                Domains that AI relies on most often when answering your tracked keywords. Identify which external sources you should strengthen or join so AI is more confident recommending you.
              </p>
            </div>
          </div>

          <!-- Summary Tiles -->
          <div id="ai-sources-tiles" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
            <!-- Tiles will be populated by JS -->
          </div>

          <!-- Source Types & Quick Insights -->
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 2rem;">
            <!-- Left: Source Types Overview -->
            <div class="card">
              <div class="card-header">
                <h3>Source Types Overview</h3>
              </div>
              <div class="card-body" id="ai-sources-types-breakdown">
                <p style="color: #64748b; text-align: center; padding: 2rem;">Loading source types...</p>
              </div>
            </div>

            <!-- Right: AI Influence Summary -->
            <div class="card ai-sources-explainer">
              <div class="card-header">
                <h3>How to read this tab</h3>
              </div>
              <div class="card-body">
                <p style="line-height: 1.6; margin-bottom: 0.75rem;">
                  This view shows the domains AI relies on most often when answering your tracked keywords.
                </p>
                <ul style="line-height: 1.8;">
                  <li>Repeated citations from the same domain signal trusted sources in your niche.</li>
                  <li>Directories and review platforms highlight places where you need consistent NAP, reviews and listings.</li>
                  <li>Course marketplaces and education sites show where learners are discovering alternatives to your workshops and lessons.</li>
                </ul>
                <p style="line-height: 1.6; margin-top: 0.75rem; font-weight: 600;">
                  The goal is to identify which external sources you should strengthen or join so AI is more confident recommending you.
                </p>
              </div>
            </div>
          </div>
        </div>

          <!-- Domain Influence Table -->
          <div class="card ai-sources-domain-table-card">
            <div class="card-header">
              <h3>Domain Influence Table</h3>
              <div style="display: flex; gap: 1rem; margin-top: 1rem; flex-wrap: wrap;">
                <div class="filter-group">
                  <label>Source type:</label>
                  <select id="ai-sources-filter-type" class="filter-control">
                    <option value="all">All</option>
                    <option value="Directory">Directory</option>
                    <option value="Review platform">Review platform</option>
                    <option value="Course marketplace / education">Course marketplace / education</option>
                    <option value="Publisher / blog">Publisher / blog</option>
                    <option value="Other">Other</option>
                  </select>
                </div>
                <div class="filter-group">
                  <label>Search:</label>
                  <input type="text" id="ai-sources-filter-domain" class="filter-control" placeholder="Filter by domain...">
                </div>
                <button id="ai-sources-filter-clear" class="btn btn-small">Clear filters</button>
              </div>
            </div>
            <div class="ranking-table-wrapper">
              <table class="ranking-table" id="ai-sources-table">
                <thead>
                  <tr>
                    <th data-sort="domain" class="sortable">Domain <span class="sort-indicator"></span></th>
                    <th data-sort="type" class="sortable">Type <span class="sort-indicator"></span></th>
                    <th data-sort="citations" class="sortable">AI citations <span class="sort-indicator"></span></th>
                    <th data-sort="keywords" class="sortable">Keywords <span class="sort-indicator"></span></th>
                    <th data-sort="share" class="sortable">Citation share <span class="sort-indicator"></span></th>
                    <th>Example page</th>
                  </tr>
                </thead>
                <tbody id="ai-sources-table-body">
                  <tr><td colspan="6" class="ranking-table-empty">Loading domain data...</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- Domain Detail Panel (Right Side) -->
          <div id="ai-sources-detail-panel" style="display: none; margin-top: 2rem;">
            <div class="card">
              <div class="card-header">
                <h3 id="ai-sources-detail-domain">Domain Details</h3>
                <p id="ai-sources-detail-meta" class="card-subtitle"></p>
              </div>
              <div class="card-body" id="ai-sources-detail-content">
                <!-- Content populated by JS -->
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Local & Reviews Panel -->
      <section class="aigeo-panel" data-panel="local">
        <!-- Local entity, GBP, reviews content will be inserted here by JS -->
      </section>

      <!-- History Panel -->
      <section class="aigeo-panel" data-panel="history">
        <!-- Supabase history charts / trend lines / previous audits will be inserted here by JS -->
      </section>

    </div>
      </div>
    </main>
    </div>

    <!-- Debug Panel - Fixed at bottom, collapsible -->
    <div class="debug-panel-bottom" id="debugPanel">
      <div class="debug-header" onclick="toggleDebugPanel()" style="cursor: pointer;">
        <h3>🔍 Debug Log</h3>
        <div class="debug-actions">
          <button class="btn btn-small" onclick="event.stopPropagation(); clearDebugLog();" title="Clear all debug log entries. Useful for starting fresh during troubleshooting.">Clear</button>
          <button class="btn btn-small" onclick="event.stopPropagation(); copyDebugLog();" title="Copy the entire debug log to your clipboard. Useful for sharing logs or troubleshooting issues.">Copy Log</button>
          <button class="btn btn-small" id="debugFilterBtn" onclick="event.stopPropagation(); toggleDebugLogFilter();" title="Filter to show only warnings and errors">Filter: All</button>
          <span id="debugToggleIcon" style="color: #fff; font-size: 1.2rem;">▼</span>
        </div>
      </div>
      <div class="debug-content" id="debugLog" style="display: block;">
        <div class="debug-log-entry info">
          <span class="debug-timestamp">[Initializing...]</span>Debug panel loaded. Waiting for page initialization...
        </div>
      </div>
    </div>
  </div>

  <script>
    // Immediate console log to verify script is running
    console.log('%c=== GAIO AUDIT DASHBOARD LOADED ===', 'color: #E57200; font-size: 16px; font-weight: bold;');
    console.log('%cDebug panel should be visible at bottom with orange border', 'color: #E57200; font-size: 14px;');
    console.log('Current time:', new Date().toISOString());
    console.log('Page URL:', window.location.href);
    
    // Helper function to safely save to localStorage (handles quota errors gracefully)
    // Define apiUrl helper IMMEDIATELY at the top level so it's available to all functions
    // This must be defined before any functions that use it
    (function() {
      const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
        ? 'https://ai-geo-audit.vercel.app' // Change this to your Vercel deployment URL
        : '';
      
      window.apiUrl = function apiUrl(path) {
        if (!API_BASE_URL) {
          // When deployed on Vercel, use relative paths
          return path.startsWith('/') ? path : `/${path}`;
        }
        // When running locally, prepend the Vercel URL
        // Handle paths with or without leading slash
        const cleanPath = path.startsWith('/') ? path : `/${path}`;
        return `${API_BASE_URL}${cleanPath}`;
      };
    })();
    
    // ======================
    // Optimisation Tracking Utilities (Phase 2)
    // ======================
    // Normalization functions matching DB helpers (arp_keyword_key, arp_clean_url)
    window.keywordKey = function keywordKey(keyword) {
      if (!keyword || typeof keyword !== 'string') return null;
      return keyword.trim().replace(/\s+/g, ' ').toLowerCase();
    };

    window.cleanUrlForKey = function cleanUrlForKey(url) {
      if (!url || typeof url !== 'string') return null;
      // Remove fragment (#)
      let cleaned = url.split('#')[0];
      // Remove query string (?)
      cleaned = cleaned.split('?')[0];
      // Remove protocol (http:// or https://)
      cleaned = cleaned.replace(/^https?:\/\//, '');
      // Remove trailing slashes
      cleaned = cleaned.replace(/\/+$/, '');
      return cleaned;
    };

    // Clean URL but keep protocol (for display in modals)
    window.cleanUrlForDisplay = function cleanUrlForDisplay(url) {
      if (!url || typeof url !== 'string') return '';
      // Remove fragment (#)
      let cleaned = url.split('#')[0];
      // Remove query string (?)
      cleaned = cleaned.split('?')[0];
      // Remove trailing slashes
      cleaned = cleaned.replace(/\/+$/, '');
      return cleaned;
    };

    // Admin key utilities (Phase A - Security)
    window.getAdminKey = function getAdminKey() {
      if (typeof window === "undefined") return "";
      return sessionStorage.getItem("arp_admin_key") || "";
    };

    window.setAdminKey = function setAdminKey(key) {
      if (typeof window === "undefined") return;
      sessionStorage.setItem("arp_admin_key", key);
    };

    window.hasAdminKey = function hasAdminKey() {
      return window.getAdminKey().length > 0;
    };

    window.clearAdminKey = function clearAdminKey() {
      if (typeof window === "undefined") return;
      sessionStorage.removeItem("arp_admin_key");
    };

    // Helper to build headers with admin key
    window.getOptimisationHeaders = function getOptimisationHeaders() {
      const headers = { 'Content-Type': 'application/json' };
      const adminKey = window.getAdminKey();
      if (adminKey) {
        headers['x-arp-admin-key'] = adminKey;
      }
      return headers;
    };

    // Cache for optimisation status (keyed by keyword_key::target_url_clean::task_type)
    window.optimisationStatusCache = new Map();

    // Fetch optimisation statuses in bulk
    window.fetchOptimisationStatuses = async function fetchOptimisationStatuses(rows) {
      if (!rows || rows.length === 0) {
        window.optimisationStatusCache.clear();
        return;
      }

      try {
        // Build unique set of keyword keys and URL keys
        const keywordKeys = new Set();
        const urlKeys = new Set();
        rows.forEach(row => {
          const kwKey = window.keywordKey(row.keyword);
          const url = row.best_url || row.targetUrl || row.ranking_url || '';
          const urlKey = window.cleanUrlForKey(url);
          if (kwKey) keywordKeys.add(kwKey);
          if (urlKey) urlKeys.add(urlKey);
        });

        if (keywordKeys.size === 0) {
          window.optimisationStatusCache.clear();
          return;
        }

        // Fetch from API endpoint (we'll create this)
        const response = await fetch(apiUrl('/api/optimisation/status'), {
          method: 'POST',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            keyword_keys: Array.from(keywordKeys),
            url_keys: Array.from(urlKeys)
          })
        });

        if (!response.ok) {
          console.warn('[Optimisation] Failed to fetch statuses:', response.status);
          window.optimisationStatusCache.clear();
          return;
        }

        const data = await response.json();
        window.optimisationStatusCache.clear();

        // Build cache map: key = keyword_key::target_url_clean::task_type
        (data.statuses || []).forEach(status => {
          const key = `${status.keyword_key}::${status.target_url_clean}::${status.task_type || 'on_page'}`;
          window.optimisationStatusCache.set(key, status);
        });

        console.log(`[Optimisation] Loaded ${window.optimisationStatusCache.size} status records`);
      } catch (error) {
        console.error('[Optimisation] Error fetching statuses:', error);
        window.optimisationStatusCache.clear();
      }
    };

    // Get optimisation status for a row
    window.getOptimisationStatus = function getOptimisationStatus(row, taskType = 'on_page') {
      const kwKey = window.keywordKey(row.keyword);
      const url = row.best_url || row.targetUrl || row.ranking_url || '';
      const urlKey = window.cleanUrlForKey(url);
      
      if (!kwKey || !urlKey) return null;
      
      const key = `${kwKey}::${urlKey}::${taskType}`;
      return window.optimisationStatusCache.get(key) || null;
    };

    // ======================
    // Optimisation Tracking Modals (Phase 2)
    // ======================
    
    // Open Track Keyword modal
    window.openTrackKeywordModal = function openTrackKeywordModal(row, taskType = 'on_page') {
      console.log('[Optimisation] openTrackKeywordModal called', { row, taskType });
      const modal = document.getElementById('optimisation-track-modal');
      if (!modal) {
        console.error('[Optimisation] Track modal not found');
        alert('Track modal not found. Please refresh the page.');
        return;
      }

      // Get and clean URL (remove query strings and fragments)
      const rawUrl = row.best_url || row.targetUrl || row.ranking_url || '';
      console.log('[Optimisation] Raw URL:', rawUrl);
      if (!window.cleanUrlForDisplay) {
        console.error('[Optimisation] cleanUrlForDisplay function not found');
        alert('Error: cleanUrlForDisplay function not found. Please refresh the page.');
        return;
      }
      const cleanedUrl = window.cleanUrlForDisplay(rawUrl);
      console.log('[Optimisation] Cleaned URL:', cleanedUrl);

      // Populate fields
      document.getElementById('track-keyword-text').textContent = row.keyword;
      document.getElementById('track-url-text').textContent = cleanedUrl; // Use .textContent for div
      document.getElementById('track-task-type').value = taskType;
      document.getElementById('track-status').value = 'planned';
      document.getElementById('track-title').value = '';
      document.getElementById('track-notes').value = '';

      // Store cleaned URL for submit
      modal.dataset.rowKeyword = row.keyword;
      modal.dataset.rowUrl = cleanedUrl;
      modal.dataset.taskType = taskType;

      modal.style.display = 'flex';
    };

    // Submit Track Keyword
    window.submitTrackKeyword = async function submitTrackKeyword() {
      const modal = document.getElementById('optimisation-track-modal');
      if (!modal) return;

      const keyword = modal.dataset.rowKeyword;
      // Get cleaned URL from dataset (already cleaned when modal opened)
      let targetUrl = modal.dataset.rowUrl || '';
      // Double-check it's cleaned (in case it was modified elsewhere)
      targetUrl = window.cleanUrlForDisplay(targetUrl);
      const taskType = modal.dataset.taskType || document.getElementById('track-task-type').value;
      const status = document.getElementById('track-status').value;
      const title = document.getElementById('track-title').value.trim();
      const notes = document.getElementById('track-notes').value.trim();

      if (!keyword || !targetUrl) {
        alert('Missing keyword or URL');
        return;
      }

      try {
        const response = await fetch(apiUrl('/api/optimisation/task'), {
          method: 'POST',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            keyword_text: keyword,
            target_url: targetUrl,
            task_type: taskType,
            status: status,
            title: title || null,
            notes: notes || null
          })
        });

        if (!response.ok) {
          if (response.status === 401) {
            throw new Error('Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.');
          }
          const error = await response.text();
          throw new Error(error || 'Failed to create task');
        }

        // Refresh status cache
        await window.fetchOptimisationStatuses([{ keyword, best_url: targetUrl }]);
        
        // Close modal
        modal.style.display = 'none';
        
        // Ensure Ranking & AI tab stays active and refresh table
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        if (rankingTab) {
          // Ensure tab is active
          document.querySelectorAll('.aigeo-panel').forEach(panel => panel.classList.remove('is-active'));
          rankingTab.classList.add('is-active');
          
          // Update nav button states
          document.querySelectorAll('.aigeo-nav button').forEach(btn => btn.classList.remove('is-active'));
          const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav button')).find(btn => 
            btn.textContent.includes('Ranking') || btn.getAttribute('data-tab') === 'ranking'
          );
          if (rankingNavBtn) rankingNavBtn.classList.add('is-active');
        }
        
        // Trigger table re-render
        if (typeof renderRankingAiTab === 'function') {
          await renderRankingAiTab();
        } else if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        } else {
          console.warn('[Optimisation] renderRankingAiTab not found, refreshing page');
          location.reload();
        }
      } catch (error) {
        console.error('[Optimisation] Error creating task:', error);
        alert('Failed to create task: ' + error.message);
      }
    };

    // Open Manage Optimisation modal
    window.openManageOptimisationModal = function openManageOptimisationModal(row, status, taskType = 'on_page') {
      const modal = document.getElementById('optimisation-manage-modal');
      if (!modal) {
        console.error('[Optimisation] Manage modal not found');
        return;
      }

      // Populate read-only fields
      document.getElementById('manage-keyword-text').textContent = row.keyword;
      document.getElementById('manage-url-text').textContent = window.cleanUrlForKey(row.best_url || row.targetUrl || row.ranking_url || '');
      document.getElementById('manage-task-type-text').textContent = taskType;
      document.getElementById('manage-status-text').textContent = status.status;
      document.getElementById('manage-cycle-text').textContent = status.cycle_active || 1;
      document.getElementById('manage-last-activity-text').textContent = status.last_activity_at 
        ? new Date(status.last_activity_at).toLocaleDateString()
        : 'Never';

      // Set current status in dropdown
      document.getElementById('manage-status-select').value = status.status;

      // Store data for submit
      modal.dataset.taskId = status.id;
      modal.dataset.rowKeyword = row.keyword;
      modal.dataset.rowUrl = row.best_url || row.targetUrl || row.ranking_url || '';
      modal.dataset.taskType = taskType;
      modal.dataset.currentCycle = status.cycle_active || 1;

      modal.style.display = 'flex';
    };

    // Submit status change
    window.submitStatusChange = async function submitStatusChange() {
      const modal = document.getElementById('optimisation-manage-modal');
      if (!modal || !modal.dataset.taskId) return;

      const taskId = modal.dataset.taskId;
      if (!taskId) {
        alert('Task ID missing');
        return;
      }
      
      const oldStatus = modal.dataset.currentStatus || document.getElementById('manage-status-select').value;
      const newStatus = document.getElementById('manage-status-select').value;

      if (oldStatus === newStatus) {
        alert('Status unchanged');
        return;
      }

      try {
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'PATCH',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            status: newStatus
          })
        });

        if (!response.ok) {
          let errorMessage = 'Failed to update status';
          try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
          } catch (e) {
            const errorText = await response.text();
            if (errorText) errorMessage = errorText;
          }
          if (response.status === 401) {
            errorMessage = 'Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.';
          }
          throw new Error(errorMessage);
        }

        // Refresh and close
        await window.fetchOptimisationStatuses([{
          keyword: modal.dataset.rowKeyword,
          best_url: modal.dataset.rowUrl
        }]);
        
        modal.style.display = 'none';
        
        // Ensure Ranking & AI tab stays active and refresh table
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        if (rankingTab) {
          document.querySelectorAll('.aigeo-panel').forEach(panel => panel.classList.remove('is-active'));
          rankingTab.classList.add('is-active');
          document.querySelectorAll('.aigeo-nav button').forEach(btn => btn.classList.remove('is-active'));
          const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav button')).find(btn => 
            btn.textContent.includes('Ranking') || btn.getAttribute('data-tab') === 'ranking'
          );
          if (rankingNavBtn) rankingNavBtn.classList.add('is-active');
        }
        
        // Trigger table re-render
        if (typeof renderRankingAiTab === 'function') {
          await renderRankingAiTab();
        } else if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        } else {
          console.warn('[Optimisation] renderRankingAiTab not found, refreshing page');
          location.reload();
        }
      } catch (error) {
        console.error('[Optimisation] Error updating status:', error);
        alert('Failed to update status: ' + error.message);
      }
    };

    // Start new cycle
    window.startNewCycle = async function startNewCycle() {
      const modal = document.getElementById('optimisation-manage-modal');
      if (!modal || !modal.dataset.taskId) return;

      const taskId = modal.dataset.taskId;
      const currentCycle = Number(modal.dataset.currentCycle) || 1;
      const newCycle = currentCycle + 1;

      try {
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/cycle`), {
          method: 'POST',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            cycle_active: newCycle
          })
        });

        if (!response.ok) {
          if (response.status === 401) {
            throw new Error('Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.');
          }
          throw new Error('Failed to start new cycle');
        }

        // Refresh and close
        await window.fetchOptimisationStatuses([{
          keyword: modal.dataset.rowKeyword,
          best_url: modal.dataset.rowUrl
        }]);
        
        modal.style.display = 'none';
        
        // Ensure Ranking & AI tab stays active and refresh table
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        if (rankingTab) {
          document.querySelectorAll('.aigeo-panel').forEach(panel => panel.classList.remove('is-active'));
          rankingTab.classList.add('is-active');
          document.querySelectorAll('.aigeo-nav button').forEach(btn => btn.classList.remove('is-active'));
          const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav button')).find(btn => 
            btn.textContent.includes('Ranking') || btn.getAttribute('data-tab') === 'ranking'
          );
          if (rankingNavBtn) rankingNavBtn.classList.add('is-active');
        }
        
        // Trigger table re-render
        if (typeof renderRankingAiTab === 'function') {
          await renderRankingAiTab();
        } else if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        } else {
          console.warn('[Optimisation] renderRankingAiTab not found, refreshing page');
          location.reload();
        }
      } catch (error) {
        console.error('[Optimisation] Error starting new cycle:', error);
        alert('Failed to start new cycle: ' + error.message);
      }
    };

    // Stop tracking
    window.stopTracking = async function stopTracking() {
      const modal = document.getElementById('optimisation-manage-modal');
      if (!modal || !modal.dataset.taskId) return;

      if (!confirm('Stop tracking this keyword? The task will be marked as cancelled but history will be preserved.')) {
        return;
      }

      const taskId = modal.dataset.taskId;

      try {
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'PATCH',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            status: 'cancelled'
          })
        });

        if (!response.ok) {
          throw new Error('Failed to stop tracking');
        }

        // Refresh and close
        await window.fetchOptimisationStatuses([{
          keyword: modal.dataset.rowKeyword,
          best_url: modal.dataset.rowUrl
        }]);
        
        modal.style.display = 'none';
        
        // Ensure Ranking & AI tab stays active and refresh table
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        if (rankingTab) {
          document.querySelectorAll('.aigeo-panel').forEach(panel => panel.classList.remove('is-active'));
          rankingTab.classList.add('is-active');
          document.querySelectorAll('.aigeo-nav button').forEach(btn => btn.classList.remove('is-active'));
          const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav button')).find(btn => 
            btn.textContent.includes('Ranking') || btn.getAttribute('data-tab') === 'ranking'
          );
          if (rankingNavBtn) rankingNavBtn.classList.add('is-active');
        }
        
        // Trigger table re-render
        if (typeof renderRankingAiTab === 'function') {
          await renderRankingAiTab();
        } else if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        } else {
          console.warn('[Optimisation] renderRankingAiTab not found, refreshing page');
          location.reload();
        }
      } catch (error) {
        console.error('[Optimisation] Error stopping tracking:', error);
        alert('Failed to stop tracking: ' + error.message);
      }
    };

    // ======================
    // GSC Date Range Configuration
    // ======================
    // Centralized constant for GSC window (matches GSC UI default)
    const GSC_WINDOW_DAYS = 28;
    
    /**
     * Get GSC date range helper (matches backend utils.js getGscDateRange)
     * @param {number} daysBack - Number of days to look back (default: GSC_WINDOW_DAYS)
     * @param {number} endOffsetDays - Days to subtract from today for end date (default: 1 = yesterday)
     * @returns {Object} { startDate, endDate } as ISO strings (YYYY-MM-DD)
     */
    function getGscDateRange(daysBack = GSC_WINDOW_DAYS, endOffsetDays = 1) {
      // End date = yesterday (matches GSC UI behavior - today is often partial)
      const end = new Date();
      end.setDate(end.getDate() - endOffsetDays);
      end.setHours(0, 0, 0, 0);
      
      // Start date = end date - (daysBack - 1) days (inclusive range)
      const start = new Date(end);
      start.setDate(start.getDate() - (daysBack - 1));
      start.setHours(0, 0, 0, 0);
      
      // Format as YYYY-MM-DD
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      return {
        startDate: formatDate(start),
        endDate: formatDate(end)
      };
    }
    
    function safeSetLocalStorage(key, value) {
      try {
        const valueString = typeof value === 'string' ? value : JSON.stringify(value);
        // Check size before saving (localStorage limit is typically 5-10MB)
        if (valueString.length > 4 * 1024 * 1024) {
          debugLog(`⚠ Data too large for localStorage (${Math.round(valueString.length / 1024)}KB), skipping save. Supabase is source of truth.`, 'warn');
          return false;
        }
        localStorage.setItem(key, valueString);
        return true;
      } catch (error) {
        if (error.name === 'QuotaExceededError' || error.message.includes('quota')) {
          debugLog(`⚠ localStorage quota exceeded for ${key}, skipping save. Supabase is source of truth.`, 'warn');
          return false;
        } else {
          debugLog(`✗ Error saving to localStorage (${key}): ${error.message}`, 'error');
          return false;
        }
      }
    }
    
    // ======================
    // CRITICAL: Define buildMoneyPageMetrics at GLOBAL SCOPE first
    // This ensures it's available when displayDashboard runs
    // ======================
    console.log('[Money Pages] Defining buildMoneyPageMetrics at global scope...');
    
    // Define helper functions that buildMoneyPageMetrics depends on (if not already defined)
    // These will be defined later in the script, but we need to ensure buildMoneyPageMetrics
    // can be called even if these helpers aren't ready yet
    
    // Placeholder - will be replaced by actual function when script loads
    // This is a fallback used only if no external Money Pages module is wired.
    // It returns empty metrics so the UI can show "No data" rather than crash.
    // Diagnostic function to check keyword matching issues AND missing search volume
    window.diagnoseKeywordMatching = function() {
      try {
        const savedAudit = loadAuditResultsSync();
        if (!savedAudit || !savedAudit.searchData) {
          debugLog('⚠ No audit data found. Cannot diagnose keyword matching.', 'warn');
          return;
        }
        
        // Get keywords from ranking data
        let rankingData = [];
        if (window.RankingAiModule && typeof window.RankingAiModule.state === 'function') {
          const state = window.RankingAiModule.state();
          rankingData = state.combinedRows || [];
        }
        
        if (!rankingData || rankingData.length === 0) {
          debugLog('⚠ No ranking keywords found. Cannot diagnose.', 'warn');
          return;
        }
        
        const allKeywords = rankingData.map(r => r.keyword).filter(k => k && k.trim());
        const queryTotals = savedAudit.searchData.queryTotals || [];
        
        debugLog(`📊 Diagnostic: Checking ${allKeywords.length} keywords`, 'info');
        
        // CRITICAL: Check for missing search_volume (this is what the UI shows as "—")
        const missingSearchVolume = [];
        const hasSearchVolume = [];
        
        rankingData.forEach(row => {
          const searchVolume = row.search_volume;
          // IMPORTANT: Only treat as missing if null/undefined, not if 0 (0 is a valid value)
          if (searchVolume == null || searchVolume === undefined) {
            missingSearchVolume.push({ keyword: row.keyword, search_volume: searchVolume });
          } else {
            hasSearchVolume.push({ keyword: row.keyword, search_volume: searchVolume });
          }
        });
        
        debugLog(`📊 Search Volume Analysis:`, 'info');
        debugLog(`  ✓ Has search volume: ${hasSearchVolume.length} keywords`, 'success');
        debugLog(`  ⚠ Missing search volume: ${missingSearchVolume.length} keywords`, missingSearchVolume.length > 0 ? 'warn' : 'success');
        if (missingSearchVolume.length > 0) {
          const missingList = missingSearchVolume.slice(0, 20).map(m => m.keyword).join(', ');
          debugLog(`  Missing search volume keywords: ${missingList}${missingSearchVolume.length > 20 ? ` ... (${missingSearchVolume.length - 20} more)` : ''}`, 'warn');
        }
        
        // Also check queryTotals matching (for impressions/CTR)
        const missingQueryTotals = [];
        const matchedQueryTotals = [];
        const zeroImpressionKeywords = [];
        
        allKeywords.forEach(keyword => {
          const normalizedKeyword = normalizeKeywordForMatching(keyword);
          const queryTotal = queryTotals.find(
            qt => {
              if (!qt.query) return false;
              const normalizedQuery = normalizeKeywordForMatching(qt.query);
              return normalizedQuery === normalizedKeyword || 
                     normalizedQuery.includes(normalizedKeyword) || 
                     normalizedKeyword.includes(normalizedQuery);
            }
          );
          
          if (!queryTotal) {
            missingQueryTotals.push(keyword);
          } else {
            matchedQueryTotals.push(keyword);
            if (queryTotal.impressions === 0 || queryTotal.impressions == null) {
              zeroImpressionKeywords.push({ keyword, query: queryTotal.query, impressions: queryTotal.impressions });
            }
          }
        });
        
        debugLog(`📊 QueryTotals Analysis (for impressions/CTR):`, 'info');
        debugLog(`  ✓ Matched: ${matchedQueryTotals.length} keywords`, 'success');
        debugLog(`  ⚠ Missing: ${missingQueryTotals.length} keywords`, missingQueryTotals.length > 0 ? 'warn' : 'info');
        if (missingQueryTotals.length > 0) {
          debugLog(`  Missing queryTotals: ${missingQueryTotals.slice(0, 20).join(', ')}${missingQueryTotals.length > 20 ? ` ... (${missingQueryTotals.length - 20} more)` : ''}`, 'warn');
        }
        
        debugLog(`📊 Zero impressions: ${zeroImpressionKeywords.length} keywords`, zeroImpressionKeywords.length > 0 ? 'info' : 'success');
        if (zeroImpressionKeywords.length > 0) {
          const sample = zeroImpressionKeywords.slice(0, 10).map(z => `${z.keyword} (query: "${z.query}", impressions: ${z.impressions})`).join(', ');
          debugLog(`Sample zero-impression keywords: ${sample}${zeroImpressionKeywords.length > 10 ? '...' : ''}`, 'info');
        }
        
        // Check for queries in queryTotals that don't match any keywords (orphaned queries)
        const orphanedQueries = queryTotals.filter(qt => {
          const normalizedQuery = normalizeKeywordForMatching(qt.query || '');
          return !allKeywords.some(k => {
            const normalizedKeyword = normalizeKeywordForMatching(k);
            return normalizedQuery === normalizedKeyword || 
                   normalizedQuery.includes(normalizedKeyword) || 
                   normalizedKeyword.includes(normalizedQuery);
          });
        });
        
        if (orphanedQueries.length > 0) {
          debugLog(`⚠ Found ${orphanedQueries.length} orphaned queries in queryTotals (don't match any keywords)`, 'warn');
          const sample = orphanedQueries.slice(0, 10).map(qt => qt.query || '(no query)').join(', ');
          debugLog(`Sample orphaned queries: ${sample}${orphanedQueries.length > 10 ? '...' : ''}`, 'warn');
        }
        
        return {
          totalKeywords: allKeywords.length,
          totalQueryTotals: queryTotals.length,
          // Search volume analysis (what UI shows as "—")
          missingSearchVolume: missingSearchVolume.length,
          missingSearchVolumeKeywords: missingSearchVolume,
          hasSearchVolume: hasSearchVolume.length,
          // QueryTotals analysis (for impressions/CTR)
          matched: matchedQueryTotals.length,
          missing: missingQueryTotals.length,
          missingKeywords: missingQueryTotals,
          zeroImpression: zeroImpressionKeywords.length,
          zeroImpressionKeywords: zeroImpressionKeywords,
          orphaned: orphanedQueries.length,
          orphanedQueries: orphanedQueries
        };
      } catch (error) {
        debugLog(`✗ Error diagnosing keyword matching: ${error.message}`, 'error');
        return null;
      }
    };
    
    // Function to check Supabase database for missing search volume
    window.checkSupabaseSearchVolume = async function() {
      try {
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (!propertyUrl) {
          debugLog('⚠ No property URL found. Cannot query Supabase.', 'warn');
          return;
        }
        
        debugLog(`📊 Querying Supabase for missing search volume...`, 'info');
        
        const response = await fetch(apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`));
        if (!response.ok) {
          const errorText = await response.text();
          debugLog(`⚠ Failed to fetch from Supabase: ${response.status} - ${errorText}`, 'warn');
          return;
        }
        
        const data = await response.json();
        if (data.status !== 'ok' || !data.data || !data.data.rankingAiData || !data.data.rankingAiData.combinedRows) {
          debugLog('⚠ No ranking data found in Supabase response', 'warn');
          return;
        }
        
        const keywords = data.data.rankingAiData.combinedRows || [];
        const missingSearchVolume = keywords.filter(k => k.search_volume == null || k.search_volume === undefined);
        const hasSearchVolume = keywords.filter(k => k.search_volume != null && k.search_volume !== undefined);
        
        debugLog(`📊 Supabase Search Volume Analysis:`, 'info');
        debugLog(`  Total keywords in DB: ${keywords.length}`, 'info');
        debugLog(`  ✓ Has search volume: ${hasSearchVolume.length} keywords`, 'success');
        debugLog(`  ⚠ Missing search volume: ${missingSearchVolume.length} keywords`, missingSearchVolume.length > 0 ? 'warn' : 'success');
        
        if (missingSearchVolume.length > 0) {
          const missingList = missingSearchVolume.slice(0, 30).map(k => k.keyword).join(', ');
          debugLog(`  Missing search volume keywords: ${missingList}${missingSearchVolume.length > 30 ? ` ... (${missingSearchVolume.length - 30} more)` : ''}`, 'warn');
        }
        
        return {
          total: keywords.length,
          hasSearchVolume: hasSearchVolume.length,
          missingSearchVolume: missingSearchVolume.length,
          missingKeywords: missingSearchVolume.map(k => k.keyword)
        };
      } catch (error) {
        debugLog(`✗ Error checking Supabase: ${error.message}`, 'error');
        return null;
      }
    };
    
    // Manual function to fetch and save queryTotals (for debugging/fixing missing data)
    window.fetchQueryTotalsManually = async function() {
      try {
        const savedAudit = loadAuditResultsSync();
        if (!savedAudit || !savedAudit.searchData) {
          debugLog('⚠ No audit data found in localStorage. Please run a full audit first.', 'warn');
          return;
        }
        
        // Get keywords from ranking data
        let rankingData = [];
        
        // Try to get from RankingAiModule state first
        if (window.RankingAiModule && typeof window.RankingAiModule.state === 'function') {
          const state = window.RankingAiModule.state();
          rankingData = state.combinedRows || [];
          debugLog(`📊 Found ${rankingData.length} keywords from RankingAiModule state`, 'info');
        }
        
        // Fallback: try to get from localStorage
        if (!rankingData || rankingData.length === 0) {
          try {
            const storedData = localStorage.getItem('ranking_ai_data');
            if (storedData) {
              const parsed = JSON.parse(storedData);
              if (parsed && parsed.combinedRows && Array.isArray(parsed.combinedRows)) {
                rankingData = parsed.combinedRows;
                debugLog(`📊 Found ${rankingData.length} keywords from localStorage`, 'info');
              }
            }
          } catch (e) {
            debugLog(`⚠ Failed to parse ranking data from localStorage: ${e.message}`, 'warn');
          }
        }
        
        // Fallback: try to get from saved audit's keyword_rankings
        if (!rankingData || rankingData.length === 0) {
          if (savedAudit.keywordRankings && Array.isArray(savedAudit.keywordRankings)) {
            rankingData = savedAudit.keywordRankings;
            debugLog(`📊 Found ${rankingData.length} keywords from saved audit`, 'info');
          }
        }
        
        if (!rankingData || rankingData.length === 0) {
          debugLog('⚠ No ranking keywords found. Please run the ranking scan first.', 'warn');
          return;
        }
        
        const allKeywords = rankingData.map(r => r.keyword).filter(k => k && k.trim());
        if (allKeywords.length === 0) {
          debugLog('⚠ No valid keywords found in ranking data.', 'warn');
          return;
        }
        
        debugLog(`📊 Manually fetching queryTotals for ${allKeywords.length} keywords...`, 'info');
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28');
        
        // Fetch queryTotals from GSC API
        const keywordsParam = encodeURIComponent(JSON.stringify(allKeywords));
        const propertyParam = encodeURIComponent(propertyUrl);
        const gscResponse = await fetch(apiUrl(`/api/aigeo/gsc-entity-metrics?property=${propertyParam}&keywords=${keywordsParam}&days=${dateRange}`));
        
        if (gscResponse.ok) {
          const gscData = await gscResponse.json();
          if (gscData.status === 'ok' && gscData.data && Array.isArray(gscData.data.queryTotals)) {
            const queryTotals = gscData.data.queryTotals;
            debugLog(`✓ Fetched queryTotals for ${queryTotals.length} keywords from GSC`, 'success');
            
            // Merge queryTotals into searchData
            savedAudit.searchData.queryTotals = queryTotals;
            
            // Use the SAME audit_date as the existing audit
            let auditDate = new Date().toISOString().split('T')[0];
            if (savedAudit.timestamp) {
              try {
                auditDate = new Date(savedAudit.timestamp).toISOString().split('T')[0];
              } catch (e) {
                // Use today as fallback
              }
            }
            
            // Save to Supabase
            const saveResponse = await fetch(apiUrl('/api/supabase/save-audit'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                propertyUrl: propertyUrl,
                auditDate: auditDate,
                searchData: savedAudit.searchData
              })
            });
            
            if (saveResponse.ok) {
              debugLog(`✓ Saved queryTotals to Supabase (${queryTotals.length} keywords)`, 'success');
              
              // Update localStorage
              try {
                safeSetLocalStorage('last_audit_results', savedAudit);
                debugLog(`✓ Updated localStorage with queryTotals`, 'success');
              } catch (localStorageErr) {
                debugLog(`⚠ Failed to update localStorage: ${localStorageErr.message}`, 'warn');
              }
              
              // Re-render the table to show the new data
              renderRankingAiTab();
              debugLog('✓ Table re-rendered with queryTotals data', 'success');
            } else {
              const errorText = await saveResponse.text();
              debugLog(`⚠ Failed to save queryTotals to Supabase: ${saveResponse.status} - ${errorText}`, 'warn');
            }
          } else {
            debugLog(`⚠ GSC API did not return queryTotals data`, 'warn');
          }
        } else {
          const errorText = await gscResponse.text();
          debugLog(`⚠ Failed to fetch queryTotals from GSC: ${gscResponse.status} - ${errorText}`, 'warn');
        }
      } catch (error) {
        debugLog(`✗ Error manually fetching queryTotals: ${error.message}`, 'error');
      }
    };
    
    window.buildMoneyPageMetrics = function(topPages, schemaAudit) {
      console.warn('[Money Pages] ⚠️ buildMoneyPageMetrics placeholder called - full implementation not loaded yet. This is a fallback to prevent crashes. The UI will show "No data" until the full implementation loads.');
      // Return empty array as fallback so UI can gracefully handle missing data
      return [];
    };
    
    console.log('[Money Pages] ✓ buildMoneyPageMetrics placeholder assigned to window');
    
    // ======================
    // Ranking & AI module - DEFINE FIRST to ensure it's available
    // ======================
    console.log('[RankingAiModule] Starting module definition at top of script...');
    window.RankingAiModule = (function () {
      console.log('[RankingAiModule] IIFE executing...');
      // Core tracked keywords. Real queries, no mock values.
      // Include both Money and Education terms.
      const TRACKED_KEYWORDS = [
        "alan ranger",
        "beginner photography classes",
        "beginner photography courses",
        "beginners photography course near me",
        "beginning photography lessons",
        "best photography classes",
        "best photography course",
        "best photography workshops",
        "camera courses for beginners",
        "commercial photographer",
        "commercial photography services",
        "corporate photography",
        "free online photography course",
        "hire a photographer",
        "hire a professional photographer",
        "landscape photography courses",
        "landscape photography workshop",
        "Landscape Photography Workshops",
        "landscape photography workshops uk",
        "landscape workshops",
        "lightroom courses",
        "one day photography workshops",
        "online photography courses",
        "online photography lesson",
        "photo editing course",
        "photo workshops",
        "photographer coventry",
        "photographer in coventry",
        "photographic workshops",
        "photography classes",
        "photography classes near me",
        "photography classes online",
        "photography course online",
        "photography courses",
        "photography courses coventry",
        "photography courses for beginners",
        "photography courses near me",
        "photography evening classes",
        "photography gift card",
        "photography gift voucher",
        "photography holidays uk",
        "photography lessons",
        "photography lessons near me",
        "photography lessons online",
        "photography masterclasses",
        "photography mentor",
        "photography presents",
        "photography training",
        "photography tuition",
        "photography tutor",
        "photography vouchers",
        "photography workshops",
        "photography workshops near me",
        "photography workshops uk",
        "private photography lessons",
        "private photography tuition",
        "professional commercial photography",
        "professional photographer",
        "professional photographer coventry",
        "professional photographer near me",
        "rps courses",
        "rps distinctions",
        "uk photography workshops"
      ];

      // API endpoints – adjust if the deployed paths differ.
      // window.apiUrl is already defined at the top level, so we can use it here
      // Also create a local const for use within this scope
      const apiUrl = window.apiUrl;
      
      const SERP_RANK_ENDPOINT = apiUrl('/api/aigeo/serp-rank-test');
      const AI_MODE_ENDPOINT = apiUrl('/api/aigeo/ai-mode-serp-batch-test'); // Using batch endpoint

      let hasLoadedOnce = false;
      let isLoading = false;
      let combinedRows = [];
      let summary = null;

      function normaliseKeyword(k) {
        return (k || "").trim().toLowerCase();
      }

      // Intent-based keyword segment classifier (client-side version)
      function classifyKeywordSegment(keyword, bestUrl) {
        if (!keyword || typeof keyword !== 'string') {
          return 'other';
        }
        
        const normalizedKeyword = keyword.trim().toLowerCase();
        
        // Priority 1: Brand (highest priority)
        const brandTerms = ['alan ranger', 'alanranger', 'alan ranger photography', 'photography academy', 'alan ranger academy'];
        if (brandTerms.some(term => normalizedKeyword.includes(term.toLowerCase()))) {
          return 'brand';
        }
        
        // Priority 2: Money (transactional OR local intent)
        const moneyTerms = ['lesson', 'lessons', 'class', 'classes', 'course', 'courses', 'training', 'workshop', 'workshops', 'mentoring', 'mentor', '1-2-1', '1:1', 'private', 'hire', 'service', 'services', 'photographer', 'booking', 'book', 'price', 'cost', 'voucher', 'gift'];
        const localModifiers = ['near me', 'in coventry', 'coventry', 'birmingham', 'warwick', 'leamington', 'solihull', 'rugby'];
        const hasMoneyTerm = moneyTerms.some(term => normalizedKeyword.includes(term.toLowerCase()));
        const hasLocalModifier = localModifiers.some(term => normalizedKeyword.includes(term.toLowerCase()));
        const hasPostcode = /\b([A-Z]{1,2}\d{1,2}\s?\d?[A-Z]{0,2})\b/i.test(normalizedKeyword);
        
        if (hasMoneyTerm || hasLocalModifier || hasPostcode) {
          return 'money';
        }
        
        // Priority 3: Education (informational/learning intent)
        const educationTerms = ['how to', 'what is', 'guide', 'tutorial', 'tips', 'settings', 'meaning', 'vs', 'difference', 'examples', 'best way to'];
        const techniqueTopics = ['aperture', 'shutter speed', 'iso', 'depth of field', 'histogram', 'dynamic range', 'composition'];
        const hasEducationTerm = educationTerms.some(term => normalizedKeyword.includes(term.toLowerCase()));
        const hasTechniqueTopic = techniqueTopics.some(term => normalizedKeyword.includes(term.toLowerCase()));
        
        if (hasEducationTerm || hasTechniqueTopic) {
          return 'education';
        }
        
        // Priority 4: Other (fallback)
        return 'other';
      }
      
      function classifyPageTypeForKeyword(bestUrl) {
        // Use shared classification function
        if (typeof window.classifyUrlForRankingAi === 'function') {
          const classification = window.classifyUrlForRankingAi(bestUrl || '');
          return classification.pageType;
        }
        return "Landing"; // Default fallback
      }

        const module = {
        TRACKED_KEYWORDS,
        SERP_RANK_ENDPOINT,
        AI_MODE_ENDPOINT,
        normaliseKeyword,
        classifyKeywordSegment,
        classifyPageTypeForKeyword,
        state: () => ({ hasLoadedOnce, isLoading, combinedRows, summary }),
        setLoadedOnce: (value) => { hasLoadedOnce = value; },
        setLoading: (value) => { isLoading = value; },
        setData: (rows, sum) => { 
          // Normalize rows: add segment_norm, segment_display, page_type_norm, page_type_display, impressions30d
          // Use window references since functions may be defined later
          const normSeg = window.normalizeSegment || ((input) => {
            const s = (input ?? "").trim().toLowerCase();
            return s.charAt(0).toUpperCase() + s.slice(1);
          });
          const segLabel = window.segmentLabel || ((s) => s);
          const normPageType = window.normalizePageType || ((pt) => {
            const k = (pt ?? "").trim().toLowerCase();
            return k.charAt(0).toUpperCase() + k.slice(1);
          });
          const pageTypeLab = window.pageTypeLabel || ((pt) => {
            const k = normPageType(pt);
            return k.charAt(0).toUpperCase() + k.slice(1);
          });
          // Get impressions30d for each row using getGscMetricsForKeywordRow (which returns impressions)
          const getGscMetrics = window.getGscMetricsForKeywordRow || (() => null);
          combinedRows = rows.map(r => {
            const segNorm = normSeg(r.segment);
            const segDisplay = segLabel(r.segment);
            const ptNorm = normPageType(r.pageType);
            const ptDisplay = pageTypeLab(r.pageType);
            // Get impressions30d from GSC data - use canonical targetUrl
            const pageUrlForGsc = r.targetUrl || r.ranking_url || r.best_url || '';
            const gscMetrics = getGscMetrics({ query: r.keyword, pageUrl: pageUrlForGsc });
            const impressions30d = gscMetrics && gscMetrics.impressions != null ? gscMetrics.impressions : null;
            return {
              ...r,
              segment_norm: segNorm,
              segment_display: segDisplay,
              page_type_norm: ptNorm,
              page_type_display: ptDisplay,
              impressions30d: impressions30d
            };
          });
          summary = sum; 
        }
      };
      console.log('[RankingAiModule] Module object created:', Object.keys(module));
      return module;
    })();
    
    console.log('[RankingAiModule] Assignment complete. window.RankingAiModule exists:', typeof window.RankingAiModule !== 'undefined');
    console.log('[RankingAiModule] window.RankingAiModule:', window.RankingAiModule);
    
    if (typeof window.RankingAiModule !== 'undefined') {
      console.log('[RankingAiModule] ✓ Successfully assigned to window');
      console.log('[RankingAiModule] TRACKED_KEYWORDS:', window.RankingAiModule.TRACKED_KEYWORDS);
    } else {
      console.error('[RankingAiModule] ✗ FAILED to assign to window');
    }
    
    // Debug logging system
    const debugLogEntries = [];
    let debugLogFilter = 'all'; // 'all', 'warnings-errors'
    
    function debugLog(message, type = 'info') {
      const timestamp = new Date().toISOString();
      const entry = {
        timestamp,
        message,
        type
      };
      debugLogEntries.push(entry);
      
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        // Check if entry should be displayed based on filter
        const shouldShow = debugLogFilter === 'all' || (debugLogFilter === 'warnings-errors' && (type === 'warn' || type === 'error'));
        
        if (shouldShow) {
        const entryDiv = document.createElement('div');
        entryDiv.className = `debug-log-entry ${type}`;
        entryDiv.innerHTML = `<span class="debug-timestamp">[${new Date(timestamp).toLocaleTimeString()}]</span>${message}`;
        logElement.appendChild(entryDiv);
        logElement.scrollTop = logElement.scrollHeight;
        }
      }
      
      // Only log critical errors to browser console (for debugging production issues)
      // All other logs go to UI debug console only
      if (type === 'error') {
        console.error(`[DEBUG ERROR]`, message);
      }
    }
    
    function toggleDebugLogFilter() {
      debugLogFilter = debugLogFilter === 'all' ? 'warnings-errors' : 'all';
      const filterBtn = document.getElementById('debugFilterBtn');
      if (filterBtn) {
        filterBtn.textContent = `Filter: ${debugLogFilter === 'all' ? 'All' : 'Warnings/Errors'}`;
      }
      
      // Re-render all log entries with current filter
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        logElement.innerHTML = '';
        debugLogEntries.forEach(entry => {
          const shouldShow = debugLogFilter === 'all' || (debugLogFilter === 'warnings-errors' && (entry.type === 'warn' || entry.type === 'error'));
          if (shouldShow) {
            const entryDiv = document.createElement('div');
            entryDiv.className = `debug-log-entry ${entry.type}`;
            entryDiv.innerHTML = `<span class="debug-timestamp">[${new Date(entry.timestamp).toLocaleTimeString()}]</span>${entry.message}`;
            logElement.appendChild(entryDiv);
          }
        });
        logElement.scrollTop = logElement.scrollHeight;
      }
    }

    function clearDebugLog() {
      debugLogEntries.length = 0;
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        logElement.innerHTML = '';
      }
      debugLog('Debug log cleared', 'info');
    }
    
    // Initialize filter button text on page load
    window.addEventListener('DOMContentLoaded', () => {
      const filterBtn = document.getElementById('debugFilterBtn');
      if (filterBtn) {
        filterBtn.textContent = `Filter: ${debugLogFilter === 'all' ? 'All' : 'Warnings/Errors'}`;
      }
    });

    function copyDebugLog() {
      // Filter entries based on current filter state
      const filteredEntries = debugLogEntries.filter(entry => {
        return debugLogFilter === 'all' || (debugLogFilter === 'warnings-errors' && (entry.type === 'warn' || entry.type === 'error'));
      });
      
      const logText = filteredEntries.map(entry => 
        `[${entry.timestamp}] [${entry.type.toUpperCase()}] ${entry.message}`
      ).join('\n');
      
      navigator.clipboard.writeText(logText).then(() => {
        debugLog(`Debug log copied to clipboard (${filteredEntries.length} ${debugLogFilter === 'all' ? 'entries' : 'warnings/errors'})`, 'success');
        showStatus(`Debug log copied! (${filteredEntries.length} ${debugLogFilter === 'all' ? 'entries' : 'warnings/errors'})`, 'success');
      }).catch(err => {
        debugLog('Failed to copy log: ' + err.message, 'error');
        showStatus('Failed to copy log', 'error');
      });
    }

    function toggleDebugPanel() {
      const panel = document.getElementById('debugPanel');
      const icon = document.getElementById('debugToggleIcon');
      if (panel.classList.contains('collapsed')) {
        panel.classList.remove('collapsed');
        if (icon) icon.textContent = '▼';
      } else {
        panel.classList.add('collapsed');
        if (icon) icon.textContent = '▲';
      }
    }

    // Performance optimization: Defer heavy work to improve INP
    function defer(fn) {
      if (window.requestIdleCallback) {
        requestIdleCallback(fn, { timeout: 800 });
      } else {
        setTimeout(fn, 0);
      }
    }

    const panelInitDone = new Set();

    function setActivePanel(panelId) {
      // 1) fast: toggle active nav styles
      document.querySelectorAll('.aigeo-nav-item').forEach(btn => {
        btn.classList.toggle('is-active', btn.dataset.panel === panelId);
        btn.setAttribute('aria-selected', btn.dataset.panel === panelId ? 'true' : 'false');
      });

      // 2) fast: show/hide panels only (NO rendering work here)
      document.querySelectorAll('.aigeo-panel').forEach(p => {
        const isActive = p.dataset.panel === panelId;
        p.classList.toggle('is-active', isActive);
        p.hidden = !isActive; // Explicitly set hidden attribute
      });
    }

    function ensurePanelRendered(panelId) {
      if (panelInitDone.has(panelId)) return;

      // IMPORTANT: only do heavy first-time render here
      // e.g. build big tables, compute summaries, populate dropdowns
      if (panelId === 'ranking') {
        // Fix DOM structure first
        fixRankingPanelStructure();
        // Load data and render ranking panel
        (async () => {
          debugLog('📊 Ranking panel: Loading data from storage...', 'info');
          const storedData = await loadRankingAiDataFromStorage(false);
          if (storedData && storedData.combinedRows && storedData.summary) {
            const mod = window.RankingAiModule;
            if (mod) {
              const normalizedSummary = normalizeSummaryFields(storedData.summary);
              mod.setData(storedData.combinedRows, normalizedSummary);
              mod.setLoadedOnce(true);
              renderRankingAiTab();
              const lastRunEl = document.getElementById("ranking-ai-last-run");
              if (lastRunEl && storedData.timestamp) {
                const date = new Date(storedData.timestamp);
                // Format in GMT/UTC: "DD MMM YYYY, HH:MM:SS GMT"
                const day = String(date.getUTCDate()).padStart(2, '0');
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const month = monthNames[date.getUTCMonth()];
                const year = date.getUTCFullYear();
                const hours = String(date.getUTCHours()).padStart(2, '0');
                const minutes = String(date.getUTCMinutes()).padStart(2, '0');
                const seconds = String(date.getUTCSeconds()).padStart(2, '0');
                const formatted = `${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
                lastRunEl.textContent = `Last run: ${formatted}`;
              }
            }
          } else {
            const mod = window.RankingAiModule;
            if (mod) {
              mod.setData([], { total_keywords: 0, keywords_with_rank: 0, keywords_with_ai_overview: 0, keywords_with_ai_citations: 0, top10: 0, top3: 0 });
              renderRankingAiTab();
            }
          }
          
          // CRITICAL: After initial render, check if queryTotals are available and re-render if needed
          // This ensures CTR/Impressions columns are populated even if loadAuditResults() completes after initial render
          (async () => {
            try {
              debugLog(`📊 Checking for queryTotals after initial render...`, 'info');
              const savedAudit = await loadAuditResults();
              debugLog(`📊 loadAuditResults() completed - savedAudit=${!!savedAudit}, searchData=${!!savedAudit?.searchData}, queryTotals=${savedAudit?.searchData?.queryTotals?.length || 0}`, savedAudit?.searchData?.queryTotals?.length > 0 ? 'success' : 'warn');
              if (savedAudit && savedAudit.searchData && Array.isArray(savedAudit.searchData.queryTotals) && savedAudit.searchData.queryTotals.length > 0) {
                debugLog(`✓ queryTotals loaded (${savedAudit.searchData.queryTotals.length} keywords), re-rendering table to show CTR/Impressions`, 'success');
                // Re-render the table to show CTR/Impressions data
                if (typeof renderRankingAiTab === 'function') {
                  renderRankingAiTab();
                  debugLog(`✓ Table re-rendered with queryTotals data`, 'success');
                } else {
                  debugLog(`⚠ renderRankingAiTab function not found`, 'warn');
                }
              } else {
                debugLog(`⚠ No queryTotals found in savedAudit - searchData=${!!savedAudit?.searchData}, queryTotals type=${typeof savedAudit?.searchData?.queryTotals}, length=${savedAudit?.searchData?.queryTotals?.length || 0}`, 'warn');
                if (savedAudit && savedAudit.searchData) {
                  debugLog(`⚠ searchData keys: ${Object.keys(savedAudit.searchData).join(', ')}`, 'warn');
                }
              }
            } catch (err) {
              debugLog(`⚠ Error loading queryTotals for re-render: ${err.message}`, 'error');
              debugLog(`⚠ Error stack: ${err.stack}`, 'error');
            }
          })();
          
          // Wire up filters and sorting after render
          setTimeout(() => {
            // Fix DOM structure after render
            fixRankingPanelStructure();
            if (typeof wireRankingAiButton === 'function') wireRankingAiButton();
            if (typeof wireRankingFilters === 'function') wireRankingFilters();
            if (typeof wireRankingSorting === 'function') wireRankingSorting();
            if (typeof wireRankingPagination === 'function') wireRankingPagination();
          }, 100);
        })();
      } else if (panelId === 'ai-sources') {
        setTimeout(() => {
          if (typeof wireAiSourcesFilters === 'function') wireAiSourcesFilters();
        }, 100);
        (async () => {
          debugLog('📊 AI Sources & Influence tab clicked - loading data...', 'info');
          const storedData = await loadRankingAiDataFromStorage(false);
          if (storedData && storedData.combinedRows && storedData.combinedRows.length > 0) {
            const mod = window.RankingAiModule;
            if (mod) {
              const normalizedSummary = normalizeSummaryFields(storedData.summary);
              mod.setData(storedData.combinedRows, normalizedSummary);
              debugLog(`✓ AI Sources tab: Rendering with ${storedData.combinedRows.length} keywords`, 'success');
              if (typeof renderAiSourcesTab === 'function') {
                renderAiSourcesTab();
              }
            }
          } else {
            debugLog('⚠ AI Sources tab: No keyword data available. Run a Ranking & AI check first.', 'warn');
            if (typeof renderAiSourcesTab === 'function') {
              renderAiSourcesTab(); // Will show empty state
            }
          }
        })();
      } else if (panelId === 'overview') {
        setTimeout(async () => {
          // Use async loadAuditResults to ensure we get latest data from Supabase (including localSignals with locations)
          const saved = await loadAuditResults();
          if (saved && saved.scores && saved.searchData) {
            const trendCanvas = document.getElementById('trendChart');
            if (trendCanvas && typeof displayDashboard === 'function') {
              debugLog('Re-rendering Score Trends chart for Overview tab', 'info');
              // DEBUG: Log localSignals structure when loading Overview tab
              if (saved.localSignals) {
                debugLog(`[Overview Tab] localSignals structure: status=${saved.localSignals.status}, hasData=${!!saved.localSignals.data}, hasLocations=${!!saved.localSignals.data?.locations}, locationsCount=${saved.localSignals.data?.locations?.length || 0}`, 'info');
              } else {
                debugLog(`[Overview Tab] ⚠️ localSignals is missing from saved audit data`, 'warn');
              }
              try {
                await displayDashboard(saved.scores, saved.searchData, saved.snippetReadiness || 0, saved.schemaAudit || null, saved.localSignals || null);
              } catch (err) {
                debugLog(`Error re-rendering trend chart: ${err.message}`, 'warn');
              }
            }
          }
        }, 200);
      } else if (panelId === 'money') {
        setTimeout(() => {
          const saved = loadAuditResultsSync();
          
          if (typeof renderMoneyPagesTable === 'function') {
            const priorityData = window.moneyPagePriorityData || (saved && saved.moneyPagePriorityData) || [];
            if (priorityData && priorityData.length > 0) {
              debugLog('Re-rendering Money Pages Priority Matrix table', 'info');
              renderMoneyPagesTable(priorityData);
            }
          }
          
          if (typeof renderMoneyPagesSection === 'function' && saved && saved.scores && saved.scores.moneyPagesMetrics) {
            debugLog('Re-rendering Money Pages section', 'info');
            renderMoneyPagesSection(saved.scores.moneyPagesMetrics);
            
            // Wait for HTML structure to be created before rendering charts
            setTimeout(() => {
              // Opportunity Mix: render after layout settles (Money tab activation can report 0x0)
              if (saved && saved.scores && saved.scores.moneyPagesMetrics && typeof renderMoneyPagesCategoryChart === 'function') {
                requestAnimationFrame(() => {
                  requestAnimationFrame(() => {
                    renderMoneyPagesCategoryChart(saved.scores.moneyPagesMetrics, 0);
                  });
                });
              }
            }, 200); // Give renderMoneyPagesSection time to create HTML structure
          } else if (saved && saved.scores && saved.scores.moneyPagesMetrics && typeof renderMoneyPagesCategoryChart === 'function') {
            // If renderMoneyPagesSection wasn't called, still try to render charts (structure might already exist)
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                renderMoneyPagesCategoryChart(saved.scores.moneyPagesMetrics, 0);
              });
            });
          }
          
          // Render charts only when panel is visible and canvas has dimensions
          // Wait a bit longer to ensure HTML structure is created
          setTimeout(() => {
            const renderMoneyCharts = () => {
            const moneyPanel = document.querySelector('.aigeo-panel[data-panel="money"]');
            const isPanelVisible = moneyPanel && moneyPanel.classList.contains('is-active') && 
                                   window.getComputedStyle(moneyPanel).display !== 'none';
            
            if (!isPanelVisible) {
              debugLog('⚠ Money Pages charts: Panel not visible yet, will retry', 'warn');
              setTimeout(renderMoneyCharts, 200);
              return;
            }
            
            const volumeCanvas = document.getElementById('moneyPagesVolumeChart');
            const rateCanvas = document.getElementById('moneyPagesRateChart');
            if ((volumeCanvas || rateCanvas) && typeof renderMoneyPagesTrendChart === 'function') {
              const volumeRect = volumeCanvas ? volumeCanvas.getBoundingClientRect() : { width: 0, height: 0 };
              const rateRect = rateCanvas ? rateCanvas.getBoundingClientRect() : { width: 0, height: 0 };
              if ((volumeRect.width === 0 || volumeRect.height === 0) && (rateRect.width === 0 || rateRect.height === 0)) {
                debugLog('⚠ Money Pages trend charts: Canvases have zero dimensions, will retry', 'warn');
                setTimeout(renderMoneyCharts, 200);
                return;
              }
              
              const propertyUrl = document.getElementById('propertyUrl')?.value;
              if (propertyUrl) {
                const endDate = new Date();
                const startDate = new Date();
                startDate.setFullYear(startDate.getFullYear() - 1);
                const startDateStr = startDate.toISOString().split('T')[0];
                const endDateStr = endDate.toISOString().split('T')[0];
                
                // Use apiUrl helper so this works both on Vercel and when opened locally (file://)
                const urlHelper = window.apiUrl || ((path) => {
                  const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || !window.location.hostname;
                  const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
                  const cleanPath = path.startsWith('/') ? path : `/${path}`;
                  return `${baseUrl}${cleanPath}`;
                });
                fetch(urlHelper(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDateStr}`))
                  .then(res => res.json())
                  .then(json => {
                    if (json.status === 'ok' && json.data) {
                      // Extract last GSC timeseries date from API response if available
                      if (json.timeseries && Array.isArray(json.timeseries) && json.timeseries.length > 0) {
                        const timeseriesDates = json.timeseries
                          .map(ts => ts.date)
                          .filter(date => date)
                          .sort()
                          .reverse();
                        if (timeseriesDates.length > 0) {
                          window.lastGscTimeseriesDate = timeseriesDates[0];
                          debugLog(`Money Pages Trend: Set last GSC timeseries date from API: ${window.lastGscTimeseriesDate}`, 'info');
                        }
                      } else {
                        debugLog(`Money Pages Trend: No timeseries data in API response`, 'warn');
                      }
                      
                      debugLog(`Money Pages Trend: About to render chart with ${json.data ? json.data.length : 0} history records`, 'info');
                      
                      requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                          const volumeCanvas = document.getElementById('moneyPagesVolumeChart');
                          const rateCanvas = document.getElementById('moneyPagesRateChart');
                          if (volumeCanvas && rateCanvas) {
                            const volumeRect = volumeCanvas.getBoundingClientRect();
                            const rateRect = rateCanvas.getBoundingClientRect();
                            debugLog(`Money Pages Trend: Canvas dimensions - Volume: ${volumeRect.width}x${volumeRect.height}, Rate: ${rateRect.width}x${rateRect.height}`, 'info');
                            if (volumeRect.width > 0 && volumeRect.height > 0 && rateRect.width > 0 && rateRect.height > 0) {
                              debugLog(`Money Pages Trend: Calling renderMoneyPagesTrendChart with ${json.data.length} records`, 'info');
                              renderMoneyPagesTrendChart(json.data);
                            } else {
                              debugLog('⚠ Money Pages trend charts: Canvases still have zero dimensions, retrying...', 'warn');
                              // Set explicit dimensions and retry
                              [volumeCanvas, rateCanvas].forEach(canvas => {
                                canvas.width = canvas.offsetWidth || canvas.parentElement?.clientWidth || 800;
                                canvas.height = canvas.offsetHeight || 300;
                              });
                              setTimeout(() => {
                                const volumeRect2 = volumeCanvas.getBoundingClientRect();
                                const rateRect2 = rateCanvas.getBoundingClientRect();
                                if (volumeRect2.width > 0 && volumeRect2.height > 0 && rateRect2.width > 0 && rateRect2.height > 0) {
                                  renderMoneyPagesTrendChart(json.data);
                                } else {
                                  setTimeout(() => renderMoneyCharts(), 200);
                                }
                              }, 100);
                            }
                          } else {
                            debugLog('⚠ Money Pages trend charts: Canvas elements not found', 'warn');
                          }
                        });
                      });
                    } else {
                      debugLog(`⚠ Money Pages trend chart: API returned error or no data. Status: ${json.status}`, 'warn');
                    }
                  })
                  .catch(err => {
                    debugLog(`✗ Error fetching history for trend chart: ${err.message}`, 'error');
                    debugLog(`Money Pages trend chart fetch error details: ${err.stack || err.toString()}`, 'error');
                  });
              }
            }
            
            const sparklineCanvas = document.getElementById('money-kpi-sparkline');
            if (sparklineCanvas && typeof loadAuditHistoryAndRenderKpis === 'function') {
              const rect = sparklineCanvas.getBoundingClientRect();
              if (rect.width === 0 || rect.height === 0) {
                debugLog('⚠ Money KPI sparkline: Canvas has zero dimensions, will retry', 'warn');
                setTimeout(renderMoneyCharts, 200);
                return;
              }
              
              const propertyUrl = document.getElementById('propertyUrl')?.value;
              if (propertyUrl) {
                requestAnimationFrame(() => {
                  requestAnimationFrame(() => {
                    const canvas = document.getElementById('money-kpi-sparkline');
                    if (canvas) {
                      const rect = canvas.getBoundingClientRect();
                      if (rect.width > 0 && rect.height > 0) {
                        loadAuditHistoryAndRenderKpis(propertyUrl);
                      } else {
                        debugLog('⚠ Money KPI sparkline: Canvas still has zero dimensions, retrying...', 'warn');
                        setTimeout(() => renderMoneyCharts(), 200);
                      }
                    }
                  });
                });
              }
            }
            };
            
            // Start rendering charts with retry logic
            renderMoneyCharts();
          }, 300); // Wait 300ms to ensure HTML structure is created
          
          // Wire up KPI metric selector
          if (typeof window.wireMoneyKpiMetricSelector === 'function') {
            window.wireMoneyKpiMetricSelector();
          }
          
          if (typeof window.wireTopLevelFilter === 'function') {
            window.wireTopLevelFilter();
          }
          if (typeof window.wirePriorityActionsFilters === 'function') {
            window.wirePriorityActionsFilters();
          }
        }, 100);
      }

      // Mark panel as initialized
      panelInitDone.add(panelId);
    }

    // Fix ranking panel DOM structure - ensure sections are siblings, not nested
    function fixRankingPanelStructure() {
      const rankingPanel = document.querySelector('.aigeo-panel[data-panel="ranking"]');
      if (!rankingPanel) return;

      const sideBySide = rankingPanel.querySelector('.ranking-cards-side-by-side');
      const priority = rankingPanel.querySelector('#ranking-priority-matrix-section');
      const table = rankingPanel.querySelector('.ranking-table-section');
      const details = rankingPanel.querySelector('.ranking-details-grid');

      if (!sideBySide) return;

      // Check if sections are incorrectly nested inside side-by-side container
      const sideBySideChildren = Array.from(sideBySide.children);
      const needsFix = sideBySideChildren.includes(priority) || 
                       sideBySideChildren.includes(table) || 
                       sideBySideChildren.includes(details);

      if (needsFix) {
        // Move sections out of side-by-side container to be siblings
        if (priority && sideBySide.contains(priority)) {
          sideBySide.parentElement.insertBefore(priority, sideBySide.nextSibling);
        }
        if (table && sideBySide.contains(table)) {
          sideBySide.parentElement.insertBefore(table, priority?.nextSibling || sideBySide.nextSibling);
        }
        if (details && sideBySide.contains(details)) {
          sideBySide.parentElement.insertBefore(details, table?.nextSibling || priority?.nextSibling || sideBySide.nextSibling);
        }
      }

      // Ensure correct order: side-by-side, priority, table, details
      const allSections = [sideBySide, priority, table, details].filter(Boolean);
      allSections.forEach((section, index) => {
        if (section.parentElement === rankingPanel) {
          const currentIndex = Array.from(rankingPanel.children).indexOf(section);
          const expectedIndex = Array.from(rankingPanel.children).indexOf(allSections[0]) + index;
          if (currentIndex !== expectedIndex && expectedIndex >= 0) {
            rankingPanel.insertBefore(section, rankingPanel.children[expectedIndex] || null);
          }
        }
      });
    }

    function toggleCalculationExplanation() {
      const explanation = document.getElementById('calculationExplanation');
      const content = document.getElementById('calculationContent');
      const toggle = document.getElementById('calculationToggle');
      if (explanation.classList.contains('collapsed')) {
        explanation.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '▼';
      } else {
        explanation.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '▶';
      }
    }

    function toggleFrameworkExplanation() {
      const explanation = document.getElementById('frameworkExplanation');
      const content = document.getElementById('frameworkContent');
      const toggle = document.getElementById('frameworkToggle');
      if (!explanation || !content) return;
      if (explanation.classList.contains('collapsed')) {
        explanation.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '▼';
      } else {
        explanation.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '▶';
      }
    }
    
    window.toggleCsvSection = function(sectionId) {
      const section = document.getElementById(sectionId);
      const contentId = sectionId === 'urlListSection' ? 'urlListContent' : 'backlinkCsvContentWrapper';
      const toggleId = sectionId === 'urlListSection' ? 'urlListToggle' : 'backlinkCsvToggle';
      const content = document.getElementById(contentId);
      const toggle = document.getElementById(toggleId);
      
      if (section.classList.contains('collapsed')) {
        section.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '▼';
      } else {
        section.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '▶';
      }
    }

    // Debug panel is always visible at bottom, start collapsed by default
    window.addEventListener('DOMContentLoaded', () => {
      const debugPanel = document.getElementById('debugPanel');
      const debugToggleIcon = document.getElementById('debugToggleIcon');
      if (debugPanel) {
        debugPanel.style.display = 'flex';
        // Start collapsed by default
        debugPanel.classList.add('collapsed');
        if (debugToggleIcon) {
          debugToggleIcon.textContent = '▲';
        }
      }
    });

    // Initialize Money Pages Priority Matrix global state early
    window.moneyPagePriorityData = window.moneyPagePriorityData || [];
    window.moneySegmentMetrics = window.moneySegmentMetrics || null;
    window.moneyMatrixFilterState = window.moneyMatrixFilterState || { impact: null, diff: null };
    
    // Verify RankingAiModule is available
    if (typeof window.RankingAiModule === 'undefined') {
      debugLog('⚠ RankingAiModule not found in window on page load', 'warn');
    } else {
      debugLog('✓ RankingAiModule verified on page load', 'success');
    }

    // Fix ranking panel structure on page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(fixRankingPanelStructure, 100);
      });
    } else {
      setTimeout(fixRankingPanelStructure, 100);
    }

    // Load saved configuration
    async function loadConfig() {
      debugLog('=== PAGE LOAD: Starting configuration load ===', 'info');
      
      // Check if Chart.js is loaded
      debugLog('Checking Chart.js library...', 'info');
      if (typeof Chart !== 'undefined') {
        debugLog('✓ Chart.js library loaded successfully', 'success');
      } else {
        debugLog('✗ Chart.js library NOT loaded', 'error');
      }
      
      // Try to fetch API key from Vercel environment variable (via API endpoint)
      let vercelApiKey = null;
      try {
        debugLog('Checking Vercel environment variable...', 'info');
        const response = await fetch(apiUrl('/api/get-api-key'));
        if (response.ok) {
          const data = await response.json();
          if (data.apiKey) {
            vercelApiKey = data.apiKey;
            debugLog('✓ API key loaded from Vercel environment variable', 'success');
          }
        }
      } catch (e) {
        debugLog('Vercel env var endpoint not available (expected for static site)', 'info');
      }
      
      // Check config.js
      debugLog('Checking for config.js...', 'info');
      if (window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey) {
        debugLog('✓ config.js found with API key', 'success');
      } else {
        debugLog('✗ config.js not found or no API key', 'warn');
      }
      
      // Check localStorage
      debugLog('Checking localStorage...', 'info');
      const configApiKey = window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey;
      const apiKey = vercelApiKey || configApiKey || localStorage.getItem('gsc_api_key');
      const propertyUrl = localStorage.getItem('gsc_property_url');
      const dateRange = localStorage.getItem('gsc_date_range');
      
      const apiKeySource = vercelApiKey ? 'Vercel env var' : configApiKey ? 'config.js' : localStorage.getItem('gsc_api_key') ? 'localStorage' : 'none';
      debugLog(`API Key source: ${apiKeySource}`, 'info');
      debugLog(`Property URL: ${propertyUrl || 'not set'}`, 'info');
      debugLog(`Date Range: ${dateRange || 'not set'}`, 'info');
      
      if (apiKey) {
        debugLog('✓ API key loaded from environment', 'success');
        // Store in a hidden variable for use in runAudit
        window._loadedApiKey = apiKey;
      } else {
        debugLog('✗ No API key found', 'warn');
      }
      
      if (propertyUrl) {
        document.getElementById('propertyUrl').value = propertyUrl;
        debugLog('✓ Property URL loaded', 'success');
      }
      if (dateRange) {
        document.getElementById('dateRange').value = dateRange;
        // Set active button based on saved date range
        const savedDays = parseInt(dateRange);
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          btn.classList.remove('active');
          const btnDays = parseInt(btn.getAttribute('data-days'));
          if (btnDays === savedDays) {
            btn.classList.add('active');
          }
        });
        // If no preset matches, show custom
        const presetDays = [7, 30, 90, 180, 365];
        if (!presetDays.includes(savedDays)) {
          document.getElementById('customDateBtn').classList.add('active');
          document.getElementById('customDays').value = savedDays;
          document.getElementById('customDateRange').style.display = 'block';
        }
        debugLog('✓ Date range loaded', 'success');
      }
      
      // Load manual URL list if saved
      const savedUrlList = localStorage.getItem('manual_url_list');
      if (savedUrlList) {
        try {
          const urls = JSON.parse(savedUrlList);
          const statusDiv = document.getElementById('urlListStatus');
          if (statusDiv) {
            statusDiv.innerHTML = `<span style="color: #10b981;">✓ ${urls.length} URLs loaded from saved list</span>`;
          }
          debugLog(`✓ Manual URL list loaded: ${urls.length} URLs`, 'success');
        } catch (e) {
          debugLog('⚠ Failed to load saved URL list', 'warn');
        }
      }
      
      // Load backlink CSV content if saved
      const savedBacklinkCsv = localStorage.getItem('backlink_csv_content');
      if (savedBacklinkCsv) {
        const textarea = document.getElementById('backlinkCsvContent');
        if (textarea) {
          textarea.value = savedBacklinkCsv;
        }
        // Check if backlink metrics are already uploaded
        try {
          const backlinkResponse = await fetch(apiUrl('/api/aigeo/backlink-metrics'));
          if (backlinkResponse.ok) {
            const backlinkData = await backlinkResponse.json();
            if (backlinkData.status === 'ok' && backlinkData.data && backlinkData.data.totalBacklinks > 0) {
              const metrics = backlinkData.data;
              const statusDiv = document.getElementById('backlinkCsvStatus');
              if (statusDiv) {
                statusDiv.innerHTML = `<span style="color: #10b981;">✓ Backlink CSV loaded: ${metrics.referringDomains} domains, ${metrics.totalBacklinks} links</span>`;
              }
              debugLog(`✓ Backlink CSV already uploaded: ${metrics.referringDomains} domains`, 'success');
            }
          }
        } catch (e) {
          // Ignore errors - backlink metrics may not be uploaded yet
        }
      }
      
      debugLog('=== Configuration load complete ===', 'info');
    }

    // Save configuration
    // Date range selector functions
    function setDateRange(days) {
      const oldDateRange = parseInt(document.getElementById('dateRange').value) || 30;
      document.getElementById('dateRange').value = days;
      localStorage.setItem('gsc_date_range', days);
      
      // Update active button
      document.querySelectorAll('.date-range-btn').forEach(btn => {
        btn.classList.remove('active');
        const btnDays = parseInt(btn.getAttribute('data-days'));
        if (btnDays === days) {
          btn.classList.add('active');
        }
      });
      
      // Hide custom input if showing
      document.getElementById('customDateRange').style.display = 'none';
      document.getElementById('customDateBtn').classList.remove('active');
      
      debugLog(`Date range set to ${days} days`, 'info');
      
      // Check if saved audit exists and if its date range matches
      const savedAudit = loadAuditResultsSync();
      if (savedAudit && savedAudit.scores) {
        const savedDateRange = savedAudit.dateRange || oldDateRange;
        // Always update if date range changed (even if going back to a previous range)
        // This ensures charts refresh properly when switching between ranges
        if (savedDateRange !== days) {
          // Date range changed - update GSC data and recalculate scores
          debugLog(`Date range changed from ${savedDateRange} to ${days} days. Updating metrics...`, 'info');
          updateAuditForNewDateRange(days, savedAudit);
        } else {
          // Date range matches, but force refresh to ensure charts are updated
          // This handles the case where user switches back to the same range
          debugLog(`Date range is already ${days} days, but refreshing charts to ensure they're up to date...`, 'info');
          // Force a refresh by calling displayDashboard with current data
          if (savedAudit.scores && savedAudit.searchData) {
            displayDashboard(savedAudit.scores, savedAudit.searchData, savedAudit.snippetReadiness, savedAudit.schemaAudit, savedAudit.localSignals);
          }
        }
      }
    }

    function showCustomDateRange() {
      const customDiv = document.getElementById('customDateRange');
      const customBtn = document.getElementById('customDateBtn');
      
      if (customDiv.style.display === 'none') {
        customDiv.style.display = 'block';
        customBtn.classList.add('active');
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          if (btn !== customBtn) btn.classList.remove('active');
        });
      } else {
        customDiv.style.display = 'none';
        customBtn.classList.remove('active');
      }
    }

    function applyCustomDateRange() {
      const customDays = parseInt(document.getElementById('customDays').value);
      if (customDays && customDays > 0) {
        const oldDateRange = parseInt(document.getElementById('dateRange').value) || 30;
        document.getElementById('dateRange').value = customDays;
        localStorage.setItem('gsc_date_range', customDays);
        document.getElementById('customDateRange').style.display = 'none';
        document.getElementById('customDateBtn').classList.remove('active');
        debugLog(`Custom date range set to ${customDays} days`, 'info');
        
        // Check if saved audit exists and if its date range matches
        const savedAudit = loadAuditResultsSync();
        if (savedAudit && savedAudit.scores) {
          const savedDateRange = savedAudit.dateRange || oldDateRange;
          if (savedDateRange !== customDays) {
            // Date range changed - update GSC data and recalculate scores
            debugLog(`Date range changed from ${savedDateRange} to ${customDays} days. Updating metrics...`, 'info');
            updateAuditForNewDateRange(customDays, savedAudit);
          }
        }
      } else {
        showStatus('Please enter a valid number of days', 'error');
      }
    }

    function saveConfig() {
      localStorage.setItem('gsc_api_key', document.getElementById('apiKey').value);
      localStorage.setItem('gsc_property_url', document.getElementById('propertyUrl').value);
      localStorage.setItem('gsc_date_range', document.getElementById('dateRange').value);
      showStatus('Configuration saved!', 'success');
    }

    // Parse CSV and validate column names
    function parseUrlListCsv(csvText) {
      const lines = csvText.split('\n').filter(line => line.trim());
      if (lines.length === 0) {
        throw new Error('CSV is empty');
      }
      
      // Parse header row
      const headerLine = lines[0].trim();
      const headers = headerLine.split(',').map(h => h.trim().replace(/^"|"$/g, '').toLowerCase());
      
      // Check for required 'url' column
      const urlColumnIndex = headers.findIndex(h => h === 'url');
      if (urlColumnIndex === -1) {
        throw new Error(`Required column 'url' not found. Found columns: ${headers.join(', ')}`);
      }
      
      // Extract URLs from the 'url' column
      const urls = [];
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        // Parse CSV line (handle quoted values)
        const columns = [];
        let current = '';
        let inQuotes = false;
        
        for (let j = 0; j < line.length; j++) {
          const char = line[j];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            columns.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        columns.push(current.trim()); // Add last column
        
        // Extract URL from the url column
        if (columns[urlColumnIndex]) {
          const url = columns[urlColumnIndex].replace(/^"|"$/g, '').trim();
          if (url && url.startsWith('http')) {
            urls.push(url);
          }
        }
      }
      
      return {
        headers,
        urls,
        totalRows: lines.length - 1,
        validUrls: urls.length
      };
    }

    // Load URL list from file input
    async function loadUrlListFromFile() {
      const fileInput = document.getElementById('urlListFile');
      const statusDiv = document.getElementById('urlListStatus');
      const textarea = document.getElementById('manualUrlList');
      
      if (!fileInput.files || fileInput.files.length === 0) {
        // If no file, try to parse from textarea
        const csvText = textarea.value.trim();
        if (!csvText) {
          statusDiv.innerHTML = '<span style="color: #ef4444;">⚠ Please select a CSV file or paste CSV content</span>';
          return;
        }
        
        try {
          const result = parseUrlListCsv(csvText);
          localStorage.setItem('manual_url_list', JSON.stringify(result.urls));
          statusDiv.innerHTML = `<span style="color: #10b981;">✓ Loaded ${result.validUrls} URLs from ${result.totalRows} rows</span>`;
          debugLog(`✓ Manual URL list loaded: ${result.validUrls} URLs from CSV`, 'success');
          showStatus(`URL list loaded! Found ${result.validUrls} URLs.`, 'success');
        } catch (error) {
          statusDiv.innerHTML = `<span style="color: #ef4444;">✗ ${error.message}</span>`;
          debugLog(`✗ URL list parse error: ${error.message}`, 'error');
          showStatus(`URL list error: ${error.message}`, 'error');
        }
        return;
      }
      
      const file = fileInput.files[0];
      debugLog(`Loading URL list from file: ${file.name} (${file.size} bytes)`, 'info');
      
      try {
        const fileText = await file.text();
        const result = parseUrlListCsv(fileText);
        
        // Store URLs in localStorage
        localStorage.setItem('manual_url_list', JSON.stringify(result.urls));
        
        // Also populate textarea with the CSV content
        textarea.value = fileText;
        
        statusDiv.innerHTML = `<span style="color: #10b981;">✓ Loaded ${result.validUrls} URLs from ${result.totalRows} rows. Columns: ${result.headers.join(', ')}</span>`;
        debugLog(`✓ URL list loaded from file: ${result.validUrls} URLs`, 'success');
        debugLog(`  File: ${file.name}, Columns: ${result.headers.join(', ')}`, 'info');
        showStatus(`URL list loaded! Found ${result.validUrls} URLs from ${file.name}.`, 'success');
        
        // Clear file input
        fileInput.value = '';
      } catch (error) {
        statusDiv.innerHTML = `<span style="color: #ef4444;">✗ ${error.message}</span>`;
        debugLog(`✗ URL list file error: ${error.message}`, 'error');
        showStatus(`URL list error: ${error.message}`, 'error');
      }
    }

    // Clear manual URL list
    function clearManualUrlList() {
      const textarea = document.getElementById('manualUrlList');
      const fileInput = document.getElementById('urlListFile');
      const statusDiv = document.getElementById('urlListStatus');
      
      textarea.value = '';
      fileInput.value = '';
      localStorage.removeItem('manual_url_list');
      statusDiv.innerHTML = '<span style="color: #666;">Manual URL list cleared</span>';
      debugLog('Manual URL list cleared', 'info');
      showStatus('Manual URL list cleared', 'success');
    }

    // Load backlink CSV from file (wrapper for uploadBacklinkCsv)
    async function loadBacklinkCsvFromFile() {
      return await uploadBacklinkCsv();
    }

    // Upload backlink CSV file
    async function uploadBacklinkCsv() {
      const fileInput = document.getElementById('backlinkCsvFile');
      const statusDiv = document.getElementById('backlinkCsvStatus');
      const textarea = document.getElementById('backlinkCsvContent');
      
      let csvContent = '';
      
      if (fileInput.files && fileInput.files.length > 0) {
        const file = fileInput.files[0];
        debugLog(`Uploading backlink CSV from file: ${file.name} (${file.size} bytes)`, 'info');
        
        try {
          csvContent = await file.text();
          // Also populate textarea with the CSV content
          textarea.value = csvContent;
        } catch (error) {
          statusDiv.innerHTML = `<span style="color: #ef4444;">✗ Error reading file: ${error.message}</span>`;
          debugLog(`✗ Backlink CSV file read error: ${error.message}`, 'error');
          showStatus(`Backlink CSV error: ${error.message}`, 'error');
          return;
        }
      } else {
        // If no file, try to get from textarea
        csvContent = textarea.value.trim();
        if (!csvContent) {
          statusDiv.innerHTML = '<span style="color: #ef4444;">⚠ Please select a CSV file or paste CSV content</span>';
          return;
        }
      }

      if (!csvContent) {
        statusDiv.innerHTML = '<span style="color: #ef4444;">⚠ No CSV content to upload</span>';
        return;
      }

      // Validate CSV has required columns
      const lines = csvContent.split('\n').filter(line => line.trim());
      if (lines.length === 0) {
        statusDiv.innerHTML = '<span style="color: #ef4444;">✗ CSV is empty</span>';
        return;
      }

      const headerLine = lines[0].trim();
      const headers = headerLine.split(',').map(h => h.trim().replace(/^"|"$/g, ''));
      
      // More flexible column matching - check for URL column (required) and Link Type (optional)
      const hasUrlColumn = headers.some(h => {
        const lower = h.toLowerCase();
        return (lower.includes('linking') && lower.includes('url')) ||
               lower.includes('url') ||
               lower.includes('source url') ||
               lower.includes('page url');
      });
      
      const hasLinkType = headers.some(h => {
        const lower = h.toLowerCase();
        return lower.includes('link type') ||
               lower.includes('type') ||
               lower.includes('follow');
      });
      
      if (!hasUrlColumn) {
        statusDiv.innerHTML = `<span style="color: #ef4444;">✗ Missing URL column. Found columns: ${headers.join(', ')}. Need a column containing 'URL' or 'Linking Page + URL'</span>`;
        debugLog(`✗ Backlink CSV missing URL column. Found: ${headers.join(', ')}`, 'error');
        return;
      }
      
      if (!hasLinkType) {
        statusDiv.innerHTML = `<span style="color: #ef4444;">✗ Missing Link Type column. Found columns: ${headers.join(', ')}. The Link Type column is required to calculate the follow ratio for the Authority score.</span>`;
        debugLog(`✗ Backlink CSV missing Link Type column. Found: ${headers.join(', ')}`, 'error');
        return;
      }

      // Upload to API
      try {
        statusDiv.innerHTML = '<span style="color: #666;">⏳ Uploading and processing backlink CSV...</span>';
        debugLog('Uploading backlink CSV to API...', 'info');
        
        // Send CSV as JSON since Vercel doesn't parse text/csv automatically
        const response = await fetch(apiUrl('/api/aigeo/backlink-metrics'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ csv: csvContent })
        });

        if (!response.ok) {
          let errorMessage = `HTTP ${response.status}`;
          try {
            const errorData = await response.json();
            errorMessage = errorData.message || errorData.error || errorMessage;
            debugLog(`API error response: ${JSON.stringify(errorData)}`, 'error');
          } catch (e) {
            // If response is not JSON, try to get text
            try {
              const errorText = await response.text();
              if (errorText) {
                errorMessage = errorText.substring(0, 200);
              }
            } catch (e2) {
              // Ignore
            }
          }
          throw new Error(errorMessage);
        }

        const result = await response.json();
        debugLog(`API response: ${JSON.stringify(result).substring(0, 200)}...`, 'info');
        
        if (result.status === 'ok' && result.data) {
          const metrics = result.data;
          statusDiv.innerHTML = `<span style="color: #10b981;">✓ Backlink CSV uploaded successfully! Found ${metrics.referringDomains} referring domains, ${metrics.totalBacklinks} backlinks, ${Math.round(metrics.followRatio * 100)}% follow ratio</span>`;
          debugLog(`✓ Backlink CSV uploaded: ${metrics.referringDomains} domains, ${metrics.totalBacklinks} links, ${(metrics.followRatio * 100).toFixed(1)}% follow`, 'success');
          showStatus(`Backlink CSV uploaded! ${metrics.referringDomains} referring domains found.`, 'success');
          
          // Store in localStorage for persistence
          localStorage.setItem('backlink_csv_content', csvContent);
          localStorage.setItem('backlink_metrics', JSON.stringify(metrics));
          debugLog(`✓ Backlink metrics stored in localStorage`, 'success');
        } else {
          // Error response - log debug info to UI
          const errorMsg = result.message || result.error || 'Upload failed - invalid response format';
          statusDiv.innerHTML = `<span style="color: #ef4444;">✗ ${errorMsg}</span>`;
          debugLog(`✗ Backlink CSV upload error: ${errorMsg}`, 'error');
          
          // Log debug info if available
          if (result.debug) {
            debugLog(`[DEBUG] CSV Length: ${result.debug.csvLength || 'N/A'}`, 'info');
            debugLog(`[DEBUG] Logical Lines: ${result.debug.logicalLines || 'N/A'}`, 'info');
            debugLog(`[DEBUG] Headers Found: ${result.debug.headers ? result.debug.headers.join(', ') : 'N/A'}`, 'info');
            if (result.debug.firstChars) {
              debugLog(`[DEBUG] First 500 chars: ${result.debug.firstChars}`, 'info');
            }
            if (result.debug.rowCount !== undefined) {
              debugLog(`[DEBUG] Rows parsed: ${result.debug.rowCount}`, 'info');
            }
            if (result.debug.firstRowKeys) {
              debugLog(`[DEBUG] First row keys: ${result.debug.firstRowKeys.join(', ')}`, 'info');
            }
            if (result.debug.error) {
              debugLog(`[DEBUG] Error details: ${result.debug.error}`, 'error');
            }
          }
          
          // Also log full error response for debugging
          debugLog(`[DEBUG] Full error response: ${JSON.stringify(result, null, 2)}`, 'error');
          showStatus(`Backlink CSV error: ${errorMsg}`, 'error');
        }
      } catch (error) {
        const errorMsg = error.message || error.toString() || 'Unknown error';
        statusDiv.innerHTML = `<span style="color: #ef4444;">✗ ${errorMsg}</span>`;
        debugLog(`✗ Backlink CSV upload error: ${errorMsg}`, 'error');
        debugLog(`Error stack: ${error.stack || 'No stack trace'}`, 'error');
        showStatus(`Backlink CSV error: ${errorMsg}`, 'error');
      }
    }

    // Clear backlink CSV
    function clearBacklinkCsv() {
      const textarea = document.getElementById('backlinkCsvContent');
      const fileInput = document.getElementById('backlinkCsvFile');
      const statusDiv = document.getElementById('backlinkCsvStatus');
      
      textarea.value = '';
      fileInput.value = '';
      localStorage.removeItem('backlink_csv_content');
      statusDiv.innerHTML = '<span style="color: #666;">Backlink CSV cleared</span>';
      debugLog('Backlink CSV cleared', 'info');
      showStatus('Backlink CSV cleared', 'success');
    }

    // Sync CSV from alan-shared-resources
    async function syncCSV() {
      const btn = document.getElementById('syncCsvBtn');
      const btnText = document.getElementById('syncCsvBtnText');
      const originalText = btnText.textContent;
      
      debugLog('=== CSV SYNC: Starting CSV sync verification ===', 'info');
      debugLog('Button clicked - initiating CSV sync check...', 'info');
      
      // Disable button and show loading state
      btn.disabled = true;
      btnText.textContent = '⏳ Syncing...';
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      debugLog('Button state: disabled, showing loading indicator', 'info');
      
      try {
        debugLog('Fetching /api/sync-csv endpoint...', 'info');
        const response = await fetch(apiUrl('/api/sync-csv'), {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
        });
        
        debugLog(`API response status: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
        
        const data = await response.json();
        debugLog(`API response data: ${JSON.stringify(data).substring(0, 200)}...`, 'info');
        
        if (response.ok && data.status === 'ok') {
          const urlCount = data.data.totalUrls || 0;
          const source = data.source || 'unknown';
          
          debugLog(`✓ CSV fetched successfully from ${source}`, 'success');
          debugLog(`  CSV URL: ${data.csvUrl || 'not provided'}`, 'info');
          debugLog(`  Total URLs fetched: ${urlCount}`, 'success');
          debugLog(`  CSV size: ${data.data.csvSize} bytes`, 'info');
          debugLog(`  Lines processed: ${data.data.linesProcessed || 'N/A'}`, 'info');
          debugLog(`  Fetched at: ${data.data.fetchedAt}`, 'info');
          
          // Show toast with URL count
          showStatus(`✅ CSV synced from ${source}! Fetched ${urlCount} URLs.`, 'success');
          btnText.textContent = `✅ ${urlCount} URLs`;
          
          // Reset button after 3 seconds
          setTimeout(() => {
            btnText.textContent = originalText;
            btn.style.opacity = '1';
            debugLog('Button reset to original state', 'info');
          }, 3000);
        } else {
          debugLog(`✗ CSV sync failed`, 'error');
          debugLog(`  Error message: ${data.message || 'Unknown error'}`, 'error');
          debugLog(`  CSV URL attempted: ${data.csvUrl || 'not provided'}`, 'error');
          if (data.suggestion) {
            debugLog(`  Suggestion: ${data.suggestion}`, 'warn');
          }
          showStatus(`CSV sync failed: ${data.message}. ${data.suggestion || ''}`, 'error');
          btnText.textContent = '❌ Sync Failed';
          
          // Reset button after 5 seconds
          setTimeout(() => {
            btnText.textContent = originalText;
            btn.style.opacity = '1';
            debugLog('Button reset to original state after error', 'info');
          }, 5000);
        }
      } catch (error) {
        debugLog(`✗ CSV sync error occurred`, 'error');
        debugLog(`  Error type: ${error.name || 'Unknown'}`, 'error');
        debugLog(`  Error message: ${error.message}`, 'error');
        if (error.stack) {
          debugLog(`  Stack trace: ${error.stack.substring(0, 300)}...`, 'error');
        }
        showStatus(`CSV sync error: ${error.message}. Please run "npm run sync:csv" locally.`, 'error');
        btnText.textContent = '❌ Error';
        
        // Reset button after 5 seconds
        setTimeout(() => {
          btnText.textContent = originalText;
          btn.style.opacity = '1';
          debugLog('Button reset to original state after exception', 'info');
        }, 5000);
      } finally {
        btn.disabled = false;
        btn.style.cursor = 'pointer';
        debugLog('=== CSV SYNC: Complete ===', 'info');
      }
    }

    // Update progress bar
    function updateProgress(percent, statusText) {
      const progressBar = document.getElementById('progressBar');
      const progressStatus = document.getElementById('progressStatus');
      if (progressBar) {
        progressBar.style.width = Math.min(100, Math.max(0, percent)) + '%';
        progressBar.textContent = Math.round(percent) + '%';
      }
      if (progressStatus) {
        progressStatus.textContent = statusText || 'Processing...';
      }
    }

    // Show status message
    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = `status ${type} show`;
      setTimeout(() => {
        status.classList.remove('show');
      }, 5000);
    }

    // Show completion summary modal
    function showCompletionModal(schemaAudit) {
      debugLog('showCompletionModal called', 'info');
      const modal = document.getElementById('completionModal');
      const content = document.getElementById('completionSummaryContent');
      
      debugLog(`Modal element found: ${modal ? 'yes' : 'no'}`, 'info');
      debugLog(`Content element found: ${content ? 'yes' : 'no'}`, 'info');
      
      if (!modal || !content) {
        debugLog('⚠ Modal or content element not found, cannot show modal', 'error');
        return;
      }
      
      let html = '';
      
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const data = schemaAudit.data;
        const meta = schemaAudit.meta || {};
        const diag = meta.diagnostic || {};
        
        const totalPages = data.totalPages || diag.totalPages || 0;
        const successfulPages = diag.successfulPages || (totalPages - (data.missingSchemaCount || 0));
        const failedPages = diag.failedPages || data.missingSchemaCount || 0;
        const isComplete = failedPages === 0;
        
        html += `<div style="margin-bottom: 1.5rem;">`;
        html += `<div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">`;
        html += `<span style="font-size: 2rem;">${isComplete ? '✅' : '⚠️'}</span>`;
        html += `<h3 style="margin: 0; color: ${isComplete ? '#10b981' : '#f59e0b'};">
          ${isComplete ? 'Complete' : 'Incomplete'} Data
        </h3>`;
        html += `</div>`;
        
        html += `<div style="background: ${isComplete ? '#f0fdf4' : '#fffbeb'}; border-left: 4px solid ${isComplete ? '#10b981' : '#f59e0b'}; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">`;
        html += `<p style="margin: 0; color: #555; line-height: 1.6;">`;
        if (isComplete) {
          html += `All pages were successfully crawled. Dashboard data is complete and accurate.`;
        } else {
          html += `<strong>Warning:</strong> ${failedPages} page${failedPages !== 1 ? 's' : ''} failed to crawl. Dashboard data may be incomplete. Failed pages are counted as missing schema.`;
        }
        html += `</p>`;
        html += `</div>`;
        
        html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">`;
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Total URLs Scanned</div>`;
        html += `<div style="font-size: 1.5rem; font-weight: 600; color: #333;">${totalPages}</div>`;
        html += `</div>`;
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Successful Crawls</div>`;
        html += `<div style="font-size: 1.5rem; font-weight: 600; color: #10b981;">${successfulPages}</div>`;
        html += `</div>`;
        html += `</div>`;
        
        if (failedPages > 0) {
          // Get failed URLs from missingSchemaPages that have errors
          const failedUrls = (data.missingSchemaPages || []).filter(p => p.error).map(p => p.url);
          
          html += `<div style="background: #fef2f2; border-left: 4px solid #ef4444; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">`;
          html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Failed Crawls</div>`;
          html += `<div style="font-size: 1.5rem; font-weight: 600; color: #ef4444;">${failedPages}</div>`;
          
          if (diag.errorTypes && Object.keys(diag.errorTypes).length > 0) {
            html += `<div style="margin-top: 0.75rem; font-size: 0.85rem; color: #666;">`;
            html += `<strong>Error Breakdown:</strong><br>`;
            Object.entries(diag.errorTypes).forEach(([type, count]) => {
              html += `${type}: ${count}<br>`;
            });
            html += `</div>`;
          }
          
          // Add retry button if there are failed URLs
          if (failedUrls.length > 0) {
            html += `<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #fee2e2;">`;
            html += `<button id="retryFailedUrls" class="btn" style="background: #10b981; color: white; border-color: #10b981; width: 100%;" title="Retry crawling the ${failedUrls.length} failed URLs. This will rescan only the URLs that failed during the initial audit.">`;
            html += `🔄 Retry Failed URLs (${failedUrls.length})`;
            html += `</button>`;
            html += `<div style="font-size: 0.8rem; color: #666; margin-top: 0.5rem; text-align: center;">Click to rescan only the failed URLs</div>`;
            html += `</div>`;
          }
          
          html += `</div>`;
        }
        
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px; margin-top: 1rem;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;"><strong>Schema Coverage</strong></div>`;
        // Ensure coverage is a number, not an object
        const coverageValue = typeof data.coverage === 'number' && !isNaN(data.coverage) 
          ? data.coverage 
          : (() => {
              // Calculate from pagesWithSchema and totalPages if coverage is not a number
              const pagesWithSchemaCount = Array.isArray(data.pagesWithSchema) 
                ? data.pagesWithSchema.length 
                : (typeof data.pagesWithSchema === 'number' ? data.pagesWithSchema : 0);
              const totalPagesCount = typeof data.totalPages === 'number' ? data.totalPages : totalPages;
              return totalPagesCount > 0 ? ((pagesWithSchemaCount / totalPagesCount) * 100) : 0;
            })();
        html += `<div style="font-size: 1.25rem; font-weight: 600; color: #333;">${coverageValue.toFixed(1)}%</div>`;
        const pagesWithSchemaCount = Array.isArray(data.pagesWithSchema) 
          ? data.pagesWithSchema.length 
          : (typeof data.pagesWithSchema === 'number' ? data.pagesWithSchema : 0);
        html += `<div style="font-size: 0.85rem; color: #666; margin-top: 0.25rem;">${pagesWithSchemaCount} pages with inline schema</div>`;
        
        // Display schema types if available, properly formatted
        if (data.schemaTypes && Array.isArray(data.schemaTypes) && data.schemaTypes.length > 0) {
          const formattedTypes = data.schemaTypes
            .filter(t => t !== null && t !== undefined)
            .map(t => {
              if (typeof t === 'string') return t;
              if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type;
              return null;
            })
            .filter(t => t !== null && typeof t === 'string')
            .slice(0, 10)
            .join(', ');
          if (formattedTypes) {
            html += `<div style="font-size: 0.75rem; color: #666; margin-top: 0.5rem; line-height: 1.4;">Schema types: ${formattedTypes}${data.schemaTypes.length > 10 ? '...' : ''}</div>`;
          }
        }
        html += `</div>`;
        
        html += `</div>`;
      } else {
        // Provide more helpful error message
        let errorMsg = 'Unable to load audit summary data.';
        if (!schemaAudit) {
          errorMsg = 'Schema audit data is missing. The audit may have failed or data was not saved properly.';
        } else if (schemaAudit.status !== 'ok') {
          errorMsg = `Schema audit failed with status: ${schemaAudit.status}. ${schemaAudit.error || schemaAudit.message || ''}`;
        } else if (!schemaAudit.data) {
          errorMsg = 'Schema audit completed but data is missing. Please check the console for errors.';
        }
        html += `<div style="background: #fef2f2; border-left: 4px solid #ef4444; padding: 1rem; border-radius: 4px;">`;
        html += `<p style="margin: 0; color: #991b1b; line-height: 1.6;">${errorMsg}</p>`;
        html += `<p style="margin: 0.5rem 0 0 0; font-size: 0.85rem; color: #666;">Check the debug log at the bottom of the page for more details.</p>`;
        html += `</div>`;
        debugLog(`⚠ Completion modal error: schemaAudit=${!!schemaAudit}, status=${schemaAudit?.status}, hasData=${!!schemaAudit?.data}, hasMeta=${!!schemaAudit?.meta}`, 'warn');
      }
      
      content.innerHTML = html;
      modal.style.display = 'block';
      debugLog('Modal display set to block', 'info');
      debugLog(`Modal is now visible: ${modal.style.display}`, 'info');
      
      // Attach retry button handler if it exists
      const retryButton = document.getElementById('retryFailedUrls');
      if (retryButton) {
        retryButton.onclick = function() {
          retryFailedUrls(schemaAudit);
        };
      }
    }
    
    // Retry failed URLs from schema audit
    async function retryFailedUrls(schemaAudit) {
      if (!schemaAudit || !schemaAudit.data || !schemaAudit.data.missingSchemaPages) {
        debugLog('✗ No failed URLs to retry', 'error');
        showStatus('No failed URLs found to retry', 'error');
        return;
      }
      
      // Extract failed URLs (those with errors)
      const failedUrls = schemaAudit.data.missingSchemaPages
        .filter(p => p.error)
        .map(p => p.url);
      
      if (failedUrls.length === 0) {
        debugLog('✗ No failed URLs to retry', 'error');
        showStatus('No failed URLs found to retry', 'error');
        return;
      }
      
      debugLog(`🔄 Retrying ${failedUrls.length} failed URLs...`, 'info');
      showStatus(`Retrying ${failedUrls.length} failed URLs...`, 'info');
      
      // Close the modal
      closeCompletionModal();
      
      // Show loading indicator
      document.getElementById('loading').classList.add('show');
      document.getElementById('dashboard').style.display = 'none';
      updateProgress(0, `Retrying ${failedUrls.length} failed URLs...`);
      
      try {
        updateProgress(20, 'Scanning failed URLs for schema markup...');
        debugLog(`Sending retry request for ${failedUrls.length} URLs`, 'info');
        
        // Call schema-audit API with only the failed URLs
        const schemaResponse = await fetch(apiUrl('/api/schema-audit'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ urls: failedUrls })
        });
        
        if (!schemaResponse.ok) {
          throw new Error(`Schema audit API returned error: ${schemaResponse.status}`);
        }
        
        const retrySchemaAudit = await schemaResponse.json();
        
        if (retrySchemaAudit.status !== 'ok') {
          throw new Error(retrySchemaAudit.message || 'Schema audit failed');
        }
        
        const retryData = retrySchemaAudit.data;
        const retrySuccessful = retryData.pagesWithSchema || 0;
        const retryStillFailed = (retryData.missingSchemaCount || 0);
        
        debugLog(`✓ Retry completed: ${retrySuccessful} pages now have schema, ${retryStillFailed} still failed`, 'success');
        updateProgress(60, 'Merging retry results with original audit...');
        
        // Load original audit results from localStorage or Supabase
        const savedAudit = await loadAuditResults();
        if (savedAudit && savedAudit.schemaAudit && savedAudit.schemaAudit.data) {
          // Merge retry results with original schema audit
          const originalData = savedAudit.schemaAudit.data;
          const originalPages = originalData.pagesWithSchema || 0;
          const originalFailed = originalData.missingSchemaCount || 0;
          
          // Create merged schema audit data
          const mergedSchemaAudit = {
            ...savedAudit.schemaAudit,
            data: {
              ...originalData,
              // Update counts: add retry successful pages, remove retry successful from failed
              pagesWithSchema: originalPages + retrySuccessful,
              missingSchemaCount: Math.max(0, originalFailed - retrySuccessful),
              // Update missingSchemaPages: remove successfully retried URLs
              missingSchemaPages: (originalData.missingSchemaPages || []).filter(p => {
                // Keep only pages that weren't in the retry list or still failed
                return !failedUrls.includes(p.url) || (retryData.missingSchemaPages || []).some(rp => rp.url === p.url);
              }),
              // Update coverage
              coverage: ((originalPages + retrySuccessful) / originalData.totalPages) * 100
            }
          };
          
          // Update saved audit with merged results
          const mergedAudit = {
            ...savedAudit,
            schemaAudit: mergedSchemaAudit
          };
          
          // Recalculate scores with merged data (use saved localSignals if available)
          // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
          const normalizedSiteReviews = getTrustpilotSnapshot(savedAudit.siteReviews || null);
          const mergedScores = await calculatePillarScores(savedAudit.searchData, mergedSchemaAudit, savedAudit.localSignals || null, normalizedSiteReviews, savedAudit.backlinkMetrics || null);
          const mergedSnippetReadiness = calculateSnippetReadiness(mergedScores, savedAudit.searchData);
          
          // Save merged results (preserve localSignals, siteReviews, and backlinkMetrics)
          saveAuditResults(mergedScores, savedAudit.searchData, mergedSnippetReadiness, mergedSchemaAudit, savedAudit.localSignals || null, normalizedSiteReviews, savedAudit.backlinkMetrics || null);
          
          // Update retry button visibility
          updateRetryButtonVisibility(mergedSchemaAudit);
          
          // Refresh dashboard with merged results
          updateProgress(80, 'Refreshing dashboard with merged results...');
          displayDashboard(mergedScores, savedAudit.searchData, mergedSnippetReadiness, mergedSchemaAudit, savedAudit.localSignals || null);
          
          updateProgress(100, 'Retry completed and dashboard updated!');
          showStatus(`Retry completed: ${retrySuccessful} URLs now have schema. Dashboard updated with merged results.`, 'success');
          
          // Show completion modal with merged results
          showCompletionModal(mergedSchemaAudit);
        } else {
          // No saved audit found, just show retry results
          updateProgress(80, 'Retry completed!');
          showCompletionModal(retrySchemaAudit);
          updateProgress(100, 'Retry completed!');
          showStatus(`Retry completed: ${retrySuccessful} URLs now have schema, ${retryStillFailed} still failed`, 'success');
          debugLog('⚠ No saved audit found to merge with. Run full audit to see complete results.', 'warn');
        }
        
      } catch (error) {
        debugLog(`✗ Retry error: ${error.message}`, 'error');
        showStatus(`Error retrying failed URLs: ${error.message}`, 'error');
      } finally {
        document.getElementById('loading').classList.remove('show');
        setTimeout(() => {
          updateProgress(0, 'Initializing audit scan...');
        }, 500);
      }
    }

    // Save audit results to localStorage
    function saveAuditResults(scores, searchData, snippetReadiness, schemaAudit, localSignals = null, siteReviews = null, backlinkMetrics = null, preserveTimestamp = false) {
      try {
        const dateRange = parseInt(document.getElementById('dateRange')?.value) || 30;
        // Get property URL from input field or from searchData
        const propertyUrl = document.getElementById('propertyUrl')?.value || 
                           searchData?.propertyUrl || 
                           searchData?.property_url ||
                           localStorage.getItem('gsc_property_url') ||
                           'https://www.alanranger.com'; // Fallback default
        
        // Get existing audit data to preserve timestamp if requested
        let existingTimestamp = null;
        if (preserveTimestamp) {
          try {
            const existing = localStorage.getItem('last_audit_results');
            if (existing) {
              const parsed = JSON.parse(existing);
              existingTimestamp = parsed.timestamp;
            }
          } catch (e) {
            // Ignore errors when reading existing data
          }
        }
        
        const auditData = {
          scores,
          searchData,
          snippetReadiness,
          schemaAudit,
          localSignals, // Store local signals data for future use
          siteReviews, // Store site reviews data for future use (preserve on retry)
          backlinkMetrics, // Store backlink metrics data
          dateRange, // Store the date range used for this audit
          propertyUrl, // CRITICAL: Save property URL so we can fetch from Supabase later
          timestamp: preserveTimestamp && existingTimestamp ? existingTimestamp : new Date().toISOString(),
          // Save Money Pages Priority Matrix data for persistence
          moneyPagePriorityData: window.moneyPagePriorityData || null,
          moneySegmentMetrics: window.moneySegmentMetrics || null
        };
        
        // Try to save to localStorage, but don't fail if quota exceeded (Supabase is source of truth)
        if (safeSetLocalStorage('last_audit_results', auditData)) {
          debugLog(`✓ Audit results saved to localStorage (propertyUrl: ${propertyUrl})`, 'success');
        }
        // Also save property URL separately for easy access
        if (propertyUrl) {
          localStorage.setItem('gsc_property_url', propertyUrl);
        }
        debugLog(`✓ Audit results saved to localStorage (propertyUrl: ${propertyUrl})`, 'success');
        
        // Update timestamp display
        updateAuditTimestamp(auditData.timestamp);
      } catch (error) {
        debugLog(`✗ Error saving audit results: ${error.message}`, 'error');
      }
    }
    
    // Show full-screen loading overlay
    function showFullScreenLoading(message = 'Loading...') {
      // Remove any existing overlay
      const existing = document.getElementById('fullScreenLoadingOverlay');
      if (existing) existing.remove();
      
      // Create overlay
      const overlay = document.createElement('div');
      overlay.id = 'fullScreenLoadingOverlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(4px);
      `;
      
      // Create spinner container
      const spinnerContainer = document.createElement('div');
      spinnerContainer.style.cssText = `
        background: white;
        padding: 3rem 4rem;
        border-radius: 12px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        text-align: center;
        min-width: 300px;
      `;
      
      // Create spinner
      const spinner = document.createElement('div');
      spinner.style.cssText = `
        width: 60px;
        height: 60px;
        border: 6px solid #e2e8f0;
        border-top-color: #3b82f6;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 1.5rem;
      `;
      
      // Create message
      const messageDiv = document.createElement('div');
      messageDiv.style.cssText = 'font-size: 1.1rem; color: #1f2937; font-weight: 500;';
      messageDiv.textContent = message;
      
      // Add spin animation if not already in stylesheet
      if (!document.getElementById('full-screen-spin-style')) {
        const style = document.createElement('style');
        style.id = 'full-screen-spin-style';
        style.textContent = '@keyframes spin { to { transform: rotate(360deg); } }';
        document.head.appendChild(style);
      }
      
      spinnerContainer.appendChild(spinner);
      spinnerContainer.appendChild(messageDiv);
      overlay.appendChild(spinnerContainer);
      document.body.appendChild(overlay);
    }
    
    // Hide full-screen loading overlay
    function hideFullScreenLoading() {
      const overlay = document.getElementById('fullScreenLoadingOverlay');
      if (overlay) overlay.remove();
    }
    
    // Update audit results for new date range without full rescan
    async function updateAuditForNewDateRange(newDateRange, savedAudit) {
      // Show full-screen loading overlay
      showFullScreenLoading(`Updating metrics for ${newDateRange} day period...`);
      
      try {
        showStatus(`Updating metrics for ${newDateRange} day period...`, 'info');
        
        const propertyUrl = document.getElementById('propertyUrl')?.value || savedAudit.propertyUrl || '';
        if (!propertyUrl) {
          // Remove loading spinner
          if (trendCanvas && trendCanvas.parentElement) {
            const loadingDiv = trendCanvas.parentElement.querySelector('.trend-chart-loading');
            if (loadingDiv) loadingDiv.remove();
          }
          clearDashboard();
          showStatus(`Date range changed to ${newDateRange} days. Please run a new audit to see updated metrics.`, 'info');
          return;
        }
        
        // Get API key (needed for fetchSearchConsoleData signature, but not actually used)
        let apiKey = window._loadedApiKey || '';
        
        // Fetch new GSC data for the new date range (will use Supabase cache)
        debugLog(`Fetching GSC data for ${newDateRange} day period...`, 'info');
        const searchData = await fetchSearchConsoleData(apiKey, propertyUrl, newDateRange);
        
        // Fetch local signals (Business Profile data doesn't change with date range, but fetch to ensure it's fresh)
        let localSignals = savedAudit.localSignals || null;
        
        // Normalize cached localSignals structure if needed (handle old format where it might just be {data: {...}})
        if (localSignals && localSignals.data && !localSignals.status) {
          debugLog(`[Local Signals] Normalizing cached data structure - wrapping in status/data format`, 'info');
          localSignals = { status: 'ok', data: localSignals.data || localSignals };
        }
        
        try {
          const localSignalsResponse = await fetch(apiUrl(`/api/aigeo/local-signals?property=${encodeURIComponent(propertyUrl)}`));
          if (localSignalsResponse.ok) {
            const freshLocalSignals = await localSignalsResponse.json();
            debugLog(`[Local Signals API] Response received - status: ${freshLocalSignals.status}, has data: ${!!freshLocalSignals.data}, locations count: ${freshLocalSignals.data?.locations?.length || 0}, structure keys: ${Object.keys(freshLocalSignals).join(', ')}`, 'info');
            
            // Use fresh data if API returned successfully
            if (freshLocalSignals.status === 'ok' && freshLocalSignals.data) {
              // Always use fresh data if API returned successfully, even if locations is 0
              // (API might return 0 locations legitimately, or we want to update cached data)
              localSignals = freshLocalSignals;
              debugLog(`✓ Local signals data fetched successfully - Locations: ${freshLocalSignals.data.locations?.length || 0}, Service Areas: ${freshLocalSignals.data.serviceAreas?.length || 0}, NAP: ${freshLocalSignals.data.napConsistencyScore}`, 'success');
            } else if (freshLocalSignals.status === 'error') {
              debugLog(`⚠ Local signals API error: ${freshLocalSignals.error?.message || 'Unknown error'}, keeping cached data`, 'warn');
              // Keep using cached data - don't overwrite with error response
            } else {
              debugLog(`⚠ Local signals API returned unexpected status (status: ${freshLocalSignals.status}, has data: ${!!freshLocalSignals.data}, locations: ${freshLocalSignals.data?.locations?.length || 0}), keeping cached data`, 'warn');
              // Keep using cached data - don't overwrite with unexpected response
            }
          }
        } catch (localSignalsError) {
          debugLog(`⚠ Local signals error: ${localSignalsError.message}, using cached data if available`, 'warn');
        }
        
        // Final normalization - ensure localSignals always has the correct structure
        if (localSignals && localSignals.data && !localSignals.status) {
          localSignals = { status: 'ok', data: localSignals.data || localSignals };
        }
        
        // Recalculate pillar scores based on new GSC data
        // Keep existing schema audit data (doesn't change with date range)
        // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
        const normalizedSiteReviews = getTrustpilotSnapshot(savedAudit.siteReviews || null);
        // Get backlinkMetrics from savedAudit (it should be there from the last audit)
        const backlinkMetrics = savedAudit.backlinkMetrics || null;
        const scores = await calculatePillarScores(searchData, savedAudit.schemaAudit, localSignals, normalizedSiteReviews, backlinkMetrics);
        const snippetReadiness = calculateSnippetReadiness(scores, searchData);
        
        debugLog(`Recalculated scores for ${newDateRange} days: ${JSON.stringify(scores)}`, 'info');
        
        // Update saved audit with new data
        // Preserve the original audit timestamp - don't update it when changing date range
        const updatedAudit = {
          ...savedAudit,
          dateRange: newDateRange,
          searchData: searchData,
          scores: scores,
          snippetReadiness: snippetReadiness,
          localSignals: localSignals, // Store local signals for future use
          timestamp: savedAudit.timestamp || new Date().toISOString(), // Preserve original timestamp
          // Preserve Money Pages Priority Matrix data if it exists
          moneyPagePriorityData: window.moneyPagePriorityData || savedAudit.moneyPagePriorityData || null,
          moneySegmentMetrics: window.moneySegmentMetrics || savedAudit.moneySegmentMetrics || null
        };
        
        // Save updated audit
        // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
        const normalizedSiteReviewsForLoad = getTrustpilotSnapshot(savedAudit.siteReviews || null);
        // Use backlinkMetrics from savedAudit (preserved from last audit)
        const preservedBacklinkMetrics = backlinkMetrics;
        // Pass preserveTimestamp=true to keep the original audit timestamp
        saveAuditResults(scores, searchData, snippetReadiness, savedAudit.schemaAudit, localSignals, normalizedSiteReviewsForLoad, preservedBacklinkMetrics, true);
        safeSetLocalStorage('last_audit_results', updatedAudit);
        
        // Do NOT save to Supabase here.
        // This "metrics refresh" (date range change) is not a full audit run, and saving it
        // can incorrectly update today's audit_results row and the "Last Audit" time.
        
        // Update dashboard with new data - ensure scores object has all required properties
        debugLog(`Updating dashboard with scores: ${JSON.stringify(scores)}`, 'info');
        displayDashboard(scores, searchData, snippetReadiness, savedAudit.schemaAudit, localSignals);
        
        showStatus(`Metrics updated for ${newDateRange} day period.`, 'success');
        debugLog(`✓ Audit updated for ${newDateRange} day period`, 'success');
        
      } catch (error) {
        debugLog(`✗ Error updating audit for new date range: ${error.message}`, 'error');
        
        // Remove loading spinner and show error
        // Hide full-screen loading overlay
        hideFullScreenLoading();
        
        // Show error message in trend chart area
        const trendCanvas = document.getElementById('trendChart');
        if (trendCanvas && trendCanvas.parentElement) {
          // Remove any existing error messages
          const existingError = trendCanvas.parentElement.querySelector('.trend-chart-error');
          if (existingError) existingError.remove();
          
          // Show error message to user
          const errorDiv = document.createElement('div');
          errorDiv.className = 'trend-chart-error';
          errorDiv.style.cssText = 'background: #fee2e2; padding: 1rem; border-radius: 4px; border-left: 3px solid #ef4444; margin-bottom: 1rem; font-size: 0.9rem; color: #991b1b;';
          errorDiv.innerHTML = `<strong>Error updating trend chart:</strong> ${error.message}. Please refresh the page or run a new audit.`;
          trendCanvas.parentElement.insertBefore(errorDiv, trendCanvas);
        }
        
        clearDashboard();
        showStatus(`Date range changed to ${newDateRange} days. Please run a new audit to see updated metrics.`, 'info');
      }
    }
    
    // Clear dashboard and show message that new audit is needed
    function clearDashboard() {
      const dashboard = document.getElementById('dashboard');
      if (dashboard) {
        dashboard.style.display = 'none';
      }
      // Clear any charts
      if (window.radarChart) {
        window.radarChart.destroy();
        window.radarChart = null;
      }
      if (window.trendChart) {
        window.trendChart.destroy();
        window.trendChart = null;
      }
      if (window.snippetReadinessChart) {
        window.snippetReadinessChart.destroy();
        window.snippetReadinessChart = null;
      }
    }
    
    // Load audit results from localStorage
    async function loadAuditResults() {
      let auditData = null;
      let localStorageData = null;
      let hasMoneyPagesData = false;
      let hasQueryTotals = false;
      
      // First, try localStorage
      try {
        const saved = localStorage.getItem('last_audit_results');
        if (saved) {
          localStorageData = JSON.parse(saved);
          debugLog('✓ Audit results loaded from localStorage', 'success');
          
          // Check if localStorage data has critical Money Pages data
          hasMoneyPagesData = !!(localStorageData?.scores?.moneyPagesMetrics || localStorageData?.moneyPagesMetrics);
          // Also check if queryTotals are present (needed for CTR/Impressions columns)
          hasQueryTotals = !!(localStorageData?.searchData?.queryTotals && Array.isArray(localStorageData.searchData.queryTotals) && localStorageData.searchData.queryTotals.length > 0);
          
          if (hasMoneyPagesData) {
            debugLog(`✓ localStorage has moneyPagesMetrics: ${localStorageData?.scores?.moneyPagesMetrics?.rows?.length || localStorageData?.moneyPagesMetrics?.rows?.length || 0} rows`, 'success');
            if (!hasQueryTotals) {
              debugLog(`⚠ localStorage missing queryTotals (${localStorageData?.searchData?.queryTotals?.length || 0} items), will try Supabase...`, 'warn');
            } else {
              debugLog(`✓ localStorage has queryTotals: ${localStorageData.searchData.queryTotals.length} keywords`, 'success');
            }
            // Don't return yet: we still want to confirm "Last Audit" against Supabase
            auditData = localStorageData;
          } else {
            debugLog('⚠ localStorage data missing moneyPagesMetrics, will try Supabase...', 'warn');
            // Keep localStorageData as fallback
            auditData = localStorageData;
          }
        }
      } catch (error) {
        debugLog(`✗ Error loading audit results from localStorage: ${error.message}`, 'error');
      }
      
      // If localStorage is empty or missing critical data, try fetching from Supabase
      // Try multiple sources for property URL - prioritize saved audit data
      let propertyUrl = (localStorageData && localStorageData.propertyUrl) || // First check: saved in auditData
                        localStorage.getItem('gsc_property_url') || 
                        localStorage.getItem('last_property_url') ||
                        (localStorageData && localStorageData.searchData && localStorageData.searchData.propertyUrl) ||
                        (localStorageData && localStorageData.searchData && localStorageData.searchData.property_url);
      
      // If still no property URL, try to extract from saved audit data structure
      if (!propertyUrl && localStorageData) {
        // Check if there's a property URL embedded in the saved data
        if (localStorageData.searchData && typeof localStorageData.searchData === 'object') {
          propertyUrl = localStorageData.searchData.propertyUrl || localStorageData.searchData.property_url;
        }
      }
      
      // Last resort: try to get from input field
      if (!propertyUrl) {
        const propertyUrlInput = document.getElementById('propertyUrl');
        if (propertyUrlInput && propertyUrlInput.value) {
          propertyUrl = propertyUrlInput.value;
        }
      }
      
      debugLog(`Property URL for Supabase fetch: ${propertyUrl || 'NOT SET'}`, propertyUrl ? 'info' : 'warn');
      
      if (propertyUrl) {
        // Always do a quick minimal check so "Last Audit" reflects the latest *full* audit,
        // even when we can serve the rest of the page from localStorage.
        try {
          const minimalResponse = await fetch(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}&minimal=true`);
          if (minimalResponse.ok) {
            const minimalJson = await minimalResponse.json();
            const minimalData = minimalJson?.data;
            if (minimalJson?.status === 'ok' && minimalData?.timestamp) {
              updateAuditTimestamp(minimalData.timestamp);
              // IMPORTANT: also update cached local data, otherwise displayDashboard() will
              // overwrite the UI with stale localStorageData.timestamp.
              const normalizedTs = typeof minimalData.timestamp === 'number'
                ? new Date(minimalData.timestamp).toISOString()
                : minimalData.timestamp;
              if (localStorageData && normalizedTs) {
                localStorageData.timestamp = normalizedTs;
                try {
                  safeSetLocalStorage('last_audit_results', localStorageData);
                } catch (e) {
                  // Non-fatal
                }
              }
              if (auditData && normalizedTs) {
                auditData.timestamp = normalizedTs;
              }
            }
          }
        } catch (e) {
          // Non-fatal
        }

        // ALWAYS fetch from Supabase as the source of truth
        debugLog(`📊 Always fetching from Supabase (source of truth)...`, 'info');
        debugLog(`📊 Calling fetchLatestAuditFromSupabase(${propertyUrl})...`, 'info');
        const supabaseData = await fetchLatestAuditFromSupabase(propertyUrl);
        debugLog(`📊 fetchLatestAuditFromSupabase returned: ${supabaseData ? 'data' : 'null/undefined'}`, supabaseData ? 'success' : 'warn');
        
        if (supabaseData) {
          debugLog('✓ Audit results loaded from Supabase', 'success');
          debugLog(`✓ Supabase data structure: scores.moneyPagesMetrics=${!!supabaseData?.scores?.moneyPagesMetrics}, moneyPagesMetrics=${!!supabaseData?.moneyPagesMetrics}, searchData=${!!supabaseData?.searchData}, queryTotals=${supabaseData?.searchData?.queryTotals?.length || 0} keywords`, 'info');
          if (supabaseData.searchData) {
            debugLog(`✓ Supabase searchData keys: ${Object.keys(supabaseData.searchData).join(', ')}`, 'info');
            if (supabaseData.searchData.queryTotals) {
              debugLog(`✓ Supabase queryTotals type: ${Array.isArray(supabaseData.searchData.queryTotals) ? 'array' : typeof supabaseData.searchData.queryTotals}, length: ${Array.isArray(supabaseData.searchData.queryTotals) ? supabaseData.searchData.queryTotals.length : 'N/A'}`, 'success');
            } else {
              debugLog(`⚠ Supabase searchData exists but queryTotals is missing/null`, 'warn');
            }
          } else {
            debugLog(`⚠ Supabase data exists but searchData is missing/null`, 'warn');
          }
          
          // Store in localStorage for offline/cache purposes (but Supabase is always source of truth)
          try {
            safeSetLocalStorage('last_audit_results', supabaseData);
            debugLog('✓ Stored Supabase data in localStorage for caching', 'success');
            // Update timestamp display
            if (supabaseData.timestamp) {
              updateAuditTimestamp(supabaseData.timestamp);
            }
          } catch (storageError) {
            debugLog(`⚠ Could not store Supabase data in localStorage: ${storageError.message}`, 'warn');
          }
          return supabaseData;
        } else {
          debugLog('⚠ No audit data found in Supabase (fetchLatestAuditFromSupabase returned null/undefined), using localStorage data as fallback', 'warn');
          debugLog(`⚠ This could mean: 1) No audit exists in Supabase for ${propertyUrl}, 2) API call failed, 3) API returned error status`, 'warn');
        }
      } else {
        debugLog('⚠ Cannot fetch from Supabase: property URL not set, using localStorage data as fallback', 'warn');
      }
      
      // Return localStorage data as fallback (even if incomplete) rather than null
      // This ensures the page still loads with whatever data we have
      if (localStorageData) {
        debugLog('✓ Returning localStorage data as fallback (may be incomplete)', 'info');
        return localStorageData;
      }
      
      return null;
    }
    
    // Synchronous version for callers that can't be async (returns localStorage only)
    function loadAuditResultsSync() {
      try {
        const saved = localStorage.getItem('last_audit_results');
        if (saved) {
          return JSON.parse(saved);
        }
      } catch (error) {
        // Silent fail for sync version
      }
      return null;
    }
    
    // Update audit timestamp display
    function updateAuditTimestamp(timestamp) {
      const timestampElement = document.getElementById('lastAuditTime');
      const snippetTimestampElement = document.getElementById('snippetReadinessAuditTime');
      const snippetTimestampContainer = document.getElementById('snippetReadinessTimestamp');
      const radarTimestampElement = document.getElementById('radarChartAuditTime');
      const radarTimestampContainer = document.getElementById('radarChartTimestamp');
      
      if (timestamp) {
        const date = new Date(timestamp);
        // Format in GMT/UTC: "DD MMM YYYY, HH:MM:SS GMT"
        const day = String(date.getUTCDate()).padStart(2, '0');
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const month = monthNames[date.getUTCMonth()];
        const year = date.getUTCFullYear();
        const hours = String(date.getUTCHours()).padStart(2, '0');
        const minutes = String(date.getUTCMinutes()).padStart(2, '0');
        const seconds = String(date.getUTCSeconds()).padStart(2, '0');
        const formatted = `${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
        
        if (timestampElement) {
          timestampElement.textContent = formatted;
        }
        
        // Update snippet readiness timestamp
        if (snippetTimestampElement) {
          snippetTimestampElement.textContent = formatted;
        }
        if (snippetTimestampContainer) {
          snippetTimestampContainer.style.display = 'block';
        }
        
        // Update radar chart timestamp
        if (radarTimestampElement) {
          radarTimestampElement.textContent = formatted;
        }
        if (radarTimestampContainer) {
          radarTimestampContainer.style.display = 'block';
        }
      } else {
        if (timestampElement) {
          timestampElement.textContent = 'Not yet run';
        }
        if (snippetTimestampContainer) {
          snippetTimestampContainer.style.display = 'none';
        }
        if (radarTimestampContainer) {
          radarTimestampContainer.style.display = 'none';
        }
      }
    }
    
    // Save audit results to Supabase for historical tracking
    async function saveAuditToSupabase(propertyUrl, scores, searchData, snippetReadiness, schemaAudit, localSignals = null, auditDateOverride = null) {
      try {
        // IMPORTANT: Only full audits should write a new audit_date.
        // If auditDateOverride is provided, use it; otherwise try to derive from the saved audit timestamp.
        let auditDate = auditDateOverride;
        if (!auditDate) {
          try {
            const saved = loadAuditResultsSync();
            if (saved && saved.timestamp) {
              auditDate = new Date(saved.timestamp).toISOString().split('T')[0];
            }
          } catch (e) {
            // Ignore
          }
        }
        if (!auditDate) {
          auditDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD fallback
        }
        
        // Ensure searchData has overview object with siteTotalImpressions and siteTotalClicks
        // These are needed for calculating shareOfImpressions in buildMoneyPagesSummary
        let overview = null;
        
        if (searchData) {
          // Create overview object if it doesn't exist
          if (!searchData.overview) {
            searchData.overview = {};
          }
          
          // Populate overview with siteTotalImpressions and siteTotalClicks
          // Priority: searchData.overview.siteTotalImpressions > searchData.totalImpressions > searchData.overview.totalImpressions
          if (!searchData.overview.siteTotalImpressions || searchData.overview.siteTotalImpressions === 0) {
            if (searchData.totalImpressions != null && searchData.totalImpressions > 0) {
              searchData.overview.siteTotalImpressions = searchData.totalImpressions;
            } else if (searchData.overview.totalImpressions != null && searchData.overview.totalImpressions > 0) {
              searchData.overview.siteTotalImpressions = searchData.overview.totalImpressions;
            } else {
              // Fallback: set to 0 if all else fails
              searchData.overview.siteTotalImpressions = 0;
            }
          }
          
          if (!searchData.overview.siteTotalClicks || searchData.overview.siteTotalClicks === 0) {
            if (searchData.totalClicks != null && searchData.totalClicks > 0) {
              searchData.overview.siteTotalClicks = searchData.totalClicks;
            } else if (searchData.overview.totalClicks != null && searchData.overview.totalClicks > 0) {
              searchData.overview.siteTotalClicks = searchData.overview.totalClicks;
            } else {
              // Fallback: set to 0 if all else fails
              searchData.overview.siteTotalClicks = 0;
            }
          }
          
          // Also ensure totalImpressions and totalClicks are set in overview for compatibility
          if (!searchData.overview.totalImpressions) {
            searchData.overview.totalImpressions = searchData.overview.siteTotalImpressions;
          }
          if (!searchData.overview.totalClicks) {
            searchData.overview.totalClicks = searchData.overview.siteTotalClicks;
          }
          
          overview = searchData.overview;
          
          // Debug logging
          debugLog(`saveAuditToSupabase: searchData.totalImpressions=${searchData.totalImpressions}, overview.siteTotalImpressions=${overview.siteTotalImpressions || 'missing'}, overview.totalImpressions=${overview.totalImpressions || 'missing'}`, 'info');
        } else {
          debugLog(`⚠ saveAuditToSupabase: searchData is null or undefined`, 'warn');
          // Create empty overview as fallback
          overview = { siteTotalImpressions: 0, siteTotalClicks: 0, totalImpressions: 0, totalClicks: 0 };
        }
        
        // Build Money Pages summary for trend tracking (Phase 3)
        // CRITICAL: Ensure moneyPagesMetrics exists in scores - check multiple sources
        debugLog(`saveAuditToSupabase: Checking for moneyPagesMetrics - scores.moneyPagesMetrics=${!!scores?.moneyPagesMetrics}, window.moneyPagesMetrics=${!!window.moneyPagesMetrics}`, 'info');
        
        if (!scores.moneyPagesMetrics) {
          debugLog(`⚠ saveAuditToSupabase: scores.moneyPagesMetrics is missing, checking window.moneyPagesMetrics`, 'warn');
          // Try to get from global state if available
          if (window.moneyPagesMetrics) {
            scores.moneyPagesMetrics = window.moneyPagesMetrics;
            debugLog(`✓ saveAuditToSupabase: Using moneyPagesMetrics from window (${window.moneyPagesMetrics.rows?.length || 0} rows)`, 'info');
          } else {
            debugLog(`⚠ saveAuditToSupabase: No moneyPagesMetrics available anywhere - this means money pages data was not generated during audit`, 'warn');
            debugLog(`⚠ saveAuditToSupabase: This could be because: 1) No queryPages data from GSC, 2) CSV fetch failed, 3) No money pages found in CSV`, 'warn');
            // Set to null explicitly so it's saved (even if empty)
            scores.moneyPagesMetrics = null;
          }
        } else {
          debugLog(`✓ saveAuditToSupabase: moneyPagesMetrics found in scores (${scores.moneyPagesMetrics.rows?.length || 0} rows)`, 'info');
        }
        
        // CRITICAL: Log what we're about to save
        debugLog(`saveAuditToSupabase: Final moneyPagesMetrics to save: ${scores.moneyPagesMetrics ? (scores.moneyPagesMetrics.rows?.length || 0) + ' rows' : 'NULL'}`, 'info');
        
        // Ensure overview is never null - create fallback if needed
        if (!overview) {
          debugLog(`⚠ saveAuditToSupabase: overview is null, creating fallback`, 'warn');
          overview = { 
            siteTotalImpressions: searchData?.totalImpressions || 0, 
            siteTotalClicks: searchData?.totalClicks || 0,
            totalImpressions: searchData?.totalImpressions || 0,
            totalClicks: searchData?.totalClicks || 0
          };
        }
        
        debugLog(`saveAuditToSupabase: About to call buildMoneyPagesSummary - overview exists=${!!overview}, overview.siteTotalImpressions=${overview?.siteTotalImpressions || 'missing'}, searchData.totalImpressions=${searchData?.totalImpressions || 'missing'}, moneyPagesMetrics=${!!scores?.moneyPagesMetrics}`, 'info');
        const moneyPagesSummary = window.buildMoneyPagesSummary ? window.buildMoneyPagesSummary(
          scores?.moneyPagesMetrics || null,
          overview || { siteTotalImpressions: 0, siteTotalClicks: 0, totalImpressions: 0, totalClicks: 0 }
        ) : null;
        if (moneyPagesSummary) {
          debugLog(`saveAuditToSupabase: moneyPagesSummary created - shareOfImpressions=${moneyPagesSummary.shareOfImpressions || 'null'}`, 'info');
        } else {
          debugLog(`saveAuditToSupabase: moneyPagesSummary is null`, 'warn');
        }
        
        // Get money segment metrics for 12-month KPI tracking
        // Ensure it's never null - build empty structure if missing
        let moneySegmentMetrics = window.moneySegmentMetrics;
        if (!moneySegmentMetrics) {
          debugLog(`⚠ saveAuditToSupabase: moneySegmentMetrics is null, building empty structure`, 'warn');
          // Build empty structure to ensure it's always saved (even if empty)
          if (typeof buildMoneySegmentSummary === 'function') {
            // Try to rebuild from moneyPagePriorityData if available
            const priorityData = window.moneyPagePriorityData || [];
            if (priorityData.length > 0) {
              debugLog(`✓ saveAuditToSupabase: Rebuilding moneySegmentMetrics from priority data (${priorityData.length} pages)`, 'info');
              moneySegmentMetrics = buildMoneySegmentSummary(priorityData, {});
            } else {
              moneySegmentMetrics = buildMoneySegmentSummary([], {});
            }
          } else {
            // Fallback structure if function not available
            moneySegmentMetrics = {
              allMoney: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
              landingPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
              eventPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
              productPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 }
            };
          }
        }
        
        // Also ensure moneyPagePriorityData is available for saving
        if (!window.moneyPagePriorityData || window.moneyPagePriorityData.length === 0) {
          debugLog(`⚠ saveAuditToSupabase: moneyPagePriorityData is missing or empty`, 'warn');
          // Try to rebuild from moneyPagesMetrics if available
          if (scores?.moneyPagesMetrics?.rows && scores.moneyPagesMetrics.rows.length > 0) {
            debugLog(`✓ saveAuditToSupabase: Rebuilding moneyPagePriorityData from moneyPagesMetrics (${scores.moneyPagesMetrics.rows.length} rows)`, 'info');
            const topPagesForPriority = scores.moneyPagesMetrics.rows.map(row => ({
              page: row.url,
              url: row.url,
              clicks: row.clicks || 0,
              impressions: row.impressions || 0,
              ctr: (row.ctr || 0) * 100,
              position: row.avgPosition || 0,
              avgPosition: row.avgPosition || 0,
              title: row.title || row.url
            }));
            // Use window.buildMoneyPageMetrics if available, otherwise use local function
            if (typeof window.buildMoneyPageMetrics === 'function') {
              window.moneyPagePriorityData = window.buildMoneyPageMetrics(topPagesForPriority, schemaAudit);
            } else if (typeof buildMoneyPageMetrics === 'function') {
              window.moneyPagePriorityData = buildMoneyPageMetrics(topPagesForPriority, schemaAudit);
            } else {
              debugLog(`✗ buildMoneyPageMetrics not available in saveAuditToSupabase, cannot rebuild`, 'error');
              window.moneyPagePriorityData = [];
            }
            debugLog(`✓ saveAuditToSupabase: Rebuilt ${window.moneyPagePriorityData.length} priority entries`, 'info');
          }
        }
        debugLog(`saveAuditToSupabase: moneySegmentMetrics ready with ${Object.keys(moneySegmentMetrics).length} segments`, 'info');
        debugLog(`saveAuditToSupabase: moneySegmentMetrics.allMoney clicks=${moneySegmentMetrics.allMoney?.clicks || 0}, impressions=${moneySegmentMetrics.allMoney?.impressions || 0}`, 'info');
        
        // Get rankingAiData from localStorage or window if available
        let rankingAiData = null;
        try {
          const localRankingData = localStorage.getItem('rankingAiData');
          if (localRankingData) {
            rankingAiData = JSON.parse(localRankingData);
            debugLog(`✓ saveAuditToSupabase: Loaded rankingAiData from localStorage (${rankingAiData.combinedRows?.length || 0} keywords)`, 'info');
          } else if (window.rankingAiData) {
            rankingAiData = window.rankingAiData;
            debugLog(`✓ saveAuditToSupabase: Using rankingAiData from window (${rankingAiData.combinedRows?.length || 0} keywords)`, 'info');
          } else {
            debugLog(`⚠ saveAuditToSupabase: No rankingAiData available`, 'warn');
          }
        } catch (rankingErr) {
          debugLog(`⚠ saveAuditToSupabase: Error loading rankingAiData: ${rankingErr.message}`, 'warn');
        }
        
        // Prepare payload
        const payload = {
          propertyUrl,
          auditDate,
          schemaAudit,
          scores,
          searchData,
          snippetReadiness,
          localSignals, // Pass Business Profile data for storage
          moneyPagesSummary, // Phase 3: Money Pages summary for trend tracking
          moneySegmentMetrics, // Phase: Money Pages Priority Matrix - segment metrics for KPI tracker
          moneyPagePriorityData: window.moneyPagePriorityData || null, // CRITICAL: Save Priority Matrix data to Supabase
          rankingAiData // Ranking & AI data (SERP rankings + AI Overview citations)
        };
        
        // Check payload size before sending (Vercel limit is ~4.5MB)
        const payloadJson = JSON.stringify(payload);
        const payloadSizeKB = Math.round(payloadJson.length / 1024);
        debugLog(`saveAuditToSupabase: Payload size: ${payloadSizeKB}KB`, 'info');
        
        if (payloadSizeKB > 4000) {
          debugLog(`⚠ Payload size (${payloadSizeKB}KB) exceeds 4MB - truncating large fields...`, 'warn');
          // Truncate queryPages if too large
          if (searchData?.queryPages && Array.isArray(searchData.queryPages) && searchData.queryPages.length > 2000) {
            debugLog(`⚠ Truncating queryPages from ${searchData.queryPages.length} to 2000 items`, 'warn');
            searchData.queryPages = searchData.queryPages.slice(0, 2000);
          }
          // Truncate topQueries if too large
          if (searchData?.topQueries && Array.isArray(searchData.topQueries) && searchData.topQueries.length > 500) {
            debugLog(`⚠ Truncating topQueries from ${searchData.topQueries.length} to 500 items`, 'warn');
            searchData.topQueries = searchData.topQueries.slice(0, 500);
          }
          // Recalculate payload size after truncation
          const truncatedPayload = {
            ...payload,
            searchData: { ...searchData }
          };
          const truncatedJson = JSON.stringify(truncatedPayload);
          const truncatedSizeKB = Math.round(truncatedJson.length / 1024);
          debugLog(`saveAuditToSupabase: Payload size after truncation: ${truncatedSizeKB}KB`, 'info');
          payload.searchData = truncatedPayload.searchData;
        }
        
        const response = await fetch(apiUrl('/api/supabase/save-audit'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload)
        });
        
        if (response.ok) {
          const result = await response.json();
          debugLog(`✓ Audit results saved to Supabase successfully (audit_date: ${auditDate})`, 'success');
          debugLog(`✓ Saved data: schema_total_pages=${schemaAudit?.data?.totalPages || 'N/A'}, scores=${JSON.stringify(Object.keys(scores || {}))}`, 'info');
          
          // Verify the save by checking Supabase
          try {
            debugLog('Verifying audit save in Supabase...', 'info');
            const verifyResponse = await fetch(apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}&minimal=true`));
            if (verifyResponse.ok) {
              const verifyResult = await verifyResponse.json();
              if (verifyResult.status === 'ok' && verifyResult.data && verifyResult.data.auditDate === auditDate) {
                debugLog(`✓ Verified: Audit ${auditDate} exists in Supabase with schema_total_pages=${verifyResult.data.scores?.contentSchema !== null ? 'present' : 'null'}`, 'success');
                showStatus(`✓ Audit saved and verified in Supabase (${auditDate})`, 'success');
              } else {
                debugLog(`⚠ Verification failed: Audit ${auditDate} not found in Supabase yet`, 'warn');
                showStatus(`⚠ Audit save reported success but verification pending (${auditDate})`, 'warn');
              }
            } else {
              debugLog(`⚠ Could not verify audit save: ${verifyResponse.status}`, 'warn');
              showStatus(`✓ Audit saved to Supabase (${auditDate}) - verification skipped`, 'success');
            }
          } catch (verifyError) {
            debugLog(`⚠ Verification error (non-critical): ${verifyError.message}`, 'warn');
            showStatus(`✓ Audit saved to Supabase (${auditDate})`, 'success');
          }
          
          // After saving, refresh Money Pages charts with updated history
          // This ensures the trend chart and KPI tracker show the new audit data
          try {
            debugLog('Refreshing Money Pages charts with updated history...', 'info');
            
            // Fetch updated history for Money Pages trend chart
            const endDate = new Date().toISOString().split('T')[0];
            const startDate = new Date();
            startDate.setFullYear(startDate.getFullYear() - 1);
            const startDateStr = startDate.toISOString().split('T')[0];
            
            const historyResponse = await fetch(apiUrl(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDate}`));
            if (historyResponse.ok) {
              const historyJson = await historyResponse.json();
              if (historyJson.status === 'ok' && historyJson.data) {
                // Render Money Pages trend chart with updated history
                if (typeof renderMoneyPagesTrendChart === 'function') {
                  setTimeout(() => {
                    renderMoneyPagesTrendChart(historyJson.data);
                    debugLog('✓ Money Pages trend chart refreshed', 'success');
                  }, 500); // Small delay to ensure DOM is ready
                }
                
                // Refresh KPI tracker
                if (typeof loadAuditHistoryAndRenderKpis === 'function') {
                  setTimeout(() => {
                    loadAuditHistoryAndRenderKpis(propertyUrl);
                    debugLog('✓ Money Pages KPI tracker refreshed', 'success');
                  }, 500);
                }
              }
            }
          } catch (refreshError) {
            debugLog(`⚠ Error refreshing Money Pages charts: ${refreshError.message}`, 'warn');
            // Don't fail the save operation if refresh fails
          }
        } else {
          // Read response body once as text, then try to parse as JSON to avoid "body stream already read" error
          let errorMessage = 'Unknown error';
          let errorDetails = null;
          try {
            const responseText = await response.text();
            // Try to parse as JSON
            try {
              const error = JSON.parse(responseText);
              errorMessage = error.message || error.details || responseText;
              errorDetails = error;
            } catch (parseError) {
              // Not JSON, use text as-is
              errorMessage = responseText || `HTTP ${response.status}: ${response.statusText}`;
            }
          } catch (textError) {
            errorMessage = `HTTP ${response.status}: ${response.statusText}`;
          }
          // Log detailed error for debugging
          console.error('[Supabase Save] Failed to save audit results to Supabase');
          console.error('[Supabase Save] Status:', response.status, response.statusText);
          console.error('[Supabase Save] Error message:', errorMessage);
          if (errorDetails) {
            console.error('[Supabase Save] Full error details:', JSON.stringify(errorDetails, null, 2));
          }
          // Show error to user - this is critical for data persistence
          debugLog(`✗ FAILED to save audit to Supabase: ${errorMessage}`, 'error');
          showStatus(`⚠ Audit completed but failed to save to Supabase: ${errorMessage}. Check console for details.`, 'error');
        }
      } catch (error) {
        // Show error to user - this is critical for data persistence
        debugLog(`✗ Supabase save exception: ${error.message}`, 'error');
        console.error('[Supabase Save] Exception:', error);
        showStatus(`✗ Failed to save audit to Supabase: ${error.message}. Check console for details.`, 'error');
      }
    }
    
    // Fetch historical Content/Schema data from Supabase
    // Forward-fill missing audit dates in history data (exclude last 3 days due to GSC lag)
    function forwardFillHistoryData(history, excludeLastDays = 3) {
      if (!history || history.length === 0) return history;
      
      // Sort by date
      const sorted = [...history].sort((a, b) => new Date(a.date) - new Date(b.date));
      
      // Calculate cutoff date (exclude last N days)
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - excludeLastDays);
      
      // Track last known values for each metric
      const lastValues = {};
      
      // Forward-fill missing values (but not for dates in the last N days)
      return sorted.map(entry => {
        const entryDate = new Date(entry.date);
        const isRecent = entryDate >= cutoffDate;
        
        // List of metric keys to forward-fill
        const metricKeys = [
          'contentSchemaScore', 'visibilityScore', 'authorityScore', 'localEntityScore', 'serviceAreaScore',
          'brandScore', 'moneyPagesBehaviourScore', 'shareOfImpressions', 'shareOfClicks', 'ctr',
          'authorityBehaviourScore', 'authorityRankingScore', 'authorityBacklinkScore', 'authorityReviewScore'
        ];
        
        const filled = { ...entry };
        
        for (const key of metricKeys) {
          const value = entry[key];
          
          // Only forward-fill if:
          // 1. Value is null/undefined (NOT 0, as 0 is a valid score) AND
          // 2. We have a last known value AND
          // 3. This is NOT a recent date (within last N days)
          if ((value == null || value === undefined) && lastValues[key] != null && !isRecent) {
            filled[key] = lastValues[key];
          } else if (value != null && value !== undefined) {
            // Update last known value (including 0, as it's a valid score)
            lastValues[key] = value;
          }
        }
        
        // Handle nested objects (e.g., moneyPagesSummary)
        if (entry.moneyPagesSummary) {
          filled.moneyPagesSummary = { ...entry.moneyPagesSummary };
          const summaryKeys = ['shareOfImpressions', 'shareOfClicks', 'ctr'];
          for (const key of summaryKeys) {
            const value = entry.moneyPagesSummary[key];
            if ((value == null || value === undefined) && lastValues[`summary_${key}`] != null && !isRecent) {
              filled.moneyPagesSummary[key] = lastValues[`summary_${key}`];
            } else if (value != null && value !== undefined) {
              lastValues[`summary_${key}`] = value;
            }
          }
        }
        
        return filled;
      });
    }
    
    async function fetchContentSchemaHistory(propertyUrl, startDate, endDate) {
      try {
        // Use window.apiUrl if available (for functions outside the main scope)
        const urlHelper = window.apiUrl || ((path) => {
          // Fallback: check if running locally and prepend Vercel URL
          const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
          const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
          if (!baseUrl) {
            return path.startsWith('/') ? path : `/${path}`;
          }
          const cleanPath = path.startsWith('/') ? path : `/${path}`;
          return `${baseUrl}${cleanPath}`;
        });
        const response = await fetch(urlHelper(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDate}&endDate=${endDate}`));
        
        if (response.ok) {
          const result = await response.json();
          if (result.status === 'ok' && result.data) {
            debugLog(`✓ Fetched ${result.count} historical Content/Schema records from Supabase`, 'success');
            // Forward-fill missing audit dates (exclude last 3 days for GSC lag)
            const filledData = forwardFillHistoryData(result.data, 3);
            return filledData;
          }
          } else {
            // Read response body once as text, then try to parse as JSON to avoid "body stream already read" error
            debugLog(`⚠ Supabase API returned non-OK status: ${response.status} ${response.statusText}`, 'warn');
            try {
              const responseText = await response.text();
              try {
                const error = JSON.parse(responseText);
                debugLog(`⚠ Supabase API error: ${error.message || 'Unknown error'}`, 'warn');
              } catch (parseError) {
                debugLog(`⚠ Supabase API error (non-JSON): ${responseText || 'Unknown error'}`, 'warn');
              }
            } catch (textError) {
              debugLog(`⚠ Could not read Supabase error response: ${textError.message}`, 'warn');
            }
          }
      } catch (error) {
        debugLog(`⚠ Supabase fetch error: ${error.message}`, 'warn');
      }
      return [];
    }
    
    // Fetch the latest audit from Supabase
    async function fetchLatestAuditFromSupabase(propertyUrl, minimalOnly = false) {
      try {
        if (!propertyUrl) {
          debugLog('⚠ Cannot fetch from Supabase: property URL not set', 'warn');
          return null;
        }
        
        // Use window.apiUrl if available (for functions outside the main scope)
        const urlHelper = window.apiUrl || ((path) => {
          // Fallback: check if running locally and prepend Vercel URL
          const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
          const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
          if (!baseUrl) {
            return path.startsWith('/') ? path : `/${path}`;
          }
          const cleanPath = path.startsWith('/') ? path : `/${path}`;
          return `${baseUrl}${cleanPath}`;
        });
        
        // Step 1: Try minimal request first to get timestamp (fast, unlikely to timeout)
        let minimalData = null;
        if (!minimalOnly) {
          debugLog(`Fetching minimal audit data (timestamp + scores) from Supabase for ${propertyUrl}...`, 'info');
          try {
            const minimalController = new AbortController();
            const minimalTimeout = setTimeout(() => minimalController.abort(), 10000); // 10 second timeout
            
            const minimalResponse = await fetch(urlHelper(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}&minimal=true`), {
              signal: minimalController.signal
            });
            clearTimeout(minimalTimeout);
            
            if (minimalResponse.ok) {
              const minimalResult = await minimalResponse.json();
              if (minimalResult.status === 'ok' && minimalResult.data && minimalResult.data.timestamp) {
                minimalData = minimalResult.data; // Store minimal data for fallback
                // Update timestamp immediately, even if full data fetch fails
                updateAuditTimestamp(minimalResult.data.timestamp);
                debugLog(`✓ Updated audit timestamp from minimal Supabase response: ${new Date(minimalResult.data.timestamp).toLocaleString()}`, 'success');
              }
            }
          } catch (minimalError) {
            if (minimalError.name === 'AbortError') {
              debugLog(`⚠ Minimal request timed out (non-critical)`, 'warn');
            } else {
              debugLog(`⚠ Minimal request failed (non-critical): ${minimalError.message}`, 'warn');
            }
            // Continue to try full request
          }
        }
        
        // Step 2: Try full request (may timeout, but we already have timestamp)
        debugLog(`Fetching full audit data from Supabase for ${propertyUrl}...`, 'info');
        try {
          const fullController = new AbortController();
          const fullTimeout = setTimeout(() => fullController.abort(), 30000); // 30 second timeout
          
          const response = await fetch(urlHelper(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`), {
            signal: fullController.signal
          });
          clearTimeout(fullTimeout);
          
          if (response.ok) {
            const result = await response.json();
            debugLog(`📊 Supabase API response: status=${result.status}, hasData=${!!result.data}`, result.status === 'ok' && result.data ? 'success' : 'warn');
            if (result.status === 'ok' && result.data) {
              debugLog(`✓ Found latest audit from Supabase: ${result.data.auditDate || 'unknown date'}`, 'success');
              // Debug: Check what moneyPagesMetrics structure we got
              const hasMoneyPages = !!(result.data?.scores?.moneyPagesMetrics || result.data?.moneyPagesMetrics);
              debugLog(`✓ Supabase data check: hasMoneyPagesMetrics=${hasMoneyPages}, structure=${result.data?.scores?.moneyPagesMetrics ? 'scores.moneyPagesMetrics' : result.data?.moneyPagesMetrics ? 'moneyPagesMetrics' : 'none'}`, 'info');
              if (hasMoneyPages) {
                const rows = result.data?.scores?.moneyPagesMetrics?.rows || result.data?.moneyPagesMetrics?.rows || [];
                debugLog(`✓ Supabase moneyPagesMetrics has ${rows.length} rows`, 'success');
              } else {
                debugLog(`⚠ Supabase data missing moneyPagesMetrics!`, 'warn');
              }
              // Debug: Check queryTotals in response
              const hasQueryTotals = !!(result.data?.searchData?.queryTotals && Array.isArray(result.data.searchData.queryTotals));
              debugLog(`📊 Supabase queryTotals check: hasSearchData=${!!result.data?.searchData}, hasQueryTotals=${hasQueryTotals}, length=${result.data?.searchData?.queryTotals?.length || 0}`, hasQueryTotals ? 'success' : 'warn');
              if (result.data.searchData) {
                debugLog(`📊 Supabase searchData keys: ${Object.keys(result.data.searchData).join(', ')}`, 'info');
              } else {
                debugLog(`⚠ Supabase data missing searchData!`, 'warn');
              }
              // Ensure timestamp is set from Supabase data (use timestamp if available, otherwise construct from auditDate)
              if (result.data.timestamp) {
                // Convert to ISO string if it's a number (milliseconds since epoch)
                if (typeof result.data.timestamp === 'number') {
                  result.data.timestamp = new Date(result.data.timestamp).toISOString();
                }
                // Timestamp is already set (and now in ISO string format)
              } else if (result.data.auditDate) {
                // Construct timestamp from auditDate (use noon as default time to avoid timezone issues)
                const auditDateStr = result.data.auditDate;
                result.data.timestamp = new Date(auditDateStr + 'T12:00:00').toISOString();
                debugLog(`✓ Constructed timestamp from auditDate: ${auditDateStr}`, 'info');
              }
              // Update timestamp display immediately when Supabase data is loaded
              if (result.data.timestamp) {
                updateAuditTimestamp(result.data.timestamp);
                debugLog(`✓ Updated audit timestamp display from Supabase data`, 'success');
              }
              return result.data;
            } else {
              debugLog(`⚠ No audit found in Supabase - result.status=${result.status}, hasData=${!!result.data}, error=${result.message || 'none'}`, 'warn');
              // Return minimal data if available, otherwise null
              if (minimalData) {
                debugLog(`⚠ Returning minimal data (timestamp + scores) as fallback`, 'info');
                return minimalData;
              }
              return null;
            }
          } else {
            const responseText = await response.text();
            try {
              const error = JSON.parse(responseText);
              debugLog(`⚠ Could not fetch latest audit from Supabase: ${error.message || 'Unknown error'}`, 'warn');
              if (error.message && error.message.includes('FUNCTION_INVOCATION_FAILED')) {
                debugLog(`⚠ Full data fetch failed due to timeout/size. Returning minimal data (timestamp + scores) as fallback.`, 'warn');
                if (minimalData) {
                  return minimalData;
                }
              }
            } catch (parseError) {
              debugLog(`⚠ Could not fetch latest audit from Supabase: ${responseText || 'Unknown error'}`, 'warn');
            }
            // Return minimal data if available, otherwise null
            if (minimalData) {
              debugLog(`⚠ Returning minimal data (timestamp + scores) as fallback after full request failure`, 'info');
              return minimalData;
            }
            return null;
          }
        } catch (error) {
          if (error.name === 'AbortError' || error.name === 'TimeoutError' || error.message.includes('timeout')) {
            debugLog(`⚠ Supabase fetch timed out. Returning minimal data (timestamp + scores) as fallback.`, 'warn');
            if (minimalData) {
              return minimalData;
            }
          } else {
            debugLog(`⚠ Supabase fetch error: ${error.message}`, 'warn');
          }
          // Return minimal data if available, otherwise null
          if (minimalData) {
            debugLog(`⚠ Returning minimal data (timestamp + scores) as fallback after error`, 'info');
            return minimalData;
          }
          return null;
        }
      } catch (outerError) {
        // Catch any errors in the outer try block (shouldn't happen, but just in case)
        debugLog(`⚠ Outer error in fetchLatestAuditFromSupabase: ${outerError.message}`, 'warn');
        if (minimalData) {
          return minimalData;
        }
        return null;
      }
    }
    
    // Update retry button visibility based on failed URLs
    function updateRetryButtonVisibility(schemaAudit) {
      const retryBtn = document.getElementById('retryFailedUrlsBtn');
      if (!retryBtn) return;
      
      if (schemaAudit && schemaAudit.data && schemaAudit.data.missingSchemaPages) {
        const failedUrls = schemaAudit.data.missingSchemaPages.filter(p => p.error);
        if (failedUrls.length > 0) {
          retryBtn.style.display = 'inline-block';
          retryBtn.textContent = `🔄 Retry Failed URLs (${failedUrls.length})`;
        } else {
          retryBtn.style.display = 'none';
        }
      } else {
        retryBtn.style.display = 'none';
      }
    }

    // Close completion modal
    function closeCompletionModal() {
      const modal = document.getElementById('completionModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    // Close modal when clicking outside
    window.onclick = function(event) {
      const modal = document.getElementById('completionModal');
      if (event.target === modal) {
        closeCompletionModal();
      }
    }

    // Calculate RAG status from score
    function getRAGStatus(score) {
      if (score >= 70) return { status: 'green', label: 'Green' };
      if (score >= 40) return { status: 'amber', label: 'Amber' };
      return { status: 'red', label: 'Red' };
    }

    // Helper: clamp score to 0-100 and round
    function clampScore(value) {
      return Math.max(0, Math.min(100, Math.round(value)));
    }

    // Calculate pillar scores (deterministic, based on GSC data and schema audit)
    
    // Page Segment Classifier
    // NOTE: PageSegment classification is derived from the canonical site-urls CSV.
    // GSC page URLs are matched by path against this inventory and then classified by
    // classifyPageSegment(...) to keep behaviour/ranking segments aligned with the UI.
    const PageSegment = {
      EDUCATION: 'education',
      MONEY: 'money',
      SUPPORT: 'support',
      SYSTEM: 'system'
    };
    
    /**
     * Canonicalize URL - removes query params, fragments, normalizes trailing slashes
     * Returns full URL with origin and path only (no query/hash)
     * @param {string} raw - Raw URL (may contain query params, fragments)
     * @returns {string} Canonical URL
     */
    function canonicalizeUrl(raw) {
      if (!raw) return "";
      
      try {
        const u = raw.startsWith("http") ? new URL(raw) : new URL(raw, "https://www.alanranger.com");
        let path = u.pathname || "/";
        if (path.length > 1) path = path.replace(/\/+$/, "");
        return `${u.origin}${path}`;
      } catch {
        const noHash = raw.split("#")[0];
        const noQuery = noHash.split("?")[0];
        return (noQuery.replace(/\/+$/, "") || raw).trim();
      }
    }
    
    function normalisePath(rawUrlOrPath) {
      try {
        let url;
        if (rawUrlOrPath && rawUrlOrPath.startsWith('http')) {
          url = new URL(rawUrlOrPath);
        } else {
          url = new URL(rawUrlOrPath || '/', 'https://www.alanranger.com');
        }
        let p = url.pathname.toLowerCase();
        if (p.length > 1 && p.endsWith('/')) p = p.slice(0, -1);
        return p;
      } catch {
        return '/';
      }
    }
    
    function isFineArtGalleryPage(path) {
      const p = path.toLowerCase();
      // Explicit known fine-art URLs from 06-site-urls.csv
      if (
        p === '/fine-art-prints' ||
        p === '/photography-services-near-me/fine-art-photography-prints-unframed' ||
        p === '/photography-services-near-me/framed-fine-art-photography-prints' ||
        p === '/photography-services-near-me/fine-art-photography-prints-canvas'
      ) {
        return true;
      }
      // Safety net: treat any future fine-art print variants as gallery/info too
      return (
        p.includes('fine-art-prints') ||
        p.includes('fine-art-photography-prints')
      );
    }
    
    function classifyPageSegment(rawUrlOrPath, title = null, kindOverride = null) {
      const path = normalisePath(rawUrlOrPath);
      
      // Manual overrides via CSV column
      if (kindOverride) {
        const v = kindOverride.toLowerCase().trim();
        if (v === 'education' || v === 'educational') return PageSegment.EDUCATION;
        if (v === 'money' || v === 'commercial') return PageSegment.MONEY;
        if (v === 'support') return PageSegment.SUPPORT;
        if (v === 'system') return PageSegment.SYSTEM;
      }
      
      // Education — all blogs + free course + calculator + tips hub
      // EXCLUDE blog posts from money pages (check both /blog-on-photography/ and /blogs/)
      if (path.startsWith('/blog-on-photography/') || path.startsWith('/blogs/')) return PageSegment.EDUCATION;
      if (
        path === '/blog-on-photography' ||
        path === '/blogs' ||
        path === '/free-online-photography-course' ||
        path === '/outdoor-photography-exposure-calculator' ||
        path === '/free-photography-tips' ||
        path === '/photography-news-blog'
      ) {
        return PageSegment.EDUCATION;
      }
      
      // Fine-art gallery pages — portfolio/informational, NOT money pages
      // These must be checked BEFORE money classification
      if (isFineArtGalleryPage(path)) return PageSegment.SYSTEM;
      
      // Support pages (must be checked before money classification)
      const SUPPORT_EXACT = new Set([
        '/', '/about-alan-ranger', '/testimonials-customer-reviews', '/awards-and-qualifications',
        '/gallery-image-portfolios', '/help-site-map', '/help-portrait-uk-coventry',
        '/photography-equipment-recommendations', '/newsletter-signup-form',
        '/which-photography-style-is-right-for-you', '/contact-us',
      ]);
      if (SUPPORT_EXACT.has(path)) return PageSegment.SUPPORT;
      
      // Money pages = Events + Products + Landing pages (excluding blog posts)
      // Events: URLs starting with specific paths (check both with and without trailing slash)
      if (path.startsWith('/beginners-photography-lessons/') || 
          path.startsWith('/beginners-photography-lessons') ||
          path.startsWith('/photographic-workshops-near-me/') ||
          path.startsWith('/photographic-workshops-near-me')) {
        return PageSegment.MONEY;
      }
      
      // Products: URLs starting with specific paths (check both with and without trailing slash)
      if (path.startsWith('/photo-workshops-uk/') || 
          path.startsWith('/photo-workshops-uk') ||
          path.startsWith('/photography-services-near-me/') ||
          path.startsWith('/photography-services-near-me')) {
        return PageSegment.MONEY;
      }
      
      // Legacy exact matches for money pages (keep for backward compatibility)
      const MONEY_EXACT = new Set([
        '/photography-workshops', '/photography-workshops-near-me', '/photography-workshops-uk',
        '/landscape-photography-workshops', '/outdoor-photography-workshops',
        '/photographic-workshops-near-me', '/photographic-workshops-uk',
        '/photography-courses-coventry', '/course-finder-photography-classes-near-me',
        '/photography-tuition-services', '/photography-services-near-me', '/photography-shop-services',
        '/rps-courses-mentoring-distinctions', '/hire-a-professional-photographer-in-coventry',
        '/professional-commercial-photographer-coventry', '/professional-photographer-near-me',
        '/coventry-photographer', '/photographer-in-coventry', '/photography-mentoring-programme',
        '/photography-academy-membership', '/photography-academy', '/photography-session-vouchers',
        '/photography-gift-vouchers', '/photography-presents-for-photographers',
        '/batsford-arboretum-photography', '/bluebell-woods-near-me',
      ]);
      if (MONEY_EXACT.has(path)) return PageSegment.MONEY;
      
      // Landing pages: Everything else that's NOT blog posts, education, support, or system
      // Default to MONEY (landing page) if it's not a blog post and doesn't match other categories
      // This ensures all non-blog pages are treated as money pages (landing pages) by default
      // Only exclude fine-art gallery pages from being money pages
      if (!isFineArtGalleryPage(path)) {
        // If we've gotten here, it's not education, support, system, or fine-art
        // So it must be a money page (landing page)
        return PageSegment.MONEY;
      }
      
      // Everything else = system (only fine-art gallery pages should reach here)
      return PageSegment.SYSTEM;
    }
    
    /**
     * Shared classification function for Ranking & AI tab
     * Returns both segment (Brand/Education/Money/Other) and pageType (Landing/Blog/Event/Product/GBP)
     * Uses canonical classification from Money Pages logic
     * @param {string} rawUrlOrPath - URL or path to classify
     * @param {string} keyword - Optional keyword for brand detection
     * @returns {{segment: string, pageType: string}}
     */
    function classifyUrlForRankingAi(rawUrlOrPath, keyword = null) {
      // Normalize URL to lowercase for consistent matching
      const urlLower = (rawUrlOrPath || "").toLowerCase();
      const path = normalisePath(rawUrlOrPath);
      
      // Brand detection: check keyword first
      if (keyword) {
        const kw = (keyword || "").toLowerCase();
        if (kw.includes("alan ranger") || kw.includes("alanranger")) {
          return { segment: "Brand", pageType: "GBP" };
        }
      }
      
      // If URL is missing/blank, return Other
      if (!rawUrlOrPath || !path) {
        return { segment: "Other", pageType: "Other" };
      }
      
      // STEP 1: Check Event pages FIRST (before Blog/GBP/Landing)
      // Event if URL contains:
      // - alanranger.com/beginners-photography-lessons/
      // - alanranger.com/photographic-workshops-near-me
      if (urlLower.includes('/beginners-photography-lessons') ||
          urlLower.includes('/photographic-workshops-near-me')) {
        return { segment: "Money", pageType: "Event" };
      }
      
      // STEP 2: Check Product pages (before Blog/GBP/Landing)
      // Product if URL contains:
      // - alanranger.com/photo-workshops-uk/
      // - alanranger.com/photography-services-near-me/
      if (urlLower.includes('/photo-workshops-uk') ||
          urlLower.includes('/photography-services-near-me')) {
        return { segment: "Money", pageType: "Product" };
      }
      
      // STEP 3: Check for Blog pages (Education segment)
      if (path.startsWith('/blog-on-photography/') || path.startsWith('/blogs/')) {
        return { segment: "Education", pageType: "Blog" };
      }
      
      // STEP 4: Check for GBP/Home/About pages (Brand segment)
      if (path === '/' ||
          path === '/about-alan-ranger' ||
          path.includes('/contact') ||
          path.includes('/reviews')) {
        return { segment: "Brand", pageType: "GBP" };
      }
      
      // STEP 5: Use canonical page classification for remaining pages
      // Try window.classifyMoneyPage first (if available), then fallback to local scope
      let isMoney = false;
      let segmentType = null;
      
      const classifyMoneyPageFn = (typeof window !== 'undefined' && window.classifyMoneyPage)
        ? window.classifyMoneyPage
        : (typeof classifyMoneyPage !== 'undefined' ? classifyMoneyPage : null);
      
      if (classifyMoneyPageFn) {
        try {
          const result = classifyMoneyPageFn(rawUrlOrPath);
          isMoney = result.isMoney;
          segmentType = result.segmentType;
        } catch (e) {
          const segment = classifyPageSegment(rawUrlOrPath);
          isMoney = segment === PageSegment.MONEY;
          segmentType = isMoney ? 'landing' : null;
        }
      } else {
        const segment = classifyPageSegment(rawUrlOrPath);
        isMoney = segment === PageSegment.MONEY;
        segmentType = isMoney ? 'landing' : null;
        if (window.DEBUG_MODE) {
          debugLog('⚠ classifyMoneyPage not available, using fallback classification', 'warn');
        }
      }
      
      // Determine pageType from canonical segmentType (for remaining pages)
      let pageType = "Landing"; // Default
      if (segmentType === "event") {
        pageType = "Event";
      } else if (segmentType === "product") {
        pageType = "Product";
      } else if (segmentType === "landing" || segmentType === "all") {
        pageType = "Landing";
      } else if (isMoney) {
        pageType = "Landing";
      } else {
        pageType = "Other";
      }
      
      // Determine segment from pageType and canonical classification
      let segment = "Other"; // Default
      
      // Brand: home page, about, contact, reviews, or brand keywords
      if (pageType === "GBP" || path === '/' || path === '/about-alan-ranger') {
        segment = "Brand";
      }
      // Money: Landing, Event, or Product page types
      else if (pageType === "Landing" || pageType === "Event" || pageType === "Product") {
        segment = "Money";
      }
      // Education: Blog pages or free course/educational content
      else if (pageType === "Blog" || 
               path === '/free-online-photography-course' ||
               path === '/outdoor-photography-exposure-calculator' ||
               path === '/free-photography-tips') {
        segment = "Education";
      }
      // Everything else is Other
      
      return { segment, pageType };
    }
    
    // Make available globally for RankingAiModule
    if (typeof window !== 'undefined') {
      window.classifyUrlForRankingAi = classifyUrlForRankingAi;
    }
    
    // Helper functions for Authority score calculation
    function normalisePct(value, max) {
      // value in 0-1 range; scale to 0-100 and cap
      const pct = Math.max(0, Math.min(1, value / max));
      return pct * 100;
    }

    function normalisePosition(pos, minPos, maxPos) {
      // map [minPos..maxPos] -> [100..10], clamp outside range
      const clamped = Math.max(minPos, Math.min(maxPos, pos));
      const t = (clamped - minPos) / (maxPos - minPos); // 0..1
      return 100 - t * 90; // 100 at best, 10 at worst
    }

    // Raw Behaviour score calculation (internal, used by segmented version)
    // ============================================================================
    // PHASE 1: Brand Overlay Metrics
    // ============================================================================
    
    /**
     * @typedef {Object} BrandOverlay
     * @property {number} score - 0-100
     * @property {'Weak'|'Developing'|'Strong'} label
     * @property {number} brandQueryShare - 0-1, impressions share
     * @property {number} brandCtr - 0-1
     * @property {number} brandAvgPosition - numeric position
     * @property {number} reviewScore - 0-100, from existing review metrics
     * @property {number} entityScore - 0-100, based on knowledge panel / GBP presence
     * @property {string[]} notes - short machine-generated reasons for the label
     */
    
    /**
     * @typedef {Object} AiSummaryLikelihood
     * @property {number} score - 0-100 composite
     * @property {'Low'|'Medium'|'High'} label
     * @property {string[]} reasons - short bullets used in UI tooltip / priorities
     */
    
    /**
     * @typedef {"LOW" | "MEDIUM" | "HIGH"} PriorityLevel
     */
    
    /**
     * @typedef {"LOW" | "MEDIUM" | "HIGH"} ImpactLevel
     */
    
    /**
     * @typedef {"LOW" | "MEDIUM" | "HIGH"} DifficultyLevel
     */
    
    /**
     * @typedef {"all" | "landing" | "event" | "product"} MoneySegmentKey
     */
    
    /**
     * @typedef {Object} MoneyPageMetrics
     * @property {string} url
     * @property {string} title
     * @property {MoneySegmentKey} segmentType       // landing / event / product / (fallback "all")
     * @property {number} clicks
     * @property {number} impressions
     * @property {number} ctr                        // 0–1 decimal
     * @property {number} avgPosition
     * @property {ImpactLevel} impactLevel
     * @property {DifficultyLevel} difficultyLevel
     * @property {PriorityLevel} priorityLevel
     * @property {number} [_lostClicks]              // Internal: calculated lost clicks
     */
    
    /**
     * Per audit, stored for history in Supabase.
     *
     * @typedef {Object} MoneySegmentSummary
     * @property {number} clicks
     * @property {number} impressions
     * @property {number} ctr           // 0–1 decimal
     * @property {number} avgPosition
     * @property {number} behaviourScore
     */
    
    /**
     * @typedef {Object} MoneySegmentMetricsByAudit
     * @property {MoneySegmentSummary} allMoney
     * @property {MoneySegmentSummary} landingPages
     * @property {MoneySegmentSummary} eventPages
     * @property {MoneySegmentSummary} productPages
     */
    
    // Brand query classification
    const BRAND_TERMS = ['alan ranger', 'alanranger', 'alan ranger photography'];
    
    /**
     * Check if a query is a brand query
     * @param {string} query - Search query text
     * @returns {boolean}
     */
    function isBrandQuery(query) {
      if (!query || typeof query !== 'string') return false;
      const q = query.toLowerCase();
      return BRAND_TERMS.some(term => q.includes(term));
    }
    
    /**
     * Calculate brand metrics from GSC query data
     * @param {Array} queries - Array of query objects with {query, clicks, impressions, position}
     * @returns {Object} Brand metrics {brandQueryShare, brandCtr, brandAvgPosition}
     */
    function calculateBrandMetrics(queries) {
      if (!queries || !Array.isArray(queries) || queries.length === 0) {
        return {
          brandQueryShare: 0,
          brandCtr: 0,
          brandAvgPosition: null
        };
      }
      
      // Filter to ranking queries (position 1-20, with impressions)
      const ranking = queries.filter(q => {
        const pos = q.position || 0;
        const impr = q.impressions || 0;
        return pos > 0 && pos <= 20 && impr > 0;
      });
      
      if (ranking.length === 0) {
        return {
          brandQueryShare: 0,
          brandCtr: 0,
          brandAvgPosition: null
        };
      }
      
      // Split into brand vs non-brand
      const brandQueries = ranking.filter(q => isBrandQuery(q.query || ''));
      const nonBrandQueries = ranking.filter(q => !isBrandQuery(q.query || ''));
      
      // Calculate totals
      const totalImpressions = ranking.reduce((s, q) => s + (q.impressions || 0), 0);
      const brandImpressions = brandQueries.reduce((s, q) => s + (q.impressions || 0), 0);
      const brandClicks = brandQueries.reduce((s, q) => s + (q.clicks || 0), 0);
      
      // Brand query share (0-1)
      const brandQueryShare = totalImpressions > 0 ? brandImpressions / totalImpressions : 0;
      
      // Brand CTR (0-1)
      const brandCtr = brandImpressions > 0 ? brandClicks / brandImpressions : 0;
      
      // Brand average position (weighted by impressions)
      const brandAvgPosition = brandImpressions > 0
        ? brandQueries.reduce((s, q) => s + (q.position || 0) * (q.impressions || 0), 0) / brandImpressions
        : null;
      
      return {
        brandQueryShare,
        brandCtr,
        brandAvgPosition
      };
    }
    
    /**
     * Normalize position to 0-100 score (for brand overlay)
     * @param {number|null} pos - Position value
     * @param {number} minPos - Minimum position (default 1)
     * @param {number} maxPos - Maximum position (default 10)
     * @returns {number} Score 0-100
     */
    function normalisePositionForBrand(pos, minPos = 1, maxPos = 10) {
      if (pos == null) return 0;
      const clamped = Math.max(minPos, Math.min(maxPos, pos));
      const t = (clamped - minPos) / (maxPos - minPos); // 0..1
      return 100 - t * 100;
    }
    
    /**
     * Compute Brand Overlay score
     * @param {Object} args - Brand overlay parameters
     * @param {number} args.brandQueryShare - 0-1, impressions share
     * @param {number} args.brandCtr - 0-1
     * @param {number|null} args.brandAvgPosition - numeric position
     * @param {number} args.reviewScore - 0-100, from existing Authority review score
     * @param {number} args.entityScore - 0-100, from Local Entity pillar
     * @returns {BrandOverlay}
     */
    function computeBrandOverlay(args) {
      const {
        brandQueryShare = 0,
        brandCtr = 0,
        brandAvgPosition = null,
        reviewScore = 0,
        entityScore = 0
      } = args;
      
      // Brand search component
      const shareScore = Math.min(brandQueryShare / 0.30, 1) * 100; // 30%+ share = 100
      const ctrScore = Math.min(brandCtr / 0.40, 1) * 100; // 40%+ CTR = 100
      const posScore = normalisePositionForBrand(brandAvgPosition, 1, 10);
      
      const brandSearchScore =
        0.4 * shareScore +
        0.3 * ctrScore +
        0.3 * posScore;
      
      // Combine with review + entity strength
      const combined =
        0.4 * brandSearchScore +
        0.3 * reviewScore +
        0.3 * entityScore;
      
      let label;
      if (combined < 40) label = 'Weak';
      else if (combined < 70) label = 'Developing';
      else label = 'Strong';
      
      const notes = [];
      if (brandQueryShare < 0.1) notes.push('Low share of branded searches in GSC.');
      if (brandCtr < 0.25) notes.push('Branded CTR is below 25%.');
      if (brandAvgPosition == null || brandAvgPosition > 5)
        notes.push('Branded queries do not consistently rank in top-5.');
      if (reviewScore < 70) notes.push('Review rating / volume is still maturing.');
      if (entityScore < 70) notes.push('Knowledge-panel / entity coverage could be stronger.');
      
      return {
        score: Math.round(combined),
        label,
        brandQueryShare,
        brandCtr,
        brandAvgPosition: brandAvgPosition ?? 0,
        reviewScore,
        entityScore,
        notes
      };
    }
    
    /**
     * Compute AI Summary Likelihood
     * @param {number} snippetReadinessScore - Existing donut score
     * @param {number} visibilityScore - Current Visibility pillar score
     * @param {number} brandScore - Brand overlay score
     * @returns {AiSummaryLikelihood}
     */
    function computeAiSummaryLikelihood(snippetReadinessScore, visibilityScore, brandScore) {
      const composite =
        0.5 * snippetReadinessScore +
        0.3 * visibilityScore +
        0.2 * brandScore;
      
      // Use same RAG bands as GAIO Score: ≥70 High (green), ≥50 Medium (amber), <50 Low (red)
      let label;
      if (composite < 50) label = 'Low';
      else if (composite < 70) label = 'Medium';
      else label = 'High';
      
      const reasons = [];
      
      if (snippetReadinessScore < 70)
        reasons.push('Improve FAQ/HowTo/Article blocks and schema to raise snippet readiness.');
      if (visibilityScore < 70)
        reasons.push('Improve average position and top-10 impression share.');
      if (brandScore < 70)
        reasons.push('Strengthen branded search and entity signals.');
      
      return {
        score: Math.round(composite),
        label,
        reasons
      };
    }
    
    // ============================================================================
    // End Phase 1: Brand Overlay Metrics
    // ============================================================================

    function computeBehaviourScoreRaw(queries) {
      if (!queries || !Array.isArray(queries) || queries.length === 0) {
        return 50; // neutral fallback
      }

      // Filter to ranking queries (position > 0, <= 20, with impressions)
      const ranking = queries.filter(q => q.position > 0 && q.position <= 20 && q.impressions > 0);

      if (ranking.length === 0) {
        return 50; // neutral fallback
      }

      // Calculate CTR for all ranking queries
      const totalClicks = ranking.reduce((s, q) => s + q.clicks, 0);
      const totalImpr = ranking.reduce((s, q) => s + q.impressions, 0);
      const ctrAll = totalImpr > 0 ? totalClicks / totalImpr : 0; // 0-1

      // Calculate CTR for top-10 queries
      const top10 = ranking.filter(q => q.position <= 10);
      const top10Clicks = top10.reduce((s, q) => s + q.clicks, 0);
      const top10Impr = top10.reduce((s, q) => s + q.impressions, 0);
      const ctrTop10 = top10Impr > 0 ? top10Clicks / top10Impr : ctrAll;

      // Normalize CTR scores: 5% CTR = 100 for all ranking, 10% CTR = 100 for top-10
      // ctrAll 0-5% → 0-100 (values >5% capped at 100)
      // ctrTop10 0-10% → 0-100 (values >10% capped at 100)
      const ctrScoreAll = normalisePct(ctrAll, 0.05); // 5% overall CTR -> 100
      const ctrScoreTop10 = normalisePct(ctrTop10, 0.10); // 10% top-10 CTR -> 100

      // Combine: 50% ctrAll + 50% ctrTop10
      return 0.5 * ctrScoreAll + 0.5 * ctrScoreTop10; // 0-100
    }
    
    // Public Behaviour score (backward compatible, uses all queries)
    function computeBehaviourScore(queries) {
      return computeBehaviourScoreRaw(queries);
    }
    
    // Segmented Behaviour score calculation
    // queryPages: Array of {query, page, clicks, impressions, ctr, position}
    // Returns: {all, nonBlog, money}
    function computeBehaviourScoreWithSegment(queryPages) {
      if (!queryPages || !Array.isArray(queryPages) || queryPages.length === 0) {
        return { all: 50, nonBlog: 50, money: 50 };
      }
      
      // Classify each query+page row by page segment
      const withSegment = queryPages.map(row => {
        const segment = classifyPageSegment(row.page || row.url || '/');
        return { ...row, __segment: segment };
      });
      
      // Convert to format expected by computeBehaviourScoreRaw
      const toQueryFormat = (rows) => rows.map(r => ({
        clicks: r.clicks || 0,
        impressions: r.impressions || 0,
        ctr: (r.ctr || 0) / 100, // Convert percentage to decimal
        position: r.position || 0
      }));
      
      // All queries
      const all = computeBehaviourScoreRaw(toQueryFormat(withSegment));
      
      // Non-blog (exclude education)
      const nonBlog = computeBehaviourScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment !== PageSegment.EDUCATION))
      );
      
      // Money pages only
      const money = computeBehaviourScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment === PageSegment.MONEY))
      );
      
      return { all, nonBlog, money };
    }

    // Raw Ranking score calculation (internal, used by segmented version)
    function computeRankingScoreRaw(queries) {
      if (!queries || !Array.isArray(queries) || queries.length === 0) {
        return 50; // neutral fallback
      }

      // Filter to ranking queries (position > 0, <= 20, with impressions)
      const ranking = queries.filter(q => q.position > 0 && q.position <= 20 && q.impressions > 0);

      if (ranking.length === 0) {
        return 50; // neutral fallback
      }

      // Calculate impression-weighted average position
      const totalImpr = ranking.reduce((s, q) => s + q.impressions, 0);
      const avgPos = totalImpr > 0
        ? ranking.reduce((s, q) => s + q.position * q.impressions, 0) / totalImpr
        : 0;

      // Map position: 1 → 100, 20 → 0 (clamped)
      const clampedPos = Math.max(1, Math.min(20, avgPos));
      const posScore = normalisePosition(clampedPos, 1, 20); // 0-100

      // Calculate top-10 impression share (% of impressions where position ≤ 10)
      const top10Impr = ranking
        .filter(q => q.position <= 10)
        .reduce((s, q) => s + q.impressions, 0);
      const top10Share = totalImpr > 0 ? top10Impr / totalImpr : 0; // 0-1
      const top10Score = top10Share * 100; // 0-100 (as a percentage)

      // Combine: 50% posScore + 50% top10Score
      return 0.5 * posScore + 0.5 * top10Score; // 0-100
    }
    
    // Public Ranking score (backward compatible, uses all queries)
    function computeRankingScore(queries) {
      return computeRankingScoreRaw(queries);
    }
    
    // Segmented Ranking score calculation
    // queryPages: Array of {query, page, clicks, impressions, ctr, position}
    // Returns: {all, nonBlog, money}
    function computeRankingScoreWithSegment(queryPages) {
      if (!queryPages || !Array.isArray(queryPages) || queryPages.length === 0) {
        return { all: 50, nonBlog: 50, money: 50 };
      }
      
      // Classify each query+page row by page segment
      const withSegment = queryPages.map(row => {
        const segment = classifyPageSegment(row.page || row.url || '/');
        return { ...row, __segment: segment };
      });
      
      // Convert to format expected by computeRankingScoreRaw
      const toQueryFormat = (rows) => rows.map(r => ({
        clicks: r.clicks || 0,
        impressions: r.impressions || 0,
        ctr: (r.ctr || 0) / 100, // Convert percentage to decimal
        position: r.position || 0
      }));
      
      // All queries
      const all = computeRankingScoreRaw(toQueryFormat(withSegment));
      
      // Non-blog (exclude education)
      const nonBlog = computeRankingScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment !== PageSegment.EDUCATION))
      );
      
      // Money pages only
      const money = computeRankingScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment === PageSegment.MONEY))
      );
      
      return { all, nonBlog, money };
    }

    function computeReviewScore(opts) {
      const {
        gbpRating = null,
        gbpCount = null,
        siteRating = null,
        siteCount = null
      } = opts || {};

      // Check if sources have valid data (not null, not 0, not undefined)
      const hasGBP = (gbpRating !== null && gbpRating !== undefined && gbpRating > 0) || 
                     (gbpCount !== null && gbpCount !== undefined && gbpCount > 0);
      const hasSite = (siteRating !== null && siteRating !== undefined && siteRating > 0) || 
                      (siteCount !== null && siteCount !== undefined && siteCount > 0);

      // If neither source exists, return neutral default
      if (!hasGBP && !hasSite) {
        debugLog('Review Score: No review data available (GBP or site), using neutral default (50)', 'warn');
        return 50;
      }

      const maxCount = 500; // cap so a few extra reviews don't blow up score

      let reviewScore;

      if (hasGBP && hasSite) {
        // Both sources exist: 60% GBP + 40% site
        const gbpRatingScore = ((gbpRating || 0) / 5) * 100;
        const gbpCountScore = Math.min((gbpCount || 0) / maxCount, 1) * 100;
        const gbpScore = 0.6 * gbpRatingScore + 0.4 * gbpCountScore;

        const siteRatingScore = ((siteRating || 0) / 5) * 100;
        const siteCountScore = Math.min((siteCount || 0) / maxCount, 1) * 100;
        const siteScore = 0.6 * siteRatingScore + 0.4 * siteCountScore;

        reviewScore = 0.6 * gbpScore + 0.4 * siteScore;
      } else if (hasGBP) {
        // Only GBP exists: 100% GBP
        const gbpRatingScore = ((gbpRating || 0) / 5) * 100;
        const gbpCountScore = Math.min((gbpCount || 0) / maxCount, 1) * 100;
        reviewScore = 0.6 * gbpRatingScore + 0.4 * gbpCountScore;
      } else {
        // Only site reviews exist: 100% site
        const siteRatingScore = ((siteRating || 0) / 5) * 100;
        const siteCountScore = Math.min((siteCount || 0) / maxCount, 1) * 100;
        reviewScore = 0.6 * siteRatingScore + 0.4 * siteCountScore;
      }

      return clampScore(reviewScore);
    }

    /**
     * Compute Backlink Score from backlink metrics
     * @param {Object|undefined} m - Backlink metrics object with referringDomains, totalBacklinks, followRatio
     * @returns {number} Score 0-100
     */
    function computeBacklinkScore(m) {
      if (!m) {
        // If metrics not present at all, return 0 (no backlink data)
        return 0;
      }

      const rd = m.referringDomains ?? 0;
      // If followRatio is missing, it means data integrity issue - log warning and use 0
      const fb = m.followRatio ?? (() => {
        debugLog('⚠ Backlink metrics missing followRatio - data integrity issue', 'warn');
        return 0;
      })();

      // If no backlinks at all, score is 0
      if (rd === 0 && (m.totalBacklinks ?? 0) === 0) {
        return 0;
      }

      // Referring domains score: 100+ domains = max score (100)
      const rdScore = Math.min(rd / 100, 1) * 100;
      
      // Follow ratio score: clamp 0-1 → 0-100
      const followScore = Math.max(0, Math.min(fb, 1)) * 100;

      // Combined: 70% referring domains, 30% follow ratio
      const score = 0.7 * rdScore + 0.3 * followScore;
      
      return Math.round(clampScore(score));
    }

    // Helper function to always return correct Trustpilot snapshot values
    // This ensures we never use old cached values (4.80, 127) - always use (4.6, 610)
    function getTrustpilotSnapshot(siteReviews = null) {
      const TRUSTPILOT_SNAPSHOT = {
        siteRating: 4.6,
        siteReviewCount: 610,
        lastUpdated: '2025-12-07',
        notes: 'Fixed Trustpilot snapshot for Authority score calculation. Update manually when Trustpilot metrics change significantly.'
      };
      
      // Always return the correct snapshot, regardless of input
      if (!siteReviews || siteReviews.siteRating !== 4.6 || siteReviews.siteReviewCount !== 610) {
        return TRUSTPILOT_SNAPSHOT;
      }
      return siteReviews;
    }

    // Helper function to get color for score (same thresholds as main pillars)
    function getScoreColor(score) {
      if (score >= 70) return { color: '#10b981', label: 'Green', bg: '#d1fae5' }; // Green
      if (score >= 40) return { color: '#f59e0b', label: 'Amber', bg: '#fef3c7' }; // Amber
      return { color: '#ef4444', label: 'Red', bg: '#fee2e2' }; // Red
    }

    // Helper function to get tooltip text for each component
    function getComponentTooltip(label) {
      const tooltips = {
        // Authority components
        'Behaviour': 'Overall CTR Score (50% weight) + Top-10 Ranked Search Terms CTR Score (50% weight). Measures CTR for all ranking search terms vs. search terms ranking in positions 1-10. Indicates how well your titles/descriptions convert impressions to clicks.',
        'Ranking': 'Average Position Score (50% weight) + Top-10 Impression Share (50% weight). Measures how high you rank on average and what percentage of impressions appear in positions 1-10.',
        'Backlinks': 'Referring Domains Score (70% weight) + Follow Ratio Score (30% weight). Measures domain authority from external links.',
        'Reviews': 'Google Business Profile Reviews (60% weight if both exist) + Trustpilot Reviews (40% weight if both exist). Each source combines rating (60%) and count (40%). Measures trust signals from customer reviews.',
        // Content/Schema components
        'Foundation': 'Foundation Schemas (30% weight): Presence of Organization, Person, WebSite, and BreadcrumbList schemas. These core schemas establish your entity identity and site structure for AI systems.',
        'Rich Results': 'Rich Result Eligibility (35% weight): Count of eligible rich result types (Article, Event, FAQPage, Product, LocalBusiness, Course, Review, HowTo, VideoObject, ImageObject, ItemList). More types = better AI understanding.',
        'Coverage': 'Schema Coverage (20% weight): Percentage of pages with structured data markup. Higher coverage means more pages are machine-readable.',
        'Diversity': 'Type Diversity (15% weight): Number of unique schema types detected across your domain. More diverse types indicate richer structured data.',
        // Visibility components
        'Position': 'Average Position Score: Derived from Google Search Console average position (1-40 scale). Better positions (lower numbers) = higher score. Measures how prominently your content appears in search results.',
        'CTR': 'Click-Through Rate Score: Derived from Google Search Console CTR percentage. Higher CTR indicates better title/description effectiveness and user engagement.',
        // Local Entity components
        'NAP Consistency': 'Name, Address, Phone consistency score (0-100%). Measures how consistently your business information appears across Google Business Profile. Higher consistency improves entity recognition.',
        'Knowledge Panel': 'Knowledge Panel Detection: Whether Google has detected and displays a knowledge panel for your entity. Indicates strong entity recognition by AI systems.',
        'Locations': 'Location Count: Number of physical locations listed in Google Business Profile. Having at least one location improves local entity recognition.',
        // Service Area components
        'Service Areas': 'Service Area Count: Number of service areas defined in Google Business Profile. More service areas (8+) indicate broader geographic coverage and better AI understanding of your operational regions.',
        'NAP Consistency': 'Name, Address, Phone consistency score (0-100%). Measures how consistently your business information appears across Google Business Profile. Higher consistency improves service area recognition.'
      };
      return tooltips[label] || '';
    }

    // Helper function to format component score with color, scale indicator, and tooltip
    function formatComponentScore(label, score) {
      const rounded = Math.round(score);
      const colorInfo = getScoreColor(rounded);
      const tooltip = getComponentTooltip(label);
      return `
        <div style="display: flex; align-items: center; gap: 0.5rem;">
          <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background-color: ${colorInfo.color};"></span>
          <span style="color: #666; position: relative; cursor: help; border-bottom: 1px dotted #999;" title="${tooltip}">${label}:</span>
          <strong style="color: ${colorInfo.color};">${rounded}</strong>
          <span style="color: #999; font-size: 0.75em;">/100</span>
        </div>
      `;
    }

    async function calculatePillarScores(data, schemaAudit = null, localSignals = null, siteReviews = null, backlinkMetrics = null) {
      // Use new API response format - get values from GSC overview
      const position = data.averagePosition || 40; // 1 (best) - 100 (worst)
      const ctr = data.ctr || 0; // 0-100 percentage from API (e.g., 10 = 10%)
      const topQueries = data.topQueries || []; // Array of query objects with clicks, impressions, ctr, position
      const queryPages = data.queryPages || []; // Array of query+page objects for segmentation

      // Map average position (1-40) -> 100-10 (better position => higher score)
      const posScore = (() => {
        const clampedPos = Math.max(1, Math.min(40, position));
        const scale = (clampedPos - 1) / 39; // 0 to 1
        return 100 - scale * 90; // 100 to 10
      })();

      // Visibility is primarily driven by position
      const visibility = clampScore(posScore);

      // Authority: New 4-component model with segmentation support
      let behaviourScore, rankingScore;
      let behaviourScoresSegmented = null;
      let rankingScoresSegmented = null;
      
      // If we have queryPages data, use segmented calculation
      if (queryPages && queryPages.length > 0) {
        debugLog(`📊 Segmentation: Received ${queryPages.length} query+page combinations from GSC API`, 'info');
        
        // Classify all pages and show distribution
        const segmentCounts = {};
        queryPages.forEach(row => {
          const segment = classifyPageSegment(row.page || row.url || '/');
          segmentCounts[segment] = (segmentCounts[segment] || 0) + 1;
        });
        
        debugLog(`📊 Segmentation: Page distribution - Education: ${segmentCounts[PageSegment.EDUCATION] || 0}, Money: ${segmentCounts[PageSegment.MONEY] || 0}, Support: ${segmentCounts[PageSegment.SUPPORT] || 0}, System: ${segmentCounts[PageSegment.SYSTEM] || 0}`, 'info');
        
        // Use segmented calculation
        debugLog('📊 Segmentation: Calculating Behaviour scores for all segments...', 'info');
        behaviourScoresSegmented = computeBehaviourScoreWithSegment(queryPages);
        debugLog(`📊 Segmentation: Behaviour scores - All: ${behaviourScoresSegmented.all.toFixed(1)}, Non-blog: ${behaviourScoresSegmented.nonBlog.toFixed(1)}, Money: ${behaviourScoresSegmented.money.toFixed(1)}`, 'success');
        
        debugLog('📊 Segmentation: Calculating Ranking scores for all segments...', 'info');
        rankingScoresSegmented = computeRankingScoreWithSegment(queryPages);
        debugLog(`📊 Segmentation: Ranking scores - All: ${rankingScoresSegmented.all.toFixed(1)}, Non-blog: ${rankingScoresSegmented.nonBlog.toFixed(1)}, Money: ${rankingScoresSegmented.money.toFixed(1)}`, 'success');
        
        // Use 'all' segment for main Authority score (backward compatible)
        behaviourScore = behaviourScoresSegmented.all;
        rankingScore = rankingScoresSegmented.all;
        
        debugLog(`✓ Using segmented calculation (queryPages available). Main scores use 'all' segment.`, 'success');
      } else {
        // Fallback to non-segmented calculation (backward compatible)
        debugLog('⚠ Segmentation: queryPages not available, using non-segmented calculation (backward compatible)', 'warn');
        const queriesForCalculation = topQueries.map(q => ({
          clicks: q.clicks || 0,
          impressions: q.impressions || 0,
          ctr: (q.ctr || 0) / 100, // Convert percentage to decimal
          position: q.position || 0
        }));
        behaviourScore = computeBehaviourScore(queriesForCalculation);
        rankingScore = computeRankingScore(queriesForCalculation);
        debugLog(`⚠ Non-segmented scores: Behaviour=${behaviourScore.toFixed(1)}, Ranking=${rankingScore.toFixed(1)}`, 'warn');
      }

      // Review Score: Phase 2 - Use real review data if available
      // Get GBP data (may be null if not available, don't default to 0)
      const gbpRating = (localSignals && localSignals.status === 'ok' && localSignals.data) 
        ? (localSignals.data.gbpRating !== null && localSignals.data.gbpRating !== undefined ? localSignals.data.gbpRating : null)
        : null;
      const gbpCount = (localSignals && localSignals.status === 'ok' && localSignals.data) 
        ? (localSignals.data.gbpReviewCount !== null && localSignals.data.gbpReviewCount !== undefined ? localSignals.data.gbpReviewCount : null)
        : null;
      
      // Get site review data - ALWAYS use correct Trustpilot snapshot (4.6, 610)
      const normalizedSiteReviews = getTrustpilotSnapshot(siteReviews);
      const siteRating = normalizedSiteReviews?.siteRating !== null && normalizedSiteReviews?.siteRating !== undefined ? normalizedSiteReviews.siteRating : null;
      const siteCount = normalizedSiteReviews?.siteReviewCount !== null && normalizedSiteReviews?.siteReviewCount !== undefined ? normalizedSiteReviews.siteReviewCount : null;
      
      // Calculate review score (handles optional sources internally)
      const reviewScore = computeReviewScore({
        gbpRating,
        gbpCount,
        siteRating,
        siteCount
      });
      
      // Log the calculation details
      const gbpInfo = gbpRating !== null || gbpCount !== null 
        ? `GBP (rating=${gbpRating !== null ? gbpRating : 'N/A'}, count=${gbpCount !== null ? gbpCount : 'N/A'})`
        : 'GBP (no data)';
      const siteInfo = siteRating !== null || siteCount !== null
        ? `Trustpilot snapshot (rating=${siteRating !== null ? siteRating : 'N/A'}, count=${siteCount !== null ? siteCount : 'N/A'})`
        : 'Trustpilot snapshot (no data)';
      debugLog(`Review Score: ${gbpInfo}, ${siteInfo}, Final=${reviewScore.toFixed(1)}`, 'info');

      // Backlink Score: Phase 3 - Use real backlink metrics if available
      // backlinkMetrics is passed as a parameter (fetched from API)
      const backlinkScore = computeBacklinkScore(backlinkMetrics);

      // Authority weights (constant across all segments)
      const AUTHORITY_WEIGHTS = {
        behaviour: 0.4,
        ranking: 0.2,
        backlinks: 0.2,
        reviews: 0.2
      };
      
      // Helper to compute Authority from component scores
      function computeAuthorityFromComponents(components) {
        const total = clampScore(
          AUTHORITY_WEIGHTS.behaviour * components.behaviour +
          AUTHORITY_WEIGHTS.ranking * components.ranking +
          AUTHORITY_WEIGHTS.backlinks * components.backlinks +
          AUTHORITY_WEIGHTS.reviews * components.reviews
        );
        return {
          behaviour: clampScore(components.behaviour),
          ranking: clampScore(components.ranking),
          backlinks: clampScore(components.backlinks),
          reviews: clampScore(components.reviews),
          total: total
        };
      }
      
      // Base Authority (all pages) - current behaviour
      const authorityAll = computeAuthorityFromComponents({
        behaviour: behaviourScore,
        ranking: rankingScore,
        backlinks: backlinkScore,
        reviews: reviewScore
      });
      
      // Per-segment Authority scores (if segmentation available)
      // Helper function to compute top pages for a segment
      function computeTopPagesForSegment(pageRows, max = 10) {
        if (!pageRows || !Array.isArray(pageRows) || pageRows.length === 0) {
          return [];
        }
        
        // Aggregate by page URL (sum clicks, impressions, weighted position)
        const pageMap = new Map();
        
        pageRows.forEach(row => {
          const url = row.page || row.url || '';
          if (!url) return;
          
          if (!pageMap.has(url)) {
            pageMap.set(url, {
              url: url,
              clicks: 0,
              impressions: 0,
              totalPositionWeight: 0,
              count: 0
            });
          }
          
          const page = pageMap.get(url);
          page.clicks += row.clicks || 0;
          page.impressions += row.impressions || 0;
          page.totalPositionWeight += (row.position || 0) * (row.impressions || 0);
          page.count += 1;
        });
        
        // Convert to top pages format
        const topPages = Array.from(pageMap.values())
          .map(page => ({
            url: page.url,
            clicks: page.clicks,
            impressions: page.impressions,
            ctr: page.impressions > 0 ? (page.clicks / page.impressions) * 100 : 0,
            avgPosition: page.impressions > 0 ? page.totalPositionWeight / page.impressions : 0
          }))
          .filter(page => page.impressions > 0) // Only pages with impressions
          .sort((a, b) => b.impressions - a.impressions) // Sort by impressions descending
          .slice(0, max);
        
        return topPages;
      }
      
      // Compute all pages including zero impressions (for money pages segmentation validation)
      function computeAllPagesForSegment(pageRows) {
        if (!pageRows || !Array.isArray(pageRows) || pageRows.length === 0) {
          return [];
        }
        
        // Aggregate by page URL (sum clicks, impressions, weighted position)
        const pageMap = new Map();
        
        pageRows.forEach(row => {
          const url = row.page || row.url || '';
          if (!url) return;
          
          if (!pageMap.has(url)) {
            pageMap.set(url, {
              url: url,
              clicks: 0,
              impressions: 0,
              totalPositionWeight: 0,
              count: 0
            });
          }
          
          const page = pageMap.get(url);
          page.clicks += row.clicks || 0;
          page.impressions += row.impressions || 0;
          page.totalPositionWeight += (row.position || 0) * (row.impressions || 0);
          page.count += 1;
        });
        
        // Convert to pages format (include zero impressions)
        const allPages = Array.from(pageMap.values())
          .map(page => ({
            url: page.url,
            clicks: page.clicks,
            impressions: page.impressions,
            ctr: page.impressions > 0 ? (page.clicks / page.impressions) * 100 : 0,
            avgPosition: page.impressions > 0 ? page.totalPositionWeight / page.impressions : null,
            position: page.impressions > 0 ? page.totalPositionWeight / page.impressions : null
          }))
          .sort((a, b) => {
            // Sort by impressions descending, but put zero impressions at the end
            if (a.impressions === 0 && b.impressions > 0) return 1;
            if (b.impressions === 0 && a.impressions > 0) return -1;
            return b.impressions - a.impressions;
          });
        
        return allPages;
      }
      
      let authorityBySegment = null;
      if (behaviourScoresSegmented && rankingScoresSegmented) {
        // Get page-level data for top pages computation
        const queryPagesData = data.queryPages || [];
        
        // Filter to ranking pages (position 1-20, with impressions)
        const rankingPages = queryPagesData.filter(row => {
          const pos = row.position || 0;
          const impr = row.impressions || 0;
          return pos > 0 && pos <= 20 && impr > 0;
        });
        
        // Classify pages by segment
        const allPages = rankingPages;
        const excludeEduPages = rankingPages.filter(row => {
          const segment = classifyPageSegment(row.page || row.url || '/');
          return segment !== PageSegment.EDUCATION;
        });
        const moneyPages = rankingPages.filter(row => {
          const segment = classifyPageSegment(row.page || row.url || '/');
          return segment === PageSegment.MONEY;
        });
        
        // Compute top pages for each segment
        const allTopPages = computeTopPagesForSegment(allPages, 10);
        const excludeEduTopPages = computeTopPagesForSegment(excludeEduPages, 10);
        const moneyTopPages = computeTopPagesForSegment(moneyPages, 10);
        
        // Non-education (exclude education pages)
        const authorityNonEducation = computeAuthorityFromComponents({
          behaviour: behaviourScoresSegmented.nonBlog,
          ranking: rankingScoresSegmented.nonBlog,
          backlinks: backlinkScore, // Same across all segments
          reviews: reviewScore      // Same across all segments
        });
        
        // Money pages only
        const authorityMoney = computeAuthorityFromComponents({
          behaviour: behaviourScoresSegmented.money,
          ranking: rankingScoresSegmented.money,
          backlinks: backlinkScore, // Same across all segments
          reviews: reviewScore      // Same across all segments
        });
        
        // Helper to compute GSC metrics for a segment from queryPages data
        const computeGSCMetricsForSegment = (queryPagesData, segmentFilter) => {
          if (!queryPagesData || queryPagesData.length === 0) {
            return { siteCtr: 0, top10Ctr: 0, avgPosition: 0, top10Share: 0 };
          }
          
          // Filter by segment if filter function provided
          let filteredData = queryPagesData;
          if (segmentFilter) {
            filteredData = queryPagesData.filter(row => {
              const segment = classifyPageSegment(row.page || row.url || '/');
              return segmentFilter(segment);
            });
          }
          
          // Filter to ranking queries (position 1-20, with impressions)
          const rankingQueries = filteredData.filter(q => {
            const pos = q.position || 0;
            const impr = q.impressions || 0;
            return pos > 0 && pos <= 20 && impr > 0;
          });
          const top10Queries = rankingQueries.filter(q => (q.position || 0) <= 10);
          
          let siteCtr = 0;
          let top10Ctr = 0;
          let avgPosition = 0;
          let top10Share = 0;
          
          if (rankingQueries.length > 0) {
            const totalClicks = rankingQueries.reduce((s, q) => s + (q.clicks || 0), 0);
            const totalImpr = rankingQueries.reduce((s, q) => s + (q.impressions || 0), 0);
            siteCtr = totalImpr > 0 ? (totalClicks / totalImpr) * 100 : 0;
            
            const top10Clicks = top10Queries.reduce((s, q) => s + (q.clicks || 0), 0);
            const top10Impr = top10Queries.reduce((s, q) => s + (q.impressions || 0), 0);
            top10Ctr = top10Impr > 0 ? (top10Clicks / top10Impr) * 100 : 0;
            
            avgPosition = totalImpr > 0
              ? rankingQueries.reduce((s, q) => s + (q.position || 0) * (q.impressions || 0), 0) / totalImpr
              : 0;
            
            top10Share = totalImpr > 0 ? (top10Impr / totalImpr) : 0; // Store as 0-1 fraction
          }
          
          return { siteCtr, top10Ctr, avgPosition, top10Share };
        };
        
        // Compute GSC metrics for each segment using full queryPages data (not pre-filtered rankingPages)
        const allGSCMetrics = computeGSCMetricsForSegment(queryPagesData, null); // All pages
        const excludeEduGSCMetrics = computeGSCMetricsForSegment(queryPagesData, (seg) => seg !== PageSegment.EDUCATION);
        const moneyGSCMetrics = computeGSCMetricsForSegment(queryPagesData, (seg) => seg === PageSegment.MONEY);
        
        debugLog(`📊 GSC Metrics - All: CTR=${allGSCMetrics.siteCtr != null ? allGSCMetrics.siteCtr.toFixed(2) : 'N/A'}%, Pos=${allGSCMetrics.avgPosition != null ? allGSCMetrics.avgPosition.toFixed(1) : 'N/A'}`, 'info');
        debugLog(`📊 GSC Metrics - ExcludeEdu: CTR=${excludeEduGSCMetrics.siteCtr != null ? excludeEduGSCMetrics.siteCtr.toFixed(2) : 'N/A'}%, Pos=${excludeEduGSCMetrics.avgPosition != null ? excludeEduGSCMetrics.avgPosition.toFixed(1) : 'N/A'}`, 'info');
        debugLog(`📊 GSC Metrics - Money: CTR=${moneyGSCMetrics.siteCtr != null ? moneyGSCMetrics.siteCtr.toFixed(2) : 'N/A'}%, Pos=${moneyGSCMetrics.avgPosition != null ? moneyGSCMetrics.avgPosition.toFixed(1) : 'N/A'}`, 'info');
        
        authorityBySegment = {
          all: { 
            ...authorityAll, 
            topPages: allTopPages,
            siteCtr: allGSCMetrics.siteCtr,
            top10Ctr: allGSCMetrics.top10Ctr,
            avgPosition: allGSCMetrics.avgPosition,
            top10Share: allGSCMetrics.top10Share
          },
          nonEducation: { 
            ...authorityNonEducation, 
            topPages: excludeEduTopPages,
            siteCtr: excludeEduGSCMetrics.siteCtr,
            top10Ctr: excludeEduGSCMetrics.top10Ctr,
            avgPosition: excludeEduGSCMetrics.avgPosition,
            top10Share: excludeEduGSCMetrics.top10Share
          },
          money: { 
            ...authorityMoney, 
            topPages: moneyTopPages,
            siteCtr: moneyGSCMetrics.siteCtr,
            top10Ctr: moneyGSCMetrics.top10Ctr,
            avgPosition: moneyGSCMetrics.avgPosition,
            top10Share: moneyGSCMetrics.top10Share
          }
        };
        
        debugLog(`📊 Authority by segment - All: ${authorityAll.total.toFixed(1)}, Non-education: ${authorityNonEducation.total.toFixed(1)}, Money: ${authorityMoney.total.toFixed(1)}`, 'info');
      }
      
      // Main Authority score (default: all pages)
      const authority = authorityAll.total;
      
      debugLog(`Authority calculation: Behaviour=${behaviourScore.toFixed(1)}, Ranking=${rankingScore.toFixed(1)}, Backlinks=${backlinkScore}, Reviews=${reviewScore}, Final=${authority}`, 'info');
      
      // Store component scores for historical tracking (backward compatible)
      const authorityComponents = {
        behaviour: authorityAll.behaviour,
        ranking: authorityAll.ranking,
        backlinks: authorityAll.backlinks,
        reviews: authorityAll.reviews,
        // Segmented scores (if available) - for backward compatibility
        behaviourScoreAll: behaviourScoresSegmented ? clampScore(behaviourScoresSegmented.all) : clampScore(behaviourScore),
        behaviourScoreNonBlog: behaviourScoresSegmented ? clampScore(behaviourScoresSegmented.nonBlog) : null,
        behaviourScoreMoney: behaviourScoresSegmented ? clampScore(behaviourScoresSegmented.money) : null,
        rankingScoreAll: rankingScoresSegmented ? clampScore(rankingScoresSegmented.all) : clampScore(rankingScore),
        rankingScoreNonBlog: rankingScoresSegmented ? clampScore(rankingScoresSegmented.nonBlog) : null,
        rankingScoreMoney: rankingScoresSegmented ? clampScore(rankingScoresSegmented.money) : null
      };
      
      // Log final segmented scores stored
      if (behaviourScoresSegmented) {
        debugLog(`📊 Segmentation: Final stored scores - Behaviour: All=${authorityComponents.behaviourScoreAll}, NonBlog=${authorityComponents.behaviourScoreNonBlog}, Money=${authorityComponents.behaviourScoreMoney}`, 'info');
        debugLog(`📊 Segmentation: Final stored scores - Ranking: All=${authorityComponents.rankingScoreAll}, NonBlog=${authorityComponents.rankingScoreNonBlog}, Money=${authorityComponents.rankingScoreMoney}`, 'info');
      }

      // Local Entity: Use real Business Profile data if available, otherwise fallback to derived calculation
      let localEntity;
      if (localSignals && localSignals.status === 'ok' && localSignals.data) {
        const localData = localSignals.data;
        // Base score from NAP consistency (0-100)
        let baseScore = localData.napConsistencyScore || 0;
        
        // Bonus for knowledge panel detection (+10 points)
        if (localData.knowledgePanelDetected) {
          baseScore = Math.min(100, baseScore + 10);
        }
        
        // Bonus for having at least one location (+5 points)
        if (localData.locations && localData.locations.length > 0) {
          baseScore = Math.min(100, baseScore + 5);
        }
        
        localEntity = clampScore(baseScore);
        debugLog(`Local Entity: NAP=${localData.napConsistencyScore || 0}, Knowledge Panel=${localData.knowledgePanelDetected}, Locations=${localData.locations?.length || 0}, Final=${localEntity}`, 'info');
      } else {
        // Fallback: derived calculation (old method)
        // Calculate ctrScore from ctr (which is 0-100 percentage)
      const ctrDecimal = ctr / 100; // Convert percentage to decimal (e.g., 10% -> 0.10)
      const ctrScore = Math.min((ctrDecimal / 0.10) * 100, 100);
        localEntity = clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
        debugLog('Local Entity: Using fallback calculation (no Business Profile data)', 'warn');
      }

      // Service Area: Use real Business Profile service areas count if available, otherwise fallback
      let serviceArea;
      if (localSignals && localSignals.status === 'ok' && localSignals.data) {
        const localData = localSignals.data;
        const serviceAreasCount = localData.serviceAreas?.length || 0;
        
        // Normalize service areas count to 0-100 score
        // 0 areas = 0, 8+ areas = 100 (more reasonable threshold)
        // Linear scale: 1 area = 12.5 points (8 areas = 100)
        if (serviceAreasCount === 0) {
          serviceArea = 0;
        } else if (serviceAreasCount >= 8) {
          serviceArea = 100;
        } else {
          // Linear scale: 1 area = 12.5 points, 2 = 25, ..., 8 = 100
          serviceArea = Math.min(100, serviceAreasCount * 12.5);
        }
        
        // Apply NAP consistency as a multiplier (if NAP is low, reduce service area score)
        if (localData.napConsistencyScore !== null && localData.napConsistencyScore < 100) {
          const napMultiplier = localData.napConsistencyScore / 100;
          serviceArea = Math.round(serviceArea * napMultiplier);
        }
        
        serviceArea = clampScore(serviceArea);
        debugLog(`Service Area: Count=${serviceAreasCount}, NAP Multiplier=${localData.napConsistencyScore !== null ? (localData.napConsistencyScore / 100).toFixed(2) : 'N/A'}, Final=${serviceArea}`, 'info');
      } else {
        // Fallback: derived from Local Entity (old method)
        serviceArea = clampScore(localEntity - 5);
        debugLog('Service Area: Using fallback calculation (no Business Profile data)', 'warn');
      }

      // Content/Schema: weighted calculation based on foundation schemas, rich results, coverage, and diversity
      let contentSchema;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        const allTypes = new Set();
        
        // Use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
        if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
          // Use all detected types for accurate calculation
          schemaData.allDetectedTypes.forEach(type => {
            if (type) allTypes.add(type);
          });
        } else if (schemaData.foundation && typeof schemaData.foundation === 'object') {
          // Use foundation object to get foundation types (most reliable)
          Object.keys(schemaData.foundation).forEach(type => {
            if (schemaData.foundation[type] === true) {
              allTypes.add(type);
            }
          });
          // Also add from richEligible for complete type list
          if (schemaData.richEligible && typeof schemaData.richEligible === 'object') {
            Object.keys(schemaData.richEligible).forEach(type => {
              if (schemaData.richEligible[type] === true) {
                allTypes.add(type);
              }
            });
          }
        } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          // Fallback: collect from schemaTypes array (contains all types, sorted by count)
          // Handle both object format {type, count} and string format
          schemaData.schemaTypes.forEach(item => {
            if (typeof item === 'string') {
              allTypes.add(item);
            } else if (item && typeof item === 'object' && item.type) {
              allTypes.add(item.type);
            }
          });
        }
        
        // 1. Foundation Schemas Score (30% weight): Organization, Person, WebSite, BreadcrumbList
        const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
        const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
        const foundationScore = (foundationPresent / foundationTypes.length) * 100;
        
        // 2. Rich Result Eligibility Score (35% weight): Count eligible rich result types
        // Note: This list must match RICH_RESULT_TYPES in api/schema-audit.js
        const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
        const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
        const richResultScore = (richEligibleCount / richResultTypes.length) * 100;
        
        // 3. Coverage Score (20% weight): Pages with schema / total pages
        // Calculate coverage from pagesWithSchema and totalPages if coverage is not available
        let coverageScore = 0;
        if (typeof schemaData.coverage === 'number' && !isNaN(schemaData.coverage)) {
          coverageScore = schemaData.coverage;
        } else {
          // Calculate from pagesWithSchema and totalPages
          const pagesWithSchemaCount = Array.isArray(schemaData.pagesWithSchema) 
            ? schemaData.pagesWithSchema.length 
            : (typeof schemaData.pagesWithSchema === 'number' ? schemaData.pagesWithSchema : 0);
          const totalPagesCount = typeof schemaData.totalPages === 'number' 
            ? schemaData.totalPages 
            : (Array.isArray(schemaData.pages) ? schemaData.pages.length : 0);
          if (totalPagesCount > 0) {
            coverageScore = (pagesWithSchemaCount / totalPagesCount) * 100;
          }
        }
        
        // 4. Type Diversity Score (15% weight): Number of unique schema types (normalized to 15 types)
        const uniqueTypesCount = allTypes.size;
        const diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
        
        // Weighted calculation: 30% foundation + 35% rich results + 20% coverage + 15% diversity
        contentSchema = clampScore(
          foundationScore * 0.30 +
          richResultScore * 0.35 +
          coverageScore * 0.20 +
          diversityScore * 0.15
        );
        
        debugLog(`Content/Schema calculation: Foundation=${foundationScore != null ? foundationScore.toFixed(1) : 'N/A'}% (${foundationPresent}/4), Rich Results=${richResultScore != null ? richResultScore.toFixed(1) : 'N/A'}% (${richEligibleCount}/${richResultTypes.length}), Coverage=${coverageScore != null ? coverageScore.toFixed(1) : 'N/A'}%, Diversity=${diversityScore != null ? diversityScore.toFixed(1) : 'N/A'}% (${uniqueTypesCount} types)`, 'info');
      } else {
        // Fallback: if no schema audit data, return 0 (can't calculate without data)
        contentSchema = 0;
        debugLog('⚠ No schema audit data available, Content/Schema score set to 0', 'warn');
      }

      // Extract coverage and diversity scores from contentSchema calculation for GAIO health
      let coverageScore = 0;
      let diversityScore = 0;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        // Coverage: Pages with schema / total pages (0-100)
        coverageScore = schemaData.coverage || 0;
        
        // Diversity: Number of unique schema types (normalized to 15 types, 0-100)
        const allTypes = new Set();
        if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
          schemaData.allDetectedTypes.forEach(type => {
            if (type) allTypes.add(type);
          });
        } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          schemaData.schemaTypes.forEach(item => {
            if (item.type) allTypes.add(item.type);
          });
        }
        const uniqueTypesCount = allTypes.size;
        diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
      }

      // ============================================================================
      // PHASE 1: Brand Overlay Calculation
      // ============================================================================
      
      // Calculate brand metrics from GSC query data
      // Use queryPages if available (more accurate), otherwise fall back to topQueries
      let brandMetrics;
      if (queryPages && queryPages.length > 0) {
        // Convert queryPages to query format for brand metrics calculation
        const queriesForBrand = queryPages.map(row => ({
          query: row.query || '',
          clicks: row.clicks || 0,
          impressions: row.impressions || 0,
          position: row.position || 0
        }));
        brandMetrics = calculateBrandMetrics(queriesForBrand);
      } else {
        // Fallback to topQueries
        brandMetrics = calculateBrandMetrics(topQueries);
      }
      debugLog(`Brand Metrics: Share=${(brandMetrics.brandQueryShare * 100).toFixed(2)}%, CTR=${(brandMetrics.brandCtr * 100).toFixed(2)}%, AvgPos=${brandMetrics.brandAvgPosition?.toFixed(1) || 'N/A'}`, 'info');
      
      // Compute brand overlay score
      const brandOverlay = computeBrandOverlay({
        brandQueryShare: brandMetrics.brandQueryShare,
        brandCtr: brandMetrics.brandCtr,
        brandAvgPosition: brandMetrics.brandAvgPosition,
        reviewScore: reviewScore,
        entityScore: localEntity
      });
      debugLog(`Brand Overlay: Score=${brandOverlay.score}, Label=${brandOverlay.label}, Notes=${brandOverlay.notes.length}`, 'info');
      
      // ============================================================================
      // End Phase 1: Brand Overlay Calculation
      // ============================================================================

      // ============================================================================
      // Money Pages Performance Metrics
      // ============================================================================
      
      /**
       * Compute site-wide aggregates from topPages data
       * @param {Array} topPages - Array of page objects with clicks, impressions, position
       * @returns {Object} Site aggregates
       */
      function computeSiteAggregateFromTopPages(topPages) {
        if (!topPages || !Array.isArray(topPages) || topPages.length === 0) {
          return {
            totalClicks: 0,
            totalImpressions: 0,
            avgCtr: 0,
            avgPosition: null
          };
        }
        
        let totalClicks = 0;
        let totalImpressions = 0;
        let weightedPosSum = 0;
        
        topPages.forEach(page => {
          const clicks = page.clicks || 0;
          const impressions = page.impressions || 0;
          const position = page.position || page.avgPosition || 0;
          
          totalClicks += clicks;
          totalImpressions += impressions;
          if (impressions > 0 && position > 0) {
            weightedPosSum += position * impressions;
          }
        });
        
        const avgCtr = totalImpressions > 0 ? totalClicks / totalImpressions : 0;
        const avgPosition = totalImpressions > 0 ? weightedPosSum / totalImpressions : null;
        
        return {
          totalClicks,
          totalImpressions,
          avgCtr,
          avgPosition
        };
      }
      
      /**
       * Classify a money page into an opportunity category and return a short recommendation.
       * @param {Object} metrics - { ctr (0–1), avgPosition, impressions }
       * @param {Object} siteAgg - { avgCtr, avgPosition }
       * @returns {Object} { category, categoryLabel, categoryColor, recommendation }
       */
      function classifyMoneyPageOpportunity(metrics, siteAgg, hasSchema = null, schemaTypes = []) {
        const { ctr, avgPosition, impressions } = metrics;
        const siteCtr = siteAgg.avgCtr || 0;
        const sitePos = siteAgg.avgPosition || 0;
        
        // Sensible defaults
        const safePos = avgPosition || 99;
        const safeCtr = ctr || 0;
        const imp = impressions || 0;
        
        // Thresholds (tune later)
        const MIN_IMPRESSIONS = 100;
        const HIGH_OPP_MAX_POS = 15;
        const MAINTAIN_MAX_POS = 8;
        
        const targetCtrHigh = 0.05;   // 5% for strong
        const targetCtrMid = 0.03;    // 3% mid range
        const lowCtrThreshold = 0.02;  // 2%
        
        let category = 'VISIBILITY_FIX';
        let categoryLabel = 'Visibility fix';
        let categoryColor = 'red';
        let recommendation = '';
        
        // Check which schema types are missing (for money pages, we typically want Product, Event, FAQPage)
        const desiredSchemaTypes = ['Product', 'Event', 'FAQPage'];
        // Normalize present types to lowercase for case-insensitive comparison
        const presentTypes = Array.isArray(schemaTypes) && schemaTypes.length > 0 
          ? schemaTypes.map(t => {
              if (typeof t === 'string') return t.trim().toLowerCase();
              if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type.trim().toLowerCase();
              return String(t).trim().toLowerCase();
            }).filter(t => t && t !== '[object object]')
          : [];
        // Check for missing types (case-insensitive comparison)
        const missingTypes = desiredSchemaTypes.filter(type => {
          const typeLower = type.toLowerCase();
          return !presentTypes.includes(typeLower);
        });
        
        // Build schema recommendation based on what's actually missing
        // Only recommend schema types that are NOT already present
        let schemaRecommendation = '';
        if (hasSchema === false) {
          // No schema at all - generic recommendation
          schemaRecommendation = 'ensure Product/Event/FAQ schema is present, and ';
        } else if (missingTypes.length > 0) {
          // Has schema but missing some or all desired types
          if (missingTypes.length === desiredSchemaTypes.length) {
            // Has schema but none of the desired types (Product, Event, FAQPage) - generic
            schemaRecommendation = 'ensure Product/Event/FAQ schema is present, and ';
          } else {
            // Missing specific types - only recommend what's actually missing (e.g., "add Product/Event schema")
            const missingTypesText = missingTypes.join('/');
            schemaRecommendation = `add ${missingTypesText} schema, and `;
          }
        }
        // If hasSchema === true AND missingTypes.length === 0, no schema recommendation (all desired types present)
        
        // 1) High opportunity: decent position, impressions, but weak CTR
        const hasDecentPosition = safePos >= 3 && safePos <= HIGH_OPP_MAX_POS;
        const hasVolume = imp >= MIN_IMPRESSIONS;
        const ctrBelowTargetForBand =
          (safePos <= 6 && safeCtr < targetCtrHigh) ||
          (safePos > 6 && safePos <= 10 && safeCtr < targetCtrMid) ||
          (safePos > 10 && safePos <= HIGH_OPP_MAX_POS && safeCtr < lowCtrThreshold);
        
        if (hasDecentPosition && hasVolume && ctrBelowTargetForBand) {
          category = 'HIGH_OPPORTUNITY';
          categoryLabel = 'High opportunity (improve CTR)';
          categoryColor = 'amber';
          // Add schema recommendation if missing (use same logic as visibility fix)
          let schemaNote = '';
          if (hasSchema === false) {
            // No schema at all
            schemaNote = ' Add Product/Event/FAQ schema to improve rich result eligibility. ';
          } else if (missingTypes.length > 0) {
            // Has schema but missing some or all desired types
            if (missingTypes.length === desiredSchemaTypes.length) {
              // Has schema but none of the desired types
              schemaNote = ' Add Product/Event/FAQ schema to improve rich result eligibility. ';
            } else {
              // Missing specific types - only recommend what's actually missing
              schemaNote = ` Add ${missingTypes.join('/')} schema to improve rich result eligibility. `;
            }
          }
          // If missingTypes.length === 0, no schema recommendation (all desired types present)
          recommendation =
            `Good visibility (avg position ${safePos.toFixed(1)}) and ` +
            `${imp.toLocaleString()} impressions, but low CTR (${(safeCtr * 100).toFixed(1)}%). ` +
            `Prioritise title/meta improvements, "best" phrasing for this offer, ` +
            `${schemaNote}` +
            `and adding FAQs that address objections for this money page.`;
        }
        // 2) Maintain: strong position + CTR above target
        else if (safePos <= MAINTAIN_MAX_POS && safeCtr >= targetCtrMid && imp >= MIN_IMPRESSIONS) {
          category = 'MAINTAIN';
          categoryLabel = 'Maintain (performing well)';
          categoryColor = 'green';
          recommendation =
            `Strong performer with avg position ${safePos.toFixed(1)} and ` +
            `CTR ${(safeCtr * 100).toFixed(1)}%. Maintain current messaging and ` +
            `internal links; focus optimisation efforts on weaker money pages first.`;
        }
        // 3) Visibility fix: fallback
        else {
          category = 'VISIBILITY_FIX';
          categoryLabel = 'Visibility fix (low impressions/rank)';
          categoryColor = 'red';
          recommendation =
            `Limited visibility (avg position ${Number.isFinite(safePos) ? safePos.toFixed(1) : '—'} ` +
            `and ${imp.toLocaleString()} impressions). Strengthen internal links from high-traffic ` +
            `educational posts, ${schemaRecommendation}` +
            `consider a clearer "best [topic]" section to signal value to searchers and AI.`;
        }
        
        return { category, categoryLabel, categoryColor, recommendation };
      }
      
      /**
       * Compute aggregate and per-URL metrics for money pages.
       * @param {Array} topPages - Array from GSC (page/url, clicks, impressions, position)
       * @param {Function} classifySegment - function(url) -> 'money' | 'education' | 'general' | ...
       * @param {Object} siteAgg - { totalClicks, totalImpressions, avgCtr, avgPosition }
       * @param {Map|Object} pageTitleLookup - Optional Map/object url->title
       * @param {Object} schemaAudit - Optional schema audit data with pages array
       * @returns {Object} { overview, rows }
       */
      // Ranking & AI module - MOVED TO TOP OF SCRIPT (see line ~1820)

      // Classify money page sub-segment (Product, Event, Landing)
      function classifyMoneyPageSubSegment(url) {
        if (!url) return 'LANDING';
        
        // Use the same classification logic as Ranking & AI for consistency
        // This ensures Event/Product pages are classified the same way in both tabs
        if (typeof window.classifyUrlForRankingAi === 'function') {
          const classification = window.classifyUrlForRankingAi(url);
          const pageType = classification.pageType;
          
          // Map Ranking & AI pageType to Money Pages segmentType
          if (pageType === 'Event') return 'EVENT';
          if (pageType === 'Product') return 'PRODUCT';
          if (pageType === 'Landing') return 'LANDING';
          // For non-money pages (GBP, Blog, Other), return LANDING as fallback
          // (Money Pages only shows money pages, so these shouldn't appear anyway)
          return 'LANDING';
        }
        
        // Fallback: Use original logic if classifyUrlForRankingAi not available
        const path = normalisePath(url);
        const urlLower = url.toLowerCase();
        
        // Event Pages: Use same pattern as Ranking & AI (substring match for consistency)
        if (urlLower.includes('/beginners-photography-lessons') ||
            urlLower.includes('/photographic-workshops-near-me')) {
          return 'EVENT';
        }
        
        // Product Pages: Use same pattern as Ranking & AI (substring match for consistency)
        if (urlLower.includes('/photo-workshops-uk') ||
            urlLower.includes('/photography-services-near-me')) {
          return 'PRODUCT';
        }
        
        // Landing Pages (default - anything not matching above)
        return 'LANDING';
      }
      
      function computeMoneyPagesMetrics(topPages, classifySegment, siteAgg, pageTitleLookup = null, schemaAudit = null) {
        // Initialize summary by category (Phase 2)
        const summaryByCategory = {
          HIGH_OPPORTUNITY: { count: 0, impressions: 0, clicks: 0 },
          VISIBILITY_FIX: { count: 0, impressions: 0, clicks: 0 },
          MAINTAIN: { count: 0, impressions: 0, clicks: 0 }
        };
        
        // Initialize summary by sub-segment
        const summaryBySubSegment = {
          PRODUCT: { count: 0, impressions: 0, clicks: 0 },
          EVENT: { count: 0, impressions: 0, clicks: 0 },
          LANDING: { count: 0, impressions: 0, clicks: 0 }
        };
        
        if (!topPages || !Array.isArray(topPages) || topPages.length === 0) {
          return {
            overview: {
              moneyClicks: 0,
              moneyImpressions: 0,
              moneyCtr: 0,
              moneyAvgPosition: null,
              moneyCoverageCount: 0,
              moneyTotalKnown: null,
              moneyCoveragePct: null,
              siteCtr: siteAgg.avgCtr || 0,
              siteAvgPosition: siteAgg.avgPosition || null,
              siteTotalClicks: siteAgg.totalClicks || 0,
              siteTotalImpressions: siteAgg.totalImpressions || 0
            },
            rows: [],
            summaryByCategory
          };
        }
        
        const moneyRows = [];
        let moneyClicks = 0;
        let moneyImpressions = 0;
        let weightedPosSum = 0;
        const moneyActiveUrls = new Set();
        
        // Convert pageTitleLookup to Map if it's an object (for backward compatibility)
        // If it's already a Map with metadata objects, use it directly
        let metadataMap = null;
        if (pageTitleLookup instanceof Map) {
          // Check if it contains metadata objects or just titles
          const firstValue = pageTitleLookup.values().next().value;
          if (firstValue && typeof firstValue === 'object' && (firstValue.title !== undefined || firstValue.metaDescription !== undefined)) {
            metadataMap = pageTitleLookup; // It's already a metadata map
          } else {
            // Convert title-only map to metadata map
            metadataMap = new Map();
            pageTitleLookup.forEach((title, url) => {
              metadataMap.set(url, { title: title, metaDescription: null });
            });
          }
        } else if (pageTitleLookup) {
          // Convert object to metadata map
          metadataMap = new Map();
          Object.entries(pageTitleLookup).forEach(([url, value]) => {
            if (typeof value === 'object' && value !== null) {
              metadataMap.set(url, { title: value.title || null, metaDescription: value.metaDescription || null });
            } else {
              metadataMap.set(url, { title: value || null, metaDescription: null });
            }
          });
        }
        
        // Build schema lookup map from schema audit data
        const schemaLookup = new Map();
        const schemaTypesLookup = new Map();
        if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data && schemaAudit.data.pages) {
          schemaAudit.data.pages.forEach(page => {
            if (page.url) {
              // Normalize URL for matching (handles trailing slashes, query params, etc.)
              const normalizedUrl = normalizeUrlForMatching(page.url);
              // Store both original and normalized for lookup flexibility
              const hasSchema = page.hasSchema || page.hasInheritedSchema || false;
              schemaLookup.set(page.url, hasSchema);
              schemaLookup.set(normalizedUrl, hasSchema); // Also store normalized version
              // Store schema types array
              schemaTypesLookup.set(page.url, page.schemaTypes || []);
              schemaTypesLookup.set(normalizedUrl, page.schemaTypes || []); // Also store normalized version
            }
          });
        }
        
        // Iterate over topPages
        // Note: topPages is already aggregated by page from queryPages
        // The Segment Overview uses query+page level data filtered to position 1-20
        // For Money Pages, we want to show ALL money pages (not just position 1-20)
        // to give a complete view of money page performance
        topPages.forEach(page => {
          const url = page.page || page.url || '';
          if (!url) return;
          
          const segment = classifyPageSegment(url);
          if (segment !== PageSegment.MONEY) return;
          
          const clicks = page.clicks || 0;
          const impressions = page.impressions || 0;
          const position = page.position || page.avgPosition || 0;
          
          if (impressions > 0) {
            moneyClicks += clicks;
            moneyImpressions += impressions;
            weightedPosSum += position * impressions;
            moneyActiveUrls.add(url);
          }
          
          // Compute row-level metrics
          const ctr = impressions > 0 ? clicks / impressions : 0;
          const avgPosition = position || null;
          
          // Get title and meta description from metadata lookup
          const metadata = metadataMap?.get(url) || {};
          const title = metadata.title || null;
          const metaDescription = metadata.metaDescription || null;
          
          // Check if schema exists for this page (normalize URL for matching)
          const normalizedUrl = normalizeUrlForMatching(url);
          const hasSchema = schemaLookup.has(url) ? schemaLookup.get(url) : 
                          schemaLookup.has(normalizedUrl) ? schemaLookup.get(normalizedUrl) : null;
          const schemaTypes = schemaTypesLookup.get(url) || schemaTypesLookup.get(normalizedUrl) || [];
          
          // Classify opportunity
          const { category, categoryLabel, categoryColor, recommendation } =
            classifyMoneyPageOpportunity({ ctr, avgPosition, impressions }, siteAgg, hasSchema, schemaTypes);
          
          // Classify sub-segment
          const subSegment = classifyMoneyPageSubSegment(url);
          
          // Update category summary (Phase 2)
          const bucket = summaryByCategory[category];
          if (bucket) {
            bucket.count += 1;
            bucket.impressions += impressions;
            bucket.clicks += clicks;
          }
          
          // Update sub-segment summary
          const subBucket = summaryBySubSegment[subSegment];
          if (subBucket) {
            subBucket.count += 1;
            subBucket.impressions += impressions;
            subBucket.clicks += clicks;
          }
          
          // Push row
          moneyRows.push({
            url,
            title,
            metaDescription,
            clicks,
            impressions,
            ctr,
            avgPosition,
            category,
            categoryLabel,
            categoryColor,
            recommendation,
            schemaTypes,
            subSegment // Add sub-segment to each row
          });
        });
        
        // Compute money overview
        const moneyCtr = moneyImpressions > 0 ? moneyClicks / moneyImpressions : 0;
        const moneyAvgPosition = moneyImpressions > 0 ? weightedPosSum / moneyImpressions : null;
        
        const overview = {
          moneyClicks,
          moneyImpressions,
          moneyCtr,
          moneyAvgPosition,
          moneyCoverageCount: moneyActiveUrls.size,
          moneyTotalKnown: null, // Can be populated if we have a known money URLs list
          moneyCoveragePct: null,
          siteCtr: siteAgg.avgCtr || 0,
          siteAvgPosition: siteAgg.avgPosition || null,
          siteTotalClicks: siteAgg.totalClicks || 0,
          siteTotalImpressions: siteAgg.totalImpressions || 0
        };
        
        // Sort by category then impressions desc
        const categoryOrder = { HIGH_OPPORTUNITY: 0, VISIBILITY_FIX: 1, MAINTAIN: 2 };
        moneyRows.sort((a, b) => {
          const ca = categoryOrder[a.category] ?? 99;
          const cb = categoryOrder[b.category] ?? 99;
          if (ca !== cb) return ca - cb;
          return (b.impressions || 0) - (a.impressions || 0);
        });
        
        return { overview, rows: moneyRows, summaryByCategory, summaryBySubSegment };
      }
      
      // Build compact Money Pages summary for trend tracking (Phase 3)
      // Make buildMoneyPagesSummary globally accessible
      window.buildMoneyPagesSummary = function buildMoneyPagesSummary(moneyPagesMetrics, overview) {
        if (!moneyPagesMetrics || !moneyPagesMetrics.rows || !moneyPagesMetrics.rows.length) {
          return null;
        }

        const pages = moneyPagesMetrics.rows;
        const impressions = pages.reduce((sum, p) => sum + (p.impressions || 0), 0);
        const clicks = pages.reduce((sum, p) => sum + (p.clicks || 0), 0);
        const avgPosWeightedSum = pages.reduce((sum, p) =>
          sum + ((p.avgPosition || p.position || 0) * (p.impressions || 0)), 0
        );

        if (!impressions) return null;

        const avgPosition = avgPosWeightedSum / impressions;
        const ctr = clicks / impressions;

        // Use siteTotalImpressions and siteTotalClicks from overview
        const totalImpressions = overview?.siteTotalImpressions || overview?.totalImpressions || null;
        const totalClicks = overview?.siteTotalClicks || overview?.totalClicks || null;
        
        const shareOfImpressions = totalImpressions && totalImpressions > 0
          ? impressions / totalImpressions
          : null;

        const shareOfClicks = totalClicks && totalClicks > 0
          ? clicks / totalClicks
          : null;

        // Debug logging (only log if we have impressions but no overview - expected when overview is missing)
        if (shareOfImpressions == null && impressions > 0) {
          // Only log if this is unexpected (we have impressions but no overview data)
          // This is expected when overview data is not available, so reduce log level
          debugLog(`ℹ buildMoneyPagesSummary: shareOfImpressions is null (overview data not available) - impressions=${impressions}`, 'info');
        } else if (shareOfImpressions != null) {
          debugLog(`✓ buildMoneyPagesSummary: shareOfImpressions=${shareOfImpressions} (${impressions}/${totalImpressions})`, 'info');
        }

        return {
          count: pages.length,
          impressions,
          clicks,
          ctr,
          avgPosition,
          shareOfImpressions,
          shareOfClicks,
          behaviourScore: moneyPagesMetrics.behaviour
            ? moneyPagesMetrics.behaviour.score
            : null
        };
      };
      
      // ============================================================================
      // PHASE: Money Pages Priority Matrix + 12-Month KPI Tracker
      // ============================================================================
      
      /**
       * Unified money page classification - returns both isMoney flag and segmentType
       * @param {string} url
       * @returns {{ isMoney: boolean, segmentType: MoneySegmentKey | null }}
       */
      function classifyMoneyPage(url) {
        if (!url) return { isMoney: false, segmentType: null };
        
        const path = normalisePath(url);
        
        // Check if it's a money page using existing logic
        const segment = classifyPageSegment(url);
        const isMoney = segment === PageSegment.MONEY;
        
        if (!isMoney) {
          return { isMoney: false, segmentType: null };
        }
        
        // Get sub-segment type (normalize to lowercase for consistency)
        const subSegment = classifyMoneyPageSubSegment(url);
        let segmentType = /** @type {MoneySegmentKey} */ ("all");
        
        if (subSegment === 'PRODUCT') {
          segmentType = "product";
        } else if (subSegment === 'EVENT') {
          segmentType = "event";
        } else if (subSegment === 'LANDING') {
          segmentType = "landing";
        }
        
        return { isMoney: true, segmentType };
      }
      
      // Make available globally for classifyUrlForRankingAi
      if (typeof window !== 'undefined') {
        window.classifyMoneyPage = classifyMoneyPage;
      }
      
      /**
       * Naive expected CTR curve by average position.
       * Returns decimal (0–1).
       * @param {number} pos - Average position
       * @returns {number}
       */
      function expectedCtrForPosition(pos) {
        if (!isFinite(pos) || pos <= 0) return 0.10;     // fallback
        if (pos <= 3) return 0.10;                       // 10% ideal for top 3
        if (pos <= 6) return 0.07;                       // 7% for 4–6
        if (pos <= 10) return 0.05;                      // 5% for 7–10
        if (pos <= 20) return 0.03;                      // 3% for 11–20
        return 0.02;                                     // long tail
      }
      
      /**
       * Compute impact levels based on lost clicks (expected CTR - actual CTR)
       * @param {Array<MoneyPageMetrics>} pages
       */
      function computeImpactLevels(pages) {
        // Step 1: compute lostClicks for each page
        let maxLost = 0;
        for (const p of pages) {
          const expectedCtr = expectedCtrForPosition(p.avgPosition);
          const gap = Math.max(0, expectedCtr - (p.ctr || 0));
          const lostClicks = (p.impressions || 0) * gap;
          p._lostClicks = lostClicks;
          if (lostClicks > maxLost) maxLost = lostClicks;
        }

        if (maxLost <= 0) {
          // All pages flat → mark all as LOW impact
          for (const p of pages) {
            p.impactLevel = "LOW";
          }
          return;
        }

        // Step 2: thresholds relative to max (no magic numbers baked into data)
        const highThreshold = 0.75 * maxLost;
        const medThreshold = 0.35 * maxLost;

        for (const p of pages) {
          const lost = p._lostClicks || 0;
          if (lost >= highThreshold) p.impactLevel = "HIGH";
          else if (lost >= medThreshold) p.impactLevel = "MEDIUM";
          else p.impactLevel = "LOW";
        }
      }
      
      /**
       * Check if a page has the "key schema" for its segment type
       * @param {string} url
       * @param {MoneySegmentKey} segmentType
       * @param {Object} schemaAudit - Schema audit data with pages array
       * @returns {boolean}
       */
      function pageHasKeySchema(url, segmentType, schemaAudit) {
        if (!schemaAudit || !schemaAudit.data || !schemaAudit.data.pages) {
          return false;
        }
        
        const page = schemaAudit.data.pages.find(p => p.url === url);
        if (!page) return false;
        
        const schemaTypes = page.schemaTypes || [];
        const typesLower = schemaTypes.map(t => {
          if (typeof t === 'string') return t.toLowerCase();
          if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type.toLowerCase();
          return String(t).toLowerCase();
        }).filter(t => t && t !== '[object object]');
        
        if (segmentType === "event") {
          return typesLower.includes("event") || typesLower.includes("course");
        } else if (segmentType === "product") {
          return typesLower.includes("product") || typesLower.includes("offer");
        } else if (segmentType === "landing") {
          return typesLower.includes("itemlist") || typesLower.includes("faqpage") || typesLower.includes("article");
        }
        
        return false;
      }
      
      /**
       * Compute difficulty level based on position + schema effort
       * @param {MoneyPageMetrics} p
       * @param {boolean} hasKeySchema   // true if this page already has the main rich type it "should"
       * @returns {DifficultyLevel}
       */
      function computeDifficultyLevel(p, hasKeySchema) {
        const pos = p.avgPosition || 0;
        let base;
        if (pos > 0 && pos <= 5) base = "LOW";          // already ranking well → "easy" CTR fixes
        else if (pos <= 10) base = "MEDIUM";
        else base = "HIGH";

        // If no key schema yet for an event/product, bump difficulty by one
        if (!hasKeySchema && (p.segmentType === "event" || p.segmentType === "product")) {
          if (base === "LOW") base = "MEDIUM";
          else if (base === "MEDIUM") base = "HIGH";
        }

        return /** @type {DifficultyLevel} */ (base);
      }
      
      /**
       * Derive priority level from Impact + Difficulty
       * @param {ImpactLevel} impact
       * @param {DifficultyLevel} difficulty
       * @returns {PriorityLevel}
       */
      function derivePriorityLevel(impact, difficulty) {
        // High impact & easy/medium difficulty → HIGH priority
        if (impact === "HIGH" && (difficulty === "LOW" || difficulty === "MEDIUM")) {
          return "HIGH";
        }

        // Medium cases or high impact but high difficulty → MEDIUM
        if (
          impact === "HIGH" && difficulty === "HIGH" ||
          impact === "MEDIUM" && (difficulty === "LOW" || difficulty === "MEDIUM")
        ) {
          return "MEDIUM";
        }

        // Everything else → LOW
        return "LOW";
      }
      
      /**
       * Build MoneyPageMetrics array from topPages data
       * @param {Array<{page: string, clicks: number, impressions: number, ctr: number, position: number, title?: string}>} topPages
       * @param {Object} schemaAudit - Optional schema audit data
       * @returns {Array<MoneyPageMetrics>}
       */
      function buildMoneyPageMetrics(topPages, schemaAudit = null) {
        const result = [];

        for (const row of topPages) {
          const url = row.page || row.url;
          const { isMoney, segmentType } = classifyMoneyPage(url);
          if (!isMoney) continue;

          // CTR might be percentage (0-100) or decimal (0-1), normalize to decimal
          let ctr = row.ctr || 0;
          if (ctr > 1) ctr = ctr / 100; // Convert percentage to decimal
          
          const m = /** @type {MoneyPageMetrics} */ ({
            url,
            title: row.title || url,
            segmentType: segmentType || "all",
            clicks: row.clicks || 0,
            impressions: row.impressions || 0,
            ctr: ctr,
            avgPosition: row.position || row.avgPosition || 0,
            impactLevel: "LOW",
            difficultyLevel: "MEDIUM",
            priorityLevel: "LOW"
          });

          const hasKeySchema = pageHasKeySchema(url, m.segmentType, schemaAudit);
          m.difficultyLevel = computeDifficultyLevel(m, hasKeySchema);
          result.push(m);
        }

        computeImpactLevels(result);

        for (const p of result) {
          p.priorityLevel = derivePriorityLevel(p.impactLevel, p.difficultyLevel);
        }

        return result;
      }
      
      // Make function globally accessible immediately after definition
      // CRITICAL: Assign to window immediately so it's available when displayDashboard runs
      // This REPLACES the placeholder we defined at the top of the script
      if (typeof window !== 'undefined') {
        window.buildMoneyPageMetrics = buildMoneyPageMetrics;
        // Also assign to global scope as fallback
        if (typeof globalThis !== 'undefined') {
          globalThis.buildMoneyPageMetrics = buildMoneyPageMetrics;
        }
        // Debug: Log that function is now available
        console.log('[Money Pages] ✓ buildMoneyPageMetrics FULL IMPLEMENTATION assigned to window (replaced placeholder)');
      }
      
      /**
       * Build per-segment summaries for Money Pages (for 12-month KPI tracking)
       * @param {Array<MoneyPageMetrics>} moneyPages
       * @param {Object} behaviourScores - Optional behaviour scores by segment
       * @returns {MoneySegmentMetricsByAudit}
       */
      function buildMoneySegmentSummary(moneyPages, behaviourScores = {}) {
        // Ensure moneyPages is an array (default to empty array)
        const pages = Array.isArray(moneyPages) ? moneyPages : [];
        
        const segments = {
          allMoney: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
          landingPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
          eventPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
          productPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 }
        };

        const groups = {
          allMoney: pages,
          landingPages: pages.filter(p => p.segmentType === "landing"),
          eventPages: pages.filter(p => p.segmentType === "event"),
          productPages: pages.filter(p => p.segmentType === "product")
        };

        for (const [key, groupPages] of Object.entries(groups)) {
          if (!groupPages || !groupPages.length) continue;
          const clicks = groupPages.reduce((s, p) => s + (p.clicks || 0), 0);
          const impressions = groupPages.reduce((s, p) => s + (p.impressions || 0), 0);
          const ctr = impressions > 0 ? clicks / impressions : 0;
          const avgPosition = groupPages.length > 0
            ? groupPages.reduce((s, p) => s + (p.avgPosition || 0), 0) / groupPages.length
            : 0;

          segments[key].clicks = clicks;
          segments[key].impressions = impressions;
          segments[key].ctr = ctr;
          segments[key].avgPosition = avgPosition;
          // Use behaviour score from parameter if available, otherwise 0
          segments[key].behaviourScore = behaviourScores[key] || behaviourScores[key.toLowerCase()] || 0;
        }

        // Always return a valid structure (never null)
        return segments;
      }
      
      // Compute money pages behaviour score (for Authority overlay)
      // Define globally to ensure accessibility from event handlers
      window.computeMoneyPagesBehaviour = function(gscQueries, moneyPages, useAllPositions = false) {
        if (!gscQueries || !gscQueries.length || !moneyPages || !moneyPages.length) {
          debugLog(`🎯 computeMoneyPagesBehaviour: Missing data - gscQueries=${!!gscQueries}(${gscQueries?.length || 0}), moneyPages=${!!moneyPages}(${moneyPages?.length || 0})`, 'warn');
          return null;
        }

        // Normalize URLs: remove trailing slash, convert to lowercase, remove protocol if present
        const normalizeUrl = (url) => {
          if (!url) return '';
          let normalized = url.toString().trim().toLowerCase();
          // Remove protocol (http:// or https://)
          normalized = normalized.replace(/^https?:\/\//, '');
          // Remove trailing slash
          normalized = normalized.replace(/\/$/, '');
          return normalized;
        };

        const moneySet = new Set(
          moneyPages.map(p => {
            const url = normalizeUrl(p.url || p.page || '');
            return url;
          })
        );

        debugLog(`🎯 computeMoneyPagesBehaviour: Created moneySet with ${moneySet.size} URLs. useAllPositions=${useAllPositions}. Sample URLs: ${Array.from(moneySet).slice(0, 3).join(', ')}`, 'info');

        let clicks = 0;
        let impressions = 0;
        let top10Clicks = 0;
        let top10Impressions = 0;
        let weightedPosSum = 0;
        let weightedPosImps = 0;
        let matchedUrls = 0;
        let unmatchedUrls = 0;
        let filteredOutByPosition = 0;

        gscQueries.forEach(row => {
          const url = normalizeUrl(row.page || row.url || '');
          if (!moneySet.has(url)) {
            unmatchedUrls++;
            return;
          }
          matchedUrls++;

          const pos = typeof row.position === 'number'
            ? row.position
            : (row.avgPosition || null);
          const imps = row.impressions || 0;
          const cls = row.clicks || 0;

          // For filtered calculations, include all positions; otherwise only 1-20 to match Authority
          if (!imps || !pos || pos <= 0) return;
          if (!useAllPositions && pos > 20) {
            filteredOutByPosition++;
            return;
          }

          clicks += cls;
          impressions += imps;

          weightedPosSum += pos * imps;
          weightedPosImps += imps;
          if (pos <= 10) {
            top10Clicks += cls;
            top10Impressions += imps;
          }
        });

        debugLog(`🎯 computeMoneyPagesBehaviour: Matched ${matchedUrls} URLs, unmatched ${unmatchedUrls} URLs, filtered by position ${filteredOutByPosition}. Total impressions: ${impressions}, clicks: ${clicks}`, 'info');

        if (!impressions || !weightedPosImps) {
          debugLog(`🎯 computeMoneyPagesBehaviour: No valid impressions (${impressions}) or weighted positions (${weightedPosImps}), returning null`, 'warn');
          return null;
        }

        const siteCtr = clicks / impressions;
        const top10Ctr = top10Impressions > 0 ? (top10Clicks / top10Impressions) : 0;
        const avgPos = weightedPosSum / weightedPosImps;
        const top10Share = impressions > 0 ? (top10Impressions / impressions) : 0;

        // Reuse existing Behaviour score calculation (same as Authority)
        // For filtered calculations, include all positions; otherwise only 1-20
        const rankingQueries = gscQueries.filter(row => {
          const url = normalizeUrl(row.page || row.url || '');
          if (!moneySet.has(url)) return false;
          const pos = typeof row.position === 'number' ? row.position : (row.avgPosition || null);
          if (!pos || pos <= 0 || !(row.impressions || 0)) return false;
          if (!useAllPositions && pos > 20) return false;
          return true;
        });

        const behaviourScore = computeBehaviourScoreRaw(rankingQueries);

        return {
          score: behaviourScore,
          siteCtr,
          top10Ctr,
          avgPos,
          top10Share,
          clicks,
          impressions
        };
      };

      // Fallback: compute Money Pages behaviour from page-level aggregates (no queryPages required)
      // Used when queryPages is missing/truncated or URLs don't match.
      function computeMoneyPagesBehaviourFromPageAggregates(moneyPages) {
        if (!Array.isArray(moneyPages) || moneyPages.length === 0) return null;

        let clicks = 0;
        let impressions = 0;
        let weightedPosSum = 0;
        let weightedPosImps = 0;
        let top10Clicks = 0;
        let top10Impressions = 0;

        moneyPages.forEach(p => {
          const imps = p.impressions || 0;
          const cls = p.clicks || 0;
          const pos = typeof p.avgPosition === 'number' ? p.avgPosition : (p.avgPosition ? parseFloat(p.avgPosition) : null);
          if (!imps || !pos || pos <= 0) return;

          clicks += cls;
          impressions += imps;
          weightedPosSum += pos * imps;
          weightedPosImps += imps;

          // Approximate top-10 using avgPosition (best available without query-level data)
          if (pos <= 10) {
            top10Clicks += cls;
            top10Impressions += imps;
          }
        });

        if (!impressions || !weightedPosImps) return null;

        const siteCtr = clicks / impressions;
        const top10Ctr = top10Impressions > 0 ? (top10Clicks / top10Impressions) : 0;
        const avgPos = weightedPosSum / weightedPosImps;
        const top10Share = impressions > 0 ? (top10Impressions / impressions) : 0;

        // Map CTR to score using same bands as Authority behaviour
        const scoreCtrAll = Math.min(siteCtr / 0.05, 1) * 100;    // 0–5% => 0–100
        const scoreCtrTop10 = Math.min(top10Ctr / 0.10, 1) * 100; // 0–10% => 0–100
        const behaviourScore = 0.5 * scoreCtrAll + 0.5 * scoreCtrTop10;

        return {
          score: behaviourScore,
          siteCtr,
          top10Ctr,
          avgPos,
          top10Share,
          clicks,
          impressions
        };
      }
      
      // Compute money pages metrics if we have queryPages data
      let moneyPagesMetrics = null;
      if (queryPages && queryPages.length > 0) {
        // Aggregate all pages from queryPages (not just top 10)
        const pageMap = new Map();
        queryPages.forEach(row => {
          const url = row.page || row.url || '';
          if (!url) return;
          
          if (!pageMap.has(url)) {
            pageMap.set(url, {
              url: url,
              clicks: 0,
              impressions: 0,
              totalPositionWeight: 0
            });
          }
          
          const page = pageMap.get(url);
          page.clicks += row.clicks || 0;
          page.impressions += row.impressions || 0;
          page.totalPositionWeight += (row.position || 0) * (row.impressions || 0);
        });
        
        // Convert to topPages format
        const allTopPages = Array.from(pageMap.values())
          .map(page => ({
            url: page.url,
            clicks: page.clicks,
            impressions: page.impressions,
            ctr: page.impressions > 0 ? (page.clicks / page.impressions) : 0,
            avgPosition: page.impressions > 0 ? page.totalPositionWeight / page.impressions : 0,
            position: page.impressions > 0 ? page.totalPositionWeight / page.impressions : 0
          }))
          .filter(page => page.impressions > 0); // Only pages with impressions
        
        // Compute site aggregates
        const siteAgg = computeSiteAggregateFromTopPages(allTopPages);
        
        // Build page metadata lookup from schema audit if available
        const pageMetadataLookup = new Map();
        if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
          const schemaData = schemaAudit.data;
          // Use the new pages array with metadata (title, metaDescription)
          if (schemaData.pages && Array.isArray(schemaData.pages)) {
            schemaData.pages.forEach(page => {
              if (page.url) {
                pageMetadataLookup.set(page.url, {
                  title: page.title || null,
                  metaDescription: page.metaDescription || null
                });
              }
            });
          }
          // Fallback to old structure for backwards compatibility
          if (schemaData.pagesWithSchema && Array.isArray(schemaData.pagesWithSchema) && pageMetadataLookup.size === 0) {
            schemaData.pagesWithSchema.forEach(page => {
              if (page.url) {
                pageMetadataLookup.set(page.url, {
                  title: page.title || null,
                  metaDescription: page.metaDescription || page.description || null
                });
              }
            });
          }
          // Also check missing pages (fallback)
          if (schemaData.missingSchemaPages && Array.isArray(schemaData.missingSchemaPages)) {
            schemaData.missingSchemaPages.forEach(page => {
              const url = typeof page === 'string' ? page : page.url;
              if (url && !pageMetadataLookup.has(url)) {
                pageMetadataLookup.set(url, {
                  title: typeof page === 'object' ? (page.title || null) : null,
                  metaDescription: typeof page === 'object' ? (page.metaDescription || page.description || null) : null
                });
              }
            });
          }
        }
        
        // Compute money pages metrics
        // Use CSV as source of truth for all pages, then match GSC data to CSV URLs
        // This ensures we segment ALL pages (433 URLs) not just those in GSC data (78 pages)
        const allGSCPages = data.queryPages || [];
        const allPagesAggregated = computeAllPagesForSegment(allGSCPages); // Aggregate GSC data by page
        
        // Fetch CSV and segment all URLs
        // First check for manually loaded URL list, then try GitHub/fallback
        let csvUrls = [];
        try {
          // Check for manually loaded URL list first
          const manualUrlList = localStorage.getItem('manual_url_list');
          if (manualUrlList) {
            try {
              csvUrls = JSON.parse(manualUrlList);
              debugLog(`✓ Using manual URL list: ${csvUrls.length} URLs`, 'info');
            } catch (parseErr) {
              debugLog(`⚠ Failed to parse manual URL list: ${parseErr.message}`, 'warn');
            }
          }
          
          // If no manual list, try fetching from GitHub/fallback
          if (csvUrls.length === 0) {
            csvUrls = await fetchAndParseSiteUrlsCsv();
            debugLog(`✓ Fetched ${csvUrls.length} URLs from CSV (GitHub/fallback)`, 'info');
          }
          
          // Segment all CSV URLs
          const allCsvPages = csvUrls.map(url => {
            const segment = classifyPageSegment(url);
            return {
              url: url,
              segment: segment,
              // GSC data will be matched below
              clicks: 0,
              impressions: 0,
              ctr: 0,
              avgPosition: null,
              position: null
            };
          });
          
          // Create a map of GSC data by URL (normalized)
          const gscDataMap = new Map();
          allPagesAggregated.forEach(page => {
            const normalizedUrl = (page.url || page.page || '').replace(/\/$/, '');
            gscDataMap.set(normalizedUrl, page);
          });
          
          // Match GSC data to CSV URLs (normalize URLs for matching)
          const csvPagesWithGsc = allCsvPages.map(csvPage => {
            const normalizedCsvUrl = csvPage.url.replace(/\/$/, '');
            
            // Try to find matching GSC data (check both with and without trailing slash)
            let gscData = gscDataMap.get(normalizedCsvUrl);
            if (!gscData) {
              // Try with trailing slash
              gscData = gscDataMap.get(normalizedCsvUrl + '/');
            }
            if (!gscData) {
              // Try without trailing slash (if CSV had one)
              gscData = gscDataMap.get(normalizedCsvUrl.replace(/\/$/, ''));
            }
            
            if (gscData) {
              // Merge GSC data - format expected by computeMoneyPagesMetrics
              return {
                url: csvPage.url,
                page: csvPage.url, // Also set page property for compatibility
                segment: csvPage.segment,
                clicks: gscData.clicks || 0,
                impressions: gscData.impressions || 0,
                ctr: gscData.ctr || 0,
                avgPosition: gscData.avgPosition || gscData.position || null,
                position: gscData.position || gscData.avgPosition || null
              };
            } else {
              // No GSC data for this URL (zero impressions or never appeared in search)
              // Format expected by computeMoneyPagesMetrics
              return {
                url: csvPage.url,
                page: csvPage.url, // Also set page property for compatibility
                segment: csvPage.segment,
                clicks: 0,
                impressions: 0,
                ctr: 0,
                avgPosition: null,
                position: null
              };
            }
          });
          
          // Filter to money pages only and compute metrics
          const moneyPagesFromCsv = csvPagesWithGsc.filter(page => page.segment === PageSegment.MONEY);
          debugLog(`✓ Segmented ${moneyPagesFromCsv.length} money pages from CSV (out of ${csvUrls.length} total URLs)`, 'info');
          
          moneyPagesMetrics = computeMoneyPagesMetrics(
            moneyPagesFromCsv, // Use CSV URLs with matched GSC data
            classifyPageSegment,
            siteAgg,
            pageMetadataLookup, // Pass metadata lookup
            schemaAudit // Pass schema audit data to check for schema presence
          );
        } catch (csvError) {
          debugLog(`⚠ Failed to fetch CSV, falling back to GSC data only: ${csvError.message}`, 'warn');
          // Fallback to GSC data only if CSV fetch fails
          moneyPagesMetrics = computeMoneyPagesMetrics(
            allPagesAggregated,
            classifyPageSegment,
            siteAgg,
            pageMetadataLookup,
            schemaAudit
          );
        }
        
        // Compute money pages behaviour score
        const moneyPagesList = moneyPagesMetrics.rows || [];
        const moneyBehaviour = window.computeMoneyPagesBehaviour(
          allGSCPages, // Use all GSC pages for behaviour calculation
          moneyPagesList
        );
        moneyPagesMetrics.behaviour = moneyBehaviour;
        
        debugLog(`Money Pages Metrics: ${moneyPagesMetrics.rows.length} money pages found, ${moneyPagesMetrics.overview.moneyClicks} clicks, ${moneyPagesMetrics.overview.moneyImpressions} impressions`, 'info');
        if (moneyBehaviour) {
          debugLog(`Money Pages Behaviour: score=${moneyBehaviour.score != null ? moneyBehaviour.score.toFixed(1) : 'N/A'}, CTR=${moneyBehaviour.siteCtr != null ? (moneyBehaviour.siteCtr * 100).toFixed(2) : 'N/A'}%, Top-10 CTR=${moneyBehaviour.top10Ctr != null ? (moneyBehaviour.top10Ctr * 100).toFixed(2) : 'N/A'}%`, 'info');
        }
        
        // Build Money Page Priority Matrix data
        // Convert moneyPagesMetrics.rows to format expected by buildMoneyPageMetrics
        const topPagesForPriority = moneyPagesMetrics.rows.map(row => ({
          page: row.url,
          url: row.url,
          clicks: row.clicks || 0,
          impressions: row.impressions || 0,
          ctr: (row.ctr || 0) * 100, // Convert to percentage for buildMoneyPageMetrics
          position: row.avgPosition || 0,
          avgPosition: row.avgPosition || 0,
          title: row.title || row.url
        }));
        
        // Store priority matrix data globally
        window.moneyPagePriorityData = buildMoneyPageMetrics(topPagesForPriority, schemaAudit);
        debugLog(`Money Pages Priority: Built ${window.moneyPagePriorityData.length} priority entries`, 'info');
        
        // Build segment summary for Supabase storage
        // CRITICAL: Use moneyPagesMetrics.rows (has clicks/impressions/avgPosition/segmentType) not moneyPagePriorityData
        const behaviourScoresBySegment = {};
        if (moneyBehaviour && moneyBehaviour.bySegment) {
          behaviourScoresBySegment.allMoney = moneyBehaviour.bySegment.money?.behaviour?.score || 0;
          behaviourScoresBySegment.landingPages = 0; // Will be calculated per segment if needed
          behaviourScoresBySegment.eventPages = 0;
          behaviourScoresBySegment.productPages = 0;
        }
        // Build segment metrics from moneyPagesMetrics.rows (has the actual GSC data)
        // Map subSegment (PRODUCT/EVENT/LANDING) to segmentType (product/event/landing)
        const moneyPagesForSegments = (moneyPagesMetrics?.rows || []).map(row => {
          const subSegment = row.subSegment || 'LANDING';
          let segmentType = 'landing'; // Default
          if (subSegment === 'PRODUCT') segmentType = 'product';
          else if (subSegment === 'EVENT') segmentType = 'event';
          else if (subSegment === 'LANDING') segmentType = 'landing';
          
          return {
            clicks: row.clicks || 0,
            impressions: row.impressions || 0,
            ctr: row.ctr || 0,
            avgPosition: row.avgPosition || 0,
            segmentType: segmentType
          };
        });
        window.moneySegmentMetrics = buildMoneySegmentSummary(moneyPagesForSegments, behaviourScoresBySegment);
        debugLog(`Money Pages Segments: Built segment summary from ${moneyPagesForSegments.length} pages`, 'info');
        debugLog(`Money Pages Segments: allMoney clicks=${window.moneySegmentMetrics.allMoney.clicks}, impressions=${window.moneySegmentMetrics.allMoney.impressions}`, 'info');
      } else {
        debugLog('⚠ Money Pages Metrics: No queryPages data available - building empty structure', 'warn');
        window.moneyPagePriorityData = [];
        // Always build empty segment metrics structure (never null) so it can be saved to Supabase
        window.moneySegmentMetrics = buildMoneySegmentSummary([], {});
        debugLog(`Money Pages Segments: Built empty segment summary (no data available) - allMoney clicks=${window.moneySegmentMetrics.allMoney.clicks}, impressions=${window.moneySegmentMetrics.allMoney.impressions}`, 'info');
      }
      
      // Ensure moneySegmentMetrics is never null (always a valid structure)
      if (!window.moneySegmentMetrics) {
        debugLog('⚠ Money Pages Segments: moneySegmentMetrics was null, building empty structure', 'warn');
        window.moneySegmentMetrics = buildMoneySegmentSummary([], {});
      }

      const scores = {
        localEntity,
        serviceArea,
        authority: {
          score: authority, // Main score (default: all pages)
          bySegment: authorityBySegment // Per-segment Authority scores (if available)
        },
        visibility,
        contentSchema,
        // Authority component scores for historical tracking (backward compatible)
        authorityComponents: authorityComponents,
        // GAIO health components (extracted from contentSchema)
        coverage: coverageScore,
        diversity: diversityScore,
        // Phase 1: Brand overlay (overlay only, not weighted in GAIO score)
        brandOverlay: brandOverlay,
        // Money Pages Performance metrics (overlay only, not weighted in GAIO score)
        // Always include moneyPagesMetrics, even if null (ensures it's saved to Supabase)
        moneyPagesMetrics: moneyPagesMetrics || null
      };
      
      // Store moneyPagesMetrics globally for saveAuditToSupabase to access
      if (moneyPagesMetrics) {
        window.moneyPagesMetrics = moneyPagesMetrics;
        debugLog(`✓ Stored moneyPagesMetrics globally: ${moneyPagesMetrics.rows?.length || 0} rows`, 'info');
      } else {
        debugLog(`⚠ moneyPagesMetrics is null - will be saved as null to Supabase`, 'warn');
      }

      debugLog(`Deterministic pillar scores: ${JSON.stringify(scores)}`, 'info');
      return scores;
    }
    
    // Calculate GAIO Health Score
    // IMPORTANT: GAIO score uses ONLY the 5 pillars - brandOverlay and aiSummary are overlay metrics only
    function calculateAiGeoScore(scores, schemaAudit = null, snippetReadiness = null) {
      // GAIO weights - ONLY the 5 pillars
      const AIGEO_WEIGHTS = {
        authority: 0.30,
        content: 0.25,
        visibility: 0.20,
        localEntity: 0.15,
        serviceArea: 0.10
      };
      
      // Extract scores from the 5 pillars ONLY
      const authorityScore = (typeof scores.authority === 'object' && scores.authority !== null) 
        ? scores.authority.score 
        : scores.authority || 0;
      const contentScore = scores.contentSchema || 0;
      const visibilityScore = scores.visibility || 0;
      const localEntityScore = scores.localEntity || 0;
      const serviceAreaScore = scores.serviceArea || 0;
      
      // Calculate weighted score using ONLY the 5 pillars
      const aiGeoScore = Math.round(
        authorityScore * AIGEO_WEIGHTS.authority +
        contentScore * AIGEO_WEIGHTS.content +
        visibilityScore * AIGEO_WEIGHTS.visibility +
        localEntityScore * AIGEO_WEIGHTS.localEntity +
        serviceAreaScore * AIGEO_WEIGHTS.serviceArea
      );
      
      // Phase 1: Calculate AI Summary Likelihood using new method (overlay only, not part of GAIO score)
      // Handle both number format (legacy) and object format (if it exists)
      const snippetReadinessScore = typeof snippetReadiness === 'number' 
        ? snippetReadiness 
        : (snippetReadiness?.overallScore || 0);
      const brandScore = scores.brandOverlay?.score || 0;
      
      // Use new computeAiSummaryLikelihood if we have snippet readiness data (brandScore can be 0)
      let aiSummary;
      if (snippetReadinessScore > 0) {
        aiSummary = computeAiSummaryLikelihood(snippetReadinessScore, visibilityScore, brandScore);
      } else {
        // Fallback to old method for backward compatibility
        aiSummary = {
          label: calculateAiSummaryLikelihood({
            aiGeoScore,
            authority: authorityScore,
            content: contentScore,
            coverage: 0 // Not used in new calculation
          }),
          score: aiGeoScore, // Use aiGeoScore as fallback
          reasons: []
        };
      }
      
      return {
        aiGeoScore, // Calculated from 5 pillars ONLY
        aiGeoStatus: aiGeoScore >= 70 ? 'green' : aiGeoScore >= 50 ? 'amber' : 'red',
        aiSummaryLikelihood: aiSummary.label, // Keep backward compatibility
        aiSummary: aiSummary // New Phase 1 field (overlay only)
      };
    }
    
    // Calculate AI Summary Likelihood (OLD - kept for backward compatibility, but will be replaced)
    // NOTE: This is being replaced by computeAiSummaryLikelihood which uses snippetReadiness, visibility, and brand
    function calculateAiSummaryLikelihood({ aiGeoScore, authority, content, coverage }) {
      const strongAuthority = authority >= 65;
      const strongContent = content >= 70;
      const strongCoverage = coverage >= 80;
      
      if (aiGeoScore >= 75 && strongAuthority && strongContent && strongCoverage) {
        return 'high';
      }
      if (aiGeoScore >= 55) {
        return 'medium';
      }
      return 'low';
    }

    function calculateSnippetReadiness(scores, data) {
      // Snippet readiness combines:
      // 1. Content/Schema score (structured data quality)
      // 2. Visibility score (SERP feature presence)
      // 3. Authority score (content depth and trust)
      // Weighted average: 40% Content/Schema, 35% Visibility, 25% Authority
      // Handle both old format (number) and new format (object with score)
      const authorityScore = typeof scores.authority === 'object' ? scores.authority.score : scores.authority;
      const readiness = (
        scores.contentSchema * 0.4 +
        scores.visibility * 0.35 +
        authorityScore * 0.25
      );
      return Math.round(Math.min(100, Math.max(0, readiness)));
    }

    // Fetch real data from Google Search Console API using unified endpoint
    // Note: apiKey parameter kept for compatibility but not used (endpoint uses OAuth2)
    async function fetchSearchConsoleData(apiKey, propertyUrl, days) {
      debugLog(`Fetching real GSC data for ${days} days...`, 'info');
      
      // Calculate date range
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);
      
      // Format dates as YYYY-MM-DD
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      const startDateStr = formatDate(startDate);
      const endDateStr = formatDate(endDate);
      
      debugLog(`Date range: ${startDateStr} to ${endDateStr}`, 'info');
      
      try {
        // Get tracked keywords for queryTotals fetching
        const trackedKeywords = window.RankingAiModule?.TRACKED_KEYWORDS || [];
        const keywordsParam = trackedKeywords.length > 0 
          ? `&keywords=${encodeURIComponent(JSON.stringify(trackedKeywords))}`
          : '';
        
        // Call unified GSC entity metrics endpoint
        const response = await fetch(apiUrl(`/api/aigeo/gsc-entity-metrics?property=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDateStr}${keywordsParam}`));

        if (!response.ok) {
          // Try to parse as JSON, but handle non-JSON error responses
          let errorData = null;
          const contentType = response.headers.get('content-type') || '';
          try {
            if (contentType.includes('application/json')) {
              errorData = await response.json();
            } else {
              // Response is not JSON (likely HTML error page)
              const errorText = await response.text();
              debugLog(`✗ GSC API returned non-JSON error (HTTP ${response.status}): ${errorText.substring(0, 200)}`, 'error');
              throw new Error(`Server error (HTTP ${response.status}): ${errorText.substring(0, 100)}...`);
            }
          } catch (parseError) {
            // If JSON parsing fails, use the parse error or create a generic error
            if (parseError.message && !parseError.message.includes('Server error')) {
              debugLog(`✗ Failed to parse error response: ${parseError.message}`, 'error');
              throw new Error(`Server error (HTTP ${response.status}): Unable to parse error response. The API may be experiencing issues.`);
            }
            throw parseError;
          }
          
          debugLog(`✗ GSC API error: ${errorData.message || errorData.error}`, 'error');
          if (errorData.details) {
            debugLog(`Details: ${errorData.details}`, 'error');
          }
          
          // If OAuth not configured, show helpful message
          if (errorData.message && errorData.message.includes('OAuth2 credentials not configured')) {
            throw new Error('Google Search Console OAuth2 credentials not configured. Please set GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, and GOOGLE_REFRESH_TOKEN in Vercel environment variables.');
          }
          
          throw new Error(errorData.message || errorData.error || 'Failed to fetch Search Console data');
        }

        const gsc = await response.json();
        
        if (gsc.status !== 'ok') {
          throw new Error(gsc.message || 'Failed to fetch Search Console data');
        }
        
        debugLog(`✓ Real GSC data fetched: ${gsc.data.overview.totalClicks} clicks, ${gsc.data.overview.totalImpressions} impressions`, 'success');
        
        // Log segmentation data availability
        if (gsc.data.queryPages && gsc.data.queryPages.length > 0) {
          debugLog(`✓ GSC API returned ${gsc.data.queryPages.length} query+page combinations for segmentation`, 'success');
        } else {
          debugLog('⚠ GSC API did not return queryPages data. Segmentation will use fallback calculation.', 'warn');
        }
        
        // Log queryTotals availability
        if (gsc.data.queryTotals && gsc.data.queryTotals.length > 0) {
          debugLog(`✓ GSC API returned ${gsc.data.queryTotals.length} query-only totals for tracked keywords`, 'success');
        } else {
          debugLog('⚠ GSC API did not return queryTotals data. Table will show — for missing keywords.', 'warn');
        }
        
        // Return data in format expected by existing code
        const searchData = {
          totalClicks: gsc.data.overview.totalClicks || 0,
          totalImpressions: gsc.data.overview.totalImpressions || 0,
          averagePosition: gsc.data.overview.avgPosition || 0,
          ctr: gsc.data.overview.ctr || 0, // Already 0-100 from API
          topQueries: gsc.data.topQueries || [],
          queryPages: gsc.data.queryPages || [], // Query+page combinations for segmentation
          queryTotals: gsc.data.queryTotals || [], // Query-only totals for tracked keywords (for table)
          timeseries: gsc.data.timeseries || [], // For trend chart
          dateRange: days,
          // Store full GSC response for trend chart access
          _gscResponse: gsc,
          // Create overview object with siteTotalImpressions and siteTotalClicks for buildMoneyPagesSummary
          overview: {
            siteTotalImpressions: gsc.data.overview.totalImpressions || 0,
            siteTotalClicks: gsc.data.overview.totalClicks || 0,
            totalImpressions: gsc.data.overview.totalImpressions || 0,
            totalClicks: gsc.data.overview.totalClicks || 0
          }
        };
        return searchData;
      } catch (error) {
        debugLog(`✗ Error fetching GSC data: ${error.message}`, 'error');
        throw error;
      }
    }

    // Run the audit
    async function runAudit() {
      debugLog('=== AUDIT START: Beginning audit scan ===', 'info');
      
      // Get API key - prioritize Vercel env var, then loaded key, then localStorage
      let apiKey = window._loadedApiKey;
      
      // Try Vercel environment variable first
      if (!apiKey) {
        try {
          debugLog('Fetching API key from Vercel environment variable...', 'info');
          const response = await fetch(apiUrl('/api/get-api-key'));
          if (response.ok) {
            const data = await response.json();
            if (data.apiKey) {
              apiKey = data.apiKey;
              debugLog('✓ Using API key from Vercel environment variable', 'success');
              window._loadedApiKey = apiKey;
            }
          }
        } catch (e) {
          debugLog('Vercel env var endpoint not available', 'info');
        }
      }
      
      // Fall back to config.js
      if (!apiKey && window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey) {
        apiKey = window.API_CONFIG.googleSearchConsoleApiKey;
        debugLog('✓ Using API key from config.js', 'success');
        window._loadedApiKey = apiKey;
      }
      
      // Fall back to localStorage
      if (!apiKey) {
        apiKey = localStorage.getItem('gsc_api_key');
        if (apiKey) {
          debugLog('✓ Using API key from localStorage', 'success');
          window._loadedApiKey = apiKey;
        }
      }
      
      const propertyUrl = document.getElementById('propertyUrl').value;
      const dateRange = parseInt(document.getElementById('dateRange').value);
      
      debugLog(`Property URL: ${propertyUrl}`, 'info');
      debugLog(`Date Range: ${dateRange} days`, 'info');

      // Note: API key no longer required - new endpoint uses OAuth2 from env vars
      if (!propertyUrl) {
        debugLog('✗ No property URL provided', 'error');
        showStatus('Please enter your property URL', 'error');
        return;
      }

      debugLog('Showing loading indicator...', 'info');
      document.getElementById('loading').classList.add('show');
      document.getElementById('dashboard').style.display = 'none';
      updateProgress(0, 'Initializing audit scan...');

      // Load saved audit data first to use as defaults (preserve data when sources unavailable)
      let savedAudit = null;
      try {
        const saved = localStorage.getItem('last_audit_results');
        if (saved) {
          savedAudit = JSON.parse(saved);
          debugLog('✓ Loaded previous audit data for fallback', 'info');
        }
      } catch (e) {
        debugLog(`⚠ Could not load previous audit data: ${e.message}`, 'warn');
      }

      // Declare schemaAudit outside try block so it's accessible in finally
      // Initialize with saved data if available (preserves Content/Schema when endpoint unavailable)
      let schemaAudit = savedAudit?.schemaAudit || null;
      let localSignals = savedAudit?.localSignals || null;
      // Don't use cached siteReviews - always fetch fresh Trustpilot snapshot
      // Old cached values (4.8, 127) should be replaced with new snapshot (4.6, 610)
      let siteReviews = null; // Always fetch fresh
      let backlinkMetrics = savedAudit?.backlinkMetrics || null;

      try {
        updateProgress(10, 'Fetching Search Console data...');
        debugLog('Fetching Search Console data...', 'info');
        // Fetch data
        const searchData = await fetchSearchConsoleData(apiKey, propertyUrl, dateRange);
        debugLog('✓ Search Console data fetched successfully', 'success');
        debugLog(`Data: ${JSON.stringify(searchData).substring(0, 200)}...`, 'info');
        
        updateProgress(35, 'Fetching local signals data...');
        debugLog('Fetching local signals data...', 'info');
        // Fetch local signals (Business Profile) data
        // Only fetch if we don't have saved data, or always fetch fresh (Business Profile can change)
        try {
          const localSignalsResponse = await fetch(apiUrl(`/api/aigeo/local-signals?property=${encodeURIComponent(propertyUrl)}`));
          if (localSignalsResponse.ok) {
            const freshLocalSignals = await localSignalsResponse.json();
            if (freshLocalSignals.status === 'ok') {
              localSignals = freshLocalSignals;
              debugLog('✓ Local signals data fetched successfully', 'success');
              debugLog(`Service areas: ${localSignals.data.serviceAreas?.length || 0}, NAP score: ${localSignals.data.napConsistencyScore || 'N/A'}`, 'info');
            } else {
              debugLog('⚠ Local signals returned error, using saved data if available', 'warn');
            }
          } else {
            debugLog('⚠ Local signals endpoint not available, using saved data if available', 'warn');
          }
        } catch (localSignalsError) {
          debugLog(`⚠ Local signals error: ${localSignalsError.message}, using saved data if available`, 'warn');
        }
        
        // If fetch failed but we have saved data, keep using it
        if (!localSignals && savedAudit?.localSignals) {
          localSignals = savedAudit.localSignals;
          debugLog('✓ Using saved local signals data', 'info');
        }
        
        updateProgress(37, 'Fetching Trustpilot snapshot data...');
        debugLog('Fetching Trustpilot snapshot data...', 'info');
        // Always fetch fresh Trustpilot snapshot data (it's a fixed snapshot, so should always work)
        try {
          const siteReviewsResponse = await fetch(apiUrl('/api/reviews/site-reviews'));
          if (siteReviewsResponse.ok) {
            const siteReviewsData = await siteReviewsResponse.json();
            if (siteReviewsData.status === 'ok' && siteReviewsData.data) {
              siteReviews = siteReviewsData.data;
              debugLog('✓ Trustpilot snapshot data fetched successfully', 'success');
              debugLog(`Trustpilot snapshot: rating=${siteReviews.siteRating}, count=${siteReviews.siteReviewCount}`, 'info');
            } else {
              debugLog('⚠ Trustpilot snapshot returned error, using saved data if available', 'warn');
              // Fallback to saved data only if API completely fails
              if (savedAudit?.siteReviews) {
                siteReviews = savedAudit.siteReviews;
                debugLog('⚠ Using saved Trustpilot data as fallback (will override with correct values)', 'warn');
              }
            }
          } else {
            debugLog('⚠ Trustpilot snapshot endpoint not available, using saved data if available', 'warn');
            // Fallback to saved data only if API completely fails
            if (savedAudit?.siteReviews) {
              siteReviews = savedAudit.siteReviews;
              debugLog('⚠ Using saved Trustpilot data as fallback (will override with correct values)', 'warn');
            }
          }
        } catch (siteReviewsError) {
          debugLog(`⚠ Trustpilot snapshot error: ${siteReviewsError.message}, using saved data if available`, 'warn');
          // Fallback to saved data only if API completely fails
          if (savedAudit?.siteReviews) {
            siteReviews = savedAudit.siteReviews;
            debugLog('⚠ Using saved Trustpilot data as fallback (will override with correct values)', 'warn');
          }
        }
        
        // ALWAYS force correct Trustpilot snapshot values (4.6, 610) - override ANY old values
        // This ensures we always use the correct snapshot regardless of API response or cached data
        const TRUSTPILOT_SNAPSHOT = {
          siteRating: 4.6,
          siteReviewCount: 610,
          lastUpdated: '2025-12-07',
          notes: 'Fixed Trustpilot snapshot for Authority score calculation. Update manually when Trustpilot metrics change significantly.'
        };
        
        if (!siteReviews || siteReviews.siteRating !== 4.6 || siteReviews.siteReviewCount !== 610) {
          if (siteReviews) {
            debugLog(`⚠ Overriding old Trustpilot values (${siteReviews.siteRating}, ${siteReviews.siteReviewCount}) with correct snapshot (4.6, 610)`, 'warn');
          } else {
            debugLog('⚠ Using default Trustpilot snapshot values (4.6, 610)', 'warn');
          }
          siteReviews = TRUSTPILOT_SNAPSHOT;
        } else {
          debugLog('✓ Trustpilot snapshot verified (4.6, 610)', 'success');
        }
        
        updateProgress(38, 'Fetching backlink metrics data...');
        debugLog('Fetching backlink metrics data...', 'info');
        // Fetch backlink metrics - try localStorage first (from CSV upload), then API
        let backlinkMetrics = null;
        
        // First, try to get from localStorage (stored when CSV was uploaded)
        try {
          const storedMetrics = localStorage.getItem('backlink_metrics');
          if (storedMetrics) {
            backlinkMetrics = JSON.parse(storedMetrics);
            debugLog('✓ Backlink metrics loaded from localStorage', 'success');
            debugLog(`Backlink metrics: domains=${backlinkMetrics.referringDomains}, links=${backlinkMetrics.totalBacklinks}, followRatio=${(backlinkMetrics.followRatio * 100).toFixed(1)}%`, 'info');
          }
        } catch (e) {
          debugLog(`⚠ Error reading backlink metrics from localStorage: ${e.message}`, 'warn');
        }
        
        // If not in localStorage, try API (for cases where metrics were uploaded via API directly)
        if (!backlinkMetrics) {
          try {
            const backlinkResponse = await fetch(apiUrl('/api/aigeo/backlink-metrics'));
            if (backlinkResponse.ok) {
              const backlinkData = await backlinkResponse.json();
              if (backlinkData.status === 'ok' && backlinkData.data && backlinkData.data.totalBacklinks > 0) {
                backlinkMetrics = backlinkData.data;
                // Store in localStorage for next time
                localStorage.setItem('backlink_metrics', JSON.stringify(backlinkMetrics));
                debugLog('✓ Backlink metrics data fetched from API and stored', 'success');
                debugLog(`Backlink metrics: domains=${backlinkMetrics.referringDomains}, links=${backlinkMetrics.totalBacklinks}, followRatio=${(backlinkMetrics.followRatio * 100).toFixed(1)}%`, 'info');
              } else {
                debugLog('⚠ Backlink metrics returned empty/zero, using saved data if available', 'warn');
              }
            } else {
              debugLog('⚠ Backlink metrics endpoint not available, using saved data if available', 'warn');
            }
          } catch (backlinkError) {
            debugLog(`⚠ Backlink metrics error: ${backlinkError.message}, using saved data if available`, 'warn');
          }
        }
        
        // If fetch failed but we have saved data, keep using it
        if (!backlinkMetrics && savedAudit?.backlinkMetrics) {
          backlinkMetrics = savedAudit.backlinkMetrics;
          debugLog('✓ Using saved backlink metrics data', 'info');
        }
        
        updateProgress(40, 'Fetching schema audit data...');
        debugLog('Fetching schema audit data...', 'info');
        // Fetch schema audit data
        try {
          // Check if manual URL list is available
          const manualUrlList = localStorage.getItem('manual_url_list');
          let schemaRequest;
          
          if (manualUrlList) {
            try {
              const urls = JSON.parse(manualUrlList);
              debugLog(`Using manual URL list: ${urls.length} URLs`, 'info');
              updateProgress(45, `Crawling ${urls.length} URLs for schema markup...`);
              schemaRequest = fetch(apiUrl('/api/schema-audit'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ urls })
              });
            } catch (e) {
              debugLog('⚠ Failed to parse manual URL list, using default CSV', 'warn');
              updateProgress(45, 'Loading URLs from CSV and crawling for schema markup...');
              schemaRequest = fetch(apiUrl('/api/schema-audit'));
            }
          } else {
            debugLog('No manual URL list, using default CSV source', 'info');
            updateProgress(45, 'Loading URLs from CSV and crawling for schema markup...');
            schemaRequest = fetch(apiUrl('/api/schema-audit'));
          }
          
          const schemaResponse = await schemaRequest;
          if (schemaResponse.ok) {
            schemaAudit = await schemaResponse.json();
            if (schemaAudit.status === 'ok') {
              debugLog('✓ Schema audit data fetched successfully', 'success');
              debugLog(`Schema coverage: ${schemaAudit.data.coverage}%`, 'info');
              if (manualUrlList) {
                debugLog('  Source: Manual URL list', 'info');
              } else {
                debugLog('  Source: CSV (GitHub/hosted)', 'info');
              }
              
              // Log comprehensive diagnostic info if available
              if (schemaAudit.meta && schemaAudit.meta.diagnostic) {
                const diag = schemaAudit.meta.diagnostic;
                debugLog('═══════════════════════════════════════════════════════', 'info');
                debugLog('📊 SCHEMA AUDIT DIAGNOSTICS', 'info');
                debugLog('═══════════════════════════════════════════════════════', 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                debugLog('📈 PAGE COUNTS:', 'info');
                debugLog(`  • Total pages scanned: ${diag.totalPages}`, 'info');
                debugLog(`  • Successful crawls: ${diag.successfulPages || diag.totalPages}`, 'info');
                debugLog(`  • Failed crawls: ${diag.failedPages || 0}`, diag.failedPages > 0 ? 'warn' : 'info');
                if (diag.failedPages > 0) {
                  debugLog(`    ⚠ Failed crawls are counted as pages without schema`, 'warn');
                  
                  // Show error breakdown if available
                  if (diag.errorTypes && Object.keys(diag.errorTypes).length > 0) {
                    debugLog('', 'info'); // Empty line
                    debugLog('  🔍 ERROR BREAKDOWN:', 'warn');
                    Object.entries(diag.errorTypes).forEach(([type, count]) => {
                      debugLog(`    • ${type}: ${count} pages`, 'warn');
                      if (diag.errorExamples && diag.errorExamples[type]) {
                        const example = diag.errorExamples[type];
                        debugLog(`      Example: ${example.url}`, 'info');
                        debugLog(`      Error: ${example.error}`, 'info');
                      }
                    });
                  }
                }
                debugLog(`  • Pages with inline schema: ${diag.pagesWithInlineSchema}`, 'info');
                debugLog(`  • Pages without inline schema: ${diag.pagesWithoutInlineSchema}`, 'info');
                if (diag.failedPages > 0) {
                  debugLog(`    (includes ${diag.failedPages} failed crawls)`, 'info');
                }
                debugLog(`  • Pages with inherited schema: ${diag.pagesWithInheritedSchema}`, 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                if (diag.urlsWithoutSchemas && diag.urlsWithoutSchemas.length > 0) {
                  debugLog('🔗 URLs WITHOUT SCHEMAS:', 'info');
                  diag.urlsWithoutSchemas.forEach(url => {
                    debugLog(`  • ${url}`, 'info');
                  });
                  if (diag.pagesWithoutInlineSchema > diag.urlsWithoutSchemas.length) {
                    debugLog(`  ... and ${diag.pagesWithoutInlineSchema - diag.urlsWithoutSchemas.length} more`, 'info');
                  }
                  debugLog('', 'info'); // Empty line for spacing
                }
                
                debugLog('🔍 MISSING SCHEMA BREAKDOWN:', 'info');
                debugLog(`  • Pages with parent but no inherited: ${diag.pagesWithParentButNoInherited}`, 'info');
                debugLog(`  • Pages with parent but not checked: ${diag.pagesWithParentButNotChecked}`, diag.pagesWithParentButNotChecked > 0 ? 'warn' : 'info');
                debugLog(`  • Pages without parent page: ${diag.pagesWithoutParent}`, 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                debugLog('✅ VALIDATION:', 'info');
                debugLog(`  • Total missing pages (calculated): ${diag.totalMissing}`, 'info');
                debugLog(`  • Expected missing (total - inline - inherited): ${diag.expectedMissing}`, 'info');
                
                if (diag.mismatch) {
                  debugLog('', 'info'); // Empty line for spacing
                  debugLog(`  ❌ MISMATCH DETECTED!`, 'error');
                  debugLog(`  ${diag.mismatchDetails}`, 'error');
                  debugLog(`  This indicates pages are being double-counted or missed in the calculation.`, 'error');
                } else {
                  debugLog(`  ✓ Counts match correctly`, 'success');
                }
                
                debugLog('', 'info'); // Empty line for spacing
                debugLog('═══════════════════════════════════════════════════════', 'info');
              }
            } else {
              debugLog(`⚠ Schema audit returned error status: ${schemaAudit.status}`, 'warn');
              if (schemaAudit.message) {
                debugLog(`  Error message: ${schemaAudit.message}`, 'warn');
              }
            }
          } else {
            const errorText = await schemaResponse.text();
            debugLog(`⚠ Schema audit endpoint returned ${schemaResponse.status}: ${schemaResponse.statusText}`, 'warn');
            if (errorText) {
              debugLog(`  Response: ${errorText.substring(0, 200)}`, 'warn');
            }
            // schemaAudit already initialized with saved data at start, so it's preserved
            if (schemaAudit) {
              debugLog('✓ Using saved schema audit data from previous audit', 'success');
              debugLog(`Schema coverage: ${schemaAudit.data?.coverage || 'N/A'}%`, 'info');
            } else {
              debugLog('⚠ No saved schema audit data available', 'warn');
            }
          }
        } catch (schemaError) {
          debugLog(`⚠ Schema audit error: ${schemaError.message}, using saved data`, 'warn');
          // schemaAudit already initialized with saved data at start, so it's preserved
          if (schemaAudit) {
            debugLog('✓ Using saved schema audit data from previous audit (fallback)', 'success');
            debugLog(`Schema coverage: ${schemaAudit.data?.coverage || 'N/A'}%`, 'info');
          } else {
            debugLog('⚠ No saved schema audit data available', 'warn');
          }
        }
        
        updateProgress(70, 'Calculating pillar scores...');
        debugLog('Calculating pillar scores...', 'info');
        // Calculate scores (pass schema audit data, local signals, site reviews, and backlink metrics)
        const scores = await calculatePillarScores(searchData, schemaAudit, localSignals, siteReviews, backlinkMetrics);
        debugLog('✓ Pillar scores calculated', 'success');
        debugLog(`Scores: ${JSON.stringify(scores)}`, 'info');

        updateProgress(85, 'Calculating snippet readiness...');
        debugLog('Calculating snippet readiness...', 'info');
        const snippetReadiness = calculateSnippetReadiness(scores, searchData);
        debugLog(`Snippet readiness: ${snippetReadiness}`, 'info');

        updateProgress(95, 'Generating dashboard...');
        debugLog('Displaying dashboard...', 'info');
        // Display results (pass current audit data including localSignals)
        displayDashboard(scores, searchData, snippetReadiness, schemaAudit, localSignals);
        
        updateProgress(100, 'Audit completed successfully!');
        debugLog('=== AUDIT COMPLETE: Success ===', 'success');
        
        // Save audit results to localStorage
        saveAuditResults(scores, searchData, snippetReadiness, schemaAudit, localSignals, siteReviews, backlinkMetrics);
        
        // Save audit results to Supabase for historical tracking
        // Note: saveAuditToSupabase is async, so we can await it or use .then()
        (async () => {
          try {
            await saveAuditToSupabase(propertyUrl, scores, searchData, snippetReadiness, schemaAudit, localSignals, new Date().toISOString().split('T')[0]);
            // After saving to Supabase, refresh the trend chart to show the latest audit
            debugLog('Refreshing Score Trends chart after saving audit...', 'info');
            // Re-render the dashboard to update the trend chart with new data
            setTimeout(async () => {
              const saved = loadAuditResultsSync();
              if (saved && saved.scores && saved.searchData) {
                try {
                  await displayDashboard(saved.scores, saved.searchData, saved.snippetReadiness || 0, saved.schemaAudit || null, saved.localSignals || null);
                  debugLog('✓ Score Trends chart refreshed after saving audit', 'success');
                } catch (err) {
                  debugLog(`⚠ Error refreshing trend chart: ${err.message}`, 'warn');
                }
              }
            }, 1000); // Delay to ensure Supabase save is complete
          } catch (err) {
            debugLog(`⚠ Error saving to Supabase (chart refresh skipped): ${err.message}`, 'warn');
          }
        })();
        
        showStatus('Audit completed successfully!', 'success');
      } catch (error) {
        debugLog(`✗ AUDIT ERROR: ${error.message}`, 'error');
        debugLog(`Stack trace: ${error.stack}`, 'error');
        showStatus('Error running audit: ' + error.message, 'error');
        console.error(error);
      } finally {
        debugLog('Hiding loading indicator...', 'info');
        document.getElementById('loading').classList.remove('show');
        
        // Show completion summary modal
        debugLog(`Schema audit available for modal: ${schemaAudit ? 'yes' : 'no'}`, 'info');
        if (schemaAudit) {
          debugLog('Showing completion modal...', 'info');
          setTimeout(() => {
            showCompletionModal(schemaAudit);
          }, 500);
        } else {
          debugLog('⚠ No schema audit data available for modal', 'warn');
        }
        
        // Reset progress bar for next run
        setTimeout(() => {
          updateProgress(0, 'Initializing audit scan...');
        }, 500);
      }
    }

    // Fetch and parse site-urls.csv from GitHub
    async function fetchAndParseSiteUrlsCsv() {
      const GITHUB_CSV_URL = "https://raw.githubusercontent.com/alanranger/alan-shared-resources/main/csv/06-site-urls.csv";
      const FALLBACK_CSV_URL = "https://schema-tools-six.vercel.app/06-site-urls.csv";
      
      try {
        // Try GitHub first
        const res = await fetch(GITHUB_CSV_URL);
        if (!res.ok) throw new Error(`GitHub fetch failed: HTTP ${res.status}`);
        const csvText = await res.text();
        
        // Parse CSV - extract URLs from url column
        const lines = csvText.split('\n').filter(line => line.trim());
        const urls = [];
        
        // Parse header row to find URL column index
        let urlColumnIndex = 0;
        if (lines.length > 0) {
          const headerLine = lines[0].trim();
          const headers = parseCsvLine(headerLine);
          const urlHeaderIndex = headers.findIndex(h => h.toLowerCase() === 'url');
          if (urlHeaderIndex !== -1) {
            urlColumnIndex = urlHeaderIndex;
          }
        }
        
        // Helper function to parse CSV line with proper quote handling
        function parseCsvLine(line) {
          const columns = [];
          let current = '';
          let inQuotes = false;
          
          for (let i = 0; i < line.length; i++) {
            const char = line[i];
            const nextChar = line[i + 1];
            
            if (char === '"') {
              if (inQuotes && nextChar === '"') {
                current += '"';
                i++;
              } else {
                inQuotes = !inQuotes;
              }
            } else if (char === ',' && !inQuotes) {
              columns.push(current.trim());
              current = '';
            } else {
              current += char;
            }
          }
          columns.push(current.trim());
          return columns;
        }
        
        // Parse data rows (skip header)
        for (let i = 1; i < lines.length; i++) {
          const columns = parseCsvLine(lines[i]);
          if (columns[urlColumnIndex]) {
            const url = columns[urlColumnIndex].trim();
            if (url) {
              // Accept URLs starting with http/https, or relative URLs starting with /
              // Also accept full URLs without protocol (will be normalized)
              if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('/')) {
                urls.push(url);
              } else if (url.includes('.') && !url.includes(' ')) {
                // Likely a URL without protocol - add https://
                urls.push(url.startsWith('//') ? `https:${url}` : `https://${url}`);
              }
            }
          }
        }
        
        return urls;
      } catch (githubErr) {
        // Try fallback
        try {
          const fallbackRes = await fetch(FALLBACK_CSV_URL);
          if (!fallbackRes.ok) throw new Error(`Fallback fetch failed: HTTP ${fallbackRes.status}`);
          const csvText = await fallbackRes.text();
          
          // Same parsing logic as above
          const lines = csvText.split('\n').filter(line => line.trim());
          const urls = [];
          let urlColumnIndex = 0;
          
          if (lines.length > 0) {
            const headerLine = lines[0].trim();
            const headers = parseCsvLine(headerLine);
            const urlHeaderIndex = headers.findIndex(h => h.toLowerCase() === 'url');
            if (urlHeaderIndex !== -1) {
              urlColumnIndex = urlHeaderIndex;
            }
          }
          
          function parseCsvLine(line) {
            const columns = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
              const char = line[i];
              const nextChar = line[i + 1];
              if (char === '"') {
                if (inQuotes && nextChar === '"') {
                  current += '"';
                  i++;
                } else {
                  inQuotes = !inQuotes;
                }
              } else if (char === ',' && !inQuotes) {
                columns.push(current.trim());
                current = '';
              } else {
                current += char;
              }
            }
            columns.push(current.trim());
            return columns;
          }
          
          for (let i = 1; i < lines.length; i++) {
            const columns = parseCsvLine(lines[i]);
            if (columns[urlColumnIndex]) {
              const url = columns[urlColumnIndex].trim();
              if (url) {
                // Accept URLs starting with http/https, or relative URLs starting with /
                // Also accept full URLs without protocol (will be normalized)
                if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('/')) {
                  urls.push(url);
                } else if (url.includes('.') && !url.includes(' ')) {
                  // Likely a URL without protocol - add https://
                  urls.push(url.startsWith('//') ? `https:${url}` : `https://${url}`);
                }
              }
            }
          }
          
          return urls;
        } catch (fallbackErr) {
          throw new Error(`Unable to load site URLs CSV: ${githubErr.message}`);
        }
      }
    }
    
    // Display dashboard
    async function displayDashboard(scores, data, snippetReadiness = 0, schemaAudit = null, localSignals = null) {
      // Normalize localSignals structure if needed (handle old format where it might just be {data: {...}})
      if (localSignals && localSignals.data && !localSignals.status) {
        debugLog(`[displayDashboard] Normalizing localSignals structure - wrapping in status/data format`, 'info');
        localSignals = { status: 'ok', data: localSignals.data || localSignals };
      }
      // Update timestamp if this is a fresh display
      const saved = await loadAuditResults();
      if (saved && saved.timestamp) {
        updateAuditTimestamp(saved.timestamp);
      }
      
      // Restore active tab from sessionStorage or URL hash
      const activeTab = sessionStorage.getItem('aigeo_active_tab') || 
                       (window.location.hash && window.location.hash.replace('#', '')) || 
                       null;
      if (activeTab === 'ranking') {
        // Activate Ranking & AI tab
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav button')).find(btn => 
          btn.textContent.includes('Ranking') || btn.getAttribute('data-tab') === 'ranking'
        );
        if (rankingTab && rankingNavBtn) {
          // Deactivate all tabs
          document.querySelectorAll('.aigeo-panel').forEach(panel => panel.classList.remove('is-active'));
          document.querySelectorAll('.aigeo-nav button').forEach(btn => btn.classList.remove('is-active'));
          // Activate Ranking & AI
          rankingTab.classList.add('is-active');
          rankingNavBtn.classList.add('is-active');
          // Clear the stored tab so it doesn't persist on next load
          sessionStorage.removeItem('aigeo_active_tab');
        }
      }
      
      // CRITICAL: Ensure Money Pages data is in scores object
      // If scores.moneyPagesMetrics is missing, get it from saved data
      // Check explicitly for null/undefined/false (not just falsy)
      debugLog(`DEBUG: Checking moneyPagesMetrics - scores.moneyPagesMetrics=${scores?.moneyPagesMetrics}, type=${typeof scores?.moneyPagesMetrics}, saved.scores.moneyPagesMetrics=${saved?.scor