<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>GAIO (Generative AI Optimization) Audit Dashboard - Automated GAIO Performance Tracking</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script>
    // Try to load config.js if it exists (for local development)
    // Note: config.js is gitignored and won't be deployed to Vercel
    // Silently fail if config.js doesn't exist (expected on Vercel)
    try {
      // First check if file exists via fetch to avoid syntax errors
      fetch('config.js')
        .then(response => {
          if (response.ok && response.headers.get('content-type')?.includes('javascript')) {
      const configScript = document.createElement('script');
      configScript.src = 'config.js';
            configScript.type = 'text/javascript';
      configScript.onerror = function() {
              // Silently ignore
      };
      document.head.appendChild(configScript);
          }
        })
        .catch(() => {
          // Silently ignore - config.js is optional
        });
    } catch (e) {
      // Silently ignore - config.js is optional
    }
  </script>
  <style>
    :root {
      --brand-orange: #E57200;
      --brand-dark: #222222;
      --brand-grey: #555555;
      --bg-page: #f2f2f2;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      
      /* Dark theme variables (from admin.html) */
      --dark-bg: #0f1419;
      --dark-panel: #1a1f2e;
      --dark-text: #e2e8f0;
      --dark-text-muted: #9ca3af;
      --dark-brand: #f59e0b;
      --dark-border: #374151;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg-page);
      color: var(--brand-dark);
      line-height: 1.5;
    }
    .header {
      background: linear-gradient(135deg, var(--brand-orange) 0%, #ff8c42 100%);
      color: white;
      padding: 2rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .header h1 {
      margin: 0 0 0.5rem 0;
      font-size: 2rem;
    }
    .header p {
      margin: 0;
      opacity: 0.9;
    }
    .container {
      max-width: 1800px;
      margin: 0 auto;
      padding: 2rem;
      padding-bottom: 60px; /* Space for debug panel */
    }
    .config-panel {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      margin-bottom: 2rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .config-panel h2 {
      margin: 0 0 1rem 0;
      color: var(--brand-dark);
      font-size: 1.25rem;
    }
    .form-group {
      margin-bottom: 1rem;
    }
    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      color: var(--brand-grey);
    }
    .form-group input {
      width: 100%;
      padding: 0.75rem;
      border: 2px solid #e2e8f0;
      border-radius: 6px;
      font-size: 1rem;
    }
    .form-group input:focus {
      outline: none;
      border-color: var(--brand-orange);
    }
    .btn {
      background: var(--brand-orange);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    .btn:hover {
      background: #d46200;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    .btn-secondary {
      background: var(--brand-grey);
    }
    .btn-secondary:hover {
      background: #444;
    }
    .status {
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      display: none;
    }
    .status.success {
      background: #d1fae5;
      color: #065f46;
      border-left: 4px solid var(--success);
    }
    .status.error {
      background: #fee2e2;
      color: #991b1b;
      border-left: 4px solid var(--danger);
    }
    .status.info {
      background: #dbeafe;
      color: #1e40af;
      border-left: 4px solid #3b82f6;
    }
    .status.show {
      display: block;
    }
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    .pillar-card {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: relative;
      display: flex;
      flex-direction: column;
      min-height: 100%; /* Ensure all cards have same minimum height */
    }
    .pillar-card h3 {
      margin: 0 0 0.75rem 0;
      color: var(--brand-dark);
      font-size: 1.1rem;
    }
    .pillar-score {
      font-size: 3rem;
      font-weight: 700;
      margin: 0.5rem 0;
      line-height: 1;
    }
    .pillar-score.rag-red {
      color: var(--danger);
    }
    .pillar-score.rag-amber {
      color: var(--warning);
    }
    .pillar-score.rag-green {
      color: var(--success);
    }
    .rag-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.875rem;
      font-weight: 600;
      margin-top: 0.75rem;
      margin-bottom: 0.5rem;
    }
    .rag-badge.red {
      background: #fee2e2;
      color: #991b1b;
    }
    .rag-badge.amber {
      background: #fef3c7;
      color: #92400e;
    }
    .rag-badge.green {
      background: #d1fae5;
      color: #065f46;
    }
    .chart-container {
      background: linear-gradient(135deg, #f0f4f8 0%, #e2e8f0 100%);
      padding: 1.5rem;
      padding-bottom: 12rem; /* Extra padding at bottom for rotated 45-degree axis labels - need significant space for diagonal labels */
      padding-right: 3rem; /* Extra padding on right for Y-axis labels */
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 6rem; /* extra breathing room below charts */
      height: 1000px; /* Doubled from 500px to 1000px for better chart visibility and less bunching */
      min-height: 1000px; /* Ensure minimum height */
      border: 1px solid rgba(100, 116, 139, 0.2);
      overflow: hidden; /* Change to hidden to clip content that extends beyond container */
    }
    .chart-container.large {
      height: 1200px;
      min-height: 1200px;
      padding: 2rem;
    }
    .dashboard-two-column {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-three-column {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-four-column {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    @media (max-width: 1200px) {
      .dashboard-four-column {
        grid-template-columns: repeat(2, 1fr);
      }
      .dashboard-three-column {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    @media (max-width: 768px) {
      .dashboard-two-column,
      .dashboard-three-column,
      .dashboard-four-column {
        grid-template-columns: 1fr;
      }
    }
    .chart-container h3 {
      margin: 0 0 0.5rem 0;
      color: var(--brand-dark);
    }
    .chart-container p {
      margin: 0 0 1rem 0;
    }
    .trend-summary-row {
      display: flex;
      gap: 1.5rem;
      font-size: 0.9rem;
      margin-bottom: 0.75rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .trend-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.7);
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.06);
      border: 1px solid rgba(148, 163, 184, 0.3);
    }
    .trend-pill span.label {
      font-weight: 600;
      color: #374151;
    }
    .trend-pill span.value.up {
      font-weight: 700;
      color: #10b981; /* green */
    }
    .trend-pill span.value.down {
      font-weight: 700;
      color: #ef4444; /* red */
    }
    .trend-pill span.value.neutral {
      font-weight: 700;
      color: #1f2937; /* black/dark gray for no change */
    }
    .metrics-section {
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border: 1px solid rgba(59, 130, 246, 0.1);
    }
    .scorecard-section {
      margin-top: 4rem;  /* push scorecard further below charts */
      margin-bottom: 3rem;
    }
    
    /* Override for scorecard sections inside ranking-ai-detail-content */
    .ranking-ai-detail-content .scorecard-section {
      margin-top: 0;
      margin-bottom: 1.0rem !important;
    }
    
    .ranking-ai-detail-content .scorecard-section:last-child {
      margin-bottom: 0 !important;
    }
    .scorecard-section h3 {
      margin-bottom: 1.5rem;
    }
    .metrics-section {
      margin-top: 3rem;
      margin-bottom: 3rem;
    }
    .metrics-section h3 {
      margin-bottom: 1.5rem;
    }
    .section-break {
      margin-top: 4rem;
      margin-bottom: 4rem;
      border-top: 2px solid #e2e8f0;
      padding-top: 2rem;
    }
    .calculation-explanation {
      background: #f8f9fa;
      border: 2px solid var(--brand-orange);
      border-radius: 8px;
      margin-bottom: 2rem;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(229, 114, 0, 0.15);
    }
    .calculation-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: linear-gradient(135deg, #fff5f0 0%, #ffe8d6 100%);
      border-bottom: 2px solid var(--brand-orange);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    .calculation-explanation.collapsed .calculation-header {
      border-bottom: none;
    }
    .calculation-header:hover {
      background: linear-gradient(135deg, #ffe8d6 0%, #ffd9b3 100%);
    }
    .calculation-header h4 {
      margin: 0;
      color: var(--brand-orange);
      font-size: 1.1rem;
      font-weight: 600;
    }
    .calculation-toggle {
      font-size: 1.2rem;
      color: var(--brand-orange);
      font-weight: bold;
      transition: transform 0.3s;
    }
    .calculation-explanation.collapsed .calculation-toggle {
      transform: rotate(-90deg);
    }
    .calculation-content {
      padding: 1.5rem;
      color: #555;
      line-height: 1.8;
    }
    .calculation-content.collapsed {
      display: none;
    }
    .csv-upload-section {
      background: #f8f9fa;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      margin-bottom: 1rem;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .csv-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: #f8f9fa;
      border-bottom: 2px solid #e2e8f0;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    .csv-upload-section.collapsed .csv-section-header {
      border-bottom: none;
    }
    .csv-section-header:hover {
      background: #f0f0f0;
    }
    .csv-section-header h3 {
      margin: 0;
      color: #1e293b;
      font-size: 1rem;
      font-weight: 600;
    }
    .csv-section-toggle {
      font-size: 1rem;
      color: #64748b;
      font-weight: bold;
      transition: transform 0.3s;
    }
    .csv-upload-section.collapsed .csv-section-toggle {
      transform: rotate(-90deg);
    }
    .csv-section-content {
      padding: 1rem;
    }
    .csv-section-content.collapsed {
      display: none;
    }
    .calculation-content h5 {
      color: var(--brand-dark);
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-size: 1rem;
      font-weight: 600;
      border-bottom: 2px solid var(--brand-orange);
      padding-bottom: 0.5rem;
    }
    .calculation-content h5:first-child {
      margin-top: 0;
    }
    .calculation-content ul {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
    }
    .calculation-content li {
      margin: 0.5rem 0;
    }
    .calculation-content code {
      background: #e2e8f0;
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #c53030;
    }
    .calculation-content .formula {
      background: #f0f4f8;
      padding: 0.75rem;
      border-left: 3px solid var(--brand-orange);
      margin: 0.75rem 0;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
    }
    .calculation-content .note {
      background: #fff3cd;
      border-left: 3px solid #f59e0b;
      padding: 0.75rem;
      margin: 1rem 0;
      font-size: 0.9rem;
    }
    .date-range-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .date-range-btn {
      padding: 0.5rem 1rem;
      border: 2px solid #e2e8f0;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    .date-range-btn:hover {
      border-color: var(--brand-orange);
      background: #fff5f0;
    }
    .date-range-btn.active {
      background: var(--brand-orange);
      color: white;
      border-color: var(--brand-orange);
    }
    .snippet-readiness-gauge {
      background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 3rem;
      border: 1px solid rgba(16, 185, 129, 0.1);
    }
    .gauge-container {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      flex: 1;
      position: relative;
    }
    .gauge-wrapper {
      position: relative;
      width: 300px;
      height: 300px;
    }
    .gauge-svg {
      transform: rotate(-90deg);
      width: 100%;
      height: 100%;
    }
    .gauge-background {
      fill: none;
      stroke: #e2e8f0;
      stroke-width: 20;
    }
    .gauge-fill {
      fill: none;
      stroke-width: 20;
      stroke-linecap: round;
      transition: stroke-dashoffset 1s ease-in-out;
    }
    .gauge-fill.green {
      stroke: #10b981;
    }
    .gauge-fill.amber {
      stroke: #f59e0b;
    }
    .gauge-fill.red {
      stroke: #ef4444;
    }
    .gauge-value {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      font-weight: 700;
      text-align: center;
      z-index: 10;
    }
    .gauge-value.green {
      color: #10b981;
    }
    .gauge-value.amber {
      color: #f59e0b;
    }
    .gauge-value.red {
      color: #ef4444;
    }
    .gauge-label {
      text-align: center;
      color: var(--brand-grey);
      margin-top: 1rem;
      font-size: 1rem;
      font-weight: 600;
    }
    .gauge-status {
      text-align: center;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      font-weight: 500;
    }
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }
    .metric-card {
      background: white;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
    }
    .metric-card .value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--brand-orange);
      margin: 0.5rem 0;
    }
    .metric-card .label {
      color: var(--brand-grey);
      font-size: 0.875rem;
    }
    .metric-label {
      color: var(--brand-grey);
      font-size: 0.875rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    .metric-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--brand-orange);
      margin: 0.5rem 0;
    }
    .metric-sub {
      color: var(--brand-grey);
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }
    .url-cell {
      max-width: 300px;
    }
    .url-main {
      font-weight: 600;
      color: #333;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .url-sub {
      font-size: 0.75rem;
      color: #666;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-top: 0.25rem;
    }
    .money-recommendation {
      font-size: 0.875rem;
      line-height: 1.5;
      color: #555;
      max-width: 400px;
    }
    .loading {
      display: none;
      text-align: center;
      padding: 2rem;
    }
    .loading.show {
      display: block;
    }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--brand-orange);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .progress-container {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1rem 0;
    }
    .progress-bar-wrapper {
      width: 100%;
      background: #e2e8f0;
      border-radius: 10px;
      height: 24px;
      overflow: hidden;
      margin: 1rem 0;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--brand-orange), #ff8c42);
      border-radius: 10px;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 0.85rem;
      min-width: 0;
    }
    .progress-status {
      font-size: 0.95rem;
      color: #555;
      margin-top: 0.5rem;
      font-weight: 500;
    }
    /* Full-page overlay for domain strength snapshot */
    .domain-strength-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      z-index: 9999;
      display: none;
      align-items: center;
      justify-content: center;
    }
    .domain-strength-overlay.show {
      display: flex;
    }
    .domain-strength-overlay-content {
      background: white;
      border-radius: 12px;
      padding: 2.5rem 3rem;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      text-align: center;
      max-width: 400px;
    }
    .domain-strength-overlay-content .spinner {
      width: 48px;
      height: 48px;
      border-width: 5px;
      margin: 0 auto 1.5rem;
    }
    .domain-strength-overlay-content h3 {
      margin: 0 0 0.75rem 0;
      font-size: 1.25rem;
      font-weight: 700;
      color: #1e293b;
    }
    .domain-strength-overlay-content p {
      margin: 0;
      font-size: 0.95rem;
      color: #64748b;
      line-height: 1.6;
    }
    /* Sticky positioning for domain strength table */
    #domain-strength-table thead {
      position: sticky;
      top: 0;
      z-index: 10;
      background: #f8fafc;
    }
    #domain-strength-table thead th {
      background: #f8fafc;
    }
    #domain-strength-self-row {
      position: sticky;
      top: 40px; /* Adjust based on header height */
      z-index: 9;
      background: #fefce8 !important;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      overflow: auto;
    }
    .modal-content {
      background-color: white;
      margin: 5% auto;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      animation: modalSlideIn 0.3s ease;
    }
    @keyframes modalSlideIn {
      from {
        transform: translateY(-50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    .ranking-ai-step-item {
      display: flex;
      align-items: center;
      padding: 0.75rem;
      border-radius: 6px;
      background-color: #f9fafb;
      transition: all 0.2s ease;
    }
    .ranking-ai-step-item.active {
      background-color: #fef3c7;
      border-left: 4px solid var(--brand-orange);
    }
    .ranking-ai-step-item.completed {
      background-color: #d1fae5;
      border-left: 4px solid #10b981;
    }
    .ranking-ai-step-item.pending {
      opacity: 0.5;
    }
    .ranking-ai-step-icon {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 0.75rem;
      font-weight: bold;
      font-size: 0.85rem;
    }
    .ranking-ai-step-item.pending .ranking-ai-step-icon {
      background-color: #e5e7eb;
      color: #9ca3af;
    }
    .ranking-ai-step-item.active .ranking-ai-step-icon {
      background-color: var(--brand-orange);
      color: white;
      animation: pulse 1.5s ease-in-out infinite;
    }
    .ranking-ai-step-item.completed .ranking-ai-step-icon {
      background-color: #10b981;
      color: white;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    .ranking-ai-step-label {
      flex: 1;
      font-size: 0.9rem;
      color: #374151;
    }
    .ranking-ai-step-item.completed .ranking-ai-step-label {
      color: #059669;
    }
    .ranking-ai-step-item.active .ranking-ai-step-label {
      color: #92400e;
      font-weight: 600;
    }
    .help-text {
      font-size: 0.875rem;
      color: var(--brand-grey);
      margin-top: 0.25rem;
    }

    .debug-panel-bottom {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1a1a1a;
      border-top: 3px solid #E57200;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      z-index: 1000;
      box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.5);
      max-height: 50vh;
      display: flex;
      flex-direction: column;
    }

    .debug-panel-bottom.collapsed {
      max-height: 50px;
    }

    .debug-panel-bottom.collapsed .debug-content {
      display: none !important;
    }

    .debug-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #333;
      background: #252525;
      user-select: none;
    }

    .debug-header h3 {
      margin: 0;
      color: #fff;
      font-size: 1rem;
    }

    .debug-actions {
      display: flex;
      gap: 0.5rem;
    }

    .btn-small {
      padding: 0.25rem 0.75rem;
      font-size: 0.75rem;
      background: #333;
      color: #fff;
      border: 1px solid #555;
    }

    .btn-small:hover {
      background: #444;
    }

    .debug-content {
      color: #fff;
      line-height: 1.6;
      padding: 1rem;
      overflow-y: auto;
      flex: 1;
      max-height: calc(50vh - 60px);
    }

    .debug-log-entry {
      margin-bottom: 0.25rem;
      padding: 0.25rem 0;
      border-left: 2px solid transparent;
      padding-left: 0.5rem;
    }

    .debug-log-entry.error {
      color: #f44;
      border-left-color: #f44;
    }

    .debug-log-entry.warn {
      color: #fa4;
      border-left-color: #fa4;
    }

    .debug-log-entry.info {
      color: #9cf;
      border-left-color: #4af;
    }

    .debug-log-entry.success {
      color: #9f9;
      border-left-color: #4f4;
    }

    .debug-timestamp {
      color: #aaa;
      margin-right: 0.5rem;
    }

    /* Sidebar Layout */
    .aigeo-layout {
      display: flex;
      min-height: calc(100vh - 120px); /* Account for header */
    }

    .aigeo-sidebar {
      width: 260px;
      background: linear-gradient(180deg, #ffffff 0%, #f8f9fa 100%);
      border-right: 2px solid #e2e8f0;
      padding: 1.5rem 0;
      position: sticky;
      top: 0;
      height: calc(100vh - 120px);
      overflow-y: auto;
      flex-shrink: 0;
      box-shadow: 2px 0 8px rgba(0,0,0,0.05);
    }

    .aigeo-nav-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      width: 100%;
      padding: 0.875rem 1.5rem;
      background: none;
      border: none;
      text-align: left;
      font-size: 0.95rem;
      font-weight: 500;
      color: #64748b;
      cursor: pointer;
      transition: all 0.2s ease;
      border-left: 4px solid transparent;
      position: relative;
    }

    .aigeo-nav-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0;
      background: var(--brand-orange);
      transition: width 0.2s ease;
    }

    .aigeo-nav-item:hover {
      background: linear-gradient(90deg, #fff5f0 0%, #ffffff 100%);
      color: var(--brand-dark);
      padding-left: 1.75rem;
    }

    .aigeo-nav-item.is-active {
      background: linear-gradient(90deg, #fff5f0 0%, #ffffff 100%);
      color: var(--brand-orange);
      border-left-color: var(--brand-orange);
      font-weight: 600;
      box-shadow: inset 0 0 0 1px rgba(229, 114, 0, 0.1);
    }

    .aigeo-nav-item.is-active::before {
      width: 4px;
    }

    .aigeo-nav-icon {
      font-size: 1.25rem;
      width: 24px;
      text-align: center;
      flex-shrink: 0;
    }

    .aigeo-main {
      flex: 1;
      overflow-y: auto;
      padding: 2rem;
      padding-bottom: 60px; /* Space for debug panel */
    }

    .aigeo-panel {
      display: none;
    }

    .aigeo-panel.is-active {
      display: block;
    }

    /* Ensure ranking panel uses block layout when active, not flex */
    .aigeo-panel[data-panel="ranking"].is-active {
      display: block !important;
    }

    /* Ensure ranking panel children stack vertically, but allow metric pills, side-by-side cards, and details grid to use their layouts */
    .aigeo-panel[data-panel="ranking"] > .ranking-metric-pills {
      display: grid !important;
    }

    .aigeo-panel[data-panel="ranking"] > .ranking-details-grid {
      display: grid !important;
    }

    .aigeo-panel[data-panel="ranking"] > .ranking-cards-side-by-side {
      display: flex !important;
    }

    .aigeo-panel[data-panel="ranking"] > *:not(.ranking-metric-pills):not(.ranking-cards-side-by-side):not(.ranking-priority-matrix-section):not(.ranking-table-section):not(.ranking-details-grid) {
      width: 100% !important;
      display: block !important;
      clear: both !important;
      float: none !important;
    }

    /* Ranking & AI Tab Styles */
    .ranking-pillars-note {
      font-size: 0.9rem;
      color: #64748b;
      margin: 0.75rem 0;
      line-height: 1.6;
    }

    .ranking-intro {
      margin-top: 0.25rem;
      font-size: 1rem;
      color: #4b5563;
      max-width: 56rem;
    }

    .ranking-intro-bullets {
      margin: 0.25rem 0 0.5rem;
      padding-left: 1.25rem;
      font-size: 0.95rem;
      color: #6b7280;
    }

    .ranking-intro-bullets li {
      margin-bottom: 0.1rem;
    }

    .ranking-header-actions {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-top: 0.4rem;
    }

    /* Section B: Metric pills - all 5 on one row */
    .ranking-metric-pills {
      display: grid !important;
      grid-template-columns: repeat(5, 1fr) !important;
      gap: 1rem;
      margin-top: 1rem;
      margin-bottom: 1.5rem;
      width: 100%;
      grid-auto-flow: row;
    }

    .ranking-metric-pills > .metric-pill {
      display: block;
      width: 100%;
      min-width: 0;
    }

    /* For medium screens, reduce gap but keep all 5 in one row */
    @media (min-width: 769px) and (max-width: 1400px) {
      .ranking-metric-pills {
        grid-template-columns: repeat(5, 1fr);
        gap: 0.75rem;
      }
    }

    /* Only wrap on very small screens */
    @media (max-width: 768px) {
      .ranking-metric-pills {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    .metric-pill {
      background: #ffffff;
      border-radius: 8px;
      padding: 1rem 1.25rem;
      box-shadow: 0 1px 3px rgba(15, 23, 42, 0.06);
      transition: all 0.2s ease;
      border-left: 4px solid transparent;
    }
    
    .metric-pill--active {
      background: #1e40af !important;
      color: #ffffff !important;
      box-shadow: 0 2px 6px rgba(30, 64, 175, 0.3);
      border-left-color: #1e3a8a;
      font-weight: 600;
    }
    
    .metric-pill--active span,
    .metric-pill--active .optimisation-tab-count {
      color: #ffffff !important;
    }
    
    .metric-pill--active:hover {
      background: #1e3a8a !important;
    }

    .metric-pill--green {
      background: #f0fdf4;
      border-left-color: #16a34a;
    }

    .metric-pill--amber {
      background: #fffbeb;
      border-left-color: #f59e0b;
    }

    .metric-pill--red {
      background: #fef2f2;
      border-left-color: #dc2626;
    }

    .metric-pill--neutral {
      background: #f9fafb;
      border-left-color: #6b7280;
    }

    .metric-pill-value {
      font-size: 2rem;
      font-weight: 700;
      margin: 0.25rem 0;
      color: #1e293b;
    }

    .metric-pill-label {
      font-size: 1rem;
      font-weight: 600;
      color: #374151;
      margin-bottom: 0.25rem;
    }

    .metric-pill-status {
      font-size: 0.85rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.7rem;
      border-radius: 999px;
      margin: 0.25rem 0;
    }

    /* ============================================
       OPTIMISATION MODULE - DARK THEME
       ============================================ */
    
    /* Dark background for entire optimisation section - fill full width of main content area */
    section[data-panel="optimisation"] {
      background: var(--dark-bg) !important;
      min-height: calc(100vh - 4rem);
      position: relative;
      color: var(--dark-text) !important;
      width: calc(100vw - 260px); /* Full viewport width minus sidebar */
      margin-left: calc(-50vw + 50% + 130px); /* Position to start after sidebar */
      margin-right: calc(-50vw + 50% - 130px);
      padding: 2rem;
      box-sizing: border-box;
    }
    
    section[data-panel="optimisation"] * {
      color: inherit;
    }
    
    /* Section header */
    section[data-panel="optimisation"] .card--section-header {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
    }
    
    section[data-panel="optimisation"] .card--section-header h2 {
      color: var(--dark-brand) !important;
      margin: 0 0 0.5rem 0;
    }
    
    section[data-panel="optimisation"] .card--section-header p {
      color: var(--dark-text-muted) !important;
      margin: 0;
    }
    
    /* Buttons */
    section[data-panel="optimisation"] .btn {
      background: var(--dark-brand) !important;
      color: #000 !important;
      border: none !important;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    section[data-panel="optimisation"] .btn:hover {
      background: #d97706 !important;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
    }
    
    /* Optimisation module tiles - dark theme with green centered counts and orange hover animation */
    .optimisation-summary-cards .card,
    .optimisation-kpi-tiles .card,
    .optimisation-impact-tiles .card {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px;
      padding: 1.5rem;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    /* Task Details Modal/Drawer - Dark Theme */
    #optimisation-task-drawer {
      background: var(--dark-panel) !important;
      color: var(--dark-text) !important;
    }
    
    #optimisation-task-drawer * {
      color: var(--dark-text) !important;
    }
    
    #optimisation-drawer-header-bar {
      background: var(--dark-panel) !important;
      border-bottom: 1px solid var(--dark-border) !important;
    }
    
    #optimisation-drawer-header-bar h3 {
      color: var(--dark-text) !important;
    }
    
    #optimisation-drawer-header-bar button {
      color: var(--dark-text-muted) !important;
    }
    
    #optimisation-drawer-header-bar button:hover {
      color: var(--dark-text) !important;
    }
    
    /* Modal sections with light backgrounds */
    #optimisation-task-drawer div[style*="background: #fff5f5"],
    #optimisation-task-drawer div[style*="background: #f8f9fa"],
    #optimisation-task-drawer div[style*="background: white"] {
      background: var(--dark-panel) !important;
      border-color: var(--dark-border) !important;
    }
    
    /* Input fields */
    #optimisation-task-drawer input,
    #optimisation-task-drawer select,
    #optimisation-task-drawer textarea {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    #optimisation-task-drawer input::placeholder,
    #optimisation-task-drawer textarea::placeholder {
      color: var(--dark-text-muted) !important;
    }
    
    /* Labels and strong text */
    #optimisation-task-drawer strong,
    #optimisation-task-drawer label {
      color: var(--dark-text) !important;
    }
    
    /* Divs with muted colors */
    #optimisation-task-drawer div[style*="color: #666"],
    #optimisation-task-drawer div[style*="color: #475569"] {
      color: var(--dark-text-muted) !important;
    }
    
    /* Links */
    #optimisation-task-drawer a {
      color: var(--dark-brand) !important;
    }
    
    /* UNIVERSAL RULE: ALL buttons in drawer MUST have BLACK text - override everything */
    #optimisation-task-drawer button,
    #optimisation-task-drawer button * {
      color: #000000 !important;
      font-weight: 700 !important;
    }
    
    /* Buttons - ensure visibility in dark theme */
    #optimisation-task-drawer .btn,
    #optimisation-task-drawer button.btn {
      background: var(--dark-brand) !important;
      color: #000000 !important;
      border: 1px solid var(--dark-brand) !important;
      font-weight: 700 !important;
    }
    
    #optimisation-task-drawer .btn:hover,
    #optimisation-task-drawer button.btn:hover {
      background: #f59e0b !important;
      color: #000000 !important;
      border-color: #f59e0b !important;
    }
    
    #optimisation-task-drawer .btn-secondary,
    #optimisation-task-drawer button.btn-secondary {
      background: rgba(156, 163, 175, 0.6) !important;
      color: #000000 !important;
      border: 1px solid var(--dark-border) !important;
      font-weight: 700 !important;
    }
    
    #optimisation-task-drawer .btn-secondary:hover,
    #optimisation-task-drawer button.btn-secondary:hover {
      background: rgba(156, 163, 175, 0.8) !important;
      color: #000000 !important;
      border-color: rgba(156, 163, 175, 0.9) !important;
    }
    
    /* Ensure all buttons in drawer are visible - default styling */
    #optimisation-task-drawer button:not(.btn):not(.btn-secondary) {
      background: rgba(156, 163, 175, 0.6) !important;
      color: #000000 !important;
      border: 1px solid var(--dark-border) !important;
      font-weight: 700 !important;
    }
    
    #optimisation-task-drawer button:not(.btn):not(.btn-secondary):hover {
      background: rgba(156, 163, 175, 0.8) !important;
      color: #000000 !important;
    }
    
    /* Override ANY inline color styles - force black */
    #optimisation-task-drawer button[style*="color"],
    #optimisation-task-drawer button[style*="color: white"],
    #optimisation-task-drawer button[style*="color: #fff"],
    #optimisation-task-drawer button[style*="color: #ffffff"] {
      color: #000000 !important;
    }
    
    /* Specific button types that might need special handling */
    #optimisation-task-drawer button[type="button"],
    #optimisation-task-drawer button[type="submit"] {
      background: var(--dark-brand) !important;
      color: #000000 !important;
      border: 1px solid var(--dark-brand) !important;
      font-weight: 700 !important;
    }
    
    /* Specific button IDs with inline styles - override to make readable */
    #optimisation-cancel-task-btn,
    #optimisation-delete-task-btn {
      background: #dc2626 !important;
      color: #000000 !important;
      border: 1px solid #dc2626 !important;
      font-weight: 700 !important;
    }
    
    #optimisation-cancel-task-btn:hover,
    #optimisation-delete-task-btn:hover {
      background: #b91c1c !important;
      color: #000000 !important;
      border-color: #b91c1c !important;
    }
    
    #optimisation-complete-cycle-btn {
      background: #059669 !important;
      color: #000000 !important;
      border: 1px solid #059669 !important;
      font-weight: 700 !important;
    }
    
    #optimisation-complete-cycle-btn:hover {
      background: #047857 !important;
      color: #000000 !important;
      border-color: #047857 !important;
    }
    
    #optimisation-add-measurement-btn,
    #optimisation-add-event-btn,
    #optimisation-save-status-btn {
      background: var(--dark-brand) !important;
      color: #000000 !important;
      border: 1px solid var(--dark-brand) !important;
      font-weight: 700 !important;
    }
    
    #optimisation-add-measurement-btn:hover,
    #optimisation-add-event-btn:hover,
    #optimisation-save-status-btn:hover {
      background: #f59e0b !important;
      color: #000000 !important;
      border-color: #f59e0b !important;
    }
    
    /* Force black text on ALL buttons in drawer - ULTRA AGGRESSIVE - HIGHEST SPECIFICITY */
    #optimisation-task-drawer button,
    #optimisation-task-drawer button.btn,
    #optimisation-task-drawer button.btn-primary,
    #optimisation-task-drawer button.btn-secondary,
    #optimisation-task-drawer button.btn-small,
    #optimisation-task-drawer button[style],
    #optimisation-task-drawer button[style*="color"],
    #optimisation-task-drawer button[style*="background"],
    #optimisation-task-drawer div button,
    #optimisation-task-drawer form button,
    #optimisation-task-drawer * button {
      color: #000000 !important;
      font-weight: 700 !important;
      --color: #000000 !important;
    }
    
    /* Force black text on button children too - ALL POSSIBLE SELECTORS */
    #optimisation-task-drawer button *,
    #optimisation-task-drawer button.btn *,
    #optimisation-task-drawer button.btn-primary *,
    #optimisation-task-drawer button.btn-secondary *,
    #optimisation-task-drawer button span,
    #optimisation-task-drawer button div,
    #optimisation-task-drawer button p,
    #optimisation-task-drawer button::before,
    #optimisation-task-drawer button::after {
      color: #000000 !important;
      --color: #000000 !important;
    }
    
    /* Override ANY inline style that sets color to white/light */
    #optimisation-task-drawer button[style*="color: white"],
    #optimisation-task-drawer button[style*="color:#fff"],
    #optimisation-task-drawer button[style*="color: #fff"],
    #optimisation-task-drawer button[style*="color:#ffffff"],
    #optimisation-task-drawer button[style*="color: #ffffff"],
    #optimisation-task-drawer button[style*="color:white"],
    #optimisation-task-drawer button[style*="color:rgb(255"],
    #optimisation-task-drawer button[style*="color: rgba(255"] {
      color: #000000 !important;
    }
    
    /* Override inline styles on all buttons in drawer */
    #optimisation-task-drawer button[style*="background"],
    #optimisation-task-drawer button[style*="color"] {
      background: var(--dark-brand) !important;
      color: #000000 !important;
      border-color: var(--dark-brand) !important;
      font-weight: 700 !important;
    }
    
    /* But keep secondary buttons as secondary - but with BLACK text */
    #optimisation-task-drawer button.btn-secondary[style*="background"],
    #optimisation-task-drawer button.btn-secondary[style*="color"] {
      background: rgba(156, 163, 175, 0.6) !important;
      color: #000000 !important;
      border-color: var(--dark-border) !important;
    }
    
    /* ALL buttons in drawer - force black text */
    #optimisation-task-drawer button {
      color: #000000 !important;
      font-weight: 700 !important;
    }
    
    /* Specific button IDs that need explicit styling */
    #optimisation-complete-cycle-btn,
    #optimisation-archive-cycle-btn,
    #optimisation-start-cycle-btn,
    #optimisation-add-event-btn,
    #optimisation-save-objective-btn,
    #optimisation-cancel-edit-objective-btn,
    #optimisation-edit-objective-btn {
      background: var(--dark-brand) !important;
      color: #000000 !important;
      border: 1px solid var(--dark-brand) !important;
      font-weight: 700 !important;
    }
    
    #optimisation-complete-cycle-btn:hover,
    #optimisation-archive-cycle-btn:hover,
    #optimisation-start-cycle-btn:hover,
    #optimisation-add-event-btn:hover,
    #optimisation-save-objective-btn:hover,
    #optimisation-cancel-edit-objective-btn:hover,
    #optimisation-edit-objective-btn:hover {
      background: #f59e0b !important;
      color: #000000 !important;
      border-color: #f59e0b !important;
    }
    
    /* Complete Cycle button - green with BLACK text */
    #optimisation-complete-cycle-btn {
      background: #10b981 !important;
      color: #000000 !important;
      border-color: #10b981 !important;
      font-weight: 700 !important;
    }
    
    #optimisation-complete-cycle-btn:hover {
      background: #059669 !important;
      color: #000000 !important;
    }
    
    /* Secondary buttons should be grey with BLACK text */
    #optimisation-archive-cycle-btn.btn-secondary,
    #optimisation-start-cycle-btn.btn-secondary,
    #optimisation-cancel-edit-objective-btn.btn-secondary {
      background: rgba(156, 163, 175, 0.6) !important;
      color: #000000 !important;
      border: 1px solid var(--dark-border) !important;
      font-weight: 700 !important;
    }
    
    #optimisation-archive-cycle-btn.btn-secondary:hover,
    #optimisation-start-cycle-btn.btn-secondary:hover,
    #optimisation-cancel-edit-objective-btn.btn-secondary:hover {
      background: rgba(156, 163, 175, 0.8) !important;
      color: #000000 !important;
    }
    
    /* Primary buttons */
    #optimisation-add-event-btn.btn-primary {
      background: var(--dark-brand) !important;
      color: #000000 !important;
      border: 1px solid var(--dark-brand) !important;
      font-weight: 700 !important;
    }
    
    #optimisation-add-event-btn.btn-primary:hover {
      background: #f59e0b !important;
      color: #000000 !important;
    }
    
    /* Status badges and pills */
    #optimisation-task-drawer span[style*="background: #f0f0f0"] {
      background: rgba(156, 163, 175, 0.2) !important;
      color: var(--dark-text) !important;
    }
    
    /* Table borders and backgrounds */
    #optimisation-task-drawer table,
    #optimisation-task-drawer th,
    #optimisation-task-drawer td {
      border-color: var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    #optimisation-task-drawer th {
      background: var(--dark-bg) !important;
    }
    
    /* Timeline border */
    #optimisation-drawer-events-container div[style*="border-left"] {
      border-left-color: var(--dark-border) !important;
    }

    .optimisation-summary-cards .card::before,
    .optimisation-kpi-tiles .card::before,
    .optimisation-impact-tiles .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--dark-brand);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }

    .optimisation-summary-cards .card:hover,
    .optimisation-kpi-tiles .card:hover,
    .optimisation-impact-tiles .card:hover {
      border-color: var(--dark-brand) !important;
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(245, 158, 11, 0.2);
      animation: wobble 0.5s ease-in-out;
    }

    @keyframes wobble {
      0%, 100% { transform: translateY(-4px) rotate(0deg); }
      25% { transform: translateY(-4px) rotate(-1deg); }
      75% { transform: translateY(-4px) rotate(1deg); }
    }

    .optimisation-summary-cards .card:hover::before,
    .optimisation-kpi-tiles .card:hover::before,
    .optimisation-impact-tiles .card:hover::before {
      transform: scaleX(1);
    }
    
    /* Traffic light pills - same styling as other cards */
    .traffic-light-pill {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px !important;
      padding: 1rem !important;
      transition: all 0.3s ease !important;
      position: relative !important;
      overflow: visible !important;
      text-align: center !important;
      cursor: pointer !important;
      z-index: 1 !important;
    }
    
    .traffic-light-pill::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--dark-brand);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }
    
    .traffic-light-pill:hover {
      border-color: var(--dark-brand) !important;
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(245, 158, 11, 0.2);
      animation: wobble 0.5s ease-in-out;
    }
    
    .traffic-light-pill:hover::before {
      transform: scaleX(1);
    }
    
    /* Restore background colors on hover based on bucket */
    .traffic-light-pill[data-bucket="worse"]:hover {
      background: rgba(239, 68, 68, 0.3) !important;
    }
    
    .traffic-light-pill[data-bucket="same"]:hover {
      background: rgba(245, 158, 11, 0.3) !important;
    }
    
    .traffic-light-pill[data-bucket="better"]:hover {
      background: rgba(16, 185, 129, 0.3) !important;
    }

    /* Green centered count values (like analytics.html) - no background */
    .optimisation-summary-cards .card > div:first-child,
    .optimisation-kpi-tiles .card > div:first-child,
    .optimisation-impact-tiles .card > div:first-child {
      font-size: 2.5rem !important;
      font-weight: 700 !important;
      color: var(--success) !important;
      margin-bottom: 0.5rem;
      text-align: center;
      background: transparent !important;
      padding: 0 !important;
    }

    /* Labels - no background */
    .optimisation-summary-cards .card > div:last-child,
    .optimisation-kpi-tiles .card > div:last-child,
    .optimisation-impact-tiles .card > div:last-child {
      color: var(--dark-text-muted) !important;
      font-size: 0.9rem;
      text-align: center;
      background: transparent !important;
      padding: 0 !important;
    }

    /* Goal rollup badges */
    section[data-panel="optimisation"] .optimisation-goal-rollups {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      border-radius: 8px;
      padding: 1rem;
      margin: 1.5rem 0;
    }
    
    section[data-panel="optimisation"] .optimisation-goal-rollups > div:first-child {
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .ranking-badge {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
      transition: all 0.2s;
    }
    
    section[data-panel="optimisation"] .ranking-badge:hover {
      border-color: var(--dark-brand) !important;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.2);
    }
    
    /* Scope toggle */
    section[data-panel="optimisation"] .optimisation-scope-toggle {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-scope-toggle label {
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-scope-toggle select {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-scope-toggle span {
      color: var(--dark-text-muted) !important;
    }
    
    /* Tab pills */
    section[data-panel="optimisation"] .optimisation-tab-pills {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      border-radius: 8px;
      padding: 1rem;
      margin: 1.5rem 0;
    }
    
    section[data-panel="optimisation"] .optimisation-tab-btn {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-tab-btn:hover {
      border-color: var(--dark-brand) !important;
      background: rgba(245, 158, 11, 0.1) !important;
    }
    
    section[data-panel="optimisation"] .metric-pill--active {
      background: var(--dark-brand) !important;
      border-color: var(--dark-brand) !important;
      color: #000 !important;
      animation: wobble 0.5s ease-in-out;
    }
    
    /* Tables */
    section[data-panel="optimisation"] .ranking-table-wrapper {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      border-radius: 8px;
      overflow: hidden;
    }
    
    section[data-panel="optimisation"] .ranking-table {
      background: var(--dark-panel) !important;
    }
    
    section[data-panel="optimisation"] .ranking-table thead th {
      background: var(--dark-bg) !important;
      color: #ffffff !important;
      border-bottom: 1px solid var(--dark-border) !important;
      font-weight: 600;
    }
    
    /* Sort indicators and info icons - white */
    section[data-panel="optimisation"] .ranking-table thead th .sort-indicator,
    section[data-panel="optimisation"] .ranking-table thead th i,
    section[data-panel="optimisation"] .ranking-table thead th [class*="icon"],
    section[data-panel="optimisation"] .ranking-table thead th::after {
      color: #ffffff !important;
      opacity: 0.8;
    }
    
    section[data-panel="optimisation"] .ranking-table thead th:hover .sort-indicator,
    section[data-panel="optimisation"] .ranking-table thead th:hover i {
      opacity: 1;
    }
    
    /* Table cells - no darker background, transparent */
    section[data-panel="optimisation"] .ranking-table tbody td {
      background: transparent !important;
      color: var(--dark-text) !important;
      border-bottom: 1px solid var(--dark-border) !important;
    }
    
    /* Remove any background from text/spans inside cells */
    section[data-panel="optimisation"] .ranking-table tbody td *,
    section[data-panel="optimisation"] .ranking-table tbody td span,
    section[data-panel="optimisation"] .ranking-table tbody td strong,
    section[data-panel="optimisation"] .ranking-table tbody td div {
      background: transparent !important;
    }
    
    /* Ensure all text in table cells is readable */
    section[data-panel="optimisation"] .ranking-table tbody td {
      background: transparent !important;
    }
    
    section[data-panel="optimisation"] .ranking-table tbody td strong {
      color: var(--dark-text) !important;
      background: transparent !important;
    }
    
    section[data-panel="optimisation"] .ranking-table tbody tr:hover {
      background: rgba(255, 255, 255, 0.05) !important;
    }
    
    section[data-panel="optimisation"] .ranking-table tbody tr:hover td {
      background: rgba(255, 255, 255, 0.05) !important;
    }
    
    section[data-panel="optimisation"] .ranking-table-empty {
      color: var(--dark-text-muted) !important;
      background: transparent !important;
    }
    
    /* Pagination */
    section[data-panel="optimisation"] #optimisation-pagination-controls {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      border-radius: 8px;
      padding: 1rem;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] #optimisation-pagination-controls button,
    section[data-panel="optimisation"] #optimisation-pagination-controls select {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] #optimisation-pagination-controls button:hover {
      border-color: var(--dark-brand) !important;
      background: rgba(245, 158, 11, 0.1) !important;
    }
    
    /* Charts container */
    section[data-panel="optimisation"] .optimisation-timeseries-charts .card {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-timeseries-charts h3 {
      color: #ffffff !important;
      font-size: 1.2rem !important;
      font-weight: 600;
    }
    
    /* Chart text - bright white and larger */
    section[data-panel="optimisation"] canvas {
      color: #ffffff !important;
    }
    
    /* Chart axis labels and text - white and larger */
    section[data-panel="optimisation"] #chart-measurements-per-week,
    section[data-panel="optimisation"] #chart-median-delta {
      color: #ffffff !important;
    }
    
    /* Filters and inputs */
    section[data-panel="optimisation"] input[type="text"],
    section[data-panel="optimisation"] input[type="checkbox"],
    section[data-panel="optimisation"] select {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] input[type="text"]:focus,
    section[data-panel="optimisation"] select:focus {
      border-color: var(--dark-brand) !important;
      outline: none;
    }
    
    /* Remove border-left from inline styles */
    .optimisation-summary-cards .card[style*="border-left"],
    .optimisation-kpi-tiles .card[style*="border-left"],
    .optimisation-impact-tiles .card[style*="border-left"] {
      border-left: 2px solid var(--dark-border) !important;
    }

    .metric-pill--green .metric-pill-status {
      background: #dcfce7;
      color: #166534;
    }

    .metric-pill--amber .metric-pill-status {
      background: #fef3c7;
      color: #92400e;
    }

    .metric-pill--red .metric-pill-status {
      background: #fee2e2;
      color: #b91c1c;
    }

    .metric-pill--neutral .metric-pill-status {
      background: #e5e7eb;
      color: #4b5563;
    }

    .metric-pill-footer {
      font-size: 0.85rem;
      color: #6b7280;
      margin-top: 0.5rem;
      line-height: 1.4;
    }

    .metric-pill-toggle {
      font-size: 0.85rem;
      color: #0284c7;
      cursor: pointer;
      margin-top: 0.5rem;
      text-decoration: underline;
      user-select: none;
    }

    .metric-pill-toggle:hover {
      color: #0369a1;
    }

    .metric-pill-details {
      display: none;
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid #e5e7eb;
    }

    .metric-pill-details.expanded {
      display: block;
    }

    /* ============================================
       AI Sources & Influence tab: layout styling
       ============================================ */
    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer {
      background: #fffbeb;
      border-left: 4px solid #f59e0b;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer .card-header {
      padding: 1.25rem 1.5rem 0.75rem 1.5rem;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer .card-header h3 {
      color: #92400e;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer .card-body {
      padding: 1.25rem 1.5rem;
      color: #78350f;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer ul {
      padding-left: 1.5rem;
      margin: 0.25rem 0;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-domain-table-card {
      background: rgba(204, 255, 255, 0.15);
      border-left: 4px solid #CCFFFF;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-domain-table-card .card-header {
      background: transparent;
    }

    /* AI sources table: alignment + hover highlight */
    #ai-sources-table th:nth-child(1),
    #ai-sources-table td:nth-child(1),
    #ai-sources-table th:nth-child(2),
    #ai-sources-table td:nth-child(2),
    #ai-sources-table th:nth-child(6),
    #ai-sources-table td:nth-child(6) {
      text-align: left !important;
    }

    #ai-sources-table th:nth-child(3),
    #ai-sources-table td:nth-child(3),
    #ai-sources-table th:nth-child(4),
    #ai-sources-table td:nth-child(4),
    #ai-sources-table th:nth-child(5),
    #ai-sources-table td:nth-child(5) {
      text-align: right !important;
    }

    #ai-sources-table tbody tr:hover td {
      background: #eff6ff !important;
    }

    /* Tile details styling */
    .tile-details-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: #374151;
      margin: 0 0 0.75rem 0;
      line-height: 1.5;
    }

    .tile-details-list {
      list-style: none;
      padding: 0;
      margin: 0 0 0.75rem 0;
    }

    .tile-details-list li {
      font-size: 0.875rem;
      color: #4b5563;
      line-height: 1.8;
      margin-bottom: 0.5rem;
    }

    .tile-details-list li strong {
      color: #1f2937;
      font-weight: 600;
    }

    .tile-details-footnote {
      font-size: 0.8rem;
      color: #6b7280;
      margin: 0.75rem 0 0 0;
      font-style: italic;
      line-height: 1.5;
    }

    /* Insights card styling */
    /* Side-by-side container for insights and visibility cards - 50% each */
    .ranking-cards-side-by-side {
      display: flex !important;
      flex-direction: row !important;
      gap: 1.5rem;
      margin: 1.5rem 0;
      align-items: flex-start;
      flex-wrap: wrap !important;
      width: 100%;
      overflow: visible;
    }

    .ranking-cards-side-by-side > *:first-child,
    .ranking-cards-side-by-side > *:nth-child(2) {
      flex: 0 0 calc(50% - 0.75rem) !important;
      min-width: 0;
      max-width: calc(50% - 0.75rem) !important;
      width: calc(50% - 0.75rem) !important;
      display: block !important;
    }

    /* Force all other children to be full width and on new rows */
    .ranking-cards-side-by-side > *:nth-child(n+3) {
      flex: 0 0 100% !important;
      width: 100% !important;
      max-width: 100% !important;
      clear: both !important;
      display: block !important;
      margin-top: 1.5rem;
    }

    .ranking-visibility-metrics-section {
      display: block !important;
    }

    /* Ensure sections after side-by-side cards are full width and stacked on new row */
    .ranking-cards-side-by-side ~ .ranking-priority-matrix-section,
    .ranking-cards-side-by-side ~ .ranking-table-section {
      width: 100% !important;
      display: block !important;
      clear: both !important;
      flex: none !important;
      margin-left: 0 !important;
      margin-right: 0 !important;
      float: none !important;
      position: relative !important;
    }

    @media (max-width: 1024px) {
      .ranking-cards-side-by-side {
        flex-direction: column;
      }
    }

    .card--insights {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin: 0;
      padding: 1.25rem 1.5rem;
    }

    .card--insights h2 {
      font-weight: 600;
      color: #92400e;
      margin: 0 0 0.5rem 0;
      font-size: 0.95rem;
    }

    .card--insights .card-subtitle {
      font-weight: 400;
      color: #78350f;
      margin: 0 0 1rem 0;
      font-size: 0.8rem;
      line-height: 1.5;
    }

    .card-pill-container {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .card-pill {
      background: #fffbeb;
      border: 1px solid #fde68a;
      border-radius: 6px;
      padding: 0.875rem;
      margin-bottom: 0.75rem;
    }

    .card-pill p {
      margin: 0;
      font-size: 0.8rem;
      line-height: 1.5;
      color: #78350f;
    }

    .card-pill strong {
      color: #92400e;
      font-weight: 600;
    }

    /* Visibility metrics card styling */
    .ranking-visibility-metrics-section .card {
      padding: 1.25rem 1.5rem;
    }

    .ranking-visibility-metrics-section h4 {
      font-size: 0.95rem !important;
      font-weight: 600 !important;
      margin-bottom: 0.5rem !important;
    }

    .ranking-visibility-metrics-section p,
    .ranking-visibility-metrics-section ul,
    .ranking-visibility-metrics-section li {
      font-size: 0.8rem !important;
    }

    .ranking-visibility-metrics-section strong {
      font-weight: 600 !important;
    }

    /* Section C: Filters */
    .ranking-filters-section {
      margin-bottom: 1rem;
      background: rgba(204, 255, 255, 0.15) !important;
      border-left: 4px solid #CCFFFF !important;
      border-radius: 8px;
      padding: 1rem 1.25rem;
      font-size: 0.75rem !important;
    }

    .ranking-filter-bar {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 0.75rem 1rem;
      align-items: end;
      padding: 0;
      background: transparent;
    }

    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 0.375rem;
      min-width: 0;
    }

    .filter-group label {
      font-size: 0.65rem !important;
      font-weight: 600;
      color: #374151;
      white-space: nowrap;
      margin: 0;
      line-height: 1.2;
    }

    .filter-control {
      padding: 0.35rem 0.55rem;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.85rem !important;
      background: #ffffff;
      width: 100%;
      min-width: 110px;
      transition: all 0.2s ease;
    }
    
    .filter-control option {
      font-size: 0.85rem;
    }

    /* Active filter state - when value is not "all" */
    .filter-control.filter-active {
      background: #eff6ff !important;
      border-color: #3b82f6 !important;
      color: #1e40af !important;
      font-weight: 600;
    }

    .filter-control:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.15);
    }

    #ranking-filter-keyword {
      min-width: 300px;
    }

    /* Search filter group should be wider */
    .filter-group-search {
      grid-column: span 2;
      min-width: 300px;
    }

    /* Clear filters button */
    #ranking-filter-clear {
      font-size: 0.7rem !important;
      padding: 0.4rem 0.75rem;
      align-self: end;
    }

    /* Keyword Priority Matrix section - full width, stacked layout */
    .ranking-priority-matrix-section {
      width: 100% !important;
      clear: both !important;
      display: block !important;
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
      flex: none !important;
      flex-basis: 100% !important;
      max-width: 100% !important;
      float: none !important;
      position: relative !important;
      box-sizing: border-box !important;
      order: 999 !important;
    }

    /* Section C: Table section - separate card */
    .ranking-table-section {
      margin: 2rem 0;
      width: 100% !important;
      clear: both !important;
      display: block !important;
      flex: none !important;
      max-width: 100% !important;
      float: none !important;
      position: relative !important;
      box-sizing: border-box !important;
      background: rgba(204, 255, 255, 0.2) !important;
      border-left: 4px solid #CCFFFF !important;
      border-radius: 8px;
      padding: 1.5rem;
      font-size: 14pt !important;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .ranking-table-section .card {
      background: transparent;
      box-shadow: none;
      padding: 0;
    }
    
    /* Apply 14pt to section elements but exclude table */
    .ranking-table-section .card-header,
    .ranking-table-section .card-subtitle,
    .ranking-table-section .filter-group,
    .ranking-table-section .filter-control,
    .ranking-table-section .btn {
      font-size: 14pt !important;
    }
    
    /* Table font size - must come after to override any universal selectors */
    .ranking-table-section .ranking-table,
    .ranking-table-section .ranking-table th,
    .ranking-table-section .ranking-table td,
    .ranking-table-section .ranking-table-wrapper .ranking-table,
    .ranking-table-section .ranking-table-wrapper .ranking-table th,
    .ranking-table-section .ranking-table-wrapper .ranking-table td {
      font-size: 0.875rem !important;
    }
    
    /* Pagination controls */
    .ranking-pagination-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #e5e7eb;
      flex-wrap: wrap;
      gap: 1rem;
    }
    
    .ranking-pagination-info {
      font-size: 14pt !important;
      color: #374151;
    }
    
    .ranking-pagination-buttons {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    
    .ranking-pagination-buttons button {
      padding: 0.5rem 1rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      background: #ffffff;
      font-size: 14pt !important;
      cursor: pointer;
      color: #374151;
    }
    
    .ranking-pagination-buttons button:hover:not(:disabled) {
      background: #f3f4f6;
      border-color: #9ca3af;
    }
    
    .ranking-pagination-buttons button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .ranking-rows-per-page {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .ranking-rows-per-page label {
      font-size: 14pt !important;
      color: #374151;
      white-space: nowrap;
    }
    
    .ranking-rows-per-page select {
      padding: 0.5rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 14pt !important;
      background: #ffffff;
    }

    /* Section D: Details grid - three columns (33% each) */
    .ranking-details-grid {
      display: grid !important;
      grid-template-columns: repeat(3, 1fr) !important;
      gap: 1rem;
      margin-top: 2rem;
      background: rgba(204, 255, 255, 0.15) !important;
      border-left: 4px solid #CCFFFF !important;
      border-radius: 8px;
      padding: 1.5rem;
    }
    
    .ranking-details-grid .card {
      min-width: 0;
      overflow: hidden;
    }
    
    .ranking-details-grid table {
      width: 100%;
      table-layout: fixed;
      font-size: 0.8rem;
    }
    
    .ranking-details-grid table th,
    .ranking-details-grid table td {
      padding: 0.5rem 0.4rem;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    .ranking-details-grid table th:first-child,
    .ranking-details-grid table td:first-child {
      width: 35%;
      max-width: 35%;
    }
    
    .ranking-details-grid table th:nth-child(2),
    .ranking-details-grid table td:nth-child(2) {
      width: 15%;
      max-width: 15%;
    }
    
    .ranking-details-grid table th:nth-child(3),
    .ranking-details-grid table td:nth-child(3) {
      width: 20%;
      max-width: 20%;
    }
    
    .ranking-details-grid table th:nth-child(4),
    .ranking-details-grid table td:nth-child(4) {
      width: 20%;
      max-width: 20%;
    }
    
    .ranking-details-grid table th:nth-child(5),
    .ranking-details-grid table td:nth-child(5) {
      width: 10%;
      max-width: 10%;
    }

    .ranking-details-grid .card {
      background: #ffffff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 0;
      margin-bottom: 0.75rem;
      border-radius: 6px;
      border: 1px solid #e5e7eb;
    }

    .ranking-details-grid .card:last-child {
      margin-bottom: 0;
    }

    /* Card header and body padding for consistent spacing */
    .ranking-details-grid .card-header {
      padding: 1.25rem 1.25rem 0.75rem 1.25rem;
    }

    .ranking-details-grid .card-body,
    .ranking-details-grid .ranking-ai-detail-body {
      padding: 0 1.25rem 1.25rem 1.25rem;
      font-size: 0.95rem;
      font-weight: 400;
      color: #1e293b;
      line-height: 1.6;
    }

    /* Typography hierarchy for cards */
    .ranking-details-grid .card-header h3 {
      font-size: 1.25rem;
      font-weight: 700;
      color: #1e293b;
      margin: 0 0 0.5rem 0;
      line-height: 1.4;
    }

    .ranking-details-grid .card-header h2 {
      font-size: 1.1rem;
      font-weight: 600;
      color: #374151;
      margin: 0 0 0.5rem 0;
      line-height: 1.4;
    }

    .ranking-details-grid .card-header p,
    .ranking-details-grid .card-subtitle {
      font-size: 0.9rem;
      font-weight: 400;
      color: #64748b;
      line-height: 1.5;
      margin: 0;
    }

    .ranking-details-grid .card-header h5 {
      font-size: 1rem;
      font-weight: 600;
      color: #374151;
      margin: 1rem 0 0.5rem 0;
    }

    /* List padding to match card body */
    .ranking-details-grid .ranking-ai-detail-list {
      padding: 0 1.25rem 1.25rem 1.25rem;
      margin: 0;
    }

    @media (max-width: 1200px) {
      .ranking-details-grid {
        grid-template-columns: 1fr;
      }
    }


    .ranking-table-wrapper {
      max-height: 540px;
      overflow: auto;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
    }

    .ranking-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.875rem !important;
    }

    /* Table header styling */
    .ranking-table th {
      text-align: center !important;
      vertical-align: middle;
      position: relative;
    }

    .ranking-table th > div:first-child {
      font-weight: 700 !important;
      text-align: center;
      margin-bottom: 0.25rem;
    }

    .ranking-table th > div:last-child {
      text-align: center !important;
      color: #2563eb !important;
      opacity: 1 !important;
    }

    .ranking-table th .sort-indicator {
      color: #1e40af !important;
      font-weight: 700 !important;
      margin-left: 0.25rem;
      opacity: 1 !important;
    }

    .ranking-table th.sortable {
      cursor: pointer;
    }

    .ranking-table th.sortable:hover {
      background-color: #f3f4f6;
    }

    /* Dynamic column widths - adjust based on content */
    .ranking-table {
      table-layout: auto;
      width: 100%;
    }

    .ranking-table th,
    .ranking-table td {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #e5e7eb;
      text-align: center;
      font-size: 0.875rem !important;
    }

    .ranking-table th {
      position: sticky;
      top: 0;
      background: #f3f4f6;
      z-index: 10;
      font-weight: 600;
      font-size: 0.875rem !important;
      vertical-align: top;
    }

    .ranking-table th > div:first-child {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
    }

    .ranking-table th.sortable {
      cursor: pointer;
      user-select: none;
      position: sticky;
      top: 0;
    }

    .ranking-table th.sortable:hover {
      background: #e5e7eb;
      position: sticky;
      top: 0;
    }

    .sort-indicator {
      display: inline-block;
      margin-left: 0.25rem;
      font-size: 0.85rem;
      opacity: 0.5;
    }

    .sort-indicator::after {
      content: "";
    }

    .ranking-table th.sort-asc .sort-indicator::after {
      content: "";
      opacity: 1;
    }

    .ranking-table th.sort-desc .sort-indicator::after {
      content: "";
      opacity: 1;
    }

    .ranking-table tr:nth-child(even) td {
      background: #f9fafb;
    }

    .ranking-table tr:hover {
      cursor: pointer;
    }

    .ranking-table-row--selected td {
      background: #eef2ff !important;
    }

    .ranking-row-good td {
      box-shadow: inset 3px 0 0 #16a34a;
    }

    .ranking-row-ok td {
      box-shadow: inset 3px 0 0 #f59e0b;
    }

    .ranking-row-weak td {
      box-shadow: inset 3px 0 0 #dc2626;
    }

    .ranking-table-empty {
      text-align: center;
      padding: 1rem;
      color: #6b7280;
    }


    .ranking-subtitle-tight {
      font-size: 0.875rem !important;
      max-width: 48rem;
    }

    /* RAG badges in table */
    .ranking-badge-rank {
      display: inline-flex;
      align-items: center;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .ranking-badge-rank--good {
      background: #dcfce7;
      color: #166534;
    }

    .ranking-badge-rank--ok {
      background: #fef3c7;
      color: #92400e;
    }

    .ranking-badge-rank--weak {
      background: #fee2e2;
      color: #b91c1c;
    }

    .ranking-badge-volume {
      display: inline-flex;
      align-items: center;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }
    
    .ranking-badge-volume--high {
      background: #dcfce7;
      color: #166534;
    }
    
    .ranking-badge-volume--med {
      background: #fef3c7;
      color: #92400e;
    }
    
    .ranking-badge-volume--low {
      background: #fee2e2;
      color: #b91c1c;
    }
    
    .ranking-badge-volume--none {
      background: #f3f4f6;
      color: #6b7280;
    }

    .ranking-badge-citation {
      display: inline-flex;
      align-items: center;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .ranking-badge-citation--good {
      background: #dcfce7;
      color: #166534;
    }

    .ranking-badge-citation--weak {
      background: #fee2e2;
      color: #b91c1c;
    }

    .ranking-ai-detail-body {
      padding: 1rem 0;
    }

    .ranking-ai-detail-content {
      /* Make scorecard stand out as separate object */
      margin: 0.75rem 0;
      padding: 1.5rem 1.5rem;
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      border-top: 1px solid #e5e7eb;
      border-right: 1px solid #e5e7eb;
      border-bottom: 1px solid #e5e7eb;
      /* Left border will be set dynamically based on priority */
    }

    .ranking-ai-detail-content.scorecard-priority-high {
      border-left: 6px solid #ef4444; /* Red for High priority */
      background: #fef2f2;
    }

    .ranking-ai-detail-content.scorecard-priority-medium {
      border-left: 6px solid #f59e0b; /* Amber for Medium priority */
      background: #fffbeb;
    }

    .ranking-ai-detail-content.scorecard-priority-low {
      border-left: 6px solid #10b981; /* Green for Low priority */
      background: #f0fdf4;
    }

    .ranking-ai-detail-content h4 {
      margin: 0 0 0.5rem 0;
      font-size: 1.25rem;
      font-weight: 700;
      color: #1e293b;
    }

    .ranking-ai-detail-content h5 {
      margin: 1rem 0 0.5rem 0;
      font-size: 1rem;
      font-weight: 600;
      color: #374151;
    }

    /* Section breaks for scorecard components */
    .ranking-ai-detail-content .scorecard-section {
      padding: 1rem 1.25rem;
      margin-bottom: 1.0rem !important;
      background: #f5f5f5;
      border-left: 3px solid #cbd5e1;
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .ranking-ai-detail-content .scorecard-section:last-child {
      margin-bottom: 0 !important;
    }

    .ranking-ai-detail-list {
      list-style: none;
      padding-left: 0;
      margin: 0.5rem 0 0;
    }

    .ranking-ai-detail-list li {
      margin-bottom: 0.4rem;
      padding: 0.5rem 0.75rem;
      background: #f9fafb;
      border-radius: 4px;
      font-size: 0.95rem;
    }

    .ranking-ai-detail-list li a {
      color: #2563eb;
      text-decoration: none;
    }

    .ranking-ai-detail-list li a:hover {
      text-decoration: underline;
    }

    .ranking-ai-last-run {
      margin-left: 0.75rem;
      font-size: 0.95rem;
      color: #6b7280;
    }

    .ranking-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 500;
    }

    .ranking-badge--ai-on { background: #ecfdf5; color: #059669; }
    .ranking-badge--ai-off { background: #f9fafb; color: #6b7280; }
    .ranking-badge--cited { background: #eff6ff; color: #1d4ed8; }
    .ranking-badge--not-cited { background: #fef2f2; color: #b91c1c; }
    .ranking-badge--segment-money { background: #fef3c7; color: #92400e; }
    .ranking-badge--segment-education { background: #e0f2fe; color: #075985; }
    .ranking-badge--segment-brand { background: #f5f3ff; color: #6d28d9; }
    .ranking-badge--segment-general { background: #f9fafb; color: #4b5563; }
    .ranking-badge--rank-good { background: #dcfce7; color: #166534; }
    .ranking-badge--rank-mid { background: #fef3c7; color: #92400e; }
    .ranking-badge--rank-weak { background: #fee2e2; color: #b91c1c; }
    
    /* Demand share styling */
    .ranking-badge-demand-share--high { color: #059669; font-weight: 600; }
    .ranking-badge-demand-share--med { color: #d97706; font-weight: 500; }
    .ranking-badge-demand-share--low { color: #6b7280; font-weight: 400; }
    .ranking-badge-demand-share--none { color: #9ca3af; }
    
    /* Opportunity score styling (RAG colors matching Money Pages priority matrix) */
    .ranking-badge-opportunity {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.9rem;
      font-weight: 600;
    }
    .ranking-badge-opportunity--high { background: #dcfce7; color: #166534; } /* Green - High */
    .ranking-badge-opportunity--medium { background: #fef3c7; color: #92400e; } /* Amber - Medium */
    .ranking-badge-opportunity--low { background: #fee2e2; color: #b91c1c; } /* Red - Low */
    
    /* Page type badge styling (matching Money Pages matrix) */
    .ranking-badge-page-type {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 500;
    }
    .ranking-badge-page-type--landing { background: #fef3c7; color: #92400e; }
    .ranking-badge-page-type--event { background: #dbeafe; color: #1e40af; }
    .ranking-badge-page-type--product { background: #fce7f3; color: #9f1239; }
    .ranking-badge-page-type--blog { background: #e0f2fe; color: #075985; }
    .ranking-badge-page-type--gbp { background: #f5f3ff; color: #6d28d9; }

    /* Money Pages KPI trend arrow colors */
    .kpi-trend-up { color: #10b981; font-weight: 700; }
    .kpi-trend-down { color: #ef4444; font-weight: 700; }
    .kpi-trend-flat { color: #64748b; font-weight: 700; }

    /* Domain Strength (Ranking & AI) */
    .domain-strength-badge {
      display: inline-flex;
      padding: 0.125rem 0.375rem !important;
      font-size: 0.65rem !important;
      line-height: 1.2 !important;
      align-items: center;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 600;
      white-space: nowrap;
    }
    .domain-strength-badge--very-strong { background: #dcfce7; color: #166534; }
    .domain-strength-badge--strong { background: #ecfdf5; color: #059669; }
    .domain-strength-badge--moderate { background: #fef3c7; color: #92400e; }
    .domain-strength-badge--weak { background: #fde68a; color: #92400e; }
    .domain-strength-badge--very-weak { background: #fee2e2; color: #b91c1c; }
    .domain-strength-badge--na { background: #f9fafb; color: #6b7280; }

    .domain-strength-summary-row {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      align-items: stretch;
      margin-top: 1rem;
    }
    .domain-strength-summary-card {
      flex: 1 1 280px;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 1rem 1.25rem;
      min-width: 280px;
    }
    .domain-strength-summary-top {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .domain-strength-summary-score {
      font-size: 2rem;
      font-weight: 800;
      letter-spacing: -0.02em;
      color: #0f172a;
      line-height: 1;
    }
    .domain-strength-summary-subtitle {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #64748b;
      line-height: 1.45;
    }
    .domain-strength-legend {
      flex: 1 1 320px;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      align-content: flex-start;
      padding: 1rem 1.25rem;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      min-width: 280px;
    }
    .domain-strength-help {
      margin-left: 0.4rem;
      opacity: 0.7;
      cursor: help;
      font-size: 0.95rem;
      border: 1px solid rgba(100, 116, 139, 0.35);
      border-radius: 999px;
      width: 20px;
      height: 20px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      background: rgba(248, 250, 252, 0.8);
    }
    .domain-strength-sparkline {
      display: inline-block;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>GAIO (Generative AI Optimization) Audit Dashboard</h1>
    <p>Automated GAIO Performance Tracking & Optimisation</p>
    <p style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 1; background: rgba(0,0,0,0.3); padding: 0.25rem 0.5rem; border-radius: 4px; display: inline-block;">
      <strong>Version: <span id="gitVersion">37685db</span></strong> | Built: <span id="buildDate"></span> | 
      <span id="loadTime" style="color: #4f4;">Loaded: <span id="loadTimeValue"></span></span>
    </p>
    <script>
      // Set build date to today in GMT
      const now = new Date();
      const gmtDate = now.toISOString().split('T')[0]; // YYYY-MM-DD
      const gmtTime = now.toISOString().split('T')[1].split('.')[0]; // HH:MM:SS
      document.getElementById('buildDate').textContent = gmtDate + ' ' + gmtTime + ' GMT';
      document.getElementById('loadTimeValue').textContent = now.toLocaleTimeString();
    </script>
  </div>

  <div class="aigeo-layout">
    <aside class="aigeo-sidebar">
      <button class="aigeo-nav-item" data-panel="config">
        <span class="aigeo-nav-icon"></span>
        <span>Configuration & Reporting</span>
      </button>
      <button class="aigeo-nav-item is-active" data-panel="overview">
        <span class="aigeo-nav-icon"></span>
        <span>Overview</span>
      </button>
      <button class="aigeo-nav-item" data-panel="authority">
        <span class="aigeo-nav-icon"></span>
        <span>Authority</span>
      </button>
      <button class="aigeo-nav-item" data-panel="money">
        <span class="aigeo-nav-icon"></span>
        <span>Money Pages</span>
      </button>
      <button class="aigeo-nav-item" data-panel="ranking">
        <span class="aigeo-nav-icon"></span>
        <span>Ranking & AI</span>
      </button>
      <button class="aigeo-nav-item" data-panel="optimisation">
        <span class="aigeo-nav-icon"></span>
        <span>Optimisation Tracking</span>
      </button>
      <button class="aigeo-nav-item" data-panel="ai-sources">
        <span class="aigeo-nav-icon"></span>
        <span>AI Sources & Influence</span>
      </button>
      <button class="aigeo-nav-item" data-panel="local">
        <span class="aigeo-nav-icon"></span>
        <span>Local & Reviews</span>
      </button>
      <button class="aigeo-nav-item" data-panel="history">
        <span class="aigeo-nav-icon"></span>
        <span>History</span>
      </button>
    </aside>
    <main class="aigeo-main">
  <div class="container">

    <div class="status" id="status"></div>

    <div class="loading" id="loading">
      <div class="progress-container">
        <div class="spinner"></div>
        <div class="progress-bar-wrapper">
          <div class="progress-bar" id="progressBar" style="width: 0%;">0%</div>
        </div>
        <div class="progress-status" id="progressStatus">Initializing audit scan...</div>
      </div>
    </div>

    <!-- Completion Summary Modal -->
    <div id="completionModal" class="modal" style="display: none;">
      <div class="modal-content" style="max-width: 600px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Audit Complete</h2>
          <button onclick="closeCompletionModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;" title="Close the audit completion summary modal">&times;</button>
        </div>
        <div id="completionSummaryContent"></div>
        <div style="margin-top: 1.5rem; text-align: right;">
          <button class="btn" onclick="closeCompletionModal()" style="background: var(--brand-orange); color: white; border-color: var(--brand-orange);" title="Close the audit completion summary modal and return to the dashboard">Close</button>
        </div>
      </div>
    </div>

    <!-- Bulk Update Results Modal -->
    <div id="optimisation-bulk-update-results-modal" class="modal" style="display: none;">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Bulk Update Complete</h2>
          <button onclick="closeBulkUpdateResultsModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;" title="Close">&times;</button>
        </div>
        <div id="bulk-update-results-content">
          <!-- Content will be populated by JavaScript -->
        </div>
        <div style="margin-top: 1.5rem; text-align: right;">
          <button class="btn" onclick="closeBulkUpdateResultsModal()" style="background: var(--brand-orange); color: white; border-color: var(--brand-orange);">Close</button>
        </div>
      </div>
    </div>

    <!-- Ranking & AI Progress Modal -->
    <div id="rankingAiProgressModal" class="modal" style="display: none;">
      <div class="modal-content" style="max-width: 700px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Running Ranking & AI Check</h2>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <button id="rankingAiProgressStop" style="display: none; padding: 0.5rem 1rem; background: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 600;" title="Stop the scan">Stop Scan</button>
            <button id="rankingAiProgressClose" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666; opacity: 0.5;" disabled title="Cannot close during processing">&times;</button>
          </div>
        </div>
        
        <!-- Keyword Count Display (shown before scan starts) -->
        <div id="rankingAiKeywordCount" style="display: none; margin-bottom: 1rem; padding: 1rem; background: #fef3c7; border: 1px solid #fbbf24; border-radius: 6px;">
          <div style="font-weight: 600; color: #92400e; margin-bottom: 0.5rem;">Ready to scan:</div>
          <div style="font-size: 1.2rem; font-weight: 700; color: #78350f;" id="rankingAiKeywordCountValue">0 keywords</div>
          <div style="font-size: 0.85rem; color: #78350f; margin-top: 0.5rem;">Click "Start Scan" below to begin, or close this modal to cancel.</div>
        </div>
        
        <!-- Progress Bar -->
        <div style="margin-bottom: 2rem;">
          <div id="rankingAiProgressBar" style="width: 100%; height: 24px; background-color: #e5e7eb; border-radius: 12px; overflow: hidden; position: relative;">
            <div id="rankingAiProgressFill" style="width: 0%; height: 100%; background: linear-gradient(90deg, var(--brand-orange), #ff8c42); transition: width 0.3s ease; border-radius: 12px;"></div>
          </div>
          <div id="rankingAiProgressText" style="margin-top: 0.5rem; text-align: center; font-size: 0.9rem; color: #6b7280; font-weight: 500;">0%</div>
        </div>

        <!-- Step Details -->
        <div id="rankingAiStepDetails" style="margin-bottom: 1.5rem;">
          <div id="rankingAiCurrentStep" style="font-size: 1.1rem; font-weight: 600; color: #1f2937; margin-bottom: 0.75rem;">
            Initializing...
          </div>
          <div id="rankingAiStepNarrative" style="font-size: 0.95rem; color: #6b7280; line-height: 1.6; margin-bottom: 1rem;">
            Preparing to fetch ranking and AI data...
          </div>
          <div id="rankingAiStepCounts" style="font-size: 0.9rem; color: #9ca3af; font-style: italic;">
            <!-- Counts will be populated here -->
          </div>
        </div>

        <!-- Step List -->
        <div style="border-top: 1px solid #e5e7eb; padding-top: 1rem;">
          <div style="font-size: 0.85rem; font-weight: 600; color: #6b7280; margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Progress Steps</div>
          <div id="rankingAiStepsList" style="display: flex; flex-direction: column; gap: 0.5rem;">
            <!-- Steps will be populated here -->
          </div>
        </div>

        <!-- Completion Summary (hidden by default) -->
        <div id="rankingAiSummary" style="display: none; border-top: 2px solid #10b981; padding-top: 1.5rem; margin-top: 1.5rem;">
          <h3 style="margin: 0 0 1rem 0; color: #10b981; font-size: 1.2rem; font-weight: 600;"> Scan Complete</h3>
          <div id="rankingAiSummaryContent" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; font-size: 0.95rem;">
            <!-- Summary content will be populated here -->
          </div>
        </div>
      </div>
    </div>

    <div id="dashboard" style="display: none;">
      <div id="auditTimestamp" style="background: #e8f5e9; padding: 0.75rem 1rem; border-radius: 6px; margin-bottom: 1rem; border-left: 4px solid #10b981; font-size: 0.9rem; color: #555;">
        <strong>Last Audit:</strong> <span id="lastAuditTime">Not yet run</span>
      </div>

      <!-- Configuration & Reporting Panel -->
      <section class="aigeo-panel" data-panel="config">
    <div class="config-panel">
      <h2>Configuration</h2>
      <div class="info-box" style="background: #e8f4f8; border-left: 4px solid #2196F3; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #1565C0;"><strong>Entity-Level Audit:</strong> This dashboard analyzes <strong>www.alanranger.com</strong> as a global entity, tracking AI-powered search visibility, entity recognition, and SERP behavior across the entire domain.</p>
      </div>
      <div class="form-group">
        <label for="propertyUrl">Property URL</label>
        <input type="text" id="propertyUrl" placeholder="https://yourwebsite.com" value="https://www.alanranger.com">
        <div class="help-text">The domain being audited (entity-level analysis)</div>
      </div>
      <div style="background: #f0f0f0; padding: 0.75rem; border-radius: 4px; margin-bottom: 1rem; font-size: 0.85rem; color: #555;">
        <strong>API Key:</strong> Loaded automatically from Vercel environment variables. No manual entry required.
      </div>
      <!-- Manual URL List Section (Collapsible) -->
      <div class="csv-upload-section collapsed" id="urlListSection">
        <div class="csv-section-header" onclick="toggleCsvSection('urlListSection')">
          <h3>Manual URL List (Optional)</h3>
          <span class="csv-section-toggle" id="urlListToggle"></span>
        </div>
        <div class="csv-section-content collapsed" id="urlListContent">
          <div class="form-group" style="margin-bottom: 0;">
        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">
          Load list of site URLs from a CSV file
        </div>
        <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
          <input type="file" id="urlListFile" accept=".csv" style="flex: 1; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem;">
              <button class="btn btn-small" onclick="loadUrlListFromFile()" style="padding: 0.5rem 1rem;" title="Load a CSV file containing site URLs. The CSV must have a 'url' column in the header row. URLs will be used for schema audit instead of the default CSV source.">Load CSV</button>
              <button class="btn btn-small" onclick="clearManualUrlList()" style="padding: 0.5rem 1rem; background: #ef4444; color: white; border-color: #ef4444;" title="Clear the manually loaded URL list and revert to using the default CSV source for schema audit">Clear</button>
        </div>
        <textarea id="manualUrlList" placeholder="Or paste CSV content here (must include 'url' column in header row)..." style="width: 100%; min-height: 100px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace; resize: vertical;"></textarea>
        <div class="help-text">
          <strong>Required column:</strong> <code>url</code> (case-insensitive). CSV must have a header row. URLs will be extracted from the 'url' column.
        </div>
        <div id="urlListStatus" style="margin-top: 0.5rem; font-size: 0.85rem;"></div>
          </div>
        </div>
      </div>
      
      <!-- Backlink CSV Upload Section (Collapsible) -->
      <div class="csv-upload-section collapsed" id="backlinkCsvSection">
        <div class="csv-section-header" onclick="toggleCsvSection('backlinkCsvSection')">
          <h3>Backlink CSV Upload (Optional)</h3>
          <span class="csv-section-toggle" id="backlinkCsvToggle"></span>
        </div>
        <div class="csv-section-content collapsed" id="backlinkCsvContentWrapper">
          <div class="form-group" style="margin-bottom: 0;">
            <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">
              Upload backlink data CSV file for Authority score calculation. Can be uploaded independently of site URLs CSV.
            </div>
            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
              <input type="file" id="backlinkCsvFile" accept=".csv" style="flex: 1; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem;">
                  <button class="btn btn-small" onclick="loadBacklinkCsvFromFile()" style="padding: 0.5rem 1rem;" title="Load a CSV file containing backlink data. The CSV must have 'source_url' and 'target_url' columns in the header row. Backlinks will be used for Authority score calculation.">Load CSV</button>
                  <button class="btn btn-small" onclick="clearBacklinkCsv()" style="padding: 0.5rem 1rem; background: #ef4444; color: white; border-color: #ef4444;" title="Clear the backlink CSV data">Clear</button>
            </div>
                <textarea id="backlinkCsvContent" placeholder="Or paste CSV content here (must include 'source_url' and 'target_url' columns in header row)..." style="width: 100%; min-height: 100px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace; resize: vertical;"></textarea>
            <div class="help-text">
                  <strong>Required columns:</strong> <code>source_url</code> and <code>target_url</code> (case-insensitive). CSV must have a header row. Backlinks will be extracted from these columns.
            </div>
            <div id="backlinkCsvStatus" style="margin-top: 0.5rem; font-size: 0.85rem;"></div>
          </div>
        </div>
      </div>
          
          <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-top: 1.5rem;">
        <button class="btn" onclick="runAudit()" title="Start a comprehensive audit scan. Fetches Google Search Console data, performs schema audit (if site URLs CSV loaded), and uses backlink data (if backlink CSV uploaded). Results will appear in the dashboard below.">Run Audit Scan</button>
            <button class="btn btn-secondary" onclick="shareAudit()" title="Generate a shareable link to your current audit results. The link will allow others to view your audit data without running a new scan.">Share Audit</button>
        <button class="btn btn-secondary" onclick="saveConfig()" title="Save your current configuration (property URL and date range) to browser localStorage. Settings will be restored when you reload the page.">Save Configuration</button>
            <button class="btn btn-success" onclick="syncCsv()" title="Sync CSV data from the configured source. This will update your URL list and backlink data from the remote CSV file.">Sync CSV</button>
      </div>
    </div>

    <!-- Share Mode Banner (read-only) -->
    <div id="share-mode-banner" class="config-panel" style="margin-top: 2rem; display: none; background: #fef3c7; border-left: 4px solid #f59e0b; padding: 1rem; border-radius: 4px;">
      <div style="display: flex; align-items: center; gap: 0.5rem;">
        <span style="font-size: 1.25rem;"></span>
        <strong style="color: #92400e;">Shared view (read-only)</strong>
        <span style="color: #92400e; font-size: 0.9rem;"> You can view all data but cannot make changes</span>
      </div>
    </div>

    <!-- Admin Key Configuration (Phase A - Security) -->
    <div id="admin-key-panel" class="config-panel" style="margin-top: 2rem;">
      <h2>Optimisation Tracking Security</h2>
      <div class="info-box" style="background: #e0f2fe; border-left: 4px solid #0284c7; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #0c4a6e;">
          <strong>Admin Key Required:</strong> Set your admin key to enable optimisation tracking actions (Track, Manage, Cycle). 
          The key is stored in your browser session and sent with API requests.
        </p>
      </div>
      <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-bottom: 1rem;">
        <input 
          type="password" 
          id="admin-key-input" 
          placeholder="Enter admin key (32+ characters)" 
          style="flex: 1; min-width: 300px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace;"
          value=""
        />
        <button 
          class="btn" 
          onclick="saveAdminKey()" 
          title="Save admin key to session storage. Required for optimisation tracking actions."
        >
          Save Admin Key
        </button>
        <button 
          class="btn btn-secondary" 
          onclick="clearAdminKeyUI()" 
          title="Clear admin key from session storage."
        >
          Clear
        </button>
      </div>
      <div id="admin-key-status" style="font-size: 0.85rem; color: #64748b; margin-top: 0.5rem;"></div>
      <script>
        // Share mode initialization
        (function() {
          const urlParams = new URLSearchParams(window.location.search);
          const isShare = urlParams.get('share') === '1';
          const shareToken = urlParams.get('st') || '';
          
          if (isShare) {
            // Hide admin key panel
            const adminPanel = document.getElementById('admin-key-panel');
            if (adminPanel) adminPanel.style.display = 'none';
            
            // Show share mode banner
            const shareBanner = document.getElementById('share-mode-banner');
            if (shareBanner) shareBanner.style.display = 'block';
            
            // Disable write buttons
            window.addEventListener('DOMContentLoaded', function() {
              // Disable audit scan, sync CSV, save config buttons
              const writeButtons = document.querySelectorAll('[onclick="runAudit()"], [onclick="syncCsv()"], [onclick="saveConfig()"]');
              writeButtons.forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
                btn.title = 'Not available in share mode (read-only)';
              });
              
              // Disable Optimisation Tracking write buttons
              const bulkUpdateBtn = document.getElementById('optimisation-bulk-update-btn');
              if (bulkUpdateBtn) {
                bulkUpdateBtn.disabled = true;
                bulkUpdateBtn.style.opacity = '0.5';
                bulkUpdateBtn.style.cursor = 'not-allowed';
                bulkUpdateBtn.title = 'Not available in share mode (read-only)';
              }
            });
          }
        })();
        
        // Admin key UI functions
        function saveAdminKey() {
          const input = document.getElementById('admin-key-input');
          const key = input.value.trim();
          if (!key) {
            alert('Please enter an admin key');
            return;
          }
          if (key.length < 32) {
            if (!confirm('Admin key should be at least 32 characters. Save anyway?')) {
              return;
            }
          }
          window.setAdminKey(key);
          updateAdminKeyStatus();
          input.value = ''; // Clear input for security
          
          // Clear auth error and reload optimisation tasks if on that tab
          if (window.optimisationModuleState) {
            window.optimisationModuleState.authError = null;
            const optimisationTab = document.querySelector('[data-panel="optimisation"]');
            if (optimisationTab && optimisationTab.classList.contains('is-active')) {
              if (typeof window.loadAllOptimisationTasks === 'function') {
                window.loadAllOptimisationTasks();
              }
            }
          }
          
          // Re-render Ranking & AI table to enable Track buttons
          // Check if Ranking & AI tab is active
          const rankingTab = document.querySelector('[data-panel="ranking"]');
          if (rankingTab && rankingTab.classList.contains('is-active')) {
            // Tab is active, try to refresh the table
            if (typeof renderRankingAiTab === 'function') {
              renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
            } else if (typeof window.renderRankingAiTab === 'function') {
              window.renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
            } else {
              // Fallback: reload the page
              if (confirm('Admin key saved! Refresh the page to enable Track buttons?')) {
                // Preserve current tab state before reload
                const currentPanel = document.querySelector('.aigeo-panel.is-active');
                if (currentPanel) {
                  const panelId = currentPanel.dataset.panel;
                  sessionStorage.setItem('activeTab', panelId);
                  window.location.hash = '#' + panelId;
                }
                location.reload();
              }
            }
          } else {
            alert('Admin key saved! Switch to the "Ranking & AI" tab to see enabled Track buttons.');
          }
        }

        function clearAdminKeyUI() {
          if (confirm('Clear admin key? Optimisation tracking actions will be disabled.')) {
            window.clearAdminKey();
            document.getElementById('admin-key-input').value = '';
            updateAdminKeyStatus();
            
            // Re-render Ranking & AI table to disable Track buttons
            const rankingTab = document.querySelector('[data-panel="ranking"]');
            if (rankingTab && rankingTab.classList.contains('is-active')) {
              if (typeof renderRankingAiTab === 'function') {
                renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
              } else if (typeof window.renderRankingAiTab === 'function') {
                window.renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
              }
            }
          }
        }

        function updateAdminKeyStatus() {
          const statusEl = document.getElementById('admin-key-status');
          if (!statusEl) return;
          
          // Safety check: ensure hasAdminKey function is loaded
          if (typeof window.hasAdminKey !== 'function') {
            // Retry after a short delay if function not yet loaded
            setTimeout(() => {
              if (typeof window.hasAdminKey === 'function') {
                updateAdminKeyStatus();
              } else {
                // If still not loaded after retry, show warning
                statusEl.innerHTML = '<span style="color: #f59e0b;"> Loading admin key functions...</span>';
                // Try one more time after longer delay
                setTimeout(() => {
                  if (typeof window.hasAdminKey === 'function') {
                    updateAdminKeyStatus();
                  } else {
                    statusEl.innerHTML = '<span style="color: #ef4444;"> Admin key functions not loaded  please refresh the page</span>';
                  }
                }, 1000);
              }
            }, 100);
            return;
          }
          
          const hasKey = window.hasAdminKey();
          if (hasKey) {
            const key = window.getAdminKey();
            statusEl.innerHTML = `<span style="color: #10b981;"> Admin key set</span> (${key.length} characters, stored in session)`;
          } else {
            statusEl.innerHTML = '<span style="color: #ef4444;"> Admin key not set  tracking actions disabled</span>';
          }
        }

        // Update status on load
        if (typeof window !== 'undefined' && document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', updateAdminKeyStatus);
        } else {
          updateAdminKeyStatus();
        }
      </script>
    </div>

    <div class="config-panel" style="margin-top: 2rem;">
      <h2>Reporting</h2>
      <div class="info-box" style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #856404;"><strong>Generate Reports:</strong> Create comprehensive PDF reports containing all audit data, charts, and pillar score definitions.</p>
      </div>
      <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
        <button class="btn" onclick="try { console.log('[PDF] Button clicked!'); generatePDFReport(); } catch(e) { console.error('[PDF] Error in onclick:', e); alert('Error generating PDF: ' + e.message); }" id="generatePdfBtn" style="background: #dc2626; color: white; border-color: #dc2626;" title="Generate a comprehensive PDF report containing all audit data, charts, pillar scores, definitions, and metrics. The report will include all sections from the dashboard.">
           Generate PDF Report
        </button>
        <div id="pdfStatus" style="font-size: 0.85rem; color: #666; margin-left: 0.5rem;"></div>
      </div>
    </div>
      </section>

      <!-- Authority Panel -->
      <section class="aigeo-panel" data-panel="authority">
        <!-- Authority - Behaviour & Ranking section will be inserted here by JS -->
      </section>

      <!-- Overview Panel -->
      <section class="aigeo-panel is-active" data-panel="overview">

      <!-- Five-Pillar Framework (collapsed by default) -->
      <div class="calculation-explanation collapsed" id="frameworkExplanation">
        <div class="calculation-header" onclick="toggleFrameworkExplanation()">
          <h4> Five-Pillar Framework</h4>
          <span class="calculation-toggle" id="frameworkToggle"></span>
        </div>
        <div class="calculation-content collapsed" id="frameworkContent">
          <p style="margin-top: 0; color: #555; line-height: 1.6; margin-bottom: 1rem;">
            This audit analyzes <strong>www.alanranger.com</strong> as a global entity using a five-pillar framework to assess AI-powered search visibility, entity recognition, and SERP behavior. Each pillar is scored 0-100 and assigned a RAG (Red/Amber/Green) status based on performance thresholds.
          </p>
          <p style="color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
            <strong>Data Sources:</strong> Scores are calculated using data from Google Search Console API (impressions, clicks, position, queries), Google Business Profile API (ratings, reviews, locations, service areas), schema markup validation, backlink CSV upload, and Trustpilot reviews snapshot.
          </p>
          <p style="color: #555; line-height: 1.6; margin-bottom: 0;">
            <strong>Score Calculation:</strong> The GAIO score combines five weighted pillars: Authority (30%: Behaviour 40% + Ranking 20% + Backlinks 20% + Reviews 20%), Content/Schema (25%: Foundation schemas 30% + Rich Results 35% + Coverage 20% + Diversity 15%), Visibility (20%: average position mapping), Local Entity (15%: NAP consistency + knowledge panel + locations), and Service Area (10%: service areas count with NAP multiplier). Brand & Entity Overlay and AI Summary Likelihood are overlay metrics that do not affect the GAIO score but provide additional insights. Scores are normalized to 0-100 scale with thresholds: Green (70), Amber (40-69), Red (&lt;40). Money pages behaviour is tracked separately and stored per audit, so you can see whether Authority improvements are coming from better CTR on commercial pages or from broader site-wide changes.
          </p>
        </div>
      </div>

      <div class="calculation-explanation collapsed" id="calculationExplanation">
        <div class="calculation-header" onclick="toggleCalculationExplanation()">
          <h4> Detailed Calculation Explanation</h4>
          <span class="calculation-toggle" id="calculationToggle"></span>
        </div>
        <div class="calculation-content collapsed" id="calculationContent">
          <h5>1. Visibility</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Primary: Average position from Google Search Console (1-40 mapped to 100-10)</li>
            <li>Formula: <code>posScore = 100 - ((clampedPosition - 1) / 39) * 90</code> where clampedPosition is constrained to 1-40</li>
            <li>Visibility score = clamped posScore (0-100)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: impressions, clicks, average position, CTR</li>
            <li>Real-time data from GSC API for the selected date range</li>
          </ul>
          <p><strong>Data Checked:</strong> Search Console impressions/clicks, average position, CTR, ranking distribution.</p>

          <h5>2. Authority (E-E-A-T)</h5>
          <p><strong>What Authority Represents:</strong></p>
          <p>Authority is not "how good the content is", it's "how much the outside world and searchers trust and choose you". It approximates E-E-A-T using four ingredients:</p>
          <ul>
            <li><strong>Behavioural signals</strong>  do people click your results when they see them?</li>
            <li><strong>Ranking strength</strong>  how often do you show near the top of organic results?</li>
            <li><strong>Off-site credibility</strong>  backlinks from other domains (Phase 3)</li>
            <li><strong>Reputation & reviews</strong>  ratings and review volume across GBP + website</li>
          </ul>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Four-component model: Behaviour (40%), Ranking (20%), Backlinks (20%), Reviews (20%)</li>
            <li>Formula: <code>authority = 0.4 * behaviourScore + 0.2 * rankingScore + 0.2 * backlinkScore + 0.2 * reviewScore</code></li>
            <li>Each sub-score is normalized to 0-100, then combined with weights above</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>2.1 Behaviour Score (40%):</strong></p>
          <ul>
            <li>From Google Search Console: Only uses queries where average position  20</li>
            <li>Computes: ctrAll = CTR for all ranking queries, ctrTop10 = CTR for impressions where position  10</li>
            <li>Maps: ctrAll 0-5%  0-100 (values >5% capped at 100), ctrTop10 0-10%  0-100</li>
            <li>Combines: <code>BehaviourScore = 0.5 * score(ctrAll) + 0.5 * score(ctrTop10)</code></li>
            <li>This stops long-tail / low-rank pages dragging the whole site down</li>
          </ul>
          <p><strong>2.2 Ranking Score (20%):</strong></p>
          <ul>
            <li>From GSC, again only for position  20</li>
            <li>avgPos = impression-weighted average position</li>
            <li>top10Share = % of impressions where position  10</li>
            <li>posScore = map(avgPos, 1  100, 20  0) (clamped)</li>
            <li>top10Score = top10Share as a % (0-100)</li>
            <li>Combines: <code>RankingScore = 0.5 * posScore + 0.5 * top10Score</code></li>
          </ul>
          <p><strong>2.3 Review Score (20%):</strong></p>
          <ul>
            <li>Inputs: From GBP API (gbpRating 0-5, gbpReviewCount) and Trustpilot snapshot (siteRating 4.6, siteReviewCount 610)</li>
            <li>Per source: ratingScore = (rating/5)*100, countScore = min(reviewCount, 500)/500*100</li>
            <li>sourceScore = 0.6 * ratingScore + 0.4 * countScore</li>
            <li>Final: <code>ReviewScore = 0.6 * gbpSourceScore + 0.4 * siteSourceScore</code></li>
            <li>If one source missing, falls back to the other; if both missing, uses neutral default (50)</li>
          </ul>
          <p><strong>2.4 Backlink Score (20%):</strong></p>
          <ul>
            <li>Phase 3  using CSVs: refDomainCount, qualityDomains, qualityRatio</li>
            <li>countScore = map(refDomainCount, 0  0, N  100) where N is cap (e.g. 150-200)</li>
            <li>qualityScore = qualityRatio * 100</li>
            <li>Combines: <code>BacklinkScore = 0.5 * countScore + 0.5 * qualityScore</code></li>
            <li>Currently placeholder (50) until Phase 3 is implemented</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API (CTR, position, impressions by position bucket)</li>
            <li>Google Business Profile API (ratings, review count)</li>
            <li>Trustpilot reviews (historic snapshot: rating 4.6, count 610)</li>
            <li>Backlink CSV upload (referring domains, quality metrics) - Phase 3</li>
          </ul>
          <p><strong>How to Improve Authority:</strong></p>
          <ul>
            <li><strong>Behaviour:</strong> Improve titles/meta descriptions on pages already in top 10-20. Focus on high-impression queries in GSC.</li>
            <li><strong>Ranking:</strong> Push more core pages into top 10 (content refreshes, internal links, stronger schema).</li>
            <li><strong>Reviews:</strong> Keep growing GBP and Trustpilot reviews; higher rating and more volume both help.</li>
            <li><strong>Backlinks:</strong> Acquire more distinct linking domains, favouring sites with real traffic/authority (Phase 3).</li>
          </ul>

          <h5>3. Local Entity</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li><strong>Primary method (when Business Profile data available):</strong> Base score from NAP consistency (0-100), with bonuses:
              <ul>
                <li>Knowledge panel detected: +10 points</li>
                <li>At least one location: +5 points</li>
                <li>Final score capped at 100</li>
              </ul>
            </li>
            <li><strong>Fallback method (no Business Profile data):</strong> Derived from search performance:
              <ul>
            <li>Formula: <code>localEntity = 60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50)</code></li>
                <li>Uses position score and CTR score from GSC</li>
              </ul>
            </li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li> <strong>Primary:</strong> Google Business Profile API: NAP consistency score, knowledge panel detection, locations count</li>
            <li> <strong>Fallback:</strong> Google Search Console API: position, CTR (when Business Profile data unavailable)</li>
          </ul>
          <p><strong>Data Checked:</strong> NAP consistency percentage, knowledge panel presence, locations count, LocalBusiness schema presence, entity recognition signals.</p>

          <h5>4. Service Area</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li><strong>Primary method (when Business Profile data available):</strong>
              <ul>
                <li>Base score from service areas count: 0 areas = 0, 1 area = 12.5, 2 areas = 25, ..., 8+ areas = 100</li>
                <li>Formula: <code>baseScore = min(serviceAreasCount * 12.5, 100)</code></li>
                <li>NAP consistency multiplier applied: <code>serviceArea = baseScore * (napConsistencyScore / 100)</code></li>
                <li>If NAP consistency is low, service area score is reduced proportionally</li>
              </ul>
            </li>
            <li><strong>Fallback method (no Business Profile data):</strong> Derived from Local Entity score (when Business Profile unavailable)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li> <strong>Primary:</strong> Google Business Profile API: service areas count, NAP consistency score</li>
            <li> <strong>Fallback:</strong> Derived from Local Entity (when Business Profile data unavailable)</li>
          </ul>
          <p><strong>Data Checked:</strong> Service areas count from Business Profile, NAP consistency percentage, geographic coverage signals.</p>

          <h5>5. Content/Schema</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Weighted calculation based on four components: Foundation schemas, Rich Results, Coverage, and Diversity</li>
            <li>Formula: <code>contentSchema = (Foundation  30%) + (Rich Results  35%) + (Coverage  20%) + (Diversity  15%)</code></li>
            <li><strong>Foundation Schemas (30%):</strong> Organization, Person, WebSite, BreadcrumbList presence. Score = (types present / 4)  100</li>
            <li><strong>Rich Results (35%):</strong> Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList eligibility. Score = (eligible types / 11)  100</li>
            <li><strong>Coverage (20%):</strong> Pages with schema / total pages. Score = coverage percentage</li>
            <li><strong>Diversity (15%):</strong> Number of unique schema types across site. Score = min((unique types / 15)  100, 100)</li>
            <li><strong>Data Source:</strong> Schema audit API (crawls actual pages for JSON-LD markup)</li>
            <li>Uses real schema coverage from CSV-based audit (when available)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Schema Audit API: CSV-based domain crawl of all site URLs</li>
            <li>Schema markup detection and type counting</li>
            <li>Foundation schema presence detection (Organization, Person, WebSite, BreadcrumbList)</li>
            <li>Rich result eligibility detection (Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList)</li>
          </ul>
          <p><strong>Data Checked:</strong> Total pages scanned, pages with schema, schema coverage percentage, schema types present (Organization, Person, LocalBusiness, Article, Course, Event, FAQ, HowTo, etc.), missing schema types, rich result eligibility (Article, Event, FAQ, Product, LocalBusiness, Course, Review, HowTo).</p>

          <h5>6. Brand & Entity Overlay</h5>
          <p><strong>What Brand Overlay Represents:</strong></p>
          <p>Brand & Entity Overlay measures how strongly your brand is recognized in search and how well entity signals support AI understanding. It combines branded search performance, review signals, and entity recognition. <strong>Note:</strong> This is an overlay metric and does not directly affect the GAIO score calculation.</p>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li><strong>Brand Search Component (40% of brand search score):</strong>
              <ul>
                <li>Brand Query Share: % of impressions that are branded queries (30%+ share = 100 points)</li>
                <li>Brand CTR: Click-through rate on branded queries (40%+ CTR = 100 points)</li>
                <li>Brand Avg Position: Average position for branded queries (normalized 1-10  100-0)</li>
                <li>Formula: <code>brandSearchScore = 0.4 * shareScore + 0.3 * ctrScore + 0.3 * posScore</code></li>
              </ul>
            </li>
            <li><strong>Combined Score:</strong>
              <ul>
                <li>Formula: <code>brandOverlay = 0.4 * brandSearchScore + 0.3 * reviewScore + 0.3 * entityScore</code></li>
                <li>Label thresholds: &lt;40 = Weak, 40-69 = Developing, 70 = Strong</li>
              </ul>
            </li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: Branded query identification, brand impressions, brand clicks, brand CTR, brand average position</li>
            <li>Google Business Profile API: Review score (reused from Authority pillar)</li>
            <li>Local Entity score: Entity recognition signals (reused from Local Entity pillar)</li>
          </ul>
          <p><strong>Data Checked:</strong> Brand query share (% of total impressions), branded CTR, average brand position, review signals, entity recognition strength.</p>

          <h5>7. AI Summary Likelihood</h5>
          <p><strong>What AI Summary Likelihood Represents:</strong></p>
          <p>AI Summary Likelihood indicates how likely AI systems (like Google's AI Overviews) are to provide accurate, comprehensive summaries about your brand and content. It combines snippet readiness, visibility, and brand strength signals.</p>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Three-component model: Snippet Readiness (50%), Visibility (30%), Brand & Entity (20%)</li>
            <li>Formula: <code>aiSummary = 0.5 * snippetReadinessScore + 0.3 * visibilityScore + 0.2 * brandScore</code></li>
            <li>Label thresholds: &lt;50 = Low, 50-69 = Medium, 70 = High</li>
            <li>Uses same RAG bands as GAIO Score (70 green, 50 amber, &lt;50 red)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Snippet Readiness score: From snippet readiness gauge (FAQ/HowTo/Article blocks, schema, rich results)</li>
            <li>Visibility score: Current Visibility pillar score (average position from GSC)</li>
            <li>Brand score: Brand & Entity Overlay score</li>
          </ul>
          <p><strong>Data Checked:</strong> Snippet-friendly content blocks, schema markup for rich results, average search position, branded search performance, entity recognition.</p>

          <div class="note">
            <strong>Current Implementation Status:</strong><br>
            <strong> Fully Implemented:</strong><br>
             Google Search Console API integration (real-time data) - Total clicks, Total impressions, Average position, CTR calculation, Top queries, Brand query classification<br>
             Schema markup validation and analysis - Full site crawl, coverage analysis, type diversity, rich result eligibility (11 types), foundation schema detection<br>
             Backlink quality/quantity analysis - CSV upload support, domain rating, referring domains tracking<br>
             Review aggregation - Trustpilot integration (snapshot), Google Business Profile reviews, review score calculation<br>
             Knowledge panel tracking - Detection and scoring (part of Local Entity pillar)<br>
             Local pack visibility metrics - Service Area pillar with NAP consistency, location coverage<br>
             SERP feature detection - Rich result eligibility checks, snippet readiness scoring<br>
             Brand overlay metrics - Brand query share, branded CTR, brand position, entity strength<br>
             AI Summary Likelihood - Composite score based on snippet readiness, visibility, and brand signals<br>
             Historical trend tracking - Supabase integration for all pillars, trend charts with segmented Authority data<br>
             Shareable audit links - Public sharing with 30-day expiration<br><br>
            <strong>Future Enhancements:</strong><br>
             Real-time SERP feature monitoring and alerts<br>
             Advanced backlink analysis with automated discovery<br>
             Competitive analysis and benchmarking<br>
             Automated action recommendations engine<br>
             Export capabilities (PDF, CSV reports)<br><br>
            <strong>Note:</strong> All five core pillars (Authority, Content/Schema, Visibility, Local Entity, Service Area) are fully implemented with real data sources. Brand & Entity and AI Summary Likelihood are overlay metrics that enhance the core scoring without changing the GAIO score calculation.
          </div>
        </div>
      </div>

      <!-- Date Range Selector -->
      <div class="config-panel" style="margin-bottom: 2rem; background: #f8f9fa; padding: 1.5rem; border-radius: 8px; border: 1px solid #e2e8f0;">
        <div class="form-group">
          <label for="dateRange">Date Range</label>
          <div class="date-range-selector">
            <button class="date-range-btn active" onclick="setDateRange(30)" data-days="30" title="Analyze search performance data from the last 30 days">Last 30 Days</button>
            <button class="date-range-btn" onclick="setDateRange(60)" data-days="60" title="Analyze search performance data from the last 60 days">Last 60 Days</button>
            <button class="date-range-btn" onclick="setDateRange(90)" data-days="90" title="Analyze search performance data from the last 90 days">Last 90 Days</button>
            <button class="date-range-btn" onclick="setDateRange(120)" data-days="120" title="Analyze search performance data from the last 120 days">Last 120 Days</button>
            <button class="date-range-btn" onclick="setDateRange(180)" data-days="180" title="Analyze search performance data from the last 6 months (180 days)">Last 6 Months</button>
            <button class="date-range-btn" onclick="setDateRange(365)" data-days="365" title="Analyze search performance data from the last 12 months (365 days)">Last 12 Months</button>
            <button class="date-range-btn" onclick="setDateRange(540)" data-days="540" title="Analyze search performance data from the last 18 months (540 days)">Last 18 Months</button>
            <button class="date-range-btn" onclick="showCustomDateRange()" id="customDateBtn" title="Set a custom date range for analysis (enter number of days)">Custom</button>
        </div>
          <input type="number" id="dateRange" value="30" min="1" style="display: none;">
          <div id="customDateRange" style="display: none; margin-top: 0.5rem;">
            <input type="number" id="customDays" placeholder="Enter days" min="1" style="width: 150px; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px;">
            <button class="btn btn-small" onclick="applyCustomDateRange()" style="margin-left: 0.5rem; padding: 0.5rem 1rem;" title="Apply the custom date range you entered">Apply</button>
      </div>
          <div class="help-text">Analysis period for historical data</div>
      </div>
    </div>

      <div class="dashboard-grid" id="pillarCards"></div>

      <div class="section-break"></div>

      <div class="metrics-section">
        <h3 style="color: var(--brand-orange); margin-bottom: 0.5rem;">Key Performance Indicators</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Core metrics from Google Search Console showing overall search performance for the entity. <strong>Note:</strong> Small differences from live GSC may occur due to data processing delays (up to 48 hours) and exact date range calculations.</p>
        <div class="metrics-grid" id="metricsGrid"></div>
      </div>

      <div class="section-break"></div>

      <div class="dashboard-two-column">
        <div class="chart-container large">
          <h3>Pillar Scores Overview</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Radar chart showing current performance across all five pillars. The larger the area, the stronger your overall entity recognition.</p>
          
          <!-- Audit Timestamp for Radar Chart -->
          <div id="radarChartTimestamp" style="background: #fff3cd; padding: 0.5rem 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #f59e0b; font-size: 0.8rem; color: #856404; display: none;">
            <strong>Current data as of:</strong> <span id="radarChartAuditTime">-</span> <span style="color: #666; font-size: 0.75rem;">(Not historical - reflects last audit scan)</span>
          </div>
          
          <canvas id="radarChart"></canvas>
        </div>

        <div class="snippet-readiness-gauge">
          <h3 style="margin-top: 0; color: var(--brand-orange);">Snippet Readiness Gauge</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Snippet readiness summarises how likely your content is to be lifted into featured snippets and AI answers. It reflects three ingredients: snippet-friendly answer blocks, suitable schema (FAQ/HowTo/Article/Course/Event) and existing rich-result behaviour.</p>
          
          <!-- Audit Timestamp for Snippet Readiness -->
          <div id="snippetReadinessTimestamp" style="background: #fff3cd; padding: 0.5rem 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #f59e0b; font-size: 0.8rem; color: #856404; display: none;">
            <strong>Current data as of:</strong> <span id="snippetReadinessAuditTime">-</span> <span style="color: #666; font-size: 0.75rem;">(Not historical - reflects last audit scan)</span>
            </div>
          
          <div id="snippetReadinessExplanation" style="display: none; background: #fde68a; border-left: 4px solid #f59e0b; padding: 1rem; margin-bottom: 1rem; border-radius: 4px; font-size: 0.85rem; color: #78350f;">
            <strong id="explanationTitle" style="color: #78350f;">Top 5 Actions to Improve Snippet Readiness</strong>
            <p style="margin: 0.5rem 0; color: #78350f;">Prioritized actions based on your current scores and their impact on overall snippet readiness:</p>
            <ol id="topActionsList" style="margin: 0.5rem 0 0 1.5rem; padding: 0; list-style-type: decimal;">
              <!-- Top 5 actions will be populated dynamically -->
            </ol>
            </div>
          
          <!-- Overall Combined Score -->
          <div style="text-align: center; margin-bottom: 1.5rem;">
            <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">Overall Snippet Readiness</div>
            <div id="snippetReadinessScore" style="font-size: 3rem; font-weight: 700; color: var(--brand-orange); line-height: 1;">0</div>
            <div id="gaugeStatus" style="font-size: 0.9rem; color: #666; margin-top: 0.25rem;">Calculating...</div>
          </div>
          
          <!-- Pie Chart Container -->
          <div style="display: flex; align-items: center; justify-content: center; gap: 1.5rem; flex-wrap: wrap;">
            <div style="flex: 2; min-width: 400px; max-width: 500px;">
              <canvas id="snippetReadinessPieChart"></canvas>
            </div>
            <div style="flex: 1; min-width: 180px; max-width: 250px;">
              <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--brand-dark);">Component Breakdown:</div>
              <div id="snippetReadinessLegend" style="display: flex; flex-direction: column; gap: 0.5rem;">
                <!-- Legend will be populated by JavaScript -->
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="section-break"></div>

      <div class="chart-container">
        <h3>Score Trends</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Historical performance tracking for all five pillars (Local Entity, Service Area, Authority, Visibility, Content/Schema) over the selected date range.</p>
        <div id="trendAuthorityModeToggle" class="authority-mode-toggle" style="margin-bottom: 1rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; display: none;">
          <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
            <span style="font-weight: 600; color: #666;">Authority Mode:</span>
            <button id="trend-mode-all" class="authority-mode-btn" data-mode="all" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: #10b981; color: white; cursor: pointer; font-size: 0.75rem;">
              All pages
            </button>
            <button id="trend-mode-nonEducation" class="authority-mode-btn" data-mode="nonEducation" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
              Exclude education
            </button>
            <button id="trend-mode-money" class="authority-mode-btn" data-mode="money" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
              Money pages only
            </button>
          </div>
        </div>
        <div id="trendSummaryRow" class="trend-summary-row"></div>
        <canvas id="trendChart"></canvas>
      </div>
      </section>

      <!-- Money Pages Panel -->
      <section class="aigeo-panel" data-panel="money">
        <!-- Money Pages content will be inserted here by JS -->
      </section>

      <!-- Ranking & AI Panel -->
      <section class="aigeo-panel" data-panel="ranking">
        <div class="card card--section-header">
          <h2>Ranking &amp; AI Visibility</h2>
          <p class="ranking-intro">
            Keyword-level view of how search engines and AI systems see you. This is an overlay on the
            <strong>Visibility</strong>, <strong>Authority</strong>, <strong>Content/Schema</strong> and
            <strong>Local Entity</strong> pillars  it does not change their weights or scores.
          </p>

          <ul class="ranking-intro-bullets">
            <li><strong>Classic rankings</strong>  Visibility + Authority (Ranking component).</li>
            <li><strong>AI Overviews &amp; citations</strong>  Content/Schema + Authority.</li>
            <li><strong>Local packs</strong>  Local Entity + Service Area.</li>
          </ul>

          <div class="ranking-header-actions" style="display: flex; align-items: center; gap: 1rem;">
            <button id="ranking-ai-refresh" class="btn btn-secondary" type="button">
              Run ranking &amp; AI check
            </button>
            <button id="ranking-gsc-refresh" class="btn btn-secondary" type="button" style="background: #10b981; color: white; border: 1px solid #10b981; font-weight: 600; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;" title="Refresh CTR & Impressions from Google Search Console (no API costs)">
              Refresh GSC Data
            </button>
            <button id="edit-keywords-btn" class="btn btn-secondary" type="button" style="background: #2563eb; color: white; border: 1px solid #2563eb; font-weight: 600; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">
              Edit Keywords
            </button>
            <span id="ranking-ai-last-run" class="ranking-ai-last-run"></span>
          </div>
        </div>

        <!-- Edit Keywords Modal -->
        <div id="edit-keywords-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 10000; align-items: center; justify-content: center;">
          <div style="background: white; border-radius: 8px; padding: 2rem; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
              <h3 style="margin: 0; font-size: 1.5rem; color: #1e293b;">Edit Keywords</h3>
              <button id="edit-keywords-close" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #64748b; padding: 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;">&times;</button>
            </div>
            
            <!-- Warning and Instructions Box -->
            <div style="background: #fef3c7; border: 1px solid #fbbf24; border-radius: 6px; padding: 1rem; margin-bottom: 1.5rem;">
              <div style="display: flex; align-items: start; gap: 0.75rem;">
                <div style="color: #d97706; font-size: 1.25rem; line-height: 1; margin-top: 0.125rem;"></div>
                <div style="flex: 1;">
                  <div style="font-weight: 600; color: #92400e; font-size: 0.9rem; margin-bottom: 0.5rem;">Important: Data Loss Warning</div>
                  <ul style="margin: 0; padding-left: 1.25rem; color: #78350f; font-size: 0.85rem; line-height: 1.6;">
                    <li><strong>Removing keywords:</strong> All historical data (rankings, AI citations, SERP features) will be permanently deleted.</li>
                    <li><strong>Changing/renaming keywords:</strong> Treated as removing the old keyword and adding a new one. All data is lost and cannot be recovered.</li>
                    <li><strong>New keywords:</strong> Will appear in the list but won't have data until you run a "Ranking & AI check".</li>
                  </ul>
                  <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #fbbf24; color: #78350f; font-size: 0.85rem;">
                    <strong>Instructions:</strong> Enter one keyword per line. Changes will be saved immediately. Keywords will be updated on the next Ranking & AI check.
                    <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                      <label for="csv-upload" style="display: inline-flex; align-items: center; padding: 0.375rem 0.75rem; background: #3b82f6; color: white; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                         Upload CSV
                        <input type="file" id="csv-upload" accept=".csv,.txt" style="display: none;" />
                      </label>
                      <span style="color: #78350f; font-size: 0.8rem;">Upload a CSV file (one keyword per line, first column)</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <textarea id="edit-keywords-textarea" style="width: 100%; min-height: 300px; padding: 0.75rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.9rem; font-family: inherit; resize: vertical; box-sizing: border-box; color: #1e293b; background: white;"></textarea>
            <div style="display: flex; justify-content: flex-end; gap: 0.75rem; margin-top: 1.5rem;">
              <button id="edit-keywords-cancel" style="padding: 0.5rem 1rem; background: #f1f5f9; color: #475569; border: 1px solid #cbd5e1; border-radius: 4px; cursor: pointer; font-size: 0.9rem;">Cancel</button>
              <button id="edit-keywords-save" style="padding: 0.5rem 1rem; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; font-weight: 600;">Save Keywords</button>
            </div>
            <div id="edit-keywords-status" style="margin-top: 1rem; font-size: 0.85rem; color: #475569; min-height: 1.5rem;"></div>
          </div>
        </div>

        <!-- Section B: Metric pills row -->
        <div class="ranking-metric-pills">
          <div class="metric-pill metric-pill--neutral" id="ranking-card-tracked">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">Tracked keywords</div>
            <div class="metric-pill-status" data-field="status">Info only</div>
            <div class="metric-pill-footer">Used across Visibility &amp; Authority behaviour/ranking.</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-tracked')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-tracked-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-ai-coverage">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">AI Overview coverage</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Pillars: Visibility, Content/Schema</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-ai-coverage')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-ai-coverage-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-ai-citations">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">AI citations (alanranger.com)</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Pillars: Authority (Reviews), Content/Schema</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-ai-citations')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-ai-citations-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-top10">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">Top-10 rank coverage</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Pillars: Visibility, Authority (Ranking)</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-top10')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-top10-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-serp-features">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">SERP feature coverage</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Pillars: Content/Schema, Local Entity</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-serp-features')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-serp-features-details"></div>
          </div>
        </div>

        <!-- Global Insights & actions and Visibility metrics side by side (underneath summary tiles) -->
        <div class="ranking-cards-side-by-side">
          <!-- Global Insights & actions (all tracked keywords) -->
          <section class="card card--insights" id="ranking-ai-insights-card-global">
            <div class="card-header">
              <h2>Insights &amp; actions (all tracked keywords)</h2>
              <p class="card-subtitle">
                Recommendations based on how your tracked keywords currently rank in classic search and appear in AI Overviews.
                These insights are global, not tied to the selected keyword.
              </p>
            </div>
            <div class="card-pill-container" id="ranking-ai-insights-list-global">
              <!-- Content populated by renderRankingAiInsights -->
            </div>
          </section>

          <!-- Tracked keyword visibility metrics (DataForSEO only - not part of GAIO pillars) -->
          <div class="ranking-visibility-metrics-section" id="ranking-visibility-metrics">
            <div class="card" style="background: rgba(204, 255, 255, 0.15); border-left: 4px solid #CCFFFF;">
            <div class="card-header">
              <h4 style="font-size: 14pt !important; margin-bottom: 0.5rem;">Tracked keyword visibility (DataForSEO)</h4>
              <div style="font-size: 12pt !important; color: #666; margin-bottom: 0.75rem; line-height: 1.5;">
                <p style="margin-bottom: 0.5rem;">
                  These metrics use DataForSEO live rankings and Google Ads search volume for your tracked keyword set only.
                </p>
                <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                  <li><strong>Demand-weighted avg position</strong>  average Google rank where each keyword is weighted by its monthly search volume (high-demand terms pull this number more).</li>
                  <li><strong>Unweighted avg position</strong>  simple average rank across all tracked keywords, with each keyword counted equally.</li>
                </ul>
                <p style="margin-top: 0.5rem; margin-bottom: 0;">
                  These are diagnostic metrics for your tracked set; the main Visibility and Authority pillar scores are still calculated from full Google Search Console data across all queries and pages.
                </p>
              </div>
              <div style="display: flex; gap: 2rem; flex-wrap: wrap; font-size: 14pt !important; align-items: baseline;">
                <div>
                  <strong style="font-size: 13pt !important;">Demand-weighted avg position:</strong>
                  <span id="ranking-avg-position-weighted" style="font-weight: bold; color: #0284c7; font-size: 16pt !important; margin-left: 0.5rem;"></span>
                  <span title="Average rank for tracked keywords where each rank is weighted by the keyword's monthly search volume from DataForSEO." style="margin-left: 0.25rem; opacity: 0.6; cursor: help; font-size: 12pt !important;"></span>
                </div>
                <div style="font-size: 12pt !important; color: #666;">
                  <strong>Unweighted avg position:</strong>
                  <span id="ranking-avg-position-unweighted" style="font-weight: normal; margin-left: 0.5rem;"></span>
                  <span title="Simple average rank for all tracked keywords from DataForSEO, each keyword counted once." style="margin-left: 0.25rem; opacity: 0.6; cursor: help;"></span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Keyword Priority Matrix (Impact  Difficulty) - Full width below side-by-side cards -->
        <div class="ranking-priority-matrix-section" id="ranking-priority-matrix-section" style="display: none; width: 100%; clear: both; float: none;">
          <div class="card" style="background: rgba(204, 255, 255, 0.15); border-left: 4px solid #CCFFFF; padding: 1.5rem;">
            <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Keyword Priority  Impact & Difficulty</h3>
            <p style="margin: 0 0 1rem 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
              Uses search volume share and current rank to surface the highest-impact keywords to work on.
              Impact is driven mainly by search volume share (global, not filter-relative) and opportunity score. Difficulty reflects current rank bucket (page 1 vs page 2+).
            </p>
            <div id="ranking-keyword-priority-matrix" style="background: #f8fafc; padding: 1rem; border-radius: 8px;">
              <!-- 3x3 grid rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Domain Strength (manual monthly snapshots) -->
        <div class="ranking-domain-strength-section" id="ranking-domain-strength-section" style="width: 100%; clear: both; float: none; margin: 1.5rem 0;">
          <div class="card" style="background: rgba(204, 255, 255, 0.15); border-left: 4px solid #CCFFFF; padding: 1.5rem;">
            <div style="display: flex; align-items: center; justify-content: space-between; gap: 1rem; flex-wrap: wrap;">
              <div>
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">
                  Domain Strength (Google  DataForSEO Labs)
                  <span
                    class="domain-strength-help"
                    title="Domain Strength (0100) is a composite score based on DataForSEO Labs. It combines:&#10; Estimated organic traffic value (visibility)&#10; Total organic keywords (breadth)&#10; Share of keywords ranking in Googles top 10 (quality)&#10;We calculate it monthly and store history so you can see trends over time."
                  >?</span>
                </h3>
                <p style="margin: 0; font-size: 0.9rem; color: #64748b; line-height: 1.6;">
                  Manual monthly snapshots based on DataForSEO Labs <code style="font-size: 0.85rem;">domain_rank_overview</code>.
                  Uses visibility (ETV), breadth (ranking keywords), and top10 share to produce a 0100 score.
                </p>
              </div>
              <div style="display: flex; gap: 0.75rem; align-items: center;">
                <button id="domain-strength-run-btn" class="btn btn-secondary" type="button">
                  Run Domain Strength Snapshot (Google)
                </button>
              </div>
            </div>

            <!-- Full-page progress overlay -->
            <div id="domain-strength-overlay" class="domain-strength-overlay">
              <div class="domain-strength-overlay-content">
                <div class="spinner"></div>
                <h3>Running Domain Strength Snapshot</h3>
                <p id="domain-strength-overlay-status">Fetching domain data from DataForSEO...</p>
              </div>
            </div>

            <!-- Completion modal -->
            <div id="domain-strength-completion-modal" class="domain-strength-overlay" style="display: none;">
              <div class="domain-strength-overlay-content" style="max-width: 500px;">
                <h3 style="margin: 0 0 1rem 0; font-size: 1.5rem; font-weight: 700; color: #1e293b;"> Snapshot Complete</h3>
                <div id="domain-strength-completion-stats" style="text-align: left; margin: 1.5rem 0;">
                  <!-- Stats will be inserted here -->
                </div>
                <button id="domain-strength-completion-close" class="btn btn-primary" style="margin-top: 1rem; width: 100%;">Close</button>
              </div>
            </div>

            <div class="domain-strength-summary-row">
              <div class="domain-strength-summary-card" id="domain-strength-summary-card">
                <div style="color:#64748b; font-size:0.95rem;">Loading domain strength</div>
              </div>
              <div style="font-size: 0.875rem; color: #64748b; line-height: 1.6;">
                <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #475569;">Understanding Domain Strength:</p>
                <ul style="margin: 0; padding-left: 1.25rem; list-style-type: disc;">
                  <li style="margin-bottom: 0.25rem;"><strong>Strength score (0-100):</strong> Composite metric combining estimated organic traffic value (visibility), total organic keywords (breadth), and share of keywords ranking in Google's top 10 (quality).</li>
                  <li style="margin-bottom: 0.25rem;"><strong>Band:</strong> Qualitative classification: Very weak (0-19), Weak (20-39), Moderate (40-59), Strong (60-79), Very strong (80-100).</li>
                  <li style="margin-bottom: 0.25rem;"><strong>ETV:</strong> Estimated Traffic Value in USD. DataForSEO's estimate of monthly organic traffic value based on keyword rankings and search volume.</li>
                  <li style="margin-bottom: 0.25rem;"><strong>Top-10 keywords:</strong> Number of keywords ranking in Google's top 10 positions. Higher counts indicate broader keyword coverage.</li>
                  <li style="margin-bottom: 0.25rem;"><strong>Change:</strong> Change in Strength score compared to the previous snapshot. Positive values (green ) indicate improvement.</li>
                  <li><strong>12-month trend:</strong> Visual graph showing Strength score over the last 12 months. Each point represents a monthly snapshot.</li>
                </ul>
              </div>
            </div>

            <div id="domain-strength-run-status" style="margin-top: 0.75rem; font-size: 0.875rem; color: #64748b;"></div>
            <h3 style="margin-top: 1.5rem; margin-bottom: 1rem; font-size: 1.25rem; font-weight: 600; color: #1e293b;">Competitors</h3>
            <div class="ranking-table-wrapper" style="margin-top: 1rem; max-height: none;">
              <div style="position: relative; overflow: visible; max-height: 80vh; overflow-y: auto;">
                <table class="ranking-table" id="domain-strength-table" style="position: relative;">
                  <thead id="domain-strength-thead" style="position: sticky; top: 0; z-index: 10; background: #f8fafc;">
                  <tr>
                    <th data-sort="name" class="sortable" title="Domain name or label for this site">
                      <div>Name <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Domain name or label for this site"></div>
                    </th>
                    <th data-sort="segment" class="sortable" title="Category or ownership segment (e.g., 'Your site' for your primary domain, or competitor segment)">
                      <div>Domain type <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Category or ownership segment (e.g., 'Your site' for your primary domain, or competitor segment)"></div>
                    </th>
                    <th data-sort="score" class="sortable" title="Domain Strength score (0-100). Composite metric combining: Estimated organic traffic value (visibility), Total organic keywords (breadth), and Share of keywords ranking in Google's top 10 (quality). Higher scores indicate stronger domain authority.">
                      <div>Strength score <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Domain Strength score (0-100). Composite metric combining: Estimated organic traffic value (visibility), Total organic keywords (breadth), and Share of keywords ranking in Google's top 10 (quality). Higher scores indicate stronger domain authority."></div>
                    </th>
                    <th data-sort="band" class="sortable" title="Qualitative band based on Strength score: Very weak (0-19), Weak (20-39), Moderate (40-59), Strong (60-79), Very strong (80-100)">
                      <div>Band <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Qualitative band based on Strength score: Very weak (0-19), Weak (20-39), Moderate (40-59), Strong (60-79), Very strong (80-100)"></div>
                    </th>
                    <th data-sort="etv" class="sortable" style="text-align:right;" title="Estimated Traffic Value (ETV). DataForSEO's estimate of monthly organic traffic value in USD based on keyword rankings and search volume. Higher values indicate more valuable organic traffic potential.">
                      <div style="text-align:right;">ETV <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Estimated Traffic Value (ETV). DataForSEO's estimate of monthly organic traffic value in USD based on keyword rankings and search volume. Higher values indicate more valuable organic traffic potential."></div>
                    </th>
                    <th data-sort="top10" class="sortable" style="text-align:right;" title="Number of keywords ranking in Google's top 10 positions. Higher counts indicate broader keyword coverage and stronger domain authority across multiple search terms.">
                      <div style="text-align:right; line-height: 1.2;">Top10<br>keywords <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Number of keywords ranking in Google's top 10 positions. Higher counts indicate broader keyword coverage and stronger domain authority across multiple search terms."></div>
                    </th>
                    <th data-sort="change" class="sortable" style="text-align:center;" title="Change in Strength score compared to the previous snapshot. Positive values (green ) indicate improvement, negative values (red ) indicate decline. Shows how domain strength is trending between snapshots.">
                      <div>Change <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Change in Strength score compared to the previous snapshot. Positive values (green ) indicate improvement, negative values (red ) indicate decline. Shows how domain strength is trending between snapshots."></div>
                    </th>
                    <th style="text-align:center;" title="Visual trend graph showing Strength score over the last 12 months. Each point represents a monthly snapshot. Helps identify long-term trends and patterns in domain authority changes.">
                      <div>12month trend</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Visual trend graph showing Strength score over the last 12 months. Each point represents a monthly snapshot. Helps identify long-term trends and patterns in domain authority changes."></div>
                    </th>
                    <th style="text-align:center;" title="Mark this domain as a competitor">
                      <div>Competitor</div>
                    </th>
                  </tr>
                  </tr>
                </thead>
                <tbody id="domain-strength-table-body">
                  <tr><td colspan="9" class="ranking-table-empty">No domain strength snapshots yet. Click "Run Domain Strength Snapshot".</td></tr>
                </tbody>
              </table>
              </div>
            </div>
            <div id="domain-strength-pagination-controls" style="margin-top: 1rem; display: flex; justify-content: space-between; align-items: center; padding-top: 1rem; border-top: 1px solid #e2e8f0; flex-wrap: wrap; gap: 1rem;">
              <div style="font-size: 0.85rem; color: #64748b;">
                <span id="domain-strength-pagination-info">Page 1 of 1  Total: 0</span>
              </div>
              <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  Rows per page:
                  <select id="domain-strength-rows-per-page" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; background: white; cursor: pointer;">
                    <option value="10" selected>10</option>
                    <option value="25">25</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                    <option value="all">All</option>
                  </select>
                </label>
                <button id="domain-strength-pagination-prev" type="button" disabled style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cbd5e1; background: #f1f5f9; cursor: not-allowed; color: #94a3b8; font-weight: 600;">
                  Previous
                </button>
                <button id="domain-strength-pagination-next" type="button" disabled style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cbd5e1; background: #f1f5f9; cursor: not-allowed; color: #94a3b8; font-weight: 600;">
                  Next
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Section C: Filters + full-width table -->
        <div class="ranking-table-section" style="width: 100%; clear: both; float: none;">
          <div class="card">
            <div class="card-header">
              <h3>Keyword rankings &amp; AI usage</h3>
              <p class="card-subtitle ranking-subtitle-tight" style="max-width: 100%; width: 100%;">
                Keyword-level inputs to <strong>Visibility</strong> and the <strong>Authority  Behaviour / Ranking</strong> components. Search volume shows demand for each tracked keyword (Visibility pillar). Combined with AI citations, it also highlights topics where you have strong or weak Authority. AI columns show where <strong>Content/Schema</strong> helps make you a source.
              </p>
            </div>
            <!-- Preset buttons -->
            <div class="ranking-presets-section" style="padding: 1rem 1.5rem; border-bottom: 1px solid #e2e8f0; background: #f8fafc;">
              <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center;">
                <span style="font-size: 0.875rem; font-weight: 600; color: #475569; margin-right: 0.5rem;">Presets:</span>
                <button type="button" class="ranking-preset-btn" data-preset="all" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Reset all filters and restore default sort">
                  All keywords
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="high-impact-money" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Segment: Money | Best rank: 1120 | Search volume: High | Min opportunity:  65 | Sort: Opportunity ">
                  High-impact money
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="ai-overview-not-cited" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="AI Overview: On | AI citation: Not cited | Min opportunity:  50 | Sort: Volume ">
                  AI Overview, not cited
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="brand-safety" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Segment: Brand | Best rank: Not top 3 | Sort: Rank  (worst first)">
                  Brand safety
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="education-growth" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Page type: Blog | Best rank: Not top 3 | Min opportunity:  30 | Sort: Opportunity ">
                  Blog opportunities
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="local-visibility" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Page type: GBP | Best rank: Not top 3 | Min opportunity:  30 | Sort: Opportunity ">
                  Local visibility
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="top-10-opportunities" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Best rank: Not top 3 | Min opportunity:  50 | Sort: Opportunity  | Shows top 10 results">
                  Top 10 opportunities
                </button>
              </div>
              <!-- Criteria chips (shown when preset is active) -->
              <div id="ranking-preset-criteria-chips" style="display: none; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0;">
                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center;">
                  <!-- Chips will be inserted here by JavaScript -->
                </div>
              </div>
            </div>
            <div class="ranking-filters-section" style="padding: 1rem 1.5rem; border-bottom: 1px solid #e2e8f0;">
              <div class="ranking-filter-bar" style="display: flex; flex-wrap: nowrap; gap: 0.75rem; align-items: flex-end; margin-bottom: 0.75rem;">
                <div class="filter-group">
                  <label>Segment:</label>
                  <select id="ranking-filter-segment" class="filter-control">
                    <option value="all">All</option>
                    <option value="brand">Brand</option>
                    <option value="money">Money</option>
                    <option value="education">Education</option>
                    <option value="other">Other</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Best rank:</label>
                  <select id="ranking-filter-rank" class="filter-control">
                    <option value="all">All</option>
                    <option value="top3">Top 3</option>
                    <option value="4-10">410</option>
                    <option value="11-20">1120</option>
                    <option value="21+">21+ / Not ranked</option>
                    <option value="not-top3">Not top 3</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Search volume:</label>
                  <select id="ranking-filter-volume" class="filter-control">
                    <option value="all">All</option>
                    <option value="high">High (200+)</option>
                    <option value="medium">Medium (50-199)</option>
                    <option value="low">Low (1-49)</option>
                    <option value="none">None</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>CTR:</label>
                  <select id="ranking-filter-ctr" class="filter-control">
                    <option value="all">All</option>
                    <option value="high">High (5%)</option>
                    <option value="medium">Medium (2-4.9%)</option>
                    <option value="low">Low (<2%)</option>
                    <option value="none">No data</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Opportunity score: <span title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10; Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10; Classic ranking strength (page 1 vs page 2+ and current position).&#10; AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first.&#10;&#10;Bands: Low <40  Medium 4069  High 70" style="opacity: 0.6; cursor: help;"></span></label>
                  <select id="ranking-filter-opportunity" class="filter-control">
                    <option value="all">All</option>
                    <option value="high">High ( 70)</option>
                    <option value="medium">Medium (4069)</option>
                    <option value="low">Low (< 40)</option>
                  </select>
                </div>
                <div class="filter-group">
                  <label>Min opportunity:</label>
                  <input type="number" id="ranking-filter-min-opportunity" class="filter-control" placeholder="e.g. 65" min="0" max="100" step="1" style="width: 80px;">
                  <div id="ranking-filter-min-opportunity-note" style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem; display: none;">
                    Min opportunity overrides band selection.
                  </div>
                </div>

                <div class="filter-group">
                  <label>AI Overview:</label>
                  <select id="ranking-filter-ai-overview" class="filter-control">
                    <option value="all">All</option>
                    <option value="has">Has AI Overview</option>
                    <option value="no">No AI Overview</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>AI citation:</label>
                  <select id="ranking-filter-ai-citation" class="filter-control">
                    <option value="all">All</option>
                    <option value="cited">Cited in AI</option>
                    <option value="not-cited">Not cited</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Page type:</label>
                  <select id="ranking-filter-page-type" class="filter-control">
                    <option value="all">All</option>
                    <option value="GBP">GBP</option>
                    <option value="Blog">Blog</option>
                    <option value="Landing">Landing</option>
                    <option value="Event">Event</option>
                    <option value="Product">Product</option>
                    <option value="Other">Other</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>SERP features:</label>
                  <select id="ranking-filter-serp-features" class="filter-control">
                    <option value="all">All</option>
                    <option value="ai-overview">AI Overview</option>
                    <option value="local-pack">Local pack</option>
                    <option value="paa">People Also Ask</option>
                    <option value="featured-snippet">Featured snippet</option>
                    <option value="none">None</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Optimisation status: <span title="Filter keywords by their optimisation tracking status. Shows whether optimisation work is planned, in progress, being monitored, completed, paused, cancelled, or not yet tracked." style="opacity: 0.6; cursor: help;"></span></label>
                  <select id="ranking-filter-optimisation-status" class="filter-control">
                    <option value="all">All</option>
                    <option value="not-tracked">Not tracked</option>
                    <option value="planned">Planned</option>
                    <option value="in_progress">In progress</option>
                    <option value="monitoring">Monitoring</option>
                    <option value="done">Done</option>
                    <option value="paused">Paused</option>
                    <option value="cancelled">Cancelled</option>
                  </select>
                </div>
              </div>

              <div style="display: flex; gap: 0.75rem; align-items: flex-end;">
                <div class="filter-group filter-group-search" style="flex: 1; min-width: 300px;">
                  <label>Search:</label>
                  <input type="text" id="ranking-filter-keyword" class="filter-control" placeholder="Filter by keyword...">
                </div>

                <div class="filter-group filter-group-button" style="align-items: end;">
                  <button id="ranking-filter-clear" class="btn btn-small" style="width: 100%;">Clear filters</button>
                </div>
              </div>
            </div>
            <div class="ranking-table-wrapper" style="max-height: none;">
              <table class="ranking-table" id="ranking-ai-table">
                <thead>
                  <tr>
                    <th data-sort="keyword" class="sortable" title="The tracked keyword or search query.">
                      <div>Keyword <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="The tracked keyword or search query."></div>
                    </th>
                    <th data-sort="segment" class="sortable" title="Keyword intent segment: Brand (branded queries), Money (commercial intent), Education (informational), or Other.">
                      <div>Segment <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Keyword intent segment: Brand (branded queries), Money (commercial intent), Education (informational), or Other."></div>
                    </th>
                    <th data-sort="rank" class="sortable" title="Current organic search ranking position for this keyword. Lower numbers are better (1 is the top position).">
                      <div>Current organic rank <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Current organic search ranking position for this keyword. Lower numbers are better (1 is the top position)."></div>
                    </th>
                    <th data-sort="volume" class="sortable" title="Average monthly Google search volume for this keyword in the UK. Source: DataForSEO Labs  Keyword Overview.">
                      <div>Search volume <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Average monthly Google search volume for this keyword in the UK. Source: DataForSEO Labs  Keyword Overview."></div>
                    </th>
                    <th data-sort="ctr" class="sortable" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days.">
                      <div>CTR (28d) <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days (matches GSC UI)."></div>
                    </th>
                    <th data-sort="impressions30d" class="sortable" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days.">
                      <div>Impressions (28d) <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days (matches GSC UI)."></div>
                    </th>
                    <th data-sort="opportunityScore" class="sortable" title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10; Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10; Classic ranking strength (page 1 vs page 2+ and current position).&#10; AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first.">
                      <div>Opportunity score <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10; Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10; Classic ranking strength (page 1 vs page 2+ and current position).&#10; AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first."></div>
                    </th>
                    <th title="Whether Google AI Overview is present in SERP results for this keyword.">
                      <div>AI Overview</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Whether Google AI Overview is present in SERP results for this keyword."></div>
                    </th>
                    <th data-sort="citations" class="sortable" title="Number of citations from your domain (alanranger.com) out of total citations in AI Overview for this keyword.">
                      <div>AI citations <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Number of citations from your domain (alanranger.com) out of total citations in AI Overview for this keyword."></div>
                    </th>
                    <th title="This is the traditional blue link in SERP results.">
                      <div>Classic Ranking URL</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="This is the traditional blue link in SERP results."></div>
                    </th>
                    <th data-sort="pageType" class="sortable" title="Type of page that ranks for this keyword: GBP (Google Business Profile), Landing (landing page), Event (event/workshop page), Product (product/service page), or Other.">
                      <div>Page type <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Type of page that ranks for this keyword: GBP (Google Business Profile), Landing (landing page), Event (event/workshop page), Product (product/service page), or Other."></div>
                    </th>
                    <th title="Optimisation tracking status for this keyword and target URL. Shows whether optimisation work is planned, in progress, being monitored, or completed.">
                      <div>Optimisation</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Optimisation tracking status for this keyword and target URL. Shows whether optimisation work is planned, in progress, being monitored, or completed."></div>
                    </th>
                  </tr>
                </thead>
                <tbody id="ranking-ai-table-body">
                  <tr><td colspan="12" class="ranking-table-empty">Click "Run ranking &amp; AI check" to load data.</td></tr>
                </tbody>
              </table>
            </div>
            <div class="ranking-pagination-controls" id="ranking-pagination-controls" style="display: none;">
              <div class="ranking-pagination-info" id="ranking-pagination-info">
                Showing 0-0 of 0
              </div>
              <div class="ranking-pagination-buttons">
                <button id="ranking-pagination-first" type="button">First</button>
                <button id="ranking-pagination-prev" type="button">Previous</button>
                <span id="ranking-pagination-page-info" style="padding: 0 0.5rem; font-size: 0.875rem;">Page 1 of 1</span>
                <button id="ranking-pagination-next" type="button">Next</button>
                <button id="ranking-pagination-last" type="button">Last</button>
              </div>
              <div class="ranking-rows-per-page">
                <label>Rows per page:</label>
                <select id="ranking-rows-per-page">
                  <option value="10" selected>10</option>
                  <option value="25">25</option>
                  <option value="50">50</option>
                  <option value="100">100</option>
                  <option value="all">All</option>
                </select>
              </div>
            </div>
          </div>
        </div>

        <!-- Section D: Keyword details & insights (three columns: 33% each) -->
        <div class="ranking-details-grid">
          <div class="card" id="ranking-ai-detail-card">
            <div class="card-header">
              <h3>Keyword Scorecard</h3>
              <p class="card-subtitle ranking-subtitle-tight">
                Detailed analysis of the selected keyword's impact, difficulty, and recommended actions. Shows demand, ranking strength, AI usage, and priority.
              </p>
            </div>
            <div class="ranking-ai-detail-body">
              <p id="ranking-ai-detail-empty">
                Select a keyword in the table or a cell in the priority grid to see a detailed scorecard.
              </p>
              <div id="ranking-ai-detail-content" class="ranking-ai-detail-content" hidden>
                <h4 id="ranking-ai-detail-keyword"></h4>
                <p id="ranking-ai-detail-summary"></p>
              </div>
            </div>
          </div>

          <div class="card" id="ranking-ai-competitors-card">
            <div class="card-header">
              <h3>Competitors in AI &amp; SERPs</h3>
              <p class="card-subtitle ranking-subtitle-tight">
                Domains that appear repeatedly in AI citations and/or classic top-10 rankings. Competitive backdrop for <strong>Authority</strong> and <strong>Visibility</strong>.
              </p>
            </div>
            <div style="padding: 0 1.25rem 1.25rem 1.25rem;">
              <div style="overflow-x: auto; max-width: 100%;">
                <table id="ranking-ai-competitors-table" style="width: 100%; border-collapse: collapse; table-layout: fixed; font-size: 0.8rem;">
                  <thead>
                    <tr style="background: #f1f5f9;">
                      <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 35%; word-wrap: break-word;">Domain</th>
                      <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 20%;">AI citations</th>
                      <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 25%;">Domain Rank</th>
                      <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 15%; word-wrap: break-word; line-height: 1.2;">
                        <div style="display: flex; flex-direction: column; align-items: flex-start;">
                          <span>Domain</span>
                          <span>type</span>
                        </div>
                      </th>
                      <th style="text-align: center; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 5%;">C</th>
                    </tr>
                  </thead>
                  <tbody id="ranking-ai-competitors-body"></tbody>
                </table>
              </div>
              <p style="margin: 0.75rem 0 0 0; font-size: 0.8rem; color: #64748b;">
                Domain Rank is sourced from your latest Domain Strength snapshot (0100).
              </p>
            </div>
          </div>

          <div class="card" id="ranking-ai-citations-card">
            <div class="card-header">
              <h3>AI Citations for Selected Keyword</h3>
              <p class="card-subtitle ranking-subtitle-tight">
                Pages from alanranger.com and other domains cited in AI Overviews for the selected keyword.
              </p>
            </div>
            <div class="ranking-ai-detail-body">
              <p id="ranking-ai-citations-empty">
                Select a keyword in the table to see AI citations.
              </p>
              <div id="ranking-ai-citations-content" hidden>
                <p class="card-subtitle ranking-subtitle-tight" style="margin-bottom: 1rem;">
                  Pages from alanranger.com and other domains cited in AI Overviews for the selected keyword.
                </p>
                <h5>Your cited pages</h5>
                <ul id="ranking-ai-detail-our-pages" class="ranking-ai-detail-list"></ul>

                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                  <h5 style="margin: 0;">Other cited domains</h5>
                  <button id="backfill-domain-ranks-btn" onclick="backfillMissingDomainRanks()" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;" title="Fetch Domain Rank for domains currently showing ''">Backfill Missing Ranks</button>
                </div>
                <div style="overflow-x: auto; margin-top: 0.5rem; max-width: 100%;">
                  <table id="ranking-ai-detail-competitors-table" style="width: 100%; border-collapse: collapse; table-layout: fixed; font-size: 0.8rem;">
                    <thead>
                      <tr style="background: #f1f5f9;">
                        <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 28%; word-wrap: break-word;">Domain</th>
                        <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 12%;">Citations</th>
                        <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 18%;">Domain Rank</th>
                        <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 16%; word-wrap: break-word; line-height: 1.2;">
                          <div style="display: flex; flex-direction: column; align-items: flex-start;">
                            <span>Domain</span>
                            <span>type</span>
                          </div>
                        </th>
                        <th style="text-align: center; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 26%;">Competitor</th>
                      </tr>
                    </thead>
                    <tbody id="ranking-ai-detail-competitors-body"></tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- AI Sources & Influence Panel -->
      <section class="aigeo-panel" data-panel="ai-sources">
        <div class="container" style="max-width: 1400px; margin: 0 auto; padding: 2rem;">
          <div class="card" style="margin-bottom: 2rem;">
            <div class="card-header">
              <h2>AI Sources & Influence</h2>
              <p class="card-subtitle">
                Domains that AI relies on most often when answering your tracked keywords. Identify which external sources you should strengthen or join so AI is more confident recommending you.
              </p>
            </div>
          </div>

          <!-- Summary Tiles -->
          <div id="ai-sources-tiles" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
            <!-- Tiles will be populated by JS -->
          </div>

          <!-- Source Types & Quick Insights -->
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 2rem;">
            <!-- Left: Source Types Overview -->
            <div class="card">
              <div class="card-header">
                <h3>Source Types Overview</h3>
              </div>
              <div class="card-body" id="ai-sources-types-breakdown">
                <p style="color: #64748b; text-align: center; padding: 2rem;">Loading source types...</p>
              </div>
            </div>

            <!-- Right: AI Influence Summary -->
            <div class="card ai-sources-explainer">
              <div class="card-header">
                <h3>How to read this tab</h3>
              </div>
              <div class="card-body">
                <p style="line-height: 1.6; margin-bottom: 0.75rem;">
                  This view shows the domains AI relies on most often when answering your tracked keywords.
                </p>
                <ul style="line-height: 1.8;">
                  <li>Repeated citations from the same domain signal trusted sources in your niche.</li>
                  <li>Directories and review platforms highlight places where you need consistent NAP, reviews and listings.</li>
                  <li>Course marketplaces and education sites show where learners are discovering alternatives to your workshops and lessons.</li>
                </ul>
                <p style="line-height: 1.6; margin-top: 0.75rem; font-weight: 600;">
                  The goal is to identify which external sources you should strengthen or join so AI is more confident recommending you.
                </p>
              </div>
            </div>
          </div>
        </div>

          <!-- Domain Influence Table -->
          <div class="card ai-sources-domain-table-card">
            <div class="card-header">
              <h3>Domain Influence Table</h3>
              <div style="display: flex; gap: 1rem; margin-top: 1rem; flex-wrap: wrap;">
                <div class="filter-group">
                  <label>Source type:</label>
                  <select id="ai-sources-filter-type" class="filter-control">
                    <option value="all">All</option>
                    <option value="Directory">Directory</option>
                    <option value="Review platform">Review platform</option>
                    <option value="Course marketplace / education">Course marketplace / education</option>
                    <option value="Publisher / blog">Publisher / blog</option>
                    <option value="Other">Other</option>
                  </select>
                </div>
                <div class="filter-group">
                  <label>Domain type:</label>
                  <select id="ai-sources-filter-domain-type" class="filter-control">
                    <option value="all">All</option>
                    <option value="self">Your site</option>
                    <option value="competitor">Competitor</option>
                    <option value="site">Site</option>
                    <option value="platform">Platform</option>
                    <option value="directory">Directory</option>
                    <option value="publisher">Publisher</option>
                    <option value="vendor">Vendor</option>
                    <option value="institution">Institution</option>
                    <option value="government">Government</option>
                    <option value="unmapped">Unmapped</option>
                  </select>
                </div>
                <div class="filter-group">
                  <label>Search:</label>
                  <input type="text" id="ai-sources-filter-domain" class="filter-control" placeholder="Filter by domain...">
                </div>
                <button id="ai-sources-filter-clear" class="btn btn-small">Clear filters</button>
              </div>
            </div>
            <div class="ranking-table-wrapper">
              <table class="ranking-table" id="ai-sources-table">
                <thead style="position: sticky; top: 0; z-index: 20; background: white;">
                  <tr>
                    <th data-sort="domain" class="sortable" style="background: white;">Domain <span class="sort-indicator"></span></th>
                    <th data-sort="domain_type" class="sortable" style="background: white;">Domain type <span class="sort-indicator"></span></th>
                    <th data-sort="competitor" class="sortable" style="background: white;">Competitor <span class="sort-indicator"></span></th>
                    <th data-sort="rank" class="sortable" style="background: white;">Domain Rank <span class="sort-indicator"></span></th>
                    <th data-sort="citations" class="sortable" style="background: white;">AI citations <span class="sort-indicator"></span></th>
                    <th data-sort="keywords" class="sortable" style="background: white;">Keywords <span class="sort-indicator"></span></th>
                    <th data-sort="share" class="sortable" style="background: white;">Citation share <span class="sort-indicator"></span></th>
                    <th style="background: white;">Example page</th>
                  </tr>
                </thead>
                <tbody id="ai-sources-table-body">
                  <tr><td colspan="8" class="ranking-table-empty">Loading domain data...</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- Domain Detail Panel (Right Side) -->
          <div id="ai-sources-detail-panel" style="display: none; margin-top: 2rem;">
            <div class="card">
              <div class="card-header">
                <h3 id="ai-sources-detail-domain">Domain Details</h3>
                <p id="ai-sources-detail-meta" class="card-subtitle"></p>
              </div>
              <div class="card-body" id="ai-sources-detail-content">
                <!-- Content populated by JS -->
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Local & Reviews Panel -->
      <section class="aigeo-panel" data-panel="local">
        <!-- Local entity, GBP, reviews content will be inserted here by JS -->
      </section>

      <!-- Optimisation Tracking Panel -->
      <section class="aigeo-panel" data-panel="optimisation" hidden>
        <div class="card card--section-header" style="display: flex; justify-content: space-between; align-items: center;">
          <div>
            <h2>Optimisation Tracking</h2>
            <p>Track and manage keyword optimisation tasks across your site. Monitor progress, cycles, and outcomes.</p>
          </div>
          <button id="optimisation-bulk-update-btn" class="btn" style="padding: 0.75rem 1.5rem; font-size: 0.95rem; white-space: nowrap;" title="Captures the latest metrics for every active task (creates a measurement entry).">
             Update All Tasks with Latest Data
          </button>
        </div>

        <!-- Summary Cards (B6) -->
        <h2 style="color: var(--dark-text) !important; font-size: 1.5rem; font-weight: 600; margin: 2rem 0 1rem 0;">Task Counts</h2>
        <div class="optimisation-summary-cards" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1.5rem 0;">
          <div class="card" title="Tasks with status: planned, in_progress, or monitoring (not done, cancelled, or deleted).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-active"></div>
            <div style="margin-top: 0.5rem;">Active Tasks</div>
          </div>
          <div class="card" title="Tasks with status: planned (task created but work not started).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-planned"></div>
            <div style="margin-top: 0.5rem;">Planned</div>
          </div>
          <div class="card" title="Tasks with status: in_progress (actively being worked on).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-in-progress"></div>
            <div style="margin-top: 0.5rem;">In Progress</div>
          </div>
          <div class="card" title="Tasks with status: monitoring (changes deployed, tracking results).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-monitoring"></div>
            <div style="margin-top: 0.5rem;">Monitoring</div>
          </div>
          <div class="card" title="Tasks with status: done (cycle completed; start a new cycle if optimising again).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-done"></div>
            <div style="margin-top: 0.5rem;">Done</div>
          </div>
          <div class="card" title="Tasks with status: paused (tracking stopped; you can start a new cycle later).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-paused"></div>
            <div style="margin-top: 0.5rem;">Paused</div>
          </div>
          <div class="card" title="Tasks with status: cancelled (tracking stopped; you can start a new cycle later).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-cancelled"></div>
            <div style="margin-top: 0.5rem;">Cancelled</div>
          </div>
          <div class="card" title="Tasks that have had a measurement event created in the last 30 days.">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-recent"></div>
            <div style="margin-top: 0.5rem;">Updated (30d)</div>
          </div>
        </div>

        <!-- Divider line between Task Counts and Objectives -->
        <hr style="border: none; border-top: 1px solid rgba(156, 163, 175, 0.3); margin: 2rem 0;">

        <!-- Goal Rollup Badges (Phase B) -->
        <h2 style="color: var(--dark-text) !important; font-size: 1.5rem; font-weight: 600; margin: 2rem 0 1rem 0;">Objectives</h2>
        <div class="optimisation-goal-rollups" style="display: flex; gap: 0.75rem; margin: 1rem 0; flex-wrap: wrap; align-items: center;">
          <div style="font-weight: 600; color: #475569; margin-right: 0.5rem;">Objectives:</div>
          <span id="optimisation-goal-filter-not-set" class="ranking-badge ranking-badge--segment-general" style="padding: 0.5rem 1rem; cursor: pointer;" title="Tasks with no objective set (no KPI, target, or timeframe defined). Click to filter.">
            Not set: <span id="optimisation-goal-not-set">0</span>
          </span>
          <span id="optimisation-goal-filter-on-track" class="ranking-badge ranking-badge--segment-education" style="padding: 0.5rem 1rem; cursor: pointer;" title="Objective set and not yet due, or delta is moving in the right direction but hasn't met target yet. Click to filter.">
            On track: <span id="optimisation-goal-on-track">0</span>
          </span>
          <span id="optimisation-goal-filter-overdue" class="ranking-badge ranking-badge--segment-money" style="padding: 0.5rem 1rem; background: #fee2e2; color: #991b1b; cursor: pointer;" title="Due date has passed and target has not been met. Click to filter.">
            Overdue: <span id="optimisation-goal-overdue">0</span>
          </span>
          <span id="optimisation-goal-filter-met" class="ranking-badge ranking-badge--segment-brand" style="padding: 0.5rem 1rem; background: #d1fae5; color: #065f46; cursor: pointer;" title="Target has been met (delta meets or exceeds target value). Click to filter.">
            Met: <span id="optimisation-goal-met">0</span>
          </span>
        </div>

        <!-- Objective Metrics Traffic Lights (7 columns: All Metrics aggregated + 6 individual metrics) -->
        <div class="optimisation-objective-metrics" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 1rem; margin: 2rem 0;">
          <!-- All Metrics (Aggregated) -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">All Metrics</div>
            <div class="traffic-light-pill" data-metric="all_metrics" data-bucket="worse" style="background: rgba(239, 68, 68, 0.2);" onclick="handleTrafficLightClick('all_metrics', 'worse')">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-all-metrics-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div class="traffic-light-pill" data-metric="all_metrics" data-bucket="same" style="background: rgba(245, 158, 11, 0.2);" onclick="handleTrafficLightClick('all_metrics', 'same')">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-all-metrics-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div class="traffic-light-pill" data-metric="all_metrics" data-bucket="better" style="background: rgba(16, 185, 129, 0.2);" onclick="handleTrafficLightClick('all_metrics', 'better')">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-all-metrics-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- CTR (28d) -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">CTR (28d)</div>
            <div class="traffic-light-pill" data-metric="ctr_28d" data-bucket="worse" style="background: rgba(239, 68, 68, 0.2);" onclick="handleTrafficLightClick('ctr_28d', 'worse')">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-ctr-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div class="traffic-light-pill" data-metric="ctr_28d" data-bucket="same" style="background: rgba(245, 158, 11, 0.2);" onclick="handleTrafficLightClick('ctr_28d', 'same')">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-ctr-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div class="traffic-light-pill" data-metric="ctr_28d" data-bucket="better" style="background: rgba(16, 185, 129, 0.2);" onclick="handleTrafficLightClick('ctr_28d', 'better')">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-ctr-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- Impressions (28d) -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">Impressions (28d)</div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-impressions-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-impressions-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-impressions-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- Clicks (28d) -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">Clicks (28d)</div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-clicks-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-clicks-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-clicks-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- Rank -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">Rank</div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-rank-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-rank-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-rank-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- AI Citations -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">AI Citations</div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-ai-citations-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-ai-citations-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-ai-citations-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- AI Overview -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">AI Overview</div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-ai-overview-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-ai-overview-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-ai-overview-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

        </div>

        <!-- Phase 9: KPI Tiles (RAG) -->
        <div class="optimisation-kpi-tiles" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 1rem; margin: 1.5rem 0;">
          <div class="card" style="cursor: pointer;" id="kpi-tile-ctr-on-track" onclick="filterByKPIRAG('ctr', 'on_track')" title="CTR objectives that are on track. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-ctr-on-track">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">CTR: On track</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-ctr-at-risk" onclick="filterByKPIRAG('ctr', 'at_risk')" title="CTR objectives at risk (due within 7 days). Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-ctr-at-risk">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">CTR: At risk</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-ctr-overdue" onclick="filterByKPIRAG('ctr', 'overdue')" title="CTR objectives that are overdue. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-ctr-overdue">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">CTR: Overdue</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-rank-improved" onclick="filterByRankDelta('improved')" title="Rank objectives with improved rank (lower is better). Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-rank-improved">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Rank: Improved</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-rank-worse" onclick="filterByRankDelta('worse')" title="Rank objectives with worsened rank. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-rank-worse">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Rank: Worse</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-rank-flat" onclick="filterByRankDelta('flat')" title="Rank objectives with no change. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-rank-flat">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Rank: Flat</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-ai-gap" onclick="filterByAIGap()" title="Tasks with AI Overview on but citations = 0. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-ai-gap">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">AI Citation Gap</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-needs-measurement" onclick="filterByNeedsMeasurement()" title="Tasks needing measurement update (>30 days or missing). Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-needs-measurement">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Needs Measurement</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-overdue-cycles" onclick="filterByOverdueCycles()" title="Tasks with overdue cycles (past due date and target not met). Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-overdue-cycles">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Overdue Cycles</div>
          </div>
        </div>

        <!-- Phase 9: Estimated Impact Tiles -->
        <div class="optimisation-impact-tiles" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin: 1.5rem 0;">
          <div class="card" title="Estimated extra clicks available if all CTR objectives meet their targets.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="impact-extra-clicks">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Estimated Extra Clicks (28d)</div>
          </div>
        </div>

        <!-- Phase 9: Scope Toggle -->
        <div class="optimisation-scope-toggle" style="display: flex; align-items: center; gap: 1rem; margin: 1.5rem 0; padding: 1rem; background: #f9fafb; border-radius: 8px;">
          <label style="font-weight: 600; color: #374151;">Scope:</label>
          <select id="optimisation-scope-select" style="padding: 0.5rem 1rem; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer; font-size: 0.875rem;">
            <option value="active_cycle">Active Cycle Only</option>
            <option value="all_tasks">All Tasks</option>
          </select>
          <span style="font-size: 0.875rem; color: #6b7280;" id="optimisation-scope-description">Showing metrics for tasks with active cycles only</span>
        </div>

        <!-- Phase 9: Time-based Charts -->
        <div class="optimisation-timeseries-charts" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 1.5rem; margin: 1.5rem 0;">
          <div class="card" style="padding: 1.5rem;">
            <h3 style="margin: 0 0 1rem 0; font-size: 1.1rem; font-weight: 600;">Tasks Updated per Week</h3>
            <div style="position: relative; height: 280px;">
              <canvas id="chart-measurements-per-week" style="width: 100%; height: 280px;"></canvas>
            </div>
          </div>
          <div class="card" style="padding: 1.5rem;">
            <h3 style="margin: 0 0 1rem 0; font-size: 1.1rem; font-weight: 600;">Median Delta by KPI (Last 30d)</h3>
            <div style="position: relative; height: 280px;">
              <canvas id="chart-median-delta" style="width: 100%; height: 280px;"></canvas>
            </div>
          </div>
        </div>

        <!-- Tab Pills (B2) -->
        <div class="optimisation-tab-pills" style="display: flex; gap: 0.5rem; margin: 1.5rem 0; flex-wrap: wrap;">
          <button class="metric-pill metric-pill--neutral optimisation-tab-btn" data-tab="active" style="cursor: pointer; padding: 0.75rem 1.5rem;">
            <span>Active</span>
            <span class="optimisation-tab-count" data-tab="active">0</span>
          </button>
          <button class="metric-pill metric-pill--neutral optimisation-tab-btn" data-tab="done" style="cursor: pointer; padding: 0.75rem 1.5rem;">
            <span>Done</span>
            <span class="optimisation-tab-count" data-tab="done">0</span>
          </button>
          <button class="metric-pill metric-pill--neutral optimisation-tab-btn" data-tab="paused-cancelled" style="cursor: pointer; padding: 0.75rem 1.5rem;">
            <span>Paused/Cancelled</span>
            <span class="optimisation-tab-count" data-tab="paused-cancelled">0</span>
          </button>
        </div>

        <!-- Filters (B6) -->
        <div class="optimisation-filters" style="display: flex; gap: 1rem; margin: 1rem 0; flex-wrap: wrap; align-items: center;">
          <select id="optimisation-filter-status" style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">All Statuses</option>
            <option value="planned">Planned</option>
            <option value="in_progress">In Progress</option>
            <option value="monitoring">Monitoring</option>
            <option value="done">Done</option>
            <option value="paused">Paused</option>
            <option value="cancelled">Cancelled</option>
          </select>
          <select id="optimisation-filter-type" style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">All Types</option>
            <option value="on_page">On Page</option>
            <option value="content">Content</option>
            <option value="internal_links">Internal Links</option>
            <option value="links_pr">Links/PR</option>
            <option value="technical">Technical</option>
            <option value="local">Local</option>
            <option value="other">Other</option>
          </select>
          <input type="text" id="optimisation-filter-keyword" placeholder="Filter by keyword..." style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; flex: 1; min-width: 200px;">
          <input type="text" id="optimisation-filter-url" placeholder="Filter by URL..." style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; flex: 1; min-width: 200px;">
          <button id="optimisation-filter-needs-update" class="btn btn-secondary" style="padding: 0.5rem 1rem;" title="Show tasks that need measurement update (no measurement or older than 30 days).">Needs Update</button>
          <button id="optimisation-filter-active-cycle" class="btn btn-secondary" style="padding: 0.5rem 1rem;" title="Show only tasks with an active cycle (current cycle not completed or archived).">Active Cycle Only</button>
          <button id="optimisation-filter-overdue-cycle" class="btn btn-secondary" style="padding: 0.5rem 1rem;" title="Show tasks with overdue current cycle (past due date and target not met).">Overdue Cycle</button>
          <label style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; cursor: pointer;" title="Include test tasks in the view (test tasks are excluded from bulk updates).">
            <input type="checkbox" id="optimisation-filter-include-test" checked style="cursor: pointer;">
            <span>Include Test Tasks</span>
          </label>
          <button id="optimisation-clear-filters" class="btn btn-secondary" style="padding: 0.5rem 1rem;">Clear Filters</button>
        </div>

        <!-- Tasks Table (B2) -->
        <div class="ranking-table-section" style="margin-top: 1.5rem;">
          <div class="card">
            <div class="ranking-table-wrapper" id="optimisation-tasks-table-container" style="overflow: visible; max-height: none;">
            <table id="optimisation-tasks-table" class="ranking-table">
              <thead>
                <tr>
                  <th data-sort="keyword" class="sortable" title="The tracked keyword or search query.">
                    <div>Keyword <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="The tracked keyword or search query."></div>
                  </th>
                  <th data-sort="url" class="sortable" title="The target URL being optimised for this keyword." style="max-width: 150px;">
                    <div>Target URL <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="The target URL being optimised for this keyword."></div>
                  </th>
                  <th data-sort="type" class="sortable" title="Type of optimisation task: on_page (content/SEO changes), technical (site structure), or other.">
                    <div>Task Type <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Type of optimisation task: on_page (content/SEO changes), technical (site structure), or other."></div>
                  </th>
                  <th data-sort="status" class="sortable" title="Current status: planned (not started), in_progress (actively working), monitoring (tracking results), done (completed), paused (temporarily stopped), or cancelled.">
                    <div>Status <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Current status: planned (not started), in_progress (actively working), monitoring (tracking results), done (completed), paused (temporarily stopped), or cancelled."></div>
                  </th>
                  <th data-sort="cycle" class="sortable" title="Current cycle number. Each cycle represents a new optimisation attempt for the same keyword.">
                    <div>Cycle <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Current cycle number. Each cycle represents a new optimisation attempt for the same keyword."></div>
                  </th>
                  <th data-sort="baselineCaptured" class="sortable" title="Date when baseline metrics snapshot was captured (when task was created).">
                    <div>Baseline Captured <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Date when baseline metrics snapshot was captured (when task was created)."></div>
                  </th>
                  <th data-sort="latestCaptured" class="sortable" title="Date when latest measurement snapshot was captured, with 'Needs update' indicator if >30 days.">
                    <div>Latest Captured <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Date when latest measurement snapshot was captured, with 'Needs update' indicator if >30 days."></div>
                  </th>
                  <th data-sort="title" class="sortable" title="Optional title or label for this optimisation task.">
                    <div>Title <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Optional title or label for this optimisation task."></div>
                  </th>
                  <th data-sort="objectiveKpi" class="sortable" title="Objective KPI type (e.g., CTR, Rank, AI Citations).">
                    <div>Objective KPI <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Objective KPI type (e.g., CTR, Rank, AI Citations)."></div>
                  </th>
                  <th data-sort="baselineLatest" class="sortable" title="Baseline  Latest values for the objective KPI.">
                    <div>Baseline  Latest <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Baseline  Latest values for the objective KPI."></div>
                  </th>
                  <th data-sort="delta" class="sortable" title="Change (delta) from baseline to latest for the objective KPI.">
                    <div> vs Baseline <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Change (delta) from baseline to latest for the objective KPI."></div>
                  </th>
                  <th data-sort="dueIn" class="sortable" title="Days remaining until due date, or 'Overdue Xd' if past due.">
                    <div>Due In <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Days remaining until due date, or 'Overdue Xd' if past due."></div>
                  </th>
                  <th title="Mini trend line (sparkline) showing last ~10 measurements for the objective KPI.">
                    <div>Trend</div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Mini trend line (sparkline) showing last ~10 measurements for the objective KPI."></div>
                  </th>
                  <th title="Goal status and progress for the current cycle objective.">
                    <div>Goal</div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Goal status and progress for the current cycle objective."></div>
                  </th>
                  <th style="text-align: center;" title="Actions available for this task.">
                    <div>Actions</div>
                  </th>
                </tr>
              </thead>
              <tbody id="optimisation-tasks-tbody">
                <tr>
                  <td colspan="13" style="padding: 2rem; text-align: center; color: #666;">Loading tasks...</td>
                </tr>
              </tbody>
            </table>
            </div>
            <div class="ranking-pagination-controls" id="optimisation-pagination-controls" style="display: none;">
            <div class="ranking-pagination-info" id="optimisation-pagination-info">
              Showing 0-0 of 0
            </div>
            <div class="ranking-pagination-buttons">
              <button id="optimisation-pagination-first" type="button">First</button>
              <button id="optimisation-pagination-prev" type="button">Previous</button>
              <span id="optimisation-pagination-page-info" style="padding: 0 0.5rem; font-size: 0.875rem;">Page 1 of 1</span>
              <button id="optimisation-pagination-next" type="button">Next</button>
              <button id="optimisation-pagination-last" type="button">Last</button>
            </div>
            <div class="ranking-rows-per-page">
              <label>Rows per page:</label>
              <select id="optimisation-rows-per-page">
                <option value="10" selected>10</option>
                <option value="25">25</option>
                <option value="50">50</option>
                <option value="100">100</option>
                <option value="all">All</option>
              </select>
            </div>
          </div>
          </div>
        </div>

        <!-- Task Detail Drawer (B3) -->
        <!-- Backdrop -->
        <div id="optimisation-task-drawer-backdrop" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 999;"></div>
        
        <!-- Draggable Modal Window -->
        <div id="optimisation-task-drawer" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 1200px; max-width: 95vw; max-height: 95vh; background: var(--dark-panel); box-shadow: 0 10px 40px rgba(0,0,0,0.5); z-index: 1000; border-radius: 8px; overflow: hidden; flex-direction: column; color: var(--dark-text);">
          <!-- Draggable Header -->
          <div id="optimisation-drawer-header-bar" style="padding: 1rem 1.5rem; border-bottom: 1px solid var(--dark-border); display: flex; justify-content: space-between; align-items: center; background: var(--dark-panel); cursor: move; user-select: none;">
            <h3 id="optimisation-drawer-header-title" style="margin: 0; flex: 1; color: var(--dark-text);">Task Details</h3>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
              <button id="optimisation-drawer-minimize" style="background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0.25rem 0.5rem; color: var(--dark-text-muted);" title="Minimize"></button>
              <button id="optimisation-drawer-maximize" style="background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0.25rem 0.5rem; color: var(--dark-text-muted);" title="Maximize"></button>
              <button id="optimisation-drawer-close" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; padding: 0.25rem 0.5rem; color: var(--dark-text-muted);" title="Close">&times;</button>
            </div>
          </div>
          
          <!-- Cancel Task, Delete Task, and Title (moved to header area) -->
          <div style="padding: 0.75rem 1.5rem; border-bottom: 1px solid var(--dark-border); background: var(--dark-panel); display: flex; gap: 0.5rem; align-items: center;">
            <button id="optimisation-cancel-task-btn" class="btn" style="background: #dc2626; border: 1px solid #dc2626; padding: 0.5rem 1rem; font-size: 0.875rem; color: #ffffff; font-weight: 700;" title="Stop tracking (keeps history).">Cancel Task</button>
            <button id="optimisation-delete-task-btn" class="btn" style="background: #991b1b; border: 1px solid #991b1b; padding: 0.5rem 1rem; font-size: 0.875rem; color: #ffffff; font-weight: 700;" title="Permanently remove task and events (cannot be undone).">Delete Task</button>
            <div style="flex: 1; display: flex; align-items: center; gap: 0.5rem; margin-left: 1rem;">
              <strong style="white-space: nowrap; color: var(--dark-text);">Title:</strong>
              <input type="text" id="optimisation-drawer-title" style="flex: 1; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="Enter task title...">
            </div>
          </div>
          
          <!-- Scrollable Content -->
          <div id="optimisation-drawer-content" style="padding: 1.5rem; overflow-y: auto; flex: 1;">
          <div>
            <!-- Task Header (Full Width) -->
            <div id="optimisation-drawer-header" style="margin-bottom: 1.5rem; display: grid; grid-template-columns: 1fr 2fr 1.5fr; gap: 1.5rem;">
              <div>
                <strong>Keyword:</strong>
                <div id="optimisation-drawer-keyword" style="margin-top: 0.25rem; font-size: 1.1rem; color: #2563eb;"></div>
              </div>
              <div>
                <strong>Target URL:</strong>
                <div id="optimisation-drawer-url" style="margin-top: 0.25rem; word-break: break-all;"></div>
              </div>
              <div style="text-align: right;">
                <div style="margin-bottom: 0.5rem;">
                  <strong style="color: var(--dark-text);">Task Type:</strong>
                  <span id="optimisation-drawer-type" style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; background: rgba(156, 163, 175, 0.2); border-radius: 4px; color: var(--dark-text);"></span>
                </div>
                <div style="margin-bottom: 0.5rem;">
                  <strong>Status:</strong>
                  <span id="optimisation-drawer-status" style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; border-radius: 4px;"></span>
                </div>
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                  <strong>Cycle:</strong>
                  <span id="optimisation-drawer-cycle" style="margin-left: 0;"></span>
                  <select id="optimisation-drawer-cycle-selector" style="padding: 0.25rem 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text); cursor: pointer; display: none; min-width: 100px;" title="Select a cycle to view its objective, measurements, and events">
                    <!-- Options will be populated by JavaScript -->
                  </select>
                </div>
              </div>
            </div>

            <!-- Objective Section (Full Width) -->
            <div id="optimisation-drawer-objective" style="margin-bottom: 1.5rem; padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                  <h4 style="margin: 0; font-size: 0.95rem; font-weight: 600;">Objective <span id="optimisation-drawer-objective-cycle">(Cycle 1)</span></h4>
                  <span id="optimisation-drawer-objective-badge" style="padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; display: none;"></span>
                </div>
                <button id="optimisation-edit-objective-btn" class="btn btn-small" style="padding: 0.25rem 0.75rem; font-size: 0.875rem; background: var(--dark-brand); color: #000000; font-weight: 700; border: 1px solid var(--dark-brand);" title="Set target KPI and timeframe for this cycle.">Edit</button>
              </div>
              <div id="optimisation-drawer-objective-content" style="font-size: 0.875rem; color: var(--dark-text);">
                <div style="color: var(--dark-text-muted); font-style: italic;">Loading objective...</div>
              </div>
              <!-- Edit Objective Form (Hidden by default) -->
              <div id="optimisation-edit-objective-form" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--dark-border);">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Title</label>
                    <input type="text" id="optimisation-edit-objective-title" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="Objective title">
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">KPI Label</label>
                    <input type="text" id="optimisation-edit-objective-kpi" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="e.g., AI citations increase by 1">
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Metric</label>
                    <select id="optimisation-edit-objective-metric" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);">
                      <option value="">Select metric</option>
                      <option value="ai_citations">AI Citations</option>
                      <option value="ai_overview">AI Overview</option>
                      <option value="ctr_28d">CTR (28d)</option>
                      <option value="impressions_28d">Impressions (28d)</option>
                      <option value="clicks_28d">Clicks (28d)</option>
                      <option value="rank">Rank</option>
                    </select>
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Direction</label>
                    <select id="optimisation-edit-objective-direction" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);">
                      <option value="">Select direction</option>
                      <option value="increase">Increase</option>
                      <option value="decrease">Decrease</option>
                      <option value="at_least">At least</option>
                      <option value="at_most">At most</option>
                    </select>
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Target Value</label>
                    <input type="number" id="optimisation-edit-objective-target-value" step="0.01" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="0">
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Timeframe (days)</label>
                    <input type="number" id="optimisation-edit-objective-timeframe" min="1" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="30">
                  </div>
                  <div style="display: flex; align-items: flex-end;">
                    <div id="optimisation-edit-objective-due-date" style="padding: 0.5rem; font-size: 0.875rem; color: var(--dark-text-muted);"></div>
                  </div>
                </div>
                <div style="margin-bottom: 1rem;">
                  <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Plan</label>
                  <textarea id="optimisation-edit-objective-plan" rows="3" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; resize: vertical; background: var(--dark-bg); color: var(--dark-text);" placeholder="Describe your plan..."></textarea>
                </div>
                <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                  <button id="optimisation-cancel-edit-objective-btn" class="btn btn-secondary" style="padding: 0.5rem 1rem; font-size: 0.875rem;">Cancel</button>
                  <button id="optimisation-save-objective-btn" class="btn" style="padding: 0.5rem 1rem; font-size: 0.875rem;">Save</button>
                </div>
              </div>
            </div>

            <!-- Two Column Layout -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;">
              <!-- Left Column -->
              <div style="display: flex; flex-direction: column; gap: 1.5rem;">
                <!-- Performance Snapshot -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center; font-size: 0.95rem; color: var(--dark-text);">
                    <span>Performance Snapshot <span title="Shows current metrics compared to baseline measurement. Baseline is captured when the cycle starts, and latest shows the most recent measurement. Use 'Add Measurement' to capture new snapshots." style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></span>
                    <button id="optimisation-add-measurement-btn" class="btn btn-small" style="padding: 0.25rem 0.75rem; font-size: 0.875rem; background: var(--dark-brand); color: #000000; font-weight: 700; border: 1px solid var(--dark-brand);" title="Capture the latest metrics and compare to baseline.">Add Measurement</button>
                  </h4>
                  <div id="optimisation-metrics-snapshot" style="display: grid; grid-template-columns: 1.5fr 1fr 1fr; gap: 0.75rem; font-size: 0.9rem; color: var(--dark-text);">
                    <!-- Metrics will be populated by JavaScript -->
                    <div style="color: var(--dark-text-muted); font-style: italic; grid-column: 1 / -1;">Loading metrics...</div>
                  </div>
                </div>

                <!-- Measurement History -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; font-size: 0.95rem; display: flex; justify-content: space-between; align-items: center; color: var(--dark-text);">
                    <span>Measurement History <span title="Recent measurement snapshots for this cycle. Shows captured date, key metrics, and delta vs previous measurement." style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></span>
                    <button id="optimisation-measurement-history-toggle" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; background: rgba(156, 163, 175, 0.6); border: 1px solid var(--dark-border); border-radius: 4px; cursor: pointer;">Show</button>
                  </h4>
                  <div id="optimisation-measurement-history" style="display: none; max-height: 400px; overflow-y: auto;">
                    <div style="color: var(--dark-text-muted); font-style: italic;">Loading measurement history...</div>
                  </div>
                </div>

                <!-- Close Button -->
                <div style="padding-top: 1rem;">
                  <button id="optimisation-drawer-close-bottom" class="btn btn-secondary" style="width: 100%; padding: 0.5rem 1rem;">Close</button>
                </div>

              </div>

              <!-- Right Column -->
              <div style="display: flex; flex-direction: column; gap: 1.5rem;">
                <!-- Timeline/Events (Collapsible) -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center; cursor: pointer; font-size: 0.95rem; color: var(--dark-text);" id="optimisation-timeline-header">
                    <span>Timeline <span title="Chronological history of all events for this task: measurements, notes, status changes, and deployed changes. Click to expand or collapse the timeline view." style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></span>
                    <span id="optimisation-timeline-toggle" style="font-size: 1.2rem; user-select: none; color: var(--dark-text);"></span>
                  </h4>
                  <div id="optimisation-drawer-events-container" style="display: none;">
                    <div id="optimisation-drawer-events" style="border-left: 2px solid var(--dark-border); padding-left: 1rem; max-height: 400px; overflow-y: auto;">
                      <div style="color: var(--dark-text-muted); font-style: italic;">Loading events...</div>
                    </div>
                  </div>
                </div>

                <!-- Cycle Management -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; font-size: 0.95rem; color: var(--dark-text);">Cycle Management</h4>
                  <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                    <button id="optimisation-complete-cycle-btn" class="btn" style="width: 100%; padding: 0.5rem; font-size: 0.875rem; background: #059669; border-color: #059669; color: #ffffff; font-weight: 700;" title="Mark the current cycle as completed. This closes the cycle and makes it viewable in history.">Complete Cycle</button>
                    <button id="optimisation-archive-cycle-btn" class="btn btn-secondary" style="width: 100%; padding: 0.5rem; font-size: 0.875rem; background: #4b5563; color: #ffffff; font-weight: 700; border: 1px solid #4b5563;" title="Archive the current cycle (for abandoned work). The cycle remains in history but is marked as archived.">Archive Cycle</button>
                    <button id="optimisation-start-cycle-btn" class="btn btn-secondary" style="width: 100%; padding: 0.5rem; font-size: 0.875rem; background: rgba(156, 163, 175, 0.6); color: #000000; font-weight: 700; border: 1px solid var(--dark-border);" title="Begins a new optimisation attempt while preserving history from previous cycles.">Start New Cycle</button>
                  </div>
                </div>

                <!-- Add Event Form -->
                <div style="padding: 0.5rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.5rem; font-size: 0.95rem; color: var(--dark-text);">Add Event <span title="Record activities and milestones: Notes for observations, Change Deployed for updates, Measurement for metric snapshots, or Status Changed for workflow updates. All events appear in the Timeline." style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></h4>
                  <div style="margin-bottom: 0.5rem;">
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Event Type:</label>
                    <select id="optimisation-event-type" style="width: 100%; padding: 0.4rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);">
                      <option value="note">Note</option>
                      <option value="change_deployed">Change Deployed</option>
                      <option value="measurement">Measurement</option>
                      <option value="status_changed">Status Changed</option>
                    </select>
                  </div>
                  <div style="margin-bottom: 0.5rem;">
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Note:</label>
                    <textarea id="optimisation-event-note" rows="2" style="width: 100%; padding: 0.4rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);"></textarea>
                  </div>
                  <button id="optimisation-add-event-btn" class="btn btn-primary" style="width: 100%; padding: 0.5rem; font-size: 0.875rem; background: var(--dark-brand); color: #000000; font-weight: 700; border: 1px solid var(--dark-brand);" title="Adds the event to the timeline. Select the event type and add any notes, then click to record it.">Add Event</button>
                </div>

                <!-- Change Status -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; font-size: 0.95rem; color: var(--dark-text);">Change Status <span title="Status meanings:&#10; Planned: Task created but work not started&#10; In Progress: Currently being worked on&#10; Monitoring: Changes deployedmonitor metrics&#10; Done: Cycle completed; start a new cycle if optimising again&#10; Paused: Tracking stopped; you can start a new cycle later&#10; Cancelled: Tracking stopped; you can start a new cycle later&#10; Deleted: Task permanently removed" style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></h4>
                  <div style="display: flex; gap: 0.5rem;">
                    <select id="optimisation-change-status" style="flex: 1; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; background: var(--dark-bg); color: var(--dark-text);" title="Updates task workflow stage; adds a timeline event.">
                      <option value="">Change Status...</option>
                      <option value="planned" title="Task created but work not started">Planned</option>
                      <option value="in_progress" title="Currently being worked on">In Progress</option>
                      <option value="monitoring" title="Changes deployedmonitor metrics">Monitoring</option>
                      <option value="done" title="Cycle completed; start a new cycle if optimising again">Done</option>
                      <option value="paused" title="Tracking stopped; you can start a new cycle later">Paused</option>
                      <option value="cancelled" title="Tracking stopped; you can start a new cycle later">Cancelled</option>
                      <option value="deleted" title="Task permanently removed">Deleted</option>
                    </select>
                    <button id="optimisation-save-status-btn" class="btn btn-primary" title="Save the selected status change.">Save</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- History Panel -->
      <section class="aigeo-panel" data-panel="history">
        <!-- Supabase history charts / trend lines / previous audits will be inserted here by JS -->
      </section>

    </div>
      </div>
    </main>
    </div>

    <!-- Debug Panel - Fixed at bottom, collapsible -->
    <div class="debug-panel-bottom" id="debugPanel">
      <div class="debug-header" onclick="toggleDebugPanel()" style="cursor: pointer;">
        <h3> Debug Log</h3>
        <div class="debug-actions">
          <button class="btn btn-small" onclick="event.stopPropagation(); clearDebugLog();" title="Clear all debug log entries. Useful for starting fresh during troubleshooting.">Clear</button>
          <button class="btn btn-small" onclick="event.stopPropagation(); copyDebugLog();" title="Copy the entire debug log to your clipboard. Useful for sharing logs or troubleshooting issues.">Copy Log</button>
          <button class="btn btn-small" id="debugFilterBtn" onclick="event.stopPropagation(); toggleDebugLogFilter();" title="Filter to show only warnings and errors">Filter: All</button>
          <span id="debugToggleIcon" style="color: #fff; font-size: 1.2rem;"></span>
        </div>
      </div>
      <div class="debug-content" id="debugLog" style="display: block;">
        <div class="debug-log-entry info">
          <span class="debug-timestamp">[Initializing...]</span>Debug panel loaded. Waiting for page initialization...
        </div>
      </div>
    </div>
  </div>

  <script>
    // Immediate console log to verify script is running
    console.log('%c=== GAIO AUDIT DASHBOARD LOADED ===', 'color: #E57200; font-size: 16px; font-weight: bold;');
    console.log('%cDebug panel should be visible at bottom with orange border', 'color: #E57200; font-size: 14px;');
    console.log('Current time:', new Date().toISOString());
    console.log('Page URL:', window.location.href);
    
    // Helper function to safely save to localStorage (handles quota errors gracefully)
    // Define apiUrl helper IMMEDIATELY at the top level so it's available to all functions
    // This must be defined before any functions that use it
    (function() {
      const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
        ? 'https://ai-geo-audit.vercel.app' // Change this to your Vercel deployment URL
        : '';
      
      window.apiUrl = function apiUrl(path) {
        if (!API_BASE_URL) {
          // When deployed on Vercel, use relative paths
          return path.startsWith('/') ? path : `/${path}`;
        }
        // When running locally, prepend the Vercel URL
        // Handle paths with or without leading slash
        const cleanPath = path.startsWith('/') ? path : `/${path}`;
        return `${API_BASE_URL}${cleanPath}`;
      };
    })();
    
    // ======================
    // Optimisation Tracking Utilities (Phase 2)
    // ======================
    // Normalization functions matching DB helpers (arp_keyword_key, arp_clean_url)
    window.keywordKey = function keywordKey(keyword) {
      if (!keyword || typeof keyword !== 'string') return null;
      return keyword.trim().replace(/\s+/g, ' ').toLowerCase();
    };

    window.cleanUrlForKey = function cleanUrlForKey(url) {
      if (!url || typeof url !== 'string') return null;
      // Remove fragment (#)
      let cleaned = url.split('#')[0];
      // Remove query string (?)
      cleaned = cleaned.split('?')[0];
      // Remove protocol (http:// or https://)
      cleaned = cleaned.replace(/^https?:\/\//, '');
      // Remove trailing slashes
      cleaned = cleaned.replace(/\/+$/, '');
      return cleaned;
    };

    // Clean URL but keep protocol (for display in modals)
    window.cleanUrlForDisplay = function cleanUrlForDisplay(url) {
      if (!url || typeof url !== 'string') return '';
      // Remove fragment (#)
      let cleaned = url.split('#')[0];
      // Remove query string (?)
      cleaned = cleaned.split('?')[0];
      // Remove trailing slashes
      cleaned = cleaned.replace(/\/+$/, '');
      return cleaned;
    };

    // Admin key utilities (Phase A - Security)
    window.getAdminKey = function getAdminKey() {
      if (typeof window === "undefined") return "";
      return sessionStorage.getItem("arp_admin_key") || "";
    };

    window.setAdminKey = function setAdminKey(key) {
      if (typeof window === "undefined") return;
      sessionStorage.setItem("arp_admin_key", key);
    };

    window.hasAdminKey = function hasAdminKey() {
      return window.getAdminKey().length > 0;
    };

    window.clearAdminKey = function clearAdminKey() {
      if (typeof window === "undefined") return;
      sessionStorage.removeItem("arp_admin_key");
    };

    // Share mode detection
    const urlParams = new URLSearchParams(window.location.search);
    window.isShareMode = urlParams.get('share') === '1';
    window.shareToken = urlParams.get('st') || '';

    // Helper to build headers with admin key or share token
    window.getOptimisationHeaders = function getOptimisationHeaders() {
      const headers = { 'Content-Type': 'application/json' };
      if (window.isShareMode && window.shareToken) {
        headers['x-arp-share-token'] = window.shareToken;
      } else {
      const adminKey = window.getAdminKey();
      if (adminKey) {
        headers['x-arp-admin-key'] = adminKey;
        }
      }
      return headers;
    };

    // Cache for optimisation status (keyed by keyword_key::target_url_clean::task_type)
    window.optimisationStatusCache = new Map();

    // Fetch optimisation statuses in bulk
    window.fetchOptimisationStatuses = async function fetchOptimisationStatuses(rows) {
      if (!rows || rows.length === 0) {
        window.optimisationStatusCache.clear();
        return;
      }

      try {
        // Build unique set of keyword keys and URL keys
        const keywordKeys = new Set();
        const urlKeys = new Set();
        rows.forEach(row => {
          const kwKey = window.keywordKey(row.keyword);
          const url = row.best_url || row.targetUrl || row.ranking_url || '';
          const urlKey = window.cleanUrlForKey(url);
          if (kwKey) keywordKeys.add(kwKey);
          if (urlKey) urlKeys.add(urlKey);
        });

        if (keywordKeys.size === 0) {
          window.optimisationStatusCache.clear();
          return;
        }

        // Fetch from API endpoint (we'll create this)
        const response = await fetch(apiUrl('/api/optimisation/status'), {
          method: 'POST',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            keyword_keys: Array.from(keywordKeys),
            url_keys: Array.from(urlKeys)
          })
        });

        if (!response.ok) {
          console.warn('[Optimisation] Failed to fetch statuses:', response.status);
          window.optimisationStatusCache.clear();
          return;
        }

        const data = await response.json();
        window.optimisationStatusCache.clear();

        // Build cache map: key = keyword_key::target_url_clean::task_type
        (data.statuses || []).forEach(status => {
          const key = `${status.keyword_key}::${status.target_url_clean}::${status.task_type || 'on_page'}`;
          window.optimisationStatusCache.set(key, status);
        });

        console.log(`[Optimisation] Loaded ${window.optimisationStatusCache.size} status records`);
      } catch (error) {
        console.error('[Optimisation] Error fetching statuses:', error);
        window.optimisationStatusCache.clear();
      }
    };

    // Get optimisation status for a row
    window.getOptimisationStatus = function getOptimisationStatus(row, taskType = 'on_page') {
      const kwKey = window.keywordKey(row.keyword);
      const url = row.best_url || row.targetUrl || row.ranking_url || '';
      const urlKey = window.cleanUrlForKey(url);
      
      if (!kwKey || !urlKey) return null;
      
      const key = `${kwKey}::${urlKey}::${taskType}`;
      return window.optimisationStatusCache.get(key) || null;
    };

    // ======================
    // Optimisation Tracking Modals (Phase 2)
    // ======================
    
    // Open Track Keyword modal
    window.openTrackKeywordModal = function openTrackKeywordModal(row, taskType = 'on_page') {
      console.log('[Optimisation] openTrackKeywordModal called', { row, taskType });
      const modal = document.getElementById('optimisation-track-modal');
      if (!modal) {
        console.error('[Optimisation] Track modal not found');
        alert('Track modal not found. Please refresh the page.');
        return;
      }

      // Get and clean URL (remove query strings and fragments)
      const rawUrl = row.best_url || row.targetUrl || row.ranking_url || '';
      console.log('[Optimisation] Raw URL:', rawUrl);
      if (!window.cleanUrlForDisplay) {
        console.error('[Optimisation] cleanUrlForDisplay function not found');
        alert('Error: cleanUrlForDisplay function not found. Please refresh the page.');
        return;
      }
      const cleanedUrl = window.cleanUrlForDisplay(rawUrl);
      console.log('[Optimisation] Cleaned URL:', cleanedUrl);

      // Populate fields
      document.getElementById('track-keyword-text').textContent = row.keyword;
      
      // Make URL clickable in Track modal
      const trackUrlContainer = document.getElementById('track-url-text');
      trackUrlContainer.innerHTML = ''; // Clear existing content
      if (cleanedUrl) {
        // Ensure URL has protocol
        let fullUrl = cleanedUrl;
        if (!fullUrl.startsWith('http://') && !fullUrl.startsWith('https://')) {
          fullUrl = 'https://' + fullUrl;
        }
        const urlLink = document.createElement('a');
        urlLink.href = fullUrl;
        urlLink.target = '_blank';
        urlLink.rel = 'noopener noreferrer';
        urlLink.textContent = cleanedUrl;
        urlLink.style.color = '#0284c7';
        urlLink.style.textDecoration = 'none';
        urlLink.style.fontWeight = '600';
        urlLink.style.wordBreak = 'break-all';
        urlLink.addEventListener('mouseenter', () => {
          urlLink.style.textDecoration = 'underline';
        });
        urlLink.addEventListener('mouseleave', () => {
          urlLink.style.textDecoration = 'none';
        });
        trackUrlContainer.appendChild(urlLink);
      } else {
        trackUrlContainer.textContent = 'No URL available';
      }
      
      document.getElementById('track-task-type').value = taskType;
      document.getElementById('track-status').value = 'planned';
      document.getElementById('track-title').value = '';
      document.getElementById('track-notes').value = '';
      // Reset objective fields
      document.getElementById('track-objective-title').value = '';
      document.getElementById('track-primary-kpi').value = '';
      document.getElementById('track-target-direction').value = '';
      document.getElementById('track-target-value').value = '';
      document.getElementById('track-timeframe-days').value = '';
      
      // Populate Plan / Hypothesis from Priority & Next Actions
      let planText = '';
      try {
        const scorecardData = buildKeywordScorecardData(row);
        if (scorecardData) {
          const actions = generateActionBullets(scorecardData);
          if (actions && actions.length > 0) {
            planText = actions.join('\n');
          }
        }
      } catch (e) {
        console.warn('[Optimisation] Error generating plan from scorecard:', e);
      }
      document.getElementById('track-plan').value = planText;

      // Store cleaned URL and row data for submit (row data needed for baseline metrics)
      modal.dataset.rowKeyword = row.keyword;
      modal.dataset.rowUrl = cleanedUrl;
      modal.dataset.taskType = taskType;
      // Store row data as JSON string for baseline metrics
      modal.dataset.rowData = JSON.stringify(row);

      modal.style.display = 'flex';
    };

    // Submit Track Keyword
    window.submitTrackKeyword = async function submitTrackKeyword() {
      const modal = document.getElementById('optimisation-track-modal');
      if (!modal) return;

      const keyword = modal.dataset.rowKeyword;
      // Get cleaned URL from dataset (already cleaned when modal opened)
      let targetUrl = modal.dataset.rowUrl || '';
      // Double-check it's cleaned (in case it was modified elsewhere)
      targetUrl = window.cleanUrlForDisplay(targetUrl);
      const taskType = modal.dataset.taskType || document.getElementById('track-task-type').value;
      const status = document.getElementById('track-status').value;
      const title = document.getElementById('track-title').value.trim();
      const notes = document.getElementById('track-notes').value.trim();
      
      // Get objective fields (Phase B)
      const objective_title = document.getElementById('track-objective-title').value.trim();
      const objective_kpi = document.getElementById('track-primary-kpi').value.trim(); // Map primary_kpi to objective_kpi
      const objective_metric = objective_kpi; // Use same value for metric
      const objective_direction = document.getElementById('track-target-direction').value.trim();
      const objective_target_delta = document.getElementById('track-target-value').value.trim() ? parseFloat(document.getElementById('track-target-value').value) : null;
      const objective_timeframe_days = document.getElementById('track-timeframe-days').value.trim() ? parseInt(document.getElementById('track-timeframe-days').value) : null;
      const objective_plan = document.getElementById('track-plan').value.trim();
      
      // Calculate objective_due_at if timeframe is set
      let objective_due_at = null;
      if (objective_timeframe_days) {
        const startDate = new Date();
        objective_due_at = new Date(startDate.getTime() + objective_timeframe_days * 24 * 60 * 60 * 1000).toISOString();
      }

      if (!keyword || !targetUrl) {
        alert('Missing keyword or URL');
        return;
      }

      // Build baseline metrics from row data (stored in modal dataset)
      const rowDataStr = modal.dataset.rowData;
      let baselineMetrics = null;
      if (rowDataStr) {
        try {
          const rowData = JSON.parse(rowDataStr);
          
          // Get queryTotal data for clicks, impressions, and CTR
          let queryTotal = null;
          if (typeof getQueryTotalForKeyword === 'function') {
            queryTotal = getQueryTotalForKeyword(keyword);
          }
          
          baselineMetrics = {
            gsc_clicks_28d: queryTotal?.clicks || rowData.gsc_clicks_28d || rowData.clicks_28d || null,
            gsc_impressions_28d: queryTotal?.impressions || rowData.gsc_impressions_28d || rowData.impressions_28d || null,
            // queryTotal.ctr is a percentage (0-100), convert to decimal for storage
            gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (rowData.gsc_ctr_28d || rowData.ctr_28d || null),
            current_rank: rowData.best_rank_group || rowData.current_rank || null,
            opportunity_score: rowData.opportunityScore || null,
            ai_overview: rowData.has_ai_overview || false,
            ai_citations: rowData.ai_alan_citations_count || 0,
            ai_citations_total: rowData.ai_total_citations || 0,
            classic_ranking_url: rowData.best_url || rowData.targetUrl || rowData.ranking_url || null,
            page_type: rowData.pageType || null,
            segment: rowData.segment || null,
            captured_at: new Date().toISOString()
          };
        } catch (e) {
          console.error('[Optimisation] Failed to parse row data for baseline metrics:', e);
        }
      }

      try {
        const response = await fetch(apiUrl('/api/optimisation/task'), {
          method: 'POST',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            keyword_text: keyword,
            target_url: targetUrl,
            task_type: taskType,
            status: status,
            title: title || null,
            notes: notes || null,
            baselineMetrics: baselineMetrics,
            // Phase B objective fields
            objective_title: objective_title || null,
            objective_kpi: objective_kpi || null,
            objective_metric: objective_metric || null,
            objective_direction: objective_direction || null,
            objective_target_delta: objective_target_delta,
            objective_timeframe_days: objective_timeframe_days,
            objective_due_at: objective_due_at,
            objective_plan: objective_plan || null,
            // Also set cycle_started_at when creating task
            cycle_started_at: new Date().toISOString()
          })
        });

        if (!response.ok) {
          if (response.status === 401) {
            throw new Error('Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.');
          }
          const error = await response.text();
          throw new Error(error || 'Failed to create task');
        }

        const result = await response.json();
        const createdTask = result.task;

        // Refresh status cache
        await window.fetchOptimisationStatuses([{ keyword, best_url: targetUrl }]);
        
        // Reload all tasks so the new task is available for the drawer
        if (typeof window.loadAllOptimisationTasks === 'function') {
          await window.loadAllOptimisationTasks();
        }
        
        // Close modal
        modal.style.display = 'none';
        
        // Ensure Ranking & AI tab stays active and refresh table
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        if (rankingTab) {
          // Use setActivePanel to properly show the panel
          if (typeof setActivePanel === 'function') {
            setActivePanel('ranking');
          } else {
            // Fallback: manually set active state
            document.querySelectorAll('.aigeo-panel').forEach(panel => {
              panel.classList.remove('is-active');
              panel.hidden = true;
            });
          rankingTab.classList.add('is-active');
            rankingTab.hidden = false;
          }
          
          // Update nav button states
          document.querySelectorAll('.aigeo-nav-item').forEach(btn => btn.classList.remove('is-active'));
          const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav-item')).find(btn => 
            btn.getAttribute('data-panel') === 'ranking'
          );
          if (rankingNavBtn) rankingNavBtn.classList.add('is-active');
          
          // Ensure panel is rendered
          if (typeof ensurePanelRendered === 'function') {
            ensurePanelRendered('ranking');
          }
        }
        
        // Trigger table re-render
        if (typeof renderRankingAiTab === 'function') {
          await renderRankingAiTab();
        } else if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        } else {
          console.warn('[Optimisation] renderRankingAiTab not found, refreshing page');
          // Preserve Ranking & AI tab state before reload
          sessionStorage.setItem('activeTab', 'ranking');
          window.location.hash = '#ranking';
          location.reload();
        }
      } catch (error) {
        console.error('[Optimisation] Error creating task:', error);
        alert('Failed to create task: ' + error.message);
      }
    };

    // Open Manage Optimisation modal
    window.openManageOptimisationModal = function openManageOptimisationModal(row, status, taskType = 'on_page') {
      const modal = document.getElementById('optimisation-manage-modal');
      if (!modal) {
        console.error('[Optimisation] Manage modal not found');
        return;
      }

      // Populate read-only fields
      document.getElementById('manage-keyword-text').textContent = row.keyword;
      
      // Make URL clickable in Manage modal
      const manageUrlContainer = document.getElementById('manage-url-text');
      const rawUrl = row.best_url || row.targetUrl || row.ranking_url || '';
      const urlText = window.cleanUrlForDisplay ? window.cleanUrlForDisplay(rawUrl) : window.cleanUrlForKey(rawUrl);
      manageUrlContainer.innerHTML = ''; // Clear existing content
      if (urlText) {
        // Ensure URL has protocol
        let fullUrl = urlText;
        if (!fullUrl.startsWith('http://') && !fullUrl.startsWith('https://')) {
          fullUrl = 'https://' + fullUrl;
        }
        const urlLink = document.createElement('a');
        urlLink.href = fullUrl;
        urlLink.target = '_blank';
        urlLink.rel = 'noopener noreferrer';
        urlLink.textContent = urlText;
        urlLink.style.color = '#0284c7';
        urlLink.style.textDecoration = 'none';
        urlLink.style.wordBreak = 'break-all';
        urlLink.addEventListener('mouseenter', () => {
          urlLink.style.textDecoration = 'underline';
        });
        urlLink.addEventListener('mouseleave', () => {
          urlLink.style.textDecoration = 'none';
        });
        manageUrlContainer.appendChild(urlLink);
      } else {
        manageUrlContainer.textContent = 'No URL available';
      }
      
      document.getElementById('manage-task-type-text').textContent = taskType;
      document.getElementById('manage-status-text').textContent = status.status;
      document.getElementById('manage-cycle-text').textContent = status.cycle_active || 1;
      document.getElementById('manage-last-activity-text').textContent = status.last_activity_at 
        ? new Date(status.last_activity_at).toLocaleDateString()
        : 'Never';

      // Set current status in dropdown
      document.getElementById('manage-status-select').value = status.status;

      // Store data for submit
      modal.dataset.taskId = status.id;
      modal.dataset.rowKeyword = row.keyword;
      modal.dataset.rowUrl = row.best_url || row.targetUrl || row.ranking_url || '';
      modal.dataset.taskType = taskType;
      modal.dataset.currentCycle = status.cycle_active || 1;
      modal.dataset.currentStatus = status.status; // Store actual status value for comparison

      modal.style.display = 'flex';
    };

    // Submit status change
    window.submitStatusChange = async function submitStatusChange(newStatusParam, taskIdParam) {
      // B5: Support both modal and drawer - accept optional parameters
      const modal = document.getElementById('optimisation-manage-modal');
      const drawerTaskId = window.optimisationModuleState?.currentTaskId;
      const modalTaskId = modal?.dataset.taskId;
      const taskId = taskIdParam || drawerTaskId || modalTaskId;
      
      if (!taskId) {
        console.warn('[Optimisation] No task ID found');
        return;
      }

      // Get status from parameter, modal select, or drawer select
      const newStatus = newStatusParam || 
        (modal ? document.getElementById('manage-status-select')?.value : null) ||
        document.getElementById('optimisation-change-status')?.value;
      
      if (!newStatus) {
        alert('Please select a status');
        return;
      }

      const oldStatus = modal?.dataset.currentStatus || 
        document.getElementById('manage-status-text')?.textContent ||
        document.getElementById('optimisation-drawer-status')?.textContent;

      if (oldStatus === newStatus) {
        alert('Status unchanged');
        return;
      }

      try {
        const headers = window.getOptimisationHeaders();
        console.log('[Optimisation] Updating status:', { taskId, newStatus, oldStatus, hasAdminKey: !!headers['x-arp-admin-key'] });
        
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'PATCH',
          headers: headers,
          body: JSON.stringify({
            status: newStatus
          })
        });

        console.log('[Optimisation] Response status:', response.status, response.statusText);
        console.log('[Optimisation] Response headers:', Object.fromEntries(response.headers.entries()));

        if (!response.ok) {
          // Clone response BEFORE reading to allow multiple reads
          const responseClone = response.clone();
          let errorMessage = 'Failed to update status';
          let errorDetails = null;
          
          try {
            // Try to read as JSON first (most APIs return JSON)
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
            errorDetails = errorData;
            console.error('[Optimisation] API error response:', errorData);
          } catch (e) {
            // If JSON parsing fails, try text from clone
            console.error('[Optimisation] JSON parse failed, trying text:', e);
            try {
              const errorText = await responseClone.text();
              console.error('[Optimisation] Error response text (length):', errorText ? errorText.length : 0);
              if (errorText && errorText.trim()) {
                // Try to parse as JSON if it looks like JSON
                try {
                  const parsed = JSON.parse(errorText);
                  errorMessage = parsed.error || parsed.message || errorText;
                  errorDetails = parsed;
                } catch (parseError) {
                  errorMessage = errorText.substring(0, 200); // Limit length
                  errorDetails = { rawText: errorText.substring(0, 500) };
                }
                console.error('[Optimisation] API error text:', errorText.substring(0, 200));
              } else {
                console.error('[Optimisation] Error response body is empty');
                errorDetails = { empty: true };
              }
            } catch (e2) {
              console.error('[Optimisation] Failed to read error response:', e2);
              errorDetails = { readError: e2.message };
            }
          }
          
          // Enhance error message based on status code
          if (response.status === 401) {
            errorMessage = 'Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.';
          } else if (response.status === 404) {
            errorMessage = 'Task not found. It may have been deleted.';
          } else if (response.status === 403) {
            errorMessage = 'Forbidden - you do not have permission to update this task.';
          } else if (response.status === 500) {
            errorMessage = `Server error (${response.status}): ${errorMessage}`;
          } else {
            errorMessage = `HTTP ${response.status}: ${errorMessage}`;
          }
          
          console.error('[Optimisation] Full error details:', {
            status: response.status,
            statusText: response.statusText,
            errorMessage,
            errorDetails
          });
          
          throw new Error(errorMessage);
        }

        // Read successful response
        const result = await response.json();
        console.log('[Optimisation] Status update successful:', result);

        // Refresh data
        if (modal && modal.dataset.rowKeyword) {
        await window.fetchOptimisationStatuses([{
          keyword: modal.dataset.rowKeyword,
          best_url: modal.dataset.rowUrl
        }]);
        }
        
        // Refresh all tasks if drawer is open
        if (window.optimisationModuleState?.currentTaskId) {
          await window.loadAllOptimisationTasks();
        }
        
        // Close modal if open
        if (modal) {
        modal.style.display = 'none';
        }
        
        // Ensure Ranking & AI tab stays active and refresh table (only if modal was used)
        if (modal && modal.dataset.rowKeyword) {
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        if (rankingTab) {
          // Use setActivePanel to properly show the panel
          if (typeof setActivePanel === 'function') {
            setActivePanel('ranking');
          } else {
            // Fallback: manually set active state
            document.querySelectorAll('.aigeo-panel').forEach(panel => {
              panel.classList.remove('is-active');
              panel.hidden = true;
            });
          rankingTab.classList.add('is-active');
            rankingTab.hidden = false;
          }
          
          // Update nav button states
          document.querySelectorAll('.aigeo-nav-item').forEach(btn => btn.classList.remove('is-active'));
          const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav-item')).find(btn => 
            btn.getAttribute('data-panel') === 'ranking'
          );
          if (rankingNavBtn) rankingNavBtn.classList.add('is-active');
          
          // Ensure panel is rendered
          if (typeof ensurePanelRendered === 'function') {
            ensurePanelRendered('ranking');
          }
        }
        }
        
        // Trigger table re-render
        if (typeof renderRankingAiTab === 'function') {
          await renderRankingAiTab();
        } else if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        } else {
          console.warn('[Optimisation] renderRankingAiTab not found, refreshing page');
          // Preserve Ranking & AI tab state before reload
          sessionStorage.setItem('activeTab', 'ranking');
          window.location.hash = '#ranking';
          location.reload();
        }
      } catch (error) {
        console.error('[Optimisation] Error updating status:', error);
        alert('Failed to update status: ' + error.message);
      }
    };

    // Start new cycle
    window.startNewCycle = async function startNewCycle() {
      const taskId = window.optimisationModuleState?.currentTaskId;
      
      if (!taskId) {
        console.warn('[Optimisation] No task ID found');
        return;
      }

      // Get current task to get cycle info
      const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      if (!task) {
        alert('Task not found. Please refresh the page.');
        return;
      }

      const currentCycleNo = task.cycle_no || task.cycle_active || 1;
      const newCycleNo = currentCycleNo + 1;

      // Show modal for editing new cycle objective
      const modal = document.getElementById('optimisation-new-cycle-modal');
      if (!modal) {
        alert('New cycle modal not found. Please refresh the page.');
        return;
      }

      // Populate with previous cycle's objective if it exists (for copying)
      if (task.objective_title) {
        document.getElementById('new-cycle-objective-title').value = task.objective_title;
      }
      if (task.primary_kpi) {
        document.getElementById('new-cycle-primary-kpi').value = task.primary_kpi;
      }
      if (task.target_direction) {
        document.getElementById('new-cycle-target-direction').value = task.target_direction;
      }
      if (task.target_value != null) {
        document.getElementById('new-cycle-target-value').value = task.target_value;
      }
      if (task.timeframe_days) {
        document.getElementById('new-cycle-timeframe-days').value = task.timeframe_days;
      }
      if (task.plan) {
        document.getElementById('new-cycle-plan').value = task.plan;
      }

      document.getElementById('new-cycle-cycle-no').textContent = `Cycle ${newCycleNo}`;
      modal.dataset.taskId = taskId;
      modal.style.display = 'flex';
    };

    window.submitNewCycle = async function submitNewCycle() {
      const modal = document.getElementById('optimisation-new-cycle-modal');
      if (!modal) return;

      const taskId = modal.dataset.taskId;
      if (!taskId) {
        alert('Task ID not found');
        return;
      }

      // Get objective fields
      const objective_title = document.getElementById('new-cycle-objective-title').value.trim();
      const primary_kpi = document.getElementById('new-cycle-primary-kpi').value.trim();
      const target_direction = document.getElementById('new-cycle-target-direction').value.trim();
      const target_value = document.getElementById('new-cycle-target-value').value.trim();
      const timeframe_days = document.getElementById('new-cycle-timeframe-days').value.trim();
      const plan = document.getElementById('new-cycle-plan').value.trim();

      try {
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/cycle`), {
          method: 'POST',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            objective_title: objective_title || null,
            primary_kpi: primary_kpi || null,
            target_direction: target_direction || null,
            target_value: target_value ? parseFloat(target_value) : null,
            timeframe_days: timeframe_days ? parseInt(timeframe_days) : null,
            plan: plan || null
          })
        });

        if (!response.ok) {
          if (response.status === 401) {
            throw new Error('Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.');
          }
          const errorData = await response.json();
          throw new Error(errorData.error || 'Failed to start new cycle');
        }

        const result = await response.json();
        
        // Update task in state immediately with returned task data (includes new cycle objective)
        if (result.task && window.optimisationModuleState && window.optimisationModuleState.allTasks) {
          const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
          if (taskIndex >= 0) {
            window.optimisationModuleState.allTasks[taskIndex] = result.task;
            console.log('[Optimisation] Updated task in state with new cycle data:', result.task);
          } else {
            window.optimisationModuleState.allTasks.push(result.task);
          }
          // Also update filtered tasks if it exists there
          if (window.optimisationModuleState.filteredTasks) {
            const filteredIndex = window.optimisationModuleState.filteredTasks.findIndex(t => t.id === taskId);
            if (filteredIndex >= 0) {
              window.optimisationModuleState.filteredTasks[filteredIndex] = result.task;
            }
          }
        }
        
        // Small delay to ensure view has updated with new cycle
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Refresh tasks to ensure all data is up to date
        await window.loadAllOptimisationTasks();
        
        // Reload drawer if it's open (will use updated task data)
        if (window.optimisationModuleState.currentTaskId === taskId) {
          // Force reload by closing and reopening
          const currentTaskId = window.optimisationModuleState.currentTaskId;
          window.optimisationModuleState.currentTaskId = null;
          await new Promise(resolve => setTimeout(resolve, 100));
          await window.openOptimisationTaskDrawer(currentTaskId);
        }
        
        modal.style.display = 'none';
        
        // Show success message with cycle info
        const cycleNo = result.cycle?.cycle_no || result.task?.cycle_active || 'new';
        alert(`Cycle ${cycleNo} started successfully!${result.baseline_from_audit ? ' Baseline set from latest audit.' : (result.baseline_from_measurement ? ' Baseline set from previous latest measurement.' : '')}`);
      } catch (error) {
        console.error('[Optimisation] Error starting new cycle:', error);
        alert('Failed to start new cycle: ' + error.message);
      }
    };

    // Edit Objective function
    // Edit objective (inline form)
    window.editObjective = async function editObjective() {
      const taskId = window.optimisationModuleState?.currentTaskId;
      if (!taskId) return;

      const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      if (!task) return;

      const form = document.getElementById('optimisation-edit-objective-form');
      const content = document.getElementById('optimisation-drawer-objective-content');
      if (!form || !content) return;

      // Populate form with current values (Phase 5: use objective from cycle, fallback to legacy)
      const objective = task.objective || task.cycle?.objective || null;
      
      if (objective) {
        // Phase 5 format
        document.getElementById('optimisation-edit-objective-title').value = objective.title || '';
        document.getElementById('optimisation-edit-objective-kpi').value = ''; // KPI label not used in Phase 5
        document.getElementById('optimisation-edit-objective-metric').value = objective.kpi || '';
        document.getElementById('optimisation-edit-objective-direction').value = objective.target_type === 'absolute' ? 'at_least' : 'increase'; // Default
        document.getElementById('optimisation-edit-objective-target-value').value = objective.target != null ? objective.target : '';
        document.getElementById('optimisation-edit-objective-plan').value = objective.plan || '';
        
        // Calculate timeframe from due_at if available
        if (objective.due_at) {
          const dueDate = new Date(objective.due_at);
          const taskStart = task.cycle_started_at || task.cycle_start_date || new Date();
          const startDate = new Date(taskStart);
          const daysDiff = Math.round((dueDate - startDate) / (1000 * 60 * 60 * 24));
          document.getElementById('optimisation-edit-objective-timeframe').value = daysDiff > 0 ? daysDiff : '';
          
          const dueDateEl = document.getElementById('optimisation-edit-objective-due-date');
          if (dueDateEl) {
            dueDateEl.textContent = `Due: ${dueDate.toLocaleDateString('en-GB')}`;
          }
        } else {
          document.getElementById('optimisation-edit-objective-timeframe').value = '';
        }
      } else {
        // Legacy format fallback
        document.getElementById('optimisation-edit-objective-title').value = task.objective_title || '';
        document.getElementById('optimisation-edit-objective-kpi').value = task.objective_kpi || task.objective_metric || '';
        document.getElementById('optimisation-edit-objective-metric').value = task.objective_metric || task.objective_kpi || '';
        document.getElementById('optimisation-edit-objective-direction').value = task.objective_direction || '';
        document.getElementById('optimisation-edit-objective-target-value').value = task.objective_target_delta != null ? task.objective_target_delta : (task.objective_target_value != null ? task.objective_target_value : '');
        document.getElementById('optimisation-edit-objective-timeframe').value = task.objective_timeframe_days != null ? task.objective_timeframe_days : '';
        document.getElementById('optimisation-edit-objective-plan').value = task.objective_plan || '';
        
        // If objective_due_at exists, calculate and display it
        if (task.objective_due_at) {
          const dueDateEl = document.getElementById('optimisation-edit-objective-due-date');
          if (dueDateEl) {
            const dueDate = new Date(task.objective_due_at);
            dueDateEl.textContent = `Due: ${dueDate.toLocaleDateString('en-GB')}`;
          }
        }
      }

      // Calculate and show due date
      updateObjectiveDueDate();

      // Show form, hide content
      form.style.display = 'block';
      content.style.display = 'none';
    };

    // Update due date display when timeframe changes
    function updateObjectiveDueDate() {
      const timeframeInput = document.getElementById('optimisation-edit-objective-timeframe');
      const dueDateEl = document.getElementById('optimisation-edit-objective-due-date');
      if (!timeframeInput || !dueDateEl) return;

      const timeframe = parseInt(timeframeInput.value);
      if (timeframe > 0) {
        const taskId = window.optimisationModuleState?.currentTaskId;
        const task = window.optimisationModuleState?.allTasks?.find(t => t.id === taskId);
        const startDate = task?.cycle_started_at || task?.cycle_start_date || new Date();
        const dueDate = new Date(new Date(startDate).getTime() + timeframe * 24 * 60 * 60 * 1000);
        dueDateEl.textContent = `Due: ${dueDate.toLocaleDateString('en-GB')}`;
      } else {
        dueDateEl.textContent = '';
      }
    }

    // Save objective
    window.saveObjective = async function saveObjective() {
      const taskId = window.optimisationModuleState?.currentTaskId;
      if (!taskId) {
        alert('Task ID not found');
        return;
      }

      // Get form values (Phase 5 format)
      const title = document.getElementById('optimisation-edit-objective-title').value.trim();
      const kpi = document.getElementById('optimisation-edit-objective-metric').value || null;
      const targetValue = document.getElementById('optimisation-edit-objective-target-value').value;
      const target = targetValue ? (kpi === 'ai_overview' ? targetValue === 'true' : parseFloat(targetValue)) : null;
      const direction = document.getElementById('optimisation-edit-objective-direction').value || null;
      
      // Determine target_type based on KPI
      let target_type = 'delta';
      if (kpi === 'ai_overview' || kpi === 'current_rank') {
        target_type = 'absolute';
      } else if (direction === 'at_least' || direction === 'at_most') {
        target_type = 'absolute';
      }

      const timeframeDays = document.getElementById('optimisation-edit-objective-timeframe').value;
      const plan = document.getElementById('optimisation-edit-objective-plan').value.trim() || null;

      // Calculate due_at if timeframe is set
      let due_at = null;
      if (timeframeDays) {
        const task = window.optimisationModuleState?.allTasks?.find(t => t.id === taskId);
        const startDate = task?.cycle_started_at || task?.cycle_start_date ? new Date(task.cycle_started_at || task.cycle_start_date) : new Date();
        due_at = new Date(startDate.getTime() + parseInt(timeframeDays) * 24 * 60 * 60 * 1000).toISOString();
      }

      // Phase 5: Send new format
      const objectiveData = {
        title: title || null,
        kpi: kpi || null,
        target: target,
        target_type: target_type,
        due_at: due_at,
        plan: plan
      };

      try {
        const headers = window.getOptimisationHeaders();
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/objective`), {
          method: 'PATCH',
          headers: { ...headers, 'Content-Type': 'application/json' },
          body: JSON.stringify(objectiveData)
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || error.errors?.join(', ') || 'Failed to save objective');
        }

        const data = await response.json();

        // Hide edit form
        document.getElementById('optimisation-edit-objective-form').style.display = 'none';
        document.getElementById('optimisation-drawer-objective-content').style.display = 'block';

        // Reload tasks and refresh drawer
        if (typeof window.loadAllOptimisationTasks === 'function') {
          await window.loadAllOptimisationTasks();
        }
        await window.openOptimisationTaskDrawer(taskId);
      } catch (error) {
        console.error('[Optimisation] Error saving objective:', error);
        alert('Failed to save objective: ' + error.message);
      }
    };

    // Cancel edit objective
    window.cancelEditObjective = function cancelEditObjective() {
      const form = document.getElementById('optimisation-edit-objective-form');
      const content = document.getElementById('optimisation-drawer-objective-content');
      if (form) form.style.display = 'none';
      if (content) content.style.display = 'block';
    };

    // Old modal-based edit (keeping for backward compatibility but not used)
    window.editObjectiveOld = async function editObjectiveOld() {
      const taskId = window.optimisationModuleState?.currentTaskId;
      if (!taskId) return;

      const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      if (!task) return;

      // Show edit modal (reuse new cycle modal structure)
      const modal = document.getElementById('optimisation-edit-objective-modal');
      if (!modal) {
        alert('Edit objective modal not found. Please refresh the page.');
        return;
      }

      // Populate with current objective
      document.getElementById('edit-objective-title').value = task.objective_title || '';
      document.getElementById('edit-objective-primary-kpi').value = task.primary_kpi || '';
      document.getElementById('edit-objective-target-direction').value = task.target_direction || '';
      document.getElementById('edit-objective-target-value').value = task.target_value || '';
      document.getElementById('edit-objective-timeframe-days').value = task.timeframe_days || '';
      document.getElementById('edit-objective-plan').value = task.plan || '';

      modal.dataset.taskId = taskId;
      modal.style.display = 'flex';
    };

    window.submitEditObjective = async function submitEditObjective() {
      const modal = document.getElementById('optimisation-edit-objective-modal');
      if (!modal) return;

      const taskId = modal.dataset.taskId;
      if (!taskId) {
        alert('Task ID not found');
        return;
      }

      // Get objective fields
      const objective_title = document.getElementById('edit-objective-title').value.trim();
      const primary_kpi = document.getElementById('edit-objective-primary-kpi').value.trim();
      const target_direction = document.getElementById('edit-objective-target-direction').value.trim();
      const target_value = document.getElementById('edit-objective-target-value').value.trim();
      const timeframe_days = document.getElementById('edit-objective-timeframe-days').value.trim();
      const plan = document.getElementById('edit-objective-plan').value.trim();

      try {
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'PATCH',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            objective_title: objective_title || null,
            primary_kpi: primary_kpi || null,
            target_direction: target_direction || null,
            target_value: target_value ? parseFloat(target_value) : null,
            timeframe_days: timeframe_days ? parseInt(timeframe_days) : null,
            plan: plan || null
          })
        });

        if (!response.ok) {
          if (response.status === 401) {
            throw new Error('Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.');
          }
          const errorData = await response.json();
          throw new Error(errorData.error || 'Failed to update objective');
        }

        // Refresh tasks and reload drawer
        await window.loadAllOptimisationTasks();
        
        // Reload drawer if it's open
        if (window.optimisationModuleState.currentTaskId === taskId) {
          await window.openOptimisationTaskDrawer(taskId);
        }
        
        modal.style.display = 'none';
        
        alert('Objective updated successfully!');
      } catch (error) {
        console.error('[Optimisation] Error updating objective:', error);
        alert('Failed to update objective: ' + error.message);
      }
    };

    // Helper function to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Stop tracking
    window.stopTracking = async function stopTracking() {
      // B5: Support both modal and drawer
      const modal = document.getElementById('optimisation-manage-modal');
      const drawerTaskId = window.optimisationModuleState?.currentTaskId;
      const modalTaskId = modal?.dataset.taskId;
      const taskId = drawerTaskId || modalTaskId;
      
      if (!taskId) {
        console.warn('[Optimisation] No task ID found in modal or drawer');
        return;
      }

      if (!confirm('Stop tracking this keyword? The task will be marked as cancelled but history will be preserved.')) {
        return;
      }

      try {
        const headers = window.getOptimisationHeaders();
        console.log('[Optimisation] Stopping tracking:', { taskId, hasAdminKey: !!headers['x-arp-admin-key'] });
        
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'PATCH',
          headers: headers,
          body: JSON.stringify({
            status: 'cancelled'
          })
        });

        console.log('[Optimisation] Response status:', response.status, response.statusText);

        if (!response.ok) {
          // Clone response BEFORE reading to allow multiple reads
          const responseClone = response.clone();
          let errorMessage = 'Failed to stop tracking';
          let errorDetails = null;
          
          try {
            // Try to read as JSON first (most APIs return JSON)
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
            errorDetails = errorData;
            console.error('[Optimisation] API error response:', errorData);
          } catch (e) {
            // If JSON parsing fails, try text from clone
            console.error('[Optimisation] JSON parse failed, trying text:', e);
            try {
              const errorText = await responseClone.text();
              console.error('[Optimisation] Error response text (length):', errorText ? errorText.length : 0);
              if (errorText && errorText.trim()) {
                // Try to parse as JSON if it looks like JSON
                try {
                  const parsed = JSON.parse(errorText);
                  errorMessage = parsed.error || parsed.message || errorText;
                  errorDetails = parsed;
                } catch (parseError) {
                  errorMessage = errorText.substring(0, 200); // Limit length
                  errorDetails = { rawText: errorText.substring(0, 500) };
                }
                console.error('[Optimisation] API error text:', errorText.substring(0, 200));
              } else {
                console.error('[Optimisation] Error response body is empty');
                errorDetails = { empty: true };
              }
            } catch (e2) {
              console.error('[Optimisation] Failed to read error response:', e2);
              errorDetails = { readError: e2.message };
            }
          }
          
          // Enhance error message based on status code
          if (response.status === 401) {
            errorMessage = 'Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.';
          } else if (response.status === 404) {
            errorMessage = 'Task not found. It may have been deleted.';
          } else if (response.status === 403) {
            errorMessage = 'Forbidden - you do not have permission to update this task.';
          } else if (response.status === 500) {
            errorMessage = `Server error (${response.status}): ${errorMessage}`;
          } else {
            errorMessage = `HTTP ${response.status}: ${errorMessage}`;
          }
          
          console.error('[Optimisation] Full error details:', {
            status: response.status,
            statusText: response.statusText,
            errorMessage,
            errorDetails
          });
          
          throw new Error(errorMessage);
        }
        
        // Read successful response
        const result = await response.json();
        console.log('[Optimisation] Stop tracking successful:', result);

        // Refresh data
        if (modal && modal.dataset.rowKeyword) {
        await window.fetchOptimisationStatuses([{
          keyword: modal.dataset.rowKeyword,
          best_url: modal.dataset.rowUrl
        }]);
        }
        
        // Refresh all tasks if drawer is open
        if (window.optimisationModuleState?.currentTaskId) {
          await window.loadAllOptimisationTasks();
        }
        
        // Close modal if open, drawer if open
        if (modal) {
        modal.style.display = 'none';
        }
        if (window.optimisationModuleState?.currentTaskId) {
          closeOptimisationTaskDrawer();
        }
        
        // Ensure Ranking & AI tab stays active and refresh table
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        if (rankingTab) {
          // Use setActivePanel to properly show the panel
          if (typeof setActivePanel === 'function') {
            setActivePanel('ranking');
          } else {
            // Fallback: manually set active state
            document.querySelectorAll('.aigeo-panel').forEach(panel => {
              panel.classList.remove('is-active');
              panel.hidden = true;
            });
          rankingTab.classList.add('is-active');
            rankingTab.hidden = false;
          }
          
          // Update nav button states
          document.querySelectorAll('.aigeo-nav-item').forEach(btn => btn.classList.remove('is-active'));
          const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav-item')).find(btn => 
            btn.getAttribute('data-panel') === 'ranking'
          );
          if (rankingNavBtn) rankingNavBtn.classList.add('is-active');
          
          // Ensure panel is rendered
          if (typeof ensurePanelRendered === 'function') {
            ensurePanelRendered('ranking');
          }
        }
        
        // Trigger table re-render
        if (typeof renderRankingAiTab === 'function') {
          await renderRankingAiTab();
        } else if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        } else {
          console.warn('[Optimisation] renderRankingAiTab not found, refreshing page');
          // Preserve Ranking & AI tab state before reload
          sessionStorage.setItem('activeTab', 'ranking');
          window.location.hash = '#ranking';
          location.reload();
        }
      } catch (error) {
        console.error('[Optimisation] Error stopping tracking:', error);
        alert('Failed to stop tracking: ' + error.message);
      }
    };

    // Delete task (hard delete - removes task and all events)
    window.deleteTask = async function deleteTask() {
      const taskId = window.optimisationModuleState?.currentTaskId;
      
      if (!taskId) {
        console.warn('[Optimisation] No task ID found');
        return;
      }

      if (!confirm('Permanently delete this task and all its events? This cannot be undone.')) {
        return;
      }

      try {
        const headers = window.getOptimisationHeaders();
        console.log('[Optimisation] Deleting task:', { taskId, hasAdminKey: !!headers['x-arp-admin-key'] });
        
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'DELETE',
          headers: headers
        });

        console.log('[Optimisation] Response status:', response.status, response.statusText);

        if (!response.ok) {
          const responseClone = response.clone();
          let errorMessage = 'Failed to delete task';
          
          try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
            console.error('[Optimisation] API error response:', errorData);
          } catch (e) {
            try {
              const errorText = await responseClone.text();
              if (errorText && errorText.trim()) {
                try {
                  const parsed = JSON.parse(errorText);
                  errorMessage = parsed.error || parsed.message || errorText;
                } catch (parseError) {
                  errorMessage = errorText.substring(0, 200);
                }
              }
            } catch (e2) {
              console.error('[Optimisation] Failed to read error response:', e2);
            }
          }
          
          if (response.status === 401) {
            errorMessage = 'Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.';
          } else if (response.status === 404) {
            errorMessage = 'Task not found. It may have been deleted.';
          } else if (response.status === 403) {
            errorMessage = 'Forbidden - you do not have permission to update this task.';
          } else if (response.status === 500) {
            errorMessage = `Server error (${response.status}): ${errorMessage}`;
          } else {
            errorMessage = `HTTP ${response.status}: ${errorMessage}`;
          }
          
          throw new Error(errorMessage);
        }
        
        const result = await response.json();
        console.log('[Optimisation] Delete task successful:', result);

        // Close the modal/drawer
        const drawer = document.getElementById('optimisation-task-drawer');
        if (drawer) {
          drawer.style.display = 'none';
        }

        // Clear the cache to force refresh
        if (window.optimisationStatusCache) {
          window.optimisationStatusCache.clear();
        }

        // Refresh Optimisation Tracking table
        await window.loadAllOptimisationTasks();

        // Refresh Ranking & AI table to show "Not tracked"
        if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        }
      } catch (error) {
        console.error('[Optimisation] Error deleting task:', error);
        throw error; // Re-throw so caller can handle
      }
    };

    // ======================
    // Optimisation Tracking Module (Phase B)
    // ======================
    
    // State
    window.optimisationModuleState = {
      allTasks: [],
      dashboardTiles: null,
      dashboardImpact: null,
      dashboardTimeseries: null,
      filteredTasks: [],
      activeTab: 'active',
      currentTaskId: null,
      authError: null,
      activeObjectiveFilter: null, // 'not_set' | 'on_track' | 'overdue' | 'met' | null
      scope: 'active_cycle', // 'active_cycle' | 'all_tasks'
      metricTrafficFilter: null // { metricKey: string, bucket: 'better'|'same'|'worse' } | null
    };
    
    // Traffic Light Utility Functions (inline from lib/optimisation/metricTraffic.js)
    function isActiveStatus(status) {
      return ['planned', 'in_progress', 'monitoring'].includes(status);
    }

    function getBaselineLatest(measurements, scope, activeCycle = null) {
      if (!measurements || measurements.length === 0) {
        return null;
      }

      let eligibleMeasurements = [...measurements];

      // Filter by scope
      if (scope === 'active_cycle' && activeCycle) {
        const cycleStartDate = activeCycle.start_date ? new Date(activeCycle.start_date) : 
                              (activeCycle.started_at ? new Date(activeCycle.started_at) : null);
        if (cycleStartDate) {
          eligibleMeasurements = eligibleMeasurements.filter(m => {
            const mDate = m.captured_at ? new Date(m.captured_at) : null;
            return mDate && mDate >= cycleStartDate;
          });
        }
      }

      // Need at least 2 measurements to compute baseline/latest
      if (eligibleMeasurements.length < 2) {
        return null;
      }

      // Sort by date (oldest first)
      eligibleMeasurements.sort((a, b) => {
        const dateA = a.captured_at ? new Date(a.captured_at) : new Date(0);
        const dateB = b.captured_at ? new Date(b.captured_at) : new Date(0);
        return dateA - dateB;
      });

      const baseline = eligibleMeasurements[0];
      const latest = eligibleMeasurements[eligibleMeasurements.length - 1];

      return { baseline, latest };
    }

    function getMetricValue(measurement, metricKey) {
      if (!measurement) return null;

      const extractors = {
        ctr_28d: (m) => m?.ctr_28d ?? null,
        impressions_28d: (m) => m?.impressions_28d ?? null,
        clicks_28d: (m) => m?.clicks_28d ?? null,
        current_rank: (m) => m?.current_rank ?? m?.rank ?? null,
        opportunity_score: (m) => m?.opportunity_score ?? null,
        ai_overview: (m) => m?.ai_overview ?? null,
        ai_citations: (m) => m?.ai_citations ?? null,
      };

      const extractor = extractors[metricKey];
      if (!extractor) return null;

      return extractor(measurement);
    }

    function classifyMetric(metricKey, baseline, latest) {
      if (!baseline || !latest) {
        return null;
      }

      const baselineValue = getMetricValue(baseline, metricKey);
      const latestValue = getMetricValue(latest, metricKey);

      // If either value is null/undefined, cannot classify
      if (baselineValue == null || latestValue == null) {
        return null;
      }

      // CTR (28d) - stored as ratio (0-1), compare as percentage points
      if (metricKey === 'ctr_28d') {
        const deltaPp = (latestValue - baselineValue) * 100;
        if (Math.abs(deltaPp) < 0.10) {
          return 'same';
        }
        return deltaPp >= 0.10 ? 'better' : 'worse';
      }

      // Impressions (28d)
      if (metricKey === 'impressions_28d') {
        const delta = latestValue - baselineValue;
        const tol = Math.max(20, Math.round(baselineValue * 0.02));
        if (Math.abs(delta) < tol) {
          return 'same';
        }
        return delta >= tol ? 'better' : 'worse';
      }

      // Clicks (28d)
      if (metricKey === 'clicks_28d') {
        const delta = latestValue - baselineValue;
        const tol = Math.max(5, Math.round(baselineValue * 0.05));
        if (Math.abs(delta) < tol) {
          return 'same';
        }
        return delta >= tol ? 'better' : 'worse';
      }

      // Rank (lower is better)
      if (metricKey === 'current_rank') {
        const delta = latestValue - baselineValue; // positive means rank got worse (increased)
        if (Math.abs(delta) < 0.5) {
          return 'same';
        }
        return delta <= -0.5 ? 'better' : 'worse';
      }

      // AI Citations
      if (metricKey === 'ai_citations') {
        const delta = latestValue - baselineValue;
        if (delta === 0) {
          return 'same';
        }
        return delta > 0 ? 'better' : 'worse';
      }

      // AI Overview (boolean)
      if (metricKey === 'ai_overview') {
        const baselineBool = baselineValue === true || baselineValue === 'On' || baselineValue === 1;
        const latestBool = latestValue === true || latestValue === 'On' || latestValue === 1;
        
        if (baselineBool === latestBool) {
          return 'same';
        }
        // Better: Off -> On, Worse: On -> Off
        return (!baselineBool && latestBool) ? 'better' : 'worse';
      }

      // Opportunity Score
      if (metricKey === 'opportunity_score') {
        const delta = latestValue - baselineValue;
        if (Math.abs(delta) < 2) {
          return 'same';
        }
        return delta >= 2 ? 'better' : 'worse';
      }

      // Unknown metric
      return null;
    }

    // Helper: Get latest measurement in scope for a task
    function getLatestMeasurementInScope(task, scope) {
      const measurements = task.measurements || [];
      if (measurements.length === 0) {
        return null;
      }

      let eligibleMeasurements = [...measurements];

      // Filter by scope
      if (scope === 'active_cycle') {
        const activeCycle = task.cycles?.find(c => c.is_active || c.id === task.active_cycle_id) || null;
        if (activeCycle) {
          const cycleStartDate = activeCycle.start_date ? new Date(activeCycle.start_date) : 
                                (activeCycle.started_at ? new Date(activeCycle.started_at) : null);
          if (cycleStartDate) {
            eligibleMeasurements = eligibleMeasurements.filter(m => {
              const mDate = m.captured_at ? new Date(m.captured_at) : null;
              return mDate && mDate >= cycleStartDate;
            });
          }
        }
      }
      // For 'all_tasks' scope, use all measurements

      if (eligibleMeasurements.length === 0) {
        return null;
      }

      // Sort by date (newest first) and return the latest
      eligibleMeasurements.sort((a, b) => {
        const dateA = a.captured_at ? new Date(a.captured_at) : new Date(0);
        const dateB = b.captured_at ? new Date(b.captured_at) : new Date(0);
        return dateB - dateA; // Descending (newest first)
      });

      return eligibleMeasurements[0];
    }

    // Helper: Get Monday-start week key (YYYY-MM-DD)
    function weekStartISO(date) {
      const d = new Date(date);
      d.setHours(0, 0, 0, 0);
      // Get day of week (0 = Sunday, 1 = Monday, etc.)
      const day = d.getDay();
      // Calculate days to subtract to get to Monday
      const diff = day === 0 ? 6 : day - 1; // If Sunday, go back 6 days; otherwise go back (day-1) days
      d.setDate(d.getDate() - diff);
      // Return YYYY-MM-DD format
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, '0');
      const dayOfMonth = String(d.getDate()).padStart(2, '0');
      return `${year}-${month}-${dayOfMonth}`;
    }

    // Helper: Compute delta for a KPI with correct units
    function computeDeltaForKPI(kpi, baseline, latest) {
      if (!baseline || !latest) {
        return null;
      }

      const baselineValue = getMetricValue(baseline, kpi);
      const latestValue = getMetricValue(latest, kpi);

      if (baselineValue == null || latestValue == null) {
        return null;
      }

      // CTR: return as percentage points
      if (kpi === 'ctr_28d') {
        return (latestValue - baselineValue) * 100;
      }

      // Rank: lower is better, so invert the delta (baseline - latest)
      // Positive delta = improvement (rank decreased)
      if (kpi === 'current_rank') {
        return baselineValue - latestValue;
      }

      // All others: absolute delta (higher is better)
      return latestValue - baselineValue;
    }

    // Helper: Compute median of an array
    function median(values) {
      if (values.length === 0) return null;
      const sorted = [...values].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2 === 0
        ? (sorted[mid - 1] + sorted[mid]) / 2
        : sorted[mid];
    }

    function computeTrafficLightCounts(tasks, scope) {
      const counts = {
        ctr_28d: { worse: 0, same: 0, better: 0 },
        impressions_28d: { worse: 0, same: 0, better: 0 },
        clicks_28d: { worse: 0, same: 0, better: 0 },
        current_rank: { worse: 0, same: 0, better: 0 },
        ai_citations: { worse: 0, same: 0, better: 0 },
        ai_overview: { worse: 0, same: 0, better: 0 },
        all_metrics: { worse: 0, same: 0, better: 0 }, // Aggregated counts
      };

      const metricKeys = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];

      for (const task of tasks) {
        // Only count active tasks
        if (!isActiveStatus(task.status)) {
          continue;
        }

        // Get active cycle if scope is 'active_cycle'
        const activeCycle = scope === 'active_cycle' 
          ? (task.cycles?.find(c => c.is_active || c.id === task.active_cycle_id) || null)
          : null;

        // Get measurements
        const measurements = task.measurements || [];
        const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);

        // Track classifications for all metrics to compute aggregated count
        const taskClassifications = [];

        if (baselineLatest) {
          // Classify each metric
          for (const metricKey of metricKeys) {
            const classification = classifyMetric(
              metricKey,
              baselineLatest.baseline,
              baselineLatest.latest
            );

            if (classification) {
              counts[metricKey][classification]++;
              taskClassifications.push(classification);
            }
          }
        }

        // For aggregated "all_metrics": count ALL active tasks
        // If task has classifications, use majority vote (at least 3 out of 6 metrics)
        // If no classifications or tie, default to 'same'
        if (taskClassifications.length > 0) {
          // Count occurrences of each classification
          const classCounts = { worse: 0, same: 0, better: 0 };
          taskClassifications.forEach(cls => {
            if (cls) classCounts[cls]++;
          });
          
          // Find the majority classification
          const total = classCounts.worse + classCounts.same + classCounts.better;
          const majority = Math.max(classCounts.worse, classCounts.same, classCounts.better);
          
          let majorityClass = null;
          if (classCounts.better === majority && majority > 0) {
            majorityClass = 'better';
          } else if (classCounts.worse === majority && majority > 0) {
            majorityClass = 'worse';
          } else if (classCounts.same === majority && majority > 0) {
            majorityClass = 'same';
          }
          
          // If there's a clear majority (more than half), use it
          // Otherwise default to 'same'
          if (majorityClass && majority > total / 2) {
            counts.all_metrics[majorityClass]++;
          } else {
            // No clear majority or no classifications - default to 'same'
            counts.all_metrics.same++;
          }
        } else {
          // Task has no metric classifications (insufficient data) - count as 'same'
          counts.all_metrics.same++;
        }
      }

      return counts;
    }

    // Sorting state
    let optimisationSortState = {
      column: 'latestCaptured',
      direction: 'desc'
    };
    
    // Pagination state
    let optimisationPaginationState = {
      currentPage: 1,
      rowsPerPage: 10
    };

    // Load all optimisation tasks (Phase 9: use dashboard API)
    window.loadAllOptimisationTasks = async function loadAllOptimisationTasks() {
      try {
        // Check if admin key is set
        if (!window.hasAdminKey || !window.hasAdminKey()) {
          window.optimisationModuleState.allTasks = [];
          window.optimisationModuleState.filteredTasks = [];
          window.optimisationModuleState.authError = 'Admin key not set. Please set your admin key in the Configuration section.';
          updateOptimisationSummaryCards();
          renderOptimisationTasksTable();
          return [];
        }

        const headers = window.getOptimisationHeaders();
        const scope = window.optimisationModuleState.scope || 'active_cycle';
        const response = await fetch(apiUrl(`/api/optimisation/dashboard?scope=${scope}`), {
          method: 'GET',
          headers: headers
        });

        if (!response.ok) {
          if (response.status === 401) {
            window.optimisationModuleState.authError = 'Unauthorized - admin key missing or invalid. Please check your admin key in the Configuration section.';
          } else {
            window.optimisationModuleState.authError = `Failed to load dashboard (${response.status}). Please try refreshing the page.`;
          }
          window.optimisationModuleState.allTasks = [];
          window.optimisationModuleState.filteredTasks = [];
          window.optimisationModuleState.dashboardTiles = null;
          window.optimisationModuleState.dashboardImpact = null;
          window.optimisationModuleState.dashboardTimeseries = null;
          updateOptimisationSummaryCards();
          renderOptimisationTasksTable();
          return [];
        }

        // Clear any previous auth errors
        window.optimisationModuleState.authError = null;

        const data = await response.json();
        window.optimisationModuleState.allTasks = data.tasks || [];
        window.optimisationModuleState.filteredTasks = [...window.optimisationModuleState.allTasks];
        window.optimisationModuleState.dashboardTiles = data.tiles || null;
        window.optimisationModuleState.dashboardImpact = data.impact || null;
        window.optimisationModuleState.dashboardTimeseries = data.timeseries || null;
        
        updateOptimisationSummaryCards();
        updateKPITiles();
        updateImpactTiles();
        updateTimeseriesCharts();
        updateTrafficLights();
        applyOptimisationFilters();
        renderOptimisationTasksTable();
        
        return window.optimisationModuleState.allTasks;
      } catch (error) {
        console.error('[Optimisation Module] Error loading dashboard:', error);
        window.optimisationModuleState.allTasks = [];
        window.optimisationModuleState.filteredTasks = [];
        window.optimisationModuleState.dashboardTiles = null;
        window.optimisationModuleState.dashboardImpact = null;
        window.optimisationModuleState.dashboardTimeseries = null;
        window.optimisationModuleState.authError = error.message || 'Failed to load dashboard. Please try refreshing the page.';
        updateOptimisationSummaryCards();
        renderOptimisationTasksTable();
        return [];
      }
    };

    // Update summary cards (B6)
    function updateOptimisationSummaryCards() {
      let tasks = window.optimisationModuleState.allTasks;
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      const active = tasks.filter(t => ['planned', 'in_progress', 'monitoring'].includes(t.status));
      const planned = tasks.filter(t => t.status === 'planned');
      const inProgress = tasks.filter(t => t.status === 'in_progress');
      const monitoring = tasks.filter(t => t.status === 'monitoring');
      const done = tasks.filter(t => t.status === 'done');
      const paused = tasks.filter(t => t.status === 'paused');
      const cancelled = tasks.filter(t => t.status === 'cancelled');
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      const recent = tasks.filter(t => {
        const lastActivity = t.last_activity_at ? new Date(t.last_activity_at) : new Date(t.updated_at);
        return lastActivity >= thirtyDaysAgo;
      });

      document.getElementById('optimisation-summary-active').textContent = active.length;
      document.getElementById('optimisation-summary-planned').textContent = planned.length;
      document.getElementById('optimisation-summary-in-progress').textContent = inProgress.length;
      document.getElementById('optimisation-summary-monitoring').textContent = monitoring.length;
      document.getElementById('optimisation-summary-done').textContent = done.length;
      document.getElementById('optimisation-summary-paused').textContent = paused.length;
      document.getElementById('optimisation-summary-cancelled').textContent = cancelled.length;
      document.getElementById('optimisation-summary-recent').textContent = recent.length;

      // Update tab counts
      const pausedCancelled = paused.length + cancelled.length;
      
      document.querySelectorAll('.optimisation-tab-count[data-tab="active"]').forEach(el => {
        el.textContent = `(${active.length})`;
      });
      document.querySelectorAll('.optimisation-tab-count[data-tab="done"]').forEach(el => {
        el.textContent = `(${done.length})`;
      });
      document.querySelectorAll('.optimisation-tab-count[data-tab="paused-cancelled"]').forEach(el => {
        el.textContent = `(${pausedCancelled})`;
      });

      // Update goal rollups (Phase B) - only count active tasks (not cancelled/deleted)
      const activeTasks = tasks.filter(t => !['done', 'cancelled', 'deleted'].includes(t.status));
      // Use objective_status from cycle (Phase 5) or fallback to goal_state
      const goalNotSet = activeTasks.filter(t => {
        const status = t.objective_status || t.goal_state;
        return !status || status === 'not_set';
      }).length;
      const goalOnTrack = activeTasks.filter(t => {
        const status = t.objective_status || t.goal_state;
        return status === 'on_track';
      }).length;
      const goalOverdue = activeTasks.filter(t => {
        const status = t.objective_status || t.goal_state;
        return status === 'overdue';
      }).length;
      const goalMet = activeTasks.filter(t => {
        const status = t.objective_status || t.goal_state;
        return status === 'met';
      }).length;

      const notSetEl = document.getElementById('optimisation-goal-not-set');
      const onTrackEl = document.getElementById('optimisation-goal-on-track');
      const overdueEl = document.getElementById('optimisation-goal-overdue');
      const metEl = document.getElementById('optimisation-goal-met');
      
      if (notSetEl) notSetEl.textContent = goalNotSet;
      if (onTrackEl) onTrackEl.textContent = goalOnTrack;
      if (overdueEl) overdueEl.textContent = goalOverdue;
      if (metEl) metEl.textContent = goalMet;
    }

    // Update timeseries charts
    // OLD updateTimeseriesCharts function removed - see new implementation below

    // Sort optimisation tasks
    function sortOptimisationTasks(tasks) {
      const sorted = [...tasks];
      sorted.sort((a, b) => {
        let aVal, bVal;
        switch (optimisationSortState.column) {
          case 'keyword':
            aVal = (a.keyword_text || '').toLowerCase();
            bVal = (b.keyword_text || '').toLowerCase();
            break;
          case 'url':
            aVal = (a.target_url_clean || '').toLowerCase();
            bVal = (b.target_url_clean || '').toLowerCase();
            break;
          case 'type':
            aVal = (a.task_type || 'on_page').toLowerCase();
            bVal = (b.task_type || 'on_page').toLowerCase();
            break;
          case 'status':
            aVal = (a.status || 'planned').toLowerCase();
            bVal = (b.status || 'planned').toLowerCase();
            break;
          case 'cycle':
            aVal = a.cycle_active || 1;
            bVal = b.cycle_active || 1;
            break;
          case 'lastActivity':
            aVal = a.last_activity_at ? new Date(a.last_activity_at).getTime() : (a.updated_at ? new Date(a.updated_at).getTime() : 0);
            bVal = b.last_activity_at ? new Date(b.last_activity_at).getTime() : (b.updated_at ? new Date(b.updated_at).getTime() : 0);
            break;
          case 'baselineCaptured':
            aVal = (a.baseline_metrics?.captured_at || a.baseline_metrics?.created_at) ? new Date(a.baseline_metrics.captured_at || a.baseline_metrics.created_at).getTime() : 0;
            bVal = (b.baseline_metrics?.captured_at || b.baseline_metrics?.created_at) ? new Date(b.baseline_metrics.captured_at || b.baseline_metrics.created_at).getTime() : 0;
            break;
          case 'latestCaptured':
            aVal = (a.latest_metrics?.captured_at || a.latest_metrics?.created_at) ? new Date(a.latest_metrics.captured_at || a.latest_metrics.created_at).getTime() : 0;
            bVal = (b.latest_metrics?.captured_at || b.latest_metrics?.created_at) ? new Date(b.latest_metrics.captured_at || b.latest_metrics.created_at).getTime() : 0;
            break;
          case 'title':
            aVal = (a.title || '').toLowerCase();
            bVal = (b.title || '').toLowerCase();
            break;
          default:
            return 0;
        }
        
        if (aVal < bVal) return optimisationSortState.direction === 'asc' ? -1 : 1;
        if (aVal > bVal) return optimisationSortState.direction === 'asc' ? 1 : -1;
        return 0;
      });
      return sorted;
    }

    // Render tasks table (B2)
    function renderOptimisationTasksTable() {
      const tbody = document.getElementById('optimisation-tasks-tbody');
      if (!tbody) return;

      let tasks = window.optimisationModuleState.filteredTasks;

      // Apply tab filter
      if (window.optimisationModuleState.activeTab === 'active') {
        tasks = tasks.filter(t => ['planned', 'in_progress', 'monitoring'].includes(t.status));
      } else if (window.optimisationModuleState.activeTab === 'done') {
        tasks = tasks.filter(t => t.status === 'done');
      } else if (window.optimisationModuleState.activeTab === 'paused-cancelled') {
        tasks = tasks.filter(t => ['paused', 'cancelled'].includes(t.status));
      }

      // Sort tasks
      tasks = sortOptimisationTasks(tasks);
      
      // Calculate pagination
      const totalRows = tasks.length;
      const rowsPerPage = optimisationPaginationState.rowsPerPage === 'all' ? totalRows : optimisationPaginationState.rowsPerPage;
      const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
      const currentPage = Math.min(Math.max(1, optimisationPaginationState.currentPage), totalPages);
      optimisationPaginationState.currentPage = currentPage;
      
      const startIdx = rowsPerPage === 'all' ? 0 : (currentPage - 1) * rowsPerPage;
      const endIdx = rowsPerPage === 'all' ? totalRows : Math.min(startIdx + rowsPerPage, totalRows);
      const paginatedTasks = tasks.slice(startIdx, endIdx);

      tbody.innerHTML = '';

        // Check for authentication error
      if (window.optimisationModuleState.authError) {
        const errorMessage = window.optimisationModuleState.authError;
        tbody.innerHTML = `<tr><td colspan="13" style="padding: 2rem; text-align: center;">
          <div style="color: #ef4444; margin-bottom: 0.5rem; font-weight: 600;"> Authentication Error</div>
          <div style="color: #666; margin-bottom: 1rem;">${escapeHtml(errorMessage)}</div>
          <a href="#configuration" onclick="if(typeof setActivePanel === 'function') setActivePanel('configuration');" style="color: #2563eb; text-decoration: underline;">Go to Configuration to set your admin key</a>
        </td></tr>`;
        updateOptimisationPaginationControls(0, 1, 1, 0, 0);
        return;
      }

      if (tasks.length === 0) {
        tbody.innerHTML = '<tr><td colspan="13" class="ranking-table-empty">No tasks found</td></tr>';
        updateOptimisationPaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx);
        return;
      }

      paginatedTasks.forEach((task, index) => {
        const tr = document.createElement('tr');
        tr.onclick = () => openOptimisationTaskDrawer(task.id);

        const statusColors = {
          planned: { bg: 'rgba(245, 158, 11, 0.3)', color: '#fbbf24' }, // Brighter amber
          in_progress: { bg: 'rgba(16, 185, 129, 0.3)', color: '#34d399' }, // Brighter green
          monitoring: { bg: 'rgba(59, 130, 246, 0.3)', color: '#60a5fa' }, // Brighter blue
          done: { bg: 'rgba(156, 163, 175, 0.3)', color: '#d1d5db' }, // Brighter grey
          paused: { bg: 'rgba(245, 158, 11, 0.3)', color: '#fbbf24' }, // Brighter amber
          cancelled: { bg: 'rgba(239, 68, 68, 0.3)', color: '#f87171' } // Brighter red
        };

        const statusStyle = statusColors[task.status] || statusColors.planned;
        const lastActivity = task.last_activity_at 
          ? new Date(task.last_activity_at).toLocaleDateString('en-GB')
          : new Date(task.updated_at).toLocaleDateString('en-GB');

        // Format baseline and latest captured dates
        // Use captured_at from metrics (set by view from event.created_at) or fallback to created_at
        const baselineCaptured = (task.baseline_metrics?.captured_at || task.baseline_metrics?.created_at)
          ? new Date(task.baseline_metrics.captured_at || task.baseline_metrics.created_at).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' })
          : '';
        const latestCapturedDate = (task.latest_metrics?.captured_at || task.latest_metrics?.created_at)
          ? new Date(task.latest_metrics.captured_at || task.latest_metrics.created_at)
          : null;
        const latestCaptured = latestCapturedDate 
          ? latestCapturedDate.toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' })
          : null;
        
        // "Needs update" indicator: blank or older than 30 days
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const needsUpdate = !latestCapturedDate || latestCapturedDate < thirtyDaysAgo;
        const needsUpdateBadge = needsUpdate 
          ? '<span style="padding: 0.125rem 0.375rem; background: #fee2e2; color: #991b1b; border-radius: 4px; font-size: 0.7rem; font-weight: 600; margin-left: 0.25rem;">Needs update</span>'
          : '';
        
        // "No measurement yet" indicator
        const measurementIndicator = !latestCaptured 
          ? '<span style="padding: 0.25rem 0.5rem; background: #fef3c7; color: #92400e; border-radius: 4px; font-size: 0.75rem;">No measurement yet</span>'
          : '';

        // Extract path from URL for display
        let urlPath = '';
        let fullUrl = '';
        const urlText = task.target_url_clean || task.target_url || '';
        if (urlText) {
          try {
            // If URL contains domain, extract just the path
            if (urlText.includes('alanranger.com')) {
              const urlObj = new URL(urlText.startsWith('http') ? urlText : 'https://' + urlText);
              urlPath = urlObj.pathname || '/';
              fullUrl = urlObj.href;
            } else if (urlText.startsWith('/')) {
              // Already a path
              urlPath = urlText;
              fullUrl = 'https://www.alanranger.com' + urlText;
            } else {
              // Assume it's a path without leading slash
              urlPath = '/' + urlText;
              fullUrl = 'https://www.alanranger.com/' + urlText;
            }
          } catch (e) {
            // Fallback: treat as path
            urlPath = urlText.startsWith('/') ? urlText : '/' + urlText;
            fullUrl = 'https://www.alanranger.com' + urlPath;
          }
        }

        // Build goal status display (Phase 5: use objective_status from cycle)
        let goalHtml = '';
        const objectiveStatus = task.objective_status || task.goal_state || 'not_set';
        
        if (objectiveStatus && objectiveStatus !== 'not_set') {
          const goalConfig = {
            'on_track': { text: 'On track', bg: 'rgba(59, 130, 246, 0.3)', color: '#60a5fa' }, // Brighter blue
            'overdue': { text: 'Overdue', bg: 'rgba(239, 68, 68, 0.3)', color: '#f87171' }, // Brighter red
            'met': { text: 'Met', bg: 'rgba(16, 185, 129, 0.3)', color: '#34d399' }, // Brighter green
            'at_risk': { text: 'At risk', bg: 'rgba(245, 158, 11, 0.3)', color: '#fbbf24' } // Brighter amber
          };
          const config = goalConfig[objectiveStatus] || goalConfig['on_track'];
          let goalText = `<span style="padding: 0.25rem 0.5rem; border-radius: 4px; background: ${config.bg}; color: ${config.color}; font-size: 0.75rem; font-weight: 700; display: inline-block; margin-bottom: 0.25rem;">${config.text}</span>`;
          
          // Add progress info from objective_progress (Phase 8: use computeGoalProgress)
          if (task.objective_progress) {
            const progress = task.objective_progress;
            if (progress.baseline_value != null && progress.latest_value != null && progress.target != null) {
              const taskKpi = task.objective_kpi || task.primary_kpi || task.objective_metric || null;
              const targetType = (task.objective && task.objective.target_type) || 'delta';
              
              if (taskKpi) {
                // Use Phase 8 helper for proper formatting
                const goalProgress = computeGoalProgress({
                  kpiKey: taskKpi,
                  baseline: progress.baseline_value,
                  latest: progress.latest_value,
                  targetValue: progress.target,
                  targetType: targetType
                });
                
                const deltaColor = (progress.delta != null && progress.delta >= 0) ? '#34d399' : '#f87171'; // Brighter colors
                goalText += `<div style="font-size: 0.7rem; color: ${deltaColor}; margin-top: 0.125rem; font-weight: 600;">${goalProgress.deltaLabel} vs target ${goalProgress.targetLabel}</div>`;
                if (goalProgress.remainingToTarget != null && goalProgress.remainingToTarget > 0) {
                  const displayMeta = KPI_DISPLAY_METADATA[taskKpi];
                  const remainingLabel = displayMeta ? displayMeta.formatDelta(goalProgress.remainingToTarget) : String(goalProgress.remainingToTarget);
                  goalText += `<div style="font-size: 0.65rem; color: #d1d5db; margin-top: 0.125rem; font-weight: 500;">Remaining: ${remainingLabel}</div>`;
                }
              }
            }
          } else if (task.objective && task.objective.kpi && task.objective.target != null) {
            // Use objective from cycle
            const kpiLabel = task.objective.kpi.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            const targetText = task.objective.target_type === 'delta' 
              ? `${kpiLabel} ${task.objective.target >= 0 ? '+' : ''}${task.objective.target}`
              : `${kpiLabel}  ${task.objective.target}`;
            let dueText = '';
            if (task.objective.due_at || task.objective_due_at) {
              const dueDate = new Date(task.objective.due_at || task.objective_due_at).toLocaleDateString('en-GB');
              dueText = ` by ${dueDate}`;
            }
            goalText += `<div style="font-size: 0.7rem; color: #d1d5db; margin-top: 0.25rem; font-weight: 500;">${targetText}${dueText}</div>`;
          } else if (task.objective_kpi && task.objective_target_delta != null) {
            // Legacy fallback
            const kpiLabel = task.objective_kpi.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            const direction = task.objective_direction === 'decrease' ? '-' : '+';
            const targetText = `${kpiLabel} ${direction}${Math.abs(task.objective_target_delta)}`;
            let dueText = '';
            if (task.objective_due_at) {
              const dueDate = new Date(task.objective_due_at).toLocaleDateString('en-GB');
              dueText = ` by ${dueDate}`;
            }
            goalText += `<div style="font-size: 0.7rem; color: #d1d5db; margin-top: 0.25rem; font-weight: 500;">${targetText}${dueText}</div>`;
          }
          
          // Add delta if available (from progress or legacy)
          if (task.objective_progress && task.objective_progress.delta != null) {
            const delta = task.objective_progress.delta;
            const deltaColor = delta >= 0 ? '#34d399' : '#f87171'; // Brighter colors
            const deltaSign = delta >= 0 ? '+' : '';
            goalText += `<div style="font-size: 0.7rem; color: ${deltaColor}; margin-top: 0.125rem; font-weight: 700;"> ${deltaSign}${delta}</div>`;
          } else if (task.objective_delta != null) {
            // Legacy fallback
            const deltaColor = task.objective_delta >= 0 ? '#34d399' : '#f87171'; // Brighter colors
            const deltaSign = task.objective_delta >= 0 ? '+' : '';
            goalText += `<div style="font-size: 0.7rem; color: ${deltaColor}; margin-top: 0.125rem; font-weight: 700;"> ${deltaSign}${task.objective_delta}</div>`;
          }
          
          goalHtml = goalText;
        }

        // Phase 9: Format new columns
        const objectiveKpiKey = task.objectiveKpiKey || task.objective?.kpi || null;
        let objectiveKpiLabel = '';
        let baselineLatestHtml = '';
        let deltaHtml = '';
        let sparklineHtml = '';
        
        if (objectiveKpiKey && KPI_DISPLAY_METADATA[objectiveKpiKey]) {
          const kpiMeta = KPI_DISPLAY_METADATA[objectiveKpiKey];
          objectiveKpiLabel = kpiMeta.label || objectiveKpiKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          
          // Baseline  Latest
          const baselineValue = task.baselineValue != null ? task.baselineValue : (task.baseline_metrics ? kpiMeta.get ? kpiMeta.get(task.baseline_metrics) : null : null);
          const latestValue = task.latestValue != null ? task.latestValue : (task.latest_metrics ? kpiMeta.get ? kpiMeta.get(task.latest_metrics) : null : null);
          
          if (baselineValue != null && latestValue != null) {
            const baselineFormatted = kpiMeta.formatValue ? kpiMeta.formatValue(baselineValue) : String(baselineValue);
            const latestFormatted = kpiMeta.formatValue ? kpiMeta.formatValue(latestValue) : String(latestValue);
            baselineLatestHtml = `${baselineFormatted}  ${latestFormatted}`;
          } else if (baselineValue != null) {
            baselineLatestHtml = `${kpiMeta.formatValue ? kpiMeta.formatValue(baselineValue) : String(baselineValue)}  `;
          } else if (latestValue != null) {
            baselineLatestHtml = `  ${kpiMeta.formatValue ? kpiMeta.formatValue(latestValue) : String(latestValue)}`;
          }
          
          //  vs Baseline
          const delta = task.delta != null ? task.delta : (baselineValue != null && latestValue != null ? (objectiveKpiKey === 'current_rank' ? baselineValue - latestValue : latestValue - baselineValue) : null);
          if (delta != null) {
            const deltaFormatted = kpiMeta.formatDelta ? kpiMeta.formatDelta(delta) : (delta >= 0 ? `+${delta}` : String(delta));
            const deltaColor = delta >= 0 ? '#10b981' : '#ef4444';
            deltaHtml = `<span style="color: ${deltaColor}; font-weight: 600;">${deltaFormatted}</span>`;
          }
          
          // Sparkline
          const sparklinePoints = task.sparklinePoints || [];
          if (sparklinePoints.length > 1) {
            sparklineHtml = renderSparkline(sparklinePoints, 80, 24);
          }
        }
        
        // Due In
        const dueIn = task.dueIn || (task.dueAt ? (() => {
          const dueDate = new Date(task.dueAt);
          const now = new Date();
          const daysUntilDue = Math.ceil((dueDate - now) / (1000 * 60 * 60 * 24));
          if (daysUntilDue < 0) {
            return `Overdue ${Math.abs(daysUntilDue)}d`;
          } else {
            return `${daysUntilDue}d`;
          }
        })() : null);
        const dueInHtml = dueIn ? (dueIn.startsWith('Overdue') ? `<span style="color: #dc2626; font-weight: 600;">${dueIn}</span>` : dueIn) : '';

        tr.innerHTML = `
          <td style="text-align: left;"><strong>${escapeHtml(task.keyword_text || '')}</strong></td>
          <td style="max-width: 150px; word-wrap: break-word; word-break: break-all;">
            ${urlPath ? `<a href="${fullUrl}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${escapeHtml(urlPath)}</a>` : ''}
          </td>
          <td><span style="padding: 0.25rem 0.5rem; background: #f0f0f0; border-radius: 4px;">${escapeHtml(task.task_type || 'on_page')}</span></td>
          <td><span style="padding: 0.25rem 0.5rem; border-radius: 4px; background: ${statusStyle.bg}; color: ${statusStyle.color}; font-weight: 600; font-size: 0.85rem;">${escapeHtml(task.status || 'planned')}</span></td>
          <td>Cycle ${task.cycle_no || task.cycle_active || 1}</td>
          <td>${baselineCaptured}</td>
          <td>${latestCaptured || measurementIndicator}${needsUpdateBadge}</td>
          <td>${escapeHtml(task.title || '')}</td>
          <td style="font-size: 0.85rem;">${objectiveKpiLabel}</td>
          <td style="font-size: 0.85rem;">${baselineLatestHtml}</td>
          <td style="font-size: 0.85rem;">${deltaHtml}</td>
          <td style="font-size: 0.85rem;">${dueInHtml}</td>
          <td style="font-size: 0.75rem; text-align: center;">${sparklineHtml}</td>
          <td style="font-size: 0.85rem;">${goalHtml}</td>
          <td style="display: flex; flex-direction: column; gap: 0.15rem; align-items: center; min-width: 60px;">
            <button class="btn btn-secondary" onclick="event.stopPropagation(); openOptimisationTaskDrawer('${task.id}');" style="padding: 0.2rem 0.5rem; font-size: 0.7rem; width: 100%; background: var(--dark-brand) !important; color: #000 !important; border: 1px solid var(--dark-brand) !important; font-weight: 600;">Open</button>
            <button class="btn btn-small" onclick="event.stopPropagation(); updateTaskLatest('${task.id}');" style="padding: 0.2rem 0.5rem; font-size: 0.7rem; width: 100%; background: rgba(59, 130, 246, 0.2) !important; color: #60a5fa !important; border: 1px solid #60a5fa !important; font-weight: 600;" title="Capture latest metrics for this task.">Update</button>
          </td>
        `;

        tbody.appendChild(tr);
      });
      
      // Update sort indicators
      document.querySelectorAll('#optimisation-tasks-table th.sortable').forEach(th => {
        th.classList.remove('sort-asc', 'sort-desc');
        if (th.dataset.sort === optimisationSortState.column) {
          th.classList.add(`sort-${optimisationSortState.direction}`);
        }
      });
      
      // Update pagination controls
      updateOptimisationPaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx);
      
      // Wire sorting handlers
      wireOptimisationSorting();
      
      // Wire pagination handlers
      wireOptimisationPagination();
      
      // Wire pagination on initial load if not already done
      setTimeout(() => {
        wireOptimisationPagination();
      }, 100);
    }
    
    // Update pagination controls
    function updateOptimisationPaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx) {
      const paginationControls = document.getElementById('optimisation-pagination-controls');
      const paginationInfo = document.getElementById('optimisation-pagination-info');
      const pageInfo = document.getElementById('optimisation-pagination-page-info');
      const firstBtn = document.getElementById('optimisation-pagination-first');
      const prevBtn = document.getElementById('optimisation-pagination-prev');
      const nextBtn = document.getElementById('optimisation-pagination-next');
      const lastBtn = document.getElementById('optimisation-pagination-last');
      const rowsPerPageSelect = document.getElementById('optimisation-rows-per-page');
      
      if (!paginationControls) return;
      
      if (totalRows === 0) {
        paginationControls.style.display = 'none';
        return;
      }
      
      paginationControls.style.display = 'flex';
      
      if (paginationInfo) {
        paginationInfo.textContent = `Showing ${startIdx + 1}-${endIdx} of ${totalRows}`;
      }
      
      if (pageInfo) {
        pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
      }
      
      if (firstBtn) {
        firstBtn.disabled = currentPage === 1;
      }
      
      if (prevBtn) {
        prevBtn.disabled = currentPage === 1;
      }
      
      if (nextBtn) {
        nextBtn.disabled = currentPage === totalPages;
      }
      
      if (lastBtn) {
        lastBtn.disabled = currentPage === totalPages;
      }
      
      if (rowsPerPageSelect) {
        rowsPerPageSelect.value = optimisationPaginationState.rowsPerPage === 'all' ? 'all' : String(optimisationPaginationState.rowsPerPage);
      }
    }
    
    // Wire pagination handlers
    function wireOptimisationPagination() {
      const firstBtn = document.getElementById('optimisation-pagination-first');
      const prevBtn = document.getElementById('optimisation-pagination-prev');
      const nextBtn = document.getElementById('optimisation-pagination-next');
      const lastBtn = document.getElementById('optimisation-pagination-last');
      const rowsPerPageSelect = document.getElementById('optimisation-rows-per-page');
      
      if (firstBtn) {
        const newFirstBtn = firstBtn.cloneNode(true);
        firstBtn.parentNode.replaceChild(newFirstBtn, firstBtn);
        newFirstBtn.addEventListener('click', () => {
          optimisationPaginationState.currentPage = 1;
          renderOptimisationTasksTable();
        });
      }
      
      if (prevBtn) {
        const newPrevBtn = prevBtn.cloneNode(true);
        prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
        newPrevBtn.addEventListener('click', () => {
          if (optimisationPaginationState.currentPage > 1) {
            optimisationPaginationState.currentPage--;
            renderOptimisationTasksTable();
          }
        });
      }
      
      if (nextBtn) {
        const newNextBtn = nextBtn.cloneNode(true);
        nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
        newNextBtn.addEventListener('click', () => {
          const totalRows = window.optimisationModuleState.filteredTasks.length;
          const rowsPerPage = optimisationPaginationState.rowsPerPage === 'all' ? totalRows : optimisationPaginationState.rowsPerPage;
          const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
          if (optimisationPaginationState.currentPage < totalPages) {
            optimisationPaginationState.currentPage++;
            renderOptimisationTasksTable();
          }
        });
      }
      
      if (lastBtn) {
        const newLastBtn = lastBtn.cloneNode(true);
        lastBtn.parentNode.replaceChild(newLastBtn, lastBtn);
        newLastBtn.addEventListener('click', () => {
          const totalRows = window.optimisationModuleState.filteredTasks.length;
          const rowsPerPage = optimisationPaginationState.rowsPerPage === 'all' ? totalRows : optimisationPaginationState.rowsPerPage;
          const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
          optimisationPaginationState.currentPage = totalPages;
          renderOptimisationTasksTable();
        });
      }
      
      if (rowsPerPageSelect) {
        const newSelect = rowsPerPageSelect.cloneNode(true);
        rowsPerPageSelect.parentNode.replaceChild(newSelect, rowsPerPageSelect);
        newSelect.addEventListener('change', () => {
          optimisationPaginationState.rowsPerPage = newSelect.value === 'all' ? 'all' : parseInt(newSelect.value, 10);
          optimisationPaginationState.currentPage = 1; // Reset to first page
          renderOptimisationTasksTable();
        });
      }
    }
    
    // Wire sorting handlers
    function wireOptimisationSorting() {
      const sortableHeaders = document.querySelectorAll('#optimisation-tasks-table th.sortable');
      sortableHeaders.forEach(th => {
        // Remove existing listeners by cloning
        const newTh = th.cloneNode(true);
        th.parentNode.replaceChild(newTh, th);
        
        newTh.addEventListener('click', function(e) {
          e.stopPropagation();
          const column = this.dataset.sort;
          if (!column) return;
          
          if (optimisationSortState.column === column) {
            optimisationSortState.direction = optimisationSortState.direction === 'asc' ? 'desc' : 'asc';
          } else {
            optimisationSortState.column = column;
            optimisationSortState.direction = 'asc';
          }
          
          renderOptimisationTasksTable();
        });
      });
    }

    // Helper to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Tab switching (B2)
    function switchOptimisationTab(tabName) {
      window.optimisationModuleState.activeTab = tabName;
      
      // Reset pagination when switching tabs
      optimisationPaginationState.currentPage = 1;
      
      // Update tab button states
      document.querySelectorAll('.optimisation-tab-btn').forEach(btn => {
        btn.classList.toggle('metric-pill--active', btn.dataset.tab === tabName);
      });

      renderOptimisationTasksTable();
    }

    // Dragging state
    let optimisationDrawerDragState = {
      isDragging: false,
      startX: 0,
      startY: 0,
      startLeft: 0,
      startTop: 0
    };
    
    let optimisationDrawerState = {
      isMinimized: false,
      isMaximized: false,
      originalWidth: '1200px',
      originalHeight: 'auto',
      originalTop: '50%',
      originalLeft: '50%'
    };

    // Helper to disable write buttons in share mode
    function disableWriteButtonsInShareMode() {
      if (!window.isShareMode) return;
      
      const writeButtonIds = [
        'optimisation-cancel-task-btn',
        'optimisation-delete-task-btn',
        'optimisation-edit-objective-btn',
        'optimisation-add-measurement-btn',
        'optimisation-start-cycle-btn',
        'optimisation-complete-cycle-btn',
        'optimisation-archive-cycle-btn',
        'optimisation-add-event-btn',
        'optimisation-save-status-btn',
        'optimisation-save-objective-btn',
        'optimisation-update-latest-btn'
      ];
      
      writeButtonIds.forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
          btn.disabled = true;
          btn.style.opacity = '0.5';
          btn.style.cursor = 'not-allowed';
          btn.title = (btn.title || '') + ' (Not available in share mode)';
        }
      });
      
      // Disable inputs
      const titleInput = document.getElementById('optimisation-drawer-title');
      if (titleInput) {
        titleInput.disabled = true;
        titleInput.style.opacity = '0.5';
      }
      
      const statusSelect = document.getElementById('optimisation-change-status');
      if (statusSelect) {
        statusSelect.disabled = true;
        statusSelect.style.opacity = '0.5';
      }
      
      // Hide edit objective form
      const editForm = document.getElementById('optimisation-edit-objective-form');
      if (editForm) editForm.style.display = 'none';
    }

    // Open task drawer (B3, B4)
    window.openOptimisationTaskDrawer = async function openOptimisationTaskDrawer(taskId) {
      // CRITICAL: Switch to Optimisation tab first, otherwise drawer will be hidden
      if (typeof setActivePanel === 'function') {
        setActivePanel('optimisation');
        ensurePanelRendered('optimisation');
        // Wait a moment for panel to become visible
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      const drawer = document.getElementById('optimisation-task-drawer');
      const backdrop = document.getElementById('optimisation-task-drawer-backdrop');
      
      if (!drawer) {
        console.error('[Optimisation Drawer] Drawer element not found');
        alert('Drawer element not found. Please refresh the page.');
        return;
      }
      
      if (!backdrop) {
        console.error('[Optimisation Drawer] Backdrop element not found');
        alert('Backdrop element not found. Please refresh the page.');
        return;
      }

      if (!window.optimisationModuleState) {
        window.optimisationModuleState = { allTasks: [], filteredTasks: [], activeTab: 'active', currentTaskId: null };
      }

      window.optimisationModuleState.currentTaskId = taskId;
      
      // Always reload tasks to ensure we have latest goal_state from the view
      // This ensures the badge uses the correct state even if migrations haven't been run
      if (typeof window.loadAllOptimisationTasks === 'function') {
        await window.loadAllOptimisationTasks();
      }
      
      // Find task (after reload to ensure fresh data)
      let task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      
      // If task still not found, error
      if (!task) {
        console.error('[Optimisation Drawer] Task not found after reload:', taskId);
        alert(`Task not found (ID: ${taskId}). Please try refreshing the page.`);
        return;
      }

      // Phase 6: Fetch full task details including cycles
      try {
        const headers = window.getOptimisationHeaders();
        const taskResponse = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'GET',
          headers: headers
        });
        if (taskResponse.ok) {
          const taskData = await taskResponse.json();
          console.log('[Optimisation Drawer] Task data from API:', taskData);
          // Merge cycles and other detailed fields into task
          task = {
            ...task,
            ...taskData.task,
            cycles: taskData.cycles || [],
            events: taskData.events || []
          };
          console.log('[Optimisation Drawer] Merged task with cycles:', task.cycles);
        }
      } catch (error) {
        console.error('[Optimisation Drawer] Error fetching task details:', error);
        // Continue with task from state if fetch fails
      }

      // Populate header
      document.getElementById('optimisation-drawer-keyword').textContent = task.keyword_text || '';
      const titleInput = document.getElementById('optimisation-drawer-title');
      if (titleInput) {
        titleInput.value = task.title || '';
      }
      
      // Make Target URL clickable
      const urlEl = document.getElementById('optimisation-drawer-url');
      const targetUrl = task.target_url_clean || task.target_url || '';
      let fullUrl = '';
      if (targetUrl) {
        try {
          if (targetUrl.includes('alanranger.com')) {
            fullUrl = targetUrl.startsWith('http') ? targetUrl : 'https://' + targetUrl;
          } else if (targetUrl.startsWith('/')) {
            fullUrl = 'https://www.alanranger.com' + targetUrl;
          } else {
            fullUrl = 'https://www.alanranger.com/' + targetUrl;
          }
        } catch (e) {
          fullUrl = 'https://www.alanranger.com/' + (targetUrl.startsWith('/') ? targetUrl : '/' + targetUrl);
        }
      }
      if (fullUrl) {
        urlEl.innerHTML = `<a href="${fullUrl}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${escapeHtml(targetUrl)}</a>`;
      } else {
        urlEl.textContent = targetUrl;
      }
      
      document.getElementById('optimisation-drawer-type').textContent = task.task_type || 'on_page';
      
      const statusColors = {
        planned: { bg: '#fef3c7', color: '#92400e' },
        in_progress: { bg: '#d1fae5', color: '#065f46' },
        monitoring: { bg: '#dbeafe', color: '#1e40af' },
        done: { bg: '#e5e7eb', color: '#374151' },
        paused: { bg: '#fed7aa', color: '#9a3412' },
        cancelled: { bg: '#fee2e2', color: '#991b1b' }
      };
      const statusStyle = statusColors[task.status] || statusColors.planned;
      const statusEl = document.getElementById('optimisation-drawer-status');
      statusEl.textContent = task.status || 'planned';
      statusEl.style.background = statusStyle.bg;
      statusEl.style.color = statusStyle.color;
      
      // Update cycle display with cycle info
      const cycleEl = document.getElementById('optimisation-drawer-cycle');
      const cycleSelector = document.getElementById('optimisation-drawer-cycle-selector');
      const cycleNo = task.cycle_no || task.cycle_active || 1;
      const cycleText = `Cycle ${cycleNo}`;
      if (task.cycle_start_date) {
        const startDate = new Date(task.cycle_start_date).toLocaleDateString('en-GB');
        cycleEl.textContent = `${cycleText} (Started: ${startDate})`;
      } else if (task.created_at) {
        const createdDate = new Date(task.created_at).toLocaleDateString('en-GB');
        cycleEl.textContent = `${cycleText} (Created: ${createdDate})`;
      } else {
        cycleEl.textContent = cycleText;
      }

      // Phase 6: Populate cycle selector dropdown
      // Debug: Log cycles data
      console.log('[Optimisation Drawer] Cycles data:', task.cycles, 'Length:', task.cycles?.length, 'Active cycle ID:', task.active_cycle_id);
      
      if (cycleSelector) {
        if (task.cycles && Array.isArray(task.cycles) && task.cycles.length > 0) {
          cycleSelector.innerHTML = '';
          // Sort cycles by cycle_no descending (newest first)
          const sortedCycles = [...task.cycles].sort((a, b) => (b.cycle_no || 0) - (a.cycle_no || 0));
          sortedCycles.forEach(c => {
            const option = document.createElement('option');
            option.value = c.id;
            option.textContent = `Cycle ${c.cycle_no}`;
            if (c.id === task.active_cycle_id) {
              option.selected = true;
            }
            cycleSelector.appendChild(option);
          });
          // Show selector if there are multiple cycles
          if (task.cycles.length > 1) {
            cycleSelector.style.display = 'inline-block';
            console.log('[Optimisation Drawer] Cycle selector shown with', task.cycles.length, 'cycles');
          } else {
            cycleSelector.style.display = 'none';
            console.log('[Optimisation Drawer] Cycle selector hidden (only 1 cycle)');
          }
          
          // Store cycles in state for later use
          if (!window.optimisationModuleState) {
            window.optimisationModuleState = {};
          }
          window.optimisationModuleState.taskCycles = task.cycles;
          window.optimisationModuleState.selectedCycleId = task.active_cycle_id;
          
          // Handle cycle selection change (remove old listener first to avoid duplicates)
          const oldHandler = cycleSelector.dataset.handler;
          if (oldHandler) {
            cycleSelector.removeEventListener('change', window[oldHandler]);
          }
          const handlerName = `cycleSelectorHandler_${taskId}`;
          const handler = async (e) => {
            const selectedCycleId = e.target.value;
            window.optimisationModuleState.selectedCycleId = selectedCycleId;
            const selectedCycle = task.cycles.find(c => c.id === selectedCycleId);
            const selectedCycleNo = selectedCycle?.cycle_no || 1;
            await loadCycleData(taskId, selectedCycleId, task.cycles, selectedCycle, selectedCycleNo, task);
          };
          window[handlerName] = handler;
          cycleSelector.dataset.handler = handlerName;
          cycleSelector.addEventListener('change', handler);
        } else {
          cycleSelector.style.display = 'none';
          console.log('[Optimisation Drawer] Cycle selector hidden (no cycles data)');
        }
      } else {
        console.error('[Optimisation Drawer] Cycle selector element not found!');
      }

      // Load progress data
      let progress = null;
      try {
        const headers = window.getOptimisationHeaders();
        const progressResponse = await fetch(apiUrl(`/api/optimisation/task/${taskId}/progress`), {
          method: 'GET',
          headers: headers
        });
        if (progressResponse.ok) {
          const progressData = await progressResponse.json();
          progress = progressData.progress || null;
        }
      } catch (error) {
        console.error('[Optimisation Drawer] Error loading progress:', error);
      }

      // Update objective display
      const objectiveCycleEl = document.getElementById('optimisation-drawer-objective-cycle');
      if (objectiveCycleEl) {
        objectiveCycleEl.textContent = `(Cycle ${cycleNo})`;
      }

      // Update progress badge - Use objective_status from cycle (Phase 5) or fallback to goal_state
      const objectiveBadgeEl = document.getElementById('optimisation-drawer-objective-badge');
      if (objectiveBadgeEl) {
        // Phase 5: Use objective_status from cycle (server-computed), fallback to goal_state
        let state = task.objective_status || task.goal_state;
        
        // Debug logging to understand what's happening
        if (typeof debugLog === 'function') {
          debugLog(`[Optimisation Badge] Task ${task.id}: goal_state="${task.goal_state}", objective_delta=${task.objective_delta}, target=${task.objective_target_delta || task.objective_target_value}, direction=${task.objective_direction}, progress.objective_state="${progress?.objective_state}"`, 'info');
        }
        
        // If goal_state is not available, determine from objective fields
        if (!state && (task.objective_metric || task.objective_kpi)) {
          // Check if baseline_metrics exists (from view) or if we have any measurement
          const hasBaseline = task.baseline_metrics || (progress && progress.baseline_value != null);
          state = hasBaseline ? 'on_track' : 'no_measurement';
          if (typeof debugLog === 'function') {
            debugLog(`[Optimisation Badge] goal_state was null, determined state="${state}" from objective fields`, 'warn');
          }
        } else if (!state) {
          state = 'not_set';
        }
        
        // NEVER use progress.objective_state - it's from a different (buggy) view
        // If we're seeing 'achieved' here, it means task.goal_state is wrong or missing
        if (typeof debugLog === 'function' && progress?.objective_state && progress.objective_state !== state) {
          debugLog(`[Optimisation Badge] WARNING: progress.objective_state="${progress.objective_state}" differs from goal_state="${state}". Using goal_state.`, 'warn');
        }
        
        // ALWAYS validate state using actual delta vs target - don't trust database views
        // This ensures badge matches reality regardless of which view is used
        const target = task.objective_target_delta != null ? task.objective_target_delta : 
          (task.objective_target_value != null ? task.objective_target_value : null);
        
        if (target != null && target > 0 && (task.objective_metric || task.objective_kpi)) {
          // Get delta from task (from goal status view) or calculate from progress
          let delta = task.objective_delta;
          if (delta === null || delta === undefined) {
            if (progress && progress.latest_value != null && progress.baseline_value != null) {
              delta = progress.latest_value - progress.baseline_value;
            }
          }
          
          // If we have delta, validate it against target
          if (delta !== null && delta !== undefined) {
            const direction = task.objective_direction || 'increase';
            const meetsTarget = direction === 'decrease' 
              ? delta <= (target * -1)
              : delta >= target;
            
            // Override state based on actual delta, not database view
            if (meetsTarget) {
              if (state !== 'met' && state !== 'achieved') {
                if (typeof debugLog === 'function') {
                  debugLog(`[Optimisation Badge] Overriding state "${state}" to 'met': delta=${delta} meets target=${target}`, 'info');
                }
                state = 'met';
              }
            } else {
              // Delta doesn't meet target - can't be 'met' or 'achieved'
              if (state === 'met' || state === 'achieved') {
                if (typeof debugLog === 'function') {
                  debugLog(`[Optimisation Badge] Overriding '${state}' to 'on_track': delta=${delta} does NOT meet target=${target} (direction=${direction})`, 'warn');
                }
                state = 'on_track';
              }
            }
          } else if (progress && progress.baseline_value != null && progress.latest_value != null) {
            // If baseline equals latest, delta is 0 - can't be met
            if (progress.baseline_value === progress.latest_value) {
              if (state === 'met' || state === 'achieved') {
                if (typeof debugLog === 'function') {
                  debugLog(`[Optimisation Badge] Overriding '${state}' to 'on_track': baseline equals latest (delta=0)`, 'warn');
                }
                state = 'on_track';
              }
            }
          }
        }
        
        const badgeConfig = {
          'achieved': { text: 'Achieved', bg: '#10b981', color: '#ffffff' },
          'met': { text: 'Met', bg: '#10b981', color: '#ffffff' },
          'on_track': { text: 'On track', bg: '#3b82f6', color: '#ffffff' },
          'at_risk': { text: 'At risk', bg: '#f59e0b', color: '#ffffff' },
          'overdue': { text: 'Overdue', bg: '#ef4444', color: '#ffffff' },
          'not_set': { text: 'Not set', bg: '#9ca3af', color: '#ffffff' },
          'no_measurement': { text: 'No measurement', bg: '#9ca3af', color: '#ffffff' }
        };
        const config = badgeConfig[state] || badgeConfig['not_set'];
        
        if (typeof debugLog === 'function') {
          debugLog(`[Optimisation Badge] Setting badge: state="${state}", text="${config.text}"`, 'info');
        }
        
        objectiveBadgeEl.textContent = config.text;
        objectiveBadgeEl.style.background = config.bg;
        objectiveBadgeEl.style.color = config.color;
        objectiveBadgeEl.style.display = 'inline-block';
      }

      const objectiveContentEl = document.getElementById('optimisation-drawer-objective-content');
      if (objectiveContentEl) {
        // Phase 5: Use objective from cycle (jsonb) or fallback to legacy task fields
        const objective = task.objective || task.cycle?.objective || null;
        const objectiveProgress = task.objective_progress || task.cycle?.objective_progress || null;
        const objectiveStatus = task.objective_status || task.cycle?.objective_status || task.goal_state || 'not_set';
        const objectiveDueAt = task.objective_due_at || task.cycle?.due_at || null;

        // Legacy fallback fields - read from cycle fields (via view) or task fields
        const objectiveTitle = objective?.title || task.objective_title || null;
        const objectiveKpi = objective?.kpi || task.primary_kpi || task.objective_kpi || task.objective_metric || null;
        const objectiveMetric = objective?.kpi || task.primary_kpi || task.objective_metric || task.objective_kpi || null;
        // target_direction comes from cycle, objective_direction is legacy task field
        const objectiveDirection = objective?.target_type === 'delta' ? 'increase' : (task.target_direction || task.objective_direction || null);
        const objectiveTargetValue = objective?.target != null ? objective.target : (task.target_value != null ? task.target_value : (task.objective_target_delta != null ? task.objective_target_delta : (task.objective_target_value != null ? task.objective_target_value : null)));
        const objectiveTimeframe = objective?.due_at ? null : (task.timeframe_days != null ? task.timeframe_days : (task.objective_timeframe_days != null ? task.objective_timeframe_days : null));
        const objectivePlan = objective?.plan || task.plan || task.objective_plan || null;
        const cycleStartedAt = task.cycle_started_at || task.cycle_start_date || null;

        if (objective || objectiveTitle || objectiveKpi || objectiveMetric || objectiveDirection) {
          // Use two-column layout for objective details
          let leftColumn = '';
          let rightColumn = '';
          
          if (objectiveTitle) {
            leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Title:</strong> ${escapeHtml(objectiveTitle)}</div>`;
          }
            if (objectiveKpi) {
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>KPI:</strong> ${escapeHtml(objectiveKpi)}</div>`;
            }
            // Show target if we have a target value (direction is optional)
            if (objectiveTargetValue != null) {
              const directionLabels = {
                'increase': 'Increase by',
                'decrease': 'Decrease by',
                'at_least': 'At least',
                'at_most': 'At most'
              };
              let targetText = '';
              if (objectiveDirection) {
                targetText = `${directionLabels[objectiveDirection] || objectiveDirection} ${objectiveTargetValue}`;
              } else {
                // If no direction specified, just show the target value
                targetText = `${objectiveTargetValue}`;
              }
              if (objectiveMetric === 'ctr_28d' || (objectiveKpi && objectiveKpi.includes('ctr'))) {
                targetText += '%';
              }
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Target:</strong> ${escapeHtml(targetText)}</div>`;
            } else if (objectiveDirection) {
              // Show direction even if no target value
              const directionLabels = {
                'increase': 'Increase',
                'decrease': 'Decrease',
                'at_least': 'At least',
                'at_most': 'At most'
              };
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Direction:</strong> ${escapeHtml(directionLabels[objectiveDirection] || objectiveDirection)}</div>`;
            }
          
          if (objectiveTimeframe || task.objective_due_at) {
            let timeframeText = '';
            const dueAt = task.objective_due_at || (progress && progress.due_at) || null;
            if (dueAt) {
              const dueDate = new Date(dueAt).toLocaleDateString('en-GB');
              timeframeText = `Due: ${dueDate}`;
              if (progress && progress.days_remaining != null) {
                const daysRemaining = Math.round(progress.days_remaining);
                timeframeText += ` (${daysRemaining} days remaining)`;
              }
            } else if (objectiveTimeframe) {
              timeframeText = `${objectiveTimeframe} days`;
              if (cycleStartedAt) {
                const startDate = new Date(cycleStartedAt);
                const dueDate = new Date(startDate.getTime() + objectiveTimeframe * 24 * 60 * 60 * 1000);
                timeframeText += ` (Due: ${dueDate.toLocaleDateString('en-GB')})`;
              }
            }
            if (timeframeText) {
              rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>Timeframe:</strong> ${timeframeText}</div>`;
            }
          }
          
          // Show progress: baseline  latest () vs target (Phase 8: use computeGoalProgress)
          if (objectiveProgress && objectiveProgress.baseline_value != null && objectiveProgress.latest_value != null) {
            const baselineVal = objectiveProgress.baseline_value;
            const latestVal = objectiveProgress.latest_value;
            const target = objectiveProgress.target != null ? objectiveProgress.target : objectiveTargetValue;
            const targetType = objective?.target_type || 'delta';
            const kpiKey = objectiveKpi || objectiveMetric;
            
            if (target != null && kpiKey) {
              // Use Phase 8 helper for proper formatting
              const progress = computeGoalProgress({
                kpiKey: kpiKey,
                baseline: baselineVal,
                latest: latestVal,
                targetValue: target,
                targetType: targetType
              });
              
              const deltaColor = (objectiveProgress.delta != null && objectiveProgress.delta >= 0) ? '#10b981' : '#ef4444';
              rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>Progress:</strong> ${progress.baselineLabel}  ${progress.latestLabel} (<span style="color: ${deltaColor}; font-weight: 600;">${progress.deltaLabel}</span>) vs target ${progress.targetLabel}</div>`;
              if (progress.remainingToTarget != null && progress.remainingToTarget > 0) {
                const displayMeta = KPI_DISPLAY_METADATA[kpiKey];
                const remainingLabel = displayMeta ? displayMeta.formatDelta(progress.remainingToTarget) : String(progress.remainingToTarget);
                rightColumn += `<div style="font-size: 0.85rem; color: #666; margin-top: 0.25rem;">Remaining: ${remainingLabel}</div>`;
              }
            }
          } else if (progress && progress.baseline_value != null && progress.latest_value != null && objectiveMetric) {
            // Legacy fallback
            const baselineVal = progress.baseline_value;
            const latestVal = progress.latest_value;
            const delta = progress.objective_delta != null ? progress.objective_delta : (latestVal - baselineVal);
            const targetDelta = task.objective_target_delta != null ? task.objective_target_delta : (task.objective_target_value != null ? task.objective_target_value : null);
            
            if (targetDelta != null) {
              const deltaColor = delta >= 0 ? '#10b981' : '#ef4444';
              const deltaSign = delta >= 0 ? '+' : '';
              const kpiLabel = (objectiveKpi || objectiveMetric).replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
              
              // Format values based on KPI type
              const formattedBaseline = formatProgressValue(baselineVal, objectiveKpi || objectiveMetric);
              const formattedLatest = formatProgressValue(latestVal, objectiveKpi || objectiveMetric);
              const formattedDelta = formatProgressValue(delta, objectiveKpi || objectiveMetric);
              const formattedTarget = formatProgressValue(targetDelta, objectiveKpi || objectiveMetric);
              
              rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>Progress:</strong> ${formattedBaseline}  ${formattedLatest} (<span style="color: ${deltaColor}; font-weight: 600;">${deltaSign}${formattedDelta}</span>) vs target ${targetDelta > 0 ? '+' : ''}${formattedTarget}</div>`;
            }
          }
          
          // Build two-column layout
          let objectiveHtml = `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
            <div>${leftColumn || '<div style="color: #999; font-style: italic;"></div>'}</div>
            <div>${rightColumn || '<div style="color: #999; font-style: italic;"></div>'}</div>
          </div>`;
          
          if (objectivePlan) {
            objectiveHtml += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #e2e8f0;"><strong>Plan:</strong> ${escapeHtml(objectivePlan)}</div>`;
          }
          objectiveContentEl.innerHTML = objectiveHtml || '<div style="color: #666; font-style: italic;">No objective set</div>';
        } else {
          objectiveContentEl.innerHTML = '<div style="color: #666; font-style: italic;">No objective set</div>';
        }
      }
      
      document.getElementById('optimisation-change-status').value = task.status || '';

      // Phase 6: Load data for selected cycle (defaults to active cycle)
      const selectedCycleId = window.optimisationModuleState?.selectedCycleId || task.active_cycle_id;
      const selectedCycle = task.cycles?.find(c => c.id === selectedCycleId) || null;
      const selectedCycleNo = selectedCycle?.cycle_no || task.cycle_no || task.cycle_active || 1;
      
      await loadCycleData(taskId, selectedCycleId, task.cycles, selectedCycle, selectedCycleNo, task);

      // Reset timeline to collapsed state
      const timelineContainer = document.getElementById('optimisation-drawer-events-container');
      const timelineToggle = document.getElementById('optimisation-timeline-toggle');
      if (timelineContainer && timelineToggle) {
        timelineContainer.style.display = 'none';
        timelineToggle.textContent = '';
      }

      // Reset state
      optimisationDrawerState.isMinimized = false;
      optimisationDrawerState.isMaximized = false;
      
      // Show backdrop and drawer (centered)
      backdrop.style.display = 'block';
      drawer.style.display = 'flex';
      drawer.style.top = '50%';
      drawer.style.left = '50%';
      drawer.style.transform = 'translate(-50%, -50%)';
      drawer.style.width = optimisationDrawerState.originalWidth;
      drawer.style.height = optimisationDrawerState.originalHeight;
      
      // Disable write buttons in share mode
      disableWriteButtonsInShareMode();
      drawer.style.maxHeight = '90vh';
      
      // Ensure content is visible
      const content = document.getElementById('optimisation-drawer-content');
      if (content) {
        content.style.display = 'block';
      }
      
      // Update button states
      document.getElementById('optimisation-drawer-minimize').textContent = '';
      document.getElementById('optimisation-drawer-maximize').textContent = '';
      
      // Phase 7: Show/hide Complete/Archive buttons based on active cycle
      const completeCycleBtn = document.getElementById('optimisation-complete-cycle-btn');
      const archiveCycleBtn = document.getElementById('optimisation-archive-cycle-btn');
      const hasActiveCycle = task.active_cycle_id != null;
      
      if (completeCycleBtn) {
        completeCycleBtn.style.display = hasActiveCycle ? 'block' : 'none';
        completeCycleBtn.disabled = !hasActiveCycle || window.isShareMode;
      }
      if (archiveCycleBtn) {
        archiveCycleBtn.style.display = hasActiveCycle ? 'block' : 'none';
        archiveCycleBtn.disabled = !hasActiveCycle || window.isShareMode;
      }
    };

    // Close task drawer
    window.closeOptimisationTaskDrawer = function closeOptimisationTaskDrawer() {
      const drawer = document.getElementById('optimisation-task-drawer');
      const backdrop = document.getElementById('optimisation-task-drawer-backdrop');
      if (!drawer || !backdrop) return;
      
      backdrop.style.display = 'none';
      drawer.style.display = 'none';
      window.optimisationModuleState.currentTaskId = null;
      optimisationDrawerState.isMinimized = false;
      optimisationDrawerState.isMaximized = false;
    };
    
    // Minimize drawer
    function minimizeOptimisationDrawer() {
      const drawer = document.getElementById('optimisation-task-drawer');
      if (!drawer) return;
      
      if (optimisationDrawerState.isMinimized) {
        // Restore
        drawer.style.height = optimisationDrawerState.originalHeight;
        drawer.style.maxHeight = '90vh';
        document.getElementById('optimisation-drawer-content').style.display = 'block';
        optimisationDrawerState.isMinimized = false;
        document.getElementById('optimisation-drawer-minimize').textContent = '';
      } else {
        // Minimize
        optimisationDrawerState.originalHeight = drawer.style.height || 'auto';
        drawer.style.height = '60px';
        drawer.style.maxHeight = '60px';
        document.getElementById('optimisation-drawer-content').style.display = 'none';
        optimisationDrawerState.isMinimized = true;
        document.getElementById('optimisation-drawer-minimize').textContent = '+';
      }
    }
    
    // Maximize drawer
    function maximizeOptimisationDrawer() {
      const drawer = document.getElementById('optimisation-task-drawer');
      if (!drawer) return;
      
      if (optimisationDrawerState.isMaximized) {
        // Restore
        drawer.style.top = optimisationDrawerState.originalTop;
        drawer.style.left = optimisationDrawerState.originalLeft;
        drawer.style.transform = 'translate(-50%, -50%)';
        drawer.style.width = optimisationDrawerState.originalWidth;
        drawer.style.height = optimisationDrawerState.originalHeight;
        drawer.style.maxHeight = '90vh';
        optimisationDrawerState.isMaximized = false;
        document.getElementById('optimisation-drawer-maximize').textContent = '';
      } else {
        // Maximize
        optimisationDrawerState.originalTop = drawer.style.top;
        optimisationDrawerState.originalLeft = drawer.style.left;
        optimisationDrawerState.originalWidth = drawer.style.width;
        optimisationDrawerState.originalHeight = drawer.style.height || 'auto';
        
        drawer.style.top = '0';
        drawer.style.left = '0';
        drawer.style.transform = 'none';
        drawer.style.width = '100vw';
        drawer.style.height = '100vh';
        drawer.style.maxHeight = '100vh';
        optimisationDrawerState.isMaximized = true;
        document.getElementById('optimisation-drawer-maximize').textContent = '';
      }
    }
    
    // Make drawer draggable
    function initOptimisationDrawerDragging() {
      const drawer = document.getElementById('optimisation-task-drawer');
      const headerBar = document.getElementById('optimisation-drawer-header-bar');
      if (!drawer || !headerBar) return;
      
      headerBar.addEventListener('mousedown', (e) => {
        if (optimisationDrawerState.isMaximized) return; // Don't drag when maximized
        
        optimisationDrawerDragState.isDragging = true;
        const rect = drawer.getBoundingClientRect();
        optimisationDrawerDragState.startX = e.clientX;
        optimisationDrawerDragState.startY = e.clientY;
        optimisationDrawerDragState.startLeft = rect.left;
        optimisationDrawerDragState.startTop = rect.top;
        
        drawer.style.transition = 'none';
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!optimisationDrawerDragState.isDragging) return;
        
        const deltaX = e.clientX - optimisationDrawerDragState.startX;
        const deltaY = e.clientY - optimisationDrawerDragState.startY;
        
        drawer.style.left = (optimisationDrawerDragState.startLeft + deltaX) + 'px';
        drawer.style.top = (optimisationDrawerDragState.startTop + deltaY) + 'px';
        drawer.style.transform = 'none';
      });
      
      document.addEventListener('mouseup', () => {
        if (optimisationDrawerDragState.isDragging) {
          optimisationDrawerDragState.isDragging = false;
          drawer.style.transition = '';
        }
      });
    }

    // Phase 6: Load cycle-specific data (objective, measurements, events)
    async function loadCycleData(taskId, cycleId, allCycles, selectedCycle, cycleNo, task) {
      // Update objective display for selected cycle
      const objectiveCycleEl = document.getElementById('optimisation-drawer-objective-cycle');
      if (objectiveCycleEl) {
        objectiveCycleEl.textContent = `(Cycle ${cycleNo})`;
      }

      // Get cycle data (use selected cycle if provided, otherwise fetch from task)
      let cycleData = selectedCycle;
      if (!cycleData && cycleId && allCycles) {
        cycleData = allCycles.find(c => c.id === cycleId);
      }

      // Update objective display with selected cycle's objective
      if (cycleData) {
        // Merge cycle data into task for rendering
        const cycleTask = {
          ...task,
          objective: cycleData.objective || null,
          objective_status: cycleData.objective_status || 'not_set',
          objective_progress: cycleData.objective_progress || null,
          objective_due_at: cycleData.due_at || null,
          objective_title: cycleData.objective_title || null,
          primary_kpi: cycleData.primary_kpi || null,
          target_value: cycleData.target_value != null ? parseFloat(cycleData.target_value) : null,
          target_direction: cycleData.target_direction || null,
          timeframe_days: cycleData.timeframe_days != null ? parseInt(cycleData.timeframe_days) : null,
          plan: cycleData.plan || null,
          cycle_start_date: cycleData.start_date || null
        };
        
        // Re-render objective badge and content for selected cycle
        const objectiveBadgeEl = document.getElementById('optimisation-drawer-objective-badge');
        if (objectiveBadgeEl) {
          const status = cycleTask.objective_status || 'not_set';
          const badgeConfig = {
            'met': { text: 'Met', bg: '#10b981', color: '#ffffff' },
            'on_track': { text: 'On track', bg: '#3b82f6', color: '#ffffff' },
            'overdue': { text: 'Overdue', bg: '#ef4444', color: '#ffffff' },
            'not_set': { text: 'Not set', bg: '#9ca3af', color: '#ffffff' }
          };
          const config = badgeConfig[status] || badgeConfig['not_set'];
          objectiveBadgeEl.textContent = config.text;
          objectiveBadgeEl.style.background = config.bg;
          objectiveBadgeEl.style.color = config.color;
          objectiveBadgeEl.style.display = 'inline-block';
        }
        
        // Re-render objective content (reuse existing logic from earlier in the file)
        const objectiveContentEl = document.getElementById('optimisation-drawer-objective-content');
        if (objectiveContentEl) {
          const objective = cycleTask.objective || null;
          const objectiveProgress = cycleTask.objective_progress || null;
          const objectiveTitle = objective?.title || cycleTask.objective_title || null;
          const objectiveKpi = objective?.kpi || cycleTask.primary_kpi || null;
          const objectiveMetric = objective?.kpi || cycleTask.primary_kpi || null;
          // Handle target_type: 'delta' means increase/decrease, 'absolute' means at_least/at_most
          let objectiveDirection = null;
          if (objective?.target_type === 'delta') {
            // For delta, check if target is positive (increase) or negative (decrease)
            const targetVal = objective?.target != null ? objective.target : (cycleTask.target_value != null ? cycleTask.target_value : null);
            objectiveDirection = targetVal != null && targetVal >= 0 ? 'increase' : 'decrease';
          } else if (objective?.target_type === 'absolute') {
            // For absolute, we need to determine from KPI direction (higher_better vs lower_better)
            // For now, default to 'at_least' for most KPIs, 'at_most' for rank
            objectiveDirection = (objectiveKpi && objectiveKpi.includes('rank')) ? 'at_most' : 'at_least';
          } else {
            // Fallback to legacy target_direction
            objectiveDirection = cycleTask.target_direction || null;
          }
          const objectiveTargetValue = objective?.target != null ? objective.target : (cycleTask.target_value != null ? cycleTask.target_value : null);
          const objectiveTimeframe = objective?.due_at ? null : (cycleTask.timeframe_days != null ? cycleTask.timeframe_days : null);
          const objectivePlan = objective?.plan || cycleTask.plan || null;
          const cycleStartedAt = cycleTask.cycle_start_date || null;

          // Debug logging
          console.log('[loadCycleData] Cycle objective data:', {
            objective,
            objectiveTitle,
            objectiveKpi,
            objectiveMetric,
            objectiveDirection,
            objectiveTargetValue,
            cycleTask
          });

          if (objective || objectiveTitle || objectiveKpi || objectiveMetric || objectiveDirection || objectiveTargetValue != null) {
            let leftColumn = '';
            let rightColumn = '';
            
            if (objectiveTitle) {
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Title:</strong> ${escapeHtml(objectiveTitle)}</div>`;
            }
            if (objectiveKpi) {
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>KPI:</strong> ${escapeHtml(objectiveKpi)}</div>`;
            }
            // Show target if we have a target value (direction is optional)
            if (objectiveTargetValue != null) {
              const directionLabels = {
                'increase': 'Increase by',
                'decrease': 'Decrease by',
                'at_least': 'At least',
                'at_most': 'At most'
              };
              let targetText = '';
              if (objectiveDirection) {
                targetText = `${directionLabels[objectiveDirection] || objectiveDirection} ${objectiveTargetValue}`;
              } else {
                // If no direction specified, just show the target value
                targetText = `${objectiveTargetValue}`;
              }
              if (objectiveMetric === 'ctr_28d' || (objectiveKpi && objectiveKpi.includes('ctr'))) {
                targetText += '%';
              }
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Target:</strong> ${escapeHtml(targetText)}</div>`;
            } else if (objectiveDirection) {
              // Show direction even if no target value
              const directionLabels = {
                'increase': 'Increase',
                'decrease': 'Decrease',
                'at_least': 'At least',
                'at_most': 'At most'
              };
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Direction:</strong> ${escapeHtml(directionLabels[objectiveDirection] || objectiveDirection)}</div>`;
            }
            
            if (objectiveTimeframe || cycleTask.objective_due_at) {
              let timeframeText = '';
              const dueAt = cycleTask.objective_due_at || null;
              if (dueAt) {
                const dueDate = new Date(dueAt).toLocaleDateString('en-GB');
                timeframeText = `Due: ${dueDate}`;
              } else if (objectiveTimeframe && cycleStartedAt) {
                timeframeText = `${objectiveTimeframe} days`;
                const startDate = new Date(cycleStartedAt);
                const dueDate = new Date(startDate.getTime() + objectiveTimeframe * 24 * 60 * 60 * 1000);
                timeframeText += ` (Due: ${dueDate.toLocaleDateString('en-GB')})`;
              }
              if (timeframeText) {
                rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>Timeframe:</strong> ${timeframeText}</div>`;
              }
            }
            
            if (objectiveProgress && objectiveProgress.baseline_value != null && objectiveProgress.latest_value != null) {
              const baselineVal = objectiveProgress.baseline_value;
              const latestVal = objectiveProgress.latest_value;
              const delta = objectiveProgress.delta != null ? objectiveProgress.delta : (latestVal - baselineVal);
              const target = objectiveProgress.target != null ? objectiveProgress.target : objectiveTargetValue;
              
              if (target != null) {
                const deltaColor = delta >= 0 ? '#10b981' : '#ef4444';
                const deltaSign = delta >= 0 ? '+' : '';
                const targetType = objective?.target_type || 'delta';
                
                // Format values based on KPI type
                const formattedBaseline = formatProgressValue(baselineVal, objectiveKpi || objectiveMetric);
                const formattedLatest = formatProgressValue(latestVal, objectiveKpi || objectiveMetric);
                const formattedDelta = formatProgressValue(delta, objectiveKpi || objectiveMetric);
                const formattedTarget = formatProgressValue(target, objectiveKpi || objectiveMetric);
                
                const targetText = targetType === 'delta' 
                  ? `target ${delta >= 0 ? '+' : ''}${formattedTarget}`
                  : `target ${formattedTarget}`;
                rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>Progress:</strong> ${formattedBaseline}  ${formattedLatest} (<span style="color: ${deltaColor}; font-weight: 600;">${deltaSign}${formattedDelta}</span>) vs ${targetText}</div>`;
              }
            }
            
            let objectiveHtml = `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
              <div>${leftColumn || '<div style="color: #999; font-style: italic;"></div>'}</div>
              <div>${rightColumn || '<div style="color: #999; font-style: italic;"></div>'}</div>
            </div>`;
            
            if (objectivePlan) {
              objectiveHtml += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #e2e8f0;"><strong>Plan:</strong> ${escapeHtml(objectivePlan)}</div>`;
            }
            objectiveContentEl.innerHTML = objectiveHtml || '<div style="color: #666; font-style: italic;">No objective set</div>';
          } else {
            objectiveContentEl.innerHTML = '<div style="color: #666; font-style: italic;">No objective set</div>';
          }
        }
      }

      // Fetch baseline and latest metrics for selected cycle
      await renderOptimisationMetricsSnapshotForCycle(taskId, cycleId, cycleNo);

      // Load measurement history (for selected cycle)
      await loadOptimisationMeasurementHistory(taskId, cycleId, cycleNo);

      // Load events (filtered to selected cycle)
      await loadOptimisationTaskEventsForCycle(taskId, cycleId, cycleNo);
    }

    // Phase 6: Render metrics snapshot for a specific cycle
    async function renderOptimisationMetricsSnapshotForCycle(taskId, cycleId, cycleNo) {
      // Fetch events for this cycle to get baseline and latest
      const headers = window.getOptimisationHeaders();
      const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/events?cycle_id=${cycleId || ''}&cycle_number=${cycleNo || ''}&event_type=measurement`), {
        headers: headers
      });

      let baselineMetrics = null;
      let latestMetrics = null;

      if (response.ok) {
        const data = await response.json();
        const measurements = data.events || [];
        
        if (measurements.length > 0) {
          // Sort by created_at ascending
          const sorted = [...measurements].sort((a, b) => {
            const dateA = new Date(a.created_at || a.event_at || 0);
            const dateB = new Date(b.created_at || b.event_at || 0);
            return dateA - dateB;
          });
          
          baselineMetrics = sorted[0]?.metrics || null;
          latestMetrics = sorted[sorted.length - 1]?.metrics || null;
          
          // Add captured_at to metrics
          if (baselineMetrics && sorted[0].created_at) {
            baselineMetrics.captured_at = sorted[0].created_at;
          }
          if (latestMetrics && sorted[sorted.length - 1].created_at) {
            latestMetrics.captured_at = sorted[sorted.length - 1].created_at;
          }
        }
      }

      // Render with cycle-specific metrics
      const cycleTask = {
        baseline_metrics: baselineMetrics,
        latest_metrics: latestMetrics
      };
      renderOptimisationMetricsSnapshot(cycleTask);
    }

    // Phase 6: Load events filtered to selected cycle
    async function loadOptimisationTaskEventsForCycle(taskId, cycleId, cycleNo) {
      const eventsContainer = document.getElementById('optimisation-drawer-events');
      if (!eventsContainer) return;

      try {
        const headers = window.getOptimisationHeaders();
        let url = apiUrl(`/api/optimisation/task/${taskId}/events`);
        if (cycleId) {
          url += `?cycle_id=${cycleId}`;
        } else if (cycleNo) {
          url += `?cycle_number=${cycleNo}`;
        }
        
        const response = await fetch(url, {
          method: 'GET',
          headers: headers
        });

        if (!response.ok) {
          throw new Error(`Failed to load events: ${response.status}`);
        }

        const data = await response.json();
        let events = data.events || [];

        // Filter to selected cycle if not already filtered by API
        if (cycleId || cycleNo) {
          events = events.filter(e => {
            if (cycleId) return e.cycle_id === cycleId;
            if (cycleNo) return e.cycle_number === cycleNo;
            return true;
          });
        }

        if (events.length === 0) {
          eventsContainer.innerHTML = `<div style="color: #666; font-style: italic;">No events for Cycle ${cycleNo || 'this cycle'}</div>`;
          return;
        }

        // Group events by cycle for display
        const eventsByCycle = {};
        events.forEach(event => {
          const cycleKey = event.cycle_number || 'unknown';
          if (!eventsByCycle[cycleKey]) {
            eventsByCycle[cycleKey] = [];
          }
          eventsByCycle[cycleKey].push(event);
        });

        eventsContainer.innerHTML = Object.keys(eventsByCycle).sort((a, b) => {
          if (a === 'unknown') return 1;
          if (b === 'unknown') return -1;
          return parseInt(b) - parseInt(a);
        }).map(cycleKey => {
          const cycleEvents = eventsByCycle[cycleKey];
          const cycleLabel = cycleKey === 'unknown' ? 'Other' : `Cycle ${cycleKey}`;
          return `
            <div style="margin-bottom: 1.5rem;">
              <div style="font-weight: 700; color: #1e293b; margin-bottom: 0.5rem; padding-bottom: 0.25rem; border-bottom: 2px solid #e2e8f0;">${cycleLabel}</div>
              ${cycleEvents.map(event => {
                const date = new Date(event.event_at || event.created_at).toLocaleString('en-GB', { timeZone: 'UTC' });
                return `
                  <div style="margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid #eee;">
                    <div style="font-weight: 600; color: #2563eb;">${escapeHtml(event.event_type || 'note')}</div>
                    <div style="color: #666; font-size: 0.875rem; margin-top: 0.25rem;">${date}</div>
                    ${event.note ? `<div style="margin-top: 0.5rem;">${escapeHtml(event.note)}</div>` : ''}
                  </div>
                `;
              }).join('')}
            </div>
          `;
        }).join('');
      } catch (error) {
        console.error('[Optimisation Module] Error loading events:', error);
        eventsContainer.innerHTML = '<div style="color: #ef4444;">Error loading events</div>';
      }
    }

    // Phase 8: KPI-specific formatting metadata (Phase 9: add get methods)
    const KPI_DISPLAY_METADATA = {
      clicks_28d: {
        label: 'Clicks (28d)',
        get: (m) => m?.clicks_28d ?? m?.gsc_clicks_28d ?? null,
        formatValue: (val) => val != null ? Math.round(val).toLocaleString('en-GB') : '',
        formatDelta: (delta) => {
          if (delta == null) return '';
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Math.round(delta).toLocaleString('en-GB')}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toLocaleString('en-GB');
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target).toLocaleString('en-GB')}`;
        }
      },
      impressions_28d: {
        label: 'Impressions (28d)',
        get: (m) => m?.impressions_28d ?? m?.gsc_impressions_28d ?? null,
        formatValue: (val) => {
          if (val == null) return '';
          if (val >= 1000) {
            return (val / 1000).toFixed(1) + 'k';
          }
          return Math.round(val).toLocaleString('en-GB');
        },
        formatDelta: (delta) => {
          if (delta == null) return '';
          const sign = delta >= 0 ? '+' : '';
          if (Math.abs(delta) >= 1000) {
            return `${sign}${(delta / 1000).toFixed(1)}k`;
          }
          return `${sign}${Math.round(delta).toLocaleString('en-GB')}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            if (target >= 1000) {
              return (target / 1000).toFixed(1) + 'k';
            }
            return Math.round(target).toLocaleString('en-GB');
          }
          const sign = target >= 0 ? '+' : '';
          if (Math.abs(target) >= 1000) {
            return `${sign}${(target / 1000).toFixed(1)}k`;
          }
          return `${sign}${Math.round(target).toLocaleString('en-GB')}`;
        }
      },
      ctr_28d: {
        formatValue: (val) => {
          if (val == null) return '';
          return (val * 100).toFixed(2) + '%';
        },
        formatDelta: (delta) => {
          if (delta == null) return '';
          // Delta is in decimal (0-1), convert to percentage points (pp)
          const deltaPp = delta * 100;
          const sign = deltaPp >= 0 ? '+' : '';
          return `${sign}${deltaPp.toFixed(2)}pp`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            // Absolute target is stored as decimal (0-1), display as %
            return (target * 100).toFixed(2) + '%';
          }
          // Delta target: for CTR, show as percentage points
          // The target is the absolute delta in decimal units
          const targetPp = target * 100;
          const sign = target >= 0 ? '+' : '';
          return `${sign}${targetPp.toFixed(2)}pp`;
        }
      },
      current_rank: {
        label: 'Current Rank',
        get: (m) => m?.current_rank ?? m?.rank ?? null,
        formatValue: (val) => val != null ? Math.round(val).toString() : '',
        formatDelta: (delta) => {
          if (delta == null) return '';
          // For rank, positive delta means improvement (rank went down)
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Math.round(delta)}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toString();
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target)}`;
        }
      },
      opportunity_score: {
        label: 'Opportunity Score',
        get: (m) => m?.opportunity_score ?? null,
        formatValue: (val) => val != null ? Math.round(val).toString() : '',
        formatDelta: (delta) => {
          if (delta == null) return '';
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Math.round(delta)}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toString();
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target)}`;
        }
      },
      ai_overview: {
        label: 'AI Overview',
        get: (m) => m?.ai_overview ?? false,
        formatValue: (val) => val === true ? 'On' : (val === false ? 'Off' : ''),
        formatDelta: (delta) => {
          if (delta == null) return '';
          if (delta > 0) return '+1';
          if (delta < 0) return '-1';
          return '0';
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          return target === true ? 'On' : 'Off';
        }
      },
      ai_citations: {
        label: 'AI Citations',
        get: (m) => m?.ai_citations ?? null,
        formatValue: (val) => val != null ? Math.round(val).toString() : '',
        formatDelta: (delta) => {
          if (delta == null) return '';
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Math.round(delta)}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toString();
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target)}`;
        }
      }
    };

    // Legacy formatProgressValue function (kept for backward compatibility)
    function formatProgressValue(value, kpi) {
      if (value == null || value === undefined) return '';
      
      const displayMeta = kpi ? KPI_DISPLAY_METADATA[kpi] : null;
      if (displayMeta) {
        return displayMeta.formatValue(value);
      }
      
      // Fallback for unknown KPIs
      if (typeof value === 'number') {
        if (Math.abs(value) < 1 && value !== 0) {
          return value.toFixed(2);
        }
        if (Number.isInteger(value) || Math.abs(value) >= 1) {
          return value.toLocaleString('en-GB', { maximumFractionDigits: 2 });
        }
        return value.toFixed(2);
      }
      
      return String(value);
    }
    
    // Phase 8: Compute goal progress with proper formatting
    function computeGoalProgress({ kpiKey, baseline, latest, targetValue, targetType }) {
      const displayMeta = KPI_DISPLAY_METADATA[kpiKey];
      if (!displayMeta) {
        return {
          baselineLabel: baseline != null ? String(baseline) : '',
          latestLabel: latest != null ? String(latest) : '',
          deltaLabel: '',
          targetLabel: targetValue != null ? String(targetValue) : '',
          progressLabel: ''
        };
      }

      // Calculate delta
      let delta = null;
      if (baseline != null && latest != null) {
        // For rank, improvement is positive when rank decreases
        if (kpiKey === 'current_rank') {
          delta = baseline - latest;
        } else {
          delta = latest - baseline;
        }
      }

      // Format labels
      const baselineLabel = displayMeta.formatValue(baseline);
      const latestLabel = displayMeta.formatValue(latest);
      const deltaLabel = displayMeta.formatDelta(delta);
      const targetLabel = displayMeta.formatTarget(targetValue, targetType, baseline);
      
      // Calculate remaining to target
      let remainingToTarget = null;
      if (targetType === 'delta' && delta != null && targetValue != null) {
        remainingToTarget = Math.max(0, targetValue - delta);
      } else if (targetType === 'absolute' && latest != null && targetValue != null) {
        if (kpiKey === 'current_rank') {
          remainingToTarget = Math.max(0, latest - targetValue);
        } else {
          remainingToTarget = Math.max(0, targetValue - latest);
        }
      }

      // Build progress label
      let progressLabel = '';
      if (baseline != null && latest != null && targetValue != null) {
        if (targetType === 'delta') {
          if (remainingToTarget != null && remainingToTarget > 0) {
            progressLabel = `${deltaLabel}/${targetLabel} (${displayMeta.formatDelta(remainingToTarget)} remaining)`;
          } else if (delta != null && delta >= targetValue) {
            progressLabel = `${deltaLabel}/${targetLabel} (Met)`;
          } else {
            progressLabel = `${deltaLabel}/${targetLabel}`;
          }
        } else {
          if (remainingToTarget != null && remainingToTarget > 0) {
            progressLabel = `${latestLabel}/${targetLabel} (${displayMeta.formatValue(remainingToTarget)} remaining)`;
          } else if (latest != null && ((kpiKey === 'current_rank' && latest <= targetValue) || (kpiKey !== 'current_rank' && latest >= targetValue))) {
            progressLabel = `${latestLabel}/${targetLabel} (Met)`;
          } else {
            progressLabel = `${latestLabel}/${targetLabel}`;
          }
        }
      }

      return {
        baselineLabel,
        latestLabel,
        deltaLabel,
        targetLabel,
        progressLabel,
        remainingToTarget
      };
    }

    // Phase 9: Helper functions for dashboard features
    
    // Render sparkline SVG
    function renderSparkline(points, width = 80, height = 24) {
      if (!points || points.length < 2) return '';
      
      const filtered = points.filter(p => p != null);
      if (filtered.length < 2) return '';
      
      const min = Math.min(...filtered);
      const max = Math.max(...filtered);
      const range = max - min || 1; // Avoid division by zero
      
      const padding = 2;
      const plotWidth = width - padding * 2;
      const plotHeight = height - padding * 2;
      
      const path = filtered.map((val, idx) => {
        const x = padding + (idx / (filtered.length - 1)) * plotWidth;
        const y = padding + plotHeight - ((val - min) / range) * plotHeight;
        return `${x},${y}`;
      }).join(' ');
      
      const color = filtered[filtered.length - 1] >= filtered[0] ? '#10b981' : '#ef4444';
      
      return `<svg width="${width}" height="${height}" style="display: block;">
        <polyline points="${path}" fill="none" stroke="${color}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>`;
    }
    
    // Update KPI tiles
    function updateKPITiles() {
      let tasks = window.optimisationModuleState.allTasks || [];
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      // Recalculate tiles from filtered tasks
      const tiles = {
        ctr: { on_track: 0, at_risk: 0, overdue: 0 },
        rank: { improved: 0, worse: 0, flat: 0 },
        ai_gap: 0,
        needs_measurement: 0,
        overdue_cycles: 0,
      };
      
      for (const task of tasks) {
        const objectiveRag = task.objectiveRag || task.objective_status || 'no_data';
        const objectiveKpiKey = task.objectiveKpiKey || task.objective?.kpi;
        const delta = task.delta != null ? task.delta : 0;
        
        // CTR tiles
        if (objectiveKpiKey === 'ctr_28d' && objectiveRag !== 'no_data') {
          if (objectiveRag === 'on_track') tiles.ctr.on_track++;
          else if (objectiveRag === 'at_risk') tiles.ctr.at_risk++;
          else if (objectiveRag === 'overdue') tiles.ctr.overdue++;
        }
        
        // Rank tiles
        if (objectiveKpiKey === 'current_rank' && delta != null) {
          if (delta > 0) tiles.rank.improved++;
          else if (delta < 0) tiles.rank.worse++;
          else tiles.rank.flat++;
        }
        
        // AI Gap
        if (task.latestValue != null && objectiveKpiKey === 'ai_citations') {
          // Check if AI overview is on but citations = 0
          const latestMetrics = task.latest_metrics || {};
          if (latestMetrics.ai_overview === true && (latestMetrics.ai_citations === 0 || latestMetrics.ai_citations == null)) {
            tiles.ai_gap++;
          }
        }
        
        // Needs Measurement
        if (task.needsMeasurement) {
          tiles.needs_measurement++;
        }
        
        // Overdue Cycles
        if (objectiveRag === 'overdue') {
          tiles.overdue_cycles++;
        }
      }
      
      if (tiles.ctr) {
        const onTrackEl = document.getElementById('kpi-ctr-on-track');
        const atRiskEl = document.getElementById('kpi-ctr-at-risk');
        const overdueEl = document.getElementById('kpi-ctr-overdue');
        if (onTrackEl) onTrackEl.textContent = tiles.ctr.on_track || 0;
        if (atRiskEl) atRiskEl.textContent = tiles.ctr.at_risk || 0;
        if (overdueEl) overdueEl.textContent = tiles.ctr.overdue || 0;
      }
      
      if (tiles.rank) {
        const improvedEl = document.getElementById('kpi-rank-improved');
        const worseEl = document.getElementById('kpi-rank-worse');
        const flatEl = document.getElementById('kpi-rank-flat');
        if (improvedEl) improvedEl.textContent = tiles.rank.improved || 0;
        if (worseEl) worseEl.textContent = tiles.rank.worse || 0;
        if (flatEl) flatEl.textContent = tiles.rank.flat || 0;
      }
      
      const aiGapEl = document.getElementById('kpi-ai-gap');
      const needsMeasEl = document.getElementById('kpi-needs-measurement');
      const overdueCyclesEl = document.getElementById('kpi-overdue-cycles');
      if (aiGapEl) aiGapEl.textContent = tiles.ai_gap || 0;
      if (needsMeasEl) needsMeasEl.textContent = tiles.needs_measurement || 0;
      if (overdueCyclesEl) overdueCyclesEl.textContent = tiles.overdue_cycles || 0;
    }
    
    // Update impact tiles
    function updateImpactTiles() {
      let tasks = window.optimisationModuleState.allTasks || [];
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      // Recalculate impact from filtered tasks
      let estimatedExtraClicks = 0;
      let aiCitationGapCount = 0;
      
      for (const task of tasks) {
        const objectiveKpiKey = task.objectiveKpiKey || task.objective?.kpi;
        const baselineValue = task.baselineValue;
        const latestValue = task.latestValue;
        const latestMetrics = task.latest_metrics || {};
        
        // Estimated extra clicks for CTR tasks
        if (objectiveKpiKey === 'ctr_28d' && baselineValue != null && latestValue != null) {
          const impressions = latestMetrics.impressions_28d || 0;
          if (impressions > 0 && task.objective) {
            let goalCtr = null;
            if (task.objective.target_type === 'delta') {
              goalCtr = baselineValue + task.objective.target;
            } else {
              goalCtr = task.objective.target;
            }
            if (goalCtr != null && goalCtr > latestValue) {
              const extraClicks = impressions * (goalCtr - latestValue);
              estimatedExtraClicks += extraClicks;
            }
          }
        }
        
        // AI Citation Gap
        if (latestMetrics.ai_overview === true && (latestMetrics.ai_citations === 0 || latestMetrics.ai_citations == null)) {
          aiCitationGapCount++;
        }
      }
      
      const extraClicksEl = document.getElementById('impact-extra-clicks');
      if (extraClicksEl) {
        extraClicksEl.textContent = estimatedExtraClicks >= 1000 
          ? (estimatedExtraClicks / 1000).toFixed(1) + 'k' 
          : Math.round(estimatedExtraClicks).toLocaleString('en-GB');
      }
      
      const aiGapEl = document.getElementById('impact-ai-gap');
      if (aiGapEl) aiGapEl.textContent = aiCitationGapCount || 0;
    }
    
    // Handle traffic light pill click
    window.handleTrafficLightClick = function(metricKey, bucket) {
      const currentFilter = window.optimisationModuleState.metricTrafficFilter;
      
      // Toggle: if clicking the same pill, clear filter
      if (currentFilter && currentFilter.metricKey === metricKey && currentFilter.bucket === bucket) {
        window.optimisationModuleState.metricTrafficFilter = null;
      } else {
        window.optimisationModuleState.metricTrafficFilter = { metricKey, bucket };
      }
      
      // Update visual state (highlighting)
      updateTrafficLightVisuals();
      
      // Apply filters (this will update filteredTasks)
      applyOptimisationFilters();
      
      // Update charts with new filtered data
      updateTimeseriesCharts();
      
      // Only sort if there's an active filter
      if (window.optimisationModuleState.metricTrafficFilter) {
        const filter = window.optimisationModuleState.metricTrafficFilter;
        let tasks = [...window.optimisationModuleState.filteredTasks];
        const scope = window.optimisationModuleState.scope || 'active_cycle';
        const metricKeys = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
        
        // Sort tasks by their classification for this metric
        tasks.sort((a, b) => {
          // Get classifications for both tasks
          const aActiveCycle = scope === 'active_cycle' 
            ? (a.cycles?.find(c => c.is_active || c.id === a.active_cycle_id) || null)
            : null;
          const bActiveCycle = scope === 'active_cycle' 
            ? (b.cycles?.find(c => c.is_active || c.id === b.active_cycle_id) || null)
            : null;
          
          const aMeasurements = a.measurements || [];
          const bMeasurements = b.measurements || [];
          
          const aBaselineLatest = getBaselineLatest(aMeasurements, scope, aActiveCycle);
          const bBaselineLatest = getBaselineLatest(bMeasurements, scope, bActiveCycle);
          
          let aClass, bClass;
          
          if (filter.metricKey === 'all_metrics') {
            // For all_metrics, find majority classification (at least 3 out of 6)
            const aClasses = [];
            const bClasses = [];
            
            if (aBaselineLatest) {
              for (const mk of metricKeys) {
                const cls = classifyMetric(mk, aBaselineLatest.baseline, aBaselineLatest.latest);
                if (cls) aClasses.push(cls);
              }
            }
            
            if (bBaselineLatest) {
              for (const mk of metricKeys) {
                const cls = classifyMetric(mk, bBaselineLatest.baseline, bBaselineLatest.latest);
                if (cls) bClasses.push(cls);
              }
            }
            
            // Find majority classification for task A
            if (aClasses.length >= 4) {
              const aCounts = { worse: 0, same: 0, better: 0 };
              aClasses.forEach(c => aCounts[c]++);
              const aMajority = Math.max(aCounts.worse, aCounts.same, aCounts.better);
              aClass = aCounts.worse === aMajority ? 'worse' :
                       aCounts.same === aMajority ? 'same' :
                       aCounts.better === aMajority ? 'better' : null;
              // Only use if majority is at least 4
              if (aMajority < 4) aClass = null;
            } else {
              aClass = null;
            }
            
            // Find majority classification for task B
            if (bClasses.length >= 4) {
              const bCounts = { worse: 0, same: 0, better: 0 };
              bClasses.forEach(c => bCounts[c]++);
              const bMajority = Math.max(bCounts.worse, bCounts.same, bCounts.better);
              bClass = bCounts.worse === bMajority ? 'worse' :
                       bCounts.same === bMajority ? 'same' :
                       bCounts.better === bMajority ? 'better' : null;
              // Only use if majority is at least 4
              if (bMajority < 4) bClass = null;
            } else {
              bClass = null;
            }
          } else {
            // Single metric
            aClass = aBaselineLatest ? classifyMetric(filter.metricKey, aBaselineLatest.baseline, aBaselineLatest.latest) : null;
            bClass = bBaselineLatest ? classifyMetric(filter.metricKey, bBaselineLatest.baseline, bBaselineLatest.latest) : null;
          }
          
          // Priority: better (2) > same (1) > worse (0) > null (-1)
          const getPriority = (cls) => {
            if (cls === 'better') return 2;
            if (cls === 'same') return 1;
            if (cls === 'worse') return 0;
            return -1;
          };
          
          const aPriority = getPriority(aClass);
          const bPriority = getPriority(bClass);
          
          // Sort descending (better first)
          return bPriority - aPriority;
        });
        
        window.optimisationModuleState.filteredTasks = tasks;
      }
      
      // Re-render table with new filter and sort
      renderOptimisationTasksTable();
    };
    
    // Update visual state of traffic light pills (selected/not selected)
    function updateTrafficLightVisuals() {
      const filter = window.optimisationModuleState.metricTrafficFilter;
      const pills = document.querySelectorAll('.traffic-light-pill');
      
      pills.forEach(pill => {
        const metricKey = pill.dataset.metric;
        const bucket = pill.dataset.bucket;
        const isSelected = filter && filter.metricKey === metricKey && filter.bucket === bucket;
        
        if (isSelected) {
          // Active state: bright orange border, strong glow, and brighter background
          pill.style.border = '3px solid var(--dark-brand)';
          pill.style.boxShadow = '0 0 16px rgba(245, 158, 11, 0.8), 0 0 8px rgba(245, 158, 11, 0.6)';
          pill.style.transform = 'scale(1.05)';
          pill.style.zIndex = '10';
          // Make background brighter when selected
          if (bucket === 'worse') {
            pill.style.background = 'rgba(239, 68, 68, 0.4) !important';
          } else if (bucket === 'same') {
            pill.style.background = 'rgba(245, 158, 11, 0.4) !important';
          } else {
            pill.style.background = 'rgba(16, 185, 129, 0.4) !important';
          }
        } else {
          // Inactive state: normal border, no glow, normal size
          pill.style.border = '2px solid var(--dark-border)';
          pill.style.boxShadow = 'none';
          pill.style.transform = 'scale(1)';
          pill.style.zIndex = '1';
          // Restore default background
          if (bucket === 'worse') {
            pill.style.background = 'rgba(239, 68, 68, 0.2)';
          } else if (bucket === 'same') {
            pill.style.background = 'rgba(245, 158, 11, 0.2)';
          } else {
            pill.style.background = 'rgba(16, 185, 129, 0.2)';
          }
        }
      });
    }
    
    // Helper to restore hover state (considering selection) - no longer needed with CSS hover
    window.updateTrafficLightHover = function(element) {
      // CSS handles hover now, but keep for compatibility
    };
    
    // Update traffic light counts and display
    function updateTrafficLights() {
      let tasks = window.optimisationModuleState.allTasks || [];
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      // Apply other existing filters (keyword, url, type, status) - same as table uses
      // Get filter values
      const keywordFilter = document.getElementById('optimisation-filter-keyword')?.value?.toLowerCase().trim() || '';
      const urlFilter = document.getElementById('optimisation-filter-url')?.value?.toLowerCase().trim() || '';
      const typeFilter = document.getElementById('optimisation-filter-type')?.value || '';
      const statusFilter = document.getElementById('optimisation-filter-status')?.value || '';
      
      // Apply filters
      if (keywordFilter) {
        tasks = tasks.filter(t => (t.keyword || '').toLowerCase().includes(keywordFilter));
      }
      if (urlFilter) {
        tasks = tasks.filter(t => (t.target_url || '').toLowerCase().includes(urlFilter));
      }
      if (typeFilter) {
        tasks = tasks.filter(t => t.task_type === typeFilter);
      }
      if (statusFilter) {
        tasks = tasks.filter(t => t.status === statusFilter);
      }
      
      // Get scope
      const scope = window.optimisationModuleState.scope || 'active_cycle';
      
      // Compute traffic light counts
      const counts = computeTrafficLightCounts(tasks, scope);
      
      // Update display
      const metricMap = {
        all_metrics: 'all-metrics',
        ctr_28d: 'ctr',
        impressions_28d: 'impressions',
        clicks_28d: 'clicks',
        current_rank: 'rank',
        ai_citations: 'ai-citations',
        ai_overview: 'ai-overview',
        opportunity_score: 'opportunity-score'
      };
      
      for (const [metricKey, displayKey] of Object.entries(metricMap)) {
        const worseEl = document.getElementById(`objective-${displayKey}-red`);
        const sameEl = document.getElementById(`objective-${displayKey}-amber`);
        const betterEl = document.getElementById(`objective-${displayKey}-green`);
        
        if (worseEl) worseEl.textContent = counts[metricKey].worse || 0;
        if (sameEl) sameEl.textContent = counts[metricKey].same || 0;
        if (betterEl) betterEl.textContent = counts[metricKey].better || 0;
      }
    }
    
    // Apply all filters to filteredTasks (including metric traffic filter)
    function applyOptimisationFilters() {
      let tasks = [...window.optimisationModuleState.allTasks];
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      // Apply keyword filter
      const keywordFilter = document.getElementById('optimisation-filter-keyword')?.value?.toLowerCase().trim() || '';
      if (keywordFilter) {
        tasks = tasks.filter(t => (t.keyword || '').toLowerCase().includes(keywordFilter));
      }
      
      // Apply URL filter
      const urlFilter = document.getElementById('optimisation-filter-url')?.value?.toLowerCase().trim() || '';
      if (urlFilter) {
        tasks = tasks.filter(t => (t.target_url || '').toLowerCase().includes(urlFilter));
      }
      
      // Apply type filter
      const typeFilter = document.getElementById('optimisation-filter-type')?.value || '';
      if (typeFilter) {
        tasks = tasks.filter(t => t.task_type === typeFilter);
      }
      
      // Apply status filter
      const statusFilter = document.getElementById('optimisation-filter-status')?.value || '';
      if (statusFilter) {
        tasks = tasks.filter(t => t.status === statusFilter);
      }
      
      // Apply metric traffic filter
      const metricTrafficFilter = window.optimisationModuleState.metricTrafficFilter;
      if (metricTrafficFilter) {
        const scope = window.optimisationModuleState.scope || 'active_cycle';
        const metricKeys = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
        
        tasks = tasks.filter(task => {
          // Only active tasks can match
          if (!isActiveStatus(task.status)) {
            return false;
          }
          
          // Get active cycle if scope is 'active_cycle'
          const activeCycle = scope === 'active_cycle' 
            ? (task.cycles?.find(c => c.is_active || c.id === task.active_cycle_id) || null)
            : null;
          
          // Get measurements
          const measurements = task.measurements || [];
          const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);
          
          if (!baselineLatest) {
            // Task doesn't have enough measurements, exclude
            return false;
          }
          
          // Handle "all_metrics" filter: check that majority of metrics (at least 3 out of 6) match the bucket
          if (metricTrafficFilter.metricKey === 'all_metrics') {
            const classifications = [];
            for (const metricKey of metricKeys) {
              const classification = classifyMetric(
                metricKey,
                baselineLatest.baseline,
                baselineLatest.latest
              );
              if (classification) {
                classifications.push(classification);
              }
            }
            
            // Count occurrences of the filter bucket
            const bucketCount = classifications.filter(cls => cls === metricTrafficFilter.bucket).length;
            
            // At least 4 metrics must match the bucket (majority)
            return bucketCount >= 4;
          } else {
            // Single metric filter
            const classification = classifyMetric(
              metricTrafficFilter.metricKey,
              baselineLatest.baseline,
              baselineLatest.latest
            );
            
            // Include only if classification matches the filter bucket
            return classification === metricTrafficFilter.bucket;
          }
        });
      }
      
      window.optimisationModuleState.filteredTasks = tasks;
    }
    
    // Update timeseries charts
    function updateTimeseriesCharts() {
      // Use the SAME filteredTasks as the table (includes all filters + scope + traffic-pill filter)
      let filteredTasks = window.optimisationModuleState.filteredTasks || [];
      const scope = window.optimisationModuleState.scope || 'active_cycle';
      
      // PART 1: Tasks Updated per Week (distinct tasks per week)
      const tasksUpdatedPerWeek = [];
      const weekTaskMap = new Map(); // weekKey -> Set(taskId)
      
      for (const task of filteredTasks) {
        const latestMeasurement = getLatestMeasurementInScope(task, scope);
        if (latestMeasurement && latestMeasurement.captured_at) {
          const weekKey = weekStartISO(latestMeasurement.captured_at);
          if (!weekTaskMap.has(weekKey)) {
            weekTaskMap.set(weekKey, new Set());
          }
          weekTaskMap.get(weekKey).add(task.id || task.task_id);
        }
      }
      
      // Convert to sorted array
      for (const [weekKey, taskIds] of weekTaskMap.entries()) {
        tasksUpdatedPerWeek.push({
          weekStart: weekKey,
          count: taskIds.size
        });
      }
      tasksUpdatedPerWeek.sort((a, b) => a.weekStart.localeCompare(b.weekStart));
      
      // PART 2: Median Delta by KPI (Last 30d) - only tasks with latest measurement in last 30 days
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      
      const eligibleTasks = filteredTasks.filter(task => {
        const latestMeasurement = getLatestMeasurementInScope(task, scope);
        if (!latestMeasurement || !latestMeasurement.captured_at) {
          return false;
        }
        const latestDate = new Date(latestMeasurement.captured_at);
        return latestDate >= thirtyDaysAgo;
      });
      
      // Compute deltas for each KPI
      const deltasByKpi = {};
      const kpiList = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
      
      for (const task of eligibleTasks) {
        const activeCycle = scope === 'active_cycle' 
          ? (task.cycles?.find(c => c.is_active || c.id === task.active_cycle_id) || null)
          : null;
        const measurements = task.measurements || [];
        const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);
        
        if (!baselineLatest) {
          continue;
        }
        
        // Compute delta for each KPI
        for (const kpi of kpiList) {
          const delta = computeDeltaForKPI(kpi, baselineLatest.baseline, baselineLatest.latest);
          if (delta != null) {
            if (!deltasByKpi[kpi]) {
              deltasByKpi[kpi] = [];
            }
            deltasByKpi[kpi].push(delta);
          }
        }
      }
      
      // Compute medians
      const medianDeltaByKpi = [];
      for (const [kpi, deltas] of Object.entries(deltasByKpi)) {
        if (deltas.length > 0) {
          const med = median(deltas);
          if (med != null) {
            medianDeltaByKpi.push({ kpi, value: med });
          }
        }
      }
      
      // Sort by KPI name for consistent display
      medianDeltaByKpi.sort((a, b) => a.kpi.localeCompare(b.kpi));
      
      const timeseries = {
        tasksUpdatedPerWeek,
        medianDeltaByKpi
      };
      
      // Render Tasks Updated per Week chart (with device pixel ratio for crisp rendering)
      const measurementsCanvas = document.getElementById('chart-measurements-per-week');
      if (measurementsCanvas && timeseries.tasksUpdatedPerWeek) {
        const ctx = measurementsCanvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const displayWidth = measurementsCanvas.offsetWidth || 400;
        const displayHeight = 280;
        
        // Set canvas internal size accounting for device pixel ratio for crisp rendering
        measurementsCanvas.width = displayWidth * dpr;
        measurementsCanvas.height = displayHeight * dpr;
        
        // Scale canvas CSS size to display size
        measurementsCanvas.style.width = displayWidth + 'px';
        measurementsCanvas.style.height = displayHeight + 'px';
        
        // Scale context to match device pixel ratio
        ctx.scale(dpr, dpr);
        
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        
        const data = timeseries.tasksUpdatedPerWeek;
        if (!data || data.length === 0) {
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No data', displayWidth / 2, displayHeight / 2);
        } else {
          const maxCount = Math.max(...data.map(d => d.count), 1);
          const padding = { top: 20, right: 20, bottom: 50, left: 60 };
          const chartWidth = displayWidth - padding.left - padding.right;
          const chartHeight = displayHeight - padding.top - padding.bottom;
          
          // Draw axes - white
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(padding.left, padding.top);
          ctx.lineTo(padding.left, displayHeight - padding.bottom);
          ctx.lineTo(displayWidth - padding.right, displayHeight - padding.bottom);
          ctx.stroke();
          
          // Draw y-axis label - bright white and much larger
          ctx.save();
          ctx.translate(15, displayHeight / 2);
          ctx.rotate(-Math.PI / 2);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 18px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Tasks updated', 0, 0);
          ctx.restore();
          
          // Draw x-axis label - bright white and much larger
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 18px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Week starting', displayWidth / 2, displayHeight - 10);
          
          // Draw y-axis ticks and labels - white and larger
          const yTicks = 5;
          for (let i = 0; i <= yTicks; i++) {
            const value = (maxCount / yTicks) * i;
            const y = displayHeight - padding.bottom - (i / yTicks) * chartHeight;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(padding.left, y);
            ctx.lineTo(displayWidth - padding.right, y);
            ctx.stroke();
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(Math.round(value).toString(), padding.left - 10, y + 4);
          }
          
          // Draw x-axis week labels (horizontal, wrapped) - white and larger
          data.forEach((d, i) => {
            const x = padding.left + (i / (data.length - 1 || 1)) * chartWidth;
            const weekDate = new Date(d.weekStart);
            const day = weekDate.getDate();
            const month = weekDate.getMonth() + 1;
            const weekLabel = `${day}/${month}`;
            
            // Calculate max width for label (bar width or spacing)
            const labelMaxWidth = chartWidth / data.length * 0.9;
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            
            // Simple text wrapping: if label is too long, split it
            const metrics = ctx.measureText(weekLabel);
            if (metrics.width > labelMaxWidth) {
              // Split day and month on separate lines
              ctx.fillText(day.toString(), x, displayHeight - padding.bottom + 12);
              ctx.fillText(month.toString(), x, displayHeight - padding.bottom + 24);
            } else {
              ctx.fillText(weekLabel, x, displayHeight - padding.bottom + 18);
            }
          });
          
          // Draw line
          ctx.strokeStyle = '#3b82f6';
          ctx.lineWidth = 2;
          ctx.beginPath();
          data.forEach((d, i) => {
            const x = padding.left + (i / (data.length - 1 || 1)) * chartWidth;
            const y = displayHeight - padding.bottom - (d.count / maxCount) * chartHeight;
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          });
          ctx.stroke();
          
          // Draw points
          ctx.fillStyle = '#3b82f6';
          data.forEach((d, i) => {
            const x = padding.left + (i / (data.length - 1 || 1)) * chartWidth;
            const y = displayHeight - padding.bottom - (d.count / maxCount) * chartHeight;
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fill();
          });
        }
      }

      // Render Median Delta by KPI chart (with device pixel ratio for crisp rendering)
      const deltaCanvas = document.getElementById('chart-median-delta');
      if (deltaCanvas && timeseries.medianDeltaByKpi) {
        const ctx = deltaCanvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const displayWidth = deltaCanvas.offsetWidth || 400;
        const displayHeight = 280;
        
        // Set canvas internal size accounting for device pixel ratio for crisp rendering
        deltaCanvas.width = displayWidth * dpr;
        deltaCanvas.height = displayHeight * dpr;
        
        // Scale canvas CSS size to display size
        deltaCanvas.style.width = displayWidth + 'px';
        deltaCanvas.style.height = displayHeight + 'px';
        
        // Scale context to match device pixel ratio
        ctx.scale(dpr, dpr);
        
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        
        const data = timeseries.medianDeltaByKpi;
        if (data.length === 0) {
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No data', displayWidth / 2, displayHeight / 2);
        } else {
          const maxAbs = Math.max(...data.map(d => Math.abs(d.value)), 1);
          const padding = { top: 20, right: 20, bottom: 70, left: 60 };
          const chartWidth = displayWidth - padding.left - padding.right;
          const chartHeight = displayHeight - padding.top - padding.bottom;
          const barWidth = chartWidth / data.length * 0.7;
          const barSpacing = chartWidth / data.length * 0.3;
          const zeroY = displayHeight - padding.bottom - (maxAbs / (maxAbs * 2)) * chartHeight;
          
          // KPI label mapping
          const kpiLabels = {
            'ctr_28d': 'CTR (pp)',
            'impressions_28d': 'Impressions',
            'clicks_28d': 'Clicks',
            'current_rank': 'Rank (, lower better)',
            'ai_citations': 'AI Citations',
            'ai_overview': 'AI Overview'
          };
          
          // Draw y-axis label - bright white and much larger
          ctx.save();
          ctx.translate(15, displayHeight / 2);
          ctx.rotate(-Math.PI / 2);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 18px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Median Delta', 0, 0);
          ctx.restore();
          
          // Draw zero line - white
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(padding.left, zeroY);
          ctx.lineTo(displayWidth - padding.right, zeroY);
          ctx.stroke();
          
          // Draw y-axis ticks and labels - white and larger
          const yTicks = 5;
          for (let i = 0; i <= yTicks; i++) {
            const value = (maxAbs * 2 / yTicks) * i - maxAbs;
            const y = displayHeight - padding.bottom - (i / yTicks) * chartHeight;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(padding.left, y);
            ctx.lineTo(displayWidth - padding.right, y);
            ctx.stroke();
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'right';
            const label = value >= 0 ? `+${value.toFixed(1)}` : value.toFixed(1);
            ctx.fillText(label, padding.left - 10, y + 4);
          }
          
          // Draw bars
          data.forEach((d, i) => {
            const x = padding.left + i * (barWidth + barSpacing) + barSpacing / 2;
            const barHeight = (Math.abs(d.value) / maxAbs) * chartHeight;
            const y = d.value >= 0 ? zeroY - barHeight : zeroY;
            
            ctx.fillStyle = d.value >= 0 ? '#10b981' : '#ef4444';
            ctx.fillRect(x, y, barWidth, barHeight);
            
            // Draw KPI label (horizontal, wrapped) - white and much larger
            const label = kpiLabels[d.kpi] || d.kpi.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            const labelX = x + barWidth / 2;
            const labelMaxWidth = barWidth * 0.95;
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            
            // Simple word wrapping: split on spaces if needed
            const words = label.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (const word of words) {
              const testLine = currentLine ? `${currentLine} ${word}` : word;
              const metrics = ctx.measureText(testLine);
              if (metrics.width > labelMaxWidth && currentLine) {
                lines.push(currentLine);
                currentLine = word;
              } else {
                currentLine = testLine;
              }
            }
            if (currentLine) lines.push(currentLine);
            
            // Draw lines centered under the bar
            const lineHeight = 12;
            const startY = displayHeight - padding.bottom + 15;
            lines.forEach((line, lineIdx) => {
              ctx.fillText(line, labelX, startY + (lineIdx * lineHeight));
            });
          });
        }
      }
    }
    
    // Simple line chart renderer
    function renderLineChart(canvas, data, valueKey, label) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width || canvas.offsetWidth || 400;
      const height = canvas.height || canvas.offsetHeight || 200;
      canvas.width = width;
      canvas.height = height;
      
      ctx.clearRect(0, 0, width, height);
      
      if (!data || data.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No data', width / 2, height / 2);
        return;
      }
      
      const padding = 40;
      const plotWidth = width - padding * 2;
      const plotHeight = height - padding * 2;
      
      const values = data.map(d => d[valueKey] || 0);
      const max = Math.max(...values, 1);
      
      ctx.strokeStyle = '#3b82f6';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      data.forEach((d, idx) => {
        const x = padding + (idx / (data.length - 1 || 1)) * plotWidth;
        const y = padding + plotHeight - ((d[valueKey] || 0) / max) * plotHeight;
        if (idx === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      
      ctx.stroke();
      
      // Draw points
      ctx.fillStyle = '#3b82f6';
      data.forEach((d, idx) => {
        const x = padding + (idx / (data.length - 1 || 1)) * plotWidth;
        const y = padding + plotHeight - ((d[valueKey] || 0) / max) * plotHeight;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      });
    }
    
    // Simple bar chart renderer
    function renderBarChart(canvas, data, valueKey, label) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width || canvas.offsetWidth || 400;
      const height = canvas.height || canvas.offsetHeight || 200;
      canvas.width = width;
      canvas.height = height;
      
      ctx.clearRect(0, 0, width, height);
      
      if (!data || data.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No data', width / 2, height / 2);
        return;
      }
      
      const padding = 40;
      const plotWidth = width - padding * 2;
      const plotHeight = height - padding * 2;
      const barWidth = plotWidth / data.length;
      
      const values = data.map(d => d[valueKey] || 0);
      const max = Math.max(...values.map(Math.abs), 1);
      
      data.forEach((d, idx) => {
        const value = d[valueKey] || 0;
        const barHeight = (Math.abs(value) / max) * plotHeight;
        const x = padding + idx * barWidth;
        const y = padding + plotHeight - barHeight;
        
        ctx.fillStyle = value >= 0 ? '#10b981' : '#ef4444';
        ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
        
        // Label
        ctx.fillStyle = '#333';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        const kpiLabel = d.kpi ? d.kpi.replace(/_/g, ' ').substring(0, 10) : '';
        ctx.fillText(kpiLabel, x + barWidth / 2, height - 5);
      });
    }
    
    // Filter functions for KPI tiles
    window.filterByKPIRAG = function(kpi, rag) {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        return t.objectiveKpiKey === (kpi === 'ctr' ? 'ctr_28d' : null) && t.objectiveRag === rag;
      });
      renderOptimisationTasksTable();
    };
    
    window.filterByRankDelta = function(direction) {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        if (t.objectiveKpiKey !== 'current_rank' || t.delta == null) return false;
        if (direction === 'improved') return t.delta > 0;
        if (direction === 'worse') return t.delta < 0;
        if (direction === 'flat') return t.delta === 0;
        return false;
      });
      renderOptimisationTasksTable();
    };
    
    window.filterByAIGap = function() {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        return t.objectiveKpiKey === 'ai_citations' && t.latestValue === 0;
      });
      renderOptimisationTasksTable();
    };
    
    window.filterByNeedsMeasurement = function() {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        return t.needsMeasurement === true;
      });
      renderOptimisationTasksTable();
    };
    
    window.filterByOverdueCycles = function() {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        return t.objectiveRag === 'overdue';
      });
      renderOptimisationTasksTable();
    };

    // Load task events (B3)

    // Load task events (B3)
    // Render metrics snapshot (baseline + latest + deltas)
    function renderOptimisationMetricsSnapshot(task) {
      const container = document.getElementById('optimisation-metrics-snapshot');
      if (!container) return;

      const baseline = task.baseline_metrics || null;
      const latest = task.latest_metrics || null;

      if (!baseline && !latest) {
        container.innerHTML = '<div style="color: #666; font-style: italic; grid-column: 1 / -1;">No metrics snapshot available yet.</div>';
        return;
      }

      // Helper to format numbers
      const formatNum = (val) => {
        if (val == null) return '';
        if (typeof val === 'number') {
          if (val >= 1000) return (val / 1000).toFixed(1) + 'k';
          return val.toLocaleString();
        }
        return val;
      };

      // Helper to calculate delta
      const calcDelta = (latestVal, baselineVal) => {
        if (latestVal == null || baselineVal == null) return null;
        if (typeof latestVal === 'number' && typeof baselineVal === 'number') {
          return latestVal - baselineVal;
        }
        return null;
      };

      // Helper to format delta with color (handles rank where lower is better)
      const formatDelta = (delta, metricKey) => {
        if (delta == null) return { text: '', color: '#666' };
        // For rank, lower is better (negative delta is good)
        if (metricKey === 'current_rank') {
          if (delta < 0) return { text: `${Math.abs(delta)}`, color: '#10b981' }; // Improved (moved up)
          if (delta > 0) return { text: `${delta}`, color: '#ef4444' }; // Worsened (moved down)
          return { text: '0', color: '#666' };
        }
        // For other metrics, higher is typically better
        if (delta > 0) return { text: `+${formatNum(delta)}`, color: '#10b981' };
        if (delta < 0) return { text: formatNum(delta), color: '#ef4444' };
        return { text: '0', color: '#666' };
      };

      // Build metrics table
      const metrics = [
        { label: 'Clicks (28d)', baselineKey: 'gsc_clicks_28d', latestKey: 'gsc_clicks_28d', higherIsBetter: true },
        { label: 'Impressions (28d)', baselineKey: 'gsc_impressions_28d', latestKey: 'gsc_impressions_28d', higherIsBetter: true },
        { label: 'CTR (28d)', baselineKey: 'gsc_ctr_28d', latestKey: 'gsc_ctr_28d', higherIsBetter: true, format: (v) => v != null ? (v * 100).toFixed(2) + '%' : '' },
        { label: 'Current Rank', baselineKey: 'current_rank', latestKey: 'current_rank', higherIsBetter: false },
        { label: 'AI Overview', baselineKey: 'ai_overview', latestKey: 'ai_overview', format: (v) => v ? 'On' : 'Off' },
        { label: 'AI Citations', baselineKey: 'ai_citations', latestKey: 'ai_citations', higherIsBetter: true }
      ];

      let html = `
        <div style="font-weight: 700; padding: 0.5rem; background: #e0e7ff; border-radius: 4px; font-size: 0.9rem; color: #1e293b;">Metric</div>
        <div style="font-weight: 700; padding: 0.5rem; background: #fef3c7; border-radius: 4px; font-size: 0.9rem; color: #1e293b;">Baseline</div>
        <div style="font-weight: 700; padding: 0.5rem; background: #dbeafe; border-radius: 4px; font-size: 0.9rem; color: #1e293b;">Latest</div>
      `;

      metrics.forEach(metric => {
        const baselineVal = baseline?.[metric.baselineKey];
        const latestVal = latest?.[metric.latestKey];
        const delta = calcDelta(latestVal, baselineVal);
        const deltaFormatted = formatDelta(delta, metric.latestKey);

        const formatValue = (val) => {
          if (metric.format) return metric.format(val);
          return formatNum(val);
        };

        html += `
          <div style="padding: 0.5rem; border-bottom: 1px solid #e5e7eb; font-weight: 600; font-size: 0.9rem; color: #1e293b;">${metric.label}</div>
          <div style="padding: 0.5rem; border-bottom: 1px solid #e5e7eb; font-weight: 700; font-size: 1rem; color: #1e293b;">${formatValue(baselineVal)}</div>
          <div style="padding: 0.5rem; border-bottom: 1px solid #e5e7eb; font-weight: 700; font-size: 1rem; color: #1e293b;">
            ${formatValue(latestVal)}
            ${delta != null ? `<span style="margin-left: 0.5rem; color: ${deltaFormatted.color}; font-weight: 700;">(${deltaFormatted.text})</span>` : ''}
          </div>
        `;
      });

      // Add captured_at timestamps (use created_at from event if captured_at not in metrics)
      const baselineDate = baseline?.captured_at || baseline?.created_at;
      const latestDate = latest?.captured_at || latest?.created_at;
      if (baselineDate || latestDate) {
        html += `
          <div style="padding: 0.5rem; border-top: 2px solid #e5e7eb; font-size: 0.85rem; color: #1e293b; font-weight: 600;">Captured</div>
          <div style="padding: 0.5rem; border-top: 2px solid #e5e7eb; font-size: 0.85rem; color: #1e293b; font-weight: 700;">
            ${baselineDate ? new Date(baselineDate).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' }) : ''}
          </div>
          <div style="padding: 0.5rem; border-top: 2px solid #e5e7eb; font-size: 0.85rem; color: #1e293b; font-weight: 700;">
            ${latestDate ? new Date(latestDate).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' }) : ''}
          </div>
        `;
      }

      container.innerHTML = html;
    }

    // Load and render measurement history for a task
    async function loadOptimisationMeasurementHistory(taskId, cycleId, cycleNo) {
      const container = document.getElementById('optimisation-measurement-history');
      if (!container) return;

      try {
        // Fetch last 10 measurement events for this task (current cycle only)
        const cycleFilter = cycleId ? `&cycle_id=${cycleId}` : (cycleNo ? `&cycle_number=${cycleNo}` : '');
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/events?event_type=measurement&limit=10${cycleFilter}`), {
          headers: window.getOptimisationHeaders()
        });

        if (!response.ok) {
          container.innerHTML = '<div style="color: #ef4444; font-size: 0.875rem;">Failed to load measurement history</div>';
          return;
        }

        const data = await response.json();
        const events = data.events || [];
        
        if (!events || events.length === 0) {
          container.innerHTML = '<div style="color: #666; font-style: italic; font-size: 0.875rem;">No measurements captured yet for this cycle</div>';
          return;
        }

        // Filter to current cycle and sort by created_at descending (most recent first)
        const cycleEvents = events.filter(e => {
          if (cycleId) return e.cycle_id === cycleId;
          if (cycleNo) return e.cycle_number === cycleNo;
          return true;
        }).sort((a, b) => {
          const dateA = new Date(a.created_at || a.event_at || 0);
          const dateB = new Date(b.created_at || b.event_at || 0);
          return dateB - dateA;
        });

        if (cycleEvents.length === 0) {
          container.innerHTML = '<div style="color: #666; font-style: italic; font-size: 0.875rem;">No measurements captured yet for this cycle</div>';
          return;
        }

        // Build history table
        let html = `
          <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
            <thead>
              <tr style="background: #f3f4f6; border-bottom: 2px solid #d1d5db;">
                <th style="padding: 0.5rem; text-align: left; font-weight: 600;">Date</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">Clicks</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">Impr.</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">CTR</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">Rank</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">AI Cit.</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;"> vs Prev</th>
              </tr>
            </thead>
            <tbody>
        `;

        cycleEvents.forEach((event, idx) => {
          const metrics = event.metrics || {};
          const capturedAt = event.created_at || event.event_at || event.metrics?.captured_at;
          const prevEvent = idx < cycleEvents.length - 1 ? cycleEvents[idx + 1] : null;
          const prevMetrics = prevEvent?.metrics || {};

          // Calculate deltas vs previous measurement
          const deltaClicks = metrics.gsc_clicks_28d != null && prevMetrics.gsc_clicks_28d != null 
            ? metrics.gsc_clicks_28d - prevMetrics.gsc_clicks_28d : null;
          const deltaImpr = metrics.gsc_impressions_28d != null && prevMetrics.gsc_impressions_28d != null
            ? metrics.gsc_impressions_28d - prevMetrics.gsc_impressions_28d : null;
          const deltaCTR = metrics.gsc_ctr_28d != null && prevMetrics.gsc_ctr_28d != null
            ? ((metrics.gsc_ctr_28d - prevMetrics.gsc_ctr_28d) * 100).toFixed(2) : null;
          const deltaRank = metrics.current_rank != null && prevMetrics.current_rank != null
            ? metrics.current_rank - prevMetrics.current_rank : null;
          const deltaAICit = metrics.ai_citations != null && prevMetrics.ai_citations != null
            ? metrics.ai_citations - prevMetrics.ai_citations : null;

          const formatDelta = (val, isRank = false) => {
            if (val == null) return '';
            if (isRank) {
              if (val < 0) return `<span style="color: #10b981;">${Math.abs(val)}</span>`;
              if (val > 0) return `<span style="color: #ef4444;">${val}</span>`;
              return '0';
            }
            if (val > 0) return `<span style="color: #10b981;">+${val}</span>`;
            if (val < 0) return `<span style="color: #ef4444;">${val}</span>`;
            return '0';
          };

          html += `
            <tr style="border-bottom: 1px solid #e5e7eb;">
              <td style="padding: 0.5rem; white-space: nowrap;">
                ${capturedAt ? new Date(capturedAt).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' }) : ''}
              </td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.gsc_clicks_28d != null ? metrics.gsc_clicks_28d.toLocaleString() : ''}</td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.gsc_impressions_28d != null ? metrics.gsc_impressions_28d.toLocaleString() : ''}</td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.gsc_ctr_28d != null ? (metrics.gsc_ctr_28d * 100).toFixed(2) + '%' : ''}</td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.current_rank != null ? metrics.current_rank : ''}</td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.ai_citations != null ? metrics.ai_citations : ''}</td>
              <td style="padding: 0.5rem; text-align: right; font-size: 0.8rem;">
                ${prevEvent ? `
                  <div>${formatDelta(deltaClicks)}</div>
                  <div>${formatDelta(deltaImpr)}</div>
                  <div>${formatDelta(deltaCTR)}</div>
                  <div>${formatDelta(deltaRank, true)}</div>
                  <div>${formatDelta(deltaAICit)}</div>
                ` : '<span style="color: #9ca3af;">Baseline</span>'}
              </td>
            </tr>
          `;
        });

        html += `
            </tbody>
          </table>
        `;

        container.innerHTML = html;
      } catch (error) {
        console.error('[Optimisation] Error loading measurement history:', error);
        container.innerHTML = '<div style="color: #ef4444; font-size: 0.875rem;">Error loading measurement history</div>';
      }
    }

    async function loadOptimisationTaskEvents(taskId) {
      const eventsContainer = document.getElementById('optimisation-drawer-events');
      if (!eventsContainer) return;

      try {
        const headers = window.getOptimisationHeaders();
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/events`), {
          method: 'GET',
          headers: headers
        });

        if (!response.ok) {
          throw new Error(`Failed to load events: ${response.status}`);
        }

        const data = await response.json();
        const events = data.events || [];

        if (events.length === 0) {
          eventsContainer.innerHTML = '<div style="color: #666; font-style: italic;">No events yet</div>';
          return;
        }

        eventsContainer.innerHTML = events.map(event => {
          const date = new Date(event.event_at || event.created_at).toLocaleString('en-GB');
          // Format event type for display (replace underscores with spaces, capitalize)
          const eventTypeDisplay = (event.event_type || 'note')
            .replace(/_/g, ' ')
            .replace(/\b\w/g, l => l.toUpperCase());
          // Use different colors for different event types
          let eventColor = '#2563eb'; // Default blue
          if (event.event_type === 'cycle_completed') eventColor = '#10b981'; // Green
          if (event.event_type === 'cycle_archived') eventColor = '#6b7280'; // Grey
          if (event.event_type === 'cycle_start') eventColor = '#3b82f6'; // Blue
          if (event.event_type === 'measurement') eventColor = '#8b5cf6'; // Purple
          if (event.event_type === 'status_changed') eventColor = '#f59e0b'; // Orange
          
          return `
            <div style="margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid #eee;">
              <div style="font-weight: 600; color: ${eventColor};">${escapeHtml(eventTypeDisplay)}</div>
              <div style="color: #666; font-size: 0.875rem; margin-top: 0.25rem;">${date}</div>
              ${event.note ? `<div style="margin-top: 0.5rem;">${escapeHtml(event.note)}</div>` : ''}
            </div>
          `;
        }).join('');
      } catch (error) {
        console.error('[Optimisation Module] Error loading events:', error);
        eventsContainer.innerHTML = '<div style="color: #ef4444;">Error loading events</div>';
      }
    }

    // Initialize Optimisation Tracking module
    function initOptimisationTrackingModule() {
      // Set initial active tab
      if (!window.optimisationModuleState.activeTab) {
        window.optimisationModuleState.activeTab = 'active';
      }
      
      // Update tab button states on init
      document.querySelectorAll('.optimisation-tab-btn').forEach(btn => {
        btn.classList.toggle('metric-pill--active', btn.dataset.tab === window.optimisationModuleState.activeTab);
      });
      
      // Tab button handlers
      document.querySelectorAll('.optimisation-tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          switchOptimisationTab(btn.dataset.tab);
        });
      });

      // Drawer buttons
      const closeBtn = document.getElementById('optimisation-drawer-close');
      if (closeBtn) {
        closeBtn.addEventListener('click', closeOptimisationTaskDrawer);
      }
      
      const closeBottomBtn = document.getElementById('optimisation-drawer-close-bottom');
      if (closeBottomBtn) {
        closeBottomBtn.addEventListener('click', closeOptimisationTaskDrawer);
      }
      
      const minimizeBtn = document.getElementById('optimisation-drawer-minimize');
      if (minimizeBtn) {
        minimizeBtn.addEventListener('click', minimizeOptimisationDrawer);
      }
      
      const maximizeBtn = document.getElementById('optimisation-drawer-maximize');
      if (maximizeBtn) {
        maximizeBtn.addEventListener('click', maximizeOptimisationDrawer);
      }
      
      // Edit Objective button
      const editObjectiveBtn = document.getElementById('optimisation-edit-objective-btn');
      if (editObjectiveBtn) {
        editObjectiveBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (typeof window.editObjective === 'function') {
            window.editObjective();
          }
        });
      }

      // Save Objective button
      const saveObjectiveBtn = document.getElementById('optimisation-save-objective-btn');
      if (saveObjectiveBtn) {
        saveObjectiveBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (typeof window.saveObjective === 'function') {
            window.saveObjective();
          }
        });
      }

      // Cancel Edit Objective button
      const cancelEditObjectiveBtn = document.getElementById('optimisation-cancel-edit-objective-btn');
      if (cancelEditObjectiveBtn) {
        cancelEditObjectiveBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (typeof window.cancelEditObjective === 'function') {
            window.cancelEditObjective();
          }
        });
      }

      // Measurement history toggle
      const measurementHistoryToggle = document.getElementById('optimisation-measurement-history-toggle');
      const measurementHistoryContainer = document.getElementById('optimisation-measurement-history');
      if (measurementHistoryToggle && measurementHistoryContainer) {
        measurementHistoryToggle.addEventListener('click', () => {
          const isVisible = measurementHistoryContainer.style.display !== 'none';
          measurementHistoryContainer.style.display = isVisible ? 'none' : 'block';
          measurementHistoryToggle.textContent = isVisible ? 'Show' : 'Hide';
        });
      }

      // Update due date when timeframe changes
      const timeframeInput = document.getElementById('optimisation-edit-objective-timeframe');
      if (timeframeInput) {
        timeframeInput.addEventListener('input', updateObjectiveDueDate);
      }

      // Backdrop click to close (but not when clicking on drawer)
      const backdrop = document.getElementById('optimisation-task-drawer-backdrop');
      if (backdrop) {
        backdrop.addEventListener('click', (e) => {
          if (e.target === backdrop) {
            closeOptimisationTaskDrawer();
          }
        });
      }
      
      // Initialize dragging
      initOptimisationDrawerDragging();

      // Bulk update button
      const bulkUpdateBtn = document.getElementById('optimisation-bulk-update-btn');
      if (bulkUpdateBtn) {
        bulkUpdateBtn.addEventListener('click', async () => {
          if (typeof window.bulkUpdateAllTasks === 'function') {
            await window.bulkUpdateAllTasks();
          }
        });
      }

      // Timeline toggle (collapsed by default)
      const timelineHeader = document.getElementById('optimisation-timeline-header');
      const timelineToggle = document.getElementById('optimisation-timeline-toggle');
      const timelineContainer = document.getElementById('optimisation-drawer-events-container');
      if (timelineHeader && timelineToggle && timelineContainer) {
        timelineHeader.addEventListener('click', () => {
          const isCollapsed = timelineContainer.style.display === 'none';
          timelineContainer.style.display = isCollapsed ? 'block' : 'none';
          timelineToggle.textContent = isCollapsed ? '' : '';
        });
        // Ensure it starts collapsed
        timelineContainer.style.display = 'none';
        timelineToggle.textContent = '';
      }

      // Filter handlers
      const filterStatus = document.getElementById('optimisation-filter-status');
      const filterType = document.getElementById('optimisation-filter-type');
      const filterKeyword = document.getElementById('optimisation-filter-keyword');
      const filterUrl = document.getElementById('optimisation-filter-url');
      const clearFilters = document.getElementById('optimisation-clear-filters');

      const applyFilters = () => {
        // Apply base filters (test tasks, keyword, url, type, status, metric traffic)
        applyOptimisationFilters();
        
        // Apply additional button filters on top of base filters
        let filtered = [...window.optimisationModuleState.filteredTasks];
        
        // Apply status/type/keyword/url filters (using field name variations)
        if (filterStatus && filterStatus.value) {
          filtered = filtered.filter(t => t.status === filterStatus.value);
        }
        if (filterType && filterType.value) {
          filtered = filtered.filter(t => t.task_type === filterType.value);
        }
        if (filterKeyword && filterKeyword.value) {
          const keyword = filterKeyword.value.toLowerCase();
          filtered = filtered.filter(t => 
            (t.keyword_text || t.keyword || '').toLowerCase().includes(keyword)
          );
        }
        if (filterUrl && filterUrl.value) {
          const url = filterUrl.value.toLowerCase();
          filtered = filtered.filter(t => 
            (t.target_url_clean || t.target_url || '').toLowerCase().includes(url)
          );
        }
        
        // "Needs Update" filter: tasks with no measurement or measurement older than 30 days
        const needsUpdateBtn = document.getElementById('optimisation-filter-needs-update');
        if (needsUpdateBtn && needsUpdateBtn.classList.contains('active')) {
          const thirtyDaysAgo = new Date();
          thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
          
          filtered = filtered.filter(t => {
            // Check if task has latest_metrics
            if (!t.latest_metrics) {
              return true; // No measurement = needs update
            }
            
            // Check captured_at from latest_metrics
            const capturedAt = t.latest_metrics.captured_at;
            if (!capturedAt) {
              return true; // No capture date = needs update
            }
            
            const latestCapturedDate = new Date(capturedAt);
            return latestCapturedDate < thirtyDaysAgo; // Older than 30 days = needs update
          });
        }
        
        // "Active Cycle Only" filter: tasks with an active cycle (not completed/archived)
        const activeCycleBtn = document.getElementById('optimisation-filter-active-cycle');
        if (activeCycleBtn && activeCycleBtn.classList.contains('active')) {
          filtered = filtered.filter(t => {
            return t.active_cycle_id != null; // Has an active cycle
          });
        }
        
        // "Overdue Cycle" filter: tasks with overdue current cycle
        const overdueCycleBtn = document.getElementById('optimisation-filter-overdue-cycle');
        if (overdueCycleBtn && overdueCycleBtn.classList.contains('active')) {
          filtered = filtered.filter(t => {
            // Check if current cycle is overdue
            const status = t.objective_status || t.goal_state;
            return status === 'overdue';
          });
        }

        window.optimisationModuleState.filteredTasks = filtered;
        // Reset pagination when filters change
        optimisationPaginationState.currentPage = 1;
        updateTrafficLights(); // Update traffic lights when filters change
        updateTrafficLightVisuals(); // Update visual state of pills
        updateTimeseriesCharts(); // Update charts with filtered data
        renderOptimisationTasksTable();
      };

      if (filterStatus) filterStatus.addEventListener('change', applyFilters);
      if (filterType) filterType.addEventListener('change', applyFilters);
      if (filterKeyword) filterKeyword.addEventListener('input', applyFilters);
      if (filterUrl) filterUrl.addEventListener('input', applyFilters);
      
      // Attach click handlers to all traffic light pills (for pills that don't have onclick yet)
      setTimeout(() => {
        const metricMap = {
          'objective-impressions': 'impressions_28d',
          'objective-clicks': 'clicks_28d',
          'objective-rank': 'current_rank',
          'objective-ai-citations': 'ai_citations',
          'objective-ai-overview': 'ai_overview'
        };
        
        for (const [prefix, metricKey] of Object.entries(metricMap)) {
          const worseEl = document.getElementById(`${prefix}-red`);
          const sameEl = document.getElementById(`${prefix}-amber`);
          const betterEl = document.getElementById(`${prefix}-green`);
          
          if (worseEl && !worseEl.closest('.traffic-light-pill')) {
            const pill = worseEl.closest('div[style*="background"]');
            if (pill) {
              pill.classList.add('traffic-light-pill');
              pill.dataset.metric = metricKey;
              pill.dataset.bucket = 'worse';
              pill.style.background = 'rgba(239, 68, 68, 0.2)';
              pill.onclick = () => handleTrafficLightClick(metricKey, 'worse');
              // Remove any inline hover handlers - CSS handles it now
              pill.removeAttribute('onmouseover');
              pill.removeAttribute('onmouseout');
            }
          }
          
          if (sameEl && !sameEl.closest('.traffic-light-pill')) {
            const pill = sameEl.closest('div[style*="background"]');
            if (pill) {
              pill.classList.add('traffic-light-pill');
              pill.dataset.metric = metricKey;
              pill.dataset.bucket = 'same';
              pill.style.background = 'rgba(245, 158, 11, 0.2)';
              pill.onclick = () => handleTrafficLightClick(metricKey, 'same');
              // Remove any inline hover handlers - CSS handles it now
              pill.removeAttribute('onmouseover');
              pill.removeAttribute('onmouseout');
            }
          }
          
          if (betterEl && !betterEl.closest('.traffic-light-pill')) {
            const pill = betterEl.closest('div[style*="background"]');
            if (pill) {
              pill.classList.add('traffic-light-pill');
              pill.dataset.metric = metricKey;
              pill.dataset.bucket = 'better';
              pill.style.background = 'rgba(16, 185, 129, 0.2)';
              pill.onclick = () => handleTrafficLightClick(metricKey, 'better');
              // Remove any inline hover handlers - CSS handles it now
              pill.removeAttribute('onmouseover');
              pill.removeAttribute('onmouseout');
            }
          }
        }
        
        // Update visual state on initial load
        updateTrafficLightVisuals();
      }, 100);
      
      const needsUpdateBtn = document.getElementById('optimisation-filter-needs-update');
      if (needsUpdateBtn) {
        needsUpdateBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('[Optimisation] Needs Update button clicked');
          needsUpdateBtn.classList.toggle('active');
          if (needsUpdateBtn.classList.contains('active')) {
            needsUpdateBtn.style.background = '#3b82f6';
            needsUpdateBtn.style.color = '#ffffff';
          } else {
            needsUpdateBtn.style.background = '';
            needsUpdateBtn.style.color = '';
          }
          console.log('[Optimisation] Needs Update filter active:', needsUpdateBtn.classList.contains('active'));
          applyFilters();
        });
      } else {
        console.error('[Optimisation] Needs Update button not found!');
      }
      
      // Active Cycle Only filter button
      const activeCycleBtn = document.getElementById('optimisation-filter-active-cycle');
      if (activeCycleBtn) {
        activeCycleBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          activeCycleBtn.classList.toggle('active');
          if (activeCycleBtn.classList.contains('active')) {
            activeCycleBtn.style.background = '#3b82f6';
            activeCycleBtn.style.color = '#ffffff';
          } else {
            activeCycleBtn.style.background = '';
            activeCycleBtn.style.color = '';
          }
          applyFilters();
        });
      }
      
      // Overdue Cycle filter button
      const overdueCycleBtn = document.getElementById('optimisation-filter-overdue-cycle');
      if (overdueCycleBtn) {
        overdueCycleBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          overdueCycleBtn.classList.toggle('active');
          if (overdueCycleBtn.classList.contains('active')) {
            overdueCycleBtn.style.background = '#ef4444';
            overdueCycleBtn.style.color = '#ffffff';
          } else {
            overdueCycleBtn.style.background = '';
            overdueCycleBtn.style.color = '';
          }
          applyFilters();
        });
      }
      
      // Objective filter pills
      const goalNotSet = document.getElementById('optimisation-goal-filter-not-set');
      const goalOnTrack = document.getElementById('optimisation-goal-filter-on-track');
      const goalOverdue = document.getElementById('optimisation-goal-filter-overdue');
      const goalMet = document.getElementById('optimisation-goal-filter-met');
      
      const updateObjectiveFilterUI = () => {
        const active = window.optimisationModuleState.activeObjectiveFilter;
        [goalNotSet, goalOnTrack, goalOverdue, goalMet].forEach((el, idx) => {
          if (!el) return;
          const states = ['not_set', 'on_track', 'overdue', 'met'];
          if (active === states[idx]) {
            el.style.opacity = '1';
            el.style.fontWeight = '600';
            el.style.border = '2px solid #3b82f6';
          } else {
            el.style.opacity = active ? '0.6' : '1';
            el.style.fontWeight = '';
            el.style.border = '';
          }
        });
      };
      
      if (goalNotSet) {
        goalNotSet.addEventListener('click', () => {
          if (window.optimisationModuleState.activeObjectiveFilter === 'not_set') {
            window.optimisationModuleState.activeObjectiveFilter = null;
          } else {
            window.optimisationModuleState.activeObjectiveFilter = 'not_set';
          }
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      if (goalOnTrack) {
        goalOnTrack.addEventListener('click', () => {
          if (window.optimisationModuleState.activeObjectiveFilter === 'on_track') {
            window.optimisationModuleState.activeObjectiveFilter = null;
          } else {
            window.optimisationModuleState.activeObjectiveFilter = 'on_track';
          }
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      if (goalOverdue) {
        goalOverdue.addEventListener('click', () => {
          if (window.optimisationModuleState.activeObjectiveFilter === 'overdue') {
            window.optimisationModuleState.activeObjectiveFilter = null;
          } else {
            window.optimisationModuleState.activeObjectiveFilter = 'overdue';
          }
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      if (goalMet) {
        goalMet.addEventListener('click', () => {
          if (window.optimisationModuleState.activeObjectiveFilter === 'met') {
            window.optimisationModuleState.activeObjectiveFilter = null;
          } else {
            window.optimisationModuleState.activeObjectiveFilter = 'met';
          }
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      
      if (clearFilters) {
        clearFilters.addEventListener('click', () => {
          if (filterStatus) filterStatus.value = '';
          if (filterType) filterType.value = '';
          if (filterKeyword) filterKeyword.value = '';
          if (filterUrl) filterUrl.value = '';
          // Clear metric traffic filter
          window.optimisationModuleState.metricTrafficFilter = null;
          updateTrafficLightVisuals();
          if (needsUpdateBtn) {
            needsUpdateBtn.classList.remove('active');
            needsUpdateBtn.style.background = '';
            needsUpdateBtn.style.color = '';
          }
          const activeCycleBtn = document.getElementById('optimisation-filter-active-cycle');
          if (activeCycleBtn) {
            activeCycleBtn.classList.remove('active');
            activeCycleBtn.style.background = '';
            activeCycleBtn.style.color = '';
          }
          const overdueCycleBtn = document.getElementById('optimisation-filter-overdue-cycle');
          if (overdueCycleBtn) {
            overdueCycleBtn.classList.remove('active');
            overdueCycleBtn.style.background = '';
            overdueCycleBtn.style.color = '';
          }
          const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
          if (includeTestCheckbox) {
            includeTestCheckbox.checked = false;
          }
          window.optimisationModuleState.activeObjectiveFilter = null;
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      
      // Include test tasks checkbox
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (includeTestCheckbox) {
        includeTestCheckbox.addEventListener('change', () => {
          applyFilters();
          updateOptimisationSummaryCards();
          updateKPITiles();
          updateImpactTiles();
          updateTimeseriesCharts();
        });
      }
      
      // Scope toggle
      const scopeSelect = document.getElementById('optimisation-scope-select');
      const scopeDescription = document.getElementById('optimisation-scope-description');
      if (scopeSelect) {
        scopeSelect.value = window.optimisationModuleState.scope || 'active_cycle';
        scopeSelect.addEventListener('change', () => {
          window.optimisationModuleState.scope = scopeSelect.value;
          if (scopeDescription) {
            scopeDescription.textContent = scopeSelect.value === 'active_cycle' 
              ? 'Showing metrics for tasks with active cycles only'
              : 'Showing metrics for all tasks';
          }
          window.loadAllOptimisationTasks();
        });
        if (scopeDescription) {
          scopeDescription.textContent = scopeSelect.value === 'active_cycle' 
            ? 'Showing metrics for tasks with active cycles only'
            : 'Showing metrics for all tasks';
        }
      }

      // Drawer action handlers
      const addEventBtn = document.getElementById('optimisation-add-event-btn');
      if (addEventBtn) {
        addEventBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          const eventType = document.getElementById('optimisation-event-type').value;
          const note = document.getElementById('optimisation-event-note').value;

          if (!note.trim()) {
            alert('Please enter a note');
            return;
          }

          try {
            const headers = window.getOptimisationHeaders();
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/event`), {
              method: 'POST',
              headers: headers,
              body: JSON.stringify({ event_type: eventType, note })
            });

            if (!response.ok) throw new Error('Failed to add event');

            document.getElementById('optimisation-event-note').value = '';
            await loadOptimisationTaskEvents(taskId);
            await window.loadAllOptimisationTasks();
            
            // If it was a measurement event, refresh the modal to update badge with fresh goal_state
            if (eventType === 'measurement') {
              if (typeof debugLog === 'function') {
                debugLog(`[Optimisation] Measurement added, refreshing modal to update badge state`, 'info');
              }
              await openOptimisationTaskDrawer(taskId);
            }
          } catch (error) {
            if (typeof debugLog === 'function') {
              debugLog(`[Optimisation] Error adding event: ${error.message}`, 'error');
            }
            console.error('[Optimisation Module] Error adding event:', error);
            alert('Failed to add event: ' + error.message);
          }
        });
      }

      const saveStatusBtn = document.getElementById('optimisation-save-status-btn');
      if (saveStatusBtn) {
        saveStatusBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          const newStatus = document.getElementById('optimisation-change-status').value;
          if (!newStatus) {
            alert('Please select a status');
            return;
          }

          try {
            await window.submitStatusChange(newStatus, taskId);
            await window.loadAllOptimisationTasks();
            await openOptimisationTaskDrawer(taskId);
          } catch (error) {
            console.error('[Optimisation Module] Error changing status:', error);
            alert('Failed to change status: ' + error.message);
          }
        });
      }

      // Complete Cycle button
      const completeCycleBtn = document.getElementById('optimisation-complete-cycle-btn');
      if (completeCycleBtn) {
        completeCycleBtn.addEventListener('click', async () => {
          // Get task ID from state
          let taskId = window.optimisationModuleState?.currentTaskId;
          
          // If not in state, try to get from the drawer's displayed content
          if (!taskId && window.optimisationModuleState?.allTasks?.length > 0) {
            // Find the task that has an active cycle (most likely the one being viewed)
            const taskWithActiveCycle = window.optimisationModuleState.allTasks.find(t => t.active_cycle_id);
            if (taskWithActiveCycle) {
              taskId = taskWithActiveCycle.id;
            }
          }
          
          if (!taskId) {
            alert('No task selected. Please open a task first.');
            return;
          }

          const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
          if (!task) {
            alert('Task not found. Please refresh the page.');
            return;
          }
          
          if (!task.active_cycle_id) {
            alert('No active cycle to complete');
            return;
          }

          if (!confirm(`Complete Cycle ${task.cycle_no || task.cycle_active || 'current'}? This will close the cycle and mark it as completed.`)) {
            return;
          }

          try {
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/cycle/complete`), {
              method: 'POST',
              headers: { ...window.getOptimisationHeaders(), 'Content-Type': 'application/json' },
              body: JSON.stringify({
                action: 'complete',
                cycle_id: task.active_cycle_id
              })
            });

            if (!response.ok) {
              const error = await response.json().catch(() => ({ error: 'Unknown error' }));
              throw new Error(error.error || 'Failed to complete cycle');
            }

            const result = await response.json();
            console.log('[Optimisation] Cycle completed successfully:', result);
            
            // Update task in state
            const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
            if (taskIndex >= 0 && result.task) {
              window.optimisationModuleState.allTasks[taskIndex] = result.task;
            }

            // Reload tasks to get fresh data
            if (typeof window.loadAllOptimisationTasks === 'function') {
              await window.loadAllOptimisationTasks();
            }
            
            // Refresh drawer if it's still open for this task
            if (window.optimisationModuleState.currentTaskId === taskId) {
              if (typeof window.openOptimisationTaskDrawer === 'function') {
                await window.openOptimisationTaskDrawer(taskId);
              }
            }

            // Refresh table
            if (typeof renderOptimisationTasksTable === 'function') {
              renderOptimisationTasksTable();
            }
            
            // Show success message
            alert(`Cycle ${task.cycle_no || task.cycle_active || 'current'} has been completed successfully.`);
          } catch (error) {
            console.error('[Optimisation] Error completing cycle:', error);
            alert('Failed to complete cycle: ' + error.message);
          }
        });
      }

      // Archive Cycle button
      const archiveCycleBtn = document.getElementById('optimisation-archive-cycle-btn');
      if (archiveCycleBtn) {
        archiveCycleBtn.addEventListener('click', async () => {
          // Get task ID from state
          let taskId = window.optimisationModuleState?.currentTaskId;
          
          // If not in state, try to get from the drawer's displayed content
          if (!taskId && window.optimisationModuleState?.allTasks?.length > 0) {
            // Find the task that has an active cycle (most likely the one being viewed)
            const taskWithActiveCycle = window.optimisationModuleState.allTasks.find(t => t.active_cycle_id);
            if (taskWithActiveCycle) {
              taskId = taskWithActiveCycle.id;
            }
          }
          
          if (!taskId) {
            alert('No task selected. Please open a task first.');
            return;
          }

          const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
          if (!task) {
            alert('Task not found. Please refresh the page.');
            return;
          }
          
          if (!task.active_cycle_id) {
            alert('No active cycle to archive');
            return;
          }

          if (!confirm(`Archive Cycle ${task.cycle_no || task.cycle_active || 'current'}? This will mark the cycle as archived (for abandoned work).`)) {
            return;
          }

          try {
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/cycle/complete`), {
              method: 'POST',
              headers: { ...window.getOptimisationHeaders(), 'Content-Type': 'application/json' },
              body: JSON.stringify({
                action: 'archive',
                cycle_id: task.active_cycle_id
              })
            });

            if (!response.ok) {
              const error = await response.json().catch(() => ({ error: 'Unknown error' }));
              throw new Error(error.error || 'Failed to archive cycle');
            }

            const result = await response.json();
            console.log('[Optimisation] Cycle archived successfully:', result);
            
            // Update task in state
            const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
            if (taskIndex >= 0 && result.task) {
              window.optimisationModuleState.allTasks[taskIndex] = result.task;
            }

            // Reload tasks to get fresh data
            if (typeof window.loadAllOptimisationTasks === 'function') {
              await window.loadAllOptimisationTasks();
            }
            
            // Refresh drawer if it's still open for this task
            if (window.optimisationModuleState.currentTaskId === taskId) {
              if (typeof window.openOptimisationTaskDrawer === 'function') {
                await window.openOptimisationTaskDrawer(taskId);
              }
            }

            // Refresh table
            if (typeof renderOptimisationTasksTable === 'function') {
              renderOptimisationTasksTable();
            }
            
            // Show success message
            alert(`Cycle ${task.cycle_no || task.cycle_active || 'current'} has been archived successfully.`);
          } catch (error) {
            console.error('[Optimisation] Error archiving cycle:', error);
            alert('Failed to archive cycle: ' + error.message);
          }
        });
      }

      const startCycleBtn = document.getElementById('optimisation-start-cycle-btn');
      if (startCycleBtn) {
        startCycleBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          try {
            await window.startNewCycle();
            await window.loadAllOptimisationTasks();
            await openOptimisationTaskDrawer(taskId);
          } catch (error) {
            console.error('[Optimisation Module] Error starting cycle:', error);
            alert('Failed to start cycle: ' + error.message);
          }
        });
      }

      const cancelTaskBtn = document.getElementById('optimisation-cancel-task-btn');
      if (cancelTaskBtn) {
        cancelTaskBtn.addEventListener('click', async () => {
          if (!confirm('Cancel this task? It will be marked as cancelled but history will be preserved.')) {
            return;
          }

          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          try {
            await window.stopTracking();
            await window.loadAllOptimisationTasks();
            closeOptimisationTaskDrawer();
          } catch (error) {
            console.error('[Optimisation Module] Error cancelling task:', error);
            alert('Failed to cancel task: ' + error.message);
          }
        });
      }

      const deleteTaskBtn = document.getElementById('optimisation-delete-task-btn');
      if (deleteTaskBtn) {
        deleteTaskBtn.addEventListener('click', async () => {
          try {
            await window.deleteTask();
          } catch (error) {
            alert('Failed to delete task: ' + error.message);
          }

          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          try {
            await window.deleteTask();
            await window.loadAllOptimisationTasks();
            // Refresh Ranking & AI table if it's visible
            if (typeof window.renderRankingAiTab === 'function') {
              await window.renderRankingAiTab();
            }
            closeOptimisationTaskDrawer();
          } catch (error) {
            console.error('[Optimisation Module] Error deleting task:', error);
            alert('Failed to delete task: ' + error.message);
          }
        });
      }

      const addMeasurementBtn = document.getElementById('optimisation-add-measurement-btn');
      if (addMeasurementBtn) {
        addMeasurementBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          // Try to get current row data from Ranking & AI table if available
          const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
          if (!task) {
            alert('Task not found. Please refresh the page.');
            return;
          }

          // Try to ensure Ranking & AI data is loaded
          if (typeof window.renderRankingAiTab === 'function') {
            try {
              await window.renderRankingAiTab();
              // Small delay to let data load
              await new Promise(resolve => setTimeout(resolve, 500));
            } catch (e) {
              console.warn('[Optimisation] Could not refresh Ranking & AI data:', e);
            }
          }

          // Try to find matching row in Ranking & AI data
          let currentMetrics = null;
          let matchingRow = null;
          
          // First try RankingAiModule state
          if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
            const { combinedRows } = RankingAiModule.state();
            console.log('[Optimisation] Searching in combinedRows:', combinedRows?.length, 'rows');
            
            // Normalize URLs for comparison
            const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
            const taskUrlPath = taskUrlClean.includes('/') ? taskUrlClean.split('/').slice(1).join('/') : '';
            
            matchingRow = combinedRows?.find(r => {
              const keywordMatch = (r.keyword || '').toLowerCase() === (task.keyword_text || '').toLowerCase();
              if (!keywordMatch) return false;
              
              // Try multiple URL matching strategies
              const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
              const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
              const rowUrlPath = rowUrlClean.includes('/') ? rowUrlClean.split('/').slice(1).join('/') : '';
              
              return rowUrl === taskUrlClean || 
                     rowUrlClean === taskUrlClean ||
                     rowUrlPath === taskUrlPath ||
                     rowUrl.includes(taskUrlClean) ||
                     taskUrlClean.includes(rowUrlClean);
            });
            
            console.log('[Optimisation] Found matching row:', matchingRow ? 'YES' : 'NO', { 
              taskKeyword: task.keyword_text, 
              taskUrl: task.target_url_clean || task.target_url,
              matchingRowKeyword: matchingRow?.keyword,
              matchingRowUrl: matchingRow?.best_url || matchingRow?.targetUrl
            });
            
            if (matchingRow) {
              // Get queryTotal data for clicks, impressions, and CTR (same as submitTrackKeyword)
              let queryTotal = null;
              if (typeof getQueryTotalForKeyword === 'function') {
                queryTotal = getQueryTotalForKeyword(task.keyword_text);
              }
              
              currentMetrics = {
                gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
                gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
                // queryTotal.ctr is a percentage (0-100), convert to decimal for storage
                gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
                current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
                opportunity_score: matchingRow.opportunityScore || null,
                ai_overview: matchingRow.has_ai_overview || false,
                ai_citations: matchingRow.ai_alan_citations_count || 0,
                ai_citations_total: matchingRow.ai_total_citations || 0,
                classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
                page_type: matchingRow.pageType || null,
                segment: matchingRow.segment || null,
                captured_at: new Date().toISOString()
              };
            }
          }
          
          // If still no data, try to get from window.rankingAiData
          if (!matchingRow && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
            console.log('[Optimisation] Searching in window.rankingAiData:', window.rankingAiData.length, 'rows');
            
            const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
            const taskUrlPath = taskUrlClean.includes('/') ? taskUrlClean.split('/').slice(1).join('/') : '';
            
            matchingRow = window.rankingAiData.find(r => {
              const keywordMatch = (r.keyword || '').toLowerCase() === (task.keyword_text || '').toLowerCase();
              if (!keywordMatch) return false;
              
              const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
              const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
              const rowUrlPath = rowUrlClean.includes('/') ? rowUrlClean.split('/').slice(1).join('/') : '';
              
              return rowUrl === taskUrlClean || 
                     rowUrlClean === taskUrlClean ||
                     rowUrlPath === taskUrlPath ||
                     rowUrl.includes(taskUrlClean) ||
                     taskUrlClean.includes(rowUrlClean);
            });
            
            console.log('[Optimisation] Found matching row in window.rankingAiData:', matchingRow ? 'YES' : 'NO');
            
          }
          
          // Build metrics from matching row if found
          if (matchingRow) {
            // Get queryTotal data for clicks, impressions, and CTR (same as submitTrackKeyword)
            let queryTotal = null;
            if (typeof getQueryTotalForKeyword === 'function') {
              queryTotal = getQueryTotalForKeyword(task.keyword_text);
              console.log('[Optimisation] QueryTotal for keyword:', queryTotal);
            }
            
            currentMetrics = {
              gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
              gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
              // queryTotal.ctr is a percentage (0-100), convert to decimal for storage
              gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
              current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
              opportunity_score: matchingRow.opportunityScore || null,
              ai_overview: matchingRow.has_ai_overview || false,
              ai_citations: matchingRow.ai_alan_citations_count || 0,
              ai_citations_total: matchingRow.ai_total_citations || 0,
              classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
              page_type: matchingRow.pageType || null,
              segment: matchingRow.segment || null,
              captured_at: new Date().toISOString()
            };
            
            console.log('[Optimisation] Built currentMetrics from matching row:', currentMetrics);
          }

          // If no current data, try to use baseline metrics (if no new audit, current = baseline)
          if (!currentMetrics) {
            console.warn('[Optimisation] No matching row found for:', {
              keyword: task.keyword_text,
              url: task.target_url_clean || task.target_url
            });
            
            // Check if we have baseline metrics to reuse
            const baselineMetrics = task.baseline_metrics;
            if (baselineMetrics && typeof baselineMetrics === 'object') {
              console.log('[Optimisation] Using baseline metrics as current (no new audit data found)');
              // Reuse baseline metrics but update captured_at to current timestamp
              currentMetrics = {
                ...baselineMetrics,
                captured_at: new Date().toISOString()
              };
            } else {
              // No baseline either, ask user
              const proceed = confirm('Could not find current ranking data for this keyword/URL. Create measurement with current timestamp only?');
              if (!proceed) return;
              
              // Create minimal metrics with just captured_at
              currentMetrics = {
                captured_at: new Date().toISOString()
              };
            }
          }

          try {
            const headers = window.getOptimisationHeaders();
            console.log('[Optimisation] Adding measurement with metrics:', currentMetrics);
            
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/measurement`), {
              method: 'POST',
              headers: headers,
              body: JSON.stringify({
                metrics: currentMetrics,
                note: 'Measurement snapshot'
              })
            });

            if (!response.ok) {
              const errorText = await response.text();
              console.error('[Optimisation] Measurement error response:', errorText);
              throw new Error(errorText || 'Failed to add measurement');
            }

            const responseData = await response.json();
            console.log('[Optimisation] Measurement response:', responseData);

            // Reload tasks to get fresh data from view
            await window.loadAllOptimisationTasks();
            
            // If the response includes updated task data, use it to update state immediately
            if (responseData.task) {
              const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
              if (taskIndex >= 0) {
                window.optimisationModuleState.allTasks[taskIndex] = responseData.task;
                console.log('[Optimisation] Updated task in state with latest_metrics:', responseData.task.latest_metrics);
              } else {
                // Task not in state yet, add it
                window.optimisationModuleState.allTasks.push(responseData.task);
              }
            }
            
            // Refresh drawer with updated data
            await openOptimisationTaskDrawer(taskId);
            
            alert('Measurement added successfully!');
          } catch (error) {
            console.error('[Optimisation Module] Error adding measurement:', error);
            alert('Failed to add measurement: ' + error.message);
          }
        });
      }
    }

    // Bulk update all tasks with latest data
    window.bulkUpdateAllTasks = async function bulkUpdateAllTasks() {
      if (!window.optimisationModuleState || !window.optimisationModuleState.allTasks) {
        alert('No tasks loaded. Please wait for tasks to load first.');
        return;
      }

      // Get active tasks (not done/cancelled/deleted)
      const activeTasks = window.optimisationModuleState.allTasks.filter(
        t => !['done', 'cancelled', 'deleted'].includes(t.status)
      );

      if (activeTasks.length === 0) {
        alert('No active tasks to update.');
        return;
      }

      const confirmMsg = `Update ${activeTasks.length} task(s) with latest ranking data? This will create a new measurement for each task.`;
      if (!confirm(confirmMsg)) {
        return;
      }

      // Ensure Ranking & AI data is loaded
      if (typeof window.renderRankingAiTab === 'function') {
        try {
          await window.renderRankingAiTab();
          await new Promise(resolve => setTimeout(resolve, 1000)); // Give time for data to load
        } catch (e) {
          console.warn('[Optimisation] Could not refresh Ranking & AI data:', e);
        }
      }

      // Get ranking data sources
      let combinedRows = [];
      if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
        const state = RankingAiModule.state();
        combinedRows = state.combinedRows || [];
      }
      if (combinedRows.length === 0 && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
        combinedRows = window.rankingAiData;
      }

      if (combinedRows.length === 0) {
        alert('No ranking data available. Please run a Ranking & AI check first.');
        return;
      }

      const bulkUpdateBtn = document.getElementById('optimisation-bulk-update-btn');
      const originalText = bulkUpdateBtn ? bulkUpdateBtn.textContent : '';
      if (bulkUpdateBtn) {
        bulkUpdateBtn.disabled = true;
        bulkUpdateBtn.textContent = 'Updating...';
      }

      let successCount = 0;
      let skippedCount = 0;
      let failCount = 0;
      const errors = [];

      try {
        // Process sequentially to avoid rate limits (max 3 concurrent)
        const maxConcurrent = 3;
        for (let i = 0; i < activeTasks.length; i += maxConcurrent) {
          const batch = activeTasks.slice(i, i + maxConcurrent);
          
          await Promise.all(batch.map(async (task, batchIdx) => {
            const taskNum = i + batchIdx + 1;
            if (bulkUpdateBtn) {
              bulkUpdateBtn.textContent = `Updating ${taskNum}/${activeTasks.length}...`;
            }

          // Find matching row
          const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
          const taskUrlPath = taskUrlClean.includes('/') ? taskUrlClean.split('/').slice(1).join('/') : '';
          
          const matchingRow = combinedRows.find(r => {
            const keywordMatch = (r.keyword || '').toLowerCase() === (task.keyword_text || '').toLowerCase();
            if (!keywordMatch) return false;
            
            const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
            const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
            const rowUrlPath = rowUrlClean.includes('/') ? rowUrlClean.split('/').slice(1).join('/') : '';
            
            return rowUrl === taskUrlClean || 
                   rowUrlClean === taskUrlClean ||
                   rowUrlPath === taskUrlPath ||
                   rowUrl.includes(taskUrlClean) ||
                   taskUrlClean.includes(rowUrlClean);
          });

          let currentMetrics = null;

          if (matchingRow) {
            // Get queryTotal data for clicks, impressions, and CTR
            let queryTotal = null;
            if (typeof getQueryTotalForKeyword === 'function') {
              queryTotal = getQueryTotalForKeyword(task.keyword_text);
            }
            
            currentMetrics = {
              gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
              gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
              gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
              current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
              opportunity_score: matchingRow.opportunityScore || null,
              ai_overview: matchingRow.has_ai_overview || false,
              ai_citations: matchingRow.ai_alan_citations_count || 0,
              ai_citations_total: matchingRow.ai_total_citations || 0,
              classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
              page_type: matchingRow.pageType || null,
              segment: matchingRow.segment || null,
              captured_at: new Date().toISOString()
            };
          } else if (task.baseline_metrics) {
            // Fallback to baseline if no current data found
            console.log(`[Optimisation] No current data for ${task.keyword_text}, using baseline`);
            currentMetrics = { ...task.baseline_metrics, captured_at: new Date().toISOString() };
            // Remove null GSC metrics to avoid stale nulls
            if (currentMetrics.gsc_clicks_28d === null) delete currentMetrics.gsc_clicks_28d;
            if (currentMetrics.gsc_impressions_28d === null) delete currentMetrics.gsc_impressions_28d;
            if (currentMetrics.gsc_ctr_28d === null) delete currentMetrics.gsc_ctr_28d;
          }

          if (!currentMetrics) {
            failCount++;
            errors.push(`${task.keyword_text}: No data found`);
            return;
          }

            // Create measurement
            try {
              const headers = window.getOptimisationHeaders();
              const response = await fetch(apiUrl(`/api/optimisation/task/${task.id}/measurement`), {
                method: 'POST',
                headers: { ...headers, 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  metrics: currentMetrics,
                  note: 'Bulk update - latest data snapshot'
                })
              });

              if (!response.ok) {
                const error = await response.json().catch(() => ({ error: 'Unknown error' }));
                throw new Error(error.error || 'Failed to create measurement');
              }

              const result = await response.json();
              if (result.skipped) {
                skippedCount++;
              } else {
                successCount++;
              }
            } catch (error) {
              failCount++;
              errors.push(`${task.keyword_text}: ${error.message}`);
              console.error(`[Optimisation] Error updating task ${task.id}:`, error);
            }
          }));
        }

        // Reload tasks to show updated data
        await window.loadAllOptimisationTasks();

        // Show results in modal
        showBulkUpdateResultsModal(successCount, skippedCount, failCount, errors, activeTasks.length);

      } catch (error) {
        console.error('[Optimisation] Bulk update error:', error);
        showBulkUpdateResultsModal(0, 0, activeTasks.length, [`Bulk update failed: ${error.message}`], activeTasks.length);
      } finally {
        if (bulkUpdateBtn) {
          bulkUpdateBtn.disabled = false;
          bulkUpdateBtn.textContent = originalText;
        }
      }
    };

    // Show bulk update results modal
    function showBulkUpdateResultsModal(successCount, skippedCount, failCount, errors, totalTasks) {
      const modal = document.getElementById('optimisation-bulk-update-results-modal');
      const content = document.getElementById('bulk-update-results-content');
      
      if (!modal || !content) {
        // Fallback to alert if modal not found
        let message = `Updated ${successCount} task(s) successfully.`;
        if (skippedCount > 0) {
          message += ` Skipped ${skippedCount} (recent measurement within 5 minutes).`;
        }
        if (failCount > 0) {
          message += `\n\nFailed to update ${failCount} task(s):\n${errors.slice(0, 5).join('\n')}`;
          if (errors.length > 5) {
            message += `\n... and ${errors.length - 5} more.`;
          }
        }
        alert(message);
        return;
      }

      // Build summary HTML
      let html = '<div style="margin-bottom: 1.5rem;">';
      
      // Summary stats
      html += '<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 1.5rem;">';
      html += `<div style="padding: 1rem; background: #f0fdf4; border-left: 4px solid #10b981; border-radius: 4px;">
        <div style="font-size: 2rem; font-weight: 700; color: #10b981;">${successCount}</div>
        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">Successfully Updated</div>
      </div>`;
      html += `<div style="padding: 1rem; background: #fef3c7; border-left: 4px solid #f59e0b; border-radius: 4px;">
        <div style="font-size: 2rem; font-weight: 700; color: #f59e0b;">${skippedCount}</div>
        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">Skipped</div>
      </div>`;
      html += `<div style="padding: 1rem; background: #fee2e2; border-left: 4px solid #ef4444; border-radius: 4px;">
        <div style="font-size: 2rem; font-weight: 700; color: #ef4444;">${failCount}</div>
        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">Failed</div>
      </div>`;
      html += `<div style="padding: 1rem; background: #f3f4f6; border-left: 4px solid #6b7280; border-radius: 4px;">
        <div style="font-size: 2rem; font-weight: 700; color: #6b7280;">${totalTasks}</div>
        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">Total Tasks</div>
      </div>`;
      html += '</div>';

      // Skipped tasks explanation
      if (skippedCount > 0) {
        html += '<div style="padding: 1rem; background: #fef3c7; border-left: 4px solid #f59e0b; border-radius: 4px; margin-bottom: 1rem;">';
        html += '<div style="font-weight: 600; color: #92400e; margin-bottom: 0.5rem;">Why were tasks skipped?</div>';
        html += '<div style="font-size: 0.875rem; color: #78350f;">Tasks were skipped because they already have a recent measurement (within the last 5 minutes). This prevents duplicate measurements if you click the update button multiple times.</div>';
        html += '</div>';
      }

      // Failed tasks details
      if (failCount > 0 && errors.length > 0) {
        html += '<div style="padding: 1rem; background: #fee2e2; border-left: 4px solid #ef4444; border-radius: 4px; margin-bottom: 1rem;">';
        html += '<div style="font-weight: 600; color: #991b1b; margin-bottom: 0.75rem;">Failed Tasks:</div>';
        html += '<div style="max-height: 300px; overflow-y: auto; font-size: 0.875rem;">';
        html += '<ul style="margin: 0; padding-left: 1.5rem; color: #7f1d1d;">';
        errors.forEach(error => {
          html += `<li style="margin-bottom: 0.5rem;">${escapeHtml(error)}</li>`;
        });
        html += '</ul>';
        html += '</div>';
        html += '<div style="margin-top: 0.75rem; font-size: 0.875rem; color: #7f1d1d;">';
        html += '<strong>Common reasons for failures:</strong><ul style="margin-top: 0.5rem; padding-left: 1.5rem;">';
        html += '<li>No matching data found in Ranking & AI results</li>';
        html += '<li>Task keyword or URL doesn\'t match any ranking data</li>';
        html += '<li>Network or server error during update</li>';
        html += '<li>Task is missing required fields</li>';
        html += '</ul>';
        html += '</div>';
        html += '</div>';
      }

      // Success message
      if (successCount > 0) {
        html += '<div style="padding: 1rem; background: #f0fdf4; border-left: 4px solid #10b981; border-radius: 4px;">';
        html += '<div style="font-weight: 600; color: #065f46; margin-bottom: 0.5rem;"> Update Complete</div>';
        html += '<div style="font-size: 0.875rem; color: #047857;">Successfully updated measurements for ' + successCount + ' task(s). The table has been refreshed to show the latest data.</div>';
        html += '</div>';
      }

      html += '</div>';

      content.innerHTML = html;
      modal.style.display = 'flex';
    }

    // Close bulk update results modal
    window.closeBulkUpdateResultsModal = function closeBulkUpdateResultsModal() {
      const modal = document.getElementById('optimisation-bulk-update-results-modal');
      if (modal) {
        modal.style.display = 'none';
      }
    };

    // Update latest metrics for a single task
    window.updateTaskLatest = async function updateTaskLatest(taskId) {
      const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      if (!task) {
        alert('Task not found. Please refresh the page.');
        return;
      }

      // Ensure Ranking & AI data is loaded
      if (typeof window.renderRankingAiTab === 'function') {
        try {
          await window.renderRankingAiTab();
          await new Promise(resolve => setTimeout(resolve, 500));
        } catch (e) {
          console.warn('[Optimisation] Could not refresh Ranking & AI data:', e);
        }
      }

      // Get ranking data sources
      let combinedRows = [];
      if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
        const state = RankingAiModule.state();
        combinedRows = state.combinedRows || [];
      }
      if (combinedRows.length === 0 && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
        combinedRows = window.rankingAiData;
      }

      // Find matching row
      const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
      const taskUrlPath = taskUrlClean.includes('/') ? taskUrlClean.split('/').slice(1).join('/') : '';
      
      const matchingRow = combinedRows.find(r => {
        const keywordMatch = (r.keyword || '').toLowerCase() === (task.keyword_text || '').toLowerCase();
        if (!keywordMatch) return false;
        
        const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
        const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
        const rowUrlPath = rowUrlClean.includes('/') ? rowUrlClean.split('/').slice(1).join('/') : '';
        
        return rowUrl === taskUrlClean || 
               rowUrlClean === taskUrlClean ||
               rowUrlPath === taskUrlPath ||
               rowUrl.includes(taskUrlClean) ||
               taskUrlClean.includes(rowUrlClean);
      });

      let currentMetrics = null;

      if (matchingRow) {
        // Get queryTotal data for clicks, impressions, and CTR
        let queryTotal = null;
        if (typeof getQueryTotalForKeyword === 'function') {
          queryTotal = getQueryTotalForKeyword(task.keyword_text);
        }
        
        currentMetrics = {
          gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
          gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
          gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
          current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
          opportunity_score: matchingRow.opportunityScore || null,
          ai_overview: matchingRow.has_ai_overview || false,
          ai_citations: matchingRow.ai_alan_citations_count || 0,
          ai_citations_total: matchingRow.ai_total_citations || 0,
          classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
          page_type: matchingRow.pageType || null,
          segment: matchingRow.segment || null,
          captured_at: new Date().toISOString()
        };
      } else if (task.baseline_metrics) {
        // Fallback to baseline if no current data found
        currentMetrics = { ...task.baseline_metrics, captured_at: new Date().toISOString() };
        if (currentMetrics.gsc_clicks_28d === null) delete currentMetrics.gsc_clicks_28d;
        if (currentMetrics.gsc_impressions_28d === null) delete currentMetrics.gsc_impressions_28d;
        if (currentMetrics.gsc_ctr_28d === null) delete currentMetrics.gsc_ctr_28d;
      }

      if (!currentMetrics) {
        alert('No ranking data available for this task. Please run a Ranking & AI check first.');
        return;
      }

      // Find the Update button to show loading state
      const updateBtn = event?.target;
      const originalText = updateBtn?.textContent || 'Update';
      if (updateBtn) {
        updateBtn.disabled = true;
        updateBtn.textContent = 'Updating...';
      }

      try {
        const headers = window.getOptimisationHeaders();
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/measurement`), {
          method: 'POST',
          headers: { ...headers, 'Content-Type': 'application/json' },
          body: JSON.stringify({
            metrics: currentMetrics,
            note: 'Latest measurement captured'
          })
        });

        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: 'Unknown error' }));
          throw new Error(error.error || 'Failed to create measurement');
        }

        const result = await response.json();
        
        // Reload tasks to show updated data
        await window.loadAllOptimisationTasks();
        
        // Show success message
        if (result.skipped) {
          if (typeof debugLog === 'function') {
            debugLog(`[Optimisation] Measurement skipped (recent): ${task.keyword_text}`, 'info');
          }
          // Show brief feedback
          if (updateBtn) {
            updateBtn.textContent = 'Skipped';
            setTimeout(() => {
              if (updateBtn) {
                updateBtn.disabled = false;
                updateBtn.textContent = originalText;
              }
            }, 2000);
          }
        } else {
          if (typeof debugLog === 'function') {
            debugLog(`[Optimisation] Measurement updated: ${task.keyword_text}`, 'success');
          }
          // Show brief success feedback
          if (updateBtn) {
            updateBtn.textContent = '';
            setTimeout(() => {
              if (updateBtn) {
                updateBtn.disabled = false;
                updateBtn.textContent = originalText;
              }
            }, 2000);
          }
        }
      } catch (error) {
        console.error(`[Optimisation] Error updating task ${taskId}:`, error);
        alert(`Failed to update task: ${error.message}`);
        if (updateBtn) {
          updateBtn.disabled = false;
          updateBtn.textContent = originalText;
        }
      }
    };

    // Add to ensurePanelRendered
    const originalEnsurePanelRendered = ensurePanelRendered;
    ensurePanelRendered = function(panelId) {
      originalEnsurePanelRendered(panelId);
      
      if (panelId === 'optimisation') {
        if (!window.optimisationModuleInitialized) {
          initOptimisationTrackingModule();
          window.optimisationModuleInitialized = true;
        }
        window.loadAllOptimisationTasks();
      }
    };

    // ======================
    // GSC Date Range Configuration
    // ======================
    // Centralized constant for GSC window (matches GSC UI default)
    const GSC_WINDOW_DAYS = 28;
    
    /**
     * Get GSC date range helper (matches backend utils.js getGscDateRange)
     * @param {number} daysBack - Number of days to look back (default: GSC_WINDOW_DAYS)
     * @param {number} endOffsetDays - Days to subtract from today for end date (default: 1 = yesterday)
     * @returns {Object} { startDate, endDate } as ISO strings (YYYY-MM-DD)
     */
    function getGscDateRange(daysBack = GSC_WINDOW_DAYS, endOffsetDays = 1) {
      // End date = yesterday (matches GSC UI behavior - today is often partial)
      const end = new Date();
      end.setDate(end.getDate() - endOffsetDays);
      end.setHours(0, 0, 0, 0);
      
      // Start date = end date - (daysBack - 1) days (inclusive range)
      const start = new Date(end);
      start.setDate(start.getDate() - (daysBack - 1));
      start.setHours(0, 0, 0, 0);
      
      // Format as YYYY-MM-DD
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      return {
        startDate: formatDate(start),
        endDate: formatDate(end)
      };
    }
    
    function safeSetLocalStorage(key, value) {
      try {
        const valueString = typeof value === 'string' ? value : JSON.stringify(value);
        // Check size before saving (localStorage limit is typically 5-10MB)
        if (valueString.length > 4 * 1024 * 1024) {
          debugLog(` Data too large for localStorage (${Math.round(valueString.length / 1024)}KB), skipping save. Supabase is source of truth.`, 'warn');
          return false;
        }
        localStorage.setItem(key, valueString);
        return true;
      } catch (error) {
        if (error.name === 'QuotaExceededError' || error.message.includes('quota')) {
          debugLog(` localStorage quota exceeded for ${key}, skipping save. Supabase is source of truth.`, 'warn');
          return false;
        } else {
          debugLog(` Error saving to localStorage (${key}): ${error.message}`, 'error');
          return false;
        }
      }
    }
    
    // ======================
    // CRITICAL: Define buildMoneyPageMetrics at GLOBAL SCOPE first
    // This ensures it's available when displayDashboard runs
    // ======================
    console.log('[Money Pages] Defining buildMoneyPageMetrics at global scope...');
    
    // Define helper functions that buildMoneyPageMetrics depends on (if not already defined)
    // These will be defined later in the script, but we need to ensure buildMoneyPageMetrics
    // can be called even if these helpers aren't ready yet
    
    // Placeholder - will be replaced by actual function when script loads
    // This is a fallback used only if no external Money Pages module is wired.
    // It returns empty metrics so the UI can show "No data" rather than crash.
    // Diagnostic function to check keyword matching issues AND missing search volume
    window.diagnoseKeywordMatching = function() {
      try {
        const savedAudit = loadAuditResultsSync();
        if (!savedAudit || !savedAudit.searchData) {
          debugLog(' No audit data found. Cannot diagnose keyword matching.', 'warn');
          return;
        }
        
        // Get keywords from ranking data
        let rankingData = [];
        if (window.RankingAiModule && typeof window.RankingAiModule.state === 'function') {
          const state = window.RankingAiModule.state();
          rankingData = state.combinedRows || [];
        }
        
        if (!rankingData || rankingData.length === 0) {
          debugLog(' No ranking keywords found. Cannot diagnose.', 'warn');
          return;
        }
        
        const allKeywords = rankingData.map(r => r.keyword).filter(k => k && k.trim());
        const queryTotals = savedAudit.searchData.queryTotals || [];
        
        debugLog(` Diagnostic: Checking ${allKeywords.length} keywords`, 'info');
        
        // CRITICAL: Check for missing search_volume (this is what the UI shows as "")
        const missingSearchVolume = [];
        const hasSearchVolume = [];
        
        rankingData.forEach(row => {
          const searchVolume = row.search_volume;
          // IMPORTANT: Only treat as missing if null/undefined, not if 0 (0 is a valid value)
          if (searchVolume == null || searchVolume === undefined) {
            missingSearchVolume.push({ keyword: row.keyword, search_volume: searchVolume });
          } else {
            hasSearchVolume.push({ keyword: row.keyword, search_volume: searchVolume });
          }
        });
        
        debugLog(` Search Volume Analysis:`, 'info');
        debugLog(`   Has search volume: ${hasSearchVolume.length} keywords`, 'success');
        debugLog(`   Missing search volume: ${missingSearchVolume.length} keywords`, missingSearchVolume.length > 0 ? 'warn' : 'success');
        if (missingSearchVolume.length > 0) {
          const missingList = missingSearchVolume.slice(0, 20).map(m => m.keyword).join(', ');
          debugLog(`  Missing search volume keywords: ${missingList}${missingSearchVolume.length > 20 ? ` ... (${missingSearchVolume.length - 20} more)` : ''}`, 'warn');
        }
        
        // Also check queryTotals matching (for impressions/CTR)
        const missingQueryTotals = [];
        const matchedQueryTotals = [];
        const zeroImpressionKeywords = [];
        
        allKeywords.forEach(keyword => {
          const normalizedKeyword = normalizeKeywordForMatching(keyword);
          const queryTotal = queryTotals.find(
            qt => {
              if (!qt.query) return false;
              const normalizedQuery = normalizeKeywordForMatching(qt.query);
              return normalizedQuery === normalizedKeyword || 
                     normalizedQuery.includes(normalizedKeyword) || 
                     normalizedKeyword.includes(normalizedQuery);
            }
          );
          
          if (!queryTotal) {
            missingQueryTotals.push(keyword);
          } else {
            matchedQueryTotals.push(keyword);
            if (queryTotal.impressions === 0 || queryTotal.impressions == null) {
              zeroImpressionKeywords.push({ keyword, query: queryTotal.query, impressions: queryTotal.impressions });
            }
          }
        });
        
        debugLog(` QueryTotals Analysis (for impressions/CTR):`, 'info');
        debugLog(`   Matched: ${matchedQueryTotals.length} keywords`, 'success');
        debugLog(`   Missing: ${missingQueryTotals.length} keywords`, missingQueryTotals.length > 0 ? 'warn' : 'info');
        if (missingQueryTotals.length > 0) {
          debugLog(`  Missing queryTotals: ${missingQueryTotals.slice(0, 20).join(', ')}${missingQueryTotals.length > 20 ? ` ... (${missingQueryTotals.length - 20} more)` : ''}`, 'warn');
        }
        
        debugLog(` Zero impressions: ${zeroImpressionKeywords.length} keywords`, zeroImpressionKeywords.length > 0 ? 'info' : 'success');
        if (zeroImpressionKeywords.length > 0) {
          const sample = zeroImpressionKeywords.slice(0, 10).map(z => `${z.keyword} (query: "${z.query}", impressions: ${z.impressions})`).join(', ');
          debugLog(`Sample zero-impression keywords: ${sample}${zeroImpressionKeywords.length > 10 ? '...' : ''}`, 'info');
        }
        
        // Check for queries in queryTotals that don't match any keywords (orphaned queries)
        const orphanedQueries = queryTotals.filter(qt => {
          const normalizedQuery = normalizeKeywordForMatching(qt.query || '');
          return !allKeywords.some(k => {
            const normalizedKeyword = normalizeKeywordForMatching(k);
            return normalizedQuery === normalizedKeyword || 
                   normalizedQuery.includes(normalizedKeyword) || 
                   normalizedKeyword.includes(normalizedQuery);
          });
        });
        
        if (orphanedQueries.length > 0) {
          debugLog(` Found ${orphanedQueries.length} orphaned queries in queryTotals (don't match any keywords)`, 'warn');
          const sample = orphanedQueries.slice(0, 10).map(qt => qt.query || '(no query)').join(', ');
          debugLog(`Sample orphaned queries: ${sample}${orphanedQueries.length > 10 ? '...' : ''}`, 'warn');
        }
        
        return {
          totalKeywords: allKeywords.length,
          totalQueryTotals: queryTotals.length,
          // Search volume analysis (what UI shows as "")
          missingSearchVolume: missingSearchVolume.length,
          missingSearchVolumeKeywords: missingSearchVolume,
          hasSearchVolume: hasSearchVolume.length,
          // QueryTotals analysis (for impressions/CTR)
          matched: matchedQueryTotals.length,
          missing: missingQueryTotals.length,
          missingKeywords: missingQueryTotals,
          zeroImpression: zeroImpressionKeywords.length,
          zeroImpressionKeywords: zeroImpressionKeywords,
          orphaned: orphanedQueries.length,
          orphanedQueries: orphanedQueries
        };
      } catch (error) {
        debugLog(` Error diagnosing keyword matching: ${error.message}`, 'error');
        return null;
      }
    };
    
    // Function to check Supabase database for missing search volume
    window.checkSupabaseSearchVolume = async function() {
      try {
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (!propertyUrl) {
          debugLog(' No property URL found. Cannot query Supabase.', 'warn');
          return;
        }
        
        debugLog(` Querying Supabase for missing search volume...`, 'info');
        
        const response = await fetch(apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`));
        if (!response.ok) {
          const errorText = await response.text();
          debugLog(` Failed to fetch from Supabase: ${response.status} - ${errorText}`, 'warn');
          return;
        }
        
        const data = await response.json();
        if (data.status !== 'ok' || !data.data || !data.data.rankingAiData || !data.data.rankingAiData.combinedRows) {
          debugLog(' No ranking data found in Supabase response', 'warn');
          return;
        }
        
        const keywords = data.data.rankingAiData.combinedRows || [];
        const missingSearchVolume = keywords.filter(k => k.search_volume == null || k.search_volume === undefined);
        const hasSearchVolume = keywords.filter(k => k.search_volume != null && k.search_volume !== undefined);
        
        debugLog(` Supabase Search Volume Analysis:`, 'info');
        debugLog(`  Total keywords in DB: ${keywords.length}`, 'info');
        debugLog(`   Has search volume: ${hasSearchVolume.length} keywords`, 'success');
        debugLog(`   Missing search volume: ${missingSearchVolume.length} keywords`, missingSearchVolume.length > 0 ? 'warn' : 'success');
        
        if (missingSearchVolume.length > 0) {
          const missingList = missingSearchVolume.slice(0, 30).map(k => k.keyword).join(', ');
          debugLog(`  Missing search volume keywords: ${missingList}${missingSearchVolume.length > 30 ? ` ... (${missingSearchVolume.length - 30} more)` : ''}`, 'warn');
        }
        
        return {
          total: keywords.length,
          hasSearchVolume: hasSearchVolume.length,
          missingSearchVolume: missingSearchVolume.length,
          missingKeywords: missingSearchVolume.map(k => k.keyword)
        };
      } catch (error) {
        debugLog(` Error checking Supabase: ${error.message}`, 'error');
        return null;
      }
    };
    
    // Manual function to fetch and save queryTotals (for debugging/fixing missing data)
    window.fetchQueryTotalsManually = async function() {
      try {
        const savedAudit = loadAuditResultsSync();
        if (!savedAudit || !savedAudit.searchData) {
          debugLog(' No audit data found in localStorage. Please run a full audit first.', 'warn');
          return;
        }
        
        // Get keywords from ranking data
        let rankingData = [];
        
        // Try to get from RankingAiModule state first
        if (window.RankingAiModule && typeof window.RankingAiModule.state === 'function') {
          const state = window.RankingAiModule.state();
          rankingData = state.combinedRows || [];
          debugLog(` Found ${rankingData.length} keywords from RankingAiModule state`, 'info');
        }
        
        // Fallback: try to get from localStorage
        if (!rankingData || rankingData.length === 0) {
          try {
            const storedData = localStorage.getItem('ranking_ai_data');
            if (storedData) {
              const parsed = JSON.parse(storedData);
              if (parsed && parsed.combinedRows && Array.isArray(parsed.combinedRows)) {
                rankingData = parsed.combinedRows;
                debugLog(` Found ${rankingData.length} keywords from localStorage`, 'info');
              }
            }
          } catch (e) {
            debugLog(` Failed to parse ranking data from localStorage: ${e.message}`, 'warn');
          }
        }
        
        // Fallback: try to get from saved audit's keyword_rankings
        if (!rankingData || rankingData.length === 0) {
          if (savedAudit.keywordRankings && Array.isArray(savedAudit.keywordRankings)) {
            rankingData = savedAudit.keywordRankings;
            debugLog(` Found ${rankingData.length} keywords from saved audit`, 'info');
          }
        }
        
        if (!rankingData || rankingData.length === 0) {
          debugLog(' No ranking keywords found. Please run the ranking scan first.', 'warn');
          return;
        }
        
        const allKeywords = rankingData.map(r => r.keyword).filter(k => k && k.trim());
        if (allKeywords.length === 0) {
          debugLog(' No valid keywords found in ranking data.', 'warn');
          return;
        }
        
        debugLog(` Manually fetching queryTotals for ${allKeywords.length} keywords...`, 'info');
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28');
        
        // Fetch queryTotals from GSC API
        const keywordsParam = encodeURIComponent(JSON.stringify(allKeywords));
        const propertyParam = encodeURIComponent(propertyUrl);
        const gscResponse = await fetch(apiUrl(`/api/aigeo/gsc-entity-metrics?property=${propertyParam}&keywords=${keywordsParam}&days=${dateRange}`));
        
        if (gscResponse.ok) {
          const gscData = await gscResponse.json();
          if (gscData.status === 'ok' && gscData.data && Array.isArray(gscData.data.queryTotals)) {
            const queryTotals = gscData.data.queryTotals;
            debugLog(` Fetched queryTotals for ${queryTotals.length} keywords from GSC`, 'success');
            
            // Merge queryTotals into searchData
            savedAudit.searchData.queryTotals = queryTotals;
            
            // Use the SAME audit_date as the existing audit
            let auditDate = new Date().toISOString().split('T')[0];
            if (savedAudit.timestamp) {
              try {
                auditDate = new Date(savedAudit.timestamp).toISOString().split('T')[0];
              } catch (e) {
                // Use today as fallback
              }
            }
            
            // Save to Supabase
            const saveResponse = await fetch(apiUrl('/api/supabase/save-audit'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                propertyUrl: propertyUrl,
                auditDate: auditDate,
                searchData: savedAudit.searchData
              })
            });
            
            if (saveResponse.ok) {
              debugLog(` Saved queryTotals to Supabase (${queryTotals.length} keywords)`, 'success');
              
              // Update localStorage
              try {
                safeSetLocalStorage('last_audit_results', savedAudit);
                debugLog(` Updated localStorage with queryTotals`, 'success');
              } catch (localStorageErr) {
                debugLog(` Failed to update localStorage: ${localStorageErr.message}`, 'warn');
              }
              
              // Re-render the table to show the new data
              renderRankingAiTab();
              debugLog(' Table re-rendered with queryTotals data', 'success');
            } else {
              const errorText = await saveResponse.text();
              debugLog(` Failed to save queryTotals to Supabase: ${saveResponse.status} - ${errorText}`, 'warn');
            }
          } else {
            debugLog(` GSC API did not return queryTotals data`, 'warn');
          }
        } else {
          const errorText = await gscResponse.text();
          debugLog(` Failed to fetch queryTotals from GSC: ${gscResponse.status} - ${errorText}`, 'warn');
        }
      } catch (error) {
        debugLog(` Error manually fetching queryTotals: ${error.message}`, 'error');
      }
    };
    
    window.buildMoneyPageMetrics = function(topPages, schemaAudit) {
      console.warn('[Money Pages]  buildMoneyPageMetrics placeholder called - full implementation not loaded yet. This is a fallback to prevent crashes. The UI will show "No data" until the full implementation loads.');
      // Return empty array as fallback so UI can gracefully handle missing data
      return [];
    };
    
    console.log('[Money Pages]  buildMoneyPageMetrics placeholder assigned to window');
    
    // ======================
    // Ranking & AI module - DEFINE FIRST to ensure it's available
    // ======================
    console.log('[RankingAiModule] Starting module definition at top of script...');
    window.RankingAiModule = (function () {
      console.log('[RankingAiModule] IIFE executing...');
      // Core tracked keywords. Real queries, no mock values.
      // Include both Money and Education terms.
      const TRACKED_KEYWORDS = [
        "alan ranger",
        "beginner photography classes",
        "beginner photography courses",
        "beginners photography course near me",
        "beginning photography lessons",
        "best photography classes",
        "best photography course",
        "best photography workshops",
        "camera courses for beginners",
        "commercial photographer",
        "commercial photography services",
        "corporate photography",
        "free online photography course",
        "hire a photographer",
        "hire a professional photographer",
        "landscape photography courses",
        "landscape photography workshop",
        "Landscape Photography Workshops",
        "landscape photography workshops uk",
        "landscape workshops",
        "lightroom courses",
        "one day photography workshops",
        "online photography courses",
        "online photography lesson",
        "photo editing course",
        "photo workshops",
        "photographer coventry",
        "photographer in coventry",
        "photographic workshops",
        "photography classes",
        "photography classes near me",
        "photography classes online",
        "photography course online",
        "photography courses",
        "photography courses coventry",
        "photography courses for beginners",
        "photography courses near me",
        "photography evening classes",
        "photography gift card",
        "photography gift voucher",
        "photography holidays uk",
        "photography lessons",
        "photography lessons near me",
        "photography lessons online",
        "photography masterclasses",
        "photography mentor",
        "photography presents",
        "photography training",
        "photography tuition",
        "photography tutor",
        "photography vouchers",
        "photography workshops",
        "photography workshops near me",
        "photography workshops uk",
        "private photography lessons",
        "private photography tuition",
        "professional commercial photography",
        "professional photographer",
        "professional photographer coventry",
        "professional photographer near me",
        "rps courses",
        "rps distinctions",
        "uk photography workshops"
      ];

      // API endpoints  adjust if the deployed paths differ.
      // window.apiUrl is already defined at the top level, so we can use it here
      // Also create a local const for use within this scope
      const apiUrl = window.apiUrl;
      
      const SERP_RANK_ENDPOINT = apiUrl('/api/aigeo/serp-rank-test');
      const AI_MODE_ENDPOINT = apiUrl('/api/aigeo/ai-mode-serp-batch-test'); // Using batch endpoint

      let hasLoadedOnce = false;
      let isLoading = false;
      let combinedRows = [];
      let summary = null;

      function normaliseKeyword(k) {
        return (k || "").trim().toLowerCase();
      }

      // Intent-based keyword segment classifier (client-side version)
      function classifyKeywordSegment(keyword, bestUrl) {
        if (!keyword || typeof keyword !== 'string') {
          return 'other';
        }
        
        const normalizedKeyword = keyword.trim().toLowerCase();
        
        // Priority 1: Brand (highest priority)
        const brandTerms = ['alan ranger', 'alanranger', 'alan ranger photography', 'photography academy', 'alan ranger academy'];
        if (brandTerms.some(term => normalizedKeyword.includes(term.toLowerCase()))) {
          return 'brand';
        }
        
        // Priority 2: Money (transactional OR local intent)
        const moneyTerms = ['lesson', 'lessons', 'class', 'classes', 'course', 'courses', 'training', 'workshop', 'workshops', 'mentoring', 'mentor', '1-2-1', '1:1', 'private', 'hire', 'service', 'services', 'photographer', 'booking', 'book', 'price', 'cost', 'voucher', 'gift'];
        const localModifiers = ['near me', 'in coventry', 'coventry', 'birmingham', 'warwick', 'leamington', 'solihull', 'rugby'];
        const hasMoneyTerm = moneyTerms.some(term => normalizedKeyword.includes(term.toLowerCase()));
        const hasLocalModifier = localModifiers.some(term => normalizedKeyword.includes(term.toLowerCase()));
        const hasPostcode = /\b([A-Z]{1,2}\d{1,2}\s?\d?[A-Z]{0,2})\b/i.test(normalizedKeyword);
        
        if (hasMoneyTerm || hasLocalModifier || hasPostcode) {
          return 'money';
        }
        
        // Priority 3: Education (informational/learning intent)
        const educationTerms = ['how to', 'what is', 'guide', 'tutorial', 'tips', 'settings', 'meaning', 'vs', 'difference', 'examples', 'best way to'];
        const techniqueTopics = ['aperture', 'shutter speed', 'iso', 'depth of field', 'histogram', 'dynamic range', 'composition'];
        const hasEducationTerm = educationTerms.some(term => normalizedKeyword.includes(term.toLowerCase()));
        const hasTechniqueTopic = techniqueTopics.some(term => normalizedKeyword.includes(term.toLowerCase()));
        
        if (hasEducationTerm || hasTechniqueTopic) {
          return 'education';
        }
        
        // Priority 4: Other (fallback)
        return 'other';
      }
      
      function classifyPageTypeForKeyword(bestUrl) {
        // Use shared classification function
        if (typeof window.classifyUrlForRankingAi === 'function') {
          const classification = window.classifyUrlForRankingAi(bestUrl || '');
          return classification.pageType;
        }
        return "Landing"; // Default fallback
      }

        const module = {
        TRACKED_KEYWORDS,
        SERP_RANK_ENDPOINT,
        AI_MODE_ENDPOINT,
        normaliseKeyword,
        classifyKeywordSegment,
        classifyPageTypeForKeyword,
        state: () => ({ hasLoadedOnce, isLoading, combinedRows, summary }),
        setLoadedOnce: (value) => { hasLoadedOnce = value; },
        setLoading: (value) => { isLoading = value; },
        setData: (rows, sum) => { 
          // Normalize rows: add segment_norm, segment_display, page_type_norm, page_type_display, impressions30d
          // Use window references since functions may be defined later
          const normSeg = window.normalizeSegment || ((input) => {
            const s = (input ?? "").trim().toLowerCase();
            return s.charAt(0).toUpperCase() + s.slice(1);
          });
          const segLabel = window.segmentLabel || ((s) => s);
          const normPageType = window.normalizePageType || ((pt) => {
            const k = (pt ?? "").trim().toLowerCase();
            return k.charAt(0).toUpperCase() + k.slice(1);
          });
          const pageTypeLab = window.pageTypeLabel || ((pt) => {
            const k = normPageType(pt);
            return k.charAt(0).toUpperCase() + k.slice(1);
          });
          // Get impressions30d for each row using getGscMetricsForKeywordRow (which returns impressions)
          const getGscMetrics = window.getGscMetricsForKeywordRow || (() => null);
          combinedRows = rows.map(r => {
            const segNorm = normSeg(r.segment);
            const segDisplay = segLabel(r.segment);
            const ptNorm = normPageType(r.pageType);
            const ptDisplay = pageTypeLab(r.pageType);
            // Get impressions30d from GSC data - use canonical targetUrl
            const pageUrlForGsc = r.targetUrl || r.ranking_url || r.best_url || '';
            const gscMetrics = getGscMetrics({ query: r.keyword, pageUrl: pageUrlForGsc });
            const impressions30d = gscMetrics && gscMetrics.impressions != null ? gscMetrics.impressions : null;
            return {
              ...r,
              segment_norm: segNorm,
              segment_display: segDisplay,
              page_type_norm: ptNorm,
              page_type_display: ptDisplay,
              impressions30d: impressions30d
            };
          });
          summary = sum; 
        }
      };
      console.log('[RankingAiModule] Module object created:', Object.keys(module));
      return module;
    })();
    
    console.log('[RankingAiModule] Assignment complete. window.RankingAiModule exists:', typeof window.RankingAiModule !== 'undefined');
    console.log('[RankingAiModule] window.RankingAiModule:', window.RankingAiModule);
    
    if (typeof window.RankingAiModule !== 'undefined') {
      console.log('[RankingAiModule]  Successfully assigned to window');
      console.log('[RankingAiModule] TRACKED_KEYWORDS:', window.RankingAiModule.TRACKED_KEYWORDS);
    } else {
      console.error('[RankingAiModule]  FAILED to assign to window');
    }
    
    // Debug logging system
    const debugLogEntries = [];
    let debugLogFilter = 'all'; // 'all', 'warnings-errors'
    
    function debugLog(message, type = 'info') {
      const timestamp = new Date().toISOString();
      const entry = {
        timestamp,
        message,
        type
      };
      debugLogEntries.push(entry);
      
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        // Check if entry should be displayed based on filter
        const shouldShow = debugLogFilter === 'all' || (debugLogFilter === 'warnings-errors' && (type === 'warn' || type === 'error'));
        
        if (shouldShow) {
        const entryDiv = document.createElement('div');
        entryDiv.className = `debug-log-entry ${type}`;
        entryDiv.innerHTML = `<span class="debug-timestamp">[${new Date(timestamp).toLocaleTimeString()}]</span>${message}`;
        logElement.appendChild(entryDiv);
        logElement.scrollTop = logElement.scrollHeight;
        }
      }
      
      // Only log critical errors to browser console (for debugging production issues)
      // All other logs go to UI debug console only
      if (type === 'error') {
        console.error(`[DEBUG ERROR]`, message);
      }
    }
    
    function toggleDebugLogFilter() {
      debugLogFilter = debugLogFilter === 'all' ? 'warnings-errors' : 'all';
      const filterBtn = document.getElementById('debugFilterBtn');
      if (filterBtn) {
        filterBtn.textContent = `Filter: ${debugLogFilter === 'all' ? 'All' : 'Warnings/Errors'}`;
      }
      
      // Re-render all log entries with current filter
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        logElement.innerHTML = '';
        debugLogEntries.forEach(entry => {
          const shouldShow = debugLogFilter === 'all' || (debugLogFilter === 'warnings-errors' && (entry.type === 'warn' || entry.type === 'error'));
          if (shouldShow) {
            const entryDiv = document.createElement('div');
            entryDiv.className = `debug-log-entry ${entry.type}`;
            entryDiv.innerHTML = `<span class="debug-timestamp">[${new Date(entry.timestamp).toLocaleTimeString()}]</span>${entry.message}`;
            logElement.appendChild(entryDiv);
          }
        });
        logElement.scrollTop = logElement.scrollHeight;
      }
    }

    function clearDebugLog() {
      debugLogEntries.length = 0;
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        logElement.innerHTML = '';
      }
      debugLog('Debug log cleared', 'info');
    }
    
    // Initialize filter button text on page load
    window.addEventListener('DOMContentLoaded', () => {
      const filterBtn = document.getElementById('debugFilterBtn');
      if (filterBtn) {
        filterBtn.textContent = `Filter: ${debugLogFilter === 'all' ? 'All' : 'Warnings/Errors'}`;
      }
    });

    function copyDebugLog() {
      // Filter entries based on current filter state
      const filteredEntries = debugLogEntries.filter(entry => {
        return debugLogFilter === 'all' || (debugLogFilter === 'warnings-errors' && (entry.type === 'warn' || entry.type === 'error'));
      });
      
      const logText = filteredEntries.map(entry => 
        `[${entry.timestamp}] [${entry.type.toUpperCase()}] ${entry.message}`
      ).join('\n');
      
      navigator.clipboard.writeText(logText).then(() => {
        debugLog(`Debug log copied to clipboard (${filteredEntries.length} ${debugLogFilter === 'all' ? 'entries' : 'warnings/errors'})`, 'success');
        showStatus(`Debug log copied! (${filteredEntries.length} ${debugLogFilter === 'all' ? 'entries' : 'warnings/errors'})`, 'success');
      }).catch(err => {
        debugLog('Failed to copy log: ' + err.message, 'error');
        showStatus('Failed to copy log', 'error');
      });
    }

    function toggleDebugPanel() {
      const panel = document.getElementById('debugPanel');
      const icon = document.getElementById('debugToggleIcon');
      if (panel.classList.contains('collapsed')) {
        panel.classList.remove('collapsed');
        if (icon) icon.textContent = '';
      } else {
        panel.classList.add('collapsed');
        if (icon) icon.textContent = '';
      }
    }

    // Performance optimization: Defer heavy work to improve INP
    function defer(fn) {
      if (window.requestIdleCallback) {
        requestIdleCallback(fn, { timeout: 800 });
      } else {
        setTimeout(fn, 0);
      }
    }

    const panelInitDone = new Set();

    function setActivePanel(panelId) {
      // 1) fast: toggle active nav styles
      document.querySelectorAll('.aigeo-nav-item').forEach(btn => {
        btn.classList.toggle('is-active', btn.dataset.panel === panelId);
        btn.setAttribute('aria-selected', btn.dataset.panel === panelId ? 'true' : 'false');
      });

      // 2) fast: show/hide panels only (NO rendering work here)
      document.querySelectorAll('.aigeo-panel').forEach(p => {
        const isActive = p.dataset.panel === panelId;
        p.classList.toggle('is-active', isActive);
        p.hidden = !isActive; // Explicitly set hidden attribute
      });
    }

    function ensurePanelRendered(panelId) {
      if (panelInitDone.has(panelId)) return;

      // IMPORTANT: only do heavy first-time render here
      // e.g. build big tables, compute summaries, populate dropdowns
      if (panelId === 'ranking') {
        // Fix DOM structure first
        fixRankingPanelStructure();
        // Load data and render ranking panel
        (async () => {
          debugLog(' Ranking panel: Loading data from storage...', 'info');
          const storedData = await loadRankingAiDataFromStorage(false);
          if (storedData && storedData.combinedRows && storedData.summary) {
            const mod = window.RankingAiModule;
            if (mod) {
              const normalizedSummary = normalizeSummaryFields(storedData.summary);
              mod.setData(storedData.combinedRows, normalizedSummary);
              mod.setLoadedOnce(true);
              renderRankingAiTab();
              const lastRunEl = document.getElementById("ranking-ai-last-run");
              if (lastRunEl && storedData.timestamp) {
                const date = new Date(storedData.timestamp);
                // Format in GMT/UTC: "DD MMM YYYY, HH:MM:SS GMT"
                const day = String(date.getUTCDate()).padStart(2, '0');
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const month = monthNames[date.getUTCMonth()];
                const year = date.getUTCFullYear();
                const hours = String(date.getUTCHours()).padStart(2, '0');
                const minutes = String(date.getUTCMinutes()).padStart(2, '0');
                const seconds = String(date.getUTCSeconds()).padStart(2, '0');
                const formatted = `${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
                lastRunEl.textContent = `Last run: ${formatted}`;
              }
            }
          } else {
            const mod = window.RankingAiModule;
            if (mod) {
              mod.setData([], { total_keywords: 0, keywords_with_rank: 0, keywords_with_ai_overview: 0, keywords_with_ai_citations: 0, top10: 0, top3: 0 });
              renderRankingAiTab();
            }
          }
          
          // CRITICAL: After initial render, check if queryTotals are available and re-render if needed
          // This ensures CTR/Impressions columns are populated even if loadAuditResults() completes after initial render
          (async () => {
            try {
              debugLog(` Checking for queryTotals after initial render...`, 'info');
              const savedAudit = await loadAuditResults();
              debugLog(` loadAuditResults() completed - savedAudit=${!!savedAudit}, searchData=${!!savedAudit?.searchData}, queryTotals=${savedAudit?.searchData?.queryTotals?.length || 0}`, savedAudit?.searchData?.queryTotals?.length > 0 ? 'success' : 'warn');
              if (savedAudit && savedAudit.searchData && Array.isArray(savedAudit.searchData.queryTotals) && savedAudit.searchData.queryTotals.length > 0) {
                debugLog(` queryTotals loaded (${savedAudit.searchData.queryTotals.length} keywords), re-rendering table to show CTR/Impressions`, 'success');
                // Re-render the table to show CTR/Impressions data
                if (typeof renderRankingAiTab === 'function') {
                  renderRankingAiTab();
                  debugLog(` Table re-rendered with queryTotals data`, 'success');
                } else {
                  debugLog(` renderRankingAiTab function not found`, 'warn');
                }
              } else {
                debugLog(` No queryTotals found in savedAudit - searchData=${!!savedAudit?.searchData}, queryTotals type=${typeof savedAudit?.searchData?.queryTotals}, length=${savedAudit?.searchData?.queryTotals?.length || 0}`, 'warn');
                if (savedAudit && savedAudit.searchData) {
                  debugLog(` searchData keys: ${Object.keys(savedAudit.searchData).join(', ')}`, 'warn');
                }
              }
            } catch (err) {
              debugLog(` Error loading queryTotals for re-render: ${err.message}`, 'error');
              debugLog(` Error stack: ${err.stack}`, 'error');
            }
          })();
          
          // Wire up filters and sorting after render
          setTimeout(() => {
            // Fix DOM structure after render
            fixRankingPanelStructure();
            if (typeof wireRankingAiButton === 'function') wireRankingAiButton();
            if (typeof wireRankingFilters === 'function') wireRankingFilters();
            if (typeof wireRankingSorting === 'function') wireRankingSorting();
            if (typeof wireRankingPagination === 'function') wireRankingPagination();
          }, 100);
        })();
      } else if (panelId === 'ai-sources') {
        setTimeout(() => {
          if (typeof wireAiSourcesFilters === 'function') wireAiSourcesFilters();
        }, 100);
        (async () => {
          debugLog(' AI Sources & Influence tab clicked - loading data...', 'info');
          const storedData = await loadRankingAiDataFromStorage(false);
          if (storedData && storedData.combinedRows && storedData.combinedRows.length > 0) {
            const mod = window.RankingAiModule;
            if (mod) {
              const normalizedSummary = normalizeSummaryFields(storedData.summary);
              mod.setData(storedData.combinedRows, normalizedSummary);
              debugLog(` AI Sources tab: Rendering with ${storedData.combinedRows.length} keywords`, 'success');
              if (typeof renderAiSourcesTab === 'function') {
                renderAiSourcesTab();
              }
            }
          } else {
            debugLog(' AI Sources tab: No keyword data available. Run a Ranking & AI check first.', 'warn');
            if (typeof renderAiSourcesTab === 'function') {
              renderAiSourcesTab(); // Will show empty state
            }
          }
        })();
      } else if (panelId === 'overview') {
        setTimeout(async () => {
          // Use async loadAuditResults to ensure we get latest data from Supabase (including localSignals with locations)
          const saved = await loadAuditResults();
          if (saved && saved.scores && saved.searchData) {
            const trendCanvas = document.getElementById('trendChart');
            if (trendCanvas && typeof displayDashboard === 'function') {
              debugLog('Re-rendering Score Trends chart for Overview tab', 'info');
              // DEBUG: Log localSignals structure when loading Overview tab
              if (saved.localSignals) {
                debugLog(`[Overview Tab] localSignals structure: status=${saved.localSignals.status}, hasData=${!!saved.localSignals.data}, hasLocations=${!!saved.localSignals.data?.locations}, locationsCount=${saved.localSignals.data?.locations?.length || 0}`, 'info');
              } else {
                debugLog(`[Overview Tab]  localSignals is missing from saved audit data`, 'warn');
              }
              try {
                await displayDashboard(saved.scores, saved.searchData, saved.snippetReadiness || 0, saved.schemaAudit || null, saved.localSignals || null);
              } catch (err) {
                debugLog(`Error re-rendering trend chart: ${err.message}`, 'warn');
              }
            }
          }
        }, 200);
      } else if (panelId === 'money') {
        setTimeout(() => {
          const saved = loadAuditResultsSync();
          
          if (typeof renderMoneyPagesTable === 'function') {
            const priorityData = window.moneyPagePriorityData || (saved && saved.moneyPagePriorityData) || [];
            if (priorityData && priorityData.length > 0) {
              debugLog('Re-rendering Money Pages Priority Matrix table', 'info');
              renderMoneyPagesTable(priorityData);
            }
          }
          
          if (typeof renderMoneyPagesSection === 'function' && saved && saved.scores && saved.scores.moneyPagesMetrics) {
            debugLog('Re-rendering Money Pages section', 'info');
            renderMoneyPagesSection(saved.scores.moneyPagesMetrics);
            
            // Wait for HTML structure to be created before rendering charts
            setTimeout(() => {
              // Opportunity Mix: render after layout settles (Money tab activation can report 0x0)
              if (saved && saved.scores && saved.scores.moneyPagesMetrics && typeof renderMoneyPagesCategoryChart === 'function') {
                requestAnimationFrame(() => {
                  requestAnimationFrame(() => {
                    renderMoneyPagesCategoryChart(saved.scores.moneyPagesMetrics, 0);
                  });
                });
              }
            }, 200); // Give renderMoneyPagesSection time to create HTML structure
          } else if (saved && saved.scores && saved.scores.moneyPagesMetrics && typeof renderMoneyPagesCategoryChart === 'function') {
            // If renderMoneyPagesSection wasn't called, still try to render charts (structure might already exist)
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                renderMoneyPagesCategoryChart(saved.scores.moneyPagesMetrics, 0);
              });
            });
          }
          
          // Render charts only when panel is visible and canvas has dimensions
          // Wait a bit longer to ensure HTML structure is created
          setTimeout(() => {
            const renderMoneyCharts = () => {
            const moneyPanel = document.querySelector('.aigeo-panel[data-panel="money"]');
            const isPanelVisible = moneyPanel && moneyPanel.classList.contains('is-active') && 
                                   window.getComputedStyle(moneyPanel).display !== 'none';
            
            if (!isPanelVisible) {
              debugLog(' Money Pages charts: Panel not visible yet, will retry', 'warn');
              setTimeout(renderMoneyCharts, 200);
              return;
            }
            
            const volumeCanvas = document.getElementById('moneyPagesVolumeChart');
            const rateCanvas = document.getElementById('moneyPagesRateChart');
            if ((volumeCanvas || rateCanvas) && typeof renderMoneyPagesTrendChart === 'function') {
              const volumeRect = volumeCanvas ? volumeCanvas.getBoundingClientRect() : { width: 0, height: 0 };
              const rateRect = rateCanvas ? rateCanvas.getBoundingClientRect() : { width: 0, height: 0 };
              if ((volumeRect.width === 0 || volumeRect.height === 0) && (rateRect.width === 0 || rateRect.height === 0)) {
                debugLog(' Money Pages trend charts: Canvases have zero dimensions, will retry', 'warn');
                setTimeout(renderMoneyCharts, 200);
                return;
              }
              
              const propertyUrl = document.getElementById('propertyUrl')?.value;
              if (propertyUrl) {
                const endDate = new Date();
                const startDate = new Date();
                startDate.setFullYear(startDate.getFullYear() - 1);
                const startDateStr = startDate.toISOString().split('T')[0];
                const endDateStr = endDate.toISOString().split('T')[0];
                
                // Use apiUrl helper so this works both on Vercel and when opened locally (file://)
                const urlHelper = window.apiUrl || ((path) => {
                  const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || !window.location.hostname;
                  const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
                  const cleanPath = path.startsWith('/') ? path : `/${path}`;
                  return `${baseUrl}${cleanPath}`;
                });
                fetch(urlHelper(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDateStr}`))
                  .then(res => res.json())
                  .then(json => {
                    if (json.status === 'ok' && json.data) {
                      // Extract last GSC timeseries date from API response if available
                      if (json.timeseries && Array.isArray(json.timeseries) && json.timeseries.length > 0) {
                        const timeseriesDates = json.timeseries
                          .map(ts => ts.date)
                          .filter(date => date)
                          .sort()
                          .reverse();
                        if (timeseriesDates.length > 0) {
                          window.lastGscTimeseriesDate = timeseriesDates[0];
                          debugLog(`Money Pages Trend: Set last GSC timeseries date from API: ${window.lastGscTimeseriesDate}`, 'info');
                        }
                      } else {
                        debugLog(`Money Pages Trend: No timeseries data in API response`, 'warn');
                      }
                      
                      debugLog(`Money Pages Trend: About to render chart with ${json.data ? json.data.length : 0} history records`, 'info');
                      
                      requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                          const volumeCanvas = document.getElementById('moneyPagesVolumeChart');
                          const rateCanvas = document.getElementById('moneyPagesRateChart');
                          if (volumeCanvas && rateCanvas) {
                            const volumeRect = volumeCanvas.getBoundingClientRect();
                            const rateRect = rateCanvas.getBoundingClientRect();
                            debugLog(`Money Pages Trend: Canvas dimensions - Volume: ${volumeRect.width}x${volumeRect.height}, Rate: ${rateRect.width}x${rateRect.height}`, 'info');
                            if (volumeRect.width > 0 && volumeRect.height > 0 && rateRect.width > 0 && rateRect.height > 0) {
                              debugLog(`Money Pages Trend: Calling renderMoneyPagesTrendChart with ${json.data.length} records`, 'info');
                              renderMoneyPagesTrendChart(json.data);
                            } else {
                              debugLog(' Money Pages trend charts: Canvases still have zero dimensions, retrying...', 'warn');
                              // Set explicit dimensions and retry
                              [volumeCanvas, rateCanvas].forEach(canvas => {
                                canvas.width = canvas.offsetWidth || canvas.parentElement?.clientWidth || 800;
                                canvas.height = canvas.offsetHeight || 300;
                              });
                              setTimeout(() => {
                                const volumeRect2 = volumeCanvas.getBoundingClientRect();
                                const rateRect2 = rateCanvas.getBoundingClientRect();
                                if (volumeRect2.width > 0 && volumeRect2.height > 0 && rateRect2.width > 0 && rateRect2.height > 0) {
                                  renderMoneyPagesTrendChart(json.data);
                                } else {
                                  setTimeout(() => renderMoneyCharts(), 200);
                                }
                              }, 100);
                            }
                          } else {
                            debugLog(' Money Pages trend charts: Canvas elements not found', 'warn');
                          }
                        });
                      });
                    } else {
                      debugLog(` Money Pages trend chart: API returned error or no data. Status: ${json.status}`, 'warn');
                    }
                  })
                  .catch(err => {
                    debugLog(` Error fetching history for trend chart: ${err.message}`, 'error');
                    debugLog(`Money Pages trend chart fetch error details: ${err.stack || err.toString()}`, 'error');
                  });
              }
            }
            
            const sparklineCanvas = document.getElementById('money-kpi-sparkline');
            if (sparklineCanvas && typeof loadAuditHistoryAndRenderKpis === 'function') {
              const rect = sparklineCanvas.getBoundingClientRect();
              if (rect.width === 0 || rect.height === 0) {
                debugLog(' Money KPI sparkline: Canvas has zero dimensions, will retry', 'warn');
                setTimeout(renderMoneyCharts, 200);
                return;
              }
              
              const propertyUrl = document.getElementById('propertyUrl')?.value;
              if (propertyUrl) {
                requestAnimationFrame(() => {
                  requestAnimationFrame(() => {
                    const canvas = document.getElementById('money-kpi-sparkline');
                    if (canvas) {
                      const rect = canvas.getBoundingClientRect();
                      if (rect.width > 0 && rect.height > 0) {
                        loadAuditHistoryAndRenderKpis(propertyUrl);
                      } else {
                        debugLog(' Money KPI sparkline: Canvas still has zero dimensions, retrying...', 'warn');
                        setTimeout(() => renderMoneyCharts(), 200);
                      }
                    }
                  });
                });
              }
            }
            };
            
            // Start rendering charts with retry logic
            renderMoneyCharts();
          }, 300); // Wait 300ms to ensure HTML structure is created
          
          // Wire up KPI metric selector
          if (typeof window.wireMoneyKpiMetricSelector === 'function') {
            window.wireMoneyKpiMetricSelector();
          }
          
          if (typeof window.wireTopLevelFilter === 'function') {
            window.wireTopLevelFilter();
          }
          if (typeof window.wirePriorityActionsFilters === 'function') {
            window.wirePriorityActionsFilters();
          }
        }, 100);
      }

      // Mark panel as initialized
      panelInitDone.add(panelId);
    }

    // Fix ranking panel DOM structure - ensure sections are siblings, not nested
    function fixRankingPanelStructure() {
      const rankingPanel = document.querySelector('.aigeo-panel[data-panel="ranking"]');
      if (!rankingPanel) return;

      const sideBySide = rankingPanel.querySelector('.ranking-cards-side-by-side');
      const priority = rankingPanel.querySelector('#ranking-priority-matrix-section');
      const table = rankingPanel.querySelector('.ranking-table-section');
      const details = rankingPanel.querySelector('.ranking-details-grid');

      if (!sideBySide) return;

      // Check if sections are incorrectly nested inside side-by-side container
      const sideBySideChildren = Array.from(sideBySide.children);
      const needsFix = sideBySideChildren.includes(priority) || 
                       sideBySideChildren.includes(table) || 
                       sideBySideChildren.includes(details);

      if (needsFix) {
        // Move sections out of side-by-side container to be siblings
        if (priority && sideBySide.contains(priority)) {
          sideBySide.parentElement.insertBefore(priority, sideBySide.nextSibling);
        }
        if (table && sideBySide.contains(table)) {
          sideBySide.parentElement.insertBefore(table, priority?.nextSibling || sideBySide.nextSibling);
        }
        if (details && sideBySide.contains(details)) {
          sideBySide.parentElement.insertBefore(details, table?.nextSibling || priority?.nextSibling || sideBySide.nextSibling);
        }
      }

      // Ensure correct order: side-by-side, priority, table, details
      const allSections = [sideBySide, priority, table, details].filter(Boolean);
      allSections.forEach((section, index) => {
        if (section.parentElement === rankingPanel) {
          const currentIndex = Array.from(rankingPanel.children).indexOf(section);
          const expectedIndex = Array.from(rankingPanel.children).indexOf(allSections[0]) + index;
          if (currentIndex !== expectedIndex && expectedIndex >= 0) {
            rankingPanel.insertBefore(section, rankingPanel.children[expectedIndex] || null);
          }
        }
      });
    }

    function toggleCalculationExplanation() {
      const explanation = document.getElementById('calculationExplanation');
      const content = document.getElementById('calculationContent');
      const toggle = document.getElementById('calculationToggle');
      if (explanation.classList.contains('collapsed')) {
        explanation.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '';
      } else {
        explanation.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '';
      }
    }

    function toggleFrameworkExplanation() {
      const explanation = document.getElementById('frameworkExplanation');
      const content = document.getElementById('frameworkContent');
      const toggle = document.getElementById('frameworkToggle');
      if (!explanation || !content) return;
      if (explanation.classList.contains('collapsed')) {
        explanation.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '';
      } else {
        explanation.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '';
      }
    }
    
    window.toggleCsvSection = function(sectionId) {
      const section = document.getElementById(sectionId);
      const contentId = sectionId === 'urlListSection' ? 'urlListContent' : 'backlinkCsvContentWrapper';
      const toggleId = sectionId === 'urlListSection' ? 'urlListToggle' : 'backlinkCsvToggle';
      const content = document.getElementById(contentId);
      const toggle = document.getElementById(toggleId);
      
      if (section.classList.contains('collapsed')) {
        section.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '';
      } else {
        section.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '';
      }
    }

    // Debug panel is always visible at bottom, start collapsed by default
    window.addEventListener('DOMContentLoaded', () => {
      const debugPanel = document.getElementById('debugPanel');
      const debugToggleIcon = document.getElementById('debugToggleIcon');
      if (debugPanel) {
        debugPanel.style.display = 'flex';
        // Start collapsed by default
        debugPanel.classList.add('collapsed');
        if (debugToggleIcon) {
          debugToggleIcon.textContent = '';
        }
      }
    });

    // Initialize Money Pages Priority Matrix global state early
    window.moneyPagePriorityData = window.moneyPagePriorityData || [];
    window.moneySegmentMetrics = window.moneySegmentMetrics || null;
    window.moneyMatrixFilterState = window.moneyMatrixFilterState || { impact: null, diff: null };
    
    // Verify RankingAiModule is available
    if (typeof window.RankingAiModule === 'undefined') {
      debugLog(' RankingAiModule not found in window on page load', 'warn');
    } else {
      debugLog(' RankingAiModule verified on page load', 'success');
    }

    // Fix ranking panel structure on page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(fixRankingPanelStructure, 100);
      });
    } else {
      setTimeout(fixRankingPanelStructure, 100);
    }

    // Load saved configuration
    async function loadConfig() {
      debugLog('=== PAGE LOAD: Starting configuration load ===', 'info');
      
      // Check if Chart.js is loaded
      debugLog('Checking Chart.js library...', 'info');
      if (typeof Chart !== 'undefined') {
        debugLog(' Chart.js library loaded successfully', 'success');
      } else {
        debugLog(' Chart.js library NOT loaded', 'error');
      }
      
      // Try to fetch API key from Vercel environment variable (via API endpoint)
      let vercelApiKey = null;
      try {
        debugLog('Checking Vercel environment variable...', 'info');
        const response = await fetch(apiUrl('/api/get-api-key'));
        if (response.ok) {
          const data = await response.json();
          if (data.apiKey) {
            vercelApiKey = data.apiKey;
            debugLog(' API key loaded from Vercel environment variable', 'success');
          }
        }
      } catch (e) {
        debugLog('Vercel env var endpoint not available (expected for static site)', 'info');
      }
      
      // Check config.js
      debugLog('Checking for config.js...', 'info');
      if (window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey) {
        debugLog(' config.js found with API key', 'success');
      } else {
        debugLog(' config.js not found or no API key', 'warn');
      }
      
      // Check localStorage
      debugLog('Checking localStorage...', 'info');
      const configApiKey = window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey;
      const apiKey = vercelApiKey || configApiKey || localStorage.getItem('gsc_api_key');
      const propertyUrl = localStorage.getItem('gsc_property_url');
      const dateRange = localStorage.getItem('gsc_date_range');
      
      const apiKeySource = vercelApiKey ? 'Vercel env var' : configApiKey ? 'config.js' : localStorage.getItem('gsc_api_key') ? 'localStorage' : 'none';
      debugLog(`API Key source: ${apiKeySource}`, 'info');
      debugLog(`Property URL: ${propertyUrl || 'not set'}`, 'info');
      debugLog(`Date Range: ${dateRange || 'not set'}`, 'info');
      
      if (apiKey) {
        debugLog(' API key loaded from environment', 'success');
        // Store in a hidden variable for use in runAudit
        window._loadedApiKey = apiKey;
      } else {
        debugLog(' No API key found', 'warn');
      }
      
      if (propertyUrl) {
        document.getElementById('propertyUrl').value = propertyUrl;
        debugLog(' Property URL loaded', 'success');
      }
      if (dateRange) {
        document.getElementById('dateRange').value = dateRange;
        // Set active button based on saved date range
        const savedDays = parseInt(dateRange);
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          btn.classList.remove('active');
          const btnDays = parseInt(btn.getAttribute('data-days'));
          if (btnDays === savedDays) {
            btn.classList.add('active');
          }
        });
        // If no preset matches, show custom
        const presetDays = [7, 30, 90, 180, 365];
        if (!presetDays.includes(savedDays)) {
          document.getElementById('customDateBtn').classList.add('active');
          document.getElementById('customDays').value = savedDays;
          document.getElementById('customDateRange').style.display = 'block';
        }
        debugLog(' Date range loaded', 'success');
      }
      
      // Load manual URL list if saved
      const savedUrlList = localStorage.getItem('manual_url_list');
      if (savedUrlList) {
        try {
          const urls = JSON.parse(savedUrlList);
          const statusDiv = document.getElementById('urlListStatus');
          if (statusDiv) {
            statusDiv.innerHTML = `<span style="color: #10b981;"> ${urls.length} URLs loaded from saved list</span>`;
          }
          debugLog(` Manual URL list loaded: ${urls.length} URLs`, 'success');
        } catch (e) {
          debugLog(' Failed to load saved URL list', 'warn');
        }
      }
      
      // Load backlink CSV content if saved
      const savedBacklinkCsv = localStorage.getItem('backlink_csv_content');
      if (savedBacklinkCsv) {
        const textarea = document.getElementById('backlinkCsvContent');
        if (textarea) {
          textarea.value = savedBacklinkCsv;
        }
        // Check if backlink metrics are already uploaded
        try {
          const backlinkResponse = await fetch(apiUrl('/api/aigeo/backlink-metrics'));
          if (backlinkResponse.ok) {
            const backlinkData = await backlinkResponse.json();
            if (backlinkData.status === 'ok' && backlinkData.data && backlinkData.data.totalBacklinks > 0) {
              const metrics = backlinkData.data;
              const statusDiv = document.getElementById('backlinkCsvStatus');
              if (statusDiv) {
                statusDiv.innerHTML = `<span style="color: #10b981;"> Backlink CSV loaded: ${metrics.referringDomains} domains, ${metrics.totalBacklinks} links</span>`;
              }
              debugLog(` Backlink CSV already uploaded: ${metrics.referringDomains} domains`, 'success');
            }
          }
        } catch (e) {
          // Ignore errors - backlink metrics may not be uploaded yet
        }
      }
      
      debugLog('=== Configuration load complete ===', 'info');
    }

    // Save configuration
    // Date range selector functions
    function setDateRange(days) {
      const oldDateRange = parseInt(document.getElementById('dateRange').value) || 30;
      document.getElementById('dateRange').value = days;
      localStorage.setItem('gsc_date_range', days);
      
      // Update active button
      document.querySelectorAll('.date-range-btn').forEach(btn => {
        btn.classList.remove('active');
        const btnDays = parseInt(btn.getAttribute('data-days'));
        if (btnDays === days) {
          btn.classList.add('active');
        }
      });
      
      // Hide custom input if showing
      document.getElementById('customDateRange').style.display = 'none';
      document.getElementById('customDateBtn').classList.remove('active');
      
      debugLog(`Date range set to ${days} days`, 'info');
      
      // Check if saved audit exists and if its date range matches
      const savedAudit = loadAuditResultsSync();
      if (savedAudit && savedAudit.scores) {
        const savedDateRange = savedAudit.dateRange || oldDateRange;
        // Always update if date range changed (even if going back to a previous range)
        // This ensures charts refresh properly when switching between ranges
        if (savedDateRange !== days) {
          // Date range changed - update GSC data and recalculate scores
          debugLog(`Date range changed from ${savedDateRange} to ${days} days. Updating metrics...`, 'info');
          updateAuditForNewDateRange(days, savedAudit);
        } else {
          // Date range matches, but force refresh to ensure charts are updated
          // This handles the case where user switches back to the same range
          debugLog(`Date range is already ${days} days, but refreshing charts to ensure they're up to date...`, 'info');
          // Force a refresh by calling displayDashboard with current data
          if (savedAudit.scores && savedAudit.searchData) {
            displayDashboard(savedAudit.scores, savedAudit.searchData, savedAudit.snippetReadiness, savedAudit.schemaAudit, savedAudit.localSignals);
          }
        }
      }
    }

    function showCustomDateRange() {
      const customDiv = document.getElementById('customDateRange');
      const customBtn = document.getElementById('customDateBtn');
      
      if (customDiv.style.display === 'none') {
        customDiv.style.display = 'block';
        customBtn.classList.add('active');
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          if (btn !== customBtn) btn.classList.remove('active');
        });
      } else {
        customDiv.style.display = 'none';
        customBtn.classList.remove('active');
      }
    }

    function applyCustomDateRange() {
      const customDays = parseInt(document.getElementById('customDays').value);
      if (customDays && customDays > 0) {
        const oldDateRange = parseInt(document.getElementById('dateRange').value) || 30;
        document.getElementById('dateRange').value = customDays;
        localStorage.setItem('gsc_date_range', customDays);
        document.getElementById('customDateRange').style.display = 'none';
        document.getElementById('customDateBtn').classList.remove('active');
        debugLog(`Custom date range set to ${customDays} days`, 'info');
        
        // Check if saved audit exists and if its date range matches
        const savedAudit = loadAuditResultsSync();
        if (savedAudit && savedAudit.scores) {
          const savedDateRange = savedAudit.dateRange || oldDateRange;
          if (savedDateRange !== customDays) {
            // Date range changed - update GSC data and recalculate scores
            debugLog(`Date range changed from ${savedDateRange} to ${customDays} days. Updating metrics...`, 'info');
            updateAuditForNewDateRange(customDays, savedAudit);
          }
        }
      } else {
        showStatus('Please enter a valid number of days', 'error');
      }
    }

    function saveConfig() {
      localStorage.setItem('gsc_api_key', document.getElementById('apiKey').value);
      localStorage.setItem('gsc_property_url', document.getElementById('propertyUrl').value);
      localStorage.setItem('gsc_date_range', document.getElementById('dateRange').value);
      showStatus('Configuration saved!', 'success');
    }

    window.shareAudit = async function shareAudit() {
      // Check if admin key is set
      const adminKey = window.getAdminKey();
      if (!adminKey) {
        alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
        return;
      }

      try {
        // Call share create endpoint
        const response = await fetch(apiUrl('/api/share/create'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-arp-admin-key': adminKey
          },
          body: JSON.stringify({
            expiryDays: 30 // Default to 30 days
          })
        });

        if (!response.ok) {
          let errorMessage = `HTTP ${response.status}`;
          try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorMessage;
          } catch (e) {
            // If JSON parsing fails, try to get text
            try {
              const text = await response.text();
              errorMessage = text || errorMessage;
            } catch (e2) {
              // If that fails too, use status
              errorMessage = `HTTP ${response.status}: ${response.statusText || 'Unknown error'}`;
            }
          }
          throw new Error(errorMessage);
        }

        const data = await response.json();
        const shareUrl = data.shareUrl;
        const expiresAt = data.expiresAt ? new Date(data.expiresAt).toLocaleDateString('en-GB') : 'Unknown';

        // Show share URL in a prompt for easy copying
        const message = `Share URL created!\n\nExpires: ${expiresAt}\n\nShare URL:\n${shareUrl}\n\nClick OK to copy to clipboard.`;
        if (confirm(message)) {
          // Copy to clipboard
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(shareUrl);
            showStatus('Share URL copied to clipboard!', 'success');
          } else {
            // Fallback: select text
            const textarea = document.createElement('textarea');
            textarea.value = shareUrl;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
              document.execCommand('copy');
              showStatus('Share URL copied to clipboard!', 'success');
            } catch (e) {
              showStatus('Share URL created. Please copy it manually.', 'info');
            }
            document.body.removeChild(textarea);
          }
        }
      } catch (error) {
        console.error('[Share Audit] Error:', error);
        alert(`Failed to create share URL: ${error.message}`);
      }
    }

    // Parse CSV and validate column names
    function parseUrlListCsv(csvText) {
      const lines = csvText.split('\n').filter(line => line.trim());
      if (lines.length === 0) {
        throw new Error('CSV is empty');
      }
      
      // Parse header row
      const headerLine = lines[0].trim();
      const headers = headerLine.split(',').map(h => h.trim().replace(/^"|"$/g, '').toLowerCase());
      
      // Check for required 'url' column
      const urlColumnIndex = headers.findIndex(h => h === 'url');
      if (urlColumnIndex === -1) {
        throw new Error(`Required column 'url' not found. Found columns: ${headers.join(', ')}`);
      }
      
      // Extract URLs from the 'url' column
      const urls = [];
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        // Parse CSV line (handle quoted values)
        const columns = [];
        let current = '';
        let inQuotes = false;
        
        for (let j = 0; j < line.length; j++) {
          const char = line[j];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            columns.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        columns.push(current.trim()); // Add last column
        
        // Extract URL from the url column
        if (columns[urlColumnIndex]) {
          const url = columns[urlColumnIndex].replace(/^"|"$/g, '').trim();
          if (url && url.startsWith('http')) {
            urls.push(url);
          }
        }
      }
      
      return {
        headers,
        urls,
        totalRows: lines.length - 1,
        validUrls: urls.length
      };
    }

    // Load URL list from file input
    async function loadUrlListFromFile() {
      const fileInput = document.getElementById('urlListFile');
      const statusDiv = document.getElementById('urlListStatus');
      const textarea = document.getElementById('manualUrlList');
      
      if (!fileInput.files || fileInput.files.length === 0) {
        // If no file, try to parse from textarea
        const csvText = textarea.value.trim();
        if (!csvText) {
          statusDiv.innerHTML = '<span style="color: #ef4444;"> Please select a CSV file or paste CSV content</span>';
          return;
        }
        
        try {
          const result = parseUrlListCsv(csvText);
          localStorage.setItem('manual_url_list', JSON.stringify(result.urls));
          statusDiv.innerHTML = `<span style="color: #10b981;"> Loaded ${result.validUrls} URLs from ${result.totalRows} rows</span>`;
          debugLog(` Manual URL list loaded: ${result.validUrls} URLs from CSV`, 'success');
          showStatus(`URL list loaded! Found ${result.validUrls} URLs.`, 'success');
        } catch (error) {
          statusDiv.innerHTML = `<span style="color: #ef4444;"> ${error.message}</span>`;
          debugLog(` URL list parse error: ${error.message}`, 'error');
          showStatus(`URL list error: ${error.message}`, 'error');
        }
        return;
      }
      
      const file = fileInput.files[0];
      debugLog(`Loading URL list from file: ${file.name} (${file.size} bytes)`, 'info');
      
      try {
        const fileText = await file.text();
        const result = parseUrlListCsv(fileText);
        
        // Store URLs in localStorage
        localStorage.setItem('manual_url_list', JSON.stringify(result.urls));
        
        // Also populate textarea with the CSV content
        textarea.value = fileText;
        
        statusDiv.innerHTML = `<span style="color: #10b981;"> Loaded ${result.validUrls} URLs from ${result.totalRows} rows. Columns: ${result.headers.join(', ')}</span>`;
        debugLog(` URL list loaded from file: ${result.validUrls} URLs`, 'success');
        debugLog(`  File: ${file.name}, Columns: ${result.headers.join(', ')}`, 'info');
        showStatus(`URL list loaded! Found ${result.validUrls} URLs from ${file.name}.`, 'success');
        
        // Clear file input
        fileInput.value = '';
      } catch (error) {
        statusDiv.innerHTML = `<span style="color: #ef4444;"> ${error.message}</span>`;
        debugLog(` URL list file error: ${error.message}`, 'error');
        showStatus(`URL list error: ${error.message}`, 'error');
      }
    }

    // Clear manual URL list
    function clearManualUrlList() {
      const textarea = document.getElementById('manualUrlList');
      const fileInput = document.getElementById('urlListFile');
      const statusDiv = document.getElementById('urlListStatus');
      
      textarea.value = '';
      fileInput.value = '';
      localStorage.removeItem('manual_url_list');
      statusDiv.innerHTML = '<span style="color: #666;">Manual URL list cleared</span>';
      debugLog('Manual URL list cleared', 'info');
      showStatus('Manual URL list cleared', 'success');
    }

    // Load backlink CSV from file (wrapper for uploadBacklinkCsv)
    async function loadBacklinkCsvFromFile() {
      return await uploadBacklinkCsv();
    }

    // Upload backlink CSV file
    async function uploadBacklinkCsv() {
      const fileInput = document.getElementById('backlinkCsvFile');
      const statusDiv = document.getElementById('backlinkCsvStatus');
      const textarea = document.getElementById('backlinkCsvContent');
      
      let csvContent = '';
      
      if (fileInput.files && fileInput.files.length > 0) {
        const file = fileInput.files[0];
        debugLog(`Uploading backlink CSV from file: ${file.name} (${file.size} bytes)`, 'info');
        
        try {
          csvContent = await file.text();
          // Also populate textarea with the CSV content
          textarea.value = csvContent;
        } catch (error) {
          statusDiv.innerHTML = `<span style="color: #ef4444;"> Error reading file: ${error.message}</span>`;
          debugLog(` Backlink CSV file read error: ${error.message}`, 'error');
          showStatus(`Backlink CSV error: ${error.message}`, 'error');
          return;
        }
      } else {
        // If no file, try to get from textarea
        csvContent = textarea.value.trim();
        if (!csvContent) {
          statusDiv.innerHTML = '<span style="color: #ef4444;"> Please select a CSV file or paste CSV content</span>';
          return;
        }
      }

      if (!csvContent) {
        statusDiv.innerHTML = '<span style="color: #ef4444;"> No CSV content to upload</span>';
        return;
      }

      // Validate CSV has required columns
      const lines = csvContent.split('\n').filter(line => line.trim());
      if (lines.length === 0) {
        statusDiv.innerHTML = '<span style="color: #ef4444;"> CSV is empty</span>';
        return;
      }

      const headerLine = lines[0].trim();
      const headers = headerLine.split(',').map(h => h.trim().replace(/^"|"$/g, ''));
      
      // More flexible column matching - check for URL column (required) and Link Type (optional)
      const hasUrlColumn = headers.some(h => {
        const lower = h.toLowerCase();
        return (lower.includes('linking') && lower.includes('url')) ||
               lower.includes('url') ||
               lower.includes('source url') ||
               lower.includes('page url');
      });
      
      const hasLinkType = headers.some(h => {
        const lower = h.toLowerCase();
        return lower.includes('link type') ||
               lower.includes('type') ||
               lower.includes('follow');
      });
      
      if (!hasUrlColumn) {
        statusDiv.innerHTML = `<span style="color: #ef4444;"> Missing URL column. Found columns: ${headers.join(', ')}. Need a column containing 'URL' or 'Linking Page + URL'</span>`;
        debugLog(` Backlink CSV missing URL column. Found: ${headers.join(', ')}`, 'error');
        return;
      }
      
      if (!hasLinkType) {
        statusDiv.innerHTML = `<span style="color: #ef4444;"> Missing Link Type column. Found columns: ${headers.join(', ')}. The Link Type column is required to calculate the follow ratio for the Authority score.</span>`;
        debugLog(` Backlink CSV missing Link Type column. Found: ${headers.join(', ')}`, 'error');
        return;
      }

      // Upload to API
      try {
        statusDiv.innerHTML = '<span style="color: #666;"> Uploading and processing backlink CSV...</span>';
        debugLog('Uploading backlink CSV to API...', 'info');
        
        // Send CSV as JSON since Vercel doesn't parse text/csv automatically
        const response = await fetch(apiUrl('/api/aigeo/backlink-metrics'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ csv: csvContent })
        });

        if (!response.ok) {
          let errorMessage = `HTTP ${response.status}`;
          try {
            const errorData = await response.json();
            errorMessage = errorData.message || errorData.error || errorMessage;
            debugLog(`API error response: ${JSON.stringify(errorData)}`, 'error');
          } catch (e) {
            // If response is not JSON, try to get text
            try {
              const errorText = await response.text();
              if (errorText) {
                errorMessage = errorText.substring(0, 200);
              }
            } catch (e2) {
              // Ignore
            }
          }
          throw new Error(errorMessage);
        }

        const result = await response.json();
        debugLog(`API response: ${JSON.stringify(result).substring(0, 200)}...`, 'info');
        
        if (result.status === 'ok' && result.data) {
          const metrics = result.data;
          statusDiv.innerHTML = `<span style="color: #10b981;"> Backlink CSV uploaded successfully! Found ${metrics.referringDomains} referring domains, ${metrics.totalBacklinks} backlinks, ${Math.round(metrics.followRatio * 100)}% follow ratio</span>`;
          debugLog(` Backlink CSV uploaded: ${metrics.referringDomains} domains, ${metrics.totalBacklinks} links, ${(metrics.followRatio * 100).toFixed(1)}% follow`, 'success');
          showStatus(`Backlink CSV uploaded! ${metrics.referringDomains} referring domains found.`, 'success');
          
          // Store in localStorage for persistence
          localStorage.setItem('backlink_csv_content', csvContent);
          localStorage.setItem('backlink_metrics', JSON.stringify(metrics));
          debugLog(` Backlink metrics stored in localStorage`, 'success');
        } else {
          // Error response - log debug info to UI
          const errorMsg = result.message || result.error || 'Upload failed - invalid response format';
          statusDiv.innerHTML = `<span style="color: #ef4444;"> ${errorMsg}</span>`;
          debugLog(` Backlink CSV upload error: ${errorMsg}`, 'error');
          
          // Log debug info if available
          if (result.debug) {
            debugLog(`[DEBUG] CSV Length: ${result.debug.csvLength || 'N/A'}`, 'info');
            debugLog(`[DEBUG] Logical Lines: ${result.debug.logicalLines || 'N/A'}`, 'info');
            debugLog(`[DEBUG] Headers Found: ${result.debug.headers ? result.debug.headers.join(', ') : 'N/A'}`, 'info');
            if (result.debug.firstChars) {
              debugLog(`[DEBUG] First 500 chars: ${result.debug.firstChars}`, 'info');
            }
            if (result.debug.rowCount !== undefined) {
              debugLog(`[DEBUG] Rows parsed: ${result.debug.rowCount}`, 'info');
            }
            if (result.debug.firstRowKeys) {
              debugLog(`[DEBUG] First row keys: ${result.debug.firstRowKeys.join(', ')}`, 'info');
            }
            if (result.debug.error) {
              debugLog(`[DEBUG] Error details: ${result.debug.error}`, 'error');
            }
          }
          
          // Also log full error response for debugging
          debugLog(`[DEBUG] Full error response: ${JSON.stringify(result, null, 2)}`, 'error');
          showStatus(`Backlink CSV error: ${errorMsg}`, 'error');
        }
      } catch (error) {
        const errorMsg = error.message || error.toString() || 'Unknown error';
        statusDiv.innerHTML = `<span style="color: #ef4444;"> ${errorMsg}</span>`;
        debugLog(` Backlink CSV upload error: ${errorMsg}`, 'error');
        debugLog(`Error stack: ${error.stack || 'No stack trace'}`, 'error');
        showStatus(`Backlink CSV error: ${errorMsg}`, 'error');
      }
    }

    // Clear backlink CSV
    function clearBacklinkCsv() {
      const textarea = document.getElementById('backlinkCsvContent');
      const fileInput = document.getElementById('backlinkCsvFile');
      const statusDiv = document.getElementById('backlinkCsvStatus');
      
      textarea.value = '';
      fileInput.value = '';
      localStorage.removeItem('backlink_csv_content');
      statusDiv.innerHTML = '<span style="color: #666;">Backlink CSV cleared</span>';
      debugLog('Backlink CSV cleared', 'info');
      showStatus('Backlink CSV cleared', 'success');
    }

    // Sync CSV from alan-shared-resources
    async function syncCSV() {
      const btn = document.getElementById('syncCsvBtn');
      const btnText = document.getElementById('syncCsvBtnText');
      const originalText = btnText.textContent;
      
      debugLog('=== CSV SYNC: Starting CSV sync verification ===', 'info');
      debugLog('Button clicked - initiating CSV sync check...', 'info');
      
      // Disable button and show loading state
      btn.disabled = true;
      btnText.textContent = ' Syncing...';
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      debugLog('Button state: disabled, showing loading indicator', 'info');
      
      try {
        debugLog('Fetching /api/sync-csv endpoint...', 'info');
        const response = await fetch(apiUrl('/api/sync-csv'), {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
        });
        
        debugLog(`API response status: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
        
        const data = await response.json();
        debugLog(`API response data: ${JSON.stringify(data).substring(0, 200)}...`, 'info');
        
        if (response.ok && data.status === 'ok') {
          const urlCount = data.data.totalUrls || 0;
          const source = data.source || 'unknown';
          
          debugLog(` CSV fetched successfully from ${source}`, 'success');
          debugLog(`  CSV URL: ${data.csvUrl || 'not provided'}`, 'info');
          debugLog(`  Total URLs fetched: ${urlCount}`, 'success');
          debugLog(`  CSV size: ${data.data.csvSize} bytes`, 'info');
          debugLog(`  Lines processed: ${data.data.linesProcessed || 'N/A'}`, 'info');
          debugLog(`  Fetched at: ${data.data.fetchedAt}`, 'info');
          
          // Show toast with URL count
          showStatus(` CSV synced from ${source}! Fetched ${urlCount} URLs.`, 'success');
          btnText.textContent = ` ${urlCount} URLs`;
          
          // Reset button after 3 seconds
          setTimeout(() => {
            btnText.textContent = originalText;
            btn.style.opacity = '1';
            debugLog('Button reset to original state', 'info');
          }, 3000);
        } else {
          debugLog(` CSV sync failed`, 'error');
          debugLog(`  Error message: ${data.message || 'Unknown error'}`, 'error');
          debugLog(`  CSV URL attempted: ${data.csvUrl || 'not provided'}`, 'error');
          if (data.suggestion) {
            debugLog(`  Suggestion: ${data.suggestion}`, 'warn');
          }
          showStatus(`CSV sync failed: ${data.message}. ${data.suggestion || ''}`, 'error');
          btnText.textContent = ' Sync Failed';
          
          // Reset button after 5 seconds
          setTimeout(() => {
            btnText.textContent = originalText;
            btn.style.opacity = '1';
            debugLog('Button reset to original state after error', 'info');
          }, 5000);
        }
      } catch (error) {
        debugLog(` CSV sync error occurred`, 'error');
        debugLog(`  Error type: ${error.name || 'Unknown'}`, 'error');
        debugLog(`  Error message: ${error.message}`, 'error');
        if (error.stack) {
          debugLog(`  Stack trace: ${error.stack.substring(0, 300)}...`, 'error');
        }
        showStatus(`CSV sync error: ${error.message}. Please run "npm run sync:csv" locally.`, 'error');
        btnText.textContent = ' Error';
        
        // Reset button after 5 seconds
        setTimeout(() => {
          btnText.textContent = originalText;
          btn.style.opacity = '1';
          debugLog('Button reset to original state after exception', 'info');
        }, 5000);
      } finally {
        btn.disabled = false;
        btn.style.cursor = 'pointer';
        debugLog('=== CSV SYNC: Complete ===', 'info');
      }
    }

    // Update progress bar
    function updateProgress(percent, statusText) {
      const progressBar = document.getElementById('progressBar');
      const progressStatus = document.getElementById('progressStatus');
      if (progressBar) {
        progressBar.style.width = Math.min(100, Math.max(0, percent)) + '%';
        progressBar.textContent = Math.round(percent) + '%';
      }
      if (progressStatus) {
        progressStatus.textContent = statusText || 'Processing...';
      }
    }

    // Show status message
    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = `status ${type} show`;
      setTimeout(() => {
        status.classList.remove('show');
      }, 5000);
    }

    // Show completion summary modal
    function showCompletionModal(schemaAudit) {
      debugLog('showCompletionModal called', 'info');
      const modal = document.getElementById('completionModal');
      const content = document.getElementById('completionSummaryContent');
      
      debugLog(`Modal element found: ${modal ? 'yes' : 'no'}`, 'info');
      debugLog(`Content element found: ${content ? 'yes' : 'no'}`, 'info');
      
      if (!modal || !content) {
        debugLog(' Modal or content element not found, cannot show modal', 'error');
        return;
      }
      
      let html = '';
      
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const data = schemaAudit.data;
        const meta = schemaAudit.meta || {};
        const diag = meta.diagnostic || {};
        
        const totalPages = data.totalPages || diag.totalPages || 0;
        const successfulPages = diag.successfulPages || (totalPages - (data.missingSchemaCount || 0));
        const failedPages = diag.failedPages || data.missingSchemaCount || 0;
        const isComplete = failedPages === 0;
        
        html += `<div style="margin-bottom: 1.5rem;">`;
        html += `<div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">`;
        html += `<span style="font-size: 2rem;">${isComplete ? '' : ''}</span>`;
        html += `<h3 style="margin: 0; color: ${isComplete ? '#10b981' : '#f59e0b'};">
          ${isComplete ? 'Complete' : 'Incomplete'} Data
        </h3>`;
        html += `</div>`;
        
        html += `<div style="background: ${isComplete ? '#f0fdf4' : '#fffbeb'}; border-left: 4px solid ${isComplete ? '#10b981' : '#f59e0b'}; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">`;
        html += `<p style="margin: 0; color: #555; line-height: 1.6;">`;
        if (isComplete) {
          html += `All pages were successfully crawled. Dashboard data is complete and accurate.`;
        } else {
          html += `<strong>Warning:</strong> ${failedPages} page${failedPages !== 1 ? 's' : ''} failed to crawl. Dashboard data may be incomplete. Failed pages are counted as missing schema.`;
        }
        html += `</p>`;
        html += `</div>`;
        
        html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">`;
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Total URLs Scanned</div>`;
        html += `<div style="font-size: 1.5rem; font-weight: 600; color: #333;">${totalPages}</div>`;
        html += `</div>`;
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Successful Crawls</div>`;
        html += `<div style="font-size: 1.5rem; font-weight: 600; color: #10b981;">${successfulPages}</div>`;
        html += `</div>`;
        html += `</div>`;
        
        if (failedPages > 0) {
          // Get failed URLs from missingSchemaPages that have errors
          const failedUrls = (data.missingSchemaPages || []).filter(p => p.error).map(p => p.url);
          
          html += `<div style="background: #fef2f2; border-left: 4px solid #ef4444; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">`;
          html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Failed Crawls</div>`;
          html += `<div style="font-size: 1.5rem; font-weight: 600; color: #ef4444;">${failedPages}</div>`;
          
          if (diag.errorTypes && Object.keys(diag.errorTypes).length > 0) {
            html += `<div style="margin-top: 0.75rem; font-size: 0.85rem; color: #666;">`;
            html += `<strong>Error Breakdown:</strong><br>`;
            Object.entries(diag.errorTypes).forEach(([type, count]) => {
              html += `${type}: ${count}<br>`;
            });
            html += `</div>`;
          }
          
          // Add retry button if there are failed URLs
          if (failedUrls.length > 0) {
            html += `<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #fee2e2;">`;
            html += `<button id="retryFailedUrls" class="btn" style="background: #10b981; color: white; border-color: #10b981; width: 100%;" title="Retry crawling the ${failedUrls.length} failed URLs. This will rescan only the URLs that failed during the initial audit.">`;
            html += ` Retry Failed URLs (${failedUrls.length})`;
            html += `</button>`;
            html += `<div style="font-size: 0.8rem; color: #666; margin-top: 0.5rem; text-align: center;">Click to rescan only the failed URLs</div>`;
            html += `</div>`;
          }
          
          html += `</div>`;
        }
        
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px; margin-top: 1rem;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;"><strong>Schema Coverage</strong></div>`;
        // Ensure coverage is a number, not an object
        const coverageValue = typeof data.coverage === 'number' && !isNaN(data.coverage) 
          ? data.coverage 
          : (() => {
              // Calculate from pagesWithSchema and totalPages if coverage is not a number
              const pagesWithSchemaCount = Array.isArray(data.pagesWithSchema) 
                ? data.pagesWithSchema.length 
                : (typeof data.pagesWithSchema === 'number' ? data.pagesWithSchema : 0);
              const totalPagesCount = typeof data.totalPages === 'number' ? data.totalPages : totalPages;
              return totalPagesCount > 0 ? ((pagesWithSchemaCount / totalPagesCount) * 100) : 0;
            })();
        html += `<div style="font-size: 1.25rem; font-weight: 600; color: #333;">${coverageValue.toFixed(1)}%</div>`;
        const pagesWithSchemaCount = Array.isArray(data.pagesWithSchema) 
          ? data.pagesWithSchema.length 
          : (typeof data.pagesWithSchema === 'number' ? data.pagesWithSchema : 0);
        html += `<div style="font-size: 0.85rem; color: #666; margin-top: 0.25rem;">${pagesWithSchemaCount} pages with inline schema</div>`;
        
        // Display schema types if available, properly formatted
        if (data.schemaTypes && Array.isArray(data.schemaTypes) && data.schemaTypes.length > 0) {
          const formattedTypes = data.schemaTypes
            .filter(t => t !== null && t !== undefined)
            .map(t => {
              if (typeof t === 'string') return t;
              if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type;
              return null;
            })
            .filter(t => t !== null && typeof t === 'string')
            .slice(0, 10)
            .join(', ');
          if (formattedTypes) {
            html += `<div style="font-size: 0.75rem; color: #666; margin-top: 0.5rem; line-height: 1.4;">Schema types: ${formattedTypes}${data.schemaTypes.length > 10 ? '...' : ''}</div>`;
          }
        }
        html += `</div>`;
        
        html += `</div>`;
      } else {
        // Provide more helpful error message
        let errorMsg = 'Unable to load audit summary data.';
        if (!schemaAudit) {
          errorMsg = 'Schema audit data is missing. The audit may have failed or data was not saved properly.';
        } else if (schemaAudit.status !== 'ok') {
          errorMsg = `Schema audit failed with status: ${schemaAudit.status}. ${schemaAudit.error || schemaAudit.message || ''}`;
        } else if (!schemaAudit.data) {
          errorMsg = 'Schema audit completed but data is missing. Please check the console for errors.';
        }
        html += `<div style="background: #fef2f2; border-left: 4px solid #ef4444; padding: 1rem; border-radius: 4px;">`;
        html += `<p style="margin: 0; color: #991b1b; line-height: 1.6;">${errorMsg}</p>`;
        html += `<p style="margin: 0.5rem 0 0 0; font-size: 0.85rem; color: #666;">Check the debug log at the bottom of the page for more details.</p>`;
        html += `</div>`;
        debugLog(` Completion modal error: schemaAudit=${!!schemaAudit}, status=${schemaAudit?.status}, hasData=${!!schemaAudit?.data}, hasMeta=${!!schemaAudit?.meta}`, 'warn');
      }
      
      content.innerHTML = html;
      modal.style.display = 'block';
      debugLog('Modal display set to block', 'info');
      debugLog(`Modal is now visible: ${modal.style.display}`, 'info');
      
      // Attach retry button handler if it exists
      const retryButton = document.getElementById('retryFailedUrls');
      if (retryButton) {
        retryButton.onclick = function() {
          retryFailedUrls(schemaAudit);
        };
      }
    }
    
    // Retry failed URLs from schema audit
    async function retryFailedUrls(schemaAudit) {
      if (!schemaAudit || !schemaAudit.data || !schemaAudit.data.missingSchemaPages) {
        debugLog(' No failed URLs to retry', 'error');
        showStatus('No failed URLs found to retry', 'error');
        return;
      }
      
      // Extract failed URLs (those with errors)
      const failedUrls = schemaAudit.data.missingSchemaPages
        .filter(p => p.error)
        .map(p => p.url);
      
      if (failedUrls.length === 0) {
        debugLog(' No failed URLs to retry', 'error');
        showStatus('No failed URLs found to retry', 'error');
        return;
      }
      
      debugLog(` Retrying ${failedUrls.length} failed URLs...`, 'info');
      showStatus(`Retrying ${failedUrls.length} failed URLs...`, 'info');
      
      // Close the modal
      closeCompletionModal();
      
      // Show loading indicator
      document.getElementById('loading').classList.add('show');
      document.getElementById('dashboard').style.display = 'none';
      updateProgress(0, `Retrying ${failedUrls.length} failed URLs...`);
      
      try {
        updateProgress(20, 'Scanning failed URLs for schema markup...');
        debugLog(`Sending retry request for ${failedUrls.length} URLs`, 'info');
        
        // Call schema-audit API with only the failed URLs
        const schemaResponse = await fetch(apiUrl('/api/schema-audit'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ urls: failedUrls })
        });
        
        if (!schemaResponse.ok) {
          throw new Error(`Schema audit API returned error: ${schemaResponse.status}`);
        }
        
        const retrySchemaAudit = await schemaResponse.json();
        
        if (retrySchemaAudit.status !== 'ok') {
          throw new Error(retrySchemaAudit.message || 'Schema audit failed');
        }
        
        const retryData = retrySchemaAudit.data;
        const retrySuccessful = retryData.pagesWithSchema || 0;
        const retryStillFailed = (retryData.missingSchemaCount || 0);
        
        debugLog(` Retry completed: ${retrySuccessful} pages now have schema, ${retryStillFailed} still failed`, 'success');
        updateProgress(60, 'Merging retry results with original audit...');
        
        // Load original audit results from localStorage or Supabase
        const savedAudit = await loadAuditResults();
        if (savedAudit && savedAudit.schemaAudit && savedAudit.schemaAudit.data) {
          // Merge retry results with original schema audit
          const originalData = savedAudit.schemaAudit.data;
          const originalPages = originalData.pagesWithSchema || 0;
          const originalFailed = originalData.missingSchemaCount || 0;
          
          // Create merged schema audit data
          const mergedSchemaAudit = {
            ...savedAudit.schemaAudit,
            data: {
              ...originalData,
              // Update counts: add retry successful pages, remove retry successful from failed
              pagesWithSchema: originalPages + retrySuccessful,
              missingSchemaCount: Math.max(0, originalFailed - retrySuccessful),
              // Update missingSchemaPages: remove successfully retried URLs
              missingSchemaPages: (originalData.missingSchemaPages || []).filter(p => {
                // Keep only pages that weren't in the retry list or still failed
                return !failedUrls.includes(p.url) || (retryData.missingSchemaPages || []).some(rp => rp.url === p.url);
              }),
              // Update coverage
              coverage: ((originalPages + retrySuccessful) / originalData.totalPages) * 100
            }
          };
          
          // Update saved audit with merged results
          const mergedAudit = {
            ...savedAudit,
            schemaAudit: mergedSchemaAudit
          };
          
          // Recalculate scores with merged data (use saved localSignals if available)
          // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
          const normalizedSiteReviews = getTrustpilotSnapshot(savedAudit.siteReviews || null);
          const mergedScores = await calculatePillarScores(savedAudit.searchData, mergedSchemaAudit, savedAudit.localSignals || null, normalizedSiteReviews, savedAudit.backlinkMetrics || null);
          const mergedSnippetReadiness = calculateSnippetReadiness(mergedScores, savedAudit.searchData);
          
          // Save merged results (preserve localSignals, siteReviews, and backlinkMetrics)
          saveAuditResults(mergedScores, savedAudit.searchData, mergedSnippetReadiness, mergedSchemaAudit, savedAudit.localSignals || null, normalizedSiteReviews, savedAudit.backlinkMetrics || null);
          
          // Update retry button visibility
          updateRetryButtonVisibility(mergedSchemaAudit);
          
          // Refresh dashboard with merged results
          updateProgress(80, 'Refreshing dashboard with merged results...');
          displayDashboard(mergedScores, savedAudit.searchData, mergedSnippetReadiness, mergedSchemaAudit, savedAudit.localSignals || null);
          
          updateProgress(100, 'Retry completed and dashboard updated!');
          showStatus(`Retry completed: ${retrySuccessful} URLs now have schema. Dashboard updated with merged results.`, 'success');
          
          // Show completion modal with merged results
          showCompletionModal(mergedSchemaAudit);
        } else {
          // No saved audit found, just show retry results
          updateProgress(80, 'Retry completed!');
          showCompletionModal(retrySchemaAudit);
          updateProgress(100, 'Retry completed!');
          showStatus(`Retry completed: ${retrySuccessful} URLs now have schema, ${retryStillFailed} still failed`, 'success');
          debugLog(' No saved audit found to merge with. Run full audit to see complete results.', 'warn');
        }
        
      } catch (error) {
        debugLog(` Retry error: ${error.message}`, 'error');
        showStatus(`Error retrying failed URLs: ${error.message}`, 'error');
      } finally {
        document.getElementById('loading').classList.remove('show');
        setTimeout(() => {
          updateProgress(0, 'Initializing audit scan...');
        }, 500);
      }
    }

    // Save audit results to localStorage
    function saveAuditResults(scores, searchData, snippetReadiness, schemaAudit, localSignals = null, siteReviews = null, backlinkMetrics = null, preserveTimestamp = false) {
      try {
        const dateRange = parseInt(document.getElementById('dateRange')?.value) || 30;
        // Get property URL from input field or from searchData
        const propertyUrl = document.getElementById('propertyUrl')?.value || 
                           searchData?.propertyUrl || 
                           searchData?.property_url ||
                           localStorage.getItem('gsc_property_url') ||
                           'https://www.alanranger.com'; // Fallback default
        
        // Get existing audit data to preserve timestamp if requested
        let existingTimestamp = null;
        if (preserveTimestamp) {
          try {
            const existing = localStorage.getItem('last_audit_results');
            if (existing) {
              const parsed = JSON.parse(existing);
              existingTimestamp = parsed.timestamp;
            }
          } catch (e) {
            // Ignore errors when reading existing data
          }
        }
        
        const auditData = {
          scores,
          searchData,
          snippetReadiness,
          schemaAudit,
          localSignals, // Store local signals data for future use
          siteReviews, // Store site reviews data for future use (preserve on retry)
          backlinkMetrics, // Store backlink metrics data
          dateRange, // Store the date range used for this audit
          propertyUrl, // CRITICAL: Save property URL so we can fetch from Supabase later
          timestamp: preserveTimestamp && existingTimestamp ? existingTimestamp : new Date().toISOString(),
          // Save Money Pages Priority Matrix data for persistence
          moneyPagePriorityData: window.moneyPagePriorityData || null,
          moneySegmentMetrics: window.moneySegmentMetrics || null
        };
        
        // Try to save to localStorage, but don't fail if quota exceeded (Supabase is source of truth)
        if (safeSetLocalStorage('last_audit_results', auditData)) {
          debugLog(` Audit results saved to localStorage (propertyUrl: ${propertyUrl})`, 'success');
        }
        // Also save property URL separately for easy access
        if (propertyUrl) {
          localStorage.setItem('gsc_property_url', propertyUrl);
        }
        debugLog(` Audit results saved to localStorage (propertyUrl: ${propertyUrl})`, 'success');
        
        // Update timestamp display
        updateAuditTimestamp(auditData.timestamp);
      } catch (error) {
        debugLog(` Error saving audit results: ${error.message}`, 'error');
      }
    }
    
    // Show full-screen loading overlay
    function showFullScreenLoading(message = 'Loading...') {
      // Remove any existing overlay
      const existing = document.getElementById('fullScreenLoadingOverlay');
      if (existing) existing.remove();
      
      // Create overlay
      const overlay = document.createElement('div');
      overlay.id = 'fullScreenLoadingOverlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(4px);
      `;
      
      // Create spinner container
      const spinnerContainer = document.createElement('div');
      spinnerContainer.style.cssText = `
        background: white;
        padding: 3rem 4rem;
        border-radius: 12px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        text-align: center;
        min-width: 300px;
      `;
      
      // Create spinner
      const spinner = document.createElement('div');
      spinner.style.cssText = `
        width: 60px;
        height: 60px;
        border: 6px solid #e2e8f0;
        border-top-color: #3b82f6;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 1.5rem;
      `;
      
      // Create message
      const messageDiv = document.createElement('div');
      messageDiv.style.cssText = 'font-size: 1.1rem; color: #1f2937; font-weight: 500;';
      messageDiv.textContent = message;
      
      // Add spin animation if not already in stylesheet
      if (!document.getElementById('full-screen-spin-style')) {
        const style = document.createElement('style');
        style.id = 'full-screen-spin-style';
        style.textContent = '@keyframes spin { to { transform: rotate(360deg); } }';
        document.head.appendChild(style);
      }
      
      spinnerContainer.appendChild(spinner);
      spinnerContainer.appendChild(messageDiv);
      overlay.appendChild(spinnerContainer);
      document.body.appendChild(overlay);
    }
    
    // Hide full-screen loading overlay
    function hideFullScreenLoading() {
      const overlay = document.getElementById('fullScreenLoadingOverlay');
      if (overlay) overlay.remove();
    }
    
    // Update audit results for new date range without full rescan
    async function updateAuditForNewDateRange(newDateRange, savedAudit) {
      // Show full-screen loading overlay
      showFullScreenLoading(`Updating metrics for ${newDateRange} day period...`);
      
      try {
        showStatus(`Updating metrics for ${newDateRange} day period...`, 'info');
        
        const propertyUrl = document.getElementById('propertyUrl')?.value || savedAudit.propertyUrl || '';
        if (!propertyUrl) {
          // Remove loading spinner
          if (trendCanvas && trendCanvas.parentElement) {
            const loadingDiv = trendCanvas.parentElement.querySelector('.trend-chart-loading');
            if (loadingDiv) loadingDiv.remove();
          }
          clearDashboard();
          showStatus(`Date range changed to ${newDateRange} days. Please run a new audit to see updated metrics.`, 'info');
          return;
        }
        
        // Get API key (needed for fetchSearchConsoleData signature, but not actually used)
        let apiKey = window._loadedApiKey || '';
        
        // Fetch new GSC data for the new date range (will use Supabase cache)
        debugLog(`Fetching GSC data for ${newDateRange} day period...`, 'info');
        const searchData = await fetchSearchConsoleData(apiKey, propertyUrl, newDateRange);
        
        // Fetch local signals (Business Profile data doesn't change with date range, but fetch to ensure it's fresh)
        let localSignals = savedAudit.localSignals || null;
        
        // Normalize cached localSignals structure if needed (handle old format where it might just be {data: {...}})
        if (localSignals && localSignals.data && !localSignals.status) {
          debugLog(`[Local Signals] Normalizing cached data structure - wrapping in status/data format`, 'info');
          localSignals = { status: 'ok', data: localSignals.data || localSignals };
        }
        
        try {
          const localSignalsResponse = await fetch(apiUrl(`/api/aigeo/local-signals?property=${encodeURIComponent(propertyUrl)}`));
          if (localSignalsResponse.ok) {
            const freshLocalSignals = await localSignalsResponse.json();
            debugLog(`[Local Signals API] Response received - status: ${freshLocalSignals.status}, has data: ${!!freshLocalSignals.data}, locations count: ${freshLocalSignals.data?.locations?.length || 0}, structure keys: ${Object.keys(freshLocalSignals).join(', ')}`, 'info');
            
            // Use fresh data if API returned successfully
            if (freshLocalSignals.status === 'ok' && freshLocalSignals.data) {
              // Always use fresh data if API returned successfully, even if locations is 0
              // (API might return 0 locations legitimately, or we want to update cached data)
              localSignals = freshLocalSignals;
              debugLog(` Local signals data fetched successfully - Locations: ${freshLocalSignals.data.locations?.length || 0}, Service Areas: ${freshLocalSignals.data.serviceAreas?.length || 0}, NAP: ${freshLocalSignals.data.napConsistencyScore}`, 'success');
            } else if (freshLocalSignals.status === 'error') {
              debugLog(` Local signals API error: ${freshLocalSignals.error?.message || 'Unknown error'}, keeping cached data`, 'warn');
              // Keep using cached data - don't overwrite with error response
            } else {
              debugLog(` Local signals API returned unexpected status (status: ${freshLocalSignals.status}, has data: ${!!freshLocalSignals.data}, locations: ${freshLocalSignals.data?.locations?.length || 0}), keeping cached data`, 'warn');
              // Keep using cached data - don't overwrite with unexpected response
            }
          }
        } catch (localSignalsError) {
          debugLog(` Local signals error: ${localSignalsError.message}, using cached data if available`, 'warn');
        }
        
        // Final normalization - ensure localSignals always has the correct structure
        if (localSignals && localSignals.data && !localSignals.status) {
          localSignals = { status: 'ok', data: localSignals.data || localSignals };
        }
        
        // Recalculate pillar scores based on new GSC data
        // Keep existing schema audit data (doesn't change with date range)
        // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
        const normalizedSiteReviews = getTrustpilotSnapshot(savedAudit.siteReviews || null);
        // Get backlinkMetrics from savedAudit (it should be there from the last audit)
        const backlinkMetrics = savedAudit.backlinkMetrics || null;
        const scores = await calculatePillarScores(searchData, savedAudit.schemaAudit, localSignals, normalizedSiteReviews, backlinkMetrics);
        const snippetReadiness = calculateSnippetReadiness(scores, searchData);
        
        debugLog(`Recalculated scores for ${newDateRange} days: ${JSON.stringify(scores)}`, 'info');
        
        // Update saved audit with new data
        // Preserve the original audit timestamp - don't update it when changing date range
        const updatedAudit = {
          ...savedAudit,
          dateRange: newDateRange,
          searchData: searchData,
          scores: scores,
          snippetReadiness: snippetReadiness,
          localSignals: localSignals, // Store local signals for future use
          timestamp: savedAudit.timestamp || new Date().toISOString(), // Preserve original timestamp
          // Preserve Money Pages Priority Matrix data if it exists
          moneyPagePriorityData: window.moneyPagePriorityData || savedAudit.moneyPagePriorityData || null,
          moneySegmentMetrics: window.moneySegmentMetrics || savedAudit.moneySegmentMetrics || null
        };
        
        // Save updated audit
        // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
        const normalizedSiteReviewsForLoad = getTrustpilotSnapshot(savedAudit.siteReviews || null);
        // Use backlinkMetrics from savedAudit (preserved from last audit)
        const preservedBacklinkMetrics = backlinkMetrics;
        // Pass preserveTimestamp=true to keep the original audit timestamp
        saveAuditResults(scores, searchData, snippetReadiness, savedAudit.schemaAudit, localSignals, normalizedSiteReviewsForLoad, preservedBacklinkMetrics, true);
        safeSetLocalStorage('last_audit_results', updatedAudit);
        
        // Do NOT save to Supabase here.
        // This "metrics refresh" (date range change) is not a full audit run, and saving it
        // can incorrectly update today's audit_results row and the "Last Audit" time.
        
        // Update dashboard with new data - ensure scores object has all required properties
        debugLog(`Updating dashboard with scores: ${JSON.stringify(scores)}`, 'info');
        displayDashboard(scores, searchData, snippetReadiness, savedAudit.schemaAudit, localSignals);
        
        showStatus(`Metrics updated for ${newDateRange} day period.`, 'success');
        debugLog(` Audit updated for ${newDateRange} day period`, 'success');
        
      } catch (error) {
        debugLog(` Error updating audit for new date range: ${error.message}`, 'error');
        
        // Remove loading spinner and show error
        // Hide full-screen loading overlay
        hideFullScreenLoading();
        
        // Show error message in trend chart area
        const trendCanvas = document.getElementById('trendChart');
        if (trendCanvas && trendCanvas.parentElement) {
          // Remove any existing error messages
          const existingError = trendCanvas.parentElement.querySelector('.trend-chart-error');
          if (existingError) existingError.remove();
          
          // Show error message to user
          const errorDiv = document.createElement('div');
          errorDiv.className = 'trend-chart-error';
          errorDiv.style.cssText = 'background: #fee2e2; padding: 1rem; border-radius: 4px; border-left: 3px solid #ef4444; margin-bottom: 1rem; font-size: 0.9rem; color: #991b1b;';
          errorDiv.innerHTML = `<strong>Error updating trend chart:</strong> ${error.message}. Please refresh the page or run a new audit.`;
          trendCanvas.parentElement.insertBefore(errorDiv, trendCanvas);
        }
        
        clearDashboard();
        showStatus(`Date range changed to ${newDateRange} days. Please run a new audit to see updated metrics.`, 'info');
      }
    }
    
    // Clear dashboard and show message that new audit is needed
    function clearDashboard() {
      const dashboard = document.getElementById('dashboard');
      if (dashboard) {
        dashboard.style.display = 'none';
      }
      // Clear any charts
      if (window.radarChart) {
        window.radarChart.destroy();
        window.radarChart = null;
      }
      if (window.trendChart) {
        window.trendChart.destroy();
        window.trendChart = null;
      }
      if (window.snippetReadinessChart) {
        window.snippetReadinessChart.destroy();
        window.snippetReadinessChart = null;
      }
    }
    
    // Load audit results from localStorage
    async function loadAuditResults() {
      let auditData = null;
      let localStorageData = null;
      let hasMoneyPagesData = false;
      let hasQueryTotals = false;
      
      // First, try localStorage
      try {
        const saved = localStorage.getItem('last_audit_results');
        if (saved) {
          localStorageData = JSON.parse(saved);
          debugLog(' Audit results loaded from localStorage', 'success');
          
          // Check if localStorage data has critical Money Pages data
          hasMoneyPagesData = !!(localStorageData?.scores?.moneyPagesMetrics || localStorageData?.moneyPagesMetrics);
          // Also check if queryTotals are present (needed for CTR/Impressions columns)
          hasQueryTotals = !!(localStorageData?.searchData?.queryTotals && Array.isArray(localStorageData.searchData.queryTotals) && localStorageData.searchData.queryTotals.length > 0);
          
          if (hasMoneyPagesData) {
            debugLog(` localStorage has moneyPagesMetrics: ${localStorageData?.scores?.moneyPagesMetrics?.rows?.length || localStorageData?.moneyPagesMetrics?.rows?.length || 0} rows`, 'success');
            if (!hasQueryTotals) {
              debugLog(` localStorage missing queryTotals (${localStorageData?.searchData?.queryTotals?.length || 0} items), will try Supabase...`, 'warn');
            } else {
              debugLog(` localStorage has queryTotals: ${localStorageData.searchData.queryTotals.length} keywords`, 'success');
            }
            // Don't return yet: we still want to confirm "Last Audit" against Supabase
            auditData = localStorageData;
          } else {
            debugLog(' localStorage data missing moneyPagesMetrics, will try Supabase...', 'warn');
            // Keep localStorageData as fallback
            auditData = localStorageData;
          }
        }
      } catch (error) {
        debugLog(` Error loading audit results from localStorage: ${error.message}`, 'error');
      }
      
      // If localStorage is empty or missing critical data, try fetching from Supabase
      // Try multiple sources for property URL - prioritize saved audit data
      let propertyUrl = (localStorageData && localStorageData.propertyUrl) || // First check: saved in auditData
                        localStorage.getItem('gsc_property_url') || 
                        localStorage.getItem('last_property_url') ||
                        (localStorageData && localStorageData.searchData && localStorageData.searchData.propertyUrl) ||
                        (localStorageData && localStorageData.searchData && localStorageData.searchData.property_url);
      
      // If still no property URL, try to extract from saved audit data structure
      if (!propertyUrl && localStorageData) {
        // Check if there's a property URL embedded in the saved data
        if (localStorageData.searchData && typeof localStorageData.searchData === 'object') {
          propertyUrl = localStorageData.searchData.propertyUrl || localStorageData.searchData.property_url;
        }
      }
      
      // Last resort: try to get from input field
      if (!propertyUrl) {
        const propertyUrlInput = document.getElementById('propertyUrl');
        if (propertyUrlInput && propertyUrlInput.value) {
          propertyUrl = propertyUrlInput.value;
        }
      }
      
      debugLog(`Property URL for Supabase fetch: ${propertyUrl || 'NOT SET'}`, propertyUrl ? 'info' : 'warn');
      
      if (propertyUrl) {
        // Always do a quick minimal check so "Last Audit" reflects the latest *full* audit,
        // even when we can serve the rest of the page from localStorage.
        try {
          const minimalResponse = await fetch(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}&minimal=true`);
          if (minimalResponse.ok) {
            const minimalJson = await minimalResponse.json();
            const minimalData = minimalJson?.data;
            if (minimalJson?.status === 'ok' && minimalData?.timestamp) {
              updateAuditTimestamp(minimalData.timestamp);
              // IMPORTANT: also update cached local data, otherwise displayDashboard() will
              // overwrite the UI with stale localStorageData.timestamp.
              const normalizedTs = typeof minimalData.timestamp === 'number'
                ? new Date(minimalData.timestamp).toISOString()
                : minimalData.timestamp;
              if (localStorageData && normalizedTs) {
                localStorageData.timestamp = normalizedTs;
                try {
                  safeSetLocalStorage('last_audit_results', localStorageData);
                } catch (e) {
                  // Non-fatal
                }
              }
              if (auditData && normalizedTs) {
                auditData.timestamp = normalizedTs;
              }
            }
          }
        } catch (e) {
          // Non-fatal
        }

        // ALWAYS fetch from Supabase as the source of truth
        debugLog(` Always fetching from Supabase (source of truth)...`, 'info');
        debugLog(` Calling fetchLatestAuditFromSupabase(${propertyUrl})...`, 'info');
        const supabaseData = await fetchLatestAuditFromSupabase(propertyUrl);
        debugLog(` fetchLatestAuditFromSupabase returned: ${supabaseData ? 'data' : 'null/undefined'}`, supabaseData ? 'success' : 'warn');
        
        if (supabaseData) {
          debugLog(' Audit results loaded from Supabase', 'success');
          debugLog(` Supabase data structure: scores.moneyPagesMetrics=${!!supabaseData?.scores?.moneyPagesMetrics}, moneyPagesMetrics=${!!supabaseData?.moneyPagesMetrics}, searchData=${!!supabaseData?.searchData}, queryTotals=${supabaseData?.searchData?.queryTotals?.length || 0} keywords`, 'info');
          if (supabaseData.searchData) {
            debugLog(` Supabase searchData keys: ${Object.keys(supabaseData.searchData).join(', ')}`, 'info');
            if (supabaseData.searchData.queryTotals) {
              debugLog(` Supabase queryTotals type: ${Array.isArray(supabaseData.searchData.queryTotals) ? 'array' : typeof supabaseData.searchData.queryTotals}, length: ${Array.isArray(supabaseData.searchData.queryTotals) ? supabaseData.searchData.queryTotals.length : 'N/A'}`, 'success');
            } else {
              debugLog(` Supabase searchData exists but queryTotals is missing/null`, 'warn');
            }
          } else {
            debugLog(` Supabase data exists but searchData is missing/null`, 'warn');
          }
          
          // Store in localStorage for offline/cache purposes (but Supabase is always source of truth)
          try {
            safeSetLocalStorage('last_audit_results', supabaseData);
            debugLog(' Stored Supabase data in localStorage for caching', 'success');
            // Update timestamp display
            if (supabaseData.timestamp) {
              updateAuditTimestamp(supabaseData.timestamp);
            }
          } catch (storageError) {
            debugLog(` Could not store Supabase data in localStorage: ${storageError.message}`, 'warn');
          }
          return supabaseData;
        } else {
          debugLog(' No audit data found in Supabase (fetchLatestAuditFromSupabase returned null/undefined), using localStorage data as fallback', 'warn');
          debugLog(` This could mean: 1) No audit exists in Supabase for ${propertyUrl}, 2) API call failed, 3) API returned error status`, 'warn');
        }
      } else {
        debugLog(' Cannot fetch from Supabase: property URL not set, using localStorage data as fallback', 'warn');
      }
      
      // Return localStorage data as fallback (even if incomplete) rather than null
      // This ensures the page still loads with whatever data we have
      if (localStorageData) {
        debugLog(' Returning localStorage data as fallback (may be incomplete)', 'info');
        return localStorageData;
      }
      
      return null;
    }
    
    // Synchronous version for callers that can't be async (returns localStorage only)
    function loadAuditResultsSync() {
      try {
        const saved = localStorage.getItem('last_audit_results');
        if (saved) {
          return JSON.parse(saved);
        }
      } catch (error) {
        // Silent fail for sync version
      }
      return null;
    }
    
    // Update audit timestamp display
    function updateAuditTimestamp(timestamp) {
      const timestampElement = document.getElementById('lastAuditTime');
      const snippetTimestampElement = document.getElementById('snippetReadinessAuditTime');
      const snippetTimestampContainer = document.getElementById('snippetReadinessTimestamp');
      const radarTimestampElement = document.getElementById('radarChartAuditTime');
      const radarTimestampContainer = document.getElementById('radarChartTimestamp');
      
      if (timestamp) {
        const date = new Date(timestamp);
        // Format in GMT/UTC: "DD MMM YYYY, HH:MM:SS GMT"
        const day = String(date.getUTCDate()).padStart(2, '0');
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const month = monthNames[date.getUTCMonth()];
        const year = date.getUTCFullYear();
        const hours = String(date.getUTCHours()).padStart(2, '0');
        const minutes = String(date.getUTCMinutes()).padStart(2, '0');
        const seconds = String(date.getUTCSeconds()).padStart(2, '0');
        const formatted = `${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
        
        if (timestampElement) {
          timestampElement.textContent = formatted;
        }
        
        // Update snippet readiness timestamp
        if (snippetTimestampElement) {
          snippetTimestampElement.textContent = formatted;
        }
        if (snippetTimestampContainer) {
          snippetTimestampContainer.style.display = 'block';
        }
        
        // Update radar chart timestamp
        if (radarTimestampElement) {
          radarTimestampElement.textContent = formatted;
        }
        if (radarTimestampContainer) {
          radarTimestampContainer.style.display = 'block';
        }
      } else {
        if (timestampElement) {
          timestampElement.textContent = 'Not yet run';
        }
        if (snippetTimestampContainer) {
          snippetTimestampContainer.style.display = 'none';
        }
        if (radarTimestampContainer) {
          radarTimestampContainer.style.display = 'none';
        }
      }
    }
    
    // Save audit results to Supabase for historical tracking
    async function saveAuditToSupabase(propertyUrl, scores, searchData, snippetReadiness, schemaAudit, localSignals = null, auditDateOverride = null) {
      try {
        // IMPORTANT: Only full audits should write a new audit_date.
        // If auditDateOverride is provided, use it; otherwise try to derive from the saved audit timestamp.
        let auditDate = auditDateOverride;
        if (!auditDate) {
          try {
            const saved = loadAuditResultsSync();
            if (saved && saved.timestamp) {
              auditDate = new Date(saved.timestamp).toISOString().split('T')[0];
            }
          } catch (e) {
            // Ignore
          }
        }
        if (!auditDate) {
          auditDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD fallback
        }
        
        // Ensure searchData has overview object with siteTotalImpressions and siteTotalClicks
        // These are needed for calculating shareOfImpressions in buildMoneyPagesSummary
        let overview = null;
        
        if (searchData) {
          // Create overview object if it doesn't exist
          if (!searchData.overview) {
            searchData.overview = {};
          }
          
          // Populate overview with siteTotalImpressions and siteTotalClicks
          // Priority: searchData.overview.siteTotalImpressions > searchData.totalImpressions > searchData.overview.totalImpressions
          if (!searchData.overview.siteTotalImpressions || searchData.overview.siteTotalImpressions === 0) {
            if (searchData.totalImpressions != null && searchData.totalImpressions > 0) {
              searchData.overview.siteTotalImpressions = searchData.totalImpressions;
            } else if (searchData.overview.totalImpressions != null && searchData.overview.totalImpressions > 0) {
              searchData.overview.siteTotalImpressions = searchData.overview.totalImpressions;
            } else {
              // Fallback: set to 0 if all else fails
              searchData.overview.siteTotalImpressions = 0;
            }
          }
          
          if (!searchData.overview.siteTotalClicks || searchData.overview.siteTotalClicks === 0) {
            if (searchData.totalClicks != null && searchData.totalClicks > 0) {
              searchData.overview.siteTotalClicks = searchData.totalClicks;
            } else if (searchData.overview.totalClicks != null && searchData.overview.totalClicks > 0) {
              searchData.overview.siteTotalClicks = searchData.overview.totalClicks;
            } else {
              // Fallback: set to 0 if all else fails
              searchData.overview.siteTotalClicks = 0;
            }
          }
          
          // Also ensure totalImpressions and totalClicks are set in overview for compatibility
          if (!searchData.overview.totalImpressions) {
            searchData.overview.totalImpressions = searchData.overview.siteTotalImpressions;
          }
          if (!searchData.overview.totalClicks) {
            searchData.overview.totalClicks = searchData.overview.siteTotalClicks;
          }
          
          overview = searchData.overview;
          
          // Debug logging
          debugLog(`saveAuditToSupabase: searchData.totalImpressions=${searchData.totalImpressions}, overview.siteTotalImpressions=${overview.siteTotalImpressions || 'missing'}, overview.totalImpressions=${overview.totalImpressions || 'missing'}`, 'info');
        } else {
          debugLog(` saveAuditToSupabase: searchData is null or undefined`, 'warn');
          // Create empty overview as fallback
          overview = { siteTotalImpressions: 0, siteTotalClicks: 0, totalImpressions: 0, totalClicks: 0 };
        }
        
        // Build Money Pages summary for trend tracking (Phase 3)
        // CRITICAL: Ensure moneyPagesMetrics exists in scores - check multiple sources
        debugLog(`saveAuditToSupabase: Checking for moneyPagesMetrics - scores.moneyPagesMetrics=${!!scores?.moneyPagesMetrics}, window.moneyPagesMetrics=${!!window.moneyPagesMetrics}`, 'info');
        
        if (!scores.moneyPagesMetrics) {
          debugLog(` saveAuditToSupabase: scores.moneyPagesMetrics is missing, checking window.moneyPagesMetrics`, 'warn');
          // Try to get from global state if available
          if (window.moneyPagesMetrics) {
            scores.moneyPagesMetrics = window.moneyPagesMetrics;
            debugLog(` saveAuditToSupabase: Using moneyPagesMetrics from window (${window.moneyPagesMetrics.rows?.length || 0} rows)`, 'info');
          } else {
            debugLog(` saveAuditToSupabase: No moneyPagesMetrics available anywhere - this means money pages data was not generated during audit`, 'warn');
            debugLog(` saveAuditToSupabase: This could be because: 1) No queryPages data from GSC, 2) CSV fetch failed, 3) No money pages found in CSV`, 'warn');
            // Set to null explicitly so it's saved (even if empty)
            scores.moneyPagesMetrics = null;
          }
        } else {
          debugLog(` saveAuditToSupabase: moneyPagesMetrics found in scores (${scores.moneyPagesMetrics.rows?.length || 0} rows)`, 'info');
        }
        
        // CRITICAL: Log what we're about to save
        debugLog(`saveAuditToSupabase: Final moneyPagesMetrics to save: ${scores.moneyPagesMetrics ? (scores.moneyPagesMetrics.rows?.length || 0) + ' rows' : 'NULL'}`, 'info');
        
        // Ensure overview is never null - create fallback if needed
        if (!overview) {
          debugLog(` saveAuditToSupabase: overview is null, creating fallback`, 'warn');
          overview = { 
            siteTotalImpressions: searchData?.totalImpressions || 0, 
            siteTotalClicks: searchData?.totalClicks || 0,
            totalImpressions: searchData?.totalImpressions || 0,
            totalClicks: searchData?.totalClicks || 0
          };
        }
        
        debugLog(`saveAuditToSupabase: About to call buildMoneyPagesSummary - overview exists=${!!overview}, overview.siteTotalImpressions=${overview?.siteTotalImpressions || 'missing'}, searchData.totalImpressions=${searchData?.totalImpressions || 'missing'}, moneyPagesMetrics=${!!scores?.moneyPagesMetrics}`, 'info');
        const moneyPagesSummary = window.buildMoneyPagesSummary ? window.buildMoneyPagesSummary(
          scores?.moneyPagesMetrics || null,
          overview || { siteTotalImpressions: 0, siteTotalClicks: 0, totalImpressions: 0, totalClicks: 0 }
        ) : null;
        if (moneyPagesSummary) {
          debugLog(`saveAuditToSupabase: moneyPagesSummary created - shareOfImpressions=${moneyPagesSummary.shareOfImpressions || 'null'}`, 'info');
        } else {
          debugLog(`saveAuditToSupabase: moneyPagesSummary is null`, 'warn');
        }
        
        // Get money segment metrics for 12-month KPI tracking
        // Ensure it's never null - build empty structure if missing
        let moneySegmentMetrics = window.moneySegmentMetrics;
        if (!moneySegmentMetrics) {
          debugLog(` saveAuditToSupabase: moneySegmentMetrics is null, building empty structure`, 'warn');
          // Build empty structure to ensure it's always saved (even if empty)
          if (typeof buildMoneySegmentSummary === 'function') {
            // Try to rebuild from moneyPagePriorityData if available
            const priorityData = window.moneyPagePriorityData || [];
            if (priorityData.length > 0) {
              debugLog(` saveAuditToSupabase: Rebuilding moneySegmentMetrics from priority data (${priorityData.length} pages)`, 'info');
              moneySegmentMetrics = buildMoneySegmentSummary(priorityData, {});
            } else {
              moneySegmentMetrics = buildMoneySegmentSummary([], {});
            }
          } else {
            // Fallback structure if function not available
            moneySegmentMetrics = {
              allMoney: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
              landingPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
              eventPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
              productPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 }
            };
          }
        }
        
        // Also ensure moneyPagePriorityData is available for saving
        if (!window.moneyPagePriorityData || window.moneyPagePriorityData.length === 0) {
          debugLog(` saveAuditToSupabase: moneyPagePriorityData is missing or empty`, 'warn');
          // Try to rebuild from moneyPagesMetrics if available
          if (scores?.moneyPagesMetrics?.rows && scores.moneyPagesMetrics.rows.length > 0) {
            debugLog(` saveAuditToSupabase: Rebuilding moneyPagePriorityData from moneyPagesMetrics (${scores.moneyPagesMetrics.rows.length} rows)`, 'info');
            const topPagesForPriority = scores.moneyPagesMetrics.rows.map(row => ({
              page: row.url,
              url: row.url,
              clicks: row.clicks || 0,
              impressions: row.impressions || 0,
              ctr: (row.ctr || 0) * 100,
              position: row.avgPosition || 0,
              avgPosition: row.avgPosition || 0,
              title: row.title || row.url
            }));
            // Use window.buildMoneyPageMetrics if available, otherwise use local function
            if (typeof window.buildMoneyPageMetrics === 'function') {
              window.moneyPagePriorityData = window.buildMoneyPageMetrics(topPagesForPriority, schemaAudit);
            } else if (typeof buildMoneyPageMetrics === 'function') {
              window.moneyPagePriorityData = buildMoneyPageMetrics(topPagesForPriority, schemaAudit);
            } else {
              debugLog(` buildMoneyPageMetrics not available in saveAuditToSupabase, cannot rebuild`, 'error');
              window.moneyPagePriorityData = [];
            }
            debugLog(` saveAuditToSupabase: Rebuilt ${window.moneyPagePriorityData.length} priority entries`, 'info');
          }
        }
        debugLog(`saveAuditToSupabase: moneySegmentMetrics ready with ${Object.keys(moneySegmentMetrics).length} segments`, 'info');
        debugLog(`saveAuditToSupabase: moneySegmentMetrics.allMoney clicks=${moneySegmentMetrics.allMoney?.clicks || 0}, impressions=${moneySegmentMetrics.allMoney?.impressions || 0}`, 'info');
        
        // Get rankingAiData from localStorage or window if available
        let rankingAiData = null;
        try {
          const localRankingData = localStorage.getItem('rankingAiData');
          if (localRankingData) {
            rankingAiData = JSON.parse(localRankingData);
            debugLog(` saveAuditToSupabase: Loaded rankingAiData from localStorage (${rankingAiData.combinedRows?.length || 0} keywords)`, 'info');
          } else if (window.rankingAiData) {
            rankingAiData = window.rankingAiData;
            debugLog(` saveAuditToSupabase: Using rankingAiData from window (${rankingAiData.combinedRows?.length || 0} keywords)`, 'info');
          } else {
            debugLog(` saveAuditToSupabase: No rankingAiData available`, 'warn');
          }
        } catch (rankingErr) {
          debugLog(` saveAuditToSupabase: Error loading rankingAiData: ${rankingErr.message}`, 'warn');
        }
        
        // Prepare payload
        const payload = {
          propertyUrl,
          auditDate,
          schemaAudit,
          scores,
          searchData,
          snippetReadiness,
          localSignals, // Pass Business Profile data for storage
          moneyPagesSummary, // Phase 3: Money Pages summary for trend tracking
          moneySegmentMetrics, // Phase: Money Pages Priority Matrix - segment metrics for KPI tracker
          moneyPagePriorityData: window.moneyPagePriorityData || null, // CRITICAL: Save Priority Matrix data to Supabase
          rankingAiData // Ranking & AI data (SERP rankings + AI Overview citations)
        };
        
        // Check payload size before sending (Vercel limit is ~4.5MB)
        const payloadJson = JSON.stringify(payload);
        const payloadSizeKB = Math.round(payloadJson.length / 1024);
        debugLog(`saveAuditToSupabase: Payload size: ${payloadSizeKB}KB`, 'info');
        
        if (payloadSizeKB > 4000) {
          debugLog(` Payload size (${payloadSizeKB}KB) exceeds 4MB - truncating large fields...`, 'warn');
          // Truncate queryPages if too large
          if (searchData?.queryPages && Array.isArray(searchData.queryPages) && searchData.queryPages.length > 2000) {
            debugLog(` Truncating queryPages from ${searchData.queryPages.length} to 2000 items`, 'warn');
            searchData.queryPages = searchData.queryPages.slice(0, 2000);
          }
          // Truncate topQueries if too large
          if (searchData?.topQueries && Array.isArray(searchData.topQueries) && searchData.topQueries.length > 500) {
            debugLog(` Truncating topQueries from ${searchData.topQueries.length} to 500 items`, 'warn');
            searchData.topQueries = searchData.topQueries.slice(0, 500);
          }
          // Recalculate payload size after truncation
          const truncatedPayload = {
            ...payload,
            searchData: { ...searchData }
          };
          const truncatedJson = JSON.stringify(truncatedPayload);
          const truncatedSizeKB = Math.round(truncatedJson.length / 1024);
          debugLog(`saveAuditToSupabase: Payload size after truncation: ${truncatedSizeKB}KB`, 'info');
          payload.searchData = truncatedPayload.searchData;
        }
        
        const response = await fetch(apiUrl('/api/supabase/save-audit'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload)
        });
        
        if (response.ok) {
          const result = await response.json();
          debugLog(` Audit results saved to Supabase successfully (audit_date: ${auditDate})`, 'success');
          debugLog(` Saved data: schema_total_pages=${schemaAudit?.data?.totalPages || 'N/A'}, scores=${JSON.stringify(Object.keys(scores || {}))}`, 'info');
          
          // Verify the save by checking Supabase
          try {
            debugLog('Verifying audit save in Supabase...', 'info');
            const verifyResponse = await fetch(apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}&minimal=true`));
            if (verifyResponse.ok) {
              const verifyResult = await verifyResponse.json();
              if (verifyResult.status === 'ok' && verifyResult.data && verifyResult.data.auditDate === auditDate) {
                debugLog(` Verified: Audit ${auditDate} exists in Supabase with schema_total_pages=${verifyResult.data.scores?.contentSchema !== null ? 'present' : 'null'}`, 'success');
                showStatus(` Audit saved and verified in Supabase (${auditDate})`, 'success');
              } else {
                debugLog(` Verification failed: Audit ${auditDate} not found in Supabase yet`, 'warn');
                showStatus(` Audit save reported success but verification pending (${auditDate})`, 'warn');
              }
            } else {
              debugLog(` Could not verify audit save: ${verifyResponse.status}`, 'warn');
              showStatus(` Audit saved to Supabase (${auditDate}) - verification skipped`, 'success');
            }
          } catch (verifyError) {
            debugLog(` Verification error (non-critical): ${verifyError.message}`, 'warn');
            showStatus(` Audit saved to Supabase (${auditDate})`, 'success');
          }
          
          // After saving, refresh Money Pages charts with updated history
          // This ensures the trend chart and KPI tracker show the new audit data
          try {
            debugLog('Refreshing Money Pages charts with updated history...', 'info');
            
            // Fetch updated history for Money Pages trend chart
            const endDate = new Date().toISOString().split('T')[0];
            const startDate = new Date();
            startDate.setFullYear(startDate.getFullYear() - 1);
            const startDateStr = startDate.toISOString().split('T')[0];
            
            const historyResponse = await fetch(apiUrl(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDate}`));
            if (historyResponse.ok) {
              const historyJson = await historyResponse.json();
              if (historyJson.status === 'ok' && historyJson.data) {
                // Render Money Pages trend chart with updated history
                if (typeof renderMoneyPagesTrendChart === 'function') {
                  setTimeout(() => {
                    renderMoneyPagesTrendChart(historyJson.data);
                    debugLog(' Money Pages trend chart refreshed', 'success');
                  }, 500); // Small delay to ensure DOM is ready
                }
                
                // Refresh KPI tracker
                if (typeof loadAuditHistoryAndRenderKpis === 'function') {
                  setTimeout(() => {
                    loadAuditHistoryAndRenderKpis(propertyUrl);
                    debugLog(' Money Pages KPI tracker refreshed', 'success');
                  }, 500);
                }
              }
            }
          } catch (refreshError) {
            debugLog(` Error refreshing Money Pages charts: ${refreshError.message}`, 'warn');
            // Don't fail the save operation if refresh fails
          }
        } else {
          // Read response body once as text, then try to parse as JSON to avoid "body stream already read" error
          let errorMessage = 'Unknown error';
          let errorDetails = null;
          try {
            const responseText = await response.text();
            // Try to parse as JSON
            try {
              const error = JSON.parse(responseText);
              errorMessage = error.message || error.details || responseText;
              errorDetails = error;
            } catch (parseError) {
              // Not JSON, use text as-is
              errorMessage = responseText || `HTTP ${response.status}: ${response.statusText}`;
            }
          } catch (textError) {
            errorMessage = `HTTP ${response.status}: ${response.statusText}`;
          }
          // Log detailed error for debugging
          console.error('[Supabase Save] Failed to save audit results to Supabase');
          console.error('[Supabase Save] Status:', response.status, response.statusText);
          console.error('[Supabase Save] Error message:', errorMessage);
          if (errorDetails) {
            console.error('[Supabase Save] Full error details:', JSON.stringify(errorDetails, null, 2));
          }
          // Show error to user - this is critical for data persistence
          debugLog(` FAILED to save audit to Supabase: ${errorMessage}`, 'error');
          showStatus(` Audit completed but failed to save to Supabase: ${errorMessage}. Check console for details.`, 'error');
        }
      } catch (error) {
        // Show error to user - this is critical for data persistence
        debugLog(` Supabase save exception: ${error.message}`, 'error');
        console.error('[Supabase Save] Exception:', error);
        showStatus(` Failed to save audit to Supabase: ${error.message}. Check console for details.`, 'error');
      }
    }
    
    // Fetch historical Content/Schema data from Supabase
    // Forward-fill missing audit dates in history data (exclude last 3 days due to GSC lag)
    function forwardFillHistoryData(history, excludeLastDays = 3) {
      if (!history || history.length === 0) return history;
      
      // Sort by date
      const sorted = [...history].sort((a, b) => new Date(a.date) - new Date(b.date));
      
      // Calculate cutoff date (exclude last N days)
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - excludeLastDays);
      
      // Track last known values for each metric
      const lastValues = {};
      
      // Forward-fill missing values (but not for dates in the last N days)
      return sorted.map(entry => {
        const entryDate = new Date(entry.date);
        const isRecent = entryDate >= cutoffDate;
        
        // List of metric keys to forward-fill
        const metricKeys = [
          'contentSchemaScore', 'visibilityScore', 'authorityScore', 'localEntityScore', 'serviceAreaScore',
          'brandScore', 'moneyPagesBehaviourScore', 'shareOfImpressions', 'shareOfClicks', 'ctr',
          'authorityBehaviourScore', 'authorityRankingScore', 'authorityBacklinkScore', 'authorityReviewScore'
        ];
        
        const filled = { ...entry };
        
        for (const key of metricKeys) {
          const value = entry[key];
          
          // Only forward-fill if:
          // 1. Value is null/undefined (NOT 0, as 0 is a valid score) AND
          // 2. We have a last known value AND
          // 3. This is NOT a recent date (within last N days)
          if ((value == null || value === undefined) && lastValues[key] != null && !isRecent) {
            filled[key] = lastValues[key];
          } else if (value != null && value !== undefined) {
            // Update last known value (including 0, as it's a valid score)
            lastValues[key] = value;
          }
        }
        
        // Handle nested objects (e.g., moneyPagesSummary)
        if (entry.moneyPagesSummary) {
          filled.moneyPagesSummary = { ...entry.moneyPagesSummary };
          const summaryKeys = ['shareOfImpressions', 'shareOfClicks', 'ctr'];
          for (const key of summaryKeys) {
            const value = entry.moneyPagesSummary[key];
            if ((value == null || value === undefined) && lastValues[`summary_${key}`] != null && !isRecent) {
              filled.moneyPagesSummary[key] = lastValues[`summary_${key}`];
            } else if (value != null && value !== undefined) {
              lastValues[`summary_${key}`] = value;
            }
          }
        }
        
        return filled;
      });
    }
    
    async function fetchContentSchemaHistory(propertyUrl, startDate, endDate) {
      try {
        // Use window.apiUrl if available (for functions outside the main scope)
        const urlHelper = window.apiUrl || ((path) => {
          // Fallback: check if running locally and prepend Vercel URL
          const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
          const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
          if (!baseUrl) {
            return path.startsWith('/') ? path : `/${path}`;
          }
          const cleanPath = path.startsWith('/') ? path : `/${path}`;
          return `${baseUrl}${cleanPath}`;
        });
        const response = await fetch(urlHelper(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDate}&endDate=${endDate}`));
        
        if (response.ok) {
          const result = await response.json();
          if (result.status === 'ok' && result.data) {
            debugLog(` Fetched ${result.count} historical Content/Schema records from Supabase`, 'success');
            // Forward-fill missing audit dates (exclude last 3 days for GSC lag)
            const filledData = forwardFillHistoryData(result.data, 3);
            return filledData;
          }
          } else {
            // Read response body once as text, then try to parse as JSON to avoid "body stream already read" error
            debugLog(` Supabase API returned non-OK status: ${response.status} ${response.statusText}`, 'warn');
            try {
              const responseText = await response.text();
              try {
                const error = JSON.parse(responseText);
                debugLog(` Supabase API error: ${error.message || 'Unknown error'}`, 'warn');
              } catch (parseError) {
                debugLog(` Supabase API error (non-JSON): ${responseText || 'Unknown error'}`, 'warn');
              }
            } catch (textError) {
              debugLog(` Could not read Supabase error response: ${textError.message}`, 'warn');
            }
          }
      } catch (error) {
        debugLog(` Supabase fetch error: ${error.message}`, 'warn');
      }
      return [];
    }
    
    // Fetch the latest audit from Supabase
    async function fetchLatestAuditFromSupabase(propertyUrl, minimalOnly = false) {
      try {
        if (!propertyUrl) {
          debugLog(' Cannot fetch from Supabase: property URL not set', 'warn');
          return null;
        }
        
        // Use window.apiUrl if available (for functions outside the main scope)
        const urlHelper = window.apiUrl || ((path) => {
          // Fallback: check if running locally and prepend Vercel URL
          const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
          const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
          if (!baseUrl) {
            return path.startsWith('/') ? path : `/${path}`;
          }
          const cleanPath = path.startsWith('/') ? path : `/${path}`;
          return `${baseUrl}${cleanPath}`;
        });
        
        // Step 1: Try minimal request first to get timestamp (fast, unlikely to timeout)
        let minimalData = null;
        if (!minimalOnly) {
          debugLog(`Fetching minimal audit data (timestamp + scores) from Supabase for ${propertyUrl}...`, 'info');
          try {
            const minimalController = new AbortController();
            const minimalTimeout = setTimeout(() => minimalController.abort(), 10000); // 10 second timeout
            
            const minimalResponse = await fetch(urlHelper(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}&minimal=true`), {
              signal: minimalController.signal
            });
            clearTimeout(minimalTimeout);
            
            if (minimalResponse.ok) {
              const minimalResult = await minimalResponse.json();
              if (minimalResult.status === 'ok' && minimalResult.data && minimalResult.data.timestamp) {
                minimalData = minimalResult.data; // Store minimal data for fallback
                // Update timestamp immediately, even if full data fetch fails
                updateAuditTimestamp(minimalResult.data.timestamp);
                debugLog(` Updated audit timestamp from minimal Supabase response: ${new Date(minimalResult.data.timestamp).toLocaleString()}`, 'success');
              }
            }
          } catch (minimalError) {
            if (minimalError.name === 'AbortError') {
              debugLog(` Minimal request timed out (non-critical)`, 'warn');
            } else {
              debugLog(` Minimal request failed (non-critical): ${minimalError.message}`, 'warn');
            }
            // Continue to try full request
          }
        }
        
        // Step 2: Try full request (may timeout, but we already have timestamp)
        debugLog(`Fetching full audit data from Supabase for ${propertyUrl}...`, 'info');
        try {
          const fullController = new AbortController();
          const fullTimeout = setTimeout(() => fullController.abort(), 30000); // 30 second timeout
          
          const response = await fetch(urlHelper(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`), {
            signal: fullController.signal
          });
          clearTimeout(fullTimeout);
          
          if (response.ok) {
            const result = await response.json();
            debugLog(` Supabase API response: status=${result.status}, hasData=${!!result.data}`, result.status === 'ok' && result.data ? 'success' : 'warn');
            if (result.status === 'ok' && result.data) {
              debugLog(` Found latest audit from Supabase: ${result.data.auditDate || 'unknown date'}`, 'success');
              // Debug: Check what moneyPagesMetrics structure we got
              const hasMoneyPages = !!(result.data?.scores?.moneyPagesMetrics || result.data?.moneyPagesMetrics);
              debugLog(` Supabase data check: hasMoneyPagesMetrics=${hasMoneyPages}, structure=${result.data?.scores?.moneyPagesMetrics ? 'scores.moneyPagesMetrics' : result.data?.moneyPagesMetrics ? 'moneyPagesMetrics' : 'none'}`, 'info');
              if (hasMoneyPages) {
                const rows = result.data?.scores?.moneyPagesMetrics?.rows || result.data?.moneyPagesMetrics?.rows || [];
                debugLog(` Supabase moneyPagesMetrics has ${rows.length} rows`, 'success');
              } else {
                debugLog(` Supabase data missing moneyPagesMetrics!`, 'warn');
              }
              // Debug: Check queryTotals in response
              const hasQueryTotals = !!(result.data?.searchData?.queryTotals && Array.isArray(result.data.searchData.queryTotals));
              debugLog(` Supabase queryTotals check: hasSearchData=${!!result.data?.searchData}, hasQueryTotals=${hasQueryTotals}, length=${result.data?.searchData?.queryTotals?.length || 0}`, hasQueryTotals ? 'success' : 'warn');
              if (result.data.searchData) {
                debugLog(` Supabase searchData keys: ${Object.keys(result.data.searchData).join(', ')}`, 'info');
              } else {
                debugLog(` Supabase data missing searchData!`, 'warn');
              }
              // Ensure timestamp is set from Supabase data (use timestamp if available, otherwise construct from auditDate)
              if (result.data.timestamp) {
                // Convert to ISO string if it's a number (milliseconds since epoch)
                if (typeof result.data.timestamp === 'number') {
                  result.data.timestamp = new Date(result.data.timestamp).toISOString();
                }
                // Timestamp is already set (and now in ISO string format)
              } else if (result.data.auditDate) {
                // Construct timestamp from auditDate (use noon as default time to avoid timezone issues)
                const auditDateStr = result.data.auditDate;
                result.data.timestamp = new Date(auditDateStr + 'T12:00:00').toISOString();
                debugLog(` Constructed timestamp from auditDate: ${auditDateStr}`, 'info');
              }
              // Update timestamp display immediately when Supabase data is loaded
              if (result.data.timestamp) {
                updateAuditTimestamp(result.data.timestamp);
                debugLog(` Updated audit timestamp display from Supabase data`, 'success');
              }
              return result.data;
            } else {
              debugLog(` No audit found in Supabase - result.status=${result.status}, hasData=${!!result.data}, error=${result.message || 'none'}`, 'warn');
              // Return minimal data if available, otherwise null
              if (minimalData) {
                debugLog(` Returning minimal data (timestamp + scores) as fallback`, 'info');
                return minimalData;
              }
              return null;
            }
          } else {
            const responseText = await response.text();
            try {
              const error = JSON.parse(responseText);
              debugLog(` Could not fetch latest audit from Supabase: ${error.message || 'Unknown error'}`, 'warn');
              if (error.message && error.message.includes('FUNCTION_INVOCATION_FAILED')) {
                debugLog(` Full data fetch failed due to timeout/size. Returning minimal data (timestamp + scores) as fallback.`, 'warn');
                if (minimalData) {
                  return minimalData;
                }
              }
            } catch (parseError) {
              debugLog(` Could not fetch latest audit from Supabase: ${responseText || 'Unknown error'}`, 'warn');
            }
            // Return minimal data if available, otherwise null
            if (minimalData) {
              debugLog(` Returning minimal data (timestamp + scores) as fallback after full request failure`, 'info');
              return minimalData;
            }
            return null;
          }
        } catch (error) {
          if (error.name === 'AbortError' || error.name === 'TimeoutError' || error.message.includes('timeout')) {
            debugLog(` Supabase fetch timed out. Returning minimal data (timestamp + scores) as fallback.`, 'warn');
            if (minimalData) {
              return minimalData;
            }
          } else {
            debugLog(` Supabase fetch error: ${error.message}`, 'warn');
          }
          // Return minimal data if available, otherwise null
          if (minimalData) {
            debugLog(` Returning minimal data (timestamp + scores) as fallback after error`, 'info');
            return minimalData;
          }
          return null;
        }
      } catch (outerError) {
        // Catch any errors in the outer try block (shouldn't happen, but just in case)
        debugLog(` Outer error in fetchLatestAuditFromSupabase: ${outerError.message}`, 'warn');
        if (minimalData) {
          return minimalData;
        }
        return null;
      }
    }
    
    // Update retry button visibility based on failed URLs
    function updateRetryButtonVisibility(schemaAudit) {
      const retryBtn = document.getElementById('retryFailedUrlsBtn');
      if (!retryBtn) return;
      
      if (schemaAudit && schemaAudit.data && schemaAudit.data.missingSchemaPages) {
        const failedUrls = schemaAudit.data.missingSchemaPages.filter(p => p.error);
        if (failedUrls.length > 0) {
          retryBtn.style.display = 'inline-block';
          retryBtn.textContent = ` Retry Failed URLs (${failedUrls.length})`;
        } else {
          retryBtn.style.display = 'none';
        }
      } else {
        retryBtn.style.display = 'none';
      }
    }

    // Close completion modal
    function closeCompletionModal() {
      const modal = document.getElementById('completionModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    // Close modal when clicking outside
    window.onclick = function(event) {
      const modal = document.getElementById('completionModal');
      if (event.target === modal) {
        closeCompletionModal();
      }
    }

    // Calculate RAG status from score
    function getRAGStatus(score) {
      if (score >= 70) return { status: 'green', label: 'Green' };
      if (score >= 40) return { status: 'amber', label: 'Amber' };
      return { status: 'red', label: 'Red' };
    }

    // Helper: clamp score to 0-100 and round
    function clampScore(value) {
      return Math.max(0, Math.min(100, Math.round(value)));
    }

    // Calculate pillar scores (deterministic, based on GSC data and schema audit)
    
    // Page Segment Classifier
    // NOTE: PageSegment classification is derived from the canonical site-urls CSV.
    // GSC page URLs are matched by path against this inventory and then classified by
    // classifyPageSegment(...) to keep behaviour/ranking segments aligned with the UI.
    const PageSegment = {
      EDUCATION: 'education',
      MONEY: 'money',
      SUPPORT: 'support',
      SYSTEM: 'system'
    };
    
    /**
     * Canonicalize URL - removes query params, fragments, normalizes trailing slashes
     * Returns full URL with origin and path only (no query/hash)
     * @param {string} raw - Raw URL (may contain query params, fragments)
     * @returns {string} Canonical URL
     */
    function canonicalizeUrl(raw) {
      if (!raw) return "";
      
      try {
        const u = raw.startsWith("http") ? new URL(raw) : new URL(raw, "https://www.alanranger.com");
        let path = u.pathname || "/";
        if (path.length > 1) path = path.replace(/\/+$/, "");
        return `${u.origin}${path}`;
      } catch {
        const noHash = raw.split("#")[0];
        const noQuery = noHash.split("?")[0];
        return (noQuery.replace(/\/+$/, "") || raw).trim();
      }
    }
    
    function normalisePath(rawUrlOrPath) {
      try {
        let url;
        if (rawUrlOrPath && rawUrlOrPath.startsWith('http')) {
          url = new URL(rawUrlOrPath);
        } else {
          url = new URL(rawUrlOrPath || '/', 'https://www.alanranger.com');
        }
        let p = url.pathname.toLowerCase();
        if (p.length > 1 && p.endsWith('/')) p = p.slice(0, -1);
        return p;
      } catch {
        return '/';
      }
    }
    
    function isFineArtGalleryPage(path) {
      const p = path.toLowerCase();
      // Explicit known fine-art URLs from 06-site-urls.csv
      if (
        p === '/fine-art-prints' ||
        p === '/photography-services-near-me/fine-art-photography-prints-unframed' ||
        p === '/photography-services-near-me/framed-fine-art-photography-prints' ||
        p === '/photography-services-near-me/fine-art-photography-prints-canvas'
      ) {
        return true;
      }
      // Safety net: treat any future fine-art print variants as gallery/info too
      return (
        p.includes('fine-art-prints') ||
        p.includes('fine-art-photography-prints')
      );
    }
    
    function classifyPageSegment(rawUrlOrPath, title = null, kindOverride = null) {
      const path = normalisePath(rawUrlOrPath);
      
      // Manual overrides via CSV column
      if (kindOverride) {
        const v = kindOverride.toLowerCase().trim();
        if (v === 'education' || v === 'educational') return PageSegment.EDUCATION;
        if (v === 'money' || v === 'commercial') return PageSegment.MONEY;
        if (v === 'support') return PageSegment.SUPPORT;
        if (v === 'system') return PageSegment.SYSTEM;
      }
      
      // Education  all blogs + free course + calculator + tips hub
      // EXCLUDE blog posts from money pages (check both /blog-on-photography/ and /blogs/)
      if (path.startsWith('/blog-on-photography/') || path.startsWith('/blogs/')) return PageSegment.EDUCATION;
      if (
        path === '/blog-on-photography' ||
        path === '/blogs' ||
        path === '/free-online-photography-course' ||
        path === '/outdoor-photography-exposure-calculator' ||
        path === '/free-photography-tips' ||
        path === '/photography-news-blog'
      ) {
        return PageSegment.EDUCATION;
      }
      
      // Fine-art gallery pages  portfolio/informational, NOT money pages
      // These must be checked BEFORE money classification
      if (isFineArtGalleryPage(path)) return PageSegment.SYSTEM;
      
      // Support pages (must be checked before money classification)
      const SUPPORT_EXACT = new Set([
        '/', '/about-alan-ranger', '/testimonials-customer-reviews', '/awards-and-qualifications',
        '/gallery-image-portfolios', '/help-site-map', '/help-portrait-uk-coventry',
        '/photography-equipment-recommendations', '/newsletter-signup-form',
        '/which-photography-style-is-right-for-you', '/contact-us',
      ]);
      if (SUPPORT_EXACT.has(path)) return PageSegment.SUPPORT;
      
      // Money pages = Events + Products + Landing pages (excluding blog posts)
      // Events: URLs starting with specific paths (check both with and without trailing slash)
      if (path.startsWith('/beginners-photography-lessons/') || 
          path.startsWith('/beginners-photography-lessons') ||
          path.startsWith('/photographic-workshops-near-me/') ||
          path.startsWith('/photographic-workshops-near-me')) {
        return PageSegment.MONEY;
      }
      
      // Products: URLs starting with specific paths (check both with and without trailing slash)
      if (path.startsWith('/photo-workshops-uk/') || 
          path.startsWith('/photo-workshops-uk') ||
          path.startsWith('/photography-services-near-me/') ||
          path.startsWith('/photography-services-near-me')) {
        return PageSegment.MONEY;
      }
      
      // Legacy exact matches for money pages (keep for backward compatibility)
      const MONEY_EXACT = new Set([
        '/photography-workshops', '/photography-workshops-near-me', '/photography-workshops-uk',
        '/landscape-photography-workshops', '/outdoor-photography-workshops',
        '/photographic-workshops-near-me', '/photographic-workshops-uk',
        '/photography-courses-coventry', '/course-finder-photography-classes-near-me',
        '/photography-tuition-services', '/photography-services-near-me', '/photography-shop-services',
        '/rps-courses-mentoring-distinctions', '/hire-a-professional-photographer-in-coventry',
        '/professional-commercial-photographer-coventry', '/professional-photographer-near-me',
        '/coventry-photographer', '/photographer-in-coventry', '/photography-mentoring-programme',
        '/photography-academy-membership', '/photography-academy', '/photography-session-vouchers',
        '/photography-gift-vouchers', '/photography-presents-for-photographers',
        '/batsford-arboretum-photography', '/bluebell-woods-near-me',
      ]);
      if (MONEY_EXACT.has(path)) return PageSegment.MONEY;
      
      // Landing pages: Everything else that's NOT blog posts, education, support, or system
      // Default to MONEY (landing page) if it's not a blog post and doesn't match other categories
      // This ensures all non-blog pages are treated as money pages (landing pages) by default
      // Only exclude fine-art gallery pages from being money pages
      if (!isFineArtGalleryPage(path)) {
        // If we've gotten here, it's not education, support, system, or fine-art
        // So it must be a money page (landing page)
        return PageSegment.MONEY;
      }
      
      // Everything else = system (only fine-art gallery pages should reach here)
      return PageSegment.SYSTEM;
    }
    
    /**
     * Shared classification function for Ranking & AI tab
     * Returns both segment (Brand/Education/Money/Other) and pageType (Landing/Blog/Event/Product/GBP)
     * Uses canonical classification from Money Pages logic
     * @param {string} rawUrlOrPath - URL or path to classify
     * @param {string} keyword - Optional keyword for brand detection
     * @returns {{segment: string, pageType: string}}
     */
    function classifyUrlForRankingAi(rawUrlOrPath, keyword = null) {
      // Normalize URL to lowercase for consistent matching
      const urlLower = (rawUrlOrPath || "").toLowerCase();
      const path = normalisePath(rawUrlOrPath);
      
      // Brand detection: check keyword first
      if (keyword) {
        const kw = (keyword || "").toLowerCase();
        if (kw.includes("alan ranger") || kw.includes("alanranger")) {
          return { segment: "Brand", pageType: "GBP" };
        }
      }
      
      // If URL is missing/blank, return Other
      if (!rawUrlOrPath || !path) {
        return { segment: "Other", pageType: "Other" };
      }
      
      // STEP 1: Check Event pages FIRST (before Blog/GBP/Landing)
      // Event if URL contains:
      // - alanranger.com/beginners-photography-lessons/
      // - alanranger.com/photographic-workshops-near-me
      if (urlLower.includes('/beginners-photography-lessons') ||
          urlLower.includes('/photographic-workshops-near-me')) {
        return { segment: "Money", pageType: "Event" };
      }
      
      // STEP 2: Check Product pages (before Blog/GBP/Landing)
      // Product if URL contains:
      // - alanranger.com/photo-workshops-uk/
      // - alanranger.com/photography-services-near-me/
      if (urlLower.includes('/photo-workshops-uk') ||
          urlLower.includes('/photography-services-near-me')) {
        return { segment: "Money", pageType: "Product" };
      }
      
      // STEP 3: Check for Blog pages (Education segment)
      if (path.startsWith('/blog-on-photography/') || path.startsWith('/blogs/')) {
        return { segment: "Education", pageType: "Blog" };
      }
      
      // STEP 4: Check for GBP/Home/About pages (Brand segment)
      if (path === '/' ||
          path === '/about-alan-ranger' ||
          path.includes('/contact') ||
          path.includes('/reviews')) {
        return { segment: "Brand", pageType: "GBP" };
      }
      
      // STEP 5: Use canonical page classification for remaining pages
      // Try window.classifyMoneyPage first (if available), then fallback to local scope
      let isMoney = false;
      let segmentType = null;
      
      const classifyMoneyPageFn = (typeof window !== 'undefined' && window.classifyMoneyPage)
        ? window.classifyMoneyPage
        : (typeof classifyMoneyPage !== 'undefined' ? classifyMoneyPage : null);
      
      if (classifyMoneyPageFn) {
        try {
          const result = classifyMoneyPageFn(rawUrlOrPath);
          isMoney = result.isMoney;
          segmentType = result.segmentType;
        } catch (e) {
          const segment = classifyPageSegment(rawUrlOrPath);
          isMoney = segment === PageSegment.MONEY;
          segmentType = isMoney ? 'landing' : null;
        }
      } else {
        const segment = classifyPageSegment(rawUrlOrPath);
        isMoney = segment === PageSegment.MONEY;
        segmentType = isMoney ? 'landing' : null;
        if (window.DEBUG_MODE) {
          debugLog(' classifyMoneyPage not available, using fallback classification', 'warn');
        }
      }
      
      // Determine pageType from canonical segmentType (for remaining pages)
      let pageType = "Landing"; // Default
      if (segmentType === "event") {
        pageType = "Event";
      } else if (segmentType === "product") {
        pageType = "Product";
      } else if (segmentType === "landing" || segmentType === "all") {
        pageType = "Landing";
      } else if (isMoney) {
        pageType = "Landing";
      } else {
        pageType = "Other";
      }
      
      // Determine segment from pageType and canonical classification
      let segment = "Other"; // Default
      
      // Brand: home page, about, contact, reviews, or brand keywords
      if (pageType === "GBP" || path === '/' || path === '/about-alan-ranger') {
        segment = "Brand";
      }
      // Money: Landing, Event, or Product page types
      else if (pageType === "Landing" || pageType === "Event" || pageType === "Product") {
        segment = "Money";
      }
      // Education: Blog pages or free course/educational content
      else if (pageType === "Blog" || 
               path === '/free-online-photography-course' ||
               path === '/outdoor-photography-exposure-calculator' ||
               path === '/free-photography-tips') {
        segment = "Education";
      }
      // Everything else is Other
      
      return { segment, pageType };
    }
    
    // Make available globally for RankingAiModule
    if (typeof window !== 'undefined') {
      window.classifyUrlForRankingAi = classifyUrlForRankingAi;
    }
    
    // Helper functions for Authority score calculation
    function normalisePct(value, max) {
      // value in 0-1 range; scale to 0-100 and cap
      const pct = Math.max(0, Math.min(1, value / max));
      return pct * 100;
    }

    function normalisePosition(pos, minPos, maxPos) {
      // map [minPos..maxPos] -> [100..10], clamp outside range
      const clamped = Math.max(minPos, Math.min(maxPos, pos));
      const t = (clamped - minPos) / (maxPos - minPos); // 0..1
      return 100 - t * 90; // 100 at best, 10 at worst
    }

    // Raw Behaviour score calculation (internal, used by segmented version)
    // ============================================================================
    // PHASE 1: Brand Overlay Metrics
    // ============================================================================
    
    /**
     * @typedef {Object} BrandOverlay
     * @property {number} score - 0-100
     * @property {'Weak'|'Developing'|'Strong'} label
     * @property {number} brandQueryShare - 0-1, impressions share
     * @property {number} brandCtr - 0-1
     * @property {number} brandAvgPosition - numeric position
     * @property {number} reviewScore - 0-100, from existing review metrics
     * @property {number} entityScore - 0-100, based on knowledge panel / GBP presence
     * @property {string[]} notes - short machine-generated reasons for the label
     */
    
    /**
     * @typedef {Object} AiSummaryLikelihood
     * @property {number} score - 0-100 composite
     * @property {'Low'|'Medium'|'High'} label
     * @property {string[]} reasons - short bullets used in UI tooltip / priorities
     */
    
    /**
     * @typedef {"LOW" | "MEDIUM" | "HIGH"} PriorityLevel
     */
    
    /**
     * @typedef {"LOW" | "MEDIUM" | "HIGH"} ImpactLevel
     */
    
    /**
     * @typedef {"LOW" | "MEDIUM" | "HIGH"} DifficultyLevel
     */
    
    /**
     * @typedef {"all" | "landing" | "event" | "product"} MoneySegmentKey
     */
    
    /**
     * @typedef {Object} MoneyPageMetrics
     * @property {string} url
     * @property {string} title
     * @property {MoneySegmentKey} segmentType       // landing / event / product / (fallback "all")
     * @property {number} clicks
     * @property {number} impressions
     * @property {number} ctr                        // 01 decimal
     * @property {number} avgPosition
     * @property {ImpactLevel} impactLevel
     * @property {DifficultyLevel} difficultyLevel
     * @property {PriorityLevel} priorityLevel
     * @property {number} [_lostClicks]              // Internal: calculated lost clicks
     */
    
    /**
     * Per audit, stored for history in Supabase.
     *
     * @typedef {Object} MoneySegmentSummary
     * @property {number} clicks
     * @property {number} impressions
     * @property {number} ctr           // 01 decimal
     * @property {number} avgPosition
     * @property {number} behaviourScore
     */
    
    /**
     * @typedef {Object} MoneySegmentMetricsByAudit
     * @property {MoneySegmentSummary} allMoney
     * @property {MoneySegmentSummary} landingPages
     * @property {MoneySegmentSummary} eventPages
     * @property {MoneySegmentSummary} productPages
     */
    
    // Brand query classification
    const BRAND_TERMS = ['alan ranger', 'alanranger', 'alan ranger photography'];
    
    /**
     * Check if a query is a brand query
     * @param {string} query - Search query text
     * @returns {boolean}
     */
    function isBrandQuery(query) {
      if (!query || typeof query !== 'string') return false;
      const q = query.toLowerCase();
      return BRAND_TERMS.some(term => q.includes(term));
    }
    
    /**
     * Calculate brand metrics from GSC query data
     * @param {Array} queries - Array of query objects with {query, clicks, impressions, position}
     * @returns {Object} Brand metrics {brandQueryShare, brandCtr, brandAvgPosition}
     */
    function calculateBrandMetrics(queries) {
      if (!queries || !Array.isArray(queries) || queries.length === 0) {
        return {
          brandQueryShare: 0,
          brandCtr: 0,
          brandAvgPosition: null
        };
      }
      
      // Filter to ranking queries (position 1-20, with impressions)
      const ranking = queries.filter(q => {
        const pos = q.position || 0;
        const impr = q.impressions || 0;
        return pos > 0 && pos <= 20 && impr > 0;
      });
      
      if (ranking.length === 0) {
        return {
          brandQueryShare: 0,
          brandCtr: 0,
          brandAvgPosition: null
        };
      }
      
      // Split into brand vs non-brand
      const brandQueries = ranking.filter(q => isBrandQuery(q.query || ''));
      const nonBrandQueries = ranking.filter(q => !isBrandQuery(q.query || ''));
      
      // Calculate totals
      const totalImpressions = ranking.reduce((s, q) => s + (q.impressions || 0), 0);
      const brandImpressions = brandQueries.reduce((s, q) => s + (q.impressions || 0), 0);
      const brandClicks = brandQueries.reduce((s, q) => s + (q.clicks || 0), 0);
      
      // Brand query share (0-1)
      const brandQueryShare = totalImpressions > 0 ? brandImpressions / totalImpressions : 0;
      
      // Brand CTR (0-1)
      const brandCtr = brandImpressions > 0 ? brandClicks / brandImpressions : 0;
      
      // Brand average position (weighted by impressions)
      const brandAvgPosition = brandImpressions > 0
        ? brandQueries.reduce((s, q) => s + (q.position || 0) * (q.impressions || 0), 0) / brandImpressions
        : null;
      
      return {
        brandQueryShare,
        brandCtr,
        brandAvgPosition
      };
    }
    
    /**
     * Normalize position to 0-100 score (for brand overlay)
     * @param {number|null} pos - Position value
     * @param {number} minPos - Minimum position (default 1)
     * @param {number} maxPos - Maximum position (default 10)
     * @returns {number} Score 0-100
     */
    function normalisePositionForBrand(pos, minPos = 1, maxPos = 10) {
      if (pos == null) return 0;
      const clamped = Math.max(minPos, Math.min(maxPos, pos));
      const t = (clamped - minPos) / (maxPos - minPos); // 0..1
      return 100 - t * 100;
    }
    
    /**
     * Compute Brand Overlay score
     * @param {Object} args - Brand overlay parameters
     * @param {number} args.brandQueryShare - 0-1, impressions share
     * @param {number} args.brandCtr - 0-1
     * @param {number|null} args.brandAvgPosition - numeric position
     * @param {number} args.reviewScore - 0-100, from existing Authority review score
     * @param {number} args.entityScore - 0-100, from Local Entity pillar
     * @returns {BrandOverlay}
     */
    function computeBrandOverlay(args) {
      const {
        brandQueryShare = 0,
        brandCtr = 0,
        brandAvgPosition = null,
        reviewScore = 0,
        entityScore = 0
      } = args;
      
      // Brand search component
      const shareScore = Math.min(brandQueryShare / 0.30, 1) * 100; // 30%+ share = 100
      const ctrScore = Math.min(brandCtr / 0.40, 1) * 100; // 40%+ CTR = 100
      const posScore = normalisePositionForBrand(brandAvgPosition, 1, 10);
      
      const brandSearchScore =
        0.4 * shareScore +
        0.3 * ctrScore +
        0.3 * posScore;
      
      // Combine with review + entity strength
      const combined =
        0.4 * brandSearchScore +
        0.3 * reviewScore +
        0.3 * entityScore;
      
      let label;
      if (combined < 40) label = 'Weak';
      else if (combined < 70) label = 'Developing';
      else label = 'Strong';
      
      const notes = [];
      if (brandQueryShare < 0.1) notes.push('Low share of branded searches in GSC.');
      if (brandCtr < 0.25) notes.push('Branded CTR is below 25%.');
      if (brandAvgPosition == null || brandAvgPosition > 5)
        notes.push('Branded queries do not consistently rank in top-5.');
      if (reviewScore < 70) notes.push('Review rating / volume is still maturing.');
      if (entityScore < 70) notes.push('Knowledge-panel / entity coverage could be stronger.');
      
      return {
        score: Math.round(combined),
        label,
        brandQueryShare,
        brandCtr,
        brandAvgPosition: brandAvgPosition ?? 0,
        reviewScore,
        entityScore,
        notes
      };
    }
    
    /**
     * Compute AI Summary Likelihood
     * @param {number} snippetReadinessScore - Existing donut score
     * @param {number} visibilityScore - Current Visibility pillar score
     * @param {number} brandScore - Brand overlay score
     * @returns {AiSummaryLikelihood}
     */
    function computeAiSummaryLikelihood(snippetReadinessScore, visibilityScore, brandScore) {
      const composite =
        0.5 * snippetReadinessScore +
        0.3 * visibilityScore +
        0.2 * brandScore;
      
      // Use same RAG bands as GAIO Score: 70 High (green), 50 Medium (amber), <50 Low (red)
      let label;
      if (composite < 50) label = 'Low';
      else if (composite < 70) label = 'Medium';
      else label = 'High';
      
      const reasons = [];
      
      if (snippetReadinessScore < 70)
        reasons.push('Improve FAQ/HowTo/Article blocks and schema to raise snippet readiness.');
      if (visibilityScore < 70)
        reasons.push('Improve average position and top-10 impression share.');
      if (brandScore < 70)
        reasons.push('Strengthen branded search and entity signals.');
      
      return {
        score: Math.round(composite),
        label,
        reasons
      };
    }
    
    // ============================================================================
    // End Phase 1: Brand Overlay Metrics
    // ============================================================================

    function computeBehaviourScoreRaw(queries) {
      if (!queries || !Array.isArray(queries) || queries.length === 0) {
        return 50; // neutral fallback
      }

      // Filter to ranking queries (position > 0, <= 20, with impressions)
      const ranking = queries.filter(q => q.position > 0 && q.position <= 20 && q.impressions > 0);

      if (ranking.length === 0) {
        return 50; // neutral fallback
      }

      // Calculate CTR for all ranking queries
      const totalClicks = ranking.reduce((s, q) => s + q.clicks, 0);
      const totalImpr = ranking.reduce((s, q) => s + q.impressions, 0);
      const ctrAll = totalImpr > 0 ? totalClicks / totalImpr : 0; // 0-1

      // Calculate CTR for top-10 queries
      const top10 = ranking.filter(q => q.position <= 10);
      const top10Clicks = top10.reduce((s, q) => s + q.clicks, 0);
      const top10Impr = top10.reduce((s, q) => s + q.impressions, 0);
      const ctrTop10 = top10Impr > 0 ? top10Clicks / top10Impr : ctrAll;

      // Normalize CTR scores: 5% CTR = 100 for all ranking, 10% CTR = 100 for top-10
      // ctrAll 0-5%  0-100 (values >5% capped at 100)
      // ctrTop10 0-10%  0-100 (values >10% capped at 100)
      const ctrScoreAll = normalisePct(ctrAll, 0.05); // 5% overall CTR -> 100
      const ctrScoreTop10 = normalisePct(ctrTop10, 0.10); // 10% top-10 CTR -> 100

      // Combine: 50% ctrAll + 50% ctrTop10
      return 0.5 * ctrScoreAll + 0.5 * ctrScoreTop10; // 0-100
    }
    
    // Public Behaviour score (backward compatible, uses all queries)
    function computeBehaviourScore(queries) {
      return computeBehaviourScoreRaw(queries);
    }
    
    // Segmented Behaviour score calculation
    // queryPages: Array of {query, page, clicks, impressions, ctr, position}
    // Returns: {all, nonBlog, money}
    function computeBehaviourScoreWithSegment(queryPages) {
      if (!queryPages || !Array.isArray(queryPages) || queryPages.length === 0) {
        return { all: 50, nonBlog: 50, money: 50 };
      }
      
      // Classify each query+page row by page segment
      const withSegment = queryPages.map(row => {
        const segment = classifyPageSegment(row.page || row.url || '/');
        return { ...row, __segment: segment };
      });
      
      // Convert to format expected by computeBehaviourScoreRaw
      const toQueryFormat = (rows) => rows.map(r => ({
        clicks: r.clicks || 0,
        impressions: r.impressions || 0,
        ctr: (r.ctr || 0) / 100, // Convert percentage to decimal
        position: r.position || 0
      }));
      
      // All queries
      const all = computeBehaviourScoreRaw(toQueryFormat(withSegment));
      
      // Non-blog (exclude education)
      const nonBlog = computeBehaviourScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment !== PageSegment.EDUCATION))
      );
      
      // Money pages only
      const money = computeBehaviourScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment === PageSegment.MONEY))
      );
      
      return { all, nonBlog, money };
    }

    // Raw Ranking score calculation (internal, used by segmented version)
    function computeRankingScoreRaw(queries) {
      if (!queries || !Array.isArray(queries) || queries.length === 0) {
        return 50; // neutral fallback
      }

      // Filter to ranking queries (position > 0, <= 20, with impressions)
      const ranking = queries.filter(q => q.position > 0 && q.position <= 20 && q.impressions > 0);

      if (ranking.length === 0) {
        return 50; // neutral fallback
      }

      // Calculate impression-weighted average position
      const totalImpr = ranking.reduce((s, q) => s + q.impressions, 0);
      const avgPos = totalImpr > 0
        ? ranking.reduce((s, q) => s + q.position * q.impressions, 0) / totalImpr
        : 0;

      // Map position: 1  100, 20  0 (clamped)
      const clampedPos = Math.max(1, Math.min(20, avgPos));
      const posScore = normalisePosition(clampedPos, 1, 20); // 0-100

      // Calculate top-10 impression share (% of impressions where position  10)
      const top10Impr = ranking
        .filter(q => q.position <= 10)
        .reduce((s, q) => s + q.impressions, 0);
      const top10Share = totalImpr > 0 ? top10Impr / totalImpr : 0; // 0-1
      const top10Score = top10Share * 100; // 0-100 (as a percentage)

      // Combine: 50% posScore + 50% top10Score
      return 0.5 * posScore + 0.5 * top10Score; // 0-100
    }
    
    // Public Ranking score (backward compatible, uses all queries)
    function computeRankingScore(queries) {
      return computeRankingScoreRaw(queries);
    }
    
    // Segmented Ranking score calculation
    // queryPages: Array of {query, page, clicks, impressions, ctr, position}
    // Returns: {all, nonBlog, money}
    function computeRankingScoreWithSegment(queryPages) {
      if (!queryPages || !Array.isArray(queryPages) || queryPages.length === 0) {
        return { all: 50, nonBlog: 50, money: 50 };
      }
      
      // Classify each query+page row by page segment
      const withSegment = queryPages.map(row => {
        const segment = classifyPageSegment(row.page || row.url || '/');
        return { ...row, __segment: segment };
      });
      
      // Convert to format expected by computeRankingScoreRaw
      const toQueryFormat = (rows) => rows.map(r => ({
        clicks: r.clicks || 0,
        impressions: r.impressions || 0,
        ctr: (r.ctr || 0) / 100, // Convert percentage to decimal
        position: r.position || 0
      }));
      
      // All queries
      const all = computeRankingScoreRaw(toQueryFormat(withSegment));
      
      // Non-blog (exclude education)
      const nonBlog = computeRankingScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment !== PageSegment.EDUCATION))
      );
      
      // Money pages only
      const money = computeRankingScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment === PageSegment.MONEY))
      );
      
      return { all, nonBlog, money };
    }

    function computeReviewScore(opts) {
      const {
        gbpRating = null,
        gbpCount = null,
        siteRating = null,
        siteCount = null
      } = opts || {};

      // Check if sources have valid data (not null, not 0, not undefined)
      const hasGBP = (gbpRating !== null && gbpRating !== undefined && gbpRating > 0) || 
                     (gbpCount !== null && gbpCount !== undefined && gbpCount > 0);
      const hasSite = (siteRating !== null && siteRating !== undefined && siteRating > 0) || 
                      (siteCount !== null && siteCount !== undefined && siteCount > 0);

      // If neither source exists, return neutral default
      if (!hasGBP && !hasSite) {
        debugLog('Review Score: No review data available (GBP or site), using neutral default (50)', 'warn');
        return 50;
      }

      const maxCount = 500; // cap so a few extra reviews don't blow up score

      let reviewScore;

      if (hasGBP && hasSite) {
        // Both sources exist: 60% GBP + 40% site
        const gbpRatingScore = ((gbpRating || 0) / 5) * 100;
        const gbpCountScore = Math.min((gbpCount || 0) / maxCount, 1) * 100;
        const gbpScore = 0.6 * gbpRatingScore + 0.4 * gbpCountScore;

        const siteRatingScore = ((siteRating || 0) / 5) * 100;
        const siteCountScore = Math.min((siteCount || 0) / maxCount, 1) * 100;
        const siteScore = 0.6 * siteRatingScore + 0.4 * siteCountScore;

        reviewScore = 0.6 * gbpScore + 0.4 * siteScore;
      } else if (hasGBP) {
        // Only GBP exists: 100% GBP
        const gbpRatingScore = ((gbpRating || 0) / 5) * 100;
        const gbpCountScore = Math.min((gbpCount || 0) / maxCount, 1) * 100;
        reviewScore = 0.6 * gbpRatingScore + 0.4 * gbpCountScore;
      } else {
        // Only site reviews exist: 100% site
        const siteRatingScore = ((siteRating || 0) / 5) * 100;
        const siteCountScore = Math.min((siteCount || 0) / maxCount, 1) * 100;
        reviewScore = 0.6 * siteRatingScore + 0.4 * siteCountScore;
      }

      return clampScore(reviewScore);
    }

    /**
     * Compute Backlink Score from backlink metrics
     * @param {Object|undefined} m - Backlink metrics object with referringDomains, totalBacklinks, followRatio
     * @returns {number} Score 0-100
     */
    function computeBacklinkScore(m) {
      if (!m) {
        // If metrics not present at all, return 0 (no backlink data)
        return 0;
      }

      const rd = m.referringDomains ?? 0;
      // If followRatio is missing, it means data integrity issue - log warning and use 0
      const fb = m.followRatio ?? (() => {
        debugLog(' Backlink metrics missing followRatio - data integrity issue', 'warn');
        return 0;
      })();

      // If no backlinks at all, score is 0
      if (rd === 0 && (m.totalBacklinks ?? 0) === 0) {
        return 0;
      }

      // Referring domains score: 100+ domains = max score (100)
      const rdScore = Math.min(rd / 100, 1) * 100;
      
      // Follow ratio score: clamp 0-1  0-100
      const followScore = Math.max(0, Math.min(fb, 1)) * 100;

      // Combined: 70% referring domains, 30% follow ratio
      const score = 0.7 * rdScore + 0.3 * followScore;
      
      return Math.round(clampScore(score));
    }

    // Helper function to always return correct Trustpilot snapshot values
    // This ensures we never use old cached values (4.80, 127) - always use (4.6, 610)
    function getTrustpilotSnapshot(siteReviews = null) {
      const TRUSTPILOT_SNAPSHOT = {
        siteRating: 4.6,
        siteReviewCount: 610,
        lastUpdated: '2025-12-07',
        notes: 'Fixed Trustpilot snapshot for Authority score calculation. Update manually when Trustpilot metrics change significantly.'
      };
      
      // Always return the correct snapshot, regardless of input
      if (!siteReviews || siteReviews.siteRating !== 4.6 || siteReviews.siteReviewCount !== 610) {
        return TRUSTPILOT_SNAPSHOT;
      }
      return siteReviews;
    }

    // Helper function to get color for score (same thresholds as main pillars)
    function getScoreColor(score) {
      if (score >= 70) return { color: '#10b981', label: 'Green', bg: '#d1fae5' }; // Green
      if (score >= 40) return { color: '#f59e0b', label: 'Amber', bg: '#fef3c7' }; // Amber
      return { color: '#ef4444', label: 'Red', bg: '#fee2e2' }; // Red
    }

    // Helper function to get tooltip text for each component
    function getComponentTooltip(label) {
      const tooltips = {
        // Authority components
        'Behaviour': 'Overall CTR Score (50% weight) + Top-10 Ranked Search Terms CTR Score (50% weight). Measures CTR for all ranking search terms vs. search terms ranking in positions 1-10. Indicates how well your titles/descriptions convert impressions to clicks.',
        'Ranking': 'Average Position Score (50% weight) + Top-10 Impression Share (50% weight). Measures how high you rank on average and what percentage of impressions appear in positions 1-10.',
        'Backlinks': 'Referring Domains Score (70% weight) + Follow Ratio Score (30% weight). Measures domain authority from external links.',
        'Reviews': 'Google Business Profile Reviews (60% weight if both exist) + Trustpilot Reviews (40% weight if both exist). Each source combines rating (60%) and count (40%). Measures trust signals from customer reviews.',
        // Content/Schema components
        'Foundation': 'Foundation Schemas (30% weight): Presence of Organization, Person, WebSite, and BreadcrumbList schemas. These core schemas establish your entity identity and site structure for AI systems.',
        'Rich Results': 'Rich Result Eligibility (35% weight): Count of eligible rich result types (Article, Event, FAQPage, Product, LocalBusiness, Course, Review, HowTo, VideoObject, ImageObject, ItemList). More types = better AI understanding.',
        'Coverage': 'Schema Coverage (20% weight): Percentage of pages with structured data markup. Higher coverage means more pages are machine-readable.',
        'Diversity': 'Type Diversity (15% weight): Number of unique schema types detected across your domain. More diverse types indicate richer structured data.',
        // Visibility components
        'Position': 'Average Position Score: Derived from Google Search Console average position (1-40 scale). Better positions (lower numbers) = higher score. Measures how prominently your content appears in search results.',
        'CTR': 'Click-Through Rate Score: Derived from Google Search Console CTR percentage. Higher CTR indicates better title/description effectiveness and user engagement.',
        // Local Entity components
        'NAP Consistency': 'Name, Address, Phone consistency score (0-100%). Measures how consistently your business information appears across Google Business Profile. Higher consistency improves entity recognition.',
        'Knowledge Panel': 'Knowledge Panel Detection: Whether Google has detected and displays a knowledge panel for your entity. Indicates strong entity recognition by AI systems.',
        'Locations': 'Location Count: Number of physical locations listed in Google Business Profile. Having at least one location improves local entity recognition.',
        // Service Area components
        'Service Areas': 'Service Area Count: Number of service areas defined in Google Business Profile. More service areas (8+) indicate broader geographic coverage and better AI understanding of your operational regions.',
        'NAP Consistency': 'Name, Address, Phone consistency score (0-100%). Measures how consistently your business information appears across Google Business Profile. Higher consistency improves service area recognition.'
      };
      return tooltips[label] || '';
    }

    // Helper function to format component score with color, scale indicator, and tooltip
    function formatComponentScore(label, score) {
      const rounded = Math.round(score);
      const colorInfo = getScoreColor(rounded);
      const tooltip = getComponentTooltip(label);
      return `
        <div style="display: flex; align-items: center; gap: 0.5rem;">
          <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background-color: ${colorInfo.color};"></span>
          <span style="color: #666; position: relative; cursor: help; border-bottom: 1px dotted #999;" title="${tooltip}">${label}:</span>
          <strong style="color: ${colorInfo.color};">${rounded}</strong>
          <span style="color: #999; font-size: 0.75em;">/100</span>
        </div>
      `;
    }

    async function calculatePillarScores(data, schemaAudit = null, localSignals = null, siteReviews = null, backlinkMetrics = null) {
      // Use new API response format - get values from GSC overview
      const position = data.averagePosition || 40; // 1 (best) - 100 (worst)
      const ctr = data.ctr || 0; // 0-100 percentage from API (e.g., 10 = 10%)
      const topQueries = data.topQueries || []; // Array of query objects with clicks, impressions, ctr, position
      const queryPages = data.queryPages || []; // Array of query+page objects for segmentation

      // Map average position (1-40) -> 100-10 (better position => higher score)
      const posScore = (() => {
        const clampedPos = Math.max(1, Math.min(40, position));
        const scale = (clampedPos - 1) / 39; // 0 to 1
        return 100 - scale * 90; // 100 to 10
      })();

      // Visibility is primarily driven by position
      const visibility = clampScore(posScore);

      // Authority: New 4-component model with segmentation support
      let behaviourScore, rankingScore;
      let behaviourScoresSegmented = null;
      let rankingScoresSegmented = null;
      
      // If we have queryPages data, use segmented calculation
      if (queryPages && queryPages.length > 0) {
        debugLog(` Segmentation: Received ${queryPages.length} query+page combinations from GSC API`, 'info');
        
        // Classify all pages and show distribution
        const segmentCounts = {};
        queryPages.forEach(row => {
          const segment = classifyPageSegment(row.page || row.url || '/');
          segmentCounts[segment] = (segmentCounts[segment] || 0) + 1;
        });
        
        debugLog(` Segmentation: Page distribution - Education: ${segmentCounts[PageSegment.EDUCATION] || 0}, Money: ${segmentCounts[PageSegment.MONEY] || 0}, Support: ${segmentCounts[PageSegment.SUPPORT] || 0}, System: ${segmentCounts[PageSegment.SYSTEM] || 0}`, 'info');
        
        // Use segmented calculation
        debugLog(' Segmentation: Calculating Behaviour scores for all segments...', 'info');
        behaviourScoresSegmented = computeBehaviourScoreWithSegment(queryPages);
        debugLog(` Segmentation: Behaviour scores - All: ${behaviourScoresSegmented.all.toFixed(1)}, Non-blog: ${behaviourScoresSegmented.nonBlog.toFixed(1)}, Money: ${behaviourScoresSegmented.money.toFixed(1)}`, 'success');
        
        debugLog(' Segmentation: Calculating Ranking scores for all segments...', 'info');
        rankingScoresSegmented = computeRankingScoreWithSegment(queryPages);
        debugLog(` Segmentation: Ranking scores - All: ${rankingScoresSegmented.all.toFixed(1)}, Non-blog: ${rankingScoresSegmented.nonBlog.toFixed(1)}, Money: ${rankingScoresSegmented.money.toFixed(1)}`, 'success');
        
        // Use 'all' segment for main Authority score (backward compatible)
        behaviourScore = behaviourScoresSegmented.all;
        rankingScore = rankingScoresSegmented.all;
        
        debugLog(` Using segmented calculation (queryPages available). Main scores use 'all' segment.`, 'success');
      } else {
        // Fallback to non-segmented calculation (backward compatible)
        debugLog(' Segmentation: queryPages not available, using non-segmented calculation (backward compatible)', 'warn');
        const queriesForCalculation = topQueries.map(q => ({
          clicks: q.clicks || 0,
          impressions: q.impressions || 0,
          ctr: (q.ctr || 0) / 100, // Convert percentage to decimal
          position: q.position || 0
        }));
        behaviourScore = computeBehaviourScore(queriesForCalculation);
        rankingScore = computeRankingScore(queriesForCalculation);
        debugLog(` Non-segmented scores: Behaviour=${behaviourScore.toFixed(1)}, Ranking=${rankingScore.toFixed(1)}`, 'warn');
      }

      // Review Score: Phase 2 - Use real review data if available
      // Get GBP data (may be null if not available, don't default to 0)
      const gbpRating = (localSignals && localSignals.status === 'ok' && localSignals.data) 
        ? (localSignals.data.gbpRating !== null && localSignals.data.gbpRating !== undefined ? localSignals.data.gbpRating : null)
        : null;
      const gbpCount = (localSignals && localSignals.status === 'ok' && localSignals.data) 
        ? (localSignals.data.gbpReviewCount !== null && localSignals.data.gbpReviewCount !== undefined ? localSignals.data.gbpReviewCount : null)
        : null;
      
      // Get site review data - ALWAYS use correct Trustpilot snapshot (4.6, 610)
      const normalizedSiteReviews = getTrustpilotSnapshot(siteReviews);
      const siteRating = normalizedSiteReviews?.siteRating !== null && normalizedSiteReviews?.siteRating !== undefined ? normalizedSiteReviews.siteRating : null;
      const siteCount = normalizedSiteReviews?.siteReviewCount !== null && normalizedSiteReviews?.siteReviewCount !== undefined ? normalizedSiteReviews.siteReviewCount : null;
      
      // Calculate review score (handles optional sources internally)
      const reviewScore = computeReviewScore({
        gbpRating,
        gbpCount,
        siteRating,
        siteCount
      });
      
      // Log the calculation details
      const gbpInfo = gbpRating !== null || gbpCount !== null 
        ? `GBP (rating=${gbpRating !== null ? gbpRating : 'N/A'}, count=${gbpCount !== null ? gbpCount : 'N/A'})`
        : 'GBP (no data)';
      const siteInfo = siteRating !== null || siteCount !== null
        ? `Trustpilot snapshot (rating=${siteRating !== null ? siteRating : 'N/A'}, count=${siteCount !== null ? siteCount : 'N/A'})`
        : 'Trustpilot snapshot (no data)';
      debugLog(`Review Score: ${gbpInfo}, ${siteInfo}, Final=${reviewScore.toFixed(1)}`, 'info');

      // Backlink Score: Phase 3 - Use real backlink metrics if available
      // backlinkMetrics is passed as a parameter (fetched from API)
      const backlinkScore = computeBacklinkScore(backlinkMetrics);

      // Authority weights (constant across all segments)
      const AUTHORITY_WEIGHTS = {
        behaviour: 0.4,
        ranking: 0.2,
        backlinks: 0.2,
        reviews: 0.2
      };
      
      // Helper to compute Authority from component scores
      function computeAuthorityFromComponents(components) {
        const total = clampScore(
          AUTHORITY_WEIGHTS.behaviour * components.behaviour +
          AUTHORITY_WEIGHTS.ranking * components.ranking +
          AUTHORITY_WEIGHTS.backlinks * components.backlinks +
          AUTHORITY_WEIGHTS.reviews * components.reviews
        );
        return {
          behaviour: clampScore(components.behaviour),
          ranking: clampScore(components.ranking),
          backlinks: clampScore(components.backlinks),
          reviews: clampScore(components.reviews),
          total: total
        };
      }
      
      // Base Authority (all pages) - current behaviour
      const authorityAll = computeAuthorityFromComponents({
        behaviour: behaviourScore,
        ranking: rankingScore,
        backlinks: backlinkScore,
        reviews: reviewScore
      });
      
      // Per-segment Authority scores (if segmentation available)
      // Helper function to compute top pages for a segment
      function computeTopPagesForSegment(pageRows, max = 10) {
        if (!pageRows || !Array.isArray(pageRows) || pageRows.length === 0) {
          return [];
        }
        
        // Aggregate by page URL (sum clicks, impressions, weighted position)
        const pageMap = new Map();
        
        pageRows.forEach(row => {
          const url = row.page || row.url || '';
          if (!url) return;
          
          if (!pageMap.has(url)) {
            pageMap.set(url, {
              url: url,
              clicks: 0,
              impressions: 0,
              totalPositionWeight: 0,
              count: 0
            });
          }
          
          const page = pageMap.get(url);
          page.clicks += row.clicks || 0;
          page.impressions += row.impressions || 0;
          page.totalPositionWeight += (row.position || 0) * (row.impressions || 0);
          page.count += 1;
        });
        
        // Convert to top pages format
        const topPages = Array.from(pageMap.values())
          .map(page => ({
            url: page.url,
            clicks: page.clicks,
            impressions: page.impressions,
            ctr: page.impressions > 0 ? (page.clicks / page.impressions) * 100 : 0,
            avgPosition: page.impressions > 0 ? page.totalPositionWeight / page.impressions : 0
          }))
          .filter(page => page.impressions > 0) // Only pages with impressions
          .sort((a, b) => b.impressions - a.impressions) // Sort by impressions descending
          .slice(0, max);
        
        return topPages;
      }
      
      // Compute all pages including zero impressions (for money pages segmentation validation)
      function computeAllPagesForSegment(pageRows) {
        if (!pageRows || !Array.isArray(pageRows) || pageRows.length === 0) {
          return [];
        }
        
        // Aggregate by page URL (sum clicks, impressions, weighted position)
        const pageMap = new Map();
        
        pageRows.forEach(row => {
          const url = row.page || row.url || '';
          if (!url) return;
          
          if (!pageMap.has(url)) {
            pageMap.set(url, {
              url: url,
              clicks: 0,
              impressions: 0,
              totalPositionWeight: 0,
              count: 0
            });
          }
          
          const page = pageMap.get(url);
          page.clicks += row.clicks || 0;
          page.impressions += row.impressions || 0;
          page.totalPositionWeight += (row.position || 0) * (row.impressions || 0);
          page.count += 1;
        });
        
        // Convert to pages format (include zero impressions)
        const allPages = Array.from(pageMap.values())
          .map(page => ({
            url: page.url,
            clicks: page.clicks,
            impressions: page.impressions,
            ctr: page.impressions > 0 ? (page.clicks / page.impressions) * 100 : 0,
            avgPosition: page.impressions > 0 ? page.totalPositionWeight / page.impressions : null,
            position: page.impressions > 0 ? page.totalPositionWeight / page.impressions : null
          }))
          .sort((a, b) => {
            // Sort by impressions descending, but put zero impressions at the end
            if (a.impressions === 0 && b.impressions > 0) return 1;
            if (b.impressions === 0 && a.impressions > 0) return -1;
            return b.impressions - a.impressions;
          });
        
        return allPages;
      }
      
      let authorityBySegment = null;
      if (behaviourScoresSegmented && rankingScoresSegmented) {
        // Get page-level data for top pages computation
        const queryPagesData = data.queryPages || [];
        
        // Filter to ranking pages (position 1-20, with impressions)
        const rankingPages = queryPagesData.filter(row => {
          const pos = row.position || 0;
          const impr = row.impressions || 0;
          return pos > 0 && pos <= 20 && impr > 0;
        });
        
        // Classify pages by segment
        const allPages = rankingPages;
        const excludeEduPages = rankingPages.filter(row => {
          const segment = classifyPageSegment(row.page || row.url || '/');
          return segment !== PageSegment.EDUCATION;
        });
        const moneyPages = rankingPages.filter(row => {
          const segment = classifyPageSegment(row.page || row.url || '/');
          return segment === PageSegment.MONEY;
        });
        
        // Compute top pages for each segment
        const allTopPages = computeTopPagesForSegment(allPages, 10);
        const excludeEduTopPages = computeTopPagesForSegment(excludeEduPages, 10);
        const moneyTopPages = computeTopPagesForSegment(moneyPages, 10);
        
        // Non-education (exclude education pages)
        const authorityNonEducation = computeAuthorityFromComponents({
          behaviour: behaviourScoresSegmented.nonBlog,
          ranking: rankingScoresSegmented.nonBlog,
          backlinks: backlinkScore, // Same across all segments
          reviews: reviewScore      // Same across all segments
        });
        
        // Money pages only
        const authorityMoney = computeAuthorityFromComponents({
          behaviour: behaviourScoresSegmented.money,
          ranking: rankingScoresSegmented.money,
          backlinks: backlinkScore, // Same across all segments
          reviews: reviewScore      // Same across all segments
        });
        
        // Helper to compute GSC metrics for a segment from queryPages data
        const computeGSCMetricsForSegment = (queryPagesData, segmentFilter) => {
          if (!queryPagesData || queryPagesData.length === 0) {
            return { siteCtr: 0, top10Ctr: 0, avgPosition: 0, top10Share: 0 };
          }
          
          // Filter by segment if filter function provided
          let filteredData = queryPagesData;
          if (segmentFilter) {
            filteredData = queryPagesData.filter(row => {
              const segment = classifyPageSegment(row.page || row.url || '/');
              return segmentFilter(segment);
            });
          }
          
          // Filter to ranking queries (position 1-20, with impressions)
          const rankingQueries = filteredData.filter(q => {
            const pos = q.position || 0;
            const impr = q.impressions || 0;
            return pos > 0 && pos <= 20 && impr > 0;
          });
          const top10Queries = rankingQueries.filter(q => (q.position || 0) <= 10);
          
          let siteCtr = 0;
          let top10Ctr = 0;
          let avgPosition = 0;
          let top10Share = 0;
          
          if (rankingQueries.length > 0) {
            const totalClicks = rankingQueries.reduce((s, q) => s + (q.clicks || 0), 0);
            const totalImpr = rankingQueries.reduce((s, q) => s + (q.impressions || 0), 0);
            siteCtr = totalImpr > 0 ? (totalClicks / totalImpr) * 100 : 0;
            
            const top10Clicks = top10Queries.reduce((s, q) => s + (q.clicks || 0), 0);
            const top10Impr = top10Queries.reduce((s, q) => s + (q.impressions || 0), 0);
            top10Ctr = top10Impr > 0 ? (top10Clicks / top10Impr) * 100 : 0;
            
            avgPosition = totalImpr > 0
              ? rankingQueries.reduce((s, q) => s + (q.position || 0) * (q.impressions || 0), 0) / totalImpr
              : 0;
            
            top10Share = totalImpr > 0 ? (top10Impr / totalImpr) : 0; // Store as 0-1 fraction
          }
          
          return { siteCtr, top10Ctr, avgPosition, top10Share };
        };
        
        // Compute GSC metrics for each segment using full queryPages data (not pre-filtered rankingPages)
        const allGSCMetrics = computeGSCMetricsForSegment(queryPagesData, null); // All pages
        const excludeEduGSCMetrics = computeGSCMetricsForSegment(queryPagesData, (seg) => seg !== PageSegment.EDUCATION);
        const moneyGSCMetrics = computeGSCMetricsForSegment(queryPagesData, (seg) => seg === PageSegment.MONEY);
        
        debugLog(` GSC Metrics - All: CTR=${allGSCMetrics.siteCtr != null ? allGSCMetrics.siteCtr.toFixed(2) : 'N/A'}%, Pos=${allGSCMetrics.avgPosition != null ? allGSCMetrics.avgPosition.toFixed(1) : 'N/A'}`, 'info');
        debugLog(` GSC Metrics - ExcludeEdu: CTR=${excludeEduGSCMetrics.siteCtr != null ? excludeEduGSCMetrics.siteCtr.toFixed(2) : 'N/A'}%, Pos=${excludeEduGSCMetrics.avgPosition != null ? excludeEduGSCMetrics.avgPosition.toFixed(1) : 'N/A'}`, 'info');
        debugLog(` GSC Metrics - Money: CTR=${moneyGSCMetrics.siteCtr != null ? moneyGSCMetrics.siteCtr.toFixed(2) : 'N/A'}%, Pos=${moneyGSCMetrics.avgPosition != null ? moneyGSCMetrics.avgPosition.toFixed(1) : 'N/A'}`, 'info');
        
        authorityBySegment = {
          all: { 
            ...authorityAll, 
            topPages: allTopPages,
            siteCtr: allGSCMetrics.siteCtr,
            top10Ctr: allGSCMetrics.top10Ctr,
            avgPosition: allGSCMetrics.avgPosition,
            top10Share: allGSCMetrics.top10Share
          },
          nonEducation: { 
            ...authorityNonEducation, 
            topPages: excludeEduTopPages,
            siteCtr: excludeEduGSCMetrics.siteCtr,
            top10Ctr: excludeEduGSCMetrics.top10Ctr,
            avgPosition: excludeEduGSCMetrics.avgPosition,
            top10Share: excludeEduGSCMetrics.top10Share
          },
          money: { 
            ...authorityMoney, 
            topPages: moneyTopPages,
            siteCtr: moneyGSCMetrics.siteCtr,
            top10Ctr: moneyGSCMetrics.top10Ctr,
            avgPosition: moneyGSCMetrics.avgPosition,
            top10Share: moneyGSCMetrics.top10Share
          }
        };
        
        debugLog(` Authority by segment - All: ${authorityAll.total.toFixed(1)}, Non-education: ${authorityNonEducation.total.toFixed(1)}, Money: ${authorityMoney.total.toFixed(1)}`, 'info');
      }
      
      // Main Authority score (default: all pages)
      const authority = authorityAll.total;
      
      debugLog(`Authority calculation: Behaviour=${behaviourScore.toFixed(1)}, Ranking=${rankingScore.toFixed(1)}, Backlinks=${backlinkScore}, Reviews=${reviewScore}, Final=${authority}`, 'info');
      
      // Store component scores for historical tracking (backward compatible)
      const authorityComponents = {
        behaviour: authorityAll.behaviour,
        ranking: authorityAll.ranking,
        backlinks: authorityAll.backlinks,
        reviews: authorityAll.reviews,
        // Segmented scores (if available) - for backward compatibility
        behaviourScoreAll: behaviourScoresSegmented ? clampScore(behaviourScoresSegmented.all) : clampScore(behaviourScore),
        behaviourScoreNonBlog: behaviourScoresSegmented ? clampScore(behaviourScoresSegmented.nonBlog) : null,
        behaviourScoreMoney: behaviourScoresSegmented ? clampScore(behaviourScoresSegmented.money) : null,
        rankingScoreAll: rankingScoresSegmented ? clampScore(rankingScoresSegmented.all) : clampScore(rankingScore),
        rankingScoreNonBlog: rankingScoresSegmented ? clampScore(rankingScoresSegmented.nonBlog) : null,
        rankingScoreMoney: rankingScoresSegmented ? clampScore(rankingScoresSegmented.money) : null
      };
      
      // Log final segmented scores stored
      if (behaviourScoresSegmented) {
        debugLog(` Segmentation: Final stored scores - Behaviour: All=${authorityComponents.behaviourScoreAll}, NonBlog=${authorityComponents.behaviourScoreNonBlog}, Money=${authorityComponents.behaviourScoreMoney}`, 'info');
        debugLog(` Segmentation: Final stored scores - Ranking: All=${authorityComponents.rankingScoreAll}, NonBlog=${authorityComponents.rankingScoreNonBlog}, Money=${authorityComponents.rankingScoreMoney}`, 'info');
      }

      // Local Entity: Use real Business Profile data if available, otherwise fallback to derived calculation
      let localEntity;
      if (localSignals && localSignals.status === 'ok' && localSignals.data) {
        const localData = localSignals.data;
        // Base score from NAP consistency (0-100)
        let baseScore = localData.napConsistencyScore || 0;
        
        // Bonus for knowledge panel detection (+10 points)
        if (localData.knowledgePanelDetected) {
          baseScore = Math.min(100, baseScore + 10);
        }
        
        // Bonus for having at least one location (+5 points)
        if (localData.locations && localData.locations.length > 0) {
          baseScore = Math.min(100, baseScore + 5);
        }
        
        localEntity = clampScore(baseScore);
        debugLog(`Local Entity: NAP=${localData.napConsistencyScore || 0}, Knowledge Panel=${localData.knowledgePanelDetected}, Locations=${localData.locations?.length || 0}, Final=${localEntity}`, 'info');
      } else {
        // Fallback: derived calculation (old method)
        // Calculate ctrScore from ctr (which is 0-100 percentage)
      const ctrDecimal = ctr / 100; // Convert percentage to decimal (e.g., 10% -> 0.10)
      const ctrScore = Math.min((ctrDecimal / 0.10) * 100, 100);
        localEntity = clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
        debugLog('Local Entity: Using fallback calculation (no Business Profile data)', 'warn');
      }

      // Service Area: Use real Business Profile service areas count if available, otherwise fallback
      let serviceArea;
      if (localSignals && localSignals.status === 'ok' && localSignals.data) {
        const localData = localSignals.data;
        const serviceAreasCount = localData.serviceAreas?.length || 0;
        
        // Normalize service areas count to 0-100 score
        // 0 areas = 0, 8+ areas = 100 (more reasonable threshold)
        // Linear scale: 1 area = 12.5 points (8 areas = 100)
        if (serviceAreasCount === 0) {
          serviceArea = 0;
        } else if (serviceAreasCount >= 8) {
          serviceArea = 100;
        } else {
          // Linear scale: 1 area = 12.5 points, 2 = 25, ..., 8 = 100
          serviceArea = Math.min(100, serviceAreasCount * 12.5);
        }
        
        // Apply NAP consistency as a multiplier (if NAP is low, reduce service area score)
        if (localData.napConsistencyScore !== null && localData.napConsistencyScore < 100) {
          const napMultiplier = localData.napConsistencyScore / 100;
          serviceArea = Math.round(serviceArea * napMultiplier);
        }
        
        serviceArea = clampScore(serviceArea);
        debugLog(`Service Area: Count=${serviceAreasCount}, NAP Multiplier=${localData.napConsistencyScore !== null ? (localData.napConsistencyScore / 100).toFixed(2) : 'N/A'}, Final=${serviceArea}`, 'info');
      } else {
        // Fallback: derived from Local Entity (old method)
        serviceArea = clampScore(localEntity - 5);
        debugLog('Service Area: Using fallback calculation (no Business Profile data)', 'warn');
      }

      // Content/Schema: weighted calculation based on foundation schemas, rich results, coverage, and diversity
      let contentSchema;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        const allTypes = new Set();
        
        // Use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
        if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
          // Use all detected types for accurate calculation
          schemaData.allDetectedTypes.forEach(type => {
            if (type) allTypes.add(type);
          });
        } else if (schemaData.foundation && typeof schemaData.foundation === 'object') {
          // Use foundation object to get foundation types (most reliable)
          Object.keys(schemaData.foundation).forEach(type => {
            if (schemaData.foundation[type] === true) {
              allTypes.add(type);
            }
          });
          // Also add from richEligible for complete type list
          if (schemaData.richEligible && typeof schemaData.richEligible === 'object') {
            Object.keys(schemaData.richEligible).forEach(type => {
              if (schemaData.richEligible[type] === true) {
                allTypes.add(type);
              }
            });
          }
        } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          // Fallback: collect from schemaTypes array (contains all types, sorted by count)
          // Handle both object format {type, count} and string format
          schemaData.schemaTypes.forEach(item => {
            if (typeof item === 'string') {
              allTypes.add(item);
            } else if (item && typeof item === 'object' && item.type) {
              allTypes.add(item.type);
            }
          });
        }
        
        // 1. Foundation Schemas Score (30% weight): Organization, Person, WebSite, BreadcrumbList
        const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
        const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
        const foundationScore = (foundationPresent / foundationTypes.length) * 100;
        
        // 2. Rich Result Eligibility Score (35% weight): Count eligible rich result types
        // Note: This list must match RICH_RESULT_TYPES in api/schema-audit.js
        const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
        const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
        const richResultScore = (richEligibleCount / richResultTypes.length) * 100;
        
        // 3. Coverage Score (20% weight): Pages with schema / total pages
        // Calculate coverage from pagesWithSchema and totalPages if coverage is not available
        let coverageScore = 0;
        if (typeof schemaData.coverage === 'number' && !isNaN(schemaData.coverage)) {
          coverageScore = schemaData.coverage;
        } else {
          // Calculate from pagesWithSchema and totalPages
          const pagesWithSchemaCount = Array.isArray(schemaData.pagesWithSchema) 
            ? schemaData.pagesWithSchema.length 
            : (typeof schemaData.pagesWithSchema === 'number' ? schemaData.pagesWithSchema : 0);
          const totalPagesCount = typeof schemaData.totalPages === 'number' 
            ? schemaData.totalPages 
            : (Array.isArray(schemaData.pages) ? schemaData.pages.length : 0);
          if (totalPagesCount > 0) {
            coverageScore = (pagesWithSchemaCount / totalPagesCount) * 100;
          }
        }
        
        // 4. Type Diversity Score (15% weight): Number of unique schema types (normalized to 15 types)
        const uniqueTypesCount = allTypes.size;
        const diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
        
        // Weighted calculation: 30% foundation + 35% rich results + 20% coverage + 15% diversity
        contentSchema = clampScore(
          foundationScore * 0.30 +
          richResultScore * 0.35 +
          coverageScore * 0.20 +
          diversityScore * 0.15
        );
        
        debugLog(`Content/Schema calculation: Foundation=${foundationScore != null ? foundationScore.toFixed(1) : 'N/A'}% (${foundationPresent}/4), Rich Results=${richResultScore != null ? richResultScore.toFixed(1) : 'N/A'}% (${richEligibleCount}/${richResultTypes.length}), Coverage=${coverageScore != null ? coverageScore.toFixed(1) : 'N/A'}%, Diversity=${diversityScore != null ? diversityScore.toFixed(1) : 'N/A'}% (${uniqueTypesCount} types)`, 'info');
      } else {
        // Fallback: if no schema audit data, return 0 (can't calculate without data)
        contentSchema = 0;
        debugLog(' No schema audit data available, Content/Schema score set to 0', 'warn');
      }

      // Extract coverage and diversity scores from contentSchema calculation for GAIO health
      let coverageScore = 0;
      let diversityScore = 0;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        // Coverage: Pages with schema / total pages (0-100)
        coverageScore = schemaData.coverage || 0;
        
        // Diversity: Number of unique schema types (normalized to 15 types, 0-100)
        const allTypes = new Set();
        if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
          schemaData.allDetectedTypes.forEach(type => {
            if (type) allTypes.add(type);
          });
        } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          schemaData.schemaTypes.forEach(item => {
            if (item.type) allTypes.add(item.type);
          });
        }
        const uniqueTypesCount = allTypes.size;
        diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
      }

      // ============================================================================
      // PHASE 1: Brand Overlay Calculation
      // ============================================================================
      
      // Calculate brand metrics from GSC query data
      // Use queryPages if available (more accurate), otherwise fall back to topQueries
      let brandMetrics;
      if (queryPages && queryPages.length > 0) {
        // Convert queryPages to query format for brand metrics calculation
        const queriesForBrand = queryPages.map(row => ({
          query: row.query || '',
          clicks: row.clicks || 0,
          impressions: row.impressions || 0,
          position: row.position || 0
        }));
        brandMetrics = calculateBrandMetrics(queriesForBrand);
      } else {
        // Fallback to topQueries
        brandMetrics = calculateBrandMetrics(topQueries);
      }
      debugLog(`Brand Metrics: Share=${(brandMetrics.brandQueryShare * 100).toFixed(2)}%, CTR=${(brandMetrics.brandCtr * 100).toFixed(2)}%, AvgPos=${brandMetrics.brandAvgPosition?.toFixed(1) || 'N/A'}`, 'info');
      
      // Compute brand overlay score
      const brandOverlay = computeBrandOverlay({
        brandQueryShare: brandMetrics.brandQueryShare,
        brandCtr: brandMetrics.brandCtr,
        brandAvgPosition: brandMetrics.brandAvgPosition,
        reviewScore: reviewScore,
        entityScore: localEntity
      });
      debugLog(`Brand Overlay: Score=${brandOverlay.score}, Label=${brandOverlay.label}, Notes=${brandOverlay.notes.length}`, 'info');
      
      // ============================================================================
      // End Phase 1: Brand Overlay Calculation
      // ============================================================================

      // ============================================================================
      // Money Pages Performance Metrics
      // ============================================================================
      
      /**
       * Compute site-wide aggregates from topPages data
       * @param {Array} topPages - Array of page objects with clicks, impressions, position
       * @returns {Object} Site aggregates
       */
      function computeSiteAggregateFromTopPages(topPages) {
        if (!topPages || !Array.isArray(topPages) || topPages.length === 0) {
          return {
            totalClicks: 0,
            totalImpressions: 0,
            avgCtr: 0,
            avgPosition: null
          };
        }
        
        let totalClicks = 0;
        let totalImpressions = 0;
        let weightedPosSum = 0;
        
        topPages.forEach(page => {
          const clicks = page.clicks || 0;
          const impressions = page.impressions || 0;
          const position = page.position || page.avgPosition || 0;
          
          totalClicks += clicks;
          totalImpressions += impressions;
          if (impressions > 0 && position > 0) {
            weightedPosSum += position * impressions;
          }
        });
        
        const avgCtr = totalImpressions > 0 ? totalClicks / totalImpressions : 0;
        const avgPosition = totalImpressions > 0 ? weightedPosSum / totalImpressions : null;
        
        return {
          totalClicks,
          totalImpressions,
          avgCtr,
          avgPosition
        };
      }
      
      /**
       * Classify a money page into an opportunity category and return a short recommendation.
       * @param {Object} metrics - { ctr (01), avgPosition, impressions }
       * @param {Object} siteAgg - { avgCtr, avgPosition }
       * @returns {Object} { category, categoryLabel, categoryColor, recommendation }
       */
      function classifyMoneyPageOpportunity(metrics, siteAgg, hasSchema = null, schemaTypes = []) {
        const { ctr, avgPosition, impressions } = metrics;
        const siteCtr = siteAgg.avgCtr || 0;
        const sitePos = siteAgg.avgPosition || 0;
        
        // Sensible defaults
        const safePos = avgPosition || 99;
        const safeCtr = ctr || 0;
        const imp = impressions || 0;
        
        // Thresholds (tune later)
        const MIN_IMPRESSIONS = 100;
        const HIGH_OPP_MAX_POS = 15;
        const MAINTAIN_MAX_POS = 8;
        
        const targetCtrHigh = 0.05;   // 5% for strong
        const targetCtrMid = 0.03;    // 3% mid range
        const lowCtrThreshold = 0.02;  // 2%
        
        let category = 'VISIBILITY_FIX';
        let categoryLabel = 'Visibility fix';
        let categoryColor = 'red';
        let recommendation = '';
        
        // Check which schema types are missing (for money pages, we typically want Product, Event, FAQPage)
        const desiredSchemaTypes = ['Product', 'Event', 'FAQPage'];
        // Normalize present types to lowercase for case-insensitive comparison
        const presentTypes = Array.isArray(schemaTypes) && schemaTypes.length > 0 
          ? schemaTypes.map(t => {
              if (typeof t === 'string') return t.trim().toLowerCase();
              if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type.trim().toLowerCase();
              return String(t).trim().toLowerCase();
            }).filter(t => t && t !== '[object object]')
          : [];
        // Check for missing types (case-insensitive comparison)
        const missingTypes = desiredSchemaTypes.filter(type => {
          const typeLower = type.toLowerCase();
          return !presentTypes.includes(typeLower);
        });
        
        // Build schema recommendation based on what's actually missing
        // Only recommend schema types that are NOT already present
        let schemaRecommendation = '';
        if (hasSchema === false) {
          // No schema at all - generic recommendation
          schemaRecommendation = 'ensure Product/Event/FAQ schema is present, and ';
        } else if (missingTypes.length > 0) {
          // Has schema but missing some or all desired types
          if (missingTypes.length === desiredSchemaTypes.length) {
            // Has schema but none of the desired types (Product, Event, FAQPage) - generic
            schemaRecommendation = 'ensure Product/Event/FAQ schema is present, and ';
          } else {
            // Missing specific types - only recommend what's actually missing (e.g., "add Product/Event schema")
            const missingTypesText = missingTypes.join('/');
            schemaRecommendation = `add ${missingTypesText} schema, and `;
          }
        }
        // If hasSchema === true AND missingTypes.length === 0, no schema recommendation (all desired types present)
        
        // 1) High opportunity: decent position, impressions, but weak CTR
        const hasDecentPosition = safePos >= 3 && safePos <= HIGH_OPP_MAX_POS;
        const hasVolume = imp >= MIN_IMPRESSIONS;
        const ctrBelowTargetForBand =
          (safePos <= 6 && safeCtr < targetCtrHigh) ||
          (safePos > 6 && safePos <= 10 && safeCtr < targetCtrMid) ||
          (safePos > 10 && safePos <= HIGH_OPP_MAX_POS && safeCtr < lowCtrThreshold);
        
        if (hasDecentPosition && hasVolume && ctrBelowTargetForBand) {
          category = 'HIGH_OPPORTUNITY';
          categoryLabel = 'High opportunity (improve CTR)';
          categoryColor = 'amber';
          // Add schema recommendation if missing (use same logic as visibility fix)
          let schemaNote = '';
          if (hasSchema === false) {
            // No schema at all
            schemaNote = ' Add Product/Event/FAQ schema to improve rich result eligibility. ';
          } else if (missingTypes.length > 0) {
            // Has schema but missing some or all desired types
            if (missingTypes.length === desiredSchemaTypes.length) {
              // Has schema but none of the desired types
              schemaNote = ' Add Product/Event/FAQ schema to improve rich result eligibility. ';
            } else {
              // Missing specific types - only recommend what's actually missing
              schemaNote = ` Add ${missingTypes.join('/')} schema to improve rich result eligibility. `;
            }
          }
          // If missingTypes.length === 0, no schema recommendation (all desired types present)
          recommendation =
            `Good visibility (avg position ${safePos.toFixed(1)}) and ` +
            `${imp.toLocaleString()} impressions, but low CTR (${(safeCtr * 100).toFixed(1)}%). ` +
            `Prioritise title/meta improvements, "best" phrasing for this offer, ` +
            `${schemaNote}` +
            `and adding FAQs that address objections for this money page.`;
        }
        // 2) Maintain: strong position + CTR above target
        else if (safePos <= MAINTAIN_MAX_POS && safeCtr >= targetCtrMid && imp >= MIN_IMPRESSIONS) {
          category = 'MAINTAIN';
          categoryLabel = 'Maintain (performing well)';
          categoryColor = 'green';
          recommendation =
            `Strong performer with avg position ${safePos.toFixed(1)} and ` +
            `CTR ${(safeCtr * 100).toFixed(1)}%. Maintain current messaging and ` +
            `internal links; focus optimisation efforts on weaker money pages first.`;
        }
        // 3) Visibility fix: fallback
        else {
          category = 'VISIBILITY_FIX';
          categoryLabel = 'Visibility fix (low impressions/rank)';
          categoryColor = 'red';
          recommendation =
            `Limited visibility (avg position ${Number.isFinite(safePos) ? safePos.toFixed(1) : ''} ` +
            `and ${imp.toLocaleString()} impressions). Strengthen internal links from high-traffic ` +
            `educational posts, ${schemaRecommendation}` +
            `consider a clearer "best [topic]" section to signal value to searchers and AI.`;
        }
        
        return { category, categoryLabel, categoryColor, recommendation };
      }
      
      /**
       * Compute aggregate and per-URL metrics for money pages.
       * @param {Array} topPages - Array from GSC (page/url, clicks, impressions, position)
       * @param {Function} classifySegment - function(url) -> 'money' | 'education' | 'general' | ...
       * @param {Object} siteAgg - { totalClicks, totalImpressions, avgCtr, avgPosition }
       * @param {Map|Object} pageTitleLookup - Optional Map/object url->title
       * @param {Object} schemaAudit - Optional schema audit data with pages array
       * @returns {Object} { overview, rows }
       */
      // Ranking & AI module - MOVED TO TOP OF SCRIPT (see line ~1820)

      // Classify money page sub-segment (Product, Event, Landing)
      function classifyMoneyPageSubSegment(url) {
        if (!url) return 'LANDING';
        
        // Use the same classification logic as Ranking & AI for consistency
        // This ensures Event/Product pages are classified the same way in both tabs
        if (typeof window.classifyUrlForRankingAi === 'function') {
          const classification = window.classifyUrlForRankingAi(url);
          const pageType = classification.pageType;
          
          // Map Ranking & AI pageType to Money Pages segmentType
          if (pageType === 'Event') return 'EVENT';
          if (pageType === 'Product') return 'PRODUCT';
          if (pageType === 'Landing') return 'LANDING';
          // For non-money pages (GBP, Blog, Other), return LANDING as fallback
          // (Money Pages only shows money pages, so these shouldn't appear anyway)
          return 'LANDING';
        }
        
        // Fallback: Use original logic if classifyUrlForRankingAi not available
        const path = normalisePath(url);
        const urlLower = url.toLowerCase();
        
        // Event Pages: Use same pattern as Ranking & AI (substring match for consistency)
        if (urlLower.includes('/beginners-photography-lessons') ||
            urlLower.includes('/photographic-workshops-near-me')) {
          return 'EVENT';
        }
        
        // Product Pages: Use same pattern as Ranking & AI (substring match for consistency)
        if (urlLower.includes('/photo-workshops-uk') ||
            urlLower.includes('/photography-services-near-me')) {
          return 'PRODUCT';
        }
        
        // Landing Pages (default - anything not matching above)
        return 'LANDING';
      }
      
      function computeMoneyPagesMetrics(topPages, classifySegment, siteAgg, pageTitleLookup = null, schemaAudit = null) {
        // Initialize summary by category (Phase 2)
        const summaryByCategory = {
          HIGH_OPPORTUNITY: { count: 0, impressions: 0, clicks: 0 },
          VISIBILITY_FIX: { count: 0, impressions: 0, clicks: 0 },
          MAINTAIN: { count: 0, impressions: 0, clicks: 0 }
        };
        
        // Initialize summary by sub-segment
        const summaryBySubSegment = {
          PRODUCT: { count: 0, impressions: 0, clicks: 0 },
          EVENT: { count: 0, impressions: 0, clicks: 0 },
          LANDING: { count: 0, impressions: 0, clicks: 0 }
        };
        
        if (!topPages || !Array.isArray(topPages) || topPages.length === 0) {
          return {
            overview: {
              moneyClicks: 0,
              moneyImpressions: 0,
              moneyCtr: 0,
              moneyAvgPosition: null,
              moneyCoverageCount: 0,
              moneyTotalKnown: null,
              moneyCoveragePct: null,
              siteCtr: siteAgg.avgCtr || 0,
              siteAvgPosition: siteAgg.avgPosition || null,
              siteTotalClicks: siteAgg.totalClicks || 0,
              siteTotalImpressions: siteAgg.totalImpressions || 0
            },
            rows: [],
            summaryByCategory
          };
        }
        
        const moneyRows = [];
        let moneyClicks = 0;
        let moneyImpressions = 0;
        let weightedPosSum = 0;
        const moneyActiveUrls = new Set();
        
        // Convert pageTitleLookup to Map if it's an object (for backward compatibility)
        // If it's already a Map with metadata objects, use it directly
        let metadataMap = null;
        if (pageTitleLookup instanceof Map) {
          // Check if it contains metadata objects or just titles
          const firstValue = pageTitleLookup.values().next().value;
          if (firstValue && typeof firstValue === 'object' && (firstValue.title !== undefined || firstValue.metaDescription !== undefined)) {
            metadataMap = pageTitleLookup; // It's already a metadata map
          } else {
            // Convert title-only map to metadata map
            metadataMap = new Map();
            pageTitleLookup.forEach((title, url) => {
              metadataMap.set(url, { title: title, metaDescription: null });
            });
          }
        } else if (pageTitleLookup) {
          // Convert object to metadata map
          metadataMap = new Map();
          Object.entries(pageTitleLookup).forEach(([url, value]) => {
            if (typeof value === 'object' && value !== null) {
              metadataMap.set(url, { title: value.title || null, metaDescription: value.metaDescription || null });
            } else {
              metadataMap.set(url, { title: value || null, metaDescription: null });
            }
          });
        }
        
        // Build schema lookup map from schema audit data
        const schemaLookup = new Map();
        const schemaTypesLookup = new Map();
        if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data && schemaAudit.data.pages) {
          schemaAudit.data.pages.forEach(page => {
            if (page.url) {
              // Normalize URL for matching (handles trailing slashes, query params, etc.)
              const normalizedUrl = normalizeUrlForMatching(page.url);
              // Store both original and normalized for lookup flexibility
              const hasSchema = page.hasSchema || page.hasInheritedSchema || false;
              schemaLookup.set(page.url, hasSchema);
              schemaLookup.set(normalizedUrl, hasSchema); // Also store normalized version
              // Store schema types array
              schemaTypesLookup.set(page.url, page.schemaTypes || []);
              schemaTypesLookup.set(normalizedUrl, page.schemaTypes || []); // Also store normalized version
            }
          });
        }
        
        // Iterate over topPages
        // Note: topPages is already aggregated by page from queryPages
        // The Segment Overview uses query+page level data filtered to position 1-20
        // For Money Pages, we want to show ALL money pages (not just position 1-20)
        // to give a complete view of money page performance
        topPages.forEach(page => {
          const url = page.page || page.url || '';
          if (!url) return;
          
          const segment = classifyPageSegment(url);
          if (segment !== PageSegment.MONEY) return;
          
          const clicks = page.clicks || 0;
          const impressions = page.impressions || 0;
          const position = page.position || page.avgPosition || 0;
          
          if (impressions > 0) {
            moneyClicks += clicks;
            moneyImpressions += impressions;
            weightedPosSum += position * impressions;
            moneyActiveUrls.add(url);
          }
          
          // Compute row-level metrics
          const ctr = impressions > 0 ? clicks / impressions : 0;
          const avgPosition = position || null;
          
          // Get title and meta description from metadata lookup
          const metadata = metadataMap?.get(url) || {};
          const title = metadata.title || null;
          const metaDescription = metadata.metaDescription || null;
          
          // Check if schema exists for this page (normalize URL for matching)
          const normalizedUrl = normalizeUrlForMatching(url);
          const hasSchema = schemaLookup.has(url) ? schemaLookup.get(url) : 
                          schemaLookup.has(normalizedUrl) ? schemaLookup.get(normalizedUrl) : null;
          const schemaTypes = schemaTypesLookup.get(url) || schemaTypesLookup.get(normalizedUrl) || [];
          
          // Classify opportunity
          const { category, categoryLabel, categoryColor, recommendation } =
            classifyMoneyPageOpportunity({ ctr, avgPosition, impressions }, siteAgg, hasSchema, schemaTypes);
          
          // Classify sub-segment
          const subSegment = classifyMoneyPageSubSegment(url);
          
          // Update category summary (Phase 2)
          const bucket = summaryByCategory[category];
          if (bucket) {
            bucket.count += 1;
            bucket.impressions += impressions;
            bucket.clicks += clicks;
          }
          
          // Update sub-segment summary
          const subBucket = summaryBySubSegment[subSegment];
          if (subBucket) {
            subBucket.count += 1;
            subBucket.impressions += impressions;
            subBucket.clicks += clicks;
          }
          
          // Push row
          moneyRows.push({
            url,
            title,
            metaDescription,
            clicks,
            impressions,
            ctr,
            avgPosition,
            category,
            categoryLabel,
            categoryColor,
            recommendation,
            schemaTypes,
            subSegment // Add sub-segment to each row
          });
        });
        
        // Compute money overview
        const moneyCtr = moneyImpressions > 0 ? moneyClicks / moneyImpressions : 0;
        const moneyAvgPosition = moneyImpressions > 0 ? weightedPosSum / moneyImpressions : null;
        
        const overview = {
          moneyClicks,
          moneyImpressions,
          moneyCtr,
          moneyAvgPosition,
          moneyCoverageCount: moneyActiveUrls.size,
          moneyTotalKnown: null, // Can be populated if we have a known money URLs list
          moneyCoveragePct: null,
          siteCtr: siteAgg.avgCtr || 0,
          siteAvgPosition: siteAgg.avgPosition || null,
          siteTotalClicks: siteAgg.totalClicks || 0,
          siteTotalImpressions: siteAgg.totalImpressions || 0
        };
        
        // Sort by category then impressions desc
        const categoryOrder = { HIGH_OPPORTUNITY: 0, VISIBILITY_FIX: 1, MAINTAIN: 2 };
        moneyRows.sort((a, b) => {
          const ca = categoryOrder[a.category] ?? 99;
          const cb = categoryOrder[b.category] ?? 99;
          if (ca !== cb) return ca - cb;
          return (b.impressions || 0) - (a.impressions || 0);
        });
        
        return { overview, rows: moneyRows, summaryByCategory, summaryBySubSegment };
      }
      
      // Build compact Money Pages summary for trend tracking (Phase 3)
      // Make buildMoneyPagesSummary globally accessible
      window.buildMoneyPagesSummary = function buildMoneyPagesSummary(moneyPagesMetrics, overview) {
        if (!moneyPagesMetrics || !moneyPagesMetrics.rows || !moneyPagesMetrics.rows.length) {
          return null;
        }

        const pages = moneyPagesMetrics.rows;
        const impressions = pages.reduce((sum, p) => sum + (p.impressions || 0), 0);
        const clicks = pages.reduce((sum, p) => sum + (p.clicks || 0), 0);
        const avgPosWeightedSum = pages.reduce((sum, p) =>
          sum + ((p.avgPosition || p.position || 0) * (p.impressions || 0)), 0
        );

        if (!impressions) return null;

        const avgPosition = avgPosWeightedSum / impressions;
        const ctr = clicks / impressions;

        // Use siteTotalImpressions and siteTotalClicks from overview
        const totalImpressions = overview?.siteTotalImpressions || overview?.totalImpressions || null;
        const totalClicks = overview?.siteTotalClicks || overview?.totalClicks || null;
        
        const shareOfImpressions = totalImpressions && totalImpressions > 0
          ? impressions / totalImpressions
          : null;

        const shareOfClicks = totalClicks && totalClicks > 0
          ? clicks / totalClicks
          : null;

        // Debug logging (only log if we have impressions but no overview - expected when overview is missing)
        if (shareOfImpressions == null && impressions > 0) {
          // Only log if this is unexpected (we have impressions but no overview data)
          // This is expected when overview data is not available, so reduce log level
          debugLog(` buildMoneyPagesSummary: shareOfImpressions is null (overview data not available) - impressions=${impressions}`, 'info');
        } else if (shareOfImpressions != null) {
          debugLog(` buildMoneyPagesSummary: shareOfImpressions=${shareOfImpressions} (${impressions}/${totalImpressions})`, 'info');
        }

        return {
          count: pages.length,
          impressions,
          clicks,
          ctr,
          avgPosition,
          shareOfImpressions,
          shareOfClicks,
          behaviourScore: moneyPagesMetrics.behaviour
            ? moneyPagesMetrics.behaviour.score
            : null
        };
      };
      
      // ============================================================================
      // PHASE: Money Pages Priority Matrix + 12-Month KPI Tracker
      // ============================================================================
      
      /**
       * Unified money page classification - returns both isMoney flag and segmentType
       * @param {string} url
       * @returns {{ isMoney: boolean, segmentType: MoneySegmentKey | null }}
       */
      function classifyMoneyPage(url) {
        if (!url) return { isMoney: false, segmentType: null };
        
        const path = normalisePath(url);
        
        // Check if it's a money page using existing logic
        const segment = classifyPageSegment(url);
        const isMoney = segment === PageSegment.MONEY;
        
        if (!isMoney) {
          return { isMoney: false, segmentType: null };
        }
        
        // Get sub-segment type (normalize to lowercase for consistency)
        const subSegment = classifyMoneyPageSubSegment(url);
        let segmentType = /** @type {MoneySegmentKey} */ ("all");
        
        if (subSegment === 'PRODUCT') {
          segmentType = "product";
        } else if (subSegment === 'EVENT') {
          segmentType = "event";
        } else if (subSegment === 'LANDING') {
          segmentType = "landing";
        }
        
        return { isMoney: true, segmentType };
      }
      
      // Make available globally for classifyUrlForRankingAi
      if (typeof window !== 'undefined') {
        window.classifyMoneyPage = classifyMoneyPage;
      }
      
      /**
       * Naive expected CTR curve by average position.
       * Returns decimal (01).
       * @param {number} pos - Average position
       * @returns {number}
       */
      function expectedCtrForPosition(pos) {
        if (!isFinite(pos) || pos <= 0) return 0.10;     // fallback
        if (pos <= 3) return 0.10;                       // 10% ideal for top 3
        if (pos <= 6) return 0.07;                       // 7% for 46
        if (pos <= 10) return 0.05;                      // 5% for 710
        if (pos <= 20) return 0.03;                      // 3% for 1120
        return 0.02;                                     // long tail
      }
      
      /**
       * Compute impact levels based on lost clicks (expected CTR - actual CTR)
       * @param {Array<MoneyPageMetrics>} pages
       */
      function computeImpactLevels(pages) {
        // Step 1: compute lostClicks for each page
        let maxLost = 0;
        for (const p of pages) {
          const expectedCtr = expectedCtrForPosition(p.avgPosition);
          const gap = Math.max(0, expectedCtr - (p.ctr || 0));
          const lostClicks = (p.impressions || 0) * gap;
          p._lostClicks = lostClicks;
          if (lostClicks > maxLost) maxLost = lostClicks;
        }

        if (maxLost <= 0) {
          // All pages flat  mark all as LOW impact
          for (const p of pages) {
            p.impactLevel = "LOW";
          }
          return;
        }

        // Step 2: thresholds relative to max (no magic numbers baked into data)
        const highThreshold = 0.75 * maxLost;
        const medThreshold = 0.35 * maxLost;

        for (const p of pages) {
          const lost = p._lostClicks || 0;
          if (lost >= highThreshold) p.impactLevel = "HIGH";
          else if (lost >= medThreshold) p.impactLevel = "MEDIUM";
          else p.impactLevel = "LOW";
        }
      }
      
      /**
       * Check if a page has the "key schema" for its segment type
       * @param {string} url
       * @param {MoneySegmentKey} segmentType
       * @param {Object} schemaAudit - Schema audit data with pages array
       * @returns {boolean}
       */
      function pageHasKeySchema(url, segmentType, schemaAudit) {
        if (!schemaAudit || !schemaAudit.data || !schemaAudit.data.pages) {
          return false;
        }
        
        const page = schemaAudit.data.pages.find(p => p.url === url);
        if (!page) return false;
        
        const schemaTypes = page.schemaTypes || [];
        const typesLower = schemaTypes.map(t => {
          if (typeof t === 'string') return t.toLowerCase();
          if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type.toLowerCase();
          return String(t).toLowerCase();
        }).filter(t => t && t !== '[object object]');
        
        if (segmentType === "event") {
          return typesLower.includes("event") || typesLower.includes("course");
        } else if (segmentType === "product") {
          return typesLower.includes("product") || typesLower.includes("offer");
        } else if (segmentType === "landing") {
          return typesLower.includes("itemlist") || typesLower.includes("faqpage") || typesLower.includes("article");
        }
        
        return false;
      }
      
      /**
       * Compute difficulty level based on position + schema effort
       * @param {MoneyPageMetrics} p
       * @param {boolean} hasKeySchema   // true if this page already has the main rich type it "should"
       * @returns {DifficultyLevel}
       */
      function computeDifficultyLevel(p, hasKeySchema) {
        const pos = p.avgPosition || 0;
        let base;
        if (pos > 0 && pos <= 5) base = "LOW";          // already ranking well  "easy" CTR fixes
        else if (pos <= 10) base = "MEDIUM";
        else base = "HIGH";

        // If no key schema yet for an event/product, bump difficulty by one
        if (!hasKeySchema && (p.segmentType === "event" || p.segmentType === "product")) {
          if (base === "LOW") base = "MEDIUM";
          else if (base === "MEDIUM") base = "HIGH";
        }

        return /** @type {DifficultyLevel} */ (base);
      }
      
      /**
       * Derive priority level from Impact + Difficulty
       * @param {ImpactLevel} impact
       * @param {DifficultyLevel} difficulty
       * @returns {PriorityLevel}
       */
      function derivePriorityLevel(impact, difficulty) {
        // High impact & easy/medium difficulty  HIGH priority
        if (impact === "HIGH" && (difficulty === "LOW" || difficulty === "MEDIUM")) {
          return "HIGH";
        }

        // Medium cases or high impact but high difficulty  MEDIUM
        if (
          impact === "HIGH" && difficulty === "HIGH" ||
          impact === "MEDIUM" && (difficulty === "LOW" || difficulty === "MEDIUM")
        ) {
          return "MEDIUM";
        }

        // Everything else  LOW
        return "LOW";
      }
      
      /**
       * Build MoneyPageMetrics array from topPages data
       * @param {Array<{page: string, clicks: number, impressions: number, ctr: number, position: number, title?: string}>} topPages
       * @param {Object} schemaAudit - Optional schema audit data
       * @returns {Array<MoneyPageMetrics>}
       */
      function buildMoneyPageMetrics(topPages, schemaAudit = null) {
        const result = [];

        for (const row of topPages) {
          const url = row.page || row.url;
          const { isMoney, segmentType } = classifyMoneyPage(url);
          if (!isMoney) continue;

          // CTR might be percentage (0-100) or decimal (0-1), normalize to decimal
          let ctr = row.ctr || 0;
          if (ctr > 1) ctr = ctr / 100; // Convert percentage to decimal
          
          const m = /** @type {MoneyPageMetrics} */ ({
            url,
            title: row.title || url,
            segmentType: segmentType || "all",
            clicks: row.clicks || 0,
            impressions: row.impressions || 0,
            ctr: ctr,
            avgPosition: row.position || row.avgPosition || 0,
            impactLevel: "LOW",
            difficultyLevel: "MEDIUM",
            priorityLevel: "LOW"
          });

          const hasKeySchema = pageHasKeySchema(url, m.segmentType, schemaAudit);
          m.difficultyLevel = computeDifficultyLevel(m, hasKeySchema);
          result.push(m);
        }

        computeImpactLevels(result);

        for (const p of result) {
          p.priorityLevel = derivePriorityLevel(p.impactLevel, p.difficultyLevel);
        }

        return result;
      }
      
      // Make function globally accessible immediately after definition
      // CRITICAL: Assign to window immediately so it's available when displayDashboard runs
      // This REPLACES the placeholder we defined at the top of the script
      if (typeof window !== 'undefined') {
        window.buildMoneyPageMetrics = buildMoneyPageMetrics;
        // Also assign to global scope as fallback
        if (typeof globalThis !== 'undefined') {
          globalThis.buildMoneyPageMetrics = buildMoneyPageMetrics;
        }
        // Debug: Log that function is now available
        console.log('[Money Pages]  buildMoneyPageMetrics FULL IMPLEMENTATION assigned to window (replaced placeholder)');
      }
      
      /**
       * Build per-segment summaries for Money Pages (for 12-month KPI tracking)
       * @param {Array<MoneyPageMetrics>} moneyPages
       * @param {Object} behaviourScores - Optional behaviour scores by segment
       * @returns {MoneySegmentMetricsByAudit}
       */
      function buildMoneySegmentSummary(moneyPages, behaviourScores = {}) {
        // Ensure moneyPages is an array (default to empty array)
        const pages = Array.isArray(moneyPages) ? moneyPages : [];
        
        const segments = {
          allMoney: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
          landingPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
          eventPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 },
          productPages: { clicks: 0, impressions: 0, ctr: 0, avgPosition: 0, behaviourScore: 0 }
        };

        const groups = {
          allMoney: pages,
          landingPages: pages.filter(p => p.segmentType === "landing"),
          eventPages: pages.filter(p => p.segmentType === "event"),
          productPages: pages.filter(p => p.segmentType === "product")
        };

        for (const [key, groupPages] of Object.entries(groups)) {
          if (!groupPages || !groupPages.length) continue;
          const clicks = groupPages.reduce((s, p) => s + (p.clicks || 0), 0);
          const impressions = groupPages.reduce((s, p) => s + (p.impressions || 0), 0);
          const ctr = impressions > 0 ? clicks / impressions : 0;
          const avgPosition = groupPages.length > 0
            ? groupPages.reduce((s, p) => s + (p.avgPosition || 0), 0) / groupPages.length
            : 0;

          segments[key].clicks = clicks;
          segments[key].impressions = impressions;
          segments[key].ctr = ctr;
          segments[key].avgPosition = avgPosition;
          // Use behaviour score from parameter if available, otherwise 0
          segments[key].behaviourScore = behaviourScores[key] || behaviourScores[key.toLowerCase()] || 0;
        }

        // Always return a valid structure (never null)
        return segments;
      }
      
      // Compute money pages behaviour score (for Authority overlay)
      // Define globally to ensure accessibility from event handlers
      window.computeMoneyPagesBehaviour = function(gscQueries, moneyPages, useAllPositions = false) {
        if (!gscQueries || !gscQueries.length || !moneyPages || !moneyPages.length) {
          debugLog(` computeMoneyPagesBehaviour: Missing data - gscQueries=${!!gscQueries}(${gscQueries?.length || 0}), moneyPages=${!!moneyPages}(${moneyPages?.length || 0})`, 'warn');
          return null;
        }

        // Normalize URLs: remove trailing slash, convert to lowercase, remove protocol if present
        const normalizeUrl = (url) => {
          if (!url) return '';
          let normalized = url.toString().trim().toLowerCase();
          // Remove protocol (http:// or https://)
          normalized = normalized.replace(/^https?:\/\//, '');
          // Remove trailing slash
          normalized = normalized.replace(/\/$/, '');
          return normalized;
        };

        const moneySet = new Set(
          moneyPages.map(p => {
            const url = normalizeUrl(p.url || p.page || '');
            return url;
          })
        );

        debugLog(` computeMoneyPagesBehaviour: Created moneySet with ${moneySet.size} URLs. useAllPositions=${useAllPositions}. Sample URLs: ${Array.from(moneySet).slice(0, 3).join(', ')}`, 'info');

        let clicks = 0;
        let impressions = 0;
        let top10Clicks = 0;
        let top10Impressions = 0;
        let weightedPosSum = 0;
        let weightedPosImps = 0;
        let matchedUrls = 0;
        let unmatchedUrls = 0;
        let filteredOutByPosition = 0;

        gscQueries.forEach(row => {
          const url = normalizeUrl(row.page || row.url || '');
          if (!moneySet.has(url)) {
            unmatchedUrls++;
            return;
          }
          matchedUrls++;

          const pos = typeof row.position === 'number'
            ? row.position
            : (row.avgPosition || null);
          const imps = row.impressions || 0;
          const cls = row.clicks || 0;

          // For filtered calculations, include all positions; otherwise only 1-20 to match Authority
          if (!imps || !pos || pos <= 0) return;
          if (!useAllPositions && pos > 20) {
            filteredOutByPosition++;
            return;
          }

          clicks += cls;
          impressions += imps;

          weightedPosSum += pos * imps;
          weightedPosImps += imps;
          if (pos <= 10) {
            top10Clicks += cls;
            top10Impressions += imps;
          }
        });

        debugLog(` computeMoneyPagesBehaviour: Matched ${matchedUrls} URLs, unmatched ${unmatchedUrls} URLs, filtered by position ${filteredOutByPosition}. Total impressions: ${impressions}, clicks: ${clicks}`, 'info');

        if (!impressions || !weightedPosImps) {
          debugLog(` computeMoneyPagesBehaviour: No valid impressions (${impressions}) or weighted positions (${weightedPosImps}), returning null`, 'warn');
          return null;
        }

        const siteCtr = clicks / impressions;
        const top10Ctr = top10Impressions > 0 ? (top10Clicks / top10Impressions) : 0;
        const avgPos = weightedPosSum / weightedPosImps;
        const top10Share = impressions > 0 ? (top10Impressions / impressions) : 0;

        // Reuse existing Behaviour score calculation (same as Authority)
        // For filtered calculations, include all positions; otherwise only 1-20
        const rankingQueries = gscQueries.filter(row => {
          const url = normalizeUrl(row.page || row.url || '');
          if (!moneySet.has(url)) return false;
          const pos = typeof row.position === 'number' ? row.position : (row.avgPosition || null);
          if (!pos || pos <= 0 || !(row.impressions || 0)) return false;
          if (!useAllPositions && pos > 20) return false;
          return true;
        });

        const behaviourScore = computeBehaviourScoreRaw(rankingQueries);

        return {
          score: behaviourScore,
          siteCtr,
          top10Ctr,
          avgPos,
          top10Share,
          clicks,
          impressions
        };
      };

      // Fallback: compute Money Pages behaviour from page-level aggregates (no queryPages required)
      // Used when queryPages is missing/truncated or URLs don't match.
      function computeMoneyPagesBehaviourFromPageAggregates(moneyPages) {
        if (!Array.isArray(moneyPages) || moneyPages.length === 0) return null;

        let clicks = 0;
        let impressions = 0;
        let weightedPosSum = 0;
        let weightedPosImps = 0;
        let top10Clicks = 0;
        let top10Impressions = 0;

        moneyPages.forEach(p => {
          const imps = p.impressions || 0;
          const cls = p.clicks || 0;
          const pos = typeof p.avgPosition === 'number' ? p.avgPosition : (p.avgPosition ? parseFloat(p.avgPosition) : null);
          if (!imps || !pos || pos <= 0) return;

          clicks += cls;
          impressions += imps;
          weightedPosSum += pos * imps;
          weightedPosImps += imps;

          // Approximate top-10 using avgPosition (best available without query-level data)
          if (pos <= 10) {
            top10Clicks += cls;
            top10Impressions += imps;
          }
        });

        if (!impressions || !weightedPosImps) return null;

        const siteCtr = clicks / impressions;
        const top10Ctr = top10Impressions > 0 ? (top10Clicks / top10Impressions) : 0;
        const avgPos = weightedPosSum / weightedPosImps;
        const top10Share = impressions > 0 ? (top10Impressions / impressions) : 0;

        // Map CTR to score using same bands as Authority behaviour
        const scoreCtrAll = Math.min(siteCtr / 0.05, 1) * 100;    // 05% => 0100
        const scoreCtrTop10 = Math.min(top10Ctr / 0.10, 1) * 100; // 010% => 0100
        const behaviourScore = 0.5 * scoreCtrAll + 0.5 * scoreCtrTop10;

        return {
          score: behaviourScore,
          siteCtr,
          top10Ctr,
          avgPos,
          top10Share,
          clicks,
          impressions
        };
      }
      
      // Compute money pages metrics if we have queryPages data
      let moneyPagesMetrics = null;
      if (queryPages && queryPages.length > 0) {
        // Aggregate all pages from queryPages (not just top 10)
        const pageMap = new Map();
        queryPages.forEach(row => {
          const url = row.page || row.url || '';
          if (!url) return;
          
          if (!pageMap.has(url)) {
            pageMap.set(url, {
              url: url,
              clicks: 0,
              impressions: 0,
              totalPositionWeight: 0
            });
          }
          
          const page = pageMap.get(url);
          page.clicks += row.clicks || 0;
          page.impressions += row.impressions || 0;
          page.totalPositionWeight += (row.position || 0) * (row.impressions || 0);
        });
        
        // Convert to topPages format
        const allTopPages = Array.from(pageMap.values())
          .map(page => ({
            url: page.url,
            clicks: page.clicks,
            impressions: page.impressions,
            ctr: page.impressions > 0 ? (page.clicks / page.impressions) : 0,
            avgPosition: page.impressions > 0 ? page.totalPositionWeight / page.impressions : 0,
            position: page.impressions > 0 ? page.totalPositionWeight / page.impressions : 0
          }))
          .filter(page => page.impressions > 0); // Only pages with impressions
        
        // Compute site aggregates
        const siteAgg = computeSiteAggregateFromTopPages(allTopPages);
        
        // Build page metadata lookup from schema audit if available
        const pageMetadataLookup = new Map();
        if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
          const schemaData = schemaAudit.data;
          // Use the new pages array with metadata (title, metaDescription)
          if (schemaData.pages && Array.isArray(schemaData.pages)) {
            schemaData.pages.forEach(page => {
              if (page.url) {
                pageMetadataLookup.set(page.url, {
                  title: page.title || null,
                  metaDescription: page.metaDescription || null
                });
              }
            });
          }
          // Fallback to old structure for backwards compatibility
          if (schemaData.pagesWithSchema && Array.isArray(schemaData.pagesWithSchema) && pageMetadataLookup.size === 0) {
            schemaData.pagesWithSchema.forEach(page => {
              if (page.url) {
                pageMetadataLookup.set(page.url, {
                  title: page.title || null,
                  metaDescription: page.metaDescription || page.description || null
                });
              }
            });
          }
          // Also check missing pages (fallback)
          if (schemaData.missingSchemaPages && Array.isArray(schemaData.missingSchemaPages)) {
            schemaData.missingSchemaPages.forEach(page => {
              const url = typeof page === 'string' ? page : page.url;
              if (url && !pageMetadataLookup.has(url)) {
                pageMetadataLookup.set(url, {
                  title: typeof page === 'object' ? (page.title || null) : null,
                  metaDescription: typeof page === 'object' ? (page.metaDescription || page.description || null) : null
                });
              }
            });
          }
        }
        
        // Compute money pages metrics
        // Use CSV as source of truth for all pages, then match GSC data to CSV URLs
        // This ensures we segment ALL pages (433 URLs) not just those in GSC data (78 pages)
        const allGSCPages = data.queryPages || [];
        const allPagesAggregated = computeAllPagesForSegment(allGSCPages); // Aggregate GSC data by page
        
        // Fetch CSV and segment all URLs
        // First check for manually loaded URL list, then try GitHub/fallback
        let csvUrls = [];
        try {
          // Check for manually loaded URL list first
          const manualUrlList = localStorage.getItem('manual_url_list');
          if (manualUrlList) {
            try {
              csvUrls = JSON.parse(manualUrlList);
              debugLog(` Using manual URL list: ${csvUrls.length} URLs`, 'info');
            } catch (parseErr) {
              debugLog(` Failed to parse manual URL list: ${parseErr.message}`, 'warn');
            }
          }
          
          // If no manual list, try fetching from GitHub/fallback
          if (csvUrls.length === 0) {
            csvUrls = await fetchAndParseSiteUrlsCsv();
            debugLog(` Fetched ${csvUrls.length} URLs from CSV (GitHub/fallback)`, 'info');
          }
          
          // Segment all CSV URLs
          const allCsvPages = csvUrls.map(url => {
            const segment = classifyPageSegment(url);
            return {
              url: url,
              segment: segment,
              // GSC data will be matched below
              clicks: 0,
              impressions: 0,
              ctr: 0,
              avgPosition: null,
              position: null
            };
          });
          
          // Create a map of GSC data by URL (normalized)
          const gscDataMap = new Map();
          allPagesAggregated.forEach(page => {
            const normalizedUrl = (page.url || page.page || '').replace(/\/$/, '');
            gscDataMap.set(normalizedUrl, page);
          });
          
          // Match GSC data to CSV URLs (normalize URLs for matching)
          const csvPagesWithGsc = allCsvPages.map(csvPage => {
            const normalizedCsvUrl = csvPage.url.replace(/\/$/, '');
            
            // Try to find matching GSC data (check both with and without trailing slash)
            let gscData = gscDataMap.get(normalizedCsvUrl);
            if (!gscData) {
              // Try with trailing slash
              gscData = gscDataMap.get(normalizedCsvUrl + '/');
            }
            if (!gscData) {
              // Try without trailing slash (if CSV had one)
              gscData = gscDataMap.get(normalizedCsvUrl.replace(/\/$/, ''));
            }
            
            if (gscData) {
              // Merge GSC data - format expected by computeMoneyPagesMetrics
              return {
                url: csvPage.url,
                page: csvPage.url, // Also set page property for compatibility
                segment: csvPage.segment,
                clicks: gscData.clicks || 0,
                impressions: gscData.impressions || 0,
                ctr: gscData.ctr || 0,
                avgPosition: gscData.avgPosition || gscData.position || null,
                position: gscData.position || gscData.avgPosition || null
              };
            } else {
              // No GSC data for this URL (zero impressions or never appeared in search)
              // Format expected by computeMoneyPagesMetrics
              return {
                url: csvPage.url,
                page: csvPage.url, // Also set page property for compatibility
                segment: csvPage.segment,
                clicks: 0,
                impressions: 0,
                ctr: 0,
                avgPosition: null,
                position: null
              };
            }
          });
          
          // Filter to money pages only and compute metrics
          const moneyPagesFromCsv = csvPagesWithGsc.filter(page => page.segment === PageSegment.MONEY);
          debugLog(` Segmented ${moneyPagesFromCsv.length} money pages from CSV (out of ${csvUrls.length} total URLs)`, 'info');
          
          moneyPagesMetrics = computeMoneyPagesMetrics(
            moneyPagesFromCsv, // Use CSV URLs with matched GSC data
            classifyPageSegment,
            siteAgg,
            pageMetadataLookup, // Pass metadata lookup
            schemaAudit // Pass schema audit data to check for schema presence
          );
        } catch (csvError) {
          debugLog(` Failed to fetch CSV, falling back to GSC data only: ${csvError.message}`, 'warn');
          // Fallback to GSC data only if CSV fetch fails
          moneyPagesMetrics = computeMoneyPagesMetrics(
            allPagesAggregated,
            classifyPageSegment,
            siteAgg,
            pageMetadataLookup,
            schemaAudit
          );
        }
        
        // Compute money pages behaviour score
        const moneyPagesList = moneyPagesMetrics.rows || [];
        const moneyBehaviour = window.computeMoneyPagesBehaviour(
          allGSCPages, // Use all GSC pages for behaviour calculation
          moneyPagesList
        );
        moneyPagesMetrics.behaviour = moneyBehaviour;
        
        debugLog(`Money Pages Metrics: ${moneyPagesMetrics.rows.length} money pages found, ${moneyPagesMetrics.overview.moneyClicks} clicks, ${moneyPagesMetrics.overview.moneyImpressions} impressions`, 'info');
        if (moneyBehaviour) {
          debugLog(`Money Pages Behaviour: score=${moneyBehaviour.score != null ? moneyBehaviour.score.toFixed(1) : 'N/A'}, CTR=${moneyBehaviour.siteCtr != null ? (moneyBehaviour.siteCtr * 100).toFixed(2) : 'N/A'}%, Top-10 CTR=${moneyBehaviour.top10Ctr != null ? (moneyBehaviour.top10Ctr * 100).toFixed(2) : 'N/A'}%`, 'info');
        }
        
        // Build Money Page Priority Matrix data
        // Convert moneyPagesMetrics.rows to format expected by buildMoneyPageMetrics
        const topPagesForPriority = moneyPagesMetrics.rows.map(row => ({
          page: row.url,
          url: row.url,
          clicks: row.clicks || 0,
          impressions: row.impressions || 0,
          ctr: (row.ctr || 0) * 100, // Convert to percentage for buildMoneyPageMetrics
          position: row.avgPosition || 0,
          avgPosition: row.avgPosition || 0,
          title: row.title || row.url
        }));
        
        // Store priority matrix data globally
        window.moneyPagePriorityData = buildMoneyPageMetrics(topPagesForPriority, schemaAudit);
        debugLog(`Money Pages Priority: Built ${window.moneyPagePriorityData.length} priority entries`, 'info');
        
        // Build segment summary for Supabase storage
        // CRITICAL: Use moneyPagesMetrics.rows (has clicks/impressions/avgPosition/segmentType) not moneyPagePriorityData
        const behaviourScoresBySegment = {};
        if (moneyBehaviour && moneyBehaviour.bySegment) {
          behaviourScoresBySegment.allMoney = moneyBehaviour.bySegment.money?.behaviour?.score || 0;
          behaviourScoresBySegment.landingPages = 0; // Will be calculated per segment if needed
          behaviourScoresBySegment.eventPages = 0;
          behaviourScoresBySegment.productPages = 0;
        }
        // Build segment metrics from moneyPagesMetrics.rows (has the actual GSC data)
        // Map subSegment (PRODUCT/EVENT/LANDING) to segmentType (product/event/landing)
        const moneyPagesForSegments = (moneyPagesMetrics?.rows || []).map(row => {
          const subSegment = row.subSegment || 'LANDING';
          let segmentType = 'landing'; // Default
          if (subSegment === 'PRODUCT') segmentType = 'product';
          else if (subSegment === 'EVENT') segmentType = 'event';
          else if (subSegment === 'LANDING') segmentType = 'landing';
          
          return {
            clicks: row.clicks || 0,
            impressions: row.impressions || 0,
            ctr: row.ctr || 0,
            avgPosition: row.avgPosition || 0,
            segmentType: segmentType
          };
        });
        window.moneySegmentMetrics = buildMoneySegmentSummary(moneyPagesForSegments, behaviourScoresBySegment);
        debugLog(`Money Pages Segments: Built segment summary from ${moneyPagesForSegments.length} pages`, 'info');
        debugLog(`Money Pages Segments: allMoney clicks=${window.moneySegmentMetrics.allMoney.clicks}, impressions=${window.moneySegmentMetrics.allMoney.impressions}`, 'info');
      } else {
        debugLog(' Money Pages Metrics: No queryPages data available - building empty structure', 'warn');
        window.moneyPagePriorityData = [];
        // Always build empty segment metrics structure (never null) so it can be saved to Supabase
        window.moneySegmentMetrics = buildMoneySegmentSummary([], {});
        debugLog(`Money Pages Segments: Built empty segment summary (no data available) - allMoney clicks=${window.moneySegmentMetrics.allMoney.clicks}, impressions=${window.moneySegmentMetrics.allMoney.impressions}`, 'info');
      }
      
      // Ensure moneySegmentMetrics is never null (always a valid structure)
      if (!window.moneySegmentMetrics) {
        debugLog(' Money Pages Segments: moneySegmentMetrics was null, building empty structure', 'warn');
        window.moneySegmentMetrics = buildMoneySegmentSummary([], {});
      }

      const scores = {
        localEntity,
        serviceArea,
        authority: {
          score: authority, // Main score (default: all pages)
          bySegment: authorityBySegment // Per-segment Authority scores (if available)
        },
        visibility,
        contentSchema,
        // Authority component scores for historical tracking (backward compatible)
        authorityComponents: authorityComponents,
        // GAIO health components (extracted from contentSchema)
        coverage: coverageScore,
        diversity: diversityScore,
        // Phase 1: Brand overlay (overlay only, not weighted in GAIO score)
        brandOverlay: brandOverlay,
        // Money Pages Performance metrics (overlay only, not weighted in GAIO score)
        // Always include moneyPagesMetrics, even if null (ensures it's saved to Supabase)
        moneyPagesMetrics: moneyPagesMetrics || null
      };
      
      // Store moneyPagesMetrics globally for saveAuditToSupabase to access
      if (moneyPagesMetrics) {
        window.moneyPagesMetrics = moneyPagesMetrics;
        debugLog(` Stored moneyPagesMetrics globally: ${moneyPagesMetrics.rows?.length || 0} rows`, 'info');
      } else {
        debugLog(` moneyPagesMetrics is null - will be saved as null to Supabase`, 'warn');
      }

      debugLog(`Deterministic pillar scores: ${JSON.stringify(scores)}`, 'info');
      return scores;
    }
    
    // Calculate GAIO Health Score
    // IMPORTANT: GAIO score uses ONLY the 5 pillars - brandOverlay and aiSummary are overlay metrics only
    function calculateAiGeoScore(scores, schemaAudit = null, snippetReadiness = null) {
      // GAIO weights - ONLY the 5 pillars
      const AIGEO_WEIGHTS = {
        authority: 0.30,
        content: 0.25,
        visibility: 0.20,
        localEntity: 0.15,
        serviceArea: 0.10
      };
      
      // Extract scores from the 5 pillars ONLY
      const authorityScore = (typeof scores.authority === 'object' && scores.authority !== null) 
        ? scores.authority.score 
        : scores.authority || 0;
      const contentScore = scores.contentSchema || 0;
      const visibilityScore = scores.visibility || 0;
      const localEntityScore = scores.localEntity || 0;
      const serviceAreaScore = scores.serviceArea || 0;
      
      // Calculate weighted score using ONLY the 5 pillars
      const aiGeoScore = Math.round(
        authorityScore * AIGEO_WEIGHTS.authority +
        contentScore * AIGEO_WEIGHTS.content +
        visibilityScore * AIGEO_WEIGHTS.visibility +
        localEntityScore * AIGEO_WEIGHTS.localEntity +
        serviceAreaScore * AIGEO_WEIGHTS.serviceArea
      );
      
      // Phase 1: Calculate AI Summary Likelihood using new method (overlay only, not part of GAIO score)
      // Handle both number format (legacy) and object format (if it exists)
      const snippetReadinessScore = typeof snippetReadiness === 'number' 
        ? snippetReadiness 
        : (snippetReadiness?.overallScore || 0);
      const brandScore = scores.brandOverlay?.score || 0;
      
      // Use new computeAiSummaryLikelihood if we have snippet readiness data (brandScore can be 0)
      let aiSummary;
      if (snippetReadinessScore > 0) {
        aiSummary = computeAiSummaryLikelihood(snippetReadinessScore, visibilityScore, brandScore);
      } else {
        // Fallback to old method for backward compatibility
        aiSummary = {
          label: calculateAiSummaryLikelihood({
            aiGeoScore,
            authority: authorityScore,
            content: contentScore,
            coverage: 0 // Not used in new calculation
          }),
          score: aiGeoScore, // Use aiGeoScore as fallback
          reasons: []
        };
      }
      
      return {
        aiGeoScore, // Calculated from 5 pillars ONLY
        aiGeoStatus: aiGeoScore >= 70 ? 'green' : aiGeoScore >= 50 ? 'amber' : 'red',
        aiSummaryLikelihood: aiSummary.label, // Keep backward compatibility
        aiSummary: aiSummary // New Phase 1 field (overlay only)
      };
    }
    
    // Calculate AI Summary Likelihood (OLD - kept for backward compatibility, but will be replaced)
    // NOTE: This is being replaced by computeAiSummaryLikelihood which uses snippetReadiness, visibility, and brand
    function calculateAiSummaryLikelihood({ aiGeoScore, authority, content, coverage }) {
      const strongAuthority = authority >= 65;
      const strongContent = content >= 70;
      const strongCoverage = coverage >= 80;
      
      if (aiGeoScore >= 75 && strongAuthority && strongContent && strongCoverage) {
        return 'high';
      }
      if (aiGeoScore >= 55) {
        return 'medium';
      }
      return 'low';
    }

    function calculateSnippetReadiness(scores, data) {
      // Snippet readiness combines:
      // 1. Content/Schema score (structured data quality)
      // 2. Visibility score (SERP feature presence)
      // 3. Authority score (content depth and trust)
      // Weighted average: 40% Content/Schema, 35% Visibility, 25% Authority
      // Handle both old format (number) and new format (object with score)
      const authorityScore = typeof scores.authority === 'object' ? scores.authority.score : scores.authority;
      const readiness = (
        scores.contentSchema * 0.4 +
        scores.visibility * 0.35 +
        authorityScore * 0.25
      );
      return Math.round(Math.min(100, Math.max(0, readiness)));
    }

    // Fetch real data from Google Search Console API using unified endpoint
    // Note: apiKey parameter kept for compatibility but not used (endpoint uses OAuth2)
    async function fetchSearchConsoleData(apiKey, propertyUrl, days) {
      debugLog(`Fetching real GSC data for ${days} days...`, 'info');
      
      // Calculate date range
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);
      
      // Format dates as YYYY-MM-DD
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      const startDateStr = formatDate(startDate);
      const endDateStr = formatDate(endDate);
      
      debugLog(`Date range: ${startDateStr} to ${endDateStr}`, 'info');
      
      try {
        // Get tracked keywords for queryTotals fetching
        const trackedKeywords = window.RankingAiModule?.TRACKED_KEYWORDS || [];
        const keywordsParam = trackedKeywords.length > 0 
          ? `&keywords=${encodeURIComponent(JSON.stringify(trackedKeywords))}`
          : '';
        
        // Call unified GSC entity metrics endpoint
        const response = await fetch(apiUrl(`/api/aigeo/gsc-entity-metrics?property=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDateStr}${keywordsParam}`));

        if (!response.ok) {
          // Try to parse as JSON, but handle non-JSON error responses
          let errorData = null;
          const contentType = response.headers.get('content-type') || '';
          try {
            if (contentType.includes('application/json')) {
              errorData = await response.json();
            } else {
              // Response is not JSON (likely HTML error page)
              const errorText = await response.text();
              debugLog(` GSC API returned non-JSON error (HTTP ${response.status}): ${errorText.substring(0, 200)}`, 'error');
              throw new Error(`Server error (HTTP ${response.status}): ${errorText.substring(0, 100)}...`);
            }
          } catch (parseError) {
            // If JSON parsing fails, use the parse error or create a generic error
            if (parseError.message && !parseError.message.includes('Server error')) {
              debugLog(` Failed to parse error response: ${parseError.message}`, 'error');
              throw new Error(`Server error (HTTP ${response.status}): Unable to parse error response. The API may be experiencing issues.`);
            }
            throw parseError;
          }
          
          debugLog(` GSC API error: ${errorData.message || errorData.error}`, 'error');
          if (errorData.details) {
            debugLog(`Details: ${errorData.details}`, 'error');
          }
          
          // If OAuth not configured, show helpful message
          if (errorData.message && errorData.message.includes('OAuth2 credentials not configured')) {
            throw new Error('Google Search Console OAuth2 credentials not configured. Please set GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, and GOOGLE_REFRESH_TOKEN in Vercel environment variables.');
          }
          
          throw new Error(errorData.message || errorData.error || 'Failed to fetch Search Console data');
        }

        const gsc = await response.json();
        
        if (gsc.status !== 'ok') {
          throw new Error(gsc.message || 'Failed to fetch Search Console data');
        }
        
        debugLog(` Real GSC data fetched: ${gsc.data.overview.totalClicks} clicks, ${gsc.data.overview.totalImpressions} impressions`, 'success');
        
        // Log segmentation data availability
        if (gsc.data.queryPages && gsc.data.queryPages.length > 0) {
          debugLog(` GSC API returned ${gsc.data.queryPages.length} query+page combinations for segmentation`, 'success');
        } else {
          debugLog(' GSC API did not return queryPages data. Segmentation will use fallback calculation.', 'warn');
        }
        
        // Log queryTotals availability
        if (gsc.data.queryTotals && gsc.data.queryTotals.length > 0) {
          debugLog(` GSC API returned ${gsc.data.queryTotals.length} query-only totals for tracked keywords`, 'success');
        } else {
          debugLog(' GSC API did not return queryTotals data. Table will show  for missing keywords.', 'warn');
        }
        
        // Return data in format expected by existing code
        const searchData = {
          totalClicks: gsc.data.overview.totalClicks || 0,
          totalImpressions: gsc.data.overview.totalImpressions || 0,
          averagePosition: gsc.data.overview.avgPosition || 0,
          ctr: gsc.data.overview.ctr || 0, // Already 0-100 from API
          topQueries: gsc.data.topQueries || [],
          queryPages: gsc.data.queryPages || [], // Query+page combinations for segmentation
          queryTotals: gsc.data.queryTotals || [], // Query-only totals for tracked keywords (for table)
          timeseries: gsc.data.timeseries || [], // For trend chart
          dateRange: days,
          // Store full GSC response for trend chart access
          _gscResponse: gsc,
          // Create overview object with siteTotalImpressions and siteTotalClicks for buildMoneyPagesSummary
          overview: {
            siteTotalImpressions: gsc.data.overview.totalImpressions || 0,
            siteTotalClicks: gsc.data.overview.totalClicks || 0,
            totalImpressions: gsc.data.overview.totalImpressions || 0,
            totalClicks: gsc.data.overview.totalClicks || 0
          }
        };
        return searchData;
      } catch (error) {
        debugLog(` Error fetching GSC data: ${error.message}`, 'error');
        throw error;
      }
    }

    // Run the audit
    async function runAudit() {
      debugLog('=== AUDIT START: Beginning audit scan ===', 'info');
      
      // Get API key - prioritize Vercel env var, then loaded key, then localStorage
      let apiKey = window._loadedApiKey;
      
      // Try Vercel environment variable first
      if (!apiKey) {
        try {
          debugLog('Fetching API key from Vercel environment variable...', 'info');
          const response = await fetch(apiUrl('/api/get-api-key'));
          if (response.ok) {
            const data = await response.json();
            if (data.apiKey) {
              apiKey = data.apiKey;
              debugLog(' Using API key from Vercel environment variable', 'success');
              window._loadedApiKey = apiKey;
            }
          }
        } catch (e) {
          debugLog('Vercel env var endpoint not available', 'info');
        }
      }
      
      // Fall back to config.js
      if (!apiKey && window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey) {
        apiKey = window.API_CONFIG.googleSearchConsoleApiKey;
        debugLog(' Using API key from config.js', 'success');
        window._loadedApiKey = apiKey;
      }
      
      // Fall back to localStorage
      if (!apiKey) {
        apiKey = localStorage.getItem('gsc_api_key');
        if (apiKey) {
          debugLog(' Using API key from localStorage', 'success');
          window._loadedApiKey = apiKey;
        }
      }
      
      const propertyUrl = document.getElementById('propertyUrl').value;
      const dateRange = parseInt(document.getElementById('dateRange').value);
      
      debugLog(`Property URL: ${propertyUrl}`, 'info');
      debugLog(`Date Range: ${dateRange} days`, 'info');

      // Note: API key no longer required - new endpoint uses OAuth2 from env vars
      if (!propertyUrl) {
        debugLog(' No property URL provided', 'error');
        showStatus('Please enter your property URL', 'error');
        return;
      }

      debugLog('Showing loading indicator...', 'info');
      document.getElementById('loading').classList.add('show');
      document.getElementById('dashboard').style.display = 'none';
      updateProgress(0, 'Initializing audit scan...');

      // Load saved audit data first to use as defaults (preserve data when sources unavailable)
      let savedAudit = null;
      try {
        const saved = localStorage.getItem('last_audit_results');
        if (saved) {
          savedAudit = JSON.parse(saved);
          debugLog(' Loaded previous audit data for fallback', 'info');
        }
      } catch (e) {
        debugLog(` Could not load previous audit data: ${e.message}`, 'warn');
      }

      // Declare schemaAudit outside try block so it's accessible in finally
      // Initialize with saved data if available (preserves Content/Schema when endpoint unavailable)
      let schemaAudit = savedAudit?.schemaAudit || null;
      let localSignals = savedAudit?.localSignals || null;
      // Don't use cached siteReviews - always fetch fresh Trustpilot snapshot
      // Old cached values (4.8, 127) should be replaced with new snapshot (4.6, 610)
      let siteReviews = null; // Always fetch fresh
      let backlinkMetrics = savedAudit?.backlinkMetrics || null;

      try {
        updateProgress(10, 'Fetching Search Console data...');
        debugLog('Fetching Search Console data...', 'info');
        // Fetch data
        const searchData = await fetchSearchConsoleData(apiKey, propertyUrl, dateRange);
        debugLog(' Search Console data fetched successfully', 'success');
        debugLog(`Data: ${JSON.stringify(searchData).substring(0, 200)}...`, 'info');
        
        updateProgress(35, 'Fetching local signals data...');
        debugLog('Fetching local signals data...', 'info');
        // Fetch local signals (Business Profile) data
        // Only fetch if we don't have saved data, or always fetch fresh (Business Profile can change)
        try {
          const localSignalsResponse = await fetch(apiUrl(`/api/aigeo/local-signals?property=${encodeURIComponent(propertyUrl)}`));
          if (localSignalsResponse.ok) {
            const freshLocalSignals = await localSignalsResponse.json();
            if (freshLocalSignals.status === 'ok') {
              localSignals = freshLocalSignals;
              debugLog(' Local signals data fetched successfully', 'success');
              debugLog(`Service areas: ${localSignals.data.serviceAreas?.length || 0}, NAP score: ${localSignals.data.napConsistencyScore || 'N/A'}`, 'info');
            } else {
              debugLog(' Local signals returned error, using saved data if available', 'warn');
            }
          } else {
            debugLog(' Local signals endpoint not available, using saved data if available', 'warn');
          }
        } catch (localSignalsError) {
          debugLog(` Local signals error: ${localSignalsError.message}, using saved data if available`, 'warn');
        }
        
        // If fetch failed but we have saved data, keep using it
        if (!localSignals && savedAudit?.localSignals) {
          localSignals = savedAudit.localSignals;
          debugLog(' Using saved local signals data', 'info');
        }
        
        updateProgress(37, 'Fetching Trustpilot snapshot data...');
        debugLog('Fetching Trustpilot snapshot data...', 'info');
        // Always fetch fresh Trustpilot snapshot data (it's a fixed snapshot, so should always work)
        try {
          const siteReviewsResponse = await fetch(apiUrl('/api/reviews/site-reviews'));
          if (siteReviewsResponse.ok) {
            const siteReviewsData = await siteReviewsResponse.json();
            if (siteReviewsData.status === 'ok' && siteReviewsData.data) {
              siteReviews = siteReviewsData.data;
              debugLog(' Trustpilot snapshot data fetched successfully', 'success');
              debugLog(`Trustpilot snapshot: rating=${siteReviews.siteRating}, count=${siteReviews.siteReviewCount}`, 'info');
            } else {
              debugLog(' Trustpilot snapshot returned error, using saved data if available', 'warn');
              // Fallback to saved data only if API completely fails
              if (savedAudit?.siteReviews) {
                siteReviews = savedAudit.siteReviews;
                debugLog(' Using saved Trustpilot data as fallback (will override with correct values)', 'warn');
              }
            }
          } else {
            debugLog(' Trustpilot snapshot endpoint not available, using saved data if available', 'warn');
            // Fallback to saved data only if API completely fails
            if (savedAudit?.siteReviews) {
              siteReviews = savedAudit.siteReviews;
              debugLog(' Using saved Trustpilot data as fallback (will override with correct values)', 'warn');
            }
          }
        } catch (siteReviewsError) {
          debugLog(` Trustpilot snapshot error: ${siteReviewsError.message}, using saved data if available`, 'warn');
          // Fallback to saved data only if API completely fails
          if (savedAudit?.siteReviews) {
            siteReviews = savedAudit.siteReviews;
            debugLog(' Using saved Trustpilot data as fallback (will override with correct values)', 'warn');
          }
        }
        
        // ALWAYS force correct Trustpilot snapshot values (4.6, 610) - override ANY old values
        // This ensures we always use the correct snapshot regardless of API response or cached data
        const TRUSTPILOT_SNAPSHOT = {
          siteRating: 4.6,
          siteReviewCount: 610,
          lastUpdated: '2025-12-07',
          notes: 'Fixed Trustpilot snapshot for Authority score calculation. Update manually when Trustpilot metrics change significantly.'
        };
        
        if (!siteReviews || siteReviews.siteRating !== 4.6 || siteReviews.siteReviewCount !== 610) {
          if (siteReviews) {
            debugLog(` Overriding old Trustpilot values (${siteReviews.siteRating}, ${siteReviews.siteReviewCount}) with correct snapshot (4.6, 610)`, 'warn');
          } else {
            debugLog(' Using default Trustpilot snapshot values (4.6, 610)', 'warn');
          }
          siteReviews = TRUSTPILOT_SNAPSHOT;
        } else {
          debugLog(' Trustpilot snapshot verified (4.6, 610)', 'success');
        }
        
        updateProgress(38, 'Fetching backlink metrics data...');
        debugLog('Fetching backlink metrics data...', 'info');
        // Fetch backlink metrics - try localStorage first (from CSV upload), then API
        let backlinkMetrics = null;
        
        // First, try to get from localStorage (stored when CSV was uploaded)
        try {
          const storedMetrics = localStorage.getItem('backlink_metrics');
          if (storedMetrics) {
            backlinkMetrics = JSON.parse(storedMetrics);
            debugLog(' Backlink metrics loaded from localStorage', 'success');
            debugLog(`Backlink metrics: domains=${backlinkMetrics.referringDomains}, links=${backlinkMetrics.totalBacklinks}, followRatio=${(backlinkMetrics.followRatio * 100).toFixed(1)}%`, 'info');
          }
        } catch (e) {
          debugLog(` Error reading backlink metrics from localStorage: ${e.message}`, 'warn');
        }
        
        // If not in localStorage, try API (for cases where metrics were uploaded via API directly)
        if (!backlinkMetrics) {
          try {
            const backlinkResponse = await fetch(apiUrl('/api/aigeo/backlink-metrics'));
            if (backlinkResponse.ok) {
              const backlinkData = await backlinkResponse.json();
              if (backlinkData.status === 'ok' && backlinkData.data && backlinkData.data.totalBacklinks > 0) {
                backlinkMetrics = backlinkData.data;
                // Store in localStorage for next time
                localStorage.setItem('backlink_metrics', JSON.stringify(backlinkMetrics));
                debugLog(' Backlink metrics data fetched from API and stored', 'success');
                debugLog(`Backlink metrics: domains=${backlinkMetrics.referringDomains}, links=${backlinkMetrics.totalBacklinks}, followRatio=${(backlinkMetrics.followRatio * 100).toFixed(1)}%`, 'info');
              } else {
                debugLog(' Backlink metrics returned empty/zero, using saved data if available', 'warn');
              }
            } else {
              debugLog(' Backlink metrics endpoint not available, using saved data if available', 'warn');
            }
          } catch (backlinkError) {
            debugLog(` Backlink metrics error: ${backlinkError.message}, using saved data if available`, 'warn');
          }
        }
        
        // If fetch failed but we have saved data, keep using it
        if (!backlinkMetrics && savedAudit?.backlinkMetrics) {
          backlinkMetrics = savedAudit.backlinkMetrics;
          debugLog(' Using saved backlink metrics data', 'info');
        }
        
        updateProgress(40, 'Fetching schema audit data...');
        debugLog('Fetching schema audit data...', 'info');
        // Fetch schema audit data
        try {
          // Check if manual URL list is available
          const manualUrlList = localStorage.getItem('manual_url_list');
          let schemaRequest;
          
          if (manualUrlList) {
            try {
              const urls = JSON.parse(manualUrlList);
              debugLog(`Using manual URL list: ${urls.length} URLs`, 'info');
              updateProgress(45, `Crawling ${urls.length} URLs for schema markup...`);
              schemaRequest = fetch(apiUrl('/api/schema-audit'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ urls })
              });
            } catch (e) {
              debugLog(' Failed to parse manual URL list, using default CSV', 'warn');
              updateProgress(45, 'Loading URLs from CSV and crawling for schema markup...');
              schemaRequest = fetch(apiUrl('/api/schema-audit'));
            }
          } else {
            debugLog('No manual URL list, using default CSV source', 'info');
            updateProgress(45, 'Loading URLs from CSV and crawling for schema markup...');
            schemaRequest = fetch(apiUrl('/api/schema-audit'));
          }
          
          const schemaResponse = await schemaRequest;
          if (schemaResponse.ok) {
            schemaAudit = await schemaResponse.json();
            if (schemaAudit.status === 'ok') {
              debugLog(' Schema audit data fetched successfully', 'success');
              debugLog(`Schema coverage: ${schemaAudit.data.coverage}%`, 'info');
              if (manualUrlList) {
                debugLog('  Source: Manual URL list', 'info');
              } else {
                debugLog('  Source: CSV (GitHub/hosted)', 'info');
              }
              
              // Log comprehensive diagnostic info if available
              if (schemaAudit.meta && schemaAudit.meta.diagnostic) {
                const diag = schemaAudit.meta.diagnostic;
                debugLog('', 'info');
                debugLog(' SCHEMA AUDIT DIAGNOSTICS', 'info');
                debugLog('', 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                debugLog(' PAGE COUNTS:', 'info');
                debugLog(`   Total pages scanned: ${diag.totalPages}`, 'info');
                debugLog(`   Successful crawls: ${diag.successfulPages || diag.totalPages}`, 'info');
                debugLog(`   Failed crawls: ${diag.failedPages || 0}`, diag.failedPages > 0 ? 'warn' : 'info');
                if (diag.failedPages > 0) {
                  debugLog(`     Failed crawls are counted as pages without schema`, 'warn');
                  
                  // Show error breakdown if available
                  if (diag.errorTypes && Object.keys(diag.errorTypes).length > 0) {
                    debugLog('', 'info'); // Empty line
                    debugLog('   ERROR BREAKDOWN:', 'warn');
                    Object.entries(diag.errorTypes).forEach(([type, count]) => {
                      debugLog(`     ${type}: ${count} pages`, 'warn');
                      if (diag.errorExamples && diag.errorExamples[type]) {
                        const example = diag.errorExamples[type];
                        debugLog(`      Example: ${example.url}`, 'info');
                        debugLog(`      Error: ${example.error}`, 'info');
                      }
                    });
                  }
                }
                debugLog(`   Pages with inline schema: ${diag.pagesWithInlineSchema}`, 'info');
                debugLog(`   Pages without inline schema: ${diag.pagesWithoutInlineSchema}`, 'info');
                if (diag.failedPages > 0) {
                  debugLog(`    (includes ${diag.failedPages} failed crawls)`, 'info');
                }
                debugLog(`   Pages with inherited schema: ${diag.pagesWithInheritedSchema}`, 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                if (diag.urlsWithoutSchemas && diag.urlsWithoutSchemas.length > 0) {
                  debugLog(' URLs WITHOUT SCHEMAS:', 'info');
                  diag.urlsWithoutSchemas.forEach(url => {
                    debugLog(`   ${url}`, 'info');
                  });
                  if (diag.pagesWithoutInlineSchema > diag.urlsWithoutSchemas.length) {
                    debugLog(`  ... and ${diag.pagesWithoutInlineSchema - diag.urlsWithoutSchemas.length} more`, 'info');
                  }
                  debugLog('', 'info'); // Empty line for spacing
                }
                
                debugLog(' MISSING SCHEMA BREAKDOWN:', 'info');
                debugLog(`   Pages with parent but no inherited: ${diag.pagesWithParentButNoInherited}`, 'info');
                debugLog(`   Pages with parent but not checked: ${diag.pagesWithParentButNotChecked}`, diag.pagesWithParentButNotChecked > 0 ? 'warn' : 'info');
                debugLog(`   Pages without parent page: ${diag.pagesWithoutParent}`, 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                debugLog(' VALIDATION:', 'info');
                debugLog(`   Total missing pages (calculated): ${diag.totalMissing}`, 'info');
                debugLog(`   Expected missing (total - inline - inherited): ${diag.expectedMissing}`, 'info');
                
                if (diag.mismatch) {
                  debugLog('', 'info'); // Empty line for spacing
                  debugLog(`   MISMATCH DETECTED!`, 'error');
                  debugLog(`  ${diag.mismatchDetails}`, 'error');
                  debugLog(`  This indicates pages are being double-counted or missed in the calculation.`, 'error');
                } else {
                  debugLog(`   Counts match correctly`, 'success');
                }
                
                debugLog('', 'info'); // Empty line for spacing
                debugLog('', 'info');
              }
            } else {
              debugLog(` Schema audit returned error status: ${schemaAudit.status}`, 'warn');
              if (schemaAudit.message) {
                debugLog(`  Error message: ${schemaAudit.message}`, 'warn');
              }
            }
          } else {
            const errorText = await schemaResponse.text();
            debugLog(` Schema audit endpoint returned ${schemaResponse.status}: ${schemaResponse.statusText}`, 'warn');
            if (errorText) {
              debugLog(`  Response: ${errorText.substring(0, 200)}`, 'warn');
            }
            // schemaAudit already initialized with saved data at start, so it's preserved
            if (schemaAudit) {
              debugLog(' Using saved schema audit data from previous audit', 'success');
              debugLog(`Schema coverage: ${schemaAudit.data?.coverage || 'N/A'}%`, 'info');
            } else {
              debugLog(' No saved schema audit data available', 'warn');
            }
          }
        } catch (schemaError) {
          debugLog(` Schema audit error: ${schemaError.message}, using saved data`, 'warn');
          // schemaAudit already initialized with saved data at start, so it's preserved
          if (schemaAudit) {
            debugLog(' Using saved schema audit data from previous audit (fallback)', 'success');
            debugLog(`Schema coverage: ${schemaAudit.data?.coverage || 'N/A'}%`, 'info');
          } else {
            debugLog(' No saved schema audit data available', 'warn');
          }
        }
        
        updateProgress(70, 'Calculating pillar scores...');
        debugLog('Calculating pillar scores...', 'info');
        // Calculate scores (pass schema audit data, local signals, site reviews, and backlink metrics)
        const scores = await calculatePillarScores(searchData, schemaAudit, localSignals, siteReviews, backlinkMetrics);
        debugLog(' Pillar scores calculated', 'success');
        debugLog(`Scores: ${JSON.stringify(scores)}`, 'info');

        updateProgress(85, 'Calculating snippet readiness...');
        debugLog('Calculating snippet readiness...', 'info');
        const snippetReadiness = calculateSnippetReadiness(scores, searchData);
        debugLog(`Snippet readiness: ${snippetReadiness}`, 'info');

        updateProgress(95, 'Generating dashboard...');
        debugLog('Displaying dashboard...', 'info');
        // Display results (pass current audit data including localSignals)
        displayDashboard(scores, searchData, snippetReadiness, schemaAudit, localSignals);
        
        updateProgress(100, 'Audit completed successfully!');
        debugLog('=== AUDIT COMPLETE: Success ===', 'success');
        
        // Save audit results to localStorage
        saveAuditResults(scores, searchData, snippetReadiness, schemaAudit, localSignals, siteReviews, backlinkMetrics);
        
        // Save audit results to Supabase for historical tracking
        // Note: saveAuditToSupabase is async, so we can await it or use .then()
        (async () => {
          try {
            await saveAuditToSupabase(propertyUrl, scores, searchData, snippetReadiness, schemaAudit, localSignals, new Date().toISOString().split('T')[0]);
            // After saving to Supabase, refresh the trend chart to show the latest audit
            debugLog('Refreshing Score Trends chart after saving audit...', 'info');
            // Re-render the dashboard to update the trend chart with new data
            setTimeout(async () => {
              const saved = loadAuditResultsSync();
              if (saved && saved.scores && saved.searchData) {
                try {
                  await displayDashboard(saved.scores, saved.searchData, saved.snippetReadiness || 0, saved.schemaAudit || null, saved.localSignals || null);
                  debugLog(' Score Trends chart refreshed after saving audit', 'success');
                } catch (err) {
                  debugLog(` Error refreshing trend chart: ${err.message}`, 'warn');
                }
              }
            }, 1000); // Delay to ensure Supabase save is complete
          } catch (err) {
            debugLog(` Error saving to Supabase (chart refresh skipped): ${err.message}`, 'warn');
          }
        })();
        
        showStatus('Audit completed successfully!', 'success');
      } catch (error) {
        debugLog(` AUDIT ERROR: ${error.message}`, 'error');
        debugLog(`Stack trace: ${error.stack}`, 'error');
        showStatus('Error running audit: ' + error.message, 'error');
        console.error(error);
      } finally {
        debugLog('Hiding loading indicator...', 'info');
        document.getElementById('loading').classList.remove('show');
        
        // Show completion summary modal
        debugLog(`Schema audit available for modal: ${schemaAudit ? 'yes' : 'no'}`, 'info');
        if (schemaAudit) {
          debugLog('Showing completion modal...', 'info');
          setTimeout(() => {
            showCompletionModal(schemaAudit);
          }, 500);
        } else {
          debugLog(' No schema audit data available for modal', 'warn');
        }
        
        // Reset progress bar for next run
        setTimeout(() => {
          updateProgress(0, 'Initializing audit scan...');
        }, 500);
      }
    }

    // Fetch and parse site-urls.csv from GitHub
    async function fetchAndParseSiteUrlsCsv() {
      const GITHUB_CSV_URL = "https://raw.githubusercontent.com/alanranger/alan-shared-resources/main/csv/06-site-urls.csv";
      const FALLBACK_CSV_URL = "https://schema-tools-six.vercel.app/06-site-urls.csv";
      
      try {
        // Try GitHub first
        const res = await fetch(GITHUB_CSV_URL);
        if (!res.ok) throw new Error(`GitHub fetch failed: HTTP ${res.status}`);
        const csvText = await res.text();
        
        // Parse CSV - extract URLs from url column
        const lines = csvText.split('\n').filter(line => line.trim());
        const urls = [];
        
        // Parse header row to find URL column index
        let urlColumnIndex = 0;
        if (lines.length > 0) {
          const headerLine = lines[0].trim();
          const headers = parseCsvLine(headerLine);
          const urlHeaderIndex = headers.findIndex(h => h.toLowerCase() === 'url');
          if (urlHeaderIndex !== -1) {
            urlColumnIndex = urlHeaderIndex;
          }
        }
        
        // Helper function to parse CSV line with proper quote handling
        function parseCsvLine(line) {
          const columns = [];
          let current = '';
          let inQuotes = false;
          
          for (let i = 0; i < line.length; i++) {
            const char = line[i];
            const nextChar = line[i + 1];
            
            if (char === '"') {
              if (inQuotes && nextChar === '"') {
                current += '"';
                i++;
              } else {
                inQuotes = !inQuotes;
              }
            } else if (char === ',' && !inQuotes) {
              columns.push(current.trim());
              current = '';
            } else {
              current += char;
            }
          }
          columns.push(current.trim());
          return columns;
        }
        
        // Parse data rows (skip header)
        for (let i = 1; i < lines.length; i++) {
          const columns = parseCsvLine(lines[i]);
          if (columns[urlColumnIndex]) {
            const url = columns[urlColumnIndex].trim();
            if (url) {
              // Accept URLs starting with http/https, or relative URLs starting with /
              // Also accept full URLs without protocol (will be normalized)
              if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('/')) {
                urls.push(url);
              } else if (url.includes('.') && !url.includes(' ')) {
                // Likely a URL without protocol - add https://
                urls.push(url.startsWith('//') ? `https:${url}` : `https://${url}`);
              }
            }
          }
        }
        
        return urls;
      } catch (githubErr) {
        // Try fallback
        try {
          const fallbackRes = await fetch(FALLBACK_CSV_URL);
          if (!fallbackRes.ok) throw new Error(`Fallback fetch failed: HTTP ${fallbackRes.status}`);
          const csvText = await fallbackRes.text();
          
          // Same parsing logic as above
          const lines = csvText.split('\n').filter(line => line.trim());
          const urls = [];
          let urlColumnIndex = 0;
          
          if (lines.length > 0) {
            const headerLine = lines[0].trim();
            const headers = parseCsvLine(headerLine);
            const urlHeaderIndex = headers.findIndex(h => h.toLowerCase() === 'url');
            if (urlHeaderIndex !== -1) {
              urlColumnIndex = urlHeaderIndex;
            }
          }
          
          function parseCsvLine(line) {
            const columns = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
              const char = line[i];
              const nextChar = line[i + 1];
              if (char === '"') {
                if (inQuotes && nextChar === '"') {
                  current += '"';
                  i++;
                } else {
                  inQuotes = !inQuotes;
                }
              } else if (char === ',' && !inQuotes) {
                columns.push(current.trim());
                current = '';
              } else {
                current += char;
              }
            }
            columns.push(current.trim());
            return columns;
          }
          
          for (let i = 1; i < lines.length; i++) {
            const columns = parseCsvLine(lines[i]);
            if (columns[urlColumnIndex]) {
              const url = columns[urlColumnIndex].trim();
              if (url) {
                // Accept URLs starting with http/https, or relative URLs starting with /
                // Also accept full URLs without protocol (will be normalized)
                if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('/')) {
                  urls.push(url);
                } else if (url.includes('.') && !url.includes(' ')) {
                  // Likely a URL without protocol - add https://
                  urls.push(url.startsWith('//') ? `https:${url}` : `https://${url}`);
                }
              }
            }
          }
          
          return urls;
        } catch (fallbackErr) {
          throw new Error(`Unable to load site URLs CSV: ${githubErr.message}`);
        }
      }
    }
    
    // Display dashboard
    async function displayDashboard(scores, data, snippetReadiness = 0, schemaAudit = null, localSignals = null) {
      // Normalize localSignals structure if needed (handle old format where it might just be {data: {...}})
      if (localSignals && localSignals.data && !localSignals.status) {
        debugLog(`[displayDashboard] Normalizing localSignals structure - wrapping in status/data format`, 'info');
        localSignals = { status: 'ok', data: localSignals.data || localSignals };
      }
      // Update timestamp if this is a fresh display
      const saved = await loadAuditResults();
      if (saved && saved.timestamp) {
        updateAuditTimestamp(saved.timestamp);
      }
      
      // CRITICAL: Ensure Money Pages data is in scores object
      // If scores.moneyPagesMetrics is missing, get it from saved data
      // Check explicitly for null/undefined/false (not just falsy)
      debugLog(`DEBUG: Checking moneyPagesMetrics - scores.moneyPagesMetrics=${scores?.moneyPagesMetrics}, type=${typeof scores?.moneyPagesMetrics}, saved.scores.moneyPagesMetrics=${saved?.scores?.moneyPagesMetrics}, type=${typeof saved?.scores?.moneyPagesMetrics}, saved.moneyPagesMetrics=${saved?.moneyPagesMetrics}, type=${typeof saved?.moneyPagesMetrics}`, 'info');
      
      if (!scores.moneyPagesMetrics || scores.moneyPagesMetrics === null || scores.moneyPagesMetrics === false) {
        if (saved && saved.scores && saved.scores.moneyPagesMetrics !== null && saved.scores.moneyPagesMetrics !== undefined && saved.scores.moneyPagesMetrics !== false) {
          scores.moneyPagesMetrics = saved.scores.moneyPagesMetrics;
          debugLog(` Restored moneyPagesMetrics from saved.scores (${saved.scores.moneyPagesMetrics.rows?.length || 0} rows)`, 'success');
        } else if (saved && saved.moneyPagesMetrics !== null && saved.moneyPagesMetrics !== undefined && saved.moneyPagesMetrics !== false) {
          scores.moneyPagesMetrics = saved.moneyPagesMetrics;
          debugLog(` Restored moneyPagesMetrics from saved.moneyPagesMetrics (${saved.moneyPagesMetrics.rows?.length || 0} rows)`, 'success');
        } else {
          debugLog(` No moneyPagesMetrics found in saved data: saved.scores.moneyPagesMetrics=${saved?.scores?.moneyPagesMetrics} (type: ${typeof saved?.scores?.moneyPagesMetrics}), saved.moneyPagesMetrics=${saved?.moneyPagesMetrics} (type: ${typeof saved?.moneyPagesMetrics})`, 'warn');
        }
      }
      
      // Store globally for Money Pages sections
      if (scores.moneyPagesMetrics) {
        window.currentMoneyPagesMetrics = scores.moneyPagesMetrics;
        window.moneyPagesMetrics = scores.moneyPagesMetrics;
        debugLog(` Stored moneyPagesMetrics globally: ${scores.moneyPagesMetrics.rows?.length || 0} rows`, 'success');
      }
      
      // Use current audit data (passed as parameter) or fallback to saved data
      // This ensures we always use the most recent audit run data, not stale localStorage
      // Check both localSignals and localSignalsSnapshot (different storage formats)
      const currentLocalSignals = localSignals || (saved && (saved.localSignals || saved.localSignalsSnapshot)) || null;
      
      // DEBUG: Log currentLocalSignals structure
      if (currentLocalSignals) {
        debugLog(`[displayDashboard] currentLocalSignals structure: status=${currentLocalSignals.status}, hasData=${!!currentLocalSignals.data}, hasLocations=${!!currentLocalSignals.data?.locations}, locationsCount=${currentLocalSignals.data?.locations?.length || 0}`, 'info');
        if (currentLocalSignals.data && currentLocalSignals.data.locations) {
          debugLog(`[displayDashboard] currentLocalSignals.data.locations type: ${typeof currentLocalSignals.data.locations}, isArray: ${Array.isArray(currentLocalSignals.data.locations)}, length: ${currentLocalSignals.data.locations.length}`, 'info');
        } else {
          debugLog(`[displayDashboard]  currentLocalSignals.data.locations is missing!`, 'warn');
        }
      } else {
        debugLog(`[displayDashboard]  currentLocalSignals is null!`, 'warn');
      }
      
      // Restore Money Pages Priority Matrix data from localStorage
      // If not available, try to rebuild from saved data
      if (saved && saved.moneyPagePriorityData && Array.isArray(saved.moneyPagePriorityData) && saved.moneyPagePriorityData.length > 0) {
        window.moneyPagePriorityData = saved.moneyPagePriorityData;
        // Use saved moneySegmentMetrics if available, otherwise rebuild
        if (saved.moneySegmentMetrics) {
          window.moneySegmentMetrics = saved.moneySegmentMetrics;
          debugLog(` Restored Money Pages Priority data and segment metrics from localStorage: ${window.moneyPagePriorityData.length} pages`, 'success');
        } else {
          window.moneySegmentMetrics = null;
          debugLog(` Restored Money Pages Priority data from localStorage: ${window.moneyPagePriorityData.length} pages (no segment metrics)`, 'success');
        }
      } else {
        // Try to rebuild from saved data - check multiple locations
        // IMPORTANT: Check for null/undefined explicitly, not just truthy (null is falsy but we need to distinguish it from missing)
        let savedMetrics = null;
        if (saved && saved.scores && saved.scores.moneyPagesMetrics !== null && saved.scores.moneyPagesMetrics !== undefined && saved.scores.moneyPagesMetrics !== false) {
          savedMetrics = saved.scores.moneyPagesMetrics;
          debugLog(` Found moneyPagesMetrics in saved.scores.moneyPagesMetrics`, 'success');
        } else if (saved && saved.moneyPagesMetrics !== null && saved.moneyPagesMetrics !== undefined && saved.moneyPagesMetrics !== false) {
          savedMetrics = saved.moneyPagesMetrics;
          debugLog(` Found moneyPagesMetrics in saved.moneyPagesMetrics`, 'success');
        } else if (scores && scores.moneyPagesMetrics !== null && scores.moneyPagesMetrics !== undefined && scores.moneyPagesMetrics !== false) {
          savedMetrics = scores.moneyPagesMetrics;
          debugLog(` Found moneyPagesMetrics in scores.moneyPagesMetrics`, 'success');
        } else {
          debugLog(` moneyPagesMetrics not found in any location: saved.scores.moneyPagesMetrics=${saved?.scores?.moneyPagesMetrics}, saved.moneyPagesMetrics=${saved?.moneyPagesMetrics}, scores.moneyPagesMetrics=${scores?.moneyPagesMetrics}`, 'warn');
        }
        
        const savedSearchData = data || (saved && saved.searchData);
        
        if (savedMetrics && savedMetrics.rows && Array.isArray(savedMetrics.rows) && savedMetrics.rows.length > 0 && savedSearchData) {
          // Rebuild from saved data if priority data is missing but we have the source data
          // schemaAudit is optional - buildMoneyPageMetrics can work without it
          try {
            debugLog(`Rebuilding Money Pages Priority data from ${savedMetrics.rows.length} rows`, 'info');
            const topPagesForPriority = savedMetrics.rows.map(row => ({
              page: row.url,
              url: row.url,
              clicks: row.clicks || 0,
              impressions: row.impressions || 0,
              ctr: (row.ctr || 0) * 100, // Convert to percentage for buildMoneyPageMetrics
              position: row.avgPosition || 0,
              avgPosition: row.avgPosition || 0,
              title: row.title || row.url
            }));
            
            // Use schemaAudit if available, otherwise pass null (function handles it)
            const auditSchema = schemaAudit || (saved && saved.schemaAudit) || null;
            // Use global function - it should be available after the function is defined
            // If not available, try to wait a bit for it to load
            if (typeof window.buildMoneyPageMetrics !== 'function') {
              debugLog(' buildMoneyPageMetrics not available, waiting 100ms...', 'warn');
              // Wait a bit for function to be defined (in case script hasn't finished loading)
              await new Promise(resolve => setTimeout(resolve, 100));
              
              if (typeof window.buildMoneyPageMetrics !== 'function') {
                debugLog(' buildMoneyPageMetrics still not available after wait, cannot rebuild Priority data', 'warn');
                // Function should be defined earlier in the script, but if not, we can't rebuild
                // Don't throw - just skip rebuilding and show empty state
                window.moneyPagePriorityData = [];
                window.moneySegmentMetrics = null;
              } else {
                debugLog(' buildMoneyPageMetrics now available after wait', 'success');
                // Function is now available, proceed with rebuild
                window.moneyPagePriorityData = window.buildMoneyPageMetrics(topPagesForPriority, auditSchema);
                
                // Use saved moneySegmentMetrics if available (from Supabase), otherwise rebuild
                if (saved && saved.moneySegmentMetrics) {
                  window.moneySegmentMetrics = saved.moneySegmentMetrics;
                  debugLog(` Using moneySegmentMetrics from saved data (Supabase)`, 'success');
                } else {
                  // Rebuild segment metrics
                  const behaviourScoresBySegment = {};
                  if (savedMetrics.behaviour) {
                    behaviourScoresBySegment.allMoney = savedMetrics.behaviour.score || 0;
                  }
                  if (typeof buildMoneySegmentSummary === 'function') {
                    window.moneySegmentMetrics = buildMoneySegmentSummary(window.moneyPagePriorityData, behaviourScoresBySegment);
                    debugLog(` Rebuilt moneySegmentMetrics from moneyPagePriorityData`, 'success');
                  } else {
                    debugLog(` buildMoneySegmentSummary is not available, cannot rebuild moneySegmentMetrics`, 'warn');
                    window.moneySegmentMetrics = null;
                  }
                }
                
                debugLog(` Rebuilt Money Pages Priority data from saved metrics: ${window.moneyPagePriorityData.length} pages`, 'success');
                
                // Save the rebuilt data back to localStorage
                if (window.moneyPagePriorityData && window.moneyPagePriorityData.length > 0) {
                  const updatedAudit = { ...saved, moneyPagePriorityData: window.moneyPagePriorityData, moneySegmentMetrics: window.moneySegmentMetrics };
                  safeSetLocalStorage('last_audit_results', updatedAudit);
                }
              }
            } else {
              // Function is available, proceed with rebuild
              window.moneyPagePriorityData = window.buildMoneyPageMetrics(topPagesForPriority, auditSchema);
              
              // Use saved moneySegmentMetrics if available (from Supabase), otherwise rebuild
              if (saved && saved.moneySegmentMetrics) {
                window.moneySegmentMetrics = saved.moneySegmentMetrics;
                debugLog(` Using moneySegmentMetrics from saved data (Supabase)`, 'success');
              } else {
                // Rebuild segment metrics
                const behaviourScoresBySegment = {};
                if (savedMetrics.behaviour) {
                  behaviourScoresBySegment.allMoney = savedMetrics.behaviour.score || 0;
                }
                if (typeof buildMoneySegmentSummary === 'function') {
                  window.moneySegmentMetrics = buildMoneySegmentSummary(window.moneyPagePriorityData, behaviourScoresBySegment);
                  debugLog(` Rebuilt moneySegmentMetrics from moneyPagePriorityData`, 'success');
                } else {
                  debugLog(` buildMoneySegmentSummary is not available, cannot rebuild moneySegmentMetrics`, 'warn');
                  window.moneySegmentMetrics = null;
                }
              }
              
              debugLog(` Rebuilt Money Pages Priority data from saved metrics: ${window.moneyPagePriorityData.length} pages`, 'success');
              
              // Save the rebuilt data back to localStorage
              if (window.moneyPagePriorityData && window.moneyPagePriorityData.length > 0) {
                const updatedAudit = { ...saved, moneyPagePriorityData: window.moneyPagePriorityData, moneySegmentMetrics: window.moneySegmentMetrics };
                safeSetLocalStorage('last_audit_results', updatedAudit);
              }
            }
          } catch (error) {
            debugLog(` Failed to rebuild Money Pages Priority data: ${error.message}`, 'warn');
            debugLog(`Error stack: ${error.stack}`, 'error');
            window.moneyPagePriorityData = [];
            window.moneySegmentMetrics = null;
          }
        } else {
          // No saved data available
          window.moneyPagePriorityData = window.moneyPagePriorityData || [];
          window.moneySegmentMetrics = window.moneySegmentMetrics || null;
          debugLog(' No Money Pages Priority data available (will be empty until next audit)', 'warn');
          debugLog(`Debug: saved=${!!saved}, savedMetrics=${!!savedMetrics}, savedMetrics.rows=${savedMetrics?.rows?.length || 0}, searchData=${!!(saved && saved.searchData || data)}`, 'warn');
        }
      }
      
      // Update retry button visibility
      updateRetryButtonVisibility(schemaAudit);
      
      debugLog('=== DISPLAY DASHBOARD: Starting ===', 'info');
      debugLog(`Using current audit data: schemaAudit=${schemaAudit ? 'yes' : 'no'}, localSignals=${currentLocalSignals ? 'yes' : 'no'}`, 'info');
      debugLog(`Scores object keys: ${scores ? Object.keys(scores).join(', ') : 'null'}`, 'info');
      debugLog(`Money Pages Metrics in scores: ${scores?.moneyPagesMetrics ? 'yes' : 'no'}`, 'info');
      if (saved && saved.scores) {
        debugLog(`Saved scores keys: ${Object.keys(saved.scores).join(', ')}`, 'info');
        debugLog(`Money Pages Metrics in saved scores: ${saved.scores.moneyPagesMetrics ? 'yes' : 'no'}`, 'info');
      }
      
      // Show dashboard first (canvas elements need to be visible for Chart.js)
      const dashboardDiv = document.getElementById('dashboard');
      if (!dashboardDiv) {
        debugLog(' Dashboard div not found', 'error');
        console.error('Dashboard div not found');
        return;
      }
      debugLog(' Dashboard div found', 'success');
      dashboardDiv.style.display = 'block';
      debugLog('Dashboard div displayed', 'info');
      
      // Update trend chart description with date range
      const dateRange = parseInt(document.getElementById('dateRange').value) || 30;
      const trendDesc = document.getElementById('trendChartDescription');
      if (trendDesc) {
        let rangeText = '';
        if (dateRange === 30) rangeText = 'Last 30 Days';
        else if (dateRange === 60) rangeText = 'Last 60 Days';
        else if (dateRange === 90) rangeText = 'Last 90 Days';
        else if (dateRange === 120) rangeText = 'Last 120 Days';
        else if (dateRange === 180) rangeText = 'Last 6 Months';
        else if (dateRange === 365) rangeText = 'Last 12 Months';
        else if (dateRange === 540) rangeText = 'Last 18 Months';
        else rangeText = `Last ${dateRange} Days`;
        trendDesc.textContent = `Historical performance tracking for Local Entity, Visibility, and Authority pillars over ${rangeText.toLowerCase()}.`;
      }
      
      const pillarNames = {
        localEntity: 'Local Entity',
        serviceArea: 'Service Area',
        authority: 'Authority',
        visibility: 'Visibility',
        contentSchema: 'Content / Schema'
      };
      
      // Define pillar weightings and order by weight (highest to lowest)
      const pillarWeights = {
        authority: 0.30,        // 30% - E-A-T is crucial for AI trust
        contentSchema: 0.25,     // 25% - Structured data is key for AI understanding
        visibility: 0.20,        // 20% - How AI surfaces your content
        localEntity: 0.15,       // 15% - Entity recognition important but not critical
        serviceArea: 0.10         // 10% - Less critical for AI search
      };
      
      // Sort pillars by weight (highest to lowest) for consistent ordering
      const getOrderedPillars = (scoresObj) => {
        // Filter out non-pillar keys (like authorityComponents)
        const validPillars = ['localEntity', 'serviceArea', 'authority', 'visibility', 'contentSchema'];
        return Object.entries(scoresObj)
          .filter(([key]) => validPillars.includes(key))
          .map(([key, scoreValue]) => {
            // Handle new Authority structure (object with score) or legacy (number)
            let score = scoreValue;
            if (key === 'authority' && typeof scoreValue === 'object' && scoreValue !== null) {
              score = scoreValue.score || 0;
            }
            return [key, score];
          })
          .sort((a, b) => {
          return (pillarWeights[b[0]] || 0) - (pillarWeights[a[0]] || 0);
        });
      };

      // Use current audit data (passed as parameter) for health dashboard
      // This ensures we use the most recent audit run data, not stale localStorage
      // Handle both status/data structure and direct data structure
      const hasLocalSignals = currentLocalSignals && (
        (currentLocalSignals.status === 'ok' && currentLocalSignals.data) ||
        (currentLocalSignals.data && (currentLocalSignals.data.napConsistencyScore !== undefined || currentLocalSignals.data.locationsScore !== undefined))
      );
      const localSignalsData = hasLocalSignals 
        ? (currentLocalSignals.data || currentLocalSignals)
        : null;
      
      // DEBUG: Log local signals status for health dashboard
      debugLog(`[Health Dashboard] Local signals: hasLocalSignals=${hasLocalSignals}, currentLocalSignals=${JSON.stringify(currentLocalSignals ? {status: currentLocalSignals.status, hasData: !!currentLocalSignals.data} : null)}`, 'info');
      
      // DEBUG: Verify brandOverlay is populated
      console.log('DEBUG brandOverlay', scores.brandOverlay);
      debugLog(`DEBUG brandOverlay: ${JSON.stringify(scores.brandOverlay)}`, 'info');
      
      // Calculate GAIO Health Score
      const aiGeoHealth = calculateAiGeoScore(scores, schemaAudit, snippetReadiness);
      debugLog(`GAIO Health: Score=${aiGeoHealth.aiGeoScore}, Status=${aiGeoHealth.aiGeoStatus}, Likelihood=${aiGeoHealth.aiSummaryLikelihood}`, 'info');
      
      // Extract component scores for health dashboard
      const authorityScore = (typeof scores.authority === 'object' && scores.authority !== null) 
        ? scores.authority.score 
        : scores.authority || 0;
      const contentScore = scores.contentSchema || 0;
      
      // Extract coverage and diversity from schema audit (same logic as calculateAiGeoScore)
      let coverageScore = scores.coverage || 0;
      let diversityScore = scores.diversity || 0;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        coverageScore = schemaData.coverage || 0;
        const allTypes = new Set();
        if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
          schemaData.allDetectedTypes.forEach(type => {
            if (type) allTypes.add(type);
          });
        } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          schemaData.schemaTypes.forEach(item => {
            if (item.type) allTypes.add(item.type);
          });
        }
        const uniqueTypesCount = allTypes.size;
        diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
      }
      
      const locationsScore = ((scores.localEntity || 0) + (scores.serviceArea || 0)) / 2;
      
      // Create GAIO Health Dashboard (insert before pillar cards)
      const healthDashboard = document.createElement('div');
      healthDashboard.id = 'ai-geo-health-dashboard';
      healthDashboard.style.marginBottom = '2rem';
      
      // Get pillar hints/comments for the comparison table
      const getPillarHint = (pillarKey, score, scoresObj, schemaAuditData, localSignalsData) => {
        switch(pillarKey) {
          case 'authority':
            const authComponents = scoresObj?.authorityComponents;
            if (authComponents) {
              if (authComponents.behaviour < 30 && authComponents.backlinks >= 50 && authComponents.reviews >= 50) {
                return 'Backlinks and reviews strong; CTR weak';
              } else if (authComponents.behaviour >= 50 && authComponents.ranking < 30) {
                return 'CTR strong; ranking needs improvement';
              } else if (authComponents.behaviour < 30) {
                return 'Behaviour is weak; backlinks/reviews strong';
              }
            }
            return 'E-A-T signals balanced';
          case 'content':
            if (score >= 90) return 'Fully structured, rich schema';
            if (score >= 70) return 'Good schema coverage';
            return 'Schema needs improvement';
          case 'coverage':
            if (score >= 90) return 'All priority pages ingested';
            if (score >= 70) return 'Most pages covered';
            return 'Coverage gaps present';
          case 'diversity':
            if (score >= 80) return 'Good mix of topics and formats';
            if (score >= 60) return 'Moderate diversity';
            return 'Limited schema diversity';
          case 'locations':
            if (score >= 85) return 'GBP + core locations covered well';
            if (score >= 70) return 'Local entity and service areas solid';
            return 'Location signals need strengthening';
          default:
            return '';
        }
      };
      
      // Phase 2: Get brand priority
      const getBrandPriority = (summary) => {
        const b = summary.brandOverlay;
        if (!b) return null;
        if (b.score >= 70) return null; // only suggest actions if score is below "Strong"
        
        const share = b.brandQueryShare || 0;
        const ctr = b.brandCtr || 0;
        const entity = b.entityScore ?? 0;
        const review = b.reviewScore ?? 0;
        
        // Decide the most important brand-related action
        if (share < 0.10) {
          return {
            pillar: 'Brand & Entity',
            severity: 'medium',
            message: 'Increase the share of branded searches (e.g. "Alan Ranger Photography") by using your full brand name consistently in campaigns, key landing pages and off-site mentions.',
            link: '#pillarCards',
            score: b.score
          };
        }
        
        if (ctr < 0.25) {
          return {
            pillar: 'Brand & Entity',
            severity: 'medium',
            message: 'Improve titles and meta descriptions on core brand pages (home, about, tuition, workshops) to raise CTR on branded queries above 25%.',
            link: '#pillarCards',
            score: b.score
          };
        }
        
        if (entity < 70) {
          return {
            pillar: 'Brand & Entity',
            severity: 'medium',
            message: 'Strengthen entity signals by maintaining NAP consistency, adding more detail to GBP and About/Press pages, and earning mentions on relevant third-party sites.',
            link: '#pillarCards',
            score: b.score
          };
        }
        
        if (review < 70) {
          return {
            pillar: 'Brand & Entity',
            severity: 'medium',
            message: 'Boost review signals with a steady flow of new Google reviews and clear calls-to-review after workshops and lessons.',
            link: '#pillarCards',
            score: b.score
          };
        }
        
        // Fallback for mid-range scores
        return {
          pillar: 'Brand & Entity',
          severity: 'low',
          message: 'Continue building branded visibility by consolidating strong informational content into clear "hub" pages that use your brand name and service area.',
          link: '#pillarCards',
          score: b.score
        };
      };
      
      // Generate priorities list from pillar diagnostics
      // Helper to generate money pages priority (Phase 2)
      function getMoneyPagesPriority(moneyPagesMetrics) {
        if (!moneyPagesMetrics || !moneyPagesMetrics.rows || !moneyPagesMetrics.rows.length) {
          debugLog('getMoneyPagesPriority: No rows data', 'warn');
          return null;
        }
        
        const { rows, summaryByCategory, overview } = moneyPagesMetrics;
        const moneyImpressions = overview.moneyImpressions || 0;
        if (moneyImpressions === 0) {
          debugLog('getMoneyPagesPriority: No money impressions', 'warn');
          return null;
        }
        
        const high = summaryByCategory?.HIGH_OPPORTUNITY || { count: 0, impressions: 0 };
        const vis = summaryByCategory?.VISIBILITY_FIX || { count: 0, impressions: 0 };
        
        const highCount = high.count || 0;
        const highImps = high.impressions || 0;
        const visCount = vis.count || 0;
        const visImps = vis.impressions || 0;
        
        debugLog(`getMoneyPagesPriority: high=${highCount} pages/${highImps} imps, vis=${visCount} pages/${visImps} imps, total=${moneyImpressions}`, 'info');
        
        const totalFocusImps = highImps + visImps;
        if (totalFocusImps === 0) {
          debugLog('getMoneyPagesPriority: No focus impressions (high+vis)', 'warn');
          return null;
        }
        
        const sharePct = (totalFocusImps / moneyImpressions) * 100;
        
        let severity = 'medium';
        if (sharePct >= 60) severity = 'high';
        else if (sharePct <= 25) severity = 'low';
        
        const topExamples = rows
          .filter((r) => r.category === 'HIGH_OPPORTUNITY' || r.category === 'VISIBILITY_FIX')
          .slice(0, 3)
          .map((r) => {
            try {
              const urlObj = new URL(r.url);
              return urlObj.pathname.split('/').filter(p => p).pop() || r.url;
            } catch (e) {
              return r.url;
            }
          });
        
        const description =
          `Money pages: ${highCount} high-opportunity and ${visCount} visibility-fix URLs ` +
          `account for ${sharePct.toFixed(1)}% of money-page impressions. ` +
          `Prioritise improving titles/meta, "best" framing, and FAQs on these pages.`;
        
        const detail =
          topExamples.length
            ? `Examples: ${topExamples.join(', ')}`
            : '';
        
        const priority = {
          pillar: 'Money Pages',
          severity, // 'high' | 'medium' | 'low'
          message: description,
          detail: detail,
          link: '#money-pages-section'
        };
        
        debugLog(` Money pages priority created: ${JSON.stringify(priority)}`, 'success');
        return priority;
      }
      
      const getPriorities = (scoresObj, schemaAuditData, localSignalsData, authorityComponents) => {
        const priorities = [];
        
        // Authority priorities
        if (authorityComponents) {
          if (authorityComponents.behaviour < 30) {
            priorities.push({
              pillar: 'Authority',
              severity: 'high',
              message: 'Improve Top-10 CTR on money pages (Authority  Behaviour table, status = Poor)',
              link: '#authority-top-pages-section'
            });
          }
          if (authorityComponents.ranking < 30) {
            priorities.push({
              pillar: 'Authority',
              severity: 'medium',
              message: 'Improve average position and top-10 impression share',
              link: '#authority-top-pages-section'
            });
          }
        }
        
        // Content/Schema priorities
        if (schemaAuditData && schemaAuditData.status === 'ok' && schemaAuditData.data) {
          const schemaData = schemaAuditData.data;
          if (schemaData.coverage < 100) {
            // Use missingSchemaCount if available, otherwise calculate from coverage
            const missingCount = schemaData.missingSchemaCount || 
              (schemaData.totalPages ? Math.round((100 - schemaData.coverage) / 100 * schemaData.totalPages) : 0);
            priorities.push({
              pillar: 'Content',
              severity: 'medium',
              message: `Add schema to ${missingCount > 0 ? missingCount : 'remaining'} pages (Content/Schema  coverage ${schemaData.coverage != null ? schemaData.coverage.toFixed(0) : 'N/A'}%)`,
              link: '#pillarCards'
            });
          }
          const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
          // PRIORITY: Use foundation object first (most reliable source) - same logic as Content/Schema card
          let foundationPresent = 0;
          if (schemaData.foundation && typeof schemaData.foundation === 'object') {
            // Use foundation object directly - count how many are true (same as Content/Schema card)
            foundationPresent = foundationTypes.filter(type => schemaData.foundation[type] === true).length;
          } else {
            // Fallback: check allDetectedTypes or schemaTypes
            const allTypes = new Set();
            if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
              schemaData.allDetectedTypes.forEach(type => {
                if (type) allTypes.add(type);
              });
            } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
              schemaData.schemaTypes.forEach(item => {
                if (item && typeof item === 'object' && item.type) {
                  allTypes.add(item.type);
                } else if (typeof item === 'string') {
                  allTypes.add(item);
                }
              });
            }
            foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
          }
          
          if (foundationPresent < 4) {
            // Determine missing types based on which data structure was used
            const missingTypes = schemaData.foundation && typeof schemaData.foundation === 'object'
              ? foundationTypes.filter(t => schemaData.foundation[t] !== true)
              : foundationTypes.filter(t => {
                  // Fallback: check allTypes set if foundation object not available
                  const allTypes = new Set();
                  if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
                    schemaData.allDetectedTypes.forEach(type => { if (type) allTypes.add(type); });
                  } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
                    schemaData.schemaTypes.forEach(item => {
                      if (item && typeof item === 'object' && item.type) allTypes.add(item.type);
                      else if (typeof item === 'string') allTypes.add(item);
                    });
                  }
                  return !allTypes.has(t);
                });
            
            priorities.push({
              pillar: 'Content',
              severity: 'high',
              message: `Add missing foundation schemas: ${missingTypes.join(', ')}`,
              link: '#pillarCards'
            });
          }
        }
        
        // Locations priorities
        if (localSignalsData) {
          if (localSignalsData.napConsistencyScore < 100) {
            priorities.push({
              pillar: 'Locations',
              severity: 'medium',
              message: `Improve NAP consistency (currently ${localSignalsData.napConsistencyScore}%)`,
              link: '#pillarCards'
            });
          }
          const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
          if (serviceAreasCount < 5) {
            priorities.push({
              pillar: 'Locations',
              severity: 'low',
              message: `Add more service areas to Google Business Profile (currently ${serviceAreasCount}, target: 5+)`,
              link: '#pillarCards'
            });
          }
        }
        
        // Phase 2: Add brand priority if applicable
        const brandPriority = getBrandPriority ? getBrandPriority({ brandOverlay: scoresObj.brandOverlay }) : null;
        if (brandPriority) {
          priorities.push(brandPriority);
        }
        
        // Phase 2: Add money pages priority if applicable
        debugLog(`Checking for money pages priority - moneyPagesMetrics exists: ${!!scoresObj.moneyPagesMetrics}`, 'info');
        if (scoresObj.moneyPagesMetrics) {
          debugLog(`Money pages metrics: rows=${scoresObj.moneyPagesMetrics.rows?.length || 0}, summaryByCategory=${!!scoresObj.moneyPagesMetrics.summaryByCategory}`, 'info');
        }
        const moneyPriority = getMoneyPagesPriority(scoresObj.moneyPagesMetrics);
        if (moneyPriority) {
          debugLog(` Adding money pages priority: ${moneyPriority.message}`, 'success');
          priorities.push(moneyPriority);
        } else {
          debugLog(' No money pages priority generated', 'warn');
        }
        
        // Sort by severity (high > medium > low) and limit to top items
        const severityOrder = { high: 3, medium: 2, low: 1 };
        const sorted = priorities.sort((a, b) => severityOrder[b.severity] - severityOrder[a.severity]);
        
        // Allow up to 4 items when brand or money pages priorities are present, or 5 otherwise
        const hasOverlayPriorities = brandPriority || moneyPriority;
        const maxItems = hasOverlayPriorities ? 4 : 5;
        return sorted.slice(0, maxItems);
      };
      
      const priorities = getPriorities(scores, schemaAudit, localSignalsData, scores.authorityComponents);
      
      healthDashboard.innerHTML = `
        <!-- Updated: 2024 - Site AI Health title, 0% marker removed -->
        <div style="background: white; padding: 2rem; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-bottom: 2rem;">
          <!-- GAIO Health Top Card -->
          <div style="text-align: center; margin-bottom: 3rem; padding: 2rem 0; border-bottom: 2px solid #e2e8f0;">
            <div style="display: flex; align-items: flex-start; justify-content: center; gap: 4rem; margin-bottom: 2rem; flex-wrap: wrap;">
              <!-- Dial Section with Title -->
              <div style="display: flex; flex-direction: column; align-items: center;">
                <!-- Section Title - Centered over dial -->
                <h2 style="font-size: 2rem; font-weight: 700; color: #1e293b; margin-bottom: 1.5rem; letter-spacing: -0.02em; text-align: center; width: 100%;">
                  Site AI Health
                </h2>
                <!-- Circular Progress Ring - Speedometer Style -->
                <div style="position: relative; width: 520px; height: 520px; margin: 0 auto; overflow: visible;">
                ${(() => {
                  const score = aiGeoHealth.aiGeoScore;
                  const center = 260;
                  const radius = 195;
                  const strokeWidth = 26;
                  const normalizedRadius = radius - strokeWidth / 2;
                  
                  // Determine colors based on status
                  const color = aiGeoHealth.aiGeoStatus === 'green' ? '#10b981' : 
                               aiGeoHealth.aiGeoStatus === 'amber' ? '#f59e0b' : '#ef4444';
                  const bgColor = aiGeoHealth.aiGeoStatus === 'green' ? '#d1fae5' : 
                                 aiGeoHealth.aiGeoStatus === 'amber' ? '#fef3c7' : '#fee2e2';
                  
                  // Angle calculations: 0% at 12:05 (-85), 50% at 6pm (90), 100% at 12pm (-90)
                  const startAngle = -85; // 12:05 position
                  const endAngle = -90;   // 12pm position
                  const angleRange = 360 - 5; // Full circle minus 5 gap
                  
                  // Helper function to create arc path
                  const createArc = (start, end, r) => {
                    const startRad = (start * Math.PI) / 180;
                    const endRad = (end * Math.PI) / 180;
                    const largeArc = Math.abs(end - start) > 180 ? 1 : 0;
                    const x1 = center + r * Math.cos(startRad);
                    const y1 = center + r * Math.sin(startRad);
                    const x2 = center + r * Math.cos(endRad);
                    const y2 = center + r * Math.sin(endRad);
                    return `M ${x1} ${y1} A ${r} ${r} 0 ${largeArc} 1 ${x2} ${y2}`;
                  };
                  
                  // Calculate segment angles
                  const angle0 = startAngle;
                  const angle50 = startAngle + angleRange * 0.5;
                  const angle70 = startAngle + angleRange * 0.7;
                  const angle100 = startAngle + angleRange;
                  
                  // Calculate current score angle
                  const scoreAngle = startAngle + (score / 100) * angleRange;
                  const scoreRad = (scoreAngle * Math.PI) / 180;
                  
                  return `
                    <svg width="520" height="520" style="filter: drop-shadow(0 4px 12px rgba(0,0,0,0.08)); overflow: visible;">
                      <!-- Background circle -->
                      <circle
                        cx="${center}"
                        cy="${center}"
                        r="${normalizedRadius}"
                        fill="none"
                        stroke="#f1f5f9"
                        stroke-width="${strokeWidth}"
                      />
                      
                      <!-- Red segment: 0-50% -->
                      <path
                        d="${createArc(angle0, angle50, normalizedRadius)}"
                        fill="none"
                        stroke="#ef4444"
                        stroke-width="${strokeWidth}"
                        stroke-linecap="round"
                      />
                      
                      <!-- Amber segment: 50-70% -->
                      <path
                        d="${createArc(angle50, angle70, normalizedRadius)}"
                        fill="none"
                        stroke="#f59e0b"
                        stroke-width="${strokeWidth}"
                        stroke-linecap="round"
                      />
                      
                      <!-- Green segment: 70-100% -->
                      <path
                        d="${createArc(angle70, angle100, normalizedRadius)}"
                        fill="none"
                        stroke="#10b981"
                        stroke-width="${strokeWidth}"
                        stroke-linecap="round"
                      />
                      
                      <!-- Tick marks for GAIO Score, AI Summary Likelihood, and Brand & Entity -->
                      <g>
                        ${(() => {
                          // Get all three scores
                          const aiGeoScoreValue = score; // Already calculated
                          const brandScore = scores?.brandOverlay?.score || 0;
                          const aiSummaryScore = aiGeoHealth?.aiSummary?.score || 0;
                          
                          // Calculate angles for each score
                          const aiGeoAngle = startAngle + (aiGeoScoreValue / 100) * angleRange;
                          const brandAngle = startAngle + (brandScore / 100) * angleRange;
                          const aiSummaryAngle = startAngle + (aiSummaryScore / 100) * angleRange;
                          
                          const aiGeoRad = (aiGeoAngle * Math.PI) / 180;
                          const brandRad = (brandAngle * Math.PI) / 180;
                          const aiSummaryRad = (aiSummaryAngle * Math.PI) / 180;
                          
                          // GAIO Score tick mark (solid, thick) - scaled 30% larger
                          const aiGeoTickLength = 31.2;
                          const aiGeoTickWidth = 5.2;
                          const aiGeoTickX1 = center + (normalizedRadius - aiGeoTickLength) * Math.cos(aiGeoRad);
                          const aiGeoTickY1 = center + (normalizedRadius - aiGeoTickLength) * Math.sin(aiGeoRad);
                          const aiGeoTickX2 = center + (normalizedRadius + aiGeoTickLength) * Math.cos(aiGeoRad);
                          const aiGeoTickY2 = center + (normalizedRadius + aiGeoTickLength) * Math.sin(aiGeoRad);
                          
                          // AI Summary Likelihood tick mark (solid, medium) - scaled 30% larger
                          const aiSummaryTickLength = 26;
                          const aiSummaryTickWidth = 3.9;
                          const aiSummaryTickX1 = center + (normalizedRadius - aiSummaryTickLength) * Math.cos(aiSummaryRad);
                          const aiSummaryTickY1 = center + (normalizedRadius - aiSummaryTickLength) * Math.sin(aiSummaryRad);
                          const aiSummaryTickX2 = center + (normalizedRadius + aiSummaryTickLength) * Math.cos(aiSummaryRad);
                          const aiSummaryTickY2 = center + (normalizedRadius + aiSummaryTickLength) * Math.sin(aiSummaryRad);
                          
                          // Brand & Entity tick mark (dashed, medium) - scaled 30% larger
                          const brandTickLength = 23.4;
                          const brandTickWidth = 3.9;
                          const brandTickX1 = center + (normalizedRadius - brandTickLength) * Math.cos(brandRad);
                          const brandTickY1 = center + (normalizedRadius - brandTickLength) * Math.sin(brandRad);
                          const brandTickX2 = center + (normalizedRadius + brandTickLength) * Math.cos(brandRad);
                          const brandTickY2 = center + (normalizedRadius + brandTickLength) * Math.sin(brandRad);
                          
                          // Colors based on scores (consistent with badge logic)
                          // AI Summary uses same RAG bands as GAIO: 70 green, 50 amber, <50 red
                          const aiSummaryColor = aiSummaryScore >= 70 ? '#10b981' : aiSummaryScore >= 50 ? '#f59e0b' : '#ef4444';
                          const brandColor = brandScore >= 70 ? '#10b981' : brandScore >= 40 ? '#f59e0b' : '#ef4444';
                          
                          return `
                            <!-- GAIO Score tick mark (main score) -->
                            <line x1="${aiGeoTickX1}" y1="${aiGeoTickY1}" 
                                  x2="${aiGeoTickX2}" y2="${aiGeoTickY2}" 
                                  stroke="${color}" 
                                  stroke-width="${aiGeoTickWidth}" 
                                  stroke-linecap="round"
                                  style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));"/>
                            
                            <!-- AI Summary Likelihood tick mark -->
                            ${aiSummaryScore > 0 ? `
                            <line x1="${aiSummaryTickX1}" y1="${aiSummaryTickY1}" 
                                  x2="${aiSummaryTickX2}" y2="${aiSummaryTickY2}" 
                                  stroke="${aiSummaryColor}" 
                                  stroke-width="${aiSummaryTickWidth}" 
                                  stroke-linecap="round"
                                  style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));"/>
                            ` : ''}
                            
                            <!-- Brand & Entity score tick mark -->
                            ${brandScore > 0 ? `
                            <line x1="${brandTickX1}" y1="${brandTickY1}" 
                                  x2="${brandTickX2}" y2="${brandTickY2}" 
                                  stroke="${brandColor}" 
                                  stroke-width="${brandTickWidth}" 
                                  stroke-linecap="round"
                                  stroke-dasharray="4,2"
                                  style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));"/>
                            ` : ''}
                          `;
                        })()}
                      </g>
                      
                      <!-- Needle indicator for current score -->
                      <g>
                        <line
                          x1="${center}"
                          y1="${center}"
                          x2="${center + (normalizedRadius + 19.5) * Math.cos(scoreRad)}"
                          y2="${center + (normalizedRadius + 19.5) * Math.sin(scoreRad)}"
                          stroke="${color}"
                          stroke-width="5.2"
                          stroke-linecap="round"
                          style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2)); transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1);"
                        />
                        <!-- Needle center dot -->
                        <circle
                          cx="${center}"
                          cy="${center}"
                          r="10.4"
                          fill="${color}"
                          style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));"
                        />
                      </g>
                      
                      <!-- Labels: 50%, 100%, and all three score indicators -->
                      <g>
                        ${(() => {
                          // Get all three scores
                          const aiGeoScoreValue = score;
                          const brandScore = scores?.brandOverlay?.score || 0;
                          const aiSummaryScore = aiGeoHealth?.aiSummary?.score || 0;
                          
                          // Calculate angles
                          const aiGeoAngle = startAngle + (aiGeoScoreValue / 100) * angleRange;
                          const brandAngle = startAngle + (brandScore / 100) * angleRange;
                          const aiSummaryAngle = startAngle + (aiSummaryScore / 100) * angleRange;
                          
                          // Colors - AI Summary uses same RAG bands as GAIO: 70 green, 50 amber, <50 red
                          const aiSummaryColor = aiSummaryScore >= 70 ? '#10b981' : aiSummaryScore >= 50 ? '#f59e0b' : '#ef4444';
                          const brandColor = brandScore >= 70 ? '#10b981' : brandScore >= 40 ? '#f59e0b' : '#ef4444';
                          
                          const labels = [
                            { value: 100, angle: angle100, color: '#10b981' },  // Scale marker
                            { value: aiGeoScoreValue, angle: aiGeoAngle, color: color, label: 'GAIO' },  // Main score
                            ...(aiSummaryScore > 0 ? [{ value: aiSummaryScore, angle: aiSummaryAngle, color: aiSummaryColor, label: 'AI Summary' }] : []),
                            ...(brandScore > 0 ? [{ value: brandScore, angle: brandAngle, color: brandColor, label: 'Brand' }] : [])
                          ];
                          
                          return labels.map(m => {
                            const rad = (m.angle * Math.PI) / 180;
                            const labelOffset = 65;
                            const labelX = center + (normalizedRadius + labelOffset) * Math.cos(rad);
                            const labelY = center + (normalizedRadius + labelOffset) * Math.sin(rad);
                            
                            // For scores, show value with label below
                            if (m.label) {
                              return `
                                <g>
                                  <text x="${labelX}" y="${labelY - 10}" 
                                        text-anchor="middle" dominant-baseline="middle"
                                        fill="${m.color}" 
                                        font-size="18" font-weight="700"
                                        style="text-shadow: 0 1px 2px rgba(255,255,255,0.8);">${m.value}</text>
                                  <text x="${labelX}" y="${labelY + 13}" 
                                        text-anchor="middle" dominant-baseline="middle"
                                        fill="#64748b" 
                                        font-size="13" font-weight="500"
                                        style="text-shadow: 0 1px 2px rgba(255,255,255,0.8);">${m.label}</text>
                                </g>
                              `;
                            } else {
                              // Scale markers (50, 100)
                              return `
                                <text x="${labelX}" y="${labelY}" 
                                      text-anchor="middle" dominant-baseline="middle"
                                      fill="${m.color}" 
                                      font-size="21" font-weight="700"
                                      style="text-shadow: 0 1px 2px rgba(255,255,255,0.8);">${m.value}</text>
                              `;
                            }
                          }).join('');
                        })()}
                      </g>
                    </svg>
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; width: 100%; pointer-events: none;">
                      <div style="font-size: 5.5rem; font-weight: 800; color: ${color}; line-height: 1; margin-bottom: 0.5rem; letter-spacing: -0.03em; text-shadow: 0 2px 12px ${color}25;">
                        ${score}
                      </div>
                      <div style="font-size: 0.9rem; color: #64748b; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; margin-bottom: 0.75rem;">
                        GAIO Score
                      </div>
                      <div style="padding: 0.5rem 1rem; background: ${bgColor}; border-radius: 24px; display: inline-block;">
                        <span style="font-size: 0.875rem; color: ${color}; font-weight: 700;">
                          ${aiGeoHealth.aiGeoStatus === 'green' ? ' Excellent' : aiGeoHealth.aiGeoStatus === 'amber' ? ' Good' : ' Needs Work'}
                        </span>
                      </div>
                    </div>
                  `;
                })()}
                </div>
              </div>
              <div style="display: flex; flex-direction: column; align-items: center; gap: 1.5rem; justify-content: center;">
                <div style="text-align: center;">
                  <div style="font-size: 0.9rem; color: #64748b; margin-bottom: 0.5rem; font-weight: 500;">GAIO Status:</div>
                  ${(() => {
                    // Build GAIO score breakdown summary
                    const authorityScore = (typeof scores.authority === 'object' && scores.authority !== null) 
                      ? scores.authority.score 
                      : scores.authority || 0;
                    const contentScore = scores.contentSchema || 0;
                    const visibilityScore = scores.visibility || 0;
                    const localEntityScore = scores.localEntity || 0;
                    const serviceAreaScore = scores.serviceArea || 0;
                    
                    const aiGeoBreakdown = `GAIO Score Breakdown:
 Authority: ${Math.round(authorityScore)} (30% weight)
 Content/Schema: ${Math.round(contentScore)} (25% weight)
 Visibility: ${Math.round(visibilityScore)} (20% weight)
 Local Entity: ${Math.round(localEntityScore)} (15% weight)
 Service Area: ${Math.round(serviceAreaScore)} (10% weight)
Final Score: ${aiGeoHealth.aiGeoScore}/100`;
                    
                    return `
                      <div style="display: flex; align-items: flex-start; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                        <span class="rag-badge ${aiGeoHealth.aiGeoStatus}" style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: help; width: 170px; justify-content: center; flex-shrink: 0;" title="${aiGeoBreakdown}">
                          ${aiGeoHealth.aiGeoStatus === 'green' ? 'Green' : aiGeoHealth.aiGeoStatus === 'amber' ? 'Amber' : 'Red'} (${aiGeoHealth.aiGeoScore}/100)
                          <span style="display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 50%; background: #3b82f6; color: white; font-size: 0.75rem; font-weight: 700; cursor: help; flex-shrink: 0;" title="${aiGeoBreakdown}">i</span>
                        </span>
                        <div style="background: white; border: 1px solid #e2e8f0; border-radius: 6px; padding: 0.75rem 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 0.85rem; color: #1e293b; line-height: 1.6; width: 320px; min-height: 140px;">
                          <div style="font-weight: 600; margin-bottom: 0.5rem; color: #1e293b;">GAIO Score Breakdown:</div>
                          <div style="color: #64748b;">
                            <div> Authority: ${Math.round(authorityScore)} (30% weight)</div>
                            <div> Content/Schema: ${Math.round(contentScore)} (25% weight)</div>
                            <div> Visibility: ${Math.round(visibilityScore)} (20% weight)</div>
                            <div> Local Entity: ${Math.round(localEntityScore)} (15% weight)</div>
                            <div> Service Area: ${Math.round(serviceAreaScore)} (10% weight)</div>
                            <div style="margin-top: 0.5rem; font-weight: 600; color: #1e293b;">Final Score: ${aiGeoHealth.aiGeoScore}/100</div>
                          </div>
                        </div>
                      </div>
                    `;
                  })()}
                </div>
                <div style="text-align: center;">
                  <div style="display: flex; flex-direction: column; gap: 1rem;">
                    <div>
                      <div style="font-size: 0.9rem; color: #64748b; margin-bottom: 0.5rem; font-weight: 500;">AI summary likelihood:</div>
                      ${(() => {
                        // Phase 2: Use aiSummary.label if available, otherwise fallback to aiSummaryLikelihood
                        const aiSummary = aiGeoHealth.aiSummary || { label: aiGeoHealth.aiSummaryLikelihood || 'Low', score: 0 };
                        // Ensure label is capitalized correctly
                        let label = aiSummary.label || 'Low';
                        if (typeof label === 'string') {
                          label = label.charAt(0).toUpperCase() + label.slice(1).toLowerCase();
                        }
                        const score = aiSummary.score || 0;
                        // Use same RAG bands as GAIO Score: 70 green, 50 amber, <50 red
                        const bgColor = score >= 70 ? '#d1fae5' : score >= 50 ? '#fef3c7' : '#fee2e2';
                        const textColor = score >= 70 ? '#065f46' : score >= 50 ? '#92400e' : '#991b1b';
                        
                        // Build AI Summary breakdown
                        // Handle both number format (legacy) and object format (if it exists)
                        const snippetReadinessScore = typeof snippetReadiness === 'number' 
                          ? snippetReadiness 
                          : (snippetReadiness?.overallScore || 0);
                        const visibilityScore = scores.visibility || 0;
                        const brandScore = scores.brandOverlay?.score || 0;
                        
                        const aiSummaryBreakdown = `AI Summary Likelihood Breakdown:
 Snippet Readiness: ${Math.round(snippetReadinessScore)}/100 (50% weight)
 Visibility: ${Math.round(visibilityScore)}/100 (30% weight)
 Brand & Entity: ${Math.round(brandScore)}/100 (20% weight)
Final Score: ${score}/100

Based on snippet-friendly content (FAQ / HowTo / Article / Event blocks), how often your content appears in rich results, and the strength of your brand & entity signals (branded searches, reviews, knowledge panel).`;
                        
                        return `
                          <div style="display: flex; align-items: flex-start; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                            <span style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 6px; font-size: 1rem; font-weight: 600; background: ${bgColor}; color: ${textColor}; cursor: help; width: 170px; justify-content: center; flex-shrink: 0;" title="${aiSummaryBreakdown}">
                              ${label} (${score}/100)
                              <span style="display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 50%; background: #3b82f6; color: white; font-size: 0.75rem; font-weight: 700; cursor: help; flex-shrink: 0;" title="${aiSummaryBreakdown}">i</span>
                            </span>
                            <div style="background: white; border: 1px solid #e2e8f0; border-radius: 6px; padding: 0.75rem 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 0.85rem; color: #1e293b; line-height: 1.6; width: 320px; min-height: 140px;">
                              <div style="font-weight: 600; margin-bottom: 0.5rem; color: #1e293b;">AI Summary Likelihood Breakdown:</div>
                              <div style="color: #64748b;">
                                <div> Snippet Readiness: ${Math.round(snippetReadinessScore)}/100 (50% weight)</div>
                                <div> Visibility: ${Math.round(visibilityScore)}/100 (30% weight)</div>
                                <div> Brand & Entity: ${Math.round(brandScore)}/100 (20% weight)</div>
                                <div style="margin-top: 0.5rem; font-weight: 600; color: #1e293b;">Final Score: ${score}/100</div>
                              </div>
                            </div>
                          </div>
                        `;
                      })()}
                    </div>
                    <div>
                      <div style="font-size: 0.9rem; color: #64748b; margin-bottom: 0.5rem; font-weight: 500;">Brand & entity:</div>
                      ${(() => {
                        // Brand & Entity chip - show even if missing (with N/A)
                        const brandOverlay = scores.brandOverlay;
                        if (brandOverlay) {
                          const score = brandOverlay.score || 0;
                          const label = brandOverlay.label || 'Weak';
                          const bgColor = score >= 70 ? '#d1fae5' : score >= 40 ? '#fef3c7' : '#fee2e2';
                          const textColor = score >= 70 ? '#065f46' : score >= 40 ? '#92400e' : '#991b1b';
                          const brandQueryShare = brandOverlay.brandQueryShare != null ? (brandOverlay.brandQueryShare * 100).toFixed(1) : 'N/A';
                          const brandCtr = brandOverlay.brandCtr != null ? (brandOverlay.brandCtr * 100).toFixed(1) : 'N/A';
                          const brandAvgPos = brandOverlay.brandAvgPosition != null ? brandOverlay.brandAvgPosition.toFixed(1) : 'N/A';
                          const reviewScore = brandOverlay.reviewScore != null ? brandOverlay.reviewScore : 'N/A';
                          const entityScore = brandOverlay.entityScore != null ? brandOverlay.entityScore : 'N/A';
                          const brandTooltip = `Brand & Entity Overlay Breakdown:
 Brand Query Share: ${brandQueryShare}% of impressions
 Brand CTR: ${brandCtr}%
 Avg Brand Position: ${brandAvgPos}
 Review Score: ${reviewScore}/100
 Entity Score: ${entityScore}/100
Final Score: ${score}/100`;
                          return `
                            <div style="display: flex; align-items: flex-start; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                              <span style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 6px; font-size: 1rem; font-weight: 600; background: ${bgColor}; color: ${textColor}; cursor: help; width: 170px; justify-content: center; flex-shrink: 0;" title="${brandTooltip}">
                                ${label} (${score}/100)
                                <span style="display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 50%; background: #3b82f6; color: white; font-size: 0.75rem; font-weight: 700; cursor: help; flex-shrink: 0;" title="${brandTooltip}">i</span>
                              </span>
                              <div style="background: white; border: 1px solid #e2e8f0; border-radius: 6px; padding: 0.75rem 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 0.85rem; color: #1e293b; line-height: 1.6; width: 320px; min-height: 140px;">
                                <div style="font-weight: 600; margin-bottom: 0.5rem; color: #1e293b;">Brand & Entity Overlay Breakdown:</div>
                                <div style="color: #64748b;">
                                  <div> Brand Query Share: ${brandQueryShare}% of impressions</div>
                                  <div> Brand CTR: ${brandCtr}%</div>
                                  <div> Avg Brand Position: ${brandAvgPos}</div>
                                  <div> Review Score: ${reviewScore}/100</div>
                                  <div> Entity Score: ${entityScore}/100</div>
                                  <div style="margin-top: 0.5rem; font-weight: 600; color: #1e293b;">Final Score: ${score}/100</div>
                                </div>
                              </div>
                            </div>
                          `;
                        } else {
                          // Show N/A if brandOverlay is missing
                          const brandTooltip = 'No brand overlay data available  run an audit with access to query data.';
                          return `
                            <div style="display: flex; align-items: flex-start; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                              <span style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 6px; font-size: 1rem; font-weight: 600; background: #e5e7eb; color: #6b7280; cursor: help; width: 170px; justify-content: center; flex-shrink: 0;" title="${brandTooltip}">
                                N/A
                                <span style="display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 50%; background: #3b82f6; color: white; font-size: 0.75rem; font-weight: 700; cursor: help; flex-shrink: 0;" title="${brandTooltip}">i</span>
                              </span>
                              <div style="background: white; border: 1px solid #e2e8f0; border-radius: 6px; padding: 0.75rem 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 0.85rem; color: #64748b; width: 320px; min-height: 140px; display: flex; align-items: center;">
                                No brand overlay data available  run an audit with access to query data.
                              </div>
                            </div>
                          `;
                        }
                      })()}
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <p style="margin: 0; font-size: 0.95rem; color: #475569; font-weight: 500;">
              Based on Authority, Content & Schema, Coverage, Diversity, Locations and Brand & entity signals.
            </p>
          </div>
          
          <!-- This Month's Priorities -->
          ${priorities.length > 0 ? `
          <div>
            <h3 style="margin: 0 0 1rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">This Month's Priorities</h3>
            <div style="background: #f8f9fa; border-radius: 8px; padding: 1rem; border-left: 4px solid #ef4444;">
              <ul style="margin: 0; padding-left: 1.5rem; list-style: none;">
                ${priorities.map((p, idx) => {
                  // Phase 2: For brand priorities, use brandOverlay score for color
                  let severityColor;
                  if (p.pillar === 'Brand & Entity' && p.score !== undefined) {
                    severityColor = p.score >= 70 ? '#10b981' : p.score >= 40 ? '#f59e0b' : '#ef4444';
                  } else {
                    severityColor = p.severity === 'high' ? '#ef4444' : p.severity === 'medium' ? '#f59e0b' : '#10b981';
                  }
                  return `
                    <li style="margin-bottom: ${idx < priorities.length - 1 ? '0.75rem' : '0'}; padding-left: 0.5rem; position: relative;">
                      <span style="position: absolute; left: -1.5rem; color: ${severityColor}; font-weight: 700;"></span>
                      <a href="${p.link}" style="color: #1e293b; text-decoration: none; font-weight: 500; border-bottom: 1px solid transparent; transition: border-color 0.2s;" onmouseover="this.style.borderBottomColor='#1e293b';" onmouseout="this.style.borderBottomColor='transparent';">
                        ${p.message}
                      </a>
                    </li>
                  `;
                }).join('')}
              </ul>
            </div>
          </div>
          ` : ''}
        </div>
      `;
      
      // Insert health dashboard before pillar cards
      const pillarCards = document.getElementById('pillarCards');
      if (!pillarCards) {
        debugLog(' Pillar cards container not found', 'error');
        console.error('Pillar cards container (id="pillarCards") not found in DOM');
        return;
      }
      debugLog(' Pillar cards container found', 'success');
      
      // Remove existing health dashboard if present
      const existingHealth = document.getElementById('ai-geo-health-dashboard');
      if (existingHealth) {
        existingHealth.remove();
      }
      
      // Insert health dashboard before pillar cards
      pillarCards.parentNode.insertBefore(healthDashboard, pillarCards);
      debugLog(' GAIO Health Dashboard created', 'success');
      
      // Circular progress ring is SVG-based, no additional drawing needed
      
      // Clear pillar cards for fresh render
      pillarCards.innerHTML = '';

      const orderedPillars = getOrderedPillars(scores);
      debugLog(`Creating ${orderedPillars.length} pillar cards from scores: ${JSON.stringify(scores)}`, 'info');
      
      if (orderedPillars.length === 0) {
        debugLog(' No pillars found in scores object!', 'warn');
        console.warn('No pillars found in scores:', scores);
      }
      
      orderedPillars.forEach(([key, scoreValue]) => {
        // Handle new Authority structure (object with score and bySegment) or legacy (number)
        // Note: getOrderedPillars extracts the score, so we need to get bySegment from original scores object
        let score = scoreValue;
        let authorityBySegment = null;
        if (key === 'authority') {
          // Get the original Authority object from scores (not from getOrderedPillars result)
          const authorityObj = scores.authority;
          if (typeof authorityObj === 'object' && authorityObj !== null) {
            score = authorityObj.score || 0;
            authorityBySegment = authorityObj.bySegment || null;
          }
        }
        
        const rag = getRAGStatus(score);
        const card = document.createElement('div');
        card.className = 'pillar-card';
        
        // Get pillar description with data source info (dynamic based on whether we have real data)
        // Use currentLocalSignals (from displayDashboard parameter) for pillar cards, not just health dashboard
        // Check both localSignals and localSignalsSnapshot (different storage formats)
        const pillarLocalSignals = currentLocalSignals || (saved && (saved.localSignals || saved.localSignalsSnapshot)) || null;
        // Handle both status/data structure and direct data structure
        const pillarHasLocalSignals = pillarLocalSignals && (
          (pillarLocalSignals.status === 'ok' && pillarLocalSignals.data) ||
          (pillarLocalSignals.data && (pillarLocalSignals.data.napConsistencyScore !== undefined || pillarLocalSignals.data.locationsScore !== undefined))
        );
        const pillarLocalSignalsData = pillarHasLocalSignals 
          ? (pillarLocalSignals.data || pillarLocalSignals)
          : null;
        
        // DEBUG: Log local signals status for pillar cards
        debugLog(`[Pillar Cards] Local signals in definitions: hasLocalSignals=${pillarHasLocalSignals}, currentLocalSignals=${JSON.stringify(pillarLocalSignals ? {status: pillarLocalSignals.status, hasData: !!pillarLocalSignals.data, hasLocations: !!pillarLocalSignals.data?.locations, locationsCount: pillarLocalSignals.data?.locations?.length || 0} : null)}`, 'info');
        if (pillarLocalSignals && pillarLocalSignals.data) {
          debugLog(`[Pillar Cards] pillarLocalSignals.data keys: ${Object.keys(pillarLocalSignals.data).join(', ')}`, 'info');
          debugLog(`[Pillar Cards] pillarLocalSignals.data.locations type: ${typeof pillarLocalSignals.data.locations}, isArray: ${Array.isArray(pillarLocalSignals.data.locations)}, length: ${pillarLocalSignals.data.locations?.length || 0}`, 'info');
        }
        
        let localEntityDesc, serviceAreaDesc;
        if (pillarHasLocalSignals && pillarLocalSignalsData) {
          const napScore = pillarLocalSignalsData.napConsistencyScore !== null ? pillarLocalSignalsData.napConsistencyScore : 'N/A';
          const serviceAreasCount = pillarLocalSignalsData.serviceAreas?.length || 0;
          const locationsCount = pillarLocalSignalsData.locations?.length || 0;
          localEntityDesc = `How clearly your business and you as a person are recognised as entities by AI search systems. <strong>Data Source:</strong>  Live data from Google Business Profile API. <strong>Data Checked:</strong> NAP consistency (${napScore}%), knowledge panel (${pillarLocalSignalsData.knowledgePanelDetected ? 'detected' : 'not detected'}), locations (${locationsCount}).`;
          serviceAreaDesc = `How well AI understands where you operate and which regions you serve. <strong>Data Source:</strong>  Live data from Google Business Profile API. <strong>Data Checked:</strong> Service areas (${serviceAreasCount}), NAP consistency (${napScore}%).`;
        } else {
          localEntityDesc = 'How clearly your business and you as a person are recognised as entities by AI search systems. <strong>Data Source:</strong>  Currently derived from search performance (GSC position/CTR). Real local signals API integration pending.';
          serviceAreaDesc = 'How well AI understands where you operate and which regions you serve. <strong>Data Source:</strong>  Currently derived from Local Entity score. Real service area data from Google Business Profile pending.';
        }
        
        const descriptions = {
          localEntity: localEntityDesc,
          serviceArea: serviceAreaDesc,
          authority: 'E-A-T (Experience, Expertise, Authoritativeness, Trustworthiness): Perceived expertise and trust in the topic space. <strong>Calculation:</strong> Behaviour (40%) + Ranking (20%) + Backlinks (20%) + Reviews (20%). <strong>Data Source:</strong>  Live data from Google Search Console, Google Business Profile API, historic Trustpilot reviews snapshot, and backlink CSV upload.',
          visibility: 'How prominently your content appears in AI-powered search results and featured snippets. <strong>Data Source:</strong>  Live data from Google Search Console (impressions, clicks, position, SERP features).',
          contentSchema: 'Quality and completeness of structured data markup across your domain. <strong>Data Source:</strong>  Live data from schema audit. <strong>Calculation:</strong> Foundation schemas (30%) + Rich Results (35%) + Coverage (20%) + Diversity (15%).'
        };
        
        // Build breakdown and details sections for all pillars (for consistency)
        let pillarBreakdown = '';
        let pillarDetails = '';
        let authorityBreakdown = '';
        let authorityDetails = '';
        let authorityModeToggle = '';
        
        // Get saved audit data for breakdown calculations (reuse saved from function start to avoid redeclaration)
        // Use schemaAudit parameter if available, otherwise fall back to saved
        const schemaAuditData = schemaAudit || saved?.schemaAudit;
        const searchDataForBreakdown = data || saved?.searchData;
        // Note: hasLocalSignals and localSignalsData are already defined at function level (line 3688-3689), reuse them
        
        if (key === 'authority') {
          const savedAudit = loadAuditResultsSync();
          // Try multiple sources for backlinkMetrics: savedAudit, then localStorage
          // Note: API call removed from here since forEach doesn't support async properly
          // Backlink metrics should be loaded during audit run and saved to savedAudit
          let backlinkMetrics = savedAudit?.backlinkMetrics || null;
          if (!backlinkMetrics) {
            try {
              const storedMetrics = localStorage.getItem('backlink_metrics');
              if (storedMetrics) {
                backlinkMetrics = JSON.parse(storedMetrics);
                debugLog(' Backlink metrics loaded from localStorage for Authority card', 'info');
              }
            } catch (e) {
              debugLog(` Error reading backlink metrics from localStorage: ${e.message}`, 'warn');
            }
          }
          // Use currentLocalSignals from displayDashboard parameter, or fallback to savedAudit
          const localSignals = currentLocalSignals || savedAudit?.localSignals || null;
          // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
          const siteReviews = getTrustpilotSnapshot(savedAudit?.siteReviews);
          const searchData = savedAudit?.searchData;
          
          // Authority mode state (stored per card instance)
          const modeId = `authority-mode-${Date.now()}`;
          let currentMode = 'all'; // Default mode
          
          // Get selected Authority scores based on mode
          const getAuthorityForMode = (mode) => {
            if (authorityBySegment && authorityBySegment[mode]) {
              return authorityBySegment[mode];
            }
            // Fallback to all or legacy structure
            if (authorityBySegment && authorityBySegment.all) {
              return authorityBySegment.all;
            }
            // Legacy fallback
            const components = scores.authorityComponents || {};
            return {
              total: score,
              behaviour: components.behaviour || 0,
              ranking: components.ranking || 0,
              backlinks: components.backlinks || 0,
              reviews: components.reviews || 0
            };
          };
          
          // Get current Authority data
          let selectedAuthority = getAuthorityForMode(currentMode);
          
          // DEBUG: Log authority components and backlink metrics
          debugLog(`[Authority Card] Current authority components: ${JSON.stringify(selectedAuthority)}`, 'info');
          debugLog(`[Authority Card] Scores authorityComponents: ${JSON.stringify(scores.authorityComponents)}`, 'info');
          
          // Build mode toggle UI (only if bySegment is available)
          if (authorityBySegment) {
            authorityModeToggle = `
              <div class="authority-mode-toggle" style="margin-top: 0.5rem; margin-bottom: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem;">
                <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                  <span style="font-weight: 600; color: #666;">Mode:</span>
                  <button id="${modeId}-all" class="authority-mode-btn" data-mode="all" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: #10b981; color: white; cursor: pointer; font-size: 0.75rem;">
                    All pages
                  </button>
                  <button id="${modeId}-nonEducation" class="authority-mode-btn" data-mode="nonEducation" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
                    Exclude education
                  </button>
                  <button id="${modeId}-money" class="authority-mode-btn" data-mode="money" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
                    Money pages only
                  </button>
                </div>
              </div>
            `;
          }
          
          // Build breakdown display with color-coded scores (will be updated by mode toggle)
          const updateAuthorityDisplay = () => {
            const mode = card._authorityMode || currentMode;
            selectedAuthority = getAuthorityForMode(mode);
            const breakdownDiv = document.getElementById(`${modeId}-breakdown`);
            const scoreDiv = document.getElementById(`${modeId}-score`);
            if (breakdownDiv) {
              breakdownDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('Behaviour', selectedAuthority.behaviour)}
                  ${formatComponentScore('Ranking', selectedAuthority.ranking)}
                  ${formatComponentScore('Backlinks', selectedAuthority.backlinks)}
                  ${formatComponentScore('Reviews', selectedAuthority.reviews)}
                </div>
              `;
            }
            if (scoreDiv) {
              scoreDiv.textContent = Math.round(selectedAuthority.total);
              const newRag = getRAGStatus(selectedAuthority.total);
              scoreDiv.className = `pillar-score rag-${newRag.status}`;
            }
          };
          
          // Initial breakdown (with consistent spacing for alignment)
          authorityBreakdown = `
            <div id="${modeId}-breakdown" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                ${formatComponentScore('Behaviour', selectedAuthority.behaviour)}
                ${formatComponentScore('Ranking', selectedAuthority.ranking)}
                ${formatComponentScore('Backlinks', selectedAuthority.backlinks)}
                ${formatComponentScore('Reviews', selectedAuthority.reviews)}
              </div>
            </div>
          `;
          
          // Store update function for mode toggle handlers
          card._updateAuthorityDisplay = updateAuthorityDisplay;
          card._authorityMode = currentMode;
          card._authorityBySegment = authorityBySegment;
          card._modeId = modeId;
          
          // Build details panel (hidden by default, toggled by button)
          const detailsId = `authority-details-${Date.now()}`;
          const buttonId = `authority-details-btn-${Date.now()}`;
          
          // Get GSC metrics for details (segment-aware)
          // Store queryPages and searchData on card for access in update functions
          card._queryPages = searchData?.queryPages || [];
          card._topQueries = searchData?.topQueries || [];
          const queryPages = card._queryPages;
          const topQueries = card._topQueries;
          
          // Function to calculate GSC metrics for a specific segment
          const getGSCMetricsForSegment = (mode, queryPagesData, topQueriesData) => {
            let dataToUse = [];
            
            // Use the passed data (from card storage) to ensure we have latest
            const qp = queryPagesData || queryPages;
            const tq = topQueriesData || topQueries;
            
            if (qp && qp.length > 0) {
              // Use queryPages with segmentation
              let filtered = qp;
              if (mode === 'nonEducation') {
                filtered = qp.filter(row => {
                  const segment = classifyPageSegment(row.page || row.url || '/');
                  return segment !== PageSegment.EDUCATION;
                });
              } else if (mode === 'money') {
                filtered = qp.filter(row => {
                  const segment = classifyPageSegment(row.page || row.url || '/');
                  return segment === PageSegment.MONEY;
                });
              }
              
              debugLog(` GSC Metrics for ${mode}: Filtered ${filtered.length} rows from ${qp.length} total queryPages`, 'info');
              
              // Convert to query format for calculation
              dataToUse = filtered.map(row => ({
                query: row.query || '',
                clicks: row.clicks || 0,
                impressions: row.impressions || 0,
                ctr: (row.ctr || 0) / 100,
                position: row.position || 0
              }));
            } else {
              // Fallback to topQueries (all pages)
              dataToUse = tq.map(q => ({
                query: q.query || '',
                clicks: q.clicks || 0,
                impressions: q.impressions || 0,
                ctr: (q.ctr || 0) / 100,
                position: q.position || 0
              }));
            }
            
            const rankingQueries = dataToUse.filter(q => q.position > 0 && q.position <= 20 && q.impressions > 0);
            const top10Queries = rankingQueries.filter(q => q.position <= 10);
            
            let siteCtr = 0;
            let top10Ctr = 0;
            let avgPosition = 0;
            let top10ImpressionShare = 0;
            
            if (rankingQueries.length > 0) {
              const totalClicks = rankingQueries.reduce((s, q) => s + (q.clicks || 0), 0);
              const totalImpr = rankingQueries.reduce((s, q) => s + (q.impressions || 0), 0);
              siteCtr = totalImpr > 0 ? (totalClicks / totalImpr) * 100 : 0;
              
              const top10Clicks = top10Queries.reduce((s, q) => s + (q.clicks || 0), 0);
              const top10Impr = top10Queries.reduce((s, q) => s + (q.impressions || 0), 0);
              top10Ctr = top10Impr > 0 ? (top10Clicks / top10Impr) * 100 : 0;
              
              avgPosition = totalImpr > 0
                ? rankingQueries.reduce((s, q) => s + (q.position || 0) * (q.impressions || 0), 0) / totalImpr
                : 0;
              
              top10ImpressionShare = totalImpr > 0 ? (top10Impr / totalImpr) * 100 : 0;
            }
            
            return { siteCtr, top10Ctr, avgPosition, top10ImpressionShare };
          };
          
          // Get initial metrics (all pages)
          let gscMetrics = getGSCMetricsForSegment(currentMode, queryPages, topQueries);
          let siteCtr = gscMetrics.siteCtr;
          let top10Ctr = gscMetrics.top10Ctr;
          let avgPosition = gscMetrics.avgPosition;
          let top10ImpressionShare = gscMetrics.top10ImpressionShare;
          
          // Function to update GSC metrics display
          const updateGSCMetrics = (mode) => {
            // Get fresh data from card storage
            const qp = card._queryPages || [];
            const tq = card._topQueries || [];
            const metrics = getGSCMetricsForSegment(mode, qp, tq);
            const metricsDiv = document.getElementById(`${modeId}-gsc-metrics`);
            if (metricsDiv) {
              const siteCtrStr = metrics.siteCtr != null ? metrics.siteCtr.toFixed(2) : 'N/A';
              const avgPosStr = metrics.avgPosition != null ? metrics.avgPosition.toFixed(1) : 'N/A';
              debugLog(` Updating GSC metrics for mode ${mode}: CTR=${siteCtrStr}%, Position=${avgPosStr}`, 'info');
              const top10CtrStr = metrics.top10Ctr != null ? metrics.top10Ctr.toFixed(2) : 'N/A';
              const top10ShareStr = metrics.top10ImpressionShare != null ? metrics.top10ImpressionShare.toFixed(1) : 'N/A';
              metricsDiv.innerHTML = `
                <div style="margin-bottom: 0.5rem;"><strong>Behaviour & Ranking:</strong></div>
                <div style="margin-bottom: 0.25rem; font-size: 0.7rem; color: #999;">Segment: ${mode === 'all' ? 'All pages' : mode === 'nonEducation' ? 'Exclude education (blogs / free course)' : 'Money pages only'}</div>
                <div>Site CTR (ranking queries): ${siteCtrStr}%</div>
                <div>Top-10 CTR: ${top10CtrStr}%</div>
                <div>Avg position (ranking): ${avgPosStr}</div>
                <div>Top-10 impression share: ${top10ShareStr}%</div>
              `;
            } else {
              debugLog(` GSC metrics div not found: ${modeId}-gsc-metrics`, 'warn');
            }
          };
          
          // Store update function and data
          card._updateGSCMetrics = updateGSCMetrics;
          card._getGSCMetricsForSegment = getGSCMetricsForSegment;
          
          // Get review data - check multiple possible data structures
          let gbpRating = null;
          let gbpReviewCount = null;
          
          if (localSignals) {
            // Handle both direct data structure and wrapped response structure
            const signalsStatus = localSignals.status;
            const signalsData = localSignals.data || (localSignals.locations !== undefined ? localSignals : null);
            
            debugLog(`[Authority Card] Local signals status: ${signalsStatus}, has data: ${!!signalsData}, structure: ${JSON.stringify(Object.keys(localSignals))}`, 'info');
            
            if (signalsStatus === 'ok' && signalsData) {
              // Enhanced logging for GBP data
              debugLog(`[Authority Card] signalsData keys: ${Object.keys(signalsData).join(', ')}`, 'info');
              debugLog(`[Authority Card] signalsData.gbpRating raw: ${JSON.stringify(signalsData.gbpRating)} (type: ${typeof signalsData.gbpRating})`, 'info');
              debugLog(`[Authority Card] signalsData.gbpReviewCount raw: ${JSON.stringify(signalsData.gbpReviewCount)} (type: ${typeof signalsData.gbpReviewCount})`, 'info');
              
              gbpRating = signalsData.gbpRating !== null && signalsData.gbpRating !== undefined 
                ? signalsData.gbpRating 
                : null;
              gbpReviewCount = signalsData.gbpReviewCount !== null && signalsData.gbpReviewCount !== undefined 
                ? signalsData.gbpReviewCount 
                : null;
              debugLog(`[Authority Card] GBP data extracted: rating=${gbpRating}, count=${gbpReviewCount}`, gbpRating !== null ? 'info' : 'warn');
            } else {
              debugLog(`[Authority Card] Local signals not OK or missing data. Status: ${signalsStatus}, data keys: ${signalsData ? Object.keys(signalsData).join(', ') : 'no data'}, full object keys: ${Object.keys(localSignals).join(', ')}`, 'warn');
            }
          } else {
            debugLog(`[Authority Card] No localSignals available`, 'warn');
          }
          const siteRating = siteReviews?.siteRating !== null ? siteReviews?.siteRating : null;
          const siteReviewCount = siteReviews?.siteReviewCount !== null ? siteReviews?.siteReviewCount : null;
          
          authorityDetails = `
            <div style="margin-top: 0.5rem;">
              <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                Show details
              </button>
              <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                <div id="${modeId}-gsc-metrics">
                  <div style="margin-bottom: 0.5rem;"><strong>Behaviour & Ranking:</strong></div>
                  <div style="margin-bottom: 0.25rem; font-size: 0.7rem; color: #999;">Segment: ${currentMode === 'all' ? 'All pages' : currentMode === 'nonEducation' ? 'Exclude education (blogs / free course)' : 'Money pages only'}</div>
                  <div>Site CTR (ranking queries): ${siteCtr != null ? siteCtr.toFixed(1) : 'N/A'}%</div>
                  <div>Top-10 CTR: ${top10Ctr != null ? top10Ctr.toFixed(1) : 'N/A'}%</div>
                  <div>Avg position (ranking): ${avgPosition != null ? avgPosition.toFixed(1) : 'N/A'}</div>
                  <div>Top-10 impression share: ${top10ImpressionShare != null ? top10ImpressionShare.toFixed(1) : 'N/A'}%</div>
                </div>
                ${(() => {
                  // Use authorityComponents.backlinks to determine if backlinks exist
                  // Also try to get backlinkMetrics for detailed display if available
                  const hasBacklinkScore = selectedAuthority.backlinks > 0 || (scores.authorityComponents && scores.authorityComponents.backlinks > 0);
                  const hasBacklinkMetrics = backlinkMetrics && (backlinkMetrics.referringDomains > 0 || backlinkMetrics.totalBacklinks > 0);
                  
                  // Only show "No backlink data uploaded" if both score and metrics are missing
                  if (!hasBacklinkScore && !hasBacklinkMetrics) {
                    return `
                      <div style="margin-top: 0.75rem; margin-bottom: 0.5rem;"><strong>Backlink Metrics:</strong></div>
                      <div>No backlink data uploaded</div>
                    `;
                  }
                  
                  // Show backlink metrics if available, otherwise show score-based info
                  if (hasBacklinkMetrics) {
                    return `
                      <div style="margin-top: 0.75rem; margin-bottom: 0.5rem;"><strong>Backlink Metrics:</strong></div>
                      <div>Referring domains: ${backlinkMetrics.referringDomains || 0}</div>
                      <div>Total backlinks: ${backlinkMetrics.totalBacklinks || 0}</div>
                      <div>Follow ratio: ${backlinkMetrics.followRatio ? Math.round(backlinkMetrics.followRatio * 100) : 50}%</div>
                      <div style="margin-top: 0.25rem; font-size: 0.7rem; color: #999;">Backlink score: ${selectedAuthority.backlinks.toFixed(0)}</div>
                    `;
                  } else {
                    return `
                      <div style="margin-top: 0.75rem; margin-bottom: 0.5rem;"><strong>Backlink Metrics:</strong></div>
                      <div>Backlink score: ${selectedAuthority.backlinks.toFixed(0)}</div>
                      <div style="font-size: 0.7rem; color: #999;">Detailed metrics not available</div>
                    `;
                  }
                })()}
                <div style="margin-top: 0.75rem; margin-bottom: 0.5rem;"><strong>Review Metrics:</strong></div>
                <div>GBP rating: ${gbpRating !== null ? gbpRating.toFixed(2) : 'N/A'} (${gbpReviewCount !== null ? gbpReviewCount : 'N/A'} reviews)</div>
                <div>Trustpilot (snapshot): ${siteRating !== null ? siteRating.toFixed(2) : 'N/A'} (${siteReviewCount !== null ? siteReviewCount : 'N/A'} reviews)</div>
              </div>
            </div>
          `;
          
          // Store topPages data on card for access in update functions
          card._topPages = {
            all: authorityBySegment?.all?.topPages || [],
            nonEducation: authorityBySegment?.nonEducation?.topPages || [],
            money: authorityBySegment?.money?.topPages || []
          };
          
          // Function to render top pages table
          function renderTopPagesTable(mode, authorityBySegment) {
            const topPages = mode === 'all' 
              ? (authorityBySegment?.all?.topPages || [])
              : mode === 'nonEducation'
              ? (authorityBySegment?.nonEducation?.topPages || [])
              : (authorityBySegment?.money?.topPages || []);
            
            if (!topPages || topPages.length === 0) {
              return '<div style="font-size: 0.75rem; color: #999;">No page data available for this segment.</div>';
            }
            
            const segmentLabel = mode === 'all' 
              ? 'All pages'
              : mode === 'nonEducation'
              ? 'Exclude education (blogs / free course)'
              : 'Money pages only';
            
            const copyButtonId = `${modeId}-copy-urls`;
            
            let tableHtml = `
              <div style="margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                <h4 style="margin: 0; font-size: 0.95rem; font-weight: 600;">Top pages in this segment (by impressions)</h4>
                <button id="${copyButtonId}" type="button" style="font-size: 0.8rem; padding: 0.35rem 0.6rem; border-radius: 4px; border: 1px solid #ddd; background: white; cursor: pointer; color: #666;">
                  Copy URLs
                </button>
              </div>
              <p style="margin: 0 0 0.5rem 0; font-size: 0.75rem; color: #999;">Segment: ${segmentLabel}</p>
              <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse; font-size: 0.75rem;">
                  <thead>
                    <tr style="border-bottom: 1px solid #e2e8f0;">
                      <th style="text-align: left; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">#</th>
                      <th style="text-align: left; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">URL</th>
                      <th style="text-align: right; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">CTR</th>
                      <th style="text-align: right; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">Impr.</th>
                      <th style="text-align: right; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">Clicks</th>
                      <th style="text-align: right; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">Avg pos.</th>
                    </tr>
                  </thead>
                  <tbody>
            `;
            
            topPages.forEach((page, idx) => {
              const ctrStr = page.ctr != null ? page.ctr.toFixed(1) : 'N/A';
              const posStr = page.avgPosition != null ? page.avgPosition.toFixed(1) : 'N/A';
              const impressionsStr = page.impressions != null ? page.impressions.toLocaleString() : 'N/A';
              const clicksStr = page.clicks != null ? page.clicks.toLocaleString() : 'N/A';
              tableHtml += `
                <tr style="border-bottom: 1px solid #f1f5f9;">
                  <td style="padding: 0.25rem 0.4rem; color: #666;">${idx + 1}</td>
                  <td style="padding: 0.25rem 0.4rem; word-break: break-all; color: #333;">${page.url || 'N/A'}</td>
                  <td style="padding: 0.25rem 0.4rem; text-align: right; color: #666;">${ctrStr}%</td>
                  <td style="padding: 0.25rem 0.4rem; text-align: right; color: #666;">${impressionsStr}</td>
                  <td style="padding: 0.25rem 0.4rem; text-align: right; color: #666;">${clicksStr}</td>
                  <td style="padding: 0.25rem 0.4rem; text-align: right; color: #666;">${posStr}</td>
                </tr>
              `;
            });
            
            tableHtml += `
                  </tbody>
                </table>
              </div>
            `;
            
            // Store copy button ID and current mode for later event handler attachment
            card._copyButtonId = copyButtonId;
            card._topPagesForCopy = topPages;
            card._currentTopPagesMode = mode;
            
            return tableHtml;
          }
          
          // Function to update top pages table when mode changes
          const updateTopPagesTable = (mode) => {
            const topPagesDiv = document.getElementById(`${modeId}-top-pages`);
            if (topPagesDiv && authorityBySegment) {
              topPagesDiv.innerHTML = renderTopPagesTable(mode, authorityBySegment);
              
              // Re-attach copy button handler
              setTimeout(() => {
                const copyBtn = document.getElementById(card._copyButtonId);
                if (copyBtn) {
                  // Remove existing listener if any
                  const newCopyBtn = copyBtn.cloneNode(true);
                  copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
                  
                  newCopyBtn.addEventListener('click', async () => {
                    const currentTopPages = mode === 'all'
                      ? (authorityBySegment?.all?.topPages || [])
                      : mode === 'nonEducation'
                      ? (authorityBySegment?.nonEducation?.topPages || [])
                      : (authorityBySegment?.money?.topPages || []);
                    
                    const text = currentTopPages.map(p => p.url).join('\n');
                    try {
                      await navigator.clipboard.writeText(text);
                      newCopyBtn.textContent = 'Copied!';
                      newCopyBtn.style.color = '#10b981';
                      setTimeout(() => {
                        newCopyBtn.textContent = 'Copy URLs';
                        newCopyBtn.style.color = '#666';
                      }, 2000);
                    } catch (err) {
                      console.error('Failed to copy URLs:', err);
                      newCopyBtn.textContent = 'Copy failed';
                      setTimeout(() => {
                        newCopyBtn.textContent = 'Copy URLs';
                      }, 2000);
                    }
                  });
                }
              }, 0);
            }
          };
          
          // Store update function
          card._updateTopPagesTable = updateTopPagesTable;
          
          // Add click handlers for details toggle and mode toggle
          setTimeout(() => {
            const btn = document.getElementById(buttonId);
            const details = document.getElementById(detailsId);
            if (btn && details) {
              btn.addEventListener('click', () => {
                const isVisible = details.style.display !== 'none';
                details.style.display = isVisible ? 'none' : 'block';
                btn.textContent = isVisible ? 'Show details' : 'Hide details';
              });
            }
            
            // Add initial copy button handler
            const copyBtn = document.getElementById(card._copyButtonId);
            if (copyBtn) {
              copyBtn.addEventListener('click', async () => {
                const currentTopPages = currentMode === 'all'
                  ? (authorityBySegment?.all?.topPages || [])
                  : currentMode === 'nonEducation'
                  ? (authorityBySegment?.nonEducation?.topPages || [])
                  : (authorityBySegment?.money?.topPages || []);
                
                const text = currentTopPages.map(p => p.url).join('\n');
                try {
                  await navigator.clipboard.writeText(text);
                  copyBtn.textContent = 'Copied!';
                  copyBtn.style.color = '#10b981';
                  setTimeout(() => {
                    copyBtn.textContent = 'Copy URLs';
                    copyBtn.style.color = '#666';
                  }, 2000);
                } catch (err) {
                  console.error('Failed to copy URLs:', err);
                  copyBtn.textContent = 'Copy failed';
                  setTimeout(() => {
                    copyBtn.textContent = 'Copy URLs';
                  }, 2000);
                }
              });
            }
            
            // Add mode toggle handlers
            if (authorityBySegment) {
              ['all', 'nonEducation', 'money'].forEach(mode => {
                const modeBtn = document.getElementById(`${modeId}-${mode}`);
                if (modeBtn) {
                  modeBtn.addEventListener('click', () => {
                    // Update current mode
                    currentMode = mode;
                    card._authorityMode = mode;
                    
                    // Update button styles
                    ['all', 'nonEducation', 'money'].forEach(m => {
                      const btn = document.getElementById(`${modeId}-${m}`);
                      if (btn) {
                        if (m === mode) {
                          btn.style.background = '#10b981';
                          btn.style.color = 'white';
                        } else {
                          btn.style.background = 'white';
                          btn.style.color = '#666';
                        }
                      }
                    });
                    
                    // Update Authority score and breakdown
                    if (card._updateAuthorityDisplay) {
                      card._updateAuthorityDisplay();
                    }
                    
                    // Update GSC metrics
                    if (card._updateGSCMetrics) {
                      card._updateGSCMetrics(mode);
                    }
                    
                    // Update top pages section (full width, below pillars)
                    window.currentAuthorityMode = mode;
                    if (window.updateTopPagesSection) {
                      window.updateTopPagesSection(mode);
                    }
                    
                    debugLog(` Authority mode changed to: ${mode === 'all' ? 'All pages' : mode === 'nonEducation' ? 'Exclude education' : 'Money pages only'}`, 'info');
                  });
                }
              });
            }
          }, 0);
        }
        
        // Build breakdown and details for other pillars (Content/Schema, Visibility, Local Entity, Service Area)
        if (key !== 'authority') {
          const breakdownId = `${key}-breakdown-${Date.now()}`;
          const detailsId = `${key}-details-${Date.now()}`;
          const buttonId = `${key}-details-btn-${Date.now()}`;
          
          if (key === 'contentSchema' && schemaAuditData && schemaAuditData.status === 'ok' && schemaAuditData.data) {
            const schemaData = schemaAuditData.data;
            const allTypes = new Set();
            
            // PRIORITY: Use foundation object first (most reliable source)
            if (schemaData.foundation && typeof schemaData.foundation === 'object') {
              Object.keys(schemaData.foundation).forEach(type => {
                if (schemaData.foundation[type] === true) {
                  allTypes.add(type);
                }
              });
            }
            
            // Also add types from allDetectedTypes if available (for complete type list)
            if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
              schemaData.allDetectedTypes.forEach(type => { if (type) allTypes.add(type); });
            }
            
            // Also add from richEligible for complete type list
            if (schemaData.richEligible && typeof schemaData.richEligible === 'object') {
              Object.keys(schemaData.richEligible).forEach(type => {
                if (schemaData.richEligible[type] === true) {
                  allTypes.add(type);
                }
              });
            }
            
            // Fallback: collect from schemaTypes array (but filter out page objects)
            if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
              schemaData.schemaTypes.forEach(item => {
                // Skip page objects (have 'url' property) - these are NOT schema types
                if (item && typeof item === 'object' && item.url) {
                  return; // Skip page objects
                }
                // Only process valid schema type objects or strings
                if (typeof item === 'string') {
                  allTypes.add(item);
                } else if (item && typeof item === 'object' && item.type && typeof item.type === 'string' && !item.url) {
                  allTypes.add(item.type);
                }
              });
            }
            
            // Foundation detection: Use foundation object directly (most reliable)
            const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
            let foundationPresent = 0;
            if (schemaData.foundation && typeof schemaData.foundation === 'object') {
              // Use foundation object directly - count how many are true
              foundationPresent = foundationTypes.filter(type => schemaData.foundation[type] === true).length;
            } else {
              // Fallback: check allTypes set
              foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
            }
            const foundationScore = (foundationPresent / foundationTypes.length) * 100;
            
            const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
            const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
            const richResultScore = (richEligibleCount / richResultTypes.length) * 100;
            
            const coverageScore = schemaData.coverage || 0;
            const uniqueTypesCount = allTypes.size;
            const diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
            
            // Get schema types list for display (properly formatted to avoid [object Object])
            let schemaTypesList = [];
            if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
              schemaTypesList = schemaData.allDetectedTypes.slice(0, 20).filter(t => t && typeof t === 'string');
            } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
              schemaTypesList = schemaData.schemaTypes
                .filter(t => {
                  // Skip null/undefined
                  if (!t) return false;
                  // Skip page objects (have 'url' property) - these are pages, not types!
                  if (typeof t === 'object' && ('url' in t || ('title' in t && 'metaDescription' in t))) return false;
                  // Only keep valid type objects or strings
                  return typeof t === 'string' || (typeof t === 'object' && t.type && typeof t.type === 'string' && !t.url);
                })
                .map(t => {
                  if (typeof t === 'string') return t.trim();
                  if (t && typeof t === 'object' && t.type && typeof t.type === 'string') {
                    return `${t.type}${t.count ? ` (${t.count})` : ''}`;
                  }
                  return null;
                })
                .filter(t => t !== null && t !== undefined && t !== '' && typeof t === 'string')
                .slice(0, 20);
            }
            const schemaTypesDisplay = schemaTypesList.length > 0 ? schemaTypesList.join(', ') : 'None detected';
            
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('Foundation', foundationScore)}
                  ${formatComponentScore('Rich Results', richResultScore)}
                  ${formatComponentScore('Coverage', coverageScore)}
                  ${formatComponentScore('Diversity', diversityScore)}
                </div>
              </div>
            `;
            
            pillarDetails = `
              <div style="margin-top: 0.5rem;">
                <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                  Show details
                </button>
                <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                  <div style="margin-bottom: 0.5rem;"><strong>Schema Details:</strong></div>
                  <div>Foundation schemas: ${foundationPresent}/4 (${foundationTypes.filter(t => (schemaData.foundation && schemaData.foundation[t] === true) || allTypes.has(t)).join(', ') || 'none'})</div>
                  <div>Rich result types: ${richEligibleCount}/${richResultTypes.length} eligible</div>
                  <div>Coverage: ${coverageScore != null ? coverageScore.toFixed(1) : 'N/A'}% (${Array.isArray(schemaData.pagesWithSchema) ? schemaData.pagesWithSchema.length : (typeof schemaData.pagesWithSchema === 'number' ? schemaData.pagesWithSchema : 0)}/${Array.isArray(schemaData.pages) ? schemaData.pages.length : (typeof schemaData.totalPages === 'number' ? schemaData.totalPages : (Array.isArray(schemaData.pages) ? schemaData.pages.length : 0))} pages)</div>
                  <div>Type diversity: ${uniqueTypesCount} unique types</div>
                  <div style="margin-top: 0.5rem;"><strong>Schema types found:</strong> ${schemaTypesDisplay}${schemaTypesList.length >= 20 ? '...' : ''}</div>
                </div>
              </div>
            `;
            
            setTimeout(() => {
              const btn = document.getElementById(buttonId);
              const details = document.getElementById(detailsId);
              if (btn && details) {
                btn.addEventListener('click', () => {
                  const isVisible = details.style.display !== 'none';
                  details.style.display = isVisible ? 'none' : 'block';
                  btn.textContent = isVisible ? 'Show details' : 'Hide details';
                });
              }
            }, 0);
          } else if (key === 'visibility' && searchDataForBreakdown) {
            const avgPos = searchDataForBreakdown.averagePosition || 40;
            const clampedPos = Math.max(1, Math.min(40, avgPos));
            const scale = (clampedPos - 1) / 39;
            const posScore = 100 - scale * 90;
            
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('Position', clampScore(posScore))}
                  ${formatComponentScore('CTR', Math.min((searchDataForBreakdown.ctr || 0) / 0.10 * 100, 100))}
                </div>
              </div>
            `;
            
            pillarDetails = `
              <div style="margin-top: 0.5rem;">
                <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                  Show details
                </button>
                <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                  <div style="margin-bottom: 0.5rem;"><strong>GSC Metrics:</strong></div>
                  <div>Average position: ${avgPos != null ? avgPos.toFixed(1) : 'N/A'}</div>
                  <div>CTR: ${(searchDataForBreakdown.ctr || 0).toFixed(1)}%</div>
                  <div>Total clicks: ${(searchDataForBreakdown.totalClicks || 0).toLocaleString()}</div>
                  <div>Total impressions: ${(searchDataForBreakdown.totalImpressions || 0).toLocaleString()}</div>
                </div>
              </div>
            `;
            
            setTimeout(() => {
              const btn = document.getElementById(buttonId);
              const details = document.getElementById(detailsId);
              if (btn && details) {
                btn.addEventListener('click', () => {
                  const isVisible = details.style.display !== 'none';
                  details.style.display = isVisible ? 'none' : 'block';
                  btn.textContent = isVisible ? 'Show details' : 'Hide details';
                });
              }
            }, 0);
          } else if (key === 'localEntity' && pillarHasLocalSignals && pillarLocalSignalsData) {
            // DEBUG: Log locations data structure
            debugLog(`[Local Entity Card] pillarLocalSignalsData keys: ${Object.keys(pillarLocalSignalsData).join(', ')}`, 'info');
            debugLog(`[Local Entity Card] locations type: ${typeof pillarLocalSignalsData.locations}, isArray: ${Array.isArray(pillarLocalSignalsData.locations)}, length: ${pillarLocalSignalsData.locations?.length || 0}`, 'info');
            if (pillarLocalSignalsData.locations && pillarLocalSignalsData.locations.length > 0) {
              debugLog(`[Local Entity Card] First location: ${JSON.stringify(pillarLocalSignalsData.locations[0]).substring(0, 200)}`, 'info');
            } else {
              debugLog(`[Local Entity Card]  locations is missing or empty!`, 'warn');
            }
            const napScore = pillarLocalSignalsData.napConsistencyScore || 0;
            const knowledgePanelScore = pillarLocalSignalsData.knowledgePanelDetected ? 100 : 0;
            const locationsScore = (pillarLocalSignalsData.locations?.length || 0) > 0 ? 100 : 0;
            
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('NAP Consistency', napScore)}
                  ${formatComponentScore('Knowledge Panel', knowledgePanelScore)}
                  ${formatComponentScore('Locations', locationsScore)}
                </div>
              </div>
            `;
            
            pillarDetails = `
              <div style="margin-top: 0.5rem;">
                <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                  Show details
                </button>
                <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                  <div style="margin-bottom: 0.5rem;"><strong>Business Profile Data:</strong></div>
                  <div>NAP consistency: ${napScore}%</div>
                  <div>Knowledge panel: ${pillarLocalSignalsData.knowledgePanelDetected ? 'detected' : 'not detected'}</div>
                  <div>Locations: ${pillarLocalSignalsData.locations?.length || 0}</div>
                </div>
              </div>
            `;
            
            setTimeout(() => {
              const btn = document.getElementById(buttonId);
              const details = document.getElementById(detailsId);
              if (btn && details) {
                btn.addEventListener('click', () => {
                  const isVisible = details.style.display !== 'none';
                  details.style.display = isVisible ? 'none' : 'block';
                  btn.textContent = isVisible ? 'Show details' : 'Hide details';
                });
              }
            }, 0);
          } else if (key === 'serviceArea' && pillarHasLocalSignals && pillarLocalSignalsData) {
            const serviceAreasCount = pillarLocalSignalsData.serviceAreas?.length || 0;
            const serviceAreasScore = serviceAreasCount >= 8 ? 100 : Math.min(100, serviceAreasCount * 12.5);
            const napScore = pillarLocalSignalsData.napConsistencyScore || 0;
            
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('Service Areas', serviceAreasScore)}
                  ${formatComponentScore('NAP Consistency', napScore)}
                </div>
              </div>
            `;
            
            pillarDetails = `
              <div style="margin-top: 0.5rem;">
                <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                  Show details
                </button>
                <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                  <div style="margin-bottom: 0.5rem;"><strong>Service Area Data:</strong></div>
                  <div>Service areas: ${serviceAreasCount}</div>
                  <div>NAP consistency: ${napScore}%</div>
                </div>
              </div>
            `;
            
            setTimeout(() => {
              const btn = document.getElementById(buttonId);
              const details = document.getElementById(detailsId);
              if (btn && details) {
                btn.addEventListener('click', () => {
                  const isVisible = details.style.display !== 'none';
                  details.style.display = isVisible ? 'none' : 'block';
                  btn.textContent = isVisible ? 'Show details' : 'Hide details';
                });
              }
            }, 0);
          } else {
            // No breakdown available - add empty section for consistent spacing
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
              </div>
            `;
            pillarDetails = `
              <div style="margin-top: 0.5rem; min-height: 1.5rem;">
              </div>
            `;
          }
        }
        
        // Define pillar colors for consistency across all reports
        const pillarColors = {
          localEntity: 'rgba(147, 51, 234, 1)', // Purple
          serviceArea: '#00FFFF', // Cyan (not RAG color)
          authority: '#99004C', // Dark pink/magenta
          visibility: 'rgba(37, 99, 235, 1)', // Blue
          contentSchema: 'rgba(107, 114, 128, 1)' // Grey
        };
        
        const pillarColor = pillarColors[key] || '#666';
        
        card.innerHTML = `
          <div style="flex: 1; display: flex; flex-direction: column; position: relative;">
            <div style="position: absolute; top: 0; right: 0; width: 20px; height: 20px; background: ${pillarColor}; border-radius: 3px; border: 1px solid rgba(0,0,0,0.1);" title="Color key for ${pillarNames[key]} in all reports"></div>
          <h3>${pillarNames[key]}</h3>
            <div id="${key === 'authority' ? card._modeId + '-score' : ''}" class="pillar-score rag-${rag.status}">${Math.round(score)}</div>
          <div class="rag-badge ${rag.status}">${rag.label}</div>
          <p style="font-size: 0.85rem; color: #666; margin-top: 0.5rem; line-height: 1.5; flex-grow: 1;">${descriptions[key] || ''}</p>
            ${key === 'authority' ? authorityModeToggle : '<div style="min-height: 2.5rem;"></div>'}
            ${key === 'authority' ? authorityBreakdown : pillarBreakdown}
          </div>
          <div style="margin-top: auto;">
            ${key === 'authority' ? authorityDetails : pillarDetails}
          </div>
        `;
        pillarCards.appendChild(card);
        debugLog(` Added pillar card for ${key} (score: ${score})`, 'info');
      });
      
      debugLog(` Created ${orderedPillars.length} pillar cards total`, 'success');
      
      // Shared functions for Top Pages section (used by both createTopPagesSection functions)
      
      // Classification functions for metric status
      function classifySiteCtr(v) {
        // v is already a percentage (0-100), not a decimal
        if (v < 1) return 'poor';      // <1%
        if (v < 3) return 'ok';        // 1-3%
        return 'strong';                  // 3%+
      }
      
      function classifyTop10Ctr(v) {
        // v is already a percentage (0-100), not a decimal
        if (v < 2) return 'poor';      // <2%
        if (v < 5) return 'ok';        // 2-5%
        return 'strong';                  // 5%+
      }
      
      function classifyAvgPos(p) {
        if (p > 10) return 'poor';        // mostly bottom of page 1 / page 2
        if (p > 5) return 'ok';           // mid-page 1
        return 'strong';                  // positions 1-5
      }
      
      function classifyTop10Share(v) {
        // v is stored as decimal (0-1), needs to be converted to percentage for comparison
        const pct = v * 100;
        if (pct < 60) return 'poor';       // <60% of impressions in top 10
        if (pct < 80) return 'ok';         // 60-80%
        return 'strong';                  // 80%+
      }
      
      // Helper to format percentage
      // For CTR values: already percentages (0-100), just format
      // For top10Share: stored as decimal (0-1), convert to percentage
      function pct(v, isDecimal = false) {
        if (isDecimal) {
          return `${(v * 100).toFixed(2)}%`;
        }
        return `${v.toFixed(2)}%`;
      }
      
      // Helper to extract target value from target text
      function extractTargetValue(targetText, metricType) {
        if (metricType === 'ctr' || metricType === 'percentage') {
          // Extract range like "23%+" or "7585%+"
          const match = targetText.match(/(\d+(?:\.\d+)?)[-](\d+(?:\.\d+)?)%/);
          if (match) {
            const min = parseFloat(match[1]);
            const max = parseFloat(match[2]);
            return (min + max) / 2; // Return midpoint
          }
        } else if (metricType === 'position') {
          // Extract range like "36"
          const match = targetText.match(/(\d+(?:\.\d+)?)[-](\d+(?:\.\d+)?)/);
          if (match) {
            const min = parseFloat(match[1]);
            const max = parseFloat(match[2]);
            return (min + max) / 2; // Return midpoint
          }
        }
        return null;
      }
      
      // Build recommendation rows from segment metrics
      function buildBehaviourRankingRecommendations(segment, m) {
        const rows = [];
        
        // Site CTR recommendation
        const siteStatus = classifySiteCtr(m.siteCtr);
        const siteCurrent = m.siteCtr;
        const siteTargetText = 'Aim for 23%+ overall CTR';
        const siteTargetValue = extractTargetValue(siteTargetText, 'ctr'); // 2.5%
        const siteDiff = siteTargetValue ? (siteCurrent - siteTargetValue) : null; // Keep sign for display
        rows.push({
          metric: 'Overall CTR (all ranking queries)',
          status: siteStatus,
          value: pct(m.siteCtr),
          currentValue: siteCurrent,
          target: siteTargetText,
          targetValue: siteTargetValue,
          difference: siteDiff,
          action: siteStatus === 'poor'
            ? (segment === 'money'
                ? 'Rewrite titles and descriptions on the top money pages (table above). Add intent phrases ("workshop", "course", "near me") and stronger benefits to lift clicks for your money pages.'
                : 'Focus on high-impression pages with weak CTR in this segment. Tighten titles and descriptions so they clearly answer the search intent and highlight the benefit.')
            : siteStatus === 'ok'
            ? (segment === 'money'
                ? 'CTR is reasonable for your money pages. Prioritise the worst pages in the table above for A/B-style tests on titles and descriptions.'
                : 'CTR is reasonable for this segment. Prioritise the worst pages in the table above for A/B-style tests on titles and descriptions.')
            : 'CTR is strong for this segment. Keep monitoring but prioritise ranking and impression share improvements.'
        });
        
        // Top-10 CTR recommendation
        const top10Status = classifyTop10Ctr(m.top10Ctr);
        const top10Current = m.top10Ctr;
        const top10TargetText = 'Aim for 35%+ in top-10';
        const top10TargetValue = extractTargetValue(top10TargetText, 'ctr'); // 4%
        const top10Diff = top10TargetValue ? (top10Current - top10TargetValue) : null; // Keep sign for display
        rows.push({
          metric: 'Top-10 CTR (positions 110)',
          status: top10Status,
          value: pct(m.top10Ctr),
          currentValue: top10Current,
          target: top10TargetText,
          targetValue: top10TargetValue,
          difference: top10Diff,
          action: top10Status === 'poor'
            ? (segment === 'money'
                ? 'When your money pages are already in positions 110 but clicks are low, re-write titles/meta to be more specific: include location, level (beginner/advanced), and outcome ("learn to", "master").'
                : 'When you are already in positions 110 but clicks are low, re-write titles/meta to be more specific: include location, level (beginner/advanced), and outcome ("learn to", "master").')
            : top10Status === 'ok'
            ? (segment === 'money'
                ? 'Identify top-10 money pages with below-average CTR and iterate on their SERP snippet (titles, descriptions, rich results where available).'
                : 'Identify top-10 pages with below-average CTR and iterate on their SERP snippet (titles, descriptions, rich results where available).')
            : 'Top-10 CTR is healthy. Focus on pushing more queries into the top-10 (see avg position & top-10 share).'
        });
        
        // Average position recommendation
        const posStatus = classifyAvgPos(m.avgPosition);
        const posCurrent = m.avgPosition;
        const posTargetText = 'Aim for average position 36 on core queries';
        const posTargetValue = extractTargetValue(posTargetText, 'position'); // 4.5
        const posDiff = posTargetValue ? (posCurrent - posTargetValue) : null; // Keep sign for display (positive = worse)
        rows.push({
          metric: 'Average position (ranking queries)',
          status: posStatus,
          value: m.avgPosition != null ? m.avgPosition.toFixed(1) : 'N/A',
          currentValue: posCurrent,
          target: posTargetText,
          targetValue: posTargetValue,
          difference: posDiff,
          action: posStatus === 'poor'
            ? (segment === 'money'
                ? 'Most impressions for money pages are coming from low positions. Strengthen internal links to money pages, add more supporting content, and build links from relevant blogs/assignments into these URLs.'
                : 'Most impressions are coming from low positions. Strengthen internal links to key pages, add more supporting content, and build links from relevant blogs/assignments into these URLs.')
            : posStatus === 'ok'
            ? (segment === 'money'
                ? 'Your money pages are mid-page 1 on average. Use on-page tuning (H1, sub-heads, FAQs) and internal links from strong blogs to nudge key money URLs into positions 13.'
                : 'You are mid-page 1 on average. Use on-page tuning (H1, sub-heads, FAQs) and internal links from strong blogs to nudge key URLs into positions 13.')
            : 'Positions are strong overall. Concentrate on CTR and expanding coverage to more relevant queries.'
        });
        
        // Top-10 share recommendation
        const shareStatus = classifyTop10Share(m.top10Share);
        const shareCurrent = m.top10Share * 100; // Convert to percentage
        const shareTargetText = 'Aim for 7585%+ of impressions in top-10';
        const shareTargetValue = extractTargetValue(shareTargetText, 'percentage'); // 80%
        const shareDiff = shareTargetValue ? (shareCurrent - shareTargetValue) : null; // Keep sign for display
        rows.push({
          metric: 'Top-10 impression share',
          status: shareStatus,
          value: pct(m.top10Share, true), // top10Share is stored as decimal (0-1)
          currentValue: shareCurrent,
          target: shareTargetText,
          targetValue: shareTargetValue,
          difference: shareDiff,
          action: shareStatus === 'poor'
            ? (segment === 'money'
                ? 'Large share of impressions for money pages are outside the top-10. Review which queries are generating impressions but no clicks and decide: improve those money pages or deliberately de-optimise low-value queries.'
                : 'Large share of impressions are outside the top-10. Review which queries are generating impressions but no clicks and decide: improve those pages or deliberately de-optimise low-value queries.')
            : shareStatus === 'ok'
            ? (segment === 'money'
                ? 'Gradually push more money page impressions into the top-10 by strengthening key hub pages (workshops, courses, tuition) and consolidating thin or overlapping content.'
                : 'Gradually push more impressions into the top-10 by strengthening key hub pages (workshops, courses, tuition) and consolidating thin or overlapping content.')
            : 'Most impressions are already top-10. Shift effort to CTR and conversion on the URLs listed above.'
        });
        
        return rows;
      }
      
      // Render recommendations table
      function renderRecommendationsTable(segment, metrics, segmentLabel, dateRangeText = '30 days') {
        if (!metrics) {
          return '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">No metrics available for recommendations.</div>';
        }
        
        const recommendations = buildBehaviourRankingRecommendations(segment, metrics);
        
        // Determine priority row: poor status first, or largest gap if no poor
        let priorityIdx = -1;
        const poorRows = recommendations.map((r, i) => ({ idx: i, row: r })).filter(({ row }) => row.status === 'poor');
        if (poorRows.length > 0) {
          // Find poor row with largest gap (use absolute value for comparison)
          priorityIdx = poorRows.reduce((max, curr) => {
            const currGap = Math.abs(curr.row.difference || 0);
            const maxGap = Math.abs(max.row.difference || 0);
            return currGap > maxGap ? curr : max;
          }, poorRows[0]).idx;
        } else {
          // No poor rows, find row with largest gap (use absolute value)
          priorityIdx = recommendations.reduce((maxIdx, row, idx) => {
            const currGap = Math.abs(row.difference || 0);
            const maxGap = Math.abs(recommendations[maxIdx]?.difference || 0);
            return currGap > maxGap ? idx : maxIdx;
          }, 0);
        }
        
        const getStatusPill = (status) => {
          const colors = {
            poor: { bg: '#fee2e2', text: '#991b1b', label: 'Poor' },
            ok: { bg: '#fef3c7', text: '#92400e', label: 'OK' },
            strong: { bg: '#d1fae5', text: '#065f46', label: 'Strong' }
          };
          const color = colors[status] || colors.ok;
          return `<span style="display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; background: ${color.bg}; color: ${color.text}; font-size: 0.75rem; font-weight: 600;">${color.label}</span>`;
        };
        
        // Get segment display name
        const segmentDisplayName = segmentLabel || (segment === 'all' ? 'All pages' : segment === 'nonEducation' ? 'Exclude education (blogs / free course)' : 'Money pages only');
        
        let tableHtml = `
          <div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
            <h4 style="margin: 0 0 0.25rem 0; font-size: 1.2rem; font-weight: 700; color: #1e293b;">Recommended actions for this segment</h4>
            <p style="margin: 0 0 0.5rem 0; font-size: 0.9rem; color: #334155; font-weight: 500;">Segment: <strong>${segmentDisplayName}</strong> (last ${dateRangeText})</p>
            <p style="margin: 0; font-size: 0.9rem; color: #334155; font-weight: 400;">Based on last ${dateRangeText} of Google Search Console data for the currently selected segment.</p>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 1rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">Metric</th>
                  <th style="text-align: center; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">Status</th>
                  <th style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">Current</th>
                  <th style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">Target</th>
                  <th style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">To Target</th>
                  <th style="text-align: left; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">Suggested action</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        recommendations.forEach((row, idx) => {
          const isEven = idx % 2 === 0;
          const isPriority = idx === priorityIdx;
          
          // Determine metric type and format accordingly
          let currentDisplay = row.value;
          let targetDisplay = row.target;
          let diffDisplay = '';
          
          if (row.metric.includes('CTR')) {
            // CTR metrics: show as percentages (1 decimal)
            currentDisplay = `${row.currentValue.toFixed(1)}%`;
            if (row.targetValue !== null && row.targetValue !== undefined) {
              targetDisplay = `${row.targetValue.toFixed(1)}%`;
              if (row.difference !== null && row.difference !== undefined) {
                // Show sign and color based on status
                const gap = row.difference; // Already calculated as current - target
                if (gap >= 0) {
                  // At or above target
                  diffDisplay = '<span style="color: #10b981; font-weight: 600;"> On target</span>';
                } else {
                  // Below target - show with sign
                  const gapColor = row.status === 'poor' ? '#ef4444' : row.status === 'ok' ? '#f59e0b' : '#10b981';
                  diffDisplay = `<span style="color: ${gapColor}; font-weight: 600;">${gap.toFixed(2)}%</span>`;
                }
              }
            }
          } else if (row.metric.includes('position')) {
            // Position metrics: show as numbers (1 decimal)
            currentDisplay = row.currentValue.toFixed(1);
            if (row.targetValue !== null && row.targetValue !== undefined) {
              targetDisplay = row.targetValue.toFixed(1);
              if (row.difference !== null && row.difference !== undefined) {
                // For position, lower is better, so if current <= target, we're good
                const gap = row.difference; // Already calculated as current - target
                if (gap <= 0) {
                  // At or better than target
                  diffDisplay = '<span style="color: #10b981; font-weight: 600;"> On target</span>';
                } else {
                  // Above target (worse position) - show with sign
                  const gapColor = row.status === 'poor' ? '#ef4444' : row.status === 'ok' ? '#f59e0b' : '#10b981';
                  diffDisplay = `<span style="color: ${gapColor}; font-weight: 600;">+${gap.toFixed(1)}</span>`;
                }
              }
            }
          } else if (row.metric.includes('impression share')) {
            // Share metrics: show as percentages (1 decimal)
            currentDisplay = `${row.currentValue.toFixed(1)}%`;
            if (row.targetValue !== null && row.targetValue !== undefined) {
              targetDisplay = `${row.targetValue.toFixed(1)}%`;
              if (row.difference !== null && row.difference !== undefined) {
                // For share, higher is better
                const gap = row.difference; // Already calculated as current - target
                if (gap >= 0) {
                  // At or above target
                  diffDisplay = '<span style="color: #10b981; font-weight: 600;"> On target</span>';
                } else {
                  // Below target - show with sign
                  const gapColor = row.status === 'poor' ? '#ef4444' : row.status === 'ok' ? '#f59e0b' : '#10b981';
                  diffDisplay = `<span style="color: ${gapColor}; font-weight: 600;">${gap.toFixed(2)}%</span>`;
                }
              }
            }
          }
          
          // Priority row styling: left border and optional priority badge
          const priorityStyle = isPriority ? 'border-left: 4px solid #ef4444; background: #fef2f2;' : '';
          const priorityBadge = isPriority ? '<span style="display: inline-block; margin-left: 0.5rem; padding: 0.15rem 0.4rem; background: #ef4444; color: white; border-radius: 4px; font-size: 0.8rem; font-weight: 600;">Priority</span>' : '';
          
          tableHtml += `
            <tr style="border-bottom: 1px solid #f1f5f9; background: ${isEven ? '#ffffff' : '#fafafa'}; ${priorityStyle} transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa';" onmouseout="this.style.background='${isEven ? '#ffffff' : '#fafafa'}';">
              <td style="padding: 0.9rem; color: #0f172a; font-weight: 600; font-size: 1rem;">${row.metric}${priorityBadge}</td>
              <td style="padding: 0.9rem; text-align: center; font-size: 1rem;">${getStatusPill(row.status)}</td>
              <td style="padding: 0.9rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 1rem;">${currentDisplay}</td>
              <td style="padding: 0.9rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 1rem;">${targetDisplay}</td>
              <td style="padding: 0.9rem; text-align: right; font-weight: 600; font-size: 1rem;">${diffDisplay}</td>
              <td style="padding: 0.9rem; color: #0f172a; font-weight: 400; line-height: 1.5; font-size: 1rem;">${row.action}</td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        return tableHtml;
      }
      
      // Function to render full-width top pages table (shared by both createTopPagesSection functions)
      function renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText = '30 days') {
        if (!topPages || topPages.length === 0) {
          return '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">No page data available for this segment. This table shows the latest snapshot from your most recent audit (static data, not affected by time period selections). If you see this message, the data may not have been computed during the last audit. Make sure your audit includes Google Search Console query+page metrics (queryPages dimension) and that you have uploaded site-urls.csv for segmentation.</div>';
        }
        
        // Store original data for sorting
        if (!window.topPagesData) {
          window.topPagesData = topPages;
          window.topPagesSortColumn = null;
          window.topPagesSortDirection = 'desc';
        }
        
        // Sort data if needed
        let sortedPages = [...topPages];
        if (window.topPagesSortColumn) {
          sortedPages.sort((a, b) => {
            let aVal, bVal;
            switch(window.topPagesSortColumn) {
              case 'ctr':
                aVal = a.ctr || 0;
                bVal = b.ctr || 0;
                break;
              case 'impressions':
                aVal = a.impressions || 0;
                bVal = b.impressions || 0;
                break;
              case 'clicks':
                aVal = a.clicks || 0;
                bVal = b.clicks || 0;
                break;
              case 'position':
                aVal = a.avgPosition || 0;
                bVal = b.avgPosition || 0;
                break;
              default:
                return 0;
            }
            const diff = aVal - bVal;
            return window.topPagesSortDirection === 'asc' ? diff : -diff;
          });
        }
        
        // Helper function to get sort icon (must be defined before use in template)
        const getSortIcon = (column) => {
          if (!window.topPagesSortColumn || window.topPagesSortColumn !== column) {
            return '<span style="color: #475569; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 600;"></span>';
          }
          return window.topPagesSortDirection === 'asc' 
            ? '<span style="color: #99004C; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 700;"></span>'
            : '<span style="color: #99004C; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 700;"></span>';
        };
        
        let tableHtml = `
          <div style="margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
            <div>
              <h4 style="margin: 0 0 0.25rem 0; font-size: 1.2rem; font-weight: 700; color: #1e293b;">Top 10 pages by impressions</h4>
              <span style="font-size: 0.9rem; color: #334155; font-weight: 500;">Data period: Last ${dateRangeText}</span>
            </div>
            <button id="top-pages-copy-urls" type="button" style="font-size: 0.95rem; padding: 0.6rem 0.9rem; border-radius: 6px; border: 1px solid #2563eb; background: #2563eb; cursor: pointer; color: white; font-weight: 600; transition: all 0.2s; box-shadow: 0 1px 2px rgba(0,0,0,0.1);" onmouseover="this.style.background='#1d4ed8'; this.style.borderColor='#1d4ed8';" onmouseout="this.style.background='#2563eb'; this.style.borderColor='#2563eb';">
              Copy URLs
            </button>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 1rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">#</th>
                  <th style="text-align: left; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;">URL</th>
                  <th id="sort-ctr" style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by CTR">
                    CTR${getSortIcon('ctr')}
                  </th>
                  <th id="sort-impressions" style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Impressions">
                    Impressions${getSortIcon('impressions')}
                  </th>
                  <th id="sort-clicks" style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Clicks">
                    Clicks${getSortIcon('clicks')}
                  </th>
                  <th id="sort-position" style="text-align: right; padding: 0.9rem; font-weight: 700; color: #1e293b; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Avg Position">
                    Avg Position${getSortIcon('position')}
                  </th>
                </tr>
              </thead>
              <tbody>
        `;
        
        sortedPages.forEach((page, idx) => {
          const isEven = idx % 2 === 0;
          const safeCtr = page.ctr != null ? page.ctr : 0;
          const safePos = page.avgPosition != null ? page.avgPosition : 0;
          const ctrColor = safeCtr >= 2 ? '#10b981' : safeCtr >= 1 ? '#f59e0b' : '#ef4444';
          const posColor = safePos <= 5 ? '#10b981' : safePos <= 10 ? '#f59e0b' : '#ef4444';
          const ctrStr = page.ctr != null ? page.ctr.toFixed(1) : 'N/A';
          const posStr = page.avgPosition != null ? page.avgPosition.toFixed(1) : 'N/A';
          tableHtml += `
            <tr style="border-bottom: 1px solid #f1f5f9; background: ${isEven ? '#ffffff' : '#fafafa'}; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa';" onmouseout="this.style.background='${isEven ? '#ffffff' : '#fafafa'}';">
              <td style="padding: 0.9rem; color: #0f172a; font-weight: 600; font-size: 1rem;">${idx + 1}</td>
              <td style="padding: 0.9rem; word-break: break-all; font-size: 1rem;">
                <a href="${page.url}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none; font-weight: 500; border-bottom: 1px solid transparent; transition: all 0.2s;" onmouseover="this.style.color='#1d4ed8'; this.style.borderBottomColor='#1d4ed8';" onmouseout="this.style.color='#2563eb'; this.style.borderBottomColor='transparent';" title="Open ${page.url} in new tab">${page.url}</a>
              </td>
              <td style="padding: 0.9rem; text-align: right; color: ${ctrColor}; font-weight: 600; font-size: 1rem;">${ctrStr}%</td>
              <td style="padding: 0.9rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 1rem;">${page.impressions.toLocaleString()}</td>
              <td style="padding: 0.9rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 1rem;">${page.clicks.toLocaleString()}</td>
              <td style="padding: 0.9rem; text-align: right; color: ${posColor}; font-weight: 600; font-size: 1rem;">${page.avgPosition != null ? page.avgPosition.toFixed(1) : 'N/A'}</td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        return tableHtml;
      }
      
      // Helper to attach sort handlers after table is in DOM (shared by both createTopPagesSection functions)
      function attachSortHandlers() {
        setTimeout(() => {
          ['ctr', 'impressions', 'clicks', 'position'].forEach(col => {
            const th = document.getElementById(`sort-${col}`);
            if (th) {
              // Remove existing listeners by cloning
              const newTh = th.cloneNode(true);
              th.parentNode.replaceChild(newTh, th);
              newTh.addEventListener('click', () => {
                if (window.handleSort) {
                  window.handleSort(col);
                } else {
                  console.error('window.handleSort is not defined');
                }
              });
            } else {
              console.warn(`Sort header not found: sort-${col}`);
            }
          });
        }, 50);
      }
      
      // Make handleSort available globally (shared by both createTopPagesSection functions)
      if (!window.handleSort) {
        window.handleSort = function(column) {
          console.log('handleSort called with column:', column);
          if (window.topPagesSortColumn === column) {
            window.topPagesSortDirection = window.topPagesSortDirection === 'asc' ? 'desc' : 'asc';
          } else {
            window.topPagesSortColumn = column;
            window.topPagesSortDirection = 'desc';
          }
          
          // Get current data from stored source
          const currentMode = window.currentAuthorityMode || 'all';
          let topPages = window.topPagesData || [];
          
          // If no stored data, try to get from authorityBySegment
          if (!topPages || topPages.length === 0) {
            const segData = window.authorityBySegment;
            if (segData) {
              topPages = currentMode === 'all'
                ? (segData.all?.topPages || [])
                : currentMode === 'nonEducation'
                ? (segData.nonEducation?.topPages || [])
                : (segData.money?.topPages || []);
              window.topPagesData = topPages;
            }
          }
          
          const segmentLabel = currentMode === 'all'
            ? 'All pages'
            : currentMode === 'nonEducation'
            ? 'Exclude education (blogs / free course)'
            : 'Money pages only';
          
          // Get date range for display
          const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
          const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
          
          const tableContainer = document.getElementById('top-pages-table-container');
          if (tableContainer) {
            tableContainer.innerHTML = renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText);
            // attachCopyButtonHandler and attachSortHandlers are in shared scope, so they're accessible
            attachSortHandlers();
            // attachCopyButtonHandler is defined inside createTopPagesSection, so we need to find it or define it globally
            // For now, attach the copy button handler directly
            setTimeout(() => {
              const copyBtn = document.getElementById('top-pages-copy-urls');
              if (copyBtn) {
                const newCopyBtn = copyBtn.cloneNode(true);
                copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
                newCopyBtn.addEventListener('click', async () => {
                  const currentMode = window.currentAuthorityMode || 'all';
                  const segData = window.authorityBySegment;
                  const currentTopPages = currentMode === 'all'
                    ? (segData?.all?.topPages || [])
                    : currentMode === 'nonEducation'
                    ? (segData?.nonEducation?.topPages || [])
                    : (segData?.money?.topPages || []);
                  const text = currentTopPages.map(p => p.url).join('\n');
                  try {
                    await navigator.clipboard.writeText(text);
                    newCopyBtn.textContent = 'Copied!';
                    newCopyBtn.style.color = '#10b981';
                    setTimeout(() => {
                      newCopyBtn.textContent = 'Copy URLs';
                      newCopyBtn.style.color = '#666';
                    }, 2000);
                  } catch (err) {
                    console.error('Failed to copy URLs:', err);
                    newCopyBtn.textContent = 'Copy failed';
                    setTimeout(() => {
                      newCopyBtn.textContent = 'Copy URLs';
                    }, 2000);
                  }
                });
              }
            }, 50);
          } else {
            console.error('top-pages-table-container not found');
          }
        };
      }
      
      // Function to render segment comparison table (shared by both createTopPagesSection functions)
      function renderSegmentComparisonTable(authorityBySegment, currentMode) {
        const segments = [
          { key: 'all', label: 'All pages', data: authorityBySegment.all },
          { key: 'nonEducation', label: 'Exclude education (blogs / free course)', data: authorityBySegment.nonEducation },
          { key: 'money', label: 'Money pages only', data: authorityBySegment.money }
        ];
        
        let tableHtml = `
          <div style="margin-bottom: 0.5rem;">
            <h4 style="margin: 0 0 0.5rem 0; font-size: 1.15rem; font-weight: 700; color: #1e293b;">Segment overview (CTR & ranking)</h4>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.95rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Segment</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Site CTR</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Top-10 CTR</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Avg pos.</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Top-10 share</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Behaviour</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Ranking</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        segments.forEach(({ key, label, data }, idx) => {
          const isActive = key === currentMode;
          const siteCtr = data?.siteCtr || 0;
          const top10Ctr = data?.top10Ctr || 0;
          const avgPosition = data?.avgPosition || 0;
          const top10Share = (data?.top10Share || 0) * 100;
          const behaviourScore = data?.behaviour || 0;
          const rankingScore = data?.ranking || 0;
          
          tableHtml += `
            <tr 
              onclick="window.currentAuthorityMode = '${key}'; if(window.updateTopPagesSection) window.updateTopPagesSection('${key}');"
              style="
                cursor: pointer;
                border-bottom: 1px solid #f1f5f9;
                background: ${isActive ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : (idx % 2 === 0 ? '#ffffff' : '#fafafa')};
                transition: all 0.2s;
              "
              onmouseover="this.style.background='${isActive ? 'linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%)' : '#f8f9fa'}';"
              onmouseout="this.style.background='${isActive ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : (idx % 2 === 0 ? '#ffffff' : '#fafafa')}';"
            >
              <td style="padding: 0.75rem 1rem; font-weight: ${isActive ? '600' : '500'}; color: #0f172a; font-size: 0.95rem;">
                ${label}
                ${isActive ? '<span style="margin-left: 0.5rem; font-size: 0.8rem; padding: 0.15rem 0.5rem; border-radius: 999px; background: #10b981; color: white; font-weight: 600;">current</span>' : ''}
              </td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${siteCtr != null ? siteCtr.toFixed(1) : 'N/A'}%</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${top10Ctr != null ? top10Ctr.toFixed(1) : 'N/A'}%</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${avgPosition != null ? avgPosition.toFixed(1) : 'N/A'}</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${top10Share != null ? top10Share.toFixed(1) : 'N/A'}%</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 0.95rem;">${behaviourScore != null ? Math.round(behaviourScore) : 'N/A'}</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 0.95rem;">${rankingScore != null ? Math.round(rankingScore) : 'N/A'}</td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        return tableHtml;
      }
      
      // Function to create Top Pages section (full width, below pillar cards)
      function createTopPagesSection(scores, saved) {
        // Get Authority segment data from current scores (latest snapshot, not historical)
        // This uses the most recent audit data, not historical Supabase data
        const authorityObj = scores?.authority;
        let authorityBySegment = (typeof authorityObj === 'object' && authorityObj !== null) 
          ? authorityObj.bySegment 
          : null;
        
        // If no segment data in scores, try to get from saved audit (latest audit data from localStorage)
        if (!authorityBySegment && saved) {
          const savedScores = saved.scores;
          if (savedScores && savedScores.authority) {
            const savedAuthorityObj = savedScores.authority;
            if (typeof savedAuthorityObj === 'object' && savedAuthorityObj !== null) {
              authorityBySegment = savedAuthorityObj.bySegment || null;
              debugLog(' Top Pages: Using Authority segment data from saved audit (latest snapshot)', 'info');
            }
          }
        }
        
        if (!authorityBySegment) {
          debugLog(' No Authority segment data available for Top Pages table. This requires GSC queryPages data from your most recent audit.', 'warn');
          // Still create the section but show a helpful message - don't return early
        }
        
        // Remove existing top pages section if it exists
        const existingTopPages = document.getElementById('authority-top-pages-section');
        if (existingTopPages) {
          existingTopPages.remove();
        }
        
        // Create new section
        const topPagesSection = document.createElement('div');
        topPagesSection.id = 'authority-top-pages-section';
        topPagesSection.className = 'section-break';
        topPagesSection.style.marginTop = '2rem';
        topPagesSection.style.marginBottom = '2rem';
        
        // Get current mode from Authority card toggle (default to 'all')
        let currentMode = 'all';
        const authorityCard = Array.from(document.querySelectorAll('.pillar-card')).find(card => {
          const h3 = card.querySelector('h3');
          return h3 && h3.textContent === 'Authority';
        });
        
        if (authorityCard && authorityCard._authorityMode) {
          currentMode = authorityCard._authorityMode;
        }
        
        // Get top pages for current mode
        const topPages = currentMode === 'all'
          ? (authorityBySegment?.all?.topPages || [])
          : currentMode === 'nonEducation'
          ? (authorityBySegment?.nonEducation?.topPages || [])
          : (authorityBySegment?.money?.topPages || []);
        
        const segmentLabel = currentMode === 'all'
          ? 'All pages'
          : currentMode === 'nonEducation'
          ? 'Exclude education (blogs / free course)'
          : 'Money pages only';
        
        debugLog(` Top Pages: Found ${topPages.length} pages for segment "${currentMode}"`, 'info');
        if (topPages.length > 0) {
          debugLog(` Top Pages: First page URL: ${topPages[0].url}, Impressions: ${topPages[0].impressions}`, 'info');
        }
        
        // Get brand queries for mini-table
        const topQueries = saved?.searchData?.topQueries || [];
        const brandQueries = topQueries
          .filter(q => isBrandQuery(q.query || ''))
          .sort((a, b) => (b.impressions || 0) - (a.impressions || 0))
          .slice(0, 10);
        
        // Create section HTML
        topPagesSection.innerHTML = `
          <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 1rem 0; color: var(--brand-dark); font-size: 1.5rem;">Authority - Behaviour & Ranking</h3>
            <div style="margin-bottom: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 4px; font-size: 1rem; line-height: 1.6; color: #666;">
              <p style="margin: 0 0 0.75rem 0;"><strong>Behaviour:</strong> Measures click-through rate (CTR) performance. Combines Overall CTR (50% weight) for all ranking search terms and Top-10 Ranked Search Terms CTR (50% weight) for queries ranking in positions 1-10. Indicates how well your titles and descriptions convert impressions to clicks. Data source: Google Search Console query+page metrics.</p>
              <p style="margin: 0;"><strong>Ranking:</strong> Measures search visibility and position quality. Combines Average Position Score (50% weight) and Top-10 Impression Share (50% weight). Shows how high you rank on average and what percentage of impressions appear in positions 1-10. Data source: Google Search Console query+page metrics.</p>
            </div>
            <div style="margin-bottom: 1rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; font-size: 0.9rem;">
              <span style="font-weight: 600; color: #666;">Current Segment:</span>
              <span id="top-pages-segment-label" style="color: #333; margin-left: 0.5rem;">${segmentLabel}</span>
            </div>
            <div id="top-pages-table-container">
              ${renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText)}
            </div>
            
            ${authorityBySegment && authorityBySegment[currentMode] ? `
            <div id="top-pages-recommendations-container" style="margin-top: 2rem;">
              ${renderRecommendationsTable(currentMode, {
                siteCtr: authorityBySegment[currentMode].siteCtr || 0,
                top10Ctr: authorityBySegment[currentMode].top10Ctr || 0,
                avgPosition: authorityBySegment[currentMode].avgPosition || 0,
                top10Share: authorityBySegment[currentMode].top10Share || 0,
                behaviourScore: authorityBySegment[currentMode].behaviour || 0,
                rankingScore: authorityBySegment[currentMode].ranking || 0
              }, segmentLabel, dateRangeText)}
            </div>
            ` : ''}
            
            ${brandQueries.length > 0 ? `
            <div style="margin-top: 2rem; padding: 1rem; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #f59e0b;">
              <h4 style="margin: 0 0 0.75rem 0; color: #92400e; font-size: 1rem; font-weight: 600;">Top Branded Queries</h4>
              <p style="margin: 0 0 1rem 0; font-size: 0.85rem; color: #666; line-height: 1.5;">Branded search queries (e.g., "Alan Ranger Photography") with CTR and position metrics.</p>
              <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                  <thead>
                    <tr style="background: #e5e7eb; border-bottom: 2px solid #d1d5db;">
                      <th style="padding: 0.5rem; text-align: left; font-weight: 600; color: #374151;">Query</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Impressions</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Clicks</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">CTR</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Position</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${brandQueries.map((q, idx) => {
                      const ctr = q.impressions > 0 ? ((q.clicks || 0) / q.impressions * 100) : 0;
                      const ctrColor = ctr >= 25 ? '#10b981' : ctr >= 10 ? '#f59e0b' : '#ef4444';
                      const posColor = (q.position || 0) <= 3 ? '#10b981' : (q.position || 0) <= 5 ? '#f59e0b' : '#ef4444';
                      return `
                      <tr style="border-bottom: 1px solid #e5e7eb; ${idx % 2 === 0 ? 'background: #ffffff;' : 'background: #f9fafb;'}">
                        <td style="padding: 0.5rem; color: #1f2937; font-weight: 500;">${(q.query || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</td>
                        <td style="padding: 0.5rem; text-align: right; color: #6b7280;">${(q.impressions || 0).toLocaleString()}</td>
                        <td style="padding: 0.5rem; text-align: right; color: #6b7280;">${(q.clicks || 0).toLocaleString()}</td>
                        <td style="padding: 0.5rem; text-align: right; color: ${ctrColor}; font-weight: 600;">${ctr.toFixed(1)}%</td>
                        <td style="padding: 0.5rem; text-align: right; color: ${posColor}; font-weight: 600;">${(q.position || 0).toFixed(1)}</td>
                      </tr>
                    `;
                    }).join('')}
                  </tbody>
                </table>
              </div>
            </div>
            ` : ''}
          </div>
        `;
        
        // Insert into Authority panel instead of Overview
        const authorityPanel = document.querySelector('.aigeo-panel[data-panel="authority"]');
        if (authorityPanel) {
          // Clear any existing content
          const existing = document.getElementById('authority-top-pages-section');
          if (existing) existing.remove();
          authorityPanel.appendChild(topPagesSection);
          debugLog(' Authority section inserted into Authority panel', 'success');
        } else {
          // Fallback: insert after pillar cards (old behavior)
        pillarCards.parentNode.insertBefore(topPagesSection, pillarCards.nextSibling);
          debugLog(' Authority section inserted after pillar cards (fallback)', 'info');
        }
        
        // Store authorityBySegment globally so updateTopPagesSection can access it
        window.authorityBySegment = authorityBySegment;
        
        // Store update function globally so Authority mode toggle can call it
        window.updateTopPagesSection = function(mode) {
          const topPages = mode === 'all'
            ? (authorityBySegment?.all?.topPages || [])
            : mode === 'nonEducation'
            ? (authorityBySegment?.nonEducation?.topPages || [])
            : (authorityBySegment?.money?.topPages || []);
          
          const segmentLabel = mode === 'all'
            ? 'All pages'
            : mode === 'nonEducation'
            ? 'Exclude education (blogs / free course)'
            : 'Money pages only';
          
          debugLog(` Top Pages: Updating to segment "${mode}", found ${topPages.length} pages`, 'info');
          
          // Update segment label
          const labelEl = document.getElementById('top-pages-segment-label');
          if (labelEl) labelEl.textContent = segmentLabel;
          
          // Update summary if available
          const getSegmentSummary = (m) => {
            if (!authorityBySegment || !authorityBySegment[m]) return null;
            const segmentData = authorityBySegment[m];
            return {
              behaviour: segmentData.behaviour || 0,
              ranking: segmentData.ranking || 0,
              total: segmentData.total || segmentData.score || 0
            };
          };
          
          const summary = getSegmentSummary(mode);
          const summaryDiv = document.getElementById('top-pages-segment-summary');
          if (summary && summaryDiv) {
            const rag = getRAGStatus(summary.total);
            summaryDiv.innerHTML = `
              ${formatComponentScore('Behaviour', summary.behaviour)}
              ${formatComponentScore('Ranking', summary.ranking)}
            `;
            // Update RAG badge and score
            const ragBadge = summaryDiv.parentElement.querySelector('.rag-badge');
            const scoreSpan = summaryDiv.parentElement.querySelector('span[style*="font-size: 1.5rem"]');
            if (ragBadge) {
              ragBadge.className = `rag-badge ${rag.status}`;
              ragBadge.textContent = rag.label;
            }
            if (scoreSpan) {
              scoreSpan.textContent = Math.round(summary.total);
              scoreSpan.style.color = rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444';
            }
          }
          
          // Update toggle buttons
          ['all', 'nonEducation', 'money'].forEach(m => {
            const btn = document.getElementById(`top-pages-mode-${m}`);
            if (btn) {
              if (m === mode) {
                btn.style.background = '#10b981';
                btn.style.color = 'white';
                btn.style.fontWeight = '600';
              } else {
                btn.style.background = 'white';
                btn.style.color = '#666';
                btn.style.fontWeight = '400';
              }
            }
          });
          
          // Update comparison table
          const comparisonDiv = document.getElementById('top-pages-comparison-table');
          if (comparisonDiv && authorityBySegment) {
            comparisonDiv.innerHTML = renderSegmentComparisonTable(authorityBySegment, mode);
          }
          
          // Get date range for display
          const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
          const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
          
          // Update table (reset sort when switching segments)
          window.topPagesData = topPages;
          window.topPagesSortColumn = null;
          window.topPagesSortDirection = 'desc';
          const tableContainer = document.getElementById('top-pages-table-container');
          if (tableContainer) {
            tableContainer.innerHTML = renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText);
            attachCopyButtonHandler();
            attachSortHandlers();
          }
          
          // Update recommendations table
          const recommendationsContainer = document.getElementById('top-pages-recommendations-container');
          if (recommendationsContainer && authorityBySegment && authorityBySegment[mode]) {
            const segmentLabel = mode === 'all'
              ? 'All pages'
              : mode === 'nonEducation'
              ? 'Exclude education (blogs / free course)'
              : 'Money pages only';
            const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
            const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
            recommendationsContainer.innerHTML = renderRecommendationsTable(mode, {
              siteCtr: authorityBySegment[mode].siteCtr || 0,
              top10Ctr: authorityBySegment[mode].top10Ctr || 0,
              avgPosition: authorityBySegment[mode].avgPosition || 0,
              top10Share: authorityBySegment[mode].top10Share || 0,
              behaviourScore: authorityBySegment[mode].behaviour || 0,
              rankingScore: authorityBySegment[mode].ranking || 0
            }, segmentLabel, dateRangeText);
          }
        };
        
        // window.handleSort is now defined in shared scope above
        
        // Attach toggle button handlers
        setTimeout(() => {
          ['all', 'nonEducation', 'money'].forEach(mode => {
            const btn = document.getElementById(`top-pages-mode-${mode}`);
            if (btn) {
              btn.addEventListener('click', () => {
                window.currentAuthorityMode = mode;
                window.updateTopPagesSection(mode);
                // Also update Authority pillar card if it exists
                const authorityCard = Array.from(document.querySelectorAll('.pillar-card')).find(card => {
                  const h3 = card.querySelector('h3');
                  return h3 && h3.textContent === 'Authority';
                });
                if (authorityCard && authorityCard._updateAuthorityDisplay) {
                  authorityCard._authorityMode = mode;
                  authorityCard._updateAuthorityDisplay();
                  // Update Authority pillar toggle buttons
                  const modeId = authorityCard._modeId;
                  ['all', 'nonEducation', 'money'].forEach(m => {
                    const authBtn = document.getElementById(`${modeId}-${m}`);
                    if (authBtn) {
                      if (m === mode) {
                        authBtn.style.background = '#10b981';
                        authBtn.style.color = 'white';
                      } else {
                        authBtn.style.background = 'white';
                        authBtn.style.color = '#666';
                      }
                    }
                  });
                }
              });
            }
          });
        }, 0);
        
        // Attach initial copy button handler
        attachCopyButtonHandler();
        
        function attachCopyButtonHandler() {
          setTimeout(() => {
            const copyBtn = document.getElementById('top-pages-copy-urls');
            if (copyBtn) {
              // Remove existing listener
              const newCopyBtn = copyBtn.cloneNode(true);
              copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
              
              newCopyBtn.addEventListener('click', async () => {
                const currentMode = window.currentAuthorityMode || 'all';
                const currentTopPages = currentMode === 'all'
                  ? (authorityBySegment?.all?.topPages || [])
                  : currentMode === 'nonEducation'
                  ? (authorityBySegment?.nonEducation?.topPages || [])
                  : (authorityBySegment?.money?.topPages || []);
                
                const text = currentTopPages.map(p => p.url).join('\n');
                try {
                  await navigator.clipboard.writeText(text);
                  newCopyBtn.textContent = 'Copied!';
                  newCopyBtn.style.color = '#10b981';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                    newCopyBtn.style.color = '#666';
                  }, 2000);
                } catch (err) {
                  console.error('Failed to copy URLs:', err);
                  newCopyBtn.textContent = 'Copy failed';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                  }, 2000);
                }
              });
            }
          }, 0);
        }
        // renderFullWidthTopPagesTable is now defined in shared scope above
      }
      
      // Function to render Money Pages table (with pagination and sorting, matching Top Pages format)
      function renderMoneyPagesTable(moneyRows, currentPage = 1, rowsPerPage = 10) {
        try {
          if (!moneyRows || moneyRows.length === 0) {
            return '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">No money-page data available for this audit period. Check that your money pages have impressions in the selected date range.</div>';
          }
        
        // Store original data for sorting (across all pages) - update if new data provided
        window.moneyPagesData = moneyRows;
        if (window.moneyPagesSortColumn === undefined) {
          window.moneyPagesSortColumn = null;
          window.moneyPagesSortDirection = 'desc';
        }
        
        // Sort data if needed (sort ALL rows, not just current page)
        let sortedRows = [...moneyRows];
        if (window.moneyPagesSortColumn) {
          sortedRows.sort((a, b) => {
            let aVal, bVal;
            switch(window.moneyPagesSortColumn) {
              case 'ctr':
                aVal = (a.ctr || 0) * 100;
                bVal = (b.ctr || 0) * 100;
                break;
              case 'impressions':
                aVal = a.impressions || 0;
                bVal = b.impressions || 0;
                break;
              case 'clicks':
                aVal = a.clicks || 0;
                bVal = b.clicks || 0;
                break;
              case 'position':
                aVal = a.avgPosition || 99;
                bVal = b.avgPosition || 99;
                break;
              case 'opportunity':
                // Sort by category priority: HIGH_OPPORTUNITY=0, VISIBILITY_FIX=1, MAINTAIN=2
                const categoryOrder = { HIGH_OPPORTUNITY: 0, VISIBILITY_FIX: 1, MAINTAIN: 2 };
                aVal = categoryOrder[a.category] ?? 99;
                bVal = categoryOrder[b.category] ?? 99;
                break;
              default:
                return 0;
            }
            const diff = aVal - bVal;
            return window.moneyPagesSortDirection === 'asc' ? diff : -diff;
          });
        }
        
        // Update stored sorted data
        window.moneyPagesData = sortedRows;
        
        // Helper function to get sort icon
        const getSortIcon = (column) => {
          if (!window.moneyPagesSortColumn || window.moneyPagesSortColumn !== column) {
            return '<span style="color: #475569; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 600;"></span>';
          }
          return window.moneyPagesSortDirection === 'asc' 
            ? '<span style="color: #99004C; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 700;"></span>'
            : '<span style="color: #99004C; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 700;"></span>';
        };
        
        // Get date range for display
        const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
        const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
        
        // Get current filter values (stored globally)
        const currentCategoryFilter = window.moneyPagesCategoryFilter || 'ALL';
        const currentSubSegmentFilter = window.moneyPagesSubSegmentFilter || 'ALL';
        const currentMinImpressions = window.moneyPagesMinImpressions || 0;
        
        // Get zero impressions filter (default to true - include zero impressions)
        const includeZero = window.moneyPagesIncludeZero !== false;
        
        // Apply filters before sorting/pagination
        let filteredRows = sortedRows.filter(row => {
          const matchCat = currentCategoryFilter === 'ALL' || row.category === currentCategoryFilter;
          const matchSubSeg = currentSubSegmentFilter === 'ALL' || row.subSegment === currentSubSegmentFilter;
          const matchImp = (row.impressions || 0) >= currentMinImpressions;
          const matchZero = includeZero || (row.impressions || 0) > 0; // Include zero impressions if checkbox is checked
          return matchCat && matchSubSeg && matchImp && matchZero;
        });
        
        // Update pagination based on filtered rows
        const filteredTotalPages = Math.ceil(filteredRows.length / rowsPerPage);
        const filteredStartIdx = (currentPage - 1) * rowsPerPage;
        const filteredEndIdx = filteredStartIdx + rowsPerPage;
        const pageRows = filteredRows.slice(filteredStartIdx, filteredEndIdx);
        
        let tableHtml = `
          <div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem;">
              <div>
                <h4 style="margin: 0 0 0.25rem 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Money Pages Opportunity Table</h4>
                <p class="table-subtitle" style="margin: 0 0 0.5rem 0; font-size: 0.75rem; color: #64748b;">
                  Filter by opportunity type and impressions to focus optimisation work.
                </p>
                <span style="font-size: 0.75rem; color: #334155; font-weight: 500;">Data period: Last ${dateRangeText}  Showing ${filteredStartIdx + 1}-${Math.min(filteredEndIdx, filteredRows.length)} of ${filteredRows.length}</span>
              </div>
              <div class="table-controls" style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  Category:
                  <select id="money-pages-filter-category" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; background: white; cursor: pointer;">
                    <option value="ALL" ${currentCategoryFilter === 'ALL' ? 'selected' : ''}>All categories</option>
                    <option value="HIGH_OPPORTUNITY" ${currentCategoryFilter === 'HIGH_OPPORTUNITY' ? 'selected' : ''}>High opportunity</option>
                    <option value="VISIBILITY_FIX" ${currentCategoryFilter === 'VISIBILITY_FIX' ? 'selected' : ''}>Visibility fix</option>
                    <option value="MAINTAIN" ${currentCategoryFilter === 'MAINTAIN' ? 'selected' : ''}>Maintain</option>
                  </select>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  Sub-segment:
                  <select id="money-pages-filter-subsegment" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; background: white; cursor: pointer;">
                    <option value="ALL" ${currentSubSegmentFilter === 'ALL' ? 'selected' : ''} id="money-subsegment-all">All sub-segments</option>
                    <option value="PRODUCT" ${currentSubSegmentFilter === 'PRODUCT' ? 'selected' : ''} id="money-subsegment-product">Product Pages</option>
                    <option value="EVENT" ${currentSubSegmentFilter === 'EVENT' ? 'selected' : ''} id="money-subsegment-event">Event Pages</option>
                    <option value="LANDING" ${currentSubSegmentFilter === 'LANDING' ? 'selected' : ''} id="money-subsegment-landing">Landing Pages</option>
                  </select>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  Min impressions:
                  <input type="number" id="money-pages-min-impressions" min="0" step="50" value="${currentMinImpressions}" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; width: 100px;" />
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  <input type="checkbox" id="money-pages-include-zero" ${window.moneyPagesIncludeZero !== false ? 'checked' : ''} style="cursor: pointer;" />
                  Include zero impressions
                </label>
                <button id="money-pages-copy-urls" type="button" style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #2563eb; background: #2563eb; cursor: pointer; color: white; font-weight: 600; transition: all 0.2s; box-shadow: 0 1px 2px rgba(0,0,0,0.1);" onmouseover="this.style.background='#1d4ed8'; this.style.borderColor='#1d4ed8';" onmouseout="this.style.background='#2563eb'; this.style.borderColor='#2563eb';">
                  Copy current URLs
                </button>
              </div>
            </div>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; width: 40px;">#</th>
                  <th style="text-align: left; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; width: 500px; min-width: 500px;">URL / Title / Meta</th>
                  <th id="money-sort-clicks" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; white-space: nowrap;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Clicks">
                    Clicks${getSortIcon('clicks')}
                  </th>
                  <th id="money-sort-impressions" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; white-space: nowrap;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Impressions">
                    Impressions${getSortIcon('impressions')}
                  </th>
                  <th id="money-sort-ctr" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; white-space: nowrap;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by CTR">
                    CTR${getSortIcon('ctr')}
                  </th>
                  <th id="money-sort-position" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; line-height: 1.2;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Avg Position">
                    <div>Avg</div><div>Position</div>${getSortIcon('position')}
                  </th>
                  <th id="money-sort-opportunity" style="text-align: center; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s; white-space: nowrap;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Opportunity">
                    Opportunity${getSortIcon('opportunity')}
                  </th>
                  <th style="text-align: left; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; width: 200px; min-width: 200px;">Schema Types</th>
                  <th style="text-align: left; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px;">Recommended action</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        pageRows.forEach((row, idx) => {
          const isEven = idx % 2 === 0;
          const rowBg = isEven ? '#ffffff' : '#fafafa';
          const ctrPct = (row.ctr || 0) * 100;
          const ctrColor = ctrPct >= 2 ? '#10b981' : ctrPct >= 1 ? '#f59e0b' : '#ef4444';
          const posColor = row.avgPosition <= 5 ? '#10b981' : row.avgPosition <= 10 ? '#f59e0b' : '#ef4444';
          const categoryColor = row.categoryColor === 'green' ? '#10b981' : row.categoryColor === 'amber' ? '#f59e0b' : '#ef4444';
          
          // Extract title from row data or generate from URL
          const pageTitle = row.title || (() => {
            try {
              const urlObj = new URL(row.url);
              const pathParts = urlObj.pathname.split('/').filter(p => p);
              if (pathParts.length > 0) {
                // Convert last path segment to title case
                const lastPart = pathParts[pathParts.length - 1];
                return lastPart.split('-').map(word => 
                  word.charAt(0).toUpperCase() + word.slice(1)
                ).join(' ');
              }
            } catch (e) {}
            return null; // Will show URL if no title
          })();
          
          // Meta description from row data
          const metaDescription = row.metaDescription || null;
          
          tableHtml += `
            <tr style="border-bottom: 1px solid #f1f5f9; background: ${rowBg}; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa';" onmouseout="this.style.background='${rowBg}';">
              <td style="padding: 0.75rem; color: #0f172a; font-weight: 600; vertical-align: top; width: 40px;">${filteredStartIdx + idx + 1}</td>
              <td style="padding: 0.75rem; vertical-align: top; width: 500px; min-width: 500px;">
                <a href="${row.url}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none; font-weight: 500; border-bottom: 1px solid transparent; transition: all 0.2s;" onmouseover="this.style.color='#1d4ed8'; this.style.borderBottomColor='#1d4ed8';" onmouseout="this.style.color='#2563eb'; this.style.borderBottomColor='transparent';" title="Open ${row.url} in new tab">
                  <div style="font-size: 0.85rem; color: #64748b; margin-bottom: 0.25rem; word-break: break-all;">${row.url}</div>
                </a>
                ${pageTitle ? `<div style="font-weight: 600; color: #1e293b; font-size: 0.9rem; margin-top: 0.5rem; margin-bottom: 0.25rem; white-space: nowrap;">${pageTitle}</div>` : ''}
                ${metaDescription ? `<div style="font-size: 0.8rem; color: #64748b; line-height: 1.4; margin-top: ${pageTitle ? '0.25rem' : '0.5rem'}; word-wrap: break-word;">${metaDescription}</div>` : '<div style="font-size: 0.8rem; color: #94a3b8; font-style: italic; margin-top: 0.5rem;">No meta description available</div>'}
              </td>
              <td style="padding: 0.75rem; text-align: right; color: #0f172a; font-weight: 500; vertical-align: top; white-space: nowrap;">${(row.clicks || 0).toLocaleString()}</td>
              <td style="padding: 0.75rem; text-align: right; color: #0f172a; font-weight: 500; vertical-align: top; white-space: nowrap;">${(row.impressions || 0).toLocaleString()}</td>
              <td style="padding: 0.75rem; text-align: right; color: ${ctrColor}; font-weight: 600; vertical-align: top; white-space: nowrap;">${ctrPct.toFixed(1)}%</td>
              <td style="padding: 0.75rem; text-align: right; color: ${posColor}; font-weight: 600; vertical-align: top; white-space: nowrap;">${row.avgPosition ? row.avgPosition.toFixed(1) : ''}</td>
              <td style="padding: 0.75rem; text-align: center; vertical-align: top;">
                ${(() => {
                  // Split categoryLabel into main part and bracketed part
                  const label = row.categoryLabel || '';
                  const bracketMatch = label.match(/^(.+?)\s*\((.+?)\)$/);
                  if (bracketMatch) {
                    const mainPart = bracketMatch[1].trim();
                    const bracketPart = bracketMatch[2].trim();
                    return `<span style="display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; background: ${categoryColor}20; color: ${categoryColor}; border: 1px solid ${categoryColor}40; line-height: 1.3;">
                      <div>${mainPart}</div>
                      <div style="font-size: 0.7rem; font-weight: 500; opacity: 0.9;">(${bracketPart})</div>
                    </span>`;
                  }
                  // If no brackets, just show the label
                  return `<span style="display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; background: ${categoryColor}20; color: ${categoryColor}; border: 1px solid ${categoryColor}40;">
                    ${label}
                  </span>`;
                })()}
              </td>
              <td style="padding: 0.75rem; vertical-align: top; width: 200px; min-width: 200px;">
                ${(() => {
                  const schemaTypes = row.schemaTypes || [];
                  if (schemaTypes.length === 0) {
                    return '<span style="color: #94a3b8; font-style: italic; font-size: 0.8rem;">None</span>';
                  }
                  // Ensure schemaTypes are strings (handle both string arrays and object arrays)
                  const typeStrings = schemaTypes.map(t => {
                    if (typeof t === 'string') return t;
                    if (typeof t === 'object' && t !== null) {
                      // Handle objects like {type: 'FAQPage', count: 5}
                      return t.type || String(t);
                    }
                    return String(t);
                  }).filter(Boolean);
                  
                  if (typeStrings.length === 0) {
                    return '<span style="color: #94a3b8; font-style: italic; font-size: 0.8rem;">None</span>';
                  }
                  
                  // Show first 5 types, then "+X more" if there are more
                  const displayTypes = typeStrings.slice(0, 5);
                  const remaining = typeStrings.length - 5;
                  const typesText = displayTypes.join(', ');
                  const moreText = remaining > 0 ? ` <span style="color: #64748b; font-size: 0.75rem;">+${remaining} more</span>` : '';
                  return `<span style="color: #475569; font-size: 0.8rem; line-height: 1.4;" title="${typeStrings.join(', ')}">${typesText}${moreText}</span>`;
                })()}
              </td>
              <td style="padding: 0.75rem; color: #475569; font-size: 0.8rem; line-height: 1.5; vertical-align: top;">${row.recommendation}</td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        // Pagination controls and total count (using filtered data)
        tableHtml += `
          <div style="margin-top: 1rem; display: flex; justify-content: space-between; align-items: center; padding-top: 1rem; border-top: 1px solid #e2e8f0; flex-wrap: wrap; gap: 1rem;">
            <div style="font-size: 0.85rem; color: #64748b;">
              ${filteredTotalPages > 1 ? `Page ${currentPage} of ${filteredTotalPages}  ` : ''}Total URLs: ${filteredRows.length}${filteredRows.length !== sortedRows.length ? ` (filtered from ${sortedRows.length})` : ''}
            </div>
            <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
              <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                Rows per page:
                <select id="money-pages-rows-per-page" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; background: white; cursor: pointer;">
                  <option value="10" ${rowsPerPage === 10 ? 'selected' : ''}>10</option>
                  <option value="25" ${rowsPerPage === 25 ? 'selected' : ''}>25</option>
                  <option value="50" ${rowsPerPage === 50 ? 'selected' : ''}>50</option>
                  <option value="100" ${rowsPerPage === 100 ? 'selected' : ''}>100</option>
                  <option value="200" ${rowsPerPage === 200 ? 'selected' : ''}>200</option>
                </select>
              </label>
              ${filteredTotalPages > 1 ? `
              <button id="money-pages-prev" type="button" ${currentPage === 1 ? 'disabled' : ''} style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cbd5e1; background: ${currentPage === 1 ? '#f1f5f9' : 'white'}; cursor: ${currentPage === 1 ? 'not-allowed' : 'pointer'}; color: ${currentPage === 1 ? '#94a3b8' : '#475569'}; font-weight: 600; transition: all 0.2s;" ${currentPage === 1 ? '' : 'onmouseover="this.style.background=\'#f8f9fa\'; this.style.borderColor=\'#94a3b8\';" onmouseout="this.style.background=\'white\'; this.style.borderColor=\'#cbd5e1\';"'}>
                Previous
              </button>
              <button id="money-pages-next" type="button" ${currentPage === filteredTotalPages ? 'disabled' : ''} style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cbd5e1; background: ${currentPage === filteredTotalPages ? '#f1f5f9' : 'white'}; cursor: ${currentPage === filteredTotalPages ? 'not-allowed' : 'pointer'}; color: ${currentPage === filteredTotalPages ? '#94a3b8' : '#475569'}; font-weight: 600; transition: all 0.2s;" ${currentPage === filteredTotalPages ? '' : 'onmouseover="this.style.background=\'#f8f9fa\'; this.style.borderColor=\'#94a3b8\';" onmouseout="this.style.background=\'white\'; this.style.borderColor=\'#cbd5e1\';"'}>
                Next
              </button>
              ` : ''}
            </div>
          </div>
        `;
        
        return tableHtml;
        } catch (error) {
          debugLog(`Error in renderMoneyPagesTable: ${error.message}`, 'error');
          return '<div style="font-size: 0.85rem; color: #ef4444; padding: 1rem; text-align: center; border: 1px solid #fecaca; border-radius: 4px; background: #fef2f2;">Error rendering table. Please refresh the page.</div>';
        }
      }
      
      // Get filtered money pages metrics based on current filter state
      function getFilteredMoneyPagesMetrics(moneyPagesMetrics) {
        if (!moneyPagesMetrics || !moneyPagesMetrics.rows) {
          return null;
        }
        
        // Get current filter state from global variables
        const subSegmentFilter = window.moneyPagesSubSegmentFilter || 'ALL';
        
        // Filter rows by sub-segment
        let filteredRows = moneyPagesMetrics.rows || [];
        if (subSegmentFilter !== 'ALL') {
          // Map filter values to segment types
          const segmentMap = {
            'PRODUCT': 'product',
            'EVENT': 'event',
            'LANDING': 'landing'
          };
          const targetSegment = segmentMap[subSegmentFilter];
          if (targetSegment) {
            filteredRows = filteredRows.filter(row => {
              // Check subSegment field first, then fallback to segmentType
              const rowSegment = row.subSegment || row.segmentType || 'all';
              return rowSegment.toLowerCase() === targetSegment.toLowerCase();
            });
          }
        }
        
        // Recalculate overview from filtered rows
        const filteredClicks = filteredRows.reduce((sum, r) => sum + (r.clicks || 0), 0);
        const filteredImpressions = filteredRows.reduce((sum, r) => sum + (r.impressions || 0), 0);
        const filteredCtr = filteredImpressions > 0 ? filteredClicks / filteredImpressions : 0;
        const filteredAvgPosition = filteredRows.length > 0
          ? filteredRows.reduce((sum, r) => sum + (r.avgPosition || 0), 0) / filteredRows.length
          : 0;
        
        // Recalculate summaryByCategory from filtered rows
        const filteredSummaryByCategory = {
          HIGH_OPPORTUNITY: { count: 0, impressions: 0, clicks: 0 },
          VISIBILITY_FIX: { count: 0, impressions: 0, clicks: 0 },
          MAINTAIN: { count: 0, impressions: 0, clicks: 0 }
        };
        
        filteredRows.forEach(row => {
          const category = row.category || 'MAINTAIN';
          if (filteredSummaryByCategory[category]) {
            filteredSummaryByCategory[category].count++;
            filteredSummaryByCategory[category].impressions += (row.impressions || 0);
            filteredSummaryByCategory[category].clicks += (row.clicks || 0);
          }
        });
        
        // Build filtered overview
        const originalOverview = moneyPagesMetrics.overview || {};
        const filteredOverview = {
          ...originalOverview,
          moneyClicks: filteredClicks,
          moneyImpressions: filteredImpressions,
          moneyCtr: filteredCtr,
          moneyAvgPosition: filteredAvgPosition,
          moneyCoverageCount: filteredRows.length,
          siteTotalClicks: originalOverview.siteTotalClicks || 0,
          siteTotalImpressions: originalOverview.siteTotalImpressions || 0,
          siteCtr: originalOverview.siteCtr || 0,
          siteAvgPosition: originalOverview.siteAvgPosition || 0
        };
        
        return {
          rows: filteredRows,
          overview: filteredOverview,
          summaryByCategory: filteredSummaryByCategory
        };
      }
      
      // Make function globally available
      window.getFilteredMoneyPagesMetrics = getFilteredMoneyPagesMetrics;
      
      // Update summary metrics with sub-segment filtering
      function updateMoneyPagesSummaryMetrics(moneyPagesMetrics) {
        if (!moneyPagesMetrics) return;
        
        // Use the new function that applies all filters
        const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
        if (!filteredMetrics) return;
        
        const { overview } = filteredMetrics;
        const summaryClickEl = document.getElementById('money-summary-click-share');
        const summaryCtrEl = document.getElementById('money-summary-ctr');
        const summaryPosEl = document.getElementById('money-summary-position');
        const summaryCovEl = document.getElementById('money-summary-coverage');
        
        if (!overview || !summaryClickEl || !summaryCtrEl || !summaryPosEl || !summaryCovEl) {
          return;
        }
        
        const moneyClicks = overview.moneyClicks || 0;
        const moneyImpressions = overview.moneyImpressions || 0;
        const siteClicks = overview.siteTotalClicks || 0;
        const siteImpressions = overview.siteTotalImpressions || 0;
        
        // Summary metrics
        const clickSharePct = siteClicks && siteClicks > 0 ? (moneyClicks / siteClicks) * 100 : null;
        const moneyCtrPct = (overview.moneyCtr || 0) * 100;
        const siteCtrPct = (overview.siteCtr || 0) * 100;
        const moneyPos = overview.moneyAvgPosition;
        const sitePos = overview.siteAvgPosition;
        const coverageCount = overview.moneyCoverageCount || 0;
        
        // Helper for RAG label class
        function labelClass(score) {
          if (score == null) return 'pill pill-muted';
          if (score >= 70) return 'pill pill-success';
          if (score >= 40) return 'pill pill-warning';
          return 'pill pill-danger';
        }
        
        // Update cards
        summaryClickEl.innerHTML =
          `<div class="metric-label">Share of site clicks</div>
           <div class="metric-value">
             ${clickSharePct != null ? clickSharePct.toFixed(1) + '%' : ''}
           </div>
           <div class="metric-sub">
             Money pages clicks: ${moneyClicks.toLocaleString()}
             ${siteClicks ? ` of ${siteClicks.toLocaleString()} total` : ''}
           </div>`;
        
        let ctrScore = null;
        if (siteCtrPct > 0) {
          ctrScore = moneyCtrPct >= siteCtrPct ? 75 : 30;
        }
        summaryCtrEl.innerHTML =
          `<div class="metric-label">CTR vs site</div>
           <div class="metric-value">
             ${moneyCtrPct.toFixed(2)}%
             <span class="metric-sub">vs ${siteCtrPct.toFixed(1)}% site</span>
           </div>`;
        summaryCtrEl.className = 'metric-card ' + labelClass(ctrScore);
        
        let posScore = null;
        if (moneyPos && sitePos) {
          posScore = moneyPos <= sitePos ? 70 : 30;
        }
        summaryPosEl.innerHTML =
          `<div class="metric-label">Average position</div>
           <div class="metric-value">
             ${moneyPos ? moneyPos.toFixed(1) : ''}
             <span class="metric-sub">vs ${sitePos ? sitePos.toFixed(1) : ''} site</span>
           </div>`;
        summaryPosEl.className = 'metric-card ' + labelClass(posScore);
        
        summaryCovEl.innerHTML =
          `<div class="metric-label">Money pages with impressions</div>
           <div class="metric-value">
             ${coverageCount}
           </div>
           <div class="metric-sub">
             Based on GSC pages only
           </div>`;
      }
      
      // Update sub-segment dropdown counts
      function updateMoneyPagesSubSegmentCounts(moneyPagesMetrics) {
        if (!moneyPagesMetrics || !moneyPagesMetrics.rows) return;
        
        const rows = moneyPagesMetrics.rows || [];
        
        // Count by sub-segment
        const counts = {
          ALL: rows.length,
          PRODUCT: 0,
          EVENT: 0,
          LANDING: 0
        };
        
        rows.forEach(row => {
          const subSegment = row.subSegment || row.segmentType || 'LANDING';
          if (subSegment === 'PRODUCT' || subSegment === 'product') {
            counts.PRODUCT++;
          } else if (subSegment === 'EVENT' || subSegment === 'event') {
            counts.EVENT++;
          } else if (subSegment === 'LANDING' || subSegment === 'landing') {
            counts.LANDING++;
          }
        });
        
        // Update dropdown options with counts
        const allOption = document.getElementById('money-subsegment-all');
        const productOption = document.getElementById('money-subsegment-product');
        const eventOption = document.getElementById('money-subsegment-event');
        const landingOption = document.getElementById('money-subsegment-landing');
        
        if (allOption) allOption.textContent = `All sub-segments (${counts.ALL})`;
        if (productOption) productOption.textContent = `Product Pages (${counts.PRODUCT})`;
        if (eventOption) eventOption.textContent = `Event Pages (${counts.EVENT})`;
        if (landingOption) landingOption.textContent = `Landing Pages (${counts.LANDING})`;
      }
      
      // Update type filter dropdown counts (for Priority & Actions)
      function updateMoneyPagesTypeFilterCounts(sourcePages) {
        if (!sourcePages || !Array.isArray(sourcePages)) return;
        
        // Count by segment type
        const counts = {
          all: sourcePages.length,
          authority: 0,
          landing: 0,
          event: 0,
          product: 0
        };
        
        sourcePages.forEach(page => {
          const segmentType = page.segmentType || 'landing';
          if (segmentType === 'authority') {
            counts.authority++;
          } else if (segmentType === 'landing') {
            counts.landing++;
          } else if (segmentType === 'event') {
            counts.event++;
          } else if (segmentType === 'product') {
            counts.product++;
          }
        });
        
        // Update dropdown options with counts
        const typeFilterEl = document.getElementById('money-pages-type-filter');
        if (typeFilterEl) {
          const options = typeFilterEl.querySelectorAll('option');
          options.forEach(opt => {
            const value = opt.value;
            if (value === 'all') {
              opt.textContent = `All money pages (${counts.all})`;
            } else if (value === 'authority') {
              opt.textContent = `Authority (${counts.authority})`;
            } else if (value === 'landing') {
              opt.textContent = `Landing pages (${counts.landing})`;
            } else if (value === 'event') {
              opt.textContent = `Event pages (${counts.event})`;
            } else if (value === 'product') {
              opt.textContent = `Product pages (${counts.product})`;
            }
          });
        }
      }
      
      // Function to render Money Pages Performance section
      function renderMoneyPagesSection(moneyPagesMetrics) {
        // Get or create the Money Pages panel
        const moneyPanel = document.querySelector('.aigeo-panel[data-panel="money"]');
        if (!moneyPanel) {
          debugLog(' Money Pages panel not found', 'warn');
          return;
        }
        
        // Get or create the money-pages-section element
        let section = document.getElementById('money-pages-section');
        if (!section) {
          debugLog(' Money Pages section element not found, creating it...', 'warn');
          // Create the Money Pages HTML structure if it doesn't exist
          section = document.createElement('div');
          section.id = 'money-pages-section';
          section.style.display = 'block';
          moneyPanel.appendChild(section);
        }
        
        // Check if full structure already exists (created by displayDashboard)
        const existingHeader = section.querySelector('h3[style*="color: var(--brand-dark)"]');
        if (existingHeader && existingHeader.textContent.includes('Money Pages Performance & Actions')) {
          debugLog(' Money Pages full structure already exists, skipping HTML recreation', 'info');
          // Don't overwrite - just ensure section is visible
          section.style.display = 'block';
        } else {
          // Always update the HTML structure to ensure it has the latest canvas IDs
          // Create the full Money Pages HTML structure with all sections
          section.innerHTML = `
          <div style="padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); background: rgba(204, 255, 229, 0.3); border-left: 4px solid #10b981;">
            <h3 style="margin: 0 0 1rem 0; color: var(--brand-dark);">Money Pages Performance & Actions</h3>
            <p style="margin: 0 0 1.5rem 0; font-size: 0.9rem; color: #666; line-height: 1.6;">
              Focused view of your money pages: how much traffic they capture,
              how they convert clicks, and which URLs to improve first.
              This section uses 30-day Google Search Console data and historical audits to show how your commercial pages perform over time and how much they contribute to your overall Authority behaviour score.
            </p>
            
            <!-- Top-level filter for Performance Metrics, Behaviour, and Opportunity Mix -->
            <div style="display: flex; justify-content: flex-start; align-items: center; margin-bottom: 1.5rem; padding: 1rem 1.25rem; background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%); border-radius: 8px; border: 2px solid #0ea5e9; box-shadow: 0 2px 4px rgba(14, 165, 233, 0.2);">
              <label style="display: flex; align-items: center; gap: 0.75rem; font-size: 0.95rem; color: #0c4a6e; font-weight: 700;" title="Filter Performance Metrics, Behaviour, and Opportunity Mix by sub-segment type">
                <span style="font-weight: 700;">Sub-segment Filter:</span>
                <select id="money-top-level-filter-subsegment" style="padding: 0.6rem 1rem; border: 2px solid #0ea5e9; border-radius: 6px; font-size: 0.95rem; background: white; cursor: pointer; font-weight: 600; color: #0c4a6e; min-width: 150px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);" title="Filter money pages by sub-segment type. Landing pages are collection/category pages, Event pages are workshop/event listings, Product pages are service/product offerings. This filter controls Performance Metrics, Behaviour, and Opportunity Mix sections.">
                  <option value="ALL">All</option>
                  <option value="PRODUCT">Product</option>
                  <option value="EVENT">Event</option>
                  <option value="LANDING">Landing</option>
                </select>
              </label>
            </div>
            
            <!-- Performance Metrics -->
            <div style="margin-bottom: 1.5rem;">
              <h4 style="margin: 0 0 1rem 0; font-size: 0.95rem; font-weight: 600; color: #1e293b;">Performance Metrics</h4>
            </div>
            <div id="money-pages-summary" class="metrics-row" style="display: flex; gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap;">
              <div class="metric-card" id="money-summary-click-share" style="flex: 1; min-width: 200px; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
              <div class="metric-card" id="money-summary-ctr" style="flex: 1; min-width: 200px; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
              <div class="metric-card" id="money-summary-position" style="flex: 1; min-width: 200px; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
              <div class="metric-card" id="money-summary-coverage" style="flex: 1; min-width: 200px; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
            </div>
            
            <!-- Explanation text -->
            <div style="margin-bottom: 1.5rem; padding: 1rem; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #64748b; font-size: 0.85rem; line-height: 1.6; color: #475569;">
              <p style="margin: 0 0 0.5rem 0;"><strong>Note:</strong> These metrics include <strong>all money pages</strong> regardless of ranking position (positions 1-20 and beyond). This provides a complete view of your money page performance, including pages that need improvement.</p>
              <p style="margin: 0;"><strong>Difference from Segment Overview:</strong> The "Segment overview (CTR & ranking)" table above shows metrics for money pages ranking in <strong>positions 1-20 only</strong> (used for Authority scoring). The Money Pages Performance section shows <strong>all money pages</strong> to help identify opportunities across your entire money page portfolio.</p>
            </div>
            
            <!-- Money Pages Behaviour KPIs -->
            <div style="margin-bottom: 1rem;">
              <h3 style="margin: 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Money Pages Behaviour</h3>
            </div>
            <div class="money-behaviour-kpis" id="money-behaviour-kpis" style="display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 1.5rem;">
              <div class="kpi-card" id="money-behaviour-card" style="flex: 1 1 180px; background: #fff; border-radius: 6px; padding: 8px 12px; box-shadow: 0 0 0 1px rgba(0,0,0,0.04);">
                <div class="kpi-label" style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">Money pages behaviour</div>
                <div class="kpi-value" id="money-behaviour-score" style="font-size: 1.5rem; font-weight: 700; color: #1e293b;"></div>
                <div class="kpi-sub" id="money-behaviour-status" style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;">CTR and ranking for money pages only.</div>
              </div>
              <div class="kpi-card" style="flex: 1 1 180px; background: #fff; border-radius: 6px; padding: 8px 12px; box-shadow: 0 0 0 1px rgba(0,0,0,0.04);">
                <div class="kpi-label" style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">CTR (ranking queries)</div>
                <div class="kpi-value" id="money-ctr-value" style="font-size: 1.5rem; font-weight: 700; color: #1e293b;"></div>
                <div class="kpi-sub" style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;">Target 2.5%</div>
              </div>
              <div class="kpi-card" style="flex: 1 1 180px; background: #fff; border-radius: 6px; padding: 8px 12px; box-shadow: 0 0 0 1px rgba(0,0,0,0.04);">
                <div class="kpi-label" style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">Top-10 CTR</div>
                <div class="kpi-value" id="money-top10-ctr-value" style="font-size: 1.5rem; font-weight: 700; color: #1e293b;"></div>
                <div class="kpi-sub" style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;">Target 4.0%</div>
              </div>
            </div>
            <p class="chart-subtitle" style="margin: 0 0 1.5rem 0; font-size: 0.85rem; color: #64748b; padding: 0 0.5rem;">
              Behaviour score here is calculated the same way as <strong>Authority  Behaviour</strong>,
              but only for money pages. Improvements you make on these URLs will move both this score
              and the Authority pillar.
            </p>
            
            <!-- Chart row (Phase 2) -->
            <div class="chart-row" id="money-pages-chart-row" style="margin-bottom: 1.5rem; display: block; visibility: visible;">
              <div class="chart-card" style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: flex; gap: 1.5rem; align-items: flex-start;">
                <div style="flex: 1;">
                  <div style="margin-bottom: 0.5rem;">
                  <h3 id="money-pages-chart-title" style="margin: 0 0 0.5rem 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Money Pages Opportunity Mix</h3>
                  <p class="chart-subtitle" style="margin: 0 0 1rem 0; font-size: 0.85rem; color: #64748b;">
                    How your money pages are distributed across improvement categories in this audit window.
                  </p>
                  </div>
                  <div style="position: relative; width: 500px; height: 300px; margin: 0 auto; overflow: hidden;">
                    <canvas id="money-pages-category-chart" width="500" height="300" style="display: block; max-width: 500px; max-height: 300px;"></canvas>
                  </div>
                  <div id="money-pages-category-summary" class="chart-summary" style="margin-top: 8px; font-size: 0.9rem; color: #1e293b; font-weight: 500; text-align: center;"></div>
                  <div id="money-pages-category-breakdown" class="chart-breakdown-row" style="margin-top: 4px; display: flex; flex-wrap: wrap; gap: 0.5rem; font-size: 0.85rem; justify-content: center;"></div>
                </div>
                <div id="money-pages-chart-summary-box" style="flex: 0 0 320px; background: #f8fafc; padding: 1.5rem; border-radius: 8px; border: 1px solid #e2e8f0; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                  <h4 style="margin: 0 0 1rem 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Filtered Summary</h4>
                  <div style="display: flex; flex-direction: column; gap: 0.75rem; font-size: 0.9rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span style="color: #64748b; font-size: 0.9rem;">Pages:</span>
                      <span id="summary-pages-count" style="font-weight: 700; color: #1e293b; font-size: 1rem;">-</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span style="color: #64748b; font-size: 0.9rem;">Impressions:</span>
                      <span id="summary-impressions" style="font-weight: 700; color: #1e293b; font-size: 1rem;">-</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span style="color: #64748b; font-size: 0.9rem;">Clicks:</span>
                      <span id="summary-clicks" style="font-weight: 700; color: #1e293b; font-size: 1rem;">-</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span style="color: #64748b; font-size: 0.9rem;">CTR:</span>
                      <span id="summary-ctr" style="font-weight: 700; font-size: 1rem;">-</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0.5rem; padding-top: 0.75rem; border-top: 2px solid #e2e8f0;">
                      <span style="color: #64748b; font-size: 0.9rem;">Behaviour Score:</span>
                      <span id="summary-behaviour" style="font-weight: 700; font-size: 1.1rem;">-</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Table container (will be populated by renderMoneyPagesTable) -->
            <div id="money-pages-table-container">
              <!-- Table will be rendered here -->
            </div>
            
            <!-- Phase 3: Money Pages Trend Chart -->
            <section id="money-pages-trend" class="card card--full" style="margin-top: 2rem; background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div class="card-header" style="margin-bottom: 1rem;">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Money Pages Performance Trends (last 28 days)</h3>
                <p class="card-subtitle" style="margin: 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
                  Weekly trends calculated from actual Google Search Console data for the last 28 days. Shows money pages clicks, impressions, CTR, and behaviour score over time.
                </p>
              </div>
              <div class="card-body" style="min-height: 300px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                  <div>
                    <h4 style="font-size: 0.95rem; font-weight: 600; color: #1e293b; margin-bottom: 0.5rem;">Volume Metrics</h4>
                    <div style="position: relative; height: 300px;">
                      <canvas id="moneyPagesVolumeChart"></canvas>
                    </div>
                  </div>
                  <div>
                    <h4 style="font-size: 0.95rem; font-weight: 600; color: #1e293b; margin-bottom: 0.5rem;">Rate & Score Metrics</h4>
                    <div style="position: relative; height: 300px;">
                      <canvas id="moneyPagesRateChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              <div class="card-footer small" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e2e8f0; font-size: 0.85rem; color: #64748b;">
                Data calculated from Google Search Console timeseries for the last 28 days, displayed as 8 weekly data points. Metrics are calculated using money page proportions from the latest audit.
              </div>
            </section>
            
            <!-- Phase: 12-Month KPI Tracker -->
            <section id="money-pages-kpi-card" class="card card--full" style="margin-top: 2rem; background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div class="card-header" style="margin-bottom: 1rem;">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Money Pages KPI Tracker (last 28 days)</h3>
                <p class="card-subtitle" style="margin: 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
                  Weekly KPI trends by money-page segment (All, Landing, Event, Product) calculated from actual Google Search Console data for the last 28 days.
                </p>
              </div>

              <div class="controls-row" style="margin-bottom: 1.5rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem;" title="Select which metric to display in the KPI tracker chart and table. CTR shows click-through rate, Impressions shows search visibility, Clicks shows actual traffic, and Avg position shows average ranking.">
                  Metric:
                  <select id="money-kpi-metric-select" style="padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px;" title="Select which metric to display in the KPI tracker chart and table. CTR shows click-through rate, Impressions shows search visibility, Clicks shows actual traffic, and Avg position shows average ranking.">
                    <option value="ctr">CTR</option>
                    <option value="impressions">Impressions</option>
                    <option value="clicks">Clicks</option>
                    <option value="avgPosition">Avg position</option>
                  </select>
                </label>
              </div>

              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                <div class="sparkline-wrapper" style="height: 400px; width: 100%;">
                  <canvas id="money-kpi-sparkline" style="width: 100% !important;"></canvas>
                </div>

                <div class="table-wrapper" style="overflow-x: auto; max-width: 100%; width: 100%;">
                  <table id="money-kpi-table" style="width: max-content; min-width: 100%; border-collapse: collapse; table-layout: fixed;">
                    <thead>
                      <tr id="money-kpi-header-row" style="background: #f1f5f9;">
                        <!-- Filled by JS -->
                      </tr>
                    </thead>
                    <tbody>
                      <!-- JS rows -->
                    </tbody>
                  </table>
                </div>
              </div>
            </section>
            
            <!-- Phase: Money Pages Priority Matrix + Action List -->
            <section id="money-pages-priority-card" class="card card--full" style="margin-top: 2rem; background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div class="card-header" style="margin-bottom: 1rem;">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Money Pages  Priority & Actions</h3>
                <p class="card-subtitle" style="margin: 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
                  Landing, event and product pages that drive revenue. Triaged by impact, difficulty and priority.
                </p>
              </div>

              <!-- Summary strip -->
              <div class="summary-strip" id="money-pages-summary-strip" style="display: flex; gap: 2rem; padding: 1rem; background: #f8fafc; border-radius: 4px; margin-bottom: 1.5rem;">
                <!-- Filled by JS -->
              </div>

              <!-- Controls -->
              <div class="controls-row" style="display: flex; gap: 1.5rem; margin-bottom: 1.5rem; align-items: center;">
                <label style="display: flex; align-items: center; gap: 0.5rem;" title="Filter money pages by segment type. Landing pages are collection/category pages, Event pages are workshop/event listings, Product pages are service/product offerings.">
                  Page type:
                  <select id="money-pages-type-filter" style="padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px;" title="Filter money pages by segment type. Landing pages are collection/category pages, Event pages are workshop/event listings, Product pages are service/product offerings.">
                    <option value="all" id="money-pages-type-all">All money pages</option>
                    <option value="authority" id="money-pages-type-authority">Authority</option>
                    <option value="landing" id="money-pages-type-landing">Landing pages</option>
                    <option value="event" id="money-pages-type-event">Event pages</option>
                    <option value="product" id="money-pages-type-product">Product pages</option>
                  </select>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem;" title="Filter out pages with fewer impressions than this threshold. Helps focus on pages with meaningful search visibility.">
                  Min impressions:
                  <input type="number" id="money-pages-min-impr" value="10" min="0" step="10" style="padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px; width: 120px;" title="Filter out pages with fewer impressions than this threshold. Helps focus on pages with meaningful search visibility.">
                </label>
              </div>

              <div class="matrix-and-table" style="display: grid; grid-template-columns: 1fr 2fr; gap: 2rem;">
                <div class="priority-matrix" id="money-pages-matrix" style="background: #f8fafc; padding: 1rem; border-radius: 8px;">
                  <!-- 3x3 grid rendered by JS -->
                </div>

                <div class="priority-table-wrapper" style="overflow-x: auto;">
                  <table id="money-pages-priority-table" style="width: 100%; border-collapse: collapse;">
                    <thead>
                      <tr style="background: #f1f5f9;">
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="The URL of the money page. Click to open in a new tab.">Page</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Segment type: Landing (collection/category pages), Event (workshop/event listings), or Product (service/product offerings).">Type</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Priority level (HIGH/MEDIUM/LOW) based on impact and difficulty. HIGH priority = high impact + low/medium difficulty. Click column header to sort.">Priority</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Impact level based on lost clicks (expected CTR minus actual CTR). HIGH = significant opportunity to improve clicks. Click column header to sort.">Impact</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Difficulty level based on current ranking position and schema effort required. LOW = easy to improve, HIGH = requires more work. Click column header to sort.">Difficulty</th>
                        <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;" title="Click-through rate: percentage of impressions that resulted in clicks. Higher is better. Click column header to sort.">CTR</th>
                        <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;" title="Total impressions: number of times this page appeared in search results. Click column header to sort.">Impr.</th>
                        <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;" title="Average position: average ranking position in search results (1 = best, lower numbers are better). Click column header to sort.">Avg pos.</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Recommended action based on priority level. HIGH = Fix CTR & strengthen content, MEDIUM = Improve SERP snippet & schema, LOW = Monitor & maintain.">Action</th>
                      </tr>
                    </thead>
                    <tbody>
                      <!-- JS rows -->
                    </tbody>
                  </table>
                  <div id="money-pages-priority-pagination"></div>
                  <button id="money-pages-copy-urls-btn" type="button" class="btn btn-small" style="margin-top: 1rem;" title="Copy all filtered page URLs to clipboard. URLs are copied one per line, ready to paste into spreadsheets or other tools.">Copy URLs</button>
                </div>
              </div>
            </section>
            
            <p class="card-footnote" style="margin-top: 1rem; font-size: 0.85rem; color: #666;">
              Based on the current audit date range and money-page segment only.
              Categories and actions are data-driven and will update each time you run a new audit.
            </p>
          </div>
        `;
        }
          
        debugLog(' Money Pages section HTML structure created/updated', 'success');
        
        // Always show section, even if no data (will show "No data" message)
        section.style.display = 'block';
        
        if (!moneyPagesMetrics) {
          debugLog(' Money Pages Metrics: No data provided', 'warn');
          // Show "No data" message in table and summary cards
          const tableContainer = document.getElementById('money-pages-table-container');
          if (tableContainer) {
            tableContainer.innerHTML = '<div style="font-size: 0.85rem; color: #999; padding: 2rem; text-align: center;">No money-page data available. Run an audit with GSC data to see money pages performance.</div>';
          }
          // Populate summary cards with ""
          const summaryClickEl = document.getElementById('money-summary-click-share');
          const summaryCtrEl = document.getElementById('money-summary-ctr');
          const summaryPosEl = document.getElementById('money-summary-position');
          const summaryCovEl = document.getElementById('money-summary-coverage');
          if (summaryClickEl) summaryClickEl.innerHTML = `<div class="metric-label">Share of site clicks</div><div class="metric-value"></div><div class="metric-sub">No data</div>`;
          if (summaryCtrEl) summaryCtrEl.innerHTML = `<div class="metric-label">CTR vs site</div><div class="metric-value"></div><div class="metric-sub">No data</div>`;
          if (summaryPosEl) summaryPosEl.innerHTML = `<div class="metric-label">Average position</div><div class="metric-value"></div><div class="metric-sub">No data</div>`;
          if (summaryCovEl) summaryCovEl.innerHTML = `<div class="metric-label">Money pages with impressions</div><div class="metric-value">0</div><div class="metric-sub">No data</div>`;
          return;
        }
        
        const { rows } = moneyPagesMetrics;
        const tableContainer = document.getElementById('money-pages-table-container');
        
        if (!tableContainer) {
          return;
        }
        
        // Store data globally for sorting/pagination
        // Ensure we're using the most up-to-date metrics
        window.currentMoneyPagesMetrics = moneyPagesMetrics || window.currentMoneyPagesMetrics;
        
        // Initialize pagination state if not set
        if (window.moneyPagesCurrentPage === undefined) {
          window.moneyPagesCurrentPage = 1;
        }
        if (window.moneyPagesRowsPerPage === undefined) {
          window.moneyPagesRowsPerPage = 10;
        }
        
        // Store full rows array for filtering
        window.moneyPagesAllRows = rows;
        
        // Initialize filter state if not set
        if (window.moneyPagesCategoryFilter === undefined) {
          window.moneyPagesCategoryFilter = 'ALL';
        }
        if (window.moneyPagesSubSegmentFilter === undefined) {
          window.moneyPagesSubSegmentFilter = 'ALL';
        }
        
        // Update summary metrics with current filters
        updateMoneyPagesSummaryMetrics(moneyPagesMetrics);
        if (window.moneyPagesMinImpressions === undefined) {
          window.moneyPagesMinImpressions = 0;
        }
        
        // Update sub-segment dropdown counts
        updateMoneyPagesSubSegmentCounts(moneyPagesMetrics);
        
        // Function to apply filters and re-render ALL sections (table, chart, KPIs, summaries)
        const applyFiltersAndRender = () => {
          const moneyPagesMetrics = window.currentMoneyPagesMetrics;
          const queryPages = window.currentQueryPages || null;
          
          if (!moneyPagesMetrics) return;
          
          // Get filtered metrics based on current filters FIRST
          const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
          if (!filteredMetrics) return;
          
          const filteredRows = filteredMetrics.rows || [];
          
          // Update table with FILTERED rows
          const currentPage = window.moneyPagesCurrentPage || 1;
          const rowsPerPage = window.moneyPagesRowsPerPage || 10;
          const tableHtml = renderMoneyPagesTable(filteredRows, currentPage, rowsPerPage);
          if (tableHtml && typeof tableHtml === 'string') {
            tableContainer.innerHTML = tableHtml;
          } else {
            debugLog(` renderMoneyPagesTable returned invalid value: ${typeof tableHtml}`, 'warn');
            tableContainer.innerHTML = '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">Error rendering table. Please refresh the page.</div>';
          }
          
          // Re-attach all handlers after re-render
          // Use filtered rows for pagination/copy, but use original rows for filter handlers
          // (filter handlers need the full dataset to filter from)
          attachMoneyPagesSortHandlers();
          attachMoneyPagesPaginationHandlers(filteredRows);
          attachMoneyPagesCopyHandler(filteredRows);
          attachMoneyPagesFilterHandlers(rows, applyFiltersAndRender);
          
          // Update all other sections with filtered data
          setTimeout(() => {
            // Update doughnut chart with filtered data
            renderMoneyPagesCategoryChart(moneyPagesMetrics, 0);
            
            // Recalculate behaviour for filtered pages
            debugLog(` Filter change: Recalculating behaviour for ${filteredRows.length} filtered rows`, 'info');
            debugLog(` Filter change: queryPages available: ${!!queryPages}, length: ${queryPages?.length || 0}`, 'info');
            
            const filteredBehaviour = window.computeMoneyPagesBehaviour ? 
              window.computeMoneyPagesBehaviour(queryPages, filteredRows, true) : null;
            
            debugLog(` Filter change: filteredBehaviour calculated: ${!!filteredBehaviour}, impressions: ${filteredBehaviour?.impressions || 0}`, 'info');
            
          // Update all sections
          renderMoneyPagesBehaviourKpis(filteredBehaviour, filteredMetrics, queryPages);
          updateMoneyPagesSummaryMetrics(moneyPagesMetrics); // Pass original metrics so function can apply filters internally
          updateMoneyPagesChartSummary(filteredMetrics);
          
          // Update dropdown counts after filtering (both table and top-level)
          updateMoneyPagesSubSegmentCounts(moneyPagesMetrics);
          }, 100);
        };
        
        // Initial render
        const currentPage = window.moneyPagesCurrentPage || 1;
        const rowsPerPage = window.moneyPagesRowsPerPage || 10;
        const tableHtml = renderMoneyPagesTable(rows, currentPage, rowsPerPage);
        if (tableHtml && typeof tableHtml === 'string') {
          tableContainer.innerHTML = tableHtml;
        } else {
          debugLog(` renderMoneyPagesTable returned invalid value: ${typeof tableHtml}`, 'warn');
          tableContainer.innerHTML = '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">Error rendering table. Please refresh the page.</div>';
        }
        
        // Attach sort handlers
        attachMoneyPagesSortHandlers();
        
        // Attach pagination handlers
        attachMoneyPagesPaginationHandlers(rows);
        
        // Attach copy button handler
        attachMoneyPagesCopyHandler(rows);
        
        // Attach filter handlers (Phase 2)
        attachMoneyPagesFilterHandlers(rows, applyFiltersAndRender);
        
        // Show section
        section.style.display = 'block';
      }
      
      // Attach sort handlers for Money Pages table
      function attachMoneyPagesSortHandlers() {
        setTimeout(() => {
          ['clicks', 'impressions', 'ctr', 'position', 'opportunity'].forEach(col => {
            const th = document.getElementById(`money-sort-${col}`);
            if (th) {
              const newTh = th.cloneNode(true);
              th.parentNode.replaceChild(newTh, th);
              newTh.addEventListener('click', () => {
                handleMoneyPagesSort(col);
              });
            }
          });
        }, 50);
      }
      
      // Handle sorting for Money Pages table
      function handleMoneyPagesSort(column) {
        if (window.moneyPagesSortColumn === column) {
          window.moneyPagesSortDirection = window.moneyPagesSortDirection === 'asc' ? 'desc' : 'asc';
        } else {
          window.moneyPagesSortColumn = column;
          window.moneyPagesSortDirection = 'desc';
        }
        
        // Reset to page 1 when sorting
        window.moneyPagesCurrentPage = 1;
        
        // Get current data from stored source
        const allRows = window.moneyPagesData || [];
        if (allRows.length > 0) {
          const tableContainer = document.getElementById('money-pages-table-container');
          if (tableContainer) {
            const rowsPerPage = window.moneyPagesRowsPerPage || 10;
            tableContainer.innerHTML = renderMoneyPagesTable(allRows, 1, rowsPerPage);
            attachMoneyPagesSortHandlers();
            attachMoneyPagesPaginationHandlers(allRows);
            attachMoneyPagesCopyHandler(allRows);
          }
        }
      }
      
      // Attach pagination handlers
      function attachMoneyPagesPaginationHandlers(allRows) {
        setTimeout(() => {
          const prevBtn = document.getElementById('money-pages-prev');
          const nextBtn = document.getElementById('money-pages-next');
          const rowsPerPageSelect = document.getElementById('money-pages-rows-per-page');
          
          // Use stored sorted data for pagination
          const sortedRows = window.moneyPagesData || allRows || [];
          const rowsPerPage = window.moneyPagesRowsPerPage || 10;
          
          // Handle rows-per-page change
          if (rowsPerPageSelect) {
            const newSelect = rowsPerPageSelect.cloneNode(true);
            rowsPerPageSelect.parentNode.replaceChild(newSelect, rowsPerPageSelect);
            newSelect.addEventListener('change', () => {
              const newRowsPerPage = parseInt(newSelect.value, 10);
              window.moneyPagesRowsPerPage = newRowsPerPage;
              window.moneyPagesCurrentPage = 1; // Reset to first page when changing rows per page
              const tableContainer = document.getElementById('money-pages-table-container');
              if (tableContainer) {
                tableContainer.innerHTML = renderMoneyPagesTable(sortedRows, 1, newRowsPerPage);
                attachMoneyPagesSortHandlers();
                attachMoneyPagesPaginationHandlers(sortedRows);
                attachMoneyPagesCopyHandler(sortedRows);
              }
            });
          }
          
          if (prevBtn) {
            const newPrevBtn = prevBtn.cloneNode(true);
            prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
            newPrevBtn.addEventListener('click', () => {
              if (window.moneyPagesCurrentPage > 1) {
                window.moneyPagesCurrentPage--;
                const tableContainer = document.getElementById('money-pages-table-container');
                if (tableContainer) {
                  const currentRowsPerPage = window.moneyPagesRowsPerPage || 10;
                  tableContainer.innerHTML = renderMoneyPagesTable(sortedRows, window.moneyPagesCurrentPage, currentRowsPerPage);
                  attachMoneyPagesSortHandlers();
                  attachMoneyPagesPaginationHandlers(sortedRows);
                  attachMoneyPagesCopyHandler(sortedRows);
                }
              }
            });
          }
          
          if (nextBtn) {
            const newNextBtn = nextBtn.cloneNode(true);
            nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
            newNextBtn.addEventListener('click', () => {
              const currentRowsPerPage = window.moneyPagesRowsPerPage || 10;
              const totalPages = Math.ceil(sortedRows.length / currentRowsPerPage);
              if (window.moneyPagesCurrentPage < totalPages) {
                window.moneyPagesCurrentPage++;
                const tableContainer = document.getElementById('money-pages-table-container');
                if (tableContainer) {
                  tableContainer.innerHTML = renderMoneyPagesTable(sortedRows, window.moneyPagesCurrentPage, currentRowsPerPage);
                  attachMoneyPagesSortHandlers();
                  attachMoneyPagesPaginationHandlers(sortedRows);
                  attachMoneyPagesCopyHandler(sortedRows);
                }
              }
            });
          }
        }, 50);
      }
      
      // Attach copy button handler
      function attachMoneyPagesCopyHandler(allRows) {
        setTimeout(() => {
          const copyBtn = document.getElementById('money-pages-copy-urls');
          if (copyBtn) {
            const newCopyBtn = copyBtn.cloneNode(true);
            copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
            newCopyBtn.addEventListener('click', async () => {
              const urls = (allRows || []).slice(0, 10).map((r) => r.url).join('\n');
              if (urls) {
                try {
                  await navigator.clipboard.writeText(urls);
                  newCopyBtn.textContent = 'Copied!';
                  newCopyBtn.style.color = '#10b981';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                    newCopyBtn.style.color = 'white';
                  }, 2000);
                } catch (err) {
                  newCopyBtn.textContent = 'Copy failed';
                  newCopyBtn.style.color = '#ef4444';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                    newCopyBtn.style.color = 'white';
                  }, 2000);
                }
              }
            });
          }
        }, 50);
      }
      
      // Attach filter handlers for Money Pages table (Phase 2)
      function attachMoneyPagesFilterHandlers(allRows, onFilterChange) {
        setTimeout(() => {
          const categoryFilterEl = document.getElementById('money-pages-filter-category');
          const subSegmentFilterEl = document.getElementById('money-pages-filter-subsegment');
          const minImpressionsEl = document.getElementById('money-pages-min-impressions');
          const copyBtn = document.getElementById('money-pages-copy-urls');
          const tableContainer = document.getElementById('money-pages-table-container');
          
          if (!categoryFilterEl || !subSegmentFilterEl || !minImpressionsEl || !tableContainer) return;
          
          // Get zero impressions checkbox
          const includeZeroEl = document.getElementById('money-pages-include-zero');
          
          // Function to apply filters and re-render
          const applyFilters = () => {
            // Re-read checkbox state from DOM (it might have changed)
            const currentIncludeZeroEl = document.getElementById('money-pages-include-zero');
            const filterCat = categoryFilterEl.value || 'ALL';
            const filterSubSeg = subSegmentFilterEl.value || 'ALL';
            const minImp = parseInt(minImpressionsEl.value, 10) || 0;
            const includeZero = currentIncludeZeroEl ? currentIncludeZeroEl.checked : (includeZeroEl ? includeZeroEl.checked : true);
            
            debugLog(` applyFilters: includeZero=${includeZero}, filterCat=${filterCat}, filterSubSeg=${filterSubSeg}, minImp=${minImp}`, 'info');
            
            // Store filter state globally
            window.moneyPagesCategoryFilter = filterCat;
            window.moneyPagesSubSegmentFilter = filterSubSeg;
            window.moneyPagesMinImpressions = minImp;
            window.moneyPagesIncludeZero = includeZero;
            
            // Reset to page 1 when filters change
            window.moneyPagesCurrentPage = 1;
            
            // Re-render everything with filters (table, chart, KPIs, summary)
            if (onFilterChange) {
              onFilterChange();
            } else {
              // Fallback: re-render directly with filtered data
              const moneyPagesMetrics = window.currentMoneyPagesMetrics;
              const queryPages = window.currentQueryPages || null;
              
              if (!moneyPagesMetrics) return;
              
              // Get filtered metrics FIRST
              const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
              if (!filteredMetrics) return;
              
              const filteredRows = filteredMetrics.rows || [];
              
              // Update table with FILTERED rows
              const currentPage = 1;
              const rowsPerPage = window.moneyPagesRowsPerPage || 10;
              tableContainer.innerHTML = renderMoneyPagesTable(filteredRows, currentPage, rowsPerPage);
              attachMoneyPagesSortHandlers();
              attachMoneyPagesPaginationHandlers(filteredRows);
              attachMoneyPagesCopyHandler(filteredRows);
              // Use original allRows for filter handlers (they need full dataset to filter from)
              // Get original rows from moneyPagesMetrics
              const originalRows = moneyPagesMetrics?.rows || allRows;
              attachMoneyPagesFilterHandlers(originalRows, onFilterChange);
              
              // Re-render chart and KPIs with filters
              setTimeout(() => {
                // Get queryPages from global storage
                const queryPages = window.currentQueryPages || null;
                
                debugLog(` Fallback filter change: Recalculating behaviour for ${filteredRows.length} filtered rows`, 'info');
                debugLog(` Fallback filter change: queryPages available: ${!!queryPages}, length: ${queryPages?.length || 0}`, 'info');
                
                // Update doughnut chart with filtered data
                renderMoneyPagesCategoryChart(moneyPagesMetrics, 0);
                
                // Recalculate behaviour for filtered pages (use all positions for filtered calculations)
                const filteredBehaviour = window.computeMoneyPagesBehaviour ? 
                  window.computeMoneyPagesBehaviour(queryPages, filteredRows, true) : null;
                
                debugLog(` Fallback filter change: filteredBehaviour calculated: ${!!filteredBehaviour}, impressions: ${filteredBehaviour?.impressions || 0}`, 'info');
                
                // Update all sections
                renderMoneyPagesBehaviourKpis(filteredBehaviour, filteredMetrics, queryPages);
                updateMoneyPagesSummaryMetrics(moneyPagesMetrics); // Pass original metrics so function can apply filters internally
                updateMoneyPagesChartSummary(filteredMetrics);
                
                // Update dropdown counts after filtering
                updateMoneyPagesSubSegmentCounts(moneyPagesMetrics);
              }, 100);
            }
          };
          
          // Attach filter change handlers
          categoryFilterEl.addEventListener('change', applyFilters);
          subSegmentFilterEl.addEventListener('change', applyFilters);
          minImpressionsEl.addEventListener('change', applyFilters);
          if (includeZeroEl) {
            includeZeroEl.addEventListener('change', applyFilters);
          }
          
          // When table filter changes, update top-level filter (if user changes table filter directly)
          subSegmentFilterEl.addEventListener('change', () => {
            const value = subSegmentFilterEl.value;
            const topLevelFilterEl = document.getElementById('money-top-level-filter-subsegment');
            if (topLevelFilterEl && topLevelFilterEl.value !== value) {
              topLevelFilterEl.value = value;
              window.moneyPagesSubSegmentFilter = value;
            }
            // Update summary metrics when filter changes
            const moneyPagesMetrics = window.currentMoneyPagesMetrics || window.moneyPagesMetrics;
            if (moneyPagesMetrics && typeof updateMoneyPagesSummaryMetrics === 'function') {
              updateMoneyPagesSummaryMetrics(moneyPagesMetrics);
            }
          });
          
          // Update copy button to use filtered data
          if (copyBtn) {
            const newCopyBtn = copyBtn.cloneNode(true);
            copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
            newCopyBtn.addEventListener('click', async () => {
              const filterCat = categoryFilterEl.value || 'ALL';
              const filterSubSeg = subSegmentFilterEl.value || 'ALL';
              const minImp = parseInt(minImpressionsEl.value, 10) || 0;
              const includeZero = includeZeroEl ? includeZeroEl.checked : true;
              
              const filtered = (allRows || []).filter(row => {
                const matchCat = filterCat === 'ALL' || row.category === filterCat;
                const matchSubSeg = filterSubSeg === 'ALL' || row.subSegment === filterSubSeg;
                const matchImp = (row.impressions || 0) >= minImp;
                const matchZero = includeZero || (row.impressions || 0) > 0;
                return matchCat && matchSubSeg && matchImp && matchZero;
              });
              
              const urls = filtered.map(r => r.url).join('\n');
              if (urls) {
                try {
                  await navigator.clipboard.writeText(urls);
                  newCopyBtn.textContent = 'Copied!';
                  newCopyBtn.style.color = '#10b981';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy current URLs';
                    newCopyBtn.style.color = 'white';
                  }, 2000);
                } catch (err) {
                  newCopyBtn.textContent = 'Copy failed';
                  newCopyBtn.style.color = '#ef4444';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy current URLs';
                    newCopyBtn.style.color = 'white';
                  }, 2000);
                }
              }
            });
          }
        }, 50);
      }
      
      // Make renderMoneyPagesSection globally available
      window.renderMoneyPagesSection = renderMoneyPagesSection;
      
      // Helper function to filter money pages data by sub-segment
      // Apply all filters and calculate filtered metrics
      function getFilteredMoneyPagesMetrics(moneyPagesMetrics) {
        if (!moneyPagesMetrics || !moneyPagesMetrics.rows) {
          return null;
        }
        
        const currentCategoryFilter = window.moneyPagesCategoryFilter || 'ALL';
        const currentSubSegmentFilter = window.moneyPagesSubSegmentFilter || 'ALL';
        const currentMinImpressions = window.moneyPagesMinImpressions || 0;
        const includeZero = window.moneyPagesIncludeZero !== false;
        
        debugLog(` getFilteredMoneyPagesMetrics: includeZero=${includeZero}, category=${currentCategoryFilter}, subSegment=${currentSubSegmentFilter}, minImp=${currentMinImpressions}, totalRows=${moneyPagesMetrics.rows.length}`, 'info');
        
        // Apply all filters
        const filteredRows = moneyPagesMetrics.rows.filter(row => {
          const matchCat = currentCategoryFilter === 'ALL' || row.category === currentCategoryFilter;
          const matchSubSeg = currentSubSegmentFilter === 'ALL' || row.subSegment === currentSubSegmentFilter;
          const matchImp = (row.impressions || 0) >= currentMinImpressions;
          const matchZero = includeZero || (row.impressions || 0) > 0;
          return matchCat && matchSubSeg && matchImp && matchZero;
        });
        
        // Recalculate summaryByCategory from filtered rows
        const filteredSummaryByCategory = {
          HIGH_OPPORTUNITY: { count: 0, impressions: 0, clicks: 0 },
          VISIBILITY_FIX: { count: 0, impressions: 0, clicks: 0 },
          MAINTAIN: { count: 0, impressions: 0, clicks: 0 }
        };
        
        let filteredClicks = 0;
        let filteredImpressions = 0;
        let filteredWeightedPosSum = 0;
        
        filteredRows.forEach(row => {
          const bucket = filteredSummaryByCategory[row.category];
          if (bucket) {
            bucket.count += 1;
            bucket.impressions += row.impressions || 0;
            bucket.clicks += row.clicks || 0;
          }
          filteredClicks += row.clicks || 0;
          filteredImpressions += row.impressions || 0;
          filteredWeightedPosSum += (row.avgPosition || 0) * (row.impressions || 0);
        });
        
        const filteredCtr = filteredImpressions > 0 ? filteredClicks / filteredImpressions : 0;
        const filteredAvgPosition = filteredImpressions > 0 ? filteredWeightedPosSum / filteredImpressions : null;
        
        debugLog(` getFilteredMoneyPagesMetrics: Filtered ${filteredRows.length} rows (from ${moneyPagesMetrics.rows.length}), impressions=${filteredImpressions}, clicks=${filteredClicks}`, 'info');
        
        return {
          ...moneyPagesMetrics,
          rows: filteredRows,
          summaryByCategory: filteredSummaryByCategory,
          overview: {
            ...moneyPagesMetrics.overview,
            moneyClicks: filteredClicks,
            moneyImpressions: filteredImpressions,
            moneyCtr: filteredCtr,
            moneyAvgPosition: filteredAvgPosition,
            moneyCoverageCount: filteredRows.length
          }
        };
      }
      
      // Get filter description for chart title
      function getFilterDescription() {
        const categoryFilter = window.moneyPagesCategoryFilter || 'ALL';
        const subSegmentFilter = window.moneyPagesSubSegmentFilter || 'ALL';
        const minImpressions = window.moneyPagesMinImpressions || 0;
        const includeZero = window.moneyPagesIncludeZero !== false;
        
        const parts = [];
        
        if (categoryFilter !== 'ALL') {
          const categoryLabels = {
            'HIGH_OPPORTUNITY': 'High opportunity',
            'VISIBILITY_FIX': 'Visibility fix',
            'MAINTAIN': 'Maintain'
          };
          parts.push(categoryLabels[categoryFilter] || categoryFilter);
        }
        
        if (subSegmentFilter !== 'ALL') {
          const subSegmentLabels = {
            'PRODUCT': 'Product',
            'EVENT': 'Event',
            'LANDING': 'Landing'
          };
          parts.push(subSegmentLabels[subSegmentFilter] || subSegmentFilter);
        }
        
        if (minImpressions > 0) {
          parts.push(`${minImpressions} impressions`);
        }
        
        if (!includeZero) {
          parts.push('with impressions');
        }
        
        if (parts.length === 0) {
          return 'Money Pages';
        }
        
        return parts.join(' ') + ' Pages';
      }
      
      // Ensure this helper exists in the global scope (Money tab can run before other sections)
      if (!window.computeMoneyPagesBehaviourFromPageAggregates) {
        window.computeMoneyPagesBehaviourFromPageAggregates = function(moneyPages) {
          if (!Array.isArray(moneyPages) || moneyPages.length === 0) return null;

          let clicks = 0;
          let impressions = 0;
          let weightedPosSum = 0;
          let weightedPosImps = 0;
          let top10Clicks = 0;
          let top10Impressions = 0;

          moneyPages.forEach(p => {
            const imps = p.impressions || 0;
            const cls = p.clicks || 0;
            const pos = typeof p.avgPosition === 'number' ? p.avgPosition : (p.avgPosition ? Number.parseFloat(p.avgPosition) : null);
            if (!imps || !pos || pos <= 0) return;

            clicks += cls;
            impressions += imps;
            weightedPosSum += pos * imps;
            weightedPosImps += imps;
            if (pos <= 10) {
              top10Clicks += cls;
              top10Impressions += imps;
            }
          });

          if (!impressions || !weightedPosImps) return null;

          const siteCtr = clicks / impressions;
          const top10Ctr = top10Impressions > 0 ? (top10Clicks / top10Impressions) : 0;
          const avgPos = weightedPosSum / weightedPosImps;
          const top10Share = impressions > 0 ? (top10Impressions / impressions) : 0;

          const scoreCtrAll = Math.min(siteCtr / 0.05, 1) * 100;
          const scoreCtrTop10 = Math.min(top10Ctr / 0.10, 1) * 100;
          const behaviourScore = 0.5 * scoreCtrAll + 0.5 * scoreCtrTop10;

          return {
            score: behaviourScore,
            siteCtr,
            top10Ctr,
            avgPos,
            top10Share,
            clicks,
            impressions
          };
        };
      }

      // Update chart title and summary box
      function updateMoneyPagesChartSummary(filteredMetrics) {
        if (!filteredMetrics) return;
        
        // Update chart title
        const titleEl = document.getElementById('money-pages-chart-title');
        if (titleEl) {
          const filterDesc = getFilterDescription();
          titleEl.textContent = (filterDesc || 'Money Pages') + ' Opportunity Mix';
        }
        
        // Calculate behaviour score for filtered pages
        const queryPages = window.currentQueryPages || [];
        const filteredRows = filteredMetrics.rows || [];
        let filteredBehaviour = window.computeMoneyPagesBehaviour ? 
          window.computeMoneyPagesBehaviour(queryPages, filteredRows, true) : null;
        if (!filteredBehaviour || !filteredBehaviour.impressions) {
          const aggFn = window.computeMoneyPagesBehaviourFromPageAggregates;
          filteredBehaviour = typeof aggFn === 'function' ? aggFn(filteredRows) : null;
        }
        
        // Update summary box
        const overview = filteredMetrics.overview || {};
        const pagesCount = filteredRows.length;
        const impressions = overview.moneyImpressions || 0;
        const clicks = overview.moneyClicks || 0;
        const ctr = overview.moneyCtr || 0;
        const behaviourScore = filteredBehaviour ? filteredBehaviour.score : null;
        
        const pagesEl = document.getElementById('summary-pages-count');
        const impressionsEl = document.getElementById('summary-impressions');
        const clicksEl = document.getElementById('summary-clicks');
        const ctrEl = document.getElementById('summary-ctr');
        const behaviourEl = document.getElementById('summary-behaviour');
        
        if (pagesEl) pagesEl.textContent = pagesCount.toLocaleString();
        if (impressionsEl) impressionsEl.textContent = impressions.toLocaleString();
        if (clicksEl) clicksEl.textContent = clicks.toLocaleString();
        
        // Update CTR with RAG color coding
        if (ctrEl) {
          if (impressions > 0) {
            const ctrPercent = ctr * 100;
            ctrEl.textContent = `${ctrPercent.toFixed(1)}%`;
            // Apply RAG color: Green >= 2.5%, Amber 1.0-2.49%, Red < 1.0%
            if (ctrPercent >= 2.5) {
              ctrEl.style.color = '#10b981'; // green
            } else if (ctrPercent >= 1.0) {
              ctrEl.style.color = '#f59e0b'; // amber
            } else {
              ctrEl.style.color = '#ef4444'; // red
            }
          } else {
            ctrEl.textContent = '-';
            ctrEl.style.color = '#64748b';
          }
        }
        
        // Update Behaviour Score with RAG color coding
        if (behaviourEl) {
          if (behaviourScore !== null && behaviourScore !== undefined) {
            behaviourEl.textContent = Math.round(behaviourScore);
            // Apply RAG color: Green >= 70, Amber 40-69, Red < 40
            if (behaviourScore >= 70) {
              behaviourEl.style.color = '#10b981'; // green
            } else if (behaviourScore >= 40) {
              behaviourEl.style.color = '#f59e0b'; // amber
            } else {
              behaviourEl.style.color = '#ef4444'; // red
            }
          } else {
            behaviourEl.textContent = 'N/A';
            behaviourEl.style.color = '#64748b';
          }
        }
      }
      
      // Render Money Pages category chart (Phase 2)
      let moneyPagesCategoryChart = null;
      
      function renderMoneyPagesCategoryChart(moneyPagesMetrics, retryCount = 0) {
        const summaryEl = document.getElementById('money-pages-category-summary');
        const breakdownEl = document.getElementById('money-pages-category-breakdown');

        // Show loading placeholder early (prevents blank card)
        if (retryCount === 0 && summaryEl && !summaryEl.textContent) {
          summaryEl.textContent = 'Loading opportunity mix';
        }

        // Prevent excessive retries (show user-facing message instead of blank canvas)
        if (retryCount > 8) {
          debugLog(' Max retries reached for Money Pages Opportunity Mix chart', 'warn');
          if (summaryEl) {
            summaryEl.textContent = 'Could not render Opportunity Mix chart. Try switching tabs or refreshing.';
            summaryEl.style.color = '#b45309';
          }
          if (breakdownEl) breakdownEl.innerHTML = '';
          return;
        }

        debugLog(`renderMoneyPagesCategoryChart called (attempt ${retryCount + 1})`, 'info');
        
        // Check if Chart.js is available
        if (typeof Chart === 'undefined') {
          debugLog(' Chart.js not loaded, cannot render money pages chart', 'warn');
          // Retry after a delay if Chart.js might still be loading
          if (retryCount < 3) {
            setTimeout(() => renderMoneyPagesCategoryChart(moneyPagesMetrics, retryCount + 1), 500);
          }
          return;
        }
        
        const canvas = document.getElementById('money-pages-category-chart');
        if (!canvas) {
          debugLog(` Money pages chart canvas not found (attempt ${retryCount + 1})`, 'warn');
          // Retry if canvas doesn't exist yet (DOM might not be ready)
          if (retryCount < 5) {
            setTimeout(() => renderMoneyPagesCategoryChart(moneyPagesMetrics, retryCount + 1), 200);
          }
          return;
        }
        
        if (!moneyPagesMetrics || !moneyPagesMetrics.summaryByCategory) {
          debugLog(' Money pages metrics or summaryByCategory missing', 'warn');
          // Hide chart row if no data
          const chartRow = document.getElementById('money-pages-chart-row');
          if (chartRow) {
            chartRow.style.display = 'none';
          }
          if (summaryEl) summaryEl.textContent = 'No opportunity mix data available for this audit.';
          return;
        }
        
        // Apply all filters
        const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
        if (!filteredMetrics) {
          debugLog(' No filtered metrics available', 'warn');
          return;
        }
        
        const { summaryByCategory } = filteredMetrics;
        debugLog(`Money pages summaryByCategory: ${JSON.stringify(summaryByCategory)}`, 'info');
        
        const labels = [
          'High opportunity',
          'Visibility fix',
          'Maintain'
        ];
        const keys = ['HIGH_OPPORTUNITY', 'VISIBILITY_FIX', 'MAINTAIN'];
        
        const counts = keys.map(k => (summaryByCategory[k]?.count || 0));
        const impressions = keys.map(k => (summaryByCategory[k]?.impressions || 0));
        
        debugLog(`Money pages chart data - counts: [${counts.join(', ')}], impressions: [${impressions.join(', ')}]`, 'info');
        
        // Check for no data
        const totalPages = counts.reduce((a, b) => a + b, 0);
        const totalImpressions = impressions.reduce((a, b) => a + b, 0);
        function setNoDataMessage() {
          if (summaryEl) {
            summaryEl.textContent = 'No meaningful money-page impressions found for this audit period.';
          }
          if (breakdownEl) {
            breakdownEl.innerHTML = '';
          }
        }
        
        if (!totalPages || !totalImpressions) {
          debugLog(' No money pages data for chart', 'warn');
          const chartRow = document.getElementById('money-pages-chart-row');
          if (chartRow) {
            const canvas = chartRow.querySelector('#money-pages-category-chart');
            if (canvas) canvas.remove();
            setNoDataMessage();
          }
          return;
        }
        
        // Show chart row and ensure it's visible
        const chartRow = document.getElementById('money-pages-chart-row');
        if (!chartRow) {
          debugLog(' Chart row element not found', 'warn');
          // Retry if chart row doesn't exist yet
          if (retryCount < 3) {
            setTimeout(() => renderMoneyPagesCategoryChart(moneyPagesMetrics, retryCount + 1), 200);
          }
          return;
        }
        
        // Ensure chart row is visible
        chartRow.style.display = 'block';
        chartRow.style.visibility = 'visible';
        debugLog(' Chart row is visible', 'success');
        
        // Re-check canvas after ensuring row is visible (in case it wasn't accessible before)
        const canvasCheck = document.getElementById('money-pages-category-chart');
        if (!canvasCheck) {
          debugLog(' Canvas still not found after showing row, retrying...', 'warn');
          if (retryCount < 3) {
            setTimeout(() => renderMoneyPagesCategoryChart(moneyPagesMetrics, retryCount + 1), 200);
          }
          return;
        }
        
        // Destroy existing chart if it exists to prevent memory leaks
        // Also check Chart.js registry to ensure canvas is not already in use
        if (moneyPagesCategoryChart) {
          try {
            moneyPagesCategoryChart.destroy();
            moneyPagesCategoryChart = null;
          } catch (e) {
            debugLog('Error destroying existing chart: ' + e.message, 'warn');
          }
        }
        
        // Also check Chart.js registry and destroy any existing chart on this canvas
        if (typeof Chart !== 'undefined' && Chart.getChart) {
          const existingChart = Chart.getChart(canvas);
          if (existingChart) {
            try {
              existingChart.destroy();
              debugLog('Destroyed existing Chart.js instance from registry', 'info');
            } catch (e) {
              debugLog('Error destroying chart from registry: ' + e.message, 'warn');
            }
          }
        }
        
        // Clear canvas context to ensure clean slate
        const tempCtx = canvas.getContext('2d');
        if (tempCtx) {
          tempCtx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // Set explicit canvas dimensions FIRST to ensure it has size
        // This must happen before checking dimensions
        const parentContainer = canvas.parentElement;
        if (parentContainer) {
          const containerWidth = parentContainer.clientWidth || parentContainer.offsetWidth || 500;
          const containerHeight = 300; // Fixed height for consistency
          canvas.width = containerWidth;
          canvas.height = containerHeight;
        } else {
          canvas.width = 500;
          canvas.height = 300;
        }
        
        // Check if panel/canvas are actually visible and have dimensions AFTER setting them
        const moneyPanel = canvas.closest('.aigeo-panel[data-panel="money"]');
        const isPanelActive = !moneyPanel || moneyPanel.classList.contains('is-active');
        const isPanelVisible = !moneyPanel || (isPanelActive && window.getComputedStyle(moneyPanel).display !== 'none');
        
        const canvasRect = canvas.getBoundingClientRect();
        const hasDimensions = canvasRect.width > 0 && canvasRect.height > 0;
        
        if (!isPanelActive) {
          debugLog(` Money Pages Opportunity Mix: panel not active yet, waiting`, 'warn');
          if (summaryEl) summaryEl.textContent = 'Loading opportunity mix';
          if (moneyPanel) {
            const observer = new MutationObserver(() => {
              if (moneyPanel.classList.contains('is-active')) {
                observer.disconnect();
                requestAnimationFrame(() => renderMoneyPagesCategoryChart(moneyPagesMetrics, 0));
              }
            });
            observer.observe(moneyPanel, { attributes: true, attributeFilter: ['class'] });
          }
          return;
        }

        if (!hasDimensions || !isPanelVisible) {
          debugLog(` Money Pages Opportunity Mix chart: panelVisible=${isPanelVisible} or canvas ${canvasRect.width}${canvasRect.height} (width=${canvasRect.width}, height=${canvasRect.height}, display=${moneyPanel ? window.getComputedStyle(moneyPanel).display : 'N/A'}), retrying`, 'warn');
          setTimeout(() => renderMoneyPagesCategoryChart(moneyPagesMetrics, retryCount + 1), 300);
          return;
        }
        
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          debugLog(' Could not get canvas context', 'warn');
          return;
        }
        
        // Use impressions as weight for the chart slices
        const dataValues = impressions;
        
        debugLog(`Creating money pages category chart with data: [${dataValues.join(', ')}]`, 'info');
        
        try {
          moneyPagesCategoryChart = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels,
            datasets: [
              {
                data: dataValues,
                backgroundColor: [
                  '#f59e0b', // Amber for High opportunity
                  '#ef4444', // Red for Visibility fix
                  '#10b981'  // Green for Maintain
                ],
                borderColor: [
                  '#d97706',
                  '#dc2626',
                  '#059669'
                ],
                borderWidth: 2
              }
            ]
          },
          options: {
            responsive: false,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  padding: 15,
                  font: {
                    size: 12
                  }
                }
              },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    const label = context.label || '';
                    const value = context.raw || 0;
                    const total = dataValues.reduce((a, b) => a + b, 0) || 1;
                    const pct = (value / total) * 100;
                    const count = counts[context.dataIndex] || 0;
                    return `${label}: ${value.toLocaleString()} impressions, ` +
                           `${count} pages (${pct.toFixed(1)}%)`;
                  }
                }
              }
            },
            cutout: '60%'
          }
        });
        debugLog(' Money pages category chart created successfully', 'success');
        
        // Update chart title and summary box with filtered data
        updateMoneyPagesChartSummary(filteredMetrics);
        
        // Populate summary and breakdown after chart is created
        const totalPages = counts.reduce((a, b) => a + b, 0);
        const totalImpressions = impressions.reduce((a, b) => a + b, 0);
        
        const summaryEl = document.getElementById('money-pages-category-summary');
        const breakdownEl = document.getElementById('money-pages-category-breakdown');
        
        // 1) Summary line
        if (summaryEl && totalPages > 0 && totalImpressions > 0) {
          const highImps = impressions[0] || 0;
          const visImps = impressions[1] || 0;
          const mainImps = impressions[2] || 0;
          const mainBucket =
            highImps >= visImps && highImps >= mainImps
              ? 'high-opportunity'
              : visImps >= mainImps
                ? 'visibility-fix'
                : 'maintain';
          
          const focusShare = (Math.max(highImps, visImps, mainImps) / totalImpressions) * 100;
          
          summaryEl.textContent =
            `${totalPages} money pages, ${totalImpressions.toLocaleString()} impressions. ` +
            `Largest share is ${mainBucket} pages ` +
            `(${focusShare.toFixed(1)}% of impressions).`;
        }
        
        // 2) Category pills row
        if (breakdownEl && totalImpressions > 0) {
          breakdownEl.innerHTML = ''; // clear
          
          const colors = ['pill-warning', 'pill-danger', 'pill-success']; // high, vis, maintain
          
          impressions.forEach((imps, idx) => {
            if (!imps) return;
            const count = counts[idx] || 0;
            const pct = (imps / totalImpressions) * 100;
            
            const pill = document.createElement('span');
            pill.className = `pill pill-small ${colors[idx]}`;
            pill.style.cssText = 'display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.8rem; font-weight: 600; margin: 0.125rem;';
            if (colors[idx] === 'pill-warning') {
              pill.style.background = '#fef3c7'; pill.style.color = '#92400e';
            } else if (colors[idx] === 'pill-danger') {
              pill.style.background = '#fee2e2'; pill.style.color = '#991b1b';
            } else {
              pill.style.background = '#d1fae5'; pill.style.color = '#065f46';
            }
            pill.textContent =
              `${labels[idx]}: ${count} pages, ` +
              `${imps.toLocaleString()} imps (${pct.toFixed(1)}%)`;
            
            breakdownEl.appendChild(pill);
          });
        }
        
        } catch (error) {
          debugLog(` Error creating money pages chart: ${error.message}`, 'error');
          console.error('Error creating money pages category chart:', error);
        }
      }
      
      // Phase 3: Render Money Pages Trend Chart
      function renderMoneyPagesTrendChart(history) {
        const ctx = document.getElementById('moneyPagesTrendChart');
        if (!ctx) {
          debugLog(' Money Pages trend chart canvas not found', 'warn');
          return;
        }
        
        if (!history || !history.length) {
          debugLog(' No history data for Money Pages trend chart', 'warn');
          // Show message in chart container
          const cardBody = ctx.closest('.card-body');
          if (cardBody) {
            cardBody.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b; font-size: 0.9rem;">No historical audit data available. Run multiple audits to see trends over time.</div>';
          }
          return;
        }
        
        // Check if Chart.js is available
        if (typeof Chart === 'undefined') {
          debugLog(' Chart.js not loaded, cannot render Money Pages trend chart', 'warn');
          return;
        }
        
        // Destroy existing chart if it exists
        if (window.moneyPagesTrendChart) {
          try {
            // Check if it's a Chart.js instance before calling destroy
            if (window.moneyPagesTrendChart && typeof window.moneyPagesTrendChart.destroy === 'function') {
            window.moneyPagesTrendChart.destroy();
            }
            window.moneyPagesTrendChart = null;
          } catch (e) {
            debugLog('Error destroying existing trend chart: ' + e.message, 'warn');
          }
        }
        
        // Extract money pages history from audit history
        const moneyHistory = history.map(row => ({
          date: row.date,
          dateLabel: row.date ? new Date(row.date).toLocaleDateString('en-GB', { month: 'short', day: 'numeric' }) : row.date,
          behaviourScore: row.moneyPagesBehaviourScore ?? null,
          shareOfImpressions: row.moneyPagesSummary?.shareOfImpressions ?? null,
          shareOfClicks: row.moneyPagesSummary?.shareOfClicks ?? null,
          ctr: row.moneyPagesSummary?.ctr ?? null
        })).filter(h => h.date); // Filter out entries without dates
        
        debugLog(` Money Pages Trend: Extracted ${moneyHistory.length} history entries from ${history.length} total records`, 'info');
        if (moneyHistory.length > 0) {
          const sample = moneyHistory[0];
          debugLog(` Sample entry: date=${sample.date}, behaviourScore=${sample.behaviourScore}, shareOfImpressions=${sample.shareOfImpressions}, shareOfClicks=${sample.shareOfClicks}, ctr=${sample.ctr}`, 'info');
          debugLog(` Sample entry moneyPagesSummary: ${JSON.stringify(sample.moneyPagesSummary || 'missing')}`, 'info');
        } else {
          debugLog(` Money Pages Trend: No valid history entries extracted. History records: ${history.length}`, 'warn');
          if (history.length > 0) {
            debugLog(` Sample history record keys: ${Object.keys(history[0]).join(', ')}`, 'warn');
            debugLog(` Sample history record: ${JSON.stringify(history[0])}`, 'warn');
          }
        }
        
        // Add current audit data if available
        const currentMoneyPagesMetrics = window.currentMoneyPagesMetrics || (window.saved && window.saved.scores && window.saved.scores.moneyPagesMetrics);
        const currentSearchData = window.currentSearchData || (window.saved && window.saved.searchData);
        
        if (currentMoneyPagesMetrics && currentMoneyPagesMetrics.behaviour && currentMoneyPagesMetrics.behaviour.score != null) {
          const today = new Date().toISOString().split('T')[0];
          const currentSummary = window.buildMoneyPagesSummary ? window.buildMoneyPagesSummary(currentMoneyPagesMetrics, currentSearchData?.overview || null) : null;
          
          // Check if today's data is already in history
          const todayInHistory = moneyHistory.find(h => h.date === today);
          if (!todayInHistory && currentSummary) {
            debugLog(` Adding current audit data to Money Pages trend: date=${today}, behaviourScore=${currentMoneyPagesMetrics.behaviour.score}, shareOfImpressions=${currentSummary.shareOfImpressions}, ctr=${currentSummary.ctr}`, 'info');
            debugLog(` Current overview: ${JSON.stringify(currentSearchData?.overview || 'missing')}`, 'info');
            moneyHistory.push({
              date: today,
              dateLabel: new Date(today).toLocaleDateString('en-GB', { month: 'short', day: 'numeric' }),
              behaviourScore: currentMoneyPagesMetrics.behaviour.score,
              shareOfImpressions: currentSummary.shareOfImpressions,
              shareOfClicks: currentSummary.shareOfClicks,
              ctr: currentSummary.ctr
            });
          } else if (todayInHistory && currentMoneyPagesMetrics.behaviour.score != null) {
            // Update today's entry with current data if it exists but is missing behaviour score
            if (todayInHistory.behaviourScore == null) {
              debugLog(` Updating today's entry with current behaviour score: ${currentMoneyPagesMetrics.behaviour.score}`, 'info');
              todayInHistory.behaviourScore = currentMoneyPagesMetrics.behaviour.score;
              if (currentSummary) {
                todayInHistory.shareOfImpressions = currentSummary.shareOfImpressions;
                todayInHistory.shareOfClicks = currentSummary.shareOfClicks;
                todayInHistory.ctr = currentSummary.ctr;
              }
            }
          }
        }
        
        // Sort by date
        moneyHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        // Forward-fill missing values: use last available value for each metric
        let lastValues = {
          behaviourScore: null,
          shareOfImpressions: null,
          shareOfClicks: null,
          ctr: null
        };
        
        for (const entry of moneyHistory) {
          // Forward-fill missing values
          if (entry.behaviourScore == null && lastValues.behaviourScore != null) {
            entry.behaviourScore = lastValues.behaviourScore;
          }
          if (entry.shareOfImpressions == null && lastValues.shareOfImpressions != null) {
            entry.shareOfImpressions = lastValues.shareOfImpressions;
          }
          if (entry.shareOfClicks == null && lastValues.shareOfClicks != null) {
            entry.shareOfClicks = lastValues.shareOfClicks;
          }
          if (entry.ctr == null && lastValues.ctr != null) {
            entry.ctr = lastValues.ctr;
          }
          
          // Update last values if we have new ones
          if (entry.behaviourScore != null) lastValues.behaviourScore = entry.behaviourScore;
          if (entry.shareOfImpressions != null) lastValues.shareOfImpressions = entry.shareOfImpressions;
          if (entry.shareOfClicks != null) lastValues.shareOfClicks = entry.shareOfClicks;
          if (entry.ctr != null) lastValues.ctr = entry.ctr;
        }
        
        if (moneyHistory.length === 0) {
          debugLog(' No money pages history data after filtering', 'warn');
          const cardBody = ctx.closest('.card-body');
          if (cardBody) {
            cardBody.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b; font-size: 0.9rem;">No money pages historical data available. Run audits to build trend data.</div>';
          }
          return;
        }
        
        // Filter to only entries with at least one non-null value
        const validHistory = moneyHistory.filter(h => 
          h.behaviourScore != null || 
          h.shareOfImpressions != null || 
          h.ctr != null
        );
        
        if (validHistory.length === 0) {
          debugLog(' No money pages history data with valid values', 'warn');
          const cardBody = ctx.closest('.card-body');
          if (cardBody) {
            cardBody.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b; font-size: 0.9rem;">No money pages historical data available. Run audits to build trend data.</div>';
          }
          return;
        }
        
        debugLog(` Money Pages Trend: Using ${validHistory.length} entries with valid data`, 'info');
        
        const labels = validHistory.map(p => p.dateLabel || p.date);
        const behaviour = validHistory.map(p => p.behaviourScore ?? null);
        const shareImps = validHistory.map(p =>
          p.shareOfImpressions != null ? p.shareOfImpressions * 100 : null
        );
        const ctr = validHistory.map(p =>
          p.ctr != null ? p.ctr * 100 : null
        );
        
        debugLog(` Chart data: ${labels.length} labels, behaviour=${behaviour.filter(v => v != null).length} values, shareImps=${shareImps.filter(v => v != null).length} values, ctr=${ctr.filter(v => v != null).length} values`, 'info');
        
        // Set canvas dimensions FIRST
        const parentContainer = ctx.parentElement;
        if (parentContainer) {
          const containerWidth = parentContainer.clientWidth || parentContainer.offsetWidth || 500;
          ctx.width = containerWidth;
          ctx.height = 300;
        } else {
          ctx.width = 500;
          ctx.height = 300;
        }
        
        // Check if canvas is visible and panel is active AFTER setting dimensions
        const moneyPanel = ctx.closest('.aigeo-panel[data-panel="money"]');
        const isPanelActive = moneyPanel && moneyPanel.classList.contains('is-active');
        const panelStyle = moneyPanel ? window.getComputedStyle(moneyPanel) : null;
        const isPanelVisible = !moneyPanel || (isPanelActive && panelStyle && panelStyle.display !== 'none' && panelStyle.visibility !== 'hidden');
        const canvasRect = ctx.getBoundingClientRect();
        
        // Wait a bit for layout to settle if panel was just activated
        if (!isPanelVisible || canvasRect.width === 0 || canvasRect.height === 0) {
          // Only log warning if panel is not active (to reduce noise)
          if (!isPanelActive) {
            debugLog(` Money Pages trend chart: Panel hidden or canvas has zero dimensions (width=${canvasRect.width}, height=${canvasRect.height}, panelVisible=${isPanelVisible}). Chart will render when panel is shown.`, 'warn');
            // Schedule retry when panel becomes visible
            if (moneyPanel && !moneyPanel.classList.contains('is-active')) {
              // Use a one-time observer
              const observer = new MutationObserver((mutations) => {
                if (moneyPanel.classList.contains('is-active')) {
                  observer.disconnect();
                  // Wait a bit longer for layout to settle
                  setTimeout(() => renderMoneyPagesTrendChart(history), 200);
                }
              });
              observer.observe(moneyPanel, { attributes: true, attributeFilter: ['class'] });
              // Also set a timeout fallback (max 5 seconds)
              setTimeout(() => {
                observer.disconnect();
                if (moneyPanel.classList.contains('is-active')) {
                  renderMoneyPagesTrendChart(history);
                }
              }, 5000);
            }
          } else {
            // Panel is active but canvas still has zero dimensions - retry after a short delay
            setTimeout(() => renderMoneyPagesTrendChart(history), 200);
          }
          return;
        }
        
        try {
          window.moneyPagesTrendChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  label: 'Behaviour score (money pages)',
                  data: behaviour,
                  yAxisID: 'yScore',
                  borderColor: 'rgb(59, 130, 246)',
                  backgroundColor: 'rgba(59, 130, 246, 0.1)',
                  borderWidth: 2,
                  spanGaps: true,
                  tension: 0.1
                },
                {
                  label: 'Share of impressions (%)',
                  data: shareImps,
                  yAxisID: 'yPct',
                  borderColor: 'rgb(16, 185, 129)',
                  backgroundColor: 'rgba(16, 185, 129, 0.1)',
                  borderWidth: 2,
                  borderDash: [4, 4],
                  spanGaps: true,
                  tension: 0.1
                },
                {
                  label: 'CTR on money pages (%)',
                  data: ctr,
                  yAxisID: 'yPct',
                  borderColor: 'rgb(245, 158, 11)',
                  backgroundColor: 'rgba(245, 158, 11, 0.1)',
                  borderWidth: 2,
                  borderDash: [2, 2],
                  spanGaps: true,
                  tension: 0.1
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              aspectRatio: 2,
              scales: {
                yScore: {
                  type: 'linear',
                  position: 'left',
                  min: 0,
                  max: 100,
                  title: { display: true, text: 'Behaviour score' },
                  grid: {
                    color: 'rgba(0, 0, 0, 0.05)'
                  }
                },
                yPct: {
                  type: 'linear',
                  position: 'right',
                  min: 0,
                  max: 100,
                  grid: { drawOnChartArea: false },
                  title: { display: true, text: 'Percent' }
                }
              },
              plugins: {
                title: {
                  display: false // Don't show title - it's already in the HTML
                },
                legend: { position: 'bottom' },
                tooltip: { 
                  mode: 'index', 
                  intersect: false,
                  callbacks: {
                    label: function(context) {
                      let label = context.dataset.label || '';
                      if (label) {
                        label += ': ';
                      }
                      const value = context.parsed.y;
                      if (value === null || value === undefined) {
                        label += 'N/A';
                      } else {
                        label += value.toFixed(2);
                        if (context.dataset.yAxisID === 'yPct') {
                          label += '%';
                        }
                      }
                      return label;
                    }
                  }
                }
              }
            }
          });
          
          debugLog(` Money Pages trend chart rendered with ${moneyHistory.length} data points`, 'success');
        } catch (error) {
          debugLog(` Error creating Money Pages trend chart: ${error.message}`, 'error');
          console.error('Error creating Money Pages trend chart:', error);
        }
      }
      
      // ============================================================================
      // Money Pages Priority Matrix Rendering Functions
      // ============================================================================
      
      /**
       * Render summary strip for Money Pages Priority section
       * @param {Array<MoneyPageMetrics>} moneyPages
       * @param {Object} summary - Overview data with totalClicks and totalImpressions
       * @param {HTMLElement} container
       */
      function renderMoneyPagesSummaryStrip(moneyPages, summary, container) {
        if (!moneyPages || !moneyPages.length) {
          container.innerHTML = '<div style="padding: 1rem; text-align: center; color: #64748b;">No money pages data available.</div>';
          return;
        }
        
        const totalClicks = summary?.overview?.totalClicks || summary?.totalClicks || 0;
        const totalImpressions = summary?.overview?.totalImpressions || summary?.totalImpressions || 0;

        const mpClicks = moneyPages.reduce((sum, p) => sum + (p.clicks || 0), 0);
        const mpImpr = moneyPages.reduce((sum, p) => sum + (p.impressions || 0), 0);

        const shareClicks = totalClicks > 0 ? (mpClicks / totalClicks) * 100 : 0;
        const ctr = mpImpr > 0 ? (mpClicks / mpImpr) * 100 : 0;
        const avgPos = moneyPages.length
          ? moneyPages.reduce((sum, p) => sum + (p.avgPosition || 0), 0) / moneyPages.length
          : 0;

        container.innerHTML = `
          <div class="summary-item" style="flex: 1;">
            <span class="label" style="display: block; font-size: 0.85rem; color: #64748b; margin-bottom: 0.25rem;">Money pages share of clicks</span>
            <span class="value" style="display: block; font-size: 1.5rem; font-weight: 700; color: #1e293b;">${shareClicks.toFixed(1)}%</span>
          </div>
          <div class="summary-item" style="flex: 1;">
            <span class="label" style="display: block; font-size: 0.85rem; color: #64748b; margin-bottom: 0.25rem;">Money pages CTR</span>
            <span class="value" style="display: block; font-size: 1.5rem; font-weight: 700; color: #1e293b;">${ctr.toFixed(1)}%</span>
          </div>
          <div class="summary-item" style="flex: 1;">
            <span class="label" style="display: block; font-size: 0.85rem; color: #64748b; margin-bottom: 0.25rem;">Avg position (money pages)</span>
            <span class="value" style="display: block; font-size: 1.5rem; font-weight: 700; color: #1e293b;">${avgPos ? avgPos.toFixed(1) : ""}</span>
          </div>
        `;
      }
      
      /**
       * Render Priority Matrix (3x3 grid: Impact  Difficulty)
       * @param {Array<MoneyPageMetrics>} moneyPages
       * @param {HTMLElement} container
       * @param {Function} onCellClick - Callback(impact, difficulty)
       */
      function renderMoneyPagesMatrix(moneyPages, container, onCellClick, activeFilter = null) {
        if (!moneyPages || !moneyPages.length) {
          container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b;">No money pages data available.</div>';
          return;
        }
        
        const impacts = ["HIGH", "MEDIUM", "LOW"];
        const diffs = ["LOW", "MEDIUM", "HIGH"];

        const totalClicks = moneyPages.reduce((sum, p) => sum + (p.clicks || 0), 0) || 1;

        let html = `
          <div class="matrix-header" style="margin-bottom: 1rem;">
            <div class="axis-label impact" style="text-align: center; font-weight: 600; margin-bottom: 0.5rem;">Impact </div>
            <div class="matrix-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem;">
        `;

        for (const impact of impacts) {
          for (const diff of diffs) {
            const cellPages = moneyPages.filter(
              p => p.impactLevel === impact && p.difficultyLevel === diff
            );
            const count = cellPages.length;
            const clickShare = cellPages.reduce((s, p) => s + (p.clicks || 0), 0) / totalClicks * 100;

            const ragClass =
              impact === "HIGH" && (diff === "LOW" || diff === "MEDIUM") ? "rag-high" :
              impact === "HIGH" && diff === "HIGH" ? "rag-medium" :
              "rag-low";
            
            // Check if this cell is active
            const isActive = activeFilter && activeFilter.impact === impact && activeFilter.diff === diff;
            
            // Active state styling: thicker border, darker background
            const borderColor = isActive 
              ? '#2563eb' 
              : (ragClass === 'rag-high' ? '#10b981' : ragClass === 'rag-medium' ? '#f59e0b' : '#e5e7eb');
            const borderWidth = isActive ? '4px' : '2px';
            const backgroundColor = isActive
              ? '#dbeafe'
              : (ragClass === 'rag-high' ? '#ecfdf5' : ragClass === 'rag-medium' ? '#fffbeb' : '#f9fafb');

            html += `
              <button
                class="matrix-cell ${ragClass} ${isActive ? 'active' : ''}"
                data-impact="${impact}"
                data-diff="${diff}"
                type="button"
                style="padding: 1rem; border: ${borderWidth} solid ${borderColor}; border-radius: 8px; background: ${backgroundColor}; cursor: pointer; text-align: center; transition: all 0.2s; box-shadow: ${isActive ? '0 4px 8px rgba(37, 99, 235, 0.3)' : 'none'};"
                onmouseover="this.style.transform='scale(1.05)'"
                onmouseout="this.style.transform='scale(1)'"
              >
                <div class="cell-title" style="font-weight: 600; font-size: 0.75rem; margin-bottom: 0.5rem; color: #1e293b;">${impact} / ${diff}</div>
                <div class="cell-count" style="font-size: 1.25rem; font-weight: 700; color: #1e293b; margin-bottom: 0.25rem;">${count}</div>
                <div class="cell-share" style="font-size: 0.75rem; color: #64748b;">${clickShare.toFixed(1)}% of clicks</div>
              </button>
            `;
          }
        }

        html += `
            </div>
            <div class="axis-label difficulty" style="text-align: center; font-weight: 600; margin-top: 0.5rem;">Difficulty </div>
          </div>
          <p class="matrix-legend" style="font-size: 0.75rem; color: #64748b; margin-top: 1rem; line-height: 1.5;">
            Click a cell to filter the money page action list.
            Impact is based on lost clicks (expected CTR  actual). Difficulty is based on rank and schema effort.
          </p>
        `;

        container.innerHTML = html;

        container.querySelectorAll(".matrix-cell").forEach(btn => {
          btn.addEventListener("click", () => {
            const impact = /** @type {ImpactLevel} */ (btn.getAttribute("data-impact"));
            const diff = /** @type {DifficultyLevel} */ (btn.getAttribute("data-diff"));
            if (onCellClick) onCellClick(impact, diff);
          });
        });
      }
      
      // Make functions globally available
      window.renderMoneyPagesMatrix = renderMoneyPagesMatrix;
      window.renderMoneyPagesTable = renderMoneyPagesTable;
      window.renderMoneyPagesCategoryChart = renderMoneyPagesCategoryChart;
      window.updateMoneyPagesSummaryMetrics = updateMoneyPagesSummaryMetrics;
      
      /**
       * Render Money Pages Priority Table
       * @param {Array<MoneyPageMetrics>} moneyPages
       * @param {Object} filters - { typeFilter, minImpr, matrixFilter: {impact, diff} }
       */
      /**
       * Sort money pages table rows
       * @param {Array<MoneyPageMetrics>} rows
       * @param {string} column - Column to sort by
       * @param {string} direction - 'asc' or 'desc'
       */
      function sortMoneyPagesRows(rows, column, direction) {
        const priorityRank = { HIGH: 0, MEDIUM: 1, LOW: 2 };
        const impactRank = { HIGH: 0, MEDIUM: 1, LOW: 2 };
        const difficultyRank = { HIGH: 0, MEDIUM: 1, LOW: 2 };
        
        const sorted = rows.slice().sort((a, b) => {
          let comparison = 0;
          
          switch (column) {
            case 'page':
              comparison = (a.title || a.url || '').localeCompare(b.title || b.url || '');
              break;
            case 'type':
              const typeA = a.segmentType === "landing" ? "Landing" : a.segmentType === "event" ? "Event" : a.segmentType === "product" ? "Product" : "Money";
              const typeB = b.segmentType === "landing" ? "Landing" : b.segmentType === "event" ? "Event" : b.segmentType === "product" ? "Product" : "Money";
              comparison = typeA.localeCompare(typeB);
              break;
            case 'priority':
              const pa = priorityRank[a.priorityLevel] ?? 99;
              const pb = priorityRank[b.priorityLevel] ?? 99;
              comparison = pa - pb;
              break;
            case 'impact':
              const ia = impactRank[a.impactLevel] ?? 99;
              const ib = impactRank[b.impactLevel] ?? 99;
              comparison = ia - ib;
              break;
            case 'difficulty':
              const da = difficultyRank[a.difficultyLevel] ?? 99;
              const db = difficultyRank[b.difficultyLevel] ?? 99;
              comparison = da - db;
              break;
            case 'ctr':
              comparison = (a.ctr || 0) - (b.ctr || 0);
              break;
            case 'impressions':
              comparison = (a.impressions || 0) - (b.impressions || 0);
              break;
            case 'avgPosition':
              comparison = (a.avgPosition || 999) - (b.avgPosition || 999);
              break;
            case 'action':
              const actionA = (a.priorityLevel || "LOW") === "HIGH" ? "Fix CTR & strengthen content" : (a.priorityLevel || "LOW") === "MEDIUM" ? "Improve SERP snippet & schema" : "Monitor & maintain";
              const actionB = (b.priorityLevel || "LOW") === "HIGH" ? "Fix CTR & strengthen content" : (b.priorityLevel || "LOW") === "MEDIUM" ? "Improve SERP snippet & schema" : "Monitor & maintain";
              comparison = actionA.localeCompare(actionB);
              break;
            default:
              // Default: priority then lost clicks
              const paDefault = priorityRank[a.priorityLevel] ?? 99;
              const pbDefault = priorityRank[b.priorityLevel] ?? 99;
              if (paDefault !== pbDefault) {
                comparison = paDefault - pbDefault;
              } else {
                comparison = (b._lostClicks || 0) - (a._lostClicks || 0);
              }
          }
          
          return direction === 'asc' ? comparison : -comparison;
        });
        
        return sorted;
      }
      
      // Initialize pagination state for Money Pages Priority table
      if (window.moneyPagesPriorityCurrentPage === undefined) {
        window.moneyPagesPriorityCurrentPage = 1;
      }
      if (window.moneyPagesPriorityRowsPerPage === undefined) {
        window.moneyPagesPriorityRowsPerPage = 10;
      }

      function renderMoneyPagesTable(moneyPages, filters = {}) {
        const tbody = document.querySelector("#money-pages-priority-table tbody");
        const thead = document.querySelector("#money-pages-priority-table thead");
        if (!tbody || !thead) {
          debugLog(' renderMoneyPagesTable (Priority Actions): Table elements not found, table may not be rendered yet', 'warn');
          // Return empty string instead of undefined to prevent error message
          return '';
        }

        // Use window.moneyPagePriorityData if moneyPages is not provided or empty
        const sourcePages = (moneyPages && moneyPages.length > 0) ? moneyPages : (window.moneyPagePriorityData || []);
        if (!sourcePages || sourcePages.length === 0) {
          debugLog(' renderMoneyPagesTable: No money pages data available', 'warn');
          tbody.innerHTML = '<tr><td colspan="9" style="padding: 2rem; text-align: center; color: #64748b;">No money pages data available. Run an audit to generate priority matrix data.</td></tr>';
          // Clear pagination if no data
          const paginationContainer = document.getElementById('money-pages-priority-pagination');
          if (paginationContainer) {
            paginationContainer.innerHTML = '';
          }
          return '';
        }

        const typeFilter = filters.typeFilter || "all";
        const minImpr = filters.minImpr || 0;
        const matrixFilter = filters.matrixFilter || null;

        let rows = sourcePages.slice();

        // Min impressions filter should not hide domain-level authority actions.
        rows = rows.filter(p => p.segmentType === 'authority' || (p.impressions || 0) >= minImpr);

        if (typeFilter !== "all") {
          rows = rows.filter(p => p.segmentType === typeFilter);
        }

        // Matrix filter is only meaningful for money page rows; exclude authority rows unless explicitly filtering for them.
        if (matrixFilter && typeFilter !== "authority") {
          rows = rows.filter(
            p =>
              p.segmentType !== 'authority' &&
              p.impactLevel === matrixFilter.impact &&
              p.difficultyLevel === matrixFilter.diff
          );
        }

        // Apply sorting
        rows = sortMoneyPagesRows(rows, moneyPagesTableSort.column, moneyPagesTableSort.direction);
        
        // Store filtered rows for pagination and copy button
        window.moneyPagesPriorityFilteredRows = rows;
        
        // Update dropdown counts - use base data (after min impressions, before type filter)
        // Get base data for counting
        const base = window.moneyPagePriorityData || [];
        const authority = window.authorityActionRows || [];
        const allRows = base.concat(authority);
        // Apply min impressions filter for counting (but not type filter)
        const pagesForCounting = allRows.filter(p => p.segmentType === 'authority' || (p.impressions || 0) >= minImpr);
        updateMoneyPagesTypeFilterCounts(pagesForCounting);
        
        // Pagination logic
        const rowsPerPage = window.moneyPagesPriorityRowsPerPage || 10;
        const totalRows = rows.length;
        const totalPages = Math.max(1, Math.ceil(totalRows / rowsPerPage));
        let currentPage = window.moneyPagesPriorityCurrentPage || 1;
        
        // Ensure currentPage is within valid range
        if (currentPage > totalPages) {
          currentPage = totalPages;
          window.moneyPagesPriorityCurrentPage = currentPage;
        }
        if (currentPage < 1) {
          currentPage = 1;
          window.moneyPagesPriorityCurrentPage = currentPage;
        }
        
        // Slice rows for current page
        const startIndex = (currentPage - 1) * rowsPerPage;
        const endIndex = startIndex + rowsPerPage;
        const pageRows = rows.slice(startIndex, endIndex);
        
        // Render sortable header
        const sortArrow = (col) => {
          if (moneyPagesTableSort.column === col) {
            return moneyPagesTableSort.direction === 'asc' ? ' ' : ' ';
          }
          return '';
        };
        
        thead.innerHTML = `
          <tr style="background: #f1f5f9;">
            <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0; cursor: pointer; user-select: none;" data-sort="page">Page${sortArrow('page')}</th>
            <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0; cursor: pointer; user-select: none;" data-sort="type">Type${sortArrow('type')}</th>
            <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0; cursor: pointer; user-select: none;" data-sort="priority">Priority${sortArrow('priority')}</th>
            <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0; cursor: pointer; user-select: none;" data-sort="impact">Impact${sortArrow('impact')}</th>
            <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0; cursor: pointer; user-select: none;" data-sort="difficulty">Difficulty${sortArrow('difficulty')}</th>
            <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0; cursor: pointer; user-select: none;" data-sort="ctr">CTR${sortArrow('ctr')}</th>
            <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0; cursor: pointer; user-select: none;" data-sort="impressions">Impr.${sortArrow('impressions')}</th>
            <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0; cursor: pointer; user-select: none;" data-sort="avgPosition">Avg pos.${sortArrow('avgPosition')}</th>
            <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0; cursor: pointer; user-select: none;" data-sort="action">Action${sortArrow('action')}</th>
          </tr>
        `;
        
        // Add click handlers to header cells
        thead.querySelectorAll('th[data-sort]').forEach(th => {
          th.addEventListener('click', () => {
            const col = th.getAttribute('data-sort');
            if (moneyPagesTableSort.column === col) {
              moneyPagesTableSort.direction = moneyPagesTableSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
              moneyPagesTableSort.column = col;
              moneyPagesTableSort.direction = 'asc';
            }
            // Reset to page 1 when sorting changes
            window.moneyPagesPriorityCurrentPage = 1;
            renderMoneyPagesTable(moneyPages, filters);
          });
          
          th.addEventListener('mouseenter', () => {
            th.style.backgroundColor = '#e2e8f0';
          });
          th.addEventListener('mouseleave', () => {
            th.style.backgroundColor = '';
          });
        });

        tbody.innerHTML = pageRows
          .map(p => {
            // Safety checks for undefined values
            const priorityLevel = p.priorityLevel || "LOW";
            const impactLevel = p.impactLevel || "LOW";
            const difficultyLevel = p.difficultyLevel || "MEDIUM";
            const isAuthorityAction = p.segmentType === "authority";
            
            const typeLabel =
              isAuthorityAction ? "Authority" :
              p.segmentType === "landing" ? "Landing" :
              p.segmentType === "event" ? "Event" :
              p.segmentType === "product" ? "Product" :
              "Money";

            const action =
              isAuthorityAction ? "Authority building" :
              priorityLevel === "HIGH"
                ? "Fix CTR & strengthen content"
                : priorityLevel === "MEDIUM"
                ? "Improve SERP snippet & schema"
                : "Monitor & maintain";
            
            const priorityColor = priorityLevel === "HIGH" ? "#ef4444" : priorityLevel === "MEDIUM" ? "#f59e0b" : "#64748b";
            const priorityBg = priorityLevel === "HIGH" ? "#fee2e2" : priorityLevel === "MEDIUM" ? "#fef3c7" : "#f1f5f9";
            const priorityBorder = priorityLevel === "HIGH" ? "#ef4444" : priorityLevel === "MEDIUM" ? "#f59e0b" : "#94a3b8";

            const authMeta = isAuthorityAction ? (p._authorityMeta || null) : null;
            const authScore = authMeta && typeof authMeta.score === 'number' ? authMeta.score : null;
            const authBand = authMeta && typeof authMeta.band === 'string' ? authMeta.band : null;
            const authSegment = authMeta && typeof authMeta.segment === 'string' ? authMeta.segment : null;
            const domainStrengthLine =
              isAuthorityAction
                ? `Domain strength: ${authScore != null ? authScore.toFixed(1) : ''}${authBand ? ` (${authBand})` : ''}`
                : null;

            return `
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.75rem;">
                  <a href="${p.url || '#'}" target="_blank" rel="noopener" style="color: #2563eb; text-decoration: none;">${p.title || p.url || 'Untitled'}</a>
                  ${domainStrengthLine ? `<div style="margin-top: 0.25rem; font-size: 0.8rem; color: #64748b;">${domainStrengthLine}</div>` : ''}
                </td>
                <td style="padding: 0.75rem;">${typeLabel}${isAuthorityAction && authSegment ? `  <span style="color:#64748b;">${authSegment}</span>` : ''}</td>
                <td style="padding: 0.75rem;"><span class="badge badge-priority-${priorityLevel.toLowerCase()}" style="display: inline-block; padding: 0.35rem 0.75rem; border-radius: 6px; background: ${priorityBg}; color: ${priorityColor}; border: 1.5px solid ${priorityBorder}; font-weight: 700; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px;">${priorityLevel}</span></td>
                <td style="padding: 0.75rem;">${impactLevel}</td>
                <td style="padding: 0.75rem;">${difficultyLevel}</td>
                <td style="padding: 0.75rem; text-align: right;">${isAuthorityAction ? '' : `${((p.ctr || 0) * 100).toFixed(1)}%`}</td>
                <td style="padding: 0.75rem; text-align: right;">${isAuthorityAction ? '' : `${(p.impressions || 0).toLocaleString()}`}</td>
                <td style="padding: 0.75rem; text-align: right;">${isAuthorityAction ? '' : (p.avgPosition ? p.avgPosition.toFixed(1) : "")}</td>
                <td style="padding: 0.75rem;">${action}</td>
              </tr>
            `;
          })
          .join("");

        // Copy URLs button - copy all filtered rows, not just current page
        const copyBtn = document.getElementById("money-pages-copy-urls-btn");
        if (copyBtn) {
          copyBtn.onclick = () => {
            const urls = rows.map(p => p.url).join("\n");
            navigator.clipboard.writeText(urls).then(() => {
              copyBtn.textContent = "Copied!";
              setTimeout(() => { copyBtn.textContent = "Copy URLs"; }, 2000);
            }).catch(() => {
              copyBtn.textContent = "Copy failed";
            });
          };
        }
        
        // Render pagination controls
        renderMoneyPagesPriorityPagination(totalRows, currentPage, totalPages, rowsPerPage);
        
        // Return empty string since this function manipulates DOM directly
        return '';
      }
      
      function renderMoneyPagesPriorityPagination(totalRows, currentPage, totalPages, rowsPerPage) {
        const paginationContainer = document.getElementById('money-pages-priority-pagination');
        if (!paginationContainer) {
          debugLog(' Pagination container not found', 'warn');
          return;
        }
        
        if (totalRows === 0) {
          paginationContainer.innerHTML = '';
          return;
        }
        
        const startRow = totalRows === 0 ? 0 : (currentPage - 1) * rowsPerPage + 1;
        const endRow = Math.min(currentPage * rowsPerPage, totalRows);
        
        paginationContainer.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e5e7eb; flex-wrap: wrap; gap: 1rem;">
            <div style="font-size: 0.875rem; color: #374151;">
              Showing ${startRow}-${endRow} of ${totalRows.toLocaleString()}
            </div>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
              <button 
                id="money-pages-priority-pagination-first" 
                type="button" 
                style="padding: 0.5rem 1rem; border: 1px solid #d1d5db; border-radius: 6px; background: #ffffff; cursor: pointer; color: #374151; font-size: 0.875rem;"
                ${currentPage === 1 ? 'disabled' : ''}
              >First</button>
              <button 
                id="money-pages-priority-pagination-prev" 
                type="button" 
                style="padding: 0.5rem 1rem; border: 1px solid #d1d5db; border-radius: 6px; background: #ffffff; cursor: pointer; color: #374151; font-size: 0.875rem;"
                ${currentPage === 1 ? 'disabled' : ''}
              >Previous</button>
              <span style="padding: 0 0.5rem; font-size: 0.875rem; color: #374151;">Page ${currentPage} of ${totalPages}</span>
              <button 
                id="money-pages-priority-pagination-next" 
                type="button" 
                style="padding: 0.5rem 1rem; border: 1px solid #d1d5db; border-radius: 6px; background: #ffffff; cursor: pointer; color: #374151; font-size: 0.875rem;"
                ${currentPage === totalPages ? 'disabled' : ''}
              >Next</button>
              <button 
                id="money-pages-priority-pagination-last" 
                type="button" 
                style="padding: 0.5rem 1rem; border: 1px solid #d1d5db; border-radius: 6px; background: #ffffff; cursor: pointer; color: #374151; font-size: 0.875rem;"
                ${currentPage === totalPages ? 'disabled' : ''}
              >Last</button>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <label style="font-size: 0.875rem; color: #374151; white-space: nowrap;">Rows per page:</label>
              <select 
                id="money-pages-priority-rows-per-page" 
                style="padding: 0.5rem 0.75rem; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.875rem; background: #ffffff; cursor: pointer;"
              >
                <option value="10" ${rowsPerPage === 10 ? 'selected' : ''}>10</option>
                <option value="25" ${rowsPerPage === 25 ? 'selected' : ''}>25</option>
                <option value="50" ${rowsPerPage === 50 ? 'selected' : ''}>50</option>
                <option value="100" ${rowsPerPage === 100 ? 'selected' : ''}>100</option>
                <option value="200" ${rowsPerPage === 200 ? 'selected' : ''}>200</option>
              </select>
            </div>
          </div>
        `;
        
        // Wire up pagination buttons
        const firstBtn = document.getElementById('money-pages-priority-pagination-first');
        const prevBtn = document.getElementById('money-pages-priority-pagination-prev');
        const nextBtn = document.getElementById('money-pages-priority-pagination-next');
        const lastBtn = document.getElementById('money-pages-priority-pagination-last');
        const rowsPerPageSelect = document.getElementById('money-pages-priority-rows-per-page');
        
        if (firstBtn) {
          firstBtn.addEventListener('click', () => {
            window.moneyPagesPriorityCurrentPage = 1;
            const filters = {
              typeFilter: window.moneyPagesTypeFilter || 'all',
              minImpr: window.moneyPagesMinImpr || 0,
              matrixFilter: window.moneyPagesMatrixFilter || null
            };
            renderMoneyPagesTable(null, filters);
          });
        }
        
        if (prevBtn) {
          prevBtn.addEventListener('click', () => {
            if (window.moneyPagesPriorityCurrentPage > 1) {
              window.moneyPagesPriorityCurrentPage--;
              const filters = {
                typeFilter: window.moneyPagesTypeFilter || 'all',
                minImpr: window.moneyPagesMinImpr || 0,
                matrixFilter: window.moneyPagesMatrixFilter || null
              };
              renderMoneyPagesTable(null, filters);
            }
          });
        }
        
        if (nextBtn) {
          nextBtn.addEventListener('click', () => {
            const totalRows = window.moneyPagesPriorityFilteredRows?.length || 0;
            const rowsPerPage = window.moneyPagesPriorityRowsPerPage || 10;
            const totalPages = Math.max(1, Math.ceil(totalRows / rowsPerPage));
            if (window.moneyPagesPriorityCurrentPage < totalPages) {
              window.moneyPagesPriorityCurrentPage++;
              const filters = {
                typeFilter: window.moneyPagesTypeFilter || 'all',
                minImpr: window.moneyPagesMinImpr || 0,
                matrixFilter: window.moneyPagesMatrixFilter || null
              };
              renderMoneyPagesTable(null, filters);
            }
          });
        }
        
        if (lastBtn) {
          lastBtn.addEventListener('click', () => {
            const totalRows = window.moneyPagesPriorityFilteredRows?.length || 0;
            const rowsPerPage = window.moneyPagesPriorityRowsPerPage || 10;
            const totalPages = Math.max(1, Math.ceil(totalRows / rowsPerPage));
            window.moneyPagesPriorityCurrentPage = totalPages;
            const filters = {
              typeFilter: window.moneyPagesTypeFilter || 'all',
              minImpr: window.moneyPagesMinImpr || 0,
              matrixFilter: window.moneyPagesMatrixFilter || null
            };
            renderMoneyPagesTable(null, filters);
          });
        }
        
        if (rowsPerPageSelect) {
          rowsPerPageSelect.addEventListener('change', (e) => {
            const newRowsPerPage = parseInt(e.target.value, 10);
            window.moneyPagesPriorityRowsPerPage = newRowsPerPage;
            window.moneyPagesPriorityCurrentPage = 1; // Reset to first page
            const filters = {
              typeFilter: window.moneyPagesTypeFilter || 'all',
              minImpr: window.moneyPagesMinImpr || 0,
              matrixFilter: window.moneyPagesMatrixFilter || null
            };
            renderMoneyPagesTable(null, filters);
          });
        }
      }
      
      // Make renderMoneyPagesTable globally available
      window.renderMoneyPagesTable = renderMoneyPagesTable;
      
      function applyMoneyPagesTopLevelSubSegmentFilter(value) {
        const subSeg = value || 'ALL';
        debugLog(` Top-level filter changed to: ${subSeg}`, 'info');
        window.moneyPagesSubSegmentFilter = subSeg;

        // Keep table filter in sync (if present)
        const tableSubSegFilter = document.getElementById('money-pages-filter-subsegment');
        if (tableSubSegFilter && tableSubSegFilter.value !== subSeg) {
          tableSubSegFilter.value = subSeg;
        }

        const moneyPagesMetrics = window.currentMoneyPagesMetrics || window.moneyPagesMetrics;
        if (!moneyPagesMetrics) {
          debugLog(' Top-level filter: No moneyPagesMetrics available', 'warn');
          return;
        }

        if (typeof updateMoneyPagesSummaryMetrics === 'function') {
          updateMoneyPagesSummaryMetrics(moneyPagesMetrics);
        }

        const filteredMetrics = typeof getFilteredMoneyPagesMetrics === 'function'
          ? getFilteredMoneyPagesMetrics(moneyPagesMetrics)
          : null;
        const filteredRows = filteredMetrics?.rows || [];
        const queryPages = window.currentQueryPages || null;

        // Update dropdown counts (both table and top-level filters)
        updateMoneyPagesSubSegmentCounts(moneyPagesMetrics);
        
        // Also update top-level filter dropdown counts
        const topLevelFilterEl = document.getElementById('money-top-level-filter-subsegment');
        if (topLevelFilterEl && moneyPagesMetrics && moneyPagesMetrics.rows) {
          const rows = moneyPagesMetrics.rows || [];
          const counts = {
            ALL: rows.length,
            PRODUCT: 0,
            EVENT: 0,
            LANDING: 0
          };
          
          rows.forEach(row => {
            const subSegment = row.subSegment || row.segmentType || 'LANDING';
            if (subSegment === 'PRODUCT' || subSegment === 'product') {
              counts.PRODUCT++;
            } else if (subSegment === 'EVENT' || subSegment === 'event') {
              counts.EVENT++;
            } else if (subSegment === 'LANDING' || subSegment === 'landing') {
              counts.LANDING++;
            }
          });
          
          // Update top-level filter options
          const options = topLevelFilterEl.querySelectorAll('option');
          options.forEach(opt => {
            const value = opt.value;
            if (value === 'ALL') {
              opt.textContent = `All sub-segments (${counts.ALL})`;
            } else if (value === 'PRODUCT') {
              opt.textContent = `Product Pages (${counts.PRODUCT})`;
            } else if (value === 'EVENT') {
              opt.textContent = `Event Pages (${counts.EVENT})`;
            } else if (value === 'LANDING') {
              opt.textContent = `Landing Pages (${counts.LANDING})`;
            }
          });
        }

        if (typeof renderMoneyPagesBehaviourKpis === 'function') {
          const behaviour = (queryPages && typeof window.computeMoneyPagesBehaviour === 'function')
            ? window.computeMoneyPagesBehaviour(queryPages, filteredRows, true)
            : null;
          renderMoneyPagesBehaviourKpis(behaviour, filteredMetrics || moneyPagesMetrics, queryPages);
        }

        if (typeof updateMoneyPagesChartSummary === 'function' && filteredMetrics) {
          updateMoneyPagesChartSummary(filteredMetrics);
        }

        if (typeof renderMoneyPagesCategoryChart === 'function') {
          renderMoneyPagesCategoryChart(moneyPagesMetrics, 0);
        }
      }

      // Wire up top-level filter (independent of table section)
      function wireTopLevelFilter(retryCount = 0) {
        setTimeout(() => {
          const topLevelFilterEl = document.getElementById('money-top-level-filter-subsegment');
          
          if (!topLevelFilterEl) {
            debugLog(` Top-level filter not found (may not be rendered yet) (attempt ${retryCount + 1})`, 'warn');
            if (retryCount < 10) {
              setTimeout(() => wireTopLevelFilter(retryCount + 1), 200);
            }
            return;
          }
          
          // Remove existing listener by cloning
          const newFilter = topLevelFilterEl.cloneNode(true);
          topLevelFilterEl.parentNode.replaceChild(newFilter, topLevelFilterEl);
          
          // Initialize to match global state
          const currentSubSeg = window.moneyPagesSubSegmentFilter || 'ALL';
          newFilter.value = currentSubSeg;
          
          // Update counts when first wiring up
          const moneyPagesMetrics = window.currentMoneyPagesMetrics || window.moneyPagesMetrics;
          if (moneyPagesMetrics && moneyPagesMetrics.rows) {
            const rows = moneyPagesMetrics.rows || [];
            const counts = {
              ALL: rows.length,
              PRODUCT: 0,
              EVENT: 0,
              LANDING: 0
            };
            
            rows.forEach(row => {
              const subSegment = row.subSegment || row.segmentType || 'LANDING';
              if (subSegment === 'PRODUCT' || subSegment === 'product') {
                counts.PRODUCT++;
              } else if (subSegment === 'EVENT' || subSegment === 'event') {
                counts.EVENT++;
              } else if (subSegment === 'LANDING' || subSegment === 'landing') {
                counts.LANDING++;
              }
            });
            
            // Update top-level filter options with counts
            const options = newFilter.querySelectorAll('option');
            options.forEach(opt => {
              const value = opt.value;
              if (value === 'ALL') {
                opt.textContent = `All sub-segments (${counts.ALL})`;
              } else if (value === 'PRODUCT') {
                opt.textContent = `Product Pages (${counts.PRODUCT})`;
              } else if (value === 'EVENT') {
                opt.textContent = `Event Pages (${counts.EVENT})`;
              } else if (value === 'LANDING') {
                opt.textContent = `Landing Pages (${counts.LANDING})`;
              }
            });
          }
          
          debugLog(` Top-level filter found and initialized to: ${currentSubSeg}`, 'success');
          
          // When top-level filter changes, update all sections
          newFilter.addEventListener('change', () => applyMoneyPagesTopLevelSubSegmentFilter(newFilter.value));
          
          debugLog(' Top-level filter wired up successfully', 'success');
        }, 200);
      }
      
      // Make function globally available
      window.wireTopLevelFilter = wireTopLevelFilter;
      
      // Wire up Priority & Actions filters
      function wirePriorityActionsFilters() {
        setTimeout(() => {
          const typeFilterEl = document.getElementById('money-pages-type-filter');
          const minImprEl = document.getElementById('money-pages-min-impr');
          const matrixEl = document.getElementById('money-pages-matrix');
          
          if (!typeFilterEl || !minImprEl) {
            debugLog(' Priority & Actions filters not found (may not be rendered yet)', 'warn');
            return;
          }
          
          debugLog(' Priority & Actions filter elements found', 'success');
          
          // Remove existing listeners by cloning elements
          const newTypeFilter = typeFilterEl.cloneNode(true);
          const newMinImpr = minImprEl.cloneNode(true);
          typeFilterEl.parentNode.replaceChild(newTypeFilter, typeFilterEl);
          minImprEl.parentNode.replaceChild(newMinImpr, minImprEl);
          
          // Update counts initially when wiring up (apply min impressions filter if set)
          const base = window.moneyPagePriorityData || [];
          const authority = window.authorityActionRows || [];
          const allRows = base.concat(authority);
          if (allRows && allRows.length > 0) {
            // Get current min impressions value
            const initialMinImpr = parseInt(newMinImpr.value, 10) || 0;
            // Apply min impressions filter for counting
            const pagesForCounting = allRows.filter(p => p.segmentType === 'authority' || (p.impressions || 0) >= initialMinImpr);
            updateMoneyPagesTypeFilterCounts(pagesForCounting);
          }
          
          // Function to update matrix and table when filters change
          const updatePriorityActions = () => {
            const typeFilter = newTypeFilter.value || 'all';
            const minImpr = parseInt(newMinImpr.value, 10) || 0;
            
            // Store filter state globally
            window.moneyPagesTypeFilter = typeFilter;
            window.moneyPagesMinImpr = minImpr;
            
            debugLog(` Priority & Actions filter changed: type=${typeFilter}, minImpr=${minImpr}`, 'info');
            
            // Get current data
            const base = window.moneyPagePriorityData || [];
            const authority = window.authorityActionRows || [];
            const allRows = base.concat(authority);
            if (!allRows || allRows.length === 0) {
              debugLog(' No moneyPagePriorityData available for Priority & Actions', 'warn');
              return;
            }
            
            debugLog(` Priority & Actions: Found ${allRows.length} rows (money + authority)`, 'success');
            
            // Apply min impressions filter first (for counting purposes)
            let pagesForCounting = allRows.filter(p => p.segmentType === 'authority' || (p.impressions || 0) >= minImpr);
            
            // Update dropdown counts with filtered data (after min impressions filter)
            updateMoneyPagesTypeFilterCounts(pagesForCounting);
            
            // Apply type filter to get final filtered pages
            let filteredPages = pagesForCounting;
            if (typeFilter !== 'all') {
              filteredPages = filteredPages.filter(p => p.segmentType === typeFilter);
            }
            
            debugLog(` Priority & Actions: Filtered to ${filteredPages.length} pages`, 'success');
            
            // Re-render matrix with filtered data
            if (matrixEl && typeof renderMoneyPagesMatrix === 'function') {
              const pagesOnly = filteredPages.filter(p => p.segmentType !== 'authority');
              const activeFilter = window.moneyMatrixFilterState?.impact && window.moneyMatrixFilterState?.diff
                ? { impact: window.moneyMatrixFilterState.impact, diff: window.moneyMatrixFilterState.diff }
                : null;
              
              renderMoneyPagesMatrix(pagesOnly, matrixEl, (impact, diff) => {
                // Update filter state
                window.moneyMatrixFilterState = { impact, diff };
                // Re-render table with matrix filter
                const filters = {
                  typeFilter,
                  minImpr,
                  matrixFilter: { impact, diff }
                };
                if (typeof renderMoneyPagesTable === 'function') {
                  renderMoneyPagesTable(filteredPages, filters);
                }
              }, activeFilter);
            } else {
              debugLog(' renderMoneyPagesMatrix function or matrix element not found', 'warn');
            }
            
            // Re-render table with filters
            if (typeof renderMoneyPagesTable === 'function') {
              const filters = {
                typeFilter,
                minImpr,
                matrixFilter: window.moneyMatrixFilterState?.impact && window.moneyMatrixFilterState?.diff
                  ? { impact: window.moneyMatrixFilterState.impact, diff: window.moneyMatrixFilterState.diff }
                  : null
              };
              renderMoneyPagesTable(filteredPages, filters);
            } else {
              debugLog(' renderMoneyPagesTable function not found', 'warn');
            }
          };
          
          // Attach event listeners
          newTypeFilter.addEventListener('change', updatePriorityActions);
          newMinImpr.addEventListener('input', updatePriorityActions);
          
          debugLog(' Priority & Actions filters wired up', 'success');
        }, 200);
      }
      
      // Make function globally available
      window.wirePriorityActionsFilters = wirePriorityActionsFilters;
      
      // ============================================================================
      // 12-Month KPI Tracker Functions
      // ============================================================================
      
      let moneyKpiChart = null;
      let cachedAuditHistory = null;
      
      // Sort state for tables
      let moneyPagesTableSort = { column: 'priority', direction: 'asc' }; // 'asc' or 'desc'
      let moneyKpiTableSort = { column: 'segment', direction: 'asc' }; // 'asc' or 'desc'
      
      /**
       * Build KPI history structure from audit history
       * @param {Array<{date: string, moneySegmentMetrics: MoneySegmentMetricsByAudit | null}>} history
       * @param {string} metricKey - 'ctr', 'impressions', 'clicks', or 'avgPosition'
       * @returns {{ labels: string[], segments: Record<string, number[]> }}
       */
      function buildMoneyKpiHistory(history, metricKey, timeseries = [], latestMoneySegmentMetrics = null, latestMoneyPagePriorityData = []) {
        // Use last 28 days (matching Performance Trends charts) with 8 weekly date points (28 days / 4 = 7 weeks)
        // Get the last GSC timeseries date from actual timeseries data
        let lastGscTimeseriesDate = null;
        if (timeseries.length > 0) {
          const timeseriesDates = timeseries.map(ts => ts.date).filter(Boolean).sort().reverse();
          if (timeseriesDates.length > 0) {
            lastGscTimeseriesDate = timeseriesDates[0];
          }
        }
        
        // Fallback to window value if timeseries not provided
        if (!lastGscTimeseriesDate) {
          lastGscTimeseriesDate = window.lastGscTimeseriesDate || null;
        }
        
        // Calculate 28-day range ending at last GSC date (inclusive of end date, so go back 27 days)
        const endDate = lastGscTimeseriesDate ? new Date(lastGscTimeseriesDate + 'T00:00:00') : new Date();
        const startDate = new Date(endDate);
        startDate.setDate(startDate.getDate() - 27); // 27 days back + end date = 28 days total
        startDate.setHours(0, 0, 0, 0);
        endDate.setHours(0, 0, 0, 0);
        
        // Generate 8 weekly date points across the 28-day range (28 days / 4 = 7 weeks, so 8 points)
        // Range is from startDate to endDate (inclusive) = 28 days total
        const datePoints = [];
        const totalDays = 28; // startDate to endDate inclusive
        const numPoints = 8; // Weekly points: 7 intervals of 4 days each
        const step = (totalDays - 1) / (numPoints - 1); // 8 points = 7 intervals across 28 days
        
        for (let i = 0; i < numPoints; i++) {
          const date = new Date(startDate);
          date.setDate(date.getDate() + Math.round(i * step));
          date.setHours(0, 0, 0, 0);
          const dateStr = date.toISOString().split('T')[0];
          datePoints.push(dateStr);
        }
        
        // Ensure last point is exactly endDate
        if (datePoints.length > 0) {
          datePoints[datePoints.length - 1] = endDate.toISOString().split('T')[0];
        }
        
        // Create a map of date -> timeseries data for quick lookup
        const timeseriesMap = new Map();
        if (timeseries.length > 0) {
          for (const ts of timeseries) {
            if (ts.date) {
              timeseriesMap.set(ts.date, ts);
            }
          }
        }
        
        // Calculate money page proportions from latest audit's metrics
        // Find the latest audit that has both moneySegmentMetrics and corresponding timeseries data
        let moneyClicksProportion = 0;
        let moneyImpressionsProportion = 0;
        let segmentProportions = {
          landingPages: { clicks: 0, impressions: 0 },
          eventPages: { clicks: 0, impressions: 0 },
          productPages: { clicks: 0, impressions: 0 }
        };
        
        // Find latest audit with valid metrics
        let referenceAudit = null;
        let referenceTs = null;
        
        // Try to find an audit with both metrics and timeseries data
        for (let i = history.length - 1; i >= 0; i--) {
          const audit = history[i];
          const auditDate = audit.date || audit.audit_date || audit.auditDate;
          if (!auditDate) continue;
          
          const metrics = audit.moneySegmentMetrics;
          if (metrics && metrics.allMoney && metrics.allMoney.clicks > 0 && metrics.allMoney.impressions > 0) {
            // Check if we have timeseries data for this date
            const ts = timeseriesMap.get(auditDate);
            if (ts && ts.clicks > 0 && ts.impressions > 0) {
              referenceAudit = audit;
              referenceTs = ts;
              break;
            }
          }
        }
        
        // If no exact match, try to find closest timeseries date to latest audit
        if (!referenceAudit && history.length > 0 && latestMoneySegmentMetrics && latestMoneySegmentMetrics.allMoney) {
          const latestAuditDate = history[history.length - 1].date || history[history.length - 1].audit_date;
          if (latestAuditDate) {
            // Find closest timeseries date (before or on audit date)
            const auditDateObj = new Date(latestAuditDate + 'T00:00:00');
            let closestTs = null;
            let closestDate = null;
            
            for (const [tsDate, tsData] of timeseriesMap.entries()) {
              const tsDateObj = new Date(tsDate + 'T00:00:00');
              if (tsDateObj <= auditDateObj && tsData.clicks > 0 && tsData.impressions > 0) {
                if (!closestDate || tsDateObj > new Date(closestDate + 'T00:00:00')) {
                  closestDate = tsDate;
                  closestTs = tsData;
                }
              }
            }
            
            if (closestTs && latestMoneySegmentMetrics.allMoney.clicks > 0 && latestMoneySegmentMetrics.allMoney.impressions > 0) {
              referenceAudit = { moneySegmentMetrics: latestMoneySegmentMetrics };
              referenceTs = closestTs;
            }
          }
        }
        
        // Calculate proportions from reference audit
        if (referenceAudit && referenceTs && referenceAudit.moneySegmentMetrics) {
          const allMoney = referenceAudit.moneySegmentMetrics.allMoney;
          if (allMoney && allMoney.clicks > 0 && allMoney.impressions > 0 && referenceTs.clicks > 0 && referenceTs.impressions > 0) {
            moneyClicksProportion = allMoney.clicks / referenceTs.clicks;
            moneyImpressionsProportion = allMoney.impressions / referenceTs.impressions;
            
            debugLog(`[KPI Tracker] Calculated proportions: clicks=${(moneyClicksProportion * 100).toFixed(1)}%, impressions=${(moneyImpressionsProportion * 100).toFixed(1)}%`, 'info');
            
            // Calculate segment proportions
            if (allMoney.clicks > 0) {
              segmentProportions.landingPages.clicks = (referenceAudit.moneySegmentMetrics.landingPages?.clicks || 0) / allMoney.clicks;
              segmentProportions.eventPages.clicks = (referenceAudit.moneySegmentMetrics.eventPages?.clicks || 0) / allMoney.clicks;
              segmentProportions.productPages.clicks = (referenceAudit.moneySegmentMetrics.productPages?.clicks || 0) / allMoney.clicks;
            }
            if (allMoney.impressions > 0) {
              segmentProportions.landingPages.impressions = (referenceAudit.moneySegmentMetrics.landingPages?.impressions || 0) / allMoney.impressions;
              segmentProportions.eventPages.impressions = (referenceAudit.moneySegmentMetrics.eventPages?.impressions || 0) / allMoney.impressions;
              segmentProportions.productPages.impressions = (referenceAudit.moneySegmentMetrics.productPages?.impressions || 0) / allMoney.impressions;
            }
          }
        }
        
        // Create labels using same format as Performance Trends charts (e.g., "17 Nov", "15 Dec")
        const labels = datePoints.map(dateStr => {
          const date = new Date(dateStr + 'T00:00:00');
          return date.toLocaleDateString('en-GB', { month: 'short', day: 'numeric' });
        });
        
        const segments = {
          allMoney: [],
          landingPages: [],
          eventPages: [],
          productPages: []
        };
        
        // Debug: Log what we have
        debugLog(`[KPI Tracker] Building history: timeseries.length=${timeseries.length}, timeseriesMap.size=${timeseriesMap.size}, moneyClicksProportion=${moneyClicksProportion}, moneyImpressionsProportion=${moneyImpressionsProportion}`, 'info');
        
        // Process each of the 8 weekly date points - calculate from actual GSC timeseries data
        // Only proceed if we have valid proportions (calculated from real audit data)
        if (timeseries.length === 0 || (moneyClicksProportion === 0 && moneyImpressionsProportion === 0)) {
          debugLog(`[KPI Tracker] Cannot calculate: timeseries=${timeseries.length}, proportions=${moneyClicksProportion > 0}`, 'warn');
          // Return empty data structure - don't fake it
          for (const datePoint of datePoints) {
            for (const key of Object.keys(segments)) {
              segments[key].push(null);
            }
          }
        } else {
          // Process each of the 8 weekly date points - calculate from actual GSC timeseries data
          for (const datePoint of datePoints) {
            // Find closest timeseries date (might not be exact match)
            let ts = timeseriesMap.get(datePoint);
            if (!ts) {
              // Find closest timeseries date before or on this date
              const datePointDate = new Date(datePoint + 'T00:00:00');
              let closestTs = null;
              let closestDate = null;
              
              for (const [tsDate, tsData] of timeseriesMap.entries()) {
                const tsDateObj = new Date(tsDate + 'T00:00:00');
                if (tsDateObj <= datePointDate && (!closestDate || tsDateObj > new Date(closestDate + 'T00:00:00'))) {
                  closestDate = tsDate;
                  closestTs = tsData;
                }
              }
              
              if (closestTs) {
                ts = closestTs;
              }
            }
            
            for (const key of Object.keys(segments)) {
              let v = null;
              
              if (ts && ts.clicks > 0 && ts.impressions > 0 && moneyClicksProportion > 0 && moneyImpressionsProportion > 0) {
                // Calculate metrics from actual GSC timeseries data using proportions
                if (key === 'allMoney') {
                  const moneyClicks = Math.round(ts.clicks * moneyClicksProportion);
                  const moneyImpressions = Math.round(ts.impressions * moneyImpressionsProportion);
                  
                  if (metricKey === 'clicks') {
                    v = moneyClicks;
                  } else if (metricKey === 'impressions') {
                    v = moneyImpressions;
                  } else if (metricKey === 'ctr') {
                    v = moneyImpressions > 0 ? (moneyClicks / moneyImpressions) * 100 : 0;
                  } else if (metricKey === 'avgPosition') {
                    // Use reference audit's avgPosition (position doesn't change much day-to-day)
                    v = referenceAudit?.moneySegmentMetrics?.allMoney?.avgPosition || null;
                  } else if (metricKey === 'behaviourScore') {
                    v = referenceAudit?.moneySegmentMetrics?.allMoney?.behaviourScore || null;
                  }
                } else {
                  // Calculate segment metrics
                  const segmentClicks = Math.round(ts.clicks * moneyClicksProportion * segmentProportions[key].clicks);
                  const segmentImpressions = Math.round(ts.impressions * moneyImpressionsProportion * segmentProportions[key].impressions);
                  
                  if (metricKey === 'clicks') {
                    v = segmentClicks;
                  } else if (metricKey === 'impressions') {
                    v = segmentImpressions;
                  } else if (metricKey === 'ctr') {
                    v = segmentImpressions > 0 ? (segmentClicks / segmentImpressions) * 100 : 0;
                  } else if (metricKey === 'avgPosition') {
                    v = referenceAudit?.moneySegmentMetrics?.[key]?.avgPosition || null;
                  } else if (metricKey === 'behaviourScore') {
                    v = referenceAudit?.moneySegmentMetrics?.[key]?.behaviourScore || null;
                  }
                }
              } else if (ts && metricKey === 'avgPosition') {
                // For position, use reference audit's value (position is relatively stable)
                v = referenceAudit?.moneySegmentMetrics?.[key]?.avgPosition || null;
              }
              
              segments[key].push(v);
            }
          }
        }

        return { labels, segments, datePoints };
      }
      
      /**
       * Render KPI table with trend arrows
       * @param {{ labels: string[], segments: Record<string, number[]> }} historyData
       * @param {string} metricKey
       */
      function renderMoneyKpiTable(historyData, metricKey) {
        const tableHead = document.getElementById("money-kpi-header-row");
        const tbody = document.querySelector("#money-kpi-table tbody");
        if (!tableHead || !tbody) return;

        const { labels, segments, datePoints = [] } = historyData;
        
        // Show message if no data
        if (!labels || labels.length === 0) {
          tbody.innerHTML = '<tr><td colspan="100%" style="padding: 2rem; text-align: center; color: #64748b;">No data available. Run audits to build KPI history.</td></tr>';
          return;
        }

        const segmentLabels = {
          allMoney: "All money pages",
          landingPages: "Landing pages",
          eventPages: "Event pages",
          productPages: "Product pages"
        };
        
        // Convert segments to array for sorting
        let segmentEntries = Object.entries(segments).map(([key, values]) => {
          // Calculate trend value for sorting
          const first = values.find(v => v != null);
          const last = [...values].reverse().find(v => v != null);
          let trendValue = 0;
          if (first != null && last != null) {
            let diff = last - first;
            if (metricKey === "avgPosition") diff = -diff; // lower is better
            trendValue = diff;
          }
          
          return {
            key,
            label: segmentLabels[key],
            values,
            trendValue,
            latestValue: last
          };
        });
        
        // Apply sorting
        const sortArrow = (col) => {
          if (moneyKpiTableSort.column === col) {
            return moneyKpiTableSort.direction === 'asc' ? ' ' : ' ';
          }
          return '';
        };
        
        if (moneyKpiTableSort.column === 'segment') {
          segmentEntries.sort((a, b) => {
            const comparison = a.label.localeCompare(b.label);
            return moneyKpiTableSort.direction === 'asc' ? comparison : -comparison;
          });
        } else if (moneyKpiTableSort.column === 'trend') {
          segmentEntries.sort((a, b) => {
            const comparison = a.trendValue - b.trendValue;
            return moneyKpiTableSort.direction === 'asc' ? comparison : -comparison;
          });
        } else if (moneyKpiTableSort.column.startsWith('month_')) {
          const monthIndex = parseInt(moneyKpiTableSort.column.replace('month_', ''));
          segmentEntries.sort((a, b) => {
            const aVal = a.values[monthIndex] ?? (metricKey === 'avgPosition' ? 999 : -1);
            const bVal = b.values[monthIndex] ?? (metricKey === 'avgPosition' ? 999 : -1);
            const comparison = aVal - bVal;
            return moneyKpiTableSort.direction === 'asc' ? comparison : -comparison;
          });
        } else if (moneyKpiTableSort.column === 'latest') {
          segmentEntries.sort((a, b) => {
            const aVal = a.latestValue ?? (metricKey === 'avgPosition' ? 999 : -1);
            const bVal = b.latestValue ?? (metricKey === 'avgPosition' ? 999 : -1);
            const comparison = aVal - bVal;
            return moneyKpiTableSort.direction === 'asc' ? comparison : -comparison;
          });
        }

        // Header with sortable columns - use same format as chart labels (e.g., "17 Nov")
        tableHead.innerHTML = `
          <th style="padding: 0.5rem 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0; cursor: pointer; user-select: none; white-space: nowrap;" data-sort="segment" title="Money page segment type: All money pages, Landing pages (collection/category), Event pages (workshops/events), or Product pages (services/products). Click to sort.">Segment${sortArrow('segment')}</th>
          ${labels.map((label, idx) => {
            // Labels are in "17 Nov" format - split into two lines for compact display
            const parts = label.split(' ');
            const day = parts[0] || '';
            const month = parts[1] || '';
            // Use datePoints if available, otherwise just use label for tooltip
            const fullDate = (datePoints && datePoints[idx]) ? datePoints[idx] : label;
            return `<th style="padding: 0.4rem 0.2rem; text-align: center; border-bottom: 2px solid #e2e8f0; cursor: pointer; user-select: none; font-size: 0.7rem; min-width: 35px; max-width: 40px; line-height: 1.2; position: relative;" data-sort="month_${idx}" title="Value for ${fullDate}. Click to sort by this date."><div style="display: block;">${day}</div><div style="display: block; font-size: 0.65rem; color: #64748b;">${month}</div><span style="position: absolute; top: 2px; right: 2px; font-size: 0.6rem;">${sortArrow(`month_${idx}`)}</span></th>`;
          }).join("")}
          <th style="padding: 0.5rem 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0; cursor: pointer; user-select: none; white-space: nowrap;" data-sort="trend" title="Overall trend from first to last data point.  = improving,  = declining,  = stable. For Avg Position, lower is better so trend is inverted. Click to sort.">Trend${sortArrow('trend')}</th>
        `;
        
        // Add click handlers to header cells
        tableHead.querySelectorAll('th[data-sort]').forEach(th => {
          th.addEventListener('click', () => {
            const col = th.getAttribute('data-sort');
            if (moneyKpiTableSort.column === col) {
              moneyKpiTableSort.direction = moneyKpiTableSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
              moneyKpiTableSort.column = col;
              moneyKpiTableSort.direction = 'asc';
            }
            renderMoneyKpiTable(historyData, metricKey);
          });
          
          th.addEventListener('mouseenter', () => {
            th.style.backgroundColor = '#e2e8f0';
          });
          th.addEventListener('mouseleave', () => {
            th.style.backgroundColor = '';
          });
        });

        tbody.innerHTML = segmentEntries
          .map(({ key, label, values, trendValue }) => {
            if (!values.length) return "";

            let trendArrow = "";
            let trendClass = "kpi-trend-flat";
            let trendText = "";

            const first = values.find(v => v != null);
            const last = [...values].reverse().find(v => v != null);

            if (first != null && last != null) {
              let diff = last - first;
              if (metricKey === "avgPosition") diff = -diff; // lower is better
              if (diff > 0.02 * Math.abs(first || 1)) {
                trendArrow = "";
                trendClass = "kpi-trend-up";
              } else if (diff < -0.02 * Math.abs(first || 1)) {
                trendArrow = "";
                trendClass = "kpi-trend-down";
              }
              // For CTR, values are already percentages (0-100), so diff is already in percentage points
              // For other metrics, show the raw difference
              trendText = (metricKey === "ctr" ? `${diff.toFixed(1)}pp` : diff.toFixed(1));
            } else {
              trendText = "";
            }

            const cells = values
              .map((v, idx) => {
                if (v == null) return `<td style="padding: 0.4rem 0.3rem; text-align: right; font-size: 0.75rem; min-width: 50px;"></td>`;

                // arrow vs previous non-null
                let arrow = "";
                let arrowClass = "kpi-trend-flat";
                let prev = null;
                for (let j = idx - 1; j >= 0; j--) {
                  if (values[j] != null) {
                    prev = values[j];
                    break;
                  }
                }
                if (prev != null) {
                  let d = v - prev;
                  if (metricKey === "avgPosition") d = -d;
                  if (d > 0.02 * Math.abs(prev || 1)) {
                    arrow = "";
                    arrowClass = "kpi-trend-up";
                  } else if (d < -0.02 * Math.abs(prev || 1)) {
                    arrow = "";
                    arrowClass = "kpi-trend-down";
                  }
                }

                let formatted;
                const arrowHtml = `<span class="${arrowClass}">${arrow}</span>`;
                if (metricKey === "ctr") formatted = `${v.toFixed(1)}% ${arrowHtml}`; // v is already a percentage (0-100)
                else if (metricKey === "avgPosition") formatted = `${v.toFixed(1)} ${arrowHtml}`;
                else formatted = `${Math.round(v).toLocaleString()} ${arrowHtml}`;

                return `<td style="padding: 0.4rem 0.3rem; text-align: right; font-size: 0.75rem; min-width: 50px;">${formatted}</td>`;
              })
              .join("");

            return `
              <tr style="border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 0.75rem; font-weight: 600;">${label}</td>
                ${cells}
                <td style="padding: 0.75rem; text-align: right; font-weight: 600;">
                  <span class="${trendClass}">${trendArrow}</span> ${trendText}
                </td>
              </tr>
            `;
          })
          .join("");
      }
      
      /**
       * Render sparkline chart for KPI tracker
       * @param {{ labels: string[], segments: Record<string, number[]> }} historyData
       * @param {string} metricKey
       */
      function renderMoneyKpiSparkline(historyData, metricKey, retryCount = 0) {
        const ctx = document.getElementById("money-kpi-sparkline");
        if (!ctx) return;

        const { labels, segments } = historyData;
        
        // Don't set canvas dimensions manually - let Chart.js handle it with fixed container
        // The parent container now has a fixed height (300px) set in HTML
        
        // Check if panel is visible AFTER setting dimensions
        const moneyPanel = ctx.closest('.aigeo-panel[data-panel="money"]');
        const isPanelActive = moneyPanel && moneyPanel.classList.contains('is-active');
        const panelStyle = moneyPanel ? window.getComputedStyle(moneyPanel) : null;
        const isPanelVisible = !moneyPanel || (isPanelActive && panelStyle && panelStyle.display !== 'none' && panelStyle.visibility !== 'hidden');
        const canvasRect = ctx.getBoundingClientRect();
        
        // Wait a bit for layout to settle if panel was just activated
        if (!isPanelVisible || canvasRect.width === 0 || canvasRect.height === 0) {
          if (retryCount >= 10) {
            const wrapper = ctx.closest('.sparkline-wrapper');
            if (wrapper) {
              wrapper.innerHTML = '<div style="padding: 1.5rem; text-align: center; color: #b45309; background: #fffbeb; border-left: 3px solid #f59e0b; border-radius: 6px; font-size: 0.9rem;">Could not render KPI chart (canvas still 00). Try switching tabs or refreshing.</div>';
            }
            return;
          }
          // Only log warning if panel is not active (to reduce noise)
          if (!isPanelActive) {
            debugLog(` Money KPI sparkline: Panel hidden or canvas has zero dimensions (width=${canvasRect.width}, height=${canvasRect.height}, panelVisible=${isPanelVisible}). Chart will render when panel is shown.`, 'warn');
            // Schedule retry when panel becomes visible
            if (moneyPanel && !moneyPanel.classList.contains('is-active')) {
              // Use a one-time observer
              const observer = new MutationObserver((mutations) => {
                if (moneyPanel.classList.contains('is-active')) {
                  observer.disconnect();
                  // Wait a bit longer for layout to settle
                  setTimeout(() => renderMoneyKpiSparkline(historyData, metricKey, retryCount + 1), 200);
                }
              });
              observer.observe(moneyPanel, { attributes: true, attributeFilter: ['class'] });
              // Also set a timeout fallback (max 5 seconds)
              setTimeout(() => {
                observer.disconnect();
                if (moneyPanel.classList.contains('is-active')) {
                  renderMoneyKpiSparkline(historyData, metricKey, retryCount + 1);
                }
              }, 5000);
            }
          } else {
            // Panel is active but canvas still has zero dimensions - retry after a short delay
            setTimeout(() => renderMoneyKpiSparkline(historyData, metricKey, retryCount + 1), 200);
          }
          return;
        }
        
        // Check if we have data
        const hasData = labels.length > 0 && segments.allMoney.length > 0;
        
        if (!hasData || labels.length === 0) {
          // Show message if no data
          const wrapper = ctx.closest('.sparkline-wrapper');
          if (wrapper) {
            wrapper.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b;">No data available. Run audits to build KPI history.</div>';
          }
          if (moneyKpiChart) {
            moneyKpiChart.destroy();
            moneyKpiChart = null;
          }
          return;
        }
        
        // Show info message if only 1 data point
        if (labels.length === 1) {
          const wrapper = ctx.closest('.sparkline-wrapper');
          if (wrapper && !wrapper.querySelector('.single-point-message')) {
            const message = document.createElement('div');
            message.className = 'single-point-message';
            message.style.cssText = 'padding: 0.5rem; margin-bottom: 0.5rem; background: #fef3c7; border-left: 3px solid #f59e0b; border-radius: 4px; font-size: 0.85rem; color: #92400e;';
            message.textContent = 'Only 1 audit available. Run more audits to see trends over time.';
            wrapper.insertBefore(message, ctx);
          }
        } else {
          // Remove message if we have multiple data points
          const wrapper = ctx.closest('.sparkline-wrapper');
          if (wrapper) {
            const message = wrapper.querySelector('.single-point-message');
            if (message) message.remove();
          }
        }

        const datasets = [
          { key: "allMoney", label: "All", values: segments.allMoney, color: "#3b82f6" },
          { key: "landingPages", label: "Landing", values: segments.landingPages, color: "#10b981" },
          { key: "eventPages", label: "Event", values: segments.eventPages, color: "#f59e0b" },
          { key: "productPages", label: "Product", values: segments.productPages, color: "#ef4444" }
        ];

        // Always destroy existing chart to allow re-rendering (e.g., when metric changes)
        // Also check Chart.js registry to ensure canvas is not already in use
        if (moneyKpiChart) {
          try {
            moneyKpiChart.destroy();
            moneyKpiChart = null;
          } catch (e) {
            debugLog('Error destroying moneyKpiChart: ' + e.message, 'warn');
            moneyKpiChart = null;
          }
        }
        
        // Also check Chart.js registry and destroy any existing chart on this canvas
        if (typeof Chart !== 'undefined' && Chart.getChart) {
          const existingChart = Chart.getChart(ctx);
          if (existingChart) {
            try {
              existingChart.destroy();
              debugLog('Destroyed existing Chart.js instance from registry for moneyKpiChart', 'info');
            } catch (e) {
              debugLog('Error destroying chart from registry: ' + e.message, 'warn');
            }
          }
        }
        
        // Clear canvas context to ensure clean slate
        const tempCtx = ctx.getContext('2d');
        if (tempCtx) {
          tempCtx.clearRect(0, 0, ctx.width, ctx.height);
        }

        // Ensure we have at least 2 points for line chart, or show points only
        const minPoints = labels.length === 1 ? 1 : 2;
        
        // Calculate Y-axis bounds to prevent infinite expansion
        const allValues = segments.allMoney.concat(
          segments.landingPages || [],
          segments.eventPages || [],
          segments.productPages || []
        ).filter(v => v != null && !isNaN(v));
        
        let minValue = allValues.length > 0 ? Math.min(...allValues) : 0;
        let maxValue = allValues.length > 0 ? Math.max(...allValues) : 100;
        
        // Calculate padding based on data range
        const range = maxValue - minValue;
        const padding = range > 0 ? Math.max(range * 0.1, range * 0.05) : (maxValue > 0 ? maxValue * 0.1 : 0.01);
        
        try {
          moneyKpiChart = new Chart(ctx, {
            type: "line",
            data: {
              labels,
              datasets: datasets.map(d => ({
                label: d.label,
                data: d.values,
                fill: false,
                tension: labels.length > 1 ? 0.3 : 0, // No tension for single point
                pointRadius: labels.length === 1 ? 5 : 3, // Larger point for single data point
                pointHoverRadius: 6,
                borderWidth: 2,
                borderColor: d.color,
                backgroundColor: d.color
              }))
            },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            plugins: {
              legend: { display: true, position: 'top' },
              tooltip: { 
                enabled: true,
                callbacks: {
                  label: function(context) {
                    const label = context.dataset.label || '';
                    const value = context.parsed.y;
                    let formatted = '';
                    if (metricKey === 'ctr') {
                      formatted = `${value.toFixed(2)}%`; // value is already a percentage (0-100)
                    } else if (metricKey === 'avgPosition') {
                      formatted = value.toFixed(1);
                    } else {
                      formatted = Math.round(value).toLocaleString();
                    }
                    return `${label}: ${formatted}`;
                  }
                }
              }
            },
            scales: {
              x: { 
                display: true,
                title: {
                  display: true,
                  font: {
                    size: 14,
                    weight: 'bold'
                  },
                  text: 'Month'
                },
                ticks: {
                  font: {
                    size: 12,
                    weight: 'bold'
                  },
                  maxRotation: 45,
                  minRotation: 45,
                  autoSkip: true,
                  maxTicksLimit: 12,
                  callback: function(value, index) {
                    // Return shorter date format to prevent overflow
                    const label = this.getLabelForValue(value);
                    if (label && label.length > 10) {
                      // If label is too long, use shorter format (e.g., "12-15" instead of "2025-12-15")
                      const parts = label.split('-');
                      if (parts.length >= 3) {
                        return `${parts[1]}-${parts[2]}`;
                      }
                    }
                    return label;
                  }
                }
              },
              y: { 
                display: true,
                title: {
                  display: true,
                  font: {
                    size: 14,
                    weight: 'bold'
                  },
                  text: metricKey === 'ctr' ? 'CTR (%)' : 
                        metricKey === 'avgPosition' ? 'Avg Position' :
                        metricKey === 'impressions' ? 'Impressions' :
                        metricKey === 'clicks' ? 'Clicks' :
                        (metricKey ? metricKey.charAt(0).toUpperCase() + metricKey.slice(1) : 'Value')
                },
                // Let Chart.js auto-scale - don't force min/max as it can cause issues with small ranges
                // The maintainAspectRatio and fixed container height will prevent infinite expansion
                ticks: {
                  font: {
                    size: 12,
                    weight: 'bold'
                  },
                  callback: function(value) {
                    const v = typeof value === 'number' ? value : parseFloat(value);
                    if (Number.isNaN(v)) return value;
                    if (metricKey === 'ctr') return `${v.toFixed(1)}%`; // v is already a percentage (0-100)
                    if (metricKey === 'avgPosition') return v.toFixed(1);
                    return Math.round(v).toLocaleString();
                  }
                }
              }
            },
            elements: {
              point: { radius: labels.length === 1 ? 5 : 3 }
            }
          }
        });
        debugLog(` Money KPI sparkline chart created successfully with ${labels.length} data points`, 'success');
        } catch (error) {
          debugLog(` Error creating Money KPI sparkline chart: ${error.message}`, 'error');
          debugLog(`Error stack: ${error.stack}`, 'error');
          const wrapper = ctx.closest('.sparkline-wrapper');
          if (wrapper) {
            wrapper.innerHTML = `<div style="padding: 2rem; text-align: center; color: #ef4444;">Error rendering chart: ${error.message}</div>`;
          }
        }
      }
      
      /**
       * Load audit history and render KPI tracker
       * @param {string} propertyUrl
       */
      async function loadAuditHistoryAndRenderKpis(propertyUrl) {
        if (!propertyUrl) return;
        
        const endDate = new Date().toISOString().split('T')[0];
        const startDate = new Date();
        startDate.setFullYear(startDate.getFullYear() - 1);
        const startDateStr = startDate.toISOString().split('T')[0];
        
        try {
          // Use window.apiUrl if available (for functions outside the main scope)
          const urlHelper = window.apiUrl || ((path) => {
            const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
            if (!baseUrl) {
              return path.startsWith('/') ? path : `/${path}`;
            }
            const cleanPath = path.startsWith('/') ? path : `/${path}`;
            return `${baseUrl}${cleanPath}`;
          });
          const res = await fetch(urlHelper(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDate}`));
          const json = await res.json();
          if (json.status !== "ok") {
            debugLog(' Could not load audit history for KPI tracker', 'warn');
            return;
          }

          const history = json.data || [];
          cachedAuditHistory = history;
          
          if (history.length === 0) {
            const card = document.getElementById("money-pages-kpi-card");
            if (card) {
              const tableWrapper = card.querySelector('.table-wrapper');
              if (tableWrapper) {
                tableWrapper.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b;">No audit history available. Run audits to build KPI data.</div>';
              }
              const tbody = card.querySelector('#money-kpi-table tbody');
              if (tbody) {
                tbody.innerHTML = '<tr><td colspan="100%" style="padding: 2rem; text-align: center; color: #64748b;">No audit history available. Run audits to build KPI data.</td></tr>';
              }
            }
            debugLog(' Money Pages KPI Tracker: No audit history available', 'warn');
            return;
          }
          
          // Get the last GSC timeseries date (Money Pages metrics are GSC-derived, so should only show up to last GSC date)
          let lastGscTimeseriesDate = null;
          
          // Try to get from window first (if renderTrendChart already ran and set it)
          if (window.lastGscTimeseriesDate) {
            lastGscTimeseriesDate = window.lastGscTimeseriesDate;
            debugLog(`Money Pages KPI: Using last GSC timeseries date from window: ${lastGscTimeseriesDate}`, 'info');
          } else {
            // Extract from timeseries data in the API response
            // The API response should include timeseries data with dates
            if (json.timeseries && Array.isArray(json.timeseries) && json.timeseries.length > 0) {
              // Get the latest date from timeseries (dates are in YYYY-MM-DD format)
              const timeseriesDates = json.timeseries
                .map(ts => ts.date)
                .filter(date => date)
                .sort()
                .reverse();
              if (timeseriesDates.length > 0) {
                lastGscTimeseriesDate = timeseriesDates[0];
                window.lastGscTimeseriesDate = lastGscTimeseriesDate; // Store globally
                debugLog(`Money Pages KPI: Extracted last GSC timeseries date from API response: ${lastGscTimeseriesDate}`, 'info');
              }
            }
          }
          
          // Filter history to only include dates up to the last GSC timeseries date
          // Money Pages metrics (clicks, impressions, CTR, position) are GSC-derived, so should only show up to last GSC date
          let filteredHistory = history;
          if (lastGscTimeseriesDate) {
            const beforeFilter = history.length;
            filteredHistory = history.filter(record => {
              const recordDate = record.date || record.audit_date || record.auditDate;
              if (!recordDate) return false;
              // Compare dates as strings (YYYY-MM-DD format)
              const comparison = recordDate.localeCompare(lastGscTimeseriesDate);
              const include = comparison <= 0;
              if (!include) {
                debugLog(`Money Pages KPI: Excluding record with date ${recordDate} (last GSC date: ${lastGscTimeseriesDate})`, 'info');
              }
              return include;
            });
            debugLog(`Money Pages KPI: Filtered history from ${beforeFilter} to ${filteredHistory.length} records (last GSC date: ${lastGscTimeseriesDate})`, 'info');
            debugLog(`Money Pages KPI: Filtered dates: ${filteredHistory.map(r => r.date || r.audit_date || r.auditDate).join(', ')}`, 'info');
          } else {
            debugLog(`Money Pages KPI: No last GSC timeseries date found, using all history records`, 'warn');
          }
          
          // Check if any history records have moneySegmentMetrics (API returns camelCase)
          const hasMetrics = filteredHistory.some(record => record.moneySegmentMetrics);
          if (!hasMetrics) {
            debugLog(` Money Pages KPI Tracker: No moneySegmentMetrics in audit history. History length: ${filteredHistory.length}`, 'warn');
            debugLog(` Sample record keys: ${filteredHistory.length > 0 ? Object.keys(filteredHistory[0]).join(', ') : 'no records'}`, 'warn');
            const card = document.getElementById("money-pages-kpi-card");
            if (card) {
              const tableWrapper = card.querySelector('.table-wrapper');
              if (tableWrapper) {
                tableWrapper.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b;">No money segment metrics found in audit history. Run a new audit to generate KPI data.</div>';
              }
              const tbody = card.querySelector('#money-kpi-table tbody');
              if (tbody) {
                tbody.innerHTML = '<tr><td colspan="100%" style="padding: 2rem; text-align: center; color: #64748b;">No money segment metrics found. Run a new audit to generate KPI data.</td></tr>';
              }
            }
            return;
          }
          
          debugLog(` Money Pages KPI Tracker: Found ${filteredHistory.filter(r => r.moneySegmentMetrics).length} records with moneySegmentMetrics`, 'success');
          debugLog(` Money Pages KPI Tracker: Total history records: ${filteredHistory.length}`, 'info');

          // Get timeseries data from API response (actual GSC data for all dates)
          const timeseries = json.timeseries || [];
          debugLog(` Money Pages KPI Tracker: Using ${timeseries.length} timeseries data points from GSC`, 'info');
          
          // Get latest audit's moneyPagePriorityData for proportions
          const latestAudit = filteredHistory.length > 0 ? filteredHistory[filteredHistory.length - 1] : null;
          const latestMoneyPagePriorityData = latestAudit?.moneyPagePriorityData || window.moneyPagePriorityData || [];
          const latestMoneySegmentMetrics = latestAudit?.moneySegmentMetrics || null;
          
          const metricKey = document.getElementById("money-kpi-metric-select")?.value || "ctr";
          debugLog(` Money Pages KPI Tracker: Using metricKey="${metricKey}"`, 'info');
          const historyData = buildMoneyKpiHistory(filteredHistory, metricKey, timeseries, latestMoneySegmentMetrics, latestMoneyPagePriorityData);
          debugLog(` Money Pages KPI Tracker: Built history with ${historyData.labels.length} labels`, 'info');
          
          renderMoneyKpiTable(historyData, metricKey);
          renderMoneyKpiSparkline(historyData, metricKey);
        } catch (error) {
          debugLog(` Error loading KPI history: ${error.message}`, 'warn');
        }
      }
      
      // Wire up KPI metric selector to reload on change
      function wireMoneyKpiMetricSelector() {
        setTimeout(() => {
          const metricSelect = document.getElementById('money-kpi-metric-select');
          if (metricSelect) {
            const newSelect = metricSelect.cloneNode(true);
            metricSelect.parentNode.replaceChild(newSelect, metricSelect);
            newSelect.addEventListener('change', () => {
              const propertyUrl = document.getElementById('propertyUrl')?.value;
              if (propertyUrl) {
                loadAuditHistoryAndRenderKpis(propertyUrl);
              }
            });
            debugLog(' Money KPI metric selector wired up', 'success');
          }
        }, 200);
      }
      
      // Render Money Pages Performance Trends charts (split into Volume and Rate charts)
      function renderMoneyPagesTrendChart(history) {
        const volumeCanvas = document.getElementById('moneyPagesVolumeChart');
        const rateCanvas = document.getElementById('moneyPagesRateChart');
        
        if (!volumeCanvas || !rateCanvas) {
          debugLog(` Money Pages trend chart canvas(es) not found - volumeCanvas: ${!!volumeCanvas}, rateCanvas: ${!!rateCanvas}`, 'warn');
          debugLog(` Looking for canvas elements - volumeCanvas ID: moneyPagesVolumeChart, rateCanvas ID: moneyPagesRateChart`, 'warn');
          // Try to find any canvas elements in the Money Pages section
          const moneySection = document.getElementById('money-pages-section');
          if (moneySection) {
            const allCanvases = moneySection.querySelectorAll('canvas');
            debugLog(` Found ${allCanvases.length} canvas elements in money-pages-section`, 'warn');
            allCanvases.forEach((canvas, idx) => {
              debugLog(` Canvas ${idx}: id=${canvas.id}, tagName=${canvas.tagName}`, 'warn');
            });
          }
          return;
        }
        
        // Destroy existing charts if they exist
        // Also check if charts are already being rendered to prevent loops
        if (window.moneyPagesVolumeChart) {
          try {
            // Check if chart is still valid before destroying
            if (window.moneyPagesVolumeChart.canvas && window.moneyPagesVolumeChart.canvas.id === 'moneyPagesVolumeChart') {
              window.moneyPagesVolumeChart.destroy();
            }
          } catch (e) {
            // Ignore destroy errors
          }
          window.moneyPagesVolumeChart = null;
        }
        if (window.moneyPagesRateChart) {
          try {
            // Check if chart is still valid before destroying
            if (window.moneyPagesRateChart.canvas && window.moneyPagesRateChart.canvas.id === 'moneyPagesRateChart') {
              window.moneyPagesRateChart.destroy();
            }
          } catch (e) {
            // Ignore destroy errors
          }
          window.moneyPagesRateChart = null;
        }
        
        // Prevent re-rendering if charts are already being created
        if (window.moneyPagesChartsRendering) {
          debugLog(' Money Pages charts already rendering, skipping...', 'warn');
          return;
        }
        window.moneyPagesChartsRendering = true;
        
        if (!history || !Array.isArray(history) || history.length === 0) {
          debugLog(' Money Pages trend chart: No history data available', 'warn');
          // Set canvas dimensions before drawing text
          [volumeCanvas, rateCanvas].forEach(canvas => {
            if (canvas) {
              canvas.width = canvas.offsetWidth || 800;
              canvas.height = canvas.offsetHeight || 400;
              const ctx = canvas.getContext('2d');
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.font = '14px Arial';
              ctx.fillStyle = '#64748b';
              ctx.textAlign = 'center';
              ctx.fillText('No trend data available. Run audits to build trend data.', canvas.width / 2, canvas.height / 2);
            }
          });
          return;
        }
        
        // Get the last GSC timeseries date (Money Pages metrics are GSC-derived)
        // Use actual GSC data date, not audit date - GSC data is typically 2-3 days behind
        let lastGscTimeseriesDate = window.lastGscTimeseriesDate || null;
        
        // If not set, try to get from the latest history record's actual GSC date
        if (!lastGscTimeseriesDate && history.length > 0) {
          // Find the latest date that has moneySegmentMetrics (actual GSC data)
          const recordsWithMetrics = history
            .filter(r => r.moneySegmentMetrics && !r.isPartial)
            .map(r => r.date || r.audit_date || r.auditDate)
            .filter(Boolean)
            .sort()
            .reverse();
          
          if (recordsWithMetrics.length > 0) {
            // Use the latest date that has actual GSC metrics
            lastGscTimeseriesDate = recordsWithMetrics[0];
            debugLog(`Money Pages Trend Chart: Using latest date with GSC metrics: ${lastGscTimeseriesDate}`, 'info');
          }
        }
        
        debugLog(`Money Pages Trend Chart: Starting with ${history.length} history records, lastGscTimeseriesDate: ${lastGscTimeseriesDate}`, 'info');
        
        // Calculate the cutoff date for last 28 days (matches GSC data window)
        // Use the last GSC date if available, otherwise use today
        // Go back 27 days to get 28 days total (inclusive of end date)
        const cutoffDate = lastGscTimeseriesDate ? new Date(lastGscTimeseriesDate) : new Date();
        const twentyEightDaysAgo = new Date(cutoffDate);
        twentyEightDaysAgo.setDate(twentyEightDaysAgo.getDate() - 27); // 27 days back + end date = 28 days total
        const twentyEightDaysAgoStr = twentyEightDaysAgo.toISOString().split('T')[0];
        
        debugLog(`Money Pages Trend Chart: Showing last 28 days up to ${cutoffDate.toISOString().split('T')[0]} (from ${twentyEightDaysAgoStr})`, 'info');
        
        // Filter history to only include:
        // 1. Dates up to the last GSC timeseries date
        // 2. Dates within the last 28 days
        // 3. EXCLUDE partial audits (isPartial=true) to prevent unnatural spikes
        let filteredHistory = history;
        if (lastGscTimeseriesDate) {
          const beforeFilter = history.length;
          filteredHistory = history.filter(record => {
            const recordDate = record.date || record.audit_date || record.auditDate;
            if (!recordDate) return false;
            
            // Exclude partial audits - they can have incomplete/incorrect data
            if (record.isPartial === true) {
              debugLog(`Money Pages Trend: Excluding partial audit ${recordDate} to prevent spikes`, 'info');
              return false;
            }
            
            // Check if date is within last 28 days
            const isWithin28Days = recordDate.localeCompare(twentyEightDaysAgoStr) >= 0;
            
            // Check if date is up to last GSC date
            const isUpToGscDate = recordDate.localeCompare(lastGscTimeseriesDate) <= 0;
            
            const include = isWithin28Days && isUpToGscDate;
            if (!include) {
              debugLog(`Money Pages Trend: Excluding record with date ${recordDate} (28-day cutoff: ${twentyEightDaysAgoStr}, last GSC date: ${lastGscTimeseriesDate})`, 'info');
            }
            return include;
          });
          debugLog(`Money Pages Trend: Filtered history from ${beforeFilter} to ${filteredHistory.length} records (last 28 days up to GSC date: ${lastGscTimeseriesDate}, excluding partial audits)`, 'info');
          debugLog(`Money Pages Trend: Filtered dates: ${filteredHistory.map(r => r.date || r.audit_date || r.auditDate).join(', ')}`, 'info');
        } else {
          // If no GSC date, just filter by last 28 days and exclude partial audits
          const beforeFilter = history.length;
          filteredHistory = history.filter(record => {
            const recordDate = record.date || record.audit_date || record.auditDate;
            if (!recordDate) return false;
            
            // Exclude partial audits - they can have incomplete/incorrect data
            if (record.isPartial === true) {
              debugLog(`Money Pages Trend: Excluding partial audit ${recordDate} to prevent spikes`, 'info');
              return false;
            }
            
            const isWithin28Days = recordDate.localeCompare(twentyEightDaysAgoStr) >= 0;
            return isWithin28Days;
          });
          debugLog(`Money Pages Trend: Filtered history from ${beforeFilter} to ${filteredHistory.length} records (last 28 days, no GSC date limit, excluding partial audits)`, 'info');
        }
        
        // Create a map of date -> record for quick lookup
        const historyMap = new Map();
        filteredHistory.forEach(record => {
          const dateStr = record.date || record.audit_date || record.auditDate;
          if (dateStr) {
            historyMap.set(dateStr, record);
            // Debug: log records with money pages data
            if (record.moneySegmentMetrics || record.moneyPagesSummary) {
              debugLog(`Money Pages Trend: Found record for ${dateStr} with data: clicks=${record.moneySegmentMetrics?.allMoney?.clicks || 'null'}, impressions=${record.moneySegmentMetrics?.allMoney?.impressions || 'null'}`, 'info');
            }
          }
        });
        debugLog(`Money Pages Trend: Created historyMap with ${historyMap.size} entries`, 'info');
        
        // Generate 8 weekly date points for last 28 days (up to GSC date)
        // 28 days / 4 = 7 weeks, so 8 points (one per week including start and end)
        const endDate = lastGscTimeseriesDate ? new Date(lastGscTimeseriesDate + 'T00:00:00') : new Date();
        const startDate = new Date(twentyEightDaysAgo);
        const allDates = [];
        const numPoints = 8; // Weekly points: 7 intervals of 4 days each
        const totalDays = 28;
        const step = (totalDays - 1) / (numPoints - 1); // 8 points = 7 intervals
        
        // Ensure we're comparing dates correctly (set time to midnight)
        endDate.setHours(0, 0, 0, 0);
        startDate.setHours(0, 0, 0, 0);
        
        // Generate weekly date points
        for (let i = 0; i < numPoints; i++) {
          const date = new Date(startDate);
          date.setDate(date.getDate() + Math.round(i * step));
          date.setHours(0, 0, 0, 0);
          const dateStr = date.toISOString().split('T')[0];
          allDates.push(dateStr);
        }
        
        // Ensure last point is exactly endDate
        if (allDates.length > 0) {
          allDates[allDates.length - 1] = endDate.toISOString().split('T')[0];
        }
        
        debugLog(`Money Pages Trend: Generated ${allDates.length} weekly date points in range (${allDates[0]} to ${allDates[allDates.length - 1]})`, 'info');
        debugLog(`Money Pages Trend: Date range: startDate=${startDate.toISOString().split('T')[0]}, endDate=${endDate.toISOString().split('T')[0]}, twentyEightDaysAgoStr=${twentyEightDaysAgoStr}`, 'info');
        
        // Extract money pages trend data, filling in weekly dates
        const labels = [];
        const clicksData = [];
        const impressionsData = [];
        const ctrData = [];
        const behaviourData = [];
        
        // Track first available values (for backward-filling) and last known values (for forward-filling)
        let firstClicks = null;
        let firstImpressions = null;
        let firstCtr = null;
        let firstBehaviour = null;
        let lastClicks = null;
        let lastImpressions = null;
        let lastCtr = null;
        let lastBehaviour = null;
        
        // Find the first available audit record (for backward-filling the first point)
        let firstAvailableRecord = null;
        let firstAvailableDateStr = null;
        for (const [dateStr, record] of historyMap.entries()) {
          if (!record.isPartial) {
            const segmentMetrics = record.moneySegmentMetrics || {};
            const allMoney = segmentMetrics.allMoney || {};
            const hasZeroMetrics = (allMoney.clicks === 0 && allMoney.impressions === 0 && allMoney.ctr === 0);
            if (!hasZeroMetrics) {
              firstAvailableRecord = record;
              firstAvailableDateStr = dateStr;
              break;
            }
          }
        }
        
        allDates.forEach((dateStr, dateIndex) => {
          const date = new Date(dateStr);
          labels.push(date.toLocaleDateString('en-GB', { month: 'short', day: 'numeric' }));
          
          // For weekly points, find the nearest audit record (exact match or closest before this date)
          let record = historyMap.get(dateStr);
          if (!record) {
            // Find the closest audit date before or on this weekly point date
            const weeklyDate = new Date(dateStr);
            let closestDate = null;
            let closestRecord = null;
            
            historyMap.forEach((rec, recDateStr) => {
              const recDate = new Date(recDateStr);
              if (recDate <= weeklyDate && (!closestDate || recDate > closestDate)) {
                closestDate = recDate;
                closestRecord = rec;
              }
            });
            
            record = closestRecord;
          }
          
          // If still no record found and this is the first date point, use the first available record (backward-fill)
          if (!record && dateIndex === 0 && firstAvailableRecord) {
            record = firstAvailableRecord;
            debugLog(`Money Pages Trend: First date point ${dateStr} has no data, backward-filling from first available audit ${firstAvailableDateStr}`, 'info');
          }
          
          if (record) {
            // Skip partial audits or audits with all-zero metrics (like Dec 15)
            // Check if this is a partial audit or has invalid zero data
            const isPartial = record.isPartial === true;
            const segmentMetrics = record.moneySegmentMetrics || {};
            const allMoney = segmentMetrics.allMoney || {};
            const hasZeroMetrics = (allMoney.clicks === 0 && allMoney.impressions === 0 && allMoney.ctr === 0);
            
            // If partial audit or has all zeros, skip this record and forward-fill from last known value
            if (isPartial || hasZeroMetrics) {
              debugLog(`Money Pages Trend: Skipping ${dateStr} (isPartial=${isPartial}, hasZeroMetrics=${hasZeroMetrics}), forward-filling`, 'info');
              clicksData.push(lastClicks);
              impressionsData.push(lastImpressions);
              ctrData.push(lastCtr);
              behaviourData.push(lastBehaviour);
              return; // Use return instead of continue in forEach
            }
            
            // Get money pages summary data (shareOfImpressions, shareOfClicks, ctr)
            const summary = record.moneyPagesSummary || {};
            
            // Get behaviour score
            const behaviourScore = record.moneyPagesBehaviourScore || null;
            
            // For clicks and impressions, use moneySegmentMetrics if available
            const clicks = allMoney.clicks || null;
            const impressions = allMoney.impressions || null;
            // Calculate CTR directly from clicks/impressions for accuracy
            // If clicks and impressions are available, calculate CTR as percentage
            // Otherwise fall back to stored values (assuming they're in decimal format 0-1)
            let ctr = null;
            if (clicks != null && impressions != null && impressions > 0) {
              ctr = (clicks / impressions) * 100;
            } else if (summary.ctr != null) {
              // summary.ctr might be decimal (0.015) or percentage (1.5)
              // If > 1, assume it's already a percentage; otherwise multiply by 100
              ctr = summary.ctr > 1 ? summary.ctr : summary.ctr * 100;
            } else if (allMoney.ctr != null) {
              // allMoney.ctr might be decimal (0.015) or percentage (1.5)
              // If > 1, assume it's already a percentage; otherwise multiply by 100
              ctr = allMoney.ctr > 1 ? allMoney.ctr : allMoney.ctr * 100;
            }
            
            // Debug logging for Dec 14 specifically
            if (dateStr === '2025-12-14') {
              debugLog(`Money Pages Trend: Dec 14 extraction - record found: ${!!record}, segmentMetrics: ${!!segmentMetrics}, allMoney: ${!!allMoney}, clicks: ${clicks}, impressions: ${impressions}`, 'info');
              debugLog(`Money Pages Trend: Dec 14 raw data - segmentMetrics: ${JSON.stringify(segmentMetrics)}, allMoney: ${JSON.stringify(allMoney)}`, 'info');
            }
            
            // Track first available values (for backward-filling)
            if (firstClicks == null && clicks != null) firstClicks = clicks;
            if (firstImpressions == null && impressions != null) firstImpressions = impressions;
            if (firstCtr == null && ctr != null) firstCtr = ctr;
            if (firstBehaviour == null && behaviourScore != null) firstBehaviour = behaviourScore;
            
            // Update last known values
            if (clicks != null) lastClicks = clicks;
            if (impressions != null) lastImpressions = impressions;
            if (ctr != null) lastCtr = ctr;
            if (behaviourScore != null) lastBehaviour = behaviourScore;
            
            clicksData.push(clicks);
            impressionsData.push(impressions);
            ctrData.push(ctr);
            behaviourData.push(behaviourScore);
          } else {
            // No audit data for this date - forward-fill from last known value
            clicksData.push(lastClicks);
            impressionsData.push(lastImpressions);
            ctrData.push(lastCtr);
            behaviourData.push(lastBehaviour);
          }
        });
        
        // Backward-fill from first available value
        // This ensures dates before the first data point also get filled
        if (firstClicks != null || firstImpressions != null || firstCtr != null || firstBehaviour != null) {
          for (let i = 0; i < clicksData.length; i++) {
            if (clicksData[i] == null && firstClicks != null) clicksData[i] = firstClicks;
            if (impressionsData[i] == null && firstImpressions != null) impressionsData[i] = firstImpressions;
            if (ctrData[i] == null && firstCtr != null) ctrData[i] = firstCtr;
            if (behaviourData[i] == null && firstBehaviour != null) behaviourData[i] = firstBehaviour;
          }
          debugLog(`Money Pages Trend: Backward-filled from first values (clicks: ${firstClicks}, impressions: ${firstImpressions}, ctr: ${firstCtr}, behaviour: ${firstBehaviour})`, 'info');
        }
        
        debugLog(`Money Pages Trend: Populated ${labels.length} dates with data (${clicksData.filter(v => v != null).length} clicks values, ${impressionsData.filter(v => v != null).length} impressions values)`, 'info');
        debugLog(`Money Pages Trend: Sample data - First 5 dates: ${labels.slice(0, 5).join(', ')}, Last 5 dates: ${labels.slice(-5).join(', ')}`, 'info');
        debugLog(`Money Pages Trend: Sample clicks - First 5: ${clicksData.slice(0, 5).map(v => v != null ? v : 'null').join(', ')}, Last 5: ${clicksData.slice(-5).map(v => v != null ? v : 'null').join(', ')}`, 'info');
        
        if (labels.length === 0) {
          debugLog(' Money Pages trend chart: No valid data points after filtering', 'warn');
          // Set canvas dimensions before drawing text
          canvas.width = canvas.offsetWidth || 800;
          canvas.height = canvas.offsetHeight || 400;
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.font = '14px Arial';
          ctx.fillStyle = '#64748b';
          ctx.textAlign = 'center';
          ctx.fillText('No trend data available. Run audits to build trend data.', canvas.width / 2, canvas.height / 2);
          return;
        }
        
        // Ensure canvases have dimensions before creating charts
        // Use parent container dimensions (Chart.js will handle responsive sizing)
        [volumeCanvas, rateCanvas].forEach(canvas => {
          if (canvas) {
            const parentContainer = canvas.parentElement;
            if (parentContainer) {
              // Don't set canvas.width/height directly - let Chart.js handle it
              // Just ensure the parent has a height
              if (!parentContainer.style.height) {
                parentContainer.style.height = '300px';
              }
            }
          }
        });
        
        debugLog(`Money Pages Trend Chart: Creating chart with ${labels.length} data points`, 'info');
        debugLog(`Money Pages Trend Chart: Clicks data: ${clicksData.filter(v => v != null).length} values, Impressions: ${impressionsData.filter(v => v != null).length} values, CTR: ${ctrData.filter(v => v != null).length} values, Behaviour: ${behaviourData.filter(v => v != null).length} values`, 'info');
        debugLog(`Money Pages Trend Chart: Labels: ${labels.join(', ')}`, 'info');
        
        // Check if Chart.js is available
        if (typeof Chart === 'undefined') {
          debugLog(' Money Pages trend chart: Chart.js not loaded', 'warn');
          [volumeCanvas, rateCanvas].forEach(canvas => {
            if (canvas) {
              canvas.width = canvas.offsetWidth || 800;
              canvas.height = canvas.offsetHeight || 300;
              const ctx = canvas.getContext('2d');
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.font = '14px Arial';
              ctx.fillStyle = '#ef4444';
              ctx.textAlign = 'center';
              ctx.fillText('Chart.js library not loaded', canvas.width / 2, canvas.height / 2);
            }
          });
          return;
        }
        
        try {
          const volumeCtx = volumeCanvas.getContext('2d');
          const rateCtx = rateCanvas.getContext('2d');
          
          if (!volumeCtx || !rateCtx) {
            debugLog(' Money Pages trend chart: Could not get canvas context', 'warn');
            return;
          }
          
          debugLog(`Money Pages Trend Chart: Creating two Chart.js instances (Volume and Rate)...`, 'info');
          
          // Chart 1: Volume Metrics (Clicks + Impressions)
          window.moneyPagesVolumeChart = new Chart(volumeCtx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [
                {
                  label: 'Clicks',
                  data: clicksData,
                  borderColor: '#2563eb',
                  backgroundColor: 'rgba(37, 99, 235, 0.1)',
                  yAxisID: 'y',
                  tension: 0.4,
                  spanGaps: true
                },
                {
                  label: 'Impressions',
                  data: impressionsData,
                  borderColor: '#10b981',
                  backgroundColor: 'rgba(16, 185, 129, 0.1)',
                  yAxisID: 'y1',
                  tension: 0.4,
                  spanGaps: true
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              aspectRatio: 2.5,
              interaction: {
                mode: 'index',
                intersect: false
              },
              plugins: {
                legend: {
                  display: true,
                  position: 'top'
                },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      let label = context.dataset.label || '';
                      if (label) {
                        label += ': ';
                      }
                      label += context.parsed.y.toLocaleString();
                      return label;
                    }
                  }
                }
              },
              scales: {
                x: {
                  display: true,
                  title: {
                    display: true,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    text: 'Audit Date'
                  },
                  ticks: {
                    font: {
                      size: 12,
                      weight: 'bold'
                    },
                    maxRotation: 45,
                    minRotation: 45,
                    autoSkip: true,
                    maxTicksLimit: 15
                  }
                },
                y: {
                  type: 'linear',
                  display: true,
                  position: 'left',
                  title: {
                    display: true,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    text: 'Clicks'
                  },
                  ticks: {
                    font: {
                      size: 12,
                      weight: 'bold'
                    },
                    callback: function(value) {
                      return value.toLocaleString();
                    }
                  }
                },
                y1: {
                  type: 'linear',
                  display: true,
                  position: 'right',
                  title: {
                    display: true,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    text: 'Impressions'
                  },
                  grid: {
                    drawOnChartArea: false
                  },
                  ticks: {
                    font: {
                      size: 12,
                      weight: 'bold'
                    },
                    callback: function(value) {
                      return value.toLocaleString();
                    }
                  }
                }
              }
            }
          });
          
          // Chart 2: Rate & Score Metrics (CTR + Behaviour Score)
          window.moneyPagesRateChart = new Chart(rateCtx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [
                {
                  label: 'CTR (%)',
                  data: ctrData,
                  borderColor: '#f59e0b',
                  backgroundColor: 'rgba(245, 158, 11, 0.1)',
                  yAxisID: 'y',
                  tension: 0.4,
                  spanGaps: true
                },
                {
                  label: 'Behaviour Score',
                  data: behaviourData,
                  borderColor: '#8b5cf6',
                  backgroundColor: 'rgba(139, 92, 246, 0.1)',
                  yAxisID: 'y1',
                  tension: 0.4,
                  spanGaps: true
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              aspectRatio: 2.5,
              interaction: {
                mode: 'index',
                intersect: false
              },
              plugins: {
                legend: {
                  display: true,
                  position: 'top'
                },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      let label = context.dataset.label || '';
                      if (label) {
                        label += ': ';
                      }
                      const value = context.parsed.y;
                      // Use 2 decimal places for CTR to match axis precision
                      if (context.dataset.label === 'CTR (%)') {
                        label += value.toFixed(2) + '%';
                      } else {
                        label += value.toFixed(1);
                      }
                      return label;
                    }
                  }
                }
              },
              scales: {
                x: {
                  display: true,
                  title: {
                    display: true,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    text: 'Audit Date'
                  },
                  ticks: {
                    font: {
                      size: 12,
                      weight: 'bold'
                    },
                    maxRotation: 45,
                    minRotation: 45,
                    autoSkip: true,
                    maxTicksLimit: 15
                  }
                },
                y: {
                  type: 'linear',
                  display: true,
                  position: 'left',
                  title: {
                    display: true,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    text: 'CTR (%)'
                  },
                  ticks: {
                    font: {
                      size: 12,
                      weight: 'bold'
                    },
                    stepSize: 0.02,
                    precision: 2,
                    callback: function(value) {
                      return value.toFixed(2) + '%';
                    }
                  },
                  grid: {
                    color: 'rgba(0, 0, 0, 0.1)'
                  }
                },
                y1: {
                  type: 'linear',
                  display: true,
                  position: 'right',
                  title: {
                    display: true,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    text: 'Behaviour Score'
                  },
                  grid: {
                    drawOnChartArea: false
                  },
                  ticks: {
                    font: {
                      size: 12,
                      weight: 'bold'
                    },
                    callback: function(value) {
                      return value.toFixed(1);
                    }
                  }
                }
              }
            }
          });
          
          debugLog(' Money Pages trend charts rendered successfully', 'success');
          window.moneyPagesChartsRendering = false;
        } catch (error) {
          window.moneyPagesChartsRendering = false;
          debugLog(` Error creating Money Pages trend charts: ${error.message}`, 'error');
          debugLog(`Money Pages trend chart error details: ${error.stack || error.toString()}`, 'error');
          // Show error message on canvases
          [volumeCanvas, rateCanvas].forEach(canvas => {
            if (canvas) {
              const ctx = canvas.getContext('2d');
              if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = '14px Arial';
                ctx.fillStyle = '#ef4444';
                ctx.textAlign = 'center';
                ctx.fillText(`Error rendering chart: ${error.message}`, canvas.width / 2, canvas.height / 2);
              }
            }
          });
        }
      }
      
      // Make functions globally available
      window.renderMoneyPagesTrendChart = renderMoneyPagesTrendChart;
      window.wireMoneyKpiMetricSelector = wireMoneyKpiMetricSelector;
      
      // Recalculate behaviour for filtered sub-segment
      function recalculateMoneyPagesBehaviour(moneyPagesMetrics, queryPages, subSegmentFilter) {
        if (!moneyPagesMetrics || !moneyPagesMetrics.rows || !queryPages || subSegmentFilter === 'ALL') {
          return moneyPagesMetrics?.behaviour || null;
        }
        
        // Get filtered money page URLs
        const filteredRows = moneyPagesMetrics.rows.filter(row => row.subSegment === subSegmentFilter);
        
        if (filteredRows.length === 0) return null;
        
        // Recalculate behaviour for filtered URLs only (use all positions for filtered calculations)
        return window.computeMoneyPagesBehaviour(queryPages, filteredRows, true);
      }
      
      // Render Money Pages Behaviour KPIs
      // behaviour: pre-calculated behaviour object (already filtered if needed)
      // moneyPagesMetrics: optional, for backward compatibility
      // queryPages: optional, for backward compatibility
      function renderMoneyPagesBehaviourKpis(behaviour, moneyPagesMetrics = null, queryPages = null) {
        const scoreEl = document.getElementById('money-behaviour-score');
        const statusEl = document.getElementById('money-behaviour-status');
        const ctrEl = document.getElementById('money-ctr-value');
        const top10El = document.getElementById('money-top10-ctr-value');
        const cardEl = document.getElementById('money-behaviour-card');

        debugLog(` renderMoneyPagesBehaviourKpis called: behaviour=${!!behaviour}, moneyPagesMetrics=${!!moneyPagesMetrics}, queryPages=${!!queryPages}`, 'info');
        debugLog(` DOM elements found: scoreEl=${!!scoreEl}, statusEl=${!!statusEl}, ctrEl=${!!ctrEl}, top10El=${!!top10El}`, 'info');

        // Use the behaviour passed in (should already be filtered)
        // Only recalculate if behaviour is null and we have the data to calculate it
        let filteredBehaviour = behaviour;
        
        // Fallback: if no behaviour passed but we have metrics and queryPages, try to calculate
        if (!filteredBehaviour && moneyPagesMetrics && queryPages) {
          debugLog(` No behaviour passed, attempting to calculate from filtered metrics`, 'info');
          // Get filtered metrics based on ALL current filters
          const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
          if (filteredMetrics && filteredMetrics.rows && filteredMetrics.rows.length > 0) {
            debugLog(` Calculating behaviour for ${filteredMetrics.rows.length} filtered rows`, 'info');
            filteredBehaviour = window.computeMoneyPagesBehaviour ? 
              window.computeMoneyPagesBehaviour(queryPages, filteredMetrics.rows, true) : null;
            debugLog(` Calculated behaviour: ${!!filteredBehaviour}, impressions: ${filteredBehaviour?.impressions || 0}`, 'info');
          } else {
            debugLog(` No filtered metrics or rows available`, 'warn');
          }
        }

        // Fallback #2: compute from page-level aggregates when queryPages is missing/truncated
        if ((!filteredBehaviour || !filteredBehaviour.impressions) && moneyPagesMetrics) {
          const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
          if (filteredMetrics && Array.isArray(filteredMetrics.rows) && filteredMetrics.rows.length > 0) {
            const aggFn = window.computeMoneyPagesBehaviourFromPageAggregates;
            const aggBehaviour = typeof aggFn === 'function' ? aggFn(filteredMetrics.rows) : null;
            if (aggBehaviour && aggBehaviour.impressions) {
              filteredBehaviour = aggBehaviour;
              debugLog(` Fallback behaviour (page aggregates): impressions=${aggBehaviour.impressions}, clicks=${aggBehaviour.clicks}`, 'info');
            }
          }
        }

        if (!scoreEl) {
          debugLog(`  scoreEl not found in DOM`, 'warn');
          return;
        }

        if (!filteredBehaviour || !filteredBehaviour.impressions) {
          debugLog(`  No valid behaviour data: filteredBehaviour=${!!filteredBehaviour}, impressions=${filteredBehaviour?.impressions || 0}`, 'warn');
          if (scoreEl) scoreEl.textContent = 'N/A';
          if (statusEl) statusEl.textContent = 'Not enough data for money pages in this window.';
          if (ctrEl) ctrEl.textContent = '';
          if (top10El) top10El.textContent = '';
          if (cardEl) {
            cardEl.classList.remove('status-green', 'status-amber', 'status-red');
            cardEl.style.borderLeft = '';
            cardEl.style.background = '';
          }
          return;
        }

        const score = Math.round(filteredBehaviour.score);
        const ctrPct = (filteredBehaviour.siteCtr * 100);
        const top10Pct = (filteredBehaviour.top10Ctr * 100);

        scoreEl.textContent = `${score}/100`;
        ctrEl.textContent = `${ctrPct.toFixed(1)}%`;
        top10El.textContent = `${top10Pct.toFixed(2)}%`;

        let label, ragClass;
        if (score >= 70) { 
          label = 'Good  money pages aren\'t holding Authority back.'; 
          ragClass = 'status-green'; 
        } else if (score >= 40) { 
          label = 'Amber  money pages behaviour is the main Authority constraint.'; 
          ragClass = 'status-amber'; 
        } else { 
          label = 'Red  poor CTR on money pages is strongly dragging Authority down.'; 
          ragClass = 'status-red'; 
        }

        if (statusEl) statusEl.textContent = label;
        if (cardEl) {
          cardEl.classList.remove('status-green', 'status-amber', 'status-red');
          cardEl.classList.add(ragClass);
          // Apply RAG colors
          if (ragClass === 'status-green') {
            cardEl.style.borderLeft = '3px solid #10b981';
            cardEl.style.background = '#f0fdf4';
          } else if (ragClass === 'status-amber') {
            cardEl.style.borderLeft = '3px solid #f59e0b';
            cardEl.style.background = '#fffbeb';
          } else {
            cardEl.style.borderLeft = '3px solid #ef4444';
            cardEl.style.background = '#fef2f2';
          }
        }
      }

      // Create Top Pages section (full width, below pillar cards)
      createTopPagesSection(scores, saved);
      
      // Create Money Pages Performance section (right after Top Pages section)
      // Use setTimeout to ensure Top Pages section is inserted first
      setTimeout(() => {
        // Check if section already exists (e.g., from previous render or page refresh)
        let moneyPagesSection = document.getElementById('money-pages-section');
        if (moneyPagesSection) {
          debugLog(' Money Pages section already exists, reusing it', 'info');
          // Clear existing content before re-populating
          moneyPagesSection.innerHTML = '';
        } else {
          // Create new section
          moneyPagesSection = document.createElement('div');
          moneyPagesSection.id = 'money-pages-section';
          moneyPagesSection.className = 'section-break';
          moneyPagesSection.style.marginTop = '2rem';
          moneyPagesSection.style.marginBottom = '2rem';
        }
        
        moneyPagesSection.innerHTML = `
          <div style="padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); background: rgba(204, 255, 229, 0.3); border-left: 4px solid #10b981;">
            <h3 style="margin: 0 0 1rem 0; color: var(--brand-dark);">Money Pages Performance & Actions</h3>
            <p style="margin: 0 0 1.5rem 0; font-size: 0.9rem; color: #666; line-height: 1.6;">
              Focused view of your money pages: how much traffic they capture,
              how they convert clicks, and which URLs to improve first.
              This section uses 30-day Google Search Console data and historical audits to show how your commercial pages perform over time and how much they contribute to your overall Authority behaviour score.
            </p>
            
            <!-- Top-level filter for Performance Metrics, Behaviour, and Opportunity Mix -->
            <div style="display: flex; justify-content: flex-start; align-items: center; margin-bottom: 1.5rem; padding: 1rem 1.25rem; background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%); border-radius: 8px; border: 2px solid #0ea5e9; box-shadow: 0 2px 4px rgba(14, 165, 233, 0.2);">
              <label style="display: flex; align-items: center; gap: 0.75rem; font-size: 0.95rem; color: #0c4a6e; font-weight: 700;" title="Filter Performance Metrics, Behaviour, and Opportunity Mix by sub-segment type">
                <span style="font-weight: 700;">Sub-segment Filter:</span>
                <select id="money-top-level-filter-subsegment" style="padding: 0.6rem 1rem; border: 2px solid #0ea5e9; border-radius: 6px; font-size: 0.95rem; background: white; cursor: pointer; font-weight: 600; color: #0c4a6e; min-width: 150px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);" title="Filter money pages by sub-segment type. Landing pages are collection/category pages, Event pages are workshop/event listings, Product pages are service/product offerings. This filter controls Performance Metrics, Behaviour, and Opportunity Mix sections.">
                  <option value="ALL">All</option>
                  <option value="PRODUCT">Product</option>
                  <option value="EVENT">Event</option>
                  <option value="LANDING">Landing</option>
                </select>
              </label>
            </div>
            
            <!-- Performance Metrics -->
            <div style="margin-bottom: 1.5rem;">
              <h4 style="margin: 0 0 1rem 0; font-size: 0.95rem; font-weight: 600; color: #1e293b;">Performance Metrics</h4>
            </div>
            <div id="money-pages-summary" class="metrics-row" style="display: flex; gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap;">
              <div class="metric-card" id="money-summary-click-share" style="flex: 1; min-width: 200px; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
              <div class="metric-card" id="money-summary-ctr" style="flex: 1; min-width: 200px; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
              <div class="metric-card" id="money-summary-position" style="flex: 1; min-width: 200px; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
              <div class="metric-card" id="money-summary-coverage" style="flex: 1; min-width: 200px; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
            </div>
            
            <!-- Explanation text -->
            <div style="margin-bottom: 1.5rem; padding: 1rem; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #64748b; font-size: 0.85rem; line-height: 1.6; color: #475569;">
              <p style="margin: 0 0 0.5rem 0;"><strong>Note:</strong> These metrics include <strong>all money pages</strong> regardless of ranking position (positions 1-20 and beyond). This provides a complete view of your money page performance, including pages that need improvement.</p>
              <p style="margin: 0;"><strong>Difference from Segment Overview:</strong> The "Segment overview (CTR & ranking)" table above shows metrics for money pages ranking in <strong>positions 1-20 only</strong> (used for Authority scoring). The Money Pages Performance section shows <strong>all money pages</strong> to help identify opportunities across your entire money page portfolio.</p>
            </div>
            
            <!-- Money Pages Behaviour KPIs -->
            <div style="margin-bottom: 1rem;">
              <h3 style="margin: 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Money Pages Behaviour</h3>
            </div>
            <div class="money-behaviour-kpis" id="money-behaviour-kpis" style="display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 1.5rem;">
              <div class="kpi-card" id="money-behaviour-card" style="flex: 1 1 180px; background: #fff; border-radius: 6px; padding: 8px 12px; box-shadow: 0 0 0 1px rgba(0,0,0,0.04);">
                <div class="kpi-label" style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">Money pages behaviour</div>
                <div class="kpi-value" id="money-behaviour-score" style="font-size: 1.5rem; font-weight: 700; color: #1e293b;"></div>
                <div class="kpi-sub" id="money-behaviour-status" style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;">CTR and ranking for money pages only.</div>
              </div>
              <div class="kpi-card" style="flex: 1 1 180px; background: #fff; border-radius: 6px; padding: 8px 12px; box-shadow: 0 0 0 1px rgba(0,0,0,0.04);">
                <div class="kpi-label" style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">CTR (ranking queries)</div>
                <div class="kpi-value" id="money-ctr-value" style="font-size: 1.5rem; font-weight: 700; color: #1e293b;"></div>
                <div class="kpi-sub" style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;">Target 2.5%</div>
              </div>
              <div class="kpi-card" style="flex: 1 1 180px; background: #fff; border-radius: 6px; padding: 8px 12px; box-shadow: 0 0 0 1px rgba(0,0,0,0.04);">
                <div class="kpi-label" style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">Top-10 CTR</div>
                <div class="kpi-value" id="money-top10-ctr-value" style="font-size: 1.5rem; font-weight: 700; color: #1e293b;"></div>
                <div class="kpi-sub" style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;">Target 4.0%</div>
              </div>
            </div>
            <p class="chart-subtitle" style="margin: 0 0 1.5rem 0; font-size: 0.85rem; color: #64748b; padding: 0 0.5rem;">
              Behaviour score here is calculated the same way as <strong>Authority  Behaviour</strong>,
              but only for money pages. Improvements you make on these URLs will move both this score
              and the Authority pillar.
            </p>
            
            <!-- Chart row (Phase 2) -->
            <div class="chart-row" id="money-pages-chart-row" style="margin-bottom: 1.5rem; display: block; visibility: visible;">
              <div class="chart-card" style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: flex; gap: 1.5rem; align-items: flex-start;">
                <div style="flex: 1;">
                  <div style="margin-bottom: 0.5rem;">
                  <h3 id="money-pages-chart-title" style="margin: 0 0 0.5rem 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Money Pages Opportunity Mix</h3>
                  <p class="chart-subtitle" style="margin: 0 0 1rem 0; font-size: 0.85rem; color: #64748b;">
                    How your money pages are distributed across improvement categories in this audit window.
                  </p>
                  </div>
                  <div style="position: relative; width: 500px; height: 300px; margin: 0 auto; overflow: hidden;">
                    <canvas id="money-pages-category-chart" width="500" height="300" style="display: block; max-width: 500px; max-height: 300px;"></canvas>
                  </div>
                  <div id="money-pages-category-summary" class="chart-summary" style="margin-top: 8px; font-size: 0.9rem; color: #1e293b; font-weight: 500; text-align: center;"></div>
                  <div id="money-pages-category-breakdown" class="chart-breakdown-row" style="margin-top: 4px; display: flex; flex-wrap: wrap; gap: 0.5rem; font-size: 0.85rem; justify-content: center;"></div>
                </div>
                <div id="money-pages-chart-summary-box" style="flex: 0 0 320px; background: #f8fafc; padding: 1.5rem; border-radius: 8px; border: 1px solid #e2e8f0; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                  <h4 style="margin: 0 0 1rem 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Filtered Summary</h4>
                  <div style="display: flex; flex-direction: column; gap: 0.75rem; font-size: 0.9rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span style="color: #64748b; font-size: 0.9rem;">Pages:</span>
                      <span id="summary-pages-count" style="font-weight: 700; color: #1e293b; font-size: 1rem;">-</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span style="color: #64748b; font-size: 0.9rem;">Impressions:</span>
                      <span id="summary-impressions" style="font-weight: 700; color: #1e293b; font-size: 1rem;">-</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span style="color: #64748b; font-size: 0.9rem;">Clicks:</span>
                      <span id="summary-clicks" style="font-weight: 700; color: #1e293b; font-size: 1rem;">-</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span style="color: #64748b; font-size: 0.9rem;">CTR:</span>
                      <span id="summary-ctr" style="font-weight: 700; font-size: 1rem;">-</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0.5rem; padding-top: 0.75rem; border-top: 2px solid #e2e8f0;">
                      <span style="color: #64748b; font-size: 0.9rem;">Behaviour Score:</span>
                      <span id="summary-behaviour" style="font-weight: 700; font-size: 1.1rem;">-</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Table container (will be populated by renderMoneyPagesTable) -->
            <div id="money-pages-table-container">
              <!-- Table will be rendered here -->
            </div>
            
            <!-- Phase 3: Money Pages Trend Chart -->
            <section id="money-pages-trend" class="card card--full" style="margin-top: 2rem; background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div class="card-header" style="margin-bottom: 1rem;">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Money Pages Performance Trends (last 28 days)</h3>
                <p class="card-subtitle" style="margin: 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
                  Weekly trends calculated from actual Google Search Console data for the last 28 days. Shows money pages clicks, impressions, CTR, and behaviour score over time.
                </p>
              </div>
              <div class="card-body" style="min-height: 300px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                  <div>
                    <h4 style="font-size: 0.95rem; font-weight: 600; color: #1e293b; margin-bottom: 0.5rem;">Volume Metrics</h4>
                    <div style="position: relative; height: 300px;">
                      <canvas id="moneyPagesVolumeChart"></canvas>
                    </div>
                  </div>
                  <div>
                    <h4 style="font-size: 0.95rem; font-weight: 600; color: #1e293b; margin-bottom: 0.5rem;">Rate & Score Metrics</h4>
                    <div style="position: relative; height: 300px;">
                      <canvas id="moneyPagesRateChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              <div class="card-footer small" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e2e8f0; font-size: 0.85rem; color: #64748b;">
                Data calculated from Google Search Console timeseries for the last 28 days, displayed as 8 weekly data points. Metrics are calculated using money page proportions from the latest audit.
              </div>
            </section>
            
            <!-- Phase: 12-Month KPI Tracker -->
            <section id="money-pages-kpi-card" class="card card--full" style="margin-top: 2rem; background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div class="card-header" style="margin-bottom: 1rem;">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Money Pages KPI Tracker (last 28 days)</h3>
                <p class="card-subtitle" style="margin: 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
                  Weekly KPI trends by money-page segment (All, Landing, Event, Product) calculated from actual Google Search Console data for the last 28 days.
                </p>
              </div>

              <div class="controls-row" style="margin-bottom: 1.5rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem;" title="Select which metric to display in the KPI tracker chart and table. CTR shows click-through rate, Impressions shows search visibility, Clicks shows actual traffic, and Avg position shows average ranking.">
                  Metric:
                  <select id="money-kpi-metric-select" style="padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px;" title="Select which metric to display in the KPI tracker chart and table. CTR shows click-through rate, Impressions shows search visibility, Clicks shows actual traffic, and Avg position shows average ranking.">
                    <option value="ctr">CTR</option>
                    <option value="impressions">Impressions</option>
                    <option value="clicks">Clicks</option>
                    <option value="avgPosition">Avg position</option>
                  </select>
                </label>
              </div>

              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                <div class="sparkline-wrapper" style="height: 400px; width: 100%;">
                  <canvas id="money-kpi-sparkline" style="width: 100% !important;"></canvas>
                </div>

                <div class="table-wrapper" style="overflow-x: auto; max-width: 100%; width: 100%;">
                  <table id="money-kpi-table" style="width: max-content; min-width: 100%; border-collapse: collapse; table-layout: fixed;">
                    <thead>
                      <tr id="money-kpi-header-row" style="background: #f1f5f9;">
                        <!-- Filled by JS -->
                      </tr>
                    </thead>
                    <tbody>
                      <!-- JS rows -->
                    </tbody>
                  </table>
                </div>
              </div>
            </section>
            
            <!-- Phase: Money Pages Priority Matrix + Action List -->
            <section id="money-pages-priority-card" class="card card--full" style="margin-top: 2rem; background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div class="card-header" style="margin-bottom: 1rem;">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Money Pages  Priority & Actions</h3>
                <p class="card-subtitle" style="margin: 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
                  Landing, event and product pages that drive revenue. Triaged by impact, difficulty and priority.
                </p>
              </div>

              <!-- Summary strip -->
              <div class="summary-strip" id="money-pages-summary-strip" style="display: flex; gap: 2rem; padding: 1rem; background: #f8fafc; border-radius: 4px; margin-bottom: 1.5rem;">
                <!-- Filled by JS -->
              </div>

              <!-- Controls -->
              <div class="controls-row" style="display: flex; gap: 1.5rem; margin-bottom: 1.5rem; align-items: center;">
                <label style="display: flex; align-items: center; gap: 0.5rem;" title="Filter money pages by segment type. Landing pages are collection/category pages, Event pages are workshop/event listings, Product pages are service/product offerings.">
                  Page type:
                  <select id="money-pages-type-filter" style="padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px;" title="Filter money pages by segment type. Landing pages are collection/category pages, Event pages are workshop/event listings, Product pages are service/product offerings.">
                    <option value="all" id="money-pages-type-all">All money pages</option>
                    <option value="authority" id="money-pages-type-authority">Authority</option>
                    <option value="landing" id="money-pages-type-landing">Landing pages</option>
                    <option value="event" id="money-pages-type-event">Event pages</option>
                    <option value="product" id="money-pages-type-product">Product pages</option>
                  </select>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem;" title="Filter out pages with fewer impressions than this threshold. Helps focus on pages with meaningful search visibility.">
                  Min impressions:
                  <input type="number" id="money-pages-min-impr" value="10" min="0" step="10" style="padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px; width: 120px;" title="Filter out pages with fewer impressions than this threshold. Helps focus on pages with meaningful search visibility.">
                </label>
              </div>

              <div class="matrix-and-table" style="display: grid; grid-template-columns: 1fr 2fr; gap: 2rem;">
                <div class="priority-matrix" id="money-pages-matrix" style="background: #f8fafc; padding: 1rem; border-radius: 8px;">
                  <!-- 3x3 grid rendered by JS -->
                </div>

                <div class="priority-table-wrapper" style="overflow-x: auto;">
                  <table id="money-pages-priority-table" style="width: 100%; border-collapse: collapse;">
                    <thead>
                      <tr style="background: #f1f5f9;">
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="The URL of the money page. Click to open in a new tab.">Page</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Segment type: Landing (collection/category pages), Event (workshop/event listings), or Product (service/product offerings).">Type</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Priority level (HIGH/MEDIUM/LOW) based on impact and difficulty. HIGH priority = high impact + low/medium difficulty. Click column header to sort.">Priority</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Impact level based on lost clicks (expected CTR minus actual CTR). HIGH = significant opportunity to improve clicks. Click column header to sort.">Impact</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Difficulty level based on current ranking position and schema effort required. LOW = easy to improve, HIGH = requires more work. Click column header to sort.">Difficulty</th>
                        <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;" title="Click-through rate: percentage of impressions that resulted in clicks. Higher is better. Click column header to sort.">CTR</th>
                        <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;" title="Total impressions: number of times this page appeared in search results. Click column header to sort.">Impr.</th>
                        <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;" title="Average position: average ranking position in search results (1 = best, lower numbers are better). Click column header to sort.">Avg pos.</th>
                        <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;" title="Recommended action based on priority level. HIGH = Fix CTR & strengthen content, MEDIUM = Improve SERP snippet & schema, LOW = Monitor & maintain.">Action</th>
                      </tr>
                    </thead>
                    <tbody>
                      <!-- JS rows -->
                    </tbody>
                  </table>
                  <div id="money-pages-priority-pagination"></div>
                  <button id="money-pages-copy-urls-btn" type="button" class="btn btn-small" style="margin-top: 1rem;" title="Copy all filtered page URLs to clipboard. URLs are copied one per line, ready to paste into spreadsheets or other tools.">Copy URLs</button>
                </div>
              </div>
            </section>
            
            <p class="card-footnote" style="margin-top: 1rem; font-size: 0.85rem; color: #666;">
              Based on the current audit date range and money-page segment only.
              Categories and actions are data-driven and will update each time you run a new audit.
            </p>
          </div>
        `;
        
        // Insert section if it's not already in the DOM
        if (!moneyPagesSection.parentNode) {
          // Insert after Top Pages section (try multiple insertion points)
          let inserted = false;
          // Insert into money panel
          const moneyPanel = document.querySelector('.aigeo-panel[data-panel="money"]');
          if (moneyPanel) {
            moneyPanel.appendChild(moneyPagesSection);
            inserted = true;
            debugLog(' Money Pages section inserted into money panel', 'success');
          } else {
            // Fallback: insert after pillar cards (old behavior)
            const pillarCards = document.getElementById('pillarCards');
            if (pillarCards && pillarCards.parentNode) {
              pillarCards.parentNode.insertBefore(moneyPagesSection, pillarCards.nextSibling);
              inserted = true;
              debugLog(' Money Pages section inserted after pillar cards (fallback)', 'success');
            }
          }
          
          if (!inserted) {
            debugLog(' Money Pages section could not be inserted - no insertion point found', 'warn');
            // Still try to render even if insertion failed (section might be in DOM already)
          }
        } else {
          debugLog(' Money Pages section already in DOM, content updated', 'info');
        }
        
        // Always render money pages section (will show "No data" if empty)
        // Get Money Pages metrics - prioritize passed scores, then saved data, then global
        let moneyPagesMetricsToRender = scores.moneyPagesMetrics || window.currentMoneyPagesMetrics || window.moneyPagesMetrics;
        
        if (!moneyPagesMetricsToRender && saved) {
          // Try multiple locations in saved data
          if (saved.scores && saved.scores.moneyPagesMetrics) {
            debugLog('Money Pages: Loading from saved.scores.moneyPagesMetrics', 'info');
          moneyPagesMetricsToRender = saved.scores.moneyPagesMetrics;
            scores.moneyPagesMetrics = moneyPagesMetricsToRender;
          } else if (saved.moneyPagesMetrics) {
            debugLog('Money Pages: Loading from saved.moneyPagesMetrics', 'info');
            moneyPagesMetricsToRender = saved.moneyPagesMetrics;
          scores.moneyPagesMetrics = moneyPagesMetricsToRender;
          }
        }
        
        // Store globally for other functions
        if (moneyPagesMetricsToRender) {
          window.currentMoneyPagesMetrics = moneyPagesMetricsToRender;
          window.moneyPagesMetrics = moneyPagesMetricsToRender;
          debugLog(` Money Pages metrics stored globally: ${moneyPagesMetricsToRender.rows?.length || 0} rows`, 'success');
        }
        
        debugLog(`Money Pages Metrics available: ${moneyPagesMetricsToRender ? 'yes' : 'no'}`, 'info');
        if (moneyPagesMetricsToRender) {
          debugLog(`Money Pages: Rendering ${moneyPagesMetricsToRender.rows?.length || 0} money pages`, 'info');
          if (moneyPagesMetricsToRender.rows && moneyPagesMetricsToRender.rows.length > 0) {
            debugLog(`Money Pages: First row sample: ${JSON.stringify(moneyPagesMetricsToRender.rows[0]).substring(0, 100)}...`, 'info');
          } else {
            debugLog(' Money Pages: moneyPagesMetrics exists but has no rows', 'warn');
          }
        } else {
          debugLog(' Money Pages: No metrics data available, will show "No data" message', 'warn');
          debugLog(`Money Pages: scores.moneyPagesMetrics=${!!scores.moneyPagesMetrics}, saved.scores.moneyPagesMetrics=${!!(saved && saved.scores && saved.scores.moneyPagesMetrics)}, saved.moneyPagesMetrics=${!!(saved && saved.moneyPagesMetrics)}`, 'warn');
        }
        
        // Ensure section exists before rendering (retry if needed)
        let sectionExists = document.getElementById('money-pages-section');
        if (!sectionExists) {
          debugLog(' Money Pages section not found, waiting 50ms and retrying...', 'warn');
          setTimeout(() => {
            sectionExists = document.getElementById('money-pages-section');
            if (sectionExists) {
              debugLog(' Money Pages section found on retry, rendering...', 'success');
              renderMoneyPagesSection(moneyPagesMetricsToRender || null);
            } else {
              debugLog(' Money Pages section still not found after retry', 'error');
            }
          }, 50);
        } else {
          renderMoneyPagesSection(moneyPagesMetricsToRender || null);
        }

        // Ensure top-level filter is wired after any re-render of this section
        if (typeof window.wireTopLevelFilter === 'function') {
          setTimeout(() => window.wireTopLevelFilter(), 0);
        }
        
        // Phase: Render Money Pages Priority Matrix & Action List
        const priorityCard = document.getElementById('money-pages-priority-card');
        if (priorityCard) {
          if (window.moneyPagePriorityData && Array.isArray(window.moneyPagePriorityData) && window.moneyPagePriorityData.length > 0) {
            priorityCard.style.display = 'block';
            
            // Initialize state for matrix filter
            window.moneyMatrixFilterState = window.moneyMatrixFilterState || { impact: null, diff: null };

            // Domain-level authority actions (read-only; from Supabase domain_strength_snapshots via /api/actions)
            window.authorityActionRows = window.authorityActionRows || [];
            if (typeof window.refreshAuthorityActionsForMoneyPages !== 'function') {
              window.refreshAuthorityActionsForMoneyPages = async function refreshAuthorityActionsForMoneyPages() {
                try {
                  const resp = await fetch('/api/actions');
                  const json = await resp.json();
                  const actions = resp.ok && json && json.status === 'ok' && Array.isArray(json.actions) ? json.actions : [];

                  const toUpperLevel = (v, fallback) => {
                    const s = String(v || '').toUpperCase();
                    return s === 'HIGH' || s === 'MEDIUM' || s === 'LOW' ? s : fallback;
                  };

                  window.authorityActionRows = actions
                    .filter(a => a && a.type === 'authority' && a.level === 'domain' && a.domain)
                    .map(a => ({
                      url: `https://${String(a.domain).replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0]}`,
                      title: a.title || 'Build domain authority',
                      segmentType: 'authority',
                      clicks: 0,
                      impressions: 0,
                      ctr: 0,
                      avgPosition: null,
                      impactLevel: toUpperLevel(a.impact, 'LOW'),
                      difficultyLevel: toUpperLevel(a.difficulty, 'HIGH'),
                      priorityLevel: toUpperLevel(a.priority, 'LOW'),
                      _authorityMeta: {
                        domain: a.domain,
                        segment: a.segment || null,
                        score: a.metrics && typeof a.metrics.domainStrengthScore === 'number' ? a.metrics.domainStrengthScore : null,
                        band: a.metrics && typeof a.metrics.domainStrengthBand === 'string' ? a.metrics.domainStrengthBand : null
                      }
                    }));
                } catch (e) {
                  // Non-fatal: keep existing authorityActionRows (or empty).
                  window.authorityActionRows = window.authorityActionRows || [];
                }
              };
            }
            
            // Helper function to get filtered pages based on current filters (defined before use)
            const getFilteredPages = () => {
              const typeFilter = document.getElementById('money-pages-type-filter')?.value || 'all';
              const minImpr = Number(document.getElementById('money-pages-min-impr')?.value) || 0;
              
              const base = (window.moneyPagePriorityData || []).slice();
              const authority = (window.authorityActionRows || []).slice();
              let filtered = base.concat(authority);
              
              // Apply type filter
              if (typeFilter !== 'all') {
                filtered = filtered.filter(p => p.segmentType === typeFilter);
              }
              
              // Apply min impressions filter
              filtered = filtered.filter(p => p.segmentType === 'authority' || (p.impressions || 0) >= minImpr);
              
              return filtered;
            };
            
            // Helper function to update summary strip, matrix, and table
            const updateMatrixAndTable = () => {
              const typeFilter = document.getElementById('money-pages-type-filter')?.value || 'all';
              const minImpr = Number(document.getElementById('money-pages-min-impr')?.value) || 0;
              
              // Get base data for counting (before type filter, but after min impressions)
              const base = (window.moneyPagePriorityData || []).slice();
              const authority = (window.authorityActionRows || []).slice();
              const allRows = base.concat(authority);
              
              // Apply min impressions filter for counting (but not type filter)
              const pagesForCounting = allRows.filter(p => p.segmentType === 'authority' || (p.impressions || 0) >= minImpr);
              
              // Update dropdown counts with filtered data (after min impressions, before type filter)
              updateMoneyPagesTypeFilterCounts(pagesForCounting);
              
              // Now get fully filtered pages (with type filter applied)
              const filteredPages = getFilteredPages();
              
              debugLog(`Money Pages Update: Filtered to ${filteredPages.length} pages (type: ${typeFilter}, minImpr: ${minImpr})`, 'info');
              
              // Reset pagination to page 1 when filters change
              window.moneyPagesPriorityCurrentPage = 1;
              
              // Re-render summary strip with filtered pages
              const pagesOnly = filteredPages.filter(p => p.segmentType !== 'authority');
              const summaryStrip = document.getElementById('money-pages-summary-strip');
              if (summaryStrip && typeof renderMoneyPagesSummaryStrip === 'function') {
                renderMoneyPagesSummaryStrip(pagesOnly, data || {}, summaryStrip);
              }
              
              // Re-render matrix with filtered pages
              const matrixEl = document.getElementById('money-pages-matrix');
              if (matrixEl && typeof renderMoneyPagesMatrix === 'function') {
                renderMoneyPagesMatrix(
                  pagesOnly,
                  matrixEl,
                  (impact, diff) => {
                    window.moneyMatrixFilterState = { impact, diff };
                    window.moneyPagesPriorityCurrentPage = 1; // Reset pagination when matrix cell clicked
                    debugLog(`Money Pages Matrix: Cell clicked - Impact: ${impact}, Difficulty: ${diff}`, 'info');
                    // Re-render matrix to show active state
                    updateMatrixAndTable();
                  },
                  window.moneyMatrixFilterState
                );
              }
              
              // Store filter state globally for pagination
              window.moneyPagesTypeFilter = typeFilter;
              window.moneyPagesMinImpr = minImpr;
              window.moneyPagesMatrixFilter = window.moneyMatrixFilterState;
              
              // Re-render table with filters
              if (typeof renderMoneyPagesTable === 'function') {
                renderMoneyPagesTable(filteredPages, {
                  typeFilter: typeFilter,
                  minImpr: minImpr,
                  matrixFilter: window.moneyMatrixFilterState
                });
              }
            };
            
            // Render summary strip
            const summaryStrip = document.getElementById('money-pages-summary-strip');
            if (summaryStrip) {
              renderMoneyPagesSummaryStrip(window.moneyPagePriorityData, data || {}, summaryStrip);
            }
            
            // Render matrix initially
            const matrixEl = document.getElementById('money-pages-matrix');
            if (matrixEl && typeof renderMoneyPagesMatrix === 'function') {
              renderMoneyPagesMatrix(
                window.moneyPagePriorityData,
                matrixEl,
                (impact, diff) => {
                  window.moneyMatrixFilterState = { impact, diff };
                  debugLog(`Money Pages Matrix: Cell clicked - Impact: ${impact}, Difficulty: ${diff}`, 'info');
                  updateMatrixAndTable();
                },
                null // No active filter initially
              );
            }
            
            // Initialize filter state
            window.moneyPagesTypeFilter = 'all';
            window.moneyPagesMinImpr = 1000;
            window.moneyPagesMatrixFilter = null;
            
            // Render initial table
            if (typeof renderMoneyPagesTable === 'function') {
              renderMoneyPagesTable(window.moneyPagePriorityData, {
                typeFilter: 'all',
                minImpr: 1000,
                matrixFilter: null
              });
            }

            // Load authority actions async and refresh table (non-blocking).
            window.refreshAuthorityActionsForMoneyPages()
              .then(() => {
                updateMatrixAndTable();
              })
              .catch(() => {
                // ignore
              });
            
            // Wire up filter controls (functions already defined above)
            const typeFilter = document.getElementById('money-pages-type-filter');
            const minImprFilter = document.getElementById('money-pages-min-impr');
            
            if (typeFilter) {
              typeFilter.addEventListener('change', () => {
                const selectedType = typeFilter.value;
                debugLog(`Money Pages Filter: Type changed to "${selectedType}"`, 'info');
                // Store filter state globally for pagination
                window.moneyPagesTypeFilter = selectedType;
                // Clear matrix filter when type filter changes
                window.moneyMatrixFilterState = { impact: null, diff: null };
                window.moneyPagesMatrixFilter = null;
                updateMatrixAndTable();
              });
            }
            
            if (minImprFilter) {
              minImprFilter.addEventListener('change', () => {
                const minImpr = Number(minImprFilter.value) || 0;
                debugLog(`Money Pages Filter: Min impressions changed to ${minImpr}`, 'info');
                // Store filter state globally for pagination
                window.moneyPagesMinImpr = minImpr;
                // Clear matrix filter when min impressions filter changes
                window.moneyMatrixFilterState = { impact: null, diff: null };
                window.moneyPagesMatrixFilter = null;
                updateMatrixAndTable();
              });
            }
          } else {
            // Show card but with "no data" message
            priorityCard.style.display = 'block';
            const summaryStrip = document.getElementById('money-pages-summary-strip');
            if (summaryStrip) {
              summaryStrip.innerHTML = '<div style="padding: 1rem; text-align: center; color: #64748b;">No money pages data available. Run an audit to generate priority matrix data.</div>';
            }
            const matrixEl = document.getElementById('money-pages-matrix');
            if (matrixEl) {
              matrixEl.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b;">No data available</div>';
            }
            const tbody = document.querySelector('#money-pages-priority-table tbody');
            if (tbody) {
              tbody.innerHTML = '<tr><td colspan="9" style="padding: 2rem; text-align: center; color: #64748b;">No money pages data available. Run an audit to generate priority matrix data.</td></tr>';
            }
            debugLog(' Money Pages Priority Matrix: No data available', 'warn');
          }
        }
        
        // Phase: Load and render 12-month KPI Tracker
        const propertyUrl = document.getElementById('propertyUrl')?.value || localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url');
        if (propertyUrl) {
          loadAuditHistoryAndRenderKpis(propertyUrl);
          
          // Wire up metric selector
          const metricSelect = document.getElementById('money-kpi-metric-select');
          if (metricSelect) {
            metricSelect.addEventListener('change', (e) => {
              const metricKey = e.target.value;
              if (cachedAuditHistory) {
                const historyData = buildMoneyKpiHistory(cachedAuditHistory, metricKey);
                renderMoneyKpiTable(historyData, metricKey);
                renderMoneyKpiSparkline(historyData, metricKey);
              }
            });
          }
        }
        
        // Store queryPages globally for filtering
        // Use data parameter (searchData) first, then fallback to saved data
        if (data && data.queryPages) {
          window.currentQueryPages = data.queryPages;
        } else if (saved && saved.searchData && saved.searchData.queryPages) {
          window.currentQueryPages = saved.searchData.queryPages;
        }
        // Render behaviour KPIs and chart after a delay to ensure DOM and Chart.js are ready
        // Apply filters and update all sections with filtered data
        if (moneyPagesMetricsToRender) {
          setTimeout(() => {
            const queryPages = window.currentQueryPages || null;
            const moneyPagesMetrics = moneyPagesMetricsToRender;
            
            // Use saved behaviour data if available (from Supabase/localStorage)
            let savedBehaviour = null;
            if (moneyPagesMetrics && moneyPagesMetrics.behaviour) {
              savedBehaviour = moneyPagesMetrics.behaviour;
              debugLog(` Using saved behaviour data: score=${savedBehaviour.score}, impressions=${savedBehaviour.impressions}`, 'info');
            }
            
            // Get filtered metrics based on current filters (defaults to 'ALL' on initial load)
            const filteredMetrics = getFilteredMoneyPagesMetrics(moneyPagesMetrics);
            if (filteredMetrics) {
              // Try to recalculate behaviour for filtered pages, but use saved if calculation fails
              const filteredRows = filteredMetrics.rows || [];
              let filteredBehaviour = null;
              
              if (window.computeMoneyPagesBehaviour && queryPages && filteredRows.length > 0) {
                filteredBehaviour = window.computeMoneyPagesBehaviour(queryPages, filteredRows, true);
                debugLog(` Recalculated behaviour for filtered pages: ${!!filteredBehaviour}, impressions=${filteredBehaviour?.impressions || 0}`, 'info');
              }
              
              // Use saved behaviour as fallback if recalculation failed or returned no data
              if (!filteredBehaviour || !filteredBehaviour.impressions) {
                if (savedBehaviour && savedBehaviour.impressions) {
                  debugLog(` Using saved behaviour as fallback (recalculation had no data)`, 'info');
                  filteredBehaviour = savedBehaviour;
                }
              }
              
              // Update all sections with filtered data
              renderMoneyPagesBehaviourKpis(filteredBehaviour, filteredMetrics, queryPages);
              updateMoneyPagesSummaryMetrics(moneyPagesMetrics); // Pass original metrics so function can apply filters internally
              updateMoneyPagesChartSummary(filteredMetrics);
              
              // Render chart with filtered data
              // Always re-render chart to ensure it uses current filters
                renderMoneyPagesCategoryChart(moneyPagesMetrics, 0);
            } else {
              // Fallback: render with unfiltered data if filtering fails
              renderMoneyPagesBehaviourKpis(savedBehaviour || moneyPagesMetrics.behaviour, moneyPagesMetrics, queryPages);
              if (!moneyPagesCategoryChart) {
                renderMoneyPagesCategoryChart(moneyPagesMetrics, 0);
              }
            }
          }, 200);
        }
      }, 100);
      
      // Remove existing scorecard table if it exists
      const existingScorecard = pillarCards.parentNode.querySelector('.scorecard-section');
      if (existingScorecard) {
        existingScorecard.remove();
      }
      
      // Function to render segment comparison table (shared by both createTopPagesSection functions)
      function renderSegmentComparisonTable(authorityBySegment, currentMode) {
        const segments = [
          { key: 'all', label: 'All pages', data: authorityBySegment.all },
          { key: 'nonEducation', label: 'Exclude education (blogs / free course)', data: authorityBySegment.nonEducation },
          { key: 'money', label: 'Money pages only', data: authorityBySegment.money }
        ];
        
        let tableHtml = `
          <div style="margin-bottom: 0.5rem;">
            <h4 style="margin: 0 0 0.5rem 0; font-size: 1.15rem; font-weight: 700; color: #1e293b;">Segment overview (CTR & ranking)</h4>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.95rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Segment</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Site CTR</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Top-10 CTR</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Avg pos.</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Top-10 share</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Behaviour</th>
                  <th style="text-align: right; padding: 0.75rem 1rem; font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">Ranking</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        segments.forEach(({ key, label, data }, idx) => {
          const isActive = key === currentMode;
          const siteCtr = data?.siteCtr || 0;
          const top10Ctr = data?.top10Ctr || 0;
          const avgPosition = data?.avgPosition || 0;
          const top10Share = (data?.top10Share || 0) * 100;
          const behaviourScore = data?.behaviour || 0;
          const rankingScore = data?.ranking || 0;
          
          tableHtml += `
            <tr 
              onclick="window.currentAuthorityMode = '${key}'; if(window.updateTopPagesSection) window.updateTopPagesSection('${key}');"
              style="
                cursor: pointer;
                border-bottom: 1px solid #f1f5f9;
                background: ${isActive ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : (idx % 2 === 0 ? '#ffffff' : '#fafafa')};
                transition: all 0.2s;
              "
              onmouseover="this.style.background='${isActive ? 'linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%)' : '#f8f9fa'}';"
              onmouseout="this.style.background='${isActive ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : (idx % 2 === 0 ? '#ffffff' : '#fafafa')}';"
            >
              <td style="padding: 0.75rem 1rem; font-weight: ${isActive ? '600' : '500'}; color: #0f172a; font-size: 0.95rem;">
                ${label}
                ${isActive ? '<span style="margin-left: 0.5rem; font-size: 0.8rem; padding: 0.15rem 0.5rem; border-radius: 999px; background: #10b981; color: white; font-weight: 600;">current</span>' : ''}
              </td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${siteCtr != null ? siteCtr.toFixed(1) : 'N/A'}%</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${top10Ctr != null ? top10Ctr.toFixed(1) : 'N/A'}%</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${avgPosition != null ? avgPosition.toFixed(1) : 'N/A'}</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 500; font-size: 0.95rem;">${top10Share != null ? top10Share.toFixed(1) : 'N/A'}%</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 0.95rem;">${behaviourScore != null ? Math.round(behaviourScore) : 'N/A'}</td>
              <td style="padding: 0.75rem 1rem; text-align: right; color: #0f172a; font-weight: 600; font-size: 0.95rem;">${rankingScore != null ? Math.round(rankingScore) : 'N/A'}</td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        return tableHtml;
      }
      
      // Function to create Top Pages section (full width, below pillar cards)
      function createTopPagesSection(scores, saved) {
        // Get Authority segment data from current scores (latest snapshot, not historical)
        // This uses the most recent audit data, not historical Supabase data
        const authorityObj = scores?.authority;
        let authorityBySegment = (typeof authorityObj === 'object' && authorityObj !== null) 
          ? authorityObj.bySegment 
          : null;
        
        // If no segment data in scores, try to get from saved audit (latest audit data from localStorage)
        if (!authorityBySegment && saved) {
          const savedScores = saved.scores;
          if (savedScores && savedScores.authority) {
            const savedAuthorityObj = savedScores.authority;
            if (typeof savedAuthorityObj === 'object' && savedAuthorityObj !== null) {
              authorityBySegment = savedAuthorityObj.bySegment || null;
              debugLog(' Top Pages: Using Authority segment data from saved audit (latest snapshot)', 'info');
            }
          }
        }
        
        if (!authorityBySegment) {
          debugLog(' No Authority segment data available for Top Pages table. This requires GSC queryPages data from your most recent audit.', 'warn');
          // Still create the section but show a helpful message - don't return early
        }
        
        // Remove existing top pages section if it exists
        const existingTopPages = document.getElementById('authority-top-pages-section');
        if (existingTopPages) {
          existingTopPages.remove();
        }
        
        // Create new section
        const topPagesSection = document.createElement('div');
        topPagesSection.id = 'authority-top-pages-section';
        topPagesSection.className = 'section-break';
        topPagesSection.style.marginTop = '2rem';
        topPagesSection.style.marginBottom = '2rem';
        
        // Get current mode from Authority card toggle (default to 'all')
        let currentMode = 'all';
        const authorityCard = Array.from(document.querySelectorAll('.pillar-card')).find(card => {
          const h3 = card.querySelector('h3');
          return h3 && h3.textContent === 'Authority';
        });
        
        if (authorityCard && authorityCard._authorityMode) {
          currentMode = authorityCard._authorityMode;
        }
        
        // Get top pages for current mode
        const topPages = currentMode === 'all'
          ? (authorityBySegment?.all?.topPages || [])
          : currentMode === 'nonEducation'
          ? (authorityBySegment?.nonEducation?.topPages || [])
          : (authorityBySegment?.money?.topPages || []);
        
        const segmentLabel = currentMode === 'all'
          ? 'All pages'
          : currentMode === 'nonEducation'
          ? 'Exclude education (blogs / free course)'
          : 'Money pages only';
        
        // Get segment metrics for summary display
        const getSegmentSummary = (mode) => {
          if (!authorityBySegment || !authorityBySegment[mode]) return null;
          const segmentData = authorityBySegment[mode];
          return {
            behaviour: segmentData.behaviour || 0,
            ranking: segmentData.ranking || 0,
            total: segmentData.total || segmentData.score || 0
          };
        };
        
        const currentSummary = getSegmentSummary(currentMode);
        const rag = currentSummary ? getRAGStatus(currentSummary.total) : { status: 'amber', label: 'N/A' };
        
        // Get date range for display
        const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
        const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
        
        // Get brand queries for mini-table
        const topQueries = saved?.searchData?.topQueries || [];
        const brandQueries = topQueries
          .filter(q => isBrandQuery(q.query || ''))
          .sort((a, b) => (b.impressions || 0) - (a.impressions || 0))
          .slice(0, 10);
        
        // Create section HTML with improved styling and pastel background
        topPagesSection.innerHTML = `
          <div style="background: #F5F0F5; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border-left: 4px solid #99004C;">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem;">
              <div style="flex: 1;">
                <h3 style="margin: 0 0 0.5rem 0; color: var(--brand-dark); font-size: 1.25rem; font-weight: 700;">Authority - Behaviour & Ranking</h3>
                <div style="margin-bottom: 1rem; padding: 1rem; background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-radius: 6px; font-size: 0.85rem; line-height: 1.6; color: #555; border-left: 3px solid #99004C;">
                  <p style="margin: 0 0 0.75rem 0;"><strong style="color: #99004C;">Behaviour:</strong> Measures click-through rate (CTR) performance. Combines Overall CTR (50% weight) for all ranking search terms and Top-10 Ranked Search Terms CTR (50% weight) for queries ranking in positions 1-10. Indicates how well your titles and descriptions convert impressions to clicks. Data source: Google Search Console query+page metrics.</p>
                  <p style="margin: 0;"><strong style="color: #99004C;">Ranking:</strong> Measures search visibility and position quality. Combines Average Position Score (50% weight) and Top-10 Impression Share (50% weight). Shows how high you rank on average and what percentage of impressions appear in positions 1-10. Data source: Google Search Console query+page metrics.</p>
                </div>
              </div>
            </div>
            
            ${currentSummary ? `
            <div style="margin-bottom: 1rem; padding: 1rem; background: rgba(221, 160, 221, 0.2); border-radius: 6px; border: 1px solid #e2e8f0;">
              <div style="text-align: center; margin-bottom: 0.75rem;">
                <span style="font-weight: 600; color: #333; font-size: 1.08rem;">Segment Summary: </span>
                <span id="top-pages-segment-label" style="color: #666; font-size: 0.85rem; padding: 0.25rem 0.75rem; background: #f1f5f9; border-radius: 4px;">${segmentLabel}</span>
              </div>
              <div style="display: flex; justify-content: center; align-items: center; gap: 1.5rem; flex-wrap: wrap;">
                <div id="top-pages-segment-summary" style="display: flex; align-items: center; gap: 1.5rem; font-size: 1rem;">
                  ${formatComponentScore('Behaviour', currentSummary.behaviour)}
                  ${formatComponentScore('Ranking', currentSummary.ranking)}
                </div>
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                  <span style="font-size: 1.5rem; font-weight: 700; color: ${rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444'};">${Math.round(currentSummary.total)}</span>
                  <span class="rag-badge ${rag.status}" style="display: inline-block; padding: 0.35rem 0.85rem; border-radius: 4px; font-size: 0.85rem; font-weight: 600;">${rag.label}</span>
                </div>
              </div>
            </div>
            ` : `
            <div style="margin-bottom: 1rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem;">
              <span style="font-weight: 600; color: #666;">Current Segment:</span>
              <span id="top-pages-segment-label" style="color: #333; margin-left: 0.5rem;">${segmentLabel}</span>
            </div>
            `}
            
            ${authorityBySegment ? `
            <div style="margin-bottom: 1rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem;">
              <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                <span style="font-weight: 600; color: #666;">View:</span>
                <button id="top-pages-mode-all" class="authority-mode-btn" data-mode="all" style="padding: 0.35rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: ${currentMode === 'all' ? '#10b981' : 'white'}; color: ${currentMode === 'all' ? 'white' : '#666'}; cursor: pointer; font-size: 0.75rem; font-weight: ${currentMode === 'all' ? '600' : '400'}; transition: all 0.2s;">
                  All pages
                </button>
                <button id="top-pages-mode-nonEducation" class="authority-mode-btn" data-mode="nonEducation" style="padding: 0.35rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: ${currentMode === 'nonEducation' ? '#10b981' : 'white'}; color: ${currentMode === 'nonEducation' ? 'white' : '#666'}; cursor: pointer; font-size: 0.75rem; font-weight: ${currentMode === 'nonEducation' ? '600' : '400'}; transition: all 0.2s;">
                  Exclude education
                </button>
                <button id="top-pages-mode-money" class="authority-mode-btn" data-mode="money" style="padding: 0.35rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: ${currentMode === 'money' ? '#10b981' : 'white'}; color: ${currentMode === 'money' ? 'white' : '#666'}; cursor: pointer; font-size: 0.75rem; font-weight: ${currentMode === 'money' ? '600' : '400'}; transition: all 0.2s;">
                  Money pages only
                </button>
              </div>
            </div>
            ` : ''}
            
            ${authorityBySegment ? `
            <div id="top-pages-comparison-table" style="margin-bottom: 1.5rem;">
              ${renderSegmentComparisonTable(authorityBySegment, currentMode)}
            </div>
            ` : ''}
            
            <div id="top-pages-table-container">
              ${renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText)}
            </div>
            
            ${authorityBySegment && authorityBySegment[currentMode] ? `
            <div id="top-pages-recommendations-container" style="margin-top: 2rem;">
              ${renderRecommendationsTable(currentMode, {
                siteCtr: authorityBySegment[currentMode].siteCtr || 0,
                top10Ctr: authorityBySegment[currentMode].top10Ctr || 0,
                avgPosition: authorityBySegment[currentMode].avgPosition || 0,
                top10Share: authorityBySegment[currentMode].top10Share || 0,
                behaviourScore: authorityBySegment[currentMode].behaviour || 0,
                rankingScore: authorityBySegment[currentMode].ranking || 0
              }, segmentLabel, dateRangeText)}
            </div>
            ` : ''}
            
            ${brandQueries.length > 0 ? `
            <div style="margin-top: 2rem; padding: 1rem; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #f59e0b;">
              <h4 style="margin: 0 0 0.75rem 0; color: #92400e; font-size: 1rem; font-weight: 600;">Top Branded Queries</h4>
              <p style="margin: 0 0 1rem 0; font-size: 0.85rem; color: #666; line-height: 1.5;">Branded search queries (e.g., "Alan Ranger Photography") with CTR and position metrics.</p>
              <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                  <thead>
                    <tr style="background: #e5e7eb; border-bottom: 2px solid #d1d5db;">
                      <th style="padding: 0.5rem; text-align: left; font-weight: 600; color: #374151;">Query</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Impressions</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Clicks</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">CTR</th>
                      <th style="padding: 0.5rem; text-align: right; font-weight: 600; color: #374151;">Position</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${brandQueries.map((q, idx) => {
                      const ctr = q.impressions > 0 ? ((q.clicks || 0) / q.impressions * 100) : 0;
                      const ctrColor = ctr >= 25 ? '#10b981' : ctr >= 10 ? '#f59e0b' : '#ef4444';
                      const posColor = (q.position || 0) <= 3 ? '#10b981' : (q.position || 0) <= 5 ? '#f59e0b' : '#ef4444';
                      return `
                      <tr style="border-bottom: 1px solid #e5e7eb; ${idx % 2 === 0 ? 'background: #ffffff;' : 'background: #f9fafb;'}">
                        <td style="padding: 0.5rem; color: #1f2937; font-weight: 500;">${(q.query || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</td>
                        <td style="padding: 0.5rem; text-align: right; color: #6b7280;">${(q.impressions || 0).toLocaleString()}</td>
                        <td style="padding: 0.5rem; text-align: right; color: #6b7280;">${(q.clicks || 0).toLocaleString()}</td>
                        <td style="padding: 0.5rem; text-align: right; color: ${ctrColor}; font-weight: 600;">${ctr.toFixed(1)}%</td>
                        <td style="padding: 0.5rem; text-align: right; color: ${posColor}; font-weight: 600;">${(q.position || 0).toFixed(1)}</td>
                      </tr>
                    `;
                    }).join('')}
                  </tbody>
                </table>
              </div>
            </div>
            ` : ''}
          </div>
        `;
        
        // Insert into Authority panel instead of Overview
        const authorityPanel = document.querySelector('.aigeo-panel[data-panel="authority"]');
        if (authorityPanel) {
          // Clear any existing content
          const existing = document.getElementById('authority-top-pages-section');
          if (existing) existing.remove();
          authorityPanel.appendChild(topPagesSection);
          debugLog(' Authority section inserted into Authority panel', 'success');
        } else {
          // Fallback: insert after pillar cards (old behavior)
        pillarCards.parentNode.insertBefore(topPagesSection, pillarCards.nextSibling);
          debugLog(' Authority section inserted after pillar cards (fallback)', 'info');
        }
        
        // Store authorityBySegment globally so updateTopPagesSection can access it
        window.authorityBySegment = authorityBySegment;
        
        // Attach toggle button handlers
        setTimeout(() => {
          ['all', 'nonEducation', 'money'].forEach(mode => {
            const btn = document.getElementById(`top-pages-mode-${mode}`);
            if (btn) {
              // Remove existing listeners by cloning
              const newBtn = btn.cloneNode(true);
              btn.parentNode.replaceChild(newBtn, btn);
              
              newBtn.addEventListener('click', () => {
                window.currentAuthorityMode = mode;
                if (window.updateTopPagesSection) {
                  window.updateTopPagesSection(mode);
                }
                // Also update Authority pillar card if it exists
                const authorityCard = Array.from(document.querySelectorAll('.pillar-card')).find(card => {
                  const h3 = card.querySelector('h3');
                  return h3 && h3.textContent === 'Authority';
                });
                if (authorityCard && authorityCard._updateAuthorityDisplay) {
                  authorityCard._authorityMode = mode;
                  authorityCard._updateAuthorityDisplay();
                  // Update Authority pillar toggle buttons
                  const modeId = authorityCard._modeId;
                  ['all', 'nonEducation', 'money'].forEach(m => {
                    const authBtn = document.getElementById(`${modeId}-${m}`);
                    if (authBtn) {
                      if (m === mode) {
                        authBtn.style.background = '#10b981';
                        authBtn.style.color = 'white';
                      } else {
                        authBtn.style.background = 'white';
                        authBtn.style.color = '#666';
                      }
                    }
                  });
                }
              });
            }
          });
        }, 100);
        
        // Store update function globally so Authority mode toggle can call it
        window.updateTopPagesSection = function(mode) {
          // Get fresh authorityBySegment from global or try to get from current scores
          let segData = window.authorityBySegment;
          if (!segData) {
            // Try to get from current scores
            const authorityObj = scores?.authority;
            segData = (typeof authorityObj === 'object' && authorityObj !== null) 
              ? authorityObj.bySegment 
              : null;
          }
          
          const topPages = mode === 'all'
            ? (segData?.all?.topPages || [])
            : mode === 'nonEducation'
            ? (segData?.nonEducation?.topPages || [])
            : (segData?.money?.topPages || []);
          
          const segmentLabel = mode === 'all'
            ? 'All pages'
            : mode === 'nonEducation'
            ? 'Exclude education (blogs / free course)'
            : 'Money pages only';
          
          debugLog(` Top Pages: Updating to segment "${mode}", found ${topPages.length} pages`, 'info');
          
          // Update segment label
          const labelEl = document.getElementById('top-pages-segment-label');
          if (labelEl) labelEl.textContent = segmentLabel;
          
          // Update summary if available
          const getSegmentSummary = (m) => {
            if (!segData || !segData[m]) return null;
            const segmentData = segData[m];
            return {
              behaviour: segmentData.behaviour || 0,
              ranking: segmentData.ranking || 0,
              total: segmentData.total || segmentData.score || 0
            };
          };
          
          const summary = getSegmentSummary(mode);
          const summaryDiv = document.getElementById('top-pages-segment-summary');
          if (summary && summaryDiv) {
            const rag = getRAGStatus(summary.total);
            summaryDiv.innerHTML = `
              ${formatComponentScore('Behaviour', summary.behaviour)}
              ${formatComponentScore('Ranking', summary.ranking)}
            `;
            // Update RAG badge and score
            const ragBadge = summaryDiv.parentElement.querySelector('.rag-badge');
            const scoreSpan = summaryDiv.parentElement.querySelector('span[style*="font-size: 1.5rem"]');
            if (ragBadge) {
              ragBadge.className = `rag-badge ${rag.status}`;
              ragBadge.textContent = rag.label;
            }
            if (scoreSpan) {
              scoreSpan.textContent = Math.round(summary.total);
              scoreSpan.style.color = rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444';
            }
          }
          
          // Update toggle buttons
          ['all', 'nonEducation', 'money'].forEach(m => {
            const btn = document.getElementById(`top-pages-mode-${m}`);
            if (btn) {
              if (m === mode) {
                btn.style.background = '#10b981';
                btn.style.color = 'white';
                btn.style.fontWeight = '600';
              } else {
                btn.style.background = 'white';
                btn.style.color = '#666';
                btn.style.fontWeight = '400';
              }
            }
          });
          
          // Update comparison table
          const comparisonDiv = document.getElementById('top-pages-comparison-table');
          if (comparisonDiv && segData) {
            comparisonDiv.innerHTML = renderSegmentComparisonTable(segData, mode);
          }
          
          // Get date range for display
          const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
          const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
          
          // Update table (reset sort when switching segments)
          window.topPagesData = topPages;
          window.topPagesSortColumn = null;
          window.topPagesSortDirection = 'desc';
          const tableContainer = document.getElementById('top-pages-table-container');
          if (tableContainer) {
            tableContainer.innerHTML = renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText);
            attachCopyButtonHandler();
            attachSortHandlers();
          }
          
          // Update recommendations table
          const recommendationsContainer = document.getElementById('top-pages-recommendations-container');
          if (recommendationsContainer && segData && segData[mode]) {
            const segmentLabel = mode === 'all'
              ? 'All pages'
              : mode === 'nonEducation'
              ? 'Exclude education (blogs / free course)'
              : 'Money pages only';
            const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
            const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
            recommendationsContainer.innerHTML = renderRecommendationsTable(mode, {
              siteCtr: segData[mode].siteCtr || 0,
              top10Ctr: segData[mode].top10Ctr || 0,
              avgPosition: segData[mode].avgPosition || 0,
              top10Share: segData[mode].top10Share || 0,
              behaviourScore: segData[mode].behaviour || 0,
              rankingScore: segData[mode].ranking || 0
            }, segmentLabel, dateRangeText);
          }
        };
        
        // Helper to attach sort handlers after table is in DOM
        function attachSortHandlers() {
          setTimeout(() => {
            ['ctr', 'impressions', 'clicks', 'position'].forEach(col => {
              const th = document.getElementById(`sort-${col}`);
              if (th) {
                // Remove existing listeners by cloning
                const newTh = th.cloneNode(true);
                th.parentNode.replaceChild(newTh, th);
                newTh.addEventListener('click', () => {
                  if (window.handleSort) {
                    window.handleSort(col);
                  }
                });
              }
            });
          }, 50);
        }
        
        // Attach initial handlers after section is created
        setTimeout(() => {
          attachCopyButtonHandler();
          attachSortHandlers();
        }, 150);
        
        function attachCopyButtonHandler() {
          setTimeout(() => {
            const copyBtn = document.getElementById('top-pages-copy-urls');
            if (copyBtn) {
              // Remove existing listener
              const newCopyBtn = copyBtn.cloneNode(true);
              copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
              
              newCopyBtn.addEventListener('click', async () => {
                const currentMode = window.currentAuthorityMode || 'all';
                const currentTopPages = currentMode === 'all'
                  ? (authorityBySegment?.all?.topPages || [])
                  : currentMode === 'nonEducation'
                  ? (authorityBySegment?.nonEducation?.topPages || [])
                  : (authorityBySegment?.money?.topPages || []);
                
                const text = currentTopPages.map(p => p.url).join('\n');
                try {
                  await navigator.clipboard.writeText(text);
                  newCopyBtn.textContent = 'Copied!';
                  newCopyBtn.style.color = '#10b981';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                    newCopyBtn.style.color = '#666';
                  }, 2000);
                } catch (err) {
                  console.error('Failed to copy URLs:', err);
                  newCopyBtn.textContent = 'Copy failed';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                  }, 2000);
                }
              });
            }
          }, 0);
        }
      }
      
      // Add pillar scorecard table
      // Use current audit data (from function parameters) instead of stale localStorage data
      const auditTimestamp = saved?.timestamp;
      
      // Define schemaAuditData in scope accessible to scorecard table
      const schemaAuditData = schemaAudit || saved?.schemaAudit;
      
      // Fetch historical scores for the last date in chart range to ensure scorecard matches chart
      // This fixes the issue where scorecard shows latest audit score but chart shows historical score
      let historicalScoresForLastDate = {};
      const propertyUrlForHistorical = document.getElementById('propertyUrl')?.value || data?.propertyUrl || propertyUrl || '';
      if (propertyUrlForHistorical) {
        try {
          // Get the last date from timeseries or maps
          let lastChartDate = null;
          if (data && data.timeseries && Array.isArray(data.timeseries) && data.timeseries.length > 0) {
            lastChartDate = data.timeseries[data.timeseries.length - 1].date;
          } else if (window.lastGscTimeseriesDate) {
            lastChartDate = window.lastGscTimeseriesDate;
          } else if (window.authorityMap && window.authorityMap.size > 0) {
            const authorityDates = Array.from(window.authorityMap.keys()).sort();
            lastChartDate = authorityDates[authorityDates.length - 1];
          }
          
          if (lastChartDate) {
            debugLog(`[Scorecard] Fetching historical scores for last chart date: ${lastChartDate}`, 'info');
            const historicalResponse = await fetch(apiUrl(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrlForHistorical)}&startDate=${lastChartDate}&endDate=${lastChartDate}`));
            if (historicalResponse.ok) {
              const historicalData = await historicalResponse.json();
              if (historicalData.status === 'ok' && historicalData.data && Array.isArray(historicalData.data) && historicalData.data.length > 0) {
                // Get the latest audit for this date (in case of multiple audits per day)
                const auditsForDate = historicalData.data.filter(r => r.date === lastChartDate);
                if (auditsForDate.length > 0) {
                  // Sort by timestamp/updated_at to get the latest
                  auditsForDate.sort((a, b) => {
                    const aTime = a.updated_at || a.timestamp || 0;
                    const bTime = b.updated_at || b.timestamp || 0;
                    return bTime - aTime;
                  });
                  const latestAudit = auditsForDate[0];
                  historicalScoresForLastDate = {
                    authority: latestAudit.authorityScore,
                    contentSchema: latestAudit.contentSchemaScore,
                    localEntity: latestAudit.localEntityScore,
                    serviceArea: latestAudit.serviceAreaScore,
                    visibility: latestAudit.visibilityScore
                  };
                  debugLog(`[Scorecard] Found historical scores for ${lastChartDate}: Authority=${historicalScoresForLastDate.authority}, Content/Schema=${historicalScoresForLastDate.contentSchema}`, 'info');
                }
              }
            }
          }
        } catch (e) {
          debugLog(`[Scorecard] Error fetching historical scores: ${e.message}`, 'warn');
        }
      }
      
      // Get last GSC data date from current data (for Authority, Visibility, and Brand & Entity)
      // CRITICAL: Always fetch fresh from Supabase to get the actual last timeseries date
      // data.timeseries may be stale (from localStorage), so we can't rely on it for the Data Date
      let gscLastDate = null;
      
      // Always fetch fresh from Supabase to ensure we have the latest date
      const propertyUrl = document.getElementById('propertyUrl')?.value || data?.propertyUrl || '';
      if (propertyUrl) {
        try {
          // Try window first (if renderTrendChart already ran and set it)
          if (window.lastGscTimeseriesDate) {
            gscLastDate = window.lastGscTimeseriesDate;
            debugLog(`Using last GSC timeseries date from window: ${gscLastDate}`, 'info');
          } else {
            // Fetch from Supabase API to get the last timeseries date
            const endDate = new Date().toISOString().split('T')[0];
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 30); // Last 30 days
            const startDateStr = startDate.toISOString().split('T')[0];
            
            debugLog(`Fetching last GSC timeseries date from Supabase for Data Date...`, 'info');
            const timeseriesResponse = await fetch(apiUrl(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDate}`));
            if (timeseriesResponse.ok) {
              const timeseriesData = await timeseriesResponse.json();
              if (timeseriesData.status === 'ok' && timeseriesData.timeseries && Array.isArray(timeseriesData.timeseries) && timeseriesData.timeseries.length > 0) {
                const lastPoint = timeseriesData.timeseries[timeseriesData.timeseries.length - 1];
                if (lastPoint && lastPoint.date) {
                  gscLastDate = lastPoint.date;
                  debugLog(` Using last GSC timeseries date from Supabase API: ${gscLastDate}`, 'success');
                } else {
                  debugLog(` Supabase timeseries response missing date in last point`, 'warn');
                }
              } else {
                debugLog(` Supabase timeseries response missing data: status=${timeseriesData.status}, hasTimeseries=${!!timeseriesData.timeseries}`, 'warn');
              }
            } else {
              debugLog(` Failed to fetch timeseries from Supabase: ${timeseriesResponse.status}`, 'warn');
            }
          }
        } catch (e) {
          debugLog(`Error fetching GSC date: ${e.message}`, 'warn');
        }
      }
      
      // Fallback to data.timeseries only if Supabase fetch failed
      if (!gscLastDate && data && data.timeseries && Array.isArray(data.timeseries) && data.timeseries.length > 0) {
        const lastTimeseriesPoint = data.timeseries[data.timeseries.length - 1];
        if (lastTimeseriesPoint && lastTimeseriesPoint.date) {
          gscLastDate = lastTimeseriesPoint.date;
          debugLog(`Using last GSC timeseries date from data (fallback): ${gscLastDate}`, 'warn');
        }
      }
      
      // Fallback to global maps, but filter to only dates <= last timeseries date if available
      if (!gscLastDate) {
        // Try to get from maps, but only if we can verify it's <= last timeseries date
        // For now, use the latest from maps but log a warning
        if (window.visibilityMap && window.visibilityMap.size > 0) {
          const visibilityDates = Array.from(window.visibilityMap.keys()).sort();
          const latestMapDate = visibilityDates[visibilityDates.length - 1];
          // Only use if we don't have a timeseries date to compare against
          // If we have window.lastGscTimeseriesDate, use that instead
          if (window.lastGscTimeseriesDate) {
            gscLastDate = window.lastGscTimeseriesDate;
            debugLog(`Using last GSC timeseries date from window (filtered): ${gscLastDate}`, 'info');
          } else {
            gscLastDate = latestMapDate;
            debugLog(`Using last GSC date from visibilityMap (fallback): ${gscLastDate}`, 'warn');
          }
        } else if (window.authorityMap && window.authorityMap.size > 0) {
          const authorityDates = Array.from(window.authorityMap.keys()).sort();
          const latestMapDate = authorityDates[authorityDates.length - 1];
          if (window.lastGscTimeseriesDate) {
            gscLastDate = window.lastGscTimeseriesDate;
            debugLog(`Using last GSC timeseries date from window (filtered): ${gscLastDate}`, 'info');
          } else {
            gscLastDate = latestMapDate;
            debugLog(`Using last GSC date from authorityMap (fallback): ${gscLastDate}`, 'warn');
          }
        }
      }
      
      // Final fallback to date from current data if available
      if (!gscLastDate && data && data.date) {
        gscLastDate = data.date;
        debugLog(`Using GSC data date (fallback): ${gscLastDate}`, 'info');
      }
      
      // If still no date, try to get it from saved audit data
      if (!gscLastDate && saved && saved.searchData && saved.searchData.date) {
        gscLastDate = saved.searchData.date;
        debugLog(`Using saved GSC data date (fallback): ${gscLastDate}`, 'info');
      }
      
      // Format date for display
      function formatDataDate(dateStr) {
        if (!dateStr) return '';
        const date = new Date(dateStr + 'T00:00:00'); // Add time to avoid timezone issues
        return date.toLocaleDateString('en-GB', {
          day: '2-digit',
          month: 'short',
          year: 'numeric'
        });
      }
      
      // Format timestamp for display
      function formatTimestamp(timestamp) {
        if (!timestamp) return '';
        const date = new Date(timestamp);
        return date.toLocaleString('en-GB', {
          day: '2-digit',
          month: 'short',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
      }
      
      // Get data date for each pillar
      function getPillarDataDate(pillarKey) {
        if (pillarKey === 'authority' || pillarKey === 'visibility' || pillarKey === 'brandOverlay') {
          // GSC-based pillars - use last GSC data date (Brand & Entity uses GSC query data)
          return gscLastDate ? formatDataDate(gscLastDate) : (auditTimestamp ? formatTimestamp(auditTimestamp) : '');
        } else {
          // Business Profile and schema audit - use audit timestamp
          return auditTimestamp ? formatTimestamp(auditTimestamp) : '';
        }
      }
      
      const scorecardTable = document.createElement('div');
      scorecardTable.className = 'scorecard-section';
      scorecardTable.innerHTML = `
        <h3 style="margin: 0 0 1rem 0; color: var(--brand-orange);">Pillar Scorecard</h3>
        <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow-x: auto;">
          <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
            <thead>
              <tr style="background: #f5f5f5;">
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 10%;">Pillar</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 6%;">Score</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 6%;">Weight</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 8%;">Status</th>
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 42%;">Description</th>
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 22%;">Improvement Suggestions</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 6%;">Data Date</th>
              </tr>
            </thead>
            <tbody>
              ${(() => {
                // Phase 3: Insert Brand & Entity row after Authority
                const orderedPillars = getOrderedPillars(scores);
                const brandOverlay = scores.brandOverlay;
                const brandRowIndex = orderedPillars.findIndex(([key]) => key === 'authority');
                
                // Insert Brand row after Authority if it exists
                if (brandRowIndex >= 0 && brandOverlay) {
                  orderedPillars.splice(brandRowIndex + 1, 0, ['brandOverlay', brandOverlay.score || 0]);
                }
                
                // Use historical scores for the last date in chart range (if available)
                // This ensures scorecard matches what's shown in the trend chart
                // Priority: 1) Fetched historical scores, 2) Window maps, 3) Current scores
                const lastChartDate = window.latestAuditDateStr || window.lastGscTimeseriesDate || 
                  (data && data.timeseries && data.timeseries.length > 0 ? data.timeseries[data.timeseries.length - 1].date : null);
                
                if (lastChartDate) {
                  // Override scores with historical values if available
                  orderedPillars.forEach(([key, currentScore], idx) => {
                    let historicalScore = null;
                    
                    // First, try fetched historical scores
                    if (key === 'authority' && historicalScoresForLastDate.authority !== null && historicalScoresForLastDate.authority !== undefined) {
                      historicalScore = historicalScoresForLastDate.authority;
                    } else if (key === 'contentSchema' && historicalScoresForLastDate.contentSchema !== null && historicalScoresForLastDate.contentSchema !== undefined) {
                      historicalScore = historicalScoresForLastDate.contentSchema;
                    } else if (key === 'localEntity' && historicalScoresForLastDate.localEntity !== null && historicalScoresForLastDate.localEntity !== undefined) {
                      historicalScore = historicalScoresForLastDate.localEntity;
                    } else if (key === 'serviceArea' && historicalScoresForLastDate.serviceArea !== null && historicalScoresForLastDate.serviceArea !== undefined) {
                      historicalScore = historicalScoresForLastDate.serviceArea;
                    } else if (key === 'visibility' && historicalScoresForLastDate.visibility !== null && historicalScoresForLastDate.visibility !== undefined) {
                      historicalScore = historicalScoresForLastDate.visibility;
                    }
                    // Fallback to window maps if fetched scores not available
                    else if (key === 'authority' && window.authorityMap && window.authorityMap.has(lastChartDate)) {
                      historicalScore = window.authorityMap.get(lastChartDate);
                    } else if (key === 'contentSchema' && window.contentSchemaMap && window.contentSchemaMap.has(lastChartDate)) {
                      historicalScore = window.contentSchemaMap.get(lastChartDate);
                    } else if (key === 'localEntity' && window.localEntityMap && window.localEntityMap.has(lastChartDate)) {
                      historicalScore = window.localEntityMap.get(lastChartDate);
                    } else if (key === 'serviceArea' && window.serviceAreaMap && window.serviceAreaMap.has(lastChartDate)) {
                      historicalScore = window.serviceAreaMap.get(lastChartDate);
                    } else if (key === 'visibility' && window.visibilityMap && window.visibilityMap.has(lastChartDate)) {
                      historicalScore = window.visibilityMap.get(lastChartDate);
                    }
                    
                    if (historicalScore !== null && historicalScore !== undefined) {
                      orderedPillars[idx][1] = historicalScore;
                      debugLog(`[Scorecard] Using historical ${key} score (${historicalScore}) for ${lastChartDate} instead of current (${currentScore})`, 'info');
                    } else {
                      debugLog(`[Scorecard] No historical ${key} score found for ${lastChartDate}, using current (${currentScore})`, 'info');
                    }
                  });
                } else {
                  debugLog(`[Scorecard] No last chart date available, using current audit scores`, 'info');
                }
                
                return orderedPillars;
              })().map(([key, score], index) => {
                const rag = getRAGStatus(score);
                
                // Define pillar colors for scorecard table (matching charts)
                const scorecardPillarColors = {
                  localEntity: 'rgba(147, 51, 234, 1)', // Purple
                  serviceArea: '#00FFFF', // Cyan
                  authority: '#99004C', // Dark pink/magenta
                  visibility: 'rgba(37, 99, 235, 1)', // Blue
                  contentSchema: 'rgba(107, 114, 128, 1)' // Grey
                };
                
                const pillarColor = scorecardPillarColors[key] || '#666';
                
                // Build Content/Schema description with schema audit data
                let contentSchemaDesc = 'Quality and completeness of structured data markup across your domain.<br><strong>AI Importance:</strong> Structured data is the primary way AI understands your content. Schema markup directly feeds AI systems, enabling them to extract facts, relationships, and context for use in AI Overviews and answer generation.<br><strong>Diversity:</strong> Measures how varied your structured content is  different schema types (Article, Event, Course, FAQPage, HowTo, Product, Review, VideoObject, ImageObject, ItemList, LocalBusiness) and formats across the site. A broader mix of types gives AI more reliable, context-rich signals for understanding what you do and for building accurate summaries.<br><strong>Data Source:</strong>  <span style="color: #10b981;">Live data</span> from schema audit (crawls actual website pages for JSON-LD markup).<br><strong>Calculation:</strong> Weighted score based on Foundation schemas (30%), Rich Result eligibility (35%), Coverage (20%), and Type Diversity (15%).';
                
                if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
                  const schemaData = schemaAudit.data;
                  const { coverage, totalPages, pagesWithSchema, missingSchemaCount, missingSchemaPages, schemaTypes } = schemaData;
                  
                  // Handle pagesWithSchema - it might be an array or a number
                  const pagesWithSchemaCount = Array.isArray(pagesWithSchema) ? pagesWithSchema.length : (typeof pagesWithSchema === 'number' ? pagesWithSchema : 0);
                  const totalPagesCount = typeof totalPages === 'number' ? totalPages : (Array.isArray(schemaData.pages) ? schemaData.pages.length : 0);
                  let coverageValue = 'N/A';
                  if (typeof coverage === 'number' && !isNaN(coverage)) {
                    coverageValue = coverage.toFixed(1);
                  } else if (totalPagesCount > 0) {
                    coverageValue = ((pagesWithSchemaCount / totalPagesCount) * 100).toFixed(1);
                  }
                  
                  // Calculate foundation schemas - PRIORITY: use schemaData.foundation object first (most reliable)
                  // foundation object has {Organization: true, Person: true, WebSite: true, BreadcrumbList: true}
                  const allTypes = new Set();
                  
                  // First, use foundation object if available (most reliable source)
                  if (schemaData.foundation && typeof schemaData.foundation === 'object') {
                    Object.keys(schemaData.foundation).forEach(type => {
                      if (schemaData.foundation[type] === true) {
                        allTypes.add(type);
                      }
                    });
                  }
                  
                  // Also add types from allDetectedTypes if available (for complete type list)
                  if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
                    schemaData.allDetectedTypes.forEach(type => {
                      if (type) allTypes.add(type);
                    });
                  }
                  
                  // Fallback: collect from schemaTypes array (contains all types, sorted by count)
                  // IMPORTANT: schemaTypes might be the pages array, so filter carefully
                  if (schemaTypes && Array.isArray(schemaTypes) && allTypes.size === 0) {
                    schemaTypes.forEach(item => {
                      // Skip page objects (have 'url' property) - these are NOT schema types
                      if (item && typeof item === 'object' && item.url) {
                        return; // Skip page objects
                      }
                      // Only process valid schema type objects (not page objects with url property)
                      if (item && typeof item === 'object' && item.type && typeof item.type === 'string' && !item.url) {
                        allTypes.add(item.type);
                      } else if (typeof item === 'string') {
                        allTypes.add(item);
                      }
                    });
                  }
                  const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
                  const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
                  
                  // Count rich result types
                  const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
                  const uniqueTypesCount = allTypes.size;
                  
                  const richResultTypesList = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
                  const richTypesPresent = richResultTypesList.filter(type => allTypes.has(type));
                  contentSchemaDesc += ` <strong>Data Checked:</strong> Foundation schemas: ${foundationPresent}/4 (${foundationTypes.filter(t => allTypes.has(t)).join(', ') || 'none'}), Rich result types: ${richEligibleCount}/${richResultTypesList.length} eligible, Coverage: ${coverageValue}% (${pagesWithSchemaCount}/${totalPagesCount} pages), Type diversity: ${richTypesPresent.length}/${richResultTypesList.length} rich result types present (${richTypesPresent.join(', ') || 'none'}), ${uniqueTypesCount} total unique types across the site. `;
                  
                  // Display schema types - use allDetectedTypes if available, otherwise try schemaTypes (but filter out pages)
                  let schemaTypesToDisplay = [];
                  if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
                    schemaTypesToDisplay = schemaData.allDetectedTypes.slice(0, 15);
                  } else if (schemaTypes && Array.isArray(schemaTypes)) {
                    // Filter out page objects (those with 'url' property) - these are NOT schema types
                    schemaTypesToDisplay = schemaTypes
                      .filter(t => {
                        // Skip null/undefined
                        if (!t) return false;
                        // Skip page objects (have 'url' property) - these are pages, not types!
                        if (typeof t === 'object' && ('url' in t || ('title' in t && 'metaDescription' in t))) return false;
                        // Only keep valid type objects or strings
                        return typeof t === 'string' || (typeof t === 'object' && t.type && typeof t.type === 'string' && !t.url);
                      })
                      .slice(0, 15);
                  }
                  
                  if (schemaTypesToDisplay.length > 0) {
                    // Convert to display strings
                    const topTypes = schemaTypesToDisplay
                      .map(t => {
                        if (typeof t === 'string' && t.trim()) {
                          return t.trim();
                        } else if (t && typeof t === 'object' && t.type && typeof t.type === 'string') {
                          return `${t.type}${t.count ? ` (${t.count})` : ''}`;
                        } else {
                          // Skip objects without a valid type property - don't convert to [object Object]
                          return null;
                        }
                      })
                      .filter(t => t !== null && t !== undefined && t !== '' && typeof t === 'string' && !t.includes('[object Object]'))
                      .join(', ');
                    if (topTypes) {
                      contentSchemaDesc += `Schema types found: ${topTypes}${schemaTypesToDisplay.length > 15 ? '...' : ''}. `;
                    }
                  }
                  
                  if (schemaData.missingTypes && Array.isArray(schemaData.missingTypes) && schemaData.missingTypes.length > 0) {
                    // Ensure all items are strings - properly handle objects
                    const missingTypesList = schemaData.missingTypes
                      .map(t => {
                        if (typeof t === 'string') return t;
                        if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type;
                        // Skip objects that can't be converted
                        return null;
                      })
                      .filter(t => t !== null && t !== undefined && typeof t === 'string');
                    if (missingTypesList.length > 0) {
                      contentSchemaDesc += `Missing foundation types: ${missingTypesList.join(', ')}. `;
                    }
                  }
                  
                  const richTypes = Object.entries(schemaData.richEligible || {})
                    .filter(([type, eligible]) => eligible)
                    .map(([type]) => type);
                  if (richTypes.length > 0) {
                    contentSchemaDesc += `Rich result eligible: ${richTypes.join(', ')}. `;
                  }
                  
                  // Check if Review schema is detected (even if not in top 10 types)
                  const hasReviewSchema = allTypes.has('Review');
                  if (hasReviewSchema) {
                    // Try to get count from schemaTypes array first, otherwise check schemaData for actual count
                    let reviewCount = schemaTypes?.find(t => t.type === 'Review')?.count || 0;
                    // If not in top 10, check if we have schemaData with all types info
                    if (reviewCount === 0 && schemaData.schemaTypes) {
                      // schemaTypes in response is top 10, but we need to check if Review exists
                      // Since it's in allTypes, it exists, but we don't have the exact count
                      // Just indicate it's detected without showing 0
                      contentSchemaDesc += `Review schema detected - matches GSC review snippets data. `;
                    } else if (reviewCount > 0) {
                      contentSchemaDesc += `Review schema detected (${reviewCount} instances) - matches GSC review snippets data. `;
                } else {
                      contentSchemaDesc += `Review schema detected - matches GSC review snippets data. `;
                    }
                  }
                } else {
                  contentSchemaDesc += ' <strong>Data Checked:</strong> Foundation schemas (Organization, Person, WebSite, BreadcrumbList), Rich result eligibility (Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList), schema coverage percentage, schema type diversity.';
                }
                
                // Build Local Entity and Service Area descriptions based on whether we have real Business Profile data
                let localEntityDesc, serviceAreaDesc;
                if (hasLocalSignals && localSignalsData) {
                  const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                  const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
                  const locationsCount = localSignalsData.locations?.length || 0;
                  const knowledgePanel = localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected';
                  localEntityDesc = `Consistency and clarity of brand, person and business entity signals.<br><strong>AI Importance:</strong> AI systems rely on clear entity signals to understand who you are and connect your brand across platforms. Strong entity recognition helps AI include you in knowledge panels and entity-based results.<br><strong>Data Source:</strong>  <span style="color: #10b981;">Live data</span> from Google Business Profile API.<br><strong>Data Checked:</strong> NAP consistency (${napScore}%), knowledge panel (${knowledgePanel}), locations (${locationsCount}), LocalBusiness schema presence, Google Business Profile data.`;
                  serviceAreaDesc = `How clearly AI understands where lessons/workshops run and which regions you cover.<br><strong>AI Importance:</strong> AI uses geographic signals to match queries with local intent. Clear service area data helps AI surface your content for location-specific searches and local AI Overviews.<br><strong>Data Source:</strong>  <span style="color: #10b981;">Live data</span> from Google Business Profile API.<br><strong>Data Checked:</strong> Service areas (${serviceAreasCount}), NAP consistency (${napScore}%), Google Business Profile service areas.`;
                } else {
                  localEntityDesc = 'Consistency and clarity of brand, person and business entity signals.<br><strong>AI Importance:</strong> AI systems rely on clear entity signals to understand who you are and connect your brand across platforms. Strong entity recognition helps AI include you in knowledge panels and entity-based results.<br><strong>Data Source:</strong>  <span style="color: #f59e0b;">Derived calculation</span> from GSC position/CTR (not using real local signals yet).<br><strong>Data Checked:</strong> Currently calculated from search performance metrics. Real data pending: LocalBusiness schema presence, NAP consistency, Google Business Profile data, knowledge panel detection.';
                  serviceAreaDesc = 'How clearly AI understands where lessons/workshops run and which regions you cover.<br><strong>AI Importance:</strong> AI uses geographic signals to match queries with local intent. Clear service area data helps AI surface your content for location-specific searches and local AI Overviews.<br><strong>Data Source:</strong>  <span style="color: #f59e0b;">Derived calculation</span> from Local Entity score (not using real service area data yet).<br><strong>Data Checked:</strong> Currently calculated from Local Entity. Real data pending: ServiceArea schema markup, Google Business Profile service areas, geographic keywords, location pages.';
                }
                
                // Format GSC data for display - use current data parameter
                const currentGSCData = data || searchDataForBreakdown || {};
                const ctr = currentGSCData.ctr || 0;
                const avgPosition = currentGSCData.averagePosition || 0;
                const totalClicks = currentGSCData.totalClicks || 0;
                const totalImpressions = currentGSCData.totalImpressions || 0;
                
                // Phase 3: Build Brand & Entity description
                let brandDesc = '';
                if (key === 'brandOverlay') {
                  const brand = scores.brandOverlay;
                  if (brand) {
                    const share = brand.brandQueryShare || 0;
                    const brandCtr = brand.brandCtr || 0;
                    const pos = brand.brandAvgPosition || 0;
                    const reviewScore = brand.reviewScore || 0;
                    const entityScore = brand.entityScore || 0;
                    
                    brandDesc = `E-A-T overlay for brand demand, reviews, and entity strength. Shows how clearly "Alan Ranger / Alan Ranger Photography" is recognised as a distinct brand in search and AI systems.<br><strong>AI Importance:</strong> Strong branded signals make it easier for AI to trust and summarise you correctly. High branded search share, strong review footprint and a clear entity graph (GBP + knowledge panel) all increase the chance of accurate AI overviews.<br><strong>Calculation:</strong> Combined overlay score from:<br> Brand search: share of branded queries, CTR, and average position<br> Reviews: Google Business Profile + on-site review scores and volumes<br> Entity: NAP consistency, locations, and knowledge panel detection<br><strong>Data Source:</strong> Live data from Google Search Console (brand queries), Google Business Profile API (rating, reviews, locations, service areas), and site reviews snapshot.`;
                    
                    // Show metrics when available
                    if (share > 0 || brandCtr > 0 || pos > 0) {
                      const sharePct = share != null ? (share * 100).toFixed(1) : 'N/A';
                      const brandCtrPct = brandCtr != null ? (brandCtr * 100).toFixed(1) : 'N/A';
                      const posStr = pos != null ? pos.toFixed(1) : 'N/A';
                      brandDesc += ` <strong>Current Metrics:</strong> Brand queries: ${sharePct}% of impressions, brand CTR ${brandCtrPct}%, avg brand position ${posStr}.`;
                    }
                  } else {
                    brandDesc = 'No brand overlay data available  run an audit with access to query data.';
                  }
                }
                
                const descriptions = {
                  localEntity: localEntityDesc,
                  serviceArea: serviceAreaDesc,
                  authority: `E-A-T (Experience, Expertise, Authoritativeness, Trustworthiness): Perceived expertise and trust in the topic space. Authority measures how much the outside world and searchers trust and choose you, not just content quality.<br><strong>AI Importance:</strong> E-A-T is critical for AI systems - they prioritize authoritative, trustworthy sources. Strong E-A-T signals help AI confidently feature your content in AI Overviews and answer boxes.<br><strong>Calculation:</strong> Behaviour Score (40%): CTR for ranking queries (position 20) + top-10 CTR. Ranking Score (20%): Average position + top-10 impression share. Backlink Score (20%): Referring domains + quality ratio. Review Score (20%): Combined ratings and counts from GBP + Trustpilot snapshot.<br><strong>Data Source:</strong>  <span style="color: #10b981;">Live data</span> from Google Search Console API, Google Business Profile API, historic Trustpilot reviews snapshot, and backlink CSV upload.<br><strong>Data Checked:</strong> CTR ${ctr.toFixed(1)}%, average position ${avgPosition.toFixed(1)}, clicks ${totalClicks.toLocaleString()}, impressions ${totalImpressions.toLocaleString()}, ranking query performance (position 20), backlink metrics (referring domains, follow ratio), review ratings and counts.`,
                  visibility: `Frequency and prominence in organic search, local pack, snippets and AI Overviews.<br><strong>AI Importance:</strong> AI systems learn from existing search performance. Higher visibility signals quality and relevance, making AI more likely to surface your content in AI-powered results and featured snippets.<br><strong>Data Source:</strong>  <span style="color: #10b981;">Live data</span> from Google Search Console API.<br><strong>Data Checked:</strong> Average position ${avgPosition.toFixed(1)}, CTR ${ctr.toFixed(1)}%, total clicks ${totalClicks.toLocaleString()}, total impressions ${totalImpressions.toLocaleString()}, SERP feature appearances.`,
                  contentSchema: contentSchemaDesc,
                  brandOverlay: brandDesc
                };
                
                // Generate dynamic next steps based on actual data and scores
                // Use current data from function parameters
                const getNextSteps = (pillarKey, pillarScore, gscData, schemaData) => {
                  // Use the schemaData parameter passed to this function
                  const currentSchemaData = schemaData;
                  const steps = [];
                  
                  switch(pillarKey) {
                    case 'contentSchema':
                      if (schemaData && schemaData.status === 'ok' && schemaData.data) {
                        const schemaAuditData = schemaData.data;
                        const { coverage, missingSchemaCount, totalPages, pagesWithSchema, schemaTypes, richEligible, missingTypes } = schemaAuditData;
                        
                        // Collect all types for analysis - use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
                        const allTypes = new Set();
                        if (schemaAuditData.allDetectedTypes && Array.isArray(schemaAuditData.allDetectedTypes)) {
                          // Use all detected types for accurate calculation
                          schemaAuditData.allDetectedTypes.forEach(type => {
                            if (type) allTypes.add(type);
                          });
                        } else if (schemaTypes && Array.isArray(schemaTypes)) {
                          // Fallback: collect from schemaTypes array (contains all types, sorted by count)
                          schemaTypes.forEach(item => {
                            if (item.type) allTypes.add(item.type);
                          });
                        }
                        
                        // 1. Foundation Schemas (30% weight)
                        const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
                        const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
                        const foundationMissing = foundationTypes.filter(type => !allTypes.has(type));
                        
                        if (foundationPresent < 4) {
                          steps.push(`<strong>Foundation schemas (30%):</strong> ${foundationPresent}/4 present. Add: ${foundationMissing.join(', ')}`);
                        } else {
                          steps.push(`<strong>Foundation schemas (30%):</strong>  All 4 present (Organization, Person, WebSite, BreadcrumbList)`);
                        }
                        
                        // 2. Rich Result Eligibility (35% weight)
                        const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
                        const richEligibleCount = Object.values(richEligible || {}).filter(eligible => eligible === true).length;
                        const richMissing = richResultTypes.filter(type => !richEligible[type]);
                        
                        // Check for failed crawls that might affect rich result detection
                        const failedPages = schemaAuditData.missingSchemaPages ? schemaAuditData.missingSchemaPages.filter(p => p.error).length : 0;
                        const hasFailedCrawls = failedPages > 0;
                        
                        if (richEligibleCount < richResultTypes.length) {
                          let richResultMsg = `<strong>Rich results (35%):</strong> ${richEligibleCount}/${richResultTypes.length} eligible.`;
                          if (richMissing.length > 0) {
                            richResultMsg += ` Missing: ${richMissing.slice(0, 3).join(', ')}${richMissing.length > 3 ? '...' : ''}`;
                            if (hasFailedCrawls) {
                              richResultMsg += ` <em>(Note: ${failedPages} page${failedPages !== 1 ? 's' : ''} failed to crawl - missing types may exist but weren't detected)</em>`;
                            }
                          }
                          steps.push(richResultMsg);
                        } else {
                          steps.push(`<strong>Rich results (35%):</strong>  All ${richResultTypes.length} types eligible`);
                        }
                        
                        // 3. Coverage (20% weight)
                        if (coverage < 100) {
                          steps.push(`<strong>Coverage (20%):</strong> ${coverage}% - Add schema to ${missingSchemaCount || 0} pages without markup`);
                        } else {
                          steps.push(`<strong>Coverage (20%):</strong>  100% - All pages have schema`);
                        }
                        
                        // 4. Type Diversity (15% weight)
                        const uniqueTypesCount = allTypes.size;
                        if (uniqueTypesCount < 15) {
                          steps.push(`<strong>Diversity (15%):</strong> ${uniqueTypesCount} unique types. Add more schema types to reach 15+ for maximum score`);
                        } else {
                          steps.push(`<strong>Diversity (15%):</strong>  ${uniqueTypesCount} unique types (excellent diversity)`);
                        }
                      } else {
                        steps.push(`<strong>Status:</strong> Schema audit data not available - run audit to see detailed metrics`);
                      }
                      break;
                      
                    case 'visibility':
                      // Use current data from function parameters
                      const currentGSCForVisibility = data || searchDataForBreakdown || {};
                      if (currentGSCForVisibility) {
                        const position = currentGSCForVisibility.averagePosition || 0;
                        const ctr = currentGSCForVisibility.ctr || 0;
                        
                        if (position > 10) {
                          steps.push(`<strong>Average position: ${position.toFixed(1)}</strong> - Target top 10 positions (currently ranking ${position > 20 ? 'below' : 'in'} page ${Math.ceil(position / 10)})`);
                        } else {
                          steps.push(`<strong>Average position: ${position.toFixed(1)}</strong> - Excellent! Maintain top 10 rankings`);
                        }
                        
                        if (ctr < 2.0) {
                          steps.push(`<strong>CTR: ${ctr.toFixed(1)}%</strong> - Improve click-through rate (target: 2%+) with better titles/meta descriptions`);
                        } else {
                          steps.push(`<strong>CTR: ${ctr.toFixed(1)}%</strong> - Good CTR! Continue optimizing for featured snippets`);
                        }
                        
                        if (currentGSCForVisibility.totalImpressions < 1000) {
                          steps.push(`<strong>Impressions: ${currentGSCForVisibility.totalImpressions}</strong> - Increase visibility by targeting more keywords`);
                        }
                      }
                      break;
                      
                    case 'authority':
                      // Use current data from function parameters, not stale localStorage
                      const currentGSCForAuthority = data || searchDataForBreakdown || {};
                      if (currentGSCForAuthority) {
                        const ctr = currentGSCForAuthority.ctr || 0;
                        const position = currentGSCForAuthority.averagePosition || 0;
                        // Use current saved data (already loaded at function start)
                        const authorityComponents = scores?.authorityComponents;
                        const backlinkMetrics = saved?.backlinkMetrics;
                        const localSignals = saved?.localSignals;
                        // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
                        const siteReviews = getTrustpilotSnapshot(saved?.siteReviews);
                        
                        // Show component-specific suggestions
                        if (authorityComponents) {
                          if (authorityComponents.behaviour < 50) {
                            steps.push(`<strong>Behaviour Score (${Math.round(authorityComponents.behaviour)}):</strong> Improve CTR for ranking queries. Target 5%+ CTR for all queries, 10%+ for top-10 positions`);
                          }
                          
                          if (authorityComponents.ranking < 50) {
                            steps.push(`<strong>Ranking Score (${Math.round(authorityComponents.ranking)}):</strong> Improve average position and increase top-10 impression share`);
                          }
                          
                          if (authorityComponents.backlinks < 50) {
                            if (backlinkMetrics && backlinkMetrics.referringDomains > 0) {
                              steps.push(`<strong>Backlink Score (${Math.round(authorityComponents.backlinks)}):</strong> Increase referring domains (current: ${backlinkMetrics.referringDomains}, target: 100+) and improve follow ratio (current: ${Math.round((backlinkMetrics.followRatio || 0) * 100)}%)`);
                            } else {
                              steps.push(`<strong>Backlink Score (${Math.round(authorityComponents.backlinks)}):</strong> Upload backlink CSV to measure domain authority`);
                            }
                          }
                          
                          if (authorityComponents.reviews < 50) {
                            const gbpRating = (localSignals && localSignals.status === 'ok' && localSignals.data) ? localSignals.data.gbpRating : null;
                            const gbpCount = (localSignals && localSignals.status === 'ok' && localSignals.data) ? localSignals.data.gbpReviewCount : null;
                            const siteRating = siteReviews?.siteRating || null;
                            const siteCount = siteReviews?.siteReviewCount || null;
                            
                            if (!gbpRating && !siteRating) {
                              steps.push(`<strong>Review Score (${Math.round(authorityComponents.reviews)}):</strong> Add GBP and Trustpilot reviews to build trust signals`);
                            } else {
                              steps.push(`<strong>Review Score (${Math.round(authorityComponents.reviews)}):</strong> Increase review count and maintain high ratings (target: 4.5+ rating, 100+ reviews)`);
                            }
                          }
                        } else {
                          // Fallback to general suggestions if components not available
                          if (ctr < 1.5) {
                            steps.push(`<strong>CTR: ${ctr.toFixed(1)}%</strong> - Low click-through indicates trust issues. Improve E-A-T signals`);
                          }
                          
                          if (position > 15) {
                            steps.push(`<strong>Position: ${position.toFixed(1)}</strong> - Improve rankings through comprehensive, expert content`);
                          }
                        }
                      }
                      break;
                      
                    case 'localEntity':
                      if (hasLocalSignals && localSignalsData) {
                        const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                        const locationsCount = localSignalsData.locations?.length || 0;
                        const knowledgePanel = localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected';
                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using real Business Profile data`);
                        steps.push(`<strong>Data:</strong> NAP consistency: ${napScore}%, Knowledge panel: ${knowledgePanel}, Locations: ${locationsCount}`);
                        if (pillarScore < 70) {
                          if (napScore < 100) {
                            steps.push(`<strong>Action:</strong> Improve NAP consistency (currently ${napScore}%) - ensure Name, Address, and Phone are consistent across all platforms`);
                          }
                          if (!localSignalsData.knowledgePanelDetected) {
                            steps.push(`<strong>Action:</strong> Work on knowledge panel detection - improve entity signals and citations`);
                          }
                          if (locationsCount === 0) {
                            steps.push(`<strong>Action:</strong> Add business location to Google Business Profile`);
                          }
                        } else {
                          steps.push(`<strong>Status:</strong>  Strong local entity signals detected`);
                        }
                      } else {
                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using derived calculation from search performance`);
                        steps.push(`<strong>Priority:</strong> Integrate Google Business Profile API to use real local signals data`);
                        if (pillarScore < 70) {
                          steps.push(`<strong>Action:</strong> Add LocalBusiness schema markup and ensure NAP consistency`);
                        }
                      }
                      break;
                      
                    case 'serviceArea':
                      if (hasLocalSignals && localSignalsData) {
                        const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
                        const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using real Business Profile data`);
                        steps.push(`<strong>Data:</strong> Service areas: ${serviceAreasCount}, NAP consistency: ${napScore}%`);
                        if (pillarScore < 70) {
                          if (serviceAreasCount < 5) {
                            steps.push(`<strong>Action:</strong> Add more service areas to Google Business Profile (currently ${serviceAreasCount}, target: 5+)`);
                          }
                          if (napScore < 100) {
                            steps.push(`<strong>Action:</strong> Improve NAP consistency to boost service area score (currently ${napScore}%)`);
                          }
                        } else {
                          steps.push(`<strong>Status:</strong>  Good service area coverage`);
                        }
                      } else {
                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using derived calculation from Local Entity`);
                        steps.push(`<strong>Priority:</strong> Integrate Google Business Profile API to get real service area data`);
                        if (pillarScore < 70) {
                          steps.push(`<strong>Action:</strong> Add ServiceArea schema and create location-specific pages`);
                        }
                      }
                      break;
                  }
                  
                  // If no specific steps generated, add generic ones
                  if (steps.length === 0) {
                    if (pillarScore >= 70) {
                      steps.push('Maintain current performance');
                      steps.push('Monitor for any score drops');
                    } else if (pillarScore >= 40) {
                      steps.push('Focus on improving this pillar');
                      steps.push('Review specific metrics above');
                    } else {
                      steps.push('Critical: Immediate action required');
                      steps.push('Review all data sources and implement fixes');
                    }
                  }
                  
                  return steps.slice(0, 3).map(s => ` ${s}`).join('<br>') || 'No next steps available';
                };
                
                // Generate suggestions based on pillar and score (fallback)
                const getSuggestions = (pillarKey, pillarScore) => {
                  const suggestions = {
                    localEntity: {
                      high: ['Maintain consistent NAP (Name, Address, Phone) across all platforms', 'Continue building personal brand mentions and citations', 'Monitor entity recognition in knowledge panels'],
                      medium: ['Add LocalBusiness schema markup to all location pages', 'Ensure consistent business name and person name across website', 'Build more local citations and directory listings', 'Create an About page with clear entity information', 'Add author markup to content'],
                      low: ['Implement LocalBusiness schema markup immediately', 'Create consistent NAP (Name, Address, Phone) across all platforms', 'Build local citations in relevant directories', 'Add clear About page with entity information', 'Ensure consistent branding across all touchpoints']
                    },
                    serviceArea: {
                      high: ['Continue maintaining clear service area information', 'Update location pages as service areas expand'],
                      medium: ['Add ServiceArea schema markup to location pages', 'Create dedicated pages for each service area/region', 'Include clear geographic information in content', 'Add location-specific keywords naturally', 'Update Google Business Profile with service areas'],
                      low: ['Implement ServiceArea schema markup immediately', 'Create location-specific landing pages', 'Add clear geographic service information to homepage', 'Update all location pages with service area details', 'Include city/region names in page titles and content']
                    },
                    authority: {
                      high: ['Continue producing in-depth, expert content', 'Maintain citation and backlink building efforts', 'Seek opportunities for expert quotes and mentions', 'Keep author bios and credentials up to date'],
                      medium: ['Create more comprehensive, long-form content (2000+ words)', 'Build backlinks from authoritative photography/education sites', 'Seek guest posting opportunities on relevant blogs', 'Collect and display customer reviews/testimonials', 'Create case studies and detailed tutorials', 'Get cited in industry publications', 'Add author bylines with credentials and experience', 'Display certifications, qualifications, and awards', 'Showcase real-world experience and portfolio work', 'Build trust signals (secure site, clear contact info, privacy policy)'],
                      low: ['Produce comprehensive, expert-level content immediately', 'Build backlinks from authoritative sources', 'Create detailed case studies and tutorials', 'Seek media mentions and expert quotes', 'Display customer reviews prominently', 'Build relationships with industry publications', 'Add clear author credentials and experience to all content', 'Display qualifications, certifications, and professional memberships', 'Create About page highlighting expertise and experience', 'Build trust signals (HTTPS, clear contact, privacy policy, terms)']
                    },
                    visibility: {
                      high: ['Continue optimizing for featured snippets', 'Maintain strong ranking positions', 'Monitor SERP feature opportunities'],
                      medium: ['Optimize content for featured snippets (answer boxes)', 'Target long-tail keywords with lower competition', 'Improve page load speed and Core Web Vitals', 'Create FAQ schema for common questions', 'Optimize for "People Also Ask" sections', 'Build internal linking structure'],
                      low: ['Optimize for featured snippets immediately', 'Target low-competition long-tail keywords', 'Improve page speed and mobile experience', 'Add FAQ schema markup', 'Create content targeting "People Also Ask" queries', 'Build strong internal linking structure']
                    },
                    contentSchema: {
                      high: ['Continue maintaining all foundation schemas (Organization, Person, WebSite, BreadcrumbList)', 'Expand rich result eligible types (Article, Event, Course, FAQ, HowTo)', 'Monitor schema validation errors', 'Add more schema type diversity'],
                      medium: ['Add missing foundation schemas (Organization, Person, WebSite, BreadcrumbList)', 'Add rich result eligible types (Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList)', 'Ensure 100% schema coverage across all pages', 'Increase schema type diversity (target 15+ unique types)', 'Validate all schema using Google Rich Results Test'],
                      low: ['Implement foundation schemas immediately (Organization, Person, WebSite, BreadcrumbList)', 'Add rich result eligible schemas (Article, Event, Course, FAQ, HowTo)', 'Ensure schema coverage reaches 100%', 'Add schema type diversity (target 15+ unique types)', 'Validate all schema using Google Rich Results Test']
                    }
                  };
                  
                  const pillarSuggestions = suggestions[pillarKey];
                  if (!pillarSuggestions) return 'No suggestions available';
                  
                  let selectedSuggestions = [];
                  if (pillarScore >= 70) {
                    selectedSuggestions = pillarSuggestions.high || [];
                  } else if (pillarScore >= 40) {
                    selectedSuggestions = pillarSuggestions.medium || [];
                  } else {
                    selectedSuggestions = pillarSuggestions.low || [];
                  }
                  
                  // Return top 3-4 suggestions as bullet points
                  return selectedSuggestions.slice(0, 4).map(s => ` ${s}`).join('<br>') || 'No suggestions available';
                };
                
                // Phase 3: Handle Brand & Entity overlay row
                if (key === 'brandOverlay') {
                  const brand = scores.brandOverlay;
                  const brandScore = brand?.score ?? 0;
                  let brandStatus = 'red';
                  let brandLabel = 'Red';
                  if (brandScore >= 70) {
                    brandStatus = 'green';
                    brandLabel = 'Green';
                  } else if (brandScore >= 40) {
                    brandStatus = 'amber';
                    brandLabel = 'Amber';
                  }
                  
                  // Get brand priority for improvement suggestions
                  const brandPriority = getBrandPriority({ brandOverlay: brand });
                  let brandSuggestion = '';
                  if (brandPriority) {
                    brandSuggestion = brandPriority.message;
                  } else if (brandScore >= 70) {
                    brandSuggestion = 'Brand & entity signals are strong. Maintain a steady flow of new reviews and consistent use of your full brand name across site and off-site mentions.';
                  } else if (!brand) {
                    brandSuggestion = 'No brand overlay data available  run an audit with access to query data.';
                  } else {
                    brandSuggestion = 'No immediate brand actions  focus on Authority behaviour first.';
                  }
                  
                  const brandDataDate = getPillarDataDate('authority'); // Use same date as Authority (GSC-based)
                  const brandDataDateDisplay = brandDataDate 
                    ? `<span style="font-size: 0.8rem; color: #666;">${brandDataDate}</span>`
                    : '<span style="font-size: 0.8rem; color: #999;">N/A</span>';
                  
                  return `
                    <tr style="border-bottom: 1px solid #eee; background: ${index % 2 === 0 ? '#ffffff' : '#fafafa'};">
                      <td style="padding: 0.75rem; font-weight: 500;">
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                          <div style="width: 16px; height: 16px; background: #f59e0b; border-radius: 2px; border: 1px solid rgba(0,0,0,0.1); flex-shrink: 0;" title="Brand & Entity overlay"></div>
                          <span>Brand & Entity <span style="color: #999; font-size: 0.85em;">(overlay)</span></span>
                        </div>
                      </td>
                      <td style="padding: 0.75rem; text-align: center; font-size: 1.1rem; font-weight: 600; color: ${brandStatus === 'green' ? '#10b981' : brandStatus === 'amber' ? '#f59e0b' : '#ef4444'};">
                        ${brand ? Math.round(brandScore) : 0}
                      </td>
                      <td style="padding: 0.75rem; text-align: center; font-size: 0.9rem; font-weight: 600; color: #999;" title="Overlay only - does not affect GAIO score">
                        <span style="color: #999;"></span>
                      </td>
                      <td style="padding: 0.75rem; text-align: center;">
                        ${brand ? `
                          <span class="rag-badge ${brandStatus}" style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.8rem;">
                            ${brandLabel}
                          </span>
                        ` : `
                          <span style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.8rem; background: #e5e7eb; color: #6b7280;">
                            N/A
                          </span>
                        `}
                      </td>
                      <td style="padding: 0.75rem; color: #666; font-size: 0.85rem; line-height: 1.6; width: 42%;">${descriptions.brandOverlay || ''}</td>
                      <td style="padding: 0.75rem; color: #555; font-size: 0.85rem; line-height: 1.6; width: 22%;">${brandSuggestion || 'No suggestions available'}</td>
                      <td style="padding: 0.75rem; text-align: center; width: 6%;">${brandDataDateDisplay}</td>
                    </tr>
                  `;
                }
                
                const weight = pillarWeights[key] || 0;
                const isEven = index % 2 === 0;
                
                // Add CSV download button for Content/Schema
                let descriptionCell = descriptions[key] || '';
                if (key === 'contentSchema' && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
                  const schemaData = schemaAudit.data;
                  const missingSchemaCount = schemaData.missingSchemaCount || 0;
                  const missingSchemaPages = schemaData.missingSchemaPages || [];
                  
                  // Always show button, but disable if no missing pages
                  const buttonDisabled = missingSchemaCount === 0;
                  const buttonStyle = buttonDisabled 
                    ? 'padding: 0.4rem 0.8rem; font-size: 0.8rem; background: #9ca3af; color: white; border: none; border-radius: 4px; cursor: not-allowed; opacity: 0.6;'
                    : 'padding: 0.4rem 0.8rem; font-size: 0.8rem; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;';
                  const buttonText = missingSchemaCount > 0 
                    ? `Download pages without schema (CSV) - ${missingSchemaCount} pages`
                    : 'Download pages without schema (CSV) - No missing pages';
                  
                  const downloadTooltip = missingSchemaCount > 0 
                    ? `Download a CSV file containing ${missingSchemaCount} page URLs that are missing schema markup. Use this list to prioritize which pages need schema added.`
                    : 'All pages have schema markup. No download available.';
                  descriptionCell += `<div style="margin-top: 0.75rem;"><button id="download-missing-schema" class="btn-small" style="${buttonStyle}" ${buttonDisabled ? 'disabled' : ''} title="${downloadTooltip}">${buttonText}</button></div>`;
                }
                
                // Get data date for this pillar
                const pillarDataDate = getPillarDataDate(key);
                const dataDateDisplay = pillarDataDate 
                  ? `<span style="font-size: 0.8rem; color: #666;">${pillarDataDate}</span>`
                  : '<span style="font-size: 0.8rem; color: #999;">N/A</span>';
                
                return `
                  <tr style="border-bottom: 1px solid #eee; background: ${isEven ? '#ffffff' : '#fafafa'};">
                    <td style="padding: 0.75rem; font-weight: 500;">
                      <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <div style="width: 16px; height: 16px; background: ${pillarColor}; border-radius: 2px; border: 1px solid rgba(0,0,0,0.1); flex-shrink: 0;" title="Color key for ${pillarNames[key]} in all reports"></div>
                        <span>${pillarNames[key]}</span>
                      </div>
                    </td>
                    <td style="padding: 0.75rem; text-align: center; font-size: 1.1rem; font-weight: 600; color: ${rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444'};">
                      ${Math.round(score)}
                    </td>
                    <td style="padding: 0.75rem; text-align: center; font-size: 0.9rem; font-weight: 600; color: #666;">
                      ${(weight * 100).toFixed(0)}%
                    </td>
                    <td style="padding: 0.75rem; text-align: center;">
                      <span class="rag-badge ${rag.status}" style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.8rem;">
                        ${rag.label}
                      </span>
                    </td>
                    <td style="padding: 0.75rem; color: #666; font-size: 0.85rem; line-height: 1.6; width: 42%;">${descriptionCell}</td>
                    <td style="padding: 0.75rem; color: #555; font-size: 0.85rem; line-height: 1.6; width: 22%;">${getNextSteps(key, score, currentGSCData, schemaAuditData)}</td>
                    <td style="padding: 0.75rem; text-align: center; width: 6%;">${dataDateDisplay}</td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
        <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-top: 1rem; border-left: 4px solid var(--brand-orange);">
          <p style="margin: 0; font-size: 0.9rem; color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
            <strong>RAG Status Guide:</strong> 
            <span style="color: #10b981; font-weight: 600;">Green (70-100)</span> = Strong performance, 
            <span style="color: #f59e0b; font-weight: 600;">Amber (40-69)</span> = Needs improvement, 
            <span style="color: #ef4444; font-weight: 600;">Red (0-39)</span> = Critical issues
          </p>
          <p style="margin: 0; font-size: 0.9rem; color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
            <strong>Weighting:</strong> Pillars are weighted by their importance for AI search systems. Authority (30%) and Content/Schema (25%) are most critical, as AI relies heavily on E-A-T signals and structured data. Visibility (20%) reflects how AI learns from existing performance, while Local Entity (15%) and Service Area (10%) are less critical for AI-powered results. Brand & Entity is treated as an overlay metric  it does not change the GAIO score but influences how AI systems attribute your content and build summaries.
          </p>
          <p style="margin: 0; font-size: 0.85rem; color: #666; line-height: 1.6; font-style: italic;">
            <strong>Note:</strong> Scores shown are for the last date in the trend chart range. If different audits were run on different days with different page counts or data scopes, scores may vary even if the underlying content didn't change. The "Data Date" column shows when the data was collected for each pillar.
          </p>
        </div>
      `;
      // Insert scorecard table after Score Trends chart (at the end)
      const trendChart = document.getElementById('trendChart');
      if (trendChart && trendChart.parentElement && trendChart.parentElement.parentNode) {
        // Find the chart container (parent of canvas) and insert after it
        const trendChartContainer = trendChart.parentElement;
        trendChartContainer.parentNode.insertBefore(scorecardTable, trendChartContainer.nextSibling);
      } else {
        // Fallback: insert at end of dashboard container
        const dashboardContainer = document.getElementById('dashboard');
        if (dashboardContainer) {
          dashboardContainer.appendChild(scorecardTable);
        } else {
          // Last resort: insert after pillar cards
          pillarCards.parentNode.insertBefore(scorecardTable, pillarCards.nextSibling);
        }
      }

      // Add CSV download handler for missing schema pages
      const downloadBtn = document.getElementById('download-missing-schema');
      if (downloadBtn && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        const missingSchemaCount = schemaData.missingSchemaCount || 0;
        const missingSchemaPages = schemaData.missingSchemaPages || [];
        
        debugLog(`Missing schema pages: count=${missingSchemaCount}, pages=${missingSchemaPages.length}`, 'info');
        debugLog(`Missing schema data: ${JSON.stringify(missingSchemaPages)}`, 'info');
        
        if (missingSchemaCount > 0 && missingSchemaPages.length > 0) {
          downloadBtn.addEventListener('click', () => {
            // Check if any pages have error field to determine CSV columns
            const hasErrors = missingSchemaPages.some(p => p.error);
            const headers = hasErrors ? ['url', 'parentUrl', 'error'] : ['url', 'parentUrl'];
            
            const rows = [
              headers,
              ...missingSchemaPages.map(p => [
                p.url, 
                p.parentUrl || '', 
                ...(hasErrors ? [p.error || ''] : [])
              ]),
            ];
            
            const csv = rows
              .map(r => r.map(v => `"${(v || '').replace(/"/g, '""')}"`).join(','))
              .join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ai-geo-missing-schema-pages.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          });
        } else {
          // Button is already disabled in the HTML, just log
          debugLog(`No missing schema pages to download (count: ${missingSchemaCount})`, 'info');
        }
      } else if (!downloadBtn) {
        debugLog('Download button not found in DOM', 'warn');
      }

      // Display snippet readiness with pie chart visualization
      const snippetScoreElement = document.getElementById('snippetReadinessScore');
      const gaugeStatus = document.getElementById('gaugeStatus');
      const legendElement = document.getElementById('snippetReadinessLegend');
      
      if (snippetScoreElement) {
        snippetScoreElement.textContent = snippetReadiness;
        
        // Color code overall score based on value
        let colorClass = '#ef4444'; // red
        let statusText = 'Critical';
        if (snippetReadiness >= 70) {
          colorClass = '#10b981'; // green
          statusText = 'Strong';
        } else if (snippetReadiness >= 40) {
          colorClass = '#f59e0b'; // amber
          statusText = 'Needs Improvement';
        }
        
        snippetScoreElement.style.color = colorClass;
        
        // Update status text
        if (gaugeStatus) {
          gaugeStatus.textContent = statusText;
          gaugeStatus.style.color = colorClass;
        }
      }
      
      // Create pie chart showing weighted components
      const pieChartCanvas = document.getElementById('snippetReadinessPieChart');
      if (pieChartCanvas && scores) {
        // Destroy existing chart if it exists
        if (window.snippetReadinessChart) {
          window.snippetReadinessChart.destroy();
        }
        
        const contentSchemaScore = Math.round(scores.contentSchema || 0);
        const visibilityScore = Math.round(scores.visibility || 0);
        const authorityScore = Math.round(typeof scores.authority === 'object' ? (scores.authority.score || 0) : (scores.authority || 0));
        
        // Generate top 5 actionable levers to improve snippet readiness
        const explanationDiv = document.getElementById('snippetReadinessExplanation');
        const topActionsList = document.getElementById('topActionsList');
        if (explanationDiv && topActionsList && scores) {
          const contentSchemaScore = Math.round(scores.contentSchema || 0);
          const visibilityScore = Math.round(scores.visibility || 0);
          const authorityScore = Math.round(typeof scores.authority === 'object' ? (scores.authority.score || 0) : (scores.authority || 0));
          
          const actions = [];
          
          // Authority (25% weight) - usually lowest, highest impact potential
          if (authorityScore < 70) {
            const potentialGain = (70 - authorityScore) * 0.25; // Max potential points if improved to 70
            if (data && data.ctr !== undefined) {
              const ctr = data.ctr || 0;
              if (ctr < 1.5) {
                actions.push({
                  priority: 1,
                  impact: potentialGain,
                  text: `Improve Authority (currently ${authorityScore}%): Increase CTR from ${ctr.toFixed(1)}% to 2%+ by optimizing titles and meta descriptions. Potential gain: +${potentialGain.toFixed(1)} points.`
                });
              } else {
                actions.push({
                  priority: 1,
                  impact: potentialGain,
                  text: `Improve Authority (currently ${authorityScore}%): Build backlinks and improve E-A-T signals. Potential gain: +${potentialGain.toFixed(1)} points.`
                });
              }
            } else {
              actions.push({
                priority: 1,
                impact: potentialGain,
                text: `Improve Authority (currently ${authorityScore}%): Build backlinks, improve E-A-T signals, and optimize CTR. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            }
          }
          
          // Content/Schema (40% weight) - highest weight
          if (contentSchemaScore < 100 && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
            const schemaData = schemaAudit.data;
            const allTypes = new Set();
            // Use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
            if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
              schemaData.allDetectedTypes.forEach(type => {
                if (type) allTypes.add(type);
              });
            } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
              schemaData.schemaTypes.forEach(item => {
                if (item.type) allTypes.add(item.type);
              });
            }
            
            const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
            const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
            const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
            const uniqueTypesCount = allTypes.size;
            
            // Calculate potential improvements
            if (foundationPresent < 4) {
              const missingFoundation = foundationTypes.filter(type => !allTypes.has(type));
              const potentialGain = ((4 - foundationPresent) / 4) * 30 * 0.4; // 30% weight of 40% total
              actions.push({
                priority: 2,
                impact: potentialGain,
                text: `Add missing foundation schemas: ${missingFoundation.join(', ')}. Currently ${foundationPresent}/4. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            }
            
            // Get list of all rich result types (must match api/schema-audit.js)
            const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
            const totalRichResultTypes = richResultTypes.length;
            
            if (richEligibleCount < totalRichResultTypes) {
              const potentialGain = ((totalRichResultTypes - richEligibleCount) / totalRichResultTypes) * 35 * 0.4; // 35% weight of 40% total
              
              // Get list of which rich result types are missing
              const applicableMissingTypes = richResultTypes.filter(type => {
                return !schemaData.richEligible || !schemaData.richEligible[type];
              });
              
              // Check for failed crawls that might affect rich result detection
              const failedPages = schemaData.missingSchemaPages ? schemaData.missingSchemaPages.filter(p => p.error).length : 0;
              const hasFailedCrawls = failedPages > 0;
              
              // Build suggestion text
              let suggestionText;
              if (applicableMissingTypes.length > 0) {
                suggestionText = `Add more rich result types. Currently ${richEligibleCount}/${totalRichResultTypes} eligible. Add: ${applicableMissingTypes.join(', ')} schemas.`;
                if (hasFailedCrawls) {
                  suggestionText += ` Note: ${failedPages} page${failedPages !== 1 ? 's' : ''} failed to crawl - missing types may exist but weren't detected.`;
                }
                suggestionText += ` Potential gain: +${potentialGain.toFixed(1)} points.`;
              } else {
                suggestionText = `Add more rich result types. Currently ${richEligibleCount}/${totalRichResultTypes} eligible. Potential gain: +${potentialGain.toFixed(1)} points.`;
              }
              
              actions.push({
                priority: 3,
                impact: potentialGain,
                text: suggestionText
              });
            }
            
            if (uniqueTypesCount < 15) {
              const potentialGain = ((15 - uniqueTypesCount) / 15) * 15 * 0.4; // 15% weight of 40% total
              actions.push({
                priority: 4,
                impact: potentialGain,
                text: `Increase schema diversity. Currently ${uniqueTypesCount} types (target: 15+). Add more schema types across different page types. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            }
          }
          
          // Visibility (35% weight)
          if (visibilityScore < 90 && data && data.averagePosition !== undefined) {
            const position = data.averagePosition || 0;
            const ctr = data.ctr || 0;
            const potentialGain = (90 - visibilityScore) * 0.35;
            
            if (position > 10) {
              actions.push({
                priority: 5,
                impact: potentialGain,
                text: `Improve Visibility (currently ${visibilityScore}%): Target top 10 positions. Current average position: ${position.toFixed(1)}. Optimize for featured snippets. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            } else if (ctr < 2.0) {
              actions.push({
                priority: 5,
                impact: potentialGain,
                text: `Improve Visibility (currently ${visibilityScore}%): Increase CTR from ${ctr.toFixed(1)}% to 2%+ with better titles and meta descriptions. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            }
          }
          
          // Sort by impact (highest first) and take top 5
          actions.sort((a, b) => b.impact - a.impact);
          const top5Actions = actions.slice(0, 5);
          
          // Update the list
          topActionsList.innerHTML = top5Actions.map((action, index) => 
            `<li style="margin: 0.5rem 0; line-height: 1.5; color: #78350f;">${action.text}</li>`
          ).join('');
          
          if (top5Actions.length === 0) {
            topActionsList.innerHTML = '<li style="margin: 0.5rem 0;">All components are performing well! Maintain current performance.</li>';
          }
          
          explanationDiv.style.display = 'block';
        } else if (explanationDiv) {
          explanationDiv.style.display = 'none';
        }
        
        // Calculate weighted contribution of each component
        const contentSchemaContribution = (contentSchemaScore * 0.4).toFixed(1);
        const visibilityContribution = (visibilityScore * 0.35).toFixed(1);
        const authorityContribution = (authorityScore * 0.25).toFixed(1);
        
        // Create nested pie chart with fill percentages
        // Outer ring: Weighting (40%, 35%, 25%)
        // Inner fill: Score percentage within each segment (like fuel gauge)
        
        const weights = [40, 35, 25];
        const scoresArray = [contentSchemaScore, visibilityScore, authorityScore];
        // Match trend chart colors (avoid red/amber/green to prevent RAG confusion)
        const colors = ['#6b7280', '#2563eb', '#99004C']; // Grey (Content/Schema), Blue (Visibility), Dark pink/magenta (Authority)
        
        // Calculate outer ring data (weighting percentages)
        const outerData = weights;
        
        // Inner ring: Same segment sizes as outer, but we'll use custom drawing to fill only the score percentage
        // The inner data must match outer segment sizes so they align
        const innerData = weights; // Same sizes as outer
        
        // Create chart with custom drawing for inner fill segments
        window.snippetReadinessChart = new Chart(pieChartCanvas, {
          type: 'doughnut',
          data: {
            labels: [
              `Content/Schema`,
              `Visibility`,
              `Authority`
            ],
            datasets: [
              {
                // Outer ring: Weighting percentages (40%, 35%, 25%)
                label: 'Weight',
                data: outerData,
                backgroundColor: colors,
                borderWidth: 4,
                borderColor: '#ffffff',
                cutout: '60%' // Leave room for inner fill
              },
              {
                // Inner ring: Same segment sizes, but will be custom-drawn to show score fill
                label: 'Score Fill',
                data: innerData,
                backgroundColor: colors.map((color, i) => {
                  // Use darker version of segment color for unfilled portion
                  return color + '40'; // Add transparency
                }),
                borderWidth: 4,
                borderColor: '#ffffff',
                cutout: '75%' // Inner ring showing fill
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                display: false // We'll use custom legend
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const datasetIndex = context.datasetIndex;
                    const index = context.dataIndex;
                    
                    if (datasetIndex === 0) {
                      // Outer ring: Show weighting
                      return `Weight: ${weights[index]}%`;
                    } else {
                      // Inner fill: Show score and fill percentage
                      const score = scoresArray[index];
                      const fillPercent = (score / 100) * 100;
                      return `Score: ${score}% (${fillPercent.toFixed(0)}% of segment filled)`;
                    }
                  }
                }
              }
            }
          },
          plugins: [{
            id: 'innerFillAndLabels',
            afterDraw: (chart) => {
              const ctx = chart.ctx;
              const outerMeta = chart.getDatasetMeta(0); // Outer ring
              const innerMeta = chart.getDatasetMeta(1); // Inner ring
              const centerX = chart.chartArea.left + (chart.chartArea.right - chart.chartArea.left) / 2;
              const centerY = chart.chartArea.top + (chart.chartArea.bottom - chart.chartArea.top) / 2;
              const outerRadius = (chart.chartArea.right - chart.chartArea.left) / 2;
              const innerRadius = outerRadius * 0.75; // 75% cutout
              const outerInnerRadius = outerRadius * 0.60; // 60% cutout (where inner ring starts)
              
              // First, clear the inner ring segments (they're drawn by Chart.js but we'll redraw them)
              // Then draw custom filled portions based on scores
              
              outerMeta.data.forEach((outerSegment, index) => {
                const score = scoresArray[index];
                const scorePercent = score / 100; // 0 to 1
                const startAngle = outerSegment.startAngle;
                const endAngle = outerSegment.endAngle;
                const segmentAngle = endAngle - startAngle;
                const filledAngle = segmentAngle * scorePercent;
                const filledEndAngle = startAngle + filledAngle;
                
                // Get RAG color for fill
                let fillColor;
                if (score >= 70) fillColor = '#10b981'; // Green
                else if (score >= 40) fillColor = '#f59e0b'; // Amber
                else fillColor = '#ef4444'; // Red
                
                // Draw the filled portion of this inner segment (fuel gauge effect)
                ctx.save();
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerInnerRadius, startAngle, filledEndAngle, false);
                ctx.arc(centerX, centerY, innerRadius, filledEndAngle, startAngle, true);
                ctx.closePath();
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.restore();
                
                // Draw weight percentage in outer segment (larger, white for grey and blue segments, black for yellow)
                const outerSegmentMidAngle = (startAngle + endAngle) / 2;
                // Position closer to outer edge but still inside segment (about 75% of outer ring width)
                const outerSegmentTextRadius = outerRadius - ((outerRadius - outerInnerRadius) * 0.25);
                const weightTextX = centerX + Math.cos(outerSegmentMidAngle) * outerSegmentTextRadius;
                const weightTextY = centerY + Math.sin(outerSegmentMidAngle) * outerSegmentTextRadius;
                
                ctx.save();
                // Use white text for grey (Content/Schema), blue (Visibility), and dark pink (Authority) segments
                const textColor = (colors[index] === '#6b7280' || colors[index] === '#2563eb' || colors[index] === '#99004C') ? '#ffffff' : '#000000';
                ctx.fillStyle = textColor;
                ctx.font = 'bold 18px system-ui'; // Increased from 14px to 18px
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // Add shadow for readability (dark shadow for white text, light shadow for black text)
                if (textColor === '#ffffff') {
                  ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                } else {
                  ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
                }
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.fillText(`${weights[index]}%`, weightTextX, weightTextY);
                ctx.restore();
                
                // Draw label in the center area, aligned to segment
                const midAngle = (startAngle + endAngle) / 2;
                // Position label in center area (about 30% from center, well inside the 75% cutout)
                const labelRadius = outerRadius * 0.25; // Position in center area
                const labelX = centerX + Math.cos(midAngle) * labelRadius;
                const labelY = centerY + Math.sin(midAngle) * labelRadius;
                
                // Get component names
                const componentNames = ['Content/Schema', 'Visibility', 'Authority'];
                const weight = weights[index];
                
                // Calculate text bounds to avoid arrow overlap
                // Estimate text height: 3 lines with spacing  45px total height
                const textHeight = 45;
                const textWidth = 80; // Approximate max text width
                
                // Draw dotted arrow from label to segment edge, routing around text
                ctx.save();
                ctx.strokeStyle = colors[index];
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // Dotted line
                ctx.beginPath();
                
                // Start arrow from edge of text area with more padding to avoid overlap
                // Calculate perpendicular offset to route around text
                const perpAngle = midAngle + Math.PI / 2; // Perpendicular to segment angle
                const textOffset = 35; // Increased from 25 to 35 - more padding from text edge
                const perpOffset = (textHeight / 2) + 8; // Increased padding perpendicular to text
                const arrowStartX = labelX + Math.cos(midAngle) * textOffset + Math.cos(perpAngle) * perpOffset;
                const arrowStartY = labelY + Math.sin(midAngle) * textOffset + Math.sin(perpAngle) * perpOffset;
                
                // End at inner ring edge
                const segmentEdgeX = centerX + Math.cos(midAngle) * innerRadius;
                const segmentEdgeY = centerY + Math.sin(midAngle) * innerRadius;
                
                // Draw curved path around text (simple two-segment path)
                const midX = (arrowStartX + segmentEdgeX) / 2;
                const midY = (arrowStartY + segmentEdgeY) / 2;
                // Offset midpoint further outward to curve around text with more clearance
                const curveOffset = 25; // Increased from 15 to 25 for more clearance
                const curveMidX = midX + Math.cos(perpAngle) * curveOffset;
                const curveMidY = midY + Math.sin(perpAngle) * curveOffset;
                
                ctx.moveTo(arrowStartX, arrowStartY);
                ctx.quadraticCurveTo(curveMidX, curveMidY, segmentEdgeX, segmentEdgeY);
                ctx.stroke();
                
                // Draw arrowhead
                const arrowLength = 8;
                const arrowAngle = Math.atan2(segmentEdgeY - curveMidY, segmentEdgeX - curveMidX);
                ctx.setLineDash([]); // Solid for arrowhead
                ctx.beginPath();
                ctx.moveTo(segmentEdgeX, segmentEdgeY);
                ctx.lineTo(
                  segmentEdgeX - arrowLength * Math.cos(arrowAngle - Math.PI / 6),
                  segmentEdgeY - arrowLength * Math.sin(arrowAngle - Math.PI / 6)
                );
                ctx.moveTo(segmentEdgeX, segmentEdgeY);
                ctx.lineTo(
                  segmentEdgeX - arrowLength * Math.cos(arrowAngle + Math.PI / 6),
                  segmentEdgeY - arrowLength * Math.sin(arrowAngle + Math.PI / 6)
                );
                ctx.stroke();
                ctx.restore();
                
                // Draw text labels without circles (to prevent overlap)
                ctx.save();
                // Add text shadow for better readability without background
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Draw text with readable fonts
                ctx.fillStyle = colors[index];
                ctx.font = 'bold 13px system-ui';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // First line: Component name
                ctx.fillText(`${componentNames[index]}`, labelX, labelY - 8);
                // Second line: Score percentage (colored) - weight removed, now in outer segment
                ctx.fillStyle = fillColor;
                ctx.font = 'bold 15px system-ui';
                ctx.fillText(`Score: ${score}%`, labelX, labelY + 8);
                
                ctx.restore();
              });
            }
          }]
        });
        
        // Create custom legend with scores
        if (legendElement) {
          const getRAGColor = (score) => {
            if (score >= 70) return '#10b981';
            if (score >= 40) return '#f59e0b';
            return '#ef4444';
          };
          
          const getRAGLabel = (score) => {
            if (score >= 70) return 'Green';
            if (score >= 40) return 'Amber';
            return 'Red';
          };
          
          legendElement.innerHTML = `
            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #6b7280;">
              <div style="width: 12px; height: 12px; background: #6b7280; border-radius: 2px; flex-shrink: 0;"></div>
              <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Content/Schema</div>
                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 40%<br>Score: <strong style="color: ${getRAGColor(contentSchemaScore)};">${contentSchemaScore}</strong> (${getRAGLabel(contentSchemaScore)})<br>Contribution: ${contentSchemaContribution} pts</div>
              </div>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #2563eb;">
              <div style="width: 12px; height: 12px; background: #2563eb; border-radius: 2px; flex-shrink: 0;"></div>
              <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Visibility</div>
                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 35%<br>Score: <strong style="color: ${getRAGColor(visibilityScore)};">${visibilityScore}</strong> (${getRAGLabel(visibilityScore)})<br>Contribution: ${visibilityContribution} pts</div>
              </div>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #99004C;">
              <div style="width: 12px; height: 12px; background: #99004C; border-radius: 2px; flex-shrink: 0;"></div>
              <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Authority</div>
                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 25%<br>Score: <strong style="color: ${getRAGColor(authorityScore)};">${authorityScore}</strong> (${getRAGLabel(authorityScore)})<br>Contribution: ${authorityContribution} pts</div>
              </div>
            </div>
          `;
        }
      }

      // Format numbers for display
      const formatNumber = (num) => {
        if (num >= 1000000) {
          return (num / 1000000).toFixed(2) + 'M';
        } else if (num >= 1000) {
          return (num / 1000).toFixed(2) + 'K';
        }
        return num.toLocaleString();
      };

      // Display metrics
      const metricsGrid = document.getElementById('metricsGrid');
      metricsGrid.innerHTML = `
        <div class="metric-card">
          <div class="value">${formatNumber(data.totalClicks)}</div>
          <div class="label">Total Clicks</div>
        </div>
        <div class="metric-card">
          <div class="value">${formatNumber(data.totalImpressions)}</div>
          <div class="label">Total Impressions</div>
        </div>
        <div class="metric-card">
          <div class="value">${data.averagePosition.toFixed(1)}</div>
          <div class="label">Avg Position</div>
        </div>
        <div class="metric-card">
          <div class="value">${(data.ctr || 0).toFixed(1)}%</div>
          <div class="label">CTR</div>
        </div>
      `;

      // Wait a moment for DOM to update, then create charts (charts need visible canvas)
      setTimeout(async () => {
        debugLog('Starting chart creation (setTimeout callback)...', 'info');
        
        // Check if Chart.js is loaded
        debugLog('Checking Chart.js availability...', 'info');
        if (typeof Chart === 'undefined') {
          debugLog(' Chart.js library not loaded', 'error');
          console.error('Chart.js library not loaded');
          showStatus('Chart.js library failed to load. Please refresh the page.', 'error');
          return;
        }
        debugLog(' Chart.js library available', 'success');
        debugLog(`Chart constructor: ${typeof Chart}`, 'info');

        // Create radar chart
        debugLog('Creating radar chart...', 'info');
        const radarCanvas = document.getElementById('radarChart');
        if (!radarCanvas) {
          debugLog(' Radar chart canvas not found', 'error');
          console.error('Radar chart canvas not found');
          return;
        }
        debugLog(' Radar chart canvas found', 'success');
        
        // Safely destroy existing chart if it exists
        debugLog(`Checking for existing radarChart: ${window.radarChart ? 'exists' : 'null'}`, 'info');
        try {
          if (window.radarChart) {
            debugLog(`radarChart type: ${typeof window.radarChart}`, 'info');
            debugLog(`radarChart instanceof Chart: ${window.radarChart instanceof Chart}`, 'info');
            debugLog(`radarChart.destroy type: ${typeof window.radarChart.destroy}`, 'info');
            
            // Check if it's actually a Chart instance
            if (window.radarChart instanceof Chart && typeof window.radarChart.destroy === 'function') {
              debugLog('Destroying existing radar chart...', 'info');
              window.radarChart.destroy();
              debugLog(' Existing radar chart destroyed', 'success');
            } else {
              debugLog('Existing radarChart is not a valid Chart instance, clearing...', 'info');
            }
            window.radarChart = null;
          } else {
            debugLog('No existing radar chart to destroy', 'info');
          }
        } catch (e) {
          debugLog(` Error destroying existing radar chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.warn('Error destroying existing radar chart:', e);
          window.radarChart = null;
        }
        
        const radarCtx = radarCanvas.getContext('2d');
        debugLog('Creating new Chart instance for radar chart...', 'info');
        try {
          // Use ordered pillars for consistent ordering
          const orderedPillars = getOrderedPillars(scores);
          const orderedLabels = orderedPillars.map(([key]) => pillarNames[key]);
          const orderedData = orderedPillars.map(([, score]) => score);
          
          // Define pillar colors for radar chart (matching trend chart)
          const radarPillarColors = {
            'Local Entity': 'rgba(147, 51, 234, 1)', // Purple
            'Service Area': '#00FFFF', // Cyan (not RAG color)
            'Authority': '#99004C', // Dark pink/magenta
            'Visibility': 'rgba(37, 99, 235, 1)', // Blue
            'Content / Schema': 'rgba(107, 114, 128, 1)' // Grey
          };
          
          window.radarChart = new Chart(radarCtx, {
            type: 'radar',
            data: {
              labels: orderedLabels,
              datasets: [{
                label: 'Current Scores',
                data: orderedData,
                backgroundColor: 'rgba(59, 130, 246, 0.2)',
                borderColor: 'rgba(37, 99, 235, 1)',
                pointBackgroundColor: 'rgba(37, 99, 235, 1)',
                pointBorderColor: '#fff',
                pointHoverBackgroundColor: '#fff',
                pointHoverBorderColor: 'rgba(37, 99, 235, 1)'
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              layout: {
                padding: {
                  top: 20,
                  bottom: 20,
                  left: 20,
                  right: 20
                }
              },
              scales: {
                r: {
                  beginAtZero: false,
                  min: 20,
                  max: 100,
                  ticks: {
                    stepSize: 20,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    color: '#1e293b'
                  },
                  pointLabels: {
                    font: {
                      size: 16,
                      weight: 'bold'
                    },
                    color: '#1e293b',
                    padding: 20
                  },
                  grid: {
                    color: 'rgba(100, 116, 139, 0.2)'
                  },
                  angleLines: {
                    color: 'rgba(100, 116, 139, 0.3)'
                  }
                }
              },
              plugins: {
                legend: {
                  labels: {
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    padding: 15
                  }
                }
              }
            },
            plugins: [{
              id: 'radarScoreLabels',
              afterDraw: (chart) => {
                const ctx = chart.ctx;
                const scale = chart.scales.r;
                const pointLabelItems = scale._pointLabelItems || [];
                const dataset = chart.data.datasets[0];
                const meta = chart.getDatasetMeta(0);
                
                // Color each point with its pillar color (Chart.js already draws the lines)
                pointLabelItems.forEach((item, index) => {
                  if (item && orderedData[index] !== undefined) {
                    const score = orderedData[index];
                    const label = orderedLabels[index];
                    const color = radarPillarColors[label] || 'rgba(37, 99, 235, 1)';
                    
                    // Get the point for this index
                    const point = meta.data[index];
                    if (point) {
                      // Draw point in pillar color (Chart.js already draws the connecting lines)
                      ctx.save();
                      ctx.fillStyle = color;
                      ctx.beginPath();
                      ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                      ctx.fill();
                      ctx.strokeStyle = '#fff';
                      ctx.lineWidth = 2;
                      ctx.stroke();
                      ctx.restore();
                    }
                    
                    // Get RAG color based on score for text
                    let ragColor = '#1e293b'; // Default dark
                    if (score >= 70) ragColor = '#10b981'; // Green
                    else if (score >= 40) ragColor = '#f59e0b'; // Amber
                    else ragColor = '#ef4444'; // Red
                    
                    // Draw the score percentage directly below the label
                    ctx.save();
                    ctx.fillStyle = ragColor;
                    ctx.font = 'bold 14px system-ui';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
                    ctx.shadowBlur = 4;
                    // Position it 20px below the label
                    const scoreY = item.y + 20;
                    ctx.fillText(`${Math.round(score)}%`, item.x, scoreY);
                    ctx.restore();
                  }
                });
              }
            }]
          });
          debugLog(' Radar chart created successfully', 'success');
          debugLog(`radarChart type after creation: ${typeof window.radarChart}`, 'info');
          debugLog(`radarChart instanceof Chart: ${window.radarChart instanceof Chart}`, 'info');
        } catch (e) {
          debugLog(` Error creating radar chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.error('Error creating radar chart:', e);
        }

        // Create trend chart (mock data for now)
        debugLog('Creating trend chart...', 'info');
        const trendCanvas = document.getElementById('trendChart');
        if (!trendCanvas) {
          debugLog(' Trend chart canvas not found', 'error');
          console.error('Trend chart canvas not found');
          return;
        }
        debugLog(' Trend chart canvas found', 'success');
        
        // Show loading state while fetching data
        const trendChartContainer = trendCanvas.parentElement;
        if (trendChartContainer) {
          // Remove any existing error messages
          const existingError = trendChartContainer.querySelector('.trend-chart-error');
          if (existingError) existingError.remove();
          
          // Show loading spinner
          const loadingDiv = document.createElement('div');
          loadingDiv.className = 'trend-chart-loading';
          loadingDiv.style.cssText = 'text-align: center; padding: 2rem; color: #64748b; font-size: 0.9rem;';
          loadingDiv.innerHTML = '<div style="display: inline-block; width: 20px; height: 20px; border: 3px solid #e2e8f0; border-top-color: #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 0.5rem;"></div>Loading historical data from Supabase...';
          // Add spin animation if not already in stylesheet
          if (!document.getElementById('trend-chart-spin-style')) {
            const style = document.createElement('style');
            style.id = 'trend-chart-spin-style';
            style.textContent = '@keyframes spin { to { transform: rotate(360deg); } }';
            document.head.appendChild(style);
          }
          trendChartContainer.insertBefore(loadingDiv, trendCanvas);
        }
        
        // Safely destroy existing chart if it exists
        debugLog(`Checking for existing trendChart: ${window.trendChart ? 'exists' : 'null'}`, 'info');
        try {
          if (window.trendChart) {
            debugLog(`trendChart type: ${typeof window.trendChart}`, 'info');
            debugLog(`trendChart instanceof Chart: ${window.trendChart instanceof Chart}`, 'info');
            debugLog(`trendChart.destroy type: ${typeof window.trendChart.destroy}`, 'info');
            // Check if it's actually a Chart instance
            if (window.trendChart instanceof Chart && typeof window.trendChart.destroy === 'function') {
              debugLog('Destroying existing trend chart...', 'info');
              window.trendChart.destroy();
              debugLog(' Existing trend chart destroyed', 'success');
            } else {
              debugLog('Existing trendChart is not a valid Chart instance, clearing...', 'info');
            }
            window.trendChart = null;
          } else {
            debugLog('No existing trend chart to destroy', 'info');
          }
        } catch (e) {
          debugLog(` Error destroying existing trend chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.warn('Error destroying existing trend chart:', e);
          window.trendChart = null;
        }
        
        const trendCtx = trendCanvas.getContext('2d');
        const dateRange = parseInt(document.getElementById('dateRange').value) || 30;
        debugLog(`Creating trend chart for date range: ${dateRange} days`, 'info');
        
        // Determine number of data points and label frequency based on date range
        let numDataPoints, labelStep, dateFormat;
        if (dateRange <= 30) {
          // For 30 days or less: show daily data, all labels
          numDataPoints = dateRange;
          labelStep = 1;
          dateFormat = { month: 'short', day: 'numeric' };
        } else if (dateRange <= 90) {
          // For 90 days: show daily data, label every 3-5 days
          numDataPoints = dateRange;
          labelStep = Math.ceil(dateRange / 20); // ~20 labels max
          dateFormat = { month: 'short', day: 'numeric' };
        } else if (dateRange <= 180) {
          // For 6 months: show weekly data, label every week
          numDataPoints = Math.ceil(dateRange / 7);
          labelStep = 1;
          dateFormat = { month: 'short', day: 'numeric' };
        } else {
          // For 12 months: show weekly data, label every 2-4 weeks
          numDataPoints = Math.ceil(dateRange / 7);
          labelStep = Math.ceil(numDataPoints / 15); // ~15 labels max
          dateFormat = { month: 'short', day: 'numeric' };
        }
        
        // Generate date labels and store Date objects
        const allDates = Array.from({ length: numDataPoints }, (_, i) => {
          const d = new Date();
          if (dateRange <= 90) {
            // Daily data
            d.setDate(d.getDate() - (numDataPoints - 1 - i));
          } else {
            // Weekly data
            d.setDate(d.getDate() - ((numDataPoints - 1 - i) * 7));
          }
          return d;
        });
        
        // Store Date objects for period detection (for mock data)
        const mockDateObjects = allDates.slice();
        
        // Create labels array with appropriate spacing and year detection
        let lastVisibleYear = null;
        const dates = allDates.map((d, i) => {
          if (i % labelStep === 0 || i === allDates.length - 1) {
            const currentYear = d.getFullYear();
            const formattedDate = d.toLocaleDateString('en-GB', dateFormat);
            
            // Add year if it changed from the last visible label
            if (lastVisibleYear !== null && currentYear !== lastVisibleYear) {
              lastVisibleYear = currentYear;
              return `${formattedDate} ${currentYear}`;
            }
            
            lastVisibleYear = currentYear;
            return formattedDate;
          }
          return ''; // Empty string for labels we don't want to show
        });
        
        // Store date objects for mock data (will be updated if timeseries data exists)
        chartDateObjects = mockDateObjects;
        debugLog('Creating new Chart instance for trend chart...', 'info');
        try {
          // CRITICAL FIX: Always fetch fresh timeseries from Supabase instead of using stale data.timeseries
          // This ensures we have the latest GSC data, not just what was saved during the last audit
          let timeseries = [];
          const propertyUrl = document.getElementById('propertyUrl')?.value || data?.propertyUrl || '';
          if (propertyUrl) {
            try {
              const endDate = new Date().toISOString().split('T')[0];
              const startDate = new Date();
              startDate.setDate(startDate.getDate() - dateRange); // Use chart's date range
              const startDateStr = startDate.toISOString().split('T')[0];
              
              debugLog(`Fetching fresh timeseries from Supabase for date range: ${startDateStr} to ${endDate}`, 'info');
              const timeseriesResponse = await fetch(apiUrl(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDate}`));
              if (timeseriesResponse.ok) {
                const timeseriesData = await timeseriesResponse.json();
                if (timeseriesData.status === 'ok' && timeseriesData.timeseries && Array.isArray(timeseriesData.timeseries)) {
                  timeseries = timeseriesData.timeseries;
                  debugLog(` Fetched ${timeseries.length} fresh timeseries data points from Supabase (last date: ${timeseries.length > 0 ? timeseries[timeseries.length - 1].date : 'none'})`, 'success');
                } else {
                  debugLog(` Supabase timeseries response missing data, falling back to data.timeseries`, 'warn');
                  timeseries = data.timeseries || [];
                }
              } else {
                debugLog(` Failed to fetch timeseries from Supabase (${timeseriesResponse.status}), falling back to data.timeseries`, 'warn');
                timeseries = data.timeseries || [];
              }
            } catch (fetchError) {
              debugLog(` Error fetching fresh timeseries: ${fetchError.message}, falling back to data.timeseries`, 'warn');
              timeseries = data.timeseries || [];
            }
          } else {
            debugLog(` No property URL found, using data.timeseries`, 'warn');
            timeseries = data.timeseries || [];
          }
          
          debugLog(`Using ${timeseries.length} timeseries data points (last date: ${timeseries.length > 0 ? timeseries[timeseries.length - 1].date : 'none'})`, 'info');
          
          // Check if we have data
          if (!timeseries || timeseries.length === 0) {
            debugLog(' No timeseries data available. Chart will show mock data. Run a new audit to get real GSC historical data.', 'warn');
            // Show message to user (only if message doesn't already exist)
            const trendCanvas = document.getElementById('trendChart');
            if (trendCanvas && trendCanvas.parentElement) {
              // Check if message already exists
              const existingMessage = trendCanvas.parentElement.querySelector('.trend-chart-warning');
              if (!existingMessage) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'trend-chart-warning';
                messageDiv.style.cssText = 'background: #fff3cd; padding: 1rem; border-radius: 4px; border-left: 3px solid #f59e0b; margin-bottom: 1rem; font-size: 0.9rem; color: #856404;';
                messageDiv.innerHTML = '<strong>No historical data available.</strong> The trend chart requires timeseries data from Google Search Console. Please run a new audit to populate the chart with real historical data.';
                trendCanvas.parentElement.insertBefore(messageDiv, trendCanvas);
              }
            }
          }
          
          // If we have timeseries data, use it; otherwise fall back to mock data
          let localEntityData, serviceAreaData, authorityData, visibilityData, contentSchemaData, brandOverlayData;
          let contentSchemaDataEstimated = []; // Declare in outer scope for use in chart creation
          let chartDates = dates;
          let chartDateObjects = []; // Store Date objects for period detection
          
          // Declare maps in outer scope so they're accessible everywhere
          // Also make them global so displayDashboard can access them for Data Date display
          let contentSchemaHistory = [];
          let contentSchemaMap = new Map();
          let localEntityMap = new Map();
          let serviceAreaMap = new Map();
          let authorityMap = new Map(); // Store historical Authority scores from Supabase (legacy: single value)
          let authorityBySegmentMap = new Map(); // Store historical segmented Authority scores from Supabase (new: {all, nonEducation, money})
          let visibilityMap = new Map(); // Store historical Visibility scores from Supabase
          let brandOverlayMap = new Map(); // Store historical Brand Overlay scores from Supabase
          
          // Make maps global for access by displayDashboard
          window.visibilityMap = visibilityMap;
          window.authorityMap = authorityMap;
          window.brandOverlayMap = brandOverlayMap;
          const currentContentSchema = scores.contentSchema || 0;
          const currentBrandOverlay = scores.brandOverlay?.score || null;
          
          // Declare latestAuditDateStr and latestAuditDate in outer scope so they're accessible in timeseries.forEach
          let today = new Date();
          today.setHours(0, 0, 0, 0);
          let todayStr = today.toISOString().split('T')[0];
          let latestAuditDateStr = todayStr; // Default to today if no audit found
          let latestAuditDate = null; // Will be set from historical data
          
          if (timeseries.length > 0) {
            // Fetch historical Content/Schema data from Supabase (async operation)
            const propertyUrl = document.getElementById('propertyUrl')?.value || '';
            // Use the actual date range from timeseries data (not calculated from today)
            // This ensures we query the correct year (2024 vs 2025)
            const timeseriesStartDate = timeseries[0].date; // First date in timeseries
            const timeseriesEndDate = timeseries[timeseries.length - 1].date; // Last date in timeseries
            // CRITICAL: Query ALL historical audit data, not just timeseries range
            // The user manually added 18 months of historical data, so we need to fetch all of it
            // Query from 2 years ago to today to ensure we get all historical data
            // Don't limit to timeseries range - fetch all available historical audit data
            const historicalStartDate = new Date();
            historicalStartDate.setFullYear(historicalStartDate.getFullYear() - 2);
            const startDate = historicalStartDate.toISOString().split('T')[0]; // 2 years ago
            const endDate = todayStr; // Use today, not timeseries end date
            
            debugLog(`Fetching Content/Schema history from Supabase: ${startDate} to ${endDate} (ALL historical data)`, 'info');
            debugLog(`Timeseries date range: ${timeseriesStartDate} to ${timeseriesEndDate}`, 'info');
            
            // Fetch historical data asynchronously (includes Content/Schema AND Business Profile data)
            if (propertyUrl) {
              try {
                contentSchemaHistory = await fetchContentSchemaHistory(propertyUrl, startDate, endDate);
                
                // Handle multiple audits per day: only keep the latest audit for each date
                // Group by date and keep only the most recent one (by timestamp if available, or last in array)
                const auditsByDate = new Map();
                contentSchemaHistory.forEach(record => {
                  let normalizedDate = null;
                  if (record.date) {
                    if (typeof record.date === 'string') {
                      normalizedDate = record.date.split('T')[0];
                    } else if (record.date instanceof Date) {
                      normalizedDate = record.date.toISOString().split('T')[0];
                    } else {
                      normalizedDate = String(record.date).split('T')[0];
                    }
                  }
                  
                  if (normalizedDate) {
                    // If we already have an audit for this date, keep the one with later timestamp
                    const existing = auditsByDate.get(normalizedDate);
                    if (!existing || (record.timestamp && existing.timestamp && record.timestamp > existing.timestamp)) {
                      auditsByDate.set(normalizedDate, record);
                    }
                  }
                });
                
                // Use only the latest audit per date
                const deduplicatedHistory = Array.from(auditsByDate.values());
                debugLog(`Deduplicated ${contentSchemaHistory.length} audits to ${deduplicatedHistory.length} unique dates (removed ${contentSchemaHistory.length - deduplicatedHistory.length} duplicate dates)`, 'info');
                contentSchemaHistory = deduplicatedHistory;
                
                // CRITICAL: Validate audits for partial/failed data (for non-GSC pillars only)
                // Detect audits with suspiciously low page counts compared to recent audits
                // This prevents using partial audit data for Content/Schema and Local Entity/Service Area
                const validateAuditQuality = (records) => {
                  if (records.length === 0) return records;
                  
                  // Sort by date to find baseline
                  const sortedRecords = [...records].sort((a, b) => {
                    const dateA = a.date ? (typeof a.date === 'string' ? a.date.split('T')[0] : String(a.date).split('T')[0]) : '';
                    const dateB = b.date ? (typeof b.date === 'string' ? b.date.split('T')[0] : String(b.date).split('T')[0]) : '';
                    return dateA.localeCompare(dateB);
                  });
                  
                  // Find the median page count from recent audits (last 10 audits or all if < 10)
                  const recentAudits = sortedRecords.slice(-10);
                  const pageCounts = recentAudits
                    .map(r => r.schemaTotalPages || r.schema_total_pages || 0)
                    .filter(count => count > 0)
                    .sort((a, b) => a - b);
                  
                  if (pageCounts.length === 0) {
                    debugLog(`[Audit Validation] No page count data available, skipping validation`, 'info');
                    return records;
                  }
                  
                  // Use median as baseline (more robust than mean for outliers)
                  const medianPageCount = pageCounts[Math.floor(pageCounts.length / 2)];
                  const minAcceptablePages = Math.max(10, medianPageCount * 0.1); // At least 10% of median, minimum 10 pages
                  
                  debugLog(`[Audit Validation] Median page count: ${medianPageCount}, Minimum acceptable: ${minAcceptablePages}`, 'info');
                  
                  // Mark records with suspiciously low page counts
                  const validatedRecords = records.map(record => {
                    const pageCount = record.schemaTotalPages || record.schema_total_pages || 0;
                    const isSuspicious = pageCount > 0 && pageCount < minAcceptablePages;
                    
                    if (isSuspicious) {
                      debugLog(`[Audit Validation]  Marking audit ${record.date} as suspicious: ${pageCount} pages (expected ~${medianPageCount})`, 'warn');
                      record._isPartialAudit = true;
                      record._partialReason = `Low page count: ${pageCount} pages (expected ~${medianPageCount})`;
                    }
                    
                    return record;
                  });
                  
                  return validatedRecords;
                };
                
                // Validate audit quality
                contentSchemaHistory = validateAuditQuality(contentSchemaHistory);
                
                // CRITICAL: Sort by date to ensure chronological processing
                // This ensures we always have a "last good value" to fall back to for partial audits
                contentSchemaHistory.sort((a, b) => {
                  const dateA = a.date ? (typeof a.date === 'string' ? a.date.split('T')[0] : String(a.date).split('T')[0]) : '';
                  const dateB = b.date ? (typeof b.date === 'string' ? b.date.split('T')[0] : String(b.date).split('T')[0]) : '';
                  return dateA.localeCompare(dateB);
                });
                
                // CRITICAL: Validate and smooth Authority scores
                // Backlink scores can drop to 0 if CSV isn't loaded, causing Authority to fluctuate wildly
                // Use last known good backlink score if current one is suspiciously low
                let lastGoodBacklinkScore = null;
                contentSchemaHistory.forEach(record => {
                  const backlinkScore = record.authorityBacklinkScore || record.authority_backlink_score;
                  if (backlinkScore !== null && backlinkScore !== undefined && backlinkScore > 0) {
                    lastGoodBacklinkScore = backlinkScore;
                  } else if (lastGoodBacklinkScore !== null && backlinkScore === 0) {
                    // Backlink score dropped to 0 - likely CSV not loaded, use last good value
                    record._useLastGoodBacklink = true;
                    record._lastGoodBacklinkScore = lastGoodBacklinkScore;
                    debugLog(`[Authority Validation]  Backlink score is 0 for ${record.date}, using last good value (${lastGoodBacklinkScore})`, 'warn');
                  }
                });
                
                // Recalculate Authority scores with smoothed backlink data
                contentSchemaHistory.forEach(record => {
                  if (record._useLastGoodBacklink && record.authorityScore !== null && record.authorityScore !== undefined) {
                    const behaviour = record.authorityBehaviourScore || record.authority_behaviour_score || 0;
                    const ranking = record.authorityRankingScore || record.authority_ranking_score || 0;
                    const backlinks = record._lastGoodBacklinkScore || 0;
                    const reviews = record.authorityReviewScore || record.authority_review_score || 0;
                    
                    // Recalculate Authority with smoothed backlink score
                    const recalculated = Math.round(
                      0.4 * behaviour +
                      0.2 * ranking +
                      0.2 * backlinks +
                      0.2 * reviews
                    );
                    
                    if (recalculated !== record.authorityScore) {
                      debugLog(`[Authority Validation] Recalculated Authority for ${record.date}: ${record.authorityScore}  ${recalculated} (using last good backlink score ${backlinks})`, 'info');
                      record._recalculatedAuthorityScore = recalculated; // Store separately, don't overwrite original
                    }
                  }
                });
                
                // Create maps of dates to scores from Supabase
                // Normalize dates to YYYY-MM-DD format (Supabase might return with timezone)
                // latestAuditDate is already tracked from the deduplication loop above
                // CRITICAL: Skip partial audits for non-GSC pillars (Content/Schema, Local Entity, Service Area)
                let lastGoodContentSchema = null;
                let lastGoodContentSchemaDate = null;
                let lastGoodLocalEntity = null;
                let lastGoodLocalEntityDate = null;
                let lastGoodServiceArea = null;
                let lastGoodServiceAreaDate = null;
                
                contentSchemaHistory.forEach(record => {
                  // Ensure date is in YYYY-MM-DD format (strip time if present)
                  // Handle both date strings and Date objects
                  let normalizedDate = null;
                  if (record.date) {
                    if (typeof record.date === 'string') {
                      normalizedDate = record.date.split('T')[0];
                    } else if (record.date instanceof Date) {
                      normalizedDate = record.date.toISOString().split('T')[0];
                    } else {
                      normalizedDate = String(record.date).split('T')[0];
                    }
                  }
                  
                  if (normalizedDate) {
                    // Update latestAuditDate if this date is newer
                    if (!latestAuditDate || normalizedDate > latestAuditDate) {
                      latestAuditDate = normalizedDate;
                      latestAuditDateStr = normalizedDate;
                    }
                    // Content/Schema data - SKIP if partial audit
                    if (record.contentSchemaScore !== null && record.contentSchemaScore !== undefined) {
                      if (record._isPartialAudit) {
                        debugLog(`[Audit Validation]  Skipping Content/Schema for ${normalizedDate} (partial audit: ${record._partialReason}), using last good value (${lastGoodContentSchema} from ${lastGoodContentSchemaDate || 'none'})`, 'warn');
                        // Use last good value instead
                        if (lastGoodContentSchema !== null && lastGoodContentSchema !== undefined) {
                          contentSchemaMap.set(normalizedDate, lastGoodContentSchema);
                        }
                      } else {
                        contentSchemaMap.set(normalizedDate, record.contentSchemaScore);
                        lastGoodContentSchema = record.contentSchemaScore;
                        lastGoodContentSchemaDate = normalizedDate;
                        debugLog(`Mapped Content/Schema: ${normalizedDate} = ${record.contentSchemaScore}`, 'info');
                      }
                    }
                    // Business Profile data (Local Entity and Service Area) - SKIP if partial audit
                    if (record.localEntityScore !== null && record.localEntityScore !== undefined) {
                      if (record._isPartialAudit) {
                        debugLog(`[Audit Validation]  Skipping Local Entity for ${normalizedDate} (partial audit: ${record._partialReason}), using last good value (${lastGoodLocalEntity} from ${lastGoodLocalEntityDate || 'none'})`, 'warn');
                        // Use last good value instead
                        if (lastGoodLocalEntity !== null && lastGoodLocalEntity !== undefined) {
                          localEntityMap.set(normalizedDate, lastGoodLocalEntity);
                        }
                      } else {
                        localEntityMap.set(normalizedDate, record.localEntityScore);
                        lastGoodLocalEntity = record.localEntityScore;
                        lastGoodLocalEntityDate = normalizedDate;
                        debugLog(`Mapped Local Entity: ${normalizedDate} = ${record.localEntityScore}`, 'info');
                      }
                    }
                    if (record.serviceAreaScore !== null && record.serviceAreaScore !== undefined) {
                      if (record._isPartialAudit) {
                        debugLog(`[Audit Validation]  Skipping Service Area for ${normalizedDate} (partial audit: ${record._partialReason}), using last good value (${lastGoodServiceArea} from ${lastGoodServiceAreaDate || 'none'})`, 'warn');
                        // Use last good value instead
                        if (lastGoodServiceArea !== null && lastGoodServiceArea !== undefined) {
                          serviceAreaMap.set(normalizedDate, lastGoodServiceArea);
                        }
                      } else {
                        serviceAreaMap.set(normalizedDate, record.serviceAreaScore);
                        lastGoodServiceArea = record.serviceAreaScore;
                        lastGoodServiceAreaDate = normalizedDate;
                        debugLog(`Mapped Service Area: ${normalizedDate} = ${record.serviceAreaScore}`, 'info');
                      }
                    }
                    // Authority data (use stored Authority score if available, calculated with new formula)
                    // CRITICAL: Use recalculated Authority score if backlink smoothing was applied
                    if (record.authorityScore !== null && record.authorityScore !== undefined) {
                      // Use recalculated score if available (from backlink smoothing)
                      const authorityScoreToUse = record._recalculatedAuthorityScore !== undefined 
                        ? record._recalculatedAuthorityScore 
                        : record.authorityScore;
                      authorityMap.set(normalizedDate, authorityScoreToUse);
                      if (record._recalculatedAuthorityScore !== undefined) {
                        debugLog(`Mapped Authority (smoothed): ${normalizedDate} = ${authorityScoreToUse} (was ${record.authorityScore})`, 'info');
                      } else {
                        debugLog(`Mapped Authority: ${normalizedDate} = ${authorityScoreToUse}`, 'info');
                      }
                    }
                    // Segmented Authority data (new: store segmented scores for historical tracking)
                    if (record.authorityBySegment !== null && record.authorityBySegment !== undefined) {
                      // authorityBySegment is a JSON object: {all: {total, behaviour, ranking, backlinks, reviews}, nonEducation: {...}, money: {...}}
                      authorityBySegmentMap.set(normalizedDate, record.authorityBySegment);
                      debugLog(`Mapped Authority by Segment: ${normalizedDate} = ${JSON.stringify(record.authorityBySegment)}`, 'info');
                    }
                    // Visibility data (use stored Visibility score from Supabase)
                    if (record.visibilityScore !== null && record.visibilityScore !== undefined) {
                      visibilityMap.set(normalizedDate, record.visibilityScore);
                      debugLog(`Mapped Visibility: ${normalizedDate} = ${record.visibilityScore}`, 'info');
                    }
                    // Brand Overlay data (Phase 1: stored as brand_score)
                    if (record.brandScore !== null && record.brandScore !== undefined) {
                      brandOverlayMap.set(normalizedDate, record.brandScore);
                      debugLog(`Mapped Brand Overlay: ${normalizedDate} = ${record.brandScore}`, 'info');
                    }
                  }
                });
                
                const hasHistoricalData = contentSchemaHistory.length > 0;
                if (hasHistoricalData) {
                  debugLog(`Using ${contentSchemaHistory.length} historical audit records from Supabase`, 'info');
                  // Debug: Show what data we have for each pillar
                  const contentSchemaCount = Array.from(contentSchemaMap.values()).filter(v => v !== null && v !== undefined).length;
                  const localEntityCount = Array.from(localEntityMap.values()).filter(v => v !== null && v !== undefined).length;
                  const serviceAreaCount = Array.from(serviceAreaMap.values()).filter(v => v !== null && v !== undefined).length;
                  const authorityCount = Array.from(authorityMap.values()).filter(v => v !== null && v !== undefined).length;
                  const visibilityCount = Array.from(visibilityMap.values()).filter(v => v !== null && v !== undefined).length;
                  const brandCount = Array.from(brandOverlayMap.values()).filter(v => v !== null && v !== undefined).length;
                  debugLog(`[Supabase Data] Content/Schema: ${contentSchemaCount} entries, Local Entity: ${localEntityCount} entries, Service Area: ${serviceAreaCount} entries, Authority: ${authorityCount} entries, Visibility: ${visibilityCount} entries, Brand: ${brandCount} entries`, 'info');
                  
                  // Debug: Show sample records to understand structure
                  if (contentSchemaHistory.length > 0) {
                    const sampleRecord = contentSchemaHistory[0];
                    debugLog(`[Sample Record] Keys: ${Object.keys(sampleRecord).join(', ')}, date: ${sampleRecord.date}, contentSchemaScore: ${sampleRecord.contentSchemaScore}, localEntityScore: ${sampleRecord.localEntityScore}, serviceAreaScore: ${sampleRecord.serviceAreaScore}`, 'info');
                  }
                  
                  // Show latest dates for each pillar
                  if (contentSchemaMap.size > 0) {
                    const latestContentSchemaDate = Array.from(contentSchemaMap.keys()).sort().reverse()[0];
                    debugLog(`[Supabase Data] Latest Content/Schema date: ${latestContentSchemaDate}`, 'info');
                  }
                  if (localEntityMap.size > 0) {
                    const latestLocalEntityDate = Array.from(localEntityMap.keys()).sort().reverse()[0];
                    debugLog(`[Supabase Data] Latest Local Entity date: ${latestLocalEntityDate}`, 'info');
                  }
                  if (serviceAreaMap.size > 0) {
                    const latestServiceAreaDate = Array.from(serviceAreaMap.keys()).sort().reverse()[0];
                    debugLog(`[Supabase Data] Latest Service Area date: ${latestServiceAreaDate}`, 'info');
                  }
                } else {
                  debugLog(`No historical data found. Will use current scores for all points.`, 'info');
                }
                
                // Phase 3: Render Money Pages trend chart
                if (typeof renderMoneyPagesTrendChart === 'function') {
                  setTimeout(() => {
                    renderMoneyPagesTrendChart(contentSchemaHistory);
                  }, 1000); // Delay to ensure DOM is ready and chart container exists
                } else {
                  debugLog(' renderMoneyPagesTrendChart function not found', 'warn');
                }
              } catch (error) {
                debugLog(` Error fetching historical data: ${error.message}`, 'warn');
                // Ensure latestAuditDateStr is still defined even if fetch fails
                // It's already set to todayStr as default, so it should be fine
                debugLog(`Using default latestAuditDateStr: ${latestAuditDateStr}`, 'info');
                contentSchemaHistory = [];
              }
            } else {
              debugLog(`No property URL found. Cannot fetch historical data.`, 'info');
            }
            
            // Get current Business Profile data for Local Entity and Service Area (fallback if no historical data)
            const hasLocalSignals = saved && saved.localSignals && saved.localSignals.status === 'ok' && saved.localSignals.data;
            const localSignalsData = hasLocalSignals ? saved.localSignals.data : null;
            
            // Calculate current Local Entity and Service Area scores from Business Profile data (if available)
            // These will be used as fallback when historical data is not available for a specific date
            let currentLocalEntity, currentServiceArea;
            if (hasLocalSignals && localSignalsData) {
              // Local Entity: NAP consistency + bonuses
              let baseScore = localSignalsData.napConsistencyScore || 0;
              if (localSignalsData.knowledgePanelDetected) {
                baseScore = Math.min(100, baseScore + 10);
              }
              if (localSignalsData.locations && localSignalsData.locations.length > 0) {
                baseScore = Math.min(100, baseScore + 5);
              }
              currentLocalEntity = clampScore(baseScore);
              
              // Service Area: based on service areas count
              const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
              if (serviceAreasCount === 0) {
                currentServiceArea = 0;
              } else if (serviceAreasCount >= 8) {
                // 8+ service areas = 100 (more reasonable threshold)
                currentServiceArea = 100;
              } else {
                // Linear scale: 1 area = 12.5 points (8 areas = 100)
                currentServiceArea = Math.min(100, serviceAreasCount * 12.5);
              }
              
              // Apply NAP consistency as a multiplier (if NAP is low, reduce service area score)
              if (localSignalsData.napConsistencyScore !== null && localSignalsData.napConsistencyScore < 100) {
                const napMultiplier = localSignalsData.napConsistencyScore / 100;
                currentServiceArea = Math.round(currentServiceArea * napMultiplier);
              }
              currentServiceArea = clampScore(currentServiceArea);
              
              debugLog(`Trend chart: Current Business Profile data - Local Entity=${currentLocalEntity}, Service Area=${currentServiceArea} (used as fallback)`, 'info');
            } else {
              // Fallback: use derived calculation
              currentLocalEntity = null;
              currentServiceArea = null;
              debugLog('Trend chart: No Business Profile data available, will use derived calculation for dates without historical data', 'warn');
            }
            
            // Calculate pillar scores for each timeseries point
            // For Local Entity and Service Area: use historical Business Profile data if available,
            // otherwise use calculated data from GSC (derived calculation)
            const calculatePillarFromMetrics = (position, ctr, dateStr = null, topQueries = null, backlinkMetrics = null, localSignals = null, siteReviews = null) => {
              // Position score (same formula as main calculation)
              const clampedPos = Math.max(1, Math.min(40, position));
              const scale = (clampedPos - 1) / 39;
              const posScore = 100 - scale * 90;
              
              // CTR score (needed for Local Entity calculation and Authority fallback)
              // Convert ctr from percentage (0-100) to decimal (0-1), then apply formula
              const ctrDecimal = ctr / 100; // Convert percentage to decimal (e.g., 10% -> 0.10)
              const ctrScore = Math.min((ctrDecimal / 0.10) * 100, 100);
              
              // Calculate each pillar (same formulas as main calculation)
              const visibility = clampScore(posScore);
              
              // Authority: New 4-component model
              // Check if we have stored Authority component scores for this date
              let authority;
              if (dateStr && authorityMap && authorityMap.has(dateStr)) {
                // Use stored Authority score from Supabase (calculated with new formula)
                authority = authorityMap.get(dateStr);
                debugLog(`Authority: Using stored score (${authority}) for ${dateStr}`, 'info');
              } else if (topQueries && Array.isArray(topQueries) && topQueries.length > 0) {
                // We have topQueries data - use full 4-component calculation
                const queriesForCalculation = topQueries.map(q => ({
                  clicks: q.clicks || 0,
                  impressions: q.impressions || 0,
                  ctr: (q.ctr || 0) / 100, // Convert percentage to decimal
                  position: q.position || 0
                }));
                
                const behaviourScore = computeBehaviourScore(queriesForCalculation);
                const rankingScore = computeRankingScore(queriesForCalculation);
                
                // Use real backlink and review scores if available (for today's date)
                const backlinkScore = computeBacklinkScore(backlinkMetrics);
                
                // Get review data
                const gbpRating = (localSignals && localSignals.status === 'ok' && localSignals.data) 
                  ? (localSignals.data.gbpRating !== null && localSignals.data.gbpRating !== undefined ? localSignals.data.gbpRating : null)
                  : null;
                const gbpCount = (localSignals && localSignals.status === 'ok' && localSignals.data) 
                  ? (localSignals.data.gbpReviewCount !== null && localSignals.data.gbpReviewCount !== undefined ? localSignals.data.gbpReviewCount : null)
                  : null;
                const siteRating = siteReviews?.siteRating !== null && siteReviews?.siteRating !== undefined ? siteReviews.siteRating : null;
                const siteCount = siteReviews?.siteReviewCount !== null && siteReviews?.siteReviewCount !== undefined ? siteReviews.siteReviewCount : null;
                
                const reviewScore = computeReviewScore({
                  gbpRating,
                  gbpCount,
                  siteRating,
                  siteCount
                });
                
                authority = clampScore(
                  0.4 * behaviourScore +
                  0.2 * rankingScore +
                  0.2 * backlinkScore +
                  0.2 * reviewScore
                );
                debugLog(`Authority: Calculated from topQueries for ${dateStr || 'current'}: Behaviour=${behaviourScore.toFixed(1)}, Ranking=${rankingScore.toFixed(1)}, Backlinks=${backlinkScore}, Reviews=${reviewScore}, Final=${authority}`, 'info');
              } else {
                // Fallback: Simplified Authority calculation from aggregate metrics
                // Estimate Behaviour and Ranking scores from aggregate metrics
                // Behaviour: Use aggregate CTR as proxy (simplified)
                const estimatedBehaviourScore = Math.min(ctrScore * 0.7, 70); // Max 70 points
                
                // Ranking: Use position score (simplified)
                const estimatedRankingScore = posScore * 0.6; // Max 60 points (position) + 40 (share estimate)
                const estimatedShareScore = 20; // Conservative estimate for top-10 share
                const estimatedRanking = estimatedRankingScore + estimatedShareScore;
                
                const backlinkScore = 50; // Placeholder
                const reviewScore = 50; // Placeholder
                
                authority = clampScore(
                  0.4 * estimatedBehaviourScore +
                  0.2 * estimatedRanking +
                  0.2 * backlinkScore +
                  0.2 * reviewScore
                );
                debugLog(`Authority: Using simplified calculation from aggregate metrics for ${dateStr || 'current'}: Estimated Behaviour=${estimatedBehaviourScore.toFixed(1)}, Estimated Ranking=${estimatedRanking.toFixed(1)}, Final=${authority}`, 'info');
              }
              
              // For Local Entity and Service Area:
              // 1. Check for historical Business Profile data for this specific date
              // 2. If no historical data, use calculated data from GSC (derived calculation)
              // 3. Only use current Business Profile data as last resort (for recent dates without historical data)
              let localEntity, serviceArea;
              
              if (dateStr) {
                const historicalLocalEntity = localEntityMap.get(dateStr);
                const historicalServiceArea = serviceAreaMap.get(dateStr);
                
                if (historicalLocalEntity !== null && historicalLocalEntity !== undefined) {
                  // Use historical Business Profile data
                  localEntity = historicalLocalEntity;
                } else {
                  // Use calculated data from GSC (derived calculation) for historical dates
                  localEntity = clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
                }
                
                if (historicalServiceArea !== null && historicalServiceArea !== undefined) {
                  // Use historical Business Profile data
                  serviceArea = historicalServiceArea;
                } else {
                  // Use calculated data from GSC (derived calculation) for historical dates
                  serviceArea = clampScore(localEntity - 5);
                }
              } else {
                // No date provided - use current Business Profile data if available, otherwise calculated
                localEntity = currentLocalEntity !== null 
                  ? currentLocalEntity 
                  : clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
                serviceArea = currentServiceArea !== null 
                  ? currentServiceArea 
                  : clampScore(localEntity - 5);
              }
              
              return { visibility, authority, localEntity, serviceArea };
            };
            
            // Extract data arrays from timeseries
            localEntityData = [];
            serviceAreaData = [];
            authorityData = [];
            visibilityData = [];
            contentSchemaData = [];
            brandOverlayData = [];
            contentSchemaDataEstimated = []; // Reset array for timeseries data
            const allDateObjects = []; // Store Date objects for year detection
            const allDates = [];
            
            debugLog(`Content/Schema map has ${contentSchemaMap.size} entries: ${Array.from(contentSchemaMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
            debugLog(`Local Entity map has ${localEntityMap.size} entries: ${Array.from(localEntityMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
            debugLog(`Service Area map has ${serviceAreaMap.size} entries: ${Array.from(serviceAreaMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
            debugLog(`Timeseries has ${timeseries.length} points`, 'info');
            
            // Get current audit data for today's full Authority calculation
            const savedAuditForTrend = loadAuditResults();
            const currentTopQueries = savedAuditForTrend?.searchData?.topQueries || null;
            const currentBacklinkMetrics = savedAuditForTrend?.backlinkMetrics || null;
            const currentLocalSignals = savedAuditForTrend?.localSignals || null;
            // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
            const currentSiteReviews = getTrustpilotSnapshot(savedAuditForTrend?.siteReviews || null);
            const currentScores = savedAuditForTrend?.scores;
            
            // Check if segmentation data is available and show/hide toggle
            const authorityBySegment = currentScores?.authority?.bySegment || null;
            const trendToggle = document.getElementById('trendAuthorityModeToggle');
            if (trendToggle) {
              if (authorityBySegment) {
                trendToggle.style.display = 'block';
                // Initialize mode if not set
                if (!window.trendAuthorityMode) {
                  window.trendAuthorityMode = 'all';
                }
              } else {
                trendToggle.style.display = 'none';
                window.trendAuthorityMode = 'all'; // Default to all
              }
            }
            
            // Get Authority score for selected mode
            const getAuthorityForMode = (mode) => {
              if (authorityBySegment && authorityBySegment[mode]) {
                return authorityBySegment[mode].total || authorityBySegment[mode].score || 0;
              }
              // Fallback to all or main score
              if (authorityBySegment && authorityBySegment.all) {
                return authorityBySegment.all.total || authorityBySegment.all.score || 0;
              }
              // Legacy fallback
              const authObj = currentScores?.authority;
              if (typeof authObj === 'object' && authObj !== null) {
                return authObj.score || 0;
              }
              return authObj || 0;
            };
            
            timeseries.forEach(point => {
              const pointDate = point.date; // YYYY-MM-DD format
              
              // Check if this is the latest audit date - if so, use stored scores from Supabase or current audit
              // Use latestAuditDateStr (from Supabase) instead of todayStr to ensure we use actual latest audit
              const isLatestAudit = pointDate === latestAuditDateStr;
              
              // Check if we have historical data from Supabase for Local Entity, Service Area, and Authority
              const historicalLocalEntity = localEntityMap.get(pointDate);
              const historicalServiceArea = serviceAreaMap.get(pointDate);
              const historicalAuthority = authorityMap.get(pointDate);
              
              // For latest audit date, use current topQueries, backlinkMetrics, and reviews for full calculation
              // For historical dates, pass null (will use simplified calculation)
              const topQueriesForDate = isLatestAudit ? currentTopQueries : null;
              const backlinkMetricsForDate = isLatestAudit ? currentBacklinkMetrics : null;
              const localSignalsForDate = isLatestAudit ? currentLocalSignals : null;
              const siteReviewsForDate = isLatestAudit ? currentSiteReviews : null;
              
              // Pass date to calculatePillarFromMetrics so it can check for historical data
              // For today, pass topQueries and other data for full calculation
              // For historical dates, pass null (will use simplified calculation)
              const pillarScores = calculatePillarFromMetrics(
                point.position, 
                point.ctr, 
                pointDate, 
                topQueriesForDate,
                backlinkMetricsForDate,
                localSignalsForDate,
                siteReviewsForDate
              );
              
              // Local Entity and Service Area: Use historical data from Supabase if available
              // These don't require GSC data, so should use latest available score for missing dates
              if (historicalLocalEntity !== undefined && historicalLocalEntity !== null) {
                localEntityData.push(historicalLocalEntity);
                debugLog(`Using historical Local Entity (${historicalLocalEntity}) for ${pointDate}`, 'info');
              } else {
                // For missing dates, use the most recent available score from the map
                let latestAvailableLocalEntity = null;
                let latestAvailableDate = null;
                localEntityMap.forEach((score, mapDate) => {
                  if (mapDate <= pointDate && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
                    latestAvailableDate = mapDate;
                    latestAvailableLocalEntity = score;
                  }
                });
                
                if (latestAvailableLocalEntity !== null && latestAvailableLocalEntity !== undefined) {
                  localEntityData.push(latestAvailableLocalEntity);
                  debugLog(`Using latest available Local Entity (${latestAvailableLocalEntity} from ${latestAvailableDate}) for ${pointDate}`, 'info');
                } else if (isLatestAudit) {
                  // For latest audit date, use current score
                  const savedAuditForLocal = loadAuditResultsSync();
                  const currentLocalEntity = savedAuditForLocal?.scores?.localEntity;
                  if (currentLocalEntity !== null && currentLocalEntity !== undefined && currentLocalEntity > 0) {
                    localEntityData.push(currentLocalEntity);
                    debugLog(`Using current Local Entity (${currentLocalEntity}) for ${pointDate} (latest audit)`, 'info');
                  } else {
                    localEntityData.push(null);
                    debugLog(`No Local Entity data for ${pointDate}`, 'warn');
                  }
                } else {
                  localEntityData.push(null);
                  debugLog(`No Local Entity data for ${pointDate} (no historical or current data)`, 'info');
                }
              }
              
              if (historicalServiceArea !== undefined && historicalServiceArea !== null) {
                serviceAreaData.push(historicalServiceArea);
                debugLog(`Using historical Service Area (${historicalServiceArea}) for ${pointDate}`, 'info');
              } else {
                // For missing dates, use the most recent available score from the map
                let latestAvailableServiceArea = null;
                let latestAvailableDate = null;
                serviceAreaMap.forEach((score, mapDate) => {
                  if (mapDate <= pointDate && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
                    latestAvailableDate = mapDate;
                    latestAvailableServiceArea = score;
                  }
                });
                
                if (latestAvailableServiceArea !== null && latestAvailableServiceArea !== undefined) {
                  serviceAreaData.push(latestAvailableServiceArea);
                  debugLog(`Using latest available Service Area (${latestAvailableServiceArea} from ${latestAvailableDate}) for ${pointDate}`, 'info');
                } else if (isLatestAudit) {
                  // For latest audit date, use current score
                  const savedAuditForService = loadAuditResultsSync();
                  const currentServiceArea = savedAuditForService?.scores?.serviceArea;
                  if (currentServiceArea !== null && currentServiceArea !== undefined && currentServiceArea > 0) {
                    serviceAreaData.push(currentServiceArea);
                    debugLog(`Using current Service Area (${currentServiceArea}) for ${pointDate} (latest audit)`, 'info');
                  } else {
                    serviceAreaData.push(null);
                    debugLog(`No Service Area data for ${pointDate}`, 'warn');
                  }
                } else {
                  serviceAreaData.push(null);
                  debugLog(`No Service Area data for ${pointDate} (no historical or current data)`, 'info');
                }
              }
              
              // Use Authority score based on selected mode, prioritizing segmented historical data when available
              // Check if we have segmented Authority data for this date in Supabase
              const historicalAuthorityBySegment = authorityBySegmentMap.get(pointDate);
              const selectedMode = window.trendAuthorityMode || 'all';
              
              if (historicalAuthorityBySegment && historicalAuthorityBySegment[selectedMode]) {
                // Use segmented Authority score from Supabase for the selected mode
                const modeScore = historicalAuthorityBySegment[selectedMode].total || historicalAuthorityBySegment[selectedMode].score || historicalAuthorityBySegment[selectedMode];
                authorityData.push(modeScore);
                debugLog(`Using historical segmented Authority (${modeScore}) for ${pointDate} (mode: ${selectedMode})`, 'info');
              } else if (isLatestAudit) {
                // For latest audit date, prioritize stored Authority score from current audit
                const savedAuditForAuthority = loadAuditResultsSync();
                const currentAuthority = savedAuditForAuthority?.scores?.authority;
                let authorityScoreToUse = null;
                
                // Try to get Authority score based on selected mode
                if (authorityBySegment) {
                  authorityScoreToUse = getAuthorityForMode(selectedMode);
                } else if (typeof currentAuthority === 'object' && currentAuthority !== null) {
                  authorityScoreToUse = currentAuthority.score || currentAuthority;
                } else if (typeof currentAuthority === 'number') {
                  authorityScoreToUse = currentAuthority;
                }
                
                if (authorityScoreToUse !== null && authorityScoreToUse !== undefined && authorityScoreToUse > 0) {
                  authorityData.push(authorityScoreToUse);
                  debugLog(`Using current stored Authority (${authorityScoreToUse}) for ${pointDate} (mode: ${selectedMode}, latest audit)`, 'info');
                } else {
                  // Fallback to calculated score if stored score not available
                  const authScore = typeof pillarScores.authority === 'object' ? pillarScores.authority.score : pillarScores.authority;
                  authorityData.push(authScore);
                  debugLog(`Using calculated Authority (${authScore}) for ${pointDate} (stored score not available)`, 'info');
                }
              } else if (historicalAuthority !== undefined && historicalAuthority !== null) {
                // Fallback: use legacy historical Authority from Supabase (single value, not segmented)
                authorityData.push(historicalAuthority);
                debugLog(`Using legacy historical Authority (${historicalAuthority}) for ${pointDate}`, 'info');
              } else {
                // For missing dates, use the most recent available score from Supabase (prevents artificial dips)
                let latestAvailableAuthority = null;
                let latestAvailableAuthorityDate = null;
                
                // Prefer segmented historical Authority if available (match selected mode)
                authorityBySegmentMap.forEach((seg, mapDate) => {
                  if (mapDate <= pointDate && (latestAvailableAuthorityDate === null || mapDate > latestAvailableAuthorityDate)) {
                    if (seg && seg[selectedMode] !== undefined && seg[selectedMode] !== null) {
                      const v = seg[selectedMode].total || seg[selectedMode].score || seg[selectedMode];
                      latestAvailableAuthorityDate = mapDate;
                      latestAvailableAuthority = v;
                    }
                  }
                });
                
                // Fallback to legacy Authority map if segmented isn't available
                if (latestAvailableAuthority === null || latestAvailableAuthority === undefined) {
                  authorityMap.forEach((score, mapDate) => {
                    if (mapDate <= pointDate && (latestAvailableAuthorityDate === null || mapDate > latestAvailableAuthorityDate)) {
                      latestAvailableAuthorityDate = mapDate;
                      latestAvailableAuthority = score;
                    }
                  });
                }
                
                if (latestAvailableAuthority !== null && latestAvailableAuthority !== undefined) {
                  authorityData.push(latestAvailableAuthority);
                  debugLog(`Using latest available Authority (${latestAvailableAuthority} from ${latestAvailableAuthorityDate}) for ${pointDate}`, 'info');
                } else {
                  // Final fallback: calculate from GSC metrics (only if we have valid data)
                  const hasValidGscData = point.position && point.position > 0 && point.ctr !== null && point.ctr >= 0;
                  if (hasValidGscData) {
                    const authScore = typeof pillarScores.authority === 'object' ? pillarScores.authority.score : pillarScores.authority;
                    authorityData.push(authScore);
                    debugLog(`Using calculated Authority (${authScore}) for ${pointDate}`, 'info');
                  } else {
                    authorityData.push(null);
                    debugLog(`No valid GSC data for Authority on ${pointDate} (position=${point.position}, ctr=${point.ctr}) - using null`, 'warn');
                  }
                }
              }
              
              // Visibility data (check historical data from Supabase FIRST, then use current audit score, then calculate only if missing and valid GSC data)
              const historicalVisibility = visibilityMap.get(pointDate);
              if (historicalVisibility !== undefined && historicalVisibility !== null) {
                // Use stored score from database (fast - no calculation needed)
                visibilityData.push(historicalVisibility);
                debugLog(`Using stored Visibility (${historicalVisibility}) for ${pointDate}`, 'info');
              } else if (isLatestAudit) {
                // For latest audit date, prioritize stored Visibility score from current audit
                const savedAuditForVisibility = loadAuditResultsSync();
                const currentVisibility = savedAuditForVisibility?.scores?.visibility;
                if (currentVisibility !== null && currentVisibility !== undefined && currentVisibility > 0) {
                  visibilityData.push(currentVisibility);
                  debugLog(`Using current stored Visibility (${currentVisibility}) for ${pointDate} (latest audit)`, 'info');
                } else {
                  // Fallback to calculated score if stored score not available
                  visibilityData.push(pillarScores.visibility);
                  debugLog(`Using calculated Visibility (${pillarScores.visibility}) for ${pointDate} (stored score not available)`, 'info');
                }
              } else {
                // For past dates: calculate from GSC data as fallback (only if stored score missing AND valid GSC data)
                const hasValidGscData = point.position && point.position > 0 && point.ctr !== null && point.ctr >= 0;
                if (hasValidGscData) {
                  visibilityData.push(pillarScores.visibility);
                  debugLog(`Calculated Visibility (${pillarScores.visibility}) for ${pointDate} - stored score missing, using GSC fallback`, 'info');
                } else {
                  visibilityData.push(null);
                  debugLog(`No valid GSC data for Visibility on ${pointDate} (position=${point.position}, ctr=${point.ctr}) - using null`, 'warn');
                }
              }
              
              // Check if we have real historical data for this date
              // Content/Schema doesn't require GSC data, so should always have values
              // NOTE: 0 is a valid score, so check for null/undefined only
              const realScore = contentSchemaMap.get(pointDate);
              
              if (realScore !== undefined && realScore !== null) {
                // We have real data for this date (including 0, which is valid)
                contentSchemaData.push(realScore);
                contentSchemaDataEstimated.push(null); // No estimated value
                debugLog(`Content/Schema: Added ${realScore} for ${pointDate} from Supabase`, 'info');
              } else {
                // For missing dates, use the most recent available score from the map
                let latestAvailableContentSchema = null;
                let latestAvailableDate = null;
                contentSchemaMap.forEach((score, mapDate) => {
                  if (mapDate <= pointDate && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
                    latestAvailableDate = mapDate;
                    latestAvailableContentSchema = score;
                  }
                });
                
                // If no historical data found, use current score for latest audit date
                // NOTE: 0 is a valid score, so check for null/undefined only
                if (latestAvailableContentSchema !== null && latestAvailableContentSchema !== undefined) {
                  contentSchemaData.push(latestAvailableContentSchema);
                  contentSchemaDataEstimated.push(null);
                  debugLog(`Content/Schema: Added ${latestAvailableContentSchema} for ${pointDate} from latest available (${latestAvailableDate})`, 'info');
                } else if (isLatestAudit) {
                  // For latest audit date, try multiple sources
                  const savedAuditForContentSchema = loadAuditResultsSync();
                  const savedContentSchema = savedAuditForContentSchema?.scores?.contentSchema;
                  // NOTE: 0 is a valid score, so check for null/undefined only
                  const scoreToUse = (currentContentSchema !== null && currentContentSchema !== undefined)
                    ? currentContentSchema
                    : (savedContentSchema !== null && savedContentSchema !== undefined)
                      ? savedContentSchema
                      : null;
                  
                  if (scoreToUse !== null && scoreToUse !== undefined) {
                    contentSchemaData.push(scoreToUse);
                    contentSchemaDataEstimated.push(null);
                    debugLog(`Content/Schema: Added ${scoreToUse} for ${pointDate} from ${scoreToUse === currentContentSchema ? 'current audit' : 'saved audit'} (latest)`, 'info');
                  } else {
                    contentSchemaData.push(null);
                    contentSchemaDataEstimated.push(null);
                    debugLog(`Content/Schema: No valid score for ${pointDate} (isLatestAudit=${isLatestAudit}, currentContentSchema=${currentContentSchema}, savedContentSchema=${savedContentSchema})`, 'warn');
                  }
                } else {
                  // No real data for this date - use null (don't show estimated line)
                  contentSchemaData.push(null);
                  contentSchemaDataEstimated.push(null);
                  debugLog(`Content/Schema: No data for ${pointDate} (not latest audit, map has ${contentSchemaMap.size} entries)`, 'info');
                }
              }
              
              // Brand Overlay data (prioritize Supabase; if missing for a date, carry-forward latest available)
              const historicalBrandOverlay = brandOverlayMap.get(pointDate);
              if (historicalBrandOverlay !== undefined && historicalBrandOverlay !== null) {
                brandOverlayData.push(historicalBrandOverlay);
                debugLog(` Added Brand Overlay score (${historicalBrandOverlay}) for ${pointDate} from Supabase (historical)`, 'info');
              } else {
                let latestAvailableBrand = null;
                let latestAvailableBrandDate = null;
                brandOverlayMap.forEach((score, mapDate) => {
                  if (mapDate <= pointDate && (latestAvailableBrandDate === null || mapDate > latestAvailableBrandDate)) {
                    latestAvailableBrandDate = mapDate;
                    latestAvailableBrand = score;
                  }
                });

                if (latestAvailableBrand !== null && latestAvailableBrand !== undefined) {
                  brandOverlayData.push(latestAvailableBrand);
                  debugLog(` Using latest available Brand Overlay (${latestAvailableBrand} from ${latestAvailableBrandDate}) for ${pointDate}`, 'info');
                } else if (isLatestAudit && currentBrandOverlay !== null) {
                  brandOverlayData.push(currentBrandOverlay);
                  debugLog(` Using current Brand Overlay score (${currentBrandOverlay}) for ${pointDate} - no historical data found in Supabase`, 'warn');
                } else {
                  // Final fallback: estimate from GSC metrics
                  const historicalRecord = contentSchemaHistory.find(r => {
                    const rDate = typeof r.date === 'string' ? r.date.split('T')[0] : (r.date instanceof Date ? r.date.toISOString().split('T')[0] : String(r.date).split('T')[0]);
                    return rDate === pointDate;
                  });
                  const historicalReviewScore = historicalRecord?.authorityReviewScore;
                  const historicalEntityScore = historicalLocalEntity !== undefined && historicalLocalEntity !== null ? historicalLocalEntity : null;

                  const reviewScore = historicalReviewScore !== undefined && historicalReviewScore !== null
                    ? historicalReviewScore
                    : (currentScores?.authorityComponents?.reviews || currentScores?.authority?.bySegment?.all?.reviews || 0);
                  const entityScore = historicalEntityScore !== null && historicalEntityScore !== undefined
                    ? historicalEntityScore
                    : (currentScores?.localEntity || 0);

                  const hasValidGscData = point.position && point.position > 0 && point.ctr !== null && point.ctr >= 0;
                  if (!hasValidGscData) {
                    brandOverlayData.push(null);
                    debugLog(`No valid GSC data for Brand Overlay on ${pointDate} (position=${point.position}, ctr=${point.ctr}) - using null`, 'warn');
                  } else {
                    const position = point.position || 40;
                    const ctr = point.ctr || 0;
                    const estimatedBrandCtr = Math.min(ctr * 1.5, 0.4);
                    const estimatedBrandPosition = Math.max(position * 0.7, 1);
                    const estimatedBrandShare = 0.02;

                    try {
                      const fallbackBrandOverlay = computeBrandOverlay({
                        brandQueryShare: estimatedBrandShare,
                        brandCtr: estimatedBrandCtr,
                        brandAvgPosition: estimatedBrandPosition,
                        reviewScore: reviewScore,
                        entityScore: entityScore
                      });
                      brandOverlayData.push(fallbackBrandOverlay.score);
                      debugLog(` Calculated fallback Brand Overlay score (${fallbackBrandOverlay.score}) for ${pointDate} from GSC timeseries data`, 'info');
                    } catch (e) {
                      debugLog(` Error calculating fallback Brand Overlay for ${pointDate}: ${e.message}`, 'warn');
                      brandOverlayData.push(null);
                    }
                  }
                }
              }
              
              // Format date for chart (timeseries dates are YYYY-MM-DD)
              const dateObj = new Date(point.date);
              allDateObjects.push(dateObj);
              allDates.push(dateObj.toLocaleDateString('en-GB', dateFormat));
            });
            
            // Log Content/Schema data array summary after timeseries loop
            const contentSchemaValid = contentSchemaData.filter(v => v !== null && v !== undefined);
            debugLog(`Content/Schema data after timeseries: ${contentSchemaValid.length} valid values out of ${contentSchemaData.length} total. Values: ${contentSchemaValid.join(', ')}`, 'info');
            
            // Fill in missing dates between last GSC date and latest audit date
            // GSC data is delayed by 2-3 days, but we want to show the latest audit date
            // Reuse 'today' and 'todayStr' variables (already declared above)
            today = new Date();
            today.setHours(0, 0, 0, 0); // Normalize to start of day
            todayStr = today.toISOString().split('T')[0];
            const lastTimeseriesDate = timeseries.length > 0 ? timeseries[timeseries.length - 1].date : null;
            
            // Store last timeseries date globally so displayDashboard can use it for Data Date
            window.lastGscTimeseriesDate = lastTimeseriesDate;
            if (lastTimeseriesDate) {
              debugLog(`Stored last GSC timeseries date globally: ${lastTimeseriesDate}`, 'info');
            }
            
            // Determine actual last GSC data date
            // CRITICAL: Only use dates from maps that are <= lastTimeseriesDate (actual GSC data)
            // Never forward-fill GSC data beyond the last actual GSC timeseries date
            // Maps may have dates after lastTimeseriesDate (from audits), but those aren't from actual GSC data
            const allGscDates = new Set();
            
            // Add all dates from timeseries (actual GSC API data)
            timeseries.forEach(point => {
              if (point.date) {
                allGscDates.add(point.date);
              }
            });
            
            // Add dates from historical maps ONLY if they're <= lastTimeseriesDate
            // This ensures we only use GSC-derived scores that are based on actual GSC data
            if (lastTimeseriesDate) {
              visibilityMap.forEach((score, date) => {
                if (date && date <= lastTimeseriesDate && score !== null && score !== undefined) {
                  allGscDates.add(date);
                }
              });
              authorityMap.forEach((score, date) => {
                if (date && date <= lastTimeseriesDate && score !== null && score !== undefined) {
                  allGscDates.add(date);
                }
              });
              brandOverlayMap.forEach((score, date) => {
                if (date && date <= lastTimeseriesDate && score !== null && score !== undefined) {
                  allGscDates.add(date);
                }
              });
            }
            
            // Use the latest date from timeseries OR valid map dates (all <= lastTimeseriesDate)
            // This is the definitive last GSC data date - never forward-fill beyond this
            let lastGscDateForRange = lastTimeseriesDate; // Default to timeseries date (most accurate)
            if (allGscDates.size > 0) {
              const sortedDates = Array.from(allGscDates).sort();
              const latestDate = sortedDates[sortedDates.length - 1];
              // Use the later of: lastTimeseriesDate or latest valid map date
              // But latestDate should never be > lastTimeseriesDate due to filtering above
              lastGscDateForRange = latestDate > lastTimeseriesDate ? lastTimeseriesDate : latestDate;
              debugLog(`Last GSC date: ${lastGscDateForRange} (timeseries: ${lastTimeseriesDate}, valid map dates: ${sortedDates.length})`, 'info');
              if (sortedDates.length > 0) {
                debugLog(`GSC date range: ${sortedDates[0]} to ${lastGscDateForRange}`, 'info');
              }
            } else {
              debugLog(`No GSC dates found, using lastTimeseriesDate: ${lastGscDateForRange}`, 'warn');
            }
            
            // Ensure latest audit date is included even if not in timeseries
            // Add it to the chart if it's after the last GSC date
            if (latestAuditDateStr && lastGscDateForRange && latestAuditDateStr > lastGscDateForRange) {
              debugLog(`Latest audit date (${latestAuditDateStr}) is after last GSC date (${lastGscDateForRange}), will add to chart`, 'info');
            }
            
            // Check if we're missing recent dates (likely due to GSC delay)
            let hasRecentMissingDates = false;
            if (lastTimeseriesDate) {
              const lastDate = new Date(lastTimeseriesDate);
              lastDate.setHours(0, 0, 0, 0);
              const daysSinceLastData = Math.floor((today - lastDate) / (1000 * 60 * 60 * 24));
              hasRecentMissingDates = daysSinceLastData > 1; // More than 1 day gap indicates GSC delay
              
              // Show a note about GSC delay if we're missing recent dates
              if (hasRecentMissingDates) {
                const trendCanvas = document.getElementById('trendChart');
                if (trendCanvas && trendCanvas.parentElement) {
                  // Check if note already exists
                  const existingNote = trendCanvas.parentElement.querySelector('.gsc-delay-note');
                  if (!existingNote) {
                    const noteDiv = document.createElement('div');
                    noteDiv.className = 'gsc-delay-note';
                    noteDiv.style.cssText = 'background: #e0f2fe; padding: 0.75rem; border-radius: 4px; border-left: 3px solid #0284c7; margin-bottom: 1rem; font-size: 0.85rem; color: #0c4a6e;';
                    noteDiv.innerHTML = `<strong>Note:</strong> Google Search Console data is typically delayed by 2-3 days. Recent dates (last ${daysSinceLastData} day${daysSinceLastData > 1 ? 's' : ''}) may show no data until GSC updates.`;
                    trendCanvas.parentElement.insertBefore(noteDiv, trendCanvas);
                  }
                }
              }
            }
            
            // Always extend chart to latestAuditDateStr (or today) for non-GSC pillars
            // GSC pillars will only show data up to lastGscDateForRange
            // CRITICAL: Use the last date from the timeseries array (what's already in the chart)
            // NOT from the maps, because the maps may have dates that aren't in the chart yet
            const lastTimeseriesDateStr = timeseries.length > 0 ? timeseries[timeseries.length - 1].date : null;
            
            // Find the latest date from all maps for fallback/validation
            const allMapDates = new Set();
            contentSchemaMap.forEach((score, date) => allMapDates.add(date));
            localEntityMap.forEach((score, date) => allMapDates.add(date));
            serviceAreaMap.forEach((score, date) => allMapDates.add(date));
            visibilityMap.forEach((score, date) => allMapDates.add(date));
            authorityMap.forEach((score, date) => allMapDates.add(date));
            brandOverlayMap.forEach((score, date) => allMapDates.add(date));
            const latestMapDateStr = allMapDates.size > 0 ? Array.from(allMapDates).sort().reverse()[0] : null;
            
            // Use the last date from timeseries (what's already in the chart) as the starting point
            // This ensures we fill dates from the last timeseries date to the latest audit date
            const lastDateInChartStr = lastTimeseriesDateStr || (timeseries.length === 0 && latestMapDateStr ? latestMapDateStr : null);
            const targetDateStr = latestAuditDateStr || latestMapDateStr || today.toISOString().split('T')[0];
            
            debugLog(`Chart extension: lastDateInChart=${lastDateInChartStr}, targetDate=${targetDateStr}, latestAuditDateStr=${latestAuditDateStr}, latestMapDate=${latestMapDateStr}`, 'info');
            debugLog(`Last GSC date: ${lastGscDateForRange} (from all sources, timeseries last: ${lastTimeseriesDate})`, 'info');
            debugLog(`Content/Schema map has ${contentSchemaMap.size} entries before filling missing dates`, 'info');
            debugLog(`Content/Schema map entries: ${Array.from(contentSchemaMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
            
            // Always fill dates from last date in chart to latest audit date
            // Use string comparison to ensure we extend the chart
            if (lastDateInChartStr && targetDateStr) {
              const dateComparison = lastDateInChartStr.localeCompare(targetDateStr);
              if (dateComparison < 0) {
              const lastDate = new Date(lastDateInChartStr);
              lastDate.setHours(0, 0, 0, 0);
              const currentDate = new Date(lastDate);
              currentDate.setDate(currentDate.getDate() + 1); // Start from day after last date
              
              debugLog(`Filling missing dates from ${currentDate.toISOString().split('T')[0]} to ${targetDateStr} (latest audit: ${latestAuditDateStr})`, 'info');
              
              while (currentDate.toISOString().split('T')[0] <= targetDateStr) {
                const dateStr = currentDate.toISOString().split('T')[0];
                const dateObj = new Date(dateStr);
                
                allDateObjects.push(dateObj);
                allDates.push(dateObj.toLocaleDateString('en-GB', dateFormat));
                
                // For GSC-based pillars (Authority, Visibility), only use data from Supabase if it exists for that specific date
                // These rely on GSC data being fetched and stored, so NO forward-filling
                // CRITICAL: Only show data for dates <= lastGscDateForRange (last GSC data date from maps or timeseries)
                // Never show data for dates after lastGscDateForRange, even if an audit was run on that date
                const isDateWithinGscRange = lastGscDateForRange && dateStr <= lastGscDateForRange;
                const historicalVisibility = visibilityMap.get(dateStr);
                const historicalAuthority = authorityMap.get(dateStr);
                
                // Visibility: only use historical data from Supabase if date is within GSC data range
                if (isDateWithinGscRange && historicalVisibility !== undefined && historicalVisibility !== null) {
                  visibilityData.push(historicalVisibility);
                  debugLog(` Added Visibility score (${historicalVisibility}) for ${dateStr} from Supabase`, 'info');
                } else {
                  // No data for dates after last GSC data date - GSC-based metrics require real GSC data
                  visibilityData.push(null);
                  if (!isDateWithinGscRange) {
                    debugLog(`No Visibility data for ${dateStr} (date is after last GSC data date: ${lastGscDateForRange})`, 'info');
                  } else {
                    debugLog(`No Visibility data for ${dateStr} (no historical audit data)`, 'info');
                  }
                }
                
                // Authority: only use historical data from Supabase if date is within GSC data range
                if (isDateWithinGscRange && historicalAuthority !== undefined && historicalAuthority !== null) {
                  authorityData.push(historicalAuthority);
                  debugLog(` Added Authority score (${historicalAuthority}) for ${dateStr} from Supabase`, 'info');
                } else {
                  // No data for dates after last GSC data date - GSC-based metrics require real GSC data
                  authorityData.push(null);
                  if (!isDateWithinGscRange) {
                    debugLog(`No Authority data for ${dateStr} (date is after last GSC data date: ${lastGscDateForRange})`, 'info');
                  } else {
                    debugLog(`No Authority data for ${dateStr} (no historical audit data)`, 'info');
                  }
                }
                
                // For Local Entity and Service Area, check if we have historical data from Supabase
                // These don't require GSC data, so should always have values up to today
                const historicalLocalEntity = localEntityMap.get(dateStr);
                const historicalServiceArea = serviceAreaMap.get(dateStr);
                
                // Local Entity: use historical data, or latest available, or current score for today
                if (historicalLocalEntity !== undefined && historicalLocalEntity !== null) {
                  localEntityData.push(historicalLocalEntity);
                  debugLog(` Added Local Entity score (${historicalLocalEntity}) for ${dateStr} from Supabase`, 'info');
                } else {
                  // For missing dates, use the most recent available score from the map
                  let latestAvailableLocalEntity = null;
                  let latestAvailableDate = null;
                  localEntityMap.forEach((score, mapDate) => {
                    if (mapDate <= dateStr && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
                      latestAvailableDate = mapDate;
                      latestAvailableLocalEntity = score;
                    }
                  });
                  
                  // If no historical data found, use current score for today/latest audit
                  if (latestAvailableLocalEntity !== null && latestAvailableLocalEntity !== undefined) {
                    localEntityData.push(latestAvailableLocalEntity);
                    debugLog(` Added Local Entity score (${latestAvailableLocalEntity}) for ${dateStr} from latest available (${latestAvailableDate})`, 'info');
                  } else if (dateStr === latestAuditDateStr || dateStr >= todayStr) {
                    const savedAuditForLocal = loadAuditResultsSync();
                    const currentLocalEntity = savedAuditForLocal?.scores?.localEntity;
                    if (currentLocalEntity !== null && currentLocalEntity !== undefined && currentLocalEntity > 0) {
                      localEntityData.push(currentLocalEntity);
                      debugLog(` Added Local Entity score (${currentLocalEntity}) for ${dateStr} from current audit`, 'info');
                    } else {
                      localEntityData.push(null);
                      debugLog(`No Local Entity data for ${dateStr}`, 'warn');
                    }
                  } else {
                    localEntityData.push(null);
                    debugLog(`No Local Entity data for ${dateStr} (no historical or current data)`, 'info');
                  }
                }
                
                // Service Area: use historical data, or latest available, or current score for today
                if (historicalServiceArea !== undefined && historicalServiceArea !== null) {
                  serviceAreaData.push(historicalServiceArea);
                  debugLog(` Added Service Area score (${historicalServiceArea}) for ${dateStr} from Supabase`, 'info');
                } else {
                  // For missing dates, use the most recent available score from the map
                  let latestAvailableServiceArea = null;
                  let latestAvailableDate = null;
                  serviceAreaMap.forEach((score, mapDate) => {
                    if (mapDate <= dateStr && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
                      latestAvailableDate = mapDate;
                      latestAvailableServiceArea = score;
                    }
                  });
                  
                  // If no historical data found, use current score for today/latest audit
                  if (latestAvailableServiceArea !== null && latestAvailableServiceArea !== undefined) {
                    serviceAreaData.push(latestAvailableServiceArea);
                    debugLog(` Added Service Area score (${latestAvailableServiceArea}) for ${dateStr} from latest available (${latestAvailableDate})`, 'info');
                  } else if (dateStr === latestAuditDateStr || dateStr >= todayStr) {
                    const savedAuditForService = loadAuditResultsSync();
                    const currentServiceArea = savedAuditForService?.scores?.serviceArea;
                    if (currentServiceArea !== null && currentServiceArea !== undefined && currentServiceArea > 0) {
                      serviceAreaData.push(currentServiceArea);
                      debugLog(` Added Service Area score (${currentServiceArea}) for ${dateStr} from current audit`, 'info');
                    } else {
                      serviceAreaData.push(null);
                      debugLog(`No Service Area data for ${dateStr}`, 'warn');
                    }
                  } else {
                    serviceAreaData.push(null);
                    debugLog(`No Service Area data for ${dateStr} (no historical or current data)`, 'info');
                  }
                }
                
                // For Content/Schema, use latest audit score for dates after last GSC date
                // This ensures we show the latest audit data instead of intermediate values
                const isAfterLastTimeseries = lastGscDateForRange && dateStr > lastGscDateForRange;
                
                if (isAfterLastTimeseries && dateStr <= latestAuditDateStr) {
                  // For dates after last timeseries but up to latest audit, use latest audit score (forward-fill)
                  const savedAuditForContentSchema = loadAuditResultsSync();
                  const savedContentSchema = savedAuditForContentSchema?.scores?.contentSchema;
                  // NOTE: 0 is a valid score, so check for null/undefined only
                  const scoreToUse = (currentContentSchema !== null && currentContentSchema !== undefined)
                    ? currentContentSchema
                    : (savedContentSchema !== null && savedContentSchema !== undefined)
                      ? savedContentSchema
                      : null;
                  
                  if (scoreToUse !== null && scoreToUse !== undefined) {
                    contentSchemaData.push(scoreToUse);
                    contentSchemaDataEstimated.push(null);
                    debugLog(` Added Content/Schema score (${scoreToUse}) for ${dateStr} from latest audit (forward-filled from ${latestAuditDateStr})`, 'info');
                  } else {
                    // Fallback: use latest available from map
                    let latestAvailableContentSchema = null;
                    let latestAvailableDate = null;
                    contentSchemaMap.forEach((score, mapDate) => {
                      if (mapDate <= latestAuditDateStr && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
                        latestAvailableDate = mapDate;
                        latestAvailableContentSchema = score;
                      }
                    });
                    if (latestAvailableContentSchema !== null && latestAvailableContentSchema !== undefined) {
                      contentSchemaData.push(latestAvailableContentSchema);
                      contentSchemaDataEstimated.push(null);
                      debugLog(` Added Content/Schema score (${latestAvailableContentSchema}) for ${dateStr} from latest available (${latestAvailableDate})`, 'info');
                    } else {
                      contentSchemaData.push(null);
                      contentSchemaDataEstimated.push(null);
                      debugLog(`No Content/Schema data for ${dateStr}`, 'warn');
                    }
                  }
                } else {
                  // For dates within timeseries range, use actual database values
                  const realScore = contentSchemaMap.get(dateStr);
                  if (realScore !== undefined && realScore !== null) {
                    // We have real data for this date (including 0, which is valid)
                    contentSchemaData.push(realScore);
                    contentSchemaDataEstimated.push(null);
                    debugLog(` Added Content/Schema score (${realScore}) for ${dateStr} from Supabase`, 'info');
                  } else {
                    // For missing dates, use the most recent available score from the map
                    let latestAvailableContentSchema = null;
                    let latestAvailableDate = null;
                    contentSchemaMap.forEach((score, mapDate) => {
                      if (mapDate <= dateStr && (latestAvailableDate === null || mapDate > latestAvailableDate)) {
                        latestAvailableDate = mapDate;
                        latestAvailableContentSchema = score;
                      }
                    });
                    
                    // If no historical data found, use current score for today/latest audit
                    if (latestAvailableContentSchema !== null && latestAvailableContentSchema !== undefined) {
                      contentSchemaData.push(latestAvailableContentSchema);
                      contentSchemaDataEstimated.push(null);
                      debugLog(` Added Content/Schema score (${latestAvailableContentSchema}) for ${dateStr} from latest available (${latestAvailableDate})`, 'info');
                    } else if (dateStr === latestAuditDateStr || dateStr >= todayStr) {
                      const savedAuditForContentSchema = loadAuditResultsSync();
                      const savedContentSchema = savedAuditForContentSchema?.scores?.contentSchema;
                      const scoreToUse = (currentContentSchema !== null && currentContentSchema !== undefined)
                        ? currentContentSchema
                        : (savedContentSchema !== null && savedContentSchema !== undefined)
                          ? savedContentSchema
                          : null;
                      
                      if (scoreToUse !== null && scoreToUse !== undefined) {
                        contentSchemaData.push(scoreToUse);
                        contentSchemaDataEstimated.push(null);
                        debugLog(` Added Content/Schema score (${scoreToUse}) for ${dateStr} from current/saved audit`, 'info');
                      } else {
                        contentSchemaData.push(null);
                        contentSchemaDataEstimated.push(null);
                        debugLog(`No Content/Schema data for ${dateStr} (latest date but no score available)`, 'warn');
                      }
                    } else {
                      // No real data - use null (don't show estimated)
                      contentSchemaData.push(null);
                      contentSchemaDataEstimated.push(null);
                      debugLog(`No Content/Schema data for ${dateStr} (no historical or current data)`, 'info');
                    }
                  }
                }
                
                // Brand Overlay data (check historical data from Supabase)
                // Brand Overlay is GSC-based, so only show data for dates <= lastTimeseriesDate
                const historicalBrandOverlay = brandOverlayMap.get(dateStr);
                if (isDateWithinGscRange && historicalBrandOverlay !== undefined && historicalBrandOverlay !== null) {
                  brandOverlayData.push(historicalBrandOverlay);
                  debugLog(` Added Brand Overlay score (${historicalBrandOverlay}) for ${dateStr} from Supabase`, 'info');
                } else {
                  // No data for dates after last GSC data date - Brand Overlay is GSC-based
                  brandOverlayData.push(null);
                  if (!isDateWithinGscRange) {
                    debugLog(`No Brand Overlay data for ${dateStr} (date is after last GSC data date: ${lastGscDateForRange})`, 'info');
                  } else {
                    debugLog(`No Brand Overlay data for ${dateStr} (no historical audit data)`, 'info');
                  }
                }
                
                // Move to next day
                currentDate.setDate(currentDate.getDate() + 1);
              }
              
              debugLog(`Filled missing dates: added ${allDateObjects.length - timeseries.length} additional dates`, 'info');
              } else {
                debugLog(`No dates to fill: lastDateInChart=${lastDateInChartStr}, targetDate=${targetDateStr}`, 'info');
              }
            } else {
              debugLog(`Cannot fill dates: lastDateInChart=${lastDateInChartStr}, targetDate=${targetDateStr}`, 'warn');
            }
            
            debugLog(`Chart date range: ${allDates[0]} to ${allDates[allDates.length - 1]} (${allDates.length} total dates)`, 'info');
            debugLog(`Latest audit date: ${latestAuditDateStr}`, 'info');
            debugLog(`Chart labels (first 5, last 5): ${allDates.slice(0, 5).join(', ')} ... ${allDates.slice(-5).join(', ')}`, 'info');
            
            if (timeseries.length === 0) {
              // No timeseries data at all - just add latest audit date or today
              const targetDateStr = latestAuditDateStr || todayStr;
              const targetDateObj = new Date(targetDateStr);
              allDateObjects.push(targetDateObj);
              allDates.push(targetDateObj.toLocaleDateString('en-GB', dateFormat));
              
              // For GSC-based pillars (Authority, Visibility), use current audit data if available
              if (savedAuditForTrend) {
                const currentSearchData = savedAuditForTrend?.searchData;
                const currentScores = savedAuditForTrend?.scores;
                
                if (currentSearchData) {
                  // Calculate Visibility from current position
                  const currentPosition = currentSearchData.averagePosition || 40;
                  const clampedPos = Math.max(1, Math.min(40, currentPosition));
                  const scale = (clampedPos - 1) / 39;
                  const posScore = 100 - scale * 90;
                  const visibility = clampScore(posScore);
                  visibilityData.push(visibility);
                  debugLog(` Added Visibility score (${visibility}) for today from current audit`, 'info');
                  
                  // Use current Authority score if available
                  const currentAuthority = currentScores?.authority || null;
                  if (currentAuthority !== null && currentAuthority !== undefined) {
                    authorityData.push(currentAuthority);
                    debugLog(` Added Authority score (${currentAuthority}) for today from current audit`, 'info');
                  } else {
                    // Fallback: calculate Authority from current data
                    const pillarScores = calculatePillarFromMetrics(
                      currentPosition,
                      currentSearchData.ctr || 0,
                      todayStr,
                      currentTopQueries,
                      currentBacklinkMetrics,
                      currentLocalSignals,
                        currentSiteReviews
                      );
                    const authScore = typeof pillarScores.authority === 'object' ? pillarScores.authority.score : pillarScores.authority;
                    authorityData.push(authScore);
                    debugLog(` Calculated Authority score (${authScore}) for today from current audit data`, 'info');
                  }
                } else {
                  // No current search data - use null
                  authorityData.push(null);
                  visibilityData.push(null);
                }
              } else {
                // No saved audit data - use null
                authorityData.push(null);
                visibilityData.push(null);
              }
              
              // For today, use current Business Profile data if available, otherwise calculated
              if (currentLocalEntity !== null) {
                localEntityData.push(currentLocalEntity);
              } else {
                localEntityData.push(null);
              }
              if (currentServiceArea !== null) {
                serviceAreaData.push(currentServiceArea);
              } else {
                serviceAreaData.push(null);
              }
              
              // For Content/Schema, check if we have real data for today
              const todayRealScore = contentSchemaMap.get(todayStr);
              if (todayRealScore !== undefined) {
                contentSchemaData.push(todayRealScore);
                contentSchemaDataEstimated.push(null);
                debugLog(` Added today's Content/Schema score (${todayRealScore}) from Supabase`, 'info');
              } else {
                contentSchemaData.push(null);
                contentSchemaDataEstimated.push(currentContentSchema);
                debugLog(`Using current Content/Schema score (${currentContentSchema}) as estimate for today`, 'info');
              }
              
              // For Brand Overlay, use current score if available
              if (currentBrandOverlay !== null) {
                brandOverlayData.push(currentBrandOverlay);
                debugLog(` Added Brand Overlay score (${currentBrandOverlay}) for today from current audit`, 'info');
              } else {
                brandOverlayData.push(null);
              }
            }
            
            // Apply label spacing to dates with year detection (show every labelStep-th label)
            let lastVisibleYear = null;
            chartDates = allDates.map((d, i) => {
              if (i % labelStep === 0 || i === allDates.length - 1) {
                const currentYear = allDateObjects[i].getFullYear();
                
                // Add year if it changed from the last visible label
                if (lastVisibleYear !== null && currentYear !== lastVisibleYear) {
                  lastVisibleYear = currentYear;
                  return `${d} ${currentYear}`;
                }
                
                lastVisibleYear = currentYear;
                return d;
              }
              return ''; // Empty string for labels we don't want to show
            });
            
            // Store date objects for timeseries data
            chartDateObjects = allDateObjects;
          } else {
            // No timeseries data available - use all nulls (no mock data)
            debugLog('No timeseries data available - chart will show empty with null values', 'warn');
            
            // Still fetch historical data for Money Pages trend chart even without timeseries
            const propertyUrl = document.getElementById('propertyUrl')?.value || '';
            if (propertyUrl) {
              try {
                // Calculate date range from saved audit or use default
                const dateRange = parseInt(document.getElementById('dateRange')?.value || '30', 10);
                const endDate = new Date().toISOString().split('T')[0];
                const startDate = new Date();
                startDate.setDate(startDate.getDate() - dateRange);
                const startDateStr = startDate.toISOString().split('T')[0];
                
                debugLog(`Fetching historical data for Money Pages trend (no timeseries): ${startDateStr} to ${endDate}`, 'info');
                const moneyPagesHistory = await fetchContentSchemaHistory(propertyUrl, startDateStr, endDate);
                
                // Phase 3: Render Money Pages trend chart
                if (typeof renderMoneyPagesTrendChart === 'function') {
                  setTimeout(() => {
                    renderMoneyPagesTrendChart(moneyPagesHistory);
                  }, 1000); // Delay to ensure DOM is ready and chart container exists
                } else {
                  debugLog(' renderMoneyPagesTrendChart function not found', 'warn');
                }
              } catch (error) {
                debugLog(` Error fetching historical data for Money Pages: ${error.message}`, 'warn');
                // Still try to render with empty history (will show current audit data if available)
                if (typeof renderMoneyPagesTrendChart === 'function') {
                  setTimeout(() => {
                    renderMoneyPagesTrendChart([]);
                  }, 1000);
                }
              }
            }
            
            // Use all null values - no mock/estimated data
            localEntityData = new Array(numDataPoints).fill(null);
            serviceAreaData = new Array(numDataPoints).fill(null);
            authorityData = new Array(numDataPoints).fill(null);
            visibilityData = new Array(numDataPoints).fill(null);
            contentSchemaData = new Array(numDataPoints).fill(null);
            contentSchemaDataEstimated = new Array(numDataPoints).fill(null);
            brandOverlayData = new Array(numDataPoints).fill(null);
            
            // Generate dates for the date range
            const fallbackDates = [];
            const fallbackDateObjects = [];
              for (let i = 0; i < numDataPoints; i++) {
              const dateObj = new Date();
              if (dateRange <= 90) {
                // Daily data
                dateObj.setDate(dateObj.getDate() - (numDataPoints - 1 - i));
              } else {
                // Weekly data
                dateObj.setDate(dateObj.getDate() - ((numDataPoints - 1 - i) * 7));
              }
              fallbackDateObjects.push(dateObj);
              fallbackDates.push(dateObj.toLocaleDateString('en-GB', dateFormat));
            }
            chartDates = fallbackDates;
            chartDateObjects = fallbackDateObjects;
          }
          
          // Calculate min and max across all datasets (filter out null values)
          const allData = [...localEntityData, ...serviceAreaData, ...authorityData, ...visibilityData, ...contentSchemaData, ...brandOverlayData].filter(v => v !== null && v !== undefined && !isNaN(v));
          const dataMin = allData.length > 0 ? Math.min(...allData) : 0;
          const dataMax = allData.length > 0 ? Math.max(...allData) : 100;
          const dataRange = dataMax - dataMin;
          
          // Debug: Log Content/Schema data to see what we have
          const contentSchemaValid = contentSchemaData.filter(v => v !== null && v !== undefined && !isNaN(v));
          debugLog(`Content/Schema dataset: ${contentSchemaValid.length} valid values out of ${contentSchemaData.length} total. Values: ${contentSchemaValid.join(', ')}`, 'info');
          debugLog(`Content/Schema data array length: ${contentSchemaData.length}, chart dates length: ${chartDates.length}`, 'info');
          debugLog(`Last few Content/Schema values: ${contentSchemaData.slice(-5).join(', ')}`, 'info');
          debugLog(`Content/Schema map size: ${contentSchemaMap.size}, map entries: ${Array.from(contentSchemaMap.entries()).slice(-10).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
          
          // Debug: Log Local Entity and Service Area data arrays
          const localEntityValid = localEntityData.filter(v => v !== null && v !== undefined && !isNaN(v));
          const serviceAreaValid = serviceAreaData.filter(v => v !== null && v !== undefined && !isNaN(v));
          debugLog(`Local Entity dataset: ${localEntityValid.length} valid values out of ${localEntityData.length} total. Last 5 values: ${localEntityData.slice(-5).join(', ')}`, 'info');
          debugLog(`Service Area dataset: ${serviceAreaValid.length} valid values out of ${serviceAreaData.length} total. Last 5 values: ${serviceAreaData.slice(-5).join(', ')}`, 'info');
          debugLog(`Local Entity map size: ${localEntityMap.size}, Service Area map size: ${serviceAreaMap.size}`, 'info');
          
          // If Content/Schema has no valid data, log a warning
          if (contentSchemaValid.length === 0) {
            debugLog(` WARNING: Content/Schema dataset has NO valid values! Map has ${contentSchemaMap.size} entries.`, 'error');
            debugLog(`Content/Schema history fetched: ${contentSchemaHistory.length} records`, 'info');
          }
          
          // Calculate dynamic Y-axis range
          // Minimum range of 30, or actual range + padding if larger
          const minRange = 30;
          const padding = 5; // Add 5 points padding above and below
          const actualRange = Math.max(minRange, dataRange + (padding * 2));
          
          // Calculate Y-axis min and max
          let yAxisMin = Math.max(0, Math.floor(dataMin - padding));
          // Ensure the red risk band (30-39) is always visible in the chart area
          // by never allowing the bottom of the axis to sit above 30.
          if (yAxisMin > 30) {
            yAxisMin = 30;
          }
          const yAxisMax = Math.min(100, Math.ceil(yAxisMin + actualRange));
          
          // Adjust step size based on range (smaller steps for smaller ranges)
          let stepSize = 10;
          if (actualRange <= 40) {
            stepSize = 5;
          } else if (actualRange <= 60) {
            stepSize = 10;
          } else {
            stepSize = 20;
          }
          
          debugLog(`Y-axis range: ${yAxisMin} to ${yAxisMax} (range: ${actualRange}, step: ${stepSize})`, 'info');
          
          // Calculate trend percentages for each dataset
          // Filter out null values to get actual first and last data points
          const calculateTrend = (data) => {
            // Filter out null/undefined values
            const validData = data.filter(v => v !== null && v !== undefined && !isNaN(v));
            if (validData.length < 2) return { percent: 0, isUp: false, isNeutral: true };
            
            const first = validData[0];
            const last = validData[validData.length - 1];
            
            // Handle division by zero (when first value is 0)
            if (first === 0) {
              // If first is 0 and last is also 0, no change
              if (last === 0) {
                return { percent: 0, isUp: false, isNeutral: true };
              }
              // If first is 0 but last has value, show as 100% increase
              return { percent: 100, isUp: true, isNeutral: false };
            }
            
            const percent = ((last - first) / first) * 100;
            
            // Handle NaN or infinite result
            if (isNaN(percent) || !isFinite(percent)) {
              return { percent: 0, isUp: false, isNeutral: true };
            }
            
            // Cap at 100% to avoid showing unrealistic percentages
            const cappedPercent = Math.min(Math.abs(percent), 100);
            // Consider values very close to 0 as neutral (within 0.1% threshold)
            const isNeutral = Math.abs(percent) < 0.1;
            return { 
              percent: cappedPercent, 
              isUp: percent > 0, 
              isNeutral: isNeutral 
            };
          };
          
          const localEntityTrend = calculateTrend(localEntityData);
          const serviceAreaTrend = calculateTrend(serviceAreaData);
          const authorityTrend = calculateTrend(authorityData);
          const visibilityTrend = calculateTrend(visibilityData);
          const contentSchemaTrend = calculateTrend(contentSchemaData);
          const brandOverlayTrend = calculateTrend(brandOverlayData);

          // Update HTML trend summary row
          const trendSummaryRow = document.getElementById('trendSummaryRow');
          if (trendSummaryRow) {
            const buildPill = (label, trend) => {
              let arrow, sign, cls;
              if (trend.isNeutral) {
                arrow = '';
                sign = '';
                cls = 'neutral';
              } else {
                arrow = trend.isUp ? '' : '';
                sign = trend.isUp ? '+' : '';
                cls = trend.isUp ? 'up' : 'down';
              }
              return `
                <div class="trend-pill">
                  <span class="label">${label}</span>
                  <span class="value ${cls}">${arrow} ${sign}${trend.percent.toFixed(1)}%</span>
                </div>
              `;
            };
            trendSummaryRow.innerHTML = [
              buildPill('Local Entity', localEntityTrend),
              buildPill('Service Area', serviceAreaTrend),
              buildPill('Authority', authorityTrend),
              buildPill('Visibility', visibilityTrend),
              buildPill('Content/Schema', contentSchemaTrend),
              buildPill('Brand & Entity', brandOverlayTrend)
            ].join('');
            
            // Add note explaining trend calculation
            const trendNote = trendSummaryRow.nextElementSibling;
            if (!trendNote || !trendNote.classList.contains('trend-calculation-note')) {
              const noteDiv = document.createElement('div');
              noteDiv.className = 'trend-calculation-note';
              noteDiv.style.cssText = 'font-size: 0.75rem; color: #64748b; margin-top: 0.5rem; font-style: italic;';
              noteDiv.textContent = 'Percentage changes are calculated from the first date to the last date in the selected range.';
              trendSummaryRow.parentElement.insertBefore(noteDiv, trendSummaryRow.nextSibling);
            }
          }
          
          // Plugin to make year transition labels bold
          const yearLabelBoldPlugin = {
            id: 'yearLabelBold',
            afterDraw: (chart) => {
              const xScale = chart.scales.x;
              const ctx = chart.ctx;
              const rotation = -45 * (Math.PI / 180); // -45 degrees in radians
              
              // Get the chart dates array from the chart's data labels (original labels before callback)
              const chartDates = chart.data.labels || [];
              
              // Iterate through all data points to find year labels
              chartDates.forEach((originalLabel, dataIndex) => {
                // Check if original label contains a year (4-digit number at the end)
                if (originalLabel && /\d{4}$/.test(originalLabel)) {
                  const label = originalLabel;
                  // Get pixel position for this data point
                  const tickPosition = xScale.getPixelForValue(dataIndex);
                  const yPosition = chart.chartArea.bottom + 25;
                  
                  // Save context
                  ctx.save();
                  
                  // Translate to tick position and rotate
                  ctx.translate(tickPosition, yPosition);
                  ctx.rotate(rotation);
                  
                  // Set bold font with larger size
                  ctx.font = 'bold 14px Arial';
                  ctx.fillStyle = '#000';
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  
                  // Measure text to clear area properly
                  const metrics = ctx.measureText(label);
                  const textWidth = metrics.width;
                  const textHeight = 18;
                  
                  // Clear a larger area to remove the original label
                  ctx.globalCompositeOperation = 'destination-out';
                  ctx.fillRect(-textWidth/2 - 6, -textHeight/2 - 3, textWidth + 12, textHeight + 6);
                  
                  // Switch back to normal drawing
                  ctx.globalCompositeOperation = 'source-over';
                  
                  // Draw bold label
                  ctx.fillText(label, 0, 0);
                  
                  // Restore context
                  ctx.restore();
                }
              });
            }
          };
          
          // Plugin to add RAG background bands with stronger contrast
          const ragBackgroundPlugin = {
            id: 'ragBackground',
            beforeDraw: (chart) => {
              const ctx = chart.ctx;
              const chartArea = chart.chartArea;
              const yScale = chart.scales.y;
              
              // Red zone (0-39) - increased opacity and saturation
              if (yAxisMin <= 39) {
                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(0, yAxisMin)));
                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(39, yAxisMax)));
                ctx.fillStyle = 'rgba(220, 38, 38, 0.18)'; // More saturated red, higher opacity
                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
              }
              
              // Amber zone (40-69) - increased opacity and saturation
              if (yAxisMin <= 69 && yAxisMax >= 40) {
                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(40, yAxisMin)));
                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(69, yAxisMax)));
                ctx.fillStyle = 'rgba(234, 179, 8, 0.18)'; // More saturated amber/yellow, higher opacity
                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
              }
              
              // Green zone (70-100) - increased opacity and saturation
              if (yAxisMax >= 70) {
                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(70, yAxisMin)));
                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(100, yAxisMax)));
                ctx.fillStyle = 'rgba(22, 163, 74, 0.18)'; // More saturated green, higher opacity
                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
              }
            }
          };
          
          // Plugin to draw vertical dividing lines at period transitions (months and years)
          const periodDividingLinePlugin = {
            id: 'periodDividingLine',
            afterDraw: (chart) => {
              const xScale = chart.scales.x;
              const ctx = chart.ctx;
              const chartArea = chart.chartArea;
              
              // Detect period transitions (month and year changes)
              const periodTransitions = [];
              let lastMonth = null;
              let lastYear = null;
              
              // Use stored date objects to detect month/year changes
              chartDateObjects.forEach((dateObj, index) => {
                if (dateObj instanceof Date) {
                  const currentMonth = dateObj.getMonth(); // 0-11
                  const currentYear = dateObj.getFullYear();
                  
                  // Check for month or year transition
                  if (lastMonth !== null && lastYear !== null) {
                    if (currentYear !== lastYear || currentMonth !== lastMonth) {
                      periodTransitions.push(index);
                    }
                  }
                  
                  lastMonth = currentMonth;
                  lastYear = currentYear;
                }
              });
              
              // Draw vertical dotted lines at period transitions
              periodTransitions.forEach((dataIndex) => {
                // Get pixel position for this data point
                const tickPosition = xScale.getPixelForValue(dataIndex);
                
                // Only draw if within chart area horizontally
                if (tickPosition >= chartArea.left && tickPosition <= chartArea.right) {
                  ctx.save();
                  ctx.strokeStyle = 'rgba(120, 120, 120, 0.7)'; // Medium grey, more visible
                  ctx.lineWidth = 3; // Thicker lines
                  ctx.setLineDash([3, 4]); // Dotted line pattern
                  ctx.beginPath();
                  // Extend line beyond chart area to reach axis labels
                  const lineTop = chartArea.top - 10; // Extend above chart
                  const lineBottom = chartArea.bottom + 50; // Extend below chart to reach axis labels
                  ctx.moveTo(tickPosition, lineTop);
                  ctx.lineTo(tickPosition, lineBottom);
                  ctx.stroke();
                  ctx.restore();
                }
              });
            }
          };
          
          // Debug: Log the actual data arrays being passed to the chart
          const brandOverlayValid = brandOverlayData.filter(v => v !== null && v !== undefined && !isNaN(v));
          debugLog(`Chart creation: Local Entity data length=${localEntityData.length}, last 3 values=${localEntityData.slice(-3).join(', ')}, Service Area data length=${serviceAreaData.length}, last 3 values=${serviceAreaData.slice(-3).join(', ')}, Brand & Entity data length=${brandOverlayData.length}, valid values=${brandOverlayValid.length}, last 3 values=${brandOverlayData.slice(-3).join(', ')}, all values=${brandOverlayData.join(', ')}`, 'info');
          
          // DEBUG: Log exact labels being passed to Chart.js
          debugLog(`[Trend Chart] Creating chart with ${chartDates.length} labels`, 'info');
          debugLog(`[Trend Chart] First 5 labels: ${chartDates.slice(0, 5).join(', ')}`, 'info');
          debugLog(`[Trend Chart] Last 5 labels: ${chartDates.slice(-5).join(', ')}`, 'info');
          debugLog(`[Trend Chart] Latest audit date: ${latestAuditDateStr}`, 'info');
          debugLog(`[Trend Chart] Data arrays length - Local Entity: ${localEntityData.length}, Service Area: ${serviceAreaData.length}, Authority: ${authorityData.length}, Visibility: ${visibilityData.length}, Content/Schema: ${contentSchemaData.length}`, 'info');
          
          // Remove inline loading spinner if it exists
          const existingLoading = trendChartContainer.querySelector('.trend-chart-loading');
          if (existingLoading) {
            existingLoading.remove();
            debugLog('Removed inline trend chart loading spinner', 'info');
          }
          
          // Hide full-screen loading overlay
          hideFullScreenLoading();
          
          // Destroy existing chart if it exists (prevent "Canvas is already in use" error)
          if (window.trendChart) {
            try {
              window.trendChart.destroy();
              debugLog(' Destroyed existing trend chart before creating new one', 'info');
            } catch (e) {
              debugLog(` Error destroying existing trend chart: ${e.message}`, 'warn');
            }
            window.trendChart = null;
          }
          
          // Also check if Chart.js has an instance registered for this canvas
          try {
            const existingChart = Chart.getChart(trendCtx);
            if (existingChart) {
              existingChart.destroy();
              debugLog(' Destroyed Chart.js registered instance for trendChart canvas', 'info');
            }
          } catch (e) {
            debugLog(` Error checking/destroying Chart.js instance: ${e.message}`, 'warn');
          }
          
          window.trendChart = new Chart(trendCtx, {
            type: 'line',
            data: {
              labels: chartDates,
              datasets: [
                {
                  label: 'Local Entity',
                  data: localEntityData,
                  borderColor: 'rgba(147, 51, 234, 1)', // Purple
                  backgroundColor: 'rgba(147, 51, 234, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5,
                  spanGaps: true // Connect across null values to show continuous line
                },
                {
                  label: 'Service Area',
                  data: serviceAreaData,
                  borderColor: '#00FFFF', // Cyan (not RAG color)
                  backgroundColor: 'rgba(0, 255, 255, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5,
                  spanGaps: true // Connect across null values to show continuous line
                },
                {
                  label: 'Authority',
                  data: authorityData,
                  borderColor: '#99004C', // Dark pink/magenta
                  backgroundColor: 'rgba(153, 0, 76, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5
                  // No spanGaps - stop at last available GSC data (Dec 4)
                },
                {
                  label: 'Visibility',
                  data: visibilityData,
                  borderColor: 'rgba(37, 99, 235, 1)', // Blue
                  backgroundColor: 'rgba(59, 130, 246, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5
                  // No spanGaps - stop at last available GSC data (Dec 4)
                },
                {
                  label: 'Content / Schema',
                  data: contentSchemaData,
                  borderColor: 'rgba(107, 114, 128, 1)', // Grey
                  backgroundColor: 'rgba(107, 114, 128, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0, // Hide points - show as solid line
                  pointHoverRadius: 5,
                  spanGaps: true, // Connect across null values to show continuous line
                  pointBackgroundColor: 'rgba(107, 114, 128, 1)',
                  pointBorderColor: '#ffffff',
                  pointBorderWidth: 2
                },
                {
                  label: 'Brand & Entity',
                  data: brandOverlayData.length === chartDates.length ? brandOverlayData : (() => {
                    // Ensure data array matches labels length
                    const adjusted = [...brandOverlayData];
                    while (adjusted.length < chartDates.length) {
                      adjusted.push(null);
                    }
                    return adjusted.slice(0, chartDates.length);
                  })(),
                  borderColor: '#FFFF66', // Bright yellow
                  backgroundColor: 'rgba(255, 255, 102, 0.1)', // Bright yellow with transparency
                  borderWidth: 3, // Increased from 2 to make more visible
                  borderDash: [5, 5], // Dashed line to indicate overlay
                  tension: 0.4,
                  pointRadius: 3, // Show points to make line more visible
                  pointHoverRadius: 6,
                  pointBackgroundColor: '#FFFF66',
                  pointBorderColor: '#FFFF66',
                  spanGaps: true,
                  hidden: false // Explicitly ensure dataset is visible
                }
              ]
            },
            plugins: [ragBackgroundPlugin, yearLabelBoldPlugin, periodDividingLinePlugin],
            options: {
              responsive: true,
              maintainAspectRatio: false,
              animation: false, // Disable animation for better performance when changing periods
              layout: {
                padding: {
                  bottom: 100, // Extra padding for rotated 45-degree X-axis labels (need space for diagonal text)
                  left: 15, // Space for left Y-axis labels
                  right: 50, // Extra space for right Y-axis labels (100, 80, 60, 40, 29)
                  top: 10
                }
              },
              scales: {
                x: {
                  ticks: {
                    maxRotation: 45,
                    minRotation: 45,
                    font: {
                      size: 11,
                      weight: 'normal'
                    },
                    callback: function(value, index) {
                      // Only show non-empty labels
                      const label = this.getLabelForValue(value);
                      // Hide year labels (they'll be drawn by plugin in bold)
                      if (label && /\d{4}$/.test(label)) {
                        return ''; // Return empty to hide, plugin will draw it
                      }
                      return label || '';
                    }
                  },
                  grid: {
                    display: true,
                    color: 'rgba(0, 0, 0, 0.05)'
                  }
                },
                y: {
                  min: yAxisMin,
                  max: yAxisMax,
                  position: 'left',
                  ticks: {
                    stepSize: stepSize,
                    font: {
                      size: 12,
                      weight: 'bold'
                    }
                  },
                  grid: {
                    color: 'rgba(0, 0, 0, 0.1)',
                    drawBorder: true
                  }
                },
                y1: {
                  min: yAxisMin,
                  max: yAxisMax,
                  position: 'right',
                  ticks: {
                    stepSize: stepSize,
                    font: {
                      size: 12,
                      weight: 'bold'
                    }
                  },
                  grid: {
                    display: false,
                    drawBorder: false
                  }
                }
              },
              plugins: {
                legend: {
                  display: true,
                  position: 'top',
                  labels: {
                    font: {
                      size: 16,
                      weight: 'bold'
                    },
                    padding: 25,
                    usePointStyle: false,
                    boxWidth: 60,
                    boxHeight: 4,
                    // Use default legend labels (pillar names only, no trends)
                    generateLabels: function(chart) {
                      const original = Chart.defaults.plugins.legend.labels.generateLabels;
                      return original.call(this, chart);
                    }
                  }
                },
                tooltip: {
                  mode: 'index',
                  intersect: false
                }
              }
            }
          });
          debugLog(' Trend chart created successfully', 'success');
          debugLog(`trendChart type after creation: ${typeof window.trendChart}`, 'info');
          debugLog(`trendChart instanceof Chart: ${window.trendChart instanceof Chart}`, 'info');
          debugLog(`Chart data points: Local Entity=${localEntityData.length}, Visibility=${visibilityData.length}, Authority=${authorityData.length}`, 'info');
          
          // Add event listeners for Authority mode toggle buttons (sync with KPI toggle)
          ['all', 'nonEducation', 'money'].forEach(mode => {
            const btn = document.getElementById(`trend-mode-${mode}`);
            if (btn) {
              btn.addEventListener('click', () => {
                // Update selected mode (shared with KPI toggle)
                window.trendAuthorityMode = mode;
                debugLog(` Trend chart Authority mode changed to: ${mode === 'all' ? 'All pages' : mode === 'nonEducation' ? 'Exclude education' : 'Money pages only'}`, 'info');
                
                // Update button styles for both KPI and trend toggles
                ['all', 'nonEducation', 'money'].forEach(m => {
                  // Update trend toggle buttons
                  const trendBtn = document.getElementById(`trend-mode-${m}`);
                  if (trendBtn) {
                    if (m === mode) {
                      trendBtn.style.background = '#10b981';
                      trendBtn.style.color = 'white';
                    } else {
                      trendBtn.style.background = 'white';
                      trendBtn.style.color = '#666';
                    }
                  }
                  // Update KPI toggle buttons
                  const kpiBtn = document.getElementById(`kpi-mode-${m}`);
                  if (kpiBtn) {
                    if (m === mode) {
                      kpiBtn.style.background = '#10b981';
                      kpiBtn.style.color = 'white';
                    } else {
                      kpiBtn.style.background = 'white';
                      kpiBtn.style.color = '#666';
                    }
                  }
                });
                
                // Redraw the chart with new Authority data
                if (window.trendChart && typeof displayDashboard === 'function') {
                  // Re-run displayDashboard to recalculate with new mode
                  displayDashboard();
                }
              });
            }
          });
          
          debugLog('=== DISPLAY DASHBOARD: Complete ===', 'success');
        } catch (e) {
          debugLog(` Error creating trend chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.error('Error creating trend chart:', e);
          
          // Hide full-screen loading overlay
          hideFullScreenLoading();
          
          // Show error message to user
          const trendCanvas = document.getElementById('trendChart');
          if (trendCanvas && trendCanvas.parentElement) {
            // Remove any existing error messages
            const existingError = trendCanvas.parentElement.querySelector('.trend-chart-error');
            if (existingError) existingError.remove();
            
            // Show error message to user
            const errorDiv = document.createElement('div');
            errorDiv.className = 'trend-chart-error';
            errorDiv.style.cssText = 'background: #fee2e2; padding: 1rem; border-radius: 4px; border-left: 3px solid #ef4444; margin-bottom: 1rem; font-size: 0.9rem; color: #991b1b;';
            errorDiv.innerHTML = `<strong>Error loading trend chart:</strong> ${e.message}. Please refresh the page or run a new audit.`;
            trendCanvas.parentElement.insertBefore(errorDiv, trendCanvas);
          }
        }
      }, 100);
    }

    // Function to load shared audit data
    async function loadSharedAudit(shareId) {
      try {
        debugLog(`Loading shared audit: ${shareId}`, 'info');
        const response = await fetch(apiUrl(`/api/supabase/get-shared-audit?shareId=${encodeURIComponent(shareId)}`));
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.message || 'Failed to load shared audit');
        }
        
        const result = await response.json();
        if (result.status === 'ok' && result.data) {
          debugLog(' Shared audit loaded successfully', 'success');
          return result.data;
        } else {
          throw new Error('Invalid shared audit data');
        }
      } catch (error) {
        debugLog(` Error loading shared audit: ${error.message}`, 'error');
        showStatus(`Failed to load shared audit: ${error.message}`, 'error');
        return null;
      }
    }

    // Function to create shareable link (exposed globally for onclick)
    window.createShareableLink = async function() {
      const savedAudit = await loadAuditResults();
      if (!savedAudit || !savedAudit.scores) {
        showStatus('No audit data available to share. Please run an audit first.', 'error');
        return;
      }

      try {
        showStatus('Creating shareable link...', 'info');
        const response = await fetch(apiUrl('/api/supabase/create-shared-audit'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            auditData: savedAudit
          })
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.message || 'Failed to create shareable link');
        }

        const result = await response.json();
        if (result.status === 'ok' && result.shareUrl) {
          // Copy to clipboard
          await navigator.clipboard.writeText(result.shareUrl);
          showStatus(`Shareable link created and copied to clipboard! Link expires in 30 days.`, 'success');
          
          // Show the link in an alert or modal
          alert(`Shareable link created!\n\n${result.shareUrl}\n\n(Link copied to clipboard)\n\nThis link expires in 30 days.`);
        } else {
          throw new Error('Invalid response from server');
        }
      } catch (error) {
        debugLog(` Error creating shareable link: ${error.message}`, 'error');
        showStatus(`Failed to create shareable link: ${error.message}`, 'error');
      }
    }

    // Initialize on load
    window.addEventListener('DOMContentLoaded', () => {
      debugLog('=== PAGE LOAD: DOMContentLoaded event fired ===', 'info');
      debugLog(`Window location: ${window.location.href}`, 'info');
      debugLog(`User agent: ${navigator.userAgent}`, 'info');
      loadConfig();
      
      // Check for share parameter in URL
      const urlParams = new URLSearchParams(window.location.search);
      const shareId = urlParams.get('share');
      
      // Load and display last audit results if available
      // Wait a tick to ensure loadConfig() has finished updating the date range input
      setTimeout(async () => {
        let auditToDisplay = null;
        
        if (shareId) {
          // Load shared audit
          debugLog(`Share ID detected: ${shareId}`, 'info');
          auditToDisplay = await loadSharedAudit(shareId);
          if (auditToDisplay) {
            // Save shared audit to localStorage temporarily for display
            safeSetLocalStorage('last_audit_results', auditToDisplay);
            // Show a banner indicating this is a shared view
            const banner = document.createElement('div');
            banner.style.cssText = 'background: #dbeafe; padding: 1rem; border-radius: 4px; border-left: 4px solid #3b82f6; margin-bottom: 1rem; font-size: 0.9rem; color: #1e40af;';
            banner.innerHTML = '<strong> Shared Audit View</strong> - This is a shared audit. You can view all results but cannot run new audits from this view.';
            const dashboard = document.getElementById('dashboard');
            if (dashboard) {
              dashboard.insertBefore(banner, dashboard.firstChild);
            }
            // Hide the run audit button
            const runAuditBtn = document.getElementById('runAudit');
            if (runAuditBtn) {
              runAuditBtn.style.display = 'none';
            }
          }
        }
        
        // If no shared audit or failed to load, try localStorage or Supabase
        if (!auditToDisplay) {
          auditToDisplay = await loadAuditResults();
        }
        
        // If still no audit data, try fetching from Supabase
        if (!auditToDisplay) {
          const propertyUrl = localStorage.getItem('gsc_property_url');
          if (propertyUrl) {
            debugLog('No audit data in localStorage, fetching from Supabase...', 'info');
            auditToDisplay = await fetchLatestAuditFromSupabase(propertyUrl);
            if (auditToDisplay) {
              // Save to localStorage for future use
              safeSetLocalStorage('last_audit_results', auditToDisplay);
              // Update timestamp display
              if (auditToDisplay.timestamp) {
                updateAuditTimestamp(auditToDisplay.timestamp);
              }
              debugLog(' Latest audit loaded from Supabase and saved to localStorage', 'success');
            } else {
              debugLog(' No audit data found in Supabase either', 'warn');
            }
          } else {
            debugLog(' Cannot fetch from Supabase: property URL not configured', 'warn');
          }
        }
        
        const savedAudit = auditToDisplay;
        if (savedAudit && savedAudit.scores && savedAudit.searchData) {
          // CRITICAL: Restore Money Pages Priority data FIRST before any rendering
          debugLog(`Checking saved audit for moneyPagePriorityData: ${!!savedAudit.moneyPagePriorityData}, type: ${Array.isArray(savedAudit.moneyPagePriorityData) ? 'array' : typeof savedAudit.moneyPagePriorityData}, length: ${Array.isArray(savedAudit.moneyPagePriorityData) ? savedAudit.moneyPagePriorityData.length : 'N/A'}, value: ${JSON.stringify(savedAudit.moneyPagePriorityData ? (Array.isArray(savedAudit.moneyPagePriorityData) ? `[${savedAudit.moneyPagePriorityData.length} items]` : savedAudit.moneyPagePriorityData) : 'null').substring(0, 100)}`, 'info');
          
          // Check if moneyPagePriorityData exists but is null/empty
          if (savedAudit.moneyPagePriorityData !== null && savedAudit.moneyPagePriorityData !== undefined) {
            if (Array.isArray(savedAudit.moneyPagePriorityData) && savedAudit.moneyPagePriorityData.length > 0) {
              window.moneyPagePriorityData = savedAudit.moneyPagePriorityData;
              debugLog(` Restored moneyPagePriorityData from saved audit: ${savedAudit.moneyPagePriorityData.length} pages`, 'success');
            } else if (Array.isArray(savedAudit.moneyPagePriorityData) && savedAudit.moneyPagePriorityData.length === 0) {
              debugLog(` moneyPagePriorityData exists but is empty array`, 'warn');
              window.moneyPagePriorityData = [];
            } else {
              debugLog(` moneyPagePriorityData exists but is not an array: ${typeof savedAudit.moneyPagePriorityData}`, 'warn');
              window.moneyPagePriorityData = [];
            }
          } else {
            debugLog(` moneyPagePriorityData is null/undefined in saved audit. Keys in savedAudit: ${Object.keys(savedAudit).join(', ')}`, 'warn');
            // Try to rebuild if we have moneyPagesMetrics
            if (savedAudit.scores?.moneyPagesMetrics?.rows && savedAudit.scores.moneyPagesMetrics.rows.length > 0) {
              debugLog(` Will try to rebuild moneyPagePriorityData from moneyPagesMetrics (${savedAudit.scores.moneyPagesMetrics.rows.length} rows)`, 'info');
            }
          }
          
          if (savedAudit.moneySegmentMetrics) {
            window.moneySegmentMetrics = savedAudit.moneySegmentMetrics;
            debugLog(` Restored moneySegmentMetrics from saved audit`, 'success');
          } else {
            debugLog(` moneySegmentMetrics NOT found in saved audit`, 'warn');
          }
          
          // Ensure moneyPagesMetrics is in scores if it exists in the audit data
          if (!savedAudit.scores.moneyPagesMetrics && savedAudit.moneyPagesMetrics) {
            savedAudit.scores.moneyPagesMetrics = savedAudit.moneyPagesMetrics;
            debugLog(' Moved moneyPagesMetrics from audit root to scores', 'success');
          }
          
          // Store globally for Money Pages sections
          if (savedAudit.scores.moneyPagesMetrics) {
            window.currentMoneyPagesMetrics = savedAudit.scores.moneyPagesMetrics;
            window.moneyPagesMetrics = savedAudit.scores.moneyPagesMetrics;
            debugLog(` Stored moneyPagesMetrics globally: ${savedAudit.scores.moneyPagesMetrics.rows?.length || 0} rows`, 'success');
          }
          
          // If saved audit has a date range, use it to set the input field and button
          // This ensures the UI matches the saved audit's date range
          if (savedAudit.dateRange) {
            const savedDateRange = savedAudit.dateRange;
            document.getElementById('dateRange').value = savedDateRange;
            // Update active button to match saved date range
            document.querySelectorAll('.date-range-btn').forEach(btn => {
              btn.classList.remove('active');
              const btnDays = parseInt(btn.getAttribute('data-days'));
              if (btnDays === savedDateRange) {
                btn.classList.add('active');
              }
            });
            // Update localStorage to match
            localStorage.setItem('gsc_date_range', savedDateRange);
            debugLog(`Set date range to ${savedDateRange} to match saved audit`, 'info');
          }
          
          // Now check if they match (they should, since we just set it)
          const currentDateRange = parseInt(document.getElementById('dateRange')?.value) || 30;
          const savedDateRange = savedAudit.dateRange || currentDateRange;
          
          debugLog(`Checking date range match: saved=${savedDateRange}, current=${currentDateRange}`, 'info');
          
          if (savedDateRange === currentDateRange) {
            debugLog('Loading last audit results from localStorage...', 'info');
            
            // CRITICAL: If moneyPagePriorityData is null but we have moneyPagesMetrics, try to rebuild it
            // But only if buildMoneyPageMetrics is available
            if ((!window.moneyPagePriorityData || window.moneyPagePriorityData.length === 0) && 
                savedAudit.scores?.moneyPagesMetrics?.rows && 
                savedAudit.scores.moneyPagesMetrics.rows.length > 0) {
              debugLog(`Attempting to rebuild moneyPagePriorityData from moneyPagesMetrics (${savedAudit.scores.moneyPagesMetrics.rows.length} rows)...`, 'info');
              
              // Wait for buildMoneyPageMetrics to be available (with timeout)
              let attempts = 0;
              const maxAttempts = 20; // 2 seconds total wait
              debugLog(`Waiting for buildMoneyPageMetrics... (currently: ${typeof window.buildMoneyPageMetrics})`, 'info');
              while (typeof window.buildMoneyPageMetrics !== 'function' && attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
                if (attempts % 5 === 0) {
                  debugLog(`Still waiting for buildMoneyPageMetrics... (attempt ${attempts}/${maxAttempts})`, 'info');
                }
              }
              
              debugLog(`buildMoneyPageMetrics check after wait: ${typeof window.buildMoneyPageMetrics}`, 'info');
              
              if (typeof window.buildMoneyPageMetrics === 'function') {
                try {
                  const topPagesForPriority = savedAudit.scores.moneyPagesMetrics.rows.map(row => ({
                    page: row.url,
                    url: row.url,
                    clicks: row.clicks || 0,
                    impressions: row.impressions || 0,
                    ctr: (row.ctr || 0) * 100,
                    position: row.avgPosition || 0,
                    avgPosition: row.avgPosition || 0,
                    title: row.title || row.url
                  }));
                  
                  window.moneyPagePriorityData = window.buildMoneyPageMetrics(topPagesForPriority, savedAudit.schemaAudit || null);
                  debugLog(` Rebuilt moneyPagePriorityData: ${window.moneyPagePriorityData.length} pages`, 'success');
                  
                  // Save rebuilt data back to localStorage
                  savedAudit.moneyPagePriorityData = window.moneyPagePriorityData;
                  safeSetLocalStorage('last_audit_results', savedAudit);
                } catch (error) {
                  debugLog(` Failed to rebuild moneyPagePriorityData: ${error.message}`, 'warn');
                }
              } else {
                debugLog(` buildMoneyPageMetrics still not available after ${maxAttempts * 100}ms wait`, 'warn');
              }
            }
            
            // Show dashboard immediately with saved results
            document.getElementById('dashboard').style.display = 'block';
            document.getElementById('loading').classList.remove('show');
            // Ensure searchData has timeseries if available
            const searchDataWithTimeseries = savedAudit.searchData || {};
            if (!searchDataWithTimeseries.timeseries) {
              // Try to load timeseries from saved audit
              if (savedAudit.timeseries) {
                searchDataWithTimeseries.timeseries = savedAudit.timeseries;
                debugLog(` Restored timeseries data from saved audit: ${savedAudit.timeseries.length} data points`, 'success');
              } else {
                // Try to fetch timeseries from Supabase gsc_timeseries table
                debugLog('Fetching timeseries data from Supabase for Score Trends chart...', 'info');
                try {
                  const propertyUrl = savedAudit.searchData?.propertyUrl || localStorage.getItem('gsc_property_url');
                  if (propertyUrl) {
                    const endDate = new Date().toISOString().split('T')[0];
                    const startDate = new Date();
                    startDate.setDate(startDate.getDate() - 30); // Last 30 days
                    const startDateStr = startDate.toISOString().split('T')[0];
                    
                    const timeseriesResponse = await fetch(apiUrl(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDate}`));
                    if (timeseriesResponse.ok) {
                      const timeseriesData = await timeseriesResponse.json();
                      if (timeseriesData.status === 'ok' && timeseriesData.timeseries && Array.isArray(timeseriesData.timeseries)) {
                        searchDataWithTimeseries.timeseries = timeseriesData.timeseries;
                        debugLog(` Loaded timeseries data from Supabase: ${timeseriesData.timeseries.length} data points`, 'success');
                      }
                    }
                  }
                } catch (error) {
                  debugLog(` Failed to load timeseries data: ${error.message}`, 'warn');
                }
              }
            }
            
            displayDashboard(
              savedAudit.scores,
              searchDataWithTimeseries,
              savedAudit.snippetReadiness || 0,
              savedAudit.schemaAudit || null,
              savedAudit.localSignals || null
            );
            debugLog(' Last audit results displayed', 'success');
          } else {
            debugLog(`Saved audit date range (${savedDateRange}) doesn't match current (${currentDateRange}). Dashboard not displayed.`, 'warn');
            // Don't show dashboard - user needs to run new audit
          }
        } else {
          // No audit data found - show empty state message
          debugLog(' No audit data found. Please run a new audit.', 'warn');
          const dashboard = document.getElementById('dashboard');
          if (dashboard) {
            dashboard.style.display = 'block';
            dashboard.innerHTML = `
              <div style="padding: 3rem; text-align: center; background: white; border-radius: 8px; margin: 2rem;">
                <h2 style="color: #1e293b; margin-bottom: 1rem;">No Audit Data Found</h2>
                <p style="color: #64748b; margin-bottom: 2rem;">Run your first audit to see the dashboard content.</p>
                <button id="runAudit" onclick="runAudit()" style="background: #f97316; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; font-size: 1rem; cursor: pointer; font-weight: 600;">
                  Run Audit
                </button>
              </div>
            `;
          }
          document.getElementById('loading').classList.remove('show');
        }
      }, 100); // Increased delay to ensure loadConfig completes
      
      debugLog('=== PAGE LOAD: Initialization complete ===', 'success');
    });

    // PDF Report Generation
    async function generatePDFReport() {
      console.log('[PDF] ===== PDF GENERATION STARTED =====');
      
      const btn = document.getElementById('generatePdfBtn');
      const statusDiv = document.getElementById('pdfStatus');
      
      if (!btn) {
        console.error('[PDF] Generate PDF button not found!');
        alert('Error: Generate PDF button not found. Please refresh the page.');
        return;
      }
      
      if (!statusDiv) {
        console.error('[PDF] PDF status div not found!');
      }
      
      // Check if html2pdf is available
      if (typeof html2pdf === 'undefined') {
        const errorMsg = ' PDF library not loaded. Please refresh the page.';
        if (statusDiv) {
          statusDiv.textContent = errorMsg;
          statusDiv.style.color = '#dc2626';
        }
        console.error('[PDF] html2pdf is not defined');
        alert(errorMsg);
        return;
      }
      
      console.log('[PDF] html2pdf library is available');
      
      // Check if dashboard has data
      const dashboard = document.getElementById('dashboard');
      if (!dashboard || dashboard.style.display === 'none') {
        const errorMsg = ' Please run an audit first to generate a report.';
        if (statusDiv) {
          statusDiv.textContent = errorMsg;
          statusDiv.style.color = '#dc2626';
        }
        console.warn('[PDF] Dashboard not available or hidden');
        return;
      }

      console.log('[PDF] Dashboard is available and visible');

      // Disable button and show status
      btn.disabled = true;
      btn.style.opacity = '0.6';
      if (statusDiv) {
        statusDiv.textContent = ' Generating PDF report...';
        statusDiv.style.color = '#2563eb';
      }
      
      console.log('[PDF] Starting PDF generation process...');

      try {
        // Load saved audit data
        const savedAudit = loadAuditResultsSync();
        if (!savedAudit || !savedAudit.scores) {
          throw new Error('No audit data available. Please run an audit first.');
        }

        // Get property URL and date range
        const propertyUrl = document.getElementById('propertyUrl')?.value || 'N/A';
        const dateRange = document.getElementById('dateRange')?.value || 30;
        const auditDate = savedAudit.auditDate || new Date().toISOString().split('T')[0];

        // Convert charts to images first (before creating HTML)
        console.log('[PDF] Converting charts to images...');
        
        // Create temporary canvas elements to capture charts
        const radarCanvas = document.getElementById('radarChart');
        const trendCanvas = document.getElementById('trendChart');
        const snippetCanvas = document.getElementById('snippetReadinessPieChart');
        
        let radarImgData = '';
        let trendImgData = '';
        let snippetImgData = '';
        
        if (radarCanvas && window.radarChart) {
          radarImgData = radarCanvas.toDataURL('image/png');
          console.log('[PDF] Radar chart converted to image');
        }
        
        if (trendCanvas && window.trendChart) {
          trendImgData = trendCanvas.toDataURL('image/png');
          console.log('[PDF] Trend chart converted to image');
        }
        
        if (snippetCanvas && window.snippetReadinessChart) {
          snippetImgData = snippetCanvas.toDataURL('image/png');
          console.log('[PDF] Snippet readiness chart converted to image');
        }

        // Create report HTML with embedded chart images
        console.log('[PDF] Creating report HTML...');
        const reportHTML = createReportHTML(savedAudit, propertyUrl, dateRange, auditDate, {
          radarChart: radarImgData,
          trendChart: trendImgData,
          snippetReadinessChart: snippetImgData
        });

        // Verify reportHTML has content
        if (!reportHTML || reportHTML.length < 100) {
          console.error('[PDF] Report HTML is empty or too short:', reportHTML ? reportHTML.length : 'null/undefined');
          throw new Error('Report HTML is empty or too short. Cannot generate PDF.');
        }
        
        console.log('[PDF] Report HTML created successfully');
        console.log('[PDF] Report HTML length:', reportHTML.length);
        console.log('[PDF] Report HTML starts with:', reportHTML.substring(0, 100));
        console.log('[PDF] Report HTML ends with:', reportHTML.substring(reportHTML.length - 100));
        
        // Check if reportHTML contains expected content
        if (!reportHTML.includes('GAIO Audit Report')) {
          console.warn('[PDF] Warning: Report HTML may not contain expected content');
        }
        
        // Use Workshop Planner approach: exactly match printJourney pattern from print-export-dialog.tsx
        const printWindow = window.open('', '_blank');
        if (!printWindow) {
          throw new Error('Could not open print window. Please allow popups for this site.');
        }
        
        console.log('[PDF] Print window opened');
        console.log('[PDF] Writing HTML content (length:', reportHTML.length, ')');
        
        // Write the complete report HTML directly (it already includes full HTML structure)
        printWindow.document.write(reportHTML);
        printWindow.document.close();
        
        console.log('[PDF] HTML written and document closed');
        
        // Add a slight delay before triggering print to ensure content is fully loaded (exactly like printJourney)
        setTimeout(function() {
          try {
            console.log('[PDF] Attempting to print styled report...');
            printWindow.focus();
            printWindow.print();
            console.log('[PDF] Print dialog triggered');
            
            if (statusDiv) {
              statusDiv.textContent = ' Print dialog opened. Save as PDF from the print dialog.';
              statusDiv.style.color = '#10b981';
              setTimeout(() => {
                statusDiv.textContent = '';
              }, 5000);
            }
          } catch (error) {
            console.error('[PDF] Print error:', error);
            if (statusDiv) {
              statusDiv.textContent = ' Error opening print dialog. Please try again.';
              statusDiv.style.color = '#dc2626';
            }
            alert('Failed to open print dialog: ' + error.message);
          }
        }, 1500); // Increased timeout to ensure content is fully loaded (matches printJourney)

      } catch (error) {
        console.error('[PDF] ===== PDF GENERATION ERROR =====');
        console.error('[PDF] Error message:', error.message);
        console.error('[PDF] Error stack:', error.stack);
        console.error('[PDF] Error object:', error);
        
        const errorMsg = ` Error: ${error.message}`;
        if (statusDiv) {
          statusDiv.textContent = errorMsg;
          statusDiv.style.color = '#dc2626';
        }
        
        // Also show alert so user definitely sees the error
        alert(`PDF Generation Failed:\n\n${error.message}\n\nCheck the browser console for more details.`);
      } finally {
        btn.disabled = false;
        btn.style.opacity = '1';
        console.log('[PDF] ===== PDF GENERATION COMPLETE =====');
      }
    }

    // Convert Chart.js charts to images
    async function convertChartsToImages(container) {
      console.log('[PDF] Converting charts to images...');
      
      // Convert radar chart
      const radarCanvas = document.getElementById('radarChart');
      if (radarCanvas && window.radarChart) {
        console.log('[PDF] Converting radar chart...');
        const radarImg = radarCanvas.toDataURL('image/png');
        const radarImgElement = container.querySelector('#radarChartImg');
        if (radarImgElement) {
          radarImgElement.src = radarImg;
          radarImgElement.style.display = 'block';
          console.log('[PDF] Radar chart image set, data URL length:', radarImg.length);
        } else {
          console.warn('[PDF] Radar chart image element not found in container');
        }
      } else {
        console.warn('[PDF] Radar chart canvas or chart instance not found');
      }

      // Convert trend chart
      const trendCanvas = document.getElementById('trendChart');
      if (trendCanvas && window.trendChart) {
        console.log('[PDF] Converting trend chart...');
        const trendImg = trendCanvas.toDataURL('image/png');
        const trendImgElement = container.querySelector('#trendChartImg');
        if (trendImgElement) {
          trendImgElement.src = trendImg;
          trendImgElement.style.display = 'block';
          console.log('[PDF] Trend chart image set, data URL length:', trendImg.length);
        } else {
          console.warn('[PDF] Trend chart image element not found in container');
        }
      } else {
        console.warn('[PDF] Trend chart canvas or chart instance not found');
      }

      // Convert snippet readiness chart
      const snippetCanvas = document.getElementById('snippetReadinessPieChart');
      if (snippetCanvas && window.snippetReadinessChart) {
        console.log('[PDF] Converting snippet readiness chart...');
        const snippetImg = snippetCanvas.toDataURL('image/png');
        const snippetImgElement = container.querySelector('#snippetReadinessChartImg');
        if (snippetImgElement) {
          snippetImgElement.src = snippetImg;
          snippetImgElement.style.display = 'block';
          console.log('[PDF] Snippet readiness chart image set, data URL length:', snippetImg.length);
        } else {
          console.warn('[PDF] Snippet readiness chart image element not found in container');
        }
      } else {
        console.warn('[PDF] Snippet readiness chart canvas or chart instance not found');
      }
      
      console.log('[PDF] Chart conversion complete');
    }

    // Create report HTML content
    function createReportHTML(auditData, propertyUrl, dateRange, auditDate, chartImages = {}) {
      const scores = auditData.scores || {};
      const searchData = auditData.searchData || {};
      const schemaAudit = auditData.schemaAudit || {};
      const snippetReadiness = auditData.snippetReadiness || 0;
      const localSignals = auditData.localSignals || null;
      const hasLocalSignals = localSignals && localSignals.status === 'ok' && localSignals.data;
      const localSignalsData = hasLocalSignals ? localSignals.data : null;

      // Helper function for RAG status
      const getRAGStatus = (score) => {
        if (score >= 70) return { color: '#10b981', label: 'Green', text: 'Good' };
        if (score >= 40) return { color: '#f59e0b', label: 'Amber', text: 'Needs Improvement' };
        return { color: '#ef4444', label: 'Red', text: 'Poor' };
      };

      // Get next steps (create a helper function similar to the one in displayDashboard)
      const getNextStepsForPDF = (scores, searchData, schemaAudit) => {
        const nextSteps = {};
        
        Object.entries(scores).forEach(([key, score]) => {
          const steps = [];
          
          switch(key) {
            case 'contentSchema':
              if (schemaAudit && schemaAudit.data) {
                const schemaData = schemaAudit.data;
                const { coverage, schemaTypes, richEligible } = schemaData;
                
                // Use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
                const allTypes = new Set();
                if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
                  // Use all detected types for accurate calculation
                  schemaData.allDetectedTypes.forEach(type => {
                    if (type) allTypes.add(type);
                  });
                } else if (schemaTypes && Array.isArray(schemaTypes)) {
                  // Fallback: collect from schemaTypes array (contains all types, sorted by count)
                  schemaTypes.forEach(item => {
                    if (item.type) allTypes.add(item.type);
                  });
                }
                
                const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
                const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
                const foundationMissing = foundationTypes.filter(type => !allTypes.has(type));
                
                if (foundationPresent < 4) {
                  steps.push(`Foundation schemas (30%): ${foundationPresent}/4 present. Add: ${foundationMissing.join(', ')}`);
                } else {
                  steps.push(`Foundation schemas (30%): All 4 present`);
                }
                
                const richEligibleCount = Object.values(richEligible || {}).filter(eligible => eligible === true).length;
                const richResultTypesCount = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'].length;
                if (richEligibleCount < richResultTypesCount) {
                  steps.push(`Rich results (35%): ${richEligibleCount}/${richResultTypesCount} eligible. Add more rich result types`);
                } else {
                  steps.push(`Rich results (35%): All ${richResultTypesCount} types eligible`);
                }
                
                if (coverage < 100) {
                  steps.push(`Coverage (20%): ${coverage.toFixed(1)}% - Add schema to pages without markup`);
                } else {
                  steps.push(`Coverage (20%): 100% - All pages have schema`);
                }
                
                const uniqueTypesCount = allTypes.size;
                if (uniqueTypesCount < 15) {
                  steps.push(`Diversity (15%): ${uniqueTypesCount} unique types. Add more schema types to reach 15+`);
                } else {
                  steps.push(`Diversity (15%): ${uniqueTypesCount} unique types (excellent)`);
                }
              } else {
                steps.push('Schema audit data not available - run audit to see detailed metrics');
              }
              break;
              
            case 'visibility':
              if (searchData) {
                const position = searchData.averagePosition || 0;
                const ctr = searchData.ctr || 0;
                
                if (position > 10) {
                  steps.push(`Average position: ${position.toFixed(1)} - Target top 10 positions`);
                } else {
                  steps.push(`Average position: ${position.toFixed(1)} - Excellent! Maintain top 10 rankings`);
                }
                
                if (ctr < 2.0) {
                  steps.push(`CTR: ${ctr.toFixed(1)}% - Improve click-through rate (target: 2%+)`);
                } else {
                  steps.push(`CTR: ${ctr.toFixed(1)}% - Good CTR! Continue optimizing`);
                }
              }
              break;
              
            case 'authority':
              if (searchData) {
                const ctr = searchData.ctr || 0;
                const position = searchData.averagePosition || 0;
                
                if (ctr < 1.5) {
                  steps.push(`CTR: ${ctr.toFixed(1)}% - Low click-through indicates trust issues. Improve E-A-T signals`);
                } else {
                  steps.push(`CTR: ${ctr.toFixed(1)}% - Good engagement. Build more backlinks to strengthen authority`);
                }
                
                if (position > 15) {
                  steps.push(`Position: ${position.toFixed(1)} - Improve rankings through comprehensive, expert content`);
                }
              }
              break;
              
            case 'localEntity':
              if (hasLocalSignals && localSignalsData) {
                const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                const locationsCount = localSignalsData.locations?.length || 0;
                const knowledgePanel = localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected';
                steps.push(`Current score: ${Math.round(score)} - Using real Business Profile data`);
                steps.push(`Data: NAP consistency: ${napScore}%, Knowledge panel: ${knowledgePanel}, Locations: ${locationsCount}`);
                if (score < 70) {
                  if (napScore < 100) {
                    steps.push(`Action: Improve NAP consistency (currently ${napScore}%)`);
                  }
                  if (!localSignalsData.knowledgePanelDetected) {
                    steps.push(`Action: Work on knowledge panel detection`);
                  }
                }
              } else {
                steps.push(`Current score: ${Math.round(score)} - Using derived calculation from search performance`);
                steps.push(`Priority: Integrate Google Business Profile API to use real local signals data`);
                if (score < 70) {
                  steps.push(`Action: Add LocalBusiness schema markup and ensure NAP consistency`);
                }
              }
              break;
              
            case 'serviceArea':
              if (hasLocalSignals && localSignalsData) {
                const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
                const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                steps.push(`Current score: ${Math.round(score)} - Using real Business Profile data`);
                steps.push(`Data: Service areas: ${serviceAreasCount}, NAP consistency: ${napScore}%`);
                if (score < 70) {
                  if (serviceAreasCount < 5) {
                    steps.push(`Action: Add more service areas (currently ${serviceAreasCount}, target: 5+)`);
                  }
                  if (napScore < 100) {
                    steps.push(`Action: Improve NAP consistency (currently ${napScore}%)`);
                  }
                }
              } else {
                steps.push(`Current score: ${Math.round(score)} - Using derived calculation from Local Entity`);
                steps.push(`Priority: Integrate Google Business Profile API to get real service area data`);
                if (score < 70) {
                  steps.push(`Action: Add ServiceArea schema and create location-specific pages`);
                }
              }
              break;
          }
          
          if (steps.length === 0) {
            if (score >= 70) {
              steps.push('Maintain current performance');
              steps.push('Monitor for any score drops');
            } else if (score >= 40) {
              steps.push('Focus on improving this pillar');
              steps.push('Review specific metrics above');
            } else {
              steps.push('Critical: Immediate action required');
              steps.push('Review all data sources and implement fixes');
            }
          }
          
          nextSteps[key] = steps;
        });
        
        return nextSteps;
      };
      
      const nextSteps = getNextStepsForPDF(scores, searchData, schemaAudit);

      return `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <style>
            body {
              font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
              color: #333;
              line-height: 1.6;
              margin: 0;
              padding: 0;
            }
            .report-header {
              text-align: center;
              border-bottom: 3px solid #f97316;
              padding-bottom: 20px;
              margin-bottom: 30px;
            }
            .report-header h1 {
              color: #f97316;
              margin: 0 0 10px 0;
              font-size: 28px;
            }
            .report-header .meta {
              color: #666;
              font-size: 14px;
            }
            .section {
              margin-bottom: 40px;
              page-break-inside: avoid;
            }
            .section-title {
              background: #f97316;
              color: white;
              padding: 12px 20px;
              margin: 0 0 20px 0;
              font-size: 20px;
              font-weight: bold;
              border-radius: 4px;
            }
            .pillar-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
              gap: 15px;
              margin-bottom: 30px;
            }
            .pillar-card {
              border: 2px solid #e2e8f0;
              border-radius: 8px;
              padding: 15px;
              background: #f8f9fa;
            }
            .pillar-card h3 {
              margin: 0 0 10px 0;
              font-size: 16px;
              color: #333;
            }
            .pillar-score {
              font-size: 36px;
              font-weight: bold;
              margin: 10px 0;
            }
            .rag-indicator {
              display: inline-block;
              width: 12px;
              height: 12px;
              border-radius: 50%;
              margin-right: 5px;
            }
            .metrics-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
              gap: 15px;
              margin-bottom: 30px;
            }
            .metric-card {
              border: 1px solid #e2e8f0;
              border-radius: 6px;
              padding: 15px;
              text-align: center;
              background: #ffffff;
            }
            .metric-value {
              font-size: 28px;
              font-weight: bold;
              color: #2563eb;
              margin: 10px 0;
            }
            .metric-label {
              color: #666;
              font-size: 14px;
            }
            .chart-container {
              text-align: center;
              margin: 30px 0;
              page-break-inside: avoid;
            }
            .chart-container img {
              max-width: 100%;
              height: auto;
              border: 1px solid #e2e8f0;
              border-radius: 4px;
            }
            .chart-title {
              font-size: 18px;
              font-weight: bold;
              margin-bottom: 15px;
              color: #333;
            }
            .definition-box {
              background: #f0f9ff;
              border-left: 4px solid #2563eb;
              padding: 15px;
              margin: 20px 0;
              border-radius: 4px;
            }
            .definition-box h4 {
              margin: 0 0 10px 0;
              color: #2563eb;
            }
            .next-steps {
              background: #fff7ed;
              border-left: 4px solid #f59e0b;
              padding: 15px;
              margin: 20px 0;
              border-radius: 4px;
            }
            .next-steps h4 {
              margin: 0 0 10px 0;
              color: #f59e0b;
            }
            .next-steps ul {
              margin: 10px 0;
              padding-left: 20px;
            }
            .next-steps li {
              margin: 8px 0;
            }
            table {
              width: 100%;
              border-collapse: collapse;
              margin: 20px 0;
            }
            table th, table td {
              border: 1px solid #e2e8f0;
              padding: 10px;
              text-align: left;
            }
            table th {
              background: #f8f9fa;
              font-weight: bold;
            }
            .footer {
              margin-top: 50px;
              padding-top: 20px;
              border-top: 1px solid #e2e8f0;
              text-align: center;
              color: #666;
              font-size: 12px;
            }
          </style>
        </head>
        <body>
          <div class="report-header">
            <h1>GAIO Audit Report</h1>
            <div class="meta">
              <strong>Property:</strong> ${propertyUrl}<br>
              <strong>Date Range:</strong> Last ${dateRange} days<br>
              <strong>Audit Date:</strong> ${new Date(auditDate).toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' })}
            </div>
          </div>

          <!-- Executive Summary -->
          <div class="section">
            <div class="section-title">Executive Summary</div>
            <div style="margin-bottom: 20px;">
              <p><strong>Overall Snippet Readiness:</strong> <span style="font-size: 24px; font-weight: bold; color: ${getRAGStatus(snippetReadiness).color};">${snippetReadiness}%</span> 
              <span class="rag-indicator" style="background-color: ${getRAGStatus(snippetReadiness).color};"></span>${getRAGStatus(snippetReadiness).text}</p>
              <p>The Snippet Readiness score indicates how likely your content is to appear in featured snippets and AI answers. It combines Content/Schema (40%), Visibility (35%), and Authority (25%).</p>
            </div>
          </div>

          <!-- Pillar Scores -->
          <div class="section">
            <div class="section-title">Pillar Scores Overview</div>
            <div class="pillar-grid">
              ${Object.entries(scores).map(([key, score]) => {
                const rag = getRAGStatus(score);
                const pillarNames = {
                  localEntity: 'Local Entity',
                  serviceArea: 'Service Area',
                  authority: 'Authority',
                  visibility: 'Visibility',
                  contentSchema: 'Content/Schema'
                };
                return `
                  <div class="pillar-card">
                    <h3>${pillarNames[key] || key}</h3>
                    <div class="pillar-score" style="color: ${rag.color};">${score}%</div>
                    <div>
                      <span class="rag-indicator" style="background-color: ${rag.color};"></span>
                      <strong>${rag.label}</strong> - ${rag.text}
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>

          <!-- Charts -->
          <div class="section">
            <div class="section-title">Visual Analytics</div>
            
            <div class="chart-container">
              <div class="chart-title">Pillar Scores Radar Chart</div>
              ${chartImages.radarChart ? '<img src="' + chartImages.radarChart + '" alt="Radar Chart" style="max-width: 600px; margin: 0 auto; display: block;">' : '<p style="color: #999;">Chart not available</p>'}
              <p style="color: #666; font-size: 14px; margin-top: 10px;">Radar chart showing current performance across all five pillars. The larger the area, the stronger your overall entity recognition.</p>
            </div>
            
            <div class="chart-container">
              <div class="chart-title">Performance Trends</div>
              ${chartImages.trendChart ? '<img src="' + chartImages.trendChart + '" alt="Trend Chart" style="max-width: 100%; margin: 0 auto; display: block;">' : '<p style="color: #999;">Chart not available</p>'}
              <p style="color: #666; font-size: 14px; margin-top: 10px;">Historical performance trends showing clicks, impressions, CTR, position, and Content/Schema scores over the selected date range.</p>
            </div>
            
            <div class="chart-container">
              <div class="chart-title">Snippet Readiness Gauge</div>
              ${chartImages.snippetReadinessChart ? '<img src="' + chartImages.snippetReadinessChart + '" alt="Snippet Readiness Chart" style="max-width: 500px; margin: 0 auto; display: block;">' : '<p style="color: #999;">Chart not available</p>'}
              <p style="color: #666; font-size: 14px; margin-top: 10px;">Nested doughnut chart showing weighted breakdown of snippet readiness components with actual performance scores.</p>
            </div>
          </div>

          <!-- Metrics -->
          <div class="section">
            <div class="section-title">Key Metrics</div>
            <div class="metrics-grid">
              <div class="metric-card">
                <div class="metric-value">${(searchData.totalClicks || 0).toLocaleString()}</div>
                <div class="metric-label">Total Clicks</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(searchData.totalImpressions || 0).toLocaleString()}</div>
                <div class="metric-label">Total Impressions</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(searchData.ctr || 0).toFixed(1)}%</div>
                <div class="metric-label">Average CTR</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(searchData.averagePosition || 0).toFixed(1)}</div>
                <div class="metric-label">Average Position</div>
              </div>
            </div>
          </div>

          <!-- Pillar Definitions -->
          <div class="section">
            <div class="section-title">Pillar Definitions & Current Status</div>
            ${Object.entries(scores).map(([key, score]) => {
              const rag = getRAGStatus(score);
              const pillarNames = {
                localEntity: 'Local Entity',
                serviceArea: 'Service Area',
                authority: 'Authority',
                visibility: 'Visibility',
                contentSchema: 'Content/Schema'
              };
              // Build definitions dynamically based on whether we have real Business Profile data
              let localEntityDef, serviceAreaDef;
              if (hasLocalSignals && localSignalsData) {
                const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
                const locationsCount = localSignalsData.locations?.length || 0;
                localEntityDef = `Measures how well your business is recognized as a local entity. Uses real data from Google Business Profile API: NAP consistency (${napScore}%), knowledge panel (${localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected'}), locations (${locationsCount}).`;
                serviceAreaDef = `Assesses your service area coverage and geographic relevance. Uses real data from Google Business Profile API: ${serviceAreasCount} service areas, NAP consistency (${napScore}%).`;
              } else {
                localEntityDef = 'Measures how well your business is recognized as a local entity. Based on LocalBusiness schema presence, NAP consistency, and knowledge panel detection. Currently uses derived calculations from GSC data.';
                serviceAreaDef = 'Assesses your service area coverage and geographic relevance. Derived from Local Entity score. Will use real service area data when Google Business Profile API is integrated.';
              }
              
              const definitions = {
                localEntity: localEntityDef,
                serviceArea: serviceAreaDef,
                authority: 'Evaluates your domain authority and trust signals. Calculated from four components: Behaviour Score (40%): CTR for ranking queries + top-10 CTR. Ranking Score (20%): Average position + top-10 impression share. Backlink Score (20%): Referring domains + quality from CSV upload. Review Score (20%): Combined ratings and counts from Google Business Profile + on-site/Trustpilot reviews.',
                visibility: 'Tracks your search visibility and ranking performance. Based on average position from Google Search Console (1 = best, 40 = worst). Score ranges from 10 to 100.',
                contentSchema: 'Measures schema markup quality and completeness. Weighted calculation: Foundation Schemas (30%), Rich Results (35%), Coverage (20%), Diversity (15%).'
              };
              return `
                <div class="definition-box">
                  <h4>${pillarNames[key] || key} - ${score}% 
                    <span class="rag-indicator" style="background-color: ${rag.color};"></span>${rag.label}
                  </h4>
                  <p>${definitions[key] || 'No definition available.'}</p>
                </div>
              `;
            }).join('')}
          </div>

          <!-- Next Steps -->
          <div class="section">
            <div class="section-title">Recommended Next Steps</div>
            ${Object.entries(nextSteps).map(([pillar, steps]) => {
              if (!steps || steps.length === 0) return '';
              const pillarNames = {
                localEntity: 'Local Entity',
                serviceArea: 'Service Area',
                authority: 'Authority',
                visibility: 'Visibility',
                contentSchema: 'Content/Schema'
              };
              return `
                <div class="next-steps">
                  <h4>${pillarNames[pillar] || pillar}</h4>
                  <ul>
                    ${steps.map(step => `<li>${step}</li>`).join('')}
                  </ul>
                </div>
              `;
            }).join('')}
          </div>

          <!-- Schema Audit Summary -->
          ${schemaAudit.data ? `
          <div class="section">
            <div class="section-title">Schema Audit Summary</div>
            <div class="metrics-grid">
              <div class="metric-card">
                <div class="metric-value">${schemaAudit.data.totalPages || 0}</div>
                <div class="metric-label">Total Pages Scanned</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${schemaAudit.data.pagesWithSchema || 0}</div>
                <div class="metric-label">Pages With Schema</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(schemaAudit.data.coverage || 0).toFixed(1)}%</div>
                <div class="metric-label">Schema Coverage</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(schemaAudit.data.schemaTypes || []).length}</div>
                <div class="metric-label">Schema Types Found</div>
              </div>
            </div>
            ${schemaAudit.data.missingSchemaPages && schemaAudit.data.missingSchemaPages.length > 0 ? `
              <div style="margin-top: 20px;">
                <h4>Pages Missing Schema (${schemaAudit.data.missingSchemaPages.length}):</h4>
                <ul style="font-size: 12px; max-height: 200px; overflow-y: auto;">
                  ${schemaAudit.data.missingSchemaPages.slice(0, 20).map(url => `<li>${url}</li>`).join('')}
                  ${schemaAudit.data.missingSchemaPages.length > 20 ? `<li><em>... and ${schemaAudit.data.missingSchemaPages.length - 20} more</em></li>` : ''}
                </ul>
              </div>
            ` : ''}
          </div>
          ` : ''}

          <!-- Top Queries -->
          ${searchData.topQueries && searchData.topQueries.length > 0 ? `
          <div class="section">
            <div class="section-title">Top Queries</div>
            <table>
              <thead>
                <tr>
                  <th>Query</th>
                  <th>Clicks</th>
                  <th>Impressions</th>
                  <th>CTR</th>
                  <th>Position</th>
                </tr>
              </thead>
              <tbody>
                ${searchData.topQueries.slice(0, 20).map(query => `
                  <tr>
                    <td>${query.query || 'N/A'}</td>
                    <td>${(query.clicks || 0).toLocaleString()}</td>
                    <td>${(query.impressions || 0).toLocaleString()}</td>
                    <td>${(query.ctr || 0).toFixed(1)}%</td>
                    <td>${(query.position || 0).toFixed(1)}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
          ` : ''}

          <div class="footer">
            <p>Generated by AIO Audit Dashboard on ${new Date().toLocaleString('en-GB')}</p>
            <p>This report contains data from Google Search Console API and schema audit results.</p>
          </div>
        </body>
        </html>
      `;
    }
    // ======================
    // Ranking & AI: Progress Modal Functions
    // ======================
    const RankingAiProgressModal = {
      steps: [
        { id: 'init', label: 'Initializing', narrative: 'Preparing to fetch ranking and AI data...' },
        { id: 'serp', label: 'Fetching SERP Rankings', narrative: 'Retrieving search engine rankings and search volume data...' },
        { id: 'ai', label: 'Fetching AI Overview Data', narrative: 'Checking AI Overview presence and citations...' },
        { id: 'process', label: 'Processing Results', narrative: 'Combining data and calculating metrics...' },
        { id: 'save', label: 'Saving Data', narrative: 'Storing results to database...' },
        { id: 'complete', label: 'Complete', narrative: 'Ranking & AI check completed successfully!' }
      ],
      
      show() {
        const modal = document.getElementById('rankingAiProgressModal');
        if (modal) {
          modal.style.display = 'block';
          this.updateProgress(0);
          this.renderSteps();
          
          // Hide summary section when starting new scan
          const summaryEl = document.getElementById('rankingAiSummary');
          if (summaryEl) {
            summaryEl.style.display = 'none';
          }
          
          // Disable close button during processing
          const closeBtn = document.getElementById('rankingAiProgressClose');
          if (closeBtn) {
            closeBtn.disabled = true;
            closeBtn.style.opacity = '0.5';
            closeBtn.onclick = null;
          }
        }
      },
      
      hide() {
        const modal = document.getElementById('rankingAiProgressModal');
        if (modal) {
          modal.style.display = 'none';
        }
      },
      
      updateProgress(percent, stepIndex = null) {
        const fill = document.getElementById('rankingAiProgressFill');
        const text = document.getElementById('rankingAiProgressText');
        if (fill) fill.style.width = `${Math.min(100, Math.max(0, percent))}%`;
        if (text) text.textContent = `${Math.round(percent)}%`;
        
        if (stepIndex !== null) {
          this.setActiveStep(stepIndex);
        }
      },
      
      setActiveStep(stepIndex) {
        const steps = document.querySelectorAll('.ranking-ai-step-item');
        steps.forEach((step, idx) => {
          step.classList.remove('active', 'completed', 'pending');
          const icon = step.querySelector('.ranking-ai-step-icon');
          if (idx < stepIndex) {
            step.classList.add('completed');
            if (icon) icon.textContent = '';
          } else if (idx === stepIndex) {
            step.classList.add('active');
            if (icon) icon.textContent = idx + 1;
          } else {
            step.classList.add('pending');
            if (icon) icon.textContent = idx + 1;
          }
        });
        
        const step = this.steps[stepIndex];
        if (step) {
          const currentStepEl = document.getElementById('rankingAiCurrentStep');
          const narrativeEl = document.getElementById('rankingAiStepNarrative');
          if (currentStepEl) currentStepEl.textContent = step.label;
          if (narrativeEl) narrativeEl.textContent = step.narrative;
        }
      },
      
      updateCounts(text) {
        const countsEl = document.getElementById('rankingAiStepCounts');
        if (countsEl) countsEl.textContent = text;
      },
      
      renderSteps() {
        const listEl = document.getElementById('rankingAiStepsList');
        if (!listEl) return;
        
        listEl.innerHTML = this.steps.map((step, idx) => `
          <div class="ranking-ai-step-item pending">
            <div class="ranking-ai-step-icon">${idx + 1}</div>
            <div class="ranking-ai-step-label">${step.label}</div>
          </div>
        `).join('');
      },

      showSummary(summary) {
        const summaryEl = document.getElementById('rankingAiSummary');
        const summaryContentEl = document.getElementById('rankingAiSummaryContent');
        if (!summaryEl || !summaryContentEl) return;

        // Build summary HTML
        const summaryItems = [];
        
        // Handle error case
        if (summary.error) {
          summaryItems.push(`<div style="padding: 1rem; background: #fef2f2; border-radius: 6px; border-left: 3px solid #ef4444; margin-bottom: 1rem;"><strong style="color: #ef4444;">Error:</strong><br><span style="font-size: 1rem;">${summary.errorMessage || 'Unknown error occurred'}</span></div>`);
        }
        
        if (summary.totalKeywords !== undefined) {
          summaryItems.push(`<div style="padding: 0.75rem; background: #f0f9ff; border-radius: 6px; border-left: 3px solid #0284c7;"><strong style="color: #0284c7;">Total Keywords:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.totalKeywords}</span></div>`);
        }
        
        if (summary.keywordsWithRank !== undefined) {
          summaryItems.push(`<div style="padding: 0.75rem; background: #f0fdf4; border-radius: 6px; border-left: 3px solid #10b981;"><strong style="color: #10b981;">With Rankings:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.keywordsWithRank}</span></div>`);
        }
        
        if (summary.top10 !== undefined) {
          summaryItems.push(`<div style="padding: 0.75rem; background: #fffbeb; border-radius: 6px; border-left: 3px solid #f59e0b;"><strong style="color: #f59e0b;">Top 10 Rankings:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.top10}</span></div>`);
        }
        
        if (summary.top3 !== undefined) {
          summaryItems.push(`<div style="padding: 0.75rem; background: #fef3c7; border-radius: 6px; border-left: 3px solid #fbbf24;"><strong style="color: #fbbf24;">Top 3 Rankings:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.top3}</span></div>`);
        }
        
        if (summary.keywordsWithAiOverview !== undefined) {
          summaryItems.push(`<div style="padding: 0.75rem; background: #f5f3ff; border-radius: 6px; border-left: 3px solid #8b5cf6;"><strong style="color: #8b5cf6;">AI Overview Present:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.keywordsWithAiOverview}</span></div>`);
        }
        
        if (summary.keywordsWithAiCitations !== undefined) {
          summaryItems.push(`<div style="padding: 0.75rem; background: #ede9fe; border-radius: 6px; border-left: 3px solid #a78bfa;"><strong style="color: #a78bfa;">AI Citations:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.keywordsWithAiCitations}</span></div>`);
        }
        
        if (summary.avgPositionUnweighted !== null && summary.avgPositionUnweighted !== undefined) {
          summaryItems.push(`<div style="padding: 0.75rem; background: #f0f9ff; border-radius: 6px; border-left: 3px solid #0284c7;"><strong style="color: #0284c7;">Avg Position (Unweighted):</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.avgPositionUnweighted.toFixed(1)}</span></div>`);
        }
        
        if (summary.avgPositionVolumeWeighted !== null && summary.avgPositionVolumeWeighted !== undefined) {
          summaryItems.push(`<div style="padding: 0.75rem; background: #f0f9ff; border-radius: 6px; border-left: 3px solid #0284c7;"><strong style="color: #0284c7;">Avg Position (Weighted):</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.avgPositionVolumeWeighted.toFixed(1)}</span></div>`);
        }
        
        if (summary.keywordsWithVolume !== undefined) {
          summaryItems.push(`<div style="padding: 0.75rem; background: #f0fdf4; border-radius: 6px; border-left: 3px solid #10b981;"><strong style="color: #10b981;">With Search Volume:</strong><br><span style="font-size: 1.1rem; font-weight: 600;">${summary.keywordsWithVolume}</span></div>`);
        }

        summaryContentEl.innerHTML = summaryItems.join('');
        summaryEl.style.display = 'block';
      }
    };
    
    // Make progress modal globally available
    window.RankingAiProgressModal = RankingAiProgressModal;

    // ======================
    // Ranking & AI: Save data to Supabase and localStorage
    // ======================
    /**
     * Save a single batch of keywords incrementally to Supabase keyword_rankings table
     * This allows partial results to be saved even if later batches fail
     */
    async function saveRankingAiDataIncremental(batchRows, auditDate, propertyUrl) {
      try {
        if (!batchRows || batchRows.length === 0) {
          return { success: true, saved: 0 };
        }

        // Prepare keyword rows for insertion
        const keywordRows = batchRows.map(row => ({
          audit_date: auditDate,
          property_url: String(propertyUrl).trim(),
          keyword: String(row.keyword || '').trim(),
          best_rank_group: row.best_rank_group !== null && row.best_rank_group !== undefined ? parseInt(row.best_rank_group) : null,
          best_rank_absolute: row.best_rank_absolute !== null && row.best_rank_absolute !== undefined ? parseInt(row.best_rank_absolute) : null,
          best_url: row.best_url ? String(row.best_url).trim() : null,
          best_title: row.best_title ? String(row.best_title).trim() : null,
          search_volume: row.search_volume !== null && row.search_volume !== undefined ? parseInt(row.search_volume) : null,
          has_ai_overview: row.has_ai_overview === true,
          ai_total_citations: row.ai_total_citations !== null && row.ai_total_citations !== undefined ? parseInt(row.ai_total_citations) : null,
          ai_alan_citations_count: row.ai_alan_citations_count !== null && row.ai_alan_citations_count !== undefined ? parseInt(row.ai_alan_citations_count) : null,
          ai_alan_citations: row.ai_alan_citations ? (Array.isArray(row.ai_alan_citations) ? row.ai_alan_citations : []) : null,
          competitor_counts: row.competitor_counts ? (typeof row.competitor_counts === 'object' ? row.competitor_counts : {}) : null,
          serp_features: row.serp_features ? (typeof row.serp_features === 'object' ? row.serp_features : {}) : null,
          // New boolean fields for SERP feature coverage
          ai_overview_present_any: row.ai_overview_present_any === true || row.has_ai_overview === true,
          local_pack_present_any: row.local_pack_present_any === true || (row.serp_features && row.serp_features.local_pack === true),
          paa_present_any: row.paa_present_any === true || (row.serp_features && row.serp_features.people_also_ask === true),
          featured_snippet_present_any: row.featured_snippet_present_any === true || (row.serp_features && row.serp_features.featured_snippet === true),
          segment: row.segment ? String(row.segment).trim() : null,
          page_type: row.pageType ? String(row.pageType).trim() : null,
          demand_share: row.demand_share !== null && row.demand_share !== undefined ? parseFloat(row.demand_share) : null,
          opportunity_score: row.opportunityScore !== null && row.opportunityScore !== undefined ? parseInt(row.opportunityScore) : null,
          updated_at: new Date().toISOString()
        }));

        // Use upsert endpoint to save batch (will merge duplicates based on unique constraint)
        const response = await fetch(apiUrl('/api/supabase/save-keyword-batch'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            keywordRows,
            auditDate,
            propertyUrl
          })
        });

        if (response.ok) {
          const responseData = await response.json();
          debugLog(` Incremental save: ${batchRows.length} keywords saved to keyword_rankings`, 'success');
          return { success: true, saved: batchRows.length };
        } else {
          const errorText = await response.text();
          debugLog(` Incremental save failed: ${response.status} - ${errorText}`, 'warn');
          return { success: false, saved: 0, error: errorText };
        }
      } catch (err) {
        debugLog(` Error in incremental save: ${err.message}`, 'error');
        return { success: false, saved: 0, error: err.message };
      }
    }

    async function saveRankingAiData(combinedRows, summary) {
      try {
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (!propertyUrl) {
          debugLog(' Cannot save Ranking & AI data: property URL not set', 'warn');
          return;
        }

        // Save to localStorage first
        const rankingAiData = {
          combinedRows,
          summary,
          timestamp: new Date().toISOString()
        };
        localStorage.setItem('rankingAiData', JSON.stringify(rankingAiData));
        debugLog(' Ranking & AI data saved to localStorage', 'success');

        // Save to Supabase
        const auditDate = new Date().toISOString().split('T')[0];
        const response = await fetch(apiUrl('/api/supabase/save-audit'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            propertyUrl,
            auditDate,
            rankingAiData // New field for ranking AI data
          })
        });

        if (response.ok) {
          const responseData = await response.json();
          debugLog(` Ranking & AI data saved to Supabase (${combinedRows.length} keywords)`, 'success');
          if (responseData.data) {
            debugLog(` Supabase confirmed save: ${JSON.stringify(responseData.data).substring(0, 200)}...`, 'info');
          }
        } else {
          const errorText = await response.text();
          debugLog(` Failed to save Ranking & AI data to Supabase: ${response.status} - ${errorText}`, 'warn');
          console.error('[Save Ranking & AI] Full error response:', errorText);
        }
      } catch (err) {
        debugLog(` Error saving Ranking & AI data: ${err.message}`, 'error');
        console.error('Save Ranking & AI data error:', err);
      }
    }

    // ======================
    // Ranking & AI: Normalize summary field names (snake_case to camelCase)
    // ======================
    function normalizeSummaryFields(summary) {
      if (!summary) return summary;
      // Convert snake_case to camelCase for display compatibility
      return {
        totalKeywords: summary.total_keywords ?? summary.totalKeywords,
        keywordsWithRank: summary.keywords_with_rank ?? summary.keywordsWithRank,
        keywordsWithAiOverview: summary.keywords_with_ai_overview ?? summary.keywordsWithAiOverview,
        keywordsWithAiCitations: summary.keywords_with_ai_citations ?? summary.keywordsWithAiCitations,
        top10: summary.top10,
        top3: summary.top3,
        avgPositionUnweighted: summary.avg_position_unweighted ?? summary.avgPositionUnweighted,
        avgPositionVolumeWeighted: summary.avg_position_volume_weighted ?? summary.avgPositionVolumeWeighted,
        keywordsUsedForAvg: summary.keywords_used_for_avg ?? summary.keywordsUsedForAvg,
        keywordsWithVolume: summary.keywords_with_volume ?? summary.keywordsWithVolume,
        // v1.4: Domain Strength context (read-only)
        domainStrength: summary.domainStrength ?? null,
        authorityPriority: summary.authorityPriority ?? null
      };
    }

    // ======================
    // Ranking & AI: Domain Strength context (read-only)
    // ======================
    let __rankingAiAuthorityContext = null;
    async function fetchRankingAiAuthorityContext() {
      if (__rankingAiAuthorityContext) return __rankingAiAuthorityContext;
      try {
        const resp = await fetch(apiUrl('/api/ranking-ai/summary'));
        const json = await resp.json();
        if (!resp.ok || !json || json.status !== 'ok') {
          __rankingAiAuthorityContext = { domainStrength: null, authorityPriority: null };
          return __rankingAiAuthorityContext;
        }
        __rankingAiAuthorityContext = {
          domainStrength: json.domainStrength || null,
          authorityPriority: json.authorityPriority || null
        };
        return __rankingAiAuthorityContext;
      } catch {
        __rankingAiAuthorityContext = { domainStrength: null, authorityPriority: null };
        return __rankingAiAuthorityContext;
      }
    }

    // ======================
    // Ranking & AI: Load data from localStorage or Supabase
    // ======================
    async function loadRankingAiDataFromStorage(forceCheckSupabase = false) {
      try {
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (!propertyUrl) {
          debugLog(' Cannot load Ranking & AI data: property URL not set', 'warn');
          return null;
        }

        // Store localStorage data as fallback (in case Supabase check fails)
        let localStorageFallback = null;
        
        // If forcing Supabase check, skip localStorage
        if (!forceCheckSupabase) {
          // Try localStorage first
          const localData = localStorage.getItem('rankingAiData');
          if (localData) {
            try {
              const parsed = JSON.parse(localData);
              if (parsed.combinedRows && parsed.summary) {
                debugLog(' Ranking & AI data found in localStorage', 'success');
                debugLog(`  Found ${parsed.combinedRows.length} keywords in localStorage`, 'info');
                
                // Re-classify pageType for all rows (fixes stale values)
                if (typeof window.classifyUrlForRankingAi === 'function') {
                  let reclassifiedCount = 0;
                  parsed.combinedRows.forEach(row => {
                    const bestUrl = row.best_url || row.bestUrl || null;
                    if (bestUrl) {
                      const oldPageType = row.pageType || 'Landing';
                      const classification = window.classifyUrlForRankingAi(bestUrl, row.keyword || null);
                      const newPageType = classification.pageType;
                      if (newPageType !== oldPageType) {
                        row.pageType = newPageType;
                        if (classification.segment && classification.segment !== row.segment) {
                          row.segment = classification.segment;
                        }
                        reclassifiedCount++;
                      }
                    }
                  });
                  if (reclassifiedCount > 0) {
                    debugLog(` Re-classified pageType for ${reclassifiedCount} keywords from localStorage`, 'info');
                  }
                }
                
                // Normalize summary field names for compatibility
                parsed.summary = normalizeSummaryFields(parsed.summary);
                // Store as fallback before checking Supabase
                localStorageFallback = parsed;
                
                // Check if localStorage data is missing search_volume (indicates stale data)
                const keywordsMissingVolume = parsed.combinedRows.filter(r => r.search_volume == null || r.search_volume === undefined).length;
                const hasMissingVolume = keywordsMissingVolume > 0;
                
                // Always check Supabase if localStorage has fewer than 10 keywords (likely stale data)
                if (parsed.combinedRows.length < 10) {
                  debugLog(` LocalStorage has only ${parsed.combinedRows.length} keywords, checking Supabase for more...`, 'info');
                  // Continue to Supabase check below
                } else if (hasMissingVolume) {
                  // Check Supabase if localStorage data is missing search_volume
                  debugLog(` LocalStorage data is missing search_volume for ${keywordsMissingVolume}/${parsed.combinedRows.length} keywords, checking Supabase...`, 'info');
                  // Continue to Supabase check below
                } else {
                  // Check if data is recent (within last 24 hours) - if older, check Supabase
                  if (parsed.timestamp) {
                    const localTime = new Date(parsed.timestamp);
                    const now = new Date();
                    const hoursDiff = (now - localTime) / (1000 * 60 * 60);
                    if (hoursDiff < 24) {
                      return parsed;
                    } else {
                      debugLog(` LocalStorage data is ${Math.round(hoursDiff)} hours old, checking Supabase for newer data...`, 'info');
                    }
                  } else {
                    return parsed;
                  }
                }
              }
            } catch (e) {
              debugLog(' Invalid Ranking & AI data in localStorage', 'warn');
            }
          }
        }

        // Try Supabase (either forced or as fallback)
        debugLog(` Loading Ranking & AI data from Supabase for propertyUrl: ${propertyUrl}`, 'info');
        const response = await fetch(apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`));
        debugLog(` API fetch response status: ${response.status} ${response.statusText}`, 'info');
        
        if (response.ok) {
          const json = await response.json();
          debugLog(` API response parsed: status=${json.status}`, 'info');
          debugLog(` Response has data object: ${!!json.data}`, 'info');
          debugLog(` Response has rankingAiData: ${!!json.data?.rankingAiData}`, 'info');
          
          if (json.status === 'ok' && json.data) {
            if (json.data.rankingAiData) {
              if (json.data.rankingAiData.combinedRows) {
                const keywordCount = json.data.rankingAiData.combinedRows.length;
                const summaryKeys = json.data.rankingAiData.summary ? Object.keys(json.data.rankingAiData.summary).join(', ') : 'none';
                debugLog(` Ranking & AI data loaded from Supabase: ${keywordCount} keywords`, 'success');
                debugLog(`  Summary fields: ${summaryKeys}`, 'info');
                debugLog(`  First keyword sample: ${json.data.rankingAiData.combinedRows[0]?.keyword || 'none'}`, 'info');
                
                // Compute opportunity scores if missing (for older data)
                const combinedRows = json.data.rankingAiData.combinedRows;
                
                // Re-classify pageType for all rows (fixes stale database values)
                // This ensures Event/Product pages are correctly identified even if DB has old values
                if (typeof window.classifyUrlForRankingAi === 'function') {
                  let reclassifiedCount = 0;
                  combinedRows.forEach(row => {
                    const bestUrl = row.best_url || row.bestUrl || null;
                    if (bestUrl) {
                      const oldPageType = row.pageType || 'Landing';
                      const classification = window.classifyUrlForRankingAi(bestUrl, row.keyword || null);
                      const newPageType = classification.pageType;
                      if (newPageType !== oldPageType) {
                        row.pageType = newPageType;
                        // Also update segment if it changed
                        if (classification.segment && classification.segment !== row.segment) {
                          row.segment = classification.segment;
                        }
                        reclassifiedCount++;
                      }
                    }
                  });
                  if (reclassifiedCount > 0) {
                    debugLog(` Re-classified pageType for ${reclassifiedCount} keywords (fixed stale DB values)`, 'info');
                  }
                }
                
                const needsOpportunityScore = combinedRows.some(r => r.opportunityScore == null);
                if (needsOpportunityScore) {
                  debugLog(` Computing opportunity scores for ${keywordCount} keywords (missing from Supabase)`, 'info');
                  const maxDemandShare = combinedRows.reduce((max, r) => {
                    const ds = r.demand_share ?? 0;
                    return ds > max ? ds : max;
                  }, 0);
                  combinedRows.forEach(row => {
                    if (row.opportunityScore == null) {
                      const oppResult = computeKeywordOpportunityScore(row, maxDemandShare);
                      row.opportunityScore = oppResult.score;
                      row.oppDemandComponent = oppResult.demandComponent;
                      row.oppRankComponent = oppResult.rankComponent;
                      row.oppAiComponent = oppResult.aiComponent;
                    }
                  });
                }
                
                // Normalize summary field names (convert snake_case to camelCase for compatibility)
                const normalizedSummary = normalizeSummaryFields(json.data.rankingAiData.summary);
                
                // Also save to localStorage for faster access next time
                localStorage.setItem('rankingAiData', JSON.stringify({
                  combinedRows: combinedRows,
                  summary: normalizedSummary,
                  timestamp: new Date().toISOString()
                }));
                debugLog(` Saved ${keywordCount} keywords to localStorage`, 'success');
                return { combinedRows, summary: normalizedSummary };
              } else {
                debugLog(' rankingAiData exists but missing combinedRows array', 'warn');
                debugLog(`  rankingAiData keys: ${Object.keys(json.data.rankingAiData || {}).join(', ')}`, 'warn');
              }
            } else {
              debugLog(' rankingAiData is null or undefined in Supabase response', 'warn');
              debugLog(`  Available data keys: ${Object.keys(json.data || {}).join(', ')}`, 'warn');
              if (json.data.rankingAiData === null) {
                debugLog('  rankingAiData is explicitly null - no keyword rows found in database', 'warn');
              }
            }
          } else {
            debugLog(` API returned error status: ${json.status}`, 'warn');
            debugLog(`  Error message: ${json.message || 'unknown'}`, 'warn');
            if (json.details) {
              debugLog(`  Error details: ${typeof json.details === 'string' ? json.details : JSON.stringify(json.details)}`, 'warn');
            }
          }
        } else {
          const errorText = await response.text();
          debugLog(` Failed to load from Supabase: HTTP ${response.status}`, 'error');
          debugLog(`  Error response: ${errorText.substring(0, 200)}`, 'error');
        }
        
        // If Supabase check failed or returned no data, fall back to localStorage if available
        if (localStorageFallback) {
          debugLog(` Falling back to localStorage data (${localStorageFallback.combinedRows.length} keywords)`, 'success');
          return localStorageFallback;
        }
      } catch (err) {
        debugLog(` Error loading Ranking & AI data from storage: ${err.message}`, 'error');
        // If error occurred but we have localStorage fallback, return it
        if (localStorageFallback) {
          debugLog(` Falling back to localStorage data after error (${localStorageFallback.combinedRows.length} keywords)`, 'success');
          return localStorageFallback;
        }
      }
      return null;
    }

    // ======================
    // Ranking & AI: Fetch and combine data
    // ======================
    async function loadRankingAiData(force = false) {
      debugLog(' loadRankingAiData called with force=' + force, 'info');
      
      // Get RankingAiModule from window (it should always be there)
      const mod = window.RankingAiModule;
      if (!mod) {
        debugLog(' RankingAiModule is not defined in window', 'error');
        debugLog(' Available window properties: ' + Object.keys(window).filter(k => k.includes('Ranking') || k.includes('AI')).join(', '), 'error');
        throw new Error('RankingAiModule is not defined. Please refresh the page.');
      }
      
      debugLog(' RankingAiModule found', 'success');
      debugLog(' RankingAiModule has TRACKED_KEYWORDS: ' + (mod.TRACKED_KEYWORDS ? mod.TRACKED_KEYWORDS.length + ' keywords' : 'missing'), 'success');
      const { hasLoadedOnce, isLoading } = mod.state();

      debugLog(` State check: hasLoadedOnce=${hasLoadedOnce}, isLoading=${isLoading}, force=${force}`, 'info');

      if (isLoading) {
        debugLog(' Already loading, skipping', 'warn');
        return;
      }

      // If not forcing, try to load from storage first
      // But if force=false and hasLoadedOnce=true, still check Supabase for newer data
      if (!force) {
        const storedData = await loadRankingAiDataFromStorage(hasLoadedOnce);
        debugLog(` loadRankingAiDataFromStorage returned: ${storedData ? 'data found' : 'null'}`, 'info');
        if (storedData) {
          debugLog(` Stored data has combinedRows: ${!!storedData.combinedRows}, count: ${storedData.combinedRows?.length || 0}`, 'info');
          debugLog(` Stored data has summary: ${!!storedData.summary}`, 'info');
        }
        
        if (storedData && storedData.combinedRows && storedData.summary) {
          debugLog(` Setting data in RankingAiModule: ${storedData.combinedRows.length} keywords`, 'success');
          // Normalize summary field names before setting
          const normalizedSummary = normalizeSummaryFields(storedData.summary);
          mod.setData(storedData.combinedRows, normalizedSummary);
          mod.setLoadedOnce(true);
          debugLog(` Calling renderRankingAiTab()`, 'info');
          renderRankingAiTab();
          const lastRunEl = document.getElementById("ranking-ai-last-run");
          if (lastRunEl && storedData.timestamp) {
            const date = new Date(storedData.timestamp);
            // Format in GMT/UTC: "DD MMM YYYY, HH:MM:SS GMT"
            const day = String(date.getUTCDate()).padStart(2, '0');
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const month = monthNames[date.getUTCMonth()];
            const year = date.getUTCFullYear();
            const hours = String(date.getUTCHours()).padStart(2, '0');
            const minutes = String(date.getUTCMinutes()).padStart(2, '0');
            const seconds = String(date.getUTCSeconds()).padStart(2, '0');
            const formatted = `${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
            lastRunEl.textContent = `Last run: ${formatted}`;
            debugLog(` Updated last run timestamp: ${formatted}`, 'info');
          }
          debugLog(` Ranking & AI data loaded from storage (${storedData.combinedRows.length} keywords)`, 'success');
          return;
        } else {
          debugLog(` Stored data incomplete or missing`, 'warn');
          if (storedData) {
            debugLog(`  Missing combinedRows: ${!storedData.combinedRows}`, 'warn');
            debugLog(`  Missing summary: ${!storedData.summary}`, 'warn');
          }
        }
      }
      
      if (hasLoadedOnce && !force) {
        debugLog(' Already loaded once and force=false, skipping', 'warn');
        return;
      }

      debugLog(' Starting data fetch from APIs...', 'info');
      mod.setLoading(true);
      const refreshBtn = document.getElementById("ranking-ai-refresh");
      if (refreshBtn) {
        refreshBtn.disabled = true;
        refreshBtn.textContent = "Loading";
      }

      // Show progress modal
      RankingAiProgressModal.show();
      RankingAiProgressModal.updateProgress(5, 0); // Initialize step
      RankingAiProgressModal.updateCounts('');

      // Declare variables outside try block for catch block access
      let allSerpResults = [];
      let keywords = [];
      let scanAborted = false; // Flag to track if scan should be aborted

      // Set up abort handler
      const stopBtn = document.getElementById('rankingAiProgressStop');
      if (stopBtn) {
        stopBtn.onclick = () => {
          scanAborted = true;
          stopBtn.disabled = true;
          stopBtn.textContent = 'Stopping...';
          debugLog(' Scan abort requested by user', 'warn');
          RankingAiProgressModal.updateCounts(' Scan abort requested...');
        };
      }

      try {
        // Load keywords from database instead of hardcoded list
        let keywordsFromDb = [];
        try {
          const keywordsResp = await fetch(apiUrl('/api/keywords/get'));
          if (keywordsResp.ok) {
            const keywordsData = await keywordsResp.json();
            if (keywordsData.status === 'ok' && Array.isArray(keywordsData.keywords) && keywordsData.keywords.length > 0) {
              keywordsFromDb = keywordsData.keywords;
              debugLog(` Loaded ${keywordsFromDb.length} keywords from database`, 'success');
            }
          }
        } catch (err) {
          debugLog(` Failed to load keywords from database: ${err.message}. Falling back to hardcoded list.`, 'warn');
        }
        
        // Use database keywords if available, otherwise fall back to hardcoded list
        // Filter out empty strings and ensure all keywords are valid
        const rawKeywords = keywordsFromDb.length > 0 ? keywordsFromDb : mod.TRACKED_KEYWORDS;
        keywords = rawKeywords
          .filter(kw => kw && typeof kw === 'string' && kw.trim().length > 0)
          .map(kw => kw.trim());
        
        const BATCH_SIZE = 20; // Match API limit

        // Show keyword count BEFORE starting scan
        const keywordCountEl = document.getElementById('rankingAiKeywordCount');
        const keywordCountValueEl = document.getElementById('rankingAiKeywordCountValue');
        if (keywordCountEl && keywordCountValueEl) {
          keywordCountValueEl.textContent = `${keywords.length} keyword${keywords.length !== 1 ? 's' : ''}`;
          keywordCountEl.style.display = 'block';
          RankingAiProgressModal.updateCounts(`Ready to scan ${keywords.length} keywords. Click "Start Scan" to begin.`);
        }

        // Wait for user confirmation before starting (show count for 2 seconds, then auto-start)
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Check if aborted during wait
        if (scanAborted) {
          throw new Error('Scan aborted by user');
        }

        // Hide keyword count and show stop button
        if (keywordCountEl) keywordCountEl.style.display = 'none';
        if (stopBtn) {
          stopBtn.style.display = 'block';
          stopBtn.disabled = false;
        }

        debugLog(` Fetching ranking & AI data for ${keywords.length} keywords`, 'info');
        debugLog(` Keywords: ${keywords.slice(0, 5).join(', ')}${keywords.length > 5 ? '... (+' + (keywords.length - 5) + ' more)' : ''}`, 'info');
        debugLog(` SERP endpoint: ${mod.SERP_RANK_ENDPOINT}`, 'info');
        debugLog(` AI endpoint: ${mod.AI_MODE_ENDPOINT}`, 'info');

        // Step 1: Fetch SERP Rankings (batched if needed) with incremental saving
        RankingAiProgressModal.updateProgress(15, 1);
        RankingAiProgressModal.updateCounts(`Processing ${keywords.length} keywords...`);
        RankingAiProgressModal.setActiveStep(1);
        
        debugLog(' Starting SERP fetch with incremental saving...', 'info');
        
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        const auditDate = new Date().toISOString().split('T')[0];
        
        // Batch keywords if needed
        allSerpResults = [];
        const batches = [];
        for (let i = 0; i < keywords.length; i += BATCH_SIZE) {
          batches.push(keywords.slice(i, i + BATCH_SIZE));
        }
        
        debugLog(` Processing ${batches.length} batch(es) of keywords`, 'info');
        
        // Accumulate combined rows for final summary calculation
        let allCombinedRows = [];
        
        for (let batchIdx = 0; batchIdx < batches.length; batchIdx++) {
          // Check if scan was aborted
          if (scanAborted) {
            throw new Error('Scan aborted by user');
          }
          
          const batch = batches[batchIdx];
          const queryParam = encodeURIComponent(batch.join(","));
          const progressPercent = 15 + Math.floor((batchIdx / batches.length) * 35);
          
          RankingAiProgressModal.updateProgress(progressPercent, 1);
          RankingAiProgressModal.updateCounts(`Processing batch ${batchIdx + 1}/${batches.length} (${batch.length} keywords)...`);
          
          debugLog(` Fetching batch ${batchIdx + 1}/${batches.length} (${batch.length} keywords)`, 'info');
          
          try {
            const serpRes = await fetch(`${mod.SERP_RANK_ENDPOINT}?keywords=${queryParam}`);
            debugLog(` SERP response status for batch ${batchIdx + 1}: ${serpRes.status}`, 'info');
            
            if (!serpRes.ok) {
              const errorText = await serpRes.text();
              debugLog(` SERP request failed for batch ${batchIdx + 1}: ${serpRes.status} - ${errorText}`, 'error');
              
              // If it's a timeout or server error, show warning but continue with partial results
              if (serpRes.status === 504 || serpRes.status === 500) {
                debugLog(` Batch ${batchIdx + 1} timed out or errored, continuing with remaining batches...`, 'warn');
                RankingAiProgressModal.updateCounts(` Batch ${batchIdx + 1} failed (${serpRes.status}), continuing...`);
                // Add error results for this batch
                batch.forEach(kw => {
                  allSerpResults.push({
                    keyword: kw,
                    best_rank_group: null,
                    best_rank_absolute: null,
                    best_url: null,
                    best_title: null,
                    has_ai_overview: false,
                    serp_features: { local_pack: false, featured_snippet: false, people_also_ask: false },
                    ai_overview_present_any: false,
                    local_pack_present_any: false,
                    paa_present_any: false,
                    featured_snippet_present_any: false,
                    search_volume: null,
                    error: `Batch request failed: ${serpRes.status}`
                  });
                });
                continue;
              } else {
                RankingAiProgressModal.updateCounts(`Error: ${serpRes.status}`);
                throw new Error(`SERP rank request failed: ${serpRes.status} - ${errorText}`);
              }
            }
            
            const serpJson = await serpRes.json();
            const batchResults = serpJson.per_keyword || [];
            allSerpResults.push(...batchResults);
            
            debugLog(` Batch ${batchIdx + 1} completed: ${batchResults.length} results`, 'success');
            
            // Save this batch incrementally (without AI data for now - will update later)
            // Create minimal combined rows for this batch
            const batchCombinedRows = batchResults.map(row => {
              const bestUrl = row.best_url || null;
              let classification = { segment: "Education", pageType: "Landing" };
              if (typeof window.classifyUrlForRankingAi === 'function') {
                classification = window.classifyUrlForRankingAi(bestUrl || '', row.keyword);
              }
              
              return {
                keyword: row.keyword,
                segment: classification.segment,
                pageType: classification.pageType,
                best_rank_group: row.best_rank_group,
                best_rank_absolute: row.best_rank_absolute,
                best_url: bestUrl,
                best_title: row.best_title || "",
                // Use SERP response's has_ai_overview (from DataForSEO) - AI fetch will add citation details later
                has_ai_overview: !!(row.has_ai_overview),
                ai_total_citations: 0,
                ai_alan_citations_count: 0,
                ai_alan_citations: [],
                ai_sample_citations: [],
                serp_features: row.serp_features || {
                  has_ai_overview: false,
                  has_local_pack: false,
                  has_featured_snippet: false,
                  has_people_also_ask: false
                },
                // New boolean fields for SERP feature coverage (from SERP API response)
                ai_overview_present_any: row.ai_overview_present_any === true || row.has_ai_overview === true,
                local_pack_present_any: row.local_pack_present_any === true || (row.serp_features && row.serp_features.local_pack === true),
                paa_present_any: row.paa_present_any === true || (row.serp_features && row.serp_features.people_also_ask === true),
                featured_snippet_present_any: row.featured_snippet_present_any === true || (row.serp_features && row.serp_features.featured_snippet === true),
                competitor_counts: {},
                search_volume: row.search_volume ?? null,
                demand_share: 0 // Will be recalculated after all batches
              };
            });
            
            // Save batch incrementally
            if (propertyUrl) {
              const saveResult = await saveRankingAiDataIncremental(batchCombinedRows, auditDate, propertyUrl);
              if (saveResult.success) {
                debugLog(` Batch ${batchIdx + 1} saved incrementally: ${saveResult.saved} keywords`, 'success');
                RankingAiProgressModal.updateCounts(` Batch ${batchIdx + 1} saved (${saveResult.saved} keywords)`);
              } else {
                debugLog(` Batch ${batchIdx + 1} incremental save failed: ${saveResult.error}`, 'warn');
              }
            }
            
            allCombinedRows.push(...batchCombinedRows);
          } catch (batchErr) {
            debugLog(` Error processing batch ${batchIdx + 1}: ${batchErr.message}`, 'error');
            
            // If it's a timeout, continue with remaining batches
            if (batchErr.message.includes('timeout') || batchErr.message.includes('504')) {
              debugLog(` Batch ${batchIdx + 1} timed out, continuing with remaining batches...`, 'warn');
              RankingAiProgressModal.updateCounts(` Batch ${batchIdx + 1} timed out, continuing...`);
              // Add error results for this batch
              batch.forEach(kw => {
                allSerpResults.push({
                  keyword: kw,
                  best_rank_group: null,
                  best_rank_absolute: null,
                  best_url: null,
                  best_title: null,
                  has_ai_overview: false,
                  serp_features: { local_pack: false, featured_snippet: false, people_also_ask: false },
                  ai_overview_present_any: false,
                  local_pack_present_any: false,
                  paa_present_any: false,
                  featured_snippet_present_any: false,
                  search_volume: null,
                  error: `Batch request timed out`
                });
              });
              continue;
            } else {
              throw batchErr;
            }
          }
        }
        
        RankingAiProgressModal.updateProgress(50, 1);
        RankingAiProgressModal.updateCounts(` Retrieved SERP data for ${allSerpResults.length}/${keywords.length} keywords (saved incrementally)`);
        
        // Step 2: Fetch AI Overview Data (batched to avoid server timeout)
        RankingAiProgressModal.updateProgress(55, 2);
        RankingAiProgressModal.setActiveStep(2);
        RankingAiProgressModal.updateCounts(`Checking AI Overview presence and citations...`);
        
        debugLog(' Starting AI fetch (batched)...', 'info');
        let aiRows = [];
        let aiFetchError = null;
        
        try {
          // Batch AI requests to avoid Vercel 300s timeout
          // Process 10 keywords per batch (each API call takes ~5s, so 10 keywords = ~50s per batch)
          const AI_BATCH_SIZE = 10;
          const aiBatches = [];
          for (let i = 0; i < keywords.length; i += AI_BATCH_SIZE) {
            aiBatches.push(keywords.slice(i, i + AI_BATCH_SIZE));
          }
          
          debugLog(` Processing AI data in ${aiBatches.length} batches of up to ${AI_BATCH_SIZE} keywords each`, 'info');
          
          // Process batches sequentially to avoid overwhelming the API
          for (let batchIdx = 0; batchIdx < aiBatches.length; batchIdx++) {
            // Check if scan was aborted
            if (scanAborted) {
              throw new Error('Scan aborted by user');
            }
            
            const batch = aiBatches[batchIdx];
            const batchProgress = 55 + Math.floor((batchIdx / aiBatches.length) * 20); // 55-75% progress
            
            RankingAiProgressModal.updateProgress(batchProgress, 2);
            RankingAiProgressModal.updateCounts(`Fetching AI data: batch ${batchIdx + 1}/${aiBatches.length} (${batch.length} keywords)...`);
            
            debugLog(` AI batch ${batchIdx + 1}/${aiBatches.length}: ${batch.length} keywords`, 'info');
            
            try {
              // Timeout per batch: 90 seconds (should be enough for 10 keywords)
              const aiFetchPromise = fetch(mod.AI_MODE_ENDPOINT, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ queries: batch })
              });
              
              // Increase timeout to 300 seconds (5 minutes) to match Vercel serverless function timeout
              const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error(`AI batch ${batchIdx + 1} timeout after 300 seconds`)), 300000)
              );
              
              const aiRes = await Promise.race([aiFetchPromise, timeoutPromise]);
              debugLog(` AI batch ${batchIdx + 1} response status: ${aiRes.status}`, 'info');

              if (!aiRes.ok) {
                const errorText = await aiRes.text();
                debugLog(` AI batch ${batchIdx + 1} failed: ${aiRes.status} - ${errorText}`, 'error');
                // Add empty results for this batch
                batch.forEach(keyword => {
                  aiRows.push({
                    query: keyword,
                    has_ai_overview: false,
                    total_citations: 0,
                    alanranger_citations_count: 0,
                    alanranger_citations: [],
                    sample_citations: [],
                    error: `Batch request failed: ${aiRes.status}`
                  });
                });
              } else {
                const aiJson = await aiRes.json();
                const batchResults = aiJson.per_query || [];
                aiRows.push(...batchResults);
                debugLog(` AI batch ${batchIdx + 1}: Retrieved ${batchResults.length} results`, 'success');
              }
            } catch (batchErr) {
              debugLog(` AI batch ${batchIdx + 1} error: ${batchErr.message}`, 'error');
              // Add empty results for this batch
              batch.forEach(keyword => {
                aiRows.push({
                  query: keyword,
                  has_ai_overview: false,
                  total_citations: 0,
                  alanranger_citations_count: 0,
                  alanranger_citations: [],
                  sample_citations: [],
                  error: batchErr.message
                });
              });
            }
            
            // Small delay between batches to avoid rate limiting
            if (batchIdx < aiBatches.length - 1) {
              await new Promise(resolve => setTimeout(resolve, 500));
            }
          }
          
          RankingAiProgressModal.updateProgress(75, 2);
          RankingAiProgressModal.updateCounts(` Retrieved AI Overview data for ${aiRows.length} keywords`);
          debugLog(` Retrieved ${aiRows.length} AI results total`, 'success');
          
        } catch (aiErr) {
          debugLog(` AI fetch error: ${aiErr.message}`, 'error');
          RankingAiProgressModal.updateCounts(` AI Overview check failed (${aiErr.message}), continuing with SERP data only...`);
          aiFetchError = aiErr.message;
          // Continue with empty AI data - UI will still show SERP results
        }
        
        // Step 3: Process Results and merge AI data
        RankingAiProgressModal.updateProgress(80, 3);
        RankingAiProgressModal.setActiveStep(3);
        RankingAiProgressModal.updateCounts(`Combining SERP and AI data...`);
        
        debugLog(' Parsing JSON responses...', 'info');
        debugLog(` SERP results: ${allSerpResults.length} keywords processed`, 'info');
        if (aiFetchError) {
          debugLog(` AI data unavailable: ${aiFetchError}`, 'warn');
        }

        const serpRows = allSerpResults; // Use batched results

        debugLog(`Received ${serpRows.length} SERP results and ${aiRows.length} AI results`, 'info');
        RankingAiProgressModal.updateCounts(`Processing ${serpRows.length} SERP results and ${aiRows.length} AI results...`);

        // Map AI rows by normalised query
        const aiByKeyword = {};
        aiRows.forEach(row => {
          const key = RankingAiModule.normaliseKeyword(row.query);
          aiByKeyword[key] = row;
        });

        // Update existing combined rows with AI data, or create new ones if needed
        // First, create a map of existing combined rows by keyword
        const combinedByKeyword = {};
        allCombinedRows.forEach(row => {
          const key = RankingAiModule.normaliseKeyword(row.keyword);
          combinedByKeyword[key] = row;
        });

        // First pass: classify all SERP rows and collect search volumes for demand_share calculation
        const rowsWithClassification = serpRows.map(row => {
          const key = RankingAiModule.normaliseKeyword(row.keyword);
          const aiRow = aiByKeyword[key] || null;
          const bestUrl = row.best_url || null;
          
          // Use intent-based classification (keyword text drives segment, not URL)
          const segment = RankingAiModule.classifyKeywordSegment(row.keyword, bestUrl);
          const pageType = RankingAiModule.classifyPageTypeForKeyword ? 
            RankingAiModule.classifyPageTypeForKeyword(bestUrl) : "Landing";
          const classification = { segment, pageType };
          
          return {
            ...row,
            aiRow,
            classification,
            search_volume: row.search_volume ?? null
          };
        });
        
        // Calculate total demand for demand_share
        const totalDemand = rowsWithClassification.reduce((sum, r) => {
          const vol = r.search_volume;
          return sum + (vol && vol > 0 ? vol : 0);
        }, 0);
        
        // Second pass: build combined rows with demand_share and AI data
        const combined = rowsWithClassification.map(row => {
          const key = RankingAiModule.normaliseKeyword(row.keyword);
          const aiRow = row.aiRow || null;
          const bestUrl = row.best_url || null;
          const { segment, pageType } = row.classification;

          const aiCitations = aiRow?.alanranger_citations || [];
          const aiOtherCitations = (aiRow?.sample_citations || []).filter(c => {
            const domain = (c.domain || "").toLowerCase();
            return domain && !domain.includes("alanranger.com");
          });

          // Count competitor domains
          const competitorCounts = {};
          aiOtherCitations.forEach(c => {
            const d = (c.domain || "").toLowerCase();
            if (!d) return;
            competitorCounts[d] = (competitorCounts[d] || 0) + 1;
          });

          // Calculate demand_share
          const searchVolume = row.search_volume;
          const demandShare = (searchVolume && searchVolume > 0 && totalDemand > 0) 
            ? searchVolume / totalDemand 
            : 0;

          // Debug: Log search volume for first few keywords
          if (serpRows.indexOf(row) < 3) {
            debugLog(`[DEBUG] Keyword "${row.keyword}": search_volume=${searchVolume}, demand_share=${(demandShare * 100).toFixed(1)}%, segment=${segment}, pageType=${pageType}`, 'info');
          }

          // Canonicalize URL - store both raw and canonical
          const rawTargetUrl = bestUrl || "";
          const canonicalTargetUrl = canonicalizeUrl(rawTargetUrl);
          
          return {
            keyword: row.keyword,
            segment: segment, // Keep capitalized: Brand/Money/Education/Other
            pageType,
            best_rank_group: row.best_rank_group,
            best_rank_absolute: row.best_rank_absolute,
            best_url: bestUrl, // Keep raw for backward compatibility
            rawTargetUrl: rawTargetUrl, // Explicit raw URL
            targetUrl: canonicalTargetUrl, // Canonical URL (single source of truth)
            best_title: row.best_title || "",
            // Use SERP response's has_ai_overview (from DataForSEO) as primary source,
            // fallback to AI API response if SERP doesn't have it
            has_ai_overview: !!(row.has_ai_overview || (aiRow && aiRow.has_ai_overview)),
            ai_total_citations: aiRow?.total_citations ?? 0,
            ai_alan_citations_count: aiRow?.alanranger_citations_count ?? 0,
            ai_alan_citations: aiCitations,
            ai_sample_citations: aiOtherCitations,
            serp_features: row.serp_features || {
              has_ai_overview: false,
              has_local_pack: false,
              has_featured_snippet: false,
              has_people_also_ask: false
            },
            // New boolean fields for SERP feature coverage (from SERP API response)
            ai_overview_present_any: row.ai_overview_present_any === true || row.has_ai_overview === true,
            local_pack_present_any: row.local_pack_present_any === true || (row.serp_features && row.serp_features.local_pack === true),
            paa_present_any: row.paa_present_any === true || (row.serp_features && row.serp_features.people_also_ask === true),
            featured_snippet_present_any: row.featured_snippet_present_any === true || (row.serp_features && row.serp_features.featured_snippet === true),
            competitor_counts: competitorCounts,
            search_volume: searchVolume,
            search_volume_trend: row.search_volume_trend || undefined,
            demand_share: demandShare
            // opportunityScore will be added after all rows are created (see below)
          };
        });
        
        // Compute maxDemandShare for opportunity score calculation
        const maxDemandShare = combined.reduce((max, r) => {
          const ds = r.demand_share ?? 0;
          return ds > max ? ds : max;
        }, 0);
        
        // Add opportunity score to each row
        combined.forEach(row => {
          const oppResult = computeKeywordOpportunityScore(row, maxDemandShare);
          row.opportunityScore = oppResult.score;
          row.oppDemandComponent = oppResult.demandComponent;
          row.oppRankComponent = oppResult.rankComponent;
          row.oppAiComponent = oppResult.aiComponent;
        });
        
        // Debug: Log opportunity scores for first few keywords
        if (combined.length > 0) {
          const sampleRows = combined.slice(0, 3);
          sampleRows.forEach(r => {
            console.debug(`[Opportunity Score] "${r.keyword}": score=${r.opportunityScore}, D=${(r.oppDemandComponent * 100).toFixed(0)}%, R=${(r.oppRankComponent * 100).toFixed(0)}%, A=${(r.oppAiComponent * 100).toFixed(0)}%`);
          });
        }

        // Summary metrics
        const totalKeywords = combined.length;
        const withRank = combined.filter(r => r.best_rank_group != null).length;
        const withAiOverview = combined.filter(r => r.has_ai_overview).length;
        const withAiCitation = combined.filter(r => r.ai_alan_citations_count > 0).length;
        const top10 = combined.filter(r => r.best_rank_group != null && r.best_rank_group <= 10).length;
        const top3 = combined.filter(r => r.best_rank_group != null && r.best_rank_group <= 3).length;
        // Count keywords with search volume (including 0, but not null/undefined)
        const withSearchVolume = combined.filter(r => r.search_volume != null && r.search_volume !== undefined).length;
        
        // Log search volume for each keyword
        combined.forEach(row => {
          const volume = row.search_volume != null && row.search_volume !== undefined
            ? row.search_volume.toLocaleString() 
            : 'none';
          debugLog(`Search volume for "${row.keyword}": ${volume}`, 'info');
        });
        
        debugLog(`Search volume summary: ${withSearchVolume}/${totalKeywords} keywords have search volume data`, 'info');
        RankingAiProgressModal.updateProgress(90, 3);
        RankingAiProgressModal.updateCounts(` Processed ${totalKeywords} keywords (${withRank} ranked, ${withAiOverview} with AI Overview, ${withSearchVolume} with search volume)`);

        // Calculate visibility metrics from combined results (Ranking API only - not part of AIO pillars)
        const validRankingRows = combined.filter(r => r.best_rank_group != null && typeof r.best_rank_group === 'number');
        let avgPositionUnweighted = null;
        let avgPositionVolumeWeighted = null;
        
        if (validRankingRows.length >= 1) {
          // Unweighted average position
          const sumRanks = validRankingRows.reduce((sum, k) => sum + k.best_rank_group, 0);
          avgPositionUnweighted = Math.round((sumRanks / validRankingRows.length) * 100) / 100;
          
          // Demand-weighted average position
          let sumWeightedRanks = 0;
          let sumVolumes = 0;
          
          for (const row of validRankingRows) {
            const vol = (row.search_volume !== null && row.search_volume !== undefined && row.search_volume > 0)
              ? row.search_volume
              : 10; // Fallback
            sumWeightedRanks += row.best_rank_group * vol;
            sumVolumes += vol;
          }
          
          if (sumVolumes > 0) {
            avgPositionVolumeWeighted = Math.round((sumWeightedRanks / sumVolumes) * 100) / 100;
          }
        }
        
        const summary = {
          total_keywords: totalKeywords,
          keywords_with_rank: withRank,
          keywords_with_ai_overview: withAiOverview,
          keywords_with_ai_citations: withAiCitation,
          top10,
          top3,
          // Include visibility metrics (Ranking API only - not part of AIO pillars)
          avg_position_unweighted: avgPositionUnweighted,
          avg_position_volume_weighted: avgPositionVolumeWeighted,
          keywords_used_for_avg: validRankingRows.length,
          keywords_with_volume: withSearchVolume
        };

        // Debug: Log AI citations for first few keywords
        const keywordsWithCitations = combined.filter(r => r.ai_alan_citations_count > 0);
        debugLog(` AI Citations Summary: ${keywordsWithCitations.length}/${totalKeywords} keywords have citations`, 'info');
        if (keywordsWithCitations.length > 0) {
          keywordsWithCitations.slice(0, 5).forEach(row => {
            debugLog(`   "${row.keyword}": ${row.ai_alan_citations_count} citations`, 'info');
          });
        } else {
          debugLog(`   No keywords have AI citations. AI fetch error: ${aiFetchError || 'none'}`, 'warn');
          if (aiRows.length > 0) {
            debugLog(`   AI rows received: ${aiRows.length}, checking first few...`, 'info');
            aiRows.slice(0, 3).forEach(aiRow => {
              debugLog(`    - "${aiRow.query}": alanranger_citations_count=${aiRow.alanranger_citations_count ?? 'undefined'}, total_citations=${aiRow.total_citations ?? 'undefined'}`, 'info');
            });
          }
        }

        // Normalize summary field names before setting (ensure camelCase for display)
        const normalizedSummary = normalizeSummaryFields(summary);
        mod.setData(combined, normalizedSummary);
        mod.setLoadedOnce(true);
        
        // Step 4: Save Data
        RankingAiProgressModal.updateProgress(95, 4);
        RankingAiProgressModal.setActiveStep(4);
        RankingAiProgressModal.updateCounts(`Saving to database...`);
        
        // Update incrementally saved rows with merged AI data
        if (propertyUrl && combined.length > 0) {
          debugLog(` Updating incrementally saved rows with merged AI data...`, 'info');
          const updateResult = await saveRankingAiDataIncremental(combined, auditDate, propertyUrl);
          if (updateResult.success) {
            debugLog(` Updated ${updateResult.saved} keyword rows with AI data`, 'success');
          } else {
            debugLog(` Failed to update rows with AI data: ${updateResult.error}`, 'warn');
          }
        }
        
        // Save to Supabase and localStorage
        await saveRankingAiData(combined, summary);
        
        // CRITICAL: Fetch and save queryTotals for all ranking keywords
        RankingAiProgressModal.updateProgress(96, 4);
        RankingAiProgressModal.updateCounts(`Fetching GSC query totals for ${combined.length} keywords...`);
        debugLog(` Fetching queryTotals for ${combined.length} ranking keywords...`, 'info');
        
        try {
          const allKeywords = combined.map(r => r.keyword).filter(k => k && k.trim());
          if (allKeywords.length > 0) {
            const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
            const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28');
            
            // Fetch queryTotals from GSC API
            const keywordsParam = encodeURIComponent(JSON.stringify(allKeywords));
            const propertyParam = encodeURIComponent(propertyUrl);
            const gscResponse = await fetch(apiUrl(`/api/aigeo/gsc-entity-metrics?property=${propertyParam}&keywords=${keywordsParam}&days=${dateRange}`));
            
            if (gscResponse.ok) {
              const gscData = await gscResponse.json();
              if (gscData.status === 'ok' && gscData.data && Array.isArray(gscData.data.queryTotals)) {
                const queryTotals = gscData.data.queryTotals;
                debugLog(` Fetched queryTotals for ${queryTotals.length} keywords from GSC`, 'success');
                
                // Load existing audit data
                const savedAudit = loadAuditResultsSync();
                if (savedAudit && savedAudit.searchData) {
                  // Merge queryTotals into searchData
                  savedAudit.searchData.queryTotals = queryTotals;
                  
                  // CRITICAL: Use the SAME audit_date as the existing audit, not today's date
                  // This ensures queryTotals are saved to the same audit record
                  let auditDate = new Date().toISOString().split('T')[0]; // Fallback to today
                  if (savedAudit.timestamp) {
                    try {
                      auditDate = new Date(savedAudit.timestamp).toISOString().split('T')[0];
                      debugLog(` Using existing audit date for queryTotals: ${auditDate}`, 'info');
                    } catch (e) {
                      debugLog(` Failed to parse saved audit timestamp, using today's date`, 'warn');
                    }
                  }
                  
                  // Save to Supabase
                  const saveResponse = await fetch(apiUrl('/api/supabase/save-audit'), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      propertyUrl: propertyUrl,
                      auditDate: auditDate,
                      searchData: savedAudit.searchData // Include updated searchData with queryTotals
                    })
                  });
                  
                  if (saveResponse.ok) {
                    debugLog(` Saved queryTotals to Supabase (${queryTotals.length} keywords) for audit_date: ${auditDate}`, 'success');
                    
                    // CRITICAL: Also update localStorage so loadAuditResultsSync() can find the data
                    try {
                      safeSetLocalStorage('last_audit_results', savedAudit);
                      debugLog(` Updated localStorage with queryTotals`, 'success');
                    } catch (localStorageErr) {
                      debugLog(` Failed to update localStorage: ${localStorageErr.message}`, 'warn');
                    }
                    
                    // Update audit date pill to reflect new scan
                    updateAuditTimestamp(new Date().toISOString());
                  } else {
                    const errorText = await saveResponse.text();
                    debugLog(` Failed to save queryTotals to Supabase: ${saveResponse.status} - ${errorText}`, 'warn');
                  }
                } else {
                  debugLog(` No existing audit data found, creating new audit record with queryTotals...`, 'warn');
                  // Create new audit record with queryTotals
                  const auditDate = new Date().toISOString().split('T')[0];
                  const saveResponse = await fetch(apiUrl('/api/supabase/save-audit'), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      propertyUrl: propertyUrl,
                      auditDate: auditDate,
                      searchData: { queryTotals: queryTotals }
                    })
                  });
                  
                  if (saveResponse.ok) {
                    debugLog(` Created new audit record with queryTotals (${queryTotals.length} keywords)`, 'success');
                    
                    // CRITICAL: Also save to localStorage so loadAuditResultsSync() can find the data
                    try {
                      const newAuditData = {
                        searchData: { queryTotals: queryTotals },
                        timestamp: new Date().toISOString(),
                        propertyUrl: propertyUrl
                      };
                      safeSetLocalStorage('last_audit_results', newAuditData);
                      debugLog(` Saved new audit record to localStorage with queryTotals`, 'success');
                    } catch (localStorageErr) {
                      debugLog(` Failed to save to localStorage: ${localStorageErr.message}`, 'warn');
                    }
                    
                    updateAuditTimestamp(new Date().toISOString());
                  } else {
                    const errorText = await saveResponse.text();
                    debugLog(` Failed to create audit record with queryTotals: ${saveResponse.status} - ${errorText}`, 'warn');
                  }
                }
              } else {
                debugLog(` GSC API did not return queryTotals data`, 'warn');
              }
            } else {
              const errorText = await gscResponse.text();
              debugLog(` Failed to fetch queryTotals from GSC: ${gscResponse.status} - ${errorText}`, 'warn');
            }
          } else {
            debugLog(` No keywords to fetch queryTotals for`, 'warn');
          }
        } catch (queryTotalsErr) {
          debugLog(` Error fetching/saving queryTotals: ${queryTotalsErr.message}`, 'error');
          // Don't fail the entire scan if queryTotals fetch fails
        }
        
        RankingAiProgressModal.updateProgress(98, 4);
        RankingAiProgressModal.updateCounts(` Data saved successfully`);
        
        // Step 5: Complete
        RankingAiProgressModal.updateProgress(100, 5);
        RankingAiProgressModal.setActiveStep(5);
        
        // Show completion summary
        RankingAiProgressModal.showSummary({
          totalKeywords,
          keywordsWithRank: withRank,
          top10,
          top3,
          keywordsWithAiOverview: withAiOverview,
          keywordsWithAiCitations: withAiCitation,
          avgPositionUnweighted: summary.avg_position_unweighted,
          avgPositionVolumeWeighted: summary.avg_position_volume_weighted,
          keywordsWithVolume: summary.keywords_with_volume,
          aiFetchError: aiFetchError || null
        });
        
        RankingAiProgressModal.updateCounts(` Scan completed successfully!`);
        
        renderRankingAiTab();

        const lastRunEl = document.getElementById("ranking-ai-last-run");
        if (lastRunEl) {
          const now = new Date();
          // Format in GMT/UTC: "DD MMM YYYY, HH:MM:SS GMT"
          const day = String(now.getUTCDate()).padStart(2, '0');
          const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          const month = monthNames[now.getUTCMonth()];
          const year = now.getUTCFullYear();
          const hours = String(now.getUTCHours()).padStart(2, '0');
          const minutes = String(now.getUTCMinutes()).padStart(2, '0');
          const seconds = String(now.getUTCSeconds()).padStart(2, '0');
          const formatted = `${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
          lastRunEl.textContent = `Last run: ${formatted}`;
        }
        debugLog(` Ranking & AI data loaded: ${totalKeywords} keywords, ${withRank} with ranks, ${withAiOverview} with AI Overview`, 'success');
        
        // Don't hide modal - keep it visible with summary
      } catch (err) {
        console.error("Ranking & AI load error", err);
        const errorMsg = scanAborted ? 'Scan aborted by user' : err.message;
        debugLog(` Ranking & AI load error: ${errorMsg}`, 'error');
        
        // If aborted, show specific message
        if (scanAborted) {
          RankingAiProgressModal.updateCounts(' Scan aborted by user');
          RankingAiProgressModal.showSummary({
            error: true,
            errorMessage: 'Scan was aborted by user. No data was saved.',
            totalKeywords: keywords?.length || 0
          });
          return;
        }
        
        // Try to load any saved data from Supabase (SERP data may have been saved incrementally)
        debugLog(' Attempting to load saved data from Supabase after error...', 'info');
        try {
          const savedData = await loadRankingAiDataFromStorage(true); // Force Supabase check
          if (savedData && savedData.combinedRows && savedData.combinedRows.length > 0) {
            debugLog(` Loaded ${savedData.combinedRows.length} keywords from Supabase after error`, 'success');
            const normalizedSummary = normalizeSummaryFields(savedData.summary);
            mod.setData(savedData.combinedRows, normalizedSummary);
            mod.setLoadedOnce(true);
            renderRankingAiTab();
            RankingAiProgressModal.updateProgress(100, 5);
            RankingAiProgressModal.setActiveStep(5);
            RankingAiProgressModal.showSummary({
              error: true,
              errorMessage: `Scan encountered an error, but loaded ${savedData.combinedRows.length} saved keywords from database: ${err.message}`,
              totalKeywords: savedData.combinedRows.length,
              keywordsWithRank: savedData.summary?.keywords_with_rank || 0,
              top10: savedData.summary?.top10 || 0,
              top3: savedData.summary?.top3 || 0,
              keywordsWithAiOverview: savedData.summary?.keywords_with_ai_overview || 0,
              keywordsWithAiCitations: savedData.summary?.keywords_with_ai_citations || 0
            });
            RankingAiProgressModal.updateCounts(` Error occurred, but loaded saved data from database`);
            return; // Exit early since we loaded saved data
          }
        } catch (loadErr) {
          debugLog(` Failed to load saved data: ${loadErr.message}`, 'error');
        }
        
        const lastRunEl = document.getElementById("ranking-ai-last-run");
        if (lastRunEl) {
          lastRunEl.textContent = "Error loading ranking & AI data. See console for details.";
        }
        
        // Show error summary in modal instead of hiding
        RankingAiProgressModal.updateProgress(100, 5);
        RankingAiProgressModal.setActiveStep(5);
        RankingAiProgressModal.showSummary({
          error: true,
          errorMessage: err.message,
          totalKeywords: keywords?.length || 0,
          keywordsWithRank: allSerpResults?.filter(r => r.best_rank_group != null).length || 0
        });
        RankingAiProgressModal.updateCounts(` Error: ${err.message}`);
      } finally {
        RankingAiModule.setLoading(false);
        const refreshBtn = document.getElementById("ranking-ai-refresh");
        if (refreshBtn) {
          refreshBtn.disabled = false;
          refreshBtn.textContent = "Run ranking & AI check";
        }
        
        // Enable close button
        const closeBtn = document.getElementById('rankingAiProgressClose');
        if (closeBtn) {
          closeBtn.disabled = false;
          closeBtn.style.opacity = '1';
          closeBtn.onclick = () => RankingAiProgressModal.hide();
        }
      }
    }
    
    // Make loadRankingAiData globally available
    window.loadRankingAiData = loadRankingAiData;

    // ======================
    // Ranking & AI: Rendering functions
    // ======================
    // Filter and sort state
    let rankingFilterState = {
      segment: 'all',
      rank: 'all',
      volume: 'all',
      ctr: 'all',
      opportunity: 'all',
      aiOverview: 'all',
      aiCitation: 'all',
      pageType: 'all',
      serpFeatures: 'all',
      optimisationStatus: 'all',
      keyword: '',
      minOpportunity: null // number | null
    };
    let rankingSortState = {
      column: 'opportunityScore', // Default sort by opportunity score (descending)
      direction: 'desc'
    };
    let rankingPaginationState = {
      currentPage: 1,
      rowsPerPage: 10  // Default to 10 rows so all show without scrolling
    };
    let rankingPriorityFilter = null; // { impact: 'high'|'medium'|'low', difficulty: 'high'|'medium'|'low' } | null
    let selectedKeywordId = null; // Store selected keyword identifier (keyword + url combination)
    let activePreset = null; // Track which preset is currently active ('all', 'high-impact-money', etc.)

    // Impact and Difficulty bucket thresholds (constants for tuning)
    const IMPACT_THRESHOLDS = {
      HIGH: 0.20,   // >= 20% of tracked demand
      MEDIUM: 0.10  // 10-19.99% of tracked demand
    };
    const DIFFICULTY_THRESHOLDS = {
      LOW: { min: 4, max: 15 },      // Easy win: rank 4-15
      MEDIUM: { min: 16, max: 30 }   // Medium: rank 16-30
    };

    /**
     * Calculate impact bucket for a keyword based on demand_share
     * @param {number} demandShare - Fraction (0-1) of total demand
     * @returns {'high'|'medium'|'low'}
     */
    /**
     * Compute Keyword Opportunity Score (0-100) with component breakdown
     * @param {Object} row - Keyword row with demand_share, best_rank_group, has_ai_overview, etc.
     * @param {number} maxDemandShare - Maximum demand_share across all keywords (0-1)
     * @returns {Object} { score: 0-100, demandComponent: 0-1, rankComponent: 0-1, aiComponent: 0-1 }
     */
    function computeKeywordOpportunityScore(row, maxDemandShare) {
      // 2.1 Demand component D (0-1)
      const demandShare = (row.demand_share ?? 0) * 100; // Convert to 0-100 if stored as 0-1
      const maxShare = (maxDemandShare ?? 0) * 100; // Convert to 0-100 if stored as 0-1
      
      let D = 0;
      if (maxShare > 0) {
        D = demandShare / maxShare; // relative to biggest keyword
      }
      D = Math.min(Math.max(D, 0), 1);

      // 2.2 Rank component R (0-1)
      const rank = row.best_rank_group ?? row.best_rank_absolute ?? null;
      let R;
      
      if (rank == null) {
        R = 0.2;          // effectively not ranked
      } else if (rank <= 3) {
        R = 0.2;          // already very strong; little upside
      } else if (rank <= 10) {
        R = 1.0;          // page 1 but not top 3: sweet spot
      } else if (rank <= 20) {
        R = 0.8;          // page 2
      } else if (rank <= 50) {
        R = 0.5;          // visible but weaker
      } else {
        R = 0.2;          // very weak
      }

      // 2.3 AI leverage component A (0-1)
      const hasAi = row.has_ai_overview === true;
      const total = row.ai_total_citations ?? row.ai_citations_total ?? 0;
      const ours = row.ai_alan_citations_count ?? row.ai_citations_from_alan ?? 0;
      
      let A;
      
      if (!hasAi) {
        A = 0.5; // neutral: AI not helping or hurting yet
      } else if (!total) {
        A = 0.5; // overview present, but no citation info
      } else {
        const share = ours / total; // 0-1
        
        if (share < 0.33) {
          A = 1.0; // overview exists, you're under-represented
        } else if (share <= 0.66) {
          A = 0.7; // present but not owning it
        } else {
          A = 0.4; // you already dominate AI answers
        }
      }

      // 2.4 Combined score S (0-100)
      const opportunity0to1 =
        0.5 * D +   // demand is main driver
        0.3 * R +   // room to move in classic rank
        0.2 * A;    // AI leverage

      const keywordOpportunityScore = Math.round(opportunity0to1 * 100);

      return {
        score: keywordOpportunityScore,
        demandComponent: D,
        rankComponent: R,
        aiComponent: A
      };
    }

    function calculateImpactBucket(demandShare) {
      if (demandShare >= IMPACT_THRESHOLDS.HIGH) return 'high';
      if (demandShare >= IMPACT_THRESHOLDS.MEDIUM) return 'medium';
      return 'low';
    }

    /**
     * Calculate difficulty bucket for a keyword based on best_rank_group
     * @param {number|null} bestRankGroup - Best rank group (position)
     * @returns {'low'|'medium'|'high'}
     */
    function calculateDifficultyBucket(bestRankGroup) {
      // If already ranking in top 3, treat as low difficulty (already winning)
      if (bestRankGroup != null && bestRankGroup >= 1 && bestRankGroup <= 3) {
        return 'low';
      }
      
      // Low difficulty: rank 4-15 (easy win)
      if (bestRankGroup != null && 
          bestRankGroup >= DIFFICULTY_THRESHOLDS.LOW.min && 
          bestRankGroup <= DIFFICULTY_THRESHOLDS.LOW.max) {
        return 'low';
      }
      
      // Medium difficulty: rank 16-30
      if (bestRankGroup != null && 
          bestRankGroup >= DIFFICULTY_THRESHOLDS.MEDIUM.min && 
          bestRankGroup <= DIFFICULTY_THRESHOLDS.MEDIUM.max) {
        return 'medium';
      }
      
      // High difficulty: rank > 30 or null (no rank)
      return 'high';
    }

    /**
     * Build comprehensive scorecard data for a keyword row
     * @param {Object} row - Keyword row from combinedRows
     * @returns {Object} Enriched scorecard data
     */
    function buildKeywordScorecardData(row) {
      if (!row) return null;

      // Demand level from search_volume
      const searchVolume = row.search_volume;
      let demandLevel = 'Low';
      if (searchVolume != null && searchVolume >= 500) {
        demandLevel = 'High';
      } else if (searchVolume != null && searchVolume >= 200) {
        demandLevel = 'Medium';
      }

      // Rank bucket
      const rank = row.best_rank_group;
      let rankBucket = 'page2plus';
      let rankBucketLabel = 'beyond page 2';
      let positionStrength = 'Weak';
      if (rank != null) {
        if (rank >= 1 && rank <= 3) {
          rankBucket = 'top3';
          rankBucketLabel = 'page 1';
          positionStrength = 'Strong';
        } else if (rank >= 4 && rank <= 10) {
          rankBucket = 'top10';
          rankBucketLabel = 'page 1';
          positionStrength = 'OK';
        } else if (rank > 10) {
          rankBucket = 'page2plus';
          rankBucketLabel = 'beyond page 2';
          positionStrength = 'Weak';
        }
      }

      // AI status bucket
      const hasAiOverview = row.has_ai_overview || false;
      const aiCitationsOurs = row.ai_alan_citations_count || 0;
      const aiCitationsTotal = row.ai_total_citations || 0;
      let aiStatus = 'no_ai';
      let aiStatusLabel = 'No AI Overview';
      if (hasAiOverview) {
        if (aiCitationsOurs === 0) {
          aiStatus = 'ai_no_citation';
          aiStatusLabel = 'AI Overview present, not cited';
        } else {
          const ourShare = aiCitationsTotal > 0 ? (aiCitationsOurs / aiCitationsTotal) : 0;
          if (ourShare >= 0.25) {
            aiStatus = 'ai_cited_strong';
            aiStatusLabel = `AI Overview present, cited in ${aiCitationsOurs}/${aiCitationsTotal} citations (strong)`;
          } else {
            aiStatus = 'ai_cited_light';
            aiStatusLabel = `AI Overview present, cited in ${aiCitationsOurs}/${aiCitationsTotal} citations (light)`;
          }
        }
      }

      // Impact, Difficulty, and Priority from opportunity score components
      // Use opportunity score components if available, otherwise fall back to old logic
      let impact, difficulty, priorityLevel;
      
      if (row.opportunityScore != null && row.oppDemandComponent != null && row.oppRankComponent != null && row.oppAiComponent != null) {
        // Use opportunity score components (new logic)
        // Impact raw: 0.7 * D + 0.3 * A
        const impactRaw = 0.7 * row.oppDemandComponent + 0.3 * row.oppAiComponent;
        if (impactRaw >= 0.66) impact = 'high';
        else if (impactRaw >= 0.33) impact = 'medium';
        else impact = 'low';
        
        // Difficulty raw: 1 - R (harder if there is less room to move)
        const difficultyRaw = 1 - row.oppRankComponent;
        if (difficultyRaw <= 0.33) difficulty = 'low';
        else if (difficultyRaw <= 0.66) difficulty = 'medium';
        else difficulty = 'high';
        
        // Priority from numeric opportunity score
        if (row.opportunityScore >= 70) priorityLevel = 'High';
        else if (row.opportunityScore >= 40) priorityLevel = 'Medium';
        else priorityLevel = 'Low';
      } else {
        // Fallback to old logic if opportunity score not available
        impact = calculateImpactBucket(row.demand_share || 0);
        difficulty = calculateDifficultyBucket(rank);
        
        // Priority level from Impact + Difficulty
        priorityLevel = 'Low';
        if (impact === 'high' && (difficulty === 'low' || difficulty === 'medium')) {
          priorityLevel = 'High';
        } else if (impact === 'high' && difficulty === 'high' || 
                   impact === 'medium' && (difficulty === 'low' || difficulty === 'medium')) {
          priorityLevel = 'Medium';
        }
      }

      return {
        // Raw data
        keyword: row.keyword,
        segment: row.segment,
        best_rank_group: rank,
        search_volume: searchVolume,
        demand_share: row.demand_share || 0,
        has_ai_overview: hasAiOverview,
        ai_citations_total: aiCitationsTotal,
        ai_citations_ours: aiCitationsOurs,
        ai_alan_citations: row.ai_alan_citations || [], // Store citations for display
        serp_features: row.serp_features || {},
        // SERP feature boolean fields
        ai_overview_present_any: row.ai_overview_present_any === true || row.has_ai_overview === true,
        local_pack_present_any: row.local_pack_present_any === true || (row.serp_features && row.serp_features.local_pack === true),
        paa_present_any: row.paa_present_any === true || (row.serp_features && row.serp_features.people_also_ask === true),
        featured_snippet_present_any: row.featured_snippet_present_any === true || (row.serp_features && row.serp_features.featured_snippet === true),
        // Canonicalize URL - store both raw and canonical
        rawTargetUrl: row.rawTargetUrl || row.best_url || '',
        targetUrl: row.targetUrl || (row.best_url ? canonicalizeUrl(row.best_url) : ''),
        ranking_url: row.targetUrl || (row.best_url ? canonicalizeUrl(row.best_url) : ''), // Use canonical for ranking_url
        page_type: row.pageType || 'Landing',
        
        // Derived fields
        demand_level: demandLevel,
        rank_bucket: rankBucket,
        rank_bucket_label: rankBucketLabel,
        position_strength: positionStrength,
        ai_status: aiStatus,
        ai_status_label: aiStatusLabel,
        impact_bucket: impact,
        difficulty_bucket: difficulty,
        priority_level: priorityLevel,
        // Opportunity score fields
        opportunity_score: row.opportunityScore ?? null,
        opp_demand_component: row.oppDemandComponent ?? null,
        opp_rank_component: row.oppRankComponent ?? null,
        opp_ai_component: row.oppAiComponent ?? null
      };
    }

    /**
     * Generate summary sentence for keyword based on demand, rank, and AI status
     * @param {Object} scorecardData - Data from buildKeywordScorecardData
     * @returns {string} Summary sentence
     */
    function generateKeywordSummary(scorecardData) {
      const { demand_level, best_rank_group, has_ai_overview, ai_citations_ours, segment } = scorecardData;
      const parts = [];
      
      // Build summary sentence based on demand, rank, and AI status
      // Format: "[Demand level]-demand [segment] keyword currently ranking #[rank] and [AI status]. [Win assessment]."
      
      // Demand level prefix
      const demandPrefix = demand_level === 'High' ? 'High-demand' : 
                          demand_level === 'Medium' ? 'Medium-demand' : 
                          'Low-demand';
      
      // Segment context
      const segmentContext = segment && segment.toLowerCase() === 'education' ? 'education ' :
                            segment && segment.toLowerCase() === 'money' ? 'commercial ' : '';
      
      // Rank description
      if (best_rank_group != null && best_rank_group <= 10) {
        parts.push(`${demandPrefix} ${segmentContext}keyword currently ranking #${best_rank_group}`);
        
        // AI Overview status
        if (has_ai_overview && ai_citations_ours > 0) {
          parts.push('and cited in AI Overviews.');
        } else if (has_ai_overview) {
          parts.push('with AI Overview present but not cited.');
        } else {
          parts.push('but not yet cited in AI Overviews.');
        }
        
        // Win assessment for page 1 keywords
        if (demand_level === 'High' && has_ai_overview && ai_citations_ours > 0) {
          parts.push('Good win if you can improve CTR and schema.');
        } else if (demand_level === 'High') {
          parts.push('Good win potential if you can improve CTR, schema, and AI citations.');
        }
      } else {
        // Page 2+ keywords
        if (demand_level === 'High') {
          parts.push(`${demandPrefix} ${segmentContext}keyword currently on page 2+; big upside if you move into page 1.`);
        } else {
          parts.push(`${demandPrefix} ${segmentContext}keyword currently on page 2+; opportunity to improve ranking.`);
        }
        
        // Add AI status for page 2+ if present
        if (has_ai_overview && ai_citations_ours > 0) {
          parts.push('Cited in AI Overviews.');
        }
      }
      
      return parts.join(' ');
    }

    /**
     * Generate action bullets based on scorecard data (always returns 3 bullets)
     * @param {Object} scorecardData - Data from buildKeywordScorecardData
     * @returns {Array<string>} Array of exactly 3 action bullet strings
     */
    function generateActionBullets(scorecardData) {
      const { demand_level, rank_bucket, ai_status, segment, page_type, position_strength } = scorecardData;
      const standardActions = [];
      
      // Bullet 1: Classic ranking & CTR
      if (demand_level === 'High' && rank_bucket !== 'top3') {
        standardActions.push('Improve title and meta description for this page to win more clicks for this high-demand term.');
      } else if (position_strength === 'Weak') {
        standardActions.push('Improve title and meta description to improve CTR and push this page into top 10.');
      } else {
        standardActions.push('Continue optimizing title and meta description to maintain strong CTR for this keyword.');
      }
      
      // Bullet 2: AI usage / authority
      if (ai_status === 'ai_no_citation') {
        standardActions.push('Strengthen on-page answer content and schema so AI can confidently cite this page in AI Overviews.');
      } else if (ai_status === 'ai_cited_strong' || ai_status === 'ai_cited_light') {
        if (rank_bucket === 'page1' || rank_bucket === 'page2plus') {
          standardActions.push('You\'re already cited in AI Overviews  improve classic ranking (links and snippet) to capture more traffic.');
        } else {
          standardActions.push('You\'re already cited in AI Overviews  maintain strong ranking and authority signals.');
        }
      } else {
        standardActions.push('No AI Overview yet  improve content depth and schema to increase chances of AI citation.');
      }
      
      // Bullet 3: Commercialisation / internal links
      if (segment && segment.toLowerCase() === 'education' && page_type === 'Landing') {
        standardActions.push('Consider adding stronger calls-to-action and internal links from money pages to capture more commercial value from this educational query.');
      } else if (segment && segment.toLowerCase() === 'money') {
        standardActions.push('Strengthen internal links from high-authority pages and optimize conversion elements on this money page.');
      } else {
        standardActions.push('Consider internal linking strategy to boost authority and capture related commercial queries.');
      }
      
      return standardActions;
    }

    /**
     * Normalize page URL for GSC matching - strips query params, fragments, ensures canonical format
     * @param {string} url - URL to normalize
     * @returns {string} Normalized URL path
     */
    function normalizeGscPageUrl(url) {
      if (!url || typeof url !== 'string') return '';
      
      let cleanUrl = url.trim();
      
      // Strip query parameters (srsltid, utm_*, gclid, fbclid, etc.) and fragments
      cleanUrl = cleanUrl.split('?')[0].split('#')[0];
      
      try {
        // Handle relative URLs by adding base URL
        let urlToParse = cleanUrl;
        if (!cleanUrl.startsWith('http://') && !cleanUrl.startsWith('https://')) {
          urlToParse = 'https://www.alanranger.com' + (cleanUrl.startsWith('/') ? cleanUrl : '/' + cleanUrl);
        }
        const urlObj = new URL(urlToParse);
        // Use pathname (automatically excludes query params and hash)
        let normalized = urlObj.pathname.toLowerCase().replace(/\/$/, '').trim();
        // If pathname is empty or just '/', treat as homepage
        if (!normalized || normalized === '/') {
          normalized = '/';
        }
        return normalized;
      } catch (e) {
        // If URL parsing fails, use manually cleaned URL
        return cleanUrl.toLowerCase().replace(/\/$/, '').trim() || '/';
      }
    }

    /**
     * Get GSC metrics for a keyword row - unified helper for table and scorecard
     * Returns atomic bundle with clicks, impressions, CTR (decimal), scope, and normalized page URL
     * @param {Object} params - Object with query (keyword) and pageUrl
     * @returns {Object} { clicks, impressions, ctrDecimal, scope, pageUsed } or null if no data
     *   - scope: 'query+page' | 'query-only' | 'page-only' | 'none'
     *   - ctrDecimal: 0-1 (decimal format, e.g., 0.0117 for 1.17%)
     *   - impressions: must be > 0 for CTR to be valid
     */
    function getGscMetricsForKeywordRow(params) {
      try {
        const { query, pageUrl } = params || {};
        if (!query) {
          return null;
        }

        // Get audit data from localStorage
        const savedAudit = loadAuditResultsSync();
        if (!savedAudit?.searchData?.queryPages) {
          return null;
        }

        const queryPages = savedAudit.searchData.queryPages || [];
        if (!Array.isArray(queryPages) || queryPages.length === 0) {
          return null;
        }

        // Normalize keyword for matching
        const normalizedKeyword = (query || '').toLowerCase().trim();
        if (!normalizedKeyword) {
          return null;
        }

        // Normalize page URL (strip query params, fragments, ensure canonical format)
        const normalizedPageUrl = pageUrl ? normalizeGscPageUrl(pageUrl) : null;

        // First try: exact match on keyword + URL (query+page scope)
        if (normalizedPageUrl) {
          const exactMatches = queryPages.filter(p => {
            const pKeyword = (p.query || '').toLowerCase().trim();
            const pPage = normalizeGscPageUrl(p.page || p.url || '');
            return pKeyword === normalizedKeyword && pPage === normalizedPageUrl;
          });

          if (exactMatches.length > 0) {
            // Aggregate all matches for this query+page combination
            let totalImpressions = 0;
            let totalClicks = 0;
            exactMatches.forEach(m => {
              totalImpressions += (m.impressions || 0);
              totalClicks += (m.clicks || 0);
            });

            // Only return data if impressions > 0 (CTR requires impressions)
            if (totalImpressions > 0) {
              // CTR from GSC is stored as percentage (0-100), convert to decimal
              const ctrDecimal = totalImpressions > 0 ? (totalClicks / totalImpressions) : 0;
              return {
                clicks: totalClicks,
                impressions: totalImpressions,
                ctrDecimal: ctrDecimal,
                scope: 'query+page',
                pageUsed: normalizedPageUrl
              };
            }
          }
        }

        // Second try: match by keyword only (query-only scope)
        const keywordMatches = queryPages.filter(p => {
          const pKeyword = (p.query || '').toLowerCase().trim();
          return pKeyword === normalizedKeyword;
        });

        if (keywordMatches.length > 0) {
          let totalImpressions = 0;
          let totalClicks = 0;
          keywordMatches.forEach(m => {
            totalImpressions += (m.impressions || 0);
            totalClicks += (m.clicks || 0);
          });

          if (totalImpressions > 0) {
            const ctrDecimal = totalClicks / totalImpressions;
            return {
              clicks: totalClicks,
              impressions: totalImpressions,
              ctrDecimal: ctrDecimal,
              scope: 'query-only',
              pageUsed: null
            };
          }
        }

        // Third try: match by URL only (page-only scope)
        if (normalizedPageUrl) {
          const urlMatches = queryPages.filter(p => {
            const pPage = normalizeGscPageUrl(p.page || p.url || '');
            return pPage === normalizedPageUrl;
          });

          if (urlMatches.length > 0) {
            let totalImpressions = 0;
            let totalClicks = 0;
            urlMatches.forEach(m => {
              totalImpressions += (m.impressions || 0);
              totalClicks += (m.clicks || 0);
            });

            if (totalImpressions > 0) {
              const ctrDecimal = totalClicks / totalImpressions;
              return {
                clicks: totalClicks,
                impressions: totalImpressions,
                ctrDecimal: ctrDecimal,
                scope: 'page-only',
                pageUsed: normalizedPageUrl
              };
            }
          }
        }

        // No data found
        return null;
      } catch (err) {
        console.error('Error getting GSC metrics for keyword row:', err);
        return null;
      }
    }

    /**
     * Get CTR metrics for a keyword from GSC audit data
     * @deprecated Use getGscMetricsForKeywordRow instead for consistent behavior
     * @param {Object} key - Object with keyword and url
     * @returns {Object|null} CTR metrics or null if not found
     */
    function getCtrMetricsForKeyword(key) {
      // Use unified helper for consistency
      const metrics = getGscMetricsForKeywordRow({
        query: key.keyword,
        pageUrl: key.url
      });

      if (!metrics) {
        return null;
      }

      // Return in legacy format for backward compatibility
      return {
        ctr: metrics.ctrDecimal,
        impressions: metrics.impressions,
        clicks: metrics.clicks
      };
    }

    /**
     * Get position bucket from rank
     * @param {number|null} rank - Ranking position
     * @returns {string} Position bucket: 'top3', '4-10', '11-20', or '20+'
     */
    function getPositionBucket(rank) {
      if (rank == null) return '20+';
      if (rank <= 3) return 'top3';
      if (rank <= 10) return '4-10';
      if (rank <= 20) return '11-20';
      return '20+';
    }

    /**
     * Get expected CTR benchmark for a position bucket
     * @param {string} positionBucket - Position bucket: 'top3', '4-10', '11-20', or '20+'
     * @returns {number} Expected CTR as decimal (e.g., 0.15 for 15%)
     */
    function getCtrBenchmarkForPosition(positionBucket) {
      // Industry benchmarks for CTR by position
      const benchmarks = {
        'top3': 0.15,    // ~15% CTR for positions 1-3
        '4-10': 0.05,   // ~5% CTR for positions 4-10
        '11-20': 0.02,  // ~2% CTR for positions 11-20
        '20+': 0.01     // ~1% CTR for positions 21+
      };
      return benchmarks[positionBucket] || 0.01;
    }

    /**
     * Normalize URL by stripping query parameters, hash, and trailing slashes
     * Returns just the pathname for matching
     */
    function normalizeUrlForMatching(url) {
      if (!url || typeof url !== 'string') return '';
      
      // Explicitly strip everything from ? onwards (query parameters) and # onwards (hash)
      // This ensures URLs with Google SERP params like ?srsltid=... are matched correctly
      let cleanUrl = url.split('?')[0].split('#')[0];
      
      let normalized = cleanUrl.toLowerCase().trim();
      try {
        // Handle relative URLs by adding a base URL
        let urlToParse = normalized;
        if (!normalized.startsWith('http://') && !normalized.startsWith('https://')) {
          urlToParse = 'https://www.alanranger.com' + (normalized.startsWith('/') ? normalized : '/' + normalized);
        }
        const urlObj = new URL(urlToParse);
        // pathname automatically excludes query params and hash, but we already stripped them above
        normalized = urlObj.pathname.toLowerCase().replace(/\/$/, '').trim();
        // If pathname is empty or just '/', treat as homepage
        if (!normalized || normalized === '/') {
          normalized = '/';
        }
      } catch (e) {
        // If URL parsing fails, use the manually cleaned URL
        normalized = cleanUrl.toLowerCase().replace(/\/$/, '').trim();
        // Ensure it starts with / if it's a path
        if (normalized && !normalized.startsWith('/')) {
          normalized = '/' + normalized;
        }
        if (!normalized || normalized === '/') {
          normalized = '/';
        }
      }
      return normalized;
    }

    async function getSchemaCoverageForUrl(url) {
      try {
        // Get audit data from localStorage using loadAuditResultsSync
        let savedAudit = loadAuditResultsSync();
        if (!savedAudit) {
          debugLog('[Schema Coverage] No saved audit found in localStorage', 'warn');
          return null;
        }
        if (!savedAudit.schemaAudit || !savedAudit.schemaAudit.data) {
          debugLog('[Schema Coverage] No schemaAudit.data in saved audit', 'warn');
          return null;
        }

        let schemaData = savedAudit.schemaAudit.data;
        // Check both pages and pagesWithSchema arrays
        let pagesArray = schemaData.pages || [];
        let pagesWithSchema = schemaData.pagesWithSchema || [];
        
        // Use pages array if available (more reliable), otherwise use pagesWithSchema
        let allPages = Array.isArray(pagesArray) && pagesArray.length > 0 ? pagesArray : 
                       (Array.isArray(pagesWithSchema) && pagesWithSchema.length > 0 ? pagesWithSchema : []);
        
        // Normalize the input URL first to use for matching
        const normalizedUrl = normalizeUrlForMatching(url);
        debugLog('[Schema Coverage] Looking for normalized URL: ' + normalizedUrl + ' (original: ' + url + ')', 'info');
        
        // Try to find the page in the current array
        let pageData = allPages.find(p => {
          if (!p || !p.url) return false;
          const pNormalized = normalizeUrlForMatching(p.url);
          const exactMatch = pNormalized === normalizedUrl;
          const homepageMatch = (normalizedUrl === '/' || normalizedUrl === '') && (pNormalized === '/' || pNormalized === '');
          return exactMatch || homepageMatch;
        });
        
        const domPropertyUrl = document.getElementById('propertyUrl')?.value;
        const effectivePropertyUrl =
          domPropertyUrl ||
          savedAudit.propertyUrl ||
          localStorage.getItem('gsc_property_url') ||
          '';

        // If not found and we have a truncated array (200 items), try fetching from Supabase
        // The API truncates to 200, but the full data exists in Supabase
        if (!pageData && allPages.length === 200) {
          debugLog('[Schema Coverage] Page not found in truncated array (200 items), fetching full data from Supabase...', 'info');
          const propertyUrl = effectivePropertyUrl;
          try {
            const supabaseData = await fetchLatestAuditFromSupabase(propertyUrl);
            if (supabaseData && supabaseData.schemaAudit && supabaseData.schemaAudit.data) {
              schemaData = supabaseData.schemaAudit.data;
              pagesArray = schemaData.pages || [];
              pagesWithSchema = schemaData.pagesWithSchema || [];
              const supabasePages = Array.isArray(pagesArray) && pagesArray.length > 0 ? pagesArray : 
                                   (Array.isArray(pagesWithSchema) && pagesWithSchema.length > 0 ? pagesWithSchema : []);
              debugLog('[Schema Coverage] Loaded schema data from Supabase (' + supabasePages.length + ' pages, may still be truncated)', 'info');
              
              // Search in the Supabase data (may still be truncated, but worth trying)
              if (supabasePages.length > 0) {
                pageData = supabasePages.find(p => {
                  if (!p || !p.url) return false;
                  const pNormalized = normalizeUrlForMatching(p.url);
                  const exactMatch = pNormalized === normalizedUrl;
                  const homepageMatch = (normalizedUrl === '/' || normalizedUrl === '') && (pNormalized === '/' || pNormalized === '');
                  return exactMatch || homepageMatch;
                });
                
                if (pageData) {
                  debugLog('[Schema Coverage]  Found page in Supabase data', 'success');
                  allPages = supabasePages;
                } else if (supabasePages.length === 200) {
                  debugLog('[Schema Coverage]  Supabase data also truncated to 200 items. Querying full data from API...', 'info');
                  // Try the dedicated API endpoint that searches the full JSONB field
                  try {
                    const propertyUrl = effectivePropertyUrl;
                    const urlHelper = window.apiUrl || ((path) => {
                      const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || !window.location.hostname;
                      const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
                      const cleanPath = path.startsWith('/') ? path : `/${path}`;
                      return `${baseUrl}${cleanPath}`;
                    });
                    const apiUrl = urlHelper(`/api/supabase/get-schema-for-url?propertyUrl=${encodeURIComponent(propertyUrl)}&searchUrl=${encodeURIComponent(url)}`);
                    const apiRes = await fetch(apiUrl);
                    if (apiRes.ok) {
                      const apiData = await apiRes.json();
                      if (apiData.status === 'ok' && apiData.data) {
                        pageData = apiData.data;
                        debugLog('[Schema Coverage]  Found page in full Supabase data via API', 'success');
                      } else {
                        debugLog('[Schema Coverage] API returned: ' + (apiData.message || 'no data'), 'warn');
                      }
                    } else {
                      debugLog('[Schema Coverage] API request failed: ' + apiRes.status, 'warn');
                    }
                  } catch (apiErr) {
                    debugLog('[Schema Coverage] API request error: ' + apiErr.message, 'warn');
                  }
                }
              }
            }
          } catch (e) {
            debugLog('[Schema Coverage] Failed to fetch from Supabase: ' + e.message, 'warn');
          }
        }
        
        // If still not found, check if pagesWithSchema is just a count (not an array)
        if (!pageData && allPages.length === 0 && typeof pagesWithSchema === 'number') {
          debugLog('[Schema Coverage] pagesWithSchema is a count in localStorage, trying Supabase...', 'warn');
          const propertyUrl = effectivePropertyUrl;
          try {
            const supabaseData = await fetchLatestAuditFromSupabase(propertyUrl);
            if (supabaseData && supabaseData.schemaAudit && supabaseData.schemaAudit.data) {
              schemaData = supabaseData.schemaAudit.data;
              pagesArray = schemaData.pages || [];
              pagesWithSchema = schemaData.pagesWithSchema || [];
              const supabasePages = Array.isArray(pagesArray) && pagesArray.length > 0 ? pagesArray : 
                                   (Array.isArray(pagesWithSchema) && pagesWithSchema.length > 0 ? pagesWithSchema : []);
              debugLog('[Schema Coverage] Loaded detailed schema data from Supabase (' + supabasePages.length + ' pages)', 'info');
              // Update localStorage with the correct structure
              savedAudit.schemaAudit.data = schemaData;
              safeSetLocalStorage('last_audit_results', savedAudit);
              if (supabasePages.length > 0) {
                allPages = supabasePages;
                // Try to find the page in the newly loaded data
                pageData = allPages.find(p => {
                  if (!p || !p.url) return false;
                  const pNormalized = normalizeUrlForMatching(p.url);
                  const exactMatch = pNormalized === normalizedUrl;
                  const homepageMatch = (normalizedUrl === '/' || normalizedUrl === '') && (pNormalized === '/' || pNormalized === '');
                  return exactMatch || homepageMatch;
                });

                // If still not found and we only have a truncated 200-page array, query full JSONB via API
                if (!pageData && allPages.length === 200) {
                  debugLog('[Schema Coverage] Still not found after Supabase load (200 items). Querying full data from API...', 'info');
                  try {
                    const urlHelper = window.apiUrl || ((path) => {
                      const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || !window.location.hostname;
                      const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
                      const cleanPath = path.startsWith('/') ? path : `/${path}`;
                      return `${baseUrl}${cleanPath}`;
                    });
                    const apiUrl = urlHelper(`/api/supabase/get-schema-for-url?propertyUrl=${encodeURIComponent(propertyUrl)}&searchUrl=${encodeURIComponent(url)}`);
                    const apiRes = await fetch(apiUrl);
                    if (apiRes.ok) {
                      const apiData = await apiRes.json();
                      if (apiData.status === 'ok' && apiData.data) {
                        pageData = apiData.data;
                        debugLog('[Schema Coverage]  Found page in full Supabase data via API', 'success');
                      } else {
                        debugLog('[Schema Coverage] API returned: ' + (apiData.message || 'no data'), 'warn');
                      }
                    } else {
                      debugLog('[Schema Coverage] API request failed: ' + apiRes.status, 'warn');
                    }
                  } catch (apiErr) {
                    debugLog('[Schema Coverage] API request error: ' + apiErr.message, 'warn');
                  }
                }
              }
            }
          } catch (e) {
            debugLog('[Schema Coverage] Failed to fetch from Supabase: ' + e.message, 'warn');
          }
        }
        
        if (!Array.isArray(allPages) || allPages.length === 0) {
          debugLog('[Schema Coverage] No pages array available (length: ' + (Array.isArray(allPages) ? allPages.length : 'not array') + ')', 'warn');
          debugLog('[Schema Coverage] This usually means the schema audit hasn\'t been run yet, or the data is missing from localStorage/Supabase.', 'info');
          return null;
        }

        // If pageData wasn't found yet, search in allPages
        if (!pageData) {
          pageData = allPages.find(p => {
            if (!p || !p.url) return false;
            const pNormalized = normalizeUrlForMatching(p.url);
            
            // Exact match after normalization (both URLs stripped of query params, hash, trailing slashes)
            const exactMatch = pNormalized === normalizedUrl;
            
            // For homepage, also check if both are '/' or empty
            const homepageMatch = (normalizedUrl === '/' || normalizedUrl === '') && (pNormalized === '/' || pNormalized === '');
            
            if (exactMatch || homepageMatch) {
              debugLog('[Schema Coverage]  Exact URL match: ' + p.url + ' -> ' + pNormalized + ' (search: ' + normalizedUrl + ')', 'info');
              return true;
            }
            return false;
          });
        }

        if (!pageData) {
          // Enhanced debugging: show sample URLs and search for similar URLs
          debugLog('[Schema Coverage]  No page data found for URL: ' + url, 'warn');
          debugLog('[Schema Coverage] Normalized search URL: ' + normalizedUrl, 'warn');
          debugLog('[Schema Coverage] Total pages in array: ' + allPages.length, 'warn');
          if (allPages.length > 0) {
            debugLog('[Schema Coverage] Sample URLs in pages array (first 10):', 'warn');
            allPages.slice(0, 10).forEach((p, idx) => {
              const pNorm = normalizeUrlForMatching(p.url);
              debugLog(`  ${idx + 1}. ${p.url} -> ${pNorm}`, 'warn');
            });
            // Try to find similar URLs (contains photography-courses or courses-coventry)
            const similarUrls = allPages.filter(p => {
              const pNorm = normalizeUrlForMatching(p.url);
              return pNorm.includes('photography-courses') || 
                     pNorm.includes('courses-coventry') ||
                     normalizedUrl.includes(pNorm.split('/').pop() || '') ||
                     (pNorm.split('/').pop() || '').includes(normalizedUrl.split('/').pop() || '');
            });
            if (similarUrls.length > 0) {
              debugLog('[Schema Coverage] Found similar URLs that might match:', 'warn');
              similarUrls.forEach((p, idx) => {
                const pNorm = normalizeUrlForMatching(p.url);
                debugLog(`  ${idx + 1}. ${p.url} -> ${pNorm}`, 'warn');
              });
            }
          }
          return null;
        }
        
        if (!pageData.schemaTypes) {
          debugLog('[Schema Coverage]  Page found but no schemaTypes: ' + pageData.url, 'warn');
          return null;
        }

        // Extract schema types from array
        const schemaTypes = Array.isArray(pageData.schemaTypes) ? pageData.schemaTypes : [];
        
        // Check for specific schema types (case-insensitive)
        const typeStrings = schemaTypes.map(t => {
          if (typeof t === 'string') return t.toLowerCase();
          if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type.toLowerCase();
          return String(t).toLowerCase();
        }).filter(t => t && t !== '[object object]');
        
        return {
          hasFAQ: typeStrings.some(t => t.includes('faq') || t === 'faqpage'),
          hasHowTo: typeStrings.some(t => t.includes('howto') || t === 'howto'),
          hasEvent: typeStrings.some(t => t.includes('event') && !t.includes('product')),
          hasProduct: typeStrings.some(t => t.includes('product')),
          hasBreadcrumb: typeStrings.some(t => t.includes('breadcrumb') || t === 'breadcrumblist'),
          hasImageObject: typeStrings.some(t => t.includes('image') || t === 'imageobject'),
          schemaTypes: schemaTypes,
          url: pageData.url
        };
      } catch (err) {
        console.error('Error getting schema coverage:', err);
        return null;
      }
    }

    /**
     * Render Keyword Priority Matrix (3x3 grid: Impact  Difficulty)
     * @param {Array} filteredRows - Filtered keyword rows
     * @param {HTMLElement} container - Container element
     * @param {Function} onCellClick - Callback(filter)
     */
    function renderKeywordPriorityMatrix(filteredRows, container, onCellClick) {
      if (!filteredRows || !filteredRows.length) {
        container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #64748b;">No keyword data available.</div>';
        return;
      }

      // Calculate impact and difficulty for each row
      const rowsWithBuckets = filteredRows.map(row => ({
        ...row,
        impact: calculateImpactBucket(row.demand_share || 0),
        difficulty: calculateDifficultyBucket(row.best_rank_group)
      }));

      // Calculate total demand share for percentages
      const totalDemandShare = filteredRows.reduce((sum, r) => {
        const share = r.demand_share || 0;
        return sum + share;
      }, 0) || 0.0001; // Avoid division by zero
      
      // Calculate total search volume for debug logging
      const totalSearchVolume = filteredRows.reduce((sum, r) => {
        const vol = r.search_volume || 0;
        return sum + (vol > 0 ? vol : 0);
      }, 0);

      const impacts = ['high', 'medium', 'low'];
      const difficulties = ['low', 'medium', 'high'];

      let html = `
        <div class="matrix-header" style="margin-bottom: 1rem;">
          <div class="axis-label impact" style="text-align: center; font-weight: 600; font-size: 1.1rem; margin-bottom: 0.5rem; color: #1e293b;">Impact </div>
          <div class="matrix-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem;">
      `;

      for (const impact of impacts) {
        for (const difficulty of difficulties) {
          const cellRows = rowsWithBuckets.filter(
            r => r.impact === impact && r.difficulty === difficulty
          );
          const count = cellRows.length;
          // Sum demand_share (0-1) for keywords in this cell
          const demandShareSum = cellRows.reduce((sum, r) => {
            const share = r.demand_share || 0;
            return sum + share;
          }, 0);
          // Convert to percentage
          const demandSharePct = totalDemandShare > 0 ? (demandShareSum / totalDemandShare) * 100 : 0;
          
          // Calculate average opportunity score for this cell
          const totalOpportunityScore = cellRows.reduce((sum, r) => {
            const score = r.opportunityScore ?? 0;
            return sum + score;
          }, 0);
          const avgOpportunityScore = count > 0 ? totalOpportunityScore / count : 0;

          // Background intensity based on avgOpportunityScore
          let backgroundColor;
          if (avgOpportunityScore >= 70) {
            backgroundColor = '#dcfce7'; // Strong green highlight (High)
          } else if (avgOpportunityScore >= 40) {
            backgroundColor = '#fef3c7'; // Medium amber highlight (Medium)
          } else {
            backgroundColor = '#f9fafb'; // Light/neutral background (Low)
          }
          
          // RAG styling: High impact + Low/Medium difficulty = high priority (green)
          const ragClass =
            impact === 'high' && (difficulty === 'low' || difficulty === 'medium') ? 'rag-high' :
            impact === 'high' && difficulty === 'high' ? 'rag-medium' :
            'rag-low';
          
          // Check if this cell is active
          const isActive = rankingPriorityFilter && 
            rankingPriorityFilter.impact === impact && 
            rankingPriorityFilter.difficulty === difficulty;
          
          // Active state styling
          const borderColor = isActive 
            ? '#2563eb' 
            : (ragClass === 'rag-high' ? '#10b981' : ragClass === 'rag-medium' ? '#f59e0b' : '#e5e7eb');
          const borderWidth = isActive ? '4px' : '2px';
          
          // Override background color if active
          if (isActive) {
            backgroundColor = '#dbeafe';
          }

          html += `
            <button
              class="matrix-cell ${ragClass} ${isActive ? 'active' : ''}"
              data-impact="${impact}"
              data-difficulty="${difficulty}"
              type="button"
              style="padding: 1.25rem; border: ${borderWidth} solid ${borderColor}; border-radius: 8px; background: ${backgroundColor}; cursor: pointer; text-align: center; transition: all 0.2s; box-shadow: ${isActive ? '0 4px 8px rgba(37, 99, 235, 0.3)' : 'none'};"
              onmouseover="this.style.transform='scale(1.05)'"
              onmouseout="this.style.transform='scale(1)'"
              title="${impact.toUpperCase()} / ${difficulty.toUpperCase()}"
            >
              <div class="cell-title" style="font-weight: 600; font-size: 0.9rem; margin-bottom: 0.5rem; color: #64748b; text-transform: uppercase;">${impact.toUpperCase()} / ${difficulty.toUpperCase()}</div>
              <div class="cell-count" style="font-size: 1.5rem; font-weight: 700; color: #1e293b; margin-bottom: 0.25rem;">${count}</div>
              <div class="cell-share" style="font-size: 0.9rem; color: #64748b; font-weight: 500;">${demandSharePct.toFixed(1)}% of demand</div>
            </button>
          `;
        }
      }

      html += `
          </div>
          <div class="axis-label difficulty" style="text-align: center; font-weight: 600; font-size: 1.1rem; margin-top: 0.5rem; color: #1e293b;">Difficulty </div>
        </div>
      `;

      container.innerHTML = html;

      // Wire up click handlers
      container.querySelectorAll('.matrix-cell').forEach(btn => {
        btn.addEventListener('click', () => {
          const impact = btn.getAttribute('data-impact');
          const difficulty = btn.getAttribute('data-difficulty');
          
          // Toggle: if clicking the same cell, clear filter; otherwise set it
          if (rankingPriorityFilter && 
              rankingPriorityFilter.impact === impact && 
              rankingPriorityFilter.difficulty === difficulty) {
            rankingPriorityFilter = null;
            selectedKeywordId = null; // Clear selection when clearing filter
          } else {
            rankingPriorityFilter = { impact, difficulty };
          }
          
          debugLog(`[RankingAI Scorecard] Priority grid cell clicked - impact: ${impact}, difficulty: ${difficulty}`, 'info');
          
          if (onCellClick) onCellClick(rankingPriorityFilter);
          
          // After filter is applied, check if exactly one row matches and auto-select it
          setTimeout(async () => {
            const { combinedRows } = RankingAiModule.state();
            const filteredAfterClick = applyRankingFilters(combinedRows);
            if (filteredAfterClick.length === 1) {
              const singleRow = filteredAfterClick[0];
              selectedKeywordId = `${singleRow.keyword}|${singleRow.best_url || ''}`;
              debugLog(`[RankingAI Scorecard] Auto-selecting single matching keyword: "${singleRow.keyword}"`, 'info');
              await renderKeywordScorecard(singleRow);
              // Also update table row selection
              const tbody = document.getElementById("ranking-ai-table-body");
              if (tbody) {
                tbody.querySelectorAll("tr").forEach(tr => {
                  tr.classList.remove("ranking-table-row--selected");
                  const idx = Number(tr.dataset.index || "-1");
                  if (!Number.isNaN(idx) && combinedRows[idx] === singleRow) {
                    tr.classList.add("ranking-table-row--selected");
                  }
                });
              }
            } else {
              selectedKeywordId = null; // Clear selection if multiple or no rows
            }
          }, 100); // Small delay to ensure renderRankingAiTab has completed
        });
      });

      // Debug logging
      debugLog(`[Keyword Priority Matrix] Rendered matrix with ${filteredRows.length} filtered rows`, 'info');
      rowsWithBuckets.forEach(row => {
        debugLog(`[Keyword Priority Matrix] "${row.keyword}": impact=${row.impact}, difficulty=${row.difficulty}, demand_share=${((row.demand_share || 0) * 100).toFixed(1)}%, rank=${row.best_rank_group ?? 'null'}`, 'info');
      });
      
      // Log cell totals
      for (const impact of impacts) {
        for (const difficulty of difficulties) {
          const cellRows = rowsWithBuckets.filter(r => r.impact === impact && r.difficulty === difficulty);
          const demandShareSum = cellRows.reduce((sum, r) => sum + ((r.search_volume && r.search_volume > 0 ? r.search_volume : 0)), 0);
          const demandSharePct = totalSearchVolume > 0 ? (demandShareSum / totalSearchVolume) * 100 : 0;
          debugLog(`[Keyword Priority Matrix] Cell ${impact}/${difficulty}: count=${cellRows.length}, demand_share=${demandSharePct.toFixed(1)}%`, 'info');
        }
      }
    }

    // Rank normalization helper
    function normalizeRank(rank) {
      const r = Number(rank);
      if (!Number.isFinite(r) || r <= 0) return null; // treat missing/unranked
      return r;
    }

    // Apply filters to rows
    function applyRankingFilters(rows, excludeFilter = null) {
      return rows.filter(row => {
        // Segment filter (normalize to lowercase for comparison)
        if (excludeFilter !== 'segment' && rankingFilterState.segment !== 'all') {
          const rowSegment = (row.segment || '').toLowerCase();
          const filterSegment = rankingFilterState.segment.toLowerCase();
          if (rowSegment !== filterSegment) {
            return false;
          }
        }

        // Rank bucket filter
        if (excludeFilter !== 'rank' && rankingFilterState.rank !== 'all') {
          const rank = normalizeRank(row.best_rank_group);
          if (rankingFilterState.rank === 'top3' && (rank === null || rank > 3)) return false;
          if (rankingFilterState.rank === '4-10' && (rank === null || rank < 4 || rank > 10)) return false;
          if (rankingFilterState.rank === '11-20' && (rank === null || rank < 11 || rank > 20)) return false;
          if (rankingFilterState.rank === '21+' && rank !== null && rank <= 20) return false;
          if (rankingFilterState.rank === 'not-top3' && rank !== null && rank <= 3) return false;
        }
        
        // Preset-specific rank predicates (when rank filter is 'all' but preset requires specific range)
        // Note: Most presets now use explicit rank filter values (e.g., 'not-top3'), so this is rarely needed
        // Keeping for backward compatibility if any presets still use 'all' with predicates
        if (excludeFilter !== 'rank' && rankingFilterState.rank === 'all' && activePreset) {
          const rank = normalizeRank(row.best_rank_group);
          // No preset-specific predicates needed - all presets now use explicit rank filter values
        }

        // Search volume filter
        if (excludeFilter !== 'volume' && rankingFilterState.volume !== 'all') {
          const volume = row.search_volume;
          if (rankingFilterState.volume === 'high' && (volume == null || volume < 200)) return false;
          if (rankingFilterState.volume === 'medium' && (volume == null || volume < 50 || volume >= 200)) return false;
          if (rankingFilterState.volume === 'low' && (volume == null || volume < 1 || volume >= 50)) return false;
          if (rankingFilterState.volume === 'none' && volume != null && volume > 0) return false;
          
        }

        // CTR filter
        if (excludeFilter !== 'ctr' && rankingFilterState.ctr !== 'all') {
          // Use canonical targetUrl for CTR metrics
          const urlForCtr = row.targetUrl || row.ranking_url || '';
          const ctrMetrics = getCtrMetricsForKeyword({ keyword: row.keyword, url: urlForCtr });
          const ctr = ctrMetrics && ctrMetrics.ctr != null ? (ctrMetrics.ctr * 100) : null;
          if (rankingFilterState.ctr === 'high' && (ctr == null || ctr < 5)) return false;
          if (rankingFilterState.ctr === 'medium' && (ctr == null || ctr < 2 || ctr >= 5)) return false;
          if (rankingFilterState.ctr === 'low' && (ctr == null || ctr >= 2)) return false;
          if (rankingFilterState.ctr === 'none' && ctr != null) return false;
        }

        // Demand share filter removed - replaced with Impressions (30d) column

        // Page type filter
        if (excludeFilter !== 'pageType' && rankingFilterState.pageType && rankingFilterState.pageType !== 'all') {
          const rowPageType = row.pageType || 'Landing';
          if (rowPageType !== rankingFilterState.pageType) {
            return false;
          }
        }

        // SERP features filter
        if (excludeFilter !== 'serpFeatures' && rankingFilterState.serpFeatures !== 'all') {
          const hasAiOverview = row.ai_overview_present_any === true;
          const hasLocalPack = row.local_pack_present_any === true;
          const hasPaa = row.paa_present_any === true;
          const hasFeaturedSnippet = row.featured_snippet_present_any === true;
          if (rankingFilterState.serpFeatures === 'ai-overview' && !hasAiOverview) return false;
          if (rankingFilterState.serpFeatures === 'local-pack' && !hasLocalPack) return false;
          if (rankingFilterState.serpFeatures === 'paa' && !hasPaa) return false;
          if (rankingFilterState.serpFeatures === 'featured-snippet' && !hasFeaturedSnippet) return false;
          if (rankingFilterState.serpFeatures === 'none' && (hasAiOverview || hasLocalPack || hasPaa || hasFeaturedSnippet)) return false;
        }

        // AI Overview filter
        if (excludeFilter !== 'aiOverview' && rankingFilterState.aiOverview !== 'all') {
          if (rankingFilterState.aiOverview === 'has' && !row.has_ai_overview) return false;
          if (rankingFilterState.aiOverview === 'no' && row.has_ai_overview) return false;
        }

        // AI Citation filter
        if (excludeFilter !== 'aiCitation' && rankingFilterState.aiCitation !== 'all') {
          const isCited = row.ai_alan_citations_count > 0;
          if (rankingFilterState.aiCitation === 'cited' && !isCited) return false;
          if (rankingFilterState.aiCitation === 'not-cited' && isCited) return false;
        }

        // Opportunity band constants
        const OP_BANDS = {
          highMin: 70,
          mediumMin: 40
        };

        // Opportunity Score filter
        if (excludeFilter !== 'opportunity' && rankingFilterState.opportunity !== 'all') {
          const oppScore = row.opportunityScore ?? -1; // Treat null as -1 (below low threshold)
          if (rankingFilterState.opportunity === 'high' && (oppScore < OP_BANDS.highMin || oppScore > 100)) return false;
          if (rankingFilterState.opportunity === 'medium' && (oppScore < OP_BANDS.mediumMin || oppScore >= OP_BANDS.highMin)) return false;
          if (rankingFilterState.opportunity === 'low' && (oppScore >= OP_BANDS.mediumMin || oppScore < 0)) return false;
        }

        // Min opportunity filter (applied after band filter if set)
        if (rankingFilterState.minOpportunity != null) {
          const oppScore = Number(row.opportunityScore) || 0;
          if (oppScore < rankingFilterState.minOpportunity) return false;
        }

        // Keyword search
        if (excludeFilter !== 'keyword' && rankingFilterState.keyword) {
          const kw = rankingFilterState.keyword.toLowerCase();
          if (!row.keyword.toLowerCase().includes(kw)) return false;
        }

        // Optimisation status filter
        if (excludeFilter !== 'optimisationStatus' && rankingFilterState.optimisationStatus !== 'all') {
          const taskType = 'on_page'; // Default task type
          const status = window.getOptimisationStatus ? window.getOptimisationStatus(row, taskType) : null;
          const rowStatus = status && status.status ? status.status : 'not-tracked';
          
          if (rankingFilterState.optimisationStatus === 'not-tracked' && rowStatus !== 'not-tracked') return false;
          if (rankingFilterState.optimisationStatus === 'planned' && rowStatus !== 'planned') return false;
          if (rankingFilterState.optimisationStatus === 'in_progress' && rowStatus !== 'in_progress') return false;
          if (rankingFilterState.optimisationStatus === 'monitoring' && rowStatus !== 'monitoring') return false;
          if (rankingFilterState.optimisationStatus === 'done' && rowStatus !== 'done') return false;
          if (rankingFilterState.optimisationStatus === 'paused' && rowStatus !== 'paused') return false;
          if (rankingFilterState.optimisationStatus === 'cancelled' && rowStatus !== 'cancelled') return false;
        }

        // Priority matrix filter (Impact  Difficulty)
        if (rankingPriorityFilter) {
          const impact = calculateImpactBucket(row.demand_share || 0);
          const difficulty = calculateDifficultyBucket(row.best_rank_group);
          if (impact !== rankingPriorityFilter.impact || difficulty !== rankingPriorityFilter.difficulty) {
            return false;
          }
        }

        return true;
      });
    }

    // Sort rows
    function sortRankingRows(rows) {
      const sorted = [...rows];
      sorted.sort((a, b) => {
        let aVal, bVal;
        switch (rankingSortState.column) {
          case 'keyword':
            aVal = a.keyword.toLowerCase();
            bVal = b.keyword.toLowerCase();
            break;
          case 'segment':
            aVal = a.segment;
            bVal = b.segment;
            break;
          case 'rank':
            aVal = a.best_rank_group ?? 999;
            bVal = b.best_rank_group ?? 999;
            break;
          case 'citations':
            aVal = a.ai_alan_citations_count ?? 0;
            bVal = b.ai_alan_citations_count ?? 0;
            break;
          case 'volume':
            aVal = a.search_volume ?? 0;
            bVal = b.search_volume ?? 0;
            break;
          case 'ctr':
            const aCtr = getCtrMetricsForKeyword({ keyword: a.keyword, url: a.ranking_url });
            const bCtr = getCtrMetricsForKeyword({ keyword: b.keyword, url: b.ranking_url });
            aVal = (aCtr && aCtr.ctr != null) ? aCtr.ctr : -1; // Put nulls at end
            bVal = (bCtr && bCtr.ctr != null) ? bCtr.ctr : -1;
            break;
          case 'impressions30d':
            aVal = a.impressions30d ?? -1; // Put nulls at end
            bVal = b.impressions30d ?? -1;
            break;
          case 'opportunityScore':
            aVal = a.opportunityScore ?? -1; // Put nulls at end
            bVal = b.opportunityScore ?? -1;
            break;
          case 'pageType':
            aVal = a.pageType || 'Landing';
            bVal = b.pageType || 'Landing';
            break;
          default:
            return 0;
        }
        if (aVal < bVal) return rankingSortState.direction === 'asc' ? -1 : 1;
        if (aVal > bVal) return rankingSortState.direction === 'asc' ? 1 : -1;
        
        // Secondary sort: for high-impact-money, sort by rank (asc) when opportunity scores are equal
        if (rankingSortState.column === 'opportunityScore' && activePreset === 'high-impact-money') {
          const aRank = normalizeRank(a.best_rank_group) ?? 999;
          const bRank = normalizeRank(b.best_rank_group) ?? 999;
          if (aRank < bRank) return -1;
          if (aRank > bRank) return 1;
        }
        
        return 0;
      });
      return sorted;
    }

    // Toggle metric pill details
    function toggleMetricPillDetails(cardId) {
      const card = document.getElementById(cardId);
      if (!card) return;
      
      const detailsEl = card.querySelector(".metric-pill-details");
      const toggleEl = card.querySelector(".metric-pill-toggle");
      
      if (detailsEl && toggleEl) {
        const isExpanded = detailsEl.classList.contains("expanded");
        if (isExpanded) {
          detailsEl.classList.remove("expanded");
          toggleEl.textContent = "Show details";
        } else {
          detailsEl.classList.add("expanded");
          toggleEl.textContent = "Hide details";
        }
      }
    }

    // Set all metric pill details to be expanded by default on desktop
    function expandAllMetricPillDetails() {
      const pillIds = ['ranking-card-ai-coverage', 'ranking-card-ai-citations', 'ranking-card-top10', 'ranking-card-serp-features'];
      pillIds.forEach(cardId => {
        const card = document.getElementById(cardId);
        if (card) {
          const detailsEl = card.querySelector(".metric-pill-details");
          const toggleEl = card.querySelector(".metric-pill-toggle");
          if (detailsEl && toggleEl && detailsEl.innerHTML.trim() !== '') {
            detailsEl.classList.add("expanded");
            toggleEl.textContent = "Hide details";
          }
        }
      });
    }

    // Update metric pills with RAG
    function updateMetricPills(filteredRows, allRows) {
      const totalKeywords = allRows.length;
      const filteredCount = filteredRows.length;
      
      // Check if filters are active (if filtered count differs from total, filters are active)
      const filtersActive = filteredCount !== totalKeywords;
      
      // Use filtered rows if filters are active, otherwise use all rows
      const rowsToUse = filtersActive ? filteredRows : allRows;
      const countToUse = filtersActive ? filteredCount : totalKeywords;

      // Tracked keywords (always shows total, but can show filtered count)
      const trackedCard = document.getElementById("ranking-card-tracked");
      if (trackedCard) {
        const valueEl = trackedCard.querySelector(".metric-pill-value[data-field='value']");
        if (valueEl) {
          valueEl.textContent = filtersActive 
            ? `${filteredCount} of ${totalKeywords}` 
            : totalKeywords.toString();
        }
        trackedCard.className = "metric-pill metric-pill--neutral";
        const statusEl = trackedCard.querySelector(".metric-pill-status[data-field='status']");
        if (statusEl) statusEl.textContent = "Info only";
      }

      // Calculate metrics from rowsToUse (filtered if filters active, all if not)
      const withAiOverview = rowsToUse.filter(r => r.has_ai_overview).length;
      const withAiCitation = rowsToUse.filter(r => r.ai_alan_citations_count > 0).length;
      const top10 = rowsToUse.filter(r => r.best_rank_group != null && r.best_rank_group <= 10).length;

      const aiCoveragePct = countToUse > 0 ? Math.round((withAiOverview / countToUse) * 100) : 0;
      const aiCitationPct = countToUse > 0 ? Math.round((withAiCitation / countToUse) * 100) : 0;
      const top10Pct = countToUse > 0 ? Math.round((top10 / countToUse) * 100) : 0;

      // AI Overview coverage
      const coverageCard = document.getElementById("ranking-card-ai-coverage");
      if (coverageCard) {
        const valueEl = coverageCard.querySelector(".metric-pill-value[data-field='value']");
        const statusEl = coverageCard.querySelector(".metric-pill-status[data-field='status']");
        const detailsEl = coverageCard.querySelector(".metric-pill-details");
        if (valueEl) valueEl.textContent = `${withAiOverview}/${countToUse} (${aiCoveragePct}%)`;
        
        let ragClass = 'red';
        let statusLabel = 'Low';
        if (aiCoveragePct >= 80) { ragClass = 'green'; statusLabel = 'Strong'; }
        else if (aiCoveragePct >= 40) { ragClass = 'amber'; statusLabel = 'Moderate'; }
        
        coverageCard.className = `metric-pill metric-pill--${ragClass}`;
        if (statusEl) statusEl.textContent = statusLabel;
        
        // Update details
        if (detailsEl) {
          const withoutOverview = countToUse - withAiOverview;
          const pctWithoutOverview = countToUse > 0 ? Math.round((withoutOverview / countToUse) * 100) : 0;
          detailsEl.innerHTML = `
            <p class="tile-details-title">How often any AI Overview appears for your tracked keywords.</p>
            <ul class="tile-details-list">
              <li>
                <strong>With AI Overview:</strong> ${withAiOverview}/${countToUse} (${aiCoveragePct}%)
              </li>
              <li>
                <strong>Without AI Overview:</strong> ${withoutOverview}/${countToUse} (${pctWithoutOverview}%)
              </li>
            </ul>
            <p class="tile-details-footnote">
              Counted per keyword. It does not matter which domains are cited.
            </p>
          `;
        }
      }

      // AI Citations
      const citationsCard = document.getElementById("ranking-card-ai-citations");
      if (citationsCard) {
        const valueEl = citationsCard.querySelector(".metric-pill-value[data-field='value']");
        const statusEl = citationsCard.querySelector(".metric-pill-status[data-field='status']");
        const detailsEl = citationsCard.querySelector(".metric-pill-details");
        if (valueEl) valueEl.textContent = `${withAiCitation}/${countToUse} (${aiCitationPct}%)`;
        
        let ragClass = 'red';
        let statusLabel = 'Not cited';
        if (aiCitationPct >= 60) { ragClass = 'green'; statusLabel = 'Strong'; }
        else if (aiCitationPct >= 30) { ragClass = 'amber'; statusLabel = 'Some'; }
        
        citationsCard.className = `metric-pill metric-pill--${ragClass}`;
        if (statusEl) statusEl.textContent = statusLabel;
        
        // Calculate total citations
        const totalCitations = rowsToUse.reduce((sum, r) => sum + (r.ai_alan_citations_count || 0), 0);
        
        // Calculate withOverviewNoCitation (keywords with AI Overview but no alanranger.com citation)
        const withOverviewNoCitation = rowsToUse.filter(r => r.has_ai_overview && r.ai_alan_citations_count === 0).length;
        const pctWithOverviewNoCitation = countToUse > 0 ? Math.round((withOverviewNoCitation / countToUse) * 100) : 0;
        
        // Update details
        if (detailsEl) {
          detailsEl.innerHTML = `
            <p class="tile-details-title">
              How often alanranger.com is actually cited inside the AI Overview.
            </p>
            <ul class="tile-details-list">
              <li>
                <strong>Keywords with citations:</strong> ${withAiCitation}/${countToUse} (${aiCitationPct}%)
              </li>
              <li>
                <strong>With AI Overview but no alanranger.com citation:</strong> ${withOverviewNoCitation}/${countToUse} (${pctWithOverviewNoCitation}%)
              </li>
              <li>
                <strong>Total citations across all keywords:</strong> ${totalCitations}
              </li>
            </ul>
            <p class="tile-details-footnote">
              A single keyword can cite alanranger.com multiple times; all those links are counted in "Total citations".
            </p>
          `;
        }
      }

      // Top-10 coverage
      const top10Card = document.getElementById("ranking-card-top10");
      if (top10Card) {
        const valueEl = top10Card.querySelector(".metric-pill-value[data-field='value']");
        const statusEl = top10Card.querySelector(".metric-pill-status[data-field='status']");
        const detailsEl = top10Card.querySelector(".metric-pill-details");
        if (valueEl) valueEl.textContent = `${top10}/${countToUse} (${top10Pct}%)`;
        
        // Calculate rank buckets
        const top3 = rowsToUse.filter(r => r.best_rank_group != null && r.best_rank_group <= 3).length;
        const top3Pct = countToUse > 0 ? Math.round((top3 / countToUse) * 100) : 0;
        const rank11to20 = rowsToUse.filter(r => r.best_rank_group != null && r.best_rank_group >= 11 && r.best_rank_group <= 20).length;
        const rank11to20Pct = countToUse > 0 ? Math.round((rank11to20 / countToUse) * 100) : 0;
        const notRanked = rowsToUse.filter(r => r.best_rank_group == null || r.best_rank_group > 20).length;
        const notRankedPct = countToUse > 0 ? Math.round((notRanked / countToUse) * 100) : 0;
        
        let ragClass = 'red';
        let statusLabel = 'Weak';
        if (top10Pct >= 60) { ragClass = 'green'; statusLabel = 'Strong'; }
        else if (top10Pct >= 30) { ragClass = 'amber'; statusLabel = 'OK'; }
        
        top10Card.className = `metric-pill metric-pill--${ragClass}`;
        if (statusEl) statusEl.textContent = statusLabel;
        
        // Calculate top10Only (positions 4-10)
        const top10Only = top10 - top3;
        const pctTop10Only = countToUse > 0 ? Math.round((top10Only / countToUse) * 100) : 0;
        const pct11to20 = countToUse > 0 ? Math.round((rank11to20 / countToUse) * 100) : 0;
        const pctNotRanked = countToUse > 0 ? Math.round((notRanked / countToUse) * 100) : 0;
        
        // Update details
        if (detailsEl) {
          detailsEl.innerHTML = `
            <p class="tile-details-title">
              Distribution of best classic (blue-link) rankings across your tracked keywords.
            </p>
            <ul class="tile-details-list">
              <li>
                <strong>Top 3 (positions 13):</strong> ${top3}/${countToUse} (${top3Pct}%)
              </li>
              <li>
                <strong>Positions 410:</strong> ${top10Only}/${countToUse} (${pctTop10Only}%)
              </li>
              <li>
                <strong>Positions 1120:</strong> ${rank11to20}/${countToUse} (${pct11to20}%)
              </li>
              <li>
                <strong>Not ranked (21+):</strong> ${notRanked}/${countToUse} (${pctNotRanked}%)
              </li>
            </ul>
            <p class="tile-details-footnote">
              "Top 3" and "410" together make up your total Top-10 coverage.
            </p>
          `;
        }
      }

      // SERP feature coverage
      const serpFeaturesCard = document.getElementById("ranking-card-serp-features");
      if (serpFeaturesCard) {
        // Count keywords with each SERP feature
        const withAiOverview = rowsToUse.filter(r => r.ai_overview_present_any === true || r.has_ai_overview === true).length;
        const withLocalPack = rowsToUse.filter(r => r.local_pack_present_any === true || (r.serp_features && r.serp_features.local_pack === true)).length;
        const withPaa = rowsToUse.filter(r => r.paa_present_any === true || (r.serp_features && r.serp_features.people_also_ask === true)).length;
        const withFeaturedSnippet = rowsToUse.filter(r => r.featured_snippet_present_any === true || (r.serp_features && r.serp_features.featured_snippet === true)).length;
        
        // Calculate average feature presence (0-100%)
        const avgFeaturePresence = countToUse > 0 
          ? Math.round(((withAiOverview + withLocalPack + withPaa + withFeaturedSnippet) / (countToUse * 4)) * 100)
          : 0;
        
        // Calculate individual percentages
        const aiOverviewPct = countToUse > 0 ? Math.round((withAiOverview / countToUse) * 100) : 0;
        const localPackPct = countToUse > 0 ? Math.round((withLocalPack / countToUse) * 100) : 0;
        const paaPct = countToUse > 0 ? Math.round((withPaa / countToUse) * 100) : 0;
        const featuredSnippetPct = countToUse > 0 ? Math.round((withFeaturedSnippet / countToUse) * 100) : 0;
        
        const valueEl = serpFeaturesCard.querySelector(".metric-pill-value[data-field='value']");
        const statusEl = serpFeaturesCard.querySelector(".metric-pill-status[data-field='status']");
        const detailsEl = serpFeaturesCard.querySelector(".metric-pill-details");
        
        // Show as "X/4 features (Y%)" format
        const featuresPresent = [withAiOverview, withLocalPack, withPaa, withFeaturedSnippet].filter(count => count > 0).length;
        if (valueEl) valueEl.textContent = `${featuresPresent}/4 features (${avgFeaturePresence}%)`;
        
        let ragClass = 'red';
        let statusLabel = 'Low';
        if (avgFeaturePresence >= 70) { ragClass = 'green'; statusLabel = 'Strong'; }
        else if (avgFeaturePresence >= 40) { ragClass = 'amber'; statusLabel = 'Moderate'; }
        
        serpFeaturesCard.className = `metric-pill metric-pill--${ragClass}`;
        if (statusEl) statusEl.textContent = statusLabel;
        
        // Update details content
        if (detailsEl) {
          detailsEl.innerHTML = `
            <p class="tile-details-title">
              How often rich SERP features appear for your tracked keywords.
            </p>
            <ul class="tile-details-list">
              <li>
                <strong>AI Overview present:</strong> ${withAiOverview}/${countToUse} (${aiOverviewPct}%)
              </li>
              <li>
                <strong>Local pack present:</strong> ${withLocalPack}/${countToUse} (${localPackPct}%)
              </li>
              <li>
                <strong>People Also Ask present:</strong> ${withPaa}/${countToUse} (${paaPct}%)
              </li>
              <li>
                <strong>Featured snippet present:</strong> ${withFeaturedSnippet}/${countToUse} (${featuredSnippetPct}%)
              </li>
            </ul>
            <p class="tile-details-footnote">
              Counts are per keyword. A single SERP can contain multiple features (for example AI Overview + People Also Ask).
            </p>
          `;
        }
      }
    }

    // Update filter counts in dropdowns
    // Counts show how many items match each option given the current state of OTHER filters
    function updateFilterCounts(rows) {
      if (!rows || rows.length === 0) return;

      // For each filter, calculate counts based on rows that match all OTHER filters
      // Segment counts (excluding segment filter)
      const segmentRows = applyRankingFilters(rows, 'segment');
      const segmentCounts = { all: segmentRows.length, brand: 0, money: 0, education: 0, other: 0 };
      segmentRows.forEach(r => {
        const seg = (r.segment || '').toLowerCase();
        if (segmentCounts.hasOwnProperty(seg)) segmentCounts[seg]++;
        else segmentCounts.other++;
      });
      updateSelectCounts('ranking-filter-segment', segmentCounts);

      // Rank counts (excluding rank filter)
      const rankRows = applyRankingFilters(rows, 'rank');
      const rankCounts = { all: rankRows.length, top3: 0, '4-10': 0, '11-20': 0, '21+': 0, 'not-top3': 0 };
      rankRows.forEach(r => {
        const rank = normalizeRank(r.best_rank_group);
        if (rank !== null && rank <= 3) {
          rankCounts.top3++;
        } else {
          // Count rows that are NOT top 3 (rank > 3 or null)
          rankCounts['not-top3']++;
        }
        if (rank !== null && rank >= 4 && rank <= 10) rankCounts['4-10']++;
        if (rank !== null && rank >= 11 && rank <= 20) rankCounts['11-20']++;
        if (rank === null || rank >= 21) rankCounts['21+']++;
      });
      updateSelectCounts('ranking-filter-rank', rankCounts);

      // Volume counts (excluding volume filter)
      const volumeRows = applyRankingFilters(rows, 'volume');
      const volumeCounts = { all: volumeRows.length, high: 0, medium: 0, low: 0, none: 0 };
      volumeRows.forEach(r => {
        const vol = r.search_volume;
        if (vol == null || vol === 0) volumeCounts.none++;
        else if (vol < 50) volumeCounts.low++;
        else if (vol < 200) volumeCounts.medium++;
        else volumeCounts.high++;
      });
      updateSelectCounts('ranking-filter-volume', volumeCounts);

      // CTR counts (excluding CTR filter)
      const ctrRows = applyRankingFilters(rows, 'ctr');
      const ctrCounts = { all: ctrRows.length, high: 0, medium: 0, low: 0, none: 0 };
      ctrRows.forEach(r => {
        const ctrMetrics = getCtrMetricsForKeyword({ keyword: r.keyword, url: r.ranking_url });
        const ctr = ctrMetrics && ctrMetrics.ctr != null ? (ctrMetrics.ctr * 100) : null;
        if (ctr == null) ctrCounts.none++;
        else if (ctr < 2) ctrCounts.low++;
        else if (ctr < 5) ctrCounts.medium++;
        else ctrCounts.high++;
      });
      updateSelectCounts('ranking-filter-ctr', ctrCounts);

      // Demand share filter removed - replaced with Impressions (30d) column

      // Opportunity score counts (excluding opportunity filter)
      const oppRows = applyRankingFilters(rows, 'opportunity');
      const oppCounts = { all: oppRows.length, high: 0, medium: 0, low: 0 };
      oppRows.forEach(r => {
        const opp = r.opportunityScore ?? -1;
        if (opp >= 70) oppCounts.high++;
        else if (opp >= 40) oppCounts.medium++;
        else if (opp >= 0) oppCounts.low++;
      });
      updateSelectCounts('ranking-filter-opportunity', oppCounts);

      // AI Overview counts (excluding AI Overview filter)
      const aiOverviewRows = applyRankingFilters(rows, 'aiOverview');
      const aiOverviewCounts = { all: aiOverviewRows.length, has: 0, no: 0 };
      aiOverviewRows.forEach(r => {
        if (r.has_ai_overview) aiOverviewCounts.has++;
        else aiOverviewCounts.no++;
      });
      updateSelectCounts('ranking-filter-ai-overview', aiOverviewCounts);

      // AI Citation counts (excluding AI Citation filter)
      const aiCitationRows = applyRankingFilters(rows, 'aiCitation');
      const aiCitationCounts = { all: aiCitationRows.length, cited: 0, 'not-cited': 0 };
      aiCitationRows.forEach(r => {
        if (r.ai_alan_citations_count > 0) aiCitationCounts.cited++;
        else aiCitationCounts['not-cited']++;
      });
      updateSelectCounts('ranking-filter-ai-citation', aiCitationCounts);

      // Page type counts (excluding page type filter)
      const pageTypeRows = applyRankingFilters(rows, 'pageType');
      const pageTypeCounts = { all: pageTypeRows.length, GBP: 0, Blog: 0, Landing: 0, Event: 0, Product: 0, Other: 0 };
      pageTypeRows.forEach(r => {
        const pt = r.pageType || 'Landing';
        if (pageTypeCounts.hasOwnProperty(pt)) pageTypeCounts[pt]++;
        else pageTypeCounts.Other++;
      });
      updateSelectCounts('ranking-filter-page-type', pageTypeCounts);

      // SERP features counts (excluding SERP features filter)
      const serpRows = applyRankingFilters(rows, 'serpFeatures');
      const serpCounts = { all: serpRows.length, 'ai-overview': 0, 'local-pack': 0, paa: 0, 'featured-snippet': 0, none: 0 };
      serpRows.forEach(r => {
        const hasAi = r.ai_overview_present_any === true;
        const hasLocal = r.local_pack_present_any === true;
        const hasPaa = r.paa_present_any === true;
        const hasFeatured = r.featured_snippet_present_any === true;
        if (hasAi) serpCounts['ai-overview']++;
        if (hasLocal) serpCounts['local-pack']++;
        if (hasPaa) serpCounts.paa++;
        if (hasFeatured) serpCounts['featured-snippet']++;
        if (!hasAi && !hasLocal && !hasPaa && !hasFeatured) serpCounts.none++;
      });
      updateSelectCounts('ranking-filter-serp-features', serpCounts);

      // Optimisation status counts (excluding optimisation status filter)
      const optimisationRows = applyRankingFilters(rows, 'optimisationStatus');
      const optimisationCounts = { all: optimisationRows.length, 'not-tracked': 0, 'planned': 0, 'in_progress': 0, 'monitoring': 0, 'done': 0, 'paused': 0, 'cancelled': 0 };
      optimisationRows.forEach(r => {
        const taskType = 'on_page'; // Default task type
        const status = window.getOptimisationStatus ? window.getOptimisationStatus(r, taskType) : null;
        const rowStatus = status && status.status ? status.status : 'not-tracked';
        if (optimisationCounts.hasOwnProperty(rowStatus)) {
          optimisationCounts[rowStatus]++;
        } else {
          optimisationCounts['not-tracked']++;
        }
      });
      updateSelectCounts('ranking-filter-optimisation-status', optimisationCounts);
    }

    function updateSelectCounts(selectId, counts) {
      const select = document.getElementById(selectId);
      if (!select) return;
      // Store original labels (without counts) for each option
      const originalLabels = {};
      Array.from(select.options).forEach(opt => {
        const value = opt.value;
        if (!originalLabels[value]) {
          // Store original label (remove existing count if any)
          originalLabels[value] = opt.textContent.split(' (')[0].trim();
        }
      });
      // Update with counts - ensure ALL options get counts, even if 0
      Array.from(select.options).forEach(opt => {
        const value = opt.value;
        const label = originalLabels[value] || opt.textContent.split(' (')[0].trim();
        if (counts.hasOwnProperty(value)) {
          const count = counts[value];
          opt.textContent = value === 'all' ? `All (${count})` : `${label} (${count})`;
        } else {
          // If count not found, show 0 (for options that might not have been in the data)
          opt.textContent = value === 'all' ? `All (0)` : `${label} (0)`;
        }
      });
    }

    // Helper function to get query-only totals for a keyword (PATCH A2)
    // Helper function to normalize keywords for matching
    function normalizeKeywordForMatching(keyword) {
      if (!keyword) return '';
      // Normalize: lowercase, trim, collapse multiple spaces to single space
      return keyword.toLowerCase().trim().replace(/\s+/g, ' ');
    }
    
    function getQueryTotalForKeyword(keyword) {
      try {
        const savedAudit = loadAuditResultsSync();
        if (!savedAudit || !savedAudit.searchData) {
          debugLog(`getQueryTotalForKeyword: No queryTotals found for "${keyword}" - savedAudit=${!!savedAudit}, searchData=${!!savedAudit?.searchData}`, 'warn');
          return null;
        }
        
        // CRITICAL: Check if queryTotals exists and handle object vs array
        let queryTotals = savedAudit.searchData.queryTotals;
        if (!queryTotals) {
          debugLog(`getQueryTotalForKeyword: No queryTotals found for "${keyword}" - queryTotals is null/undefined`, 'warn');
          return null;
        }
        
        // If queryTotals is an object instead of an array, try to convert it
        if (typeof queryTotals === 'object' && !Array.isArray(queryTotals)) {
          debugLog(`getQueryTotalForKeyword: queryTotals is an object, not an array. Type: ${typeof queryTotals}, keys: ${Object.keys(queryTotals).join(', ')}`, 'warn');
          // Try to extract array from object
          if (Object.keys(queryTotals).every(key => !isNaN(parseInt(key)))) {
            // Array-like object with numeric keys
            queryTotals = Object.values(queryTotals);
            debugLog(`getQueryTotalForKeyword: Converted array-like object to array (${queryTotals.length} items)`, 'info');
          } else {
            // Check if there's an array property inside the object
            for (const key in queryTotals) {
              if (Array.isArray(queryTotals[key])) {
                queryTotals = queryTotals[key];
                debugLog(`getQueryTotalForKeyword: Extracted array from object at key '${key}' (${queryTotals.length} items)`, 'info');
                break;
              }
            }
          }
        }
        
        if (!Array.isArray(queryTotals)) {
          debugLog(`getQueryTotalForKeyword: queryTotals is still not an array after conversion attempt. Type: ${typeof queryTotals}`, 'warn');
          return null;
        }
        
        if (queryTotals.length === 0) {
          debugLog(`getQueryTotalForKeyword: queryTotals array is empty`, 'warn');
          return null;
        }
        
        // Normalize the search keyword
        const normalizedKeyword = normalizeKeywordForMatching(keyword);
        
        // Try exact match first (normalized)
        let queryTotal = queryTotals.find(
          qt => qt.query && normalizeKeywordForMatching(qt.query) === normalizedKeyword
        );
        
        // If no exact match, try fuzzy matching (check if keyword is contained in query or vice versa)
        if (!queryTotal) {
          queryTotal = queryTotals.find(
            qt => {
              if (!qt.query) return false;
              const normalizedQuery = normalizeKeywordForMatching(qt.query);
              // Check if normalized keyword is contained in normalized query or vice versa
              return normalizedQuery === normalizedKeyword || 
                     normalizedQuery.includes(normalizedKeyword) || 
                     normalizedKeyword.includes(normalizedQuery);
            }
          );
        }
        
        if (!queryTotal) {
          // Enhanced debugging: show sample queries from queryTotals to help diagnose mismatches
          const sampleQueries = queryTotals.slice(0, 10).map(qt => qt.query || '(no query)').join(', ');
          debugLog(`getQueryTotalForKeyword: No match found for "${keyword}" (normalized: "${normalizedKeyword}") in ${queryTotals.length} queryTotals. Sample queries: ${sampleQueries}${queryTotals.length > 10 ? '...' : ''}`, 'warn');
          
          // Also check if there are any queries with zero impressions (these might be the missing ones)
          const zeroImpressionQueries = queryTotals.filter(qt => qt.impressions === 0 || qt.impressions == null).slice(0, 5).map(qt => qt.query || '(no query)').join(', ');
          if (zeroImpressionQueries) {
            debugLog(`getQueryTotalForKeyword: Found ${queryTotals.filter(qt => qt.impressions === 0 || qt.impressions == null).length} queries with zero impressions. Sample: ${zeroImpressionQueries}`, 'info');
          }
        }
        
        return queryTotal || null;
      } catch (error) {
        debugLog(`Error in getQueryTotalForKeyword: ${error.message}`, 'warn');
        return null;
      }
    }

    async function renderRankingAiTab() {
      debugLog(' renderRankingAiTab() called', 'info');
      const { combinedRows, summary } = RankingAiModule.state();
      debugLog(` renderRankingAiTab: combinedRows=${combinedRows?.length || 0}, hasSummary=${!!summary}`, 'info');
      
      // Always render table, even if no data (will show empty state)
      const tbody = document.getElementById("ranking-ai-table-body");
      if (!tbody) {
        debugLog(' renderRankingAiTab: Table body not found', 'warn');
        return;
      }
      
      if (!summary || !Array.isArray(combinedRows) || combinedRows.length === 0) {
        debugLog(` renderRankingAiTab: No data - summary=${!!summary}, combinedRows is array=${Array.isArray(combinedRows)}, length=${combinedRows?.length || 0}`, 'warn');
        // Show empty state message
        tbody.innerHTML = '<tr><td colspan="11" class="ranking-table-empty">Click "Run ranking &amp; AI check" to load data.</td></tr>';
        const paginationControls = document.getElementById("ranking-pagination-controls");
        if (paginationControls) paginationControls.style.display = "none";
        return;
      }
      
      debugLog(` renderRankingAiTab: Proceeding with ${combinedRows.length} keywords`, 'success');

      // Apply filters first
      const filteredRows = applyRankingFilters(combinedRows);
      
      // Update filter counts based on all rows (before filtering)
      updateFilterCounts(combinedRows);
      
      // Update preset button active states and render criteria chips
      if (typeof updatePresetButtonActiveStates === 'function') {
        updatePresetButtonActiveStates();
      }
      if (typeof renderPresetCriteriaChips === 'function') {
        renderPresetCriteriaChips();
      }
      
      // Note: demand_share is no longer recalculated from filtered rows
      // It remains as originally calculated from all tracked keywords (global-fixed)
      // Used internally for opportunity score calculation only
      
      // Calculate visibility metrics from filtered subset
      const validRankingRows = filteredRows.filter(
        r => r.best_rank_group !== null && typeof r.best_rank_group === 'number'
      );
      
      let avgPositionUnweighted = null;
      let avgPositionVolumeWeighted = null;
      
      if (validRankingRows.length >= 1) {
        // Unweighted average position
        const sumRanks = validRankingRows.reduce((sum, r) => sum + r.best_rank_group, 0);
        avgPositionUnweighted = sumRanks / validRankingRows.length;
        
        // Demand-weighted average position
        let sumWeightedRanks = 0;
        let sumVolumes = 0;
        
        for (const row of validRankingRows) {
          const vol = (row.search_volume !== null && row.search_volume !== undefined && row.search_volume > 0)
            ? row.search_volume
            : 10; // Fallback
          
          sumWeightedRanks += row.best_rank_group * vol;
          sumVolumes += vol;
        }
        
        if (sumVolumes > 0) {
          avgPositionVolumeWeighted = sumWeightedRanks / sumVolumes;
        }
      }
      
      // Display tracked keyword visibility metrics (DataForSEO only - not part of AIO pillars)
      const visibilityMetricsSection = document.getElementById('ranking-visibility-metrics');
      const avgPositionWeightedEl = document.getElementById('ranking-avg-position-weighted');
      const avgPositionUnweightedEl = document.getElementById('ranking-avg-position-unweighted');
      
      if (visibilityMetricsSection) {
        // Always show the visibility metrics section (it's part of the side-by-side layout)
        visibilityMetricsSection.style.display = 'block';
        if (avgPositionVolumeWeighted !== null && avgPositionVolumeWeighted !== undefined) {
          visibilityMetricsSection.style.display = 'block';
          if (avgPositionWeightedEl) {
            avgPositionWeightedEl.textContent = avgPositionVolumeWeighted.toFixed(2);
          }
          if (avgPositionUnweightedEl && avgPositionUnweighted !== null && avgPositionUnweighted !== undefined) {
            avgPositionUnweightedEl.textContent = avgPositionUnweighted.toFixed(2);
          } else if (avgPositionUnweightedEl) {
            avgPositionUnweightedEl.textContent = '';
          }
        } else {
          visibilityMetricsSection.style.display = 'block';
          if (avgPositionWeightedEl) {
            avgPositionWeightedEl.textContent = '';
            avgPositionWeightedEl.title = 'Not enough valid keywords to calculate.';
          }
          if (avgPositionUnweightedEl) {
            avgPositionUnweightedEl.textContent = '';
            avgPositionUnweightedEl.title = 'Not enough valid keywords to calculate.';
          }
        }
      }
      
      // Update metric pills from filtered data
      updateMetricPills(filteredRows, combinedRows);
      
      // Expand all metric pill details by default
      setTimeout(() => expandAllMetricPillDetails(), 100);

      // Render Keyword Priority Matrix
      const matrixContainer = document.getElementById('ranking-keyword-priority-matrix');
      const matrixSection = document.getElementById('ranking-priority-matrix-section');
      if (matrixContainer && filteredRows.length > 0) {
        if (matrixSection) matrixSection.style.display = 'block';
        renderKeywordPriorityMatrix(filteredRows, matrixContainer, (filter) => {
          // Filter changed - re-render table
          renderRankingAiTab();
        });
      } else if (matrixSection) {
        matrixSection.style.display = 'none';
      }

      // Sort filtered rows
      const sortedRows = sortRankingRows(filteredRows);
      
      // Calculate pagination
      const totalRows = sortedRows.length;
      const rowsPerPage = rankingPaginationState.rowsPerPage === 'all' ? totalRows : rankingPaginationState.rowsPerPage;
      const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
      const currentPage = Math.min(Math.max(1, rankingPaginationState.currentPage), totalPages);
      rankingPaginationState.currentPage = currentPage;
      
      const startIdx = rowsPerPage === 'all' ? 0 : (currentPage - 1) * rowsPerPage;
      const endIdx = rowsPerPage === 'all' ? totalRows : Math.min(startIdx + rowsPerPage, totalRows);
      const paginatedRows = sortedRows.slice(startIdx, endIdx);

      // -------- Fetch optimisation statuses (Phase 2) --------
      if (typeof window.fetchOptimisationStatuses === 'function') {
        await window.fetchOptimisationStatuses(sortedRows);
      }

      // -------- Keyword table --------
      // tbody already declared at top of function, just clear it
      tbody.innerHTML = "";

      if (!sortedRows.length) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = 12; // Updated: 12 columns (Keyword, Segment, Best rank, Search volume, CTR, Impressions (30d), Opportunity score, AI Overview, AI citations, Classic Ranking URL, Page type, SERP features)
        td.className = "ranking-table-empty";
        td.textContent = filteredRows.length === 0 && combinedRows.length > 0
          ? "No rows match the current filters."
          : "No data returned from ranking / AI endpoints.";
        tr.appendChild(td);
        tbody.appendChild(tr);
        
        // Hide pagination when no data
        const paginationControls = document.getElementById("ranking-pagination-controls");
        if (paginationControls) paginationControls.style.display = "none";
        return;
      }

      // Store original index mapping for detail panel
      const originalIndexMap = new Map();
      paginatedRows.forEach((row, idx) => {
        const origIdx = combinedRows.indexOf(row);
        originalIndexMap.set(idx, origIdx >= 0 ? origIdx : idx);
      });

      paginatedRows.forEach((row, index) => {
        try {
        const tr = document.createElement("tr");
        tr.dataset.index = String(originalIndexMap.get(index));

        // Keyword
        const tdKeyword = document.createElement("td");
        tdKeyword.textContent = row.keyword;
        tr.appendChild(tdKeyword);

        // Segment
        const tdSegment = document.createElement("td");
        const segBadge = document.createElement("span");
        const segLower = (row.segment || "").toLowerCase();
        segBadge.className = "ranking-badge " + (
          segLower === "money" ? "ranking-badge--segment-money" :
          segLower === "education" ? "ranking-badge--segment-education" :
          segLower === "brand" ? "ranking-badge--segment-brand" :
          "ranking-badge--segment-general"
        );
        segBadge.textContent = row.segment || "Other";
        tdSegment.appendChild(segBadge);
        tr.appendChild(tdSegment);

        // Best rank with RAG badge
        const tdRank = document.createElement("td");
        if (row.best_rank_group == null) {
          const badge = document.createElement("span");
          badge.className = "ranking-badge-rank ranking-badge-rank--weak";
          badge.textContent = "";
          tdRank.appendChild(badge);
        } else {
          const badge = document.createElement("span");
          let ragClass = "ranking-badge-rank--weak";
          if (row.best_rank_group <= 10) ragClass = "ranking-badge-rank--good";
          else if (row.best_rank_group <= 20) ragClass = "ranking-badge-rank--ok";
          badge.className = `ranking-badge-rank ${ragClass}`;
          badge.textContent = `#${row.best_rank_group}`;
          tdRank.appendChild(badge);
        }
        tr.appendChild(tdRank);

        // Search volume with RAG badge
        const tdVolume = document.createElement("td");
        const volumeBadge = document.createElement("span");
        const searchVolume = row.search_volume;
        // IMPORTANT: Only treat as missing if null/undefined, not if 0 (0 is a valid value)
        if (searchVolume == null || searchVolume === undefined) {
          volumeBadge.className = "ranking-badge-volume ranking-badge-volume--none";
          volumeBadge.textContent = "";
        } else {
          const formatted = searchVolume.toLocaleString();
          let ragClass = "ranking-badge-volume--low";
          let label = "Low";
          if (searchVolume > 200) {
            ragClass = "ranking-badge-volume--high";
            label = "High";
          } else if (searchVolume > 50) {
            ragClass = "ranking-badge-volume--med";
            label = "Med";
          }
          volumeBadge.className = `ranking-badge-volume ${ragClass}`;
          volumeBadge.textContent = `${formatted} ${label}`;
        }
        tdVolume.appendChild(volumeBadge);
        tr.appendChild(tdVolume);

        // CTR (30d) - query-only from queryTotals
        const tdCtr = document.createElement("td");
        const queryTotal = getQueryTotalForKeyword(row.keyword);
        if (queryTotal && queryTotal.impressions > 0 && queryTotal.ctr != null) {
          // queryTotal.ctr is already a percentage (0-100) from API, not a decimal
          const ctrPercent = queryTotal.ctr.toFixed(1);
          tdCtr.textContent = `${ctrPercent}%`;
          tdCtr.style.color = '#1e293b';
          tdCtr.title = `Google Search Console. Query-only (keyword totals across all pages). Last 28 days (matches GSC UI).`;
        } else {
          tdCtr.textContent = "";
          tdCtr.style.color = '#94a3b8';
          tdCtr.title = `No query totals returned for this keyword in the last 28 days.`;
        }
        tr.appendChild(tdCtr);

        // Impressions (28d) - query-only from queryTotals
        const tdImpressions = document.createElement("td");
        if (queryTotal && queryTotal.impressions != null && queryTotal.impressions > 0) {
          tdImpressions.textContent = queryTotal.impressions.toLocaleString();
          tdImpressions.style.color = '#1e293b';
          tdImpressions.title = `Google Search Console. Query-only (keyword totals across all pages). Last 28 days (matches GSC UI).`;
        } else {
          tdImpressions.textContent = "";
          tdImpressions.style.color = '#94a3b8';
          tdImpressions.title = `No query totals returned for this keyword in the last 28 days.`;
        }
        tr.appendChild(tdImpressions);

        // Opportunity Score
        const tdOpportunity = document.createElement("td");
        const oppScore = row.opportunityScore ?? null;
        if (oppScore != null) {
          const oppBadge = document.createElement("span");
          let oppClass = "ranking-badge-opportunity--low";
          if (oppScore >= 70) {
            oppClass = "ranking-badge-opportunity--high";
          } else if (oppScore >= 40) {
            oppClass = "ranking-badge-opportunity--medium";
          }
          oppBadge.className = `ranking-badge-opportunity ${oppClass}`;
          oppBadge.textContent = `${oppScore}/100`;
          tdOpportunity.appendChild(oppBadge);
        } else {
          tdOpportunity.textContent = "";
        }
        tr.appendChild(tdOpportunity);

        // AI Overview
        const tdAi = document.createElement("td");
        const aiBadge = document.createElement("span");
        aiBadge.className =
          "ranking-badge " + (row.has_ai_overview ? "ranking-badge--ai-on" : "ranking-badge--ai-off");
        aiBadge.textContent = row.has_ai_overview ? "On" : "Off";
        tdAi.appendChild(aiBadge);
        tr.appendChild(tdAi);

        // AI citation with RAG badge
        const tdCitation = document.createElement("td");
        const citBadge = document.createElement("span");
        const isCited = row.ai_alan_citations_count > 0;
        const totalCits = row.ai_total_citations || 0;
        const label = isCited
          ? `${row.ai_alan_citations_count}/${totalCits || "?"}`
          : "0";
        citBadge.className = isCited
          ? "ranking-badge-citation ranking-badge-citation--good"
          : "ranking-badge-citation ranking-badge-citation--weak";
        citBadge.textContent = label;
        tdCitation.appendChild(citBadge);
        tr.appendChild(tdCitation);

        // Classic Ranking URL
        const tdUrl = document.createElement("td");
        if (row.best_url) {
          const a = document.createElement("a");
          a.href = row.targetUrl || row.ranking_url || row.best_url || '';
          a.target = "_blank";
          a.rel = "noopener noreferrer";
          a.textContent = row.best_title || row.best_url;
          tdUrl.appendChild(a);
        } else {
          tdUrl.textContent = "";
        }
        tr.appendChild(tdUrl);

        // Page type
        const tdType = document.createElement("td");
        const pageType = row.pageType || "Landing";
        const typeBadge = document.createElement("span");
        // Use similar styling to Money Pages matrix
        let typeClass = "ranking-badge-page-type";
        if (pageType === "Event") typeClass += " ranking-badge-page-type--event";
        else if (pageType === "Product") typeClass += " ranking-badge-page-type--product";
        else if (pageType === "Blog") typeClass += " ranking-badge-page-type--blog";
        else if (pageType === "GBP") typeClass += " ranking-badge-page-type--gbp";
        else typeClass += " ranking-badge-page-type--landing";
        typeBadge.className = typeClass;
        typeBadge.textContent = pageType;
        tdType.appendChild(typeBadge);
        tr.appendChild(tdType);

        // Optimisation column
        const tdOptimisation = document.createElement("td");
        tdOptimisation.style.position = "relative";
        
        const taskType = 'on_page'; // Default task type for this integration
        const status = window.getOptimisationStatus(row, taskType);
        
        // Safety check: ensure status object has expected structure
        if (!status || typeof status !== 'object' || !status.status) {
          // Not tracked - show "Not tracked" pill + Track button
          const notTrackedBadge = document.createElement("span");
          notTrackedBadge.className = "ranking-badge ranking-badge--segment-general";
          notTrackedBadge.style.marginRight = "0.5rem";
          notTrackedBadge.textContent = "Not tracked";
          notTrackedBadge.title = "No optimisation task exists for this keyword + URL.";
          tdOptimisation.appendChild(notTrackedBadge);
          
          const trackBtn = document.createElement("button");
          trackBtn.className = "btn btn-small";
          trackBtn.style.padding = "0.15rem 0.4rem";
          trackBtn.style.fontSize = "0.3rem";
          trackBtn.style.fontWeight = "550";
          trackBtn.style.background = "#2563eb";
          trackBtn.style.color = "#ffffff";
          trackBtn.style.border = "1px solid #1e40af";
          trackBtn.textContent = "Track";
          trackBtn.title = "Create a task for this keyword + URL and capture baseline metrics.";
          if (window.isShareMode) {
            trackBtn.disabled = true;
            trackBtn.title = "Not available in share mode (read-only)";
            trackBtn.style.opacity = "0.5";
            trackBtn.style.cursor = "not-allowed";
          } else if (!window.hasAdminKey()) {
            trackBtn.disabled = true;
            trackBtn.title = "Admin key required - set your admin key in the configuration section";
            trackBtn.style.opacity = "0.5";
            trackBtn.style.cursor = "not-allowed";
          }
          trackBtn.onclick = (e) => {
            e.stopPropagation();
            if (window.isShareMode) {
              alert('Write operations are not available in share mode (read-only).');
              return;
            }
            if (!window.hasAdminKey()) {
              alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
              return;
            }
            window.openTrackKeywordModal(row, taskType);
          };
          tdOptimisation.appendChild(trackBtn);
        } else {
          // Tracked - check if status is 'done' or 'cancelled', show Track again button
          // Note: 'deleted' should never appear - if task is deleted, it won't exist in status map
          if (status.status === 'done' || status.status === 'cancelled') {
            // Show status pill + Track again button
            const statusBadge = document.createElement("span");
            statusBadge.className = "ranking-badge ranking-badge--segment-general";
            statusBadge.style.marginRight = "0.5rem";
            const statusLabels = {
              'done': 'Done',
              'cancelled': 'Cancelled'
            };
            statusBadge.textContent = statusLabels[status.status] || status.status;
            const statusTooltips = {
              'done': 'Cycle completed; start a new cycle if optimising again.',
              'cancelled': 'Tracking stopped; you can start a new cycle later.'
            };
            statusBadge.title = statusTooltips[status.status] || 'Click Track again to start a new cycle.';
            tdOptimisation.appendChild(statusBadge);
            
            const trackBtn = document.createElement("button");
            trackBtn.className = "btn btn-small";
            trackBtn.style.padding = "0.03rem 0.08rem";
            trackBtn.style.fontSize = "0.35rem";
            trackBtn.style.fontWeight = "550";
            trackBtn.style.background = "#2563eb";
            trackBtn.style.color = "#ffffff";
            trackBtn.style.border = "1px solid #1e40af";
            trackBtn.textContent = "Track again";
            trackBtn.title = "Start a new cycle for this keyword + URL.";
            if (window.isShareMode) {
              trackBtn.disabled = true;
              trackBtn.title = "Not available in share mode (read-only)";
              trackBtn.style.opacity = "0.5";
              trackBtn.style.cursor = "not-allowed";
            } else if (!window.hasAdminKey()) {
              trackBtn.disabled = true;
              trackBtn.title = "Admin key required - set your admin key in the configuration section";
              trackBtn.style.opacity = "0.5";
              trackBtn.style.cursor = "not-allowed";
            }
            trackBtn.onclick = (e) => {
              e.stopPropagation();
              if (window.isShareMode) {
                alert('Write operations are not available in share mode (read-only).');
                return;
              }
              if (!window.hasAdminKey()) {
                alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
                return;
              }
              window.openTrackKeywordModal(row, taskType);
            };
            tdOptimisation.appendChild(trackBtn);
            
            tr.appendChild(tdOptimisation);
            tbody.appendChild(tr);
            return; // Exit early, don't show Manage button
          }
          
          // Handle 'deleted' status gracefully (shouldn't happen with hard delete, but safety check)
          if (status.status === 'deleted') {
            // Show "Not tracked" + Track button
            const notTrackedBadge = document.createElement("span");
            notTrackedBadge.className = "ranking-badge ranking-badge--segment-general";
            notTrackedBadge.style.marginRight = "0.5rem";
            notTrackedBadge.textContent = "Not tracked";
            notTrackedBadge.title = "No optimisation task exists for this keyword + URL.";
            tdOptimisation.appendChild(notTrackedBadge);
            
            const trackBtn = document.createElement("button");
            trackBtn.className = "btn btn-small";
            trackBtn.style.padding = "0.03rem 0.08rem";
            trackBtn.style.fontSize = "0.35rem";
            trackBtn.style.fontWeight = "550";
            trackBtn.style.background = "#2563eb";
            trackBtn.style.color = "#ffffff";
            trackBtn.style.border = "1px solid #1e40af";
            trackBtn.textContent = "Track";
            trackBtn.title = "Create a task for this keyword + URL and capture baseline metrics.";
            if (!window.hasAdminKey()) {
              trackBtn.disabled = true;
              trackBtn.title = "Admin key required - set your admin key in the configuration section";
              trackBtn.style.opacity = "0.5";
              trackBtn.style.cursor = "not-allowed";
            }
            trackBtn.onclick = (e) => {
              e.stopPropagation();
              if (!window.hasAdminKey()) {
                alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
                return;
              }
              window.openTrackKeywordModal(row, taskType);
            };
            tdOptimisation.appendChild(trackBtn);
            tr.appendChild(tdOptimisation);
            tbody.appendChild(tr);
            return; // Exit early
          }
          
          // Tracked - show status pill + metadata + Manage button
          console.log('[Optimisation] Creating Manage button for tracked keyword:', row.keyword, 'Status:', status);
          const statusBadge = document.createElement("span");
          const statusText = {
            'planned': 'Planned',
            'in_progress': 'In progress',
            'monitoring': 'Monitoring',
            'done': 'Done',
            'paused': 'Paused',
            'cancelled': 'Cancelled'
          }[status.status] || status.status;
          
          // Distinct color scheme for optimization statuses (different from page type badges)
          statusBadge.className = "ranking-badge";
          
          // Apply status-specific colors
          if (status.status === 'planned') {
            // Light lavender - queued/upcoming
            statusBadge.style.background = "#e9d5ff";
            statusBadge.style.color = "#6b21a8";
          } else if (status.status === 'in_progress') {
            // Orange - active work
            statusBadge.style.background = "#fed7aa";
            statusBadge.style.color = "#9a3412";
          } else if (status.status === 'monitoring') {
            // Teal - watching/observing
            statusBadge.style.background = "#a7f3d0";
            statusBadge.style.color = "#065f46";
          } else if (status.status === 'done') {
            // Green - completed successfully
            statusBadge.style.background = "#dcfce7";
            statusBadge.style.color = "#166534";
          } else if (status.status === 'paused') {
            // Grey - on hold
            statusBadge.style.background = "#e5e7eb";
            statusBadge.style.color = "#374151";
          } else if (status.status === 'cancelled') {
            // Red - stopped/error
            statusBadge.style.background = "#fee2e2";
            statusBadge.style.color = "#991b1b";
          } else {
            // Default grey
            statusBadge.style.background = "#f9fafb";
            statusBadge.style.color = "#4b5563";
          }
          statusBadge.textContent = statusText;
          statusBadge.style.marginRight = "0.5rem";
          
          // Add tooltip based on status
          const statusTooltips = {
            'planned': 'Task created but work not started.',
            'in_progress': 'Currently being worked on.',
            'monitoring': 'Changes shippedmonitor metrics.',
            'done': 'Cycle completed; start a new cycle if optimising again.',
            'paused': 'Tracking stopped; you can start a new cycle later.',
            'cancelled': 'Tracking stopped; you can start a new cycle later.'
          };
          statusBadge.title = statusTooltips[status.status] || `Status: ${statusText}`;
          
          tdOptimisation.appendChild(statusBadge);
          
          // Metadata (cycle + last activity)
          const metadataDiv = document.createElement("div");
          metadataDiv.style.fontSize = "0.7rem";
          metadataDiv.style.color = "#64748b";
          metadataDiv.style.marginTop = "0.25rem";
          metadataDiv.style.marginBottom = "0.25rem";
          
          const cycleText = document.createElement("span");
          cycleText.textContent = `Cycle ${status.cycle_active || 1}`;
          cycleText.style.marginRight = "0.5rem";
          metadataDiv.appendChild(cycleText);
          
          if (status.last_activity_at) {
            const lastActivityText = document.createElement("span");
            const lastActivity = new Date(status.last_activity_at);
            const now = new Date();
            const daysAgo = Math.floor((now - lastActivity) / (1000 * 60 * 60 * 24));
            lastActivityText.textContent = daysAgo === 0 ? "Today" : daysAgo === 1 ? "1 day ago" : `${daysAgo} days ago`;
            metadataDiv.appendChild(lastActivityText);
          }
          
          tdOptimisation.appendChild(metadataDiv);
          
          // Manage button
          const manageBtn = document.createElement("button");
          manageBtn.className = "btn btn-small";
          manageBtn.style.padding = "0.15rem 0.4rem";
          manageBtn.style.fontSize = "0.3rem";
          manageBtn.style.fontWeight = "550";
          manageBtn.style.background = "#E5FFCC";
          manageBtn.style.color = "#000000";
          manageBtn.style.border = "1px solid #a3d977";
          manageBtn.textContent = "Manage";
          manageBtn.title = "Open task details, update status, add notes, record measurements, start new cycle.";
          manageBtn.style.position = "relative";
          manageBtn.style.zIndex = "100";
          manageBtn.style.pointerEvents = "auto";
          manageBtn.type = "button"; // Prevent form submission
          
          // Store status and row data on button for access in handler (closure safety)
          const statusId = status.id;
          const statusObj = status;
          const rowData = row;
          const taskTypeValue = taskType;
          
          console.log('[Optimisation] Setting up Manage button onclick, statusId:', statusId);
          
          if (!window.hasAdminKey()) {
            manageBtn.disabled = true;
            manageBtn.title = "Admin key required - set your admin key in the configuration section";
            manageBtn.style.opacity = "0.5";
            manageBtn.style.cursor = "not-allowed";
          }
          
          // Use onclick - simpler and more reliable
          manageBtn.onclick = async function(e) {
            e.stopPropagation();
            e.preventDefault();
            
            if (!window.hasAdminKey()) {
              alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
              return;
            }
            
            if (!statusId) {
              alert('No task ID found. Please try refreshing the page.');
              return;
            }
            
            // Open the drawer with the status ID
            // The drawer function will handle loading tasks if needed and switching tabs
            if (typeof window.openOptimisationTaskDrawer === 'function') {
              try {
                await window.openOptimisationTaskDrawer(statusId);
              } catch (error) {
                console.error('[Optimisation] Error opening drawer:', error);
                // Fallback to modal
                window.openManageOptimisationModal(rowData, statusObj, taskTypeValue);
              }
            } else {
              // Fallback to modal if drawer function doesn't exist
              window.openManageOptimisationModal(rowData, statusObj, taskTypeValue);
            }
          };
          
          tdOptimisation.appendChild(manageBtn);
        }
        
        tr.appendChild(tdOptimisation);

        tbody.appendChild(tr);
        } catch (error) {
          console.error(`[Ranking Table] Error rendering row ${index} for keyword "${row?.keyword || 'unknown'}":`, error);
          // Continue to next row instead of stopping the loop
        }
      });

      // Update sort indicators
      document.querySelectorAll('.ranking-table th.sortable').forEach(th => {
        th.classList.remove('sort-asc', 'sort-desc');
        if (th.dataset.sort === rankingSortState.column) {
          th.classList.add(`sort-${rankingSortState.direction}`);
        }
      });

      // Update pagination controls
      updatePaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx);
      
      // Re-wire sorting after render completes
      wireRankingSorting();

      // Row click  scorecard panel
      tbody.querySelectorAll("tr").forEach(tr => {
        tr.addEventListener("click", async () => {
          tbody.querySelectorAll("tr").forEach(r => r.classList.remove("ranking-table-row--selected"));
          tr.classList.add("ranking-table-row--selected");
          const idx = Number(tr.dataset.index || "-1");
          if (!Number.isNaN(idx) && combinedRows[idx]) {
            const row = combinedRows[idx];
            // Create unique identifier for selected keyword
            selectedKeywordId = `${row.keyword}|${row.best_url || ''}`;
            debugLog(`[RankingAI Scorecard] Row clicked - keyword: "${row.keyword}", selectedKeywordId: "${selectedKeywordId}"`, 'info');
            await renderKeywordScorecard(row);
          }
        });
      });

      // Competitors (use filtered rows)
      renderRankingAiCompetitors(filteredRows);
      
      // Insights (use all rows for global insights across all tracked keywords)
      renderRankingAiInsights(combinedRows, summary);
    }
    
    function updatePaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx) {
      const paginationControls = document.getElementById("ranking-pagination-controls");
      const paginationInfo = document.getElementById("ranking-pagination-info");
      const pageInfo = document.getElementById("ranking-pagination-page-info");
      const firstBtn = document.getElementById("ranking-pagination-first");
      const prevBtn = document.getElementById("ranking-pagination-prev");
      const nextBtn = document.getElementById("ranking-pagination-next");
      const lastBtn = document.getElementById("ranking-pagination-last");
      const rowsPerPageSelect = document.getElementById("ranking-rows-per-page");
      
      if (!paginationControls) return;
      
      if (totalRows === 0) {
        paginationControls.style.display = "none";
        return;
      }
      
      paginationControls.style.display = "flex";
      
      if (paginationInfo) {
        paginationInfo.textContent = `Showing ${startIdx + 1}-${endIdx} of ${totalRows}`;
      }
      
      if (pageInfo) {
        pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
      }
      
      if (firstBtn) {
        firstBtn.disabled = currentPage === 1;
      }
      if (prevBtn) {
        prevBtn.disabled = currentPage === 1;
      }
      if (nextBtn) {
        nextBtn.disabled = currentPage === totalPages;
      }
      if (lastBtn) {
        lastBtn.disabled = currentPage === totalPages;
      }
      
      if (rowsPerPageSelect) {
        rowsPerPageSelect.value = rankingPaginationState.rowsPerPage;
      }
    }

    /**
     * Render Keyword Scorecard Panel
     * @param {Object} row - Keyword row from combinedRows
     */
    async function renderKeywordScorecard(row) {
      const emptyEl = document.getElementById("ranking-ai-detail-empty");
      const contentEl = document.getElementById("ranking-ai-detail-content");
      if (!emptyEl || !contentEl) return;

      if (!row) {
        emptyEl.hidden = false;
        contentEl.hidden = true;
        emptyEl.textContent = "Select a keyword in the table or a cell in the priority grid to see a detailed scorecard.";
        
        // Hide citations section
        const citationsEmpty = document.getElementById("ranking-ai-citations-empty");
        const citationsContent = document.getElementById("ranking-ai-citations-content");
        if (citationsEmpty) citationsEmpty.hidden = false;
        if (citationsContent) citationsContent.hidden = true;
        
        return;
      }

      const scorecardData = buildKeywordScorecardData(row);
      if (!scorecardData) {
        emptyEl.hidden = false;
        contentEl.hidden = true;
        return;
      }
      
      // Fetch authority context for authority-building block (v1.4)
      const authorityContext = await fetchRankingAiAuthorityContext();
      const authorityPriority = authorityContext?.authorityPriority ?? null;
      const domainStrength = authorityContext?.domainStrength ?? null;

      debugLog(`[RankingAI Scorecard] Rendering scorecard for keyword: "${scorecardData.keyword}"`, 'info');
      debugLog(`[RankingAI Scorecard] Demand: ${scorecardData.demand_level}, Rank: ${scorecardData.rank_bucket_label}, AI: ${scorecardData.ai_status}, Priority: ${scorecardData.priority_level}`, 'info');

      emptyEl.hidden = true;
      contentEl.hidden = false;

      // Apply RAG color class to content element based on priority
      contentEl.classList.remove('scorecard-priority-high', 'scorecard-priority-medium', 'scorecard-priority-low');
      if (scorecardData.priority_level === 'High') {
        contentEl.classList.add('scorecard-priority-high');
      } else if (scorecardData.priority_level === 'Medium') {
        contentEl.classList.add('scorecard-priority-medium');
      } else {
        contentEl.classList.add('scorecard-priority-low');
      }

      // Build HTML for scorecard
      let html = '';

      // Impact & Difficulty summary line (under card header) - RAG color-coded
      const impactLabel = scorecardData.impact_bucket.charAt(0).toUpperCase() + scorecardData.impact_bucket.slice(1);
      const difficultyLabel = scorecardData.difficulty_bucket.charAt(0).toUpperCase() + scorecardData.difficulty_bucket.slice(1);
      const priorityLabel = scorecardData.priority_level;
      
      // RAG colors for each level
      const getRagColor = (level) => {
        const lower = level.toLowerCase();
        if (lower === 'high') return '#ef4444'; // Red
        if (lower === 'medium') return '#f59e0b'; // Amber
        return '#10b981'; // Green (Low)
      };
      
      const impactColor = getRagColor(impactLabel);
      const difficultyColor = getRagColor(difficultyLabel);
      const priorityColor = getRagColor(priorityLabel);
      
      // Opportunity Score (under header title, in same section as Impact/Difficulty/Priority)
      const oppScore = scorecardData.opportunity_score ?? null;
      let oppColor = '#b91c1c'; // Red (Low)
      let oppClass = 'low';
      if (oppScore != null) {
        if (oppScore >= 70) {
          oppColor = '#166534'; // Green (High)
          oppClass = 'high';
        } else if (oppScore >= 40) {
          oppColor = '#92400e'; // Amber (Medium)
          oppClass = 'medium';
        }
      }
      
      html += `<div style="margin-bottom: 1.25rem; padding-bottom: 0.75rem; border-bottom: 1px solid #e5e7eb;">`;
      if (oppScore != null) {
        html += `<p style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: ${oppColor}; line-height: 1.4;">`;
        html += `Keyword opportunity score: <span style="color: ${oppColor};">${oppScore}/100</span>`;
        html += ` <span title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10; Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10; Classic ranking strength (page 1 vs page 2+ and current position).&#10; AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first." style="opacity: 0.6; cursor: help; font-size: 0.875rem;"></span>`;
        html += `</p>`;
      }
      html += `<p style="margin: 0; font-size: 1.1rem; font-weight: 700; color: #1e293b; line-height: 1.4;">`;
      html += `<span>Impact: <span style="color: ${impactColor};">${impactLabel}</span></span>  `;
      html += `<span>Difficulty: <span style="color: ${difficultyColor};">${difficultyLabel}</span></span>  `;
      html += `<span>Priority: <span style="color: ${priorityColor};">${priorityLabel}</span></span>`;
      html += `</p>`;
      
      // Add derived summary sentence
      const summarySentence = generateKeywordSummary(scorecardData);
      html += `<p style="margin: 0.5rem 0 0 0; font-size: 0.875rem; font-weight: 400; color: #64748b; line-height: 1.5;">${summarySentence}</p>`;
      html += `</div>`;

      // Keyword & URL header - Keyword as prominent nameplate
      html += `<div style="margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 2px solid #e5e7eb;">`;
      // Keyword nameplate - large and prominent
      html += `<div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-left: 6px solid #f59e0b; padding: 1.25rem 1.5rem; margin-bottom: 1rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);">`;
      html += `<h4 style="font-size: 1.75rem; font-weight: 800; color: #92400e; margin: 0; letter-spacing: 0.02em; line-height: 1.2;">${scorecardData.keyword}</h4>`;
      html += `</div>`;
      // Use canonical targetUrl for display
      const displayUrl = scorecardData.targetUrl || scorecardData.ranking_url || '';
      if (displayUrl) {
        html += `<p style="margin: 0.25rem 0; font-size: 0.875rem;"><a href="${displayUrl}" target="_blank" rel="noopener noreferrer" style="color: #0284c7; text-decoration: none;">${displayUrl}</a></p>`;
      }
      html += `<div style="display: flex; gap: 1rem; margin-top: 0.5rem; flex-wrap: wrap;">`;
      html += `<span class="ranking-badge ${scorecardData.segment === 'money' ? 'ranking-badge--segment-money' : scorecardData.segment === 'education' ? 'ranking-badge--segment-education' : scorecardData.segment === 'brand' ? 'ranking-badge--segment-brand' : 'ranking-badge--segment-general'}" style="font-size: 0.875rem;">${scorecardData.segment || 'Other'}</span>`;
      html += `<span style="font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">${scorecardData.page_type}</span>`;
      html += `</div>`;
      
      // Grey meta line (under chips)
      const metaParts = [];
      if (row.best_rank_group != null) {
        metaParts.push(`Classic rank: #${row.best_rank_group}`);
      } else {
        metaParts.push("Classic rank: not in top 50");
      }
      if (row.has_ai_overview) {
        const total = row.ai_total_citations || 0;
        const ours = row.ai_alan_citations_count || 0;
        metaParts.push(`AI Overview: present (${ours}/${total || "?"} citations from alanranger.com)`);
      } else {
        metaParts.push("AI Overview: not present");
      }
      const segLabel = row.segment === "money" ? "Money page (commercial intent)" :
                      row.segment === "education" ? "Education content" :
                      row.segment === "brand" ? "Brand query" : "General / other";
      metaParts.push(`Segment: ${segLabel}`);
      html += `<p style="margin: 0.5rem 0 0 0; font-size: 0.875rem; color: #3d3d3d; line-height: 1.6; font-weight: 400;">${metaParts.join("  ")}</p>`;
      html += `</div>`;

      // Priority & Next Actions (moved to top, before Demand and Classic ranking)
      html += `<div class="scorecard-section" style="background: #fcfcfc !important;">`;
      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">Priority & Next Actions</h5>`;
      const priorityBg = scorecardData.priority_level === 'High' ? '#fef2f2' : 
                        scorecardData.priority_level === 'Medium' ? '#fffbeb' : '#f0fdf4';
      const priorityBorder = scorecardData.priority_level === 'High' ? '#ef4444' : 
                            scorecardData.priority_level === 'Medium' ? '#f59e0b' : '#10b981';
      html += `<p style="margin-bottom: 0.75rem; font-size: 0.875rem; color: #3d3d3d; line-height: 1.6; font-weight: 400;">Overall priority: <span style="padding: 0.25rem 0.5rem; border-radius: 4px; font-weight: 600; background: ${priorityBg}; border-left: 3px solid ${priorityBorder}; color: #1e293b;">${scorecardData.priority_level}</span></p>`;
      
      // Authority-building block (v1.4: Domain Strength integration)
      const opportunityScore = scorecardData.opportunity_score ?? 0;
      const currentRank = scorecardData.best_rank_group ?? null;
      const isAuthorityLimited = authorityPriority === 'high' && 
                                 opportunityScore >= 60 && 
                                 (currentRank === null || currentRank > 10);
      
      if (isAuthorityLimited) {
        html += `<div style="margin-bottom: 1rem; padding: 0.75rem; background: #fef3c7; border-left: 3px solid #f59e0b; border-radius: 4px;">`;
        html += `<h6 style="font-size: 0.875rem; font-weight: 600; color: #92400e; margin: 0 0 0.5rem 0;">Authority & external signals</h6>`;
        html += `<ul style="margin: 0; padding-left: 1.25rem; list-style-type: disc; font-size: 0.875rem; line-height: 1.6; color: #3d3d3d; font-weight: 400;">`;
        const domainStrengthScore = domainStrength?.score ?? null;
        const scoreText = domainStrengthScore !== null ? `~${domainStrengthScore.toFixed(1)}` : 'unknown';
        const bandText = domainStrength?.band ?? 'unknown';
        html += `<li style="margin-bottom: 0.25rem;">Overall domain strength is currently ${bandText} (score ${scoreText}).</li>`;
        html += `<li style="margin-bottom: 0.25rem;">For this high-impact keyword on page 2+, focus on authority-building: relevant backlinks, citations, PR, and mentions from trusted sites in the same topic.</li>`;
        html += `</ul>`;
        html += `</div>`;
      } else if (authorityPriority === 'medium' && opportunityScore >= 60 && (currentRank === null || currentRank > 10)) {
        // Medium priority - softer wording
        html += `<div style="margin-bottom: 1rem; padding: 0.75rem; background: #fef3c7; border-left: 3px solid #f59e0b; border-radius: 4px;">`;
        html += `<h6 style="font-size: 0.875rem; font-weight: 600; color: #92400e; margin: 0 0 0.5rem 0;">Authority & external signals</h6>`;
        html += `<ul style="margin: 0; padding-left: 1.25rem; list-style-type: disc; font-size: 0.875rem; line-height: 1.6; color: #1e293b;">`;
        const domainStrengthScore = domainStrength?.score ?? null;
        const scoreText = domainStrengthScore !== null ? `~${domainStrengthScore.toFixed(1)}` : 'unknown';
        html += `<li style="margin-bottom: 0.25rem;">Domain strength is moderate (score ${scoreText}). Also consider authority-building alongside on-page improvements for this high-impact keyword.</li>`;
        html += `</ul>`;
        html += `</div>`;
      }
      
      const actions = generateActionBullets(scorecardData);
      // Always show 3 bullets (function now guarantees 3)
      html += `<ul style="margin: 0; padding-left: 1.5rem; list-style-type: disc; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">`;
      actions.forEach(action => {
        html += `<li style="margin-bottom: 0.5rem; color: #3d3d3d;">${action}</li>`;
      });
      html += `</ul>`;
      html += `</div>`;

      // 1. Target page totals and 2. Classic ranking - side by side with equal height/width/padding
      html += `<div style="display: flex; gap: 1rem; margin-bottom: 1.0rem; align-items: stretch;">`;
      
      // 1. Target page totals (left half) - page-only GSC data
      html += `<div class="scorecard-section" style="flex: 1 1 50%; min-width: 0; display: flex; flex-direction: column; height: 100%;">`;
      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">1. Target page totals (GSC, 28d) <span title="All queries to this page, last 28 days (matches GSC Pages tab with no query filter)." style="opacity: 0.6; cursor: help; font-size: 0.75rem;"></span></h5>`;
      // Display target page URL (clickable) - use canonical targetUrl
      const canonicalUrl = scorecardData.targetUrl || scorecardData.ranking_url || '';
      if (canonicalUrl) {
        // URL is already canonicalized, just use it directly
        const cleanUrl = canonicalUrl;
        html += `<div style="margin-bottom: 0.75rem; padding-left: 0.75rem;">`;
        html += `<div style="font-size: 0.8125rem; color: #64748b; margin-bottom: 0.25rem;">Target page (all queries):</div>`;
        html += `<a href="${canonicalUrl}" target="_blank" rel="noopener noreferrer" style="font-size: 0.8125rem; color: #2563eb; text-decoration: underline; word-break: break-all; display: inline-block; max-width: 100%;" title="Open target page in new tab">${cleanUrl}</a>`;
        html += `<div style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem;" title="Totals for this page across all search queries (not just this keyword)."> Totals for this page across all search queries (not just this keyword).</div>`;
        html += `</div>`;
      }
      html += `<div style="padding-left: 0.75rem;" id="scorecard-page-totals-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}">`;
      html += `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">Loading page totals...</div>`;
      html += `</div></div>`;

      // 2. Classic ranking (right half)
      html += `<div class="scorecard-section" style="flex: 1 1 50%; min-width: 0; display: flex; flex-direction: column; height: 100%;">`;
      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">2. Classic ranking</h5>`;
      html += `<div style="padding-left: 0.75rem;">`;
      let rankText = '';
      if (scorecardData.best_rank_group != null) {
        const rankBucket = scorecardData.rank_bucket || scorecardData.rank_bucket_label || '';
        // Format: "Currently ranking #24 (page 2+ / Not ranked)"
        if (rankBucket === 'top3' || rankBucket === 'page 1') {
          rankText = `Currently ranking #${scorecardData.best_rank_group} (page 1)`;
        } else if (rankBucket === 'top10' || rankBucket === 'page 1') {
          rankText = `Currently ranking #${scorecardData.best_rank_group} (page 1)`;
        } else if (rankBucket === 'page2plus' || rankBucket === 'beyond page 2') {
          rankText = `Currently ranking #${scorecardData.best_rank_group} (page 2+)`;
        } else {
          rankText = `Currently ranking #${scorecardData.best_rank_group} (${rankBucket || 'beyond page 2'})`;
        }
      } else {
        rankText = 'Currently ranking (beyond page 2 / Not ranked)';
      }
      html += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.8125rem; line-height: 1.5; color: #1e293b; font-weight: 400;">${rankText}</div>`;
      const strengthClass = scorecardData.position_strength === 'Strong' ? 'status-green' : 
                         scorecardData.position_strength === 'OK' ? 'status-amber' : 'status-red';
      const strengthBg = scorecardData.position_strength === 'Strong' ? '#f0fdf4' : 
                        scorecardData.position_strength === 'OK' ? '#fffbeb' : '#fef2f2';
      const strengthBorder = scorecardData.position_strength === 'Strong' ? '#10b981' : 
                            scorecardData.position_strength === 'OK' ? '#f59e0b' : '#ef4444';
      html += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.5; color: #3d3d3d; font-weight: 400;">Position strength: <span style="padding: 0.25rem 0.5rem; border-radius: 4px; font-weight: 600; background: ${strengthBg}; border-left: 3px solid ${strengthBorder}; color: #1e293b;">${scorecardData.position_strength}</span></div>`;
      html += `</div></div>`;
      
      html += `</div>`; // Close flex container

      // 3. CTR & snippet (query-only)
      html += `<div class="scorecard-section">`;
      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">3. CTR & snippet (GSC, 28d) <span title="Query-only totals for this keyword (matches GSC Queries tab)." style="opacity: 0.6; cursor: help; font-size: 0.75rem;"></span></h5>`;
      html += `<div style="padding-left: 0.75rem;">`;
      
      // Get query-only totals from queryTotals
      const queryTotal = getQueryTotalForKeyword(scorecardData.keyword);
      
      // Only show CTR if impressions > 0 (CTR requires impressions)
      if (queryTotal && queryTotal.impressions > 0 && queryTotal.ctr != null) {
        // Real CTR data available (query-only)
        // queryTotal.ctr is already a percentage (0-100) from API, not a decimal
        const ctrPercent = queryTotal.ctr.toFixed(1);
        const impressionsFormatted = queryTotal.impressions.toLocaleString();
        const clicksFormatted = queryTotal.clicks.toLocaleString();
        const positionBucket = getPositionBucket(scorecardData.best_rank_group);
        const ctrBenchmark = getCtrBenchmarkForPosition(positionBucket);
        const benchmarkPercent = (ctrBenchmark * 100).toFixed(1);
        
        // Determine CTR performance label
        let ctrPerformance = 'OK';
        let ctrPerformanceColor = '#f59e0b'; // Amber
        let ctrPerformanceBg = '#fffbeb';
        if (queryTotal.ctr >= ctrBenchmark * 1.1) {
          ctrPerformance = 'Strong';
          ctrPerformanceColor = '#10b981'; // Green
          ctrPerformanceBg = '#f0fdf4';
        } else if (queryTotal.ctr < ctrBenchmark * 0.8) {
          ctrPerformance = 'Weak';
          ctrPerformanceColor = '#ef4444'; // Red
          ctrPerformanceBg = '#fef2f2';
        }
        
        html += `<div style="margin-bottom: 0.75rem;">`;
        html += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">`;
        html += `<span>CTR (last 28 days): <strong style="color: #1e293b;">${ctrPercent}%</strong></span>`;
        html += `<span></span>`;
        html += `<span>Impressions: <strong style="color: #1e293b;">${impressionsFormatted}</strong></span>`;
        html += `<span></span>`;
        html += `<span>Clicks: <strong style="color: #1e293b;">${clicksFormatted}</strong></span>`;
        html += `<span style="font-size: 0.75rem; color: #64748b;">(query-only)</span>`;
        html += `</div>`;
        html += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">`;
        html += `<span>Expected CTR at this position: <strong style="color: #64748b;">${benchmarkPercent}%</strong> <span title="Heuristic benchmark based on rank position (not from GSC)." style="opacity: 0.6; cursor: help; font-size: 0.75rem;"></span></span>`;
        html += `</div>`;
        html += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.75rem;">`;
        html += `<span style="font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">CTR performance: <span style="padding: 0.25rem 0.5rem; border-radius: 4px; font-weight: 600; background: ${ctrPerformanceBg}; border-left: 3px solid ${ctrPerformanceColor}; color: #1e293b;">${ctrPerformance}</span></span>`;
        html += `</div>`;
        html += `</div>`;
        
        // Explanatory text based on performance
        if (ctrPerformance === 'Weak') {
          html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">CTR is weak for this position. Improving the snippet (title, meta description and rich results) should unlock more clicks for this keyword.</p>`;
        } else if (ctrPerformance === 'Strong') {
          html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">CTR is in line with expectations for this position. Further gains are more likely to come from improving rank (links and authority) than snippet tweaks alone.</p>`;
        } else {
          // OK performance
          html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">CTR is in line with expectations for this position. Further gains are more likely to come from improving rank (links and authority) than snippet tweaks alone.</p>`;
        }
      } else {
        // No query-only data found for last 28 days
        html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">No query-only totals returned for this keyword in the last 28 days.</p>`;
      }
      html += `</div></div>`;
      
      // Advanced: Pages with impressions for this keyword (querypages breakdown)
      html += `<div class="scorecard-section" style="margin-top: 1rem;">`;
      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">Advanced: Pages with impressions for this keyword (GSC) <span title="Pages with impressions for this keyword (GSC querypages breakdown)." style="opacity: 0.6; cursor: help; font-size: 0.75rem;"></span></h5>`;
      html += `<div style="padding-left: 0.75rem;" id="scorecard-query-pages-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}">`;
      html += `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">Loading pages breakdown...</div>`;
      html += `</div></div>`;

      // 4. Schema & rich results
      html += `<div class="scorecard-section" data-scorecard-section="schema">`;
      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">4. Schema & rich results</h5>`;
      html += `<div style="padding-left: 0.75rem;">`;
      
      // Get schema coverage if available
      // Try to use the async getSchemaCoverageForUrl function which handles Supabase fallback
      let schemaCoverage = null;
      let schemaSummary = null;
      try {
        // First try sync (localStorage) for immediate display
        const savedAudit = loadAuditResultsSync();
        if (savedAudit && savedAudit.schemaAudit && savedAudit.schemaAudit.data) {
          const schemaData = savedAudit.schemaAudit.data;
          // Lightweight debug for the object used in this card
          try {
            const pagesWithSchemaCount = Array.isArray(schemaData.pagesWithSchema)
              ? schemaData.pagesWithSchema.length
              : (typeof schemaData.pagesWithSchema === 'number' ? schemaData.pagesWithSchema : 0);
            const totalPagesCount = typeof schemaData.totalPages === 'number'
              ? schemaData.totalPages
              : (Array.isArray(schemaData.pages) ? schemaData.pages.length : 0);
            const coveragePct = (typeof schemaData.coverage === 'number' && !Number.isNaN(schemaData.coverage))
              ? schemaData.coverage
              : (totalPagesCount > 0 ? (pagesWithSchemaCount / totalPagesCount) * 100 : 0);

            const allTypes = new Set();
            if (Array.isArray(schemaData.allDetectedTypes)) {
              schemaData.allDetectedTypes.forEach(t => t && allTypes.add(t));
            } else if (Array.isArray(schemaData.schemaTypes)) {
              schemaData.schemaTypes.forEach(item => {
                if (typeof item === 'string') allTypes.add(item);
                else if (item && typeof item === 'object' && item.type) allTypes.add(item.type);
              });
            }

            schemaSummary = {
              pagesWithSchemaCount,
              totalPagesCount,
              coveragePct,
              uniqueTypesCount: allTypes.size
            };

            debugLog(
              `Ranking&AI schemaAuditForCard: totalPages=${totalPagesCount}, pagesWithSchema=${pagesWithSchemaCount}, coverage=${coveragePct.toFixed(1)}%, uniqueTypes=${allTypes.size}`,
              'info'
            );
          } catch (e) {
            // Ignore summary extraction errors; per-page logic may still work
          }
          
          // PRIORITY: Check pages first (original array from schema audit API - most reliable)
          // Then check pagesWithSchema ONLY if it's an array (from Supabase schema_pages_detail)
          // Note: pagesWithSchema might be a number (count) instead of an array
          let pagesArray = null;
          if (Array.isArray(schemaData.pages) && schemaData.pages.length > 0) {
            pagesArray = schemaData.pages;
            debugLog('[Schema Coverage] Using schemaData.pages array (' + pagesArray.length + ' pages)', 'info');
          } else if (Array.isArray(schemaData.pagesWithSchema) && schemaData.pagesWithSchema.length > 0) {
            pagesArray = schemaData.pagesWithSchema;
            debugLog('[Schema Coverage] Using schemaData.pagesWithSchema array from Supabase (' + pagesArray.length + ' pages)', 'info');
          } else {
            debugLog('[Schema Coverage] No pages array found. pages=' + typeof schemaData.pages + ' (isArray=' + Array.isArray(schemaData.pages) + '), pagesWithSchema=' + typeof schemaData.pagesWithSchema + ' (isArray=' + Array.isArray(schemaData.pagesWithSchema) + ')', 'warn');
          }
          
          if (pagesArray && pagesArray.length > 0) {
            // Normalize URL: remove query params and trailing slashes for matching
            const rankingUrl = scorecardData.ranking_url || '';
            const normalizedUrl = normalizeUrlForMatching(rankingUrl);
            
            debugLog('[Schema Coverage] Looking for URL: ' + normalizedUrl + ' (original: ' + rankingUrl + ')', 'info');
            
            // Fallback matching: some ranking URLs include redirect/variant slugs (e.g. "121" vs "1-2-1")
            // If exact pathname match fails, compare a "loose" slug that strips non-alphanumerics.
            const normalizeLooseSlug = (pathname) => {
              const p = (pathname || '').toString().toLowerCase().trim();
              const last = p.split('/').filter(Boolean).pop() || '';
              return last.replace(/[^a-z0-9]/g, '');
            };
            const normalizedLoose = normalizeLooseSlug(normalizedUrl);
            
            // Exact matching only - normalize both URLs identically (strips query params, hash, trailing slashes)
            let looseMatchedUrl = null;
            const pageData = pagesArray.find(p => {
              if (!p || !p.url) return false;
              const pNormalized = normalizeUrlForMatching(p.url);
              
              // Exact match after normalization (both URLs stripped of query params, hash, trailing slashes)
              const exactMatch = pNormalized === normalizedUrl;
              
              // For homepage, also check if both are '/' or empty
              const homepageMatch = (normalizedUrl === '/' || normalizedUrl === '') && (pNormalized === '/' || pNormalized === '');
              
              if (exactMatch || homepageMatch) {
                debugLog('[Schema Coverage]  Exact URL match: ' + p.url + ' -> ' + pNormalized + ' (search: ' + normalizedUrl + ')', 'info');
                return true;
              }

              // Fallback: loose slug match (handles minor slug variants)
              if (!exactMatch && normalizedLoose) {
                const pLoose = normalizeLooseSlug(pNormalized);
                if (pLoose && pLoose === normalizedLoose) {
                  looseMatchedUrl = p.url;
                  debugLog('[Schema Coverage]  Loose slug match: ' + p.url + ' -> ' + pNormalized + ' (search: ' + normalizedUrl + ')', 'warn');
                  return true;
                }
              }
              return false;
            });
            
            if (pageData) {
              debugLog('[Schema Coverage]  Found page data for URL: ' + scorecardData.ranking_url, 'info');
              debugLog('[Schema Coverage] Matched page URL: ' + (pageData.url || 'missing'), 'info');
              if (looseMatchedUrl) {
                debugLog('[Schema Coverage] Note: match used loose slug fallback (ranking URL likely redirected or variant slug).', 'warn');
              }
              if (pageData.schemaTypes) {
                const schemaTypes = Array.isArray(pageData.schemaTypes) ? pageData.schemaTypes : [];
                const typeStrings = schemaTypes.map(t => {
                  if (typeof t === 'string') return t.toLowerCase();
                  if (t && typeof t === 'object' && t.type) return String(t.type).toLowerCase();
                  return String(t).toLowerCase();
                });
                const typeDisplay = schemaTypes.map(t => {
                  if (typeof t === 'string') return t;
                  if (t && typeof t === 'object' && t.type) return t.type;
                  return String(t);
                }).join(', ');
                debugLog('[Schema Coverage] Schema types found (' + schemaTypes.length + '): ' + typeDisplay, 'info');
                schemaCoverage = {
                  hasFAQ: typeStrings.some(t => t.includes('faq') || t === 'faqpage'),
                  hasHowTo: typeStrings.some(t => t.includes('howto') || t === 'howto'),
                  hasEvent: typeStrings.some(t => t.includes('event') && !t.includes('product')),
                  hasProduct: typeStrings.some(t => t.includes('product')),
                  hasBreadcrumb: typeStrings.some(t => t.includes('breadcrumb') || t === 'breadcrumblist'),
                  hasImageObject: typeStrings.some(t => t.includes('image') || t === 'imageobject')
                };
                debugLog('[Schema Coverage] Coverage result: ' + JSON.stringify(schemaCoverage), 'info');
              } else {
                debugLog('[Schema Coverage]  Page data found but no schemaTypes property', 'warn');
                debugLog('[Schema Coverage] Page data keys: ' + Object.keys(pageData).join(', '), 'warn');
              }
            } else {
              debugLog('[Schema Coverage]  No page data found for URL: ' + scorecardData.ranking_url, 'warn');
              debugLog('[Schema Coverage] Normalized search URL: ' + normalizedUrl, 'warn');
              if (pagesArray && pagesArray.length > 0) {
                debugLog('[Schema Coverage] Sample URLs in pages array (first 3):', 'warn');
                pagesArray.slice(0, 3).forEach((p, i) => {
                  let pNorm = (p.url || '').toLowerCase().trim();
                  try {
                    const pUrlObj = p.url ? new URL(p.url) : null;
                    if (pUrlObj) {
                      pNorm = pUrlObj.pathname.toLowerCase().replace(/\/$/, '').trim();
                    }
                  } catch (e) {}
                  debugLog(`  ${i + 1}. ${p.url} -> ${pNorm}`, 'warn');
                });
              }
            }
          } else {
            debugLog('[Schema Coverage] No pages array available in schemaData', 'warn');
            debugLog('[Schema Coverage] This usually means the schema audit hasn\'t been run yet, or the data is missing from localStorage/Supabase.', 'info');
          }
        } else {
          debugLog('[Schema Coverage] No schemaAudit.data in saved audit, trying async fetch...', 'warn');
        }
        
        // Always try async fetch to ensure we have the latest schema data
        // This will update the schema section even if sync data was found
        if (typeof getSchemaCoverageForUrl === 'function' && scorecardData.ranking_url) {
          getSchemaCoverageForUrl(scorecardData.ranking_url).then(coverage => {
            // Re-render just the schema section
            const schemaSection = contentEl.querySelector('[data-scorecard-section="schema"]');
            if (schemaSection) {
              let schemaHtml = '';
              schemaHtml += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">4. Schema & rich results</h5>`;
              schemaHtml += `<div style="padding-left: 0.75rem;">`;
              
              if (coverage) {
                schemaHtml += `<div style="margin-bottom: 0.75rem;">`;
                schemaHtml += `<div style="font-size: 0.875rem; color: #1e293b; margin-bottom: 0.5rem; font-weight: 500;">Schema coverage for this page:</div>`;
                schemaHtml += `<div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.875rem; color: #1e293b;">`;
                schemaHtml += `<span>FAQ: ${coverage.hasFAQ ? '' : ''}</span>`;
                schemaHtml += `<span>HowTo: ${coverage.hasHowTo ? '' : ''}</span>`;
                schemaHtml += `<span>Event/Product: ${(coverage.hasEvent || coverage.hasProduct) ? '' : ''}</span>`;
                schemaHtml += `<span>Breadcrumb: ${coverage.hasBreadcrumb ? '' : ''}</span>`;
                schemaHtml += `<span>ImageObject: ${coverage.hasImageObject ? '' : ''}</span>`;
                schemaHtml += `</div></div>`;
                
                let schemaInterpretation = '';
                if (scorecardData.segment && scorecardData.segment.toLowerCase() === 'education' && !coverage.hasFAQ) {
                  schemaInterpretation = 'This education page has no FAQ schema. Adding an FAQ block could help snippet richness for this keyword.';
                } else if ((scorecardData.page_type === 'Event' || scorecardData.page_type === 'Product') && !coverage.hasEvent && !coverage.hasProduct) {
                  schemaInterpretation = 'This looks like a money page but no Event/Product schema was detected. Adding Event or Product schema could improve visibility in commercial results.';
                } else if (coverage.hasFAQ && (coverage.hasEvent || coverage.hasProduct) && coverage.hasBreadcrumb) {
                  schemaInterpretation = 'Core schema types are already present for this page. Further gains are more likely to come from authority/behaviour than new schema types.';
                } else {
                  schemaInterpretation = 'Some schema types are present. Review the Content/Schema pillar for a complete assessment.';
                }
                schemaHtml += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">${schemaInterpretation}</p>`;
                debugLog('[Schema Coverage]  Updated schema section with async data', 'success');
              } else {
                // No coverage data found - show helpful message explaining data coverage gap
                const rankingUrl = scorecardData.ranking_url || 'unknown';
                const normalizedUrl = normalizeUrlForMatching(rankingUrl);
                debugLog(`[Schema Coverage]  No schema audit data found for ranking URL: ${rankingUrl} (normalized: ${normalizedUrl})`, 'warn');
                debugLog(`[Schema Coverage] This usually means the URL wasn't in the last schema crawl. The page may have schema, but it wasn't scanned in the most recent audit.`, 'info');
                schemaHtml += `<p style="color: #1e293b; font-size: 0.8125rem; line-height: 1.6; font-weight: 400;">Schema coverage data not available for this URL. This usually means the URL wasn't included in the last schema crawl. Check the Content/Schema pillar for a full schema audit, or run a new schema audit to include this page.</p>`;
              }
              
              schemaHtml += `</div></div>`;
              schemaSection.innerHTML = schemaHtml;
            }
          }).catch(err => {
            const rankingUrl = scorecardData.ranking_url || 'unknown';
            debugLog(`[Schema Coverage] Async fetch failed for URL ${rankingUrl}: ${err.message}`, 'warn');
            debugLog(`[Schema Coverage] This usually means the URL wasn't in the last schema crawl. The page may have schema, but it wasn't scanned in the most recent audit.`, 'info');
            // Update the loading message to show error
            const schemaSection = contentEl.querySelector('[data-scorecard-section="schema"]');
            if (schemaSection) {
              const loadingMsg = schemaSection.querySelector('[id^="schema-coverage-loading-"]');
              if (loadingMsg) {
                loadingMsg.textContent = 'Unable to load schema coverage. This usually means the URL wasn\'t included in the last schema crawl. Check the Content/Schema pillar for a full schema audit, or run a new schema audit to include this page.';
              }
            }
          });
        }
      } catch (e) {
        debugLog('[Schema Coverage] Error in sync check: ' + e.message, 'warn');
      }
      
      if (schemaCoverage) {
        // Show checklist
        html += `<div style="margin-bottom: 0.75rem;">`;
        html += `<div style="font-size: 0.875rem; color: #3d3d3d; margin-bottom: 0.5rem; font-weight: 500;">Schema coverage for this page:</div>`;
        html += `<div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">`;
        html += `<span>FAQ: ${schemaCoverage.hasFAQ ? '' : ''}</span>`;
        html += `<span>HowTo: ${schemaCoverage.hasHowTo ? '' : ''}</span>`;
        html += `<span>Event/Product: ${(schemaCoverage.hasEvent || schemaCoverage.hasProduct) ? '' : ''}</span>`;
        html += `<span>Breadcrumb: ${schemaCoverage.hasBreadcrumb ? '' : ''}</span>`;
        html += `<span>ImageObject: ${schemaCoverage.hasImageObject ? '' : ''}</span>`;
        html += `</div>`;
        html += `</div>`;
        
        // Interpretation based on schema coverage
        let schemaInterpretation = '';
        if (scorecardData.segment && scorecardData.segment.toLowerCase() === 'education' && !schemaCoverage.hasFAQ) {
          schemaInterpretation = 'This education page has no FAQ schema. Adding an FAQ block could help snippet richness for this keyword.';
        } else if ((scorecardData.page_type === 'Event' || scorecardData.page_type === 'Product') && !schemaCoverage.hasEvent && !schemaCoverage.hasProduct) {
          schemaInterpretation = 'This looks like a money page but no Event/Product schema was detected. Adding Event or Product schema could improve visibility in commercial results.';
        } else if (schemaCoverage.hasFAQ && (schemaCoverage.hasEvent || schemaCoverage.hasProduct) && schemaCoverage.hasBreadcrumb) {
          schemaInterpretation = 'Core schema types are already present for this page. Further gains are more likely to come from authority/behaviour than new schema types.';
        } else {
          schemaInterpretation = 'Some schema types are present. Review the Content/Schema pillar for a complete assessment.';
        }
        html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">${schemaInterpretation}</p>`;
      } else if (schemaSummary && schemaSummary.totalPagesCount > 0) {
        // We have schema audit snapshot, but no per-URL schemaTypes mapping available for this keyword URL
        html += `<div style="margin-bottom: 0.75rem;">`;
        html += `<div style="font-size: 0.875rem; color: #3d3d3d; margin-bottom: 0.5rem; font-weight: 500;">Site-wide schema snapshot (from latest audit):</div>`;
        html += `<div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.875rem; color: #3d3d3d; font-weight: 400;">`;
        html += `<span>Coverage: <strong>${schemaSummary.coveragePct.toFixed(1)}%</strong></span>`;
        html += `<span></span>`;
        html += `<span>Pages with schema: <strong>${schemaSummary.pagesWithSchemaCount.toLocaleString()}</strong> / ${schemaSummary.totalPagesCount.toLocaleString()}</span>`;
        if (schemaSummary.uniqueTypesCount > 0) {
          html += `<span></span>`;
          html += `<span>Types detected: <strong>${schemaSummary.uniqueTypesCount}</strong></span>`;
        }
        html += `</div>`;
        html += `</div>`;
        html += `<p style="color: #64748b; font-size: 0.875rem; line-height: 1.5;">Per-page schema types arent available for this specific URL in the current snapshot. Run a fresh schema crawl (or include this URL in the crawl set) to get URL-level rich-result flags here.</p>`;
      } else {
        // Show loading state if async fetch is in progress, otherwise show fallback
        // The async fetch will update this section if data is found
        const rankingUrl = scorecardData.ranking_url || 'unknown';
        debugLog(`[Schema Coverage] No schema data found in sync check for URL: ${rankingUrl}. Trying async fetch...`, 'info');
        html += `<p style="color: #64748b; font-size: 0.875rem; line-height: 1.5;" id="schema-coverage-loading-${Date.now()}">Checking schema coverage...</p>`;
      }
      html += `</div></div>`;

      // 5. AI usage
      html += `<div class="scorecard-section">`;
      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">5. AI usage</h5>`;
      html += `<div style="padding-left: 0.75rem;">`;
      
      // Format AI status with citation details
      const aiTotal = row.ai_total_citations || 0;
      const aiOurs = row.ai_alan_citations_count || 0;
      let aiStatusText = '';
      if (row.has_ai_overview) {
        if (aiOurs > 0) {
          aiStatusText = `AI Overview present, cited in ${aiOurs}/${aiTotal} citation${aiTotal !== 1 ? 's' : ''}`;
          if (aiOurs / aiTotal < 0.33) {
            aiStatusText += ' (light)';
          }
        } else {
          aiStatusText = 'AI Overview present, not cited';
        }
      } else {
        aiStatusText = 'AI Overview not present';
      }
      
      html += `<p style="font-size: 0.875rem; color: #3d3d3d; line-height: 1.6; margin-bottom: 0.5rem; font-weight: 400;">${aiStatusText}</p>`;
      
      // Show cited pages list
      if (scorecardData.ai_citations_ours > 0 && scorecardData.ai_alan_citations && scorecardData.ai_alan_citations.length > 0) {
        html += `<div style="font-size: 0.875rem; color: #3d3d3d; margin-bottom: 0.25rem; font-weight: 500;">Your cited pages:</div>`;
        html += `<ul style="margin-top: 0.25rem; padding-left: 1.5rem; font-size: 0.875rem; line-height: 1.6; color: #3d3d3d; font-weight: 400;">`;
        scorecardData.ai_alan_citations.forEach(c => {
          html += `<li><a href="${c.url}" target="_blank" rel="noopener noreferrer" style="color: #0284c7;">${c.title || c.url}</a></li>`;
        });
        html += `</ul>`;
      }
      html += `</div></div>`;

      // 6. SERP features
      html += `<div class="scorecard-section">`;
      html += `<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">6. SERP features</h5>`;
      html += `<div style="padding-left: 0.75rem;">`;
      
      // Get SERP feature presence from scorecardData
      const hasAiOverview = scorecardData.ai_overview_present_any === true;
      const hasLocalPack = scorecardData.local_pack_present_any === true;
      const hasPaa = scorecardData.paa_present_any === true;
      const hasFeaturedSnippet = scorecardData.featured_snippet_present_any === true;
      
      // Count features present
      const featuresPresent = [hasAiOverview, hasLocalPack, hasPaa, hasFeaturedSnippet].filter(Boolean).length;
      
      html += `<div style="margin-bottom: 0.75rem;">`;
      html += `<div style="font-size: 0.875rem; color: #1e293b; margin-bottom: 0.5rem; font-weight: 500;">SERP features present for this keyword:</div>`;
      html += `<div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.875rem; color: #1e293b;">`;
      html += `<span>AI Overview: ${hasAiOverview ? '' : ''}</span>`;
      html += `<span>Local pack: ${hasLocalPack ? '' : ''}</span>`;
      html += `<span>People Also Ask: ${hasPaa ? '' : ''}</span>`;
      html += `<span>Featured snippet: ${hasFeaturedSnippet ? '' : ''}</span>`;
      html += `</div>`;
      html += `<div style="margin-top: 0.5rem; font-size: 0.875rem; color: #64748b;">${featuresPresent}/4 features present</div>`;
      html += `</div>`;
      
      // Interpretation based on SERP features
      let serpInterpretation = '';
      if (featuresPresent === 4) {
        serpInterpretation = 'All major SERP features are present for this keyword. This indicates strong competition and multiple opportunities for visibility.';
      } else if (featuresPresent >= 2) {
        serpInterpretation = 'Multiple SERP features are present. Focus on optimizing for the features where you\'re not yet visible.';
      } else if (hasAiOverview && !hasLocalPack && !hasPaa && !hasFeaturedSnippet) {
        serpInterpretation = 'Only AI Overview is present. This keyword may benefit from local optimization (if applicable) or FAQ schema to trigger People Also Ask.';
      } else if (hasLocalPack && !hasAiOverview) {
        serpInterpretation = 'Local pack is present but no AI Overview. This suggests local intent; ensure your local entity is optimized.';
      } else {
        serpInterpretation = 'Few SERP features are present. This keyword may have lower competition or less rich result potential.';
      }
      html += `<p style="color: #3d3d3d; font-size: 0.875rem; line-height: 1.6; font-weight: 400;">${serpInterpretation}</p>`;
      html += `</div></div>`;

      // Summary line is now included in the keyword header section above

      // Update the content element - everything is now in one container
      const kwEl = document.getElementById("ranking-ai-detail-keyword");
      if (kwEl) kwEl.innerHTML = html;
      
      // Hide the separate summary element since it's now included in the main HTML
      const sumEl = document.getElementById("ranking-ai-detail-summary");
      if (sumEl) sumEl.style.display = 'none';
      
      // Fetch page totals and querypages breakdown asynchronously
      const pageTotalsEl = document.getElementById(`scorecard-page-totals-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}`);
      const queryPagesEl = document.getElementById(`scorecard-query-pages-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}`);
      
      // Fetch page-only totals for best_url
      if (pageTotalsEl && scorecardData.ranking_url) {
        (async () => {
          try {
            const savedAudit = loadAuditResultsSync();
            const propertyUrl = savedAudit?.propertyUrl || window.lastAuditPropertyUrl || 'https://www.alanranger.com';
            
            // Calculate date range using centralized helper (last 28 days, ending yesterday - matches GSC UI)
            const { startDate, endDate } = getGscDateRange(GSC_WINDOW_DAYS, 1);
            
            // Use canonical targetUrl for GSC page filter
            const pageUrlForGsc = scorecardData.targetUrl || scorecardData.ranking_url || '';
            const response = await fetch(apiUrl(`/api/aigeo/gsc-page-totals?property=${encodeURIComponent(propertyUrl)}&pageUrl=${encodeURIComponent(pageUrlForGsc)}&startDate=${startDate}&endDate=${endDate}`));
            
            if (response.ok) {
              const data = await response.json();
              if (data.status === 'ok' && data.data) {
                const pageData = data.data;
                let pageHtml = '';
                pageHtml += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.5; color: #3d3d3d; font-weight: 400;">`;
                pageHtml += `<span>Clicks: <strong style="color: #1e293b;">${pageData.clicks.toLocaleString()}</strong></span>`;
                pageHtml += `</div>`;
                pageHtml += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.5; color: #3d3d3d; font-weight: 400;">`;
                pageHtml += `<span>Impressions: <strong style="color: #1e293b;">${pageData.impressions.toLocaleString()}</strong></span>`;
                pageHtml += `</div>`;
                pageHtml += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.5; color: #3d3d3d; font-weight: 400;">`;
                pageHtml += `<span>CTR: <strong style="color: #1e293b;">${(pageData.ctr).toFixed(1)}%</strong></span>`;
                pageHtml += `</div>`;
                pageHtml += `<div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; font-size: 0.875rem; line-height: 1.5; color: #3d3d3d; font-weight: 400;">`;
                pageHtml += `<span>Avg position: <strong style="color: #1e293b;">${Math.round(pageData.position)}</strong></span>`;
                pageHtml += `</div>`;
                pageTotalsEl.innerHTML = pageHtml;
              } else {
                pageTotalsEl.innerHTML = `<div style="color: #64748b; font-size: 0.875rem;">No page totals returned for this URL in the last 28 days.</div>`;
              }
            } else {
              pageTotalsEl.innerHTML = `<div style="color: #64748b; font-size: 0.875rem;">Unable to load page totals.</div>`;
            }
          } catch (err) {
            console.error('Error fetching page totals:', err);
            pageTotalsEl.innerHTML = `<div style="color: #64748b; font-size: 0.875rem;">Error loading page totals: ${err.message}</div>`;
          }
        })();
      }
      
      // Fetch querypages breakdown
      if (queryPagesEl) {
        (async () => {
          try {
            const savedAudit = loadAuditResultsSync();
            const propertyUrl = savedAudit?.propertyUrl || window.lastAuditPropertyUrl || 'https://www.alanranger.com';
            
            // Calculate date range using centralized helper (last 28 days, ending yesterday - matches GSC UI)
            const { startDate, endDate } = getGscDateRange(GSC_WINDOW_DAYS, 1);
            
            const response = await fetch(apiUrl(`/api/aigeo/gsc-query-pages?property=${encodeURIComponent(propertyUrl)}&query=${encodeURIComponent(scorecardData.keyword)}&startDate=${startDate}&endDate=${endDate}`));
            
            if (response.ok) {
              const data = await response.json();
              if (data.status === 'ok' && data.data && data.data.pages) {
                const pages = data.data.pages;
                // Use canonical targetUrl for matching
                const bestUrl = scorecardData.targetUrl || scorecardData.ranking_url || '';
                const normalizedBestUrl = bestUrl ? normalizeGscPageUrl(bestUrl) : null;
                
                let pagesHtml = '';
                if (pages.length === 0) {
                  pagesHtml = `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">No pages found with impressions for this keyword.</div>`;
                } else {
                  // Separate best URL from other pages
                  const bestUrlPage = pages.find(page => {
                    const normalizedPageUrl = normalizeGscPageUrl(page.page);
                    return normalizedBestUrl && normalizedPageUrl === normalizedBestUrl;
                  });
                  const otherPages = pages.filter(page => {
                    const normalizedPageUrl = normalizeGscPageUrl(page.page);
                    return !normalizedBestUrl || normalizedPageUrl !== normalizedBestUrl;
                  });
                  
                  const tableId = `query-pages-table-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}`;
                  const collapsedRowsId = `query-pages-collapsed-${scorecardData.keyword.replace(/[^a-z0-9]/gi, '_')}`;
                  
                  pagesHtml += `<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem; margin-top: 0.5rem;" id="${tableId}">`;
                  pagesHtml += `<thead><tr style="border-bottom: 1px solid #e5e7eb;">`;
                  pagesHtml += `<th style="text-align: left; padding: 0.5rem; font-weight: 600; color: #374151;">Page URL</th>`;
                  pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Clicks</th>`;
                  pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Impressions</th>`;
                  pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">CTR</th>`;
                  pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Position</th>`;
                  pagesHtml += `</tr></thead><tbody>`;
                  
                  // Always show best URL row (yellow highlighted)
                  if (bestUrlPage) {
                    pagesHtml += `<tr style="background: #fef3c7; border-left: 3px solid #f59e0b; border-bottom: 1px solid #e5e7eb;">`;
                    pagesHtml += `<td style="padding: 0.5rem; word-break: break-word;">`;
                    pagesHtml += `<strong style="color: #92400e;">${bestUrlPage.page}</strong> <span style="font-size: 0.75rem; color: #64748b;">(DataForSEO best URL)</span>`;
                    pagesHtml += `</td>`;
                    pagesHtml += `<td style="text-align: right; padding: 0.5rem;">${bestUrlPage.clicks.toLocaleString()}</td>`;
                    pagesHtml += `<td style="text-align: right; padding: 0.5rem;">${bestUrlPage.impressions.toLocaleString()}</td>`;
                    pagesHtml += `<td style="text-align: right; padding: 0.5rem;">${(bestUrlPage.ctr).toFixed(1)}%</td>`;
                    pagesHtml += `<td style="text-align: right; padding: 0.5rem;">${Math.round(bestUrlPage.position)}</td>`;
                    pagesHtml += `</tr>`;
                  }
                  
                  // Collapsible section for other pages
                  if (otherPages.length > 0) {
                    pagesHtml += `</tbody></table>`;
                    pagesHtml += `<div style="margin-top: 0.5rem;">`;
                    pagesHtml += `<button onclick="const el = document.getElementById('${collapsedRowsId}'); el.style.display = el.style.display === 'none' ? 'table' : 'none'; this.textContent = el.style.display === 'none' ? 'Show ' + ${otherPages.length} + ' other page' + (${otherPages.length} !== 1 ? 's' : '') : 'Hide other pages';" style="background: #f3f4f6; border: 1px solid #d1d5db; border-radius: 4px; padding: 0.375rem 0.75rem; font-size: 0.875rem; color: #3d3d3d; cursor: pointer; font-weight: 400;">Show ${otherPages.length} other page${otherPages.length !== 1 ? 's' : ''}</button>`;
                    pagesHtml += `</div>`;
                    pagesHtml += `<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem; margin-top: 0.5rem; display: none;" id="${collapsedRowsId}">`;
                    pagesHtml += `<thead><tr style="border-bottom: 1px solid #e5e7eb;">`;
                    pagesHtml += `<th style="text-align: left; padding: 0.5rem; font-weight: 600; color: #374151;">Page URL</th>`;
                    pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Clicks</th>`;
                    pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Impressions</th>`;
                    pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">CTR</th>`;
                    pagesHtml += `<th style="text-align: right; padding: 0.5rem; font-weight: 600; color: #374151;">Position</th>`;
                    pagesHtml += `</tr></thead><tbody>`;
                    
                    otherPages.forEach(page => {
                      pagesHtml += `<tr style="border-bottom: 1px solid #e5e7eb;">`;
                      pagesHtml += `<td style="padding: 0.5rem; word-break: break-word; color: #3d3d3d;">${page.page}</td>`;
                      pagesHtml += `<td style="text-align: right; padding: 0.5rem; color: #3d3d3d;">${page.clicks.toLocaleString()}</td>`;
                      pagesHtml += `<td style="text-align: right; padding: 0.5rem; color: #3d3d3d;">${page.impressions.toLocaleString()}</td>`;
                      pagesHtml += `<td style="text-align: right; padding: 0.5rem; color: #3d3d3d;">${(page.ctr).toFixed(1)}%</td>`;
                      pagesHtml += `<td style="text-align: right; padding: 0.5rem; color: #3d3d3d;">${Math.round(page.position)}</td>`;
                      pagesHtml += `</tr>`;
                    });
                    
                    pagesHtml += `</tbody></table>`;
                  } else {
                    pagesHtml += `</tbody></table>`;
                  }
                }
                queryPagesEl.innerHTML = pagesHtml;
              } else {
                queryPagesEl.innerHTML = `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">No pages found with impressions for this keyword.</div>`;
              }
            } else {
              queryPagesEl.innerHTML = `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">Unable to load pages breakdown.</div>`;
            }
          } catch (err) {
            console.error('Error fetching querypages breakdown:', err);
            queryPagesEl.innerHTML = `<div style="color: #3d3d3d; font-size: 0.875rem; font-weight: 400;">Error loading pages breakdown: ${err.message}</div>`;
          }
        })();
      }

      // Update AI citations section in right panel
      const citationsEmpty = document.getElementById("ranking-ai-citations-empty");
      const citationsContent = document.getElementById("ranking-ai-citations-content");
      const ourList = document.getElementById("ranking-ai-detail-our-pages");
      const compTbody = document.getElementById("ranking-ai-detail-competitors-body");

      if (citationsEmpty && citationsContent) {
        citationsEmpty.hidden = true;
        citationsContent.hidden = false;

        if (ourList) {
          ourList.innerHTML = "";
          if (!row.ai_alan_citations || !row.ai_alan_citations.length) {
            const li = document.createElement("li");
            li.textContent = "No alanranger.com citations found for this AI Overview.";
            ourList.appendChild(li);
          } else {
            row.ai_alan_citations.forEach(c => {
              const li = document.createElement("li");
              const a = document.createElement("a");
              a.href = c.url;
              a.target = "_blank";
              a.rel = "noopener noreferrer";
              a.textContent = c.title || c.url;
              li.appendChild(a);
              ourList.appendChild(li);
            });
          }
        }

        if (compTbody) {
          compTbody.innerHTML = "";
          const entries = Object.entries(row.competitor_counts || {}).sort((a, b) => b[1] - a[1]);
          if (!entries.length) {
            const tr = document.createElement("tr");
            const td = document.createElement("td");
            td.colSpan = 5;
            td.style.padding = "1rem 0.75rem";
            td.style.color = "#64748b";
            td.style.fontSize = "0.875rem";
            td.textContent = "No competing domains recorded from AI citations for this keyword.";
            tr.appendChild(td);
            compTbody.appendChild(tr);
          } else {
            const makeDomainHref = (domain) => {
              if (!domain) return null;
              const d = String(domain).trim();
              if (!d) return null;
              if (d.startsWith('http://') || d.startsWith('https://')) return d;
              return `https://${d}`;
            };
            
            // Fetch domain metadata for all domains
            const domainsList = entries.map(([d]) => d);
            (async () => {
              const domainMetadata = await fetchDomainMetadataForDomains(domainsList);
              
              entries.forEach(([domain, count]) => {
                const tr = document.createElement("tr");
                tr.style.borderTop = "1px solid #e2e8f0";

                const normalizedDomain = normalizeDomainForStrength(domain);
                const meta = domainMetadata[normalizedDomain] || { domain_type: 'unmapped', is_competitor: false };

                const tdDomain = document.createElement("td");
                tdDomain.style.padding = "0.5rem 0.4rem";
                tdDomain.style.fontSize = "0.8rem";
                tdDomain.style.wordWrap = "break-word";
                tdDomain.style.overflowWrap = "break-word";
                const domainContainer = document.createElement("div");
                domainContainer.style.display = "flex";
                domainContainer.style.flexDirection = "column";
                domainContainer.style.alignItems = "flex-start";
                domainContainer.style.gap = "0.25rem";
                
                const domainLinkWrapper = document.createElement("div");
                domainLinkWrapper.style.width = "100%";
                const href = makeDomainHref(domain);
                if (href) {
                  const a = document.createElement("a");
                  a.href = href;
                  a.target = "_blank";
                  a.rel = "noopener noreferrer";
                  a.style.color = "#0284c7";
                  a.style.textDecoration = "none";
                  a.style.wordBreak = "break-word";
                  a.style.overflowWrap = "break-word";
                  a.textContent = domain;
                  domainLinkWrapper.appendChild(a);
                } else {
                  domainLinkWrapper.appendChild(document.createTextNode(String(domain || '')));
                }
                domainContainer.appendChild(domainLinkWrapper);

        // Add competitor badge if is_competitor is true - below the domain
        if (meta.is_competitor) {
          const badge = document.createElement("span");
          badge.textContent = "Competitor";
          badge.setAttribute('data-competitor-badge', 'true');
          badge.style.display = "inline-block";
          badge.style.padding = "0.125rem 0.5rem";
          badge.style.fontSize = "0.65rem";
          badge.style.fontWeight = "600";
          badge.style.color = "#dc2626";
          badge.style.backgroundColor = "#fee2e2";
          badge.style.borderRadius = "4px";
          badge.style.border = "1px solid #fecaca";
          badge.style.marginTop = "0.125rem";
          domainContainer.appendChild(badge);
        }

        tdDomain.appendChild(domainContainer);

                const tdCount = document.createElement("td");
                tdCount.style.padding = "0.5rem 0.4rem";
                tdCount.style.textAlign = "center";
                tdCount.style.fontWeight = "700";
                tdCount.style.color = "#1e293b";
                tdCount.style.fontSize = "0.8rem";
                tdCount.textContent = `${count}`;

                const tdRank = document.createElement("td");
                tdRank.style.padding = "0.5rem 0.4rem";
                tdRank.style.textAlign = "right";
                tdRank.style.color = "#64748b";
                tdRank.style.fontSize = "0.8rem";
                tdRank.textContent = "";
                tdRank.dataset.domain = normalizedDomain;

                const tdDomainType = document.createElement("td");
                tdDomainType.style.padding = "0.5rem 0.4rem";
                tdDomainType.style.fontSize = "0.8rem";
                tdDomainType.style.wordWrap = "break-word";
                tdDomainType.style.overflowWrap = "break-word";
                // Show domain type, but hide "unmapped" (show blank instead)
                const displayType = meta.domain_type && meta.domain_type !== 'unmapped' ? meta.domain_type : '';
                tdDomainType.textContent = displayType;
                tdDomainType.style.color = displayType ? '#475569' : '#94a3b8';

                const tdCompetitor = document.createElement("td");
                tdCompetitor.style.padding = "0.5rem 0.4rem";
                tdCompetitor.style.textAlign = "center";
                tdCompetitor.style.fontSize = "0.8rem";
                tdCompetitor.style.minWidth = "80px";
                const competitorCheckbox = document.createElement("input");
                competitorCheckbox.type = "checkbox";
                competitorCheckbox.checked = meta.is_competitor === true;
                competitorCheckbox.style.cursor = "pointer";
                competitorCheckbox.dataset.domain = normalizedDomain;
                
                competitorCheckbox.addEventListener('change', async (e) => {
                  const isCompetitor = e.target.checked;
                  const domain = e.target.dataset.domain;
                  try {
                    const resp = await fetch(apiUrl('/api/domain-strength/update-domain'), {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ domain, is_competitor: isCompetitor })
                    });
                    if (resp.ok) {
                      // Clear cache
                      __domainMetadataCache.delete(domain);
                      // Update badge - find domainContainer first
                      const domainContainer = tdDomain.querySelector('div[style*="flex-direction: column"]') || tdDomain.querySelector('div');
                      let badge = tdDomain.querySelector('span[data-competitor-badge]');
                      if (isCompetitor && !badge && domainContainer) {
                        badge = document.createElement("span");
                        badge.textContent = "Competitor";
                        badge.setAttribute('data-competitor-badge', 'true');
                        badge.style.display = "inline-block";
                        badge.style.padding = "0.125rem 0.5rem";
                        badge.style.fontSize = "0.65rem";
                        badge.style.fontWeight = "600";
                        badge.style.color = "#dc2626";
                        badge.style.backgroundColor = "#fee2e2";
                        badge.style.borderRadius = "4px";
                        badge.style.border = "1px solid #fecaca";
                        badge.style.marginTop = "0.125rem";
                        domainContainer.appendChild(badge);
                      } else if (!isCompetitor && badge) {
                        badge.remove();
                      }
                    } else {
                      // Revert on error
                      e.target.checked = !isCompetitor;
                      alert('Failed to update competitor flag. Please try again.');
                    }
                  } catch (err) {
                    e.target.checked = !isCompetitor;
                    alert('Failed to update competitor flag. Please try again.');
                  }
                });
                
                tdCompetitor.appendChild(competitorCheckbox);

                tr.appendChild(tdDomain);
                tr.appendChild(tdCount);
                tr.appendChild(tdRank);
                tr.appendChild(tdDomainType);
                tr.appendChild(tdCompetitor);
                compTbody.appendChild(tr);
              });
              
              // Fill Domain Rank column AFTER all rows are appended to DOM
              try {
                const selfDomain = typeof getSelfDomainForDomainStrength === "function" ? getSelfDomainForDomainStrength() : "alanranger.com";
                const domains = [
                  selfDomain,
                  ...entries.map(([d]) => d),
                ].map(normalizeDomainForStrength).filter(Boolean);
                const strengthByDomain = await fetchLatestDomainStrengthForDomains(domains);
                const rankCells = compTbody.querySelectorAll("td[data-domain]");
                if (rankCells.length === 0) {
                  debugLog(' No Domain Rank cells found with data-domain attribute in AI Citations table', 'warn');
                } else {
                  debugLog(` Filling Domain Rank for ${rankCells.length} domains in AI Citations table`, 'info');
                }
                rankCells.forEach((cell) => {
                  const d = normalizeDomainForStrength(cell.dataset.domain || "");
                  const strength = strengthByDomain[d] || null;
                  cell.innerHTML = renderDomainRankCellHtml(strength);
                });
              } catch (err) {
                debugLog(` Error filling Domain Rank in AI Citations table: ${err.message}`, 'error');
              }
            })();
          }
        }
      } else if (citationsEmpty) {
        citationsEmpty.hidden = false;
      }
    }

    // Keep renderRankingAiDetail as alias for backward compatibility
    async function renderRankingAiDetail(row) {
      await renderKeywordScorecard(row);
    }

    // ======================
    // Domain Rank (Domain Strength snapshots) for Keyword tables
    // ======================
    const __domainStrengthLatestCache = new Map(); // domain -> { score, band, snapshotDate }
    const __domainMetadataCache = new Map(); // domain -> { domain_type, is_competitor }

    function normalizeDomainForStrength(input) {
      const raw = String(input || "").trim().toLowerCase();
      if (!raw) return "";
      try {
        if (raw.includes("://")) return new URL(raw).hostname.replace(/^www\./, "");
      } catch {
        // ignore
      }
      return raw.replace(/^www\./, "").split("/")[0];
    }

    function renderDomainStrengthBandPillOriginal(band) {
      const label = String(band || "").trim();
      if (!label) return "";
      const key = typeof domainStrengthBandKey === "function" ? domainStrengthBandKey(label) : "na";
      return `<span class="domain-strength-badge domain-strength-badge--${key}">${label}</span>`;
    }

    function renderDomainRankCellHtml(strength) {
      if (!strength || typeof strength !== "object") {
        return `<span title="No domain strength snapshot yet"></span>`;
      }
      const score = typeof strength.score === "number" && isFinite(strength.score) ? strength.score : null;
      const band = typeof strength.band === "string" ? strength.band : "";
      if (score === null) {
        return `<span title="No domain strength snapshot yet"></span>`;
      }
      const pill = renderDomainStrengthBandPillOriginal(band);
      const scoreRounded = Math.round(score);
      // Left-align numbers in fixed-width container so they line up vertically
      return `<div style="display:flex; justify-content:flex-start; gap:0.25rem; align-items:center;">
        <span style="display:inline-block; width:2.5rem; text-align:left; font-weight:800; color:#0f172a; font-size: 0.8rem;">${scoreRounded}</span>
        ${pill || ""}
      </div>`;
    }

    async function fetchLatestDomainStrengthForDomains(domains) {
      const list = Array.isArray(domains) ? domains.map(normalizeDomainForStrength).filter(Boolean) : [];
      const unique = Array.from(new Set(list)).slice(0, 30);
      if (!unique.length) return {};

      // Serve from cache when available
      const out = {};
      const missing = [];
      for (const d of unique) {
        if (__domainStrengthLatestCache.has(d)) {
          out[d] = __domainStrengthLatestCache.get(d);
        } else {
          missing.push(d);
        }
      }
      if (!missing.length) return out;

      try {
        const qs = encodeURIComponent(missing.join(","));
        const resp = await fetch(apiUrl(`/api/domain-strength/history?domains=${qs}`));
        if (!resp.ok) return out;
        const json = await resp.json();
        const rows = json?.status === "ok" ? (json.data || []) : [];

        // Build latest per domain (google engine only)
        const latestByDomain = {};
        for (const r of rows) {
          const d = normalizeDomainForStrength(r?.domain);
          if (!d) continue;
          if (String(r?.engine || "google").toLowerCase() !== "google") continue;
          const date = String(r?.snapshot_date || "");
          const score = typeof r?.score === "number" ? r.score : parseFloat(r?.score);
          const band = typeof r?.band === "string" ? r.band : "";
          if (!date) continue;
          const prev = latestByDomain[d];
          if (!prev || String(prev.snapshotDate) < date) {
            latestByDomain[d] = { score: isFinite(score) ? score : null, band: band || null, snapshotDate: date };
          }
        }

        for (const d of missing) {
          const v = latestByDomain[d] || { score: null, band: null, snapshotDate: null };
          __domainStrengthLatestCache.set(d, v);
          out[d] = v;
        }
      } catch {
        // fail silently
      }

      return out;
    }

    async function fetchDomainMetadataForDomains(domains) {
      const list = Array.isArray(domains) ? domains.map(normalizeDomainForStrength).filter(Boolean) : [];
      const unique = Array.from(new Set(list));
      if (!unique.length) return {};

      // Serve from cache when available
      const out = {};
      const missing = [];
      for (const d of unique) {
        if (__domainMetadataCache.has(d)) {
          out[d] = __domainMetadataCache.get(d);
        } else {
          missing.push(d);
        }
      }
      if (!missing.length) return out;

      try {
        // Fetch metadata from domain_strength_domains via overview API
        const qs = encodeURIComponent(missing.join(","));
        const resp = await fetch(apiUrl(`/api/domain-strength/overview?domains=${qs}`));
        if (!resp.ok) {
          // If API fails, return defaults
          for (const d of missing) {
            out[d] = { domain_type: 'unmapped', is_competitor: false };
            __domainMetadataCache.set(d, out[d]);
          }
          return out;
        }
        const json = await resp.json();
        const items = json?.status === "ok" ? (json.items || []) : [];

        // Build metadata map
        for (const item of items) {
          const d = normalizeDomainForStrength(item?.domain);
          if (!d) continue;
          const meta = {
            domain_type: item?.domain_type || item?.segment || 'unmapped',
            is_competitor: item?.isCompetitor === true || false
          };
          __domainMetadataCache.set(d, meta);
          out[d] = meta;
        }

        // Fill in missing domains with defaults
        for (const d of missing) {
          if (!out[d]) {
            out[d] = { domain_type: 'unmapped', is_competitor: false };
            __domainMetadataCache.set(d, out[d]);
          }
        }
      } catch (e) {
        // If fetch fails, return defaults
        for (const d of missing) {
          out[d] = { domain_type: 'unmapped', is_competitor: false };
          __domainMetadataCache.set(d, out[d]);
        }
      }

      return out;
    }

    /**
     * Backfill missing Domain Ranks for domains currently showing ""
     * Collects domains from "Other cited domains" table and competitor tables that have missing ranks
     */
    async function backfillMissingDomainRanks() {
      const btn = document.getElementById('backfill-domain-ranks-btn');
      if (!btn) return;
      
      // Disable button and show loading state
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Backfilling...';
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      
      try {
        // Collect domains with missing ranks from "Other cited domains" table
        const compTbody = document.getElementById('ranking-ai-detail-competitors-body');
        const missingDomains = new Set();
        
        if (compTbody) {
          const rankCells = compTbody.querySelectorAll('td[data-domain]');
          rankCells.forEach(cell => {
            // Check if cell shows "" (missing rank)
            const cellText = cell.textContent.trim();
            if (cellText === '' || cellText === '') {
              const domain = cell.dataset.domain;
              if (domain) {
                const normalized = normalizeDomainForStrength(domain);
                if (normalized) {
                  missingDomains.add(normalized);
                }
              }
            }
          });
        }
        
        // Also check competitor tables in main ranking view
        const competitorTbody = document.getElementById('ranking-ai-competitors-body');
        if (competitorTbody) {
          const competitorCells = competitorTbody.querySelectorAll('td[data-domain]');
          competitorCells.forEach(cell => {
            const cellText = cell.textContent.trim();
            if (cellText === '' || cellText === '') {
              const domain = cell.dataset.domain;
              if (domain) {
                const normalized = normalizeDomainForStrength(domain);
                if (normalized) {
                  missingDomains.add(normalized);
                }
              }
            }
          });
        }
        
        const domainsToBackfill = Array.from(missingDomains);
        
        if (domainsToBackfill.length === 0) {
          alert('No domains with missing ranks found. All domains already have Domain Rank values.');
          return;
        }
        
        debugLog(` Backfilling Domain Rank for ${domainsToBackfill.length} domains: ${domainsToBackfill.slice(0, 10).join(', ')}${domainsToBackfill.length > 10 ? '...' : ''}`, 'info');
        
        // Call backfill API
        const adminToken = localStorage.getItem('admin_token') || '';
        const response = await fetch(apiUrl('/api/domain-strength/backfill'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-admin-token': adminToken
          },
          body: JSON.stringify({
            mode: 'list',
            domains: domainsToBackfill,
            maxNewDomains: domainsToBackfill.length,
            dryRun: false,
            source: 'ui-backfill'
          })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Backfill failed: ${errorText}`);
        }
        
        const result = await response.json();
        
        if (result.status === 'ok') {
          debugLog(` Backfill complete: ${result.processed} processed, ${result.skipped_existing} skipped, ${result.errors?.length || 0} errors`, 'success');
          
          // Clear domain strength cache for backfilled domains
          domainsToBackfill.forEach(d => {
            __domainStrengthLatestCache.delete(d);
          });
          
          // Refresh domain rank cells
          if (compTbody) {
            const rankCells = compTbody.querySelectorAll('td[data-domain]');
            const domains = Array.from(rankCells).map(cell => normalizeDomainForStrength(cell.dataset.domain || '')).filter(Boolean);
            if (domains.length > 0) {
              const strengthByDomain = await fetchLatestDomainStrengthForDomains(domains);
              rankCells.forEach(cell => {
                const d = normalizeDomainForStrength(cell.dataset.domain || '');
                const strength = strengthByDomain[d] || null;
                cell.innerHTML = renderDomainRankCellHtml(strength);
              });
            }
          }
          
          // Also refresh competitor table if visible
          if (competitorTbody) {
            const competitorCells = competitorTbody.querySelectorAll('td[data-domain]');
            const competitorDomains = Array.from(competitorCells).map(cell => normalizeDomainForStrength(cell.dataset.domain || '')).filter(Boolean);
            if (competitorDomains.length > 0) {
              const strengthByDomain = await fetchLatestDomainStrengthForDomains(competitorDomains);
              competitorCells.forEach(cell => {
                const d = normalizeDomainForStrength(cell.dataset.domain || '');
                const strength = strengthByDomain[d] || null;
                cell.innerHTML = renderDomainRankCellHtml(strength);
              });
            }
          }
          
          alert(`Domain Rank backfill complete!\n\nProcessed: ${result.processed}\nSkipped (already exist): ${result.skipped_existing}\nErrors: ${result.errors?.length || 0}`);
        } else {
          throw new Error(result.message || 'Backfill failed');
        }
      } catch (err) {
        debugLog(` Domain Rank backfill error: ${err.message}`, 'error');
        alert(`Failed to backfill Domain Ranks: ${err.message}`);
      } finally {
        // Restore button state
        btn.disabled = false;
        btn.textContent = originalText;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
      }
    }

    function renderRankingAiCompetitors(rows) {
      const tbody = document.getElementById("ranking-ai-competitors-body");
      if (!tbody) return;

      tbody.innerHTML = "";
      const aggregate = {};

      rows.forEach(row => {
        Object.entries(row.competitor_counts || {}).forEach(([domain, count]) => {
          aggregate[domain] = (aggregate[domain] || 0) + count;
        });
      });

      const entries = Object.entries(aggregate).sort((a, b) => b[1] - a[1]).slice(0, 8);

        if (!entries.length) {
          const tr = document.createElement("tr");
          const td = document.createElement("td");
            td.colSpan = 5;
            td.style.padding = "1rem 0.75rem";
            td.style.color = "#64748b";
            td.style.fontSize = "0.875rem";
            td.textContent = "No competitor citations recorded across tracked keywords.";
          tr.appendChild(td);
          tbody.appendChild(tr);
          return;
        }

      const makeDomainHref = (domain) => {
        if (!domain) return null;
        const d = String(domain).trim();
        if (!d) return null;
        if (d.startsWith('http://') || d.startsWith('https://')) return d;
        return `https://${d}`;
      };

      // Fetch domain metadata for all domains (async)
      const domainsList = entries.map(([d]) => d);
      (async () => {
        const domainMetadata = await fetchDomainMetadataForDomains(domainsList);

        entries.forEach(([domain, count]) => {
        const tr = document.createElement("tr");
        tr.style.borderTop = "1px solid #e2e8f0";

        const normalizedDomain = normalizeDomainForStrength(domain);
        const meta = domainMetadata[normalizedDomain] || { domain_type: 'unmapped', is_competitor: false };

        const tdDomain = document.createElement("td");
        tdDomain.style.padding = "0.5rem 0.4rem";
        tdDomain.style.fontSize = "0.8rem";
        tdDomain.style.wordWrap = "break-word";
        tdDomain.style.overflowWrap = "break-word";
        const domainContainer = document.createElement("div");
        domainContainer.style.display = "flex";
        domainContainer.style.flexDirection = "column";
        domainContainer.style.alignItems = "flex-start";
        domainContainer.style.gap = "0.25rem";
        
        const domainLinkWrapper = document.createElement("div");
        domainLinkWrapper.style.width = "100%";
        const href = makeDomainHref(domain);
        if (href) {
          const a = document.createElement("a");
          a.href = href;
          a.target = "_blank";
          a.rel = "noopener noreferrer";
          a.style.color = "#0284c7";
          a.style.textDecoration = "none";
          a.style.wordBreak = "break-word";
          a.style.overflowWrap = "break-word";
          a.textContent = domain;
          domainLinkWrapper.appendChild(a);
        } else {
          domainLinkWrapper.appendChild(document.createTextNode(String(domain || '')));
        }
        domainContainer.appendChild(domainLinkWrapper);

        // Add competitor badge if is_competitor is true - below the domain
        if (meta.is_competitor) {
          const badge = document.createElement("span");
          badge.textContent = "Competitor";
          badge.setAttribute('data-competitor-badge', 'true');
          badge.style.display = "inline-block";
          badge.style.padding = "0.125rem 0.5rem";
          badge.style.fontSize = "0.65rem";
          badge.style.fontWeight = "600";
          badge.style.color = "#dc2626";
          badge.style.backgroundColor = "#fee2e2";
          badge.style.borderRadius = "4px";
          badge.style.border = "1px solid #fecaca";
          badge.style.marginTop = "0.125rem";
          domainContainer.appendChild(badge);
        }

        tdDomain.appendChild(domainContainer);

        const tdCount = document.createElement("td");
        tdCount.style.padding = "0.5rem 0.4rem";
        tdCount.style.textAlign = "center";
        tdCount.style.fontWeight = "700";
        tdCount.style.color = "#1e293b";
        tdCount.style.fontSize = "0.8rem";
        tdCount.textContent = `${count}`;

        const tdRank = document.createElement("td");
        tdRank.style.padding = "0.5rem 0.4rem";
        tdRank.style.textAlign = "right";
        tdRank.style.color = "#64748b";
        tdRank.style.fontSize = "0.8rem";
        tdRank.textContent = "";
        tdRank.dataset.domain = normalizedDomain;

        const tdDomainType = document.createElement("td");
        tdDomainType.style.padding = "0.5rem 0.4rem";
        tdDomainType.style.fontSize = "0.8rem";
        tdDomainType.style.wordWrap = "break-word";
        tdDomainType.style.overflowWrap = "break-word";
        // Show domain type, but hide "unmapped" (show blank instead)
        const displayType = meta.domain_type && meta.domain_type !== 'unmapped' ? meta.domain_type : '';
        tdDomainType.textContent = displayType;
        tdDomainType.style.color = displayType ? '#475569' : '#94a3b8';

        const tdCompetitor = document.createElement("td");
        tdCompetitor.style.padding = "0.5rem 0.4rem";
        tdCompetitor.style.textAlign = "center";
        tdCompetitor.style.fontSize = "0.8rem";
        tdCompetitor.style.minWidth = "40px";
        const competitorCheckbox = document.createElement("input");
        competitorCheckbox.type = "checkbox";
        competitorCheckbox.checked = meta.is_competitor === true;
        competitorCheckbox.style.cursor = "pointer";
        competitorCheckbox.dataset.domain = normalizedDomain;
        
        competitorCheckbox.addEventListener('change', async (e) => {
          const isCompetitor = e.target.checked;
          const domain = e.target.dataset.domain;
          try {
            const resp = await fetch(apiUrl('/api/domain-strength/update-domain'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ domain, is_competitor: isCompetitor })
            });
            if (resp.ok) {
              // Clear cache
              __domainMetadataCache.delete(domain);
              // Update badge - find domainContainer first
              const domainContainer = tdDomain.querySelector('div[style*="flex-direction: column"]') || tdDomain.querySelector('div');
              let badge = tdDomain.querySelector('span[data-competitor-badge]');
              if (isCompetitor && !badge && domainContainer) {
                badge = document.createElement("span");
                badge.textContent = "Competitor";
                badge.setAttribute('data-competitor-badge', 'true');
                badge.style.display = "inline-block";
                badge.style.padding = "0.125rem 0.5rem";
                badge.style.fontSize = "0.65rem";
                badge.style.fontWeight = "600";
                badge.style.color = "#dc2626";
                badge.style.backgroundColor = "#fee2e2";
                badge.style.borderRadius = "4px";
                badge.style.border = "1px solid #fecaca";
                badge.style.marginTop = "0.125rem";
                domainContainer.appendChild(badge);
              } else if (!isCompetitor && badge) {
                badge.remove();
              }
            } else {
              // Revert on error
              e.target.checked = !isCompetitor;
              alert('Failed to update competitor flag. Please try again.');
            }
          } catch (err) {
            e.target.checked = !isCompetitor;
            alert('Failed to update competitor flag. Please try again.');
          }
        });
        
        tdCompetitor.appendChild(competitorCheckbox);

        tr.appendChild(tdDomain);
        tr.appendChild(tdCount);
        tr.appendChild(tdRank);
        tr.appendChild(tdDomainType);
        tr.appendChild(tdCompetitor);
        tbody.appendChild(tr);
        });

        // Fill Domain Rank column using latest domain_strength snapshots (read-only)
        try {
          const selfDomain = typeof getSelfDomainForDomainStrength === "function" ? getSelfDomainForDomainStrength() : "alanranger.com";
          const domains = [
            selfDomain,
            ...entries.map(([d]) => d),
          ].map(normalizeDomainForStrength).filter(Boolean);
          const strengthByDomain = await fetchLatestDomainStrengthForDomains(domains);
          tbody.querySelectorAll("td[data-domain]").forEach((cell) => {
            const d = normalizeDomainForStrength(cell.dataset.domain || "");
            const strength = strengthByDomain[d] || null;
            cell.innerHTML = renderDomainRankCellHtml(strength);
          });
        } catch {
          // fail silently
        }
      })();
    }


    function renderRankingAiInsights(rows, summary) {
      const container = document.getElementById("ranking-ai-insights-list-global");
      if (!container) return;

      container.innerHTML = "";
      if (!rows.length) return;

      // Calculate goodRankWithOverviewNoCitation: keywords with good rank (top-10), AI Overview, but no citations
      const goodRankWithOverviewNoCitation = rows.filter(
        r => r.best_rank_group != null && r.best_rank_group <= 10 && r.has_ai_overview && r.ai_alan_citations_count === 0
      ).length;

      // Calculate weakRankWithCitation: keywords with weaker rank (21+), but alanranger.com is cited
      const weakRankWithCitation = rows.filter(
        r => (r.best_rank_group == null || r.best_rank_group > 20) && r.ai_alan_citations_count > 0
      ).length;

      // Create card pills for the two main insights
      if (goodRankWithOverviewNoCitation > 0) {
        const pill = document.createElement("div");
        pill.className = "card-pill";
        pill.innerHTML = `
          <p>
            <strong>[Visibility, Content/Schema]</strong> ${goodRankWithOverviewNoCitation} keyword(s) have strong classic rankings and an AI Overview, but no citations for alanranger.com. Improving snippet-friendly content blocks and structured data on those pages can help convert existing Visibility into AI citations.
          </p>
        `;
        container.appendChild(pill);
      }

      if (weakRankWithCitation > 0) {
        const pill = document.createElement("div");
        pill.className = "card-pill";
        pill.innerHTML = `
          <p>
            <strong>[Authority, Visibility]</strong> ${weakRankWithCitation} keyword(s) already cite your content in AI Overviews despite weaker classic rankings. This indicates strong topical Authority; improving backlinks and on-page optimisation could lift classic Visibility for these terms.
          </p>
        `;
        container.appendChild(pill);
      }

      // Authority priority insight (v1.4: Domain Strength integration)
      const authorityPriority = summary?.authorityPriority ?? null;
      const domainStrength = summary?.domainStrength ?? null;
      
      if (authorityPriority !== null) {
        const pill = document.createElement("div");
        pill.className = "card-pill";
        
        let authorityText = '';
        if (authorityPriority === 'high') {
          authorityText = 'Domain authority: Low. Overall domain strength is limiting how far your pages can climb, especially for high-impact keywords. Treat "authority building" (links, citations, brand searches) as a high-priority task over the next few months.';
        } else if (authorityPriority === 'medium') {
          authorityText = 'Domain authority: Medium. Authority is "good enough" but still a constraint on some high-impact keywords. Mix authority-building with on-page improvements.';
        } else {
          // authorityPriority === 'low'
          authorityText = 'Domain authority: Strong relative to your current scale. Most gains are likely to come from on-page content, snippets, and conversion rather than more links alone.';
        }
        
        pill.innerHTML = `
          <p>
            <strong>[Authority]</strong> ${authorityText}
          </p>
        `;
        container.appendChild(pill);
      }

      // If no insights, show a general message
      if (goodRankWithOverviewNoCitation === 0 && weakRankWithCitation === 0 && authorityPriority === null) {
        const pill = document.createElement("div");
        pill.className = "card-pill";
        pill.innerHTML = `
          <p>
            Current ranking and AI signals are broadly aligned. Focus on incremental improvements to Money-page CTR, schema coverage, and consolidating reviews to keep Authority and Content/Schema strong.
          </p>
        `;
        container.appendChild(pill);
      }
    }

    // Tab switching for sidebar navigation - Optimized for performance (INP)
    (function() {
      // Restore tab state on page load (from sessionStorage or URL hash)
      function restoreTabState() {
        // Check URL hash first (more reliable)
        const hash = window.location.hash;
        if (hash && hash.startsWith('#')) {
          const panelId = hash.substring(1);
          const panel = document.querySelector(`[data-panel="${panelId}"]`);
          if (panel) {
            setActivePanel(panelId);
            ensurePanelRendered(panelId);
            return;
          }
        }
        
        // Fallback to sessionStorage
        const savedTab = sessionStorage.getItem('activeTab');
        if (savedTab) {
          const panel = document.querySelector(`[data-panel="${savedTab}"]`);
          if (panel) {
            setActivePanel(savedTab);
            ensurePanelRendered(savedTab);
            // Update URL hash to match
            window.location.hash = '#' + savedTab;
            return;
          }
        }
      }
      
      // Restore tab state when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', restoreTabState);
      } else {
        // DOM already loaded, restore immediately
        restoreTabState();
      }

      const navItems = document.querySelectorAll(".aigeo-nav-item");

      navItems.forEach(btn => {
        btn.addEventListener("click", () => {
          const panelId = btn.getAttribute("data-panel");
          if (!panelId) return;

          // Store active tab in sessionStorage
          sessionStorage.setItem('activeTab', panelId);
          window.location.hash = '#' + panelId;

          // Fast UI switch first - no heavy work here
          setActivePanel(panelId);

          // Defer heavy work so the click paints immediately
          requestAnimationFrame(() => {
            defer(() => {
              // Try to refresh audit data from Supabase when switching tabs (if data seems stale or missing)
              const propertyUrl = localStorage.getItem('gsc_property_url');
              const savedAudit = loadAuditResultsSync();
              const savedTimestamp = savedAudit?.timestamp;
              const hoursSinceLastAudit = savedTimestamp ? (Date.now() - savedTimestamp) / (1000 * 60 * 60) : Infinity;
              
              // If no data or data is more than 1 hour old, try to refresh from Supabase
              if ((!savedAudit || hoursSinceLastAudit > 1) && propertyUrl) {
                (async () => {
                  debugLog(` Tab switch: Attempting to refresh audit data from Supabase (${hoursSinceLastAudit > 1 ? 'data is stale' : 'no data found'})...`, 'info');
                  try {
                    const freshData = await fetchLatestAuditFromSupabase(propertyUrl);
                    if (freshData && freshData.timestamp) {
                      const freshTimestamp = freshData.timestamp;
                      // Only update if fresh data is newer
                      if (!savedTimestamp || freshTimestamp > savedTimestamp) {
                        safeSetLocalStorage('last_audit_results', freshData);
                        updateAuditTimestamp(freshTimestamp);
                        debugLog(` Tab switch: Refreshed audit data from Supabase (newer timestamp)`, 'success');
                      } else {
                        debugLog(` Tab switch: Supabase data is not newer than cached data`, 'info');
                      }
                    }
                  } catch (error) {
                    debugLog(` Tab switch: Failed to refresh from Supabase: ${error.message}`, 'warn');
                  }
                })();
              }

              // Lazy-render panel content (only first time)
              ensurePanelRendered(panelId);
            });
          });
        });
      });
    })();

      // Function to refresh only GSC queryTotals (CTR/Impressions) without running full audit
      window.refreshGSCDataOnly = async function refreshGSCDataOnly() {
        try {
          debugLog(' Refreshing GSC data only (CTR & Impressions)...', 'info');
          
          // Get existing audit data
          const savedAudit = loadAuditResultsSync();
          if (!savedAudit || !savedAudit.searchData) {
            debugLog(' No audit data found. Please run a full audit first.', 'warn');
            alert('No audit data found. Please run a full audit first.');
            return;
          }
          
          // Get keywords from existing ranking data
          let rankingData = [];
          
          // Try to get from RankingAiModule state first
          if (window.RankingAiModule && typeof window.RankingAiModule.state === 'function') {
            const state = window.RankingAiModule.state();
            rankingData = state.combinedRows || [];
            debugLog(` Found ${rankingData.length} keywords from RankingAiModule state`, 'info');
          }
          
          // Fallback: try to get from localStorage (check both possible keys)
          if (!rankingData || rankingData.length === 0) {
            try {
              let storedData = localStorage.getItem('rankingAiData'); // Primary key
              if (!storedData) {
                storedData = localStorage.getItem('ranking_ai_data'); // Alternative key
              }
              if (storedData) {
                const parsed = JSON.parse(storedData);
                if (parsed && parsed.combinedRows && Array.isArray(parsed.combinedRows)) {
                  rankingData = parsed.combinedRows;
                  debugLog(` Found ${rankingData.length} keywords from localStorage`, 'info');
                }
              }
            } catch (e) {
              debugLog(` Failed to parse ranking data from localStorage: ${e.message}`, 'warn');
            }
          }
          
          // Fallback: try to get from saved audit's keyword_rankings
          if (!rankingData || rankingData.length === 0) {
            if (savedAudit.keywordRankings && Array.isArray(savedAudit.keywordRankings)) {
              rankingData = savedAudit.keywordRankings;
              debugLog(` Found ${rankingData.length} keywords from saved audit`, 'info');
            }
          }
          
          // Final fallback: fetch keywords directly from Supabase
          if (!rankingData || rankingData.length === 0) {
            debugLog(' No ranking keywords in UI state, fetching from Supabase...', 'info');
            try {
              const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
              if (propertyUrl) {
                const supabaseResponse = await fetch(apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`));
                if (supabaseResponse.ok) {
                  const supabaseData = await supabaseResponse.json();
                  if (supabaseData.status === 'ok' && supabaseData.data?.rankingAiData?.combinedRows) {
                    rankingData = supabaseData.data.rankingAiData.combinedRows;
                    debugLog(` Fetched ${rankingData.length} keywords directly from Supabase`, 'success');
                  }
                }
              }
            } catch (supabaseErr) {
              debugLog(` Failed to fetch keywords from Supabase: ${supabaseErr.message}`, 'warn');
            }
          }
          
          if (!rankingData || rankingData.length === 0) {
            debugLog(' No ranking keywords found. Please run the ranking scan first.', 'warn');
            alert('No ranking keywords found. Please run the ranking scan first.');
            return;
          }
          
          const allKeywords = rankingData.map(r => r.keyword).filter(k => k && k.trim());
          if (allKeywords.length === 0) {
            debugLog(' No valid keywords found.', 'warn');
            alert('No valid keywords found.');
            return;
          }
          
          debugLog(` Fetching GSC queryTotals for ${allKeywords.length} keywords...`, 'info');
          
          const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
          if (!propertyUrl) {
            debugLog(' No property URL found.', 'warn');
            alert('No property URL found. Please configure GSC settings first.');
            return;
          }
          
          const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28');
          
          // Fetch queryTotals from GSC API
          const keywordsParam = encodeURIComponent(JSON.stringify(allKeywords));
          const propertyParam = encodeURIComponent(propertyUrl);
          const gscResponse = await fetch(apiUrl(`/api/aigeo/gsc-entity-metrics?property=${propertyParam}&keywords=${keywordsParam}&days=${dateRange}`));
          
          if (!gscResponse.ok) {
            const errorText = await gscResponse.text();
            debugLog(` Failed to fetch queryTotals from GSC: ${gscResponse.status} - ${errorText}`, 'error');
            alert(`Failed to fetch GSC data: ${gscResponse.status}`);
            return;
          }
          
          const gscData = await gscResponse.json();
          if (gscData.status !== 'ok' || !gscData.data || !Array.isArray(gscData.data.queryTotals)) {
            debugLog(` GSC API did not return queryTotals data`, 'warn');
            alert('GSC API did not return queryTotals data.');
            return;
          }
          
          const queryTotals = gscData.data.queryTotals;
          debugLog(` Fetched queryTotals for ${queryTotals.length} keywords from GSC`, 'success');
          
          // Merge queryTotals into searchData
          savedAudit.searchData.queryTotals = queryTotals;
          
          // Use the SAME audit_date as the existing audit
          let auditDate = new Date().toISOString().split('T')[0];
          if (savedAudit.timestamp) {
            try {
              auditDate = new Date(savedAudit.timestamp).toISOString().split('T')[0];
              debugLog(` Using existing audit date for queryTotals: ${auditDate}`, 'info');
            } catch (e) {
              debugLog(` Failed to parse saved audit timestamp, using today's date`, 'warn');
            }
          }
          
          // Save to Supabase
          const saveResponse = await fetch(apiUrl('/api/supabase/save-audit'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              propertyUrl: propertyUrl,
              auditDate: auditDate,
              searchData: savedAudit.searchData
            })
          });
          
          if (!saveResponse.ok) {
            const errorText = await saveResponse.text();
            debugLog(` Failed to save queryTotals to Supabase: ${saveResponse.status} - ${errorText}`, 'error');
            alert(`Failed to save to Supabase: ${saveResponse.status}`);
            return;
          }
          
          debugLog(` Saved queryTotals to Supabase (${queryTotals.length} keywords) for audit_date: ${auditDate}`, 'success');
          
          // Update localStorage
          try {
            safeSetLocalStorage('last_audit_results', savedAudit);
            debugLog(` Updated localStorage with queryTotals`, 'success');
          } catch (localStorageErr) {
            debugLog(` Failed to update localStorage: ${localStorageErr.message}`, 'warn');
          }
          
          // CRITICAL: Reload ranking data from Supabase to get latest search_volume values
          // The UI might be showing old localStorage data that doesn't have search_volume
          debugLog(' Reloading ranking data from Supabase to get latest search_volume...', 'info');
          try {
            const refreshedRankingData = await loadRankingAiDataFromStorage(true); // Force Supabase check
            if (refreshedRankingData && refreshedRankingData.combinedRows) {
              const mod = window.RankingAiModule;
              if (mod && typeof mod.setData === 'function') {
                const normalizedSummary = normalizeSummaryFields(refreshedRankingData.summary);
                mod.setData(refreshedRankingData.combinedRows, normalizedSummary);
                debugLog(` Reloaded ${refreshedRankingData.combinedRows.length} keywords from Supabase with latest search_volume`, 'success');
                
                // Check how many keywords now have search_volume
                const keywordsWithVolume = refreshedRankingData.combinedRows.filter(r => r.search_volume != null && r.search_volume !== undefined).length;
                debugLog(`  Keywords with search_volume: ${keywordsWithVolume}/${refreshedRankingData.combinedRows.length}`, 'info');
              }
            }
          } catch (reloadErr) {
            debugLog(` Failed to reload ranking data from Supabase: ${reloadErr.message}`, 'warn');
            // Continue anyway - at least GSC data was refreshed
          }
          
          // Re-render the table to show updated CTR/Impressions and search_volume
          if (typeof renderRankingAiTab === 'function') {
            renderRankingAiTab();
            debugLog(' Table re-rendered with updated GSC data and search_volume', 'success');
          }
          
          // Update last run timestamp
          updateAuditTimestamp(new Date().toISOString());
          
          debugLog(' GSC data refresh completed successfully!', 'success');
          alert(`Successfully refreshed GSC data for ${queryTotals.length} keywords!`);
          
        } catch (error) {
          debugLog(` Error refreshing GSC data: ${error.message}`, 'error');
          console.error('GSC refresh error:', error);
          alert(`Error refreshing GSC data: ${error.message}`);
        }
      }

      // Manual refresh button for Ranking & AI
      function wireRankingAiButton() {
        const refreshBtn = document.getElementById("ranking-ai-refresh");
        if (refreshBtn) {
          // Remove existing listener by cloning
          const newBtn = refreshBtn.cloneNode(true);
          refreshBtn.parentNode.replaceChild(newBtn, refreshBtn);
          
          newBtn.addEventListener("click", async () => {
            debugLog(' Ranking & AI button clicked', 'info');
            
            // Update UI immediately to show progress
            const lastRunEl = document.getElementById("ranking-ai-last-run");
            if (lastRunEl) {
              lastRunEl.textContent = "Starting...";
            }
            newBtn.disabled = true;
            newBtn.textContent = "Loading";
            
            try {
              if (typeof loadRankingAiData === 'function') {
                debugLog(' Calling loadRankingAiData (local)', 'info');
                await loadRankingAiData(true); // force re-run
              } else if (typeof window.loadRankingAiData === 'function') {
                debugLog(' Calling loadRankingAiData (window)', 'info');
                await window.loadRankingAiData(true); // force re-run
              } else {
                debugLog(' loadRankingAiData function not found', 'error');
                if (lastRunEl) {
                  lastRunEl.textContent = "Error: loadRankingAiData function not found";
                }
                newBtn.disabled = false;
                newBtn.textContent = "Run ranking & AI check";
              }
            } catch (err) {
              debugLog(` Error calling loadRankingAiData: ${err.message}`, 'error');
              console.error('Ranking & AI button error:', err);
              if (lastRunEl) {
                lastRunEl.textContent = `Error: ${err.message}`;
              }
              newBtn.disabled = false;
              newBtn.textContent = "Run ranking & AI check";
            }
          });
          debugLog(' Ranking & AI button wired up', 'success');
        } else {
          debugLog(' Ranking & AI button not found', 'warn');
        }
        
        // Wire up GSC refresh button
        const gscRefreshBtn = document.getElementById("ranking-gsc-refresh");
        if (gscRefreshBtn) {
          // Remove existing listener by cloning
          const newGscBtn = gscRefreshBtn.cloneNode(true);
          gscRefreshBtn.parentNode.replaceChild(newGscBtn, gscRefreshBtn);
          
          newGscBtn.addEventListener("click", async () => {
            debugLog(' GSC refresh button clicked', 'info');
            
            // Update UI immediately to show progress
            const lastRunEl = document.getElementById("ranking-ai-last-run");
            if (lastRunEl) {
              lastRunEl.textContent = "Refreshing GSC data...";
            }
            newGscBtn.disabled = true;
            newGscBtn.textContent = "Refreshing...";
            
            try {
              await window.refreshGSCDataOnly();
            } catch (err) {
              debugLog(` Error refreshing GSC data: ${err.message}`, 'error');
              console.error('GSC refresh button error:', err);
              if (lastRunEl) {
                lastRunEl.textContent = `Error: ${err.message}`;
              }
            } finally {
              newGscBtn.disabled = false;
              newGscBtn.textContent = "Refresh GSC Data";
              if (lastRunEl) {
                const now = new Date();
                const day = String(now.getUTCDate()).padStart(2, '0');
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const month = monthNames[now.getUTCMonth()];
                const year = now.getUTCFullYear();
                const hours = String(now.getUTCHours()).padStart(2, '0');
                const minutes = String(now.getUTCMinutes()).padStart(2, '0');
                const seconds = String(now.getUTCSeconds()).padStart(2, '0');
                lastRunEl.textContent = `Last refreshed: ${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
              }
            }
          });
          debugLog(' GSC refresh button wired up', 'success');
        } else {
          debugLog(' GSC refresh button not found', 'warn');
        }
      }

      // ======================
      // Domain Strength (manual monthly snapshot)
      // ======================
      function getSelfDomainForDomainStrength() {
        const propertyUrl =
          document.getElementById('propertyUrl')?.value ||
          localStorage.getItem('gsc_property_url') ||
          'https://www.alanranger.com';
        try {
          return new URL(propertyUrl).hostname.replace(/^www\./, '');
        } catch {
          return String(propertyUrl).replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0];
        }
      }

      function domainStrengthBandKey(band) {
        const b = String(band || '').trim();
        if (b === 'Very strong') return 'very-strong';
        if (b === 'Strong') return 'strong';
        if (b === 'Moderate') return 'moderate';
        if (b === 'Weak') return 'weak';
        if (b === 'Very weak') return 'very-weak';
        return 'na';
      }

      function renderDomainStrengthBandPill(band) {
        const original = String(band || '');
        const key = domainStrengthBandKey(original);
        // v1.3 UI label mapping: Low / Medium / High / Very High (derived from stored band)
        let label = '';
        if (original === 'Very strong') label = 'Very High';
        else if (original === 'Strong') label = 'High';
        else if (original === 'Moderate') label = 'Medium';
        else if (original === 'Weak' || original === 'Very weak') label = 'Low';
        else label = original;
        return `<span class="domain-strength-badge domain-strength-badge--${key}">${label}</span>`;
      }

      function formatDomainStrengthScore(score) {
        const n = typeof score === 'number' ? score : parseFloat(score);
        if (!isFinite(n)) return '';
        return Number(n).toFixed(1);
      }

      function computeDomainStrengthDelta(sortedAscRows) {
        const list = Array.isArray(sortedAscRows) ? sortedAscRows : [];
        if (list.length < 2) return null;
        const last = list[list.length - 1];
        const prev = list[list.length - 2];
        const a = typeof last?.score === 'number' ? last.score : parseFloat(last?.score);
        const b = typeof prev?.score === 'number' ? prev.score : parseFloat(prev?.score);
        if (!isFinite(a) || !isFinite(b)) return null;
        return a - b;
      }

      function getDomainStrengthDomainList(maxCompetitors = 20) {
        const domains = [];
        const seen = new Set();
        const self = getSelfDomainForDomainStrength();
        if (self) {
          seen.add(self);
          domains.push(self);
        }

        // Use Ranking AI combined rows as the source of competitor domains
        const mod = window.RankingAiModule;
        const combinedRows = mod?.state?.().combinedRows || [];
        const counts = {};

        for (const row of combinedRows) {
          const cc = row?.competitor_counts;
          if (!cc || typeof cc !== 'object') continue;
          for (const [domain, count] of Object.entries(cc)) {
            const d = String(domain || '').trim().replace(/^www\./, '');
            if (!d || seen.has(d)) continue;
            counts[d] = (counts[d] || 0) + (Number(count) || 0);
          }
        }

        const sorted = Object.entries(counts)
          .sort((a, b) => b[1] - a[1])
          .slice(0, Math.max(0, maxCompetitors))
          .map(([d]) => d);

        for (const d of sorted) {
          if (seen.has(d)) continue;
          seen.add(d);
          domains.push(d);
        }

        return domains;
      }

      const domainStrengthSparklineCharts = new Map();

      function safeDestroyDomainStrengthSparklines() {
        for (const ch of domainStrengthSparklineCharts.values()) {
          try { ch.destroy(); } catch { /* ignore */ }
        }
        domainStrengthSparklineCharts.clear();
      }

      function renderDomainStrengthSparklineChart(canvas, labels, scores) {
        if (!canvas) return;
        if (!window.Chart) {
          canvas.replaceWith(document.createTextNode(''));
          return;
        }
        const id = canvas.id || '';
        const existing = id ? domainStrengthSparklineCharts.get(id) : null;
        if (existing) {
          try { existing.destroy(); } catch { /* ignore */ }
          domainStrengthSparklineCharts.delete(id);
        }

        const pts = Array.isArray(scores) ? scores.map((v) => (typeof v === 'number' ? v : parseFloat(v))).filter((v) => isFinite(v)) : [];
        const labs = Array.isArray(labels) ? labels : [];
        if (pts.length === 0) {
          canvas.replaceWith(document.createTextNode(''));
          return;
        }

        const ctx = canvas.getContext('2d');
        const chart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labs,
            datasets: [{
              data: pts,
              borderColor: '#0284c7',
              backgroundColor: 'rgba(2, 132, 199, 0.15)',
              borderWidth: 2,
              pointRadius: pts.length === 1 ? 2.5 : 0,
              pointHoverRadius: 0,
              fill: false,
              tension: 0.35,
            }]
          },
          options: {
            responsive: false,
            maintainAspectRatio: false,
            animation: false,
            plugins: {
              legend: { display: false },
              tooltip: { enabled: false },
            },
            scales: {
              x: { display: false },
              y: { display: false, min: 0, max: 100 }
            },
            elements: { point: { hitRadius: 0 } }
          }
        });

        if (id) domainStrengthSparklineCharts.set(id, chart);
      }

      async function fetchDomainStrengthOverview() {
        const resp = await fetch(apiUrl('/api/domain-strength/overview'));
        const json = await resp.json();
        return json?.status === 'ok' ? (json.items || []) : [];
      }

      function formatIntegerOrDash(v) {
        const n = typeof v === 'number' ? v : parseFloat(v);
        if (!isFinite(n)) return '';
        return Math.round(n).toLocaleString();
      }

      function formatEtvDollars(v) {
        const n = typeof v === 'number' ? v : parseFloat(v);
        if (!isFinite(n)) return '';
        return '$' + Math.round(n).toLocaleString();
      }

      function formatDelta(delta) {
        if (delta === null || !isFinite(delta)) return '';
        const sign = delta > 0 ? '+' : '';
        return `${sign}${delta.toFixed(1)}`;
      }

      // Domain Strength sorting and pagination state
      let domainStrengthSortState = {
        column: 'name', // Default sort by name (alphabetical)
        direction: 'asc'
      };
      let domainStrengthPaginationState = {
        currentPage: 1,
        rowsPerPage: 10
      };
      let domainStrengthFilterState = {
        segment: null // Show all domains by default
      };
      let domainStrengthExpanded = false; // Collapsed by default

      // Sort domain strength rows
      function sortDomainStrengthRows(rows) {
        const sorted = [...rows];
        sorted.sort((a, b) => {
          let aVal, bVal;
          switch (domainStrengthSortState.column) {
            case 'name':
              aVal = (a?.label || a?.domain || '').toLowerCase();
              bVal = (b?.label || b?.domain || '').toLowerCase();
              break;
            case 'segment':
              aVal = a?.segment || '';
              bVal = b?.segment || '';
              break;
            case 'score':
              const as = a?.latest?.score;
              const bs = b?.latest?.score;
              aVal = typeof as === 'number' ? as : (isFinite(parseFloat(as)) ? parseFloat(as) : -1);
              bVal = typeof bs === 'number' ? bs : (isFinite(parseFloat(bs)) ? parseFloat(bs) : -1);
              break;
            case 'band':
              aVal = a?.latest?.band || '';
              bVal = b?.latest?.band || '';
              break;
            case 'etv':
              aVal = a?.latest?.organicEtv ?? 0;
              bVal = b?.latest?.organicEtv ?? 0;
              break;
            case 'top10':
              aVal = a?.latest?.top10Keywords ?? 0;
              bVal = b?.latest?.top10Keywords ?? 0;
              break;
            case 'change':
              aVal = a?.trend?.deltaLatest ?? -999;
              bVal = b?.trend?.deltaLatest ?? -999;
              break;
            default:
              return 0;
          }
          if (aVal < bVal) return domainStrengthSortState.direction === 'asc' ? -1 : 1;
          if (aVal > bVal) return domainStrengthSortState.direction === 'asc' ? 1 : -1;
          return 0;
        });
        return sorted;
      }

      async function renderDomainStrengthSection() {
        debugLog('[DomainStrength] renderDomainStrengthSection() called', 'info');
        const card = document.getElementById('domain-strength-summary-card');
        const tbody = document.getElementById('domain-strength-table-body');
        if (!tbody || !card) {
          debugLog('[DomainStrength] Missing card or tbody element', 'warn');
          return;
        }

        card.innerHTML = `<div style="color:#64748b; font-size:0.95rem;">Loading domain strength</div>`;
        tbody.innerHTML = '<tr><td colspan="8" class="ranking-table-empty">Loading</td></tr>';

        let items = [];
        try {
          debugLog('[DomainStrength] Fetching domain strength overview...', 'info');
          items = await fetchDomainStrengthOverview();
          debugLog(`[DomainStrength] Fetched ${items.length} items from API`, 'info');
        } catch (e) {
          const msg = e?.message || String(e);
          card.innerHTML = `<div style="color:#b91c1c;">Failed to load: ${msg}</div>`;
          tbody.innerHTML = `<tr><td colspan="8" class="ranking-table-empty">Failed to load: ${msg}</td></tr>`;
          return;
        }

        // v1.3: keep current single-engine view unless you add Bing later
        const engine = 'google';
        items = items.filter((it) => String(it?.searchEngine || '').toLowerCase() === engine);

        if (!items.length) {
          card.innerHTML = `
            <div style="font-weight:700; color:#0f172a; margin-bottom:0.25rem;">Domain Strength</div>
            <div style="color:#64748b; font-size:0.95rem;">No domain strength snapshots yet. Run a snapshot to populate this panel.</div>
          `;
          tbody.innerHTML = '<tr><td colspan="9" class="ranking-table-empty">No domain strength snapshots yet. Click "Run Domain Strength Snapshot".</td></tr>';
          return;
        }

        safeDestroyDomainStrengthSparklines();

        const selfDomain = getSelfDomainForDomainStrength();
        debugLog(`[DomainStrength] Self domain: ${selfDomain}`, 'info');
        
        // Don't filter - show all domains
        // Separate your site from competitors
        const selfItem = items.find((it) => String(it?.domain || '') === selfDomain) || null;
        // Only show domains EXPLICITLY marked as competitors (checkbox checked)
        // isCompetitor must be explicitly true, not just truthy
        const competitorItems = items.filter((it) => {
          const isCompetitor = it?.isCompetitor === true; // Only true, not just truthy
          const isNotSelf = String(it?.domain || '') !== selfDomain;
          return isCompetitor && isNotSelf;
        });
        
        console.log('[DomainStrength] Total items:', items.length, 'Competitors found:', competitorItems.length);
        
        if (selfItem && selfItem.latest) {
          debugLog(`[DomainStrength] Self item found: domain=${selfItem.domain}, score=${selfItem.latest.score}, snapshotDate=${selfItem.latest.snapshotDate}, createdAt=${selfItem.latest.createdAt}`, 'info');
        } else {
          debugLog(`[DomainStrength] Self item NOT found for domain: ${selfDomain}`, 'warn');
        }

        // Quick insight summary (your primary domain)
        if (selfItem && selfItem.latest) {
          const latest = selfItem.latest;
          debugLog(`[DomainStrength] Latest data: score=${latest.score}, snapshotDate=${latest.snapshotDate}, createdAt=${latest.createdAt}`, 'info');
          const delta = selfItem?.trend?.deltaLatest ?? null;
          const arrow = delta > 0.5 ? '' : (delta < -0.5 ? '' : '');
          const cls = delta > 0.5 ? 'kpi-trend-up' : (delta < -0.5 ? 'kpi-trend-down' : 'kpi-trend-flat');
          const changeText = delta === null ? '' : formatDelta(delta);
          const bandPill = renderDomainStrengthBandPill(latest.band);
          const label = selfItem.label || selfDomain;

          // Format last fetched timestamp (prefer createdAt, fallback to snapshotDate) in GMT
          let lastFetchedText = '';
          const timestampToUse = latest.createdAt || latest.snapshotDate;
          if (timestampToUse) {
            try {
              const timestamp = new Date(timestampToUse);
              if (!isNaN(timestamp.getTime())) {
                // Convert to GMT/UTC
                lastFetchedText = timestamp.toLocaleString('en-GB', {
                  timeZone: 'UTC',
                  year: 'numeric',
                  month: 'short',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                  hour12: false
                }) + ' GMT';
              }
            } catch (e) {
              // If date parsing fails, use raw string
              lastFetchedText = String(timestampToUse);
            }
          }

          card.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.35rem;">
              <div style="font-weight:700; color:#0f172a;">${label}</div>
              <div style="font-size: 0.75rem; color: #64748b; text-align: right;">
                <div style="font-weight: 600; color: #475569; margin-bottom: 0.125rem;">Last Fetched</div>
                <div>${lastFetchedText}</div>
              </div>
            </div>
            <div class="domain-strength-summary-top">
              <div class="domain-strength-summary-score">${formatDomainStrengthScore(latest.score)}</div>
              <div>${bandPill}</div>
            </div>
            <div style="margin-top:0.35rem; font-size:0.95rem;">
              <span class="${cls}" title="Change vs last snapshot: ${changeText}">${arrow} ${delta === null ? 'No previous snapshot data yet' : `${changeText} vs last snapshot`}</span>
            </div>
            <div class="domain-strength-summary-subtitle">
              Domain strength ${formatDomainStrengthScore(latest.score)} on Google  ${delta === null ? 'no previous snapshot yet' : `${changeText} vs last snapshot`};
              ${formatIntegerOrDash(latest.top10Keywords)} top10 keywords and estimated traffic ${formatEtvDollars(latest.organicEtv)}/month.
            </div>
          `;
        } else {
          card.innerHTML = `
            <div style="font-weight:700; color:#0f172a; margin-bottom:0.25rem;">${selfDomain || 'Your site'}</div>
            <div style="color:#64748b; font-size:0.95rem;">No domain strength snapshots yet. Run a snapshot to populate this card.</div>
          `;
        }

        // Sort competitors by strength score (highest to lowest) - ALWAYS by score desc
        // This ensures competitors are shown in order of strength (highest first)
        const sortedCompetitors = [...competitorItems].sort((a, b) => {
          const aScore = typeof a?.latest?.score === 'number' ? a.latest.score : (parseFloat(a?.latest?.score) || 0);
          const bScore = typeof b?.latest?.score === 'number' ? b.latest.score : (parseFloat(b?.latest?.score) || 0);
          return bScore - aScore; // Descending - highest score first
        });
        
        console.log('[DomainStrength] Competitors found:', sortedCompetitors.length, 'sorted by strength score (highest first)');

        // Build final sorted array: your site first, then top competitors
        let sorted = [];
        if (selfItem) {
          sorted.push(selfItem);
        }
        sorted.push(...sortedCompetitors);

        // Calculate pagination
        const totalRows = sorted.length;
        const rowsPerPage = domainStrengthPaginationState.rowsPerPage === 'all' ? totalRows : domainStrengthPaginationState.rowsPerPage;
        const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
        const currentPage = Math.min(Math.max(1, domainStrengthPaginationState.currentPage), totalPages);
        domainStrengthPaginationState.currentPage = currentPage;
        
        const startIdx = rowsPerPage === 'all' ? 0 : (currentPage - 1) * rowsPerPage;
        const endIdx = rowsPerPage === 'all' ? totalRows : Math.min(startIdx + rowsPerPage, totalRows);
        const paginatedRows = sorted.slice(startIdx, endIdx);

        // Determine visible rows based on expand/collapse state
        // Always show your site (first row), then top 2 competitors = 3 rows total
        // If your site is not in paginated rows, show first 3 rows
        const selfRowIndex = paginatedRows.findIndex((it) => String(it?.domain || '') === selfDomain);
        let visibleRows;
        if (domainStrengthExpanded) {
          visibleRows = paginatedRows;
        } else {
          if (selfRowIndex >= 0) {
            // Your site is in the paginated rows
            // Show your site + next 2 rows (competitors)
            visibleRows = paginatedRows.slice(0, Math.min(selfRowIndex + 3, paginatedRows.length));
          } else {
            // Your site not in current page, just show first 3
            visibleRows = paginatedRows.slice(0, 3);
          }
        }
        const hiddenRowsCount = paginatedRows.length - visibleRows.length;

        tbody.innerHTML = '';
        for (const it of visibleRows) {
          const latest = it?.latest || null;
          const delta = it?.trend?.deltaLatest ?? null;
          const points = Array.isArray(it?.trend?.points) ? it.trend.points : [];
          const last12 = points.slice(-12);
          const labels = last12.map((p) => p.date);
          const scores = last12.map((p) => p.score);

          const safeId = String(it?.domain || '')
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/(^-|-$)/g, '');
          const canvasId = `domain-strength-spark-${safeId || Math.random().toString(36).slice(2)}`;

          const arrow = delta > 0.5 ? '' : (delta < -0.5 ? '' : '');
          const cls = delta > 0.5 ? 'kpi-trend-up' : (delta < -0.5 ? 'kpi-trend-down' : 'kpi-trend-flat');
          const changeTitle = delta === null ? 'No previous snapshot yet' : `Change vs last snapshot: ${formatDelta(delta)}`;

          // Check if this is the self domain row
          const isSelfDomain = String(it?.domain || '') === selfDomain;
          const rowStyle = isSelfDomain ? 'font-weight: 700; background-color: #fefce8;' : '';

          const tr = document.createElement('tr');
          if (isSelfDomain) {
            tr.id = 'domain-strength-self-row';
            tr.style.fontWeight = '700';
            tr.style.backgroundColor = '#fefce8';
          }
          // Create clickable domain link
          const domainName = it?.domain || '';
          const displayName = it?.label || it?.domain || '';
          const domainLink = domainName ? `<a href="https://${domainName}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none; ${isSelfDomain ? 'font-weight: 700;' : ''}" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${displayName}</a>` : displayName;
          
          // Get domain type and competitor flag - use domain_type directly, fallback to segment, only default to 'unmapped' if both are missing
          const domainType = it?.domain_type || it?.segment || 'unmapped';
          const isCompetitor = it?.isCompetitor === true;
          const normalizedDomain = normalizeDomainForStrength(domainName);
          
          tr.innerHTML = `
            <td style="text-align:left; ${isSelfDomain ? 'font-weight: 700;' : ''}">${domainLink}</td>
            <td style="${isSelfDomain ? 'font-weight: 700;' : ''}"><span data-domain-type-display="${normalizedDomain}">${domainType}</span></td>
            <td style="text-align:center; ${isSelfDomain ? 'font-weight: 700;' : ''}">${latest ? formatDomainStrengthScore(latest.score) : ''}</td>
            <td style="${isSelfDomain ? 'font-weight: 700;' : ''}">${latest ? renderDomainStrengthBandPill(latest.band) : ''}</td>
            <td style="text-align:right; white-space: nowrap; ${isSelfDomain ? 'font-weight: 700;' : ''}">${latest ? formatEtvDollars(latest.organicEtv) : ''}</td>
            <td style="text-align:right; white-space: nowrap; ${isSelfDomain ? 'font-weight: 700;' : ''}">${latest ? formatIntegerOrDash(latest.top10Keywords) : ''}</td>
            <td style="text-align:center; ${isSelfDomain ? 'font-weight: 700;' : ''}"><span class="${cls}" title="${changeTitle}">${delta === null ? '' : `${arrow} ${formatDelta(delta)}`}</span></td>
            <td style="text-align:center;">
              <canvas class="domain-strength-sparkline" id="${canvasId}" width="140" height="28" aria-label="12 month score trend"></canvas>
            </td>
            <td style="text-align:center;"></td>
          `;
          tbody.appendChild(tr);
          
          // Add domain type dropdown to the Domain type cell
          const domainTypeCell = tr.querySelector(`td:nth-child(2)`);
          const domainTypeDisplay = domainTypeCell.querySelector(`[data-domain-type-display="${normalizedDomain}"]`);
          if (domainTypeDisplay && domainTypeCell) {
            domainTypeCell.innerHTML = '';
            const domainTypeSelect = document.createElement('select');
            domainTypeSelect.style.padding = '0.4rem 0.6rem';
            domainTypeSelect.style.border = '1px solid #cbd5e1';
            domainTypeSelect.style.borderRadius = '4px';
            domainTypeSelect.style.fontSize = '0.85rem';
            domainTypeSelect.style.background = 'white';
            domainTypeSelect.style.cursor = 'pointer';
            domainTypeSelect.style.minWidth = '120px';
            domainTypeSelect.dataset.domain = normalizedDomain;
            
            const domainTypes = [
              { value: 'unmapped', label: 'Unmapped' },
              { value: 'your_site', label: 'Your site' },
              { value: 'platform', label: 'Platform' },
              { value: 'directory', label: 'Directory' },
              { value: 'publisher', label: 'Publisher' },
              { value: 'vendor', label: 'Vendor' },
              { value: 'institution', label: 'Institution' },
              { value: 'government', label: 'Government' },
              { value: 'site', label: 'Site' }
            ];
            
            // Get the actual domain_type from the data - check both domain_type and segment fields
            let actualDomainType = 'unmapped';
            if (it?.domain_type && typeof it.domain_type === 'string' && it.domain_type.trim()) {
              actualDomainType = it.domain_type.trim();
            } else if (it?.segment && typeof it.segment === 'string' && it.segment.trim()) {
              actualDomainType = it.segment.trim();
            }
            
            // Ensure the value matches one of the valid options
            const validValues = domainTypes.map(dt => dt.value);
            if (!validValues.includes(actualDomainType)) {
              actualDomainType = 'unmapped';
            }
            
            // Create options first, then set the value
            domainTypes.forEach(({ value, label }) => {
              const option = document.createElement('option');
              option.value = value;
              option.textContent = label;
              if (value === actualDomainType) {
                option.selected = true;
              }
              domainTypeSelect.appendChild(option);
            });
            
            // Explicitly set the value after options are added
            domainTypeSelect.value = actualDomainType;
            
            domainTypeSelect.addEventListener('change', async (e) => {
              const newType = e.target.value;
              const domain = e.target.dataset.domain;
              try {
                const resp = await fetch(apiUrl('/api/domain-strength/update-domain'), {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ domain, domain_type: newType })
                });
                if (resp.ok) {
                  __domainMetadataCache.delete(domain);
                  // Refresh the table to show updated values
                  await renderDomainStrengthSection();
                } else {
                  e.target.value = domainType;
                  alert('Failed to update domain type. Please try again.');
                }
              } catch (err) {
                e.target.value = domainType;
                alert('Error updating domain type: ' + err.message);
              }
            });
            
            domainTypeCell.appendChild(domainTypeSelect);
          }
          
          // Add competitor checkbox to the Competitor cell
          const competitorCell = tr.querySelector(`td:nth-child(9)`);
          if (competitorCell) {
            const competitorCheckbox = document.createElement('input');
            competitorCheckbox.type = 'checkbox';
            competitorCheckbox.checked = isCompetitor;
            competitorCheckbox.style.cursor = 'pointer';
            competitorCheckbox.dataset.domain = normalizedDomain;
            
            competitorCheckbox.addEventListener('change', async (e) => {
              const isComp = e.target.checked;
              const domain = e.target.dataset.domain;
              try {
                const resp = await fetch(apiUrl('/api/domain-strength/update-domain'), {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ domain, is_competitor: isComp })
                });
                if (resp.ok) {
                  __domainMetadataCache.delete(domain);
                  // Refresh the table to show updated values
                  await renderDomainStrengthSection();
                } else {
                  e.target.checked = !isComp;
                  alert('Failed to update competitor flag. Please try again.');
                }
              } catch (err) {
                e.target.checked = !isComp;
                alert('Error updating competitor flag: ' + err.message);
              }
            });
            
            competitorCell.appendChild(competitorCheckbox);
          }

          const canvas = document.getElementById(canvasId);
          renderDomainStrengthSparklineChart(canvas, labels, scores);
        }

        // Add expand/collapse row if there are hidden rows
        if (!domainStrengthExpanded && hiddenRowsCount > 0) {
          const expandRow = document.createElement('tr');
          expandRow.id = 'domain-strength-expand-row';
          expandRow.style.cursor = 'pointer';
          expandRow.style.backgroundColor = '#f8fafc';
          expandRow.style.borderTop = '2px solid #e2e8f0';
          expandRow.innerHTML = `
            <td colspan="9" style="text-align: center; padding: 1rem; color: #2563eb; font-weight: 600; font-size: 0.95rem;">
              <span style="display: inline-flex; align-items: center; gap: 0.5rem;">
                <span style="font-size: 1.1rem;"></span>
                <span>Show ${hiddenRowsCount} more row${hiddenRowsCount !== 1 ? 's' : ''}</span>
              </span>
            </td>
          `;
          expandRow.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            domainStrengthExpanded = true;
            renderDomainStrengthSection();
          });
          expandRow.addEventListener('mouseenter', () => {
            expandRow.style.backgroundColor = '#e0f2fe';
          });
          expandRow.addEventListener('mouseleave', () => {
            expandRow.style.backgroundColor = '#f8fafc';
          });
          tbody.appendChild(expandRow);
        } else if (domainStrengthExpanded && paginatedRows.length > 3) {
          const collapseRow = document.createElement('tr');
          collapseRow.id = 'domain-strength-collapse-row';
          collapseRow.style.cursor = 'pointer';
          collapseRow.style.backgroundColor = '#f8fafc';
          collapseRow.style.borderTop = '2px solid #e2e8f0';
          collapseRow.innerHTML = `
            <td colspan="9" style="text-align: center; padding: 1rem; color: #2563eb; font-weight: 600; font-size: 0.95rem;">
              <span style="display: inline-flex; align-items: center; gap: 0.5rem;">
                <span style="font-size: 1.1rem;"></span>
                <span>Show less</span>
              </span>
            </td>
          `;
          collapseRow.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            domainStrengthExpanded = false;
            renderDomainStrengthSection();
          });
          collapseRow.addEventListener('mouseenter', () => {
            collapseRow.style.backgroundColor = '#e0f2fe';
          });
          collapseRow.addEventListener('mouseleave', () => {
            collapseRow.style.backgroundColor = '#f8fafc';
          });
          tbody.appendChild(collapseRow);
        }

        // Update sort indicators
        document.querySelectorAll('#domain-strength-table th.sortable').forEach(th => {
          th.classList.remove('sort-asc', 'sort-desc');
          if (th.dataset.sort === domainStrengthSortState.column) {
            th.classList.add(`sort-${domainStrengthSortState.direction}`);
          }
        });

        // Update pagination controls
        const paginationInfo = document.getElementById('domain-strength-pagination-info');
        const prevBtn = document.getElementById('domain-strength-pagination-prev');
        const nextBtn = document.getElementById('domain-strength-pagination-next');
        const rowsPerPageSelect = document.getElementById('domain-strength-rows-per-page');
        
        if (paginationInfo) {
          paginationInfo.textContent = totalPages > 1 
            ? `Page ${currentPage} of ${totalPages}  Showing ${startIdx + 1}-${endIdx} of ${totalRows}`
            : `Total: ${totalRows}`;
        }
        
        if (prevBtn) {
          prevBtn.disabled = currentPage === 1;
          prevBtn.style.background = currentPage === 1 ? '#f1f5f9' : 'white';
          prevBtn.style.cursor = currentPage === 1 ? 'not-allowed' : 'pointer';
          prevBtn.style.color = currentPage === 1 ? '#94a3b8' : '#475569';
        }
        
        if (nextBtn) {
          nextBtn.disabled = currentPage === totalPages;
          nextBtn.style.background = currentPage === totalPages ? '#f1f5f9' : 'white';
          nextBtn.style.cursor = currentPage === totalPages ? 'not-allowed' : 'pointer';
          nextBtn.style.color = currentPage === totalPages ? '#94a3b8' : '#475569';
        }
        
        if (rowsPerPageSelect) {
          rowsPerPageSelect.value = domainStrengthPaginationState.rowsPerPage;
        }

        // Re-wire sorting and pagination after render
        wireDomainStrengthSorting();
        wireDomainStrengthPagination();
      }

      async function runDomainStrengthSnapshot() {
        debugLog('[DomainStrength] runDomainStrengthSnapshot() called', 'info');
        const statusEl = document.getElementById('domain-strength-run-status');
        const btn = document.getElementById('domain-strength-run-btn');
        const overlay = document.getElementById('domain-strength-overlay');
        const overlayStatus = document.getElementById('domain-strength-overlay-status');

        // Don't send core domains - API will handle alanranger.com + pending queue
        // This ensures cost control: only fetch domains that don't have snapshots this month
        const domains = [];

        // Show overlay
        if (overlay) {
          overlay.classList.add('show');
        }
        if (overlayStatus) {
          overlayStatus.textContent = `Fetching alanranger.com + up to 100 pending domains (skipping domains already processed this month)...`;
        }

        if (btn) {
          btn.disabled = true;
          btn.textContent = 'Running';
        }
        if (statusEl) statusEl.textContent = `Running snapshot (alanranger.com + pending queue)...`;

        try {
          const apiEndpoint = apiUrl('/api/domain-strength/snapshot');
          debugLog(`[DomainStrength] Calling API: ${apiEndpoint}`, 'info');
          debugLog(`[DomainStrength] Request: mode=run, includePending=true`, 'info');
          
          if (overlayStatus) {
            overlayStatus.textContent = `Calling DataForSEO API (alanranger.com + pending domains)...`;
          }
          
          const resp = await fetch(apiEndpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ mode: 'run', domains: [], includePending: true })
          });
          
          debugLog(`[DomainStrength] API response status: ${resp.status} ${resp.statusText}`, 'info');
          
          if (overlayStatus) {
            overlayStatus.textContent = 'Processing response and saving to database...';
          }
          
          let json;
          try {
            const responseText = await resp.text();
            debugLog(`[DomainStrength] API response text (first 200 chars): ${responseText.substring(0, 200)}`, 'info');
            json = JSON.parse(responseText);
          } catch (parseError) {
            debugLog(`[DomainStrength] Failed to parse JSON response: ${parseError.message}`, 'error');
            throw new Error(`API returned invalid JSON (status ${resp.status}). Response may be an error page.`);
          }
          
          debugLog(`[DomainStrength] API response: status=${json?.status}, inserted=${json?.inserted}, snapshot_date=${json?.snapshot_date}, domains_processed=${json?.domains_processed}`, 'info');
          debugLog(`[DomainStrength] Debug info: ${JSON.stringify(json?.debug || {})}`, 'info');
          
          // Update overlay message with actual domain count from API (includes pending domains)
          const actualDomainCount = json?.domains_processed || 1;
          if (overlayStatus) {
            overlayStatus.textContent = `Calling DataForSEO API for ${actualDomainCount} domains (alanranger.com + ${actualDomainCount - 1} pending)...`;
          }
          
          if (json?.status !== 'ok') {
            const errorMsg = json?.message || json?.details || 'Snapshot failed';
            debugLog(`[DomainStrength] API returned error: ${errorMsg}`, 'error');
            throw new Error(errorMsg);
          }
          
          debugLog(`[DomainStrength]  Snapshot successful: ${json.inserted || 0} domains saved (date: ${json.snapshot_date})`, 'success');
          
          // Fetch remaining pending count
          let remainingPending = 0;
          try {
            const pendingResp = await fetch(apiUrl('/api/domain-strength/pending-count'));
            if (pendingResp.ok) {
              const pendingData = await pendingResp.json();
              remainingPending = pendingData.count || 0;
            }
          } catch (e) {
            debugLog(`[DomainStrength] Could not fetch pending count: ${e.message}`, 'warn');
          }
          
          // Hide progress overlay
          if (overlay) {
            overlay.classList.remove('show');
          }
          
          // Show completion modal
          const completionModal = document.getElementById('domain-strength-completion-modal');
          const completionStats = document.getElementById('domain-strength-completion-stats');
          if (completionModal && completionStats) {
            const domainsProcessed = json.domains_processed || 0;
            const domainsInserted = json.inserted || 0;
            const domainsFetched = json.fetched || 0;
            
            completionStats.innerHTML = `
              <div style="margin-bottom: 1rem; padding: 1rem; background: #f0f9ff; border-radius: 8px; border-left: 4px solid #0ea5e9;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                  <span style="font-weight: 600; color: #0c4a6e;">Domains Processed:</span>
                  <span style="font-size: 1.25rem; font-weight: 700; color: #0284c7;">${domainsProcessed}</span>
                </div>
                <div style="font-size: 0.875rem; color: #075985;">
                  ${domainsFetched} fetched from DataForSEO  ${domainsInserted} snapshots saved
                </div>
              </div>
              <div style="padding: 1rem; background: ${remainingPending > 0 ? '#fef3c7' : '#f0fdf4'}; border-radius: 8px; border-left: 4px solid ${remainingPending > 0 ? '#f59e0b' : '#10b981'};">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                  <span style="font-weight: 600; color: ${remainingPending > 0 ? '#92400e' : '#065f46'};">Remaining in Queue:</span>
                  <span style="font-size: 1.25rem; font-weight: 700; color: ${remainingPending > 0 ? '#d97706' : '#059669'};">${remainingPending}</span>
                </div>
                ${remainingPending > 0 ? '<div style="font-size: 0.875rem; color: #78350f; margin-top: 0.5rem;">Run snapshot again to process more domains</div>' : '<div style="font-size: 0.875rem; color: #047857; margin-top: 0.5rem;">All domains have been processed!</div>'}
              </div>
            `;
            
            completionModal.style.display = 'flex';
            
            // Wire up close button
            const closeBtn = document.getElementById('domain-strength-completion-close');
            if (closeBtn) {
              closeBtn.onclick = () => {
                completionModal.style.display = 'none';
              };
            }
          }
          
          if (statusEl) statusEl.textContent = ` Snapshot saved for ${json.inserted || 0} domains (date: ${json.snapshot_date}).`;
          showStatus(` Domain strength snapshot saved (${json.snapshot_date})`, 'success');
          
          debugLog('[DomainStrength] Refreshing domain strength section...', 'info');
          await renderDomainStrengthSection();
          debugLog('[DomainStrength]  Domain strength section refreshed', 'success');
        } catch (e) {
          const msg = e?.message || String(e);
          debugLog(`[DomainStrength]  Snapshot error: ${msg}`, 'error');
          if (overlayStatus) {
            overlayStatus.textContent = ` Error: ${msg}`;
          }
          if (statusEl) statusEl.textContent = ` Snapshot failed: ${msg}`;
          showStatus(` Domain strength snapshot failed: ${msg}`, 'error');
          // Keep overlay visible for a moment to show error
          await new Promise(resolve => setTimeout(resolve, 2000));
          
          // Hide overlay on error
          if (overlay) {
            overlay.classList.remove('show');
          }
        } finally {
          if (btn) {
            btn.disabled = false;
            btn.textContent = 'Run Domain Strength Snapshot (Google)';
          }
        }
      }

      function wireDomainStrengthButton() {
        const btn = document.getElementById('domain-strength-run-btn');
        if (!btn) return;
        const newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);
        newBtn.addEventListener('click', () => {
          runDomainStrengthSnapshot();
        });

        // Render current view (if history exists) once the ranking module has data
        try {
          renderDomainStrengthSection();
        } catch {
          // ignore
        }
      }

      function wireDomainStrengthSorting() {
        const sortableHeaders = document.querySelectorAll('#domain-strength-table th.sortable');
        if (!sortableHeaders || sortableHeaders.length === 0) return;
        
        // Remove existing listeners by cloning (preserve innerHTML structure)
        sortableHeaders.forEach(th => {
          if (th.dataset.sortWired === 'true') {
            const newTh = th.cloneNode(true);
            th.parentNode.replaceChild(newTh, th);
          }
        });
        
        // Re-query after cloning to get fresh elements
        const freshHeaders = document.querySelectorAll('#domain-strength-table th.sortable');
        
        freshHeaders.forEach(th => {
          th.dataset.sortWired = 'true';
          
          // Use a named function to make debugging easier
          const handleSortClick = function(e) {
            e.stopPropagation();
            e.preventDefault();
            const column = this.dataset.sort;
            if (!column) {
              console.warn('[DomainStrength] No sort column found on clicked header');
              return;
            }
            
            console.log('[DomainStrength] Sort clicked:', column, 'Current state:', domainStrengthSortState);
            
            if (domainStrengthSortState.column === column) {
              // Toggle direction if clicking the same column
              domainStrengthSortState.direction = domainStrengthSortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
              // New column, start with ascending
              domainStrengthSortState.column = column;
              domainStrengthSortState.direction = 'asc';
            }
            
            console.log('[DomainStrength] New sort state:', domainStrengthSortState);
            
            domainStrengthPaginationState.currentPage = 1;
            renderDomainStrengthSection();
          };
          
          th.addEventListener('click', handleSortClick);
        });
        
        console.log('[DomainStrength] Wired', freshHeaders.length, 'sortable headers');
      }

      function wireDomainStrengthPagination() {
        const prevBtn = document.getElementById('domain-strength-pagination-prev');
        const nextBtn = document.getElementById('domain-strength-pagination-next');
        const rowsPerPageSelect = document.getElementById('domain-strength-rows-per-page');
        
        if (prevBtn) {
          const newPrevBtn = prevBtn.cloneNode(true);
          prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
          newPrevBtn.addEventListener('click', () => {
            if (domainStrengthPaginationState.currentPage > 1) {
              domainStrengthPaginationState.currentPage--;
              renderDomainStrengthSection();
            }
          });
        }
        
        if (nextBtn) {
          const newNextBtn = nextBtn.cloneNode(true);
          nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
          newNextBtn.addEventListener('click', () => {
            // Re-fetch items to get accurate total
            fetchDomainStrengthOverview().then(items => {
              const engine = 'google';
              const filtered = items.filter((it) => String(it?.searchEngine || '').toLowerCase() === engine);
              const totalRows = filtered.length;
              const rowsPerPage = domainStrengthPaginationState.rowsPerPage === 'all' ? totalRows : domainStrengthPaginationState.rowsPerPage;
              const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
              if (domainStrengthPaginationState.currentPage < totalPages) {
                domainStrengthPaginationState.currentPage++;
                renderDomainStrengthSection();
              }
            }).catch(() => {
              // If fetch fails, just increment and re-render
              domainStrengthPaginationState.currentPage++;
              renderDomainStrengthSection();
            });
          });
        }
        
        if (rowsPerPageSelect) {
          const newSelect = rowsPerPageSelect.cloneNode(true);
          rowsPerPageSelect.parentNode.replaceChild(newSelect, rowsPerPageSelect);
          newSelect.value = domainStrengthPaginationState.rowsPerPage;
          newSelect.addEventListener('change', (e) => {
            const value = e.target.value;
            domainStrengthPaginationState.rowsPerPage = value === 'all' ? 'all' : parseInt(value, 10);
            domainStrengthPaginationState.currentPage = 1;
            renderDomainStrengthSection();
          });
        }
      }
      
      // Wire button immediately
      wireRankingAiButton();
      // Wire domain strength button immediately
      if (typeof wireDomainStrengthButton === 'function') wireDomainStrengthButton();
      wireRankingFilters();
      wireRankingSorting();
      wireRankingPagination();
      wireDomainStrengthSorting();
      wireDomainStrengthPagination();
      
      // Make functions globally available for panel switching
      window.wireRankingAiButton = wireRankingAiButton;
      window.wireDomainStrengthButton = wireDomainStrengthButton;
      window.wireRankingFilters = wireRankingFilters;
      window.wireRankingSorting = wireRankingSorting;
      window.wireDomainStrengthSorting = wireDomainStrengthSorting;
      window.wireDomainStrengthPagination = wireDomainStrengthPagination;

      function wireRankingFilters() {
        const segmentFilter = document.getElementById("ranking-filter-segment");
        const rankFilter = document.getElementById("ranking-filter-rank");
        const volumeFilter = document.getElementById("ranking-filter-volume");
        const ctrFilter = document.getElementById("ranking-filter-ctr");
        const aiOverviewFilter = document.getElementById("ranking-filter-ai-overview");
        const aiCitationFilter = document.getElementById("ranking-filter-ai-citation");
        const opportunityFilter = document.getElementById("ranking-filter-opportunity");
        const pageTypeFilter = document.getElementById("ranking-filter-page-type");
        const serpFeaturesFilter = document.getElementById("ranking-filter-serp-features");
        const optimisationStatusFilter = document.getElementById("ranking-filter-optimisation-status");
        const keywordFilter = document.getElementById("ranking-filter-keyword");
        const clearBtn = document.getElementById("ranking-filter-clear");

        // Update active state styling for filters
        const updateFilterActiveStates = () => {
          const filterControls = [
            { el: segmentFilter, value: rankingFilterState.segment },
            { el: rankFilter, value: rankingFilterState.rank },
            { el: volumeFilter, value: rankingFilterState.volume },
            { el: ctrFilter, value: rankingFilterState.ctr },
            { el: aiOverviewFilter, value: rankingFilterState.aiOverview },
            { el: aiCitationFilter, value: rankingFilterState.aiCitation },
            { el: opportunityFilter, value: rankingFilterState.opportunity },
            { el: pageTypeFilter, value: rankingFilterState.pageType },
            { el: serpFeaturesFilter, value: rankingFilterState.serpFeatures },
            { el: optimisationStatusFilter, value: rankingFilterState.optimisationStatus }
          ];

          filterControls.forEach(({ el, value }) => {
            if (el) {
              if (value && value !== 'all') {
                el.classList.add('filter-active');
              } else {
                el.classList.remove('filter-active');
              }
            }
          });

          // Handle keyword filter separately (active if not empty)
          if (keywordFilter) {
            if (rankingFilterState.keyword && rankingFilterState.keyword.trim() !== '') {
              keywordFilter.classList.add('filter-active');
            } else {
              keywordFilter.classList.remove('filter-active');
            }
          }
        };

        const minOpportunityInput = document.getElementById("ranking-filter-min-opportunity");
        const minOpportunityNote = document.getElementById("ranking-filter-min-opportunity-note");

        const updateFilters = () => {
          if (segmentFilter) rankingFilterState.segment = segmentFilter.value;
          if (rankFilter) rankingFilterState.rank = rankFilter.value;
          if (volumeFilter) rankingFilterState.volume = volumeFilter.value;
          if (ctrFilter) rankingFilterState.ctr = ctrFilter.value;
          if (aiOverviewFilter) rankingFilterState.aiOverview = aiOverviewFilter.value;
          if (aiCitationFilter) rankingFilterState.aiCitation = aiCitationFilter.value;
          if (opportunityFilter) rankingFilterState.opportunity = opportunityFilter.value;
          if (pageTypeFilter) rankingFilterState.pageType = pageTypeFilter.value;
          if (serpFeaturesFilter) rankingFilterState.serpFeatures = serpFeaturesFilter.value;
          if (optimisationStatusFilter) rankingFilterState.optimisationStatus = optimisationStatusFilter.value;
          if (keywordFilter) rankingFilterState.keyword = keywordFilter.value.trim();
          
          // Min opportunity filter
          if (minOpportunityInput) {
            const minOppValue = minOpportunityInput.value.trim();
            if (minOppValue === '') {
              rankingFilterState.minOpportunity = null;
              if (minOpportunityNote) minOpportunityNote.style.display = 'none';
            } else {
              const numValue = Number(minOppValue);
              if (Number.isFinite(numValue) && numValue >= 0 && numValue <= 100) {
                rankingFilterState.minOpportunity = numValue;
                if (minOpportunityNote) minOpportunityNote.style.display = 'block';
              } else {
                rankingFilterState.minOpportunity = null;
                if (minOpportunityNote) minOpportunityNote.style.display = 'none';
              }
            }
          }
          
          // Update active states
          updateFilterActiveStates();
          
          rankingPaginationState.currentPage = 1; // Reset to first page on filter change
          renderRankingAiTab();
        };

        // Debounce function for keyword filter to improve performance
        let keywordFilterTimeout = null;
        const debouncedUpdateFilters = () => {
          // Update the keyword value immediately for active state
          if (keywordFilter) {
            rankingFilterState.keyword = keywordFilter.value.trim();
            updateFilterActiveStates();
          }
          
          // Clear existing timeout
          if (keywordFilterTimeout) {
            clearTimeout(keywordFilterTimeout);
          }
          
          // Set new timeout to actually apply the filter after user stops typing
          keywordFilterTimeout = setTimeout(() => {
            updateFilters();
            keywordFilterTimeout = null;
          }, 300); // 300ms delay
        };

        if (segmentFilter) segmentFilter.addEventListener("change", updateFilters);
        if (rankFilter) rankFilter.addEventListener("change", updateFilters);
        if (volumeFilter) volumeFilter.addEventListener("change", updateFilters);
        if (ctrFilter) ctrFilter.addEventListener("change", updateFilters);
        if (aiOverviewFilter) aiOverviewFilter.addEventListener("change", updateFilters);
        if (aiCitationFilter) aiCitationFilter.addEventListener("change", updateFilters);
        if (opportunityFilter) opportunityFilter.addEventListener("change", updateFilters);
        if (pageTypeFilter) pageTypeFilter.addEventListener("change", updateFilters);
        if (serpFeaturesFilter) serpFeaturesFilter.addEventListener("change", updateFilters);
        if (optimisationStatusFilter) optimisationStatusFilter.addEventListener("change", updateFilters);
        if (keywordFilter) keywordFilter.addEventListener("input", debouncedUpdateFilters);
        if (minOpportunityInput) {
          minOpportunityInput.addEventListener("input", debouncedUpdateFilters);
          minOpportunityInput.addEventListener("blur", updateFilters);
        }

        if (clearBtn) {
          clearBtn.addEventListener("click", () => {
            // Cancel any pending debounced keyword filter updates
            if (keywordFilterTimeout) {
              clearTimeout(keywordFilterTimeout);
              keywordFilterTimeout = null;
            }
            
            rankingFilterState = {
              segment: 'all',
              rank: 'all',
              volume: 'all',
              ctr: 'all',
              opportunity: 'all',
              aiOverview: 'all',
              aiCitation: 'all',
              pageType: 'all',
              serpFeatures: 'all',
              optimisationStatus: 'all',
              keyword: '',
              minOpportunity: null
            };
            activePreset = null; // Clear active preset
            rankingPriorityFilter = null; // Clear priority matrix filter
            selectedKeywordId = null; // Clear selected keyword
            if (segmentFilter) segmentFilter.value = 'all';
            if (rankFilter) rankFilter.value = 'all';
            if (volumeFilter) volumeFilter.value = 'all';
            if (ctrFilter) ctrFilter.value = 'all';
            if (aiOverviewFilter) aiOverviewFilter.value = 'all';
            if (aiCitationFilter) aiCitationFilter.value = 'all';
            if (opportunityFilter) opportunityFilter.value = 'all';
            if (pageTypeFilter) pageTypeFilter.value = 'all';
            if (serpFeaturesFilter) serpFeaturesFilter.value = 'all';
            if (optimisationStatusFilter) optimisationStatusFilter.value = 'all';
            if (keywordFilter) keywordFilter.value = '';
            if (minOpportunityInput) {
              minOpportunityInput.value = '';
              if (minOpportunityNote) minOpportunityNote.style.display = 'none';
            }
            updateFilterActiveStates();
            if (typeof updatePresetButtonActiveStates === 'function') {
              updatePresetButtonActiveStates();
            }
            if (typeof renderPresetCriteriaChips === 'function') {
              renderPresetCriteriaChips();
            }
            rankingPaginationState.currentPage = 1; // Reset to first page on clear
            rankingSortState.column = 'opportunityScore'; // Reset sort
            rankingSortState.direction = 'desc';
            renderRankingAiTab();
          });
        }

        // Default filter state (single source of truth)
        const DEFAULT_FILTERS = {
          segment: 'all',
          rank: 'all',
          volume: 'all',
          ctr: 'all',
          opportunity: 'all',
          minOpportunity: null,
          aiOverview: 'all',
          aiCitation: 'all',
          pageType: 'all',
          serpFeatures: 'all',
          keyword: ''
        };

        // Default sort state
        const DEFAULT_SORT = {
          column: 'opportunityScore',
          direction: 'desc'
        };

        // Preset definitions (data-driven)
        const PRESETS = {
          'all': {
            label: 'All keywords',
            filters: { ...DEFAULT_FILTERS },
            sort: { ...DEFAULT_SORT }
          },
          'high-impact-money': {
            label: 'High-impact money',
            filters: {
              ...DEFAULT_FILTERS,
              segment: 'money',
              volume: 'high',
              rank: '11-20',
              minOpportunity: 65
            },
            sort: {
              column: 'opportunityScore',
              direction: 'desc'
            }
          },
          'ai-overview-not-cited': {
            label: 'AI Overview, not cited',
            filters: {
              ...DEFAULT_FILTERS,
              aiOverview: 'has',
              aiCitation: 'not-cited',
              minOpportunity: 50
            },
            sort: {
              column: 'volume',
              direction: 'desc'
            }
          },
          'brand-safety': {
            label: 'Brand safety',
            filters: {
              ...DEFAULT_FILTERS,
              segment: 'brand',
              rank: 'not-top3'
            },
            sort: {
              column: 'rank',
              direction: 'asc'
            }
          },
          'education-growth': {
            label: 'Blog opportunities',
            filters: {
              ...DEFAULT_FILTERS,
              pageType: 'Blog',
              rank: 'not-top3',
              minOpportunity: 30
            },
            sort: {
              column: 'opportunityScore',
              direction: 'desc'
            }
          },
          'local-visibility': {
            label: 'Local visibility',
            filters: {
              ...DEFAULT_FILTERS,
              pageType: 'GBP',
              rank: 'not-top3',
              minOpportunity: 30
            },
            sort: {
              column: 'opportunityScore',
              direction: 'desc'
            }
          },
          'top-10-opportunities': {
            label: 'Top 10 opportunities',
            filters: {
              ...DEFAULT_FILTERS,
              rank: 'not-top3',
              minOpportunity: 50
            },
            sort: {
              column: 'opportunityScore',
              direction: 'desc'
            },
            rowsPerPage: 10
          }
        };

        // Preset button handlers
        function applyPreset(presetKey) {
          // Cancel any pending debounced keyword filter updates
          if (keywordFilterTimeout) {
            clearTimeout(keywordFilterTimeout);
            keywordFilterTimeout = null;
          }

          // Clear priority matrix filter and selected keyword
          rankingPriorityFilter = null;
          selectedKeywordId = null;

          // Get preset definition
          const preset = PRESETS[presetKey];
          if (!preset) {
            console.warn(`Unknown preset: ${presetKey}`);
            return;
          }

          // HARD RESET: Apply preset filters (don't merge with existing state)
          rankingFilterState = { ...preset.filters };
          rankingSortState = { ...preset.sort };

          // Set rows per page if specified in preset
          if (preset.rowsPerPage) {
            const rowsPerPageSelect = document.getElementById('ranking-rows-per-page');
            if (rowsPerPageSelect) {
              rowsPerPageSelect.value = preset.rowsPerPage;
              rankingPaginationState.rowsPerPage = preset.rowsPerPage;
            }
          }

          // Set active preset (null for 'all')
          activePreset = presetKey === 'all' ? null : presetKey;

          // Update UI elements to match filter state
          if (segmentFilter) segmentFilter.value = rankingFilterState.segment;
          if (rankFilter) rankFilter.value = rankingFilterState.rank;
          if (volumeFilter) volumeFilter.value = rankingFilterState.volume;
          if (ctrFilter) ctrFilter.value = rankingFilterState.ctr;
          if (aiOverviewFilter) aiOverviewFilter.value = rankingFilterState.aiOverview;
          if (aiCitationFilter) aiCitationFilter.value = rankingFilterState.aiCitation;
          if (opportunityFilter) opportunityFilter.value = rankingFilterState.opportunity;
          if (pageTypeFilter) pageTypeFilter.value = rankingFilterState.pageType;
          if (serpFeaturesFilter) serpFeaturesFilter.value = rankingFilterState.serpFeatures;
          if (keywordFilter) keywordFilter.value = rankingFilterState.keyword;
          
          // Update minOpportunity input
          const minOppInput = document.getElementById("ranking-filter-min-opportunity");
          const minOppNote = document.getElementById("ranking-filter-min-opportunity-note");
          if (minOppInput) {
            if (rankingFilterState.minOpportunity != null) {
              minOppInput.value = String(rankingFilterState.minOpportunity);
              if (minOppNote) minOppNote.style.display = 'block';
            } else {
              minOppInput.value = '';
              if (minOppNote) minOppNote.style.display = 'none';
            }
          }

          updateFilterActiveStates();
          updatePresetButtonActiveStates();
          rankingPaginationState.currentPage = 1;
          renderPresetCriteriaChips();
          renderRankingAiTab();
        }

        // Update preset button active states
        function updatePresetButtonActiveStates() {
          const presetButtons = document.querySelectorAll('.ranking-preset-btn');
          presetButtons.forEach(btn => {
            const presetKey = btn.getAttribute('data-preset');
            if (activePreset === presetKey || (presetKey === 'all' && activePreset === null)) {
              btn.classList.add('preset-active');
              btn.style.background = '#047857'; // Darker green background for active (emerald-800)
              btn.style.borderColor = '#065f46'; // Darker border
              btn.style.color = '#ffffff';
              btn.style.fontWeight = '600';
            } else {
              btn.classList.remove('preset-active');
              btn.style.background = 'rgb(229, 255, 204)';
              btn.style.borderColor = '#cbd5e1';
              btn.style.color = '#475569';
              btn.style.fontWeight = '500';
            }
          });
        }

        // Get active criteria chips based on filter state
        function getActiveCriteriaChips() {
          const chips = [];
          
          if (rankingFilterState.segment !== 'all') {
            const segmentLabel = rankingFilterState.segment.charAt(0).toUpperCase() + rankingFilterState.segment.slice(1);
            chips.push({
              label: `Segment: ${segmentLabel}`,
              onRemove: () => {
                rankingFilterState.segment = 'all';
                const segmentFilter = document.getElementById("ranking-filter-segment");
                if (segmentFilter) segmentFilter.value = 'all';
                activePreset = null;
                updateFilters();
              }
            });
          }
          
          if (rankingFilterState.rank !== 'all') {
            let rankLabel = '';
            if (rankingFilterState.rank === 'top3') rankLabel = 'Top 3';
            else if (rankingFilterState.rank === '4-10') rankLabel = '410';
            else if (rankingFilterState.rank === '11-20') rankLabel = '1120';
            else if (rankingFilterState.rank === '21+') rankLabel = '21+ / Not ranked';
            else if (rankingFilterState.rank === 'not-top3') rankLabel = 'Not top 3';
            chips.push({
              label: `Best rank: ${rankLabel}`,
              onRemove: () => {
                rankingFilterState.rank = 'all';
                const rankFilter = document.getElementById("ranking-filter-rank");
                if (rankFilter) rankFilter.value = 'all';
                activePreset = null;
                updateFilters();
              }
            });
          }
          
          if (rankingFilterState.pageType && rankingFilterState.pageType !== 'all') {
            chips.push({
              label: `Page type: ${rankingFilterState.pageType}`,
              onRemove: () => {
                rankingFilterState.pageType = 'all';
                const pageTypeFilter = document.getElementById("ranking-filter-page-type");
                if (pageTypeFilter) pageTypeFilter.value = 'all';
                activePreset = null;
                updateFilters();
              }
            });
          }
          
          if (rankingFilterState.volume !== 'all') {
            const volumeLabel = rankingFilterState.volume.charAt(0).toUpperCase() + rankingFilterState.volume.slice(1);
            chips.push({
              label: `Search volume: ${volumeLabel}`,
              onRemove: () => {
                rankingFilterState.volume = 'all';
                const volumeFilter = document.getElementById("ranking-filter-volume");
                if (volumeFilter) volumeFilter.value = 'all';
                activePreset = null;
                updateFilters();
              }
            });
          }
          
          if (rankingFilterState.aiOverview !== 'all') {
            const aiLabel = rankingFilterState.aiOverview === 'has' ? 'On' : 'Off';
            chips.push({
              label: `AI Overview: ${aiLabel}`,
              onRemove: () => {
                rankingFilterState.aiOverview = 'all';
                const aiOverviewFilter = document.getElementById("ranking-filter-ai-overview");
                if (aiOverviewFilter) aiOverviewFilter.value = 'all';
                activePreset = null;
                updateFilters();
              }
            });
          }
          
          if (rankingFilterState.aiCitation !== 'all') {
            const citationLabel = rankingFilterState.aiCitation === 'cited' ? 'Cited' : 'Not cited';
            chips.push({
              label: `AI citation: ${citationLabel}`,
              onRemove: () => {
                rankingFilterState.aiCitation = 'all';
                const aiCitationFilter = document.getElementById("ranking-filter-ai-citation");
                if (aiCitationFilter) aiCitationFilter.value = 'all';
                activePreset = null;
                updateFilters();
              }
            });
          }
          
          if (rankingFilterState.minOpportunity != null) {
            chips.push({
              label: `Min opportunity:  ${rankingFilterState.minOpportunity}`,
              onRemove: () => {
                rankingFilterState.minOpportunity = null;
                const minOppInput = document.getElementById("ranking-filter-min-opportunity");
                const minOppNote = document.getElementById("ranking-filter-min-opportunity-note");
                if (minOppInput) minOppInput.value = '';
                if (minOppNote) minOppNote.style.display = 'none';
                activePreset = null;
                updateFilters();
              }
            });
          }
          
          // Add sort chip if not default
          if (rankingSortState.column && (rankingSortState.column !== 'opportunityScore' || rankingSortState.direction !== 'desc')) {
            const sortLabel = rankingSortState.column === 'rank' ? 'Rank' : 
                             rankingSortState.column === 'volume' ? 'Volume' : 
                             rankingSortState.column === 'opportunityScore' ? 'Opportunity' : 
                             rankingSortState.column;
            const sortDir = rankingSortState.direction === 'asc' ? '' : '';
            chips.push({
              label: `Sort: ${sortLabel} ${sortDir}`,
              onRemove: () => {
                rankingSortState.column = 'opportunityScore';
                rankingSortState.direction = 'desc';
                activePreset = null;
                renderRankingAiTab();
              }
            });
          }
          
          return chips;
        }

        // Render criteria chips
        function renderPresetCriteriaChips() {
          const chipsContainer = document.getElementById('ranking-preset-criteria-chips');
          if (!chipsContainer) return;
          
          const chips = getActiveCriteriaChips();
          
          if (chips.length === 0 || activePreset === null) {
            chipsContainer.style.display = 'none';
            return;
          }
          
          chipsContainer.style.display = 'block';
          const chipsInner = chipsContainer.querySelector('div');
          if (!chipsInner) return;
          
          chipsInner.innerHTML = chips.map(chip => {
            // Create a wrapper function to handle the removal and update
            const removeHandler = () => {
              chip.onRemove();
              updatePresetButtonActiveStates();
              renderPresetCriteriaChips();
            };
            return `
              <span style="display: inline-flex; align-items: center; gap: 0.375rem; padding: 0.375rem 0.75rem; background: #e5e7eb; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.875rem; color: #374151;">
                ${chip.label}
                <button type="button" onclick="(${removeHandler.toString()})()" style="background: none; border: none; cursor: pointer; color: #6b7280; font-size: 1rem; line-height: 1; padding: 0; margin-left: 0.25rem;" title="Remove this filter"></button>
              </span>
            `;
          }).join('');
        }

        // Wire up preset buttons (re-wire on each call to handle DOM updates)
        function wirePresetButtons() {
          // Remove existing listeners by cloning buttons
          const presetButtons = document.querySelectorAll('.ranking-preset-btn');
          presetButtons.forEach(btn => {
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
          });
          
          // Re-query to get fresh elements
          const freshPresetButtons = document.querySelectorAll('.ranking-preset-btn');
          freshPresetButtons.forEach(btn => {
            btn.addEventListener('click', () => {
              const presetKey = btn.getAttribute('data-preset');
              if (presetKey) {
                applyPreset(presetKey);
              }
            });
          });
        }
        
        // Wire preset buttons immediately
        wirePresetButtons();
        
        // Make wirePresetButtons globally available
        window.wirePresetButtons = wirePresetButtons;

        // Initialize active states on page load
        updateFilterActiveStates();
      }

      function wireRankingSorting() {
        // Find all sortable headers
        const sortableHeaders = document.querySelectorAll('.ranking-table th.sortable');
        if (!sortableHeaders || sortableHeaders.length === 0) {
          console.log('[Sort] No sortable headers found');
          return;
        }
        
        console.log('[Sort] Found', sortableHeaders.length, 'sortable headers');
        
        // Remove any existing data attribute markers
        sortableHeaders.forEach(th => {
          if (th.dataset.sortWired === 'true') {
            // Clone to remove all listeners
            const newTh = th.cloneNode(true);
            th.parentNode.replaceChild(newTh, th);
          }
        });
        
        // Re-query after cloning
        const freshHeaders = document.querySelectorAll('.ranking-table th.sortable');
        
        // Attach listeners directly to each header
        freshHeaders.forEach(th => {
          th.dataset.sortWired = 'true'; // Mark as wired
          
          th.addEventListener('click', function(e) {
            e.stopPropagation();
            const column = this.dataset.sort;
            if (!column) {
              console.log('[Sort] No sort column found');
              return;
            }
            
            console.log('[Sort] Clicked column:', column, 'Current:', rankingSortState.column, rankingSortState.direction);
            
            if (rankingSortState.column === column) {
              // Toggle direction if clicking the same column
              rankingSortState.direction = rankingSortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
              // New column, start with ascending
              rankingSortState.column = column;
              rankingSortState.direction = 'asc';
            }
            
            console.log('[Sort] New state:', rankingSortState.column, rankingSortState.direction);
            
            rankingPaginationState.currentPage = 1;
            renderRankingAiTab();
          });
        });
        
        console.log('[Sort] Wired', freshHeaders.length, 'headers');
      }
      
      function wireRankingPagination() {
        const firstBtn = document.getElementById("ranking-pagination-first");
        const prevBtn = document.getElementById("ranking-pagination-prev");
        const nextBtn = document.getElementById("ranking-pagination-next");
        const lastBtn = document.getElementById("ranking-pagination-last");
        const rowsPerPageSelect = document.getElementById("ranking-rows-per-page");
        
        if (firstBtn) {
          firstBtn.addEventListener("click", () => {
            rankingPaginationState.currentPage = 1;
            renderRankingAiTab();
          });
        }
        
        if (prevBtn) {
          prevBtn.addEventListener("click", () => {
            if (rankingPaginationState.currentPage > 1) {
              rankingPaginationState.currentPage--;
              renderRankingAiTab();
            }
          });
        }
        
        if (nextBtn) {
          nextBtn.addEventListener("click", () => {
            rankingPaginationState.currentPage++;
            renderRankingAiTab();
          });
        }
        
        if (lastBtn) {
          lastBtn.addEventListener("click", () => {
            // Calculate total pages from current data
            const { combinedRows } = RankingAiModule.state();
            if (!combinedRows || !Array.isArray(combinedRows)) return;
            const filteredRows = applyRankingFilters(combinedRows);
            const totalRows = filteredRows.length;
            const rowsPerPage = rankingPaginationState.rowsPerPage === 'all' ? totalRows : rankingPaginationState.rowsPerPage;
            const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
            rankingPaginationState.currentPage = totalPages;
            renderRankingAiTab();
          });
        }
        
        if (rowsPerPageSelect) {
          rowsPerPageSelect.addEventListener("change", () => {
            const value = rowsPerPageSelect.value;
            rankingPaginationState.rowsPerPage = value === 'all' ? 'all' : parseInt(value, 10);
            rankingPaginationState.currentPage = 1; // Reset to first page
            renderRankingAiTab();
          });
        }
      }

      // ============================================
      // AI Sources & Influence Tab Functions
      // ============================================

      /**
       * Classify domain source type based on domain pattern
       * @param {string} domain - Domain name (e.g., "visualeducation.com")
       * @returns {string} Source type classification
       */
      function classifyDomainSourceType(domain) {
        if (!domain) return 'Other';
        const lower = domain.toLowerCase();
        
        // Directory patterns
        if (lower.includes('yell.com') || lower.includes('tripadvisor') || 
            lower.includes('facebook.com/pages') || lower.includes('thomsonlocal') ||
            lower.includes('yell.co.uk') || lower.includes('freeindex')) {
          return 'Directory';
        }
        
        // Review platform patterns
        if (lower.includes('trustpilot') || lower.includes('google.com/maps') ||
            lower.includes('reviews.co.uk') || lower.includes('feefo')) {
          return 'Review platform';
        }
        
        // Course marketplace / education patterns
        if (lower.includes('udemy') || lower.includes('coursera') ||
            lower.includes('visualeducation') || lower.includes('skillshare') ||
            lower.includes('edx') || lower.includes('futurelearn')) {
          return 'Course marketplace / education';
        }
        
        // Publisher / blog patterns (common content domains)
        if (lower.includes('blog') || lower.includes('medium.com') ||
            lower.includes('wordpress.com') || lower.includes('blogger.com')) {
          return 'Publisher / blog';
        }
        
        return 'Other';
      }

      /**
       * Aggregate AI citation data by domain
       * @param {Array} combinedRows - Array of keyword rows with AI citation data
       * @param {string} targetDomain - Target domain (e.g., "alanranger.com")
       * @returns {Array} Array of domain stats objects
       */
      function aggregateAiDomainStats(combinedRows, targetDomain = 'alanranger.com') {
        if (!combinedRows || !Array.isArray(combinedRows)) {
          debugLog(' aggregateAiDomainStats: No combinedRows provided', 'warn');
          return [];
        }

        const domainMap = new Map();
        const targetDomainLower = targetDomain.toLowerCase();

        // Track total citations across all keywords
        let totalAllCitations = 0;

        combinedRows.forEach(row => {
          // Get AI citations for this keyword
          const aiCitations = row.ai_alan_citations || [];
          const competitorCounts = row.competitor_counts || {};
          const aiTotalCitations = row.ai_total_citations || 0;

          totalAllCitations += aiTotalCitations;

          // Process our own citations
          if (aiCitations && aiCitations.length > 0) {
            aiCitations.forEach(citation => {
              if (!citation || !citation.url) return;
              
              try {
                const urlObj = new URL(citation.url);
                const domain = urlObj.hostname.toLowerCase();
                
                if (!domainMap.has(domain)) {
                  domainMap.set(domain, {
                    domain,
                    is_self: domain.includes(targetDomainLower),
                    total_citations: 0,
                    keyword_count: 0,
                    keywords: new Set(),
                    example_urls: []
                  });
                }
                
                const stats = domainMap.get(domain);
                stats.total_citations += 1;
                if (!stats.keywords.has(row.keyword)) {
                  stats.keywords.add(row.keyword);
                  stats.keyword_count += 1;
                }
                if (stats.example_urls.length < 2) {
                  stats.example_urls.push(citation.url);
                }
              } catch (e) {
                // Invalid URL, skip
              }
            });
          }

          // Process competitor citations from competitor_counts (per keyword)
          Object.entries(competitorCounts).forEach(([domain, count]) => {
            if (!domain || !count) return;
            
            const domainLower = domain.toLowerCase();
            
            if (!domainMap.has(domainLower)) {
              domainMap.set(domainLower, {
                domain: domainLower,
                is_self: domainLower.includes(targetDomainLower),
                total_citations: 0,
                keyword_count: 0,
                keywords: new Set(),
                example_urls: []
              });
            }
            
            const stats = domainMap.get(domainLower);
            stats.total_citations += count;
            if (!stats.keywords.has(row.keyword)) {
              stats.keywords.add(row.keyword);
              stats.keyword_count += 1;
            }
          });
        });

        // Convert to array and calculate share_of_citations
        const domainStats = Array.from(domainMap.values()).map(stats => {
          const share_of_citations = totalAllCitations > 0 
            ? (stats.total_citations / totalAllCitations) * 100 
            : 0;
          
          return {
            domain: stats.domain,
            is_self: stats.is_self,
            total_citations: stats.total_citations,
            keyword_count: stats.keyword_count,
            share_of_citations,
            source_type: classifyDomainSourceType(stats.domain),
            example_urls: stats.example_urls.slice(0, 2),
            keywords: Array.from(stats.keywords)
          };
        });

        // Sort by total_citations descending
        domainStats.sort((a, b) => b.total_citations - a.total_citations);

        debugLog(` Aggregated ${domainStats.length} domains from AI citations`, 'info');
        return domainStats;
      }

      /**
       * Render AI Sources & Influence tab
       */
      function renderAiSourcesTab() {
        debugLog(' renderAiSourcesTab() called', 'info');
        
        const { combinedRows } = RankingAiModule.state();
        if (!combinedRows || combinedRows.length === 0) {
          debugLog(' renderAiSourcesTab: No keyword data available', 'warn');
          const tilesContainer = document.getElementById('ai-sources-tiles');
          const tableBody = document.getElementById('ai-sources-table-body');
          if (tilesContainer) tilesContainer.innerHTML = '<div class="card"><p style="padding: 2rem; text-align: center; color: #64748b;">No AI citation data available. Run a Ranking & AI check first.</p></div>';
          if (tableBody) tableBody.innerHTML = '<tr><td colspan="6" class="ranking-table-empty">No data available. Run a Ranking & AI check first.</td></tr>';
          return;
        }

        // Get target domain from property URL
        const propertyUrl = localStorage.getItem('gsc_property_url') || 'https://www.alanranger.com';
        let targetDomain = 'alanranger.com';
        try {
          const urlObj = new URL(propertyUrl);
          targetDomain = urlObj.hostname.replace('www.', '');
        } catch (e) {
          debugLog(` Could not parse property URL: ${propertyUrl}, using default domain`, 'warn');
        }

        // Aggregate domain stats
        const domainStats = aggregateAiDomainStats(combinedRows, targetDomain);
        
        // Store globally for filtering/sorting
        window.aiSourcesDomainStats = domainStats;

        // Render tiles
        renderAiSourcesTiles(domainStats, combinedRows.length);

        // Render source types breakdown
        renderAiSourcesTypesBreakdown(domainStats);

        // Render domain table
        renderAiSourcesTable(domainStats).catch(err => {
          console.error('Error rendering AI sources table:', err);
        });
      }

      /**
       * Render summary tiles for AI Sources & Influence
       */
      function renderAiSourcesTiles(domainStats, totalKeywords) {
        const tilesContainer = document.getElementById('ai-sources-tiles');
        if (!tilesContainer) return;

        // Calculate metrics
        const selfDomain = domainStats.find(d => d.is_self);
        const selfCitations = selfDomain ? selfDomain.total_citations : 0;
        const totalCitations = domainStats.reduce((sum, d) => sum + d.total_citations, 0);
        const selfShare = totalCitations > 0 ? (selfCitations / totalCitations) * 100 : 0;
        const keywordsWithSelfCitations = selfDomain ? selfDomain.keyword_count : 0;
        const externalDomains = domainStats.filter(d => !d.is_self).length;

        const pctKeywordsWithCitations = totalKeywords > 0
          ? (keywordsWithSelfCitations / totalKeywords) * 100
          : 0;

        const ragForShare = () => {
          if (totalCitations <= 0) return 'neutral';
          if (selfShare >= 20) return 'green';
          if (selfShare >= 10) return 'amber';
          return 'red';
        };

        const ragForKeywordCoverage = () => {
          if (totalKeywords <= 0) return 'neutral';
          if (pctKeywordsWithCitations >= 60) return 'green';
          if (pctKeywordsWithCitations >= 30) return 'amber';
          return 'red';
        };

        const statusForRag = (rag) => {
          if (rag === 'green') return 'Strong';
          if (rag === 'amber') return 'Moderate';
          if (rag === 'red') return 'Weak';
          return 'Info';
        };

        const makePill = ({ rag, value, label, status, footer }) => `
          <div class="metric-pill metric-pill--${rag}">
            <div class="metric-pill-value">${value}</div>
            <div class="metric-pill-label">${label}</div>
            <div class="metric-pill-status">${status}</div>
            <div class="metric-pill-footer">${footer}</div>
          </div>
        `;

        const shareRag = ragForShare();
        const coverageRag = ragForKeywordCoverage();

        const html = `
          ${makePill({
            rag: shareRag,
            value: `${selfCitations}/${totalCitations}`,
            label: 'Your AI citations',
            status: statusForRag(shareRag),
            footer: 'Share of AI citations that reference your site across tracked keywords.'
          })}
          ${makePill({
            rag: 'neutral',
            value: `${externalDomains}`,
            label: 'Top external domains',
            status: 'Info',
            footer: 'Domains most often cited alongside you in AI answers.'
          })}
          ${makePill({
            rag: coverageRag,
            value: `${keywordsWithSelfCitations}/${totalKeywords}`,
            label: 'Keywords with your citations',
            status: statusForRag(coverageRag),
            footer: 'How often AI can already see your site as a source for your tracked queries.'
          })}
          ${makePill({
            rag: shareRag,
            value: `${selfShare.toFixed(1)}%`,
            label: 'Your share of AI citations',
            status: statusForRag(shareRag),
            footer: 'Higher values mean AI relies more on your content instead of competitors or directories.'
          })}
        `;

        tilesContainer.innerHTML = html;
      }

      /**
       * Render source types breakdown
       */
      function renderAiSourcesTypesBreakdown(domainStats) {
        const container = document.getElementById('ai-sources-types-breakdown');
        if (!container) return;

        // Group by source type
        const typeGroups = {};
        domainStats.forEach(stat => {
          const type = stat.source_type;
          if (!typeGroups[type]) {
            typeGroups[type] = {
              domains: 0,
              citations: 0
            };
          }
          typeGroups[type].domains += 1;
          typeGroups[type].citations += stat.total_citations;
        });

        const totalCitations = domainStats.reduce((sum, d) => sum + d.total_citations, 0);

        let html = '<ul style="list-style: none; padding: 0; margin: 0;">';
        Object.entries(typeGroups).forEach(([type, data]) => {
          const pct = totalCitations > 0 ? (data.citations / totalCitations) * 100 : 0;
          html += `<li style="padding: 0.75rem 0; border-bottom: 1px solid #e5e7eb;">
            <strong>${type}:</strong> ${data.domains} domains (${pct.toFixed(1)}% of citations)
          </li>`;
        });
        html += '</ul>';

        container.innerHTML = html;
      }

      /**
       * Render domain influence table
       */
      async function renderAiSourcesTable(domainStats, filters = {}) {
        const tableBody = document.getElementById('ai-sources-table-body');
        if (!tableBody) return;

        // Fetch domain metadata and domain strength for all domains (same as Ranking & AI module)
        const allDomains = domainStats.map(stat => stat.domain);
        const domainMetadata = await fetchDomainMetadataForDomains(allDomains);
        const normalizedDomains = allDomains.map(normalizeDomainForStrength).filter(Boolean);
        // Fetch domain strength for all domains (not just first 30)
        // Note: fetchLatestDomainStrengthForDomains has a 30 domain limit, so we need to batch if needed
        const domainStrength = await fetchLatestDomainStrengthForDomains(normalizedDomains);
        
        // If we have more than 30 domains, fetch in batches
        if (normalizedDomains.length > 30) {
          const batches = [];
          for (let i = 0; i < normalizedDomains.length; i += 30) {
            batches.push(normalizedDomains.slice(i, i + 30));
          }
          for (const batch of batches.slice(1)) {
            const batchStrength = await fetchLatestDomainStrengthForDomains(batch);
            Object.assign(domainStrength, batchStrength);
          }
        }

        // Separate alanranger.com (self) from others
        // Self domain is always shown regardless of filters (sticky first row)
        const selfDomain = domainStats.find(stat => stat.is_self);
        const otherDomains = domainStats.filter(stat => !stat.is_self);

        // Apply filters to other domains (self domain always shown, filtered separately if needed)
        let filtered = otherDomains.filter(stat => {
          if (filters.type && filters.type !== 'all' && stat.source_type !== filters.type) {
            return false;
          }
          if (filters.domainType && filters.domainType !== 'all') {
            const normalizedDomain = normalizeDomainForStrength(stat.domain);
            const meta = domainMetadata[normalizedDomain] || { domain_type: 'unmapped' };
            const domainType = meta.domain_type && meta.domain_type !== 'unmapped' ? meta.domain_type : 'unmapped';
            
            if (filters.domainType === 'self' || filters.domainType === 'your_site') {
              // Filter is 'self' or 'your_site', but this is a competitor domain, so exclude it
              return false;
            } else if (filters.domainType === 'competitor') {
              // Filter is 'competitor', show all non-self domains (already filtered)
              // No additional filtering needed
            } else {
              // Filter by specific domain_type value (e.g., 'site', 'platform', 'directory', 'unmapped', etc.)
              if (domainType !== filters.domainType) {
                return false;
              }
            }
          }
          if (filters.domain && !stat.domain.toLowerCase().includes(filters.domain.toLowerCase())) {
            return false;
          }
          return true;
        });

        // Apply sorting (default: competitor - competitors first)
        const sortColumn = window.aiSourcesSortState?.column || 'competitor';
        const sortDirection = window.aiSourcesSortState?.direction || 'desc';
        filtered.sort((a, b) => {
          let aVal, bVal;
          switch (sortColumn) {
            case 'domain':
              aVal = a.domain.toLowerCase();
              bVal = b.domain.toLowerCase();
              break;
            case 'domain_type':
              // Sort by domain_type string value from metadata (using mapped labels for consistent sorting)
              const aNorm = normalizeDomainForStrength(a.domain);
              const bNorm = normalizeDomainForStrength(b.domain);
              const aMeta = domainMetadata[aNorm] || { domain_type: 'unmapped' };
              const bMeta = domainMetadata[bNorm] || { domain_type: 'unmapped' };
              // For self domains, use "your_site" if unmapped, otherwise use domain_type
              if (a.is_self) {
                const aDomainType = aMeta.domain_type && aMeta.domain_type !== 'unmapped' ? aMeta.domain_type : 'your_site';
                aVal = getDomainTypeLabel(aDomainType);
              } else {
                const aDomainType = aMeta.domain_type && aMeta.domain_type !== 'unmapped' ? aMeta.domain_type : 'zzz_unmapped';
                aVal = getDomainTypeLabel(aDomainType) || 'zzz_unmapped';
              }
              if (b.is_self) {
                const bDomainType = bMeta.domain_type && bMeta.domain_type !== 'unmapped' ? bMeta.domain_type : 'your_site';
                bVal = getDomainTypeLabel(bDomainType);
              } else {
                const bDomainType = bMeta.domain_type && bMeta.domain_type !== 'unmapped' ? bMeta.domain_type : 'zzz_unmapped';
                bVal = getDomainTypeLabel(bDomainType) || 'zzz_unmapped';
              }
              break;
            case 'competitor':
              // Sort by competitor status (competitors first, then non-competitors)
              const aNormComp = normalizeDomainForStrength(a.domain);
              const bNormComp = normalizeDomainForStrength(b.domain);
              const aMetaComp = domainMetadata[aNormComp] || { is_competitor: false };
              const bMetaComp = domainMetadata[bNormComp] || { is_competitor: false };
              aVal = aMetaComp.is_competitor ? 1 : 0;
              bVal = bMetaComp.is_competitor ? 1 : 0;
              break;
            case 'rank':
              // Sort by domain rank score
              const aNormRank = normalizeDomainForStrength(a.domain);
              const bNormRank = normalizeDomainForStrength(b.domain);
              const aStrength = domainStrength[aNormRank] || { score: null };
              const bStrength = domainStrength[bNormRank] || { score: null };
              aVal = aStrength.score !== null ? aStrength.score : -1;
              bVal = bStrength.score !== null ? bStrength.score : -1;
              break;
            case 'type':
              aVal = a.source_type;
              bVal = b.source_type;
              break;
            case 'citations':
              aVal = a.total_citations;
              bVal = b.total_citations;
              break;
            case 'keywords':
              aVal = a.keyword_count;
              bVal = b.keyword_count;
              break;
            case 'share':
              aVal = a.share_of_citations;
              bVal = b.share_of_citations;
              break;
            default:
              return 0;
          }
          if (aVal < bVal) return sortDirection === 'asc' ? -1 : 1;
          if (aVal > bVal) return sortDirection === 'asc' ? 1 : -1;
          return 0;
        });

        if (filtered.length === 0 && !selfDomain) {
          tableBody.innerHTML = '<tr><td colspan="8" class="ranking-table-empty">No domains match the current filters.</td></tr>';
          return;
        }

        tableBody.innerHTML = '';
        
        // Always render self domain first with yellow highlight (regardless of filters, but respect domain search and domain type filter)
        if (selfDomain) {
          // Check if self domain should be shown based on filters
          const normalizedDomain = normalizeDomainForStrength(selfDomain.domain);
          const meta = domainMetadata[normalizedDomain] || { domain_type: 'unmapped', is_competitor: false };
          const domainType = meta.domain_type && meta.domain_type !== 'unmapped' ? meta.domain_type : 'your_site';
          
          let showSelf = true;
          if (filters.domain && !selfDomain.domain.toLowerCase().includes(filters.domain.toLowerCase())) {
            showSelf = false;
          }
          if (filters.domainType && filters.domainType !== 'all') {
            if (filters.domainType === 'self' || filters.domainType === 'your_site') {
              // Show self domain
              showSelf = showSelf && true;
            } else if (filters.domainType === 'competitor') {
              // Hide self domain when filtering for competitors
              showSelf = false;
            } else {
              // Filter by specific domain_type value
              showSelf = showSelf && (domainType === filters.domainType);
            }
          }
          
          if (showSelf) {
            const strength = domainStrength[normalizedDomain] || null;
            const selfRow = createDomainRow(selfDomain, true, meta, strength);
            tableBody.appendChild(selfRow);
          }
        }
        
        // Render filtered other domains
        filtered.forEach(stat => {
          const normalizedDomain = normalizeDomainForStrength(stat.domain);
          const meta = domainMetadata[normalizedDomain] || { domain_type: 'unmapped', is_competitor: false };
          const strength = domainStrength[normalizedDomain] || null;
          const row = createDomainRow(stat, false, meta, strength);
          tableBody.appendChild(row);
        });
        
        // Re-attach sort listeners after table is rendered
        if (typeof window.attachAiSourcesSortListeners === 'function') {
          setTimeout(() => {
            window.attachAiSourcesSortListeners();
          }, 50);
        }
      }

      /**
       * Map domain_type value to display label (same as Ranking & AI module)
       */
      function getDomainTypeLabel(domainType) {
        const domainTypeMap = {
          'unmapped': 'Unmapped',
          'your_site': 'Your site',
          'platform': 'Platform',
          'directory': 'Directory',
          'publisher': 'Publisher',
          'vendor': 'Vendor',
          'institution': 'Institution',
          'government': 'Government',
          'site': 'Site'
        };
        return domainTypeMap[domainType] || domainType || '';
      }

      /**
       * Create a table row for a domain stat
       */
      function createDomainRow(stat, isSelf, meta, strength) {
          const tr = document.createElement('tr');
          tr.dataset.domain = stat.domain;
        
        // Make self domain row sticky and highlight in yellow (below header)
        if (isSelf) {
          tr.style.position = 'sticky';
          tr.style.top = '40px'; // Below sticky header (approximate header height)
          tr.style.zIndex = '15';
          tr.style.backgroundColor = '#ffffcc';
          tr.style.fontWeight = '600';
        }
          
          // Domain
          const tdDomain = document.createElement('td');
          tdDomain.textContent = stat.domain;
          if (stat.is_self) {
            tdDomain.style.fontWeight = '700';
            tdDomain.style.color = '#166534';
          tdDomain.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
          }
          tr.appendChild(tdDomain);

        // Domain type (use same categorization as Ranking & AI module)
        const tdDomainType = document.createElement('td');
        tdDomainType.style.padding = '0.5rem 0.4rem';
        tdDomainType.style.fontSize = '0.8rem';
        tdDomainType.style.wordWrap = 'break-word';
        tdDomainType.style.overflowWrap = 'break-word';
        if (stat.is_self) {
          tdDomainType.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
        }
        
        // Map domain_type value to display label (same as Ranking & AI)
        // Always show domain_type for all rows
        let displayType = '';
        if (stat.is_self) {
          // For self domain, show mapped label or "Your site" if unmapped
          const domainType = meta.domain_type && meta.domain_type !== 'unmapped' ? meta.domain_type : 'your_site';
          displayType = getDomainTypeLabel(domainType);
        } else {
          // For non-self domains, show mapped label if available, otherwise show "Unmapped"
          if (meta.domain_type && meta.domain_type !== 'unmapped') {
            displayType = getDomainTypeLabel(meta.domain_type);
          } else {
            // Show "Unmapped" so user knows domain exists but type not assigned yet
            displayType = 'Unmapped';
          }
        }
        tdDomainType.textContent = displayType;
        tdDomainType.style.color = displayType ? '#475569' : '#94a3b8';
        if (stat.is_self) {
          tdDomainType.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
        }
        tr.appendChild(tdDomainType);

        // Competitor column (separate from domain type)
        const tdCompetitor = document.createElement('td');
        tdCompetitor.style.padding = '0.5rem 0.4rem';
        tdCompetitor.style.fontSize = '0.8rem';
        tdCompetitor.style.textAlign = 'center';
        if (stat.is_self) {
          tdCompetitor.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
        }
        
        // Show competitor badge if is_competitor is true (same as Ranking & AI module)
        if (meta.is_competitor) {
          const badge = document.createElement('span');
          badge.textContent = 'Competitor';
          badge.setAttribute('data-competitor-badge', 'true');
          badge.style.display = 'inline-block';
          badge.style.padding = '0.125rem 0.5rem';
          badge.style.fontSize = '0.65rem';
          badge.style.fontWeight = '600';
          badge.style.color = '#dc2626';
          badge.style.backgroundColor = '#fee2e2';
          badge.style.borderRadius = '4px';
          badge.style.border = '1px solid #fecaca';
          tdCompetitor.appendChild(badge);
        } else {
          tdCompetitor.textContent = '';
          tdCompetitor.style.color = '#94a3b8';
        }
        tr.appendChild(tdCompetitor);

        // Domain Rank
        const tdRank = document.createElement('td');
        tdRank.style.textAlign = 'right';
        tdRank.style.padding = '0.5rem 0.4rem';
        tdRank.style.fontSize = '0.8rem';
        if (stat.is_self) {
          tdRank.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
        }
        tdRank.innerHTML = renderDomainRankCellHtml(strength);
        tr.appendChild(tdRank);

          // Citations
          const tdCitations = document.createElement('td');
          tdCitations.textContent = stat.total_citations;
        if (stat.is_self) {
          tdCitations.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
        }
          tr.appendChild(tdCitations);

          // Keywords
          const tdKeywords = document.createElement('td');
          tdKeywords.textContent = stat.keyword_count;
        if (stat.is_self) {
          tdKeywords.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
        }
          tr.appendChild(tdKeywords);

          // Citation share
          const tdShare = document.createElement('td');
          tdShare.textContent = `${stat.share_of_citations.toFixed(1)}%`;
        if (stat.is_self) {
          tdShare.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
        }
          tr.appendChild(tdShare);

          // Example page
          const tdExample = document.createElement('td');
        if (stat.is_self) {
          tdExample.style.backgroundColor = '#ffffcc'; // Ensure background covers cell
        }
          if (stat.example_urls && stat.example_urls.length > 0) {
            const a = document.createElement('a');
            a.href = stat.example_urls[0];
            a.target = '_blank';
            a.rel = 'noopener noreferrer';
            a.textContent = stat.is_self ? new URL(stat.example_urls[0]).pathname : stat.example_urls[0];
            a.style.color = '#0284c7';
            a.style.textDecoration = 'none';
            tdExample.appendChild(a);
          } else {
            tdExample.textContent = '';
          }
          tr.appendChild(tdExample);

          // Click handler
          tr.style.cursor = 'pointer';
          tr.addEventListener('click', () => {
            document.querySelectorAll('#ai-sources-table-body tr').forEach(r => r.classList.remove('ranking-table-row--selected'));
            tr.classList.add('ranking-table-row--selected');
            renderAiSourcesDetail(stat);
          });

        return tr;
      }

      /**
       * Render domain detail panel
       */
      function renderAiSourcesDetail(stat) {
        const panel = document.getElementById('ai-sources-detail-panel');
        const domainEl = document.getElementById('ai-sources-detail-domain');
        const metaEl = document.getElementById('ai-sources-detail-meta');
        const contentEl = document.getElementById('ai-sources-detail-content');

        if (!panel || !domainEl || !metaEl || !contentEl) return;

        panel.style.display = 'block';
        domainEl.textContent = stat.domain;
        metaEl.textContent = `Cited in ${stat.total_citations} AI answer${stat.total_citations !== 1 ? 's' : ''} across ${stat.keyword_count} tracked keyword${stat.keyword_count !== 1 ? 's' : ''} (${stat.share_of_citations.toFixed(1)}% of all citations).`;

        let html = '';

        // Why this domain matters
        html += '<div class="scorecard-section">';
        html += '<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">Why this domain matters</h5>';
        
        if (stat.is_self) {
          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This is your own site. AI is using your content in ' + stat.total_citations + ' answer' + (stat.total_citations !== 1 ? 's' : '') + ' across ' + stat.keyword_count + ' keyword' + (stat.keyword_count !== 1 ? 's' : '') + '. Increasing citations here usually comes from stronger schema, internal linking and coverage on key topics.</p>';
        } else if (stat.source_type === 'Directory') {
          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This is a directory / listing site. Repeated citations suggest AI trusts this listing as a key reference in your niche. Ensure your profile, NAP details and reviews are complete and consistent.</p>';
        } else if (stat.source_type === 'Review platform') {
          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This is a review platform. AI often surfaces businesses with strong, consistent reviews from here. Make sure your profile is claimed, reviews are encouraged, and descriptions match your positioning.</p>';
        } else if (stat.source_type === 'Course marketplace / education') {
          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This is an education or course marketplace. AI is seeing it as an alternative source for photography learning. Consider whether partnering, listing, or differentiating your on-site course pages against this platform makes sense.</p>';
        } else if (stat.source_type === 'Publisher / blog') {
          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This is a content publisher. Repeated citations suggest AI trusts their articles for informational queries. Collaborations, guest posts, or references from this domain can help strengthen your topical authority.</p>';
        } else {
          html += '<p style="font-size: 0.875rem; color: #1e293b; line-height: 1.6;">This domain is frequently cited, but doesn\'t fall into a specific category. Review its content and decide if it\'s a directory, partner, competitor or something to monitor.</p>';
        }
        html += '</div>';

        // Keywords where this domain appears
        html += '<div class="scorecard-section">';
        html += '<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">Keywords where this domain appears</h5>';
        html += '<ul style="font-size: 0.875rem; color: #1e293b; line-height: 1.8; padding-left: 1.5rem;">';
        const keywordsToShow = stat.keywords.slice(0, 10);
        keywordsToShow.forEach(keyword => {
          html += `<li>${keyword}</li>`;
        });
        if (stat.keywords.length > 10) {
          html += `<li style="color: #64748b; font-style: italic;">... and ${stat.keywords.length - 10} more</li>`;
        }
        html += '</ul></div>';

        // Suggested next steps
        html += '<div class="scorecard-section">';
        html += '<h5 style="font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">Suggested next steps</h5>';
        html += '<ul style="font-size: 0.875rem; color: #1e293b; line-height: 1.8; padding-left: 1.5rem;">';
        
        if (stat.is_self) {
          const selfShare = stat.share_of_citations;
          if (selfShare < 30) {
            html += '<li>Strengthen schema and content coverage on high-demand keywords where you\'re not cited yet.</li>';
            html += '<li>Revisit internal linking from money pages to these informational topics to raise their prominence.</li>';
          }
        } else if (stat.source_type === 'Directory' || stat.source_type === 'Review platform') {
          html += '<li>Audit your listing/profile on this domain (NAP details, description, categories).</li>';
          html += '<li>Encourage satisfied students/clients to leave reviews here to reinforce Authority.</li>';
        } else if (stat.source_type === 'Course marketplace / education') {
          html += '<li>Review how your offerings compare to what\'s listed here. Decide whether to list on this platform or create on-site content addressing the same needs.</li>';
        } else if (stat.source_type === 'Publisher / blog') {
          html += '<li>Identify relevant articles and consider outreach for mentions, interviews or guest content pointing back to your key pages.</li>';
        }
        
        html += '</ul></div>';

        contentEl.innerHTML = html;
      }

      // Edit Keywords functionality
      (function() {
        // Wait for DOM to be ready
        function initEditKeywords() {
          const modal = document.getElementById('edit-keywords-modal');
          const openBtn = document.getElementById('edit-keywords-btn');
          const closeBtn = document.getElementById('edit-keywords-close');
          const cancelBtn = document.getElementById('edit-keywords-cancel');
          const saveBtn = document.getElementById('edit-keywords-save');
          const textarea = document.getElementById('edit-keywords-textarea');
          const statusEl = document.getElementById('edit-keywords-status');

          if (!modal || !openBtn) {
            // Elements not found yet, try again later
            setTimeout(initEditKeywords, 100);
            return;
          }

          // Ensure modal is hidden initially - use !important to override any other styles
          modal.style.setProperty('display', 'none', 'important');
          
          // Force close on any click outside or escape - emergency close
          const forceClose = () => {
            modal.style.setProperty('display', 'none', 'important');
          };
          
          // Make forceClose available globally for emergency
          window.forceCloseEditKeywordsModal = forceClose;

          function showModal() {
            if (typeof debugLog === 'function') debugLog('[Edit Keywords] showModal() called', 'info');
            if (modal) {
              if (typeof debugLog === 'function') debugLog('[Edit Keywords] Modal found, showing...', 'info');
              modal.style.setProperty('display', 'flex', 'important');
              if (typeof debugLog === 'function') debugLog('[Edit Keywords] Calling loadKeywords()...', 'info');
              loadKeywords();
            } else {
              if (typeof debugLog === 'function') debugLog('[Edit Keywords] Modal element not found!', 'error');
            }
          }

          function hideModal() {
            if (modal) {
              modal.style.display = 'none';
              modal.style.setProperty('display', 'none', 'important');
              if (statusEl) statusEl.textContent = '';
              if (textarea) {
                textarea.value = '';
                textarea.disabled = false;
              }
            }
          }

          async function loadKeywords() {
            if (typeof debugLog === 'function') debugLog('[Edit Keywords] loadKeywords() called', 'info');
            if (!textarea) {
              if (typeof debugLog === 'function') debugLog('[Edit Keywords] Textarea not found', 'error');
              if (statusEl) {
                statusEl.textContent = 'ERROR: Textarea element not found';
                statusEl.style.color = '#dc2626';
                statusEl.style.fontWeight = 'bold';
              }
              return;
            }
            
            if (typeof debugLog === 'function') debugLog('[Edit Keywords] Setting loading state...', 'info');
            textarea.value = 'Loading keywords...';
            textarea.disabled = true;
            textarea.style.color = '#1e293b';
            textarea.style.backgroundColor = '#ffffff';
            if (statusEl) {
              statusEl.textContent = 'Loading keywords from server...';
              statusEl.style.color = '#64748b';
              statusEl.style.fontWeight = 'normal';
            }
            
            try {
              // First try to get from localStorage as fallback
              let keywordsFromStorage = [];
              try {
                const storedData = localStorage.getItem('rankingAiData');
                if (storedData) {
                  const parsed = JSON.parse(storedData);
                  if (parsed.combinedRows && Array.isArray(parsed.combinedRows)) {
                    keywordsFromStorage = [...new Set(parsed.combinedRows.map(r => r?.keyword).filter(Boolean))].sort();
                    if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Found ${keywordsFromStorage.length} keywords in localStorage`, 'info');
                  }
                }
              } catch (e) {
                if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Could not read from localStorage: ${e.message}`, 'warn');
              }
              
              const apiEndpoint = apiUrl('/api/keywords/get');
              if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Fetching from: ${apiEndpoint}`, 'info');
              
              const resp = await fetch(apiEndpoint);
              if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Response status: ${resp.status} ${resp.statusText}`, 'info');
              
              if (!resp.ok) {
                const errorText = await resp.text();
                if (typeof debugLog === 'function') debugLog(`[Edit Keywords] API error response: ${errorText}`, 'error');
                // Fallback to localStorage if API fails
                if (keywordsFromStorage.length > 0) {
                  if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Using localStorage fallback due to API error`, 'warn');
                  textarea.value = keywordsFromStorage.join('\n');
                  textarea.disabled = false;
                  textarea.style.color = '#1e293b';
                  textarea.style.backgroundColor = '#ffffff';
                  if (statusEl) {
                    statusEl.textContent = ` Loaded ${keywordsFromStorage.length} keywords from cache (API error: ${resp.status})`;
                    statusEl.style.color = '#f59e0b';
                    statusEl.style.fontWeight = '600';
                  }
                  return;
                }
                throw new Error(`HTTP ${resp.status}: ${errorText.substring(0, 100)}`);
              }
              
              const data = await resp.json();
              if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Response: status=${data.status}, keywords count=${data.keywords?.length || 0}, reason=${data.meta?.reason || 'none'}`, 'info');
              
              if (data.status === 'ok' && Array.isArray(data.keywords)) {
                if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Found ${data.keywords.length} keywords from API`, 'info');
                if (data.keywords.length > 0) {
                  const keywordsText = data.keywords.join('\n');
                  if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Setting textarea value, length: ${keywordsText.length}`, 'info');
                  textarea.value = keywordsText;
                  textarea.disabled = false;
                  textarea.style.color = '#1e293b';
                  textarea.style.backgroundColor = '#ffffff';
                  textarea.focus();
                  if (statusEl) {
                    statusEl.textContent = ` Loaded ${data.keywords.length} keywords`;
                    statusEl.style.color = '#10b981';
                    statusEl.style.fontWeight = '600';
                  }
                  if (typeof debugLog === 'function') debugLog('[Edit Keywords] Keywords loaded successfully', 'success');
                } else {
                  if (typeof debugLog === 'function') debugLog('[Edit Keywords] No keywords found in API response', 'warn');
                  // Try localStorage fallback
                  if (keywordsFromStorage.length > 0) {
                    if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Using localStorage fallback (${keywordsFromStorage.length} keywords)`, 'warn');
                    textarea.value = keywordsFromStorage.join('\n');
                    textarea.disabled = false;
                    textarea.style.color = '#1e293b';
                    textarea.style.backgroundColor = '#ffffff';
                    if (statusEl) {
                      statusEl.textContent = ` Loaded ${keywordsFromStorage.length} keywords from cache (not found in latest audit)`;
                      statusEl.style.color = '#f59e0b';
                      statusEl.style.fontWeight = '600';
                    }
                  } else {
                    textarea.value = '';
                    textarea.disabled = false;
                    textarea.style.color = '#1e293b';
                    textarea.style.backgroundColor = '#ffffff';
                    if (statusEl) {
                      statusEl.textContent = ' No keywords found. You can add keywords below (one per line).';
                      statusEl.style.color = '#f59e0b';
                      statusEl.style.fontWeight = '600';
                    }
                  }
                }
              } else {
                if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Invalid response format. Status: ${data.status}, Keywords type: ${typeof data.keywords}, Is array: ${Array.isArray(data.keywords)}`, 'error');
                textarea.value = '';
                textarea.disabled = false;
                textarea.style.color = '#1e293b';
                textarea.style.backgroundColor = '#ffffff';
                if (statusEl) {
                  statusEl.textContent = ' Invalid response format from server. Check debug log for details.';
                  statusEl.style.color = '#dc2626';
                  statusEl.style.fontWeight = 'bold';
                }
              }
            } catch (err) {
              if (typeof debugLog === 'function') debugLog(`[Edit Keywords] Exception: ${err.message}`, 'error');
              textarea.value = '';
              textarea.disabled = false;
              textarea.style.color = '#1e293b';
              textarea.style.backgroundColor = '#ffffff';
              if (statusEl) {
                statusEl.textContent = ' Error loading keywords: ' + err.message + ' (Check debug log for details)';
                statusEl.style.color = '#dc2626';
                statusEl.style.fontWeight = 'bold';
                statusEl.style.fontSize = '0.9rem';
              }
            }
          }

          async function saveKeywords() {
            if (!textarea || !saveBtn) return;
            
            const keywordsText = textarea.value.trim();
            const keywords = keywordsText.split('\n')
              .map(k => k.trim())
              .filter(k => k.length > 0);
            
            if (keywords.length === 0) {
              if (statusEl) {
                statusEl.textContent = 'Please enter at least one keyword.';
                statusEl.style.color = '#dc2626';
              }
              return;
            }

            saveBtn.disabled = true;
            saveBtn.textContent = 'Saving...';
            if (statusEl) {
              statusEl.textContent = 'Saving keywords...';
              statusEl.style.color = '#64748b';
            }

            try {
              const resp = await fetch(apiUrl('/api/keywords/save'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ keywords })
              });

              // Check if response is JSON before parsing
              const contentType = resp.headers.get('content-type');
              let data;
              
              if (contentType && contentType.includes('application/json')) {
                data = await resp.json();
              } else {
                // Non-JSON response (likely an error page or plain text)
                const errorText = await resp.text();
                throw new Error(`Server returned non-JSON response (${resp.status}): ${errorText.substring(0, 200)}`);
              }
              
              if (resp.ok && data.status === 'ok') {
                if (statusEl) {
                  statusEl.textContent = ` Successfully saved ${data.count || keywords.length} keywords. Keywords will be updated on the next Ranking & AI check.`;
                  statusEl.style.color = '#10b981';
                }
                
                // Close modal after showing success message (don't trigger a new scan)
                setTimeout(() => {
                  hideModal();
                }, 2000);
              } else {
                throw new Error(data.message || data.details || 'Failed to save keywords');
              }
            } catch (err) {
              console.error('[Edit Keywords] Save error:', err);
              if (statusEl) {
                statusEl.textContent = 'Error saving keywords: ' + err.message;
                statusEl.style.color = '#dc2626';
              }
              saveBtn.disabled = false;
              saveBtn.textContent = 'Save Keywords';
            }
          }

          // CSV upload handler
          const csvUpload = document.getElementById('csv-upload');
          if (csvUpload) {
            csvUpload.addEventListener('change', async (e) => {
              const file = e.target.files[0];
              if (!file) return;

              try {
                const text = await file.text();
                // Parse CSV and populate textarea
                const lines = text.split('\n');
                const keywords = [];
                for (const line of lines) {
                  const trimmed = line.trim();
                  if (!trimmed || trimmed.startsWith('#')) continue;
                  const firstColumn = trimmed.includes(',') ? trimmed.split(',')[0].trim() : trimmed;
                  if (firstColumn) keywords.push(firstColumn);
                }

                if (keywords.length === 0) {
                  if (statusEl) {
                    statusEl.textContent = 'No keywords found in CSV file';
                    statusEl.style.color = '#dc2626';
                  }
                  return;
                }

                textarea.value = keywords.join('\n');
                if (statusEl) {
                  statusEl.textContent = ` Loaded ${keywords.length} keywords from CSV`;
                  statusEl.style.color = '#10b981';
                }

                // Reset file input
                e.target.value = '';
              } catch (err) {
                console.error('[Edit Keywords] CSV upload error:', err);
                if (statusEl) {
                  statusEl.textContent = 'Error reading CSV file: ' + err.message;
                  statusEl.style.color = '#dc2626';
                }
              }
            });
          }

          // Only attach event listeners - modal should NOT open automatically
          openBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            showModal();
          });
          
          // Close buttons - make sure they work
          if (closeBtn) {
            closeBtn.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              hideModal();
            });
          }
          
          if (cancelBtn) {
            cancelBtn.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              hideModal();
            });
          }
          
          if (saveBtn) {
            saveBtn.addEventListener('click', saveKeywords);
          }
          
          // Close modal when clicking outside
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              e.preventDefault();
              e.stopPropagation();
              hideModal();
            }
          });

          // Close modal with Escape key - make it work globally
          const escapeHandler = (e) => {
            if (e.key === 'Escape' && modal) {
              const currentDisplay = window.getComputedStyle(modal).display;
              if (currentDisplay === 'flex' || currentDisplay === 'block') {
                e.preventDefault();
                e.stopPropagation();
                hideModal();
              }
            }
          };
          document.addEventListener('keydown', escapeHandler);
          
          // Also add a global function to force close
          window.closeEditKeywordsModal = hideModal;
        }

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initEditKeywords);
        } else {
          initEditKeywords();
        }
      })();

      // Initialize AI Sources sort state (default: sort by competitor - competitors first)
      if (!window.aiSourcesSortState) {
        window.aiSourcesSortState = { column: 'competitor', direction: 'desc' };
      }

      // Wire up AI Sources tab filters and sorting
      function wireAiSourcesFilters() {
        const typeFilter = document.getElementById('ai-sources-filter-type');
        const domainTypeFilter = document.getElementById('ai-sources-filter-domain-type');
        const domainFilter = document.getElementById('ai-sources-filter-domain');
        const clearBtn = document.getElementById('ai-sources-filter-clear');

        const updateFilters = async () => {
          const filters = {
            type: typeFilter ? typeFilter.value : 'all',
            domainType: domainTypeFilter ? domainTypeFilter.value : 'all',
            domain: domainFilter ? domainFilter.value.trim() : ''
          };
          if (window.aiSourcesDomainStats) {
            await renderAiSourcesTable(window.aiSourcesDomainStats, filters).catch(err => {
              console.error('Error rendering AI sources table:', err);
            });
          }
        };

        if (typeFilter) typeFilter.addEventListener('change', updateFilters);
        if (domainTypeFilter) domainTypeFilter.addEventListener('change', updateFilters);
        if (domainFilter) domainFilter.addEventListener('input', updateFilters);
        if (clearBtn) {
          clearBtn.addEventListener('click', () => {
            if (typeFilter) typeFilter.value = 'all';
            if (domainTypeFilter) domainTypeFilter.value = 'all';
            if (domainFilter) domainFilter.value = '';
            updateFilters();
          });
        }

        // Wire up table sorting - attach listeners after table is rendered
        window.attachAiSourcesSortListeners = function attachSortListeners() {
          const table = document.getElementById('ai-sources-table');
          if (!table) return;
          
          // Remove any existing listeners by removing and re-adding the event listener
          // Use a single delegated listener on the table
          const handleSortClick = (e) => {
            const th = e.target.closest('th.sortable');
            if (!th) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            const column = th.dataset.sort;
            if (!column) return;

            if (window.aiSourcesSortState.column === column) {
              window.aiSourcesSortState.direction = window.aiSourcesSortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
              window.aiSourcesSortState.column = column;
              window.aiSourcesSortState.direction = 'desc';
            }

            // Update sort indicators
            const allHeaders = table.querySelectorAll('th.sortable');
            allHeaders.forEach(h => {
              h.classList.remove('sort-asc', 'sort-desc');
              if (h.dataset.sort === window.aiSourcesSortState.column) {
                h.classList.add(`sort-${window.aiSourcesSortState.direction}`);
              }
            });

            // Re-render table with new sort
            const filters = {
              type: typeFilter ? typeFilter.value : 'all',
              domainType: domainTypeFilter ? domainTypeFilter.value : 'all',
              domain: domainFilter ? domainFilter.value.trim() : ''
            };
            if (window.aiSourcesDomainStats) {
              renderAiSourcesTable(window.aiSourcesDomainStats, filters).then(() => {
                // Re-attach listeners after re-render
                if (typeof window.attachAiSourcesSortListeners === 'function') {
                  window.attachAiSourcesSortListeners();
                }
              }).catch(err => {
                console.error('Error rendering AI sources table:', err);
              });
            }
          };
          
          // Remove old listener if it exists
          if (table._sortHandler) {
            table.removeEventListener('click', table._sortHandler);
          }
          table._sortHandler = handleSortClick;
          table.addEventListener('click', handleSortClick, true); // Use capture phase to catch events early
          
          // Set initial sort indicator on headers and add cursor style
          const sortableHeaders = table.querySelectorAll('th.sortable');
          sortableHeaders.forEach(h => {
            h.style.cursor = 'pointer';
            h.classList.remove('sort-asc', 'sort-desc');
            if (h.dataset.sort === window.aiSourcesSortState.column) {
              h.classList.add(`sort-${window.aiSourcesSortState.direction}`);
            }
          });
        }
        
        // Attach sort listeners initially
        window.attachAiSourcesSortListeners();
      }

      // Make functions globally available
      window.renderAiSourcesTab = renderAiSourcesTab;
      window.wireAiSourcesFilters = wireAiSourcesFilters;
  </script>

  <!-- Optimisation Tracking Modals (Phase 2) -->
  <!-- Track Keyword Modal -->
  <div id="optimisation-track-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
    <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 1000px; width: 90%; max-height: 90vh; overflow-y: auto;">
      <h3 style="margin: 0 0 1.5rem 0; font-size: 1.25rem; color: #1e293b;">Track Keyword</h3>
      
      <div style="margin-bottom: 1rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Keyword:</label>
        <div id="track-keyword-text" style="padding: 0.5rem; background: #f8fafc; border-radius: 4px; color: #0284c7; font-weight: 600; font-size: 1rem;"></div>
      </div>
      
      <div style="margin-bottom: 1rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Target URL:</label>
        <div id="track-url-text" style="padding: 0.5rem; background: #f8fafc; border-radius: 4px; color: #0284c7; font-weight: 600; word-break: break-all; font-size: 0.95rem;"></div>
      </div>
      
      <div style="margin-bottom: 1rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Task type:</label>
        <select id="track-task-type" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px;">
          <option value="on_page">On-page</option>
          <option value="content">Content</option>
          <option value="internal_links">Internal links</option>
          <option value="links_pr">Links/PR</option>
          <option value="technical">Technical</option>
          <option value="local">Local</option>
          <option value="other">Other</option>
        </select>
      </div>
      
      <div style="margin-bottom: 1rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Status: <span title="Status meanings:&#10; Planned: Task created but work not started&#10; In Progress: Currently being worked on&#10; Monitoring: Changes deployedmonitor metrics" style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></label>
        <select id="track-status" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px;">
          <option value="planned" title="Task created but work not started">Planned</option>
          <option value="in_progress" title="Currently being worked on">In progress</option>
          <option value="monitoring" title="Changes deployedmonitor metrics">Monitoring</option>
        </select>
      </div>
      
      <div style="margin-bottom: 1rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Title (optional):</label>
        <input type="text" id="track-title" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px;" placeholder="e.g. Rewrite title/H1 + FAQ schema">
      </div>
      
      <div style="margin-bottom: 1.5rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Notes (optional):</label>
        <textarea id="track-notes" rows="3" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-family: inherit;" placeholder="Additional notes..."></textarea>
      </div>

      <!-- Objective Section (Cycle 1) -->
      <div style="margin-bottom: 1.5rem; padding: 1rem; background: #f8fafc; border-radius: 4px; border: 1px solid #e2e8f0;">
        <h4 style="margin: 0 0 1rem 0; font-size: 1rem; color: #1e293b; font-weight: 600;">Objective (Cycle 1)</h4>
        
        <div style="margin-bottom: 0.75rem;">
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Objective Title:</label>
          <input type="text" id="track-objective-title" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. Improve CTR by 20%">
        </div>

        <div style="margin-bottom: 0.75rem;">
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Primary KPI:</label>
          <select id="track-primary-kpi" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
            <option value="">Select KPI...</option>
            <option value="ctr">CTR</option>
            <option value="rank">Rank</option>
            <option value="clicks">Clicks</option>
            <option value="impressions">Impressions</option>
            <option value="ai_citations">AI Citations</option>
          </select>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
          <div>
            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Direction:</label>
            <select id="track-target-direction" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
              <option value="">Select...</option>
              <option value="increase">Increase</option>
              <option value="decrease">Decrease</option>
              <option value="at_least">At least</option>
              <option value="at_most">At most</option>
            </select>
          </div>
          <div>
            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Value:</label>
            <input type="number" id="track-target-value" step="0.01" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. 20">
          </div>
        </div>

        <div style="margin-bottom: 0.75rem;">
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Timeframe (days):</label>
          <select id="track-timeframe-days" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
            <option value="">Select timeframe...</option>
            <option value="30">30 days</option>
            <option value="60">60 days</option>
            <option value="90">90 days</option>
          </select>
        </div>

        <div style="margin-bottom: 0.75rem;">
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Plan / Hypothesis (optional):</label>
          <textarea id="track-plan" rows="2" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-family: inherit; font-size: 0.875rem;" placeholder="Describe your plan or hypothesis..."></textarea>
        </div>
      </div>
      
      <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
        <button type="button" onclick="document.getElementById('optimisation-track-modal').style.display='none'" style="padding: 0.5rem 1rem; border: 1px solid #cbd5e1; border-radius: 4px; background: white; cursor: pointer;">Cancel</button>
        <button type="button" onclick="window.submitTrackKeyword()" style="padding: 0.5rem 1rem; border: none; border-radius: 4px; background: #2563eb; color: white; cursor: pointer; font-weight: 500;">Create Task</button>
      </div>
    </div>
  </div>

  <!-- Manage Optimisation Modal -->
  <div id="optimisation-manage-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
    <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto;">
      <h3 style="margin: 0 0 1.5rem 0; font-size: 1.25rem; color: #1e293b;">Manage Optimisation</h3>
      
      <div style="margin-bottom: 1rem; padding: 1rem; background: #f8fafc; border-radius: 4px;">
        <div style="margin-bottom: 0.75rem;">
          <strong style="color: #475569;">Keyword:</strong>
          <div id="manage-keyword-text" style="padding: 0.5rem; background: #f8fafc; border-radius: 4px; color: #0284c7; font-weight: 600; font-size: 1rem; margin-top: 0.25rem;"></div>
        </div>
        <div style="margin-bottom: 0.75rem;">
          <strong style="color: #475569;">Target URL:</strong>
          <div id="manage-url-text" style="padding: 0.5rem; background: #f8fafc; border-radius: 4px; margin-top: 0.25rem; word-break: break-all;"></div>
        </div>
        <div style="margin-bottom: 0.75rem;">
          <strong style="color: #475569;">Task type:</strong>
          <div id="manage-task-type-text" style="color: #1e293b; margin-top: 0.25rem;"></div>
        </div>
        <div style="margin-bottom: 0.75rem;">
          <strong style="color: #475569;">Current status:</strong>
          <div id="manage-status-text" style="color: #1e293b; margin-top: 0.25rem;"></div>
        </div>
        <div style="margin-bottom: 0.75rem;">
          <strong style="color: #475569;">Cycle:</strong>
          <div id="manage-cycle-text" style="color: #1e293b; margin-top: 0.25rem;"></div>
        </div>
        <div>
          <strong style="color: #475569;">Last activity:</strong>
          <div id="manage-last-activity-text" style="color: #1e293b; margin-top: 0.25rem;"></div>
        </div>
      </div>
      
      <div style="margin-bottom: 1.5rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569;">Change status:</label>
        <select id="manage-status-select" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px;">
          <option value="planned">Planned</option>
          <option value="in_progress">In progress</option>
          <option value="monitoring">Monitoring</option>
          <option value="done">Done</option>
          <option value="paused">Paused</option>
          <option value="cancelled">Cancelled</option>
        </select>
      </div>
      
      <div style="display: flex; flex-direction: column; gap: 0.75rem; margin-bottom: 1.5rem;">
        <button type="button" onclick="window.submitStatusChange()" style="padding: 0.5rem 1rem; border: none; border-radius: 4px; background: #2563eb; color: white; cursor: pointer; font-weight: 500;">Save Status Change</button>
        <button type="button" onclick="window.startNewCycle()" style="padding: 0.5rem 1rem; border: 1px solid #2563eb; border-radius: 4px; background: white; color: #2563eb; cursor: pointer; font-weight: 500;">Start New Cycle</button>
        <button type="button" onclick="window.stopTracking()" style="padding: 0.5rem 1rem; border: 1px solid #ef4444; border-radius: 4px; background: white; color: #ef4444; cursor: pointer; font-weight: 500;">Stop Tracking</button>
      </div>
      
      <div style="display: flex; justify-content: flex-end;">
        <button type="button" onclick="document.getElementById('optimisation-manage-modal').style.display='none'" style="padding: 0.5rem 1rem; border: 1px solid #cbd5e1; border-radius: 4px; background: white; cursor: pointer;">Close</button>
      </div>
    </div>
  </div>

  <!-- New Cycle Modal -->
  <div id="optimisation-new-cycle-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10001; align-items: center; justify-content: center;">
    <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto;">
      <h3 style="margin: 0 0 1.5rem 0; font-size: 1.25rem; color: #1e293b;">Start New Cycle: <span id="new-cycle-cycle-no">Cycle 2</span></h3>
      
      <div style="margin-bottom: 1rem; padding: 0.75rem; background: #f0f9ff; border-radius: 4px; border: 1px solid #bae6fd;">
        <div style="font-size: 0.875rem; color: #0369a1;">
          <strong>Tip:</strong> The form is pre-filled with the previous cycle's objective. You can modify it for this new cycle.
        </div>
      </div>

      <div style="margin-bottom: 0.75rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Objective Title:</label>
        <input type="text" id="new-cycle-objective-title" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. Improve CTR by 20%">
      </div>

      <div style="margin-bottom: 0.75rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Primary KPI:</label>
        <select id="new-cycle-primary-kpi" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
          <option value="">Select KPI...</option>
          <option value="ctr">CTR</option>
          <option value="rank">Rank</option>
          <option value="clicks">Clicks</option>
          <option value="impressions">Impressions</option>
          <option value="ai_citations">AI Citations</option>
        </select>
      </div>

      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
        <div>
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Direction:</label>
          <select id="new-cycle-target-direction" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
            <option value="">Select...</option>
            <option value="increase">Increase</option>
            <option value="decrease">Decrease</option>
            <option value="at_least">At least</option>
            <option value="at_most">At most</option>
          </select>
        </div>
        <div>
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Value:</label>
          <input type="number" id="new-cycle-target-value" step="0.01" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. 20">
        </div>
      </div>

      <div style="margin-bottom: 0.75rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Timeframe (days):</label>
        <select id="new-cycle-timeframe-days" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
          <option value="">Select timeframe...</option>
          <option value="30">30 days</option>
          <option value="60">60 days</option>
          <option value="90">90 days</option>
        </select>
      </div>

      <div style="margin-bottom: 1.5rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Plan / Hypothesis (optional):</label>
        <textarea id="new-cycle-plan" rows="3" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-family: inherit; font-size: 0.875rem;" placeholder="Describe your plan or hypothesis..."></textarea>
      </div>
      
      <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
        <button type="button" onclick="document.getElementById('optimisation-new-cycle-modal').style.display='none'" style="padding: 0.5rem 1rem; border: 1px solid #cbd5e1; border-radius: 4px; background: white; cursor: pointer;">Cancel</button>
        <button type="button" onclick="window.submitNewCycle()" style="padding: 0.5rem 1rem; border: none; border-radius: 4px; background: #2563eb; color: white; cursor: pointer; font-weight: 500;">Start Cycle</button>
      </div>
    </div>
  </div>

  <!-- Edit Objective Modal -->
  <div id="optimisation-edit-objective-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10001; align-items: center; justify-content: center;">
    <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto;">
      <h3 style="margin: 0 0 1.5rem 0; font-size: 1.25rem; color: #1e293b;">Edit Objective</h3>

      <div style="margin-bottom: 0.75rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Objective Title:</label>
        <input type="text" id="edit-objective-title" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. Improve CTR by 20%">
      </div>

      <div style="margin-bottom: 0.75rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Primary KPI:</label>
        <select id="edit-objective-primary-kpi" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
          <option value="">Select KPI...</option>
          <option value="ctr">CTR</option>
          <option value="rank">Rank</option>
          <option value="clicks">Clicks</option>
          <option value="impressions">Impressions</option>
          <option value="ai_citations">AI Citations</option>
        </select>
      </div>

      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
        <div>
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Direction:</label>
          <select id="edit-objective-target-direction" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
            <option value="">Select...</option>
            <option value="increase">Increase</option>
            <option value="decrease">Decrease</option>
            <option value="at_least">At least</option>
            <option value="at_most">At most</option>
          </select>
        </div>
        <div>
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Target Value:</label>
          <input type="number" id="edit-objective-target-value" step="0.01" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;" placeholder="e.g. 20">
        </div>
      </div>

      <div style="margin-bottom: 0.75rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Timeframe (days):</label>
        <select id="edit-objective-timeframe-days" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.875rem;">
          <option value="">Select timeframe...</option>
          <option value="30">30 days</option>
          <option value="60">60 days</option>
          <option value="90">90 days</option>
        </select>
      </div>

      <div style="margin-bottom: 1.5rem;">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #475569; font-size: 0.875rem;">Plan / Hypothesis (optional):</label>
        <textarea id="edit-objective-plan" rows="3" style="width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 4px; font-family: inherit; font-size: 0.875rem;" placeholder="Describe your plan or hypothesis..."></textarea>
      </div>
      
      <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
        <button type="button" onclick="document.getElementById('optimisation-edit-objective-modal').style.display='none'" style="padding: 0.5rem 1rem; border: 1px solid #cbd5e1; border-radius: 4px; background: white; cursor: pointer;">Cancel</button>
        <button type="button" onclick="window.submitEditObjective()" style="padding: 0.5rem 1rem; border: none; border-radius: 4px; background: #2563eb; color: white; cursor: pointer; font-weight: 500;">Save Objective</button>
      </div>
    </div>
  </div>

</body>
</html>



