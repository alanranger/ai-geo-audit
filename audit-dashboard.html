<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>AI GEO Audit Dashboard - Automated SEO Analysis (v 80c0dd8)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script>
    // Try to load config.js if it exists (for local development)
    // Note: config.js is gitignored and won't be deployed to Vercel
    // Silently fail if config.js doesn't exist (expected on Vercel)
    try {
      const configScript = document.createElement('script');
      configScript.src = 'config.js';
      configScript.onerror = function() {
        // Silently ignore - config.js is optional (expected on Vercel)
        // Prevent console error from showing
        return true;
      };
      configScript.onload = function() {
        // Successfully loaded
      };
      // Suppress syntax errors if file returns HTML (404 page)
      configScript.setAttribute('type', 'text/javascript');
      document.head.appendChild(configScript);
    } catch (e) {
      // Silently ignore - config.js is optional
    }
  </script>
  <style>
    :root {
      --brand-orange: #E57200;
      --brand-dark: #222222;
      --brand-grey: #555555;
      --bg-page: #f2f2f2;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg-page);
      color: var(--brand-dark);
      line-height: 1.5;
    }
    .header {
      background: linear-gradient(135deg, var(--brand-orange) 0%, #ff8c42 100%);
      color: white;
      padding: 2rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .header h1 {
      margin: 0 0 0.5rem 0;
      font-size: 2rem;
    }
    .header p {
      margin: 0;
      opacity: 0.9;
    }
    .container {
      max-width: 1800px;
      margin: 0 auto;
      padding: 2rem;
      padding-bottom: 60px; /* Space for debug panel */
    }
    .config-panel {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      margin-bottom: 2rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .config-panel h2 {
      margin: 0 0 1rem 0;
      color: var(--brand-dark);
      font-size: 1.25rem;
    }
    .form-group {
      margin-bottom: 1rem;
    }
    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      color: var(--brand-grey);
    }
    .form-group input {
      width: 100%;
      padding: 0.75rem;
      border: 2px solid #e2e8f0;
      border-radius: 6px;
      font-size: 1rem;
    }
    .form-group input:focus {
      outline: none;
      border-color: var(--brand-orange);
    }
    .btn {
      background: var(--brand-orange);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    .btn:hover {
      background: #d46200;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    .btn-secondary {
      background: var(--brand-grey);
    }
    .btn-secondary:hover {
      background: #444;
    }
    .status {
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      display: none;
    }
    .status.success {
      background: #d1fae5;
      color: #065f46;
      border-left: 4px solid var(--success);
    }
    .status.error {
      background: #fee2e2;
      color: #991b1b;
      border-left: 4px solid var(--danger);
    }
    .status.info {
      background: #dbeafe;
      color: #1e40af;
      border-left: 4px solid #3b82f6;
    }
    .status.show {
      display: block;
    }
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    .pillar-card {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: relative;
    }
    .pillar-card h3 {
      margin: 0 0 0.75rem 0;
      color: var(--brand-dark);
      font-size: 1.1rem;
    }
    .pillar-score {
      font-size: 3rem;
      font-weight: 700;
      margin: 0.5rem 0;
      line-height: 1;
    }
    .pillar-score.rag-red {
      color: var(--danger);
    }
    .pillar-score.rag-amber {
      color: var(--warning);
    }
    .pillar-score.rag-green {
      color: var(--success);
    }
    .rag-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.875rem;
      font-weight: 600;
      margin-top: 0.75rem;
      margin-bottom: 0.5rem;
    }
    .rag-badge.red {
      background: #fee2e2;
      color: #991b1b;
    }
    .rag-badge.amber {
      background: #fef3c7;
      color: #92400e;
    }
    .rag-badge.green {
      background: #d1fae5;
      color: #065f46;
    }
    .chart-container {
      background: linear-gradient(135deg, #f0f4f8 0%, #e2e8f0 100%);
      padding: 1.5rem;
      padding-bottom: 3rem; /* Extra padding at bottom for rotated axis labels */
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 6rem; /* extra breathing room below charts */
      height: 400px;
      border: 1px solid rgba(100, 116, 139, 0.2);
      overflow: visible; /* Allow axis labels to extend beyond container */
    }
    .chart-container.large {
      height: 1200px;
      min-height: 1200px;
      padding: 2rem;
    }
    .dashboard-two-column {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-three-column {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-four-column {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    @media (max-width: 1200px) {
      .dashboard-four-column {
        grid-template-columns: repeat(2, 1fr);
      }
      .dashboard-three-column {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    @media (max-width: 768px) {
      .dashboard-two-column,
      .dashboard-three-column,
      .dashboard-four-column {
        grid-template-columns: 1fr;
      }
    }
    .chart-container h3 {
      margin: 0 0 0.5rem 0;
      color: var(--brand-dark);
    }
    .chart-container p {
      margin: 0 0 1rem 0;
    }
    .trend-summary-row {
      display: flex;
      gap: 1.5rem;
      font-size: 0.9rem;
      margin-bottom: 0.75rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .trend-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.7);
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.06);
      border: 1px solid rgba(148, 163, 184, 0.3);
    }
    .trend-pill span.label {
      font-weight: 600;
      color: #374151;
    }
    .trend-pill span.value.up {
      font-weight: 700;
      color: #10b981; /* green */
    }
    .trend-pill span.value.down {
      font-weight: 700;
      color: #ef4444; /* red */
    }
    .trend-pill span.value.neutral {
      font-weight: 700;
      color: #1f2937; /* black/dark gray for no change */
    }
    .metrics-section {
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border: 1px solid rgba(59, 130, 246, 0.1);
    }
    .scorecard-section {
      margin-top: 4rem;  /* push scorecard further below charts */
      margin-bottom: 3rem;
    }
    .scorecard-section h3 {
      margin-bottom: 1.5rem;
    }
    .metrics-section {
      margin-top: 3rem;
      margin-bottom: 3rem;
    }
    .metrics-section h3 {
      margin-bottom: 1.5rem;
    }
    .section-break {
      margin-top: 4rem;
      margin-bottom: 4rem;
      border-top: 2px solid #e2e8f0;
      padding-top: 2rem;
    }
    .calculation-explanation {
      background: #f8f9fa;
      border: 2px solid var(--brand-orange);
      border-radius: 8px;
      margin-bottom: 2rem;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(229, 114, 0, 0.15);
    }
    .calculation-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: linear-gradient(135deg, #fff5f0 0%, #ffe8d6 100%);
      border-bottom: 2px solid var(--brand-orange);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    .calculation-explanation.collapsed .calculation-header {
      border-bottom: none;
    }
    .calculation-header:hover {
      background: linear-gradient(135deg, #ffe8d6 0%, #ffd9b3 100%);
    }
    .calculation-header h4 {
      margin: 0;
      color: var(--brand-orange);
      font-size: 1.1rem;
      font-weight: 600;
    }
    .calculation-toggle {
      font-size: 1.2rem;
      color: var(--brand-orange);
      font-weight: bold;
      transition: transform 0.3s;
    }
    .calculation-explanation.collapsed .calculation-toggle {
      transform: rotate(-90deg);
    }
    .calculation-content {
      padding: 1.5rem;
      color: #555;
      line-height: 1.8;
    }
    .calculation-content.collapsed {
      display: none;
    }
    .calculation-content h5 {
      color: var(--brand-dark);
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-size: 1rem;
      font-weight: 600;
      border-bottom: 2px solid var(--brand-orange);
      padding-bottom: 0.5rem;
    }
    .calculation-content h5:first-child {
      margin-top: 0;
    }
    .calculation-content ul {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
    }
    .calculation-content li {
      margin: 0.5rem 0;
    }
    .calculation-content code {
      background: #e2e8f0;
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #c53030;
    }
    .calculation-content .formula {
      background: #f0f4f8;
      padding: 0.75rem;
      border-left: 3px solid var(--brand-orange);
      margin: 0.75rem 0;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
    }
    .calculation-content .note {
      background: #fff3cd;
      border-left: 3px solid #f59e0b;
      padding: 0.75rem;
      margin: 1rem 0;
      font-size: 0.9rem;
    }
    .date-range-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .date-range-btn {
      padding: 0.5rem 1rem;
      border: 2px solid #e2e8f0;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    .date-range-btn:hover {
      border-color: var(--brand-orange);
      background: #fff5f0;
    }
    .date-range-btn.active {
      background: var(--brand-orange);
      color: white;
      border-color: var(--brand-orange);
    }
    .snippet-readiness-gauge {
      background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 3rem;
      border: 1px solid rgba(16, 185, 129, 0.1);
    }
    .gauge-container {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      flex: 1;
      position: relative;
    }
    .gauge-wrapper {
      position: relative;
      width: 300px;
      height: 300px;
    }
    .gauge-svg {
      transform: rotate(-90deg);
      width: 100%;
      height: 100%;
    }
    .gauge-background {
      fill: none;
      stroke: #e2e8f0;
      stroke-width: 20;
    }
    .gauge-fill {
      fill: none;
      stroke-width: 20;
      stroke-linecap: round;
      transition: stroke-dashoffset 1s ease-in-out;
    }
    .gauge-fill.green {
      stroke: #10b981;
    }
    .gauge-fill.amber {
      stroke: #f59e0b;
    }
    .gauge-fill.red {
      stroke: #ef4444;
    }
    .gauge-value {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      font-weight: 700;
      text-align: center;
      z-index: 10;
    }
    .gauge-value.green {
      color: #10b981;
    }
    .gauge-value.amber {
      color: #f59e0b;
    }
    .gauge-value.red {
      color: #ef4444;
    }
    .gauge-label {
      text-align: center;
      color: var(--brand-grey);
      margin-top: 1rem;
      font-size: 1rem;
      font-weight: 600;
    }
    .gauge-status {
      text-align: center;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      font-weight: 500;
    }
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }
    .metric-card {
      background: white;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
    }
    .metric-card .value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--brand-orange);
      margin: 0.5rem 0;
    }
    .metric-card .label {
      color: var(--brand-grey);
      font-size: 0.875rem;
    }
    .loading {
      display: none;
      text-align: center;
      padding: 2rem;
    }
    .loading.show {
      display: block;
    }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--brand-orange);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .progress-container {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1rem 0;
    }
    .progress-bar-wrapper {
      width: 100%;
      background: #e2e8f0;
      border-radius: 10px;
      height: 24px;
      overflow: hidden;
      margin: 1rem 0;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--brand-orange), #ff8c42);
      border-radius: 10px;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 0.85rem;
      min-width: 0;
    }
    .progress-status {
      font-size: 0.95rem;
      color: #555;
      margin-top: 0.5rem;
      font-weight: 500;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      overflow: auto;
    }
    .modal-content {
      background-color: white;
      margin: 5% auto;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      animation: modalSlideIn 0.3s ease;
    }
    @keyframes modalSlideIn {
      from {
        transform: translateY(-50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    .help-text {
      font-size: 0.875rem;
      color: var(--brand-grey);
      margin-top: 0.25rem;
    }

    .debug-panel-bottom {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1a1a1a;
      border-top: 3px solid #E57200;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      z-index: 1000;
      box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.5);
      max-height: 50vh;
      display: flex;
      flex-direction: column;
    }

    .debug-panel-bottom.collapsed {
      max-height: 50px;
    }

    .debug-panel-bottom.collapsed .debug-content {
      display: none !important;
    }

    .debug-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #333;
      background: #252525;
      user-select: none;
    }

    .debug-header h3 {
      margin: 0;
      color: #fff;
      font-size: 1rem;
    }

    .debug-actions {
      display: flex;
      gap: 0.5rem;
    }

    .btn-small {
      padding: 0.25rem 0.75rem;
      font-size: 0.75rem;
      background: #333;
      color: #fff;
      border: 1px solid #555;
    }

    .btn-small:hover {
      background: #444;
    }

    .debug-content {
      color: #fff;
      line-height: 1.6;
      padding: 1rem;
      overflow-y: auto;
      flex: 1;
      max-height: calc(50vh - 60px);
    }

    .debug-log-entry {
      margin-bottom: 0.25rem;
      padding: 0.25rem 0;
      border-left: 2px solid transparent;
      padding-left: 0.5rem;
    }

    .debug-log-entry.error {
      color: #f44;
      border-left-color: #f44;
    }

    .debug-log-entry.warn {
      color: #fa4;
      border-left-color: #fa4;
    }

    .debug-log-entry.info {
      color: #9cf;
      border-left-color: #4af;
    }

    .debug-log-entry.success {
      color: #9f9;
      border-left-color: #4f4;
    }

    .debug-timestamp {
      color: #aaa;
      margin-right: 0.5rem;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>AI GEO Audit Dashboard</h1>
    <p>Automated SEO Analysis & Pillar Score Tracking</p>
    <p style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 1; background: rgba(0,0,0,0.3); padding: 0.25rem 0.5rem; border-radius: 4px; display: inline-block;">
      <strong>Version: 80c0dd8</strong> | Built: 2025-01-27 19:20 UTC | 
      <span id="loadTime" style="color: #4f4;">Loaded: <script>document.write(new Date().toLocaleTimeString())</script></span>
    </p>
  </div>

  <div class="container">
    <div class="config-panel">
      <h2>Configuration</h2>
      <div class="info-box" style="background: #e8f4f8; border-left: 4px solid #2196F3; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #1565C0;"><strong>Entity-Level Audit:</strong> This dashboard analyzes <strong>www.alanranger.com</strong> as a global entity, tracking AI-powered search visibility, entity recognition, and SERP behavior across the entire domain.</p>
      </div>
      <div class="form-group">
        <label for="propertyUrl">Property URL</label>
        <input type="text" id="propertyUrl" placeholder="https://yourwebsite.com" value="https://www.alanranger.com">
        <div class="help-text">The domain being audited (entity-level analysis)</div>
      </div>
      <div class="form-group">
        <label for="dateRange">Date Range</label>
        <div class="date-range-selector">
          <button class="date-range-btn active" onclick="setDateRange(30)" data-days="30" title="Analyze search performance data from the last 30 days">Last 30 Days</button>
          <button class="date-range-btn" onclick="setDateRange(60)" data-days="60" title="Analyze search performance data from the last 60 days">Last 60 Days</button>
          <button class="date-range-btn" onclick="setDateRange(90)" data-days="90" title="Analyze search performance data from the last 90 days">Last 90 Days</button>
          <button class="date-range-btn" onclick="setDateRange(120)" data-days="120" title="Analyze search performance data from the last 120 days">Last 120 Days</button>
          <button class="date-range-btn" onclick="setDateRange(180)" data-days="180" title="Analyze search performance data from the last 6 months (180 days)">Last 6 Months</button>
          <button class="date-range-btn" onclick="setDateRange(365)" data-days="365" title="Analyze search performance data from the last 12 months (365 days)">Last 12 Months</button>
          <button class="date-range-btn" onclick="setDateRange(540)" data-days="540" title="Analyze search performance data from the last 18 months (540 days)">Last 18 Months</button>
          <button class="date-range-btn" onclick="showCustomDateRange()" id="customDateBtn" title="Set a custom date range for analysis (enter number of days)">Custom</button>
        </div>
        <input type="number" id="dateRange" value="30" min="1" style="display: none;">
        <div id="customDateRange" style="display: none; margin-top: 0.5rem;">
          <input type="number" id="customDays" placeholder="Enter days" min="1" style="width: 150px; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px;">
          <button class="btn btn-small" onclick="applyCustomDateRange()" style="margin-left: 0.5rem; padding: 0.5rem 1rem;" title="Apply the custom date range you entered">Apply</button>
        </div>
        <div class="help-text">Analysis period for historical data</div>
      </div>
      <div style="background: #f0f0f0; padding: 0.75rem; border-radius: 4px; margin-bottom: 1rem; font-size: 0.85rem; color: #555;">
        <strong>API Key:</strong> Loaded automatically from Vercel environment variables. No manual entry required.
      </div>
      <div class="form-group">
        <label for="manualUrlList">Manual URL List (Optional)</label>
        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">
          Load list of site URLs from a CSV file
        </div>
        <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
          <input type="file" id="urlListFile" accept=".csv" style="flex: 1; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem;">
          <button class="btn btn-small" onclick="loadUrlListFromFile()" style="padding: 0.5rem 1rem;" title="Load a CSV file containing site URLs. The CSV must have a 'url' column in the header row. URLs will be used for schema audit instead of the default CSV source.">Load CSV</button>
          <button class="btn btn-small" onclick="clearManualUrlList()" style="padding: 0.5rem 1rem; background: #ef4444; color: white; border-color: #ef4444;" title="Clear the manually loaded URL list and revert to using the default CSV source for schema audit">Clear</button>
        </div>
        <textarea id="manualUrlList" placeholder="Or paste CSV content here (must include 'url' column in header row)..." style="width: 100%; min-height: 100px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace; resize: vertical;"></textarea>
        <div class="help-text">
          <strong>Required column:</strong> <code>url</code> (case-insensitive). CSV must have a header row. URLs will be extracted from the 'url' column.
        </div>
        <div id="urlListStatus" style="margin-top: 0.5rem; font-size: 0.85rem;"></div>
      </div>
      <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
        <button class="btn" onclick="runAudit()" title="Start a comprehensive audit scan. Fetches Google Search Console data and performs schema audit on all site URLs. Results will appear in the dashboard below.">Run Audit Scan</button>
        <button class="btn btn-secondary" id="retryFailedUrlsBtn" onclick="retryFailedUrlsFromLastAudit()" style="background: #f59e0b; color: white; border-color: #f59e0b; display: none;" title="Retry scanning the failed URLs from the last audit. This will rescan only the URLs that failed during the previous audit scan.">
          üîÑ Retry Failed URLs
        </button>
        <button class="btn btn-secondary" onclick="saveConfig()" title="Save your current configuration (property URL and date range) to browser localStorage. Settings will be restored when you reload the page.">Save Configuration</button>
        <button class="btn btn-secondary" onclick="syncCSV()" id="syncCsvBtn" style="background: #10b981; color: white; border-color: #10b981;" title="Sync the site URLs CSV file from GitHub. This updates the list of URLs that will be scanned during schema audit.">
          <span id="syncCsvBtnText">üîÑ Sync CSV</span>
        </button>
      </div>
    </div>

    <!-- Reporting Section -->
    <div class="config-panel" style="margin-top: 2rem;">
      <h2>Reporting</h2>
      <div class="info-box" style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #856404;"><strong>Generate Reports:</strong> Create comprehensive PDF reports containing all audit data, charts, and pillar score definitions.</p>
      </div>
      <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
        <button class="btn" onclick="try { console.log('[PDF] Button clicked!'); generatePDFReport(); } catch(e) { console.error('[PDF] Error in onclick:', e); alert('Error generating PDF: ' + e.message); }" id="generatePdfBtn" style="background: #dc2626; color: white; border-color: #dc2626;" title="Generate a comprehensive PDF report containing all audit data, charts, pillar scores, definitions, and metrics. The report will include all sections from the dashboard.">
          üìÑ Generate PDF Report
        </button>
        <div id="pdfStatus" style="font-size: 0.85rem; color: #666; margin-left: 0.5rem;"></div>
      </div>
    </div>

    <div class="status" id="status"></div>

    <div class="loading" id="loading">
      <div class="progress-container">
        <div class="spinner"></div>
        <div class="progress-bar-wrapper">
          <div class="progress-bar" id="progressBar" style="width: 0%;">0%</div>
        </div>
        <div class="progress-status" id="progressStatus">Initializing audit scan...</div>
      </div>
    </div>

    <!-- Completion Summary Modal -->
    <div id="completionModal" class="modal" style="display: none;">
      <div class="modal-content" style="max-width: 600px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Audit Complete</h2>
          <button onclick="closeCompletionModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;" title="Close the audit completion summary modal">&times;</button>
        </div>
        <div id="completionSummaryContent"></div>
        <div style="margin-top: 1.5rem; text-align: right;">
          <button class="btn" onclick="closeCompletionModal()" style="background: var(--brand-orange); color: white; border-color: var(--brand-orange);" title="Close the audit completion summary modal and return to the dashboard">Close</button>
        </div>
      </div>
    </div>

    <div id="dashboard" style="display: none;">
      <div id="auditTimestamp" style="background: #e8f5e9; padding: 0.75rem 1rem; border-radius: 6px; margin-bottom: 1rem; border-left: 4px solid #10b981; font-size: 0.9rem; color: #555;">
        <strong>Last Audit:</strong> <span id="lastAuditTime">Not yet run</span>
      </div>
      <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px; margin-bottom: 3rem; border-left: 4px solid var(--brand-orange);">
        <h3 style="margin-top: 0; color: var(--brand-orange);">Five-Pillar Framework</h3>
        <p style="color: #555; line-height: 1.6; margin-bottom: 1rem;">
          This audit analyzes <strong>www.alanranger.com</strong> as a global entity using a five-pillar framework to assess AI-powered search visibility, entity recognition, and SERP behavior. Each pillar is scored 0-100 and assigned a RAG (Red/Amber/Green) status based on performance thresholds.
        </p>
        <p style="color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
          <strong>Data Sources:</strong> Scores are calculated using data from Google Search Console API (impressions, clicks, position, queries), schema markup validation, local pack visibility metrics, and SERP feature tracking (featured snippets, AI Overviews, rich results).
        </p>
        <p style="color: #555; line-height: 1.6; margin-bottom: 0;">
          <strong>Score Calculation:</strong> Each pillar combines multiple weighted factors: Local Entity (brand consistency, entity signals, NAP data), Service Area (geographic coverage, location schema), Authority (E-A-T: Experience, Expertise, Authoritativeness, Trustworthiness - content depth, backlinks, reviews, credentials, citations), Visibility (ranking positions, SERP features, CTR), and Content/Schema (Foundation schemas 30% + Rich Results 35% + Coverage 20% + Diversity 15%). Scores are normalized to 0-100 scale with thresholds: Green (70-100), Amber (40-69), Red (0-39).
        </p>
      </div>

      <div class="calculation-explanation collapsed" id="calculationExplanation">
        <div class="calculation-header" onclick="toggleCalculationExplanation()">
          <h4>üìä Detailed Calculation Explanation</h4>
          <span class="calculation-toggle" id="calculationToggle">‚ñ∂</span>
        </div>
        <div class="calculation-content collapsed" id="calculationContent">
          <h5>1. Visibility</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Primary: Average position from Google Search Console (1-40 mapped to 100-10)</li>
            <li>Formula: <code>posScore = 100 - ((clampedPosition - 1) / 39) * 90</code></li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: impressions, clicks, average position, CTR</li>
            <li>SERP feature tracking: featured snippets, AI Overviews, rich results</li>
          </ul>
          <p><strong>Data Checked:</strong> Search Console impressions/clicks, average position, CTR, featured snippet appearances, local pack visibility, SERP feature presence, ranking distribution.</p>

          <h5>2. Authority (E-A-T)</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Blend of CTR (60%) and position score (40%)</li>
            <li>Formula: <code>authority = 0.6 * ctrScore + 0.4 * posScore</code></li>
            <li>CTR mapped: 0-10% ‚Üí 0-100 (0.10 = 100)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: CTR, position</li>
            <li>Backlink analysis (planned)</li>
            <li>Review data (planned)</li>
          </ul>
          <p><strong>Data Checked:</strong> Content depth (word count, comprehensiveness), backlink quality/quantity, review counts/ratings, author credentials, citations in content, external mentions, case studies, certifications displayed.</p>

          <h5>3. Local Entity</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Anchored around 60, adjusted by position and CTR</li>
            <li>Formula: <code>localEntity = 60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50)</code></li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: position, CTR</li>
            <li>Schema markup validation (planned)</li>
            <li>Knowledge panel tracking (planned)</li>
          </ul>
          <p><strong>Data Checked:</strong> LocalBusiness schema presence, NAP consistency across site, entity mentions in content, knowledge panel presence, author markup, Organization schema.</p>

          <h5>4. Service Area</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Derived from Local Entity, slightly lower</li>
            <li>Formula: <code>serviceArea = localEntity - 5</code></li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API (via Local Entity calculation)</li>
            <li>Schema markup validation (planned)</li>
            <li>Google Business Profile data (planned)</li>
          </ul>
          <p><strong>Data Checked:</strong> ServiceArea schema markup, geographic keywords in content, location pages, Google Business Profile service areas, address/location schema.</p>

          <h5>5. Content/Schema</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Weighted calculation based on four components: Foundation schemas, Rich Results, Coverage, and Diversity</li>
            <li>Formula: <code>contentSchema = (Foundation √ó 30%) + (Rich Results √ó 35%) + (Coverage √ó 20%) + (Diversity √ó 15%)</code></li>
            <li><strong>Foundation Schemas (30%):</strong> Organization, Person, WebSite, BreadcrumbList presence. Score = (types present / 4) √ó 100</li>
            <li><strong>Rich Results (35%):</strong> Article, Event, Course, FAQ, HowTo, VideoObject, Recipe, Product, LocalBusiness, Review eligibility. Score = (eligible types / 10) √ó 100</li>
            <li><strong>Coverage (20%):</strong> Pages with schema / total pages. Score = coverage percentage</li>
            <li><strong>Diversity (15%):</strong> Number of unique schema types across site. Score = min((unique types / 15) √ó 100, 100)</li>
            <li><strong>Data Source:</strong> Schema audit API (crawls actual pages for JSON-LD markup)</li>
            <li>Uses real schema coverage from CSV-based audit (when available)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Schema Audit API: CSV-based domain crawl of all site URLs</li>
            <li>Schema markup detection and type counting</li>
            <li>Foundation schema presence detection (Organization, Person, WebSite, BreadcrumbList)</li>
            <li>Rich result eligibility detection (Article, Event, Course, FAQ, HowTo, VideoObject, Recipe, Product, LocalBusiness, Review)</li>
          </ul>
          <p><strong>Data Checked:</strong> Total pages scanned, pages with schema, schema coverage percentage, schema types present (Organization, Person, LocalBusiness, Article, Course, Event, FAQ, HowTo, etc.), missing schema types, rich result eligibility (Article, Event, FAQ, Product, LocalBusiness, Course, Review, HowTo).</p>

          <div class="note">
            <strong>Current Implementation Status:</strong><br>
            <strong>Currently Active:</strong> Google Search Console API integration (real-time data) - Total clicks, Total impressions, Average position, CTR calculation, Top queries.<br><br>
            <strong>Planned/Future Enhancements:</strong> Schema markup validation and analysis, Backlink quality/quantity analysis, Review aggregation, Knowledge panel tracking, Local pack visibility metrics, SERP feature detection, Rich result eligibility checks.<br><br>
            <strong>Note:</strong> Currently, most pillars are calculated from GSC metrics (position, CTR, impressions, clicks). The formulas are deterministic and stable, but full implementation will require additional data sources for complete accuracy.
          </div>
        </div>
      </div>

      <div class="dashboard-grid" id="pillarCards"></div>

      <div class="section-break"></div>

      <div class="metrics-section">
        <h3 style="color: var(--brand-orange); margin-bottom: 0.5rem;">Key Performance Indicators</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Core metrics from Google Search Console showing overall search performance for the entity. <strong>Note:</strong> Small differences from live GSC may occur due to data processing delays (up to 48 hours) and exact date range calculations.</p>
        <div class="metrics-grid" id="metricsGrid"></div>
      </div>

      <div class="section-break"></div>

      <div class="dashboard-two-column">
        <div class="chart-container large">
          <h3>Pillar Scores Overview</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Radar chart showing current performance across all five pillars. The larger the area, the stronger your overall entity recognition.</p>
          
          <!-- Audit Timestamp for Radar Chart -->
          <div id="radarChartTimestamp" style="background: #fff3cd; padding: 0.5rem 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #f59e0b; font-size: 0.8rem; color: #856404; display: none;">
            <strong>Current data as of:</strong> <span id="radarChartAuditTime">-</span> <span style="color: #666; font-size: 0.75rem;">(Not historical - reflects last audit scan)</span>
          </div>
          
          <canvas id="radarChart"></canvas>
        </div>

        <div class="snippet-readiness-gauge">
          <h3 style="margin-top: 0; color: var(--brand-orange);">Snippet Readiness Gauge</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Snippet readiness summarises how likely your content is to be lifted into featured snippets and AI answers. It reflects three ingredients: snippet-friendly answer blocks, suitable schema (FAQ/HowTo/Article/Course/Event) and existing rich-result behaviour.</p>
          
          <!-- Audit Timestamp for Snippet Readiness -->
          <div id="snippetReadinessTimestamp" style="background: #fff3cd; padding: 0.5rem 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #f59e0b; font-size: 0.8rem; color: #856404; display: none;">
            <strong>Current data as of:</strong> <span id="snippetReadinessAuditTime">-</span> <span style="color: #666; font-size: 0.75rem;">(Not historical - reflects last audit scan)</span>
          </div>
          
          <div id="snippetReadinessExplanation" style="display: none; background: #fde68a; border-left: 4px solid #f59e0b; padding: 1rem; margin-bottom: 1rem; border-radius: 4px; font-size: 0.85rem; color: #78350f;">
            <strong id="explanationTitle" style="color: #78350f;">Top 5 Actions to Improve Snippet Readiness</strong>
            <p style="margin: 0.5rem 0; color: #78350f;">Prioritized actions based on your current scores and their impact on overall snippet readiness:</p>
            <ol id="topActionsList" style="margin: 0.5rem 0 0 1.5rem; padding: 0; list-style-type: decimal;">
              <!-- Top 5 actions will be populated dynamically -->
            </ol>
          </div>
          
          <!-- Overall Combined Score -->
          <div style="text-align: center; margin-bottom: 1.5rem;">
            <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">Overall Snippet Readiness</div>
            <div id="snippetReadinessScore" style="font-size: 3rem; font-weight: 700; color: var(--brand-orange); line-height: 1;">0</div>
            <div id="gaugeStatus" style="font-size: 0.9rem; color: #666; margin-top: 0.25rem;">Calculating...</div>
          </div>
          
          <!-- Pie Chart Container -->
          <div style="display: flex; align-items: center; justify-content: center; gap: 1.5rem; flex-wrap: wrap;">
            <div style="flex: 2; min-width: 400px; max-width: 500px;">
              <canvas id="snippetReadinessPieChart"></canvas>
            </div>
            <div style="flex: 1; min-width: 180px; max-width: 250px;">
              <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--brand-dark);">Component Breakdown:</div>
              <div id="snippetReadinessLegend" style="display: flex; flex-direction: column; gap: 0.5rem;">
                <!-- Legend will be populated by JavaScript -->
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="section-break"></div>

      <div class="chart-container">
        <h3>Score Trends</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Historical performance tracking for all five pillars (Local Entity, Service Area, Authority, Visibility, Content/Schema) over the selected date range.</p>
        <div id="trendSummaryRow" class="trend-summary-row"></div>
        <canvas id="trendChart"></canvas>
      </div>

    </div>

    <!-- Debug Panel - Fixed at bottom, collapsible -->
    <div class="debug-panel-bottom" id="debugPanel">
      <div class="debug-header" onclick="toggleDebugPanel()" style="cursor: pointer;">
        <h3>üîç Debug Log (v80c0dd8)</h3>
        <div class="debug-actions">
          <button class="btn btn-small" onclick="event.stopPropagation(); clearDebugLog();" title="Clear all debug log entries. Useful for starting fresh during troubleshooting.">Clear</button>
          <button class="btn btn-small" onclick="event.stopPropagation(); copyDebugLog();" title="Copy the entire debug log to your clipboard. Useful for sharing logs or troubleshooting issues.">Copy Log</button>
          <span id="debugToggleIcon" style="color: #fff; font-size: 1.2rem;">‚ñº</span>
        </div>
      </div>
      <div class="debug-content" id="debugLog" style="display: block;">
        <div class="debug-log-entry info">
          <span class="debug-timestamp">[Initializing...]</span>Debug panel loaded. Waiting for page initialization...
        </div>
      </div>
    </div>
  </div>

  <script>
    // Immediate console log to verify script is running
    console.log('%c=== AI GEO AUDIT DASHBOARD v80c0dd8 LOADED (Fixed async/await) ===', 'color: #E57200; font-size: 16px; font-weight: bold;');
    console.log('%cDebug panel should be visible at bottom with orange border', 'color: #E57200; font-size: 14px;');
    console.log('Current time:', new Date().toISOString());
    console.log('Page URL:', window.location.href);
    
    // Debug logging system
    const debugLogEntries = [];
    
    function debugLog(message, type = 'info') {
      const timestamp = new Date().toISOString();
      const entry = {
        timestamp,
        message,
        type
      };
      debugLogEntries.push(entry);
      
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        const entryDiv = document.createElement('div');
        entryDiv.className = `debug-log-entry ${type}`;
        entryDiv.innerHTML = `<span class="debug-timestamp">[${new Date(timestamp).toLocaleTimeString()}]</span>${message}`;
        logElement.appendChild(entryDiv);
        logElement.scrollTop = logElement.scrollHeight;
      }
      
      // Only log critical errors to browser console (for debugging production issues)
      // All other logs go to UI debug console only
      if (type === 'error') {
        console.error(`[DEBUG ERROR]`, message);
      }
    }

    function clearDebugLog() {
      debugLogEntries.length = 0;
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        logElement.innerHTML = '';
      }
      debugLog('Debug log cleared', 'info');
    }

    function copyDebugLog() {
      const logText = debugLogEntries.map(entry => 
        `[${entry.timestamp}] [${entry.type.toUpperCase()}] ${entry.message}`
      ).join('\n');
      
      navigator.clipboard.writeText(logText).then(() => {
        debugLog('Debug log copied to clipboard', 'success');
        showStatus('Debug log copied to clipboard!', 'success');
      }).catch(err => {
        debugLog('Failed to copy log: ' + err.message, 'error');
        showStatus('Failed to copy log', 'error');
      });
    }

    function toggleDebugPanel() {
      const panel = document.getElementById('debugPanel');
      const icon = document.getElementById('debugToggleIcon');
      if (panel.classList.contains('collapsed')) {
        panel.classList.remove('collapsed');
        if (icon) icon.textContent = '‚ñº';
      } else {
        panel.classList.add('collapsed');
        if (icon) icon.textContent = '‚ñ≤';
      }
    }

    function toggleCalculationExplanation() {
      const explanation = document.getElementById('calculationExplanation');
      const content = document.getElementById('calculationContent');
      const toggle = document.getElementById('calculationToggle');
      if (explanation.classList.contains('collapsed')) {
        explanation.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '‚ñº';
      } else {
        explanation.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '‚ñ∂';
      }
    }

    // Debug panel is always visible at bottom, start collapsed by default
    window.addEventListener('DOMContentLoaded', () => {
      const debugPanel = document.getElementById('debugPanel');
      const debugToggleIcon = document.getElementById('debugToggleIcon');
      if (debugPanel) {
        debugPanel.style.display = 'flex';
        // Start collapsed by default
        debugPanel.classList.add('collapsed');
        if (debugToggleIcon) {
          debugToggleIcon.textContent = '‚ñ≤';
        }
      }
    });

    // Load saved configuration
    async function loadConfig() {
      debugLog('=== PAGE LOAD: Starting configuration load ===', 'info');
      
      // Check if Chart.js is loaded
      debugLog('Checking Chart.js library...', 'info');
      if (typeof Chart !== 'undefined') {
        debugLog('‚úì Chart.js library loaded successfully', 'success');
      } else {
        debugLog('‚úó Chart.js library NOT loaded', 'error');
      }
      
      // Try to fetch API key from Vercel environment variable (via API endpoint)
      let vercelApiKey = null;
      try {
        debugLog('Checking Vercel environment variable...', 'info');
        const response = await fetch('/api/get-api-key');
        if (response.ok) {
          const data = await response.json();
          if (data.apiKey) {
            vercelApiKey = data.apiKey;
            debugLog('‚úì API key loaded from Vercel environment variable', 'success');
          }
        }
      } catch (e) {
        debugLog('Vercel env var endpoint not available (expected for static site)', 'info');
      }
      
      // Check config.js
      debugLog('Checking for config.js...', 'info');
      if (window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey) {
        debugLog('‚úì config.js found with API key', 'success');
      } else {
        debugLog('‚úó config.js not found or no API key', 'warn');
      }
      
      // Check localStorage
      debugLog('Checking localStorage...', 'info');
      const configApiKey = window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey;
      const apiKey = vercelApiKey || configApiKey || localStorage.getItem('gsc_api_key');
      const propertyUrl = localStorage.getItem('gsc_property_url');
      const dateRange = localStorage.getItem('gsc_date_range');
      
      const apiKeySource = vercelApiKey ? 'Vercel env var' : configApiKey ? 'config.js' : localStorage.getItem('gsc_api_key') ? 'localStorage' : 'none';
      debugLog(`API Key source: ${apiKeySource}`, 'info');
      debugLog(`Property URL: ${propertyUrl || 'not set'}`, 'info');
      debugLog(`Date Range: ${dateRange || 'not set'}`, 'info');
      
      if (apiKey) {
        debugLog('‚úì API key loaded from environment', 'success');
        // Store in a hidden variable for use in runAudit
        window._loadedApiKey = apiKey;
      } else {
        debugLog('‚úó No API key found', 'warn');
      }
      
      if (propertyUrl) {
        document.getElementById('propertyUrl').value = propertyUrl;
        debugLog('‚úì Property URL loaded', 'success');
      }
      if (dateRange) {
        document.getElementById('dateRange').value = dateRange;
        // Set active button based on saved date range
        const savedDays = parseInt(dateRange);
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          btn.classList.remove('active');
          const btnDays = parseInt(btn.getAttribute('data-days'));
          if (btnDays === savedDays) {
            btn.classList.add('active');
          }
        });
        // If no preset matches, show custom
        const presetDays = [7, 30, 90, 180, 365];
        if (!presetDays.includes(savedDays)) {
          document.getElementById('customDateBtn').classList.add('active');
          document.getElementById('customDays').value = savedDays;
          document.getElementById('customDateRange').style.display = 'block';
        }
        debugLog('‚úì Date range loaded', 'success');
      }
      
      // Load manual URL list if saved
      const savedUrlList = localStorage.getItem('manual_url_list');
      if (savedUrlList) {
        try {
          const urls = JSON.parse(savedUrlList);
          const statusDiv = document.getElementById('urlListStatus');
          if (statusDiv) {
            statusDiv.innerHTML = `<span style="color: #10b981;">‚úì ${urls.length} URLs loaded from saved list</span>`;
          }
          debugLog(`‚úì Manual URL list loaded: ${urls.length} URLs`, 'success');
        } catch (e) {
          debugLog('‚ö† Failed to load saved URL list', 'warn');
        }
      }
      
      debugLog('=== Configuration load complete ===', 'info');
    }

    // Save configuration
    // Date range selector functions
    function setDateRange(days) {
      const oldDateRange = parseInt(document.getElementById('dateRange').value) || 30;
      document.getElementById('dateRange').value = days;
      localStorage.setItem('gsc_date_range', days);
      
      // Update active button
      document.querySelectorAll('.date-range-btn').forEach(btn => {
        btn.classList.remove('active');
        const btnDays = parseInt(btn.getAttribute('data-days'));
        if (btnDays === days) {
          btn.classList.add('active');
        }
      });
      
      // Hide custom input if showing
      document.getElementById('customDateRange').style.display = 'none';
      document.getElementById('customDateBtn').classList.remove('active');
      
      debugLog(`Date range set to ${days} days`, 'info');
      
      // Check if saved audit exists and if its date range matches
      const savedAudit = loadAuditResults();
      if (savedAudit && savedAudit.scores) {
        const savedDateRange = savedAudit.dateRange || oldDateRange;
        if (savedDateRange !== days) {
          // Date range changed - update GSC data and recalculate scores
          debugLog(`Date range changed from ${savedDateRange} to ${days} days. Updating metrics...`, 'info');
          updateAuditForNewDateRange(days, savedAudit);
        }
      }
    }

    function showCustomDateRange() {
      const customDiv = document.getElementById('customDateRange');
      const customBtn = document.getElementById('customDateBtn');
      
      if (customDiv.style.display === 'none') {
        customDiv.style.display = 'block';
        customBtn.classList.add('active');
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          if (btn !== customBtn) btn.classList.remove('active');
        });
      } else {
        customDiv.style.display = 'none';
        customBtn.classList.remove('active');
      }
    }

    function applyCustomDateRange() {
      const customDays = parseInt(document.getElementById('customDays').value);
      if (customDays && customDays > 0) {
        const oldDateRange = parseInt(document.getElementById('dateRange').value) || 30;
        document.getElementById('dateRange').value = customDays;
        localStorage.setItem('gsc_date_range', customDays);
        document.getElementById('customDateRange').style.display = 'none';
        document.getElementById('customDateBtn').classList.remove('active');
        debugLog(`Custom date range set to ${customDays} days`, 'info');
        
        // Check if saved audit exists and if its date range matches
        const savedAudit = loadAuditResults();
        if (savedAudit && savedAudit.scores) {
          const savedDateRange = savedAudit.dateRange || oldDateRange;
          if (savedDateRange !== customDays) {
            // Date range changed - update GSC data and recalculate scores
            debugLog(`Date range changed from ${savedDateRange} to ${customDays} days. Updating metrics...`, 'info');
            updateAuditForNewDateRange(customDays, savedAudit);
          }
        }
      } else {
        showStatus('Please enter a valid number of days', 'error');
      }
    }

    function saveConfig() {
      localStorage.setItem('gsc_api_key', document.getElementById('apiKey').value);
      localStorage.setItem('gsc_property_url', document.getElementById('propertyUrl').value);
      localStorage.setItem('gsc_date_range', document.getElementById('dateRange').value);
      showStatus('Configuration saved!', 'success');
    }

    // Parse CSV and validate column names
    function parseUrlListCsv(csvText) {
      const lines = csvText.split('\n').filter(line => line.trim());
      if (lines.length === 0) {
        throw new Error('CSV is empty');
      }
      
      // Parse header row
      const headerLine = lines[0].trim();
      const headers = headerLine.split(',').map(h => h.trim().replace(/^"|"$/g, '').toLowerCase());
      
      // Check for required 'url' column
      const urlColumnIndex = headers.findIndex(h => h === 'url');
      if (urlColumnIndex === -1) {
        throw new Error(`Required column 'url' not found. Found columns: ${headers.join(', ')}`);
      }
      
      // Extract URLs from the 'url' column
      const urls = [];
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        // Parse CSV line (handle quoted values)
        const columns = [];
        let current = '';
        let inQuotes = false;
        
        for (let j = 0; j < line.length; j++) {
          const char = line[j];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            columns.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        columns.push(current.trim()); // Add last column
        
        // Extract URL from the url column
        if (columns[urlColumnIndex]) {
          const url = columns[urlColumnIndex].replace(/^"|"$/g, '').trim();
          if (url && url.startsWith('http')) {
            urls.push(url);
          }
        }
      }
      
      return {
        headers,
        urls,
        totalRows: lines.length - 1,
        validUrls: urls.length
      };
    }

    // Load URL list from file input
    async function loadUrlListFromFile() {
      const fileInput = document.getElementById('urlListFile');
      const statusDiv = document.getElementById('urlListStatus');
      const textarea = document.getElementById('manualUrlList');
      
      if (!fileInput.files || fileInput.files.length === 0) {
        // If no file, try to parse from textarea
        const csvText = textarea.value.trim();
        if (!csvText) {
          statusDiv.innerHTML = '<span style="color: #ef4444;">‚ö† Please select a CSV file or paste CSV content</span>';
          return;
        }
        
        try {
          const result = parseUrlListCsv(csvText);
          localStorage.setItem('manual_url_list', JSON.stringify(result.urls));
          statusDiv.innerHTML = `<span style="color: #10b981;">‚úì Loaded ${result.validUrls} URLs from ${result.totalRows} rows</span>`;
          debugLog(`‚úì Manual URL list loaded: ${result.validUrls} URLs from CSV`, 'success');
          showStatus(`URL list loaded! Found ${result.validUrls} URLs.`, 'success');
        } catch (error) {
          statusDiv.innerHTML = `<span style="color: #ef4444;">‚úó ${error.message}</span>`;
          debugLog(`‚úó URL list parse error: ${error.message}`, 'error');
          showStatus(`URL list error: ${error.message}`, 'error');
        }
        return;
      }
      
      const file = fileInput.files[0];
      debugLog(`Loading URL list from file: ${file.name} (${file.size} bytes)`, 'info');
      
      try {
        const fileText = await file.text();
        const result = parseUrlListCsv(fileText);
        
        // Store URLs in localStorage
        localStorage.setItem('manual_url_list', JSON.stringify(result.urls));
        
        // Also populate textarea with the CSV content
        textarea.value = fileText;
        
        statusDiv.innerHTML = `<span style="color: #10b981;">‚úì Loaded ${result.validUrls} URLs from ${result.totalRows} rows. Columns: ${result.headers.join(', ')}</span>`;
        debugLog(`‚úì URL list loaded from file: ${result.validUrls} URLs`, 'success');
        debugLog(`  File: ${file.name}, Columns: ${result.headers.join(', ')}`, 'info');
        showStatus(`URL list loaded! Found ${result.validUrls} URLs from ${file.name}.`, 'success');
        
        // Clear file input
        fileInput.value = '';
      } catch (error) {
        statusDiv.innerHTML = `<span style="color: #ef4444;">‚úó ${error.message}</span>`;
        debugLog(`‚úó URL list file error: ${error.message}`, 'error');
        showStatus(`URL list error: ${error.message}`, 'error');
      }
    }

    // Clear manual URL list
    function clearManualUrlList() {
      const textarea = document.getElementById('manualUrlList');
      const fileInput = document.getElementById('urlListFile');
      const statusDiv = document.getElementById('urlListStatus');
      
      textarea.value = '';
      fileInput.value = '';
      localStorage.removeItem('manual_url_list');
      statusDiv.innerHTML = '<span style="color: #666;">Manual URL list cleared</span>';
      debugLog('Manual URL list cleared', 'info');
      showStatus('Manual URL list cleared', 'success');
    }

    // Sync CSV from alan-shared-resources
    async function syncCSV() {
      const btn = document.getElementById('syncCsvBtn');
      const btnText = document.getElementById('syncCsvBtnText');
      const originalText = btnText.textContent;
      
      debugLog('=== CSV SYNC: Starting CSV sync verification ===', 'info');
      debugLog('Button clicked - initiating CSV sync check...', 'info');
      
      // Disable button and show loading state
      btn.disabled = true;
      btnText.textContent = '‚è≥ Syncing...';
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      debugLog('Button state: disabled, showing loading indicator', 'info');
      
      try {
        debugLog('Fetching /api/sync-csv endpoint...', 'info');
        const response = await fetch('/api/sync-csv', {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
        });
        
        debugLog(`API response status: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
        
        const data = await response.json();
        debugLog(`API response data: ${JSON.stringify(data).substring(0, 200)}...`, 'info');
        
        if (response.ok && data.status === 'ok') {
          const urlCount = data.data.totalUrls || 0;
          const source = data.source || 'unknown';
          
          debugLog(`‚úì CSV fetched successfully from ${source}`, 'success');
          debugLog(`  CSV URL: ${data.csvUrl || 'not provided'}`, 'info');
          debugLog(`  Total URLs fetched: ${urlCount}`, 'success');
          debugLog(`  CSV size: ${data.data.csvSize} bytes`, 'info');
          debugLog(`  Lines processed: ${data.data.linesProcessed || 'N/A'}`, 'info');
          debugLog(`  Fetched at: ${data.data.fetchedAt}`, 'info');
          
          // Show toast with URL count
          showStatus(`‚úÖ CSV synced from ${source}! Fetched ${urlCount} URLs.`, 'success');
          btnText.textContent = `‚úÖ ${urlCount} URLs`;
          
          // Reset button after 3 seconds
          setTimeout(() => {
            btnText.textContent = originalText;
            btn.style.opacity = '1';
            debugLog('Button reset to original state', 'info');
          }, 3000);
        } else {
          debugLog(`‚úó CSV sync failed`, 'error');
          debugLog(`  Error message: ${data.message || 'Unknown error'}`, 'error');
          debugLog(`  CSV URL attempted: ${data.csvUrl || 'not provided'}`, 'error');
          if (data.suggestion) {
            debugLog(`  Suggestion: ${data.suggestion}`, 'warn');
          }
          showStatus(`CSV sync failed: ${data.message}. ${data.suggestion || ''}`, 'error');
          btnText.textContent = '‚ùå Sync Failed';
          
          // Reset button after 5 seconds
          setTimeout(() => {
            btnText.textContent = originalText;
            btn.style.opacity = '1';
            debugLog('Button reset to original state after error', 'info');
          }, 5000);
        }
      } catch (error) {
        debugLog(`‚úó CSV sync error occurred`, 'error');
        debugLog(`  Error type: ${error.name || 'Unknown'}`, 'error');
        debugLog(`  Error message: ${error.message}`, 'error');
        if (error.stack) {
          debugLog(`  Stack trace: ${error.stack.substring(0, 300)}...`, 'error');
        }
        showStatus(`CSV sync error: ${error.message}. Please run "npm run sync:csv" locally.`, 'error');
        btnText.textContent = '‚ùå Error';
        
        // Reset button after 5 seconds
        setTimeout(() => {
          btnText.textContent = originalText;
          btn.style.opacity = '1';
          debugLog('Button reset to original state after exception', 'info');
        }, 5000);
      } finally {
        btn.disabled = false;
        btn.style.cursor = 'pointer';
        debugLog('=== CSV SYNC: Complete ===', 'info');
      }
    }

    // Update progress bar
    function updateProgress(percent, statusText) {
      const progressBar = document.getElementById('progressBar');
      const progressStatus = document.getElementById('progressStatus');
      if (progressBar) {
        progressBar.style.width = Math.min(100, Math.max(0, percent)) + '%';
        progressBar.textContent = Math.round(percent) + '%';
      }
      if (progressStatus) {
        progressStatus.textContent = statusText || 'Processing...';
      }
    }

    // Show status message
    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = `status ${type} show`;
      setTimeout(() => {
        status.classList.remove('show');
      }, 5000);
    }

    // Show completion summary modal
    function showCompletionModal(schemaAudit) {
      debugLog('showCompletionModal called', 'info');
      const modal = document.getElementById('completionModal');
      const content = document.getElementById('completionSummaryContent');
      
      debugLog(`Modal element found: ${modal ? 'yes' : 'no'}`, 'info');
      debugLog(`Content element found: ${content ? 'yes' : 'no'}`, 'info');
      
      if (!modal || !content) {
        debugLog('‚ö† Modal or content element not found, cannot show modal', 'error');
        return;
      }
      
      let html = '';
      
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data && schemaAudit.meta) {
        const data = schemaAudit.data;
        const meta = schemaAudit.meta;
        const diag = meta.diagnostic || {};
        
        const totalPages = data.totalPages || diag.totalPages || 0;
        const successfulPages = diag.successfulPages || totalPages;
        const failedPages = diag.failedPages || data.missingSchemaCount || 0;
        const isComplete = failedPages === 0;
        
        html += `<div style="margin-bottom: 1.5rem;">`;
        html += `<div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">`;
        html += `<span style="font-size: 2rem;">${isComplete ? '‚úÖ' : '‚ö†Ô∏è'}</span>`;
        html += `<h3 style="margin: 0; color: ${isComplete ? '#10b981' : '#f59e0b'};">
          ${isComplete ? 'Complete' : 'Incomplete'} Data
        </h3>`;
        html += `</div>`;
        
        html += `<div style="background: ${isComplete ? '#f0fdf4' : '#fffbeb'}; border-left: 4px solid ${isComplete ? '#10b981' : '#f59e0b'}; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">`;
        html += `<p style="margin: 0; color: #555; line-height: 1.6;">`;
        if (isComplete) {
          html += `All pages were successfully crawled. Dashboard data is complete and accurate.`;
        } else {
          html += `<strong>Warning:</strong> ${failedPages} page${failedPages !== 1 ? 's' : ''} failed to crawl. Dashboard data may be incomplete. Failed pages are counted as missing schema.`;
        }
        html += `</p>`;
        html += `</div>`;
        
        html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">`;
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Total URLs Scanned</div>`;
        html += `<div style="font-size: 1.5rem; font-weight: 600; color: #333;">${totalPages}</div>`;
        html += `</div>`;
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Successful Crawls</div>`;
        html += `<div style="font-size: 1.5rem; font-weight: 600; color: #10b981;">${successfulPages}</div>`;
        html += `</div>`;
        html += `</div>`;
        
        if (failedPages > 0) {
          // Get failed URLs from missingSchemaPages that have errors
          const failedUrls = (data.missingSchemaPages || []).filter(p => p.error).map(p => p.url);
          
          html += `<div style="background: #fef2f2; border-left: 4px solid #ef4444; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">`;
          html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Failed Crawls</div>`;
          html += `<div style="font-size: 1.5rem; font-weight: 600; color: #ef4444;">${failedPages}</div>`;
          
          if (diag.errorTypes && Object.keys(diag.errorTypes).length > 0) {
            html += `<div style="margin-top: 0.75rem; font-size: 0.85rem; color: #666;">`;
            html += `<strong>Error Breakdown:</strong><br>`;
            Object.entries(diag.errorTypes).forEach(([type, count]) => {
              html += `${type}: ${count}<br>`;
            });
            html += `</div>`;
          }
          
          // Add retry button if there are failed URLs
          if (failedUrls.length > 0) {
            html += `<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #fee2e2;">`;
            html += `<button id="retryFailedUrls" class="btn" style="background: #10b981; color: white; border-color: #10b981; width: 100%;" title="Retry crawling the ${failedUrls.length} failed URLs. This will rescan only the URLs that failed during the initial audit.">`;
            html += `üîÑ Retry Failed URLs (${failedUrls.length})`;
            html += `</button>`;
            html += `<div style="font-size: 0.8rem; color: #666; margin-top: 0.5rem; text-align: center;">Click to rescan only the failed URLs</div>`;
            html += `</div>`;
          }
          
          html += `</div>`;
        }
        
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px; margin-top: 1rem;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;"><strong>Schema Coverage</strong></div>`;
        html += `<div style="font-size: 1.25rem; font-weight: 600; color: #333;">${data.coverage || 0}%</div>`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-top: 0.25rem;">${data.pagesWithSchema || 0} pages with inline schema</div>`;
        html += `</div>`;
        
        html += `</div>`;
      } else {
        html += `<p>Unable to load audit summary data.</p>`;
      }
      
      content.innerHTML = html;
      modal.style.display = 'block';
      debugLog('Modal display set to block', 'info');
      debugLog(`Modal is now visible: ${modal.style.display}`, 'info');
      
      // Attach retry button handler if it exists
      const retryButton = document.getElementById('retryFailedUrls');
      if (retryButton) {
        retryButton.onclick = function() {
          retryFailedUrls(schemaAudit);
        };
      }
    }
    
    // Retry failed URLs from schema audit
    async function retryFailedUrls(schemaAudit) {
      if (!schemaAudit || !schemaAudit.data || !schemaAudit.data.missingSchemaPages) {
        debugLog('‚úó No failed URLs to retry', 'error');
        showStatus('No failed URLs found to retry', 'error');
        return;
      }
      
      // Extract failed URLs (those with errors)
      const failedUrls = schemaAudit.data.missingSchemaPages
        .filter(p => p.error)
        .map(p => p.url);
      
      if (failedUrls.length === 0) {
        debugLog('‚úó No failed URLs to retry', 'error');
        showStatus('No failed URLs found to retry', 'error');
        return;
      }
      
      debugLog(`üîÑ Retrying ${failedUrls.length} failed URLs...`, 'info');
      showStatus(`Retrying ${failedUrls.length} failed URLs...`, 'info');
      
      // Close the modal
      closeCompletionModal();
      
      // Show loading indicator
      document.getElementById('loading').classList.add('show');
      document.getElementById('dashboard').style.display = 'none';
      updateProgress(0, `Retrying ${failedUrls.length} failed URLs...`);
      
      try {
        updateProgress(20, 'Scanning failed URLs for schema markup...');
        debugLog(`Sending retry request for ${failedUrls.length} URLs`, 'info');
        
        // Call schema-audit API with only the failed URLs
        const schemaResponse = await fetch('/api/schema-audit', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ urls: failedUrls })
        });
        
        if (!schemaResponse.ok) {
          throw new Error(`Schema audit API returned error: ${schemaResponse.status}`);
        }
        
        const retrySchemaAudit = await schemaResponse.json();
        
        if (retrySchemaAudit.status !== 'ok') {
          throw new Error(retrySchemaAudit.message || 'Schema audit failed');
        }
        
        const retryData = retrySchemaAudit.data;
        const retrySuccessful = retryData.pagesWithSchema || 0;
        const retryStillFailed = (retryData.missingSchemaCount || 0);
        
        debugLog(`‚úì Retry completed: ${retrySuccessful} pages now have schema, ${retryStillFailed} still failed`, 'success');
        updateProgress(60, 'Merging retry results with original audit...');
        
        // Load original audit results from localStorage
        const savedAudit = loadAuditResults();
        if (savedAudit && savedAudit.schemaAudit && savedAudit.schemaAudit.data) {
          // Merge retry results with original schema audit
          const originalData = savedAudit.schemaAudit.data;
          const originalPages = originalData.pagesWithSchema || 0;
          const originalFailed = originalData.missingSchemaCount || 0;
          
          // Create merged schema audit data
          const mergedSchemaAudit = {
            ...savedAudit.schemaAudit,
            data: {
              ...originalData,
              // Update counts: add retry successful pages, remove retry successful from failed
              pagesWithSchema: originalPages + retrySuccessful,
              missingSchemaCount: Math.max(0, originalFailed - retrySuccessful),
              // Update missingSchemaPages: remove successfully retried URLs
              missingSchemaPages: (originalData.missingSchemaPages || []).filter(p => {
                // Keep only pages that weren't in the retry list or still failed
                return !failedUrls.includes(p.url) || (retryData.missingSchemaPages || []).some(rp => rp.url === p.url);
              }),
              // Update coverage
              coverage: ((originalPages + retrySuccessful) / originalData.totalPages) * 100
            }
          };
          
          // Update saved audit with merged results
          const mergedAudit = {
            ...savedAudit,
            schemaAudit: mergedSchemaAudit
          };
          
          // Recalculate scores with merged data (use saved localSignals if available)
          const mergedScores = calculatePillarScores(savedAudit.searchData, mergedSchemaAudit, savedAudit.localSignals || null);
          const mergedSnippetReadiness = calculateSnippetReadiness(mergedScores, savedAudit.searchData);
          
          // Save merged results (preserve localSignals)
          saveAuditResults(mergedScores, savedAudit.searchData, mergedSnippetReadiness, mergedSchemaAudit, savedAudit.localSignals || null);
          
          // Update retry button visibility
          updateRetryButtonVisibility(mergedSchemaAudit);
          
          // Refresh dashboard with merged results
          updateProgress(80, 'Refreshing dashboard with merged results...');
          displayDashboard(mergedScores, savedAudit.searchData, mergedSnippetReadiness, mergedSchemaAudit);
          
          updateProgress(100, 'Retry completed and dashboard updated!');
          showStatus(`Retry completed: ${retrySuccessful} URLs now have schema. Dashboard updated with merged results.`, 'success');
          
          // Show completion modal with merged results
          showCompletionModal(mergedSchemaAudit);
        } else {
          // No saved audit found, just show retry results
          updateProgress(80, 'Retry completed!');
          showCompletionModal(retrySchemaAudit);
          updateProgress(100, 'Retry completed!');
          showStatus(`Retry completed: ${retrySuccessful} URLs now have schema, ${retryStillFailed} still failed`, 'success');
          debugLog('‚ö† No saved audit found to merge with. Run full audit to see complete results.', 'warn');
        }
        
      } catch (error) {
        debugLog(`‚úó Retry error: ${error.message}`, 'error');
        showStatus(`Error retrying failed URLs: ${error.message}`, 'error');
      } finally {
        document.getElementById('loading').classList.remove('show');
        setTimeout(() => {
          updateProgress(0, 'Initializing audit scan...');
        }, 500);
      }
    }

    // Save audit results to localStorage
    function saveAuditResults(scores, searchData, snippetReadiness, schemaAudit, localSignals = null) {
      try {
        const dateRange = parseInt(document.getElementById('dateRange')?.value) || 30;
        const auditData = {
          scores,
          searchData,
          snippetReadiness,
          schemaAudit,
          localSignals, // Store local signals data for future use
          dateRange, // Store the date range used for this audit
          timestamp: new Date().toISOString()
        };
        localStorage.setItem('last_audit_results', JSON.stringify(auditData));
        debugLog('‚úì Audit results saved to localStorage', 'success');
        
        // Update timestamp display
        updateAuditTimestamp(auditData.timestamp);
      } catch (error) {
        debugLog(`‚úó Error saving audit results: ${error.message}`, 'error');
      }
    }
    
    // Update audit results for new date range without full rescan
    async function updateAuditForNewDateRange(newDateRange, savedAudit) {
      try {
        showStatus(`Updating metrics for ${newDateRange} day period...`, 'info');
        
        const propertyUrl = document.getElementById('propertyUrl')?.value || savedAudit.propertyUrl || '';
        if (!propertyUrl) {
          clearDashboard();
          showStatus(`Date range changed to ${newDateRange} days. Please run a new audit to see updated metrics.`, 'info');
          return;
        }
        
        // Get API key (needed for fetchSearchConsoleData signature, but not actually used)
        let apiKey = window._loadedApiKey || '';
        
        // Fetch new GSC data for the new date range (will use Supabase cache)
        debugLog(`Fetching GSC data for ${newDateRange} day period...`, 'info');
        const searchData = await fetchSearchConsoleData(apiKey, propertyUrl, newDateRange);
        
        // Fetch local signals (Business Profile data doesn't change with date range, but fetch to ensure it's fresh)
        let localSignals = savedAudit.localSignals || null;
        try {
          const localSignalsResponse = await fetch(`/api/aigeo/local-signals?property=${encodeURIComponent(propertyUrl)}`);
          if (localSignalsResponse.ok) {
            localSignals = await localSignalsResponse.json();
            if (localSignals.status === 'ok') {
              debugLog('‚úì Local signals data fetched successfully', 'success');
            }
          }
        } catch (localSignalsError) {
          debugLog(`‚ö† Local signals error: ${localSignalsError.message}, using cached data if available`, 'warn');
        }
        
        // Recalculate pillar scores based on new GSC data
        // Keep existing schema audit data (doesn't change with date range)
        const scores = calculatePillarScores(searchData, savedAudit.schemaAudit, localSignals);
        const snippetReadiness = calculateSnippetReadiness(scores, searchData);
        
        debugLog(`Recalculated scores for ${newDateRange} days: ${JSON.stringify(scores)}`, 'info');
        
        // Update saved audit with new data
        const updatedAudit = {
          ...savedAudit,
          dateRange: newDateRange,
          searchData: searchData,
          scores: scores,
          snippetReadiness: snippetReadiness,
          localSignals: localSignals, // Store local signals for future use
          timestamp: new Date().toISOString()
        };
        
        // Save updated audit
        saveAuditResults(scores, searchData, snippetReadiness, savedAudit.schemaAudit, localSignals);
        localStorage.setItem('last_audit_results', JSON.stringify(updatedAudit));
        
        // Also save to Supabase for historical tracking
        if (propertyUrl) {
          saveAuditToSupabase(propertyUrl, scores, searchData, snippetReadiness, savedAudit.schemaAudit, localSignals);
        }
        
        // Update dashboard with new data - ensure scores object has all required properties
        debugLog(`Updating dashboard with scores: ${JSON.stringify(scores)}`, 'info');
        displayDashboard(scores, searchData, snippetReadiness, savedAudit.schemaAudit);
        
        showStatus(`Metrics updated for ${newDateRange} day period.`, 'success');
        debugLog(`‚úì Audit updated for ${newDateRange} day period`, 'success');
        
      } catch (error) {
        debugLog(`‚úó Error updating audit for new date range: ${error.message}`, 'error');
        clearDashboard();
        showStatus(`Date range changed to ${newDateRange} days. Please run a new audit to see updated metrics.`, 'info');
      }
    }
    
    // Clear dashboard and show message that new audit is needed
    function clearDashboard() {
      const dashboard = document.getElementById('dashboard');
      if (dashboard) {
        dashboard.style.display = 'none';
      }
      // Clear any charts
      if (window.radarChart) {
        window.radarChart.destroy();
        window.radarChart = null;
      }
      if (window.trendChart) {
        window.trendChart.destroy();
        window.trendChart = null;
      }
      if (window.snippetReadinessChart) {
        window.snippetReadinessChart.destroy();
        window.snippetReadinessChart = null;
      }
    }
    
    // Load audit results from localStorage
    function loadAuditResults() {
      try {
        const saved = localStorage.getItem('last_audit_results');
        if (saved) {
          const auditData = JSON.parse(saved);
          debugLog('‚úì Audit results loaded from localStorage', 'success');
          return auditData;
        }
      } catch (error) {
        debugLog(`‚úó Error loading audit results: ${error.message}`, 'error');
      }
      return null;
    }
    
    // Update audit timestamp display
    function updateAuditTimestamp(timestamp) {
      const timestampElement = document.getElementById('lastAuditTime');
      const snippetTimestampElement = document.getElementById('snippetReadinessAuditTime');
      const snippetTimestampContainer = document.getElementById('snippetReadinessTimestamp');
      const radarTimestampElement = document.getElementById('radarChartAuditTime');
      const radarTimestampContainer = document.getElementById('radarChartTimestamp');
      
      if (timestamp) {
        const date = new Date(timestamp);
        const formatted = date.toLocaleString('en-GB', {
          day: '2-digit',
          month: 'short',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        if (timestampElement) {
          timestampElement.textContent = formatted;
        }
        
        // Update snippet readiness timestamp
        if (snippetTimestampElement) {
          snippetTimestampElement.textContent = formatted;
        }
        if (snippetTimestampContainer) {
          snippetTimestampContainer.style.display = 'block';
        }
        
        // Update radar chart timestamp
        if (radarTimestampElement) {
          radarTimestampElement.textContent = formatted;
        }
        if (radarTimestampContainer) {
          radarTimestampContainer.style.display = 'block';
        }
      } else {
        if (timestampElement) {
          timestampElement.textContent = 'Not yet run';
        }
        if (snippetTimestampContainer) {
          snippetTimestampContainer.style.display = 'none';
        }
        if (radarTimestampContainer) {
          radarTimestampContainer.style.display = 'none';
        }
      }
    }
    
    // Save audit results to Supabase for historical tracking
    async function saveAuditToSupabase(propertyUrl, scores, searchData, snippetReadiness, schemaAudit, localSignals = null) {
      try {
        const auditDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
        
        const response = await fetch('/api/supabase/save-audit', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            propertyUrl,
            auditDate,
            schemaAudit,
            scores,
            searchData,
            snippetReadiness,
            localSignals // Pass Business Profile data for storage
          })
        });
        
        if (response.ok) {
          const result = await response.json();
          debugLog('‚úì Audit results saved to Supabase', 'success');
        } else {
          const error = await response.json();
          // Don't show error to user - Supabase is optional for now
          debugLog(`‚ö† Could not save to Supabase: ${error.message || 'Unknown error'}`, 'warn');
        }
      } catch (error) {
        // Don't show error to user - Supabase is optional for now
        debugLog(`‚ö† Supabase save error: ${error.message}`, 'warn');
      }
    }
    
    // Fetch historical Content/Schema data from Supabase
    async function fetchContentSchemaHistory(propertyUrl, startDate, endDate) {
      try {
        const response = await fetch(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDate}&endDate=${endDate}`);
        
        if (response.ok) {
          const result = await response.json();
          if (result.status === 'ok' && result.data) {
            debugLog(`‚úì Fetched ${result.count} historical Content/Schema records from Supabase`, 'success');
            return result.data;
          }
        } else {
          const error = await response.json();
          debugLog(`‚ö† Could not fetch from Supabase: ${error.message || 'Unknown error'}`, 'warn');
        }
      } catch (error) {
        debugLog(`‚ö† Supabase fetch error: ${error.message}`, 'warn');
      }
      return [];
    }
    
    // Update retry button visibility based on failed URLs
    function updateRetryButtonVisibility(schemaAudit) {
      const retryBtn = document.getElementById('retryFailedUrlsBtn');
      if (!retryBtn) return;
      
      if (schemaAudit && schemaAudit.data && schemaAudit.data.missingSchemaPages) {
        const failedUrls = schemaAudit.data.missingSchemaPages.filter(p => p.error);
        if (failedUrls.length > 0) {
          retryBtn.style.display = 'inline-block';
          retryBtn.textContent = `üîÑ Retry Failed URLs (${failedUrls.length})`;
        } else {
          retryBtn.style.display = 'none';
        }
      } else {
        retryBtn.style.display = 'none';
      }
    }

    // Close completion modal
    function closeCompletionModal() {
      const modal = document.getElementById('completionModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    // Close modal when clicking outside
    window.onclick = function(event) {
      const modal = document.getElementById('completionModal');
      if (event.target === modal) {
        closeCompletionModal();
      }
    }

    // Calculate RAG status from score
    function getRAGStatus(score) {
      if (score >= 70) return { status: 'green', label: 'Green' };
      if (score >= 40) return { status: 'amber', label: 'Amber' };
      return { status: 'red', label: 'Red' };
    }

    // Helper: clamp score to 0-100 and round
    function clampScore(value) {
      return Math.max(0, Math.min(100, Math.round(value)));
    }

    // Calculate pillar scores (deterministic, based on GSC data and schema audit)
    function calculatePillarScores(data, schemaAudit = null, localSignals = null) {
      // Use new API response format - get values from GSC overview
      const position = data.averagePosition || 40; // 1 (best) - 100 (worst)
      const ctr = data.ctr || 0; // 0-100 percentage from API (e.g., 10 = 10%)

      // Map average position (1-40) -> 100-10 (better position => higher score)
      const posScore = (() => {
        const clampedPos = Math.max(1, Math.min(40, position));
        const scale = (clampedPos - 1) / 39; // 0 to 1
        return 100 - scale * 90; // 100 to 10
      })();

      // Visibility is primarily driven by position
      const visibility = clampScore(posScore);

      // Authority: use exact formula with GSC values
      // Convert ctr from percentage (0-100) to decimal (0-1), then apply formula
      const ctrDecimal = ctr / 100; // Convert percentage to decimal (e.g., 10% -> 0.10)
      const ctrScore = Math.min((ctrDecimal / 0.10) * 100, 100);
      const authority = clampScore(0.6 * ctrScore + 0.4 * posScore);

      // Local Entity: Use real Business Profile data if available, otherwise fallback to derived calculation
      let localEntity;
      if (localSignals && localSignals.status === 'ok' && localSignals.data) {
        const localData = localSignals.data;
        // Base score from NAP consistency (0-100)
        let baseScore = localData.napConsistencyScore || 0;
        
        // Bonus for knowledge panel detection (+10 points)
        if (localData.knowledgePanelDetected) {
          baseScore = Math.min(100, baseScore + 10);
        }
        
        // Bonus for having at least one location (+5 points)
        if (localData.locations && localData.locations.length > 0) {
          baseScore = Math.min(100, baseScore + 5);
        }
        
        localEntity = clampScore(baseScore);
        debugLog(`Local Entity: NAP=${localData.napConsistencyScore || 0}, Knowledge Panel=${localData.knowledgePanelDetected}, Locations=${localData.locations?.length || 0}, Final=${localEntity}`, 'info');
      } else {
        // Fallback: derived calculation (old method)
        localEntity = clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
        debugLog('Local Entity: Using fallback calculation (no Business Profile data)', 'warn');
      }

      // Service Area: Use real Business Profile service areas count if available, otherwise fallback
      let serviceArea;
      if (localSignals && localSignals.status === 'ok' && localSignals.data) {
        const localData = localSignals.data;
        const serviceAreasCount = localData.serviceAreas?.length || 0;
        
        // Normalize service areas count to 0-100 score
        // 0 areas = 0, 8+ areas = 100 (more reasonable threshold)
        // Linear scale: 1 area = 12.5 points (8 areas = 100)
        if (serviceAreasCount === 0) {
          serviceArea = 0;
        } else if (serviceAreasCount >= 8) {
          serviceArea = 100;
        } else {
          // Linear scale: 1 area = 12.5 points, 2 = 25, ..., 8 = 100
          serviceArea = Math.min(100, serviceAreasCount * 12.5);
        }
        
        // Apply NAP consistency as a multiplier (if NAP is low, reduce service area score)
        if (localData.napConsistencyScore !== null && localData.napConsistencyScore < 100) {
          const napMultiplier = localData.napConsistencyScore / 100;
          serviceArea = Math.round(serviceArea * napMultiplier);
        }
        
        serviceArea = clampScore(serviceArea);
        debugLog(`Service Area: Count=${serviceAreasCount}, NAP Multiplier=${localData.napConsistencyScore !== null ? (localData.napConsistencyScore / 100).toFixed(2) : 'N/A'}, Final=${serviceArea}`, 'info');
      } else {
        // Fallback: derived from Local Entity (old method)
        serviceArea = clampScore(localEntity - 5);
        debugLog('Service Area: Using fallback calculation (no Business Profile data)', 'warn');
      }

      // Content/Schema: weighted calculation based on foundation schemas, rich results, coverage, and diversity
      let contentSchema;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        const allTypes = new Set();
        
        // Use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
        if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
          // Use all detected types for accurate calculation
          schemaData.allDetectedTypes.forEach(type => {
            if (type) allTypes.add(type);
          });
        } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          // Fallback: collect from schemaTypes array (contains all types, sorted by count)
          schemaData.schemaTypes.forEach(item => {
            if (item.type) allTypes.add(item.type);
          });
        }
        
        // 1. Foundation Schemas Score (30% weight): Organization, Person, WebSite, BreadcrumbList
        const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
        const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
        const foundationScore = (foundationPresent / foundationTypes.length) * 100;
        
        // 2. Rich Result Eligibility Score (35% weight): Count eligible rich result types
        // Note: This list must match RICH_RESULT_TYPES in api/schema-audit.js
        const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList', 'Recipe'];
        const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
        const richResultScore = (richEligibleCount / richResultTypes.length) * 100;
        
        // 3. Coverage Score (20% weight): Pages with schema / total pages
        const coverageScore = schemaData.coverage || 0;
        
        // 4. Type Diversity Score (15% weight): Number of unique schema types (normalized to 15 types)
        const uniqueTypesCount = allTypes.size;
        const diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
        
        // Weighted calculation: 30% foundation + 35% rich results + 20% coverage + 15% diversity
        contentSchema = clampScore(
          foundationScore * 0.30 +
          richResultScore * 0.35 +
          coverageScore * 0.20 +
          diversityScore * 0.15
        );
        
        debugLog(`Content/Schema calculation: Foundation=${foundationScore.toFixed(1)}% (${foundationPresent}/4), Rich Results=${richResultScore.toFixed(1)}% (${richEligibleCount}/${richResultTypes.length}), Coverage=${coverageScore.toFixed(1)}%, Diversity=${diversityScore.toFixed(1)}% (${uniqueTypesCount} types)`, 'info');
      } else {
        // Fallback: if no schema audit data, return 0 (can't calculate without data)
        contentSchema = 0;
        debugLog('‚ö† No schema audit data available, Content/Schema score set to 0', 'warn');
      }

      const scores = {
        localEntity,
        serviceArea,
        authority,
        visibility,
        contentSchema
      };

      debugLog(`Deterministic pillar scores: ${JSON.stringify(scores)}`, 'info');
      return scores;
    }

    function calculateSnippetReadiness(scores, data) {
      // Snippet readiness combines:
      // 1. Content/Schema score (structured data quality)
      // 2. Visibility score (SERP feature presence)
      // 3. Authority score (content depth and trust)
      // Weighted average: 40% Content/Schema, 35% Visibility, 25% Authority
      const readiness = (
        scores.contentSchema * 0.4 +
        scores.visibility * 0.35 +
        scores.authority * 0.25
      );
      return Math.round(Math.min(100, Math.max(0, readiness)));
    }

    // Fetch real data from Google Search Console API using unified endpoint
    // Note: apiKey parameter kept for compatibility but not used (endpoint uses OAuth2)
    async function fetchSearchConsoleData(apiKey, propertyUrl, days) {
      debugLog(`Fetching real GSC data for ${days} days...`, 'info');
      
      // Calculate date range
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);
      
      // Format dates as YYYY-MM-DD
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      const startDateStr = formatDate(startDate);
      const endDateStr = formatDate(endDate);
      
      debugLog(`Date range: ${startDateStr} to ${endDateStr}`, 'info');
      
      try {
        // Call unified GSC entity metrics endpoint
        const response = await fetch(`/api/aigeo/gsc-entity-metrics?property=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDateStr}`);

        if (!response.ok) {
          const errorData = await response.json();
          debugLog(`‚úó GSC API error: ${errorData.message || errorData.error}`, 'error');
          if (errorData.details) {
            debugLog(`Details: ${errorData.details}`, 'error');
          }
          
          // If OAuth not configured, show helpful message
          if (errorData.message && errorData.message.includes('OAuth2 credentials not configured')) {
            throw new Error('Google Search Console OAuth2 credentials not configured. Please set GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, and GOOGLE_REFRESH_TOKEN in Vercel environment variables.');
          }
          
          throw new Error(errorData.message || errorData.error || 'Failed to fetch Search Console data');
        }

        const gsc = await response.json();
        
        if (gsc.status !== 'ok') {
          throw new Error(gsc.message || 'Failed to fetch Search Console data');
        }
        
        debugLog(`‚úì Real GSC data fetched: ${gsc.data.overview.totalClicks} clicks, ${gsc.data.overview.totalImpressions} impressions`, 'success');
        
        // Return data in format expected by existing code
        return {
          totalClicks: gsc.data.overview.totalClicks || 0,
          totalImpressions: gsc.data.overview.totalImpressions || 0,
          averagePosition: gsc.data.overview.avgPosition || 0,
          ctr: gsc.data.overview.ctr || 0, // Already 0-100 from API
          topQueries: gsc.data.topQueries || [],
          timeseries: gsc.data.timeseries || [], // For trend chart
          dateRange: days,
          // Store full GSC response for trend chart access
          _gscResponse: gsc
        };
      } catch (error) {
        debugLog(`‚úó Error fetching GSC data: ${error.message}`, 'error');
        throw error;
      }
    }

    // Run the audit
    async function runAudit() {
      debugLog('=== AUDIT START: Beginning audit scan ===', 'info');
      
      // Get API key - prioritize Vercel env var, then loaded key, then localStorage
      let apiKey = window._loadedApiKey;
      
      // Try Vercel environment variable first
      if (!apiKey) {
        try {
          debugLog('Fetching API key from Vercel environment variable...', 'info');
          const response = await fetch('/api/get-api-key');
          if (response.ok) {
            const data = await response.json();
            if (data.apiKey) {
              apiKey = data.apiKey;
              debugLog('‚úì Using API key from Vercel environment variable', 'success');
              window._loadedApiKey = apiKey;
            }
          }
        } catch (e) {
          debugLog('Vercel env var endpoint not available', 'info');
        }
      }
      
      // Fall back to config.js
      if (!apiKey && window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey) {
        apiKey = window.API_CONFIG.googleSearchConsoleApiKey;
        debugLog('‚úì Using API key from config.js', 'success');
        window._loadedApiKey = apiKey;
      }
      
      // Fall back to localStorage
      if (!apiKey) {
        apiKey = localStorage.getItem('gsc_api_key');
        if (apiKey) {
          debugLog('‚úì Using API key from localStorage', 'success');
          window._loadedApiKey = apiKey;
        }
      }
      
      const propertyUrl = document.getElementById('propertyUrl').value;
      const dateRange = parseInt(document.getElementById('dateRange').value);
      
      debugLog(`Property URL: ${propertyUrl}`, 'info');
      debugLog(`Date Range: ${dateRange} days`, 'info');

      // Note: API key no longer required - new endpoint uses OAuth2 from env vars
      if (!propertyUrl) {
        debugLog('‚úó No property URL provided', 'error');
        showStatus('Please enter your property URL', 'error');
        return;
      }

      debugLog('Showing loading indicator...', 'info');
      document.getElementById('loading').classList.add('show');
      document.getElementById('dashboard').style.display = 'none';
      updateProgress(0, 'Initializing audit scan...');

      // Declare schemaAudit outside try block so it's accessible in finally
      let schemaAudit = null;

      try {
        updateProgress(10, 'Fetching Search Console data...');
        debugLog('Fetching Search Console data...', 'info');
        // Fetch data
        const searchData = await fetchSearchConsoleData(apiKey, propertyUrl, dateRange);
        debugLog('‚úì Search Console data fetched successfully', 'success');
        debugLog(`Data: ${JSON.stringify(searchData).substring(0, 200)}...`, 'info');
        
        updateProgress(35, 'Fetching local signals data...');
        debugLog('Fetching local signals data...', 'info');
        // Fetch local signals (Business Profile) data
        let localSignals = null;
        try {
          const localSignalsResponse = await fetch(`/api/aigeo/local-signals?property=${encodeURIComponent(propertyUrl)}`);
          if (localSignalsResponse.ok) {
            localSignals = await localSignalsResponse.json();
            if (localSignals.status === 'ok') {
              debugLog('‚úì Local signals data fetched successfully', 'success');
              debugLog(`Service areas: ${localSignals.data.serviceAreas?.length || 0}, NAP score: ${localSignals.data.napConsistencyScore || 'N/A'}`, 'info');
            } else {
              debugLog('‚ö† Local signals returned error, using fallback', 'warn');
            }
          } else {
            debugLog('‚ö† Local signals endpoint not available, using fallback', 'warn');
          }
        } catch (localSignalsError) {
          debugLog(`‚ö† Local signals error: ${localSignalsError.message}, using fallback`, 'warn');
        }
        
        updateProgress(40, 'Fetching schema audit data...');
        debugLog('Fetching schema audit data...', 'info');
        // Fetch schema audit data
        try {
          // Check if manual URL list is available
          const manualUrlList = localStorage.getItem('manual_url_list');
          let schemaRequest;
          
          if (manualUrlList) {
            try {
              const urls = JSON.parse(manualUrlList);
              debugLog(`Using manual URL list: ${urls.length} URLs`, 'info');
              updateProgress(45, `Crawling ${urls.length} URLs for schema markup...`);
              schemaRequest = fetch('/api/schema-audit', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ urls })
              });
            } catch (e) {
              debugLog('‚ö† Failed to parse manual URL list, using default CSV', 'warn');
              updateProgress(45, 'Loading URLs from CSV and crawling for schema markup...');
              schemaRequest = fetch('/api/schema-audit');
            }
          } else {
            debugLog('No manual URL list, using default CSV source', 'info');
            updateProgress(45, 'Loading URLs from CSV and crawling for schema markup...');
            schemaRequest = fetch('/api/schema-audit');
          }
          
          const schemaResponse = await schemaRequest;
          if (schemaResponse.ok) {
            schemaAudit = await schemaResponse.json();
            if (schemaAudit.status === 'ok') {
              debugLog('‚úì Schema audit data fetched successfully', 'success');
              debugLog(`Schema coverage: ${schemaAudit.data.coverage}%`, 'info');
              if (manualUrlList) {
                debugLog('  Source: Manual URL list', 'info');
              } else {
                debugLog('  Source: CSV (GitHub/hosted)', 'info');
              }
              
              // Log comprehensive diagnostic info if available
              if (schemaAudit.meta && schemaAudit.meta.diagnostic) {
                const diag = schemaAudit.meta.diagnostic;
                debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                debugLog('üìä SCHEMA AUDIT DIAGNOSTICS', 'info');
                debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                debugLog('üìà PAGE COUNTS:', 'info');
                debugLog(`  ‚Ä¢ Total pages scanned: ${diag.totalPages}`, 'info');
                debugLog(`  ‚Ä¢ Successful crawls: ${diag.successfulPages || diag.totalPages}`, 'info');
                debugLog(`  ‚Ä¢ Failed crawls: ${diag.failedPages || 0}`, diag.failedPages > 0 ? 'warn' : 'info');
                if (diag.failedPages > 0) {
                  debugLog(`    ‚ö† Failed crawls are counted as pages without schema`, 'warn');
                  
                  // Show error breakdown if available
                  if (diag.errorTypes && Object.keys(diag.errorTypes).length > 0) {
                    debugLog('', 'info'); // Empty line
                    debugLog('  üîç ERROR BREAKDOWN:', 'warn');
                    Object.entries(diag.errorTypes).forEach(([type, count]) => {
                      debugLog(`    ‚Ä¢ ${type}: ${count} pages`, 'warn');
                      if (diag.errorExamples && diag.errorExamples[type]) {
                        const example = diag.errorExamples[type];
                        debugLog(`      Example: ${example.url}`, 'info');
                        debugLog(`      Error: ${example.error}`, 'info');
                      }
                    });
                  }
                }
                debugLog(`  ‚Ä¢ Pages with inline schema: ${diag.pagesWithInlineSchema}`, 'info');
                debugLog(`  ‚Ä¢ Pages without inline schema: ${diag.pagesWithoutInlineSchema}`, 'info');
                if (diag.failedPages > 0) {
                  debugLog(`    (includes ${diag.failedPages} failed crawls)`, 'info');
                }
                debugLog(`  ‚Ä¢ Pages with inherited schema: ${diag.pagesWithInheritedSchema}`, 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                if (diag.urlsWithoutSchemas && diag.urlsWithoutSchemas.length > 0) {
                  debugLog('üîó URLs WITHOUT SCHEMAS:', 'info');
                  diag.urlsWithoutSchemas.forEach(url => {
                    debugLog(`  ‚Ä¢ ${url}`, 'info');
                  });
                  if (diag.pagesWithoutInlineSchema > diag.urlsWithoutSchemas.length) {
                    debugLog(`  ... and ${diag.pagesWithoutInlineSchema - diag.urlsWithoutSchemas.length} more`, 'info');
                  }
                  debugLog('', 'info'); // Empty line for spacing
                }
                
                debugLog('üîç MISSING SCHEMA BREAKDOWN:', 'info');
                debugLog(`  ‚Ä¢ Pages with parent but no inherited: ${diag.pagesWithParentButNoInherited}`, 'info');
                debugLog(`  ‚Ä¢ Pages with parent but not checked: ${diag.pagesWithParentButNotChecked}`, diag.pagesWithParentButNotChecked > 0 ? 'warn' : 'info');
                debugLog(`  ‚Ä¢ Pages without parent page: ${diag.pagesWithoutParent}`, 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                debugLog('‚úÖ VALIDATION:', 'info');
                debugLog(`  ‚Ä¢ Total missing pages (calculated): ${diag.totalMissing}`, 'info');
                debugLog(`  ‚Ä¢ Expected missing (total - inline - inherited): ${diag.expectedMissing}`, 'info');
                
                if (diag.mismatch) {
                  debugLog('', 'info'); // Empty line for spacing
                  debugLog(`  ‚ùå MISMATCH DETECTED!`, 'error');
                  debugLog(`  ${diag.mismatchDetails}`, 'error');
                  debugLog(`  This indicates pages are being double-counted or missed in the calculation.`, 'error');
                } else {
                  debugLog(`  ‚úì Counts match correctly`, 'success');
                }
                
                debugLog('', 'info'); // Empty line for spacing
                debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
              }
            } else {
              debugLog('‚ö† Schema audit returned error, using fallback', 'warn');
            }
          } else {
            debugLog('‚ö† Schema audit endpoint not available, using fallback', 'warn');
          }
        } catch (schemaError) {
          debugLog(`‚ö† Schema audit error: ${schemaError.message}, using fallback`, 'warn');
        }
        
        updateProgress(70, 'Calculating pillar scores...');
        debugLog('Calculating pillar scores...', 'info');
        // Calculate scores (pass schema audit data and local signals)
        const scores = calculatePillarScores(searchData, schemaAudit, localSignals);
        debugLog('‚úì Pillar scores calculated', 'success');
        debugLog(`Scores: ${JSON.stringify(scores)}`, 'info');

        updateProgress(85, 'Calculating snippet readiness...');
        debugLog('Calculating snippet readiness...', 'info');
        const snippetReadiness = calculateSnippetReadiness(scores, searchData);
        debugLog(`Snippet readiness: ${snippetReadiness}`, 'info');

        updateProgress(95, 'Generating dashboard...');
        debugLog('Displaying dashboard...', 'info');
        // Display results (pass schema audit data)
        displayDashboard(scores, searchData, snippetReadiness, schemaAudit);
        
        updateProgress(100, 'Audit completed successfully!');
        debugLog('=== AUDIT COMPLETE: Success ===', 'success');
        
        // Save audit results to localStorage
        saveAuditResults(scores, searchData, snippetReadiness, schemaAudit, localSignals);
        
        // Save audit results to Supabase for historical tracking
        saveAuditToSupabase(propertyUrl, scores, searchData, snippetReadiness, schemaAudit, localSignals);
        
        showStatus('Audit completed successfully!', 'success');
      } catch (error) {
        debugLog(`‚úó AUDIT ERROR: ${error.message}`, 'error');
        debugLog(`Stack trace: ${error.stack}`, 'error');
        showStatus('Error running audit: ' + error.message, 'error');
        console.error(error);
      } finally {
        debugLog('Hiding loading indicator...', 'info');
        document.getElementById('loading').classList.remove('show');
        
        // Show completion summary modal
        debugLog(`Schema audit available for modal: ${schemaAudit ? 'yes' : 'no'}`, 'info');
        if (schemaAudit) {
          debugLog('Showing completion modal...', 'info');
          setTimeout(() => {
            showCompletionModal(schemaAudit);
          }, 500);
        } else {
          debugLog('‚ö† No schema audit data available for modal', 'warn');
        }
        
        // Reset progress bar for next run
        setTimeout(() => {
          updateProgress(0, 'Initializing audit scan...');
        }, 500);
      }
    }

    // Display dashboard
    async function displayDashboard(scores, data, snippetReadiness = 0, schemaAudit = null) {
      // Update timestamp if this is a fresh display
      const saved = loadAuditResults();
      if (saved && saved.timestamp) {
        updateAuditTimestamp(saved.timestamp);
      }
      
      // Update retry button visibility
      updateRetryButtonVisibility(schemaAudit);
      
      debugLog('=== DISPLAY DASHBOARD: Starting ===', 'info');
      
      // Show dashboard first (canvas elements need to be visible for Chart.js)
      const dashboardDiv = document.getElementById('dashboard');
      if (!dashboardDiv) {
        debugLog('‚úó Dashboard div not found', 'error');
        console.error('Dashboard div not found');
        return;
      }
      debugLog('‚úì Dashboard div found', 'success');
      dashboardDiv.style.display = 'block';
      debugLog('Dashboard div displayed', 'info');
      
      // Update trend chart description with date range
      const dateRange = parseInt(document.getElementById('dateRange').value) || 30;
      const trendDesc = document.getElementById('trendChartDescription');
      if (trendDesc) {
        let rangeText = '';
        if (dateRange === 30) rangeText = 'Last 30 Days';
        else if (dateRange === 60) rangeText = 'Last 60 Days';
        else if (dateRange === 90) rangeText = 'Last 90 Days';
        else if (dateRange === 120) rangeText = 'Last 120 Days';
        else if (dateRange === 180) rangeText = 'Last 6 Months';
        else if (dateRange === 365) rangeText = 'Last 12 Months';
        else if (dateRange === 540) rangeText = 'Last 18 Months';
        else rangeText = `Last ${dateRange} Days`;
        trendDesc.textContent = `Historical performance tracking for Local Entity, Visibility, and Authority pillars over ${rangeText.toLowerCase()}.`;
      }
      
      const pillarNames = {
        localEntity: 'Local Entity',
        serviceArea: 'Service Area',
        authority: 'Authority',
        visibility: 'Visibility',
        contentSchema: 'Content / Schema'
      };
      
      // Define pillar weightings and order by weight (highest to lowest)
      const pillarWeights = {
        authority: 0.30,        // 30% - E-A-T is crucial for AI trust
        contentSchema: 0.25,     // 25% - Structured data is key for AI understanding
        visibility: 0.20,        // 20% - How AI surfaces your content
        localEntity: 0.15,       // 15% - Entity recognition important but not critical
        serviceArea: 0.10         // 10% - Less critical for AI search
      };
      
      // Sort pillars by weight (highest to lowest) for consistent ordering
      const getOrderedPillars = (scoresObj) => {
        return Object.entries(scoresObj).sort((a, b) => {
          return (pillarWeights[b[0]] || 0) - (pillarWeights[a[0]] || 0);
        });
      };

      // Create pillar cards (ordered by weight)
      const pillarCards = document.getElementById('pillarCards');
      pillarCards.innerHTML = '';

      // Check if we have real Business Profile data
      const hasLocalSignals = saved && saved.localSignals && saved.localSignals.status === 'ok' && saved.localSignals.data;
      const localSignalsData = hasLocalSignals ? saved.localSignals.data : null;
      
      getOrderedPillars(scores).forEach(([key, score]) => {
        const rag = getRAGStatus(score);
        const card = document.createElement('div');
        card.className = 'pillar-card';
        
        // Get pillar description with data source info (dynamic based on whether we have real data)
        let localEntityDesc, serviceAreaDesc;
        if (hasLocalSignals && localSignalsData) {
          const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
          const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
          const locationsCount = localSignalsData.locations?.length || 0;
          localEntityDesc = `How clearly your business and you as a person are recognised as entities by AI search systems. <strong>Data Source:</strong> ‚úÖ Live data from Google Business Profile API. <strong>Data Checked:</strong> NAP consistency (${napScore}%), knowledge panel (${localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected'}), locations (${locationsCount}).`;
          serviceAreaDesc = `How well AI understands where you operate and which regions you serve. <strong>Data Source:</strong> ‚úÖ Live data from Google Business Profile API. <strong>Data Checked:</strong> Service areas (${serviceAreasCount}), NAP consistency (${napScore}%).`;
        } else {
          localEntityDesc = 'How clearly your business and you as a person are recognised as entities by AI search systems. <strong>Data Source:</strong> ‚ö†Ô∏è Currently derived from search performance (GSC position/CTR). Real local signals API integration pending.';
          serviceAreaDesc = 'How well AI understands where you operate and which regions you serve. <strong>Data Source:</strong> ‚ö†Ô∏è Currently derived from Local Entity score. Real service area data from Google Business Profile pending.';
        }
        
        const descriptions = {
          localEntity: localEntityDesc,
          serviceArea: serviceAreaDesc,
          authority: 'E-A-T (Experience, Expertise, Authoritativeness, Trustworthiness): Perceived expertise and trust in the topic space. <strong>Data Source:</strong> ‚úÖ Live data from Google Search Console (CTR + position). Backlink metrics pending.',
          visibility: 'How prominently your content appears in AI-powered search results and featured snippets. <strong>Data Source:</strong> ‚úÖ Live data from Google Search Console (impressions, clicks, position, SERP features).',
          contentSchema: 'Quality and completeness of structured data markup across your domain. <strong>Data Source:</strong> ‚úÖ Live data from schema audit. <strong>Calculation:</strong> Foundation schemas (30%) + Rich Results (35%) + Coverage (20%) + Diversity (15%).'
        };
        
        card.innerHTML = `
          <h3>${pillarNames[key]}</h3>
          <div class="pillar-score rag-${rag.status}">${Math.round(score)}</div>
          <div class="rag-badge ${rag.status}">${rag.label}</div>
          <p style="font-size: 0.85rem; color: #666; margin-top: 0.5rem; line-height: 1.5; flex-grow: 1;">${descriptions[key] || ''}</p>
        `;
        pillarCards.appendChild(card);
      });
      
      // Remove existing scorecard table if it exists
      const existingScorecard = pillarCards.parentNode.querySelector('.scorecard-section');
      if (existingScorecard) {
        existingScorecard.remove();
      }
      
      // Add pillar scorecard table
      // Determine last data date for each pillar
      const savedAudit = loadAuditResults();
      const auditTimestamp = savedAudit?.timestamp;
      
      // Get last GSC data date from timeseries (for Authority and Visibility)
      let gscLastDate = null;
      if (data && data.timeseries && Array.isArray(data.timeseries) && data.timeseries.length > 0) {
        const lastTimeseriesPoint = data.timeseries[data.timeseries.length - 1];
        if (lastTimeseriesPoint && lastTimeseriesPoint.date) {
          gscLastDate = lastTimeseriesPoint.date;
        }
      }
      
      // Format date for display
      function formatDataDate(dateStr) {
        if (!dateStr) return '';
        const date = new Date(dateStr + 'T00:00:00'); // Add time to avoid timezone issues
        return date.toLocaleDateString('en-GB', {
          day: '2-digit',
          month: 'short',
          year: 'numeric'
        });
      }
      
      // Format timestamp for display
      function formatTimestamp(timestamp) {
        if (!timestamp) return '';
        const date = new Date(timestamp);
        return date.toLocaleString('en-GB', {
          day: '2-digit',
          month: 'short',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
      }
      
      // Get data date for each pillar
      function getPillarDataDate(pillarKey) {
        if (pillarKey === 'authority' || pillarKey === 'visibility') {
          // GSC-based pillars - use last GSC data date
          return gscLastDate ? formatDataDate(gscLastDate) : (auditTimestamp ? formatTimestamp(auditTimestamp) : '');
        } else {
          // Business Profile and schema audit - use audit timestamp
          return auditTimestamp ? formatTimestamp(auditTimestamp) : '';
        }
      }
      
      const scorecardTable = document.createElement('div');
      scorecardTable.className = 'scorecard-section';
      scorecardTable.innerHTML = `
        <h3 style="margin: 0 0 1rem 0; color: var(--brand-orange);">Pillar Scorecard</h3>
        <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow-x: auto;">
          <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
            <thead>
              <tr style="background: #f5f5f5;">
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 10%;">Pillar</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 6%;">Score</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 6%;">Weight</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 8%;">Status</th>
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 42%;">Description</th>
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 22%;">Improvement Suggestions</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 6%;">Data Date</th>
              </tr>
            </thead>
            <tbody>
              ${getOrderedPillars(scores).map(([key, score], index) => {
                const rag = getRAGStatus(score);
                
                // Build Content/Schema description with schema audit data
                let contentSchemaDesc = 'Quality and completeness of structured data markup across your domain.<br><strong>AI Importance:</strong> Structured data is the primary way AI understands your content. Schema markup directly feeds AI systems, enabling them to extract facts, relationships, and context for use in AI Overviews and answer generation.<br><strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from schema audit (crawls actual website pages for JSON-LD markup).<br><strong>Calculation:</strong> Weighted score based on Foundation schemas (30%), Rich Result eligibility (35%), Coverage (20%), and Type Diversity (15%).';
                
                if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
                  const schemaData = schemaAudit.data;
                  const { coverage, totalPages, pagesWithSchema, missingSchemaCount, missingSchemaPages, schemaTypes } = schemaData;
                  
                  // Calculate foundation schemas - use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
                  const allTypes = new Set();
                  if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
                    // Use all detected types for accurate calculation
                    schemaData.allDetectedTypes.forEach(type => {
                      if (type) allTypes.add(type);
                    });
                  } else if (schemaTypes && Array.isArray(schemaTypes)) {
                    // Fallback: collect from schemaTypes array (contains all types, sorted by count)
                    schemaTypes.forEach(item => {
                      if (item.type) allTypes.add(item.type);
                    });
                  }
                  const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
                  const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
                  
                  // Count rich result types
                  const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
                  const uniqueTypesCount = allTypes.size;
                  
                  const richResultTypesList = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList', 'Recipe'];
                  contentSchemaDesc += ` <strong>Data Checked:</strong> Foundation schemas: ${foundationPresent}/4 (${foundationTypes.filter(t => allTypes.has(t)).join(', ') || 'none'}), Rich result types: ${richEligibleCount}/${richResultTypesList.length} eligible, Coverage: ${coverage}% (${pagesWithSchema}/${totalPages} pages), Type diversity: ${uniqueTypesCount} unique types. `;
                  
                  if (schemaTypes && schemaTypes.length > 0) {
                    // Show top 15 most common types for readability (still sorted by count)
                    const topTypes = schemaTypes.slice(0, 15).map(t => `${t.type} (${t.count})`).join(', ');
                    contentSchemaDesc += `Schema types found: ${topTypes}${schemaTypes.length > 15 ? '...' : ''}. `;
                  }
                  
                  if (schemaData.missingTypes && schemaData.missingTypes.length > 0) {
                    contentSchemaDesc += `Missing foundation types: ${schemaData.missingTypes.join(', ')}. `;
                  }
                  
                  const richTypes = Object.entries(schemaData.richEligible || {})
                    .filter(([type, eligible]) => eligible)
                    .map(([type]) => type);
                  if (richTypes.length > 0) {
                    contentSchemaDesc += `Rich result eligible: ${richTypes.join(', ')}. `;
                  }
                  
                  // Check if Review schema is detected (even if not in top 10 types)
                  const hasReviewSchema = allTypes.has('Review');
                  if (hasReviewSchema) {
                    // Try to get count from schemaTypes array first, otherwise check schemaData for actual count
                    let reviewCount = schemaTypes?.find(t => t.type === 'Review')?.count || 0;
                    // If not in top 10, check if we have schemaData with all types info
                    if (reviewCount === 0 && schemaData.schemaTypes) {
                      // schemaTypes in response is top 10, but we need to check if Review exists
                      // Since it's in allTypes, it exists, but we don't have the exact count
                      // Just indicate it's detected without showing 0
                      contentSchemaDesc += `Review schema detected - matches GSC review snippets data. `;
                    } else if (reviewCount > 0) {
                      contentSchemaDesc += `Review schema detected (${reviewCount} instances) - matches GSC review snippets data. `;
                    } else {
                      contentSchemaDesc += `Review schema detected - matches GSC review snippets data. `;
                    }
                  }
                } else {
                  contentSchemaDesc += ' <strong>Data Checked:</strong> Foundation schemas (Organization, Person, WebSite, BreadcrumbList), Rich result eligibility (Article, Event, Course, FAQ, HowTo, VideoObject, Recipe, Product, LocalBusiness, Review), schema coverage percentage, schema type diversity.';
                }
                
                // Build Local Entity and Service Area descriptions based on whether we have real Business Profile data
                let localEntityDesc, serviceAreaDesc;
                if (hasLocalSignals && localSignalsData) {
                  const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                  const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
                  const locationsCount = localSignalsData.locations?.length || 0;
                  const knowledgePanel = localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected';
                  localEntityDesc = `Consistency and clarity of brand, person and business entity signals.<br><strong>AI Importance:</strong> AI systems rely on clear entity signals to understand who you are and connect your brand across platforms. Strong entity recognition helps AI include you in knowledge panels and entity-based results.<br><strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from Google Business Profile API.<br><strong>Data Checked:</strong> NAP consistency (${napScore}%), knowledge panel (${knowledgePanel}), locations (${locationsCount}), LocalBusiness schema presence, Google Business Profile data.`;
                  serviceAreaDesc = `How clearly AI understands where lessons/workshops run and which regions you cover.<br><strong>AI Importance:</strong> AI uses geographic signals to match queries with local intent. Clear service area data helps AI surface your content for location-specific searches and local AI Overviews.<br><strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from Google Business Profile API.<br><strong>Data Checked:</strong> Service areas (${serviceAreasCount}), NAP consistency (${napScore}%), Google Business Profile service areas.`;
                } else {
                  localEntityDesc = 'Consistency and clarity of brand, person and business entity signals.<br><strong>AI Importance:</strong> AI systems rely on clear entity signals to understand who you are and connect your brand across platforms. Strong entity recognition helps AI include you in knowledge panels and entity-based results.<br><strong>Data Source:</strong> ‚ö†Ô∏è <span style="color: #f59e0b;">Derived calculation</span> from GSC position/CTR (not using real local signals yet).<br><strong>Data Checked:</strong> Currently calculated from search performance metrics. Real data pending: LocalBusiness schema presence, NAP consistency, Google Business Profile data, knowledge panel detection.';
                  serviceAreaDesc = 'How clearly AI understands where lessons/workshops run and which regions you cover.<br><strong>AI Importance:</strong> AI uses geographic signals to match queries with local intent. Clear service area data helps AI surface your content for location-specific searches and local AI Overviews.<br><strong>Data Source:</strong> ‚ö†Ô∏è <span style="color: #f59e0b;">Derived calculation</span> from Local Entity score (not using real service area data yet).<br><strong>Data Checked:</strong> Currently calculated from Local Entity. Real data pending: ServiceArea schema markup, Google Business Profile service areas, geographic keywords, location pages.';
                }
                
                // Format GSC data for display
                const ctr = data?.ctr || 0;
                const avgPosition = data?.averagePosition || 0;
                const totalClicks = data?.totalClicks || 0;
                const totalImpressions = data?.totalImpressions || 0;
                
                const descriptions = {
                  localEntity: localEntityDesc,
                  serviceArea: serviceAreaDesc,
                  authority: `E-A-T (Experience, Expertise, Authoritativeness, Trustworthiness): Depth of educational content, references, reviews, external citations, and demonstrated expertise.<br><strong>AI Importance:</strong> E-A-T is critical for AI systems - they prioritize authoritative, trustworthy sources. Strong E-A-T signals help AI confidently feature your content in AI Overviews and answer boxes.<br><strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from Google Search Console API.<br><strong>Data Checked:</strong> CTR ${ctr.toFixed(2)}%, average position ${avgPosition.toFixed(1)}, clicks ${totalClicks.toLocaleString()}, impressions ${totalImpressions.toLocaleString()}. Backlink metrics pending integration.`,
                  visibility: `Frequency and prominence in organic search, local pack, snippets and AI Overviews.<br><strong>AI Importance:</strong> AI systems learn from existing search performance. Higher visibility signals quality and relevance, making AI more likely to surface your content in AI-powered results and featured snippets.<br><strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from Google Search Console API.<br><strong>Data Checked:</strong> Average position ${avgPosition.toFixed(1)}, CTR ${ctr.toFixed(2)}%, total clicks ${totalClicks.toLocaleString()}, total impressions ${totalImpressions.toLocaleString()}, SERP feature appearances.`,
                  contentSchema: contentSchemaDesc
                };
                
                // Generate dynamic next steps based on actual data and scores
                const getNextSteps = (pillarKey, pillarScore, gscData, schemaData) => {
                  const steps = [];
                  
                  switch(pillarKey) {
                    case 'contentSchema':
                      if (schemaData && schemaData.status === 'ok' && schemaData.data) {
                        const schemaAuditData = schemaData.data;
                        const { coverage, missingSchemaCount, totalPages, pagesWithSchema, schemaTypes, richEligible, missingTypes } = schemaAuditData;
                        
                        // Collect all types for analysis - use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
                        const allTypes = new Set();
                        if (schemaAuditData.allDetectedTypes && Array.isArray(schemaAuditData.allDetectedTypes)) {
                          // Use all detected types for accurate calculation
                          schemaAuditData.allDetectedTypes.forEach(type => {
                            if (type) allTypes.add(type);
                          });
                        } else if (schemaTypes && Array.isArray(schemaTypes)) {
                          // Fallback: collect from schemaTypes array (contains all types, sorted by count)
                          schemaTypes.forEach(item => {
                            if (item.type) allTypes.add(item.type);
                          });
                        }
                        
                        // 1. Foundation Schemas (30% weight)
                        const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
                        const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
                        const foundationMissing = foundationTypes.filter(type => !allTypes.has(type));
                        
                        if (foundationPresent < 4) {
                          steps.push(`<strong>Foundation schemas (30%):</strong> ${foundationPresent}/4 present. Add: ${foundationMissing.join(', ')}`);
                        } else {
                          steps.push(`<strong>Foundation schemas (30%):</strong> ‚úÖ All 4 present (Organization, Person, WebSite, BreadcrumbList)`);
                        }
                        
                        // 2. Rich Result Eligibility (35% weight)
                        const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList', 'Recipe'];
                        const richEligibleCount = Object.values(richEligible || {}).filter(eligible => eligible === true).length;
                        const richMissing = richResultTypes.filter(type => !richEligible[type]);
                        
                        if (richEligibleCount < richResultTypes.length) {
                          steps.push(`<strong>Rich results (35%):</strong> ${richEligibleCount}/${richResultTypes.length} eligible. Add: ${richMissing.slice(0, 3).join(', ')}${richMissing.length > 3 ? '...' : ''}`);
                        } else {
                          steps.push(`<strong>Rich results (35%):</strong> ‚úÖ All ${richResultTypes.length} types eligible`);
                        }
                        
                        // 3. Coverage (20% weight)
                        if (coverage < 100) {
                          steps.push(`<strong>Coverage (20%):</strong> ${coverage}% - Add schema to ${missingSchemaCount || 0} pages without markup`);
                        } else {
                          steps.push(`<strong>Coverage (20%):</strong> ‚úÖ 100% - All pages have schema`);
                        }
                        
                        // 4. Type Diversity (15% weight)
                        const uniqueTypesCount = allTypes.size;
                        if (uniqueTypesCount < 15) {
                          steps.push(`<strong>Diversity (15%):</strong> ${uniqueTypesCount} unique types. Add more schema types to reach 15+ for maximum score`);
                        } else {
                          steps.push(`<strong>Diversity (15%):</strong> ‚úÖ ${uniqueTypesCount} unique types (excellent diversity)`);
                        }
                      } else {
                        steps.push(`<strong>Status:</strong> Schema audit data not available - run audit to see detailed metrics`);
                      }
                      break;
                      
                    case 'visibility':
                      if (gscData) {
                        const position = gscData.averagePosition || 0;
                        const ctr = gscData.ctr || 0;
                        
                        if (position > 10) {
                          steps.push(`<strong>Average position: ${position.toFixed(1)}</strong> - Target top 10 positions (currently ranking ${position > 20 ? 'below' : 'in'} page ${Math.ceil(position / 10)})`);
                        } else {
                          steps.push(`<strong>Average position: ${position.toFixed(1)}</strong> - Excellent! Maintain top 10 rankings`);
                        }
                        
                        if (ctr < 2.0) {
                          steps.push(`<strong>CTR: ${ctr.toFixed(2)}%</strong> - Improve click-through rate (target: 2%+) with better titles/meta descriptions`);
                        } else {
                          steps.push(`<strong>CTR: ${ctr.toFixed(2)}%</strong> - Good CTR! Continue optimizing for featured snippets`);
                        }
                        
                        if (gscData.totalImpressions < 1000) {
                          steps.push(`<strong>Impressions: ${gscData.totalImpressions}</strong> - Increase visibility by targeting more keywords`);
                        }
                      }
                      break;
                      
                    case 'authority':
                      if (gscData) {
                        const ctr = gscData.ctr || 0;
                        const position = gscData.averagePosition || 0;
                        
                        if (ctr < 1.5) {
                          steps.push(`<strong>CTR: ${ctr.toFixed(2)}%</strong> - Low click-through indicates trust issues. Improve E-A-T signals`);
                        } else {
                          steps.push(`<strong>CTR: ${ctr.toFixed(2)}%</strong> - Good engagement. Build more backlinks to strengthen authority`);
                        }
                        
                        if (position > 15) {
                          steps.push(`<strong>Position: ${position.toFixed(1)}</strong> - Improve rankings through comprehensive, expert content`);
                        }
                        
                        steps.push(`<strong>Next:</strong> Integrate backlink metrics API to measure domain authority`);
                      }
                      break;
                      
                    case 'localEntity':
                      if (hasLocalSignals && localSignalsData) {
                        const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                        const locationsCount = localSignalsData.locations?.length || 0;
                        const knowledgePanel = localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected';
                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using real Business Profile data`);
                        steps.push(`<strong>Data:</strong> NAP consistency: ${napScore}%, Knowledge panel: ${knowledgePanel}, Locations: ${locationsCount}`);
                        if (pillarScore < 70) {
                          if (napScore < 100) {
                            steps.push(`<strong>Action:</strong> Improve NAP consistency (currently ${napScore}%) - ensure Name, Address, and Phone are consistent across all platforms`);
                          }
                          if (!localSignalsData.knowledgePanelDetected) {
                            steps.push(`<strong>Action:</strong> Work on knowledge panel detection - improve entity signals and citations`);
                          }
                          if (locationsCount === 0) {
                            steps.push(`<strong>Action:</strong> Add business location to Google Business Profile`);
                          }
                        } else {
                          steps.push(`<strong>Status:</strong> ‚úÖ Strong local entity signals detected`);
                        }
                      } else {
                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using derived calculation from search performance`);
                        steps.push(`<strong>Priority:</strong> Integrate Google Business Profile API to use real local signals data`);
                        if (pillarScore < 70) {
                          steps.push(`<strong>Action:</strong> Add LocalBusiness schema markup and ensure NAP consistency`);
                        }
                      }
                      break;
                      
                    case 'serviceArea':
                      if (hasLocalSignals && localSignalsData) {
                        const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
                        const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using real Business Profile data`);
                        steps.push(`<strong>Data:</strong> Service areas: ${serviceAreasCount}, NAP consistency: ${napScore}%`);
                        if (pillarScore < 70) {
                          if (serviceAreasCount < 5) {
                            steps.push(`<strong>Action:</strong> Add more service areas to Google Business Profile (currently ${serviceAreasCount}, target: 5+)`);
                          }
                          if (napScore < 100) {
                            steps.push(`<strong>Action:</strong> Improve NAP consistency to boost service area score (currently ${napScore}%)`);
                          }
                        } else {
                          steps.push(`<strong>Status:</strong> ‚úÖ Good service area coverage`);
                        }
                      } else {
                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using derived calculation from Local Entity`);
                        steps.push(`<strong>Priority:</strong> Integrate Google Business Profile API to get real service area data`);
                        if (pillarScore < 70) {
                          steps.push(`<strong>Action:</strong> Add ServiceArea schema and create location-specific pages`);
                        }
                      }
                      break;
                  }
                  
                  // If no specific steps generated, add generic ones
                  if (steps.length === 0) {
                    if (pillarScore >= 70) {
                      steps.push('Maintain current performance');
                      steps.push('Monitor for any score drops');
                    } else if (pillarScore >= 40) {
                      steps.push('Focus on improving this pillar');
                      steps.push('Review specific metrics above');
                    } else {
                      steps.push('Critical: Immediate action required');
                      steps.push('Review all data sources and implement fixes');
                    }
                  }
                  
                  return steps.slice(0, 3).map(s => `‚Ä¢ ${s}`).join('<br>') || 'No next steps available';
                };
                
                // Generate suggestions based on pillar and score (fallback)
                const getSuggestions = (pillarKey, pillarScore) => {
                  const suggestions = {
                    localEntity: {
                      high: ['Maintain consistent NAP (Name, Address, Phone) across all platforms', 'Continue building personal brand mentions and citations', 'Monitor entity recognition in knowledge panels'],
                      medium: ['Add LocalBusiness schema markup to all location pages', 'Ensure consistent business name and person name across website', 'Build more local citations and directory listings', 'Create an About page with clear entity information', 'Add author markup to content'],
                      low: ['Implement LocalBusiness schema markup immediately', 'Create consistent NAP (Name, Address, Phone) across all platforms', 'Build local citations in relevant directories', 'Add clear About page with entity information', 'Ensure consistent branding across all touchpoints']
                    },
                    serviceArea: {
                      high: ['Continue maintaining clear service area information', 'Update location pages as service areas expand'],
                      medium: ['Add ServiceArea schema markup to location pages', 'Create dedicated pages for each service area/region', 'Include clear geographic information in content', 'Add location-specific keywords naturally', 'Update Google Business Profile with service areas'],
                      low: ['Implement ServiceArea schema markup immediately', 'Create location-specific landing pages', 'Add clear geographic service information to homepage', 'Update all location pages with service area details', 'Include city/region names in page titles and content']
                    },
                    authority: {
                      high: ['Continue producing in-depth, expert content', 'Maintain citation and backlink building efforts', 'Seek opportunities for expert quotes and mentions', 'Keep author bios and credentials up to date'],
                      medium: ['Create more comprehensive, long-form content (2000+ words)', 'Build backlinks from authoritative photography/education sites', 'Seek guest posting opportunities on relevant blogs', 'Collect and display customer reviews/testimonials', 'Create case studies and detailed tutorials', 'Get cited in industry publications', 'Add author bylines with credentials and experience', 'Display certifications, qualifications, and awards', 'Showcase real-world experience and portfolio work', 'Build trust signals (secure site, clear contact info, privacy policy)'],
                      low: ['Produce comprehensive, expert-level content immediately', 'Build backlinks from authoritative sources', 'Create detailed case studies and tutorials', 'Seek media mentions and expert quotes', 'Display customer reviews prominently', 'Build relationships with industry publications', 'Add clear author credentials and experience to all content', 'Display qualifications, certifications, and professional memberships', 'Create About page highlighting expertise and experience', 'Build trust signals (HTTPS, clear contact, privacy policy, terms)']
                    },
                    visibility: {
                      high: ['Continue optimizing for featured snippets', 'Maintain strong ranking positions', 'Monitor SERP feature opportunities'],
                      medium: ['Optimize content for featured snippets (answer boxes)', 'Target long-tail keywords with lower competition', 'Improve page load speed and Core Web Vitals', 'Create FAQ schema for common questions', 'Optimize for "People Also Ask" sections', 'Build internal linking structure'],
                      low: ['Optimize for featured snippets immediately', 'Target low-competition long-tail keywords', 'Improve page speed and mobile experience', 'Add FAQ schema markup', 'Create content targeting "People Also Ask" queries', 'Build strong internal linking structure']
                    },
                    contentSchema: {
                      high: ['Continue maintaining all foundation schemas (Organization, Person, WebSite, BreadcrumbList)', 'Expand rich result eligible types (Article, Event, Course, FAQ, HowTo)', 'Monitor schema validation errors', 'Add more schema type diversity'],
                      medium: ['Add missing foundation schemas (Organization, Person, WebSite, BreadcrumbList)', 'Add rich result eligible types (Article, Event, Course, FAQ, HowTo, VideoObject, Recipe)', 'Ensure 100% schema coverage across all pages', 'Increase schema type diversity (target 15+ unique types)', 'Validate all schema using Google Rich Results Test'],
                      low: ['Implement foundation schemas immediately (Organization, Person, WebSite, BreadcrumbList)', 'Add rich result eligible schemas (Article, Event, Course, FAQ, HowTo)', 'Ensure schema coverage reaches 100%', 'Add schema type diversity (target 15+ unique types)', 'Validate all schema using Google Rich Results Test']
                    }
                  };
                  
                  const pillarSuggestions = suggestions[pillarKey];
                  if (!pillarSuggestions) return 'No suggestions available';
                  
                  let selectedSuggestions = [];
                  if (pillarScore >= 70) {
                    selectedSuggestions = pillarSuggestions.high || [];
                  } else if (pillarScore >= 40) {
                    selectedSuggestions = pillarSuggestions.medium || [];
                  } else {
                    selectedSuggestions = pillarSuggestions.low || [];
                  }
                  
                  // Return top 3-4 suggestions as bullet points
                  return selectedSuggestions.slice(0, 4).map(s => `‚Ä¢ ${s}`).join('<br>') || 'No suggestions available';
                };
                
                const weight = pillarWeights[key] || 0;
                const isEven = index % 2 === 0;
                
                // Add CSV download button for Content/Schema
                let descriptionCell = descriptions[key] || '';
                if (key === 'contentSchema' && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
                  const schemaData = schemaAudit.data;
                  const missingSchemaCount = schemaData.missingSchemaCount || 0;
                  const missingSchemaPages = schemaData.missingSchemaPages || [];
                  
                  // Always show button, but disable if no missing pages
                  const buttonDisabled = missingSchemaCount === 0;
                  const buttonStyle = buttonDisabled 
                    ? 'padding: 0.4rem 0.8rem; font-size: 0.8rem; background: #9ca3af; color: white; border: none; border-radius: 4px; cursor: not-allowed; opacity: 0.6;'
                    : 'padding: 0.4rem 0.8rem; font-size: 0.8rem; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;';
                  const buttonText = missingSchemaCount > 0 
                    ? `Download pages without schema (CSV) - ${missingSchemaCount} pages`
                    : 'Download pages without schema (CSV) - No missing pages';
                  
                  const downloadTooltip = missingSchemaCount > 0 
                    ? `Download a CSV file containing ${missingSchemaCount} page URLs that are missing schema markup. Use this list to prioritize which pages need schema added.`
                    : 'All pages have schema markup. No download available.';
                  descriptionCell += `<div style="margin-top: 0.75rem;"><button id="download-missing-schema" class="btn-small" style="${buttonStyle}" ${buttonDisabled ? 'disabled' : ''} title="${downloadTooltip}">${buttonText}</button></div>`;
                }
                
                // Get data date for this pillar
                const pillarDataDate = getPillarDataDate(key);
                const dataDateDisplay = pillarDataDate 
                  ? `<span style="font-size: 0.8rem; color: #666;">${pillarDataDate}</span>`
                  : '<span style="font-size: 0.8rem; color: #999;">N/A</span>';
                
                return `
                  <tr style="border-bottom: 1px solid #eee; background: ${isEven ? '#ffffff' : '#fafafa'};">
                    <td style="padding: 0.75rem; font-weight: 500;">${pillarNames[key]}</td>
                    <td style="padding: 0.75rem; text-align: center; font-size: 1.1rem; font-weight: 600; color: ${rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444'};">
                      ${Math.round(score)}
                    </td>
                    <td style="padding: 0.75rem; text-align: center; font-size: 0.9rem; font-weight: 600; color: #666;">
                      ${(weight * 100).toFixed(0)}%
                    </td>
                    <td style="padding: 0.75rem; text-align: center;">
                      <span class="rag-badge ${rag.status}" style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.8rem;">
                        ${rag.label}
                      </span>
                    </td>
                    <td style="padding: 0.75rem; color: #666; font-size: 0.85rem; line-height: 1.6; width: 42%;">${descriptionCell}</td>
                    <td style="padding: 0.75rem; color: #555; font-size: 0.85rem; line-height: 1.6; width: 22%;">${getNextSteps(key, score, data, schemaAudit)}</td>
                    <td style="padding: 0.75rem; text-align: center; width: 6%;">${dataDateDisplay}</td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
        <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-top: 1rem; border-left: 4px solid var(--brand-orange);">
          <p style="margin: 0; font-size: 0.9rem; color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
            <strong>RAG Status Guide:</strong> 
            <span style="color: #10b981; font-weight: 600;">Green (70-100)</span> = Strong performance, 
            <span style="color: #f59e0b; font-weight: 600;">Amber (40-69)</span> = Needs improvement, 
            <span style="color: #ef4444; font-weight: 600;">Red (0-39)</span> = Critical issues
          </p>
          <p style="margin: 0; font-size: 0.9rem; color: #555; line-height: 1.6;">
            <strong>Weighting:</strong> Pillars are weighted by their importance for AI search systems. Authority (30%) and Content/Schema (25%) are most critical, as AI relies heavily on E-A-T signals and structured data. Visibility (20%) reflects how AI learns from existing performance, while Local Entity (15%) and Service Area (10%) are less critical for AI-powered results.
          </p>
        </div>
      `;
      // Insert scorecard table after Score Trends chart (at the end)
      const trendChart = document.getElementById('trendChart');
      if (trendChart && trendChart.parentElement && trendChart.parentElement.parentNode) {
        // Find the chart container (parent of canvas) and insert after it
        const trendChartContainer = trendChart.parentElement;
        trendChartContainer.parentNode.insertBefore(scorecardTable, trendChartContainer.nextSibling);
      } else {
        // Fallback: insert at end of dashboard container
        const dashboardContainer = document.getElementById('dashboard');
        if (dashboardContainer) {
          dashboardContainer.appendChild(scorecardTable);
        } else {
          // Last resort: insert after pillar cards
          pillarCards.parentNode.insertBefore(scorecardTable, pillarCards.nextSibling);
        }
      }

      // Add CSV download handler for missing schema pages
      const downloadBtn = document.getElementById('download-missing-schema');
      if (downloadBtn && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        const missingSchemaCount = schemaData.missingSchemaCount || 0;
        const missingSchemaPages = schemaData.missingSchemaPages || [];
        
        debugLog(`Missing schema pages: count=${missingSchemaCount}, pages=${missingSchemaPages.length}`, 'info');
        debugLog(`Missing schema data: ${JSON.stringify(missingSchemaPages)}`, 'info');
        
        if (missingSchemaCount > 0 && missingSchemaPages.length > 0) {
          downloadBtn.addEventListener('click', () => {
            // Check if any pages have error field to determine CSV columns
            const hasErrors = missingSchemaPages.some(p => p.error);
            const headers = hasErrors ? ['url', 'parentUrl', 'error'] : ['url', 'parentUrl'];
            
            const rows = [
              headers,
              ...missingSchemaPages.map(p => [
                p.url, 
                p.parentUrl || '', 
                ...(hasErrors ? [p.error || ''] : [])
              ]),
            ];
            
            const csv = rows
              .map(r => r.map(v => `"${(v || '').replace(/"/g, '""')}"`).join(','))
              .join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ai-geo-missing-schema-pages.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          });
        } else {
          // Button is already disabled in the HTML, just log
          debugLog(`No missing schema pages to download (count: ${missingSchemaCount})`, 'info');
        }
      } else if (!downloadBtn) {
        debugLog('Download button not found in DOM', 'warn');
      }

      // Display snippet readiness with pie chart visualization
      const snippetScoreElement = document.getElementById('snippetReadinessScore');
      const gaugeStatus = document.getElementById('gaugeStatus');
      const legendElement = document.getElementById('snippetReadinessLegend');
      
      if (snippetScoreElement) {
        snippetScoreElement.textContent = snippetReadiness;
        
        // Color code overall score based on value
        let colorClass = '#ef4444'; // red
        let statusText = 'Critical';
        if (snippetReadiness >= 70) {
          colorClass = '#10b981'; // green
          statusText = 'Strong';
        } else if (snippetReadiness >= 40) {
          colorClass = '#f59e0b'; // amber
          statusText = 'Needs Improvement';
        }
        
        snippetScoreElement.style.color = colorClass;
        
        // Update status text
        if (gaugeStatus) {
          gaugeStatus.textContent = statusText;
          gaugeStatus.style.color = colorClass;
        }
      }
      
      // Create pie chart showing weighted components
      const pieChartCanvas = document.getElementById('snippetReadinessPieChart');
      if (pieChartCanvas && scores) {
        // Destroy existing chart if it exists
        if (window.snippetReadinessChart) {
          window.snippetReadinessChart.destroy();
        }
        
        const contentSchemaScore = Math.round(scores.contentSchema || 0);
        const visibilityScore = Math.round(scores.visibility || 0);
        const authorityScore = Math.round(scores.authority || 0);
        
        // Generate top 5 actionable levers to improve snippet readiness
        const explanationDiv = document.getElementById('snippetReadinessExplanation');
        const topActionsList = document.getElementById('topActionsList');
        if (explanationDiv && topActionsList && scores) {
          const contentSchemaScore = Math.round(scores.contentSchema || 0);
          const visibilityScore = Math.round(scores.visibility || 0);
          const authorityScore = Math.round(scores.authority || 0);
          
          const actions = [];
          
          // Authority (25% weight) - usually lowest, highest impact potential
          if (authorityScore < 70) {
            const potentialGain = (70 - authorityScore) * 0.25; // Max potential points if improved to 70
            if (data && data.ctr !== undefined) {
              const ctr = data.ctr || 0;
              if (ctr < 1.5) {
                actions.push({
                  priority: 1,
                  impact: potentialGain,
                  text: `Improve Authority (currently ${authorityScore}%): Increase CTR from ${ctr.toFixed(2)}% to 2%+ by optimizing titles and meta descriptions. Potential gain: +${potentialGain.toFixed(1)} points.`
                });
              } else {
                actions.push({
                  priority: 1,
                  impact: potentialGain,
                  text: `Improve Authority (currently ${authorityScore}%): Build backlinks and improve E-A-T signals. Potential gain: +${potentialGain.toFixed(1)} points.`
                });
              }
            } else {
              actions.push({
                priority: 1,
                impact: potentialGain,
                text: `Improve Authority (currently ${authorityScore}%): Build backlinks, improve E-A-T signals, and optimize CTR. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            }
          }
          
          // Content/Schema (40% weight) - highest weight
          if (contentSchemaScore < 100 && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
            const schemaData = schemaAudit.data;
            const allTypes = new Set();
            // Use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
            if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
              schemaData.allDetectedTypes.forEach(type => {
                if (type) allTypes.add(type);
              });
            } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
              schemaData.schemaTypes.forEach(item => {
                if (item.type) allTypes.add(item.type);
              });
            }
            
            const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
            const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
            const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
            const uniqueTypesCount = allTypes.size;
            
            // Calculate potential improvements
            if (foundationPresent < 4) {
              const missingFoundation = foundationTypes.filter(type => !allTypes.has(type));
              const potentialGain = ((4 - foundationPresent) / 4) * 30 * 0.4; // 30% weight of 40% total
              actions.push({
                priority: 2,
                impact: potentialGain,
                text: `Add missing foundation schemas: ${missingFoundation.join(', ')}. Currently ${foundationPresent}/4. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            }
            
            // Get list of all rich result types (must match api/schema-audit.js)
            const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList', 'Recipe'];
            const totalRichResultTypes = richResultTypes.length;
            
            if (richEligibleCount < totalRichResultTypes) {
              const potentialGain = ((totalRichResultTypes - richEligibleCount) / totalRichResultTypes) * 35 * 0.4; // 35% weight of 40% total
              
              // Get list of which rich result types are missing
              const missingRichTypes = richResultTypes.filter(type => {
                return !schemaData.richEligible || !schemaData.richEligible[type];
              });
              
              // Filter out Recipe for photography businesses (not applicable)
              const applicableMissingTypes = missingRichTypes.filter(type => type !== 'Recipe');
              
              // Build suggestion text
              let suggestionText;
              if (applicableMissingTypes.length > 0) {
                suggestionText = `Add more rich result types. Currently ${richEligibleCount}/${totalRichResultTypes} eligible. Add: ${applicableMissingTypes.join(', ')} schemas. Potential gain: +${potentialGain.toFixed(1)} points.`;
              } else {
                suggestionText = `Add more rich result types. Currently ${richEligibleCount}/${totalRichResultTypes} eligible. Potential gain: +${potentialGain.toFixed(1)} points.`;
              }
              
              actions.push({
                priority: 3,
                impact: potentialGain,
                text: suggestionText
              });
            }
            
            if (uniqueTypesCount < 15) {
              const potentialGain = ((15 - uniqueTypesCount) / 15) * 15 * 0.4; // 15% weight of 40% total
              actions.push({
                priority: 4,
                impact: potentialGain,
                text: `Increase schema diversity. Currently ${uniqueTypesCount} types (target: 15+). Add more schema types across different page types. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            }
          }
          
          // Visibility (35% weight)
          if (visibilityScore < 90 && data && data.averagePosition !== undefined) {
            const position = data.averagePosition || 0;
            const ctr = data.ctr || 0;
            const potentialGain = (90 - visibilityScore) * 0.35;
            
            if (position > 10) {
              actions.push({
                priority: 5,
                impact: potentialGain,
                text: `Improve Visibility (currently ${visibilityScore}%): Target top 10 positions. Current average position: ${position.toFixed(1)}. Optimize for featured snippets. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            } else if (ctr < 2.0) {
              actions.push({
                priority: 5,
                impact: potentialGain,
                text: `Improve Visibility (currently ${visibilityScore}%): Increase CTR from ${ctr.toFixed(2)}% to 2%+ with better titles and meta descriptions. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            }
          }
          
          // Sort by impact (highest first) and take top 5
          actions.sort((a, b) => b.impact - a.impact);
          const top5Actions = actions.slice(0, 5);
          
          // Update the list
          topActionsList.innerHTML = top5Actions.map((action, index) => 
            `<li style="margin: 0.5rem 0; line-height: 1.5; color: #78350f;">${action.text}</li>`
          ).join('');
          
          if (top5Actions.length === 0) {
            topActionsList.innerHTML = '<li style="margin: 0.5rem 0;">All components are performing well! Maintain current performance.</li>';
          }
          
          explanationDiv.style.display = 'block';
        } else if (explanationDiv) {
          explanationDiv.style.display = 'none';
        }
        
        // Calculate weighted contribution of each component
        const contentSchemaContribution = (contentSchemaScore * 0.4).toFixed(1);
        const visibilityContribution = (visibilityScore * 0.35).toFixed(1);
        const authorityContribution = (authorityScore * 0.25).toFixed(1);
        
        // Create nested pie chart with fill percentages
        // Outer ring: Weighting (40%, 35%, 25%)
        // Inner fill: Score percentage within each segment (like fuel gauge)
        
        const weights = [40, 35, 25];
        const scoresArray = [contentSchemaScore, visibilityScore, authorityScore];
        // Match trend chart colors (avoid red/amber/green to prevent RAG confusion)
        const colors = ['#6b7280', '#2563eb', '#eab308']; // Grey (Content/Schema), Blue (Visibility), Yellow (Authority)
        
        // Calculate outer ring data (weighting percentages)
        const outerData = weights;
        
        // Inner ring: Same segment sizes as outer, but we'll use custom drawing to fill only the score percentage
        // The inner data must match outer segment sizes so they align
        const innerData = weights; // Same sizes as outer
        
        // Create chart with custom drawing for inner fill segments
        window.snippetReadinessChart = new Chart(pieChartCanvas, {
          type: 'doughnut',
          data: {
            labels: [
              `Content/Schema`,
              `Visibility`,
              `Authority`
            ],
            datasets: [
              {
                // Outer ring: Weighting percentages (40%, 35%, 25%)
                label: 'Weight',
                data: outerData,
                backgroundColor: colors,
                borderWidth: 4,
                borderColor: '#ffffff',
                cutout: '60%' // Leave room for inner fill
              },
              {
                // Inner ring: Same segment sizes, but will be custom-drawn to show score fill
                label: 'Score Fill',
                data: innerData,
                backgroundColor: colors.map((color, i) => {
                  // Use darker version of segment color for unfilled portion
                  return color + '40'; // Add transparency
                }),
                borderWidth: 4,
                borderColor: '#ffffff',
                cutout: '75%' // Inner ring showing fill
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                display: false // We'll use custom legend
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const datasetIndex = context.datasetIndex;
                    const index = context.dataIndex;
                    
                    if (datasetIndex === 0) {
                      // Outer ring: Show weighting
                      return `Weight: ${weights[index]}%`;
                    } else {
                      // Inner fill: Show score and fill percentage
                      const score = scoresArray[index];
                      const fillPercent = (score / 100) * 100;
                      return `Score: ${score}% (${fillPercent.toFixed(0)}% of segment filled)`;
                    }
                  }
                }
              }
            }
          },
          plugins: [{
            id: 'innerFillAndLabels',
            afterDraw: (chart) => {
              const ctx = chart.ctx;
              const outerMeta = chart.getDatasetMeta(0); // Outer ring
              const innerMeta = chart.getDatasetMeta(1); // Inner ring
              const centerX = chart.chartArea.left + (chart.chartArea.right - chart.chartArea.left) / 2;
              const centerY = chart.chartArea.top + (chart.chartArea.bottom - chart.chartArea.top) / 2;
              const outerRadius = (chart.chartArea.right - chart.chartArea.left) / 2;
              const innerRadius = outerRadius * 0.75; // 75% cutout
              const outerInnerRadius = outerRadius * 0.60; // 60% cutout (where inner ring starts)
              
              // First, clear the inner ring segments (they're drawn by Chart.js but we'll redraw them)
              // Then draw custom filled portions based on scores
              
              outerMeta.data.forEach((outerSegment, index) => {
                const score = scoresArray[index];
                const scorePercent = score / 100; // 0 to 1
                const startAngle = outerSegment.startAngle;
                const endAngle = outerSegment.endAngle;
                const segmentAngle = endAngle - startAngle;
                const filledAngle = segmentAngle * scorePercent;
                const filledEndAngle = startAngle + filledAngle;
                
                // Get RAG color for fill
                let fillColor;
                if (score >= 70) fillColor = '#10b981'; // Green
                else if (score >= 40) fillColor = '#f59e0b'; // Amber
                else fillColor = '#ef4444'; // Red
                
                // Draw the filled portion of this inner segment (fuel gauge effect)
                ctx.save();
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerInnerRadius, startAngle, filledEndAngle, false);
                ctx.arc(centerX, centerY, innerRadius, filledEndAngle, startAngle, true);
                ctx.closePath();
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.restore();
                
                // Draw weight percentage in outer segment (larger, white for grey and blue segments, black for yellow)
                const outerSegmentMidAngle = (startAngle + endAngle) / 2;
                // Position closer to outer edge but still inside segment (about 75% of outer ring width)
                const outerSegmentTextRadius = outerRadius - ((outerRadius - outerInnerRadius) * 0.25);
                const weightTextX = centerX + Math.cos(outerSegmentMidAngle) * outerSegmentTextRadius;
                const weightTextY = centerY + Math.sin(outerSegmentMidAngle) * outerSegmentTextRadius;
                
                ctx.save();
                // Use white text for grey (Content/Schema) and blue (Visibility) segments, black for yellow (Authority)
                const textColor = (colors[index] === '#6b7280' || colors[index] === '#2563eb') ? '#ffffff' : '#000000';
                ctx.fillStyle = textColor;
                ctx.font = 'bold 18px system-ui'; // Increased from 14px to 18px
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // Add shadow for readability (dark shadow for white text, light shadow for black text)
                if (textColor === '#ffffff') {
                  ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                } else {
                  ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
                }
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.fillText(`${weights[index]}%`, weightTextX, weightTextY);
                ctx.restore();
                
                // Draw label in the center area, aligned to segment
                const midAngle = (startAngle + endAngle) / 2;
                // Position label in center area (about 30% from center, well inside the 75% cutout)
                const labelRadius = outerRadius * 0.25; // Position in center area
                const labelX = centerX + Math.cos(midAngle) * labelRadius;
                const labelY = centerY + Math.sin(midAngle) * labelRadius;
                
                // Get component names
                const componentNames = ['Content/Schema', 'Visibility', 'Authority'];
                const weight = weights[index];
                
                // Calculate text bounds to avoid arrow overlap
                // Estimate text height: 3 lines with spacing ‚âà 45px total height
                const textHeight = 45;
                const textWidth = 80; // Approximate max text width
                
                // Draw dotted arrow from label to segment edge, routing around text
                ctx.save();
                ctx.strokeStyle = colors[index];
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // Dotted line
                ctx.beginPath();
                
                // Start arrow from edge of text area with more padding to avoid overlap
                // Calculate perpendicular offset to route around text
                const perpAngle = midAngle + Math.PI / 2; // Perpendicular to segment angle
                const textOffset = 35; // Increased from 25 to 35 - more padding from text edge
                const perpOffset = (textHeight / 2) + 8; // Increased padding perpendicular to text
                const arrowStartX = labelX + Math.cos(midAngle) * textOffset + Math.cos(perpAngle) * perpOffset;
                const arrowStartY = labelY + Math.sin(midAngle) * textOffset + Math.sin(perpAngle) * perpOffset;
                
                // End at inner ring edge
                const segmentEdgeX = centerX + Math.cos(midAngle) * innerRadius;
                const segmentEdgeY = centerY + Math.sin(midAngle) * innerRadius;
                
                // Draw curved path around text (simple two-segment path)
                const midX = (arrowStartX + segmentEdgeX) / 2;
                const midY = (arrowStartY + segmentEdgeY) / 2;
                // Offset midpoint further outward to curve around text with more clearance
                const curveOffset = 25; // Increased from 15 to 25 for more clearance
                const curveMidX = midX + Math.cos(perpAngle) * curveOffset;
                const curveMidY = midY + Math.sin(perpAngle) * curveOffset;
                
                ctx.moveTo(arrowStartX, arrowStartY);
                ctx.quadraticCurveTo(curveMidX, curveMidY, segmentEdgeX, segmentEdgeY);
                ctx.stroke();
                
                // Draw arrowhead
                const arrowLength = 8;
                const arrowAngle = Math.atan2(segmentEdgeY - curveMidY, segmentEdgeX - curveMidX);
                ctx.setLineDash([]); // Solid for arrowhead
                ctx.beginPath();
                ctx.moveTo(segmentEdgeX, segmentEdgeY);
                ctx.lineTo(
                  segmentEdgeX - arrowLength * Math.cos(arrowAngle - Math.PI / 6),
                  segmentEdgeY - arrowLength * Math.sin(arrowAngle - Math.PI / 6)
                );
                ctx.moveTo(segmentEdgeX, segmentEdgeY);
                ctx.lineTo(
                  segmentEdgeX - arrowLength * Math.cos(arrowAngle + Math.PI / 6),
                  segmentEdgeY - arrowLength * Math.sin(arrowAngle + Math.PI / 6)
                );
                ctx.stroke();
                ctx.restore();
                
                // Draw text labels without circles (to prevent overlap)
                ctx.save();
                // Add text shadow for better readability without background
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Draw text with readable fonts
                ctx.fillStyle = colors[index];
                ctx.font = 'bold 13px system-ui';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // First line: Component name
                ctx.fillText(`${componentNames[index]}`, labelX, labelY - 8);
                // Second line: Score percentage (colored) - weight removed, now in outer segment
                ctx.fillStyle = fillColor;
                ctx.font = 'bold 15px system-ui';
                ctx.fillText(`Score: ${score}%`, labelX, labelY + 8);
                
                ctx.restore();
              });
            }
          }]
        });
        
        // Create custom legend with scores
        if (legendElement) {
          const getRAGColor = (score) => {
            if (score >= 70) return '#10b981';
            if (score >= 40) return '#f59e0b';
            return '#ef4444';
          };
          
          const getRAGLabel = (score) => {
            if (score >= 70) return 'Green';
            if (score >= 40) return 'Amber';
            return 'Red';
          };
          
          legendElement.innerHTML = `
            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #6b7280;">
              <div style="width: 12px; height: 12px; background: #6b7280; border-radius: 2px; flex-shrink: 0;"></div>
              <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Content/Schema</div>
                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 40%<br>Score: <strong style="color: ${getRAGColor(contentSchemaScore)};">${contentSchemaScore}</strong> (${getRAGLabel(contentSchemaScore)})<br>Contribution: ${contentSchemaContribution} pts</div>
              </div>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #2563eb;">
              <div style="width: 12px; height: 12px; background: #2563eb; border-radius: 2px; flex-shrink: 0;"></div>
              <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Visibility</div>
                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 35%<br>Score: <strong style="color: ${getRAGColor(visibilityScore)};">${visibilityScore}</strong> (${getRAGLabel(visibilityScore)})<br>Contribution: ${visibilityContribution} pts</div>
              </div>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #eab308;">
              <div style="width: 12px; height: 12px; background: #eab308; border-radius: 2px; flex-shrink: 0;"></div>
              <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Authority</div>
                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 25%<br>Score: <strong style="color: ${getRAGColor(authorityScore)};">${authorityScore}</strong> (${getRAGLabel(authorityScore)})<br>Contribution: ${authorityContribution} pts</div>
              </div>
            </div>
          `;
        }
      }

      // Format numbers for display
      const formatNumber = (num) => {
        if (num >= 1000000) {
          return (num / 1000000).toFixed(2) + 'M';
        } else if (num >= 1000) {
          return (num / 1000).toFixed(2) + 'K';
        }
        return num.toLocaleString();
      };

      // Display metrics
      const metricsGrid = document.getElementById('metricsGrid');
      metricsGrid.innerHTML = `
        <div class="metric-card">
          <div class="value">${formatNumber(data.totalClicks)}</div>
          <div class="label">Total Clicks</div>
        </div>
        <div class="metric-card">
          <div class="value">${formatNumber(data.totalImpressions)}</div>
          <div class="label">Total Impressions</div>
        </div>
        <div class="metric-card">
          <div class="value">${data.averagePosition.toFixed(1)}</div>
          <div class="label">Avg Position</div>
        </div>
        <div class="metric-card">
          <div class="value">${(data.ctr || 0).toFixed(2)}%</div>
          <div class="label">CTR</div>
        </div>
      `;

      // Wait a moment for DOM to update, then create charts (charts need visible canvas)
      setTimeout(async () => {
        debugLog('Starting chart creation (setTimeout callback)...', 'info');
        
        // Check if Chart.js is loaded
        debugLog('Checking Chart.js availability...', 'info');
        if (typeof Chart === 'undefined') {
          debugLog('‚úó Chart.js library not loaded', 'error');
          console.error('Chart.js library not loaded');
          showStatus('Chart.js library failed to load. Please refresh the page.', 'error');
          return;
        }
        debugLog('‚úì Chart.js library available', 'success');
        debugLog(`Chart constructor: ${typeof Chart}`, 'info');

        // Create radar chart
        debugLog('Creating radar chart...', 'info');
        const radarCanvas = document.getElementById('radarChart');
        if (!radarCanvas) {
          debugLog('‚úó Radar chart canvas not found', 'error');
          console.error('Radar chart canvas not found');
          return;
        }
        debugLog('‚úì Radar chart canvas found', 'success');
        
        // Safely destroy existing chart if it exists
        debugLog(`Checking for existing radarChart: ${window.radarChart ? 'exists' : 'null'}`, 'info');
        try {
          if (window.radarChart) {
            debugLog(`radarChart type: ${typeof window.radarChart}`, 'info');
            debugLog(`radarChart instanceof Chart: ${window.radarChart instanceof Chart}`, 'info');
            debugLog(`radarChart.destroy type: ${typeof window.radarChart.destroy}`, 'info');
            
            // Check if it's actually a Chart instance
            if (window.radarChart instanceof Chart && typeof window.radarChart.destroy === 'function') {
              debugLog('Destroying existing radar chart...', 'info');
              window.radarChart.destroy();
              debugLog('‚úì Existing radar chart destroyed', 'success');
            } else {
              debugLog('Existing radarChart is not a valid Chart instance, clearing...', 'info');
            }
            window.radarChart = null;
          } else {
            debugLog('No existing radar chart to destroy', 'info');
          }
        } catch (e) {
          debugLog(`‚úó Error destroying existing radar chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.warn('Error destroying existing radar chart:', e);
          window.radarChart = null;
        }
        
        const radarCtx = radarCanvas.getContext('2d');
        debugLog('Creating new Chart instance for radar chart...', 'info');
        try {
          // Use ordered pillars for consistent ordering
          const orderedPillars = getOrderedPillars(scores);
          const orderedLabels = orderedPillars.map(([key]) => pillarNames[key]);
          const orderedData = orderedPillars.map(([, score]) => score);
          
          window.radarChart = new Chart(radarCtx, {
            type: 'radar',
            data: {
              labels: orderedLabels,
              datasets: [{
                label: 'Current Scores',
                data: orderedData,
                backgroundColor: 'rgba(59, 130, 246, 0.2)',
                borderColor: 'rgba(37, 99, 235, 1)',
                pointBackgroundColor: 'rgba(37, 99, 235, 1)',
                pointBorderColor: '#fff',
                pointHoverBackgroundColor: '#fff',
                pointHoverBorderColor: 'rgba(37, 99, 235, 1)'
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              layout: {
                padding: {
                  top: 20,
                  bottom: 20,
                  left: 20,
                  right: 20
                }
              },
              scales: {
                r: {
                  beginAtZero: false,
                  min: 20,
                  max: 100,
                  ticks: {
                    stepSize: 20,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    color: '#1e293b'
                  },
                  pointLabels: {
                    font: {
                      size: 16,
                      weight: 'bold'
                    },
                    color: '#1e293b',
                    padding: 20
                  },
                  grid: {
                    color: 'rgba(100, 116, 139, 0.2)'
                  },
                  angleLines: {
                    color: 'rgba(100, 116, 139, 0.3)'
                  }
                }
              },
              plugins: {
                legend: {
                  labels: {
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    padding: 15
                  }
                }
              }
            },
            plugins: [{
              id: 'radarScoreLabels',
              afterDraw: (chart) => {
                const ctx = chart.ctx;
                const scale = chart.scales.r;
                const pointLabelItems = scale._pointLabelItems || [];
                
                // Draw score percentages directly under each label
                pointLabelItems.forEach((item, index) => {
                  if (item && orderedData[index] !== undefined) {
                    const score = orderedData[index];
                    // Get RAG color based on score
                    let ragColor = '#1e293b'; // Default dark
                    if (score >= 70) ragColor = '#10b981'; // Green
                    else if (score >= 40) ragColor = '#f59e0b'; // Amber
                    else ragColor = '#ef4444'; // Red
                    
                    // Draw the score percentage directly below the label
                    ctx.save();
                    ctx.fillStyle = ragColor;
                    ctx.font = 'bold 14px system-ui';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
                    ctx.shadowBlur = 4;
                    // Position it 20px below the label
                    const scoreY = item.y + 20;
                    ctx.fillText(`${Math.round(score)}%`, item.x, scoreY);
                    ctx.restore();
                  }
                });
              }
            }]
          });
          debugLog('‚úì Radar chart created successfully', 'success');
          debugLog(`radarChart type after creation: ${typeof window.radarChart}`, 'info');
          debugLog(`radarChart instanceof Chart: ${window.radarChart instanceof Chart}`, 'info');
        } catch (e) {
          debugLog(`‚úó Error creating radar chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.error('Error creating radar chart:', e);
        }

        // Create trend chart (mock data for now)
        debugLog('Creating trend chart...', 'info');
        const trendCanvas = document.getElementById('trendChart');
        if (!trendCanvas) {
          debugLog('‚úó Trend chart canvas not found', 'error');
          console.error('Trend chart canvas not found');
          return;
        }
        debugLog('‚úì Trend chart canvas found', 'success');
        
        // Safely destroy existing chart if it exists
        debugLog(`Checking for existing trendChart: ${window.trendChart ? 'exists' : 'null'}`, 'info');
        try {
          if (window.trendChart) {
            debugLog(`trendChart type: ${typeof window.trendChart}`, 'info');
            debugLog(`trendChart instanceof Chart: ${window.trendChart instanceof Chart}`, 'info');
            debugLog(`trendChart.destroy type: ${typeof window.trendChart.destroy}`, 'info');
            // Check if it's actually a Chart instance
            if (window.trendChart instanceof Chart && typeof window.trendChart.destroy === 'function') {
              debugLog('Destroying existing trend chart...', 'info');
              window.trendChart.destroy();
              debugLog('‚úì Existing trend chart destroyed', 'success');
            } else {
              debugLog('Existing trendChart is not a valid Chart instance, clearing...', 'info');
            }
            window.trendChart = null;
          } else {
            debugLog('No existing trend chart to destroy', 'info');
          }
        } catch (e) {
          debugLog(`‚úó Error destroying existing trend chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.warn('Error destroying existing trend chart:', e);
          window.trendChart = null;
        }
        
        const trendCtx = trendCanvas.getContext('2d');
        const dateRange = parseInt(document.getElementById('dateRange').value) || 30;
        debugLog(`Creating trend chart for date range: ${dateRange} days`, 'info');
        
        // Determine number of data points and label frequency based on date range
        let numDataPoints, labelStep, dateFormat;
        if (dateRange <= 30) {
          // For 30 days or less: show daily data, all labels
          numDataPoints = dateRange;
          labelStep = 1;
          dateFormat = { month: 'short', day: 'numeric' };
        } else if (dateRange <= 90) {
          // For 90 days: show daily data, label every 3-5 days
          numDataPoints = dateRange;
          labelStep = Math.ceil(dateRange / 20); // ~20 labels max
          dateFormat = { month: 'short', day: 'numeric' };
        } else if (dateRange <= 180) {
          // For 6 months: show weekly data, label every week
          numDataPoints = Math.ceil(dateRange / 7);
          labelStep = 1;
          dateFormat = { month: 'short', day: 'numeric' };
        } else {
          // For 12 months: show weekly data, label every 2-4 weeks
          numDataPoints = Math.ceil(dateRange / 7);
          labelStep = Math.ceil(numDataPoints / 15); // ~15 labels max
          dateFormat = { month: 'short', day: 'numeric' };
        }
        
        // Generate date labels and store Date objects
        const allDates = Array.from({ length: numDataPoints }, (_, i) => {
          const d = new Date();
          if (dateRange <= 90) {
            // Daily data
            d.setDate(d.getDate() - (numDataPoints - 1 - i));
          } else {
            // Weekly data
            d.setDate(d.getDate() - ((numDataPoints - 1 - i) * 7));
          }
          return d;
        });
        
        // Store Date objects for period detection (for mock data)
        const mockDateObjects = allDates.slice();
        
        // Create labels array with appropriate spacing and year detection
        let lastVisibleYear = null;
        const dates = allDates.map((d, i) => {
          if (i % labelStep === 0 || i === allDates.length - 1) {
            const currentYear = d.getFullYear();
            const formattedDate = d.toLocaleDateString('en-GB', dateFormat);
            
            // Add year if it changed from the last visible label
            if (lastVisibleYear !== null && currentYear !== lastVisibleYear) {
              lastVisibleYear = currentYear;
              return `${formattedDate} ${currentYear}`;
            }
            
            lastVisibleYear = currentYear;
            return formattedDate;
          }
          return ''; // Empty string for labels we don't want to show
        });
        
        // Store date objects for mock data (will be updated if timeseries data exists)
        chartDateObjects = mockDateObjects;
        debugLog('Creating new Chart instance for trend chart...', 'info');
        try {
          // Use real timeseries data from GSC API
          const timeseries = data.timeseries || [];
          debugLog(`Using ${timeseries.length} timeseries data points from GSC API`, 'info');
          
          // Check if we have data
          if (!data || !data.timeseries || data.timeseries.length === 0) {
            debugLog('‚ö† No timeseries data available. Chart will show mock data. Run a new audit to get real GSC historical data.', 'warn');
            // Show message to user (only if message doesn't already exist)
            const trendCanvas = document.getElementById('trendChart');
            if (trendCanvas && trendCanvas.parentElement) {
              // Check if message already exists
              const existingMessage = trendCanvas.parentElement.querySelector('.trend-chart-warning');
              if (!existingMessage) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'trend-chart-warning';
                messageDiv.style.cssText = 'background: #fff3cd; padding: 1rem; border-radius: 4px; border-left: 3px solid #f59e0b; margin-bottom: 1rem; font-size: 0.9rem; color: #856404;';
                messageDiv.innerHTML = '<strong>No historical data available.</strong> The trend chart requires timeseries data from Google Search Console. Please run a new audit to populate the chart with real historical data.';
                trendCanvas.parentElement.insertBefore(messageDiv, trendCanvas);
              }
            }
          }
          
          // If we have timeseries data, use it; otherwise fall back to mock data
          let localEntityData, serviceAreaData, authorityData, visibilityData, contentSchemaData;
          let contentSchemaDataEstimated = []; // Declare in outer scope for use in chart creation
          let chartDates = dates;
          let chartDateObjects = []; // Store Date objects for period detection
          
          // Declare maps in outer scope so they're accessible everywhere
          let contentSchemaHistory = [];
          let contentSchemaMap = new Map();
          let localEntityMap = new Map();
          let serviceAreaMap = new Map();
          const currentContentSchema = scores.contentSchema || 0;
          
          if (timeseries.length > 0) {
            // Fetch historical Content/Schema data from Supabase (async operation)
            const propertyUrl = document.getElementById('propertyUrl')?.value || '';
            // Use the actual date range from timeseries data (not calculated from today)
            // This ensures we query the correct year (2024 vs 2025)
            const timeseriesStartDate = timeseries[0].date; // First date in timeseries
            const timeseriesEndDate = timeseries[timeseries.length - 1].date; // Last date in timeseries
            // Use today's date (declare as 'let' so it can be reused later)
            let today = new Date();
            let todayStr = today.toISOString().split('T')[0];
            // Query from timeseries start to today (to catch any data beyond timeseries)
            const startDate = timeseriesStartDate;
            const endDate = todayStr; // Use today, not timeseries end date
            
            debugLog(`Fetching Content/Schema history from Supabase: ${startDate} to ${endDate}`, 'info');
            debugLog(`Timeseries date range: ${timeseriesStartDate} to ${timeseriesEndDate}`, 'info');
            
            // Fetch historical data asynchronously (includes Content/Schema AND Business Profile data)
            if (propertyUrl) {
              try {
                contentSchemaHistory = await fetchContentSchemaHistory(propertyUrl, startDate, endDate);
                // Create maps of dates to scores from Supabase
                // Normalize dates to YYYY-MM-DD format (Supabase might return with timezone)
                contentSchemaHistory.forEach(record => {
                  // Ensure date is in YYYY-MM-DD format (strip time if present)
                  // Handle both date strings and Date objects
                  let normalizedDate = null;
                  if (record.date) {
                    if (typeof record.date === 'string') {
                      normalizedDate = record.date.split('T')[0];
                    } else if (record.date instanceof Date) {
                      normalizedDate = record.date.toISOString().split('T')[0];
                    } else {
                      normalizedDate = String(record.date).split('T')[0];
                    }
                  }
                  
                  if (normalizedDate) {
                    // Content/Schema data
                    if (record.contentSchemaScore !== null && record.contentSchemaScore !== undefined) {
                      contentSchemaMap.set(normalizedDate, record.contentSchemaScore);
                      debugLog(`Mapped Content/Schema: ${normalizedDate} = ${record.contentSchemaScore}`, 'info');
                    }
                    // Business Profile data (Local Entity and Service Area)
                    if (record.localEntityScore !== null && record.localEntityScore !== undefined) {
                      localEntityMap.set(normalizedDate, record.localEntityScore);
                      debugLog(`Mapped Local Entity: ${normalizedDate} = ${record.localEntityScore}`, 'info');
                    }
                    if (record.serviceAreaScore !== null && record.serviceAreaScore !== undefined) {
                      serviceAreaMap.set(normalizedDate, record.serviceAreaScore);
                      debugLog(`Mapped Service Area: ${normalizedDate} = ${record.serviceAreaScore}`, 'info');
                    }
                  }
                });
                
                const hasHistoricalData = contentSchemaHistory.length > 0;
                if (hasHistoricalData) {
                  debugLog(`Using ${contentSchemaHistory.length} historical audit records from Supabase`, 'info');
                } else {
                  debugLog(`No historical data found. Will use current scores for all points.`, 'info');
                }
              } catch (error) {
                debugLog(`‚ö† Error fetching historical data: ${error.message}`, 'warn');
                contentSchemaHistory = [];
              }
            } else {
              debugLog(`No property URL found. Cannot fetch historical data.`, 'info');
            }
            
            // Get current Business Profile data for Local Entity and Service Area (fallback if no historical data)
            const hasLocalSignals = saved && saved.localSignals && saved.localSignals.status === 'ok' && saved.localSignals.data;
            const localSignalsData = hasLocalSignals ? saved.localSignals.data : null;
            
            // Calculate current Local Entity and Service Area scores from Business Profile data (if available)
            // These will be used as fallback when historical data is not available for a specific date
            let currentLocalEntity, currentServiceArea;
            if (hasLocalSignals && localSignalsData) {
              // Local Entity: NAP consistency + bonuses
              let baseScore = localSignalsData.napConsistencyScore || 0;
              if (localSignalsData.knowledgePanelDetected) {
                baseScore = Math.min(100, baseScore + 10);
              }
              if (localSignalsData.locations && localSignalsData.locations.length > 0) {
                baseScore = Math.min(100, baseScore + 5);
              }
              currentLocalEntity = clampScore(baseScore);
              
              // Service Area: based on service areas count
              const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
              if (serviceAreasCount === 0) {
                currentServiceArea = 0;
              } else if (serviceAreasCount >= 8) {
                // 8+ service areas = 100 (more reasonable threshold)
                currentServiceArea = 100;
              } else {
                // Linear scale: 1 area = 12.5 points (8 areas = 100)
                currentServiceArea = Math.min(100, serviceAreasCount * 12.5);
              }
              
              // Apply NAP consistency as a multiplier (if NAP is low, reduce service area score)
              if (localSignalsData.napConsistencyScore !== null && localSignalsData.napConsistencyScore < 100) {
                const napMultiplier = localSignalsData.napConsistencyScore / 100;
                currentServiceArea = Math.round(currentServiceArea * napMultiplier);
              }
              currentServiceArea = clampScore(currentServiceArea);
              
              debugLog(`Trend chart: Current Business Profile data - Local Entity=${currentLocalEntity}, Service Area=${currentServiceArea} (used as fallback)`, 'info');
            } else {
              // Fallback: use derived calculation
              currentLocalEntity = null;
              currentServiceArea = null;
              debugLog('Trend chart: No Business Profile data available, will use derived calculation for dates without historical data', 'warn');
            }
            
            // Calculate pillar scores for each timeseries point
            // For Local Entity and Service Area: use historical Business Profile data if available,
            // otherwise use calculated data from GSC (derived calculation)
            const calculatePillarFromMetrics = (position, ctr, dateStr = null) => {
              // Position score (same formula as main calculation)
              const clampedPos = Math.max(1, Math.min(40, position));
              const scale = (clampedPos - 1) / 39;
              const posScore = 100 - scale * 90;
              
              // Authority: use exact formula with GSC values (same as main calculation)
              // Convert ctr from percentage (0-100) to decimal (0-1), then apply formula
              const ctrDecimal = ctr / 100; // Convert percentage to decimal (e.g., 10% -> 0.10)
              const ctrScore = Math.min((ctrDecimal / 0.10) * 100, 100);
              
              // Calculate each pillar (same formulas as main calculation)
              const visibility = clampScore(posScore);
              const authority = clampScore(0.6 * ctrScore + 0.4 * posScore);
              
              // For Local Entity and Service Area:
              // 1. Check for historical Business Profile data for this specific date
              // 2. If no historical data, use calculated data from GSC (derived calculation)
              // 3. Only use current Business Profile data as last resort (for recent dates without historical data)
              let localEntity, serviceArea;
              
              if (dateStr) {
                const historicalLocalEntity = localEntityMap.get(dateStr);
                const historicalServiceArea = serviceAreaMap.get(dateStr);
                
                if (historicalLocalEntity !== null && historicalLocalEntity !== undefined) {
                  // Use historical Business Profile data
                  localEntity = historicalLocalEntity;
                } else {
                  // Use calculated data from GSC (derived calculation) for historical dates
                  localEntity = clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
                }
                
                if (historicalServiceArea !== null && historicalServiceArea !== undefined) {
                  // Use historical Business Profile data
                  serviceArea = historicalServiceArea;
                } else {
                  // Use calculated data from GSC (derived calculation) for historical dates
                  serviceArea = clampScore(localEntity - 5);
                }
              } else {
                // No date provided - use current Business Profile data if available, otherwise calculated
                localEntity = currentLocalEntity !== null 
                  ? currentLocalEntity 
                  : clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
                serviceArea = currentServiceArea !== null 
                  ? currentServiceArea 
                  : clampScore(localEntity - 5);
              }
              
              return { visibility, authority, localEntity, serviceArea };
            };
            
            // Extract data arrays from timeseries
            localEntityData = [];
            serviceAreaData = [];
            authorityData = [];
            visibilityData = [];
            contentSchemaData = [];
            contentSchemaDataEstimated = []; // Reset array for timeseries data
            const allDateObjects = []; // Store Date objects for year detection
            const allDates = [];
            
            debugLog(`Content/Schema map has ${contentSchemaMap.size} entries: ${Array.from(contentSchemaMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
            debugLog(`Local Entity map has ${localEntityMap.size} entries: ${Array.from(localEntityMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
            debugLog(`Service Area map has ${serviceAreaMap.size} entries: ${Array.from(serviceAreaMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
            debugLog(`Timeseries has ${timeseries.length} points`, 'info');
            
            timeseries.forEach(point => {
              const pointDate = point.date; // YYYY-MM-DD format
              
              // Check if we have historical data from Supabase for Local Entity and Service Area
              const historicalLocalEntity = localEntityMap.get(pointDate);
              const historicalServiceArea = serviceAreaMap.get(pointDate);
              
              // Pass date to calculatePillarFromMetrics so it can check for historical data
              const pillarScores = calculatePillarFromMetrics(point.position, point.ctr, pointDate);
              
              // Use historical data from Supabase if available, otherwise use calculated scores
              if (historicalLocalEntity !== undefined && historicalLocalEntity !== null) {
                localEntityData.push(historicalLocalEntity);
                debugLog(`Content/Schema: Using historical Local Entity (${historicalLocalEntity}) for ${pointDate}`, 'info');
              } else {
                localEntityData.push(pillarScores.localEntity);
              }
              
              if (historicalServiceArea !== undefined && historicalServiceArea !== null) {
                serviceAreaData.push(historicalServiceArea);
                debugLog(`Content/Schema: Using historical Service Area (${historicalServiceArea}) for ${pointDate}`, 'info');
              } else {
                serviceAreaData.push(pillarScores.serviceArea);
              }
              
              authorityData.push(pillarScores.authority);
              visibilityData.push(pillarScores.visibility);
              
              // Check if we have real historical data for this date
              const realScore = contentSchemaMap.get(pointDate);
              
              if (realScore !== undefined && realScore !== null) {
                // We have real data for this date
                contentSchemaData.push(realScore);
                contentSchemaDataEstimated.push(null); // No estimated value
                debugLog(`Content/Schema: Added ${realScore} for ${pointDate}`, 'info');
              } else {
                // No real data for this date - use null (don't show estimated line)
                contentSchemaData.push(null);
                contentSchemaDataEstimated.push(null);
              }
              
              // Format date for chart (timeseries dates are YYYY-MM-DD)
              const dateObj = new Date(point.date);
              allDateObjects.push(dateObj);
              allDates.push(dateObj.toLocaleDateString('en-GB', dateFormat));
            });
            
            // Log Content/Schema data array summary after timeseries loop
            const contentSchemaValid = contentSchemaData.filter(v => v !== null && v !== undefined);
            debugLog(`Content/Schema data after timeseries: ${contentSchemaValid.length} valid values out of ${contentSchemaData.length} total. Values: ${contentSchemaValid.join(', ')}`, 'info');
            
            // Fill in missing dates between last GSC date and today
            // GSC data is delayed by 2-3 days, so we need to add missing dates
            // Reuse 'today' and 'todayStr' variables (already declared above)
            today = new Date();
            today.setHours(0, 0, 0, 0); // Normalize to start of day
            todayStr = today.toISOString().split('T')[0];
            const lastTimeseriesDate = timeseries.length > 0 ? timeseries[timeseries.length - 1].date : null;
            
            // Check if we're missing recent dates (likely due to GSC delay)
            let hasRecentMissingDates = false;
            if (lastTimeseriesDate) {
              const lastDate = new Date(lastTimeseriesDate);
              lastDate.setHours(0, 0, 0, 0);
              const daysSinceLastData = Math.floor((today - lastDate) / (1000 * 60 * 60 * 24));
              hasRecentMissingDates = daysSinceLastData > 1; // More than 1 day gap indicates GSC delay
              
              // Show a note about GSC delay if we're missing recent dates
              if (hasRecentMissingDates) {
                const trendCanvas = document.getElementById('trendChart');
                if (trendCanvas && trendCanvas.parentElement) {
                  // Check if note already exists
                  const existingNote = trendCanvas.parentElement.querySelector('.gsc-delay-note');
                  if (!existingNote) {
                    const noteDiv = document.createElement('div');
                    noteDiv.className = 'gsc-delay-note';
                    noteDiv.style.cssText = 'background: #e0f2fe; padding: 0.75rem; border-radius: 4px; border-left: 3px solid #0284c7; margin-bottom: 1rem; font-size: 0.85rem; color: #0c4a6e;';
                    noteDiv.innerHTML = `<strong>Note:</strong> Google Search Console data is typically delayed by 2-3 days. Recent dates (last ${daysSinceLastData} day${daysSinceLastData > 1 ? 's' : ''}) may show no data until GSC updates.`;
                    trendCanvas.parentElement.insertBefore(noteDiv, trendCanvas);
                  }
                }
              }
            }
            
            if (lastTimeseriesDate) {
              const lastDate = new Date(lastTimeseriesDate);
              lastDate.setHours(0, 0, 0, 0);
              
              debugLog(`Last GSC date: ${lastTimeseriesDate}, Today: ${todayStr}`, 'info');
              debugLog(`Content/Schema map has ${contentSchemaMap.size} entries before filling missing dates`, 'info');
              debugLog(`Content/Schema map entries: ${Array.from(contentSchemaMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
              
              // Add all missing dates from day after last GSC date to today
              const currentDate = new Date(lastDate);
              currentDate.setDate(currentDate.getDate() + 1); // Start from day after last GSC date
              
              // Compare dates as strings to avoid timezone issues
              const todayDateStr = today.toISOString().split('T')[0];
              
              while (currentDate.toISOString().split('T')[0] <= todayDateStr) {
                const dateStr = currentDate.toISOString().split('T')[0];
                const dateObj = new Date(dateStr);
                
                allDateObjects.push(dateObj);
                allDates.push(dateObj.toLocaleDateString('en-GB', dateFormat));
                
                // For GSC-based pillars (Authority, Visibility), add null (no data yet due to GSC delay)
                authorityData.push(null);
                visibilityData.push(null);
                
                // For Local Entity and Service Area, check if we have historical data from Supabase
                const historicalLocalEntity = localEntityMap.get(dateStr);
                const historicalServiceArea = serviceAreaMap.get(dateStr);
                
                if (historicalLocalEntity !== undefined && historicalLocalEntity !== null) {
                  localEntityData.push(historicalLocalEntity);
                  debugLog(`‚úì Added Local Entity score (${historicalLocalEntity}) for ${dateStr} from Supabase`, 'info');
                } else {
                  localEntityData.push(null);
                  debugLog(`No Local Entity data for ${dateStr}`, 'info');
                }
                
                if (historicalServiceArea !== undefined && historicalServiceArea !== null) {
                  serviceAreaData.push(historicalServiceArea);
                  debugLog(`‚úì Added Service Area score (${historicalServiceArea}) for ${dateStr} from Supabase`, 'info');
                } else {
                  serviceAreaData.push(null);
                  debugLog(`No Service Area data for ${dateStr}`, 'info');
                }
                
                // For Content/Schema, check if we have real data for this date
                const realScore = contentSchemaMap.get(dateStr);
                if (realScore !== undefined && realScore !== null) {
                  // We have real data for this date
                  contentSchemaData.push(realScore);
                  contentSchemaDataEstimated.push(null);
                  debugLog(`‚úì Added Content/Schema score (${realScore}) for ${dateStr} from Supabase`, 'info');
                } else {
                  // No real data - use null (don't show estimated)
                  contentSchemaData.push(null);
                  contentSchemaDataEstimated.push(null);
                  debugLog(`No Content/Schema data for ${dateStr} (checked map, not found)`, 'info');
                }
                
                // Move to next day
                currentDate.setDate(currentDate.getDate() + 1);
              }
              
              debugLog(`Filled missing dates: added ${allDateObjects.length - timeseries.length} additional dates`, 'info');
            } else if (timeseries.length === 0) {
              // No timeseries data at all - just add today
              const todayDateObj = new Date(todayStr);
              allDateObjects.push(todayDateObj);
              allDates.push(todayDateObj.toLocaleDateString('en-GB', dateFormat));
              
              // For GSC-based pillars (Authority, Visibility), add null
              authorityData.push(null);
              visibilityData.push(null);
              
              // For today, use current Business Profile data if available, otherwise calculated
              if (currentLocalEntity !== null) {
                localEntityData.push(currentLocalEntity);
              } else {
                localEntityData.push(null);
              }
              if (currentServiceArea !== null) {
                serviceAreaData.push(currentServiceArea);
              } else {
                serviceAreaData.push(null);
              }
              
              // For Content/Schema, check if we have real data for today
              const todayRealScore = contentSchemaMap.get(todayStr);
              if (todayRealScore !== undefined) {
                contentSchemaData.push(todayRealScore);
                contentSchemaDataEstimated.push(null);
                debugLog(`‚úì Added today's Content/Schema score (${todayRealScore}) from Supabase`, 'info');
              } else {
                contentSchemaData.push(null);
                contentSchemaDataEstimated.push(currentContentSchema);
                debugLog(`Using current Content/Schema score (${currentContentSchema}) as estimate for today`, 'info');
              }
            }
            
            // Apply label spacing to dates with year detection (show every labelStep-th label)
            let lastVisibleYear = null;
            chartDates = allDates.map((d, i) => {
              if (i % labelStep === 0 || i === allDates.length - 1) {
                const currentYear = allDateObjects[i].getFullYear();
                
                // Add year if it changed from the last visible label
                if (lastVisibleYear !== null && currentYear !== lastVisibleYear) {
                  lastVisibleYear = currentYear;
                  return `${d} ${currentYear}`;
                }
                
                lastVisibleYear = currentYear;
                return d;
              }
              return ''; // Empty string for labels we don't want to show
            });
            
            // Store date objects for timeseries data
            chartDateObjects = allDateObjects;
          } else {
            // No timeseries data available - use all nulls (no mock data)
            debugLog('No timeseries data available - chart will show empty with null values', 'warn');
            
            // Use all null values - no mock/estimated data
            localEntityData = new Array(numDataPoints).fill(null);
            serviceAreaData = new Array(numDataPoints).fill(null);
            authorityData = new Array(numDataPoints).fill(null);
            visibilityData = new Array(numDataPoints).fill(null);
            contentSchemaData = new Array(numDataPoints).fill(null);
            contentSchemaDataEstimated = new Array(numDataPoints).fill(null);
            
            // Generate dates for the date range
            const fallbackDates = [];
            const fallbackDateObjects = [];
            for (let i = 0; i < numDataPoints; i++) {
              const dateObj = new Date();
              if (dateRange <= 90) {
                // Daily data
                dateObj.setDate(dateObj.getDate() - (numDataPoints - 1 - i));
              } else {
                // Weekly data
                dateObj.setDate(dateObj.getDate() - ((numDataPoints - 1 - i) * 7));
              }
              fallbackDateObjects.push(dateObj);
              fallbackDates.push(dateObj.toLocaleDateString('en-GB', dateFormat));
            }
            chartDates = fallbackDates;
            chartDateObjects = fallbackDateObjects;
          }
          
          // Calculate min and max across all datasets (filter out null values)
          const allData = [...localEntityData, ...serviceAreaData, ...authorityData, ...visibilityData, ...contentSchemaData].filter(v => v !== null && v !== undefined && !isNaN(v));
          const dataMin = allData.length > 0 ? Math.min(...allData) : 0;
          const dataMax = allData.length > 0 ? Math.max(...allData) : 100;
          const dataRange = dataMax - dataMin;
          
          // Debug: Log Content/Schema data to see what we have
          const contentSchemaValid = contentSchemaData.filter(v => v !== null && v !== undefined && !isNaN(v));
          debugLog(`Content/Schema dataset: ${contentSchemaValid.length} valid values out of ${contentSchemaData.length} total. Values: ${contentSchemaValid.join(', ')}`, 'info');
          debugLog(`Content/Schema data array length: ${contentSchemaData.length}, chart dates length: ${chartDates.length}`, 'info');
          debugLog(`Last few Content/Schema values: ${contentSchemaData.slice(-5).join(', ')}`, 'info');
          debugLog(`Content/Schema map size: ${contentSchemaMap.size}, map entries: ${Array.from(contentSchemaMap.entries()).slice(-10).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
          
          // If Content/Schema has no valid data, log a warning
          if (contentSchemaValid.length === 0) {
            debugLog(`‚ö† WARNING: Content/Schema dataset has NO valid values! Map has ${contentSchemaMap.size} entries.`, 'error');
            debugLog(`Content/Schema history fetched: ${contentSchemaHistory.length} records`, 'info');
          }
          
          // Calculate dynamic Y-axis range
          // Minimum range of 30, or actual range + padding if larger
          const minRange = 30;
          const padding = 5; // Add 5 points padding above and below
          const actualRange = Math.max(minRange, dataRange + (padding * 2));
          
          // Calculate Y-axis min and max
          let yAxisMin = Math.max(0, Math.floor(dataMin - padding));
          // Ensure the red risk band (30-39) is always visible in the chart area
          // by never allowing the bottom of the axis to sit above 30.
          if (yAxisMin > 30) {
            yAxisMin = 30;
          }
          const yAxisMax = Math.min(100, Math.ceil(yAxisMin + actualRange));
          
          // Adjust step size based on range (smaller steps for smaller ranges)
          let stepSize = 10;
          if (actualRange <= 40) {
            stepSize = 5;
          } else if (actualRange <= 60) {
            stepSize = 10;
          } else {
            stepSize = 20;
          }
          
          debugLog(`Y-axis range: ${yAxisMin} to ${yAxisMax} (range: ${actualRange}, step: ${stepSize})`, 'info');
          
          // Calculate trend percentages for each dataset
          // Filter out null values to get actual first and last data points
          const calculateTrend = (data) => {
            // Filter out null/undefined values
            const validData = data.filter(v => v !== null && v !== undefined && !isNaN(v));
            if (validData.length < 2) return { percent: 0, isUp: false, isNeutral: true };
            
            const first = validData[0];
            const last = validData[validData.length - 1];
            
            // Handle division by zero (when first value is 0)
            if (first === 0) {
              // If first is 0 and last is also 0, no change
              if (last === 0) {
                return { percent: 0, isUp: false, isNeutral: true };
              }
              // If first is 0 but last has value, show as 100% increase
              return { percent: 100, isUp: true, isNeutral: false };
            }
            
            const percent = ((last - first) / first) * 100;
            
            // Handle NaN or infinite result
            if (isNaN(percent) || !isFinite(percent)) {
              return { percent: 0, isUp: false, isNeutral: true };
            }
            
            // Cap at 100% to avoid showing unrealistic percentages
            const cappedPercent = Math.min(Math.abs(percent), 100);
            // Consider values very close to 0 as neutral (within 0.1% threshold)
            const isNeutral = Math.abs(percent) < 0.1;
            return { 
              percent: cappedPercent, 
              isUp: percent > 0, 
              isNeutral: isNeutral 
            };
          };
          
          const localEntityTrend = calculateTrend(localEntityData);
          const serviceAreaTrend = calculateTrend(serviceAreaData);
          const authorityTrend = calculateTrend(authorityData);
          const visibilityTrend = calculateTrend(visibilityData);
          const contentSchemaTrend = calculateTrend(contentSchemaData);

          // Update HTML trend summary row
          const trendSummaryRow = document.getElementById('trendSummaryRow');
          if (trendSummaryRow) {
            const buildPill = (label, trend) => {
              let arrow, sign, cls;
              if (trend.isNeutral) {
                arrow = '‚Üí';
                sign = '';
                cls = 'neutral';
              } else {
                arrow = trend.isUp ? '‚Üë' : '‚Üì';
                sign = trend.isUp ? '+' : '';
                cls = trend.isUp ? 'up' : 'down';
              }
              return `
                <div class="trend-pill">
                  <span class="label">${label}</span>
                  <span class="value ${cls}">${arrow} ${sign}${trend.percent.toFixed(1)}%</span>
                </div>
              `;
            };
            trendSummaryRow.innerHTML = [
              buildPill('Local Entity', localEntityTrend),
              buildPill('Service Area', serviceAreaTrend),
              buildPill('Authority', authorityTrend),
              buildPill('Visibility', visibilityTrend),
              buildPill('Content/Schema', contentSchemaTrend)
            ].join('');
          }
          
          // Plugin to make year transition labels bold
          const yearLabelBoldPlugin = {
            id: 'yearLabelBold',
            afterDraw: (chart) => {
              const xScale = chart.scales.x;
              const ctx = chart.ctx;
              const rotation = -45 * (Math.PI / 180); // -45 degrees in radians
              
              // Get the chart dates array from the chart's data labels (original labels before callback)
              const chartDates = chart.data.labels || [];
              
              // Iterate through all data points to find year labels
              chartDates.forEach((originalLabel, dataIndex) => {
                // Check if original label contains a year (4-digit number at the end)
                if (originalLabel && /\d{4}$/.test(originalLabel)) {
                  const label = originalLabel;
                  // Get pixel position for this data point
                  const tickPosition = xScale.getPixelForValue(dataIndex);
                  const yPosition = chart.chartArea.bottom + 25;
                  
                  // Save context
                  ctx.save();
                  
                  // Translate to tick position and rotate
                  ctx.translate(tickPosition, yPosition);
                  ctx.rotate(rotation);
                  
                  // Set bold font with larger size
                  ctx.font = 'bold 14px Arial';
                  ctx.fillStyle = '#000';
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  
                  // Measure text to clear area properly
                  const metrics = ctx.measureText(label);
                  const textWidth = metrics.width;
                  const textHeight = 18;
                  
                  // Clear a larger area to remove the original label
                  ctx.globalCompositeOperation = 'destination-out';
                  ctx.fillRect(-textWidth/2 - 6, -textHeight/2 - 3, textWidth + 12, textHeight + 6);
                  
                  // Switch back to normal drawing
                  ctx.globalCompositeOperation = 'source-over';
                  
                  // Draw bold label
                  ctx.fillText(label, 0, 0);
                  
                  // Restore context
                  ctx.restore();
                }
              });
            }
          };
          
          // Plugin to add RAG background bands with stronger contrast
          const ragBackgroundPlugin = {
            id: 'ragBackground',
            beforeDraw: (chart) => {
              const ctx = chart.ctx;
              const chartArea = chart.chartArea;
              const yScale = chart.scales.y;
              
              // Red zone (0-39) - increased opacity and saturation
              if (yAxisMin <= 39) {
                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(0, yAxisMin)));
                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(39, yAxisMax)));
                ctx.fillStyle = 'rgba(220, 38, 38, 0.18)'; // More saturated red, higher opacity
                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
              }
              
              // Amber zone (40-69) - increased opacity and saturation
              if (yAxisMin <= 69 && yAxisMax >= 40) {
                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(40, yAxisMin)));
                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(69, yAxisMax)));
                ctx.fillStyle = 'rgba(234, 179, 8, 0.18)'; // More saturated amber/yellow, higher opacity
                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
              }
              
              // Green zone (70-100) - increased opacity and saturation
              if (yAxisMax >= 70) {
                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(70, yAxisMin)));
                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(100, yAxisMax)));
                ctx.fillStyle = 'rgba(22, 163, 74, 0.18)'; // More saturated green, higher opacity
                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
              }
            }
          };
          
          // Plugin to draw vertical dividing lines at period transitions (months and years)
          const periodDividingLinePlugin = {
            id: 'periodDividingLine',
            afterDraw: (chart) => {
              const xScale = chart.scales.x;
              const ctx = chart.ctx;
              const chartArea = chart.chartArea;
              
              // Detect period transitions (month and year changes)
              const periodTransitions = [];
              let lastMonth = null;
              let lastYear = null;
              
              // Use stored date objects to detect month/year changes
              chartDateObjects.forEach((dateObj, index) => {
                if (dateObj instanceof Date) {
                  const currentMonth = dateObj.getMonth(); // 0-11
                  const currentYear = dateObj.getFullYear();
                  
                  // Check for month or year transition
                  if (lastMonth !== null && lastYear !== null) {
                    if (currentYear !== lastYear || currentMonth !== lastMonth) {
                      periodTransitions.push(index);
                    }
                  }
                  
                  lastMonth = currentMonth;
                  lastYear = currentYear;
                }
              });
              
              // Draw vertical dotted lines at period transitions
              periodTransitions.forEach((dataIndex) => {
                // Get pixel position for this data point
                const tickPosition = xScale.getPixelForValue(dataIndex);
                
                // Only draw if within chart area horizontally
                if (tickPosition >= chartArea.left && tickPosition <= chartArea.right) {
                  ctx.save();
                  ctx.strokeStyle = 'rgba(120, 120, 120, 0.7)'; // Medium grey, more visible
                  ctx.lineWidth = 3; // Thicker lines
                  ctx.setLineDash([3, 4]); // Dotted line pattern
                  ctx.beginPath();
                  // Extend line beyond chart area to reach axis labels
                  const lineTop = chartArea.top - 10; // Extend above chart
                  const lineBottom = chartArea.bottom + 50; // Extend below chart to reach axis labels
                  ctx.moveTo(tickPosition, lineTop);
                  ctx.lineTo(tickPosition, lineBottom);
                  ctx.stroke();
                  ctx.restore();
                }
              });
            }
          };
          
          window.trendChart = new Chart(trendCtx, {
            type: 'line',
            data: {
              labels: chartDates,
              datasets: [
                {
                  label: 'Local Entity',
                  data: localEntityData,
                  borderColor: 'rgba(147, 51, 234, 1)', // Purple
                  backgroundColor: 'rgba(147, 51, 234, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5,
                  spanGaps: true // Connect across null values to show continuous line
                },
                {
                  label: 'Service Area',
                  data: serviceAreaData,
                  borderColor: 'rgba(20, 184, 166, 1)', // Teal
                  backgroundColor: 'rgba(20, 184, 166, 0.1)',
                  borderWidth: 2.5,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5,
                  spanGaps: true // Connect across null values to show continuous line
                },
                {
                  label: 'Authority',
                  data: authorityData,
                  borderColor: 'rgba(234, 179, 8, 1)', // Yellow
                  backgroundColor: 'rgba(234, 179, 8, 0.1)',
                  borderWidth: 4,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5
                  // No spanGaps - stop at last available GSC data (Dec 4)
                },
                {
                  label: 'Visibility',
                  data: visibilityData,
                  borderColor: 'rgba(37, 99, 235, 1)', // Blue
                  backgroundColor: 'rgba(59, 130, 246, 0.1)',
                  borderWidth: 2.5,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5
                  // No spanGaps - stop at last available GSC data (Dec 4)
                },
                {
                  label: 'Content / Schema',
                  data: contentSchemaData,
                  borderColor: 'rgba(107, 114, 128, 1)', // Grey
                  backgroundColor: 'rgba(107, 114, 128, 0.1)',
                  borderWidth: 2.5,
                  tension: 0.4,
                  pointRadius: 0, // Hide points - show as solid line
                  pointHoverRadius: 5,
                  spanGaps: true, // Connect across null values to show continuous line
                  pointBackgroundColor: 'rgba(107, 114, 128, 1)',
                  pointBorderColor: '#ffffff',
                  pointBorderWidth: 2
                }
              ]
            },
            plugins: [ragBackgroundPlugin, yearLabelBoldPlugin, periodDividingLinePlugin],
            options: {
              responsive: true,
              maintainAspectRatio: false,
              animation: false, // Disable animation for better performance when changing periods
              layout: {
                padding: {
                  bottom: 60, // Extra padding for rotated X-axis labels and extended lines
                  left: 10,
                  right: 10,
                  top: 10
                }
              },
              scales: {
                x: {
                  ticks: {
                    maxRotation: 45,
                    minRotation: 45,
                    font: {
                      size: 11,
                      weight: 'normal'
                    },
                    callback: function(value, index) {
                      // Only show non-empty labels
                      const label = this.getLabelForValue(value);
                      // Hide year labels (they'll be drawn by plugin in bold)
                      if (label && /\d{4}$/.test(label)) {
                        return ''; // Return empty to hide, plugin will draw it
                      }
                      return label || '';
                    }
                  },
                  grid: {
                    display: true,
                    color: 'rgba(0, 0, 0, 0.05)'
                  }
                },
                y: {
                  min: yAxisMin,
                  max: yAxisMax,
                  position: 'left',
                  ticks: {
                    stepSize: stepSize,
                    font: {
                      size: 12,
                      weight: 'bold'
                    }
                  },
                  grid: {
                    color: 'rgba(0, 0, 0, 0.1)',
                    drawBorder: true
                  }
                },
                y1: {
                  min: yAxisMin,
                  max: yAxisMax,
                  position: 'right',
                  ticks: {
                    stepSize: stepSize,
                    font: {
                      size: 12,
                      weight: 'bold'
                    }
                  },
                  grid: {
                    display: false,
                    drawBorder: false
                  }
                }
              },
              plugins: {
                legend: {
                  display: true,
                  position: 'top',
                  labels: {
                    font: {
                      size: 16,
                      weight: 'bold'
                    },
                    padding: 25,
                    usePointStyle: false,
                    boxWidth: 60,
                    boxHeight: 4,
                    // Use default legend labels (pillar names only, no trends)
                    generateLabels: function(chart) {
                      const original = Chart.defaults.plugins.legend.labels.generateLabels;
                      return original.call(this, chart);
                    }
                  }
                },
                tooltip: {
                  mode: 'index',
                  intersect: false
                }
              }
            }
          });
          debugLog('‚úì Trend chart created successfully', 'success');
          debugLog(`trendChart type after creation: ${typeof window.trendChart}`, 'info');
          debugLog(`trendChart instanceof Chart: ${window.trendChart instanceof Chart}`, 'info');
          debugLog(`Chart data points: Local Entity=${localEntityData.length}, Visibility=${visibilityData.length}, Authority=${authorityData.length}`, 'info');
          debugLog('=== DISPLAY DASHBOARD: Complete ===', 'success');
        } catch (e) {
          debugLog(`‚úó Error creating trend chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.error('Error creating trend chart:', e);
          // Show error message to user
          const trendCanvas = document.getElementById('trendChart');
          if (trendCanvas && trendCanvas.parentElement) {
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'background: #fee2e2; padding: 1rem; border-radius: 4px; border-left: 3px solid #ef4444; margin-bottom: 1rem; font-size: 0.9rem; color: #991b1b;';
            errorDiv.innerHTML = `<strong>Error loading trend chart:</strong> ${e.message}. Please refresh the page or run a new audit.`;
            trendCanvas.parentElement.insertBefore(errorDiv, trendCanvas);
          }
        }
      }, 100);
    }

    // Initialize on load
    window.addEventListener('DOMContentLoaded', () => {
      debugLog('=== PAGE LOAD: DOMContentLoaded event fired ===', 'info');
      debugLog(`Window location: ${window.location.href}`, 'info');
      debugLog(`User agent: ${navigator.userAgent}`, 'info');
      loadConfig();
      
      // Load and display last audit results if available
      // Wait a tick to ensure loadConfig() has finished updating the date range input
      setTimeout(() => {
        const savedAudit = loadAuditResults();
        if (savedAudit && savedAudit.scores && savedAudit.searchData) {
          // If saved audit has a date range, use it to set the input field and button
          // This ensures the UI matches the saved audit's date range
          if (savedAudit.dateRange) {
            const savedDateRange = savedAudit.dateRange;
            document.getElementById('dateRange').value = savedDateRange;
            // Update active button to match saved date range
            document.querySelectorAll('.date-range-btn').forEach(btn => {
              btn.classList.remove('active');
              const btnDays = parseInt(btn.getAttribute('data-days'));
              if (btnDays === savedDateRange) {
                btn.classList.add('active');
              }
            });
            // Update localStorage to match
            localStorage.setItem('gsc_date_range', savedDateRange);
            debugLog(`Set date range to ${savedDateRange} to match saved audit`, 'info');
          }
          
          // Now check if they match (they should, since we just set it)
          const currentDateRange = parseInt(document.getElementById('dateRange')?.value) || 30;
          const savedDateRange = savedAudit.dateRange || currentDateRange;
          
          debugLog(`Checking date range match: saved=${savedDateRange}, current=${currentDateRange}`, 'info');
          
          if (savedDateRange === currentDateRange) {
            debugLog('Loading last audit results from localStorage...', 'info');
            // Show dashboard immediately with saved results
            document.getElementById('dashboard').style.display = 'block';
            document.getElementById('loading').classList.remove('show');
            displayDashboard(
              savedAudit.scores,
              savedAudit.searchData,
              savedAudit.snippetReadiness || 0,
              savedAudit.schemaAudit || null
            );
            debugLog('‚úì Last audit results displayed', 'success');
          } else {
            debugLog(`Saved audit date range (${savedDateRange}) doesn't match current (${currentDateRange}). Dashboard not displayed.`, 'warn');
            // Don't show dashboard - user needs to run new audit
          }
        }
      }, 100); // Increased delay to ensure loadConfig completes
      
      debugLog('=== PAGE LOAD: Initialization complete ===', 'success');
    });

    // PDF Report Generation
    async function generatePDFReport() {
      console.log('[PDF] ===== PDF GENERATION STARTED =====');
      
      const btn = document.getElementById('generatePdfBtn');
      const statusDiv = document.getElementById('pdfStatus');
      
      if (!btn) {
        console.error('[PDF] Generate PDF button not found!');
        alert('Error: Generate PDF button not found. Please refresh the page.');
        return;
      }
      
      if (!statusDiv) {
        console.error('[PDF] PDF status div not found!');
      }
      
      // Check if html2pdf is available
      if (typeof html2pdf === 'undefined') {
        const errorMsg = '‚ùå PDF library not loaded. Please refresh the page.';
        if (statusDiv) {
          statusDiv.textContent = errorMsg;
          statusDiv.style.color = '#dc2626';
        }
        console.error('[PDF] html2pdf is not defined');
        alert(errorMsg);
        return;
      }
      
      console.log('[PDF] html2pdf library is available');
      
      // Check if dashboard has data
      const dashboard = document.getElementById('dashboard');
      if (!dashboard || dashboard.style.display === 'none') {
        const errorMsg = '‚ö†Ô∏è Please run an audit first to generate a report.';
        if (statusDiv) {
          statusDiv.textContent = errorMsg;
          statusDiv.style.color = '#dc2626';
        }
        console.warn('[PDF] Dashboard not available or hidden');
        return;
      }

      console.log('[PDF] Dashboard is available and visible');

      // Disable button and show status
      btn.disabled = true;
      btn.style.opacity = '0.6';
      if (statusDiv) {
        statusDiv.textContent = '‚è≥ Generating PDF report...';
        statusDiv.style.color = '#2563eb';
      }
      
      console.log('[PDF] Starting PDF generation process...');

      try {
        // Load saved audit data
        const savedAudit = loadAuditResults();
        if (!savedAudit || !savedAudit.scores) {
          throw new Error('No audit data available. Please run an audit first.');
        }

        // Get property URL and date range
        const propertyUrl = document.getElementById('propertyUrl')?.value || 'N/A';
        const dateRange = document.getElementById('dateRange')?.value || 30;
        const auditDate = savedAudit.auditDate || new Date().toISOString().split('T')[0];

        // Convert charts to images first (before creating HTML)
        console.log('[PDF] Converting charts to images...');
        
        // Create temporary canvas elements to capture charts
        const radarCanvas = document.getElementById('radarChart');
        const trendCanvas = document.getElementById('trendChart');
        const snippetCanvas = document.getElementById('snippetReadinessPieChart');
        
        let radarImgData = '';
        let trendImgData = '';
        let snippetImgData = '';
        
        if (radarCanvas && window.radarChart) {
          radarImgData = radarCanvas.toDataURL('image/png');
          console.log('[PDF] Radar chart converted to image');
        }
        
        if (trendCanvas && window.trendChart) {
          trendImgData = trendCanvas.toDataURL('image/png');
          console.log('[PDF] Trend chart converted to image');
        }
        
        if (snippetCanvas && window.snippetReadinessChart) {
          snippetImgData = snippetCanvas.toDataURL('image/png');
          console.log('[PDF] Snippet readiness chart converted to image');
        }

        // Create report HTML with embedded chart images
        console.log('[PDF] Creating report HTML...');
        const reportHTML = createReportHTML(savedAudit, propertyUrl, dateRange, auditDate, {
          radarChart: radarImgData,
          trendChart: trendImgData,
          snippetReadinessChart: snippetImgData
        });

        // Verify reportHTML has content
        if (!reportHTML || reportHTML.length < 100) {
          console.error('[PDF] Report HTML is empty or too short:', reportHTML ? reportHTML.length : 'null/undefined');
          throw new Error('Report HTML is empty or too short. Cannot generate PDF.');
        }
        
        console.log('[PDF] Report HTML created successfully');
        console.log('[PDF] Report HTML length:', reportHTML.length);
        console.log('[PDF] Report HTML starts with:', reportHTML.substring(0, 100));
        console.log('[PDF] Report HTML ends with:', reportHTML.substring(reportHTML.length - 100));
        
        // Check if reportHTML contains expected content
        if (!reportHTML.includes('AI GEO Audit Report')) {
          console.warn('[PDF] Warning: Report HTML may not contain expected content');
        }
        
        // Use Workshop Planner approach: exactly match printJourney pattern from print-export-dialog.tsx
        const printWindow = window.open('', '_blank');
        if (!printWindow) {
          throw new Error('Could not open print window. Please allow popups for this site.');
        }
        
        console.log('[PDF] Print window opened');
        console.log('[PDF] Writing HTML content (length:', reportHTML.length, ')');
        
        // Write the complete report HTML directly (it already includes full HTML structure)
        printWindow.document.write(reportHTML);
        printWindow.document.close();
        
        console.log('[PDF] HTML written and document closed');
        
        // Add a slight delay before triggering print to ensure content is fully loaded (exactly like printJourney)
        setTimeout(function() {
          try {
            console.log('[PDF] Attempting to print styled report...');
            printWindow.focus();
            printWindow.print();
            console.log('[PDF] Print dialog triggered');
            
            if (statusDiv) {
              statusDiv.textContent = '‚úÖ Print dialog opened. Save as PDF from the print dialog.';
              statusDiv.style.color = '#10b981';
              setTimeout(() => {
                statusDiv.textContent = '';
              }, 5000);
            }
          } catch (error) {
            console.error('[PDF] Print error:', error);
            if (statusDiv) {
              statusDiv.textContent = '‚ùå Error opening print dialog. Please try again.';
              statusDiv.style.color = '#dc2626';
            }
            alert('Failed to open print dialog: ' + error.message);
          }
        }, 1500); // Increased timeout to ensure content is fully loaded (matches printJourney)

      } catch (error) {
        console.error('[PDF] ===== PDF GENERATION ERROR =====');
        console.error('[PDF] Error message:', error.message);
        console.error('[PDF] Error stack:', error.stack);
        console.error('[PDF] Error object:', error);
        
        const errorMsg = `‚ùå Error: ${error.message}`;
        if (statusDiv) {
          statusDiv.textContent = errorMsg;
          statusDiv.style.color = '#dc2626';
        }
        
        // Also show alert so user definitely sees the error
        alert(`PDF Generation Failed:\n\n${error.message}\n\nCheck the browser console for more details.`);
      } finally {
        btn.disabled = false;
        btn.style.opacity = '1';
        console.log('[PDF] ===== PDF GENERATION COMPLETE =====');
      }
    }

    // Convert Chart.js charts to images
    async function convertChartsToImages(container) {
      console.log('[PDF] Converting charts to images...');
      
      // Convert radar chart
      const radarCanvas = document.getElementById('radarChart');
      if (radarCanvas && window.radarChart) {
        console.log('[PDF] Converting radar chart...');
        const radarImg = radarCanvas.toDataURL('image/png');
        const radarImgElement = container.querySelector('#radarChartImg');
        if (radarImgElement) {
          radarImgElement.src = radarImg;
          radarImgElement.style.display = 'block';
          console.log('[PDF] Radar chart image set, data URL length:', radarImg.length);
        } else {
          console.warn('[PDF] Radar chart image element not found in container');
        }
      } else {
        console.warn('[PDF] Radar chart canvas or chart instance not found');
      }

      // Convert trend chart
      const trendCanvas = document.getElementById('trendChart');
      if (trendCanvas && window.trendChart) {
        console.log('[PDF] Converting trend chart...');
        const trendImg = trendCanvas.toDataURL('image/png');
        const trendImgElement = container.querySelector('#trendChartImg');
        if (trendImgElement) {
          trendImgElement.src = trendImg;
          trendImgElement.style.display = 'block';
          console.log('[PDF] Trend chart image set, data URL length:', trendImg.length);
        } else {
          console.warn('[PDF] Trend chart image element not found in container');
        }
      } else {
        console.warn('[PDF] Trend chart canvas or chart instance not found');
      }

      // Convert snippet readiness chart
      const snippetCanvas = document.getElementById('snippetReadinessPieChart');
      if (snippetCanvas && window.snippetReadinessChart) {
        console.log('[PDF] Converting snippet readiness chart...');
        const snippetImg = snippetCanvas.toDataURL('image/png');
        const snippetImgElement = container.querySelector('#snippetReadinessChartImg');
        if (snippetImgElement) {
          snippetImgElement.src = snippetImg;
          snippetImgElement.style.display = 'block';
          console.log('[PDF] Snippet readiness chart image set, data URL length:', snippetImg.length);
        } else {
          console.warn('[PDF] Snippet readiness chart image element not found in container');
        }
      } else {
        console.warn('[PDF] Snippet readiness chart canvas or chart instance not found');
      }
      
      console.log('[PDF] Chart conversion complete');
    }

    // Create report HTML content
    function createReportHTML(auditData, propertyUrl, dateRange, auditDate, chartImages = {}) {
      const scores = auditData.scores || {};
      const searchData = auditData.searchData || {};
      const schemaAudit = auditData.schemaAudit || {};
      const snippetReadiness = auditData.snippetReadiness || 0;
      const localSignals = auditData.localSignals || null;
      const hasLocalSignals = localSignals && localSignals.status === 'ok' && localSignals.data;
      const localSignalsData = hasLocalSignals ? localSignals.data : null;

      // Helper function for RAG status
      const getRAGStatus = (score) => {
        if (score >= 70) return { color: '#10b981', label: 'Green', text: 'Good' };
        if (score >= 40) return { color: '#f59e0b', label: 'Amber', text: 'Needs Improvement' };
        return { color: '#ef4444', label: 'Red', text: 'Poor' };
      };

      // Get next steps (create a helper function similar to the one in displayDashboard)
      const getNextStepsForPDF = (scores, searchData, schemaAudit) => {
        const nextSteps = {};
        
        Object.entries(scores).forEach(([key, score]) => {
          const steps = [];
          
          switch(key) {
            case 'contentSchema':
              if (schemaAudit && schemaAudit.data) {
                const schemaData = schemaAudit.data;
                const { coverage, schemaTypes, richEligible } = schemaData;
                
                // Use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
                const allTypes = new Set();
                if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
                  // Use all detected types for accurate calculation
                  schemaData.allDetectedTypes.forEach(type => {
                    if (type) allTypes.add(type);
                  });
                } else if (schemaTypes && Array.isArray(schemaTypes)) {
                  // Fallback: collect from schemaTypes array (contains all types, sorted by count)
                  schemaTypes.forEach(item => {
                    if (item.type) allTypes.add(item.type);
                  });
                }
                
                const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
                const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
                const foundationMissing = foundationTypes.filter(type => !allTypes.has(type));
                
                if (foundationPresent < 4) {
                  steps.push(`Foundation schemas (30%): ${foundationPresent}/4 present. Add: ${foundationMissing.join(', ')}`);
                } else {
                  steps.push(`Foundation schemas (30%): All 4 present`);
                }
                
                const richEligibleCount = Object.values(richEligible || {}).filter(eligible => eligible === true).length;
                const richResultTypesCount = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList', 'Recipe'].length;
                if (richEligibleCount < richResultTypesCount) {
                  steps.push(`Rich results (35%): ${richEligibleCount}/${richResultTypesCount} eligible. Add more rich result types`);
                } else {
                  steps.push(`Rich results (35%): All ${richResultTypesCount} types eligible`);
                }
                
                if (coverage < 100) {
                  steps.push(`Coverage (20%): ${coverage.toFixed(1)}% - Add schema to pages without markup`);
                } else {
                  steps.push(`Coverage (20%): 100% - All pages have schema`);
                }
                
                const uniqueTypesCount = allTypes.size;
                if (uniqueTypesCount < 15) {
                  steps.push(`Diversity (15%): ${uniqueTypesCount} unique types. Add more schema types to reach 15+`);
                } else {
                  steps.push(`Diversity (15%): ${uniqueTypesCount} unique types (excellent)`);
                }
              } else {
                steps.push('Schema audit data not available - run audit to see detailed metrics');
              }
              break;
              
            case 'visibility':
              if (searchData) {
                const position = searchData.averagePosition || 0;
                const ctr = searchData.ctr || 0;
                
                if (position > 10) {
                  steps.push(`Average position: ${position.toFixed(1)} - Target top 10 positions`);
                } else {
                  steps.push(`Average position: ${position.toFixed(1)} - Excellent! Maintain top 10 rankings`);
                }
                
                if (ctr < 2.0) {
                  steps.push(`CTR: ${ctr.toFixed(2)}% - Improve click-through rate (target: 2%+)`);
                } else {
                  steps.push(`CTR: ${ctr.toFixed(2)}% - Good CTR! Continue optimizing`);
                }
              }
              break;
              
            case 'authority':
              if (searchData) {
                const ctr = searchData.ctr || 0;
                const position = searchData.averagePosition || 0;
                
                if (ctr < 1.5) {
                  steps.push(`CTR: ${ctr.toFixed(2)}% - Low click-through indicates trust issues. Improve E-A-T signals`);
                } else {
                  steps.push(`CTR: ${ctr.toFixed(2)}% - Good engagement. Build more backlinks to strengthen authority`);
                }
                
                if (position > 15) {
                  steps.push(`Position: ${position.toFixed(1)} - Improve rankings through comprehensive, expert content`);
                }
              }
              break;
              
            case 'localEntity':
              if (hasLocalSignals && localSignalsData) {
                const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                const locationsCount = localSignalsData.locations?.length || 0;
                const knowledgePanel = localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected';
                steps.push(`Current score: ${Math.round(score)} - Using real Business Profile data`);
                steps.push(`Data: NAP consistency: ${napScore}%, Knowledge panel: ${knowledgePanel}, Locations: ${locationsCount}`);
                if (score < 70) {
                  if (napScore < 100) {
                    steps.push(`Action: Improve NAP consistency (currently ${napScore}%)`);
                  }
                  if (!localSignalsData.knowledgePanelDetected) {
                    steps.push(`Action: Work on knowledge panel detection`);
                  }
                }
              } else {
                steps.push(`Current score: ${Math.round(score)} - Using derived calculation from search performance`);
                steps.push(`Priority: Integrate Google Business Profile API to use real local signals data`);
                if (score < 70) {
                  steps.push(`Action: Add LocalBusiness schema markup and ensure NAP consistency`);
                }
              }
              break;
              
            case 'serviceArea':
              if (hasLocalSignals && localSignalsData) {
                const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
                const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                steps.push(`Current score: ${Math.round(score)} - Using real Business Profile data`);
                steps.push(`Data: Service areas: ${serviceAreasCount}, NAP consistency: ${napScore}%`);
                if (score < 70) {
                  if (serviceAreasCount < 5) {
                    steps.push(`Action: Add more service areas (currently ${serviceAreasCount}, target: 5+)`);
                  }
                  if (napScore < 100) {
                    steps.push(`Action: Improve NAP consistency (currently ${napScore}%)`);
                  }
                }
              } else {
                steps.push(`Current score: ${Math.round(score)} - Using derived calculation from Local Entity`);
                steps.push(`Priority: Integrate Google Business Profile API to get real service area data`);
                if (score < 70) {
                  steps.push(`Action: Add ServiceArea schema and create location-specific pages`);
                }
              }
              break;
          }
          
          if (steps.length === 0) {
            if (score >= 70) {
              steps.push('Maintain current performance');
              steps.push('Monitor for any score drops');
            } else if (score >= 40) {
              steps.push('Focus on improving this pillar');
              steps.push('Review specific metrics above');
            } else {
              steps.push('Critical: Immediate action required');
              steps.push('Review all data sources and implement fixes');
            }
          }
          
          nextSteps[key] = steps;
        });
        
        return nextSteps;
      };
      
      const nextSteps = getNextStepsForPDF(scores, searchData, schemaAudit);

      return `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <style>
            body {
              font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
              color: #333;
              line-height: 1.6;
              margin: 0;
              padding: 0;
            }
            .report-header {
              text-align: center;
              border-bottom: 3px solid #f97316;
              padding-bottom: 20px;
              margin-bottom: 30px;
            }
            .report-header h1 {
              color: #f97316;
              margin: 0 0 10px 0;
              font-size: 28px;
            }
            .report-header .meta {
              color: #666;
              font-size: 14px;
            }
            .section {
              margin-bottom: 40px;
              page-break-inside: avoid;
            }
            .section-title {
              background: #f97316;
              color: white;
              padding: 12px 20px;
              margin: 0 0 20px 0;
              font-size: 20px;
              font-weight: bold;
              border-radius: 4px;
            }
            .pillar-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
              gap: 15px;
              margin-bottom: 30px;
            }
            .pillar-card {
              border: 2px solid #e2e8f0;
              border-radius: 8px;
              padding: 15px;
              background: #f8f9fa;
            }
            .pillar-card h3 {
              margin: 0 0 10px 0;
              font-size: 16px;
              color: #333;
            }
            .pillar-score {
              font-size: 36px;
              font-weight: bold;
              margin: 10px 0;
            }
            .rag-indicator {
              display: inline-block;
              width: 12px;
              height: 12px;
              border-radius: 50%;
              margin-right: 5px;
            }
            .metrics-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
              gap: 15px;
              margin-bottom: 30px;
            }
            .metric-card {
              border: 1px solid #e2e8f0;
              border-radius: 6px;
              padding: 15px;
              text-align: center;
              background: #ffffff;
            }
            .metric-value {
              font-size: 28px;
              font-weight: bold;
              color: #2563eb;
              margin: 10px 0;
            }
            .metric-label {
              color: #666;
              font-size: 14px;
            }
            .chart-container {
              text-align: center;
              margin: 30px 0;
              page-break-inside: avoid;
            }
            .chart-container img {
              max-width: 100%;
              height: auto;
              border: 1px solid #e2e8f0;
              border-radius: 4px;
            }
            .chart-title {
              font-size: 18px;
              font-weight: bold;
              margin-bottom: 15px;
              color: #333;
            }
            .definition-box {
              background: #f0f9ff;
              border-left: 4px solid #2563eb;
              padding: 15px;
              margin: 20px 0;
              border-radius: 4px;
            }
            .definition-box h4 {
              margin: 0 0 10px 0;
              color: #2563eb;
            }
            .next-steps {
              background: #fff7ed;
              border-left: 4px solid #f59e0b;
              padding: 15px;
              margin: 20px 0;
              border-radius: 4px;
            }
            .next-steps h4 {
              margin: 0 0 10px 0;
              color: #f59e0b;
            }
            .next-steps ul {
              margin: 10px 0;
              padding-left: 20px;
            }
            .next-steps li {
              margin: 8px 0;
            }
            table {
              width: 100%;
              border-collapse: collapse;
              margin: 20px 0;
            }
            table th, table td {
              border: 1px solid #e2e8f0;
              padding: 10px;
              text-align: left;
            }
            table th {
              background: #f8f9fa;
              font-weight: bold;
            }
            .footer {
              margin-top: 50px;
              padding-top: 20px;
              border-top: 1px solid #e2e8f0;
              text-align: center;
              color: #666;
              font-size: 12px;
            }
          </style>
        </head>
        <body>
          <div class="report-header">
            <h1>AI GEO Audit Report</h1>
            <div class="meta">
              <strong>Property:</strong> ${propertyUrl}<br>
              <strong>Date Range:</strong> Last ${dateRange} days<br>
              <strong>Audit Date:</strong> ${new Date(auditDate).toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' })}
            </div>
          </div>

          <!-- Executive Summary -->
          <div class="section">
            <div class="section-title">Executive Summary</div>
            <div style="margin-bottom: 20px;">
              <p><strong>Overall Snippet Readiness:</strong> <span style="font-size: 24px; font-weight: bold; color: ${getRAGStatus(snippetReadiness).color};">${snippetReadiness}%</span> 
              <span class="rag-indicator" style="background-color: ${getRAGStatus(snippetReadiness).color};"></span>${getRAGStatus(snippetReadiness).text}</p>
              <p>The Snippet Readiness score indicates how likely your content is to appear in featured snippets and AI answers. It combines Content/Schema (40%), Visibility (35%), and Authority (25%).</p>
            </div>
          </div>

          <!-- Pillar Scores -->
          <div class="section">
            <div class="section-title">Pillar Scores Overview</div>
            <div class="pillar-grid">
              ${Object.entries(scores).map(([key, score]) => {
                const rag = getRAGStatus(score);
                const pillarNames = {
                  localEntity: 'Local Entity',
                  serviceArea: 'Service Area',
                  authority: 'Authority',
                  visibility: 'Visibility',
                  contentSchema: 'Content/Schema'
                };
                return `
                  <div class="pillar-card">
                    <h3>${pillarNames[key] || key}</h3>
                    <div class="pillar-score" style="color: ${rag.color};">${score}%</div>
                    <div>
                      <span class="rag-indicator" style="background-color: ${rag.color};"></span>
                      <strong>${rag.label}</strong> - ${rag.text}
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>

          <!-- Charts -->
          <div class="section">
            <div class="section-title">Visual Analytics</div>
            
            <div class="chart-container">
              <div class="chart-title">Pillar Scores Radar Chart</div>
              ${chartImages.radarChart ? '<img src="' + chartImages.radarChart + '" alt="Radar Chart" style="max-width: 600px; margin: 0 auto; display: block;">' : '<p style="color: #999;">Chart not available</p>'}
              <p style="color: #666; font-size: 14px; margin-top: 10px;">Radar chart showing current performance across all five pillars. The larger the area, the stronger your overall entity recognition.</p>
            </div>
            
            <div class="chart-container">
              <div class="chart-title">Performance Trends</div>
              ${chartImages.trendChart ? '<img src="' + chartImages.trendChart + '" alt="Trend Chart" style="max-width: 100%; margin: 0 auto; display: block;">' : '<p style="color: #999;">Chart not available</p>'}
              <p style="color: #666; font-size: 14px; margin-top: 10px;">Historical performance trends showing clicks, impressions, CTR, position, and Content/Schema scores over the selected date range.</p>
            </div>
            
            <div class="chart-container">
              <div class="chart-title">Snippet Readiness Gauge</div>
              ${chartImages.snippetReadinessChart ? '<img src="' + chartImages.snippetReadinessChart + '" alt="Snippet Readiness Chart" style="max-width: 500px; margin: 0 auto; display: block;">' : '<p style="color: #999;">Chart not available</p>'}
              <p style="color: #666; font-size: 14px; margin-top: 10px;">Nested doughnut chart showing weighted breakdown of snippet readiness components with actual performance scores.</p>
            </div>
          </div>

          <!-- Metrics -->
          <div class="section">
            <div class="section-title">Key Metrics</div>
            <div class="metrics-grid">
              <div class="metric-card">
                <div class="metric-value">${(searchData.totalClicks || 0).toLocaleString()}</div>
                <div class="metric-label">Total Clicks</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(searchData.totalImpressions || 0).toLocaleString()}</div>
                <div class="metric-label">Total Impressions</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(searchData.ctr || 0).toFixed(2)}%</div>
                <div class="metric-label">Average CTR</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(searchData.averagePosition || 0).toFixed(1)}</div>
                <div class="metric-label">Average Position</div>
              </div>
            </div>
          </div>

          <!-- Pillar Definitions -->
          <div class="section">
            <div class="section-title">Pillar Definitions & Current Status</div>
            ${Object.entries(scores).map(([key, score]) => {
              const rag = getRAGStatus(score);
              const pillarNames = {
                localEntity: 'Local Entity',
                serviceArea: 'Service Area',
                authority: 'Authority',
                visibility: 'Visibility',
                contentSchema: 'Content/Schema'
              };
              // Build definitions dynamically based on whether we have real Business Profile data
              let localEntityDef, serviceAreaDef;
              if (hasLocalSignals && localSignalsData) {
                const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
                const locationsCount = localSignalsData.locations?.length || 0;
                localEntityDef = `Measures how well your business is recognized as a local entity. Uses real data from Google Business Profile API: NAP consistency (${napScore}%), knowledge panel (${localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected'}), locations (${locationsCount}).`;
                serviceAreaDef = `Assesses your service area coverage and geographic relevance. Uses real data from Google Business Profile API: ${serviceAreasCount} service areas, NAP consistency (${napScore}%).`;
              } else {
                localEntityDef = 'Measures how well your business is recognized as a local entity. Based on LocalBusiness schema presence, NAP consistency, and knowledge panel detection. Currently uses derived calculations from GSC data.';
                serviceAreaDef = 'Assesses your service area coverage and geographic relevance. Derived from Local Entity score. Will use real service area data when Google Business Profile API is integrated.';
              }
              
              const definitions = {
                localEntity: localEntityDef,
                serviceArea: serviceAreaDef,
                authority: 'Evaluates your domain authority and trust signals. Calculated from CTR (60%) and average position (40%). Will include backlink metrics when backlink API is integrated.',
                visibility: 'Tracks your search visibility and ranking performance. Based on average position from Google Search Console (1 = best, 40 = worst). Score ranges from 10 to 100.',
                contentSchema: 'Measures schema markup quality and completeness. Weighted calculation: Foundation Schemas (30%), Rich Results (35%), Coverage (20%), Diversity (15%).'
              };
              return `
                <div class="definition-box">
                  <h4>${pillarNames[key] || key} - ${score}% 
                    <span class="rag-indicator" style="background-color: ${rag.color};"></span>${rag.label}
                  </h4>
                  <p>${definitions[key] || 'No definition available.'}</p>
                </div>
              `;
            }).join('')}
          </div>

          <!-- Next Steps -->
          <div class="section">
            <div class="section-title">Recommended Next Steps</div>
            ${Object.entries(nextSteps).map(([pillar, steps]) => {
              if (!steps || steps.length === 0) return '';
              const pillarNames = {
                localEntity: 'Local Entity',
                serviceArea: 'Service Area',
                authority: 'Authority',
                visibility: 'Visibility',
                contentSchema: 'Content/Schema'
              };
              return `
                <div class="next-steps">
                  <h4>${pillarNames[pillar] || pillar}</h4>
                  <ul>
                    ${steps.map(step => `<li>${step}</li>`).join('')}
                  </ul>
                </div>
              `;
            }).join('')}
          </div>

          <!-- Schema Audit Summary -->
          ${schemaAudit.data ? `
          <div class="section">
            <div class="section-title">Schema Audit Summary</div>
            <div class="metrics-grid">
              <div class="metric-card">
                <div class="metric-value">${schemaAudit.data.totalPages || 0}</div>
                <div class="metric-label">Total Pages Scanned</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${schemaAudit.data.pagesWithSchema || 0}</div>
                <div class="metric-label">Pages With Schema</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(schemaAudit.data.coverage || 0).toFixed(1)}%</div>
                <div class="metric-label">Schema Coverage</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(schemaAudit.data.schemaTypes || []).length}</div>
                <div class="metric-label">Schema Types Found</div>
              </div>
            </div>
            ${schemaAudit.data.missingSchemaPages && schemaAudit.data.missingSchemaPages.length > 0 ? `
              <div style="margin-top: 20px;">
                <h4>Pages Missing Schema (${schemaAudit.data.missingSchemaPages.length}):</h4>
                <ul style="font-size: 12px; max-height: 200px; overflow-y: auto;">
                  ${schemaAudit.data.missingSchemaPages.slice(0, 20).map(url => `<li>${url}</li>`).join('')}
                  ${schemaAudit.data.missingSchemaPages.length > 20 ? `<li><em>... and ${schemaAudit.data.missingSchemaPages.length - 20} more</em></li>` : ''}
                </ul>
              </div>
            ` : ''}
          </div>
          ` : ''}

          <!-- Top Queries -->
          ${searchData.topQueries && searchData.topQueries.length > 0 ? `
          <div class="section">
            <div class="section-title">Top Queries</div>
            <table>
              <thead>
                <tr>
                  <th>Query</th>
                  <th>Clicks</th>
                  <th>Impressions</th>
                  <th>CTR</th>
                  <th>Position</th>
                </tr>
              </thead>
              <tbody>
                ${searchData.topQueries.slice(0, 20).map(query => `
                  <tr>
                    <td>${query.query || 'N/A'}</td>
                    <td>${(query.clicks || 0).toLocaleString()}</td>
                    <td>${(query.impressions || 0).toLocaleString()}</td>
                    <td>${(query.ctr || 0).toFixed(2)}%</td>
                    <td>${(query.position || 0).toFixed(1)}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
          ` : ''}

          <div class="footer">
            <p>Generated by AI GEO Audit Dashboard on ${new Date().toLocaleString('en-GB')}</p>
            <p>This report contains data from Google Search Console API and schema audit results.</p>
          </div>
        </body>
        </html>
      `;
    }
  </script>
</body>
</html>

