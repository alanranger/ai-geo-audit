<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>GAIO (Generative AI Optimization) Audit Dashboard - Automated GAIO Performance Tracking</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script>
    // Try to load config.js if it exists (for local development)
    // Note: config.js is gitignored and won't be deployed to Vercel
    // Silently fail if config.js doesn't exist (expected on Vercel)
    try {
      // First check if file exists via fetch to avoid syntax errors
      fetch('config.js')
        .then(response => {
          if (response.ok && response.headers.get('content-type')?.includes('javascript')) {
      const configScript = document.createElement('script');
      configScript.src = 'config.js';
            configScript.type = 'text/javascript';
      configScript.onerror = function() {
              // Silently ignore
      };
      document.head.appendChild(configScript);
          }
        })
        .catch(() => {
          // Silently ignore - config.js is optional
        });
    } catch (e) {
      // Silently ignore - config.js is optional
    }
  </script>
  <style>
    :root {
      --brand-orange: #E57200;
      --brand-dark: #222222;
      --brand-grey: #555555;
      --bg-page: #f2f2f2;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      
      /* Dark theme variables (from admin.html) */
      --dark-bg: #0f1419;
      --dark-panel: #1a1f2e;
      --dark-text: #e2e8f0;
      --dark-text-muted: #9ca3af;
      --dark-brand: #f59e0b;
      --dark-border: #374151;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg-page);
      color: var(--brand-dark);
      line-height: 1.5;
    }
    .header {
      background: linear-gradient(135deg, var(--brand-orange) 0%, #ff8c42 100%);
      color: white;
      padding: 2rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .header h1 {
      margin: 0 0 0.5rem 0;
      font-size: 2rem;
    }
    .header p {
      margin: 0;
      opacity: 0.9;
    }
    .container {
      max-width: 1800px;
      margin: 0 auto;
      padding: 2rem;
      padding-bottom: 60px; /* Space for debug panel */
    }
    .config-panel {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      margin-bottom: 2rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .config-panel h2 {
      margin: 0 0 1rem 0;
      color: var(--brand-dark);
      font-size: 1.25rem;
    }
    .form-group {
      margin-bottom: 1rem;
    }
    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      color: var(--brand-grey);
    }
    .form-group input {
      width: 100%;
      padding: 0.75rem;
      border: 2px solid #e2e8f0;
      border-radius: 6px;
      font-size: 1rem;
    }
    .form-group input:focus {
      outline: none;
      border-color: var(--brand-orange);
    }
    .btn {
      background: var(--brand-orange);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    .btn:hover {
      background: #d46200;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    .btn-secondary {
      background: var(--brand-grey);
    }
    .btn-secondary:hover {
      background: #444;
    }
    .status {
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      display: none;
    }
    .status.success {
      background: #d1fae5;
      color: #065f46;
      border-left: 4px solid var(--success);
    }
    .status.error {
      background: #fee2e2;
      color: #991b1b;
      border-left: 4px solid var(--danger);
    }
    .status.info {
      background: #dbeafe;
      color: #1e40af;
      border-left: 4px solid #3b82f6;
    }
    .status.show {
      display: block;
    }
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    .pillar-card {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: relative;
      display: flex;
      flex-direction: column;
      min-height: 100%; /* Ensure all cards have same minimum height */
    }
    .pillar-card h3 {
      margin: 0 0 0.75rem 0;
      color: var(--brand-dark);
      font-size: 1.1rem;
    }
    .pillar-score {
      font-size: 3rem;
      font-weight: 700;
      margin: 0.5rem 0;
      line-height: 1;
    }
    .pillar-score.rag-red {
      color: var(--danger);
    }
    .pillar-score.rag-amber {
      color: var(--warning);
    }
    .pillar-score.rag-green {
      color: var(--success);
    }
    .rag-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.875rem;
      font-weight: 600;
      margin-top: 0.75rem;
      margin-bottom: 0.5rem;
    }
    .rag-badge.red {
      background: #fee2e2;
      color: #991b1b;
    }
    .rag-badge.amber {
      background: #fef3c7;
      color: #92400e;
    }
    .rag-badge.green {
      background: #d1fae5;
      color: #065f46;
    }
    .chart-container {
      background: linear-gradient(135deg, #f0f4f8 0%, #e2e8f0 100%);
      padding: 1.5rem;
      padding-bottom: 12rem; /* Extra padding at bottom for rotated 45-degree axis labels - need significant space for diagonal labels */
      padding-right: 3rem; /* Extra padding on right for Y-axis labels */
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 6rem; /* extra breathing room below charts */
      height: 1000px; /* Doubled from 500px to 1000px for better chart visibility and less bunching */
      min-height: 1000px; /* Ensure minimum height */
      border: 1px solid rgba(100, 116, 139, 0.2);
      overflow: hidden; /* Change to hidden to clip content that extends beyond container */
    }
    .chart-container.large {
      height: 1200px;
      min-height: 1200px;
      padding: 2rem;
    }
    .dashboard-two-column {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-three-column {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-four-column {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    @media (max-width: 1200px) {
      .dashboard-four-column {
        grid-template-columns: repeat(2, 1fr);
      }
      .dashboard-three-column {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    @media (max-width: 768px) {
      .dashboard-two-column,
      .dashboard-three-column,
      .dashboard-four-column {
        grid-template-columns: 1fr;
      }
    }
    .chart-container h3 {
      margin: 0 0 0.5rem 0;
      color: var(--brand-dark);
    }
    .chart-container p {
      margin: 0 0 1rem 0;
    }
    .trend-summary-row {
      display: flex;
      gap: 1.5rem;
      font-size: 0.9rem;
      margin-bottom: 0.75rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .trend-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.7);
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.06);
      border: 1px solid rgba(148, 163, 184, 0.3);
    }
    .trend-pill span.label {
      font-weight: 600;
      color: #374151;
    }
    .trend-pill span.value.up {
      font-weight: 700;
      color: #10b981; /* green */
    }
    .trend-pill span.value.down {
      font-weight: 700;
      color: #ef4444; /* red */
    }
    .trend-pill span.value.neutral {
      font-weight: 700;
      color: #1f2937; /* black/dark gray for no change */
    }
    .metrics-section {
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border: 1px solid rgba(59, 130, 246, 0.1);
    }
    .scorecard-section {
      margin-top: 4rem;  /* push scorecard further below charts */
      margin-bottom: 3rem;
    }
    
    /* Override for scorecard sections inside ranking-ai-detail-content */
    .ranking-ai-detail-content .scorecard-section {
      margin-top: 0;
      margin-bottom: 1.0rem !important;
    }
    
    .ranking-ai-detail-content .scorecard-section:last-child {
      margin-bottom: 0 !important;
    }
    .scorecard-section h3 {
      margin-bottom: 1.5rem;
    }
    .metrics-section {
      margin-top: 3rem;
      margin-bottom: 3rem;
    }
    .metrics-section h3 {
      margin-bottom: 1.5rem;
    }
    .section-break {
      margin-top: 4rem;
      margin-bottom: 4rem;
      border-top: 2px solid #e2e8f0;
      padding-top: 2rem;
    }
    .calculation-explanation {
      background: #f8f9fa;
      border: 2px solid var(--brand-orange);
      border-radius: 8px;
      margin-bottom: 2rem;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(229, 114, 0, 0.15);
    }
    .calculation-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: linear-gradient(135deg, #fff5f0 0%, #ffe8d6 100%);
      border-bottom: 2px solid var(--brand-orange);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    .calculation-explanation.collapsed .calculation-header {
      border-bottom: none;
    }
    .calculation-header:hover {
      background: linear-gradient(135deg, #ffe8d6 0%, #ffd9b3 100%);
    }
    .calculation-header h4 {
      margin: 0;
      color: var(--brand-orange);
      font-size: 1.1rem;
      font-weight: 600;
    }
    .calculation-toggle {
      font-size: 1.2rem;
      color: var(--brand-orange);
      font-weight: bold;
      transition: transform 0.3s;
    }
    .calculation-explanation.collapsed .calculation-toggle {
      transform: rotate(-90deg);
    }
    .calculation-content {
      padding: 1.5rem;
      color: #555;
      line-height: 1.8;
    }
    .calculation-content.collapsed {
      display: none;
    }
    .csv-upload-section {
      background: #f8f9fa;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      margin-bottom: 1rem;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .csv-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: #f8f9fa;
      border-bottom: 2px solid #e2e8f0;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    .csv-upload-section.collapsed .csv-section-header {
      border-bottom: none;
    }
    .csv-section-header:hover {
      background: #f0f0f0;
    }
    .csv-section-header h3 {
      margin: 0;
      color: #1e293b;
      font-size: 1rem;
      font-weight: 600;
    }
    .csv-section-toggle {
      font-size: 1rem;
      color: #64748b;
      font-weight: bold;
      transition: transform 0.3s;
    }
    .csv-upload-section.collapsed .csv-section-toggle {
      transform: rotate(-90deg);
    }
    .csv-section-content {
      padding: 1rem;
    }
    .csv-section-content.collapsed {
      display: none;
    }
    .calculation-content h5 {
      color: var(--brand-dark);
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-size: 1rem;
      font-weight: 600;
      border-bottom: 2px solid var(--brand-orange);
      padding-bottom: 0.5rem;
    }
    .calculation-content h5:first-child {
      margin-top: 0;
    }
    .calculation-content ul {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
    }
    .calculation-content li {
      margin: 0.5rem 0;
    }
    .calculation-content code {
      background: #e2e8f0;
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #c53030;
    }
    .calculation-content .formula {
      background: #f0f4f8;
      padding: 0.75rem;
      border-left: 3px solid var(--brand-orange);
      margin: 0.75rem 0;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
    }
    .calculation-content .note {
      background: #fff3cd;
      border-left: 3px solid #f59e0b;
      padding: 0.75rem;
      margin: 1rem 0;
      font-size: 0.9rem;
    }
    .date-range-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .date-range-btn {
      padding: 0.5rem 1rem;
      border: 2px solid #e2e8f0;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    .date-range-btn:hover {
      border-color: var(--brand-orange);
      background: #fff5f0;
    }
    .date-range-btn.active {
      background: var(--brand-orange);
      color: white;
      border-color: var(--brand-orange);
    }
    .snippet-readiness-gauge {
      background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 3rem;
      border: 1px solid rgba(16, 185, 129, 0.1);
    }
    .gauge-container {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      flex: 1;
      position: relative;
    }
    .gauge-wrapper {
      position: relative;
      width: 300px;
      height: 300px;
    }
    .gauge-svg {
      transform: rotate(-90deg);
      width: 100%;
      height: 100%;
    }
    .gauge-background {
      fill: none;
      stroke: #e2e8f0;
      stroke-width: 20;
    }
    .gauge-fill {
      fill: none;
      stroke-width: 20;
      stroke-linecap: round;
      transition: stroke-dashoffset 1s ease-in-out;
    }
    .gauge-fill.green {
      stroke: #10b981;
    }
    .gauge-fill.amber {
      stroke: #f59e0b;
    }
    .gauge-fill.red {
      stroke: #ef4444;
    }
    .gauge-value {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      font-weight: 700;
      text-align: center;
      z-index: 10;
    }
    .gauge-value.green {
      color: #10b981;
    }
    .gauge-value.amber {
      color: #f59e0b;
    }
    .gauge-value.red {
      color: #ef4444;
    }
    .gauge-label {
      text-align: center;
      color: var(--brand-grey);
      margin-top: 1rem;
      font-size: 1rem;
      font-weight: 600;
    }
    .gauge-status {
      text-align: center;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      font-weight: 500;
    }
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }
    .metric-card {
      background: white;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
    }
    .metric-card .value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--brand-orange);
      margin: 0.5rem 0;
    }
    .metric-card .label {
      color: var(--brand-grey);
      font-size: 0.875rem;
    }
    .metric-label {
      color: var(--brand-grey);
      font-size: 0.875rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    .metric-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--brand-orange);
      margin: 0.5rem 0;
    }
    .metric-sub {
      color: var(--brand-grey);
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }
    .url-cell {
      max-width: 300px;
    }
    .url-main {
      font-weight: 600;
      color: #333;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .url-sub {
      font-size: 0.75rem;
      color: #666;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-top: 0.25rem;
    }
    .money-recommendation {
      font-size: 0.875rem;
      line-height: 1.5;
      color: #555;
      max-width: 400px;
    }
    .loading {
      display: none;
      text-align: center;
      padding: 2rem;
    }
    .loading.show {
      display: block;
    }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--brand-orange);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .progress-container {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1rem 0;
    }
    .progress-bar-wrapper {
      width: 100%;
      background: #e2e8f0;
      border-radius: 10px;
      height: 24px;
      overflow: hidden;
      margin: 1rem 0;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--brand-orange), #ff8c42);
      border-radius: 10px;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 0.85rem;
      min-width: 0;
    }
    .progress-status {
      font-size: 0.95rem;
      color: #555;
      margin-top: 0.5rem;
      font-weight: 500;
    }
    /* Full-page overlay for domain strength snapshot */
    .domain-strength-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      z-index: 9999;
      display: none;
      align-items: center;
      justify-content: center;
    }
    .domain-strength-overlay.show {
      display: flex;
    }
    .domain-strength-overlay-content {
      background: white;
      border-radius: 12px;
      padding: 2.5rem 3rem;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      text-align: center;
      max-width: 400px;
    }
    .domain-strength-overlay-content .spinner {
      width: 48px;
      height: 48px;
      border-width: 5px;
      margin: 0 auto 1.5rem;
    }
    .domain-strength-overlay-content h3 {
      margin: 0 0 0.75rem 0;
      font-size: 1.25rem;
      font-weight: 700;
      color: #1e293b;
    }
    .domain-strength-overlay-content p {
      margin: 0;
      font-size: 0.95rem;
      color: #64748b;
      line-height: 1.6;
    }
    /* Sticky positioning for domain strength table */
    #domain-strength-table thead {
      position: sticky;
      top: 0;
      z-index: 10;
      background: #f8fafc;
    }
    #domain-strength-table thead th {
      background: #f8fafc;
    }
    #domain-strength-self-row {
      position: sticky;
      top: 40px; /* Adjust based on header height */
      z-index: 9;
      background: #fefce8 !important;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      overflow: auto;
    }
    .modal-content {
      background-color: white;
      margin: 5% auto;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      animation: modalSlideIn 0.3s ease;
    }
    @keyframes modalSlideIn {
      from {
        transform: translateY(-50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    .ranking-ai-step-item {
      display: flex;
      align-items: center;
      padding: 0.75rem;
      border-radius: 6px;
      background-color: #f9fafb;
      transition: all 0.2s ease;
    }
    .ranking-ai-step-item.active {
      background-color: #fef3c7;
      border-left: 4px solid var(--brand-orange);
    }
    .ranking-ai-step-item.completed {
      background-color: #d1fae5;
      border-left: 4px solid #10b981;
    }
    .ranking-ai-step-item.pending {
      opacity: 0.5;
    }
    .ranking-ai-step-icon {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 0.75rem;
      font-weight: bold;
      font-size: 0.85rem;
    }
    .ranking-ai-step-item.pending .ranking-ai-step-icon {
      background-color: #e5e7eb;
      color: #9ca3af;
    }
    .ranking-ai-step-item.active .ranking-ai-step-icon {
      background-color: var(--brand-orange);
      color: white;
      animation: pulse 1.5s ease-in-out infinite;
    }
    .ranking-ai-step-item.completed .ranking-ai-step-icon {
      background-color: #10b981;
      color: white;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    .ranking-ai-step-label {
      flex: 1;
      font-size: 0.9rem;
      color: #374151;
    }
    .ranking-ai-step-item.completed .ranking-ai-step-label {
      color: #059669;
    }
    .ranking-ai-step-item.active .ranking-ai-step-label {
      color: #92400e;
      font-weight: 600;
    }
    .help-text {
      font-size: 0.875rem;
      color: var(--brand-grey);
      margin-top: 0.25rem;
    }

    .debug-panel-bottom {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1a1a1a;
      border-top: 3px solid #E57200;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      z-index: 1000;
      box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.5);
      max-height: 50vh;
      display: flex;
      flex-direction: column;
    }

    .debug-panel-bottom.collapsed {
      max-height: 50px;
    }

    .debug-panel-bottom.collapsed .debug-content {
      display: none !important;
    }

    .debug-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #333;
      background: #252525;
      user-select: none;
    }

    .debug-header h3 {
      margin: 0;
      color: #fff;
      font-size: 1rem;
    }

    .debug-actions {
      display: flex;
      gap: 0.5rem;
    }

    .btn-small {
      padding: 0.25rem 0.75rem;
      font-size: 0.75rem;
      background: #333;
      color: #fff;
      border: 1px solid #555;
    }

    .btn-small:hover {
      background: #444;
    }

    .debug-content {
      color: #fff;
      line-height: 1.6;
      padding: 1rem;
      overflow-y: auto;
      flex: 1;
      max-height: calc(50vh - 60px);
    }

    .debug-log-entry {
      margin-bottom: 0.25rem;
      padding: 0.25rem 0;
      border-left: 2px solid transparent;
      padding-left: 0.5rem;
    }

    .debug-log-entry.error {
      color: #f44;
      border-left-color: #f44;
    }

    .debug-log-entry.warn {
      color: #fa4;
      border-left-color: #fa4;
    }

    .debug-log-entry.info {
      color: #9cf;
      border-left-color: #4af;
    }

    .debug-log-entry.success {
      color: #9f9;
      border-left-color: #4f4;
    }

    .debug-timestamp {
      color: #aaa;
      margin-right: 0.5rem;
    }

    /* Sidebar Layout */
    .aigeo-layout {
      display: flex;
      min-height: calc(100vh - 120px); /* Account for header */
    }

    .aigeo-sidebar {
      width: 260px;
      background: linear-gradient(180deg, #ffffff 0%, #f8f9fa 100%);
      border-right: 2px solid #e2e8f0;
      padding: 1.5rem 0;
      position: sticky;
      top: 0;
      height: calc(100vh - 120px);
      overflow-y: auto;
      flex-shrink: 0;
      box-shadow: 2px 0 8px rgba(0,0,0,0.05);
    }

    .aigeo-nav-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      width: 100%;
      padding: 0.875rem 1.5rem;
      background: none;
      border: none;
      text-align: left;
      font-size: 0.95rem;
      font-weight: 500;
      color: #64748b;
      cursor: pointer;
      transition: all 0.2s ease;
      border-left: 4px solid transparent;
      position: relative;
    }

    .aigeo-nav-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0;
      background: var(--brand-orange);
      transition: width 0.2s ease;
    }

    .aigeo-nav-item:hover {
      background: linear-gradient(90deg, #fff5f0 0%, #ffffff 100%);
      color: var(--brand-dark);
      padding-left: 1.75rem;
    }

    .aigeo-nav-item.is-active {
      background: linear-gradient(90deg, #fff5f0 0%, #ffffff 100%);
      color: var(--brand-orange);
      border-left-color: var(--brand-orange);
      font-weight: 600;
      box-shadow: inset 0 0 0 1px rgba(229, 114, 0, 0.1);
    }

    .aigeo-nav-item.is-active::before {
      width: 4px;
    }

    .aigeo-nav-icon {
      font-size: 1.25rem;
      width: 24px;
      text-align: center;
      flex-shrink: 0;
    }

    .aigeo-main {
      flex: 1;
      overflow-y: auto;
      padding: 2rem;
      padding-bottom: 60px; /* Space for debug panel */
    }

    .aigeo-panel {
      display: none;
    }

    .aigeo-panel.is-active {
      display: block;
    }

    /* Ensure ranking panel uses block layout when active, not flex */
    .aigeo-panel[data-panel="ranking"].is-active {
      display: block !important;
    }

    /* Ensure ranking panel children stack vertically, but allow metric pills, side-by-side cards, and details grid to use their layouts */
    .aigeo-panel[data-panel="ranking"] > .ranking-metric-pills {
      display: grid !important;
    }

    .aigeo-panel[data-panel="ranking"] > .ranking-details-grid {
      display: grid !important;
    }

    .aigeo-panel[data-panel="ranking"] > .ranking-cards-side-by-side {
      display: flex !important;
    }

    .aigeo-panel[data-panel="ranking"] > *:not(.ranking-metric-pills):not(.ranking-cards-side-by-side):not(.ranking-priority-matrix-section):not(.ranking-table-section):not(.ranking-details-grid) {
      width: 100% !important;
      display: block !important;
      clear: both !important;
      float: none !important;
    }

    /* Ranking & AI Tab Styles */
    .ranking-pillars-note {
      font-size: 0.9rem;
      color: #64748b;
      margin: 0.75rem 0;
      line-height: 1.6;
    }

    .ranking-intro {
      margin-top: 0.25rem;
      font-size: 1rem;
      color: #4b5563;
      max-width: 56rem;
    }

    .ranking-intro-bullets {
      margin: 0.25rem 0 0.5rem;
      padding-left: 1.25rem;
      font-size: 0.95rem;
      color: #6b7280;
    }

    .ranking-intro-bullets li {
      margin-bottom: 0.1rem;
    }

    .ranking-header-actions {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-top: 0.4rem;
    }

    /* Section B: Metric pills - all 5 on one row */
    .ranking-metric-pills {
      display: grid !important;
      grid-template-columns: repeat(5, 1fr) !important;
      gap: 1rem;
      margin-top: 1rem;
      margin-bottom: 1.5rem;
      width: 100%;
      grid-auto-flow: row;
    }

    .ranking-metric-pills > .metric-pill {
      display: block;
      width: 100%;
      min-width: 0;
    }

    /* For medium screens, reduce gap but keep all 5 in one row */
    @media (min-width: 769px) and (max-width: 1400px) {
      .ranking-metric-pills {
        grid-template-columns: repeat(5, 1fr);
        gap: 0.75rem;
      }
    }

    /* Only wrap on very small screens */
    @media (max-width: 768px) {
      .ranking-metric-pills {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    .metric-pill {
      background: #ffffff;
      border-radius: 8px;
      padding: 1rem 1.25rem;
      box-shadow: 0 1px 3px rgba(15, 23, 42, 0.06);
      transition: all 0.2s ease;
      border-left: 4px solid transparent;
    }
    
    .metric-pill--active {
      background: #1e40af !important;
      color: #ffffff !important;
      box-shadow: 0 2px 6px rgba(30, 64, 175, 0.3);
      border-left-color: #1e3a8a;
      font-weight: 600;
    }
    
    .metric-pill--active span,
    .metric-pill--active .optimisation-tab-count {
      color: #ffffff !important;
    }
    
    .metric-pill--active:hover {
      background: #1e3a8a !important;
    }

    .metric-pill--green {
      background: #f0fdf4;
      border-left-color: #16a34a;
    }

    .metric-pill--amber {
      background: #fffbeb;
      border-left-color: #f59e0b;
    }

    .metric-pill--red {
      background: #fef2f2;
      border-left-color: #dc2626;
    }

    .metric-pill--neutral {
      background: #f9fafb;
      border-left-color: #6b7280;
    }

    .metric-pill-value {
      font-size: 2rem;
      font-weight: 700;
      margin: 0.25rem 0;
      color: #1e293b;
    }

    .metric-pill-label {
      font-size: 1rem;
      font-weight: 600;
      color: #374151;
      margin-bottom: 0.25rem;
    }

    .metric-pill-status {
      font-size: 0.85rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.7rem;
      border-radius: 999px;
      margin: 0.25rem 0;
    }

    /* ============================================
       OPTIMISATION MODULE - DARK THEME
       ============================================ */
    
    /* Dark background for entire optimisation section - fill full width of main content area */
    section[data-panel="optimisation"] {
      background: var(--dark-bg) !important;
      min-height: calc(100vh - 4rem);
      position: relative;
      color: var(--dark-text) !important;
      width: calc(100vw - 260px); /* Full viewport width minus sidebar */
      margin-left: calc(-50vw + 50% + 130px); /* Position to start after sidebar */
      margin-right: calc(-50vw + 50% - 130px);
      padding: 2rem;
      box-sizing: border-box;
    }
    
    section[data-panel="optimisation"] * {
      color: inherit;
    }
    
    /* Section header */
    section[data-panel="optimisation"] .card--section-header {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
    }
    
    section[data-panel="optimisation"] .card--section-header h2 {
      color: var(--dark-brand) !important;
      margin: 0 0 0.5rem 0;
    }
    
    section[data-panel="optimisation"] .card--section-header p {
      color: var(--dark-text-muted) !important;
      margin: 0;
    }
    
    /* Buttons */
    section[data-panel="optimisation"] .btn {
      background: var(--dark-brand) !important;
      color: #000 !important;
      border: none !important;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    section[data-panel="optimisation"] .btn:hover {
      background: #d97706 !important;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
    }
    
    /* Optimisation module tiles - dark theme with green centered counts and orange hover animation */
    .optimisation-summary-cards .card,
    .optimisation-kpi-tiles .card {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px;
      padding: 1.5rem;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    /* Bronze/Silver/Gold backgrounds for Estimated Extra Clicks ONLY */
    #impact-extra-clicks-card.impact-bronze {
      background: linear-gradient(135deg, #cd7f32 0%, #b87333 100%) !important;
      border: 1px solid #a0652a !important;
      color: #ffffff !important;
    }
    
    #impact-extra-clicks-card.impact-bronze * {
      color: #ffffff !important;
    }
    
    #impact-extra-clicks-card.impact-silver {
      background: linear-gradient(135deg, #c0c0c0 0%, #a8a8a8 100%) !important;
      border: 1px solid #909090 !important;
      color: #1a1a1a !important;
    }
    
    #impact-extra-clicks-card.impact-silver * {
      color: #1a1a1a !important;
    }
    
    #impact-extra-clicks-card.impact-gold {
      background: linear-gradient(135deg, #ffd700 0%, #ffb700 100%) !important;
      border: 1px solid #e6a600 !important;
      color: #1a1a1a !important;
    }
    
    #impact-extra-clicks-card.impact-gold * {
      color: #1a1a1a !important;
    }
    
    .optimisation-impact-tiles .card:not(.impact-bronze):not(.impact-silver):not(.impact-gold) {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px;
      padding: 1.5rem;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    /* Task Details Modal/Drawer - Dark Theme */
    #optimisation-task-drawer {
      background: var(--dark-panel) !important;
      color: var(--dark-text) !important;
    }
    
    #optimisation-task-drawer * {
      color: var(--dark-text) !important;
    }
    
    #optimisation-drawer-header-bar {
      background: var(--dark-panel) !important;
      border-bottom: 1px solid var(--dark-border) !important;
    }
    
    #optimisation-drawer-header-bar h3 {
      color: var(--dark-text) !important;
    }
    
    #optimisation-drawer-header-bar button {
      color: var(--dark-text-muted) !important;
    }
    
    #optimisation-drawer-header-bar button:hover {
      color: var(--dark-text) !important;
    }
    
    /* Modal sections with light backgrounds */
    #optimisation-task-drawer div[style*="background: #fff5f5"],
    #optimisation-task-drawer div[style*="background: #f8f9fa"],
    #optimisation-task-drawer div[style*="background: white"] {
      background: var(--dark-panel) !important;
      border-color: var(--dark-border) !important;
    }
    
    /* Input fields */
    #optimisation-task-drawer input,
    #optimisation-task-drawer select,
    #optimisation-task-drawer textarea {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    #optimisation-task-drawer input::placeholder,
    #optimisation-task-drawer textarea::placeholder {
      color: var(--dark-text-muted) !important;
    }
    
    /* Labels and strong text */
    #optimisation-task-drawer strong,
    #optimisation-task-drawer label {
      color: var(--dark-text) !important;
    }
    
    /* Divs with muted colors */
    #optimisation-task-drawer div[style*="color: #666"],
    #optimisation-task-drawer div[style*="color: #475569"] {
      color: var(--dark-text-muted) !important;
    }
    
    /* Links */
    #optimisation-task-drawer a {
      color: var(--dark-brand) !important;
    }
    
    /* Buttons - use proper dark backgrounds with white text for readability */
    #optimisation-task-drawer .btn,
    #optimisation-task-drawer button.btn {
      background: var(--dark-brand) !important;
      color: #ffffff !important;
      border: 1px solid var(--dark-brand) !important;
      font-weight: 700 !important;
    }
    
    #optimisation-task-drawer .btn:hover,
    #optimisation-task-drawer button.btn:hover {
      background: #f59e0b !important;
      color: #ffffff !important;
      border-color: #f59e0b !important;
    }
    
    #optimisation-task-drawer .btn-secondary,
    #optimisation-task-drawer button.btn-secondary {
      background: #4b5563 !important;
      color: #ffffff !important;
      border: 1px solid #4b5563 !important;
      font-weight: 700 !important;
    }
    
    #optimisation-task-drawer .btn-secondary:hover,
    #optimisation-task-drawer button.btn-secondary:hover {
      background: #6b7280 !important;
      color: #ffffff !important;
      border-color: #6b7280 !important;
    }
    
    /* Specific button IDs - dark backgrounds with white text */
    #optimisation-cancel-task-btn,
    #optimisation-delete-task-btn {
      background: #dc2626 !important;
      color: #ffffff !important;
      border: 1px solid #dc2626 !important;
      font-weight: 700 !important;
    }
    
    #optimisation-cancel-task-btn:hover,
    #optimisation-delete-task-btn:hover {
      background: #b91c1c !important;
      color: #ffffff !important;
      border-color: #b91c1c !important;
    }
    
    #optimisation-complete-cycle-btn {
      background: #059669 !important;
      color: #ffffff !important;
      border: 1px solid #059669 !important;
      font-weight: 700 !important;
    }
    
    #optimisation-complete-cycle-btn:hover {
      background: #047857 !important;
      color: #ffffff !important;
      border-color: #047857 !important;
    }
    
    #optimisation-archive-cycle-btn {
      background: #4b5563 !important;
      color: #ffffff !important;
      border: 1px solid #4b5563 !important;
      font-weight: 700 !important;
    }
    
    #optimisation-archive-cycle-btn:hover {
      background: #6b7280 !important;
      color: #ffffff !important;
      border-color: #6b7280 !important;
    }
    
    #optimisation-add-event-btn,
    #optimisation-save-status-btn {
      background: var(--dark-brand) !important;
      color: #ffffff !important;
      border: 1px solid var(--dark-brand) !important;
      font-weight: 700 !important;
    }
    
    #optimisation-add-event-btn:hover,
    #optimisation-save-status-btn:hover {
      background: #f59e0b !important;
      color: #ffffff !important;
      border-color: #f59e0b !important;
    }
    
    /* Buttons with orange/yellow backgrounds need BLACK text for readability */
    #optimisation-edit-objective-btn,
    #optimisation-add-measurement-btn,
    #optimisation-save-objective-btn {
      background: var(--dark-brand) !important;
      color: #000000 !important;
      border: 1px solid var(--dark-brand) !important;
      font-weight: 700 !important;
    }
    
    #optimisation-edit-objective-btn:hover,
    #optimisation-add-measurement-btn:hover,
    #optimisation-save-objective-btn:hover {
      background: #f59e0b !important;
      color: #000000 !important;
      border-color: #f59e0b !important;
    }
    
    /* Status badges and pills */
    #optimisation-task-drawer span[style*="background: #f0f0f0"] {
      background: rgba(156, 163, 175, 0.2) !important;
      color: var(--dark-text) !important;
    }
    
    /* Table borders and backgrounds */
    #optimisation-task-drawer table,
    #optimisation-task-drawer th,
    #optimisation-task-drawer td {
      border-color: var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    #optimisation-task-drawer th {
      background: var(--dark-bg) !important;
    }
    
    /* Timeline border */
    #optimisation-drawer-events-container div[style*="border-left"] {
      border-left-color: var(--dark-border) !important;
    }

    .optimisation-summary-cards .card::before,
    .optimisation-kpi-tiles .card::before,
    .optimisation-impact-tiles .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--dark-brand);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }

    .optimisation-summary-cards .card:hover,
    .optimisation-kpi-tiles .card:hover,
    .optimisation-impact-tiles .card:not(.impact-bronze):not(.impact-silver):not(.impact-gold):hover {
      border-color: var(--dark-brand) !important;
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(245, 158, 11, 0.2);
      animation: wobble 0.5s ease-in-out;
    }

    @keyframes wobble {
      0%, 100% { transform: translateY(-4px) rotate(0deg); }
      25% { transform: translateY(-4px) rotate(-1deg); }
      75% { transform: translateY(-4px) rotate(1deg); }
    }

    .optimisation-summary-cards .card:hover::before,
    .optimisation-kpi-tiles .card:hover::before,
    .optimisation-impact-tiles .card:not(.impact-bronze):not(.impact-silver):not(.impact-gold):hover::before {
      transform: scaleX(1);
    }
    
    /* Traffic light pills - same styling as other cards */
    .traffic-light-pill {
      background: var(--dark-panel) !important;
      border: 2px solid var(--dark-border) !important;
      border-radius: 12px !important;
      padding: 1rem !important;
      transition: all 0.3s ease !important;
      position: relative !important;
      overflow: visible !important;
      text-align: center !important;
      cursor: pointer !important;
      z-index: 1 !important;
    }
    
    .traffic-light-pill::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--dark-brand);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }
    
    .traffic-light-pill:hover {
      border-color: var(--dark-brand) !important;
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(245, 158, 11, 0.2);
      animation: wobble 0.5s ease-in-out;
    }
    
    .traffic-light-pill:hover::before {
      transform: scaleX(1);
    }
    
    /* Restore background colors on hover based on bucket */
    .traffic-light-pill[data-bucket="worse"]:hover {
      background: rgba(239, 68, 68, 0.3) !important;
    }
    
    .traffic-light-pill[data-bucket="same"]:hover {
      background: rgba(245, 158, 11, 0.3) !important;
    }
    
    .traffic-light-pill[data-bucket="better"]:hover {
      background: rgba(16, 185, 129, 0.3) !important;
    }

    /* Green centered count values (like analytics.html) - no background */
    .optimisation-summary-cards .card > div:first-child,
    .optimisation-kpi-tiles .card > div:first-child,
    .optimisation-impact-tiles .card > div:first-child {
      font-size: 2.5rem !important;
      font-weight: 700 !important;
      color: var(--success) !important;
      margin-bottom: 0.5rem;
      text-align: center;
      background: transparent !important;
      padding: 0 !important;
    }

    /* Labels - no background */
    .optimisation-summary-cards .card > div:last-child,
    .optimisation-kpi-tiles .card > div:last-child,
    .optimisation-impact-tiles .card > div:last-child {
      color: var(--dark-text-muted) !important;
      font-size: 0.9rem;
      text-align: center;
      background: transparent !important;
      padding: 0 !important;
    }

    /* Goal rollup badges */
    section[data-panel="optimisation"] .optimisation-goal-rollups {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      border-radius: 8px;
      padding: 1rem;
      margin: 1.5rem 0;
    }
    
    section[data-panel="optimisation"] .optimisation-goal-rollups > div:first-child {
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .ranking-badge {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
      transition: all 0.2s;
    }
    
    section[data-panel="optimisation"] .ranking-badge:hover {
      border-color: var(--dark-brand) !important;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.2);
    }
    
    /* Scope toggle */
    section[data-panel="optimisation"] .optimisation-scope-toggle {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-scope-toggle label {
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-scope-toggle select {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-scope-toggle span {
      color: var(--dark-text-muted) !important;
    }
    
    /* Tab pills */
    section[data-panel="optimisation"] .optimisation-tab-pills {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      border-radius: 8px;
      padding: 1rem;
      margin: 1.5rem 0;
    }
    
    section[data-panel="optimisation"] .optimisation-tab-btn {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-tab-btn:hover {
      border-color: var(--dark-brand) !important;
      background: rgba(245, 158, 11, 0.1) !important;
    }
    
    section[data-panel="optimisation"] .metric-pill--active {
      background: var(--dark-brand) !important;
      border-color: var(--dark-brand) !important;
      color: #000 !important;
      animation: wobble 0.5s ease-in-out;
    }
    
    /* Tables */
    section[data-panel="optimisation"] .ranking-table-wrapper {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      border-radius: 8px;
      overflow: hidden;
    }
    
    section[data-panel="optimisation"] .ranking-table {
      background: var(--dark-panel) !important;
    }
    
    section[data-panel="optimisation"] .ranking-table thead th {
      background: var(--dark-bg) !important;
      color: #ffffff !important;
      border-bottom: 1px solid var(--dark-border) !important;
      font-weight: 600;
    }
    
    /* Sort indicators and info icons - white */
    section[data-panel="optimisation"] .ranking-table thead th .sort-indicator,
    section[data-panel="optimisation"] .ranking-table thead th i,
    section[data-panel="optimisation"] .ranking-table thead th [class*="icon"],
    section[data-panel="optimisation"] .ranking-table thead th::after {
      color: #ffffff !important;
      opacity: 0.8;
    }
    
    section[data-panel="optimisation"] .ranking-table thead th:hover .sort-indicator,
    section[data-panel="optimisation"] .ranking-table thead th:hover i {
      opacity: 1;
    }
    
    /* Table cells - no darker background, transparent */
    section[data-panel="optimisation"] .ranking-table tbody td {
      background: transparent !important;
      color: var(--dark-text) !important;
      border-bottom: 1px solid var(--dark-border) !important;
    }
    
    /* Remove any background from text/spans inside cells */
    section[data-panel="optimisation"] .ranking-table tbody td *,
    section[data-panel="optimisation"] .ranking-table tbody td span,
    section[data-panel="optimisation"] .ranking-table tbody td strong,
    section[data-panel="optimisation"] .ranking-table tbody td div {
      background: transparent !important;
    }
    
    /* Ensure all text in table cells is readable */
    section[data-panel="optimisation"] .ranking-table tbody td {
      background: transparent !important;
    }
    
    section[data-panel="optimisation"] .ranking-table tbody td strong {
      color: var(--dark-text) !important;
      background: transparent !important;
    }
    
    section[data-panel="optimisation"] .ranking-table tbody tr:hover {
      background: rgba(255, 255, 255, 0.05) !important;
    }
    
    section[data-panel="optimisation"] .ranking-table tbody tr:hover td {
      background: rgba(255, 255, 255, 0.05) !important;
    }
    
    section[data-panel="optimisation"] .ranking-table-empty {
      color: var(--dark-text-muted) !important;
      background: transparent !important;
    }
    
    /* Pagination */
    section[data-panel="optimisation"] #optimisation-pagination-controls {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      border-radius: 8px;
      padding: 1rem;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] #optimisation-pagination-controls button,
    section[data-panel="optimisation"] #optimisation-pagination-controls select {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] #optimisation-pagination-controls button:hover {
      border-color: var(--dark-brand) !important;
      background: rgba(245, 158, 11, 0.1) !important;
    }
    
    /* Charts container */
    section[data-panel="optimisation"] .optimisation-timeseries-charts .card {
      background: var(--dark-panel) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] .optimisation-timeseries-charts h3 {
      color: #ffffff !important;
      font-size: 1.2rem !important;
      font-weight: 600;
    }
    
    /* Chart text - bright white and larger */
    section[data-panel="optimisation"] canvas {
      color: #ffffff !important;
    }
    
    /* Chart axis labels and text - white and larger */
    section[data-panel="optimisation"] #chart-measurements-per-week,
    section[data-panel="optimisation"] #chart-median-delta {
      color: #ffffff !important;
    }
    
    /* Filters and inputs */
    section[data-panel="optimisation"] input[type="text"],
    section[data-panel="optimisation"] input[type="checkbox"],
    section[data-panel="optimisation"] select {
      background: var(--dark-bg) !important;
      border: 1px solid var(--dark-border) !important;
      color: var(--dark-text) !important;
    }
    
    section[data-panel="optimisation"] input[type="text"]:focus,
    section[data-panel="optimisation"] select:focus {
      border-color: var(--dark-brand) !important;
      outline: none;
    }
    
    /* Remove border-left from inline styles */
    .optimisation-summary-cards .card[style*="border-left"],
    .optimisation-kpi-tiles .card[style*="border-left"],
    .optimisation-impact-tiles .card[style*="border-left"] {
      border-left: 2px solid var(--dark-border) !important;
    }

    .metric-pill--green .metric-pill-status {
      background: #dcfce7;
      color: #166534;
    }

    .metric-pill--amber .metric-pill-status {
      background: #fef3c7;
      color: #92400e;
    }

    .metric-pill--red .metric-pill-status {
      background: #fee2e2;
      color: #b91c1c;
    }

    .metric-pill--neutral .metric-pill-status {
      background: #e5e7eb;
      color: #4b5563;
    }

    .metric-pill-footer {
      font-size: 0.85rem;
      color: #6b7280;
      margin-top: 0.5rem;
      line-height: 1.4;
    }

    .metric-pill-toggle {
      font-size: 0.85rem;
      color: #0284c7;
      cursor: pointer;
      margin-top: 0.5rem;
      text-decoration: underline;
      user-select: none;
    }

    .metric-pill-toggle:hover {
      color: #0369a1;
    }

    .metric-pill-details {
      display: none;
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid #e5e7eb;
    }

    .metric-pill-details.expanded {
      display: block;
    }

    /* ============================================
       AI Sources & Influence tab: layout styling
       ============================================ */
    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer {
      background: #fffbeb;
      border-left: 4px solid #f59e0b;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer .card-header {
      padding: 1.25rem 1.5rem 0.75rem 1.5rem;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer .card-header h3 {
      color: #92400e;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer .card-body {
      padding: 1.25rem 1.5rem;
      color: #78350f;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-explainer ul {
      padding-left: 1.5rem;
      margin: 0.25rem 0;
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-domain-table-card {
      background: rgba(204, 255, 255, 0.15);
      border-left: 4px solid #CCFFFF;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .aigeo-panel[data-panel="ai-sources"] .ai-sources-domain-table-card .card-header {
      background: transparent;
    }

    /* AI sources table: alignment + hover highlight */
    #ai-sources-table th:nth-child(1),
    #ai-sources-table td:nth-child(1),
    #ai-sources-table th:nth-child(2),
    #ai-sources-table td:nth-child(2),
    #ai-sources-table th:nth-child(6),
    #ai-sources-table td:nth-child(6) {
      text-align: left !important;
    }

    #ai-sources-table th:nth-child(3),
    #ai-sources-table td:nth-child(3),
    #ai-sources-table th:nth-child(4),
    #ai-sources-table td:nth-child(4),
    #ai-sources-table th:nth-child(5),
    #ai-sources-table td:nth-child(5) {
      text-align: right !important;
    }

    #ai-sources-table tbody tr:hover td {
      background: #eff6ff !important;
    }

    /* Tile details styling */
    .tile-details-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: #374151;
      margin: 0 0 0.75rem 0;
      line-height: 1.5;
    }

    .tile-details-list {
      list-style: none;
      padding: 0;
      margin: 0 0 0.75rem 0;
    }

    .tile-details-list li {
      font-size: 0.875rem;
      color: #4b5563;
      line-height: 1.8;
      margin-bottom: 0.5rem;
    }

    .tile-details-list li strong {
      color: #1f2937;
      font-weight: 600;
    }

    .tile-details-footnote {
      font-size: 0.8rem;
      color: #6b7280;
      margin: 0.75rem 0 0 0;
      font-style: italic;
      line-height: 1.5;
    }

    /* Insights card styling */
    /* Side-by-side container for insights and visibility cards - 50% each */
    .ranking-cards-side-by-side {
      display: flex !important;
      flex-direction: row !important;
      gap: 1.5rem;
      margin: 1.5rem 0;
      align-items: flex-start;
      flex-wrap: wrap !important;
      width: 100%;
      overflow: visible;
    }

    .ranking-cards-side-by-side > *:first-child,
    .ranking-cards-side-by-side > *:nth-child(2) {
      flex: 0 0 calc(50% - 0.75rem) !important;
      min-width: 0;
      max-width: calc(50% - 0.75rem) !important;
      width: calc(50% - 0.75rem) !important;
      display: block !important;
    }

    /* Force all other children to be full width and on new rows */
    .ranking-cards-side-by-side > *:nth-child(n+3) {
      flex: 0 0 100% !important;
      width: 100% !important;
      max-width: 100% !important;
      clear: both !important;
      display: block !important;
      margin-top: 1.5rem;
    }

    .ranking-visibility-metrics-section {
      display: block !important;
    }

    /* Ensure sections after side-by-side cards are full width and stacked on new row */
    .ranking-cards-side-by-side ~ .ranking-priority-matrix-section,
    .ranking-cards-side-by-side ~ .ranking-table-section {
      width: 100% !important;
      display: block !important;
      clear: both !important;
      flex: none !important;
      margin-left: 0 !important;
      margin-right: 0 !important;
      float: none !important;
      position: relative !important;
    }

    @media (max-width: 1024px) {
      .ranking-cards-side-by-side {
        flex-direction: column;
      }
    }

    .card--insights {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin: 0;
      padding: 1.25rem 1.5rem;
    }

    .card--insights h2 {
      font-weight: 600;
      color: #92400e;
      margin: 0 0 0.5rem 0;
      font-size: 0.95rem;
    }

    .card--insights .card-subtitle {
      font-weight: 400;
      color: #78350f;
      margin: 0 0 1rem 0;
      font-size: 0.8rem;
      line-height: 1.5;
    }

    .card-pill-container {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .card-pill {
      background: #fffbeb;
      border: 1px solid #fde68a;
      border-radius: 6px;
      padding: 0.875rem;
      margin-bottom: 0.75rem;
    }

    .card-pill p {
      margin: 0;
      font-size: 0.8rem;
      line-height: 1.5;
      color: #78350f;
    }

    .card-pill strong {
      color: #92400e;
      font-weight: 600;
    }

    /* Visibility metrics card styling */
    .ranking-visibility-metrics-section .card {
      padding: 1.25rem 1.5rem;
    }

    .ranking-visibility-metrics-section h4 {
      font-size: 0.95rem !important;
      font-weight: 600 !important;
      margin-bottom: 0.5rem !important;
    }

    .ranking-visibility-metrics-section p,
    .ranking-visibility-metrics-section ul,
    .ranking-visibility-metrics-section li {
      font-size: 0.8rem !important;
    }

    .ranking-visibility-metrics-section strong {
      font-weight: 600 !important;
    }

    /* Section C: Filters */
    .ranking-filters-section {
      margin-bottom: 1rem;
      background: rgba(204, 255, 255, 0.15) !important;
      border-left: 4px solid #CCFFFF !important;
      border-radius: 8px;
      padding: 1rem 1.25rem;
      font-size: 0.75rem !important;
    }

    .ranking-filter-bar {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 0.75rem 1rem;
      align-items: end;
      padding: 0;
      background: transparent;
    }

    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 0.375rem;
      min-width: 0;
    }

    .filter-group label {
      font-size: 0.65rem !important;
      font-weight: 600;
      color: #374151;
      white-space: nowrap;
      margin: 0;
      line-height: 1.2;
    }

    .filter-control {
      padding: 0.35rem 0.55rem;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.85rem !important;
      background: #ffffff;
      width: 100%;
      min-width: 110px;
      transition: all 0.2s ease;
    }
    
    .filter-control option {
      font-size: 0.85rem;
    }

    /* Active filter state - when value is not "all" */
    .filter-control.filter-active {
      background: #eff6ff !important;
      border-color: #3b82f6 !important;
      color: #1e40af !important;
      font-weight: 600;
    }

    .filter-control:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.15);
    }

    #ranking-filter-keyword {
      min-width: 300px;
    }

    /* Search filter group should be wider */
    .filter-group-search {
      grid-column: span 2;
      min-width: 300px;
    }

    /* Clear filters button */
    #ranking-filter-clear {
      font-size: 0.7rem !important;
      padding: 0.4rem 0.75rem;
      align-self: end;
    }

    /* Keyword Priority Matrix section - full width, stacked layout */
    .ranking-priority-matrix-section {
      width: 100% !important;
      clear: both !important;
      display: block !important;
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
      flex: none !important;
      flex-basis: 100% !important;
      max-width: 100% !important;
      float: none !important;
      position: relative !important;
      box-sizing: border-box !important;
      order: 999 !important;
    }

    /* Section C: Table section - separate card */
    .ranking-table-section {
      margin: 2rem 0;
      width: 100% !important;
      clear: both !important;
      display: block !important;
      flex: none !important;
      max-width: 100% !important;
      float: none !important;
      position: relative !important;
      box-sizing: border-box !important;
      background: rgba(204, 255, 255, 0.2) !important;
      border-left: 4px solid #CCFFFF !important;
      border-radius: 8px;
      padding: 1.5rem;
      font-size: 14pt !important;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .ranking-table-section .card {
      background: transparent;
      box-shadow: none;
      padding: 0;
    }
    
    /* Apply 14pt to section elements but exclude table */
    .ranking-table-section .card-header,
    .ranking-table-section .card-subtitle,
    .ranking-table-section .filter-group,
    .ranking-table-section .filter-control,
    .ranking-table-section .btn {
      font-size: 14pt !important;
    }
    
    /* Table font size - must come after to override any universal selectors */
    .ranking-table-section .ranking-table,
    .ranking-table-section .ranking-table th,
    .ranking-table-section .ranking-table td,
    .ranking-table-section .ranking-table-wrapper .ranking-table,
    .ranking-table-section .ranking-table-wrapper .ranking-table th,
    .ranking-table-section .ranking-table-wrapper .ranking-table td {
      font-size: 0.875rem !important;
    }
    
    /* Pagination controls */
    .ranking-pagination-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #e5e7eb;
      flex-wrap: wrap;
      gap: 1rem;
    }
    
    .ranking-pagination-info {
      font-size: 14pt !important;
      color: #374151;
    }
    
    .ranking-pagination-buttons {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    
    .ranking-pagination-buttons button {
      padding: 0.5rem 1rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      background: #ffffff;
      font-size: 14pt !important;
      cursor: pointer;
      color: #374151;
    }
    
    .ranking-pagination-buttons button:hover:not(:disabled) {
      background: #f3f4f6;
      border-color: #9ca3af;
    }
    
    .ranking-pagination-buttons button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .ranking-rows-per-page {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .ranking-rows-per-page label {
      font-size: 14pt !important;
      color: #374151;
      white-space: nowrap;
    }
    
    .ranking-rows-per-page select {
      padding: 0.5rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 14pt !important;
      background: #ffffff;
    }

    /* Section D: Details grid - three columns (33% each) */
    .ranking-details-grid {
      display: grid !important;
      grid-template-columns: repeat(3, 1fr) !important;
      gap: 1rem;
      margin-top: 2rem;
      background: rgba(204, 255, 255, 0.15) !important;
      border-left: 4px solid #CCFFFF !important;
      border-radius: 8px;
      padding: 1.5rem;
    }
    
    .ranking-details-grid .card {
      min-width: 0;
      overflow: hidden;
    }
    
    .ranking-details-grid table {
      width: 100%;
      table-layout: fixed;
      font-size: 0.8rem;
    }
    
    .ranking-details-grid table th,
    .ranking-details-grid table td {
      padding: 0.5rem 0.4rem;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    .ranking-details-grid table th:first-child,
    .ranking-details-grid table td:first-child {
      width: 35%;
      max-width: 35%;
    }
    
    .ranking-details-grid table th:nth-child(2),
    .ranking-details-grid table td:nth-child(2) {
      width: 15%;
      max-width: 15%;
    }
    
    .ranking-details-grid table th:nth-child(3),
    .ranking-details-grid table td:nth-child(3) {
      width: 20%;
      max-width: 20%;
    }
    
    .ranking-details-grid table th:nth-child(4),
    .ranking-details-grid table td:nth-child(4) {
      width: 20%;
      max-width: 20%;
    }
    
    .ranking-details-grid table th:nth-child(5),
    .ranking-details-grid table td:nth-child(5) {
      width: 10%;
      max-width: 10%;
    }

    .ranking-details-grid .card {
      background: #ffffff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 0;
      margin-bottom: 0.75rem;
      border-radius: 6px;
      border: 1px solid #e5e7eb;
    }

    .ranking-details-grid .card:last-child {
      margin-bottom: 0;
    }

    /* Card header and body padding for consistent spacing */
    .ranking-details-grid .card-header {
      padding: 1.25rem 1.25rem 0.75rem 1.25rem;
    }

    .ranking-details-grid .card-body,
    .ranking-details-grid .ranking-ai-detail-body {
      padding: 0 1.25rem 1.25rem 1.25rem;
      font-size: 0.95rem;
      font-weight: 400;
      color: #1e293b;
      line-height: 1.6;
    }

    /* Typography hierarchy for cards */
    .ranking-details-grid .card-header h3 {
      font-size: 1.25rem;
      font-weight: 700;
      color: #1e293b;
      margin: 0 0 0.5rem 0;
      line-height: 1.4;
    }

    .ranking-details-grid .card-header h2 {
      font-size: 1.1rem;
      font-weight: 600;
      color: #374151;
      margin: 0 0 0.5rem 0;
      line-height: 1.4;
    }

    .ranking-details-grid .card-header p,
    .ranking-details-grid .card-subtitle {
      font-size: 0.9rem;
      font-weight: 400;
      color: #64748b;
      line-height: 1.5;
      margin: 0;
    }

    .ranking-details-grid .card-header h5 {
      font-size: 1rem;
      font-weight: 600;
      color: #374151;
      margin: 1rem 0 0.5rem 0;
    }

    /* List padding to match card body */
    .ranking-details-grid .ranking-ai-detail-list {
      padding: 0 1.25rem 1.25rem 1.25rem;
      margin: 0;
    }

    @media (max-width: 1200px) {
      .ranking-details-grid {
        grid-template-columns: 1fr;
      }
    }


    .ranking-table-wrapper {
      max-height: 540px;
      overflow: auto;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
    }

    .ranking-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.875rem !important;
    }

    /* Table header styling */
    .ranking-table th {
      text-align: center !important;
      vertical-align: middle;
      position: relative;
    }

    .ranking-table th > div:first-child {
      font-weight: 700 !important;
      text-align: center;
      margin-bottom: 0.25rem;
    }

    .ranking-table th > div:last-child {
      text-align: center !important;
      color: #2563eb !important;
      opacity: 1 !important;
    }

    .ranking-table th .sort-indicator {
      color: #1e40af !important;
      font-weight: 700 !important;
      margin-left: 0.25rem;
      opacity: 1 !important;
    }

    .ranking-table th.sortable {
      cursor: pointer;
    }

    .ranking-table th.sortable:hover {
      background-color: #f3f4f6;
    }

    /* Dynamic column widths - adjust based on content */
    .ranking-table {
      table-layout: auto;
      width: 100%;
    }

    .ranking-table th,
    .ranking-table td {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #e5e7eb;
      text-align: center;
      font-size: 0.875rem !important;
    }

    .ranking-table th {
      position: sticky;
      top: 0;
      background: #f3f4f6;
      z-index: 10;
      font-weight: 600;
      font-size: 0.875rem !important;
      vertical-align: top;
    }

    .ranking-table th > div:first-child {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
    }

    .ranking-table th.sortable {
      cursor: pointer;
      user-select: none;
      position: sticky;
      top: 0;
    }

    .ranking-table th.sortable:hover {
      background: #e5e7eb;
      position: sticky;
      top: 0;
    }

    .sort-indicator {
      display: inline-block;
      margin-left: 0.25rem;
      font-size: 0.85rem;
      opacity: 0.5;
    }

    .sort-indicator::after {
      content: "";
    }

    .ranking-table th.sort-asc .sort-indicator::after {
      content: "";
      opacity: 1;
    }

    .ranking-table th.sort-desc .sort-indicator::after {
      content: "";
      opacity: 1;
    }

    .ranking-table tr:nth-child(even) td {
      background: #f9fafb;
    }

    .ranking-table tr:hover {
      cursor: pointer;
    }

    .ranking-table-row--selected td {
      background: #eef2ff !important;
    }

    .ranking-row-good td {
      box-shadow: inset 3px 0 0 #16a34a;
    }

    .ranking-row-ok td {
      box-shadow: inset 3px 0 0 #f59e0b;
    }

    .ranking-row-weak td {
      box-shadow: inset 3px 0 0 #dc2626;
    }

    .ranking-table-empty {
      text-align: center;
      padding: 1rem;
      color: #6b7280;
    }


    .ranking-subtitle-tight {
      font-size: 0.875rem !important;
      max-width: 48rem;
    }

    /* RAG badges in table */
    .ranking-badge-rank {
      display: inline-flex;
      align-items: center;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .ranking-badge-rank--good {
      background: #dcfce7;
      color: #166534;
    }

    .ranking-badge-rank--ok {
      background: #fef3c7;
      color: #92400e;
    }

    .ranking-badge-rank--weak {
      background: #fee2e2;
      color: #b91c1c;
    }

    .ranking-badge-volume {
      display: inline-flex;
      align-items: center;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }
    
    .ranking-badge-volume--high {
      background: #dcfce7;
      color: #166534;
    }
    
    .ranking-badge-volume--med {
      background: #fef3c7;
      color: #92400e;
    }
    
    .ranking-badge-volume--low {
      background: #fee2e2;
      color: #b91c1c;
    }
    
    .ranking-badge-volume--none {
      background: #f3f4f6;
      color: #6b7280;
    }

    .ranking-badge-citation {
      display: inline-flex;
      align-items: center;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .ranking-badge-citation--good {
      background: #dcfce7;
      color: #166534;
    }

    .ranking-badge-citation--weak {
      background: #fee2e2;
      color: #b91c1c;
    }

    .ranking-ai-detail-body {
      padding: 1rem 0;
    }

    .ranking-ai-detail-content {
      /* Make scorecard stand out as separate object */
      margin: 0.75rem 0;
      padding: 1.5rem 1.5rem;
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      border-top: 1px solid #e5e7eb;
      border-right: 1px solid #e5e7eb;
      border-bottom: 1px solid #e5e7eb;
      /* Left border will be set dynamically based on priority */
    }

    .ranking-ai-detail-content.scorecard-priority-high {
      border-left: 6px solid #ef4444; /* Red for High priority */
      background: #fef2f2;
    }

    .ranking-ai-detail-content.scorecard-priority-medium {
      border-left: 6px solid #f59e0b; /* Amber for Medium priority */
      background: #fffbeb;
    }

    .ranking-ai-detail-content.scorecard-priority-low {
      border-left: 6px solid #10b981; /* Green for Low priority */
      background: #f0fdf4;
    }

    .ranking-ai-detail-content h4 {
      margin: 0 0 0.5rem 0;
      font-size: 1.25rem;
      font-weight: 700;
      color: #1e293b;
    }

    .ranking-ai-detail-content h5 {
      margin: 1rem 0 0.5rem 0;
      font-size: 1rem;
      font-weight: 600;
      color: #374151;
    }

    /* Section breaks for scorecard components */
    .ranking-ai-detail-content .scorecard-section {
      padding: 1rem 1.25rem;
      margin-bottom: 1.0rem !important;
      background: #f5f5f5;
      border-left: 3px solid #cbd5e1;
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .ranking-ai-detail-content .scorecard-section:last-child {
      margin-bottom: 0 !important;
    }

    .ranking-ai-detail-list {
      list-style: none;
      padding-left: 0;
      margin: 0.5rem 0 0;
    }

    .ranking-ai-detail-list li {
      margin-bottom: 0.4rem;
      padding: 0.5rem 0.75rem;
      background: #f9fafb;
      border-radius: 4px;
      font-size: 0.95rem;
    }

    .ranking-ai-detail-list li a {
      color: #2563eb;
      text-decoration: none;
    }

    .ranking-ai-detail-list li a:hover {
      text-decoration: underline;
    }

    .ranking-ai-last-run {
      margin-left: 0.75rem;
      font-size: 0.95rem;
      color: #6b7280;
    }

    .ranking-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 500;
    }

    .ranking-badge--ai-on { background: #ecfdf5; color: #059669; }
    .ranking-badge--ai-off { background: #f9fafb; color: #6b7280; }
    .ranking-badge--cited { background: #eff6ff; color: #1d4ed8; }
    .ranking-badge--not-cited { background: #fef2f2; color: #b91c1c; }
    .ranking-badge--segment-money { background: #fef3c7; color: #92400e; }
    .ranking-badge--segment-education { background: #e0f2fe; color: #075985; }
    .ranking-badge--segment-brand { background: #f5f3ff; color: #6d28d9; }
    .ranking-badge--segment-general { background: #f9fafb; color: #4b5563; }
    .ranking-badge--rank-good { background: #dcfce7; color: #166534; }
    .ranking-badge--rank-mid { background: #fef3c7; color: #92400e; }
    .ranking-badge--rank-weak { background: #fee2e2; color: #b91c1c; }
    
    /* Demand share styling */
    .ranking-badge-demand-share--high { color: #059669; font-weight: 600; }
    .ranking-badge-demand-share--med { color: #d97706; font-weight: 500; }
    .ranking-badge-demand-share--low { color: #6b7280; font-weight: 400; }
    .ranking-badge-demand-share--none { color: #9ca3af; }
    
    /* Opportunity score styling (RAG colors matching Money Pages priority matrix) */
    .ranking-badge-opportunity {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.9rem;
      font-weight: 600;
    }
    .ranking-badge-opportunity--high { background: #dcfce7; color: #166534; } /* Green - High */
    .ranking-badge-opportunity--medium { background: #fef3c7; color: #92400e; } /* Amber - Medium */
    .ranking-badge-opportunity--low { background: #fee2e2; color: #b91c1c; } /* Red - Low */
    
    /* Page type badge styling (matching Money Pages matrix) */
    .ranking-badge-page-type {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 500;
    }
    .ranking-badge-page-type--landing { background: #fef3c7; color: #92400e; }
    .ranking-badge-page-type--event { background: #dbeafe; color: #1e40af; }
    .ranking-badge-page-type--product { background: #fce7f3; color: #9f1239; }
    .ranking-badge-page-type--blog { background: #e0f2fe; color: #075985; }
    .ranking-badge-page-type--gbp { background: #f5f3ff; color: #6d28d9; }

    /* Money Pages KPI trend arrow colors */
    .kpi-trend-up { color: #10b981; font-weight: 700; }
    .kpi-trend-down { color: #ef4444; font-weight: 700; }
    .kpi-trend-flat { color: #64748b; font-weight: 700; }

    /* Domain Strength (Ranking & AI) */
    .domain-strength-badge {
      display: inline-flex;
      padding: 0.125rem 0.375rem !important;
      font-size: 0.65rem !important;
      line-height: 1.2 !important;
      align-items: center;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 600;
      white-space: nowrap;
    }
    .domain-strength-badge--very-strong { background: #dcfce7; color: #166534; }
    .domain-strength-badge--strong { background: #ecfdf5; color: #059669; }
    .domain-strength-badge--moderate { background: #fef3c7; color: #92400e; }
    .domain-strength-badge--weak { background: #fde68a; color: #92400e; }
    .domain-strength-badge--very-weak { background: #fee2e2; color: #b91c1c; }
    .domain-strength-badge--na { background: #f9fafb; color: #6b7280; }

    .domain-strength-summary-row {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      align-items: stretch;
      margin-top: 1rem;
    }
    .domain-strength-summary-card {
      flex: 1 1 280px;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 1rem 1.25rem;
      min-width: 280px;
    }
    .domain-strength-summary-top {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .domain-strength-summary-score {
      font-size: 2rem;
      font-weight: 800;
      letter-spacing: -0.02em;
      color: #0f172a;
      line-height: 1;
    }
    .domain-strength-summary-subtitle {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #64748b;
      line-height: 1.45;
    }
    .domain-strength-legend {
      flex: 1 1 320px;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      align-content: flex-start;
      padding: 1rem 1.25rem;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      min-width: 280px;
    }
    .domain-strength-help {
      margin-left: 0.4rem;
      opacity: 0.7;
      cursor: help;
      font-size: 0.95rem;
      border: 1px solid rgba(100, 116, 139, 0.35);
      border-radius: 999px;
      width: 20px;
      height: 20px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      background: rgba(248, 250, 252, 0.8);
    }
    .domain-strength-sparkline {
      display: inline-block;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>GAIO (Generative AI Optimization) Audit Dashboard</h1>
    <p>Automated GAIO Performance Tracking & Optimisation</p>
    <p style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 1; background: rgba(0,0,0,0.3); padding: 0.25rem 0.5rem; border-radius: 4px; display: inline-block;">
      <strong>Version: <span id="gitVersion">37685db</span></strong> | Built: <span id="buildDate"></span> | 
      <span id="loadTime" style="color: #4f4;">Loaded: <span id="loadTimeValue"></span></span>
    </p>
    <script>
      // Set build date to today in GMT
      const now = new Date();
      const gmtDate = now.toISOString().split('T')[0]; // YYYY-MM-DD
      const gmtTime = now.toISOString().split('T')[1].split('.')[0]; // HH:MM:SS
      document.getElementById('buildDate').textContent = gmtDate + ' ' + gmtTime + ' GMT';
      document.getElementById('loadTimeValue').textContent = now.toLocaleTimeString();
    </script>
  </div>

  <div class="aigeo-layout">
    <aside class="aigeo-sidebar">
      <button class="aigeo-nav-item" data-panel="config">
        <span class="aigeo-nav-icon"></span>
        <span>Configuration & Reporting</span>
      </button>
      <button class="aigeo-nav-item is-active" data-panel="overview">
        <span class="aigeo-nav-icon"></span>
        <span>Overview</span>
      </button>
      <button class="aigeo-nav-item" data-panel="authority">
        <span class="aigeo-nav-icon"></span>
        <span>Authority</span>
      </button>
      <button class="aigeo-nav-item" data-panel="money">
        <span class="aigeo-nav-icon"></span>
        <span>Money Pages</span>
      </button>
      <button class="aigeo-nav-item" data-panel="ranking">
        <span class="aigeo-nav-icon"></span>
        <span>Ranking & AI</span>
      </button>
      <button class="aigeo-nav-item" data-panel="optimisation">
        <span class="aigeo-nav-icon"></span>
        <span>Optimisation Tracking</span>
      </button>
      <button class="aigeo-nav-item" data-panel="ai-sources">
        <span class="aigeo-nav-icon"></span>
        <span>AI Sources & Influence</span>
      </button>
      <button class="aigeo-nav-item" data-panel="local">
        <span class="aigeo-nav-icon"></span>
        <span>Local & Reviews</span>
      </button>
      <button class="aigeo-nav-item" data-panel="history">
        <span class="aigeo-nav-icon"></span>
        <span>History</span>
      </button>
    </aside>
    <main class="aigeo-main">
  <div class="container">

    <div class="status" id="status"></div>

    <div class="loading" id="loading">
      <div class="progress-container">
        <div class="spinner"></div>
        <div class="progress-bar-wrapper">
          <div class="progress-bar" id="progressBar" style="width: 0%;">0%</div>
        </div>
        <div class="progress-status" id="progressStatus">Initializing audit scan...</div>
      </div>
    </div>

    <!-- Completion Summary Modal -->
    <div id="completionModal" class="modal" style="display: none;">
      <div class="modal-content" style="max-width: 600px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Audit Complete</h2>
          <button onclick="closeCompletionModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;" title="Close the audit completion summary modal">&times;</button>
        </div>
        <div id="completionSummaryContent"></div>
        <div style="margin-top: 1.5rem; text-align: right;">
          <button class="btn" onclick="closeCompletionModal()" style="background: var(--brand-orange); color: white; border-color: var(--brand-orange);" title="Close the audit completion summary modal and return to the dashboard">Close</button>
        </div>
      </div>
    </div>

    <!-- Bulk Update Results Modal -->
    <div id="optimisation-bulk-update-results-modal" class="modal" style="display: none;">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Bulk Update Complete</h2>
          <button onclick="closeBulkUpdateResultsModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;" title="Close">&times;</button>
        </div>
        <div id="bulk-update-results-content">
          <!-- Content will be populated by JavaScript -->
        </div>
        <div style="margin-top: 1.5rem; text-align: right;">
          <button class="btn" onclick="closeBulkUpdateResultsModal()" style="background: var(--brand-orange); color: white; border-color: var(--brand-orange);">Close</button>
        </div>
      </div>
    </div>

    <!-- Ranking & AI Progress Modal -->
    <div id="rankingAiProgressModal" class="modal" style="display: none;">
      <div class="modal-content" style="max-width: 700px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Running Ranking & AI Check</h2>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <button id="rankingAiProgressStop" style="display: none; padding: 0.5rem 1rem; background: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 600;" title="Stop the scan">Stop Scan</button>
            <button id="rankingAiProgressClose" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666; opacity: 0.5;" disabled title="Cannot close during processing">&times;</button>
          </div>
        </div>
        
        <!-- Keyword Count Display (shown before scan starts) -->
        <div id="rankingAiKeywordCount" style="display: none; margin-bottom: 1rem; padding: 1rem; background: #fef3c7; border: 1px solid #fbbf24; border-radius: 6px;">
          <div style="font-weight: 600; color: #92400e; margin-bottom: 0.5rem;">Ready to scan:</div>
          <div style="font-size: 1.2rem; font-weight: 700; color: #78350f;" id="rankingAiKeywordCountValue">0 keywords</div>
          <div style="font-size: 0.85rem; color: #78350f; margin-top: 0.5rem;">Click "Start Scan" below to begin, or close this modal to cancel.</div>
        </div>
        
        <!-- Progress Bar -->
        <div style="margin-bottom: 2rem;">
          <div id="rankingAiProgressBar" style="width: 100%; height: 24px; background-color: #e5e7eb; border-radius: 12px; overflow: hidden; position: relative;">
            <div id="rankingAiProgressFill" style="width: 0%; height: 100%; background: linear-gradient(90deg, var(--brand-orange), #ff8c42); transition: width 0.3s ease; border-radius: 12px;"></div>
          </div>
          <div id="rankingAiProgressText" style="margin-top: 0.5rem; text-align: center; font-size: 0.9rem; color: #6b7280; font-weight: 500;">0%</div>
        </div>

        <!-- Step Details -->
        <div id="rankingAiStepDetails" style="margin-bottom: 1.5rem;">
          <div id="rankingAiCurrentStep" style="font-size: 1.1rem; font-weight: 600; color: #1f2937; margin-bottom: 0.75rem;">
            Initializing...
          </div>
          <div id="rankingAiStepNarrative" style="font-size: 0.95rem; color: #6b7280; line-height: 1.6; margin-bottom: 1rem;">
            Preparing to fetch ranking and AI data...
          </div>
          <div id="rankingAiStepCounts" style="font-size: 0.9rem; color: #9ca3af; font-style: italic;">
            <!-- Counts will be populated here -->
          </div>
        </div>

        <!-- Step List -->
        <div style="border-top: 1px solid #e5e7eb; padding-top: 1rem;">
          <div style="font-size: 0.85rem; font-weight: 600; color: #6b7280; margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Progress Steps</div>
          <div id="rankingAiStepsList" style="display: flex; flex-direction: column; gap: 0.5rem;">
            <!-- Steps will be populated here -->
          </div>
        </div>

        <!-- Completion Summary (hidden by default) -->
        <div id="rankingAiSummary" style="display: none; border-top: 2px solid #10b981; padding-top: 1.5rem; margin-top: 1.5rem;">
          <h3 style="margin: 0 0 1rem 0; color: #10b981; font-size: 1.2rem; font-weight: 600;"> Scan Complete</h3>
          <div id="rankingAiSummaryContent" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; font-size: 0.95rem;">
            <!-- Summary content will be populated here -->
          </div>
        </div>
      </div>
    </div>

    <div id="dashboard" style="display: none;">
      <div id="auditTimestamp" style="background: #e8f5e9; padding: 0.75rem 1rem; border-radius: 6px; margin-bottom: 1rem; border-left: 4px solid #10b981; font-size: 0.9rem; color: #555;">
        <strong>Last Audit:</strong> <span id="lastAuditTime">Not yet run</span>
      </div>

      <!-- Configuration & Reporting Panel -->
      <section class="aigeo-panel" data-panel="config">
    <div class="config-panel">
      <h2>Configuration</h2>
      <div class="info-box" style="background: #e8f4f8; border-left: 4px solid #2196F3; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #1565C0;"><strong>Entity-Level Audit:</strong> This dashboard analyzes <strong>www.alanranger.com</strong> as a global entity, tracking AI-powered search visibility, entity recognition, and SERP behavior across the entire domain.</p>
      </div>
      <div class="form-group">
        <label for="propertyUrl">Property URL</label>
        <input type="text" id="propertyUrl" placeholder="https://yourwebsite.com" value="https://www.alanranger.com">
        <div class="help-text">The domain being audited (entity-level analysis)</div>
      </div>
      <div style="background: #f0f0f0; padding: 0.75rem; border-radius: 4px; margin-bottom: 1rem; font-size: 0.85rem; color: #555;">
        <strong>API Key:</strong> Loaded automatically from Vercel environment variables. No manual entry required.
      </div>
      <!-- Manual URL List Section (Collapsible) -->
      <div class="csv-upload-section collapsed" id="urlListSection">
        <div class="csv-section-header" onclick="toggleCsvSection('urlListSection')">
          <h3>Manual URL List (Optional)</h3>
          <span class="csv-section-toggle" id="urlListToggle"></span>
        </div>
        <div class="csv-section-content collapsed" id="urlListContent">
          <div class="form-group" style="margin-bottom: 0;">
        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">
          Load list of site URLs from a CSV file
        </div>
        <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
          <input type="file" id="urlListFile" accept=".csv" style="flex: 1; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem;">
              <button class="btn btn-small" onclick="loadUrlListFromFile()" style="padding: 0.5rem 1rem;" title="Load a CSV file containing site URLs. The CSV must have a 'url' column in the header row. URLs will be used for schema audit instead of the default CSV source.">Load CSV</button>
              <button class="btn btn-small" onclick="clearManualUrlList()" style="padding: 0.5rem 1rem; background: #ef4444; color: white; border-color: #ef4444;" title="Clear the manually loaded URL list and revert to using the default CSV source for schema audit">Clear</button>
        </div>
        <textarea id="manualUrlList" placeholder="Or paste CSV content here (must include 'url' column in header row)..." style="width: 100%; min-height: 100px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace; resize: vertical;"></textarea>
        <div class="help-text">
          <strong>Required column:</strong> <code>url</code> (case-insensitive). CSV must have a header row. URLs will be extracted from the 'url' column.
        </div>
        <div id="urlListStatus" style="margin-top: 0.5rem; font-size: 0.85rem;"></div>
          </div>
        </div>
      </div>
      
      <!-- Backlink CSV Upload Section (Collapsible) -->
      <div class="csv-upload-section collapsed" id="backlinkCsvSection">
        <div class="csv-section-header" onclick="toggleCsvSection('backlinkCsvSection')">
          <h3>Backlink CSV Upload (Optional)</h3>
          <span class="csv-section-toggle" id="backlinkCsvToggle"></span>
        </div>
        <div class="csv-section-content collapsed" id="backlinkCsvContentWrapper">
          <div class="form-group" style="margin-bottom: 0;">
            <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">
              Upload backlink data CSV file for Authority score calculation. Can be uploaded independently of site URLs CSV.
            </div>
            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
              <input type="file" id="backlinkCsvFile" accept=".csv" style="flex: 1; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem;">
                  <button class="btn btn-small" onclick="loadBacklinkCsvFromFile()" style="padding: 0.5rem 1rem;" title="Load a CSV file containing backlink data. The CSV must have 'source_url' and 'target_url' columns in the header row. Backlinks will be used for Authority score calculation.">Load CSV</button>
                  <button class="btn btn-small" onclick="clearBacklinkCsv()" style="padding: 0.5rem 1rem; background: #ef4444; color: white; border-color: #ef4444;" title="Clear the backlink CSV data">Clear</button>
            </div>
                <textarea id="backlinkCsvContent" placeholder="Or paste CSV content here (must include 'source_url' and 'target_url' columns in header row)..." style="width: 100%; min-height: 100px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace; resize: vertical;"></textarea>
            <div class="help-text">
                  <strong>Required columns:</strong> <code>source_url</code> and <code>target_url</code> (case-insensitive). CSV must have a header row. Backlinks will be extracted from these columns.
            </div>
            <div id="backlinkCsvStatus" style="margin-top: 0.5rem; font-size: 0.85rem;"></div>
          </div>
        </div>
      </div>
          
          <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-top: 1.5rem;">
        <button class="btn" onclick="runAudit()" title="Start a comprehensive audit scan. Fetches Google Search Console data, performs schema audit (if site URLs CSV loaded), and uses backlink data (if backlink CSV uploaded). Results will appear in the dashboard below.">Run Audit Scan</button>
            <button class="btn btn-secondary" onclick="shareAudit()" title="Generate a shareable link to your current audit results. The link will allow others to view your audit data without running a new scan.">Share Audit</button>
        <button class="btn btn-secondary" onclick="saveConfig()" title="Save your current configuration (property URL and date range) to browser localStorage. Settings will be restored when you reload the page.">Save Configuration</button>
            <button class="btn btn-success" onclick="syncCsv()" title="Sync CSV data from the configured source. This will update your URL list and backlink data from the remote CSV file.">Sync CSV</button>
      </div>
    </div>

    <!-- Share Mode Banner (read-only) -->
    <div id="share-mode-banner" class="config-panel" style="margin-top: 2rem; display: none; background: #fef3c7; border-left: 4px solid #f59e0b; padding: 1rem; border-radius: 4px;">
      <div style="display: flex; align-items: center; gap: 0.5rem;">
        <span style="font-size: 1.25rem;"></span>
        <strong style="color: #92400e;">Shared view (read-only)</strong>
        <span style="color: #92400e; font-size: 0.9rem;"> You can view all data but cannot make changes</span>
      </div>
    </div>

    <!-- Admin Key Configuration (Phase A - Security) -->
    <div id="admin-key-panel" class="config-panel" style="margin-top: 2rem;">
      <h2>Optimisation Tracking Security</h2>
      <div class="info-box" style="background: #e0f2fe; border-left: 4px solid #0284c7; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #0c4a6e;">
          <strong>Admin Key Required:</strong> Set your admin key to enable optimisation tracking actions (Track, Manage, Cycle). 
          The key is stored in your browser session and sent with API requests.
        </p>
      </div>
      <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-bottom: 1rem;">
        <input 
          type="password" 
          id="admin-key-input" 
          placeholder="Enter admin key (32+ characters)" 
          style="flex: 1; min-width: 300px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace;"
          value=""
        />
        <button 
          class="btn" 
          onclick="saveAdminKey()" 
          title="Save admin key to session storage. Required for optimisation tracking actions."
        >
          Save Admin Key
        </button>
        <button 
          class="btn btn-secondary" 
          onclick="clearAdminKeyUI()" 
          title="Clear admin key from session storage."
        >
          Clear
        </button>
      </div>
      <div id="admin-key-status" style="font-size: 0.85rem; color: #64748b; margin-top: 0.5rem;"></div>
      <script>
        // Share mode initialization
        (function() {
          const urlParams = new URLSearchParams(window.location.search);
          const isShare = urlParams.get('share') === '1';
          const shareToken = urlParams.get('st') || '';
          
          if (isShare) {
            // Hide admin key panel
            const adminPanel = document.getElementById('admin-key-panel');
            if (adminPanel) adminPanel.style.display = 'none';
            
            // Show share mode banner
            const shareBanner = document.getElementById('share-mode-banner');
            if (shareBanner) shareBanner.style.display = 'block';
            
            // Disable write buttons
            window.addEventListener('DOMContentLoaded', function() {
              // Disable audit scan, sync CSV, save config buttons
              const writeButtons = document.querySelectorAll('[onclick="runAudit()"], [onclick="syncCsv()"], [onclick="saveConfig()"]');
              writeButtons.forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
                btn.title = 'Not available in share mode (read-only)';
              });
              
              // Disable Optimisation Tracking write buttons
              const bulkUpdateBtn = document.getElementById('optimisation-bulk-update-btn');
              if (bulkUpdateBtn) {
                bulkUpdateBtn.disabled = true;
                bulkUpdateBtn.style.opacity = '0.5';
                bulkUpdateBtn.style.cursor = 'not-allowed';
                bulkUpdateBtn.title = 'Not available in share mode (read-only)';
              }
            });
          }
        })();
        
        // Admin key UI functions
        function saveAdminKey() {
          const input = document.getElementById('admin-key-input');
          const key = input.value.trim();
          if (!key) {
            alert('Please enter an admin key');
            return;
          }
          if (key.length < 32) {
            if (!confirm('Admin key should be at least 32 characters. Save anyway?')) {
              return;
            }
          }
          window.setAdminKey(key);
          updateAdminKeyStatus();
          input.value = ''; // Clear input for security
          
          // Clear auth error and reload optimisation tasks if on that tab
          if (window.optimisationModuleState) {
            window.optimisationModuleState.authError = null;
            const optimisationTab = document.querySelector('[data-panel="optimisation"]');
            if (optimisationTab && optimisationTab.classList.contains('is-active')) {
              if (typeof window.loadAllOptimisationTasks === 'function') {
                window.loadAllOptimisationTasks();
              }
            }
          }
          
          // Re-render Ranking & AI table to enable Track buttons
          // Check if Ranking & AI tab is active
          const rankingTab = document.querySelector('[data-panel="ranking"]');
          if (rankingTab && rankingTab.classList.contains('is-active')) {
            // Tab is active, try to refresh the table
            if (typeof renderRankingAiTab === 'function') {
              renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
            } else if (typeof window.renderRankingAiTab === 'function') {
              window.renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
            } else {
              // Fallback: reload the page
              if (confirm('Admin key saved! Refresh the page to enable Track buttons?')) {
                // Preserve current tab state before reload
                const currentPanel = document.querySelector('.aigeo-panel.is-active');
                if (currentPanel) {
                  const panelId = currentPanel.dataset.panel;
                  sessionStorage.setItem('activeTab', panelId);
                  window.location.hash = '#' + panelId;
                }
                location.reload();
              }
            }
          } else {
            alert('Admin key saved! Switch to the "Ranking & AI" tab to see enabled Track buttons.');
          }
        }

        function clearAdminKeyUI() {
          if (confirm('Clear admin key? Optimisation tracking actions will be disabled.')) {
            window.clearAdminKey();
            document.getElementById('admin-key-input').value = '';
            updateAdminKeyStatus();
            
            // Re-render Ranking & AI table to disable Track buttons
            const rankingTab = document.querySelector('[data-panel="ranking"]');
            if (rankingTab && rankingTab.classList.contains('is-active')) {
              if (typeof renderRankingAiTab === 'function') {
                renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
              } else if (typeof window.renderRankingAiTab === 'function') {
                window.renderRankingAiTab().catch(err => console.warn('Failed to refresh table:', err));
              }
            }
          }
        }

        function updateAdminKeyStatus() {
          const statusEl = document.getElementById('admin-key-status');
          if (!statusEl) return;
          
          // Safety check: ensure hasAdminKey function is loaded
          if (typeof window.hasAdminKey !== 'function') {
            // Retry after a short delay if function not yet loaded
            setTimeout(() => {
              if (typeof window.hasAdminKey === 'function') {
                updateAdminKeyStatus();
              } else {
                // If still not loaded after retry, show warning
                statusEl.innerHTML = '<span style="color: #f59e0b;"> Loading admin key functions...</span>';
                // Try one more time after longer delay
                setTimeout(() => {
                  if (typeof window.hasAdminKey === 'function') {
                    updateAdminKeyStatus();
                  } else {
                    statusEl.innerHTML = '<span style="color: #ef4444;"> Admin key functions not loaded  please refresh the page</span>';
                  }
                }, 1000);
              }
            }, 100);
            return;
          }
          
          const hasKey = window.hasAdminKey();
          if (hasKey) {
            const key = window.getAdminKey();
            statusEl.innerHTML = `<span style="color: #10b981;"> Admin key set</span> (${key.length} characters, stored in session)`;
          } else {
            statusEl.innerHTML = '<span style="color: #ef4444;"> Admin key not set  tracking actions disabled</span>';
          }
        }

        // Update status on load
        if (typeof window !== 'undefined' && document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', updateAdminKeyStatus);
        } else {
          updateAdminKeyStatus();
        }
      </script>
    </div>

    <div class="config-panel" style="margin-top: 2rem;">
      <h2>Reporting</h2>
      <div class="info-box" style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #856404;"><strong>Generate Reports:</strong> Create comprehensive PDF reports containing all audit data, charts, and pillar score definitions.</p>
      </div>
      <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
        <button class="btn" onclick="try { console.log('[PDF] Button clicked!'); generatePDFReport(); } catch(e) { console.error('[PDF] Error in onclick:', e); alert('Error generating PDF: ' + e.message); }" id="generatePdfBtn" style="background: #dc2626; color: white; border-color: #dc2626;" title="Generate a comprehensive PDF report containing all audit data, charts, pillar scores, definitions, and metrics. The report will include all sections from the dashboard.">
           Generate PDF Report
        </button>
        <div id="pdfStatus" style="font-size: 0.85rem; color: #666; margin-left: 0.5rem;"></div>
      </div>
    </div>
      </section>

      <!-- Authority Panel -->
      <section class="aigeo-panel" data-panel="authority">
        <!-- Authority - Behaviour & Ranking section will be inserted here by JS -->
      </section>

      <!-- Overview Panel -->
      <section class="aigeo-panel is-active" data-panel="overview">

      <!-- Five-Pillar Framework (collapsed by default) -->
      <div class="calculation-explanation collapsed" id="frameworkExplanation">
        <div class="calculation-header" onclick="toggleFrameworkExplanation()">
          <h4> Five-Pillar Framework</h4>
          <span class="calculation-toggle" id="frameworkToggle"></span>
        </div>
        <div class="calculation-content collapsed" id="frameworkContent">
          <p style="margin-top: 0; color: #555; line-height: 1.6; margin-bottom: 1rem;">
            This audit analyzes <strong>www.alanranger.com</strong> as a global entity using a five-pillar framework to assess AI-powered search visibility, entity recognition, and SERP behavior. Each pillar is scored 0-100 and assigned a RAG (Red/Amber/Green) status based on performance thresholds.
          </p>
          <p style="color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
            <strong>Data Sources:</strong> Scores are calculated using data from Google Search Console API (impressions, clicks, position, queries), Google Business Profile API (ratings, reviews, locations, service areas), schema markup validation, backlink CSV upload, and Trustpilot reviews snapshot.
          </p>
          <p style="color: #555; line-height: 1.6; margin-bottom: 0;">
            <strong>Score Calculation:</strong> The GAIO score combines five weighted pillars: Authority (30%: Behaviour 40% + Ranking 20% + Backlinks 20% + Reviews 20%), Content/Schema (25%: Foundation schemas 30% + Rich Results 35% + Coverage 20% + Diversity 15%), Visibility (20%: average position mapping), Local Entity (15%: NAP consistency + knowledge panel + locations), and Service Area (10%: service areas count with NAP multiplier). Brand & Entity Overlay and AI Summary Likelihood are overlay metrics that do not affect the GAIO score but provide additional insights. Scores are normalized to 0-100 scale with thresholds: Green (70), Amber (40-69), Red (&lt;40). Money pages behaviour is tracked separately and stored per audit, so you can see whether Authority improvements are coming from better CTR on commercial pages or from broader site-wide changes.
          </p>
        </div>
      </div>

      <div class="calculation-explanation collapsed" id="calculationExplanation">
        <div class="calculation-header" onclick="toggleCalculationExplanation()">
          <h4> Detailed Calculation Explanation</h4>
          <span class="calculation-toggle" id="calculationToggle"></span>
        </div>
        <div class="calculation-content collapsed" id="calculationContent">
          <h5>1. Visibility</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Primary: Average position from Google Search Console (1-40 mapped to 100-10)</li>
            <li>Formula: <code>posScore = 100 - ((clampedPosition - 1) / 39) * 90</code> where clampedPosition is constrained to 1-40</li>
            <li>Visibility score = clamped posScore (0-100)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: impressions, clicks, average position, CTR</li>
            <li>Real-time data from GSC API for the selected date range</li>
          </ul>
          <p><strong>Data Checked:</strong> Search Console impressions/clicks, average position, CTR, ranking distribution.</p>

          <h5>2. Authority (E-E-A-T)</h5>
          <p><strong>What Authority Represents:</strong></p>
          <p>Authority is not "how good the content is", it's "how much the outside world and searchers trust and choose you". It approximates E-E-A-T using four ingredients:</p>
          <ul>
            <li><strong>Behavioural signals</strong>  do people click your results when they see them?</li>
            <li><strong>Ranking strength</strong>  how often do you show near the top of organic results?</li>
            <li><strong>Off-site credibility</strong>  backlinks from other domains (Phase 3)</li>
            <li><strong>Reputation & reviews</strong>  ratings and review volume across GBP + website</li>
          </ul>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Four-component model: Behaviour (40%), Ranking (20%), Backlinks (20%), Reviews (20%)</li>
            <li>Formula: <code>authority = 0.4 * behaviourScore + 0.2 * rankingScore + 0.2 * backlinkScore + 0.2 * reviewScore</code></li>
            <li>Each sub-score is normalized to 0-100, then combined with weights above</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>2.1 Behaviour Score (40%):</strong></p>
          <ul>
            <li>From Google Search Console: Only uses queries where average position  20</li>
            <li>Computes: ctrAll = CTR for all ranking queries, ctrTop10 = CTR for impressions where position  10</li>
            <li>Maps: ctrAll 0-5%  0-100 (values >5% capped at 100), ctrTop10 0-10%  0-100</li>
            <li>Combines: <code>BehaviourScore = 0.5 * score(ctrAll) + 0.5 * score(ctrTop10)</code></li>
            <li>This stops long-tail / low-rank pages dragging the whole site down</li>
          </ul>
          <p><strong>2.2 Ranking Score (20%):</strong></p>
          <ul>
            <li>From GSC, again only for position  20</li>
            <li>avgPos = impression-weighted average position</li>
            <li>top10Share = % of impressions where position  10</li>
            <li>posScore = map(avgPos, 1  100, 20  0) (clamped)</li>
            <li>top10Score = top10Share as a % (0-100)</li>
            <li>Combines: <code>RankingScore = 0.5 * posScore + 0.5 * top10Score</code></li>
          </ul>
          <p><strong>2.3 Review Score (20%):</strong></p>
          <ul>
            <li>Inputs: From GBP API (gbpRating 0-5, gbpReviewCount) and Trustpilot snapshot (siteRating 4.6, siteReviewCount 610)</li>
            <li>Per source: ratingScore = (rating/5)*100, countScore = min(reviewCount, 500)/500*100</li>
            <li>sourceScore = 0.6 * ratingScore + 0.4 * countScore</li>
            <li>Final: <code>ReviewScore = 0.6 * gbpSourceScore + 0.4 * siteSourceScore</code></li>
            <li>If one source missing, falls back to the other; if both missing, uses neutral default (50)</li>
          </ul>
          <p><strong>2.4 Backlink Score (20%):</strong></p>
          <ul>
            <li>Phase 3  using CSVs: refDomainCount, qualityDomains, qualityRatio</li>
            <li>countScore = map(refDomainCount, 0  0, N  100) where N is cap (e.g. 150-200)</li>
            <li>qualityScore = qualityRatio * 100</li>
            <li>Combines: <code>BacklinkScore = 0.5 * countScore + 0.5 * qualityScore</code></li>
            <li>Currently placeholder (50) until Phase 3 is implemented</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API (CTR, position, impressions by position bucket)</li>
            <li>Google Business Profile API (ratings, review count)</li>
            <li>Trustpilot reviews (historic snapshot: rating 4.6, count 610)</li>
            <li>Backlink CSV upload (referring domains, quality metrics) - Phase 3</li>
          </ul>
          <p><strong>How to Improve Authority:</strong></p>
          <ul>
            <li><strong>Behaviour:</strong> Improve titles/meta descriptions on pages already in top 10-20. Focus on high-impression queries in GSC.</li>
            <li><strong>Ranking:</strong> Push more core pages into top 10 (content refreshes, internal links, stronger schema).</li>
            <li><strong>Reviews:</strong> Keep growing GBP and Trustpilot reviews; higher rating and more volume both help.</li>
            <li><strong>Backlinks:</strong> Acquire more distinct linking domains, favouring sites with real traffic/authority (Phase 3).</li>
          </ul>

          <h5>3. Local Entity</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li><strong>Primary method (when Business Profile data available):</strong> Base score from NAP consistency (0-100), with bonuses:
              <ul>
                <li>Knowledge panel detected: +10 points</li>
                <li>At least one location: +5 points</li>
                <li>Final score capped at 100</li>
              </ul>
            </li>
            <li><strong>Fallback method (no Business Profile data):</strong> Derived from search performance:
              <ul>
            <li>Formula: <code>localEntity = 60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50)</code></li>
                <li>Uses position score and CTR score from GSC</li>
              </ul>
            </li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li> <strong>Primary:</strong> Google Business Profile API: NAP consistency score, knowledge panel detection, locations count</li>
            <li> <strong>Fallback:</strong> Google Search Console API: position, CTR (when Business Profile data unavailable)</li>
          </ul>
          <p><strong>Data Checked:</strong> NAP consistency percentage, knowledge panel presence, locations count, LocalBusiness schema presence, entity recognition signals.</p>

          <h5>4. Service Area</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li><strong>Primary method (when Business Profile data available):</strong>
              <ul>
                <li>Base score from service areas count: 0 areas = 0, 1 area = 12.5, 2 areas = 25, ..., 8+ areas = 100</li>
                <li>Formula: <code>baseScore = min(serviceAreasCount * 12.5, 100)</code></li>
                <li>NAP consistency multiplier applied: <code>serviceArea = baseScore * (napConsistencyScore / 100)</code></li>
                <li>If NAP consistency is low, service area score is reduced proportionally</li>
              </ul>
            </li>
            <li><strong>Fallback method (no Business Profile data):</strong> Derived from Local Entity score (when Business Profile unavailable)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li> <strong>Primary:</strong> Google Business Profile API: service areas count, NAP consistency score</li>
            <li> <strong>Fallback:</strong> Derived from Local Entity (when Business Profile data unavailable)</li>
          </ul>
          <p><strong>Data Checked:</strong> Service areas count from Business Profile, NAP consistency percentage, geographic coverage signals.</p>

          <h5>5. Content/Schema</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Weighted calculation based on four components: Foundation schemas, Rich Results, Coverage, and Diversity</li>
            <li>Formula: <code>contentSchema = (Foundation  30%) + (Rich Results  35%) + (Coverage  20%) + (Diversity  15%)</code></li>
            <li><strong>Foundation Schemas (30%):</strong> Organization, Person, WebSite, BreadcrumbList presence. Score = (types present / 4)  100</li>
            <li><strong>Rich Results (35%):</strong> Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList eligibility. Score = (eligible types / 11)  100</li>
            <li><strong>Coverage (20%):</strong> Pages with schema / total pages. Score = coverage percentage</li>
            <li><strong>Diversity (15%):</strong> Number of unique schema types across site. Score = min((unique types / 15)  100, 100)</li>
            <li><strong>Data Source:</strong> Schema audit API (crawls actual pages for JSON-LD markup)</li>
            <li>Uses real schema coverage from CSV-based audit (when available)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Schema Audit API: CSV-based domain crawl of all site URLs</li>
            <li>Schema markup detection and type counting</li>
            <li>Foundation schema presence detection (Organization, Person, WebSite, BreadcrumbList)</li>
            <li>Rich result eligibility detection (Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList)</li>
          </ul>
          <p><strong>Data Checked:</strong> Total pages scanned, pages with schema, schema coverage percentage, schema types present (Organization, Person, LocalBusiness, Article, Course, Event, FAQ, HowTo, etc.), missing schema types, rich result eligibility (Article, Event, FAQ, Product, LocalBusiness, Course, Review, HowTo).</p>

          <h5>6. Brand & Entity Overlay</h5>
          <p><strong>What Brand Overlay Represents:</strong></p>
          <p>Brand & Entity Overlay measures how strongly your brand is recognized in search and how well entity signals support AI understanding. It combines branded search performance, review signals, and entity recognition. <strong>Note:</strong> This is an overlay metric and does not directly affect the GAIO score calculation.</p>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li><strong>Brand Search Component (40% of brand search score):</strong>
              <ul>
                <li>Brand Query Share: % of impressions that are branded queries (30%+ share = 100 points)</li>
                <li>Brand CTR: Click-through rate on branded queries (40%+ CTR = 100 points)</li>
                <li>Brand Avg Position: Average position for branded queries (normalized 1-10  100-0)</li>
                <li>Formula: <code>brandSearchScore = 0.4 * shareScore + 0.3 * ctrScore + 0.3 * posScore</code></li>
              </ul>
            </li>
            <li><strong>Combined Score:</strong>
              <ul>
                <li>Formula: <code>brandOverlay = 0.4 * brandSearchScore + 0.3 * reviewScore + 0.3 * entityScore</code></li>
                <li>Label thresholds: &lt;40 = Weak, 40-69 = Developing, 70 = Strong</li>
              </ul>
            </li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: Branded query identification, brand impressions, brand clicks, brand CTR, brand average position</li>
            <li>Google Business Profile API: Review score (reused from Authority pillar)</li>
            <li>Local Entity score: Entity recognition signals (reused from Local Entity pillar)</li>
          </ul>
          <p><strong>Data Checked:</strong> Brand query share (% of total impressions), branded CTR, average brand position, review signals, entity recognition strength.</p>

          <h5>7. AI Summary Likelihood</h5>
          <p><strong>What AI Summary Likelihood Represents:</strong></p>
          <p>AI Summary Likelihood indicates how likely AI systems (like Google's AI Overviews) are to provide accurate, comprehensive summaries about your brand and content. It combines snippet readiness, visibility, and brand strength signals.</p>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Three-component model: Snippet Readiness (50%), Visibility (30%), Brand & Entity (20%)</li>
            <li>Formula: <code>aiSummary = 0.5 * snippetReadinessScore + 0.3 * visibilityScore + 0.2 * brandScore</code></li>
            <li>Label thresholds: &lt;50 = Low, 50-69 = Medium, 70 = High</li>
            <li>Uses same RAG bands as GAIO Score (70 green, 50 amber, &lt;50 red)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Snippet Readiness score: From snippet readiness gauge (FAQ/HowTo/Article blocks, schema, rich results)</li>
            <li>Visibility score: Current Visibility pillar score (average position from GSC)</li>
            <li>Brand score: Brand & Entity Overlay score</li>
          </ul>
          <p><strong>Data Checked:</strong> Snippet-friendly content blocks, schema markup for rich results, average search position, branded search performance, entity recognition.</p>

          <div class="note">
            <strong>Current Implementation Status:</strong><br>
            <strong> Fully Implemented:</strong><br>
             Google Search Console API integration (real-time data) - Total clicks, Total impressions, Average position, CTR calculation, Top queries, Brand query classification<br>
             Schema markup validation and analysis - Full site crawl, coverage analysis, type diversity, rich result eligibility (11 types), foundation schema detection<br>
             Backlink quality/quantity analysis - CSV upload support, domain rating, referring domains tracking<br>
             Review aggregation - Trustpilot integration (snapshot), Google Business Profile reviews, review score calculation<br>
             Knowledge panel tracking - Detection and scoring (part of Local Entity pillar)<br>
             Local pack visibility metrics - Service Area pillar with NAP consistency, location coverage<br>
             SERP feature detection - Rich result eligibility checks, snippet readiness scoring<br>
             Brand overlay metrics - Brand query share, branded CTR, brand position, entity strength<br>
             AI Summary Likelihood - Composite score based on snippet readiness, visibility, and brand signals<br>
             Historical trend tracking - Supabase integration for all pillars, trend charts with segmented Authority data<br>
             Shareable audit links - Public sharing with 30-day expiration<br><br>
            <strong>Future Enhancements:</strong><br>
             Real-time SERP feature monitoring and alerts<br>
             Advanced backlink analysis with automated discovery<br>
             Competitive analysis and benchmarking<br>
             Automated action recommendations engine<br>
             Export capabilities (PDF, CSV reports)<br><br>
            <strong>Note:</strong> All five core pillars (Authority, Content/Schema, Visibility, Local Entity, Service Area) are fully implemented with real data sources. Brand & Entity and AI Summary Likelihood are overlay metrics that enhance the core scoring without changing the GAIO score calculation.
          </div>
        </div>
      </div>

      <!-- Date Range Selector -->
      <div class="config-panel" style="margin-bottom: 2rem; background: #f8f9fa; padding: 1.5rem; border-radius: 8px; border: 1px solid #e2e8f0;">
        <div class="form-group">
          <label for="dateRange">Date Range</label>
          <div class="date-range-selector">
            <button class="date-range-btn active" onclick="setDateRange(30)" data-days="30" title="Analyze search performance data from the last 30 days">Last 30 Days</button>
            <button class="date-range-btn" onclick="setDateRange(60)" data-days="60" title="Analyze search performance data from the last 60 days">Last 60 Days</button>
            <button class="date-range-btn" onclick="setDateRange(90)" data-days="90" title="Analyze search performance data from the last 90 days">Last 90 Days</button>
            <button class="date-range-btn" onclick="setDateRange(120)" data-days="120" title="Analyze search performance data from the last 120 days">Last 120 Days</button>
            <button class="date-range-btn" onclick="setDateRange(180)" data-days="180" title="Analyze search performance data from the last 6 months (180 days)">Last 6 Months</button>
            <button class="date-range-btn" onclick="setDateRange(365)" data-days="365" title="Analyze search performance data from the last 12 months (365 days)">Last 12 Months</button>
            <button class="date-range-btn" onclick="setDateRange(540)" data-days="540" title="Analyze search performance data from the last 18 months (540 days)">Last 18 Months</button>
            <button class="date-range-btn" onclick="showCustomDateRange()" id="customDateBtn" title="Set a custom date range for analysis (enter number of days)">Custom</button>
        </div>
          <input type="number" id="dateRange" value="30" min="1" style="display: none;">
          <div id="customDateRange" style="display: none; margin-top: 0.5rem;">
            <input type="number" id="customDays" placeholder="Enter days" min="1" style="width: 150px; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px;">
            <button class="btn btn-small" onclick="applyCustomDateRange()" style="margin-left: 0.5rem; padding: 0.5rem 1rem;" title="Apply the custom date range you entered">Apply</button>
      </div>
          <div class="help-text">Analysis period for historical data</div>
      </div>
    </div>

      <div class="dashboard-grid" id="pillarCards"></div>

      <div class="section-break"></div>

      <div class="metrics-section">
        <h3 style="color: var(--brand-orange); margin-bottom: 0.5rem;">Key Performance Indicators</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Core metrics from Google Search Console showing overall search performance for the entity. <strong>Note:</strong> Small differences from live GSC may occur due to data processing delays (up to 48 hours) and exact date range calculations.</p>
        <div class="metrics-grid" id="metricsGrid"></div>
      </div>

      <div class="section-break"></div>

      <div class="dashboard-two-column">
        <div class="chart-container large">
          <h3>Pillar Scores Overview</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Radar chart showing current performance across all five pillars. The larger the area, the stronger your overall entity recognition.</p>
          
          <!-- Audit Timestamp for Radar Chart -->
          <div id="radarChartTimestamp" style="background: #fff3cd; padding: 0.5rem 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #f59e0b; font-size: 0.8rem; color: #856404; display: none;">
            <strong>Current data as of:</strong> <span id="radarChartAuditTime">-</span> <span style="color: #666; font-size: 0.75rem;">(Not historical - reflects last audit scan)</span>
          </div>
          
          <canvas id="radarChart"></canvas>
        </div>

        <div class="snippet-readiness-gauge">
          <h3 style="margin-top: 0; color: var(--brand-orange);">Snippet Readiness Gauge</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Snippet readiness summarises how likely your content is to be lifted into featured snippets and AI answers. It reflects three ingredients: snippet-friendly answer blocks, suitable schema (FAQ/HowTo/Article/Course/Event) and existing rich-result behaviour.</p>
          
          <!-- Audit Timestamp for Snippet Readiness -->
          <div id="snippetReadinessTimestamp" style="background: #fff3cd; padding: 0.5rem 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #f59e0b; font-size: 0.8rem; color: #856404; display: none;">
            <strong>Current data as of:</strong> <span id="snippetReadinessAuditTime">-</span> <span style="color: #666; font-size: 0.75rem;">(Not historical - reflects last audit scan)</span>
            </div>
          
          <div id="snippetReadinessExplanation" style="display: none; background: #fde68a; border-left: 4px solid #f59e0b; padding: 1rem; margin-bottom: 1rem; border-radius: 4px; font-size: 0.85rem; color: #78350f;">
            <strong id="explanationTitle" style="color: #78350f;">Top 5 Actions to Improve Snippet Readiness</strong>
            <p style="margin: 0.5rem 0; color: #78350f;">Prioritized actions based on your current scores and their impact on overall snippet readiness:</p>
            <ol id="topActionsList" style="margin: 0.5rem 0 0 1.5rem; padding: 0; list-style-type: decimal;">
              <!-- Top 5 actions will be populated dynamically -->
            </ol>
            </div>
          
          <!-- Overall Combined Score -->
          <div style="text-align: center; margin-bottom: 1.5rem;">
            <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">Overall Snippet Readiness</div>
            <div id="snippetReadinessScore" style="font-size: 3rem; font-weight: 700; color: var(--brand-orange); line-height: 1;">0</div>
            <div id="gaugeStatus" style="font-size: 0.9rem; color: #666; margin-top: 0.25rem;">Calculating...</div>
          </div>
          
          <!-- Pie Chart Container -->
          <div style="display: flex; align-items: center; justify-content: center; gap: 1.5rem; flex-wrap: wrap;">
            <div style="flex: 2; min-width: 400px; max-width: 500px;">
              <canvas id="snippetReadinessPieChart"></canvas>
            </div>
            <div style="flex: 1; min-width: 180px; max-width: 250px;">
              <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--brand-dark);">Component Breakdown:</div>
              <div id="snippetReadinessLegend" style="display: flex; flex-direction: column; gap: 0.5rem;">
                <!-- Legend will be populated by JavaScript -->
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="section-break"></div>

      <div class="chart-container">
        <h3>Score Trends</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Historical performance tracking for all five pillars (Local Entity, Service Area, Authority, Visibility, Content/Schema) over the selected date range.</p>
        <div id="trendAuthorityModeToggle" class="authority-mode-toggle" style="margin-bottom: 1rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; display: none;">
          <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
            <span style="font-weight: 600; color: #666;">Authority Mode:</span>
            <button id="trend-mode-all" class="authority-mode-btn" data-mode="all" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: #10b981; color: white; cursor: pointer; font-size: 0.75rem;">
              All pages
            </button>
            <button id="trend-mode-nonEducation" class="authority-mode-btn" data-mode="nonEducation" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
              Exclude education
            </button>
            <button id="trend-mode-money" class="authority-mode-btn" data-mode="money" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
              Money pages only
            </button>
          </div>
        </div>
        <div id="trendSummaryRow" class="trend-summary-row"></div>
        <canvas id="trendChart"></canvas>
      </div>
      </section>

      <!-- Money Pages Panel -->
      <section class="aigeo-panel" data-panel="money">
        <!-- Money Pages content will be inserted here by JS -->
      </section>

      <!-- Ranking & AI Panel -->
      <section class="aigeo-panel" data-panel="ranking">
        <div class="card card--section-header">
          <h2>Ranking &amp; AI Visibility</h2>
          <p class="ranking-intro">
            Keyword-level view of how search engines and AI systems see you. This is an overlay on the
            <strong>Visibility</strong>, <strong>Authority</strong>, <strong>Content/Schema</strong> and
            <strong>Local Entity</strong> pillars  it does not change their weights or scores.
          </p>

          <ul class="ranking-intro-bullets">
            <li><strong>Classic rankings</strong>  Visibility + Authority (Ranking component).</li>
            <li><strong>AI Overviews &amp; citations</strong>  Content/Schema + Authority.</li>
            <li><strong>Local packs</strong>  Local Entity + Service Area.</li>
          </ul>

          <div class="ranking-header-actions" style="display: flex; align-items: center; gap: 1rem;">
            <button id="ranking-ai-refresh" class="btn btn-secondary" type="button">
              Run ranking &amp; AI check
            </button>
            <button id="ranking-gsc-refresh" class="btn btn-secondary" type="button" style="background: #10b981; color: white; border: 1px solid #10b981; font-weight: 600; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;" title="Refresh CTR & Impressions from Google Search Console (no API costs)">
              Refresh GSC Data
            </button>
            <button id="edit-keywords-btn" class="btn btn-secondary" type="button" style="background: #2563eb; color: white; border: 1px solid #2563eb; font-weight: 600; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">
              Edit Keywords
            </button>
            <span id="ranking-ai-last-run" class="ranking-ai-last-run"></span>
          </div>
        </div>

        <!-- Edit Keywords Modal -->
        <div id="edit-keywords-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 10000; align-items: center; justify-content: center;">
          <div style="background: white; border-radius: 8px; padding: 2rem; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
              <h3 style="margin: 0; font-size: 1.5rem; color: #1e293b;">Edit Keywords</h3>
              <button id="edit-keywords-close" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #64748b; padding: 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;">&times;</button>
            </div>
            
            <!-- Warning and Instructions Box -->
            <div style="background: #fef3c7; border: 1px solid #fbbf24; border-radius: 6px; padding: 1rem; margin-bottom: 1.5rem;">
              <div style="display: flex; align-items: start; gap: 0.75rem;">
                <div style="color: #d97706; font-size: 1.25rem; line-height: 1; margin-top: 0.125rem;"></div>
                <div style="flex: 1;">
                  <div style="font-weight: 600; color: #92400e; font-size: 0.9rem; margin-bottom: 0.5rem;">Important: Data Loss Warning</div>
                  <ul style="margin: 0; padding-left: 1.25rem; color: #78350f; font-size: 0.85rem; line-height: 1.6;">
                    <li><strong>Removing keywords:</strong> All historical data (rankings, AI citations, SERP features) will be permanently deleted.</li>
                    <li><strong>Changing/renaming keywords:</strong> Treated as removing the old keyword and adding a new one. All data is lost and cannot be recovered.</li>
                    <li><strong>New keywords:</strong> Will appear in the list but won't have data until you run a "Ranking & AI check".</li>
                  </ul>
                  <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #fbbf24; color: #78350f; font-size: 0.85rem;">
                    <strong>Instructions:</strong> Enter one keyword per line. Changes will be saved immediately. Keywords will be updated on the next Ranking & AI check.
                    <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                      <label for="csv-upload" style="display: inline-flex; align-items: center; padding: 0.375rem 0.75rem; background: #3b82f6; color: white; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                         Upload CSV
                        <input type="file" id="csv-upload" accept=".csv,.txt" style="display: none;" />
                      </label>
                      <span style="color: #78350f; font-size: 0.8rem;">Upload a CSV file (one keyword per line, first column)</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <textarea id="edit-keywords-textarea" style="width: 100%; min-height: 300px; padding: 0.75rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.9rem; font-family: inherit; resize: vertical; box-sizing: border-box; color: #1e293b; background: white;"></textarea>
            <div style="display: flex; justify-content: flex-end; gap: 0.75rem; margin-top: 1.5rem;">
              <button id="edit-keywords-cancel" style="padding: 0.5rem 1rem; background: #f1f5f9; color: #475569; border: 1px solid #cbd5e1; border-radius: 4px; cursor: pointer; font-size: 0.9rem;">Cancel</button>
              <button id="edit-keywords-save" style="padding: 0.5rem 1rem; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; font-weight: 600;">Save Keywords</button>
            </div>
            <div id="edit-keywords-status" style="margin-top: 1rem; font-size: 0.85rem; color: #475569; min-height: 1.5rem;"></div>
          </div>
        </div>

        <!-- Section B: Metric pills row -->
        <div class="ranking-metric-pills">
          <div class="metric-pill metric-pill--neutral" id="ranking-card-tracked">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">Tracked keywords</div>
            <div class="metric-pill-status" data-field="status">Info only</div>
            <div class="metric-pill-footer">Used across Visibility &amp; Authority behaviour/ranking.</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-tracked')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-tracked-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-ai-coverage">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">AI Overview coverage</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Pillars: Visibility, Content/Schema</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-ai-coverage')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-ai-coverage-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-ai-citations">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">AI citations (alanranger.com)</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Pillars: Authority (Reviews), Content/Schema</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-ai-citations')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-ai-citations-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-top10">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">Top-10 rank coverage</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Pillars: Visibility, Authority (Ranking)</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-top10')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-top10-details"></div>
          </div>

          <div class="metric-pill metric-pill--red" id="ranking-card-serp-features">
            <div class="metric-pill-value" data-field="value"></div>
            <div class="metric-pill-label">SERP feature coverage</div>
            <div class="metric-pill-status" data-field="status"></div>
            <div class="metric-pill-footer">Pillars: Content/Schema, Local Entity</div>
            <div class="metric-pill-toggle" onclick="toggleMetricPillDetails('ranking-card-serp-features')">Show details</div>
            <div class="metric-pill-details" id="ranking-card-serp-features-details"></div>
          </div>
        </div>

        <!-- Global Insights & actions and Visibility metrics side by side (underneath summary tiles) -->
        <div class="ranking-cards-side-by-side">
          <!-- Global Insights & actions (all tracked keywords) -->
          <section class="card card--insights" id="ranking-ai-insights-card-global">
            <div class="card-header">
              <h2>Insights &amp; actions (all tracked keywords)</h2>
              <p class="card-subtitle">
                Recommendations based on how your tracked keywords currently rank in classic search and appear in AI Overviews.
                These insights are global, not tied to the selected keyword.
              </p>
            </div>
            <div class="card-pill-container" id="ranking-ai-insights-list-global">
              <!-- Content populated by renderRankingAiInsights -->
            </div>
          </section>

          <!-- Tracked keyword visibility metrics (DataForSEO only - not part of GAIO pillars) -->
          <div class="ranking-visibility-metrics-section" id="ranking-visibility-metrics">
            <div class="card" style="background: rgba(204, 255, 255, 0.15); border-left: 4px solid #CCFFFF;">
            <div class="card-header">
              <h4 style="font-size: 14pt !important; margin-bottom: 0.5rem;">Tracked keyword visibility (DataForSEO)</h4>
              <div style="font-size: 12pt !important; color: #666; margin-bottom: 0.75rem; line-height: 1.5;">
                <p style="margin-bottom: 0.5rem;">
                  These metrics use DataForSEO live rankings and Google Ads search volume for your tracked keyword set only.
                </p>
                <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                  <li><strong>Demand-weighted avg position</strong>  average Google rank where each keyword is weighted by its monthly search volume (high-demand terms pull this number more).</li>
                  <li><strong>Unweighted avg position</strong>  simple average rank across all tracked keywords, with each keyword counted equally.</li>
                </ul>
                <p style="margin-top: 0.5rem; margin-bottom: 0;">
                  These are diagnostic metrics for your tracked set; the main Visibility and Authority pillar scores are still calculated from full Google Search Console data across all queries and pages.
                </p>
              </div>
              <div style="display: flex; gap: 2rem; flex-wrap: wrap; font-size: 14pt !important; align-items: baseline;">
                <div>
                  <strong style="font-size: 13pt !important;">Demand-weighted avg position:</strong>
                  <span id="ranking-avg-position-weighted" style="font-weight: bold; color: #0284c7; font-size: 16pt !important; margin-left: 0.5rem;"></span>
                  <span title="Average rank for tracked keywords where each rank is weighted by the keyword's monthly search volume from DataForSEO." style="margin-left: 0.25rem; opacity: 0.6; cursor: help; font-size: 12pt !important;"></span>
                </div>
                <div style="font-size: 12pt !important; color: #666;">
                  <strong>Unweighted avg position:</strong>
                  <span id="ranking-avg-position-unweighted" style="font-weight: normal; margin-left: 0.5rem;"></span>
                  <span title="Simple average rank for all tracked keywords from DataForSEO, each keyword counted once." style="margin-left: 0.25rem; opacity: 0.6; cursor: help;"></span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Keyword Priority Matrix (Impact  Difficulty) - Full width below side-by-side cards -->
        <div class="ranking-priority-matrix-section" id="ranking-priority-matrix-section" style="display: none; width: 100%; clear: both; float: none;">
          <div class="card" style="background: rgba(204, 255, 255, 0.15); border-left: 4px solid #CCFFFF; padding: 1.5rem;">
            <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Keyword Priority  Impact & Difficulty</h3>
            <p style="margin: 0 0 1rem 0; font-size: 0.85rem; color: #64748b; line-height: 1.6;">
              Uses search volume share and current rank to surface the highest-impact keywords to work on.
              Impact is driven mainly by search volume share (global, not filter-relative) and opportunity score. Difficulty reflects current rank bucket (page 1 vs page 2+).
            </p>
            <div id="ranking-keyword-priority-matrix" style="background: #f8fafc; padding: 1rem; border-radius: 8px;">
              <!-- 3x3 grid rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Domain Strength (manual monthly snapshots) -->
        <div class="ranking-domain-strength-section" id="ranking-domain-strength-section" style="width: 100%; clear: both; float: none; margin: 1.5rem 0;">
          <div class="card" style="background: rgba(204, 255, 255, 0.15); border-left: 4px solid #CCFFFF; padding: 1.5rem;">
            <div style="display: flex; align-items: center; justify-content: space-between; gap: 1rem; flex-wrap: wrap;">
              <div>
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">
                  Domain Strength (Google  DataForSEO Labs)
                  <span
                    class="domain-strength-help"
                    title="Domain Strength (0100) is a composite score based on DataForSEO Labs. It combines:&#10; Estimated organic traffic value (visibility)&#10; Total organic keywords (breadth)&#10; Share of keywords ranking in Googles top 10 (quality)&#10;We calculate it monthly and store history so you can see trends over time."
                  >?</span>
                </h3>
                <p style="margin: 0; font-size: 0.9rem; color: #64748b; line-height: 1.6;">
                  Manual monthly snapshots based on DataForSEO Labs <code style="font-size: 0.85rem;">domain_rank_overview</code>.
                  Uses visibility (ETV), breadth (ranking keywords), and top10 share to produce a 0100 score.
                </p>
              </div>
              <div style="display: flex; gap: 0.75rem; align-items: center;">
                <button id="domain-strength-run-btn" class="btn btn-secondary" type="button">
                  Run Domain Strength Snapshot (Google)
                </button>
              </div>
            </div>

            <!-- Full-page progress overlay -->
            <div id="domain-strength-overlay" class="domain-strength-overlay">
              <div class="domain-strength-overlay-content">
                <div class="spinner"></div>
                <h3>Running Domain Strength Snapshot</h3>
                <p id="domain-strength-overlay-status">Fetching domain data from DataForSEO...</p>
              </div>
            </div>

            <!-- Completion modal -->
            <div id="domain-strength-completion-modal" class="domain-strength-overlay" style="display: none;">
              <div class="domain-strength-overlay-content" style="max-width: 500px;">
                <h3 style="margin: 0 0 1rem 0; font-size: 1.5rem; font-weight: 700; color: #1e293b;"> Snapshot Complete</h3>
                <div id="domain-strength-completion-stats" style="text-align: left; margin: 1.5rem 0;">
                  <!-- Stats will be inserted here -->
                </div>
                <button id="domain-strength-completion-close" class="btn btn-primary" style="margin-top: 1rem; width: 100%;">Close</button>
              </div>
            </div>

            <div class="domain-strength-summary-row">
              <div class="domain-strength-summary-card" id="domain-strength-summary-card">
                <div style="color:#64748b; font-size:0.95rem;">Loading domain strength</div>
              </div>
              <div style="font-size: 0.875rem; color: #64748b; line-height: 1.6;">
                <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #475569;">Understanding Domain Strength:</p>
                <ul style="margin: 0; padding-left: 1.25rem; list-style-type: disc;">
                  <li style="margin-bottom: 0.25rem;"><strong>Strength score (0-100):</strong> Composite metric combining estimated organic traffic value (visibility), total organic keywords (breadth), and share of keywords ranking in Google's top 10 (quality).</li>
                  <li style="margin-bottom: 0.25rem;"><strong>Band:</strong> Qualitative classification: Very weak (0-19), Weak (20-39), Moderate (40-59), Strong (60-79), Very strong (80-100).</li>
                  <li style="margin-bottom: 0.25rem;"><strong>ETV:</strong> Estimated Traffic Value in USD. DataForSEO's estimate of monthly organic traffic value based on keyword rankings and search volume.</li>
                  <li style="margin-bottom: 0.25rem;"><strong>Top-10 keywords:</strong> Number of keywords ranking in Google's top 10 positions. Higher counts indicate broader keyword coverage.</li>
                  <li style="margin-bottom: 0.25rem;"><strong>Change:</strong> Change in Strength score compared to the previous snapshot. Positive values (green ) indicate improvement.</li>
                  <li><strong>12-month trend:</strong> Visual graph showing Strength score over the last 12 months. Each point represents a monthly snapshot.</li>
                </ul>
              </div>
            </div>

            <div id="domain-strength-run-status" style="margin-top: 0.75rem; font-size: 0.875rem; color: #64748b;"></div>
            <h3 style="margin-top: 1.5rem; margin-bottom: 1rem; font-size: 1.25rem; font-weight: 600; color: #1e293b;">Competitors</h3>
            <div class="ranking-table-wrapper" style="margin-top: 1rem; max-height: none;">
              <div style="position: relative; overflow: visible; max-height: 80vh; overflow-y: auto;">
                <table class="ranking-table" id="domain-strength-table" style="position: relative;">
                  <thead id="domain-strength-thead" style="position: sticky; top: 0; z-index: 10; background: #f8fafc;">
                  <tr>
                    <th data-sort="name" class="sortable" title="Domain name or label for this site">
                      <div>Name <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Domain name or label for this site"></div>
                    </th>
                    <th data-sort="segment" class="sortable" title="Category or ownership segment (e.g., 'Your site' for your primary domain, or competitor segment)">
                      <div>Domain type <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Category or ownership segment (e.g., 'Your site' for your primary domain, or competitor segment)"></div>
                    </th>
                    <th data-sort="score" class="sortable" title="Domain Strength score (0-100). Composite metric combining: Estimated organic traffic value (visibility), Total organic keywords (breadth), and Share of keywords ranking in Google's top 10 (quality). Higher scores indicate stronger domain authority.">
                      <div>Strength score <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Domain Strength score (0-100). Composite metric combining: Estimated organic traffic value (visibility), Total organic keywords (breadth), and Share of keywords ranking in Google's top 10 (quality). Higher scores indicate stronger domain authority."></div>
                    </th>
                    <th data-sort="band" class="sortable" title="Qualitative band based on Strength score: Very weak (0-19), Weak (20-39), Moderate (40-59), Strong (60-79), Very strong (80-100)">
                      <div>Band <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Qualitative band based on Strength score: Very weak (0-19), Weak (20-39), Moderate (40-59), Strong (60-79), Very strong (80-100)"></div>
                    </th>
                    <th data-sort="etv" class="sortable" style="text-align:right;" title="Estimated Traffic Value (ETV). DataForSEO's estimate of monthly organic traffic value in USD based on keyword rankings and search volume. Higher values indicate more valuable organic traffic potential.">
                      <div style="text-align:right;">ETV <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Estimated Traffic Value (ETV). DataForSEO's estimate of monthly organic traffic value in USD based on keyword rankings and search volume. Higher values indicate more valuable organic traffic potential."></div>
                    </th>
                    <th data-sort="top10" class="sortable" style="text-align:right;" title="Number of keywords ranking in Google's top 10 positions. Higher counts indicate broader keyword coverage and stronger domain authority across multiple search terms.">
                      <div style="text-align:right; line-height: 1.2;">Top10<br>keywords <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Number of keywords ranking in Google's top 10 positions. Higher counts indicate broader keyword coverage and stronger domain authority across multiple search terms."></div>
                    </th>
                    <th data-sort="change" class="sortable" style="text-align:center;" title="Change in Strength score compared to the previous snapshot. Positive values (green ) indicate improvement, negative values (red ) indicate decline. Shows how domain strength is trending between snapshots.">
                      <div>Change <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Change in Strength score compared to the previous snapshot. Positive values (green ) indicate improvement, negative values (red ) indicate decline. Shows how domain strength is trending between snapshots."></div>
                    </th>
                    <th style="text-align:center;" title="Visual trend graph showing Strength score over the last 12 months. Each point represents a monthly snapshot. Helps identify long-term trends and patterns in domain authority changes.">
                      <div>12month trend</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Visual trend graph showing Strength score over the last 12 months. Each point represents a monthly snapshot. Helps identify long-term trends and patterns in domain authority changes."></div>
                    </th>
                    <th style="text-align:center;" title="Mark this domain as a competitor">
                      <div>Competitor</div>
                    </th>
                  </tr>
                  </tr>
                </thead>
                <tbody id="domain-strength-table-body">
                  <tr><td colspan="9" class="ranking-table-empty">No domain strength snapshots yet. Click "Run Domain Strength Snapshot".</td></tr>
                </tbody>
              </table>
              </div>
            </div>
            <div id="domain-strength-pagination-controls" style="margin-top: 1rem; display: flex; justify-content: space-between; align-items: center; padding-top: 1rem; border-top: 1px solid #e2e8f0; flex-wrap: wrap; gap: 1rem;">
              <div style="font-size: 0.85rem; color: #64748b;">
                <span id="domain-strength-pagination-info">Page 1 of 1  Total: 0</span>
              </div>
              <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #475569;">
                  Rows per page:
                  <select id="domain-strength-rows-per-page" style="padding: 0.4rem 0.6rem; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.85rem; background: white; cursor: pointer;">
                    <option value="10" selected>10</option>
                    <option value="25">25</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                    <option value="all">All</option>
                  </select>
                </label>
                <button id="domain-strength-pagination-prev" type="button" disabled style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cbd5e1; background: #f1f5f9; cursor: not-allowed; color: #94a3b8; font-weight: 600;">
                  Previous
                </button>
                <button id="domain-strength-pagination-next" type="button" disabled style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cbd5e1; background: #f1f5f9; cursor: not-allowed; color: #94a3b8; font-weight: 600;">
                  Next
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Section C: Filters + full-width table -->
        <div class="ranking-table-section" style="width: 100%; clear: both; float: none;">
          <div class="card">
            <div class="card-header">
              <h3>Keyword rankings &amp; AI usage</h3>
              <p class="card-subtitle ranking-subtitle-tight" style="max-width: 100%; width: 100%;">
                Keyword-level inputs to <strong>Visibility</strong> and the <strong>Authority  Behaviour / Ranking</strong> components. Search volume shows demand for each tracked keyword (Visibility pillar). Combined with AI citations, it also highlights topics where you have strong or weak Authority. AI columns show where <strong>Content/Schema</strong> helps make you a source.
              </p>
            </div>
            <!-- Preset buttons -->
            <div class="ranking-presets-section" style="padding: 1rem 1.5rem; border-bottom: 1px solid #e2e8f0; background: #f8fafc;">
              <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center;">
                <span style="font-size: 0.875rem; font-weight: 600; color: #475569; margin-right: 0.5rem;">Presets:</span>
                <button type="button" class="ranking-preset-btn" data-preset="all" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Reset all filters and restore default sort">
                  All keywords
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="high-impact-money" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Segment: Money | Best rank: 1120 | Search volume: High | Min opportunity:  65 | Sort: Opportunity ">
                  High-impact money
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="ai-overview-not-cited" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="AI Overview: On | AI citation: Not cited | Min opportunity:  50 | Sort: Volume ">
                  AI Overview, not cited
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="brand-safety" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Segment: Brand | Best rank: Not top 3 | Sort: Rank  (worst first)">
                  Brand safety
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="education-growth" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Page type: Blog | Best rank: Not top 3 | Min opportunity:  30 | Sort: Opportunity ">
                  Blog opportunities
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="local-visibility" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Page type: GBP | Best rank: Not top 3 | Min opportunity:  30 | Sort: Opportunity ">
                  Local visibility
                </button>
                <button type="button" class="ranking-preset-btn" data-preset="top-10-opportunities" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 6px; background: rgb(229, 255, 204); cursor: pointer; color: #475569; font-weight: 500; transition: all 0.2s; position: relative;" onmouseover="if (!this.classList.contains('preset-active')) { this.style.background='rgb(210, 240, 180)'; this.style.borderColor='#94a3b8'; }" onmouseout="if (!this.classList.contains('preset-active')) { this.style.background='rgb(229, 255, 204)'; this.style.borderColor='#cbd5e1'; }" title="Best rank: Not top 3 | Min opportunity:  50 | Sort: Opportunity  | Shows top 10 results">
                  Top 10 opportunities
                </button>
              </div>
              <!-- Criteria chips (shown when preset is active) -->
              <div id="ranking-preset-criteria-chips" style="display: none; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0;">
                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center;">
                  <!-- Chips will be inserted here by JavaScript -->
                </div>
              </div>
            </div>
            <div class="ranking-filters-section" style="padding: 1rem 1.5rem; border-bottom: 1px solid #e2e8f0;">
              <div class="ranking-filter-bar" style="display: flex; flex-wrap: nowrap; gap: 0.75rem; align-items: flex-end; margin-bottom: 0.75rem;">
                <div class="filter-group">
                  <label>Segment:</label>
                  <select id="ranking-filter-segment" class="filter-control">
                    <option value="all">All</option>
                    <option value="brand">Brand</option>
                    <option value="money">Money</option>
                    <option value="education">Education</option>
                    <option value="other">Other</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Best rank:</label>
                  <select id="ranking-filter-rank" class="filter-control">
                    <option value="all">All</option>
                    <option value="top3">Top 3</option>
                    <option value="4-10">410</option>
                    <option value="11-20">1120</option>
                    <option value="21+">21+ / Not ranked</option>
                    <option value="not-top3">Not top 3</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Search volume:</label>
                  <select id="ranking-filter-volume" class="filter-control">
                    <option value="all">All</option>
                    <option value="high">High (200+)</option>
                    <option value="medium">Medium (50-199)</option>
                    <option value="low">Low (1-49)</option>
                    <option value="none">None</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>CTR:</label>
                  <select id="ranking-filter-ctr" class="filter-control">
                    <option value="all">All</option>
                    <option value="high">High (5%)</option>
                    <option value="medium">Medium (2-4.9%)</option>
                    <option value="low">Low (<2%)</option>
                    <option value="none">No data</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Opportunity score: <span title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10; Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10; Classic ranking strength (page 1 vs page 2+ and current position).&#10; AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first.&#10;&#10;Bands: Low <40  Medium 4069  High 70" style="opacity: 0.6; cursor: help;"></span></label>
                  <select id="ranking-filter-opportunity" class="filter-control">
                    <option value="all">All</option>
                    <option value="high">High ( 70)</option>
                    <option value="medium">Medium (4069)</option>
                    <option value="low">Low (< 40)</option>
                  </select>
                </div>
                <div class="filter-group">
                  <label>Min opportunity:</label>
                  <input type="number" id="ranking-filter-min-opportunity" class="filter-control" placeholder="e.g. 65" min="0" max="100" step="1" style="width: 80px;">
                  <div id="ranking-filter-min-opportunity-note" style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem; display: none;">
                    Min opportunity overrides band selection.
                  </div>
                </div>

                <div class="filter-group">
                  <label>AI Overview:</label>
                  <select id="ranking-filter-ai-overview" class="filter-control">
                    <option value="all">All</option>
                    <option value="has">Has AI Overview</option>
                    <option value="no">No AI Overview</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>AI citation:</label>
                  <select id="ranking-filter-ai-citation" class="filter-control">
                    <option value="all">All</option>
                    <option value="cited">Cited in AI</option>
                    <option value="not-cited">Not cited</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Page type:</label>
                  <select id="ranking-filter-page-type" class="filter-control">
                    <option value="all">All</option>
                    <option value="GBP">GBP</option>
                    <option value="Blog">Blog</option>
                    <option value="Landing">Landing</option>
                    <option value="Event">Event</option>
                    <option value="Product">Product</option>
                    <option value="Other">Other</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>SERP features:</label>
                  <select id="ranking-filter-serp-features" class="filter-control">
                    <option value="all">All</option>
                    <option value="ai-overview">AI Overview</option>
                    <option value="local-pack">Local pack</option>
                    <option value="paa">People Also Ask</option>
                    <option value="featured-snippet">Featured snippet</option>
                    <option value="none">None</option>
                  </select>
                </div>

                <div class="filter-group">
                  <label>Optimisation status: <span title="Filter keywords by their optimisation tracking status. Shows whether optimisation work is planned, in progress, being monitored, completed, paused, cancelled, or not yet tracked." style="opacity: 0.6; cursor: help;"></span></label>
                  <select id="ranking-filter-optimisation-status" class="filter-control">
                    <option value="all">All</option>
                    <option value="not-tracked">Not tracked</option>
                    <option value="planned">Planned</option>
                    <option value="in_progress">In progress</option>
                    <option value="monitoring">Monitoring</option>
                    <option value="done">Done</option>
                    <option value="paused">Paused</option>
                    <option value="cancelled">Cancelled</option>
                  </select>
                </div>
              </div>

              <div style="display: flex; gap: 0.75rem; align-items: flex-end;">
                <div class="filter-group filter-group-search" style="flex: 1; min-width: 300px;">
                  <label>Search:</label>
                  <input type="text" id="ranking-filter-keyword" class="filter-control" placeholder="Filter by keyword...">
                </div>

                <div class="filter-group filter-group-button" style="align-items: end;">
                  <button id="ranking-filter-clear" class="btn btn-small" style="width: 100%;">Clear filters</button>
                </div>
              </div>
            </div>
            <div class="ranking-table-wrapper" style="max-height: none;">
              <table class="ranking-table" id="ranking-ai-table">
                <thead>
                  <tr>
                    <th data-sort="keyword" class="sortable" title="The tracked keyword or search query.">
                      <div>Keyword <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="The tracked keyword or search query."></div>
                    </th>
                    <th data-sort="segment" class="sortable" title="Keyword intent segment: Brand (branded queries), Money (commercial intent), Education (informational), or Other.">
                      <div>Segment <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Keyword intent segment: Brand (branded queries), Money (commercial intent), Education (informational), or Other."></div>
                    </th>
                    <th data-sort="rank" class="sortable" title="Current organic search ranking position for this keyword. Lower numbers are better (1 is the top position).">
                      <div>Current organic rank <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Current organic search ranking position for this keyword. Lower numbers are better (1 is the top position)."></div>
                    </th>
                    <th data-sort="volume" class="sortable" title="Average monthly Google search volume for this keyword in the UK. Source: DataForSEO Labs  Keyword Overview.">
                      <div>Search volume <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Average monthly Google search volume for this keyword in the UK. Source: DataForSEO Labs  Keyword Overview."></div>
                    </th>
                    <th data-sort="ctr" class="sortable" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days.">
                      <div>CTR (28d) <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days (matches GSC UI)."></div>
                    </th>
                    <th data-sort="impressions30d" class="sortable" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days.">
                      <div>Impressions (28d) <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Google Search Console. Query-only (keyword totals across all pages). Last 28 days (matches GSC UI)."></div>
                    </th>
                    <th data-sort="opportunityScore" class="sortable" title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10; Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10; Classic ranking strength (page 1 vs page 2+ and current position).&#10; AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first.">
                      <div>Opportunity score <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Keyword opportunity score&#10;Combines three signals for this tracked keyword:&#10; Search volume share (how much search volume this query represents in your tracked set - global, not filter-relative).&#10; Classic ranking strength (page 1 vs page 2+ and current position).&#10; AI usage (whether AI Overviews exist and if you're cited).&#10;Higher scores highlight the best &quot;bang-for-buck&quot; queries to improve first."></div>
                    </th>
                    <th title="Whether Google AI Overview is present in SERP results for this keyword.">
                      <div>AI Overview</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Whether Google AI Overview is present in SERP results for this keyword."></div>
                    </th>
                    <th data-sort="citations" class="sortable" title="Number of citations from your domain (alanranger.com) out of total citations in AI Overview for this keyword.">
                      <div>AI citations <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Number of citations from your domain (alanranger.com) out of total citations in AI Overview for this keyword."></div>
                    </th>
                    <th title="This is the traditional blue link in SERP results.">
                      <div>Classic Ranking URL</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="This is the traditional blue link in SERP results."></div>
                    </th>
                    <th data-sort="pageType" class="sortable" title="Type of page that ranks for this keyword: GBP (Google Business Profile), Landing (landing page), Event (event/workshop page), Product (product/service page), or Other.">
                      <div>Page type <span class="sort-indicator"></span></div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Type of page that ranks for this keyword: GBP (Google Business Profile), Landing (landing page), Event (event/workshop page), Product (product/service page), or Other."></div>
                    </th>
                    <th title="Optimisation tracking status for this keyword and target URL. Shows whether optimisation work is planned, in progress, being monitored, or completed.">
                      <div>Optimisation</div>
                      <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Optimisation tracking status for this keyword and target URL. Shows whether optimisation work is planned, in progress, being monitored, or completed."></div>
                    </th>
                  </tr>
                </thead>
                <tbody id="ranking-ai-table-body">
                  <tr><td colspan="12" class="ranking-table-empty">Click "Run ranking &amp; AI check" to load data.</td></tr>
                </tbody>
              </table>
            </div>
            <div class="ranking-pagination-controls" id="ranking-pagination-controls" style="display: none;">
              <div class="ranking-pagination-info" id="ranking-pagination-info">
                Showing 0-0 of 0
              </div>
              <div class="ranking-pagination-buttons">
                <button id="ranking-pagination-first" type="button">First</button>
                <button id="ranking-pagination-prev" type="button">Previous</button>
                <span id="ranking-pagination-page-info" style="padding: 0 0.5rem; font-size: 0.875rem;">Page 1 of 1</span>
                <button id="ranking-pagination-next" type="button">Next</button>
                <button id="ranking-pagination-last" type="button">Last</button>
              </div>
              <div class="ranking-rows-per-page">
                <label>Rows per page:</label>
                <select id="ranking-rows-per-page">
                  <option value="10" selected>10</option>
                  <option value="25">25</option>
                  <option value="50">50</option>
                  <option value="100">100</option>
                  <option value="all">All</option>
                </select>
              </div>
            </div>
          </div>
        </div>

        <!-- Section D: Keyword details & insights (three columns: 33% each) -->
        <div class="ranking-details-grid">
          <div class="card" id="ranking-ai-detail-card">
            <div class="card-header">
              <h3>Keyword Scorecard</h3>
              <p class="card-subtitle ranking-subtitle-tight">
                Detailed analysis of the selected keyword's impact, difficulty, and recommended actions. Shows demand, ranking strength, AI usage, and priority.
              </p>
            </div>
            <div class="ranking-ai-detail-body">
              <p id="ranking-ai-detail-empty">
                Select a keyword in the table or a cell in the priority grid to see a detailed scorecard.
              </p>
              <div id="ranking-ai-detail-content" class="ranking-ai-detail-content" hidden>
                <h4 id="ranking-ai-detail-keyword"></h4>
                <p id="ranking-ai-detail-summary"></p>
              </div>
            </div>
          </div>

          <div class="card" id="ranking-ai-competitors-card">
            <div class="card-header">
              <h3>Competitors in AI &amp; SERPs</h3>
              <p class="card-subtitle ranking-subtitle-tight">
                Domains that appear repeatedly in AI citations and/or classic top-10 rankings. Competitive backdrop for <strong>Authority</strong> and <strong>Visibility</strong>.
              </p>
            </div>
            <div style="padding: 0 1.25rem 1.25rem 1.25rem;">
              <div style="overflow-x: auto; max-width: 100%;">
                <table id="ranking-ai-competitors-table" style="width: 100%; border-collapse: collapse; table-layout: fixed; font-size: 0.8rem;">
                  <thead>
                    <tr style="background: #f1f5f9;">
                      <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 35%; word-wrap: break-word;">Domain</th>
                      <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 20%;">AI citations</th>
                      <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 25%;">Domain Rank</th>
                      <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 15%; word-wrap: break-word; line-height: 1.2;">
                        <div style="display: flex; flex-direction: column; align-items: flex-start;">
                          <span>Domain</span>
                          <span>type</span>
                        </div>
                      </th>
                      <th style="text-align: center; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 5%;">C</th>
                    </tr>
                  </thead>
                  <tbody id="ranking-ai-competitors-body"></tbody>
                </table>
              </div>
              <p style="margin: 0.75rem 0 0 0; font-size: 0.8rem; color: #64748b;">
                Domain Rank is sourced from your latest Domain Strength snapshot (0100).
              </p>
            </div>
          </div>

          <div class="card" id="ranking-ai-citations-card">
            <div class="card-header">
              <h3>AI Citations for Selected Keyword</h3>
              <p class="card-subtitle ranking-subtitle-tight">
                Pages from alanranger.com and other domains cited in AI Overviews for the selected keyword.
              </p>
            </div>
            <div class="ranking-ai-detail-body">
              <p id="ranking-ai-citations-empty">
                Select a keyword in the table to see AI citations.
              </p>
              <div id="ranking-ai-citations-content" hidden>
                <p class="card-subtitle ranking-subtitle-tight" style="margin-bottom: 1rem;">
                  Pages from alanranger.com and other domains cited in AI Overviews for the selected keyword.
                </p>
                <h5>Your cited pages</h5>
                <ul id="ranking-ai-detail-our-pages" class="ranking-ai-detail-list"></ul>

                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                  <h5 style="margin: 0;">Other cited domains</h5>
                  <button id="backfill-domain-ranks-btn" onclick="backfillMissingDomainRanks()" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;" title="Fetch Domain Rank for domains currently showing ''">Backfill Missing Ranks</button>
                </div>
                <div style="overflow-x: auto; margin-top: 0.5rem; max-width: 100%;">
                  <table id="ranking-ai-detail-competitors-table" style="width: 100%; border-collapse: collapse; table-layout: fixed; font-size: 0.8rem;">
                    <thead>
                      <tr style="background: #f1f5f9;">
                        <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 28%; word-wrap: break-word;">Domain</th>
                        <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 12%;">Citations</th>
                        <th style="text-align: right; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 18%;">Domain Rank</th>
                        <th style="text-align: left; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 16%; word-wrap: break-word; line-height: 1.2;">
                          <div style="display: flex; flex-direction: column; align-items: flex-start;">
                            <span>Domain</span>
                            <span>type</span>
                          </div>
                        </th>
                        <th style="text-align: center; padding: 0.5rem 0.4rem; font-size: 0.8rem; color: #475569; font-weight: 700; width: 26%;">Competitor</th>
                      </tr>
                    </thead>
                    <tbody id="ranking-ai-detail-competitors-body"></tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- AI Sources & Influence Panel -->
      <section class="aigeo-panel" data-panel="ai-sources">
        <div class="container" style="max-width: 1400px; margin: 0 auto; padding: 2rem;">
          <div class="card" style="margin-bottom: 2rem;">
            <div class="card-header">
              <h2>AI Sources & Influence</h2>
              <p class="card-subtitle">
                Domains that AI relies on most often when answering your tracked keywords. Identify which external sources you should strengthen or join so AI is more confident recommending you.
              </p>
            </div>
          </div>

          <!-- Summary Tiles -->
          <div id="ai-sources-tiles" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
            <!-- Tiles will be populated by JS -->
          </div>

          <!-- Source Types & Quick Insights -->
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 2rem;">
            <!-- Left: Source Types Overview -->
            <div class="card">
              <div class="card-header">
                <h3>Source Types Overview</h3>
              </div>
              <div class="card-body" id="ai-sources-types-breakdown">
                <p style="color: #64748b; text-align: center; padding: 2rem;">Loading source types...</p>
              </div>
            </div>

            <!-- Right: AI Influence Summary -->
            <div class="card ai-sources-explainer">
              <div class="card-header">
                <h3>How to read this tab</h3>
              </div>
              <div class="card-body">
                <p style="line-height: 1.6; margin-bottom: 0.75rem;">
                  This view shows the domains AI relies on most often when answering your tracked keywords.
                </p>
                <ul style="line-height: 1.8;">
                  <li>Repeated citations from the same domain signal trusted sources in your niche.</li>
                  <li>Directories and review platforms highlight places where you need consistent NAP, reviews and listings.</li>
                  <li>Course marketplaces and education sites show where learners are discovering alternatives to your workshops and lessons.</li>
                </ul>
                <p style="line-height: 1.6; margin-top: 0.75rem; font-weight: 600;">
                  The goal is to identify which external sources you should strengthen or join so AI is more confident recommending you.
                </p>
              </div>
            </div>
          </div>
        </div>

          <!-- Domain Influence Table -->
          <div class="card ai-sources-domain-table-card">
            <div class="card-header">
              <h3>Domain Influence Table</h3>
              <div style="display: flex; gap: 1rem; margin-top: 1rem; flex-wrap: wrap;">
                <div class="filter-group">
                  <label>Source type:</label>
                  <select id="ai-sources-filter-type" class="filter-control">
                    <option value="all">All</option>
                    <option value="Directory">Directory</option>
                    <option value="Review platform">Review platform</option>
                    <option value="Course marketplace / education">Course marketplace / education</option>
                    <option value="Publisher / blog">Publisher / blog</option>
                    <option value="Other">Other</option>
                  </select>
                </div>
                <div class="filter-group">
                  <label>Domain type:</label>
                  <select id="ai-sources-filter-domain-type" class="filter-control">
                    <option value="all">All</option>
                    <option value="self">Your site</option>
                    <option value="competitor">Competitor</option>
                    <option value="site">Site</option>
                    <option value="platform">Platform</option>
                    <option value="directory">Directory</option>
                    <option value="publisher">Publisher</option>
                    <option value="vendor">Vendor</option>
                    <option value="institution">Institution</option>
                    <option value="government">Government</option>
                    <option value="unmapped">Unmapped</option>
                  </select>
                </div>
                <div class="filter-group">
                  <label>Search:</label>
                  <input type="text" id="ai-sources-filter-domain" class="filter-control" placeholder="Filter by domain...">
                </div>
                <button id="ai-sources-filter-clear" class="btn btn-small">Clear filters</button>
              </div>
            </div>
            <div class="ranking-table-wrapper">
              <table class="ranking-table" id="ai-sources-table">
                <thead style="position: sticky; top: 0; z-index: 20; background: white;">
                  <tr>
                    <th data-sort="domain" class="sortable" style="background: white;">Domain <span class="sort-indicator"></span></th>
                    <th data-sort="domain_type" class="sortable" style="background: white;">Domain type <span class="sort-indicator"></span></th>
                    <th data-sort="competitor" class="sortable" style="background: white;">Competitor <span class="sort-indicator"></span></th>
                    <th data-sort="rank" class="sortable" style="background: white;">Domain Rank <span class="sort-indicator"></span></th>
                    <th data-sort="citations" class="sortable" style="background: white;">AI citations <span class="sort-indicator"></span></th>
                    <th data-sort="keywords" class="sortable" style="background: white;">Keywords <span class="sort-indicator"></span></th>
                    <th data-sort="share" class="sortable" style="background: white;">Citation share <span class="sort-indicator"></span></th>
                    <th style="background: white;">Example page</th>
                  </tr>
                </thead>
                <tbody id="ai-sources-table-body">
                  <tr><td colspan="8" class="ranking-table-empty">Loading domain data...</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- Domain Detail Panel (Right Side) -->
          <div id="ai-sources-detail-panel" style="display: none; margin-top: 2rem;">
            <div class="card">
              <div class="card-header">
                <h3 id="ai-sources-detail-domain">Domain Details</h3>
                <p id="ai-sources-detail-meta" class="card-subtitle"></p>
              </div>
              <div class="card-body" id="ai-sources-detail-content">
                <!-- Content populated by JS -->
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Local & Reviews Panel -->
      <section class="aigeo-panel" data-panel="local">
        <!-- Local entity, GBP, reviews content will be inserted here by JS -->
      </section>

      <!-- Optimisation Tracking Panel -->
      <section class="aigeo-panel" data-panel="optimisation" hidden>
        <div class="card card--section-header" style="display: flex; justify-content: space-between; align-items: center;">
          <div>
            <h2>Optimisation Tracking</h2>
            <p>Track and manage keyword optimisation tasks across your site. Monitor progress, cycles, and outcomes.</p>
          </div>
          <button id="optimisation-bulk-update-btn" class="btn" style="padding: 0.75rem 1.5rem; font-size: 0.95rem; white-space: nowrap;" title="Captures the latest metrics for every active task (creates a measurement entry).">
             Update All Tasks with Latest Data
          </button>
        </div>

        <!-- Summary Cards (B6) -->
        <h2 style="color: var(--dark-text) !important; font-size: 1.5rem; font-weight: 600; margin: 2rem 0 1rem 0;">Task Counts</h2>
        <div class="optimisation-summary-cards" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1.5rem 0;">
          <div class="card" title="Tasks with status: planned, in_progress, or monitoring (not done, cancelled, or deleted).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-active"></div>
            <div style="margin-top: 0.5rem;">Active Tasks</div>
          </div>
          <div class="card" title="Tasks with status: planned (task created but work not started).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-planned"></div>
            <div style="margin-top: 0.5rem;">Planned</div>
          </div>
          <div class="card" title="Tasks with status: in_progress (actively being worked on).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-in-progress"></div>
            <div style="margin-top: 0.5rem;">In Progress</div>
          </div>
          <div class="card" title="Tasks with status: monitoring (changes deployed, tracking results).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-monitoring"></div>
            <div style="margin-top: 0.5rem;">Monitoring</div>
          </div>
          <div class="card" title="Tasks with status: done (cycle completed; start a new cycle if optimising again).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-done"></div>
            <div style="margin-top: 0.5rem;">Done</div>
          </div>
          <div class="card" title="Tasks with status: paused (tracking stopped; you can start a new cycle later).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-paused"></div>
            <div style="margin-top: 0.5rem;">Paused</div>
          </div>
          <div class="card" title="Tasks with status: cancelled (tracking stopped; you can start a new cycle later).">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-cancelled"></div>
            <div style="margin-top: 0.5rem;">Cancelled</div>
          </div>
          <div class="card" title="Tasks that have had a measurement event created in the last 30 days.">
            <div style="font-size: 2rem; font-weight: bold;" id="optimisation-summary-recent"></div>
            <div style="margin-top: 0.5rem;">Updated (30d)</div>
          </div>
        </div>

        <!-- Divider line between Task Counts and Objectives -->
        <hr style="border: none; border-top: 1px solid rgba(156, 163, 175, 0.3); margin: 2rem 0;">

        <!-- Goal Rollup Badges (Phase B) -->
        <h2 style="color: var(--dark-text) !important; font-size: 1.5rem; font-weight: 600; margin: 2rem 0 1rem 0;">Objectives</h2>
        <div class="optimisation-goal-rollups" style="display: flex; gap: 0.75rem; margin: 1rem 0; flex-wrap: wrap; align-items: center;">
          <div style="font-weight: 600; color: #475569; margin-right: 0.5rem;">Objectives:</div>
          <span id="optimisation-goal-filter-not-set" class="ranking-badge ranking-badge--segment-general" style="padding: 0.5rem 1rem; cursor: pointer;" title="Tasks with no objective set (no KPI, target, or timeframe defined). Click to filter.">
            Not set: <span id="optimisation-goal-not-set">0</span>
          </span>
          <span id="optimisation-goal-filter-on-track" class="ranking-badge ranking-badge--segment-education" style="padding: 0.5rem 1rem; cursor: pointer;" title="Objective set and not yet due, or delta is moving in the right direction but hasn't met target yet. Click to filter.">
            On track: <span id="optimisation-goal-on-track">0</span>
          </span>
          <span id="optimisation-goal-filter-overdue" class="ranking-badge ranking-badge--segment-money" style="padding: 0.5rem 1rem; background: #fee2e2; color: #991b1b; cursor: pointer;" title="Due date has passed and target has not been met. Click to filter.">
            Overdue: <span id="optimisation-goal-overdue">0</span>
          </span>
          <span id="optimisation-goal-filter-met" class="ranking-badge ranking-badge--segment-brand" style="padding: 0.5rem 1rem; background: #d1fae5; color: #065f46; cursor: pointer;" title="Target has been met (delta meets or exceeds target value). Click to filter.">
            Met: <span id="optimisation-goal-met">0</span>
          </span>
        </div>

        <!-- Objective Metrics Traffic Lights (7 columns: All Metrics aggregated + 6 individual metrics) -->
        <div class="optimisation-objective-metrics" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 1rem; margin: 2rem 0;">
          <!-- All Metrics (Aggregated) -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">All Metrics</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div class="traffic-light-pill" data-metric="all_metrics" data-bucket="worse" style="background: rgba(239, 68, 68, 0.2);" onclick="handleTrafficLightClick('all_metrics', 'worse')">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-all-metrics-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div class="traffic-light-pill" data-metric="all_metrics" data-bucket="same" style="background: rgba(245, 158, 11, 0.2);" onclick="handleTrafficLightClick('all_metrics', 'same')">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-all-metrics-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div class="traffic-light-pill" data-metric="all_metrics" data-bucket="better" style="background: rgba(16, 185, 129, 0.2);" onclick="handleTrafficLightClick('all_metrics', 'better')">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-all-metrics-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- CTR (28d) -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">CTR (28d)</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div class="traffic-light-pill" data-metric="ctr_28d" data-bucket="worse" style="background: rgba(239, 68, 68, 0.2);" onclick="handleTrafficLightClick('ctr_28d', 'worse')">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-ctr-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div class="traffic-light-pill" data-metric="ctr_28d" data-bucket="same" style="background: rgba(245, 158, 11, 0.2);" onclick="handleTrafficLightClick('ctr_28d', 'same')">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-ctr-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div class="traffic-light-pill" data-metric="ctr_28d" data-bucket="better" style="background: rgba(16, 185, 129, 0.2);" onclick="handleTrafficLightClick('ctr_28d', 'better')">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-ctr-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- Impressions (28d) -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">Impressions (28d)</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-impressions-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-impressions-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-impressions-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- Clicks (28d) -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">Clicks (28d)</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-clicks-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-clicks-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-clicks-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- Rank -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">Rank</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-rank-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-rank-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-rank-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- AI Citations -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">AI Citations</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-ai-citations-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-ai-citations-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-ai-citations-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

          <!-- AI Overview -->
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="text-align: center; margin-bottom: 0.5rem; color: #ffffff; font-size: 1.5rem; font-weight: 700;">AI Overview</div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-size: 2rem; opacity: 0.8;"></div>
            <div style="background: rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;" id="objective-ai-overview-red">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Worse</div>
            </div>
            <div style="background: rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;" id="objective-ai-overview-amber">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Same</div>
            </div>
            <div style="background: rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1rem; text-align: center; border: 1px solid var(--dark-border);">
              <div style="font-size: 2rem; font-weight: 700; color: #34d399;" id="objective-ai-overview-green">0</div>
              <div style="color: var(--dark-text); font-size: 0.875rem; margin-top: 0.5rem;">Better</div>
            </div>
          </div>

        </div>

        <!-- Faint gray line separator after traffic lights -->
        <div style="height: 1px; background: rgba(156, 163, 175, 0.3); margin: 2rem 0;"></div>

        <!-- Phase 9: KPI Tiles (RAG) -->
        <div class="optimisation-kpi-tiles" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 1rem; margin: 1.5rem 0;">
          <div class="card" style="cursor: pointer;" id="kpi-tile-ctr-on-track" onclick="filterByKPIRAG('ctr', 'on_track')" title="CTR objectives that are on track. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-ctr-on-track">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">CTR: On track</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-ctr-at-risk" onclick="filterByKPIRAG('ctr', 'at_risk')" title="CTR objectives at risk (due within 7 days). Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-ctr-at-risk">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">CTR: At risk</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-ctr-overdue" onclick="filterByKPIRAG('ctr', 'overdue')" title="CTR objectives that are overdue. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-ctr-overdue">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">CTR: Overdue</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-rank-improved" onclick="filterByRankDelta('improved')" title="Rank objectives with improved rank (lower is better). Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-rank-improved">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Rank: Improved</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-rank-worse" onclick="filterByRankDelta('worse')" title="Rank objectives with worsened rank. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-rank-worse">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Rank: Worse</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-rank-flat" onclick="filterByRankDelta('flat')" title="Rank objectives with no change. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-rank-flat">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Rank: Flat</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-ai-gap" onclick="filterByAIGap()" title="Tasks with AI Overview on but citations = 0. Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-ai-gap">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">AI Citation Gap</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-needs-measurement" onclick="filterByNeedsMeasurement()" title="Tasks needing measurement update (>30 days or missing). Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-needs-measurement">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Needs Measurement</div>
          </div>
          <div class="card" style="cursor: pointer;" id="kpi-tile-overdue-cycles" onclick="filterByOverdueCycles()" title="Tasks with overdue cycles (past due date and target not met). Click to filter.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="kpi-overdue-cycles">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Overdue Cycles</div>
          </div>
        </div>

        <!-- Phase 9: Estimated Impact Tiles -->
        <div class="optimisation-impact-tiles" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin: 1.5rem 0;">
          <div class="card" id="impact-extra-clicks-card" title="Estimated extra clicks available if all CTR objectives meet their targets.">
            <div style="font-size: 1.5rem; font-weight: bold;" id="impact-extra-clicks">0</div>
            <div style="margin-top: 0.25rem; font-size: 0.875rem;">Estimated Extra Clicks (28d)</div>
          </div>
        </div>

        <!-- Phase 9: Scope Toggle -->
        <div class="optimisation-scope-toggle" style="display: flex; align-items: center; gap: 1rem; margin: 1.5rem 0; padding: 1rem; background: #f9fafb; border-radius: 8px;">
          <label style="font-weight: 600; color: #374151;">Scope:</label>
          <select id="optimisation-scope-select" style="padding: 0.5rem 1rem; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer; font-size: 0.875rem;">
            <option value="active_cycle">Active Cycle Only</option>
            <option value="all_tasks">All Tasks</option>
          </select>
          <span style="font-size: 0.875rem; color: #6b7280;" id="optimisation-scope-description">Showing metrics for tasks with active cycles only</span>
        </div>

        <!-- Phase 9: Time-based Charts -->
        <div class="optimisation-timeseries-charts" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 1.5rem; margin: 1.5rem 0;">
          <div class="card" style="padding: 1.5rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
              <div style="display: flex; gap: 0.5rem;">
                <button id="chart-left-toggle-clicks" class="chart-toggle-btn active" data-chart="clicks" style="padding: 0.5rem 1rem; background: var(--dark-brand); color: #000; border: 1px solid var(--dark-brand); border-radius: 4px; font-weight: 600; cursor: pointer;">Estimated Extra Clicks (28d) by KPI</button>
                <button id="chart-left-toggle-trend" class="chart-toggle-btn" data-chart="trend" style="padding: 0.5rem 1rem; background: var(--dark-panel); color: var(--dark-text); border: 1px solid var(--dark-border); border-radius: 4px; font-weight: 600; cursor: pointer;">Median Delta Over Time</button>
              </div>
              <select id="chart-trend-kpi-select" style="display: none; padding: 0.5rem; background: var(--dark-panel); color: var(--dark-text); border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem;">
                <option value="ctr_28d">CTR (pp)</option>
                <option value="impressions_28d">Impressions</option>
                <option value="clicks_28d">Clicks</option>
                <option value="current_rank">Rank</option>
                <option value="ai_citations">AI Citations</option>
                <option value="opportunity_score">Opportunity Score</option>
              </select>
            </div>
            <div id="chart-left-container" style="position: relative; height: 280px;">
              <canvas id="chart-estimated-clicks-by-kpi" style="width: 100%; height: 280px;"></canvas>
              <canvas id="chart-median-delta-trend" style="width: 100%; height: 280px; display: none;"></canvas>
            </div>
          </div>
          <div class="card" style="padding: 1.5rem;">
            <h3 style="margin: 0 0 1rem 0; font-size: 1.1rem; font-weight: 600;">Median Delta by KPI (Last 30d)</h3>
            <div style="position: relative; height: 280px;">
              <canvas id="chart-median-delta" style="width: 100%; height: 280px;"></canvas>
            </div>
          </div>
        </div>

        <!-- Tab Pills (B2) -->
        <div class="optimisation-tab-pills" style="display: flex; gap: 0.5rem; margin: 1.5rem 0; flex-wrap: wrap;">
          <button class="metric-pill metric-pill--neutral optimisation-tab-btn" data-tab="active" style="cursor: pointer; padding: 0.75rem 1.5rem;">
            <span>Active</span>
            <span class="optimisation-tab-count" data-tab="active">0</span>
          </button>
          <button class="metric-pill metric-pill--neutral optimisation-tab-btn" data-tab="done" style="cursor: pointer; padding: 0.75rem 1.5rem;">
            <span>Done</span>
            <span class="optimisation-tab-count" data-tab="done">0</span>
          </button>
          <button class="metric-pill metric-pill--neutral optimisation-tab-btn" data-tab="paused-cancelled" style="cursor: pointer; padding: 0.75rem 1.5rem;">
            <span>Paused/Cancelled</span>
            <span class="optimisation-tab-count" data-tab="paused-cancelled">0</span>
          </button>
        </div>

        <!-- Filters (B6) -->
        <div class="optimisation-filters" style="display: flex; gap: 1rem; margin: 1rem 0; flex-wrap: wrap; align-items: center;">
          <select id="optimisation-filter-status" style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">All Statuses</option>
            <option value="planned">Planned</option>
            <option value="in_progress">In Progress</option>
            <option value="monitoring">Monitoring</option>
            <option value="done">Done</option>
            <option value="paused">Paused</option>
            <option value="cancelled">Cancelled</option>
          </select>
          <select id="optimisation-filter-type" style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">All Types</option>
            <option value="on_page">On Page</option>
            <option value="content">Content</option>
            <option value="internal_links">Internal Links</option>
            <option value="links_pr">Links/PR</option>
            <option value="technical">Technical</option>
            <option value="local">Local</option>
            <option value="other">Other</option>
          </select>
          <input type="text" id="optimisation-filter-keyword" placeholder="Filter by keyword..." style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; flex: 1; min-width: 200px;">
          <input type="text" id="optimisation-filter-url" placeholder="Filter by URL..." style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; flex: 1; min-width: 200px;">
          <button id="optimisation-filter-needs-update" class="btn btn-secondary" style="padding: 0.5rem 1rem;" title="Show tasks that need measurement update (no measurement or older than 30 days).">Needs Update</button>
          <button id="optimisation-filter-active-cycle" class="btn btn-secondary" style="padding: 0.5rem 1rem;" title="Show only tasks with an active cycle (current cycle not completed or archived).">Active Cycle Only</button>
          <button id="optimisation-filter-overdue-cycle" class="btn btn-secondary" style="padding: 0.5rem 1rem;" title="Show tasks with overdue current cycle (past due date and target not met).">Overdue Cycle</button>
          <label style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; cursor: pointer;" title="Include test tasks in the view (test tasks are excluded from bulk updates).">
            <input type="checkbox" id="optimisation-filter-include-test" checked style="cursor: pointer;">
            <span>Include Test Tasks</span>
          </label>
          <button id="optimisation-clear-filters" class="btn btn-secondary" style="padding: 0.5rem 1rem;">Clear Filters</button>
        </div>

        <!-- Tasks Table (B2) -->
        <div class="ranking-table-section" style="margin-top: 1.5rem;">
          <div class="card">
            <div class="ranking-table-wrapper" id="optimisation-tasks-table-container" style="overflow: visible; max-height: none;">
            <table id="optimisation-tasks-table" class="ranking-table">
              <thead>
                <tr>
                  <th data-sort="keyword" class="sortable" title="The tracked keyword or search query.">
                    <div>Keyword <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="The tracked keyword or search query."></div>
                  </th>
                  <th data-sort="url" class="sortable" title="The target URL being optimised for this keyword." style="max-width: 150px;">
                    <div>Target URL <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="The target URL being optimised for this keyword."></div>
                  </th>
                  <th data-sort="type" class="sortable" title="Type of optimisation task: on_page (content/SEO changes), technical (site structure), or other.">
                    <div>Task Type <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Type of optimisation task: on_page (content/SEO changes), technical (site structure), or other."></div>
                  </th>
                  <th data-sort="status" class="sortable" title="Current status: planned (not started), in_progress (actively working), monitoring (tracking results), done (completed), paused (temporarily stopped), or cancelled.">
                    <div>Status <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Current status: planned (not started), in_progress (actively working), monitoring (tracking results), done (completed), paused (temporarily stopped), or cancelled."></div>
                  </th>
                  <th data-sort="cycle" class="sortable" title="Current cycle number. Each cycle represents a new optimisation attempt for the same keyword.">
                    <div>Cycle <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Current cycle number. Each cycle represents a new optimisation attempt for the same keyword."></div>
                  </th>
                  <th data-sort="baselineCaptured" class="sortable" title="Date when baseline metrics snapshot was captured (when task was created).">
                    <div>Baseline Captured <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Date when baseline metrics snapshot was captured (when task was created)."></div>
                  </th>
                  <th data-sort="latestCaptured" class="sortable" title="Date when latest measurement snapshot was captured, with 'Needs update' indicator if >30 days.">
                    <div>Latest Captured <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Date when latest measurement snapshot was captured, with 'Needs update' indicator if >30 days."></div>
                  </th>
                  <th data-sort="title" class="sortable" title="Optional title or label for this optimisation task.">
                    <div>Title <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Optional title or label for this optimisation task."></div>
                  </th>
                  <th data-sort="objectiveKpi" class="sortable" title="Objective KPI type (e.g., CTR, Rank, AI Citations).">
                    <div>Objective KPI <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Objective KPI type (e.g., CTR, Rank, AI Citations)."></div>
                  </th>
                  <th data-sort="baselineLatest" class="sortable" title="Baseline  Latest values for the objective KPI.">
                    <div>Baseline  Latest <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Baseline  Latest values for the objective KPI."></div>
                  </th>
                  <th data-sort="delta" class="sortable" title="Change (delta) from baseline to latest for the objective KPI.">
                    <div> vs Baseline <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Change (delta) from baseline to latest for the objective KPI."></div>
                  </th>
                  <th data-sort="dueIn" class="sortable" title="Days remaining until due date, or 'Overdue Xd' if past due.">
                    <div>Due In <span class="sort-indicator"></span></div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Days remaining until due date, or 'Overdue Xd' if past due."></div>
                  </th>
                  <th title="Mini trend line (sparkline) showing last ~10 measurements for the objective KPI.">
                    <div>Trend</div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Mini trend line (sparkline) showing last ~10 measurements for the objective KPI."></div>
                  </th>
                  <th title="Goal status and progress for the current cycle objective.">
                    <div>Goal</div>
                    <div style="font-size: 0.75rem; color: #2563eb; cursor: help; margin-top: 0.25rem; text-align: center;" title="Goal status and progress for the current cycle objective."></div>
                  </th>
                  <th style="text-align: center;" title="Actions available for this task.">
                    <div>Actions</div>
                  </th>
                </tr>
              </thead>
              <tbody id="optimisation-tasks-tbody">
                <tr>
                  <td colspan="13" style="padding: 2rem; text-align: center; color: #666;">Loading tasks...</td>
                </tr>
              </tbody>
            </table>
            </div>
            <div class="ranking-pagination-controls" id="optimisation-pagination-controls" style="display: none;">
            <div class="ranking-pagination-info" id="optimisation-pagination-info">
              Showing 0-0 of 0
            </div>
            <div class="ranking-pagination-buttons">
              <button id="optimisation-pagination-first" type="button">First</button>
              <button id="optimisation-pagination-prev" type="button">Previous</button>
              <span id="optimisation-pagination-page-info" style="padding: 0 0.5rem; font-size: 0.875rem;">Page 1 of 1</span>
              <button id="optimisation-pagination-next" type="button">Next</button>
              <button id="optimisation-pagination-last" type="button">Last</button>
            </div>
            <div class="ranking-rows-per-page">
              <label>Rows per page:</label>
              <select id="optimisation-rows-per-page">
                <option value="10" selected>10</option>
                <option value="25">25</option>
                <option value="50">50</option>
                <option value="100">100</option>
                <option value="all">All</option>
              </select>
            </div>
          </div>
          </div>
        </div>

        <!-- Task Detail Drawer (B3) -->
        <!-- Backdrop -->
        <div id="optimisation-task-drawer-backdrop" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 999;"></div>
        
        <!-- Draggable Modal Window -->
        <div id="optimisation-task-drawer" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 1200px; max-width: 95vw; max-height: 95vh; background: var(--dark-panel); box-shadow: 0 10px 40px rgba(0,0,0,0.5); z-index: 1000; border-radius: 8px; overflow: hidden; flex-direction: column; color: var(--dark-text);">
          <!-- Draggable Header -->
          <div id="optimisation-drawer-header-bar" style="padding: 1rem 1.5rem; border-bottom: 1px solid var(--dark-border); display: flex; justify-content: space-between; align-items: center; background: var(--dark-panel); cursor: move; user-select: none;">
            <h3 id="optimisation-drawer-header-title" style="margin: 0; flex: 1; color: var(--dark-text);">Task Details</h3>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
              <button id="optimisation-drawer-minimize" style="background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0.25rem 0.5rem; color: var(--dark-text-muted);" title="Minimize"></button>
              <button id="optimisation-drawer-maximize" style="background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0.25rem 0.5rem; color: var(--dark-text-muted);" title="Maximize"></button>
              <button id="optimisation-drawer-close" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; padding: 0.25rem 0.5rem; color: var(--dark-text-muted);" title="Close">&times;</button>
            </div>
          </div>
          
          <!-- Cancel Task, Delete Task, and Title (moved to header area) -->
          <div style="padding: 0.75rem 1.5rem; border-bottom: 1px solid var(--dark-border); background: var(--dark-panel); display: flex; gap: 0.5rem; align-items: center;">
            <button id="optimisation-cancel-task-btn" class="btn" style="background: #dc2626; border: 1px solid #dc2626; padding: 0.5rem 1rem; font-size: 0.875rem; color: #ffffff; font-weight: 700;" title="Stop tracking (keeps history).">Cancel Task</button>
            <button id="optimisation-delete-task-btn" class="btn" style="background: #991b1b; border: 1px solid #991b1b; padding: 0.5rem 1rem; font-size: 0.875rem; color: #ffffff; font-weight: 700;" title="Permanently remove task and events (cannot be undone).">Delete Task</button>
            <div style="flex: 1; display: flex; align-items: center; gap: 0.5rem; margin-left: 1rem;">
              <strong style="white-space: nowrap; color: var(--dark-text);">Title:</strong>
              <input type="text" id="optimisation-drawer-title" style="flex: 1; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="Enter task title...">
            </div>
          </div>
          
          <!-- Scrollable Content -->
          <div id="optimisation-drawer-content" style="padding: 1.5rem; overflow-y: auto; flex: 1;">
          <div>
            <!-- Task Header (Full Width) -->
            <div id="optimisation-drawer-header" style="margin-bottom: 1.5rem; display: grid; grid-template-columns: 1fr 2fr 1.5fr; gap: 1.5rem;">
              <div>
                <strong>Keyword:</strong>
                <div id="optimisation-drawer-keyword" style="margin-top: 0.25rem; font-size: 1.1rem; color: #2563eb;"></div>
              </div>
              <div>
                <strong>Target URL:</strong>
                <div id="optimisation-drawer-url" style="margin-top: 0.25rem; word-break: break-all;"></div>
              </div>
              <div style="text-align: right;">
                <div style="margin-bottom: 0.5rem;">
                  <strong style="color: var(--dark-text);">Task Type:</strong>
                  <span id="optimisation-drawer-type" style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; background: rgba(156, 163, 175, 0.2); border-radius: 4px; color: var(--dark-text);"></span>
                </div>
                <div style="margin-bottom: 0.5rem;">
                  <strong>Status:</strong>
                  <span id="optimisation-drawer-status" style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; border-radius: 4px;"></span>
                </div>
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                  <strong>Cycle:</strong>
                  <span id="optimisation-drawer-cycle" style="margin-left: 0;"></span>
                  <select id="optimisation-drawer-cycle-selector" style="padding: 0.25rem 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text); cursor: pointer; display: none; min-width: 100px;" title="Select a cycle to view its objective, measurements, and events">
                    <!-- Options will be populated by JavaScript -->
                  </select>
                </div>
              </div>
            </div>

            <!-- Objective Section (Full Width) -->
            <div id="optimisation-drawer-objective" style="margin-bottom: 1.5rem; padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                  <h4 style="margin: 0; font-size: 0.95rem; font-weight: 600;">Objective <span id="optimisation-drawer-objective-cycle">(Cycle 1)</span></h4>
                  <span id="optimisation-drawer-objective-badge" style="padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; display: none;"></span>
                </div>
                <button id="optimisation-edit-objective-btn" class="btn btn-small" style="padding: 0.25rem 0.75rem; font-size: 0.875rem; background: var(--dark-brand); color: #000000; font-weight: 700; border: 1px solid var(--dark-brand);" title="Set target KPI and timeframe for this cycle.">Edit</button>
              </div>
              <div id="optimisation-drawer-objective-content" style="font-size: 0.875rem; color: var(--dark-text);">
                <div style="color: var(--dark-text-muted); font-style: italic;">Loading objective...</div>
              </div>
              <!-- Edit Objective Form (Hidden by default) -->
              <div id="optimisation-edit-objective-form" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--dark-border);">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Title</label>
                    <input type="text" id="optimisation-edit-objective-title" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="Objective title">
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">KPI Label</label>
                    <input type="text" id="optimisation-edit-objective-kpi" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="e.g., AI citations increase by 1">
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Metric</label>
                    <select id="optimisation-edit-objective-metric" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);">
                      <option value="">Select metric</option>
                      <option value="ai_citations">AI Citations</option>
                      <option value="ai_overview">AI Overview</option>
                      <option value="ctr_28d">CTR (28d)</option>
                      <option value="impressions_28d">Impressions (28d)</option>
                      <option value="clicks_28d">Clicks (28d)</option>
                      <option value="rank">Rank</option>
                    </select>
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Direction</label>
                    <select id="optimisation-edit-objective-direction" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);">
                      <option value="">Select direction</option>
                      <option value="increase">Increase</option>
                      <option value="decrease">Decrease</option>
                      <option value="at_least">At least</option>
                      <option value="at_most">At most</option>
                    </select>
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Target Value</label>
                    <input type="number" id="optimisation-edit-objective-target-value" step="0.01" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="0">
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Timeframe (days)</label>
                    <input type="number" id="optimisation-edit-objective-timeframe" min="1" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);" placeholder="30">
                  </div>
                  <div style="display: flex; align-items: flex-end;">
                    <div id="optimisation-edit-objective-due-date" style="padding: 0.5rem; font-size: 0.875rem; color: var(--dark-text-muted);"></div>
                  </div>
                </div>
                <div style="margin-bottom: 1rem;">
                  <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Plan</label>
                  <textarea id="optimisation-edit-objective-plan" rows="3" style="width: 100%; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; resize: vertical; background: var(--dark-bg); color: var(--dark-text);" placeholder="Describe your plan..."></textarea>
                </div>
                <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                  <button id="optimisation-cancel-edit-objective-btn" class="btn btn-secondary" style="padding: 0.5rem 1rem; font-size: 0.875rem;">Cancel</button>
                  <button id="optimisation-save-objective-btn" class="btn" style="padding: 0.5rem 1rem; font-size: 0.875rem;">Save</button>
                </div>
              </div>
            </div>

            <!-- Two Column Layout -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;">
              <!-- Left Column -->
              <div style="display: flex; flex-direction: column; gap: 1.5rem;">
                <!-- Performance Snapshot -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center; font-size: 0.95rem; color: var(--dark-text);">
                    <span>Performance Snapshot <span title="Shows current metrics compared to baseline measurement. Baseline is captured when the cycle starts, and latest shows the most recent measurement. Use 'Add Measurement' to capture new snapshots." style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></span>
                    <button id="optimisation-add-measurement-btn" class="btn btn-small" style="padding: 0.25rem 0.75rem; font-size: 0.875rem; background: var(--dark-brand); color: #000000; font-weight: 700; border: 1px solid var(--dark-brand);" title="Capture the latest metrics and compare to baseline.">Add Measurement</button>
                  </h4>
                  <div id="optimisation-metrics-snapshot" style="display: grid; grid-template-columns: 1.5fr 1fr 1fr; gap: 0.75rem; font-size: 0.9rem; color: var(--dark-text);">
                    <!-- Metrics will be populated by JavaScript -->
                    <div style="color: var(--dark-text-muted); font-style: italic; grid-column: 1 / -1;">Loading metrics...</div>
                  </div>
                </div>

                <!-- Measurement History -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; font-size: 0.95rem; display: flex; justify-content: space-between; align-items: center; color: var(--dark-text);">
                    <span>Measurement History <span title="Recent measurement snapshots for this cycle. Shows captured date, key metrics, and delta vs previous measurement." style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></span>
                    <button id="optimisation-measurement-history-toggle" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; background: rgba(156, 163, 175, 0.6); border: 1px solid var(--dark-border); border-radius: 4px; cursor: pointer;">Show</button>
                  </h4>
                  <div id="optimisation-measurement-history" style="display: none; max-height: 400px; overflow-y: auto;">
                    <div style="color: var(--dark-text-muted); font-style: italic;">Loading measurement history...</div>
                  </div>
                </div>

                <!-- Close Button -->
                <div style="padding-top: 1rem;">
                  <button id="optimisation-drawer-close-bottom" class="btn btn-secondary" style="width: 100%; padding: 0.5rem 1rem;">Close</button>
                </div>

              </div>

              <!-- Right Column -->
              <div style="display: flex; flex-direction: column; gap: 1.5rem;">
                <!-- Timeline/Events (Collapsible) -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center; cursor: pointer; font-size: 0.95rem; color: var(--dark-text);" id="optimisation-timeline-header">
                    <span>Timeline <span title="Chronological history of all events for this task: measurements, notes, status changes, and deployed changes. Click to expand or collapse the timeline view." style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></span>
                    <span id="optimisation-timeline-toggle" style="font-size: 1.2rem; user-select: none; color: var(--dark-text);"></span>
                  </h4>
                  <div id="optimisation-drawer-events-container" style="display: none;">
                    <div id="optimisation-drawer-events" style="border-left: 2px solid var(--dark-border); padding-left: 1rem; max-height: 400px; overflow-y: auto;">
                      <div style="color: var(--dark-text-muted); font-style: italic;">Loading events...</div>
                    </div>
                  </div>
                </div>

                <!-- Cycle Management -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; font-size: 0.95rem; color: var(--dark-text);">Cycle Management</h4>
                  <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                    <button id="optimisation-complete-cycle-btn" class="btn" style="width: 100%; padding: 0.5rem; font-size: 0.875rem; background: #059669; border-color: #059669; color: #ffffff; font-weight: 700;" title="Mark the current cycle as completed. This closes the cycle and makes it viewable in history.">Complete Cycle</button>
                    <button id="optimisation-archive-cycle-btn" class="btn btn-secondary" style="width: 100%; padding: 0.5rem; font-size: 0.875rem; background: #4b5563; color: #ffffff; font-weight: 700; border: 1px solid #4b5563;" title="Archive the current cycle (for abandoned work). The cycle remains in history but is marked as archived.">Archive Cycle</button>
                    <button id="optimisation-start-cycle-btn" class="btn btn-secondary" style="width: 100%; padding: 0.5rem; font-size: 0.875rem; background: rgba(156, 163, 175, 0.6); color: #000000; font-weight: 700; border: 1px solid var(--dark-border);" title="Begins a new optimisation attempt while preserving history from previous cycles.">Start New Cycle</button>
                  </div>
                </div>

                <!-- Add Event Form -->
                <div style="padding: 0.5rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.5rem; font-size: 0.95rem; color: var(--dark-text);">Add Event <span title="Record activities and milestones: Notes for observations, Change Deployed for updates, Measurement for metric snapshots, or Status Changed for workflow updates. All events appear in the Timeline." style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></h4>
                  <div style="margin-bottom: 0.5rem;">
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Event Type:</label>
                    <select id="optimisation-event-type" style="width: 100%; padding: 0.4rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);">
                      <option value="note">Note</option>
                      <option value="change_deployed">Change Deployed</option>
                      <option value="measurement">Measurement</option>
                      <option value="status_changed">Status Changed</option>
                    </select>
                  </div>
                  <div style="margin-bottom: 0.5rem;">
                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.875rem; color: var(--dark-text);">Note:</label>
                    <textarea id="optimisation-event-note" rows="2" style="width: 100%; padding: 0.4rem; border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.875rem; background: var(--dark-bg); color: var(--dark-text);"></textarea>
                  </div>
                  <button id="optimisation-add-event-btn" class="btn btn-primary" style="width: 100%; padding: 0.5rem; font-size: 0.875rem; background: var(--dark-brand); color: #000000; font-weight: 700; border: 1px solid var(--dark-brand);" title="Adds the event to the timeline. Select the event type and add any notes, then click to record it.">Add Event</button>
                </div>

                <!-- Change Status -->
                <div style="padding: 0.75rem; background: var(--dark-panel); border-radius: 4px; border: 1px solid var(--dark-border);">
                  <h4 style="margin-bottom: 0.75rem; font-size: 0.95rem; color: var(--dark-text);">Change Status <span title="Status meanings:&#10; Planned: Task created but work not started&#10; In Progress: Currently being worked on&#10; Monitoring: Changes deployedmonitor metrics&#10; Done: Cycle completed; start a new cycle if optimising again&#10; Paused: Tracking stopped; you can start a new cycle later&#10; Cancelled: Tracking stopped; you can start a new cycle later&#10; Deleted: Task permanently removed" style="opacity: 0.6; cursor: help; font-size: 0.85rem;"></span></h4>
                  <div style="display: flex; gap: 0.5rem;">
                    <select id="optimisation-change-status" style="flex: 1; padding: 0.5rem; border: 1px solid var(--dark-border); border-radius: 4px; background: var(--dark-bg); color: var(--dark-text);" title="Updates task workflow stage; adds a timeline event.">
                      <option value="">Change Status...</option>
                      <option value="planned" title="Task created but work not started">Planned</option>
                      <option value="in_progress" title="Currently being worked on">In Progress</option>
                      <option value="monitoring" title="Changes deployedmonitor metrics">Monitoring</option>
                      <option value="done" title="Cycle completed; start a new cycle if optimising again">Done</option>
                      <option value="paused" title="Tracking stopped; you can start a new cycle later">Paused</option>
                      <option value="cancelled" title="Tracking stopped; you can start a new cycle later">Cancelled</option>
                      <option value="deleted" title="Task permanently removed">Deleted</option>
                    </select>
                    <button id="optimisation-save-status-btn" class="btn btn-primary" title="Save the selected status change.">Save</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- History Panel -->
      <section class="aigeo-panel" data-panel="history">
        <!-- Supabase history charts / trend lines / previous audits will be inserted here by JS -->
      </section>

    </div>
      </div>
    </main>
    </div>

    <!-- Debug Panel - Fixed at bottom, collapsible -->
    <div class="debug-panel-bottom" id="debugPanel">
      <div class="debug-header" onclick="toggleDebugPanel()" style="cursor: pointer;">
        <h3> Debug Log</h3>
        <div class="debug-actions">
          <button class="btn btn-small" onclick="event.stopPropagation(); clearDebugLog();" title="Clear all debug log entries. Useful for starting fresh during troubleshooting.">Clear</button>
          <button class="btn btn-small" onclick="event.stopPropagation(); copyDebugLog();" title="Copy the entire debug log to your clipboard. Useful for sharing logs or troubleshooting issues.">Copy Log</button>
          <button class="btn btn-small" id="debugFilterBtn" onclick="event.stopPropagation(); toggleDebugLogFilter();" title="Filter to show only warnings and errors">Filter: All</button>
          <span id="debugToggleIcon" style="color: #fff; font-size: 1.2rem;"></span>
        </div>
      </div>
      <div class="debug-content" id="debugLog" style="display: block;">
        <div class="debug-log-entry info">
          <span class="debug-timestamp">[Initializing...]</span>Debug panel loaded. Waiting for page initialization...
        </div>
      </div>
    </div>
  </div>

  <script>
    // Immediate console log to verify script is running
    console.log('%c=== GAIO AUDIT DASHBOARD LOADED ===', 'color: #E57200; font-size: 16px; font-weight: bold;');
    console.log('%cDebug panel should be visible at bottom with orange border', 'color: #E57200; font-size: 14px;');
    console.log('Current time:', new Date().toISOString());
    console.log('Page URL:', window.location.href);
    
    // Helper function to safely save to localStorage (handles quota errors gracefully)
    // Define apiUrl helper IMMEDIATELY at the top level so it's available to all functions
    // This must be defined before any functions that use it
    (function() {
      const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
        ? 'https://ai-geo-audit.vercel.app' // Change this to your Vercel deployment URL
        : '';
      
      window.apiUrl = function apiUrl(path) {
        if (!API_BASE_URL) {
          // When deployed on Vercel, use relative paths
          return path.startsWith('/') ? path : `/${path}`;
        }
        // When running locally, prepend the Vercel URL
        // Handle paths with or without leading slash
        const cleanPath = path.startsWith('/') ? path : `/${path}`;
        return `${API_BASE_URL}${cleanPath}`;
      };
    })();
    
    // ======================
    // Optimisation Tracking Utilities (Phase 2)
    // ======================
    // Normalization functions matching DB helpers (arp_keyword_key, arp_clean_url)
    window.keywordKey = function keywordKey(keyword) {
      if (!keyword || typeof keyword !== 'string') return null;
      return keyword.trim().replace(/\s+/g, ' ').toLowerCase();
    };

    window.cleanUrlForKey = function cleanUrlForKey(url) {
      if (!url || typeof url !== 'string') return null;
      // Remove fragment (#)
      let cleaned = url.split('#')[0];
      // Remove query string (?)
      cleaned = cleaned.split('?')[0];
      // Remove protocol (http:// or https://)
      cleaned = cleaned.replace(/^https?:\/\//, '');
      // Remove trailing slashes
      cleaned = cleaned.replace(/\/+$/, '');
      return cleaned;
    };

    // Clean URL but keep protocol (for display in modals)
    window.cleanUrlForDisplay = function cleanUrlForDisplay(url) {
      if (!url || typeof url !== 'string') return '';
      // Remove fragment (#)
      let cleaned = url.split('#')[0];
      // Remove query string (?)
      cleaned = cleaned.split('?')[0];
      // Remove trailing slashes
      cleaned = cleaned.replace(/\/+$/, '');
      return cleaned;
    };

    // Admin key utilities (Phase A - Security)
    window.getAdminKey = function getAdminKey() {
      if (typeof window === "undefined") return "";
      return sessionStorage.getItem("arp_admin_key") || "";
    };

    window.setAdminKey = function setAdminKey(key) {
      if (typeof window === "undefined") return;
      sessionStorage.setItem("arp_admin_key", key);
    };

    window.hasAdminKey = function hasAdminKey() {
      return window.getAdminKey().length > 0;
    };

    window.clearAdminKey = function clearAdminKey() {
      if (typeof window === "undefined") return;
      sessionStorage.removeItem("arp_admin_key");
    };

    // Share mode detection
    const urlParams = new URLSearchParams(window.location.search);
    window.isShareMode = urlParams.get('share') === '1';
    window.shareToken = urlParams.get('st') || '';

    // Helper to build headers with admin key or share token
    window.getOptimisationHeaders = function getOptimisationHeaders() {
      const headers = { 'Content-Type': 'application/json' };
      if (window.isShareMode && window.shareToken) {
        headers['x-arp-share-token'] = window.shareToken;
      } else {
      const adminKey = window.getAdminKey();
      if (adminKey) {
        headers['x-arp-admin-key'] = adminKey;
        }
      }
      return headers;
    };

    // Cache for optimisation status (keyed by keyword_key::target_url_clean::task_type)
    window.optimisationStatusCache = new Map();

    // Fetch optimisation statuses in bulk
    window.fetchOptimisationStatuses = async function fetchOptimisationStatuses(rows) {
      if (!rows || rows.length === 0) {
        window.optimisationStatusCache.clear();
        return;
      }

      try {
        // Build unique set of keyword keys and URL keys
        const keywordKeys = new Set();
        const urlKeys = new Set();
        rows.forEach(row => {
          const kwKey = window.keywordKey(row.keyword);
          const url = row.best_url || row.targetUrl || row.ranking_url || '';
          const urlKey = window.cleanUrlForKey(url);
          if (kwKey) keywordKeys.add(kwKey);
          if (urlKey) urlKeys.add(urlKey);
        });

        if (keywordKeys.size === 0) {
          window.optimisationStatusCache.clear();
          return;
        }

        // Fetch from API endpoint (we'll create this)
        const response = await fetch(apiUrl('/api/optimisation/status'), {
          method: 'POST',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            keyword_keys: Array.from(keywordKeys),
            url_keys: Array.from(urlKeys)
          })
        });

        if (!response.ok) {
          console.warn('[Optimisation] Failed to fetch statuses:', response.status);
          window.optimisationStatusCache.clear();
          return;
        }

        const data = await response.json();
        window.optimisationStatusCache.clear();

        // Build cache map: key = keyword_key::target_url_clean::task_type
        (data.statuses || []).forEach(status => {
          const key = `${status.keyword_key}::${status.target_url_clean}::${status.task_type || 'on_page'}`;
          window.optimisationStatusCache.set(key, status);
        });

        console.log(`[Optimisation] Loaded ${window.optimisationStatusCache.size} status records`);
      } catch (error) {
        console.error('[Optimisation] Error fetching statuses:', error);
        window.optimisationStatusCache.clear();
      }
    };

    // Get optimisation status for a row
    window.getOptimisationStatus = function getOptimisationStatus(row, taskType = 'on_page') {
      const kwKey = window.keywordKey(row.keyword);
      const url = row.best_url || row.targetUrl || row.ranking_url || '';
      const urlKey = window.cleanUrlForKey(url);
      
      if (!kwKey || !urlKey) return null;
      
      const key = `${kwKey}::${urlKey}::${taskType}`;
      return window.optimisationStatusCache.get(key) || null;
    };

    // ======================
    // Optimisation Tracking Modals (Phase 2)
    // ======================
    
    // Open Track Keyword modal
    window.openTrackKeywordModal = function openTrackKeywordModal(row, taskType = 'on_page') {
      console.log('[Optimisation] openTrackKeywordModal called', { row, taskType });
      const modal = document.getElementById('optimisation-track-modal');
      if (!modal) {
        console.error('[Optimisation] Track modal not found');
        alert('Track modal not found. Please refresh the page.');
        return;
      }

      // Get and clean URL (remove query strings and fragments)
      const rawUrl = row.best_url || row.targetUrl || row.ranking_url || '';
      console.log('[Optimisation] Raw URL:', rawUrl);
      if (!window.cleanUrlForDisplay) {
        console.error('[Optimisation] cleanUrlForDisplay function not found');
        alert('Error: cleanUrlForDisplay function not found. Please refresh the page.');
        return;
      }
      const cleanedUrl = window.cleanUrlForDisplay(rawUrl);
      console.log('[Optimisation] Cleaned URL:', cleanedUrl);

      // Populate fields
      document.getElementById('track-keyword-text').textContent = row.keyword;
      
      // Make URL clickable in Track modal
      const trackUrlContainer = document.getElementById('track-url-text');
      trackUrlContainer.innerHTML = ''; // Clear existing content
      if (cleanedUrl) {
        // Ensure URL has protocol
        let fullUrl = cleanedUrl;
        if (!fullUrl.startsWith('http://') && !fullUrl.startsWith('https://')) {
          fullUrl = 'https://' + fullUrl;
        }
        const urlLink = document.createElement('a');
        urlLink.href = fullUrl;
        urlLink.target = '_blank';
        urlLink.rel = 'noopener noreferrer';
        urlLink.textContent = cleanedUrl;
        urlLink.style.color = '#0284c7';
        urlLink.style.textDecoration = 'none';
        urlLink.style.fontWeight = '600';
        urlLink.style.wordBreak = 'break-all';
        urlLink.addEventListener('mouseenter', () => {
          urlLink.style.textDecoration = 'underline';
        });
        urlLink.addEventListener('mouseleave', () => {
          urlLink.style.textDecoration = 'none';
        });
        trackUrlContainer.appendChild(urlLink);
      } else {
        trackUrlContainer.textContent = 'No URL available';
      }
      
      document.getElementById('track-task-type').value = taskType;
      document.getElementById('track-status').value = 'planned';
      document.getElementById('track-title').value = '';
      document.getElementById('track-notes').value = '';
      // Reset objective fields
      document.getElementById('track-objective-title').value = '';
      document.getElementById('track-primary-kpi').value = '';
      document.getElementById('track-target-direction').value = '';
      document.getElementById('track-target-value').value = '';
      document.getElementById('track-timeframe-days').value = '';
      
      // Populate Plan / Hypothesis from Priority & Next Actions
      let planText = '';
      try {
        const scorecardData = buildKeywordScorecardData(row);
        if (scorecardData) {
          const actions = generateActionBullets(scorecardData);
          if (actions && actions.length > 0) {
            planText = actions.join('\n');
          }
        }
      } catch (e) {
        console.warn('[Optimisation] Error generating plan from scorecard:', e);
      }
      document.getElementById('track-plan').value = planText;

      // Store cleaned URL and row data for submit (row data needed for baseline metrics)
      modal.dataset.rowKeyword = row.keyword;
      modal.dataset.rowUrl = cleanedUrl;
      modal.dataset.taskType = taskType;
      // Store row data as JSON string for baseline metrics
      modal.dataset.rowData = JSON.stringify(row);

      modal.style.display = 'flex';
    };

    // Submit Track Keyword
    window.submitTrackKeyword = async function submitTrackKeyword() {
      const modal = document.getElementById('optimisation-track-modal');
      if (!modal) return;

      const keyword = modal.dataset.rowKeyword;
      // Get cleaned URL from dataset (already cleaned when modal opened)
      let targetUrl = modal.dataset.rowUrl || '';
      // Double-check it's cleaned (in case it was modified elsewhere)
      targetUrl = window.cleanUrlForDisplay(targetUrl);
      const taskType = modal.dataset.taskType || document.getElementById('track-task-type').value;
      const status = document.getElementById('track-status').value;
      const title = document.getElementById('track-title').value.trim();
      const notes = document.getElementById('track-notes').value.trim();
      
      // Get objective fields (Phase B)
      const objective_title = document.getElementById('track-objective-title').value.trim();
      const objective_kpi = document.getElementById('track-primary-kpi').value.trim(); // Map primary_kpi to objective_kpi
      const objective_metric = objective_kpi; // Use same value for metric
      const objective_direction = document.getElementById('track-target-direction').value.trim();
      const objective_target_delta = document.getElementById('track-target-value').value.trim() ? parseFloat(document.getElementById('track-target-value').value) : null;
      const objective_timeframe_days = document.getElementById('track-timeframe-days').value.trim() ? parseInt(document.getElementById('track-timeframe-days').value) : null;
      const objective_plan = document.getElementById('track-plan').value.trim();
      
      // Calculate objective_due_at if timeframe is set
      let objective_due_at = null;
      if (objective_timeframe_days) {
        const startDate = new Date();
        objective_due_at = new Date(startDate.getTime() + objective_timeframe_days * 24 * 60 * 60 * 1000).toISOString();
      }

      if (!keyword || !targetUrl) {
        alert('Missing keyword or URL');
        return;
      }

      // Build baseline metrics from row data (stored in modal dataset)
      const rowDataStr = modal.dataset.rowData;
      let baselineMetrics = null;
      if (rowDataStr) {
        try {
          const rowData = JSON.parse(rowDataStr);
          
          // Get queryTotal data for clicks, impressions, and CTR
          let queryTotal = null;
          if (typeof getQueryTotalForKeyword === 'function') {
            queryTotal = getQueryTotalForKeyword(keyword);
          }
          
          baselineMetrics = {
            gsc_clicks_28d: queryTotal?.clicks || rowData.gsc_clicks_28d || rowData.clicks_28d || null,
            gsc_impressions_28d: queryTotal?.impressions || rowData.gsc_impressions_28d || rowData.impressions_28d || null,
            // queryTotal.ctr is a percentage (0-100), convert to decimal for storage
            gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (rowData.gsc_ctr_28d || rowData.ctr_28d || null),
            current_rank: rowData.best_rank_group || rowData.current_rank || null,
            opportunity_score: rowData.opportunityScore || null,
            ai_overview: rowData.has_ai_overview || false,
            ai_citations: rowData.ai_alan_citations_count || 0,
            ai_citations_total: rowData.ai_total_citations || 0,
            classic_ranking_url: rowData.best_url || rowData.targetUrl || rowData.ranking_url || null,
            page_type: rowData.pageType || null,
            segment: rowData.segment || null,
            captured_at: new Date().toISOString()
          };
        } catch (e) {
          console.error('[Optimisation] Failed to parse row data for baseline metrics:', e);
        }
      }

      try {
        const response = await fetch(apiUrl('/api/optimisation/task'), {
          method: 'POST',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            keyword_text: keyword,
            target_url: targetUrl,
            task_type: taskType,
            status: status,
            title: title || null,
            notes: notes || null,
            baselineMetrics: baselineMetrics,
            // Phase B objective fields
            objective_title: objective_title || null,
            objective_kpi: objective_kpi || null,
            objective_metric: objective_metric || null,
            objective_direction: objective_direction || null,
            objective_target_delta: objective_target_delta,
            objective_timeframe_days: objective_timeframe_days,
            objective_due_at: objective_due_at,
            objective_plan: objective_plan || null,
            // Also set cycle_started_at when creating task
            cycle_started_at: new Date().toISOString()
          })
        });

        if (!response.ok) {
          if (response.status === 401) {
            throw new Error('Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.');
          }
          const error = await response.text();
          throw new Error(error || 'Failed to create task');
        }

        const result = await response.json();
        const createdTask = result.task;

        // Refresh status cache
        await window.fetchOptimisationStatuses([{ keyword, best_url: targetUrl }]);
        
        // Reload all tasks so the new task is available for the drawer
        if (typeof window.loadAllOptimisationTasks === 'function') {
          await window.loadAllOptimisationTasks();
        }
        
        // Close modal
        modal.style.display = 'none';
        
        // Ensure Ranking & AI tab stays active and refresh table
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        if (rankingTab) {
          // Use setActivePanel to properly show the panel
          if (typeof setActivePanel === 'function') {
            setActivePanel('ranking');
          } else {
            // Fallback: manually set active state
            document.querySelectorAll('.aigeo-panel').forEach(panel => {
              panel.classList.remove('is-active');
              panel.hidden = true;
            });
          rankingTab.classList.add('is-active');
            rankingTab.hidden = false;
          }
          
          // Update nav button states
          document.querySelectorAll('.aigeo-nav-item').forEach(btn => btn.classList.remove('is-active'));
          const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav-item')).find(btn => 
            btn.getAttribute('data-panel') === 'ranking'
          );
          if (rankingNavBtn) rankingNavBtn.classList.add('is-active');
          
          // Ensure panel is rendered
          if (typeof ensurePanelRendered === 'function') {
            ensurePanelRendered('ranking');
          }
        }
        
        // Trigger table re-render
        if (typeof renderRankingAiTab === 'function') {
          await renderRankingAiTab();
        } else if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        } else {
          console.warn('[Optimisation] renderRankingAiTab not found, refreshing page');
          // Preserve Ranking & AI tab state before reload
          sessionStorage.setItem('activeTab', 'ranking');
          window.location.hash = '#ranking';
          location.reload();
        }
      } catch (error) {
        console.error('[Optimisation] Error creating task:', error);
        alert('Failed to create task: ' + error.message);
      }
    };

    // Open Manage Optimisation modal
    window.openManageOptimisationModal = function openManageOptimisationModal(row, status, taskType = 'on_page') {
      const modal = document.getElementById('optimisation-manage-modal');
      if (!modal) {
        console.error('[Optimisation] Manage modal not found');
        return;
      }

      // Populate read-only fields
      document.getElementById('manage-keyword-text').textContent = row.keyword;
      
      // Make URL clickable in Manage modal
      const manageUrlContainer = document.getElementById('manage-url-text');
      const rawUrl = row.best_url || row.targetUrl || row.ranking_url || '';
      const urlText = window.cleanUrlForDisplay ? window.cleanUrlForDisplay(rawUrl) : window.cleanUrlForKey(rawUrl);
      manageUrlContainer.innerHTML = ''; // Clear existing content
      if (urlText) {
        // Ensure URL has protocol
        let fullUrl = urlText;
        if (!fullUrl.startsWith('http://') && !fullUrl.startsWith('https://')) {
          fullUrl = 'https://' + fullUrl;
        }
        const urlLink = document.createElement('a');
        urlLink.href = fullUrl;
        urlLink.target = '_blank';
        urlLink.rel = 'noopener noreferrer';
        urlLink.textContent = urlText;
        urlLink.style.color = '#0284c7';
        urlLink.style.textDecoration = 'none';
        urlLink.style.wordBreak = 'break-all';
        urlLink.addEventListener('mouseenter', () => {
          urlLink.style.textDecoration = 'underline';
        });
        urlLink.addEventListener('mouseleave', () => {
          urlLink.style.textDecoration = 'none';
        });
        manageUrlContainer.appendChild(urlLink);
      } else {
        manageUrlContainer.textContent = 'No URL available';
      }
      
      document.getElementById('manage-task-type-text').textContent = taskType;
      document.getElementById('manage-status-text').textContent = status.status;
      document.getElementById('manage-cycle-text').textContent = status.cycle_active || 1;
      document.getElementById('manage-last-activity-text').textContent = status.last_activity_at 
        ? new Date(status.last_activity_at).toLocaleDateString()
        : 'Never';

      // Set current status in dropdown
      document.getElementById('manage-status-select').value = status.status;

      // Store data for submit
      modal.dataset.taskId = status.id;
      modal.dataset.rowKeyword = row.keyword;
      modal.dataset.rowUrl = row.best_url || row.targetUrl || row.ranking_url || '';
      modal.dataset.taskType = taskType;
      modal.dataset.currentCycle = status.cycle_active || 1;
      modal.dataset.currentStatus = status.status; // Store actual status value for comparison

      modal.style.display = 'flex';
    };

    // Submit status change
    window.submitStatusChange = async function submitStatusChange(newStatusParam, taskIdParam) {
      // B5: Support both modal and drawer - accept optional parameters
      const modal = document.getElementById('optimisation-manage-modal');
      const drawerTaskId = window.optimisationModuleState?.currentTaskId;
      const modalTaskId = modal?.dataset.taskId;
      const taskId = taskIdParam || drawerTaskId || modalTaskId;
      
      if (!taskId) {
        console.warn('[Optimisation] No task ID found');
        return;
      }

      // Get status from parameter, modal select, or drawer select
      const newStatus = newStatusParam || 
        (modal ? document.getElementById('manage-status-select')?.value : null) ||
        document.getElementById('optimisation-change-status')?.value;
      
      if (!newStatus) {
        alert('Please select a status');
        return;
      }

      const oldStatus = modal?.dataset.currentStatus || 
        document.getElementById('manage-status-text')?.textContent ||
        document.getElementById('optimisation-drawer-status')?.textContent;

      if (oldStatus === newStatus) {
        alert('Status unchanged');
        return;
      }

      try {
        const headers = window.getOptimisationHeaders();
        console.log('[Optimisation] Updating status:', { taskId, newStatus, oldStatus, hasAdminKey: !!headers['x-arp-admin-key'] });
        
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'PATCH',
          headers: headers,
          body: JSON.stringify({
            status: newStatus
          })
        });

        console.log('[Optimisation] Response status:', response.status, response.statusText);
        console.log('[Optimisation] Response headers:', Object.fromEntries(response.headers.entries()));

        if (!response.ok) {
          // Clone response BEFORE reading to allow multiple reads
          const responseClone = response.clone();
          let errorMessage = 'Failed to update status';
          let errorDetails = null;
          
          try {
            // Try to read as JSON first (most APIs return JSON)
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
            errorDetails = errorData;
            console.error('[Optimisation] API error response:', errorData);
          } catch (e) {
            // If JSON parsing fails, try text from clone
            console.error('[Optimisation] JSON parse failed, trying text:', e);
            try {
              const errorText = await responseClone.text();
              console.error('[Optimisation] Error response text (length):', errorText ? errorText.length : 0);
              if (errorText && errorText.trim()) {
                // Try to parse as JSON if it looks like JSON
                try {
                  const parsed = JSON.parse(errorText);
                  errorMessage = parsed.error || parsed.message || errorText;
                  errorDetails = parsed;
                } catch (parseError) {
                  errorMessage = errorText.substring(0, 200); // Limit length
                  errorDetails = { rawText: errorText.substring(0, 500) };
                }
                console.error('[Optimisation] API error text:', errorText.substring(0, 200));
              } else {
                console.error('[Optimisation] Error response body is empty');
                errorDetails = { empty: true };
              }
            } catch (e2) {
              console.error('[Optimisation] Failed to read error response:', e2);
              errorDetails = { readError: e2.message };
            }
          }
          
          // Enhance error message based on status code
          if (response.status === 401) {
            errorMessage = 'Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.';
          } else if (response.status === 404) {
            errorMessage = 'Task not found. It may have been deleted.';
          } else if (response.status === 403) {
            errorMessage = 'Forbidden - you do not have permission to update this task.';
          } else if (response.status === 500) {
            errorMessage = `Server error (${response.status}): ${errorMessage}`;
          } else {
            errorMessage = `HTTP ${response.status}: ${errorMessage}`;
          }
          
          console.error('[Optimisation] Full error details:', {
            status: response.status,
            statusText: response.statusText,
            errorMessage,
            errorDetails
          });
          
          throw new Error(errorMessage);
        }

        // Read successful response
        const result = await response.json();
        console.log('[Optimisation] Status update successful:', result);

        // Refresh data
        if (modal && modal.dataset.rowKeyword) {
        await window.fetchOptimisationStatuses([{
          keyword: modal.dataset.rowKeyword,
          best_url: modal.dataset.rowUrl
        }]);
        }
        
        // Refresh all tasks if drawer is open
        if (window.optimisationModuleState?.currentTaskId) {
          await window.loadAllOptimisationTasks();
        }
        
        // Close modal if open
        if (modal) {
        modal.style.display = 'none';
        }
        
        // Ensure Ranking & AI tab stays active and refresh table (only if modal was used)
        if (modal && modal.dataset.rowKeyword) {
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        if (rankingTab) {
          // Use setActivePanel to properly show the panel
          if (typeof setActivePanel === 'function') {
            setActivePanel('ranking');
          } else {
            // Fallback: manually set active state
            document.querySelectorAll('.aigeo-panel').forEach(panel => {
              panel.classList.remove('is-active');
              panel.hidden = true;
            });
          rankingTab.classList.add('is-active');
            rankingTab.hidden = false;
          }
          
          // Update nav button states
          document.querySelectorAll('.aigeo-nav-item').forEach(btn => btn.classList.remove('is-active'));
          const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav-item')).find(btn => 
            btn.getAttribute('data-panel') === 'ranking'
          );
          if (rankingNavBtn) rankingNavBtn.classList.add('is-active');
          
          // Ensure panel is rendered
          if (typeof ensurePanelRendered === 'function') {
            ensurePanelRendered('ranking');
          }
        }
        }
        
        // Trigger table re-render
        if (typeof renderRankingAiTab === 'function') {
          await renderRankingAiTab();
        } else if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        } else {
          console.warn('[Optimisation] renderRankingAiTab not found, refreshing page');
          // Preserve Ranking & AI tab state before reload
          sessionStorage.setItem('activeTab', 'ranking');
          window.location.hash = '#ranking';
          location.reload();
        }
      } catch (error) {
        console.error('[Optimisation] Error updating status:', error);
        alert('Failed to update status: ' + error.message);
      }
    };

    // Start new cycle
    window.startNewCycle = async function startNewCycle() {
      const taskId = window.optimisationModuleState?.currentTaskId;
      
      if (!taskId) {
        console.warn('[Optimisation] No task ID found');
        return;
      }

      // Get current task to get cycle info
      const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      if (!task) {
        alert('Task not found. Please refresh the page.');
        return;
      }

      const currentCycleNo = task.cycle_no || task.cycle_active || 1;
      const newCycleNo = currentCycleNo + 1;

      // Show modal for editing new cycle objective
      const modal = document.getElementById('optimisation-new-cycle-modal');
      if (!modal) {
        alert('New cycle modal not found. Please refresh the page.');
        return;
      }

      // Populate with previous cycle's objective if it exists (for copying)
      if (task.objective_title) {
        document.getElementById('new-cycle-objective-title').value = task.objective_title;
      }
      if (task.primary_kpi) {
        document.getElementById('new-cycle-primary-kpi').value = task.primary_kpi;
      }
      if (task.target_direction) {
        document.getElementById('new-cycle-target-direction').value = task.target_direction;
      }
      if (task.target_value != null) {
        document.getElementById('new-cycle-target-value').value = task.target_value;
      }
      if (task.timeframe_days) {
        document.getElementById('new-cycle-timeframe-days').value = task.timeframe_days;
      }
      if (task.plan) {
        document.getElementById('new-cycle-plan').value = task.plan;
      }

      document.getElementById('new-cycle-cycle-no').textContent = `Cycle ${newCycleNo}`;
      modal.dataset.taskId = taskId;
      modal.style.display = 'flex';
    };

    window.submitNewCycle = async function submitNewCycle() {
      const modal = document.getElementById('optimisation-new-cycle-modal');
      if (!modal) return;

      const taskId = modal.dataset.taskId;
      if (!taskId) {
        alert('Task ID not found');
        return;
      }

      // Get objective fields
      const objective_title = document.getElementById('new-cycle-objective-title').value.trim();
      const primary_kpi = document.getElementById('new-cycle-primary-kpi').value.trim();
      const target_direction = document.getElementById('new-cycle-target-direction').value.trim();
      const target_value = document.getElementById('new-cycle-target-value').value.trim();
      const timeframe_days = document.getElementById('new-cycle-timeframe-days').value.trim();
      const plan = document.getElementById('new-cycle-plan').value.trim();

      try {
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/cycle`), {
          method: 'POST',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            objective_title: objective_title || null,
            primary_kpi: primary_kpi || null,
            target_direction: target_direction || null,
            target_value: target_value ? parseFloat(target_value) : null,
            timeframe_days: timeframe_days ? parseInt(timeframe_days) : null,
            plan: plan || null
          })
        });

        if (!response.ok) {
          if (response.status === 401) {
            throw new Error('Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.');
          }
          const errorData = await response.json();
          throw new Error(errorData.error || 'Failed to start new cycle');
        }

        const result = await response.json();
        
        // Update task in state immediately with returned task data (includes new cycle objective)
        if (result.task && window.optimisationModuleState && window.optimisationModuleState.allTasks) {
          const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
          if (taskIndex >= 0) {
            window.optimisationModuleState.allTasks[taskIndex] = result.task;
            console.log('[Optimisation] Updated task in state with new cycle data:', result.task);
          } else {
            window.optimisationModuleState.allTasks.push(result.task);
          }
          // Also update filtered tasks if it exists there
          if (window.optimisationModuleState.filteredTasks) {
            const filteredIndex = window.optimisationModuleState.filteredTasks.findIndex(t => t.id === taskId);
            if (filteredIndex >= 0) {
              window.optimisationModuleState.filteredTasks[filteredIndex] = result.task;
            }
          }
        }
        
        // Small delay to ensure view has updated with new cycle
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Refresh tasks to ensure all data is up to date
        await window.loadAllOptimisationTasks();
        
        // Reload drawer if it's open (will use updated task data)
        if (window.optimisationModuleState.currentTaskId === taskId) {
          // Force reload by closing and reopening
          const currentTaskId = window.optimisationModuleState.currentTaskId;
          window.optimisationModuleState.currentTaskId = null;
          await new Promise(resolve => setTimeout(resolve, 100));
          await window.openOptimisationTaskDrawer(currentTaskId);
        }
        
        modal.style.display = 'none';
        
        // Show success message with cycle info
        const cycleNo = result.cycle?.cycle_no || result.task?.cycle_active || 'new';
        alert(`Cycle ${cycleNo} started successfully!${result.baseline_from_audit ? ' Baseline set from latest audit.' : (result.baseline_from_measurement ? ' Baseline set from previous latest measurement.' : '')}`);
      } catch (error) {
        console.error('[Optimisation] Error starting new cycle:', error);
        alert('Failed to start new cycle: ' + error.message);
      }
    };

    // Edit Objective function
    // Edit objective (inline form)
    window.editObjective = async function editObjective() {
      const taskId = window.optimisationModuleState?.currentTaskId;
      if (!taskId) return;

      const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      if (!task) return;

      const form = document.getElementById('optimisation-edit-objective-form');
      const content = document.getElementById('optimisation-drawer-objective-content');
      if (!form || !content) return;

      // Populate form with current values (Phase 5: use objective from cycle, fallback to legacy)
      const objective = task.objective || task.cycle?.objective || null;
      
      if (objective) {
        // Phase 5 format
        document.getElementById('optimisation-edit-objective-title').value = objective.title || '';
        document.getElementById('optimisation-edit-objective-kpi').value = ''; // KPI label not used in Phase 5
        document.getElementById('optimisation-edit-objective-metric').value = objective.kpi || '';
        document.getElementById('optimisation-edit-objective-direction').value = objective.target_type === 'absolute' ? 'at_least' : 'increase'; // Default
        document.getElementById('optimisation-edit-objective-target-value').value = objective.target != null ? objective.target : '';
        document.getElementById('optimisation-edit-objective-plan').value = objective.plan || '';
        
        // Calculate timeframe from due_at if available
        if (objective.due_at) {
          const dueDate = new Date(objective.due_at);
          const taskStart = task.cycle_started_at || task.cycle_start_date || new Date();
          const startDate = new Date(taskStart);
          const daysDiff = Math.round((dueDate - startDate) / (1000 * 60 * 60 * 24));
          document.getElementById('optimisation-edit-objective-timeframe').value = daysDiff > 0 ? daysDiff : '';
          
          const dueDateEl = document.getElementById('optimisation-edit-objective-due-date');
          if (dueDateEl) {
            dueDateEl.textContent = `Due: ${dueDate.toLocaleDateString('en-GB')}`;
          }
        } else {
          document.getElementById('optimisation-edit-objective-timeframe').value = '';
        }
      } else {
        // Legacy format fallback
        document.getElementById('optimisation-edit-objective-title').value = task.objective_title || '';
        document.getElementById('optimisation-edit-objective-kpi').value = task.objective_kpi || task.objective_metric || '';
        document.getElementById('optimisation-edit-objective-metric').value = task.objective_metric || task.objective_kpi || '';
        document.getElementById('optimisation-edit-objective-direction').value = task.objective_direction || '';
        document.getElementById('optimisation-edit-objective-target-value').value = task.objective_target_delta != null ? task.objective_target_delta : (task.objective_target_value != null ? task.objective_target_value : '');
        document.getElementById('optimisation-edit-objective-timeframe').value = task.objective_timeframe_days != null ? task.objective_timeframe_days : '';
        document.getElementById('optimisation-edit-objective-plan').value = task.objective_plan || '';
        
        // If objective_due_at exists, calculate and display it
        if (task.objective_due_at) {
          const dueDateEl = document.getElementById('optimisation-edit-objective-due-date');
          if (dueDateEl) {
            const dueDate = new Date(task.objective_due_at);
            dueDateEl.textContent = `Due: ${dueDate.toLocaleDateString('en-GB')}`;
          }
        }
      }

      // Calculate and show due date
      updateObjectiveDueDate();

      // Show form, hide content
      form.style.display = 'block';
      content.style.display = 'none';
    };

    // Update due date display when timeframe changes
    function updateObjectiveDueDate() {
      const timeframeInput = document.getElementById('optimisation-edit-objective-timeframe');
      const dueDateEl = document.getElementById('optimisation-edit-objective-due-date');
      if (!timeframeInput || !dueDateEl) return;

      const timeframe = parseInt(timeframeInput.value);
      if (timeframe > 0) {
        const taskId = window.optimisationModuleState?.currentTaskId;
        const task = window.optimisationModuleState?.allTasks?.find(t => t.id === taskId);
        const startDate = task?.cycle_started_at || task?.cycle_start_date || new Date();
        const dueDate = new Date(new Date(startDate).getTime() + timeframe * 24 * 60 * 60 * 1000);
        dueDateEl.textContent = `Due: ${dueDate.toLocaleDateString('en-GB')}`;
      } else {
        dueDateEl.textContent = '';
      }
    }

    // Save objective
    window.saveObjective = async function saveObjective() {
      const taskId = window.optimisationModuleState?.currentTaskId;
      if (!taskId) {
        alert('Task ID not found');
        return;
      }

      // Get form values (Phase 5 format)
      const title = document.getElementById('optimisation-edit-objective-title').value.trim();
      const kpi = document.getElementById('optimisation-edit-objective-metric').value || null;
      const targetValue = document.getElementById('optimisation-edit-objective-target-value').value;
      const target = targetValue ? (kpi === 'ai_overview' ? targetValue === 'true' : parseFloat(targetValue)) : null;
      const direction = document.getElementById('optimisation-edit-objective-direction').value || null;
      
      // Determine target_type based on KPI
      let target_type = 'delta';
      if (kpi === 'ai_overview' || kpi === 'current_rank') {
        target_type = 'absolute';
      } else if (direction === 'at_least' || direction === 'at_most') {
        target_type = 'absolute';
      }

      const timeframeDays = document.getElementById('optimisation-edit-objective-timeframe').value;
      const plan = document.getElementById('optimisation-edit-objective-plan').value.trim() || null;

      // Calculate due_at if timeframe is set
      let due_at = null;
      if (timeframeDays) {
        const task = window.optimisationModuleState?.allTasks?.find(t => t.id === taskId);
        const startDate = task?.cycle_started_at || task?.cycle_start_date ? new Date(task.cycle_started_at || task.cycle_start_date) : new Date();
        due_at = new Date(startDate.getTime() + parseInt(timeframeDays) * 24 * 60 * 60 * 1000).toISOString();
      }

      // Phase 5: Send new format
      const objectiveData = {
        title: title || null,
        kpi: kpi || null,
        target: target,
        target_type: target_type,
        due_at: due_at,
        plan: plan
      };

      try {
        const headers = window.getOptimisationHeaders();
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/objective`), {
          method: 'PATCH',
          headers: { ...headers, 'Content-Type': 'application/json' },
          body: JSON.stringify(objectiveData)
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || error.errors?.join(', ') || 'Failed to save objective');
        }

        const data = await response.json();

        // Hide edit form
        document.getElementById('optimisation-edit-objective-form').style.display = 'none';
        document.getElementById('optimisation-drawer-objective-content').style.display = 'block';

        // Reload tasks and refresh drawer
        if (typeof window.loadAllOptimisationTasks === 'function') {
          await window.loadAllOptimisationTasks();
        }
        await window.openOptimisationTaskDrawer(taskId);
      } catch (error) {
        console.error('[Optimisation] Error saving objective:', error);
        alert('Failed to save objective: ' + error.message);
      }
    };

    // Cancel edit objective
    window.cancelEditObjective = function cancelEditObjective() {
      const form = document.getElementById('optimisation-edit-objective-form');
      const content = document.getElementById('optimisation-drawer-objective-content');
      if (form) form.style.display = 'none';
      if (content) content.style.display = 'block';
    };

    // Old modal-based edit (keeping for backward compatibility but not used)
    window.editObjectiveOld = async function editObjectiveOld() {
      const taskId = window.optimisationModuleState?.currentTaskId;
      if (!taskId) return;

      const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      if (!task) return;

      // Show edit modal (reuse new cycle modal structure)
      const modal = document.getElementById('optimisation-edit-objective-modal');
      if (!modal) {
        alert('Edit objective modal not found. Please refresh the page.');
        return;
      }

      // Populate with current objective
      document.getElementById('edit-objective-title').value = task.objective_title || '';
      document.getElementById('edit-objective-primary-kpi').value = task.primary_kpi || '';
      document.getElementById('edit-objective-target-direction').value = task.target_direction || '';
      document.getElementById('edit-objective-target-value').value = task.target_value || '';
      document.getElementById('edit-objective-timeframe-days').value = task.timeframe_days || '';
      document.getElementById('edit-objective-plan').value = task.plan || '';

      modal.dataset.taskId = taskId;
      modal.style.display = 'flex';
    };

    window.submitEditObjective = async function submitEditObjective() {
      const modal = document.getElementById('optimisation-edit-objective-modal');
      if (!modal) return;

      const taskId = modal.dataset.taskId;
      if (!taskId) {
        alert('Task ID not found');
        return;
      }

      // Get objective fields
      const objective_title = document.getElementById('edit-objective-title').value.trim();
      const primary_kpi = document.getElementById('edit-objective-primary-kpi').value.trim();
      const target_direction = document.getElementById('edit-objective-target-direction').value.trim();
      const target_value = document.getElementById('edit-objective-target-value').value.trim();
      const timeframe_days = document.getElementById('edit-objective-timeframe-days').value.trim();
      const plan = document.getElementById('edit-objective-plan').value.trim();

      try {
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'PATCH',
          headers: window.getOptimisationHeaders(),
          body: JSON.stringify({
            objective_title: objective_title || null,
            primary_kpi: primary_kpi || null,
            target_direction: target_direction || null,
            target_value: target_value ? parseFloat(target_value) : null,
            timeframe_days: timeframe_days ? parseInt(timeframe_days) : null,
            plan: plan || null
          })
        });

        if (!response.ok) {
          if (response.status === 401) {
            throw new Error('Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.');
          }
          const errorData = await response.json();
          throw new Error(errorData.error || 'Failed to update objective');
        }

        // Refresh tasks and reload drawer
        await window.loadAllOptimisationTasks();
        
        // Reload drawer if it's open
        if (window.optimisationModuleState.currentTaskId === taskId) {
          await window.openOptimisationTaskDrawer(taskId);
        }
        
        modal.style.display = 'none';
        
        alert('Objective updated successfully!');
      } catch (error) {
        console.error('[Optimisation] Error updating objective:', error);
        alert('Failed to update objective: ' + error.message);
      }
    };

    // Helper function to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Stop tracking
    window.stopTracking = async function stopTracking() {
      // B5: Support both modal and drawer
      const modal = document.getElementById('optimisation-manage-modal');
      const drawerTaskId = window.optimisationModuleState?.currentTaskId;
      const modalTaskId = modal?.dataset.taskId;
      const taskId = drawerTaskId || modalTaskId;
      
      if (!taskId) {
        console.warn('[Optimisation] No task ID found in modal or drawer');
        return;
      }

      if (!confirm('Stop tracking this keyword? The task will be marked as cancelled but history will be preserved.')) {
        return;
      }

      try {
        const headers = window.getOptimisationHeaders();
        console.log('[Optimisation] Stopping tracking:', { taskId, hasAdminKey: !!headers['x-arp-admin-key'] });
        
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'PATCH',
          headers: headers,
          body: JSON.stringify({
            status: 'cancelled'
          })
        });

        console.log('[Optimisation] Response status:', response.status, response.statusText);

        if (!response.ok) {
          // Clone response BEFORE reading to allow multiple reads
          const responseClone = response.clone();
          let errorMessage = 'Failed to stop tracking';
          let errorDetails = null;
          
          try {
            // Try to read as JSON first (most APIs return JSON)
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
            errorDetails = errorData;
            console.error('[Optimisation] API error response:', errorData);
          } catch (e) {
            // If JSON parsing fails, try text from clone
            console.error('[Optimisation] JSON parse failed, trying text:', e);
            try {
              const errorText = await responseClone.text();
              console.error('[Optimisation] Error response text (length):', errorText ? errorText.length : 0);
              if (errorText && errorText.trim()) {
                // Try to parse as JSON if it looks like JSON
                try {
                  const parsed = JSON.parse(errorText);
                  errorMessage = parsed.error || parsed.message || errorText;
                  errorDetails = parsed;
                } catch (parseError) {
                  errorMessage = errorText.substring(0, 200); // Limit length
                  errorDetails = { rawText: errorText.substring(0, 500) };
                }
                console.error('[Optimisation] API error text:', errorText.substring(0, 200));
              } else {
                console.error('[Optimisation] Error response body is empty');
                errorDetails = { empty: true };
              }
            } catch (e2) {
              console.error('[Optimisation] Failed to read error response:', e2);
              errorDetails = { readError: e2.message };
            }
          }
          
          // Enhance error message based on status code
          if (response.status === 401) {
            errorMessage = 'Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.';
          } else if (response.status === 404) {
            errorMessage = 'Task not found. It may have been deleted.';
          } else if (response.status === 403) {
            errorMessage = 'Forbidden - you do not have permission to update this task.';
          } else if (response.status === 500) {
            errorMessage = `Server error (${response.status}): ${errorMessage}`;
          } else {
            errorMessage = `HTTP ${response.status}: ${errorMessage}`;
          }
          
          console.error('[Optimisation] Full error details:', {
            status: response.status,
            statusText: response.statusText,
            errorMessage,
            errorDetails
          });
          
          throw new Error(errorMessage);
        }
        
        // Read successful response
        const result = await response.json();
        console.log('[Optimisation] Stop tracking successful:', result);

        // Refresh data
        if (modal && modal.dataset.rowKeyword) {
        await window.fetchOptimisationStatuses([{
          keyword: modal.dataset.rowKeyword,
          best_url: modal.dataset.rowUrl
        }]);
        }
        
        // Refresh all tasks if drawer is open
        if (window.optimisationModuleState?.currentTaskId) {
          await window.loadAllOptimisationTasks();
        }
        
        // Close modal if open, drawer if open
        if (modal) {
        modal.style.display = 'none';
        }
        if (window.optimisationModuleState?.currentTaskId) {
          closeOptimisationTaskDrawer();
        }
        
        // Ensure Ranking & AI tab stays active and refresh table
        const rankingTab = document.querySelector('[data-panel="ranking"]');
        if (rankingTab) {
          // Use setActivePanel to properly show the panel
          if (typeof setActivePanel === 'function') {
            setActivePanel('ranking');
          } else {
            // Fallback: manually set active state
            document.querySelectorAll('.aigeo-panel').forEach(panel => {
              panel.classList.remove('is-active');
              panel.hidden = true;
            });
          rankingTab.classList.add('is-active');
            rankingTab.hidden = false;
          }
          
          // Update nav button states
          document.querySelectorAll('.aigeo-nav-item').forEach(btn => btn.classList.remove('is-active'));
          const rankingNavBtn = Array.from(document.querySelectorAll('.aigeo-nav-item')).find(btn => 
            btn.getAttribute('data-panel') === 'ranking'
          );
          if (rankingNavBtn) rankingNavBtn.classList.add('is-active');
          
          // Ensure panel is rendered
          if (typeof ensurePanelRendered === 'function') {
            ensurePanelRendered('ranking');
          }
        }
        
        // Trigger table re-render
        if (typeof renderRankingAiTab === 'function') {
          await renderRankingAiTab();
        } else if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        } else {
          console.warn('[Optimisation] renderRankingAiTab not found, refreshing page');
          // Preserve Ranking & AI tab state before reload
          sessionStorage.setItem('activeTab', 'ranking');
          window.location.hash = '#ranking';
          location.reload();
        }
      } catch (error) {
        console.error('[Optimisation] Error stopping tracking:', error);
        alert('Failed to stop tracking: ' + error.message);
      }
    };

    // Delete task (hard delete - removes task and all events)
    window.deleteTask = async function deleteTask() {
      const taskId = window.optimisationModuleState?.currentTaskId;
      
      if (!taskId) {
        console.warn('[Optimisation] No task ID found');
        return;
      }

      if (!confirm('Permanently delete this task and all its events? This cannot be undone.')) {
        return;
      }

      try {
        const headers = window.getOptimisationHeaders();
        console.log('[Optimisation] Deleting task:', { taskId, hasAdminKey: !!headers['x-arp-admin-key'] });
        
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'DELETE',
          headers: headers
        });

        console.log('[Optimisation] Response status:', response.status, response.statusText);

        if (!response.ok) {
          const responseClone = response.clone();
          let errorMessage = 'Failed to delete task';
          
          try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
            console.error('[Optimisation] API error response:', errorData);
          } catch (e) {
            try {
              const errorText = await responseClone.text();
              if (errorText && errorText.trim()) {
                try {
                  const parsed = JSON.parse(errorText);
                  errorMessage = parsed.error || parsed.message || errorText;
                } catch (parseError) {
                  errorMessage = errorText.substring(0, 200);
                }
              }
            } catch (e2) {
              console.error('[Optimisation] Failed to read error response:', e2);
            }
          }
          
          if (response.status === 401) {
            errorMessage = 'Unauthorized - admin key missing or invalid. Please set your admin key in the configuration section.';
          } else if (response.status === 404) {
            errorMessage = 'Task not found. It may have been deleted.';
          } else if (response.status === 403) {
            errorMessage = 'Forbidden - you do not have permission to update this task.';
          } else if (response.status === 500) {
            errorMessage = `Server error (${response.status}): ${errorMessage}`;
          } else {
            errorMessage = `HTTP ${response.status}: ${errorMessage}`;
          }
          
          throw new Error(errorMessage);
        }
        
        const result = await response.json();
        console.log('[Optimisation] Delete task successful:', result);

        // Close the modal/drawer
        const drawer = document.getElementById('optimisation-task-drawer');
        if (drawer) {
          drawer.style.display = 'none';
        }

        // Clear the cache to force refresh
        if (window.optimisationStatusCache) {
          window.optimisationStatusCache.clear();
        }

        // Refresh Optimisation Tracking table
        await window.loadAllOptimisationTasks();

        // Refresh Ranking & AI table to show "Not tracked"
        if (typeof window.renderRankingAiTab === 'function') {
          await window.renderRankingAiTab();
        }
      } catch (error) {
        console.error('[Optimisation] Error deleting task:', error);
        throw error; // Re-throw so caller can handle
      }
    };

    // ======================
    // Optimisation Tracking Module (Phase B)
    // ======================
    
    // State
    window.optimisationModuleState = {
      allTasks: [],
      dashboardTiles: null,
      dashboardImpact: null,
      dashboardTimeseries: null,
      filteredTasks: [],
      activeTab: 'active',
      currentTaskId: null,
      authError: null,
      activeObjectiveFilter: null, // 'not_set' | 'on_track' | 'overdue' | 'met' | null
      scope: 'active_cycle', // 'active_cycle' | 'all_tasks'
      metricTrafficFilter: null, // { metricKey: string, bucket: 'better'|'same'|'worse' } | null
      selectedKpiForTrend: 'ctr_28d', // KPI selected for trend chart
      leftChartView: 'clicks' // 'clicks' | 'trend'
    };
    
    // Traffic Light Utility Functions (inline from lib/optimisation/metricTraffic.js)
    function isActiveStatus(status) {
      return ['planned', 'in_progress', 'monitoring'].includes(status);
    }

    function getBaselineLatest(measurements, scope, activeCycle = null) {
      if (!measurements || measurements.length === 0) {
        return null;
      }

      let eligibleMeasurements = [...measurements];

      // Filter by scope
      if (scope === 'active_cycle' && activeCycle) {
        const cycleStartDate = activeCycle.start_date ? new Date(activeCycle.start_date) : 
                              (activeCycle.started_at ? new Date(activeCycle.started_at) : null);
        if (cycleStartDate) {
          eligibleMeasurements = eligibleMeasurements.filter(m => {
            const mDate = m.captured_at ? new Date(m.captured_at) : null;
            return mDate && mDate >= cycleStartDate;
          });
        }
      }

      // Need at least 2 measurements to compute baseline/latest
      if (eligibleMeasurements.length < 2) {
        return null;
      }

      // Sort by date (oldest first)
      eligibleMeasurements.sort((a, b) => {
        const dateA = a.captured_at ? new Date(a.captured_at) : new Date(0);
        const dateB = b.captured_at ? new Date(b.captured_at) : new Date(0);
        return dateA - dateB;
      });

      const baseline = eligibleMeasurements[0];
      const latest = eligibleMeasurements[eligibleMeasurements.length - 1];

      return { baseline, latest };
    }

    function getMetricValue(measurement, metricKey) {
      if (!measurement) return null;

      const extractors = {
        ctr_28d: (m) => m?.ctr_28d ?? null,
        impressions_28d: (m) => m?.impressions_28d ?? null,
        clicks_28d: (m) => m?.clicks_28d ?? null,
        current_rank: (m) => m?.current_rank ?? m?.rank ?? null,
        opportunity_score: (m) => m?.opportunity_score ?? null,
        ai_overview: (m) => m?.ai_overview ?? null,
        ai_citations: (m) => m?.ai_citations ?? null,
      };

      const extractor = extractors[metricKey];
      if (!extractor) return null;

      return extractor(measurement);
    }

    function classifyMetric(metricKey, baseline, latest) {
      if (!baseline || !latest) {
        return null;
      }

      const baselineValue = getMetricValue(baseline, metricKey);
      const latestValue = getMetricValue(latest, metricKey);

      // If either value is null/undefined, cannot classify
      if (baselineValue == null || latestValue == null) {
        return null;
      }

      // CTR (28d) - stored as ratio (0-1), compare as percentage points
      if (metricKey === 'ctr_28d') {
        const deltaPp = (latestValue - baselineValue) * 100;
        if (Math.abs(deltaPp) < 0.10) {
          return 'same';
        }
        return deltaPp >= 0.10 ? 'better' : 'worse';
      }

      // Impressions (28d)
      if (metricKey === 'impressions_28d') {
        const delta = latestValue - baselineValue;
        const tol = Math.max(20, Math.round(baselineValue * 0.02));
        if (Math.abs(delta) < tol) {
          return 'same';
        }
        return delta >= tol ? 'better' : 'worse';
      }

      // Clicks (28d)
      if (metricKey === 'clicks_28d') {
        const delta = latestValue - baselineValue;
        const tol = Math.max(5, Math.round(baselineValue * 0.05));
        if (Math.abs(delta) < tol) {
          return 'same';
        }
        return delta >= tol ? 'better' : 'worse';
      }

      // Rank (lower is better)
      if (metricKey === 'current_rank') {
        const delta = latestValue - baselineValue; // positive means rank got worse (increased)
        if (Math.abs(delta) < 0.5) {
          return 'same';
        }
        return delta <= -0.5 ? 'better' : 'worse';
      }

      // AI Citations
      if (metricKey === 'ai_citations') {
        const delta = latestValue - baselineValue;
        if (delta === 0) {
          return 'same';
        }
        return delta > 0 ? 'better' : 'worse';
      }

      // AI Overview (boolean)
      if (metricKey === 'ai_overview') {
        const baselineBool = baselineValue === true || baselineValue === 'On' || baselineValue === 1;
        const latestBool = latestValue === true || latestValue === 'On' || latestValue === 1;
        
        if (baselineBool === latestBool) {
          return 'same';
        }
        // Better: Off -> On, Worse: On -> Off
        return (!baselineBool && latestBool) ? 'better' : 'worse';
      }

      // Opportunity Score
      if (metricKey === 'opportunity_score') {
        const delta = latestValue - baselineValue;
        if (Math.abs(delta) < 2) {
          return 'same';
        }
        return delta >= 2 ? 'better' : 'worse';
      }

      // Unknown metric
      return null;
    }

    // Helper: Get latest measurement in scope for a task
    function getLatestMeasurementInScope(task, scope) {
      const measurements = task.measurements || [];
      if (measurements.length === 0) {
        return null;
      }

      let eligibleMeasurements = [...measurements];

      // Filter by scope
      if (scope === 'active_cycle') {
        const activeCycle = task.cycles?.find(c => c.is_active || c.id === task.active_cycle_id) || null;
        if (activeCycle) {
          const cycleStartDate = activeCycle.start_date ? new Date(activeCycle.start_date) : 
                                (activeCycle.started_at ? new Date(activeCycle.started_at) : null);
          if (cycleStartDate) {
            eligibleMeasurements = eligibleMeasurements.filter(m => {
              const mDate = m.captured_at ? new Date(m.captured_at) : null;
              return mDate && mDate >= cycleStartDate;
            });
          }
        }
      }
      // For 'all_tasks' scope, use all measurements

      if (eligibleMeasurements.length === 0) {
        return null;
      }

      // Sort by date (newest first) and return the latest
      eligibleMeasurements.sort((a, b) => {
        const dateA = a.captured_at ? new Date(a.captured_at) : new Date(0);
        const dateB = b.captured_at ? new Date(b.captured_at) : new Date(0);
        return dateB - dateA; // Descending (newest first)
      });

      return eligibleMeasurements[0];
    }

    // Helper: Get Monday-start week key (YYYY-MM-DD)
    function weekStartISO(date) {
      const d = new Date(date);
      d.setHours(0, 0, 0, 0);
      // Get day of week (0 = Sunday, 1 = Monday, etc.)
      const day = d.getDay();
      // Calculate days to subtract to get to Monday
      const diff = day === 0 ? 6 : day - 1; // If Sunday, go back 6 days; otherwise go back (day-1) days
      d.setDate(d.getDate() - diff);
      // Return YYYY-MM-DD format
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, '0');
      const dayOfMonth = String(d.getDate()).padStart(2, '0');
      return `${year}-${month}-${dayOfMonth}`;
    }

    // Helper: Compute delta for a KPI with correct units
    function computeDeltaForKPI(kpi, baseline, latest) {
      if (!baseline || !latest) {
        return null;
      }

      const baselineValue = getMetricValue(baseline, kpi);
      const latestValue = getMetricValue(latest, kpi);

      if (baselineValue == null || latestValue == null) {
        return null;
      }

      // CTR: return as percentage points
      if (kpi === 'ctr_28d') {
        return (latestValue - baselineValue) * 100;
      }

      // Rank: lower is better, so invert the delta (baseline - latest)
      // Positive delta = improvement (rank decreased)
      if (kpi === 'current_rank') {
        return baselineValue - latestValue;
      }

      // All others: absolute delta (higher is better)
      return latestValue - baselineValue;
    }

    // Helper: Compute median of an array
    function median(values) {
      if (values.length === 0) return null;
      const sorted = [...values].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2 === 0
        ? (sorted[mid - 1] + sorted[mid]) / 2
        : sorted[mid];
    }

    function computeTrafficLightCounts(tasks, scope) {
      const counts = {
        ctr_28d: { worse: 0, same: 0, better: 0 },
        impressions_28d: { worse: 0, same: 0, better: 0 },
        clicks_28d: { worse: 0, same: 0, better: 0 },
        current_rank: { worse: 0, same: 0, better: 0 },
        ai_citations: { worse: 0, same: 0, better: 0 },
        ai_overview: { worse: 0, same: 0, better: 0 },
        all_metrics: { worse: 0, same: 0, better: 0 }, // Aggregated counts
      };

      const metricKeys = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];

      for (const task of tasks) {
        // Only count active tasks
        if (!isActiveStatus(task.status)) {
          continue;
        }

        // Get active cycle if scope is 'active_cycle'
        const activeCycle = scope === 'active_cycle' 
          ? (task.cycles?.find(c => c.is_active || c.id === task.active_cycle_id) || null)
          : null;

        // Get measurements
        const measurements = task.measurements || [];
        const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);

        // Track classifications for all metrics to compute aggregated count
        const taskClassifications = [];

        if (baselineLatest) {
          // Classify each metric
          for (const metricKey of metricKeys) {
            const classification = classifyMetric(
              metricKey,
              baselineLatest.baseline,
              baselineLatest.latest
            );

            if (classification) {
              counts[metricKey][classification]++;
              taskClassifications.push(classification);
            }
          }
        }

        // For aggregated "all_metrics": count ALL active tasks
        // If task has classifications, use majority vote (at least 3 out of 6 metrics)
        // If no classifications or tie, default to 'same'
        if (taskClassifications.length > 0) {
          // Count occurrences of each classification
          const classCounts = { worse: 0, same: 0, better: 0 };
          taskClassifications.forEach(cls => {
            if (cls) classCounts[cls]++;
          });
          
          // Find the majority classification
          const total = classCounts.worse + classCounts.same + classCounts.better;
          const majority = Math.max(classCounts.worse, classCounts.same, classCounts.better);
          
          let majorityClass = null;
          if (classCounts.better === majority && majority > 0) {
            majorityClass = 'better';
          } else if (classCounts.worse === majority && majority > 0) {
            majorityClass = 'worse';
          } else if (classCounts.same === majority && majority > 0) {
            majorityClass = 'same';
          }
          
          // If there's a clear majority (more than half), use it
          // Otherwise default to 'same'
          if (majorityClass && majority > total / 2) {
            counts.all_metrics[majorityClass]++;
          } else {
            // No clear majority or no classifications - default to 'same'
            counts.all_metrics.same++;
          }
        } else {
          // Task has no metric classifications (insufficient data) - count as 'same'
          counts.all_metrics.same++;
        }
      }

      return counts;
    }

    // Sorting state
    let optimisationSortState = {
      column: 'latestCaptured',
      direction: 'desc'
    };
    
    // Pagination state
    let optimisationPaginationState = {
      currentPage: 1,
      rowsPerPage: 10
    };

    // Load all optimisation tasks (Phase 9: use dashboard API)
    window.loadAllOptimisationTasks = async function loadAllOptimisationTasks() {
      try {
        // Check if admin key is set
        if (!window.hasAdminKey || !window.hasAdminKey()) {
          window.optimisationModuleState.allTasks = [];
          window.optimisationModuleState.filteredTasks = [];
          window.optimisationModuleState.authError = 'Admin key not set. Please set your admin key in the Configuration section.';
          updateOptimisationSummaryCards();
          renderOptimisationTasksTable();
          return [];
        }

        const headers = window.getOptimisationHeaders();
        const scope = window.optimisationModuleState.scope || 'active_cycle';
        const response = await fetch(apiUrl(`/api/optimisation/dashboard?scope=${scope}`), {
          method: 'GET',
          headers: headers
        });

        if (!response.ok) {
          if (response.status === 401) {
            window.optimisationModuleState.authError = 'Unauthorized - admin key missing or invalid. Please check your admin key in the Configuration section.';
          } else {
            window.optimisationModuleState.authError = `Failed to load dashboard (${response.status}). Please try refreshing the page.`;
          }
          window.optimisationModuleState.allTasks = [];
          window.optimisationModuleState.filteredTasks = [];
          window.optimisationModuleState.dashboardTiles = null;
          window.optimisationModuleState.dashboardImpact = null;
          window.optimisationModuleState.dashboardTimeseries = null;
          updateOptimisationSummaryCards();
          renderOptimisationTasksTable();
          return [];
        }

        // Clear any previous auth errors
        window.optimisationModuleState.authError = null;

        const data = await response.json();
        window.optimisationModuleState.allTasks = data.tasks || [];
        window.optimisationModuleState.filteredTasks = [...window.optimisationModuleState.allTasks];
        window.optimisationModuleState.dashboardTiles = data.tiles || null;
        window.optimisationModuleState.dashboardImpact = data.impact || null;
        window.optimisationModuleState.dashboardTimeseries = data.timeseries || null;
        
        updateOptimisationSummaryCards();
        updateKPITiles();
        updateImpactTiles();
        updateTimeseriesCharts();
        updateTrafficLights();
        applyOptimisationFilters();
        renderOptimisationTasksTable();
        
        return window.optimisationModuleState.allTasks;
      } catch (error) {
        console.error('[Optimisation Module] Error loading dashboard:', error);
        window.optimisationModuleState.allTasks = [];
        window.optimisationModuleState.filteredTasks = [];
        window.optimisationModuleState.dashboardTiles = null;
        window.optimisationModuleState.dashboardImpact = null;
        window.optimisationModuleState.dashboardTimeseries = null;
        window.optimisationModuleState.authError = error.message || 'Failed to load dashboard. Please try refreshing the page.';
        updateOptimisationSummaryCards();
        renderOptimisationTasksTable();
        return [];
      }
    };

    // Update summary cards (B6)
    function updateOptimisationSummaryCards() {
      let tasks = window.optimisationModuleState.allTasks;
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      const active = tasks.filter(t => ['planned', 'in_progress', 'monitoring'].includes(t.status));
      const planned = tasks.filter(t => t.status === 'planned');
      const inProgress = tasks.filter(t => t.status === 'in_progress');
      const monitoring = tasks.filter(t => t.status === 'monitoring');
      const done = tasks.filter(t => t.status === 'done');
      const paused = tasks.filter(t => t.status === 'paused');
      const cancelled = tasks.filter(t => t.status === 'cancelled');
      
      // Updated (30d): Count distinct tasks with latest measurement in last 30 days
      // Must use the same task set and scope as other status tiles
      const scope = window.optimisationModuleState.scope || 'active_cycle';
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      const updatedTaskIds = new Set();
      for (const task of tasks) {
        const latestMeasurement = getLatestMeasurementInScope(task, scope);
        if (latestMeasurement && latestMeasurement.captured_at) {
          const latestDate = new Date(latestMeasurement.captured_at);
          if (latestDate >= thirtyDaysAgo) {
            updatedTaskIds.add(task.id);
          }
        }
      }
      const recent = Array.from(updatedTaskIds).length;

      document.getElementById('optimisation-summary-active').textContent = active.length;
      document.getElementById('optimisation-summary-planned').textContent = planned.length;
      document.getElementById('optimisation-summary-in-progress').textContent = inProgress.length;
      document.getElementById('optimisation-summary-monitoring').textContent = monitoring.length;
      document.getElementById('optimisation-summary-done').textContent = done.length;
      document.getElementById('optimisation-summary-paused').textContent = paused.length;
      document.getElementById('optimisation-summary-cancelled').textContent = cancelled.length;
      document.getElementById('optimisation-summary-recent').textContent = recent.length;

      // Update tab counts
      const pausedCancelled = paused.length + cancelled.length;
      
      document.querySelectorAll('.optimisation-tab-count[data-tab="active"]').forEach(el => {
        el.textContent = `(${active.length})`;
      });
      document.querySelectorAll('.optimisation-tab-count[data-tab="done"]').forEach(el => {
        el.textContent = `(${done.length})`;
      });
      document.querySelectorAll('.optimisation-tab-count[data-tab="paused-cancelled"]').forEach(el => {
        el.textContent = `(${pausedCancelled})`;
      });

      // Update goal rollups (Phase B) - only count active tasks (not cancelled/deleted)
      const activeTasks = tasks.filter(t => !['done', 'cancelled', 'deleted'].includes(t.status));
      // Use objective_status from cycle (Phase 5) or fallback to goal_state
      const goalNotSet = activeTasks.filter(t => {
        const status = t.objective_status || t.goal_state;
        return !status || status === 'not_set';
      }).length;
      const goalOnTrack = activeTasks.filter(t => {
        const status = t.objective_status || t.goal_state;
        return status === 'on_track';
      }).length;
      const goalOverdue = activeTasks.filter(t => {
        const status = t.objective_status || t.goal_state;
        return status === 'overdue';
      }).length;
      const goalMet = activeTasks.filter(t => {
        const status = t.objective_status || t.goal_state;
        return status === 'met';
      }).length;

      const notSetEl = document.getElementById('optimisation-goal-not-set');
      const onTrackEl = document.getElementById('optimisation-goal-on-track');
      const overdueEl = document.getElementById('optimisation-goal-overdue');
      const metEl = document.getElementById('optimisation-goal-met');
      
      if (notSetEl) notSetEl.textContent = goalNotSet;
      if (onTrackEl) onTrackEl.textContent = goalOnTrack;
      if (overdueEl) overdueEl.textContent = goalOverdue;
      if (metEl) metEl.textContent = goalMet;
    }

    // Update timeseries charts
    // OLD updateTimeseriesCharts function removed - see new implementation below

    // Sort optimisation tasks
    function sortOptimisationTasks(tasks) {
      const sorted = [...tasks];
      sorted.sort((a, b) => {
        let aVal, bVal;
        switch (optimisationSortState.column) {
          case 'keyword':
            aVal = (a.keyword_text || '').toLowerCase();
            bVal = (b.keyword_text || '').toLowerCase();
            break;
          case 'url':
            aVal = (a.target_url_clean || '').toLowerCase();
            bVal = (b.target_url_clean || '').toLowerCase();
            break;
          case 'type':
            aVal = (a.task_type || 'on_page').toLowerCase();
            bVal = (b.task_type || 'on_page').toLowerCase();
            break;
          case 'status':
            aVal = (a.status || 'planned').toLowerCase();
            bVal = (b.status || 'planned').toLowerCase();
            break;
          case 'cycle':
            aVal = a.cycle_active || 1;
            bVal = b.cycle_active || 1;
            break;
          case 'lastActivity':
            aVal = a.last_activity_at ? new Date(a.last_activity_at).getTime() : (a.updated_at ? new Date(a.updated_at).getTime() : 0);
            bVal = b.last_activity_at ? new Date(b.last_activity_at).getTime() : (b.updated_at ? new Date(b.updated_at).getTime() : 0);
            break;
          case 'baselineCaptured':
            aVal = (a.baseline_metrics?.captured_at || a.baseline_metrics?.created_at) ? new Date(a.baseline_metrics.captured_at || a.baseline_metrics.created_at).getTime() : 0;
            bVal = (b.baseline_metrics?.captured_at || b.baseline_metrics?.created_at) ? new Date(b.baseline_metrics.captured_at || b.baseline_metrics.created_at).getTime() : 0;
            break;
          case 'latestCaptured':
            aVal = (a.latest_metrics?.captured_at || a.latest_metrics?.created_at) ? new Date(a.latest_metrics.captured_at || a.latest_metrics.created_at).getTime() : 0;
            bVal = (b.latest_metrics?.captured_at || b.latest_metrics?.created_at) ? new Date(b.latest_metrics.captured_at || b.latest_metrics.created_at).getTime() : 0;
            break;
          case 'title':
            aVal = (a.title || '').toLowerCase();
            bVal = (b.title || '').toLowerCase();
            break;
          default:
            return 0;
        }
        
        if (aVal < bVal) return optimisationSortState.direction === 'asc' ? -1 : 1;
        if (aVal > bVal) return optimisationSortState.direction === 'asc' ? 1 : -1;
        return 0;
      });
      return sorted;
    }

    // Render tasks table (B2)
    function renderOptimisationTasksTable() {
      const tbody = document.getElementById('optimisation-tasks-tbody');
      if (!tbody) return;

      let tasks = window.optimisationModuleState.filteredTasks;

      // Apply tab filter
      if (window.optimisationModuleState.activeTab === 'active') {
        tasks = tasks.filter(t => ['planned', 'in_progress', 'monitoring'].includes(t.status));
      } else if (window.optimisationModuleState.activeTab === 'done') {
        tasks = tasks.filter(t => t.status === 'done');
      } else if (window.optimisationModuleState.activeTab === 'paused-cancelled') {
        tasks = tasks.filter(t => ['paused', 'cancelled'].includes(t.status));
      }

      // Sort tasks
      tasks = sortOptimisationTasks(tasks);
      
      // Calculate pagination
      const totalRows = tasks.length;
      const rowsPerPage = optimisationPaginationState.rowsPerPage === 'all' ? totalRows : optimisationPaginationState.rowsPerPage;
      const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
      const currentPage = Math.min(Math.max(1, optimisationPaginationState.currentPage), totalPages);
      optimisationPaginationState.currentPage = currentPage;
      
      const startIdx = rowsPerPage === 'all' ? 0 : (currentPage - 1) * rowsPerPage;
      const endIdx = rowsPerPage === 'all' ? totalRows : Math.min(startIdx + rowsPerPage, totalRows);
      const paginatedTasks = tasks.slice(startIdx, endIdx);

      tbody.innerHTML = '';

        // Check for authentication error
      if (window.optimisationModuleState.authError) {
        const errorMessage = window.optimisationModuleState.authError;
        tbody.innerHTML = `<tr><td colspan="13" style="padding: 2rem; text-align: center;">
          <div style="color: #ef4444; margin-bottom: 0.5rem; font-weight: 600;"> Authentication Error</div>
          <div style="color: #666; margin-bottom: 1rem;">${escapeHtml(errorMessage)}</div>
          <a href="#configuration" onclick="if(typeof setActivePanel === 'function') setActivePanel('configuration');" style="color: #2563eb; text-decoration: underline;">Go to Configuration to set your admin key</a>
        </td></tr>`;
        updateOptimisationPaginationControls(0, 1, 1, 0, 0);
        return;
      }

      if (tasks.length === 0) {
        tbody.innerHTML = '<tr><td colspan="13" class="ranking-table-empty">No tasks found</td></tr>';
        updateOptimisationPaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx);
        return;
      }

      paginatedTasks.forEach((task, index) => {
        const tr = document.createElement('tr');
        tr.onclick = () => openOptimisationTaskDrawer(task.id);

        const statusColors = {
          planned: { bg: 'rgba(245, 158, 11, 0.3)', color: '#fbbf24' }, // Brighter amber
          in_progress: { bg: 'rgba(16, 185, 129, 0.3)', color: '#34d399' }, // Brighter green
          monitoring: { bg: 'rgba(59, 130, 246, 0.3)', color: '#60a5fa' }, // Brighter blue
          done: { bg: 'rgba(156, 163, 175, 0.3)', color: '#d1d5db' }, // Brighter grey
          paused: { bg: 'rgba(245, 158, 11, 0.3)', color: '#fbbf24' }, // Brighter amber
          cancelled: { bg: 'rgba(239, 68, 68, 0.3)', color: '#f87171' } // Brighter red
        };

        const statusStyle = statusColors[task.status] || statusColors.planned;
        const lastActivity = task.last_activity_at 
          ? new Date(task.last_activity_at).toLocaleDateString('en-GB')
          : new Date(task.updated_at).toLocaleDateString('en-GB');

        // Format baseline and latest captured dates
        // Use captured_at from metrics (set by view from event.created_at) or fallback to created_at
        const baselineCaptured = (task.baseline_metrics?.captured_at || task.baseline_metrics?.created_at)
          ? new Date(task.baseline_metrics.captured_at || task.baseline_metrics.created_at).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' })
          : '';
        const latestCapturedDate = (task.latest_metrics?.captured_at || task.latest_metrics?.created_at)
          ? new Date(task.latest_metrics.captured_at || task.latest_metrics.created_at)
          : null;
        const latestCaptured = latestCapturedDate 
          ? latestCapturedDate.toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' })
          : null;
        
        // "Needs update" indicator: blank or older than 30 days
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const needsUpdate = !latestCapturedDate || latestCapturedDate < thirtyDaysAgo;
        const needsUpdateBadge = needsUpdate 
          ? '<span style="padding: 0.125rem 0.375rem; background: #fee2e2; color: #991b1b; border-radius: 4px; font-size: 0.7rem; font-weight: 600; margin-left: 0.25rem;">Needs update</span>'
          : '';
        
        // "No measurement yet" indicator
        const measurementIndicator = !latestCaptured 
          ? '<span style="padding: 0.25rem 0.5rem; background: #fef3c7; color: #92400e; border-radius: 4px; font-size: 0.75rem;">No measurement yet</span>'
          : '';

        // Extract path from URL for display
        let urlPath = '';
        let fullUrl = '';
        const urlText = task.target_url_clean || task.target_url || '';
        if (urlText) {
          try {
            // If URL contains domain, extract just the path
            if (urlText.includes('alanranger.com')) {
              const urlObj = new URL(urlText.startsWith('http') ? urlText : 'https://' + urlText);
              urlPath = urlObj.pathname || '/';
              fullUrl = urlObj.href;
            } else if (urlText.startsWith('/')) {
              // Already a path
              urlPath = urlText;
              fullUrl = 'https://www.alanranger.com' + urlText;
            } else {
              // Assume it's a path without leading slash
              urlPath = '/' + urlText;
              fullUrl = 'https://www.alanranger.com/' + urlText;
            }
          } catch (e) {
            // Fallback: treat as path
            urlPath = urlText.startsWith('/') ? urlText : '/' + urlText;
            fullUrl = 'https://www.alanranger.com' + urlPath;
          }
        }

        // Build goal status display (Phase 5: use objective_status from cycle)
        let goalHtml = '';
        const objectiveStatus = task.objective_status || task.goal_state || 'not_set';
        
        if (objectiveStatus && objectiveStatus !== 'not_set') {
          const goalConfig = {
            'on_track': { text: 'On track', bg: 'rgba(59, 130, 246, 0.3)', color: '#60a5fa' }, // Brighter blue
            'overdue': { text: 'Overdue', bg: 'rgba(239, 68, 68, 0.3)', color: '#f87171' }, // Brighter red
            'met': { text: 'Met', bg: 'rgba(16, 185, 129, 0.3)', color: '#34d399' }, // Brighter green
            'at_risk': { text: 'At risk', bg: 'rgba(245, 158, 11, 0.3)', color: '#fbbf24' } // Brighter amber
          };
          const config = goalConfig[objectiveStatus] || goalConfig['on_track'];
          let goalText = `<span style="padding: 0.25rem 0.5rem; border-radius: 4px; background: ${config.bg}; color: ${config.color}; font-size: 0.75rem; font-weight: 700; display: inline-block; margin-bottom: 0.25rem;">${config.text}</span>`;
          
          // Add progress info from objective_progress (Phase 8: use computeGoalProgress)
          if (task.objective_progress) {
            const progress = task.objective_progress;
            if (progress.baseline_value != null && progress.latest_value != null && progress.target != null) {
              const taskKpi = task.objective_kpi || task.primary_kpi || task.objective_metric || null;
              const targetType = (task.objective && task.objective.target_type) || 'delta';
              
              if (taskKpi) {
                // Use Phase 8 helper for proper formatting
                const goalProgress = computeGoalProgress({
                  kpiKey: taskKpi,
                  baseline: progress.baseline_value,
                  latest: progress.latest_value,
                  targetValue: progress.target,
                  targetType: targetType
                });
                
                const delta = progress.delta != null ? progress.delta : 0;
                let deltaColor = '#f59e0b'; // Amber for no change (default)
                if (delta > 0) deltaColor = '#10b981'; // Green for positive/improvement
                else if (delta < 0) deltaColor = '#ef4444'; // Red for negative/worsening
                goalText += `<div style="font-size: 0.7rem; color: ${deltaColor} !important; margin-top: 0.125rem; font-weight: 600;">${goalProgress.deltaLabel} vs target ${goalProgress.targetLabel}</div>`;
                if (goalProgress.remainingToTarget != null && goalProgress.remainingToTarget > 0) {
                  const displayMeta = KPI_DISPLAY_METADATA[taskKpi];
                  const remainingLabel = displayMeta ? displayMeta.formatDelta(goalProgress.remainingToTarget) : String(goalProgress.remainingToTarget);
                  goalText += `<div style="font-size: 0.65rem; color: #d1d5db; margin-top: 0.125rem; font-weight: 500;">Remaining: ${remainingLabel}</div>`;
                }
              }
            }
          } else if (task.objective && task.objective.kpi && task.objective.target != null) {
            // Use objective from cycle
            const kpiLabel = task.objective.kpi.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            const targetText = task.objective.target_type === 'delta' 
              ? `${kpiLabel} ${task.objective.target >= 0 ? '+' : ''}${task.objective.target}`
              : `${kpiLabel}  ${task.objective.target}`;
            let dueText = '';
            if (task.objective.due_at || task.objective_due_at) {
              const dueDate = new Date(task.objective.due_at || task.objective_due_at).toLocaleDateString('en-GB');
              dueText = ` by ${dueDate}`;
            }
            goalText += `<div style="font-size: 0.7rem; color: #d1d5db; margin-top: 0.25rem; font-weight: 500;">${targetText}${dueText}</div>`;
          } else if (task.objective_kpi && task.objective_target_delta != null) {
            // Legacy fallback
            const kpiLabel = task.objective_kpi.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            const direction = task.objective_direction === 'decrease' ? '-' : '+';
            const targetText = `${kpiLabel} ${direction}${Math.abs(task.objective_target_delta)}`;
            let dueText = '';
            if (task.objective_due_at) {
              const dueDate = new Date(task.objective_due_at).toLocaleDateString('en-GB');
              dueText = ` by ${dueDate}`;
            }
            goalText += `<div style="font-size: 0.7rem; color: #d1d5db; margin-top: 0.25rem; font-weight: 500;">${targetText}${dueText}</div>`;
          }
          
          // Add delta if available (from progress or legacy)
          if (task.objective_progress && task.objective_progress.delta != null) {
            const delta = task.objective_progress.delta;
            const deltaColor = delta >= 0 ? '#34d399' : '#f87171'; // Brighter colors
            const deltaSign = delta >= 0 ? '+' : '';
            goalText += `<div style="font-size: 0.7rem; color: ${deltaColor}; margin-top: 0.125rem; font-weight: 700;"> ${deltaSign}${delta}</div>`;
          } else if (task.objective_delta != null) {
            // Legacy fallback
            const deltaColor = task.objective_delta >= 0 ? '#34d399' : '#f87171'; // Brighter colors
            const deltaSign = task.objective_delta >= 0 ? '+' : '';
            goalText += `<div style="font-size: 0.7rem; color: ${deltaColor}; margin-top: 0.125rem; font-weight: 700;"> ${deltaSign}${task.objective_delta}</div>`;
          }
          
          goalHtml = goalText;
        }

        // Phase 9: Format new columns
        const objectiveKpiKey = task.objectiveKpiKey || task.objective?.kpi || null;
        let objectiveKpiLabel = '';
        let baselineLatestHtml = '';
        let deltaHtml = '';
        let sparklineHtml = '';
        
        if (objectiveKpiKey && KPI_DISPLAY_METADATA[objectiveKpiKey]) {
          const kpiMeta = KPI_DISPLAY_METADATA[objectiveKpiKey];
          objectiveKpiLabel = kpiMeta.label || objectiveKpiKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          
          // Baseline  Latest
          const baselineValue = task.baselineValue != null ? task.baselineValue : (task.baseline_metrics ? kpiMeta.get ? kpiMeta.get(task.baseline_metrics) : null : null);
          const latestValue = task.latestValue != null ? task.latestValue : (task.latest_metrics ? kpiMeta.get ? kpiMeta.get(task.latest_metrics) : null : null);
          
          if (baselineValue != null && latestValue != null) {
            const baselineFormatted = kpiMeta.formatValue ? kpiMeta.formatValue(baselineValue) : String(baselineValue);
            const latestFormatted = kpiMeta.formatValue ? kpiMeta.formatValue(latestValue) : String(latestValue);
            baselineLatestHtml = `${baselineFormatted}  ${latestFormatted}`;
          } else if (baselineValue != null) {
            baselineLatestHtml = `${kpiMeta.formatValue ? kpiMeta.formatValue(baselineValue) : String(baselineValue)}  `;
          } else if (latestValue != null) {
            baselineLatestHtml = `  ${kpiMeta.formatValue ? kpiMeta.formatValue(latestValue) : String(latestValue)}`;
          }
          
          //  vs Baseline
          const delta = task.delta != null ? task.delta : (baselineValue != null && latestValue != null ? (objectiveKpiKey === 'current_rank' ? baselineValue - latestValue : latestValue - baselineValue) : null);
          if (delta != null) {
            const deltaFormatted = kpiMeta.formatDelta ? kpiMeta.formatDelta(delta) : (delta >= 0 ? `+${delta}` : String(delta));
            const deltaColor = delta >= 0 ? '#10b981' : '#ef4444';
            deltaHtml = `<span style="color: ${deltaColor}; font-weight: 600;">${deltaFormatted}</span>`;
          }
          
          // Sparkline
          const sparklinePoints = task.sparklinePoints || [];
          if (sparklinePoints.length > 1) {
            sparklineHtml = renderSparkline(sparklinePoints, 80, 24);
          }
        }
        
        // Due In
        const dueIn = task.dueIn || (task.dueAt ? (() => {
          const dueDate = new Date(task.dueAt);
          const now = new Date();
          const daysUntilDue = Math.ceil((dueDate - now) / (1000 * 60 * 60 * 24));
          if (daysUntilDue < 0) {
            return `Overdue ${Math.abs(daysUntilDue)}d`;
          } else {
            return `${daysUntilDue}d`;
          }
        })() : null);
        const dueInHtml = dueIn ? (dueIn.startsWith('Overdue') ? `<span style="color: #dc2626; font-weight: 600;">${dueIn}</span>` : dueIn) : '';

        tr.innerHTML = `
          <td style="text-align: left;"><strong>${escapeHtml(task.keyword_text || '')}</strong></td>
          <td style="max-width: 150px; word-wrap: break-word; word-break: break-all;">
            ${urlPath ? `<a href="${fullUrl}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${escapeHtml(urlPath)}</a>` : ''}
          </td>
          <td><span style="padding: 0.25rem 0.5rem; background: #f0f0f0; border-radius: 4px;">${escapeHtml(task.task_type || 'on_page')}</span></td>
          <td><span style="padding: 0.25rem 0.5rem; border-radius: 4px; background: ${statusStyle.bg}; color: ${statusStyle.color}; font-weight: 600; font-size: 0.85rem;">${escapeHtml(task.status || 'planned')}</span></td>
          <td>Cycle ${task.cycle_no || task.cycle_active || 1}</td>
          <td>${baselineCaptured}</td>
          <td>${latestCaptured || measurementIndicator}${needsUpdateBadge}</td>
          <td>${escapeHtml(task.title || '')}</td>
          <td style="font-size: 0.85rem;">${objectiveKpiLabel}</td>
          <td style="font-size: 0.85rem;">${baselineLatestHtml}</td>
          <td style="font-size: 0.85rem;">${deltaHtml}</td>
          <td style="font-size: 0.85rem;">${dueInHtml}</td>
          <td style="font-size: 0.75rem; text-align: center;">${sparklineHtml}</td>
          <td style="font-size: 0.85rem;">${goalHtml}</td>
          <td style="display: flex; flex-direction: column; gap: 1rem; align-items: center; min-width: 60px;">
            <button class="btn btn-secondary" onclick="event.stopPropagation(); openOptimisationTaskDrawer('${task.id}');" style="padding: 0.04rem 0.1rem; font-size: 0.5rem; width: 100%; background: var(--dark-brand) !important; color: #000 !important; border: 1px solid var(--dark-brand) !important; font-weight: 600;">Open</button>
            <button class="btn btn-small" onclick="event.stopPropagation(); updateTaskLatest('${task.id}');" style="padding: 0.04rem 0.1rem; font-size: 0.5rem; width: 100%; background: rgba(59, 130, 246, 0.2) !important; color: #60a5fa !important; border: 1px solid #60a5fa !important; font-weight: 600;" title="Capture latest metrics for this task.">Update</button>
          </td>
        `;

        tbody.appendChild(tr);
      });
      
      // Update sort indicators
      document.querySelectorAll('#optimisation-tasks-table th.sortable').forEach(th => {
        th.classList.remove('sort-asc', 'sort-desc');
        if (th.dataset.sort === optimisationSortState.column) {
          th.classList.add(`sort-${optimisationSortState.direction}`);
        }
      });
      
      // Update pagination controls
      updateOptimisationPaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx);
      
      // Wire sorting handlers
      wireOptimisationSorting();
      
      // Wire pagination handlers
      wireOptimisationPagination();
      
      // Wire pagination on initial load if not already done
      setTimeout(() => {
        wireOptimisationPagination();
      }, 100);
    }
    
    // Update pagination controls
    function updateOptimisationPaginationControls(totalRows, currentPage, totalPages, startIdx, endIdx) {
      const paginationControls = document.getElementById('optimisation-pagination-controls');
      const paginationInfo = document.getElementById('optimisation-pagination-info');
      const pageInfo = document.getElementById('optimisation-pagination-page-info');
      const firstBtn = document.getElementById('optimisation-pagination-first');
      const prevBtn = document.getElementById('optimisation-pagination-prev');
      const nextBtn = document.getElementById('optimisation-pagination-next');
      const lastBtn = document.getElementById('optimisation-pagination-last');
      const rowsPerPageSelect = document.getElementById('optimisation-rows-per-page');
      
      if (!paginationControls) return;
      
      if (totalRows === 0) {
        paginationControls.style.display = 'none';
        return;
      }
      
      paginationControls.style.display = 'flex';
      
      if (paginationInfo) {
        paginationInfo.textContent = `Showing ${startIdx + 1}-${endIdx} of ${totalRows}`;
      }
      
      if (pageInfo) {
        pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
      }
      
      if (firstBtn) {
        firstBtn.disabled = currentPage === 1;
      }
      
      if (prevBtn) {
        prevBtn.disabled = currentPage === 1;
      }
      
      if (nextBtn) {
        nextBtn.disabled = currentPage === totalPages;
      }
      
      if (lastBtn) {
        lastBtn.disabled = currentPage === totalPages;
      }
      
      if (rowsPerPageSelect) {
        rowsPerPageSelect.value = optimisationPaginationState.rowsPerPage === 'all' ? 'all' : String(optimisationPaginationState.rowsPerPage);
      }
    }
    
    // Wire pagination handlers
    function wireOptimisationPagination() {
      const firstBtn = document.getElementById('optimisation-pagination-first');
      const prevBtn = document.getElementById('optimisation-pagination-prev');
      const nextBtn = document.getElementById('optimisation-pagination-next');
      const lastBtn = document.getElementById('optimisation-pagination-last');
      const rowsPerPageSelect = document.getElementById('optimisation-rows-per-page');
      
      if (firstBtn) {
        const newFirstBtn = firstBtn.cloneNode(true);
        firstBtn.parentNode.replaceChild(newFirstBtn, firstBtn);
        newFirstBtn.addEventListener('click', () => {
          optimisationPaginationState.currentPage = 1;
          renderOptimisationTasksTable();
        });
      }
      
      if (prevBtn) {
        const newPrevBtn = prevBtn.cloneNode(true);
        prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
        newPrevBtn.addEventListener('click', () => {
          if (optimisationPaginationState.currentPage > 1) {
            optimisationPaginationState.currentPage--;
            renderOptimisationTasksTable();
          }
        });
      }
      
      if (nextBtn) {
        const newNextBtn = nextBtn.cloneNode(true);
        nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
        newNextBtn.addEventListener('click', () => {
          const totalRows = window.optimisationModuleState.filteredTasks.length;
          const rowsPerPage = optimisationPaginationState.rowsPerPage === 'all' ? totalRows : optimisationPaginationState.rowsPerPage;
          const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
          if (optimisationPaginationState.currentPage < totalPages) {
            optimisationPaginationState.currentPage++;
            renderOptimisationTasksTable();
          }
        });
      }
      
      if (lastBtn) {
        const newLastBtn = lastBtn.cloneNode(true);
        lastBtn.parentNode.replaceChild(newLastBtn, lastBtn);
        newLastBtn.addEventListener('click', () => {
          const totalRows = window.optimisationModuleState.filteredTasks.length;
          const rowsPerPage = optimisationPaginationState.rowsPerPage === 'all' ? totalRows : optimisationPaginationState.rowsPerPage;
          const totalPages = rowsPerPage > 0 ? Math.ceil(totalRows / rowsPerPage) : 1;
          optimisationPaginationState.currentPage = totalPages;
          renderOptimisationTasksTable();
        });
      }
      
      if (rowsPerPageSelect) {
        const newSelect = rowsPerPageSelect.cloneNode(true);
        rowsPerPageSelect.parentNode.replaceChild(newSelect, rowsPerPageSelect);
        newSelect.addEventListener('change', () => {
          optimisationPaginationState.rowsPerPage = newSelect.value === 'all' ? 'all' : parseInt(newSelect.value, 10);
          optimisationPaginationState.currentPage = 1; // Reset to first page
          renderOptimisationTasksTable();
        });
      }
    }
    
    // Wire sorting handlers
    function wireOptimisationSorting() {
      const sortableHeaders = document.querySelectorAll('#optimisation-tasks-table th.sortable');
      sortableHeaders.forEach(th => {
        // Remove existing listeners by cloning
        const newTh = th.cloneNode(true);
        th.parentNode.replaceChild(newTh, th);
        
        newTh.addEventListener('click', function(e) {
          e.stopPropagation();
          const column = this.dataset.sort;
          if (!column) return;
          
          if (optimisationSortState.column === column) {
            optimisationSortState.direction = optimisationSortState.direction === 'asc' ? 'desc' : 'asc';
          } else {
            optimisationSortState.column = column;
            optimisationSortState.direction = 'asc';
          }
          
          renderOptimisationTasksTable();
        });
      });
    }

    // Helper to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Tab switching (B2)
    function switchOptimisationTab(tabName) {
      window.optimisationModuleState.activeTab = tabName;
      
      // Reset pagination when switching tabs
      optimisationPaginationState.currentPage = 1;
      
      // Update tab button states
      document.querySelectorAll('.optimisation-tab-btn').forEach(btn => {
        btn.classList.toggle('metric-pill--active', btn.dataset.tab === tabName);
      });

      renderOptimisationTasksTable();
    }

    // Dragging state
    let optimisationDrawerDragState = {
      isDragging: false,
      startX: 0,
      startY: 0,
      startLeft: 0,
      startTop: 0
    };
    
    let optimisationDrawerState = {
      isMinimized: false,
      isMaximized: false,
      originalWidth: '1200px',
      originalHeight: 'auto',
      originalTop: '50%',
      originalLeft: '50%'
    };

    // Helper to disable write buttons in share mode
    function disableWriteButtonsInShareMode() {
      if (!window.isShareMode) return;
      
      const writeButtonIds = [
        'optimisation-cancel-task-btn',
        'optimisation-delete-task-btn',
        'optimisation-edit-objective-btn',
        'optimisation-add-measurement-btn',
        'optimisation-start-cycle-btn',
        'optimisation-complete-cycle-btn',
        'optimisation-archive-cycle-btn',
        'optimisation-add-event-btn',
        'optimisation-save-status-btn',
        'optimisation-save-objective-btn',
        'optimisation-update-latest-btn'
      ];
      
      writeButtonIds.forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
          btn.disabled = true;
          btn.style.opacity = '0.5';
          btn.style.cursor = 'not-allowed';
          btn.title = (btn.title || '') + ' (Not available in share mode)';
        }
      });
      
      // Disable inputs
      const titleInput = document.getElementById('optimisation-drawer-title');
      if (titleInput) {
        titleInput.disabled = true;
        titleInput.style.opacity = '0.5';
      }
      
      const statusSelect = document.getElementById('optimisation-change-status');
      if (statusSelect) {
        statusSelect.disabled = true;
        statusSelect.style.opacity = '0.5';
      }
      
      // Hide edit objective form
      const editForm = document.getElementById('optimisation-edit-objective-form');
      if (editForm) editForm.style.display = 'none';
    }

    // Open task drawer (B3, B4)
    window.openOptimisationTaskDrawer = async function openOptimisationTaskDrawer(taskId) {
      // CRITICAL: Switch to Optimisation tab first, otherwise drawer will be hidden
      if (typeof setActivePanel === 'function') {
        setActivePanel('optimisation');
        ensurePanelRendered('optimisation');
        // Wait a moment for panel to become visible
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      const drawer = document.getElementById('optimisation-task-drawer');
      const backdrop = document.getElementById('optimisation-task-drawer-backdrop');
      
      if (!drawer) {
        console.error('[Optimisation Drawer] Drawer element not found');
        alert('Drawer element not found. Please refresh the page.');
        return;
      }
      
      if (!backdrop) {
        console.error('[Optimisation Drawer] Backdrop element not found');
        alert('Backdrop element not found. Please refresh the page.');
        return;
      }

      if (!window.optimisationModuleState) {
        window.optimisationModuleState = { allTasks: [], filteredTasks: [], activeTab: 'active', currentTaskId: null };
      }

      window.optimisationModuleState.currentTaskId = taskId;
      
      // Always reload tasks to ensure we have latest goal_state from the view
      // This ensures the badge uses the correct state even if migrations haven't been run
      if (typeof window.loadAllOptimisationTasks === 'function') {
        await window.loadAllOptimisationTasks();
      }
      
      // Find task (after reload to ensure fresh data)
      let task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      
      // If task still not found, error
      if (!task) {
        console.error('[Optimisation Drawer] Task not found after reload:', taskId);
        alert(`Task not found (ID: ${taskId}). Please try refreshing the page.`);
        return;
      }

      // Phase 6: Fetch full task details including cycles
      try {
        const headers = window.getOptimisationHeaders();
        const taskResponse = await fetch(apiUrl(`/api/optimisation/task/${taskId}`), {
          method: 'GET',
          headers: headers
        });
        if (taskResponse.ok) {
          const taskData = await taskResponse.json();
          console.log('[Optimisation Drawer] Task data from API:', taskData);
          // Merge cycles and other detailed fields into task
          task = {
            ...task,
            ...taskData.task,
            cycles: taskData.cycles || [],
            events: taskData.events || []
          };
          console.log('[Optimisation Drawer] Merged task with cycles:', task.cycles);
        }
      } catch (error) {
        console.error('[Optimisation Drawer] Error fetching task details:', error);
        // Continue with task from state if fetch fails
      }

      // Populate header
      document.getElementById('optimisation-drawer-keyword').textContent = task.keyword_text || '';
      const titleInput = document.getElementById('optimisation-drawer-title');
      if (titleInput) {
        titleInput.value = task.title || '';
      }
      
      // Make Target URL clickable
      const urlEl = document.getElementById('optimisation-drawer-url');
      const targetUrl = task.target_url_clean || task.target_url || '';
      let fullUrl = '';
      if (targetUrl) {
        try {
          if (targetUrl.includes('alanranger.com')) {
            fullUrl = targetUrl.startsWith('http') ? targetUrl : 'https://' + targetUrl;
          } else if (targetUrl.startsWith('/')) {
            fullUrl = 'https://www.alanranger.com' + targetUrl;
          } else {
            fullUrl = 'https://www.alanranger.com/' + targetUrl;
          }
        } catch (e) {
          fullUrl = 'https://www.alanranger.com/' + (targetUrl.startsWith('/') ? targetUrl : '/' + targetUrl);
        }
      }
      if (fullUrl) {
        urlEl.innerHTML = `<a href="${fullUrl}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${escapeHtml(targetUrl)}</a>`;
      } else {
        urlEl.textContent = targetUrl;
      }
      
      document.getElementById('optimisation-drawer-type').textContent = task.task_type || 'on_page';
      
      const statusColors = {
        planned: { bg: '#4b5563', color: '#ffffff' },
        in_progress: { bg: '#059669', color: '#ffffff' },
        monitoring: { bg: '#2563eb', color: '#ffffff' },
        done: { bg: '#6b7280', color: '#ffffff' },
        paused: { bg: '#d97706', color: '#ffffff' },
        cancelled: { bg: '#dc2626', color: '#ffffff' }
      };
      const statusStyle = statusColors[task.status] || statusColors.planned;
      const statusEl = document.getElementById('optimisation-drawer-status');
      statusEl.textContent = task.status || 'planned';
      statusEl.style.background = statusStyle.bg;
      statusEl.style.color = statusStyle.color;
      
      // Update cycle display with cycle info
      const cycleEl = document.getElementById('optimisation-drawer-cycle');
      const cycleSelector = document.getElementById('optimisation-drawer-cycle-selector');
      const cycleNo = task.cycle_no || task.cycle_active || 1;
      const cycleText = `Cycle ${cycleNo}`;
      if (task.cycle_start_date) {
        const startDate = new Date(task.cycle_start_date).toLocaleDateString('en-GB');
        cycleEl.textContent = `${cycleText} (Started: ${startDate})`;
      } else if (task.created_at) {
        const createdDate = new Date(task.created_at).toLocaleDateString('en-GB');
        cycleEl.textContent = `${cycleText} (Created: ${createdDate})`;
      } else {
        cycleEl.textContent = cycleText;
      }

      // Phase 6: Populate cycle selector dropdown
      // Debug: Log cycles data
      console.log('[Optimisation Drawer] Cycles data:', task.cycles, 'Length:', task.cycles?.length, 'Active cycle ID:', task.active_cycle_id);
      
      if (cycleSelector) {
        if (task.cycles && Array.isArray(task.cycles) && task.cycles.length > 0) {
          cycleSelector.innerHTML = '';
          // Sort cycles by cycle_no descending (newest first)
          const sortedCycles = [...task.cycles].sort((a, b) => (b.cycle_no || 0) - (a.cycle_no || 0));
          sortedCycles.forEach(c => {
            const option = document.createElement('option');
            option.value = c.id;
            option.textContent = `Cycle ${c.cycle_no}`;
            if (c.id === task.active_cycle_id) {
              option.selected = true;
            }
            cycleSelector.appendChild(option);
          });
          // Show selector if there are multiple cycles
          if (task.cycles.length > 1) {
            cycleSelector.style.display = 'inline-block';
            console.log('[Optimisation Drawer] Cycle selector shown with', task.cycles.length, 'cycles');
          } else {
            cycleSelector.style.display = 'none';
            console.log('[Optimisation Drawer] Cycle selector hidden (only 1 cycle)');
          }
          
          // Store cycles in state for later use
          if (!window.optimisationModuleState) {
            window.optimisationModuleState = {};
          }
          window.optimisationModuleState.taskCycles = task.cycles;
          window.optimisationModuleState.selectedCycleId = task.active_cycle_id;
          
          // Handle cycle selection change (remove old listener first to avoid duplicates)
          const oldHandler = cycleSelector.dataset.handler;
          if (oldHandler) {
            cycleSelector.removeEventListener('change', window[oldHandler]);
          }
          const handlerName = `cycleSelectorHandler_${taskId}`;
          const handler = async (e) => {
            const selectedCycleId = e.target.value;
            window.optimisationModuleState.selectedCycleId = selectedCycleId;
            const selectedCycle = task.cycles.find(c => c.id === selectedCycleId);
            const selectedCycleNo = selectedCycle?.cycle_no || 1;
            await loadCycleData(taskId, selectedCycleId, task.cycles, selectedCycle, selectedCycleNo, task);
          };
          window[handlerName] = handler;
          cycleSelector.dataset.handler = handlerName;
          cycleSelector.addEventListener('change', handler);
        } else {
          cycleSelector.style.display = 'none';
          console.log('[Optimisation Drawer] Cycle selector hidden (no cycles data)');
        }
      } else {
        console.error('[Optimisation Drawer] Cycle selector element not found!');
      }

      // Load progress data
      let progress = null;
      try {
        const headers = window.getOptimisationHeaders();
        const progressResponse = await fetch(apiUrl(`/api/optimisation/task/${taskId}/progress`), {
          method: 'GET',
          headers: headers
        });
        if (progressResponse.ok) {
          const progressData = await progressResponse.json();
          progress = progressData.progress || null;
        }
      } catch (error) {
        console.error('[Optimisation Drawer] Error loading progress:', error);
      }

      // Update objective display
      const objectiveCycleEl = document.getElementById('optimisation-drawer-objective-cycle');
      if (objectiveCycleEl) {
        objectiveCycleEl.textContent = `(Cycle ${cycleNo})`;
      }

      // Update progress badge - Use objective_status from cycle (Phase 5) or fallback to goal_state
      const objectiveBadgeEl = document.getElementById('optimisation-drawer-objective-badge');
      if (objectiveBadgeEl) {
        // Phase 5: Use objective_status from cycle (server-computed), fallback to goal_state
        let state = task.objective_status || task.goal_state;
        
        // Debug logging to understand what's happening
        if (typeof debugLog === 'function') {
          debugLog(`[Optimisation Badge] Task ${task.id}: goal_state="${task.goal_state}", objective_delta=${task.objective_delta}, target=${task.objective_target_delta || task.objective_target_value}, direction=${task.objective_direction}, progress.objective_state="${progress?.objective_state}"`, 'info');
        }
        
        // If goal_state is not available, determine from objective fields
        if (!state && (task.objective_metric || task.objective_kpi)) {
          // Check if baseline_metrics exists (from view) or if we have any measurement
          const hasBaseline = task.baseline_metrics || (progress && progress.baseline_value != null);
          state = hasBaseline ? 'on_track' : 'no_measurement';
          if (typeof debugLog === 'function') {
            debugLog(`[Optimisation Badge] goal_state was null, determined state="${state}" from objective fields`, 'warn');
          }
        } else if (!state) {
          state = 'not_set';
        }
        
        // NEVER use progress.objective_state - it's from a different (buggy) view
        // If we're seeing 'achieved' here, it means task.goal_state is wrong or missing
        if (typeof debugLog === 'function' && progress?.objective_state && progress.objective_state !== state) {
          debugLog(`[Optimisation Badge] WARNING: progress.objective_state="${progress.objective_state}" differs from goal_state="${state}". Using goal_state.`, 'warn');
        }
        
        // ALWAYS validate state using actual delta vs target - don't trust database views
        // This ensures badge matches reality regardless of which view is used
        const target = task.objective_target_delta != null ? task.objective_target_delta : 
          (task.objective_target_value != null ? task.objective_target_value : null);
        
        if (target != null && target > 0 && (task.objective_metric || task.objective_kpi)) {
          // Get delta from task (from goal status view) or calculate from progress
          let delta = task.objective_delta;
          if (delta === null || delta === undefined) {
            if (progress && progress.latest_value != null && progress.baseline_value != null) {
              delta = progress.latest_value - progress.baseline_value;
            }
          }
          
          // If we have delta, validate it against target
          if (delta !== null && delta !== undefined) {
            const direction = task.objective_direction || 'increase';
            const meetsTarget = direction === 'decrease' 
              ? delta <= (target * -1)
              : delta >= target;
            
            // Override state based on actual delta, not database view
            if (meetsTarget) {
              if (state !== 'met' && state !== 'achieved') {
                if (typeof debugLog === 'function') {
                  debugLog(`[Optimisation Badge] Overriding state "${state}" to 'met': delta=${delta} meets target=${target}`, 'info');
                }
                state = 'met';
              }
            } else {
              // Delta doesn't meet target - can't be 'met' or 'achieved'
              if (state === 'met' || state === 'achieved') {
                if (typeof debugLog === 'function') {
                  debugLog(`[Optimisation Badge] Overriding '${state}' to 'on_track': delta=${delta} does NOT meet target=${target} (direction=${direction})`, 'warn');
                }
                state = 'on_track';
              }
            }
          } else if (progress && progress.baseline_value != null && progress.latest_value != null) {
            // If baseline equals latest, delta is 0 - can't be met
            if (progress.baseline_value === progress.latest_value) {
              if (state === 'met' || state === 'achieved') {
                if (typeof debugLog === 'function') {
                  debugLog(`[Optimisation Badge] Overriding '${state}' to 'on_track': baseline equals latest (delta=0)`, 'warn');
                }
                state = 'on_track';
              }
            }
          }
        }
        
        const badgeConfig = {
          'achieved': { text: 'Achieved', bg: '#10b981', color: '#ffffff' },
          'met': { text: 'Met', bg: '#10b981', color: '#ffffff' },
          'on_track': { text: 'On track', bg: '#3b82f6', color: '#ffffff' },
          'at_risk': { text: 'At risk', bg: '#f59e0b', color: '#ffffff' },
          'overdue': { text: 'Overdue', bg: '#ef4444', color: '#ffffff' },
          'not_set': { text: 'Not set', bg: '#9ca3af', color: '#ffffff' },
          'no_measurement': { text: 'No measurement', bg: '#9ca3af', color: '#ffffff' }
        };
        const config = badgeConfig[state] || badgeConfig['not_set'];
        
        if (typeof debugLog === 'function') {
          debugLog(`[Optimisation Badge] Setting badge: state="${state}", text="${config.text}"`, 'info');
        }
        
        objectiveBadgeEl.textContent = config.text;
        objectiveBadgeEl.style.background = config.bg;
        objectiveBadgeEl.style.color = config.color;
        objectiveBadgeEl.style.display = 'inline-block';
      }

      const objectiveContentEl = document.getElementById('optimisation-drawer-objective-content');
      if (objectiveContentEl) {
        // Phase 5: Use objective from cycle (jsonb) or fallback to legacy task fields
        const objective = task.objective || task.cycle?.objective || null;
        const objectiveProgress = task.objective_progress || task.cycle?.objective_progress || null;
        const objectiveStatus = task.objective_status || task.cycle?.objective_status || task.goal_state || 'not_set';
        const objectiveDueAt = task.objective_due_at || task.cycle?.due_at || null;

        // Legacy fallback fields - read from cycle fields (via view) or task fields
        const objectiveTitle = objective?.title || task.objective_title || null;
        const objectiveKpi = objective?.kpi || task.primary_kpi || task.objective_kpi || task.objective_metric || null;
        const objectiveMetric = objective?.kpi || task.primary_kpi || task.objective_metric || task.objective_kpi || null;
        // target_direction comes from cycle, objective_direction is legacy task field
        const objectiveDirection = objective?.target_type === 'delta' ? 'increase' : (task.target_direction || task.objective_direction || null);
        const objectiveTargetValue = objective?.target != null ? objective.target : (task.target_value != null ? task.target_value : (task.objective_target_delta != null ? task.objective_target_delta : (task.objective_target_value != null ? task.objective_target_value : null)));
        const objectiveTimeframe = objective?.due_at ? null : (task.timeframe_days != null ? task.timeframe_days : (task.objective_timeframe_days != null ? task.objective_timeframe_days : null));
        const objectivePlan = objective?.plan || task.plan || task.objective_plan || null;
        const cycleStartedAt = task.cycle_started_at || task.cycle_start_date || null;

        if (objective || objectiveTitle || objectiveKpi || objectiveMetric || objectiveDirection) {
          // Use two-column layout for objective details
          let leftColumn = '';
          let rightColumn = '';
          
          if (objectiveTitle) {
            leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Title:</strong> ${escapeHtml(objectiveTitle)}</div>`;
          }
            if (objectiveKpi) {
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>KPI:</strong> ${escapeHtml(objectiveKpi)}</div>`;
            }
            // Show target if we have a target value (direction is optional)
            if (objectiveTargetValue != null) {
              const directionLabels = {
                'increase': 'Increase by',
                'decrease': 'Decrease by',
                'at_least': 'At least',
                'at_most': 'At most'
              };
              let targetText = '';
              if (objectiveDirection) {
                targetText = `${directionLabels[objectiveDirection] || objectiveDirection} ${objectiveTargetValue}`;
              } else {
                // If no direction specified, just show the target value
                targetText = `${objectiveTargetValue}`;
              }
              if (objectiveMetric === 'ctr_28d' || (objectiveKpi && objectiveKpi.includes('ctr'))) {
                targetText += '%';
              }
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Target:</strong> ${escapeHtml(targetText)}</div>`;
            } else if (objectiveDirection) {
              // Show direction even if no target value
              const directionLabels = {
                'increase': 'Increase',
                'decrease': 'Decrease',
                'at_least': 'At least',
                'at_most': 'At most'
              };
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Direction:</strong> ${escapeHtml(directionLabels[objectiveDirection] || objectiveDirection)}</div>`;
            }
          
          if (objectiveTimeframe || task.objective_due_at) {
            let timeframeText = '';
            const dueAt = task.objective_due_at || (progress && progress.due_at) || null;
            if (dueAt) {
              const dueDate = new Date(dueAt).toLocaleDateString('en-GB');
              timeframeText = `Due: ${dueDate}`;
              if (progress && progress.days_remaining != null) {
                const daysRemaining = Math.round(progress.days_remaining);
                timeframeText += ` (${daysRemaining} days remaining)`;
              }
            } else if (objectiveTimeframe) {
              timeframeText = `${objectiveTimeframe} days`;
              if (cycleStartedAt) {
                const startDate = new Date(cycleStartedAt);
                const dueDate = new Date(startDate.getTime() + objectiveTimeframe * 24 * 60 * 60 * 1000);
                timeframeText += ` (Due: ${dueDate.toLocaleDateString('en-GB')})`;
              }
            }
            if (timeframeText) {
              rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>Timeframe:</strong> ${timeframeText}</div>`;
            }
          }
          
          // Show progress: baseline  latest () vs target (using single source of truth helper)
          if (objectiveProgress && objectiveProgress.baseline_value != null && objectiveProgress.latest_value != null) {
            const baselineVal = objectiveProgress.baseline_value;
            const latestVal = objectiveProgress.latest_value;
            const target = objectiveProgress.target != null ? objectiveProgress.target : objectiveTargetValue;
            const targetType = objective?.target_type || 'delta';
            const kpiKey = objectiveKpi || objectiveMetric;
            
            if (kpiKey) {
              // Use single source of truth helper for correct delta math
              const progressLine = computeObjectiveProgressLine({
                kpiKey: kpiKey,
                baselineValue: baselineVal,
                latestValue: latestVal,
                targetValue: target,
                direction: targetType
              });
              
              rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>${progressLine.text}</strong></div>`;
              
              // Show remaining to target if applicable
              if (target != null && targetType === 'delta' && progressLine.delta != null) {
                const remaining = Math.max(0, target - progressLine.delta);
                if (remaining > 0) {
                  const displayMeta = KPI_DISPLAY_METADATA[kpiKey];
                  const remainingLabel = displayMeta ? displayMeta.formatDelta(remaining) : String(remaining);
                  rightColumn += `<div style="font-size: 0.85rem; color: #666; margin-top: 0.25rem;">Remaining: ${remainingLabel}</div>`;
                }
              }
            }
          } else if (progress && progress.baseline_value != null && progress.latest_value != null && objectiveMetric) {
            // Legacy fallback - use helper function for consistency
            const baselineVal = progress.baseline_value;
            const latestVal = progress.latest_value;
            const targetDelta = task.objective_target_delta != null ? task.objective_target_delta : (task.objective_target_value != null ? task.objective_target_value : null);
            const targetType = task.objective_target_type || 'delta';
            
            if (objectiveMetric) {
              const progressLine = computeObjectiveProgressLine({
                kpiKey: objectiveMetric,
                baselineValue: baselineVal,
                latestValue: latestVal,
                targetValue: targetDelta,
                direction: targetType
              });
              
              rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>${progressLine.text}</strong></div>`;
            }
          }
          
          // Build two-column layout
          let objectiveHtml = `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
            <div>${leftColumn || '<div style="color: #999; font-style: italic;"></div>'}</div>
            <div>${rightColumn || '<div style="color: #999; font-style: italic;"></div>'}</div>
          </div>`;
          
          if (objectivePlan) {
            objectiveHtml += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #e2e8f0;"><strong>Plan:</strong> ${escapeHtml(objectivePlan)}</div>`;
          }
          objectiveContentEl.innerHTML = objectiveHtml || '<div style="color: #666; font-style: italic;">No objective set</div>';
        } else {
          objectiveContentEl.innerHTML = '<div style="color: #666; font-style: italic;">No objective set</div>';
        }
      }
      
      document.getElementById('optimisation-change-status').value = task.status || '';

      // Phase 6: Load data for selected cycle (defaults to active cycle)
      const selectedCycleId = window.optimisationModuleState?.selectedCycleId || task.active_cycle_id;
      const selectedCycle = task.cycles?.find(c => c.id === selectedCycleId) || null;
      const selectedCycleNo = selectedCycle?.cycle_no || task.cycle_no || task.cycle_active || 1;
      
      await loadCycleData(taskId, selectedCycleId, task.cycles, selectedCycle, selectedCycleNo, task);

      // Reset timeline to collapsed state
      const timelineContainer = document.getElementById('optimisation-drawer-events-container');
      const timelineToggle = document.getElementById('optimisation-timeline-toggle');
      if (timelineContainer && timelineToggle) {
        timelineContainer.style.display = 'none';
        timelineToggle.textContent = '';
      }

      // Reset state
      optimisationDrawerState.isMinimized = false;
      optimisationDrawerState.isMaximized = false;
      
      // Show backdrop and drawer (centered)
      backdrop.style.display = 'block';
      drawer.style.display = 'flex';
      drawer.style.top = '50%';
      drawer.style.left = '50%';
      drawer.style.transform = 'translate(-50%, -50%)';
      drawer.style.width = optimisationDrawerState.originalWidth;
      drawer.style.height = optimisationDrawerState.originalHeight;
      
      // Disable write buttons in share mode
      disableWriteButtonsInShareMode();
      drawer.style.maxHeight = '90vh';
      
      // Ensure content is visible
      const content = document.getElementById('optimisation-drawer-content');
      if (content) {
        content.style.display = 'block';
      }
      
      // Update button states
      document.getElementById('optimisation-drawer-minimize').textContent = '';
      document.getElementById('optimisation-drawer-maximize').textContent = '';
      
      // Phase 7: Show/hide Complete/Archive buttons based on active cycle
      const completeCycleBtn = document.getElementById('optimisation-complete-cycle-btn');
      const archiveCycleBtn = document.getElementById('optimisation-archive-cycle-btn');
      const hasActiveCycle = task.active_cycle_id != null;
      
      if (completeCycleBtn) {
        completeCycleBtn.style.display = hasActiveCycle ? 'block' : 'none';
        completeCycleBtn.disabled = !hasActiveCycle || window.isShareMode;
      }
      if (archiveCycleBtn) {
        archiveCycleBtn.style.display = hasActiveCycle ? 'block' : 'none';
        archiveCycleBtn.disabled = !hasActiveCycle || window.isShareMode;
      }
    };

    // Close task drawer
    window.closeOptimisationTaskDrawer = function closeOptimisationTaskDrawer() {
      const drawer = document.getElementById('optimisation-task-drawer');
      const backdrop = document.getElementById('optimisation-task-drawer-backdrop');
      if (!drawer || !backdrop) return;
      
      backdrop.style.display = 'none';
      drawer.style.display = 'none';
      window.optimisationModuleState.currentTaskId = null;
      optimisationDrawerState.isMinimized = false;
      optimisationDrawerState.isMaximized = false;
    };
    
    // Minimize drawer
    function minimizeOptimisationDrawer() {
      const drawer = document.getElementById('optimisation-task-drawer');
      if (!drawer) return;
      
      if (optimisationDrawerState.isMinimized) {
        // Restore
        drawer.style.height = optimisationDrawerState.originalHeight;
        drawer.style.maxHeight = '90vh';
        document.getElementById('optimisation-drawer-content').style.display = 'block';
        optimisationDrawerState.isMinimized = false;
        document.getElementById('optimisation-drawer-minimize').textContent = '';
      } else {
        // Minimize
        optimisationDrawerState.originalHeight = drawer.style.height || 'auto';
        drawer.style.height = '60px';
        drawer.style.maxHeight = '60px';
        document.getElementById('optimisation-drawer-content').style.display = 'none';
        optimisationDrawerState.isMinimized = true;
        document.getElementById('optimisation-drawer-minimize').textContent = '+';
      }
    }
    
    // Maximize drawer
    function maximizeOptimisationDrawer() {
      const drawer = document.getElementById('optimisation-task-drawer');
      if (!drawer) return;
      
      if (optimisationDrawerState.isMaximized) {
        // Restore
        drawer.style.top = optimisationDrawerState.originalTop;
        drawer.style.left = optimisationDrawerState.originalLeft;
        drawer.style.transform = 'translate(-50%, -50%)';
        drawer.style.width = optimisationDrawerState.originalWidth;
        drawer.style.height = optimisationDrawerState.originalHeight;
        drawer.style.maxHeight = '90vh';
        optimisationDrawerState.isMaximized = false;
        document.getElementById('optimisation-drawer-maximize').textContent = '';
      } else {
        // Maximize
        optimisationDrawerState.originalTop = drawer.style.top;
        optimisationDrawerState.originalLeft = drawer.style.left;
        optimisationDrawerState.originalWidth = drawer.style.width;
        optimisationDrawerState.originalHeight = drawer.style.height || 'auto';
        
        drawer.style.top = '0';
        drawer.style.left = '0';
        drawer.style.transform = 'none';
        drawer.style.width = '100vw';
        drawer.style.height = '100vh';
        drawer.style.maxHeight = '100vh';
        optimisationDrawerState.isMaximized = true;
        document.getElementById('optimisation-drawer-maximize').textContent = '';
      }
    }
    
    // Make drawer draggable
    function initOptimisationDrawerDragging() {
      const drawer = document.getElementById('optimisation-task-drawer');
      const headerBar = document.getElementById('optimisation-drawer-header-bar');
      if (!drawer || !headerBar) return;
      
      headerBar.addEventListener('mousedown', (e) => {
        if (optimisationDrawerState.isMaximized) return; // Don't drag when maximized
        
        optimisationDrawerDragState.isDragging = true;
        const rect = drawer.getBoundingClientRect();
        optimisationDrawerDragState.startX = e.clientX;
        optimisationDrawerDragState.startY = e.clientY;
        optimisationDrawerDragState.startLeft = rect.left;
        optimisationDrawerDragState.startTop = rect.top;
        
        drawer.style.transition = 'none';
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!optimisationDrawerDragState.isDragging) return;
        
        const deltaX = e.clientX - optimisationDrawerDragState.startX;
        const deltaY = e.clientY - optimisationDrawerDragState.startY;
        
        drawer.style.left = (optimisationDrawerDragState.startLeft + deltaX) + 'px';
        drawer.style.top = (optimisationDrawerDragState.startTop + deltaY) + 'px';
        drawer.style.transform = 'none';
      });
      
      document.addEventListener('mouseup', () => {
        if (optimisationDrawerDragState.isDragging) {
          optimisationDrawerDragState.isDragging = false;
          drawer.style.transition = '';
        }
      });
    }

    // Phase 6: Load cycle-specific data (objective, measurements, events)
    async function loadCycleData(taskId, cycleId, allCycles, selectedCycle, cycleNo, task) {
      // Update objective display for selected cycle
      const objectiveCycleEl = document.getElementById('optimisation-drawer-objective-cycle');
      if (objectiveCycleEl) {
        objectiveCycleEl.textContent = `(Cycle ${cycleNo})`;
      }

      // Get cycle data (use selected cycle if provided, otherwise fetch from task)
      let cycleData = selectedCycle;
      if (!cycleData && cycleId && allCycles) {
        cycleData = allCycles.find(c => c.id === cycleId);
      }

      // Update objective display with selected cycle's objective
      if (cycleData) {
        // Merge cycle data into task for rendering
        const cycleTask = {
          ...task,
          objective: cycleData.objective || null,
          objective_status: cycleData.objective_status || 'not_set',
          objective_progress: cycleData.objective_progress || null,
          objective_due_at: cycleData.due_at || null,
          objective_title: cycleData.objective_title || null,
          primary_kpi: cycleData.primary_kpi || null,
          target_value: cycleData.target_value != null ? parseFloat(cycleData.target_value) : null,
          target_direction: cycleData.target_direction || null,
          timeframe_days: cycleData.timeframe_days != null ? parseInt(cycleData.timeframe_days) : null,
          plan: cycleData.plan || null,
          cycle_start_date: cycleData.start_date || null
        };
        
        // Re-render objective badge and content for selected cycle
        const objectiveBadgeEl = document.getElementById('optimisation-drawer-objective-badge');
        if (objectiveBadgeEl) {
          const status = cycleTask.objective_status || 'not_set';
          const badgeConfig = {
            'met': { text: 'Met', bg: '#10b981', color: '#ffffff' },
            'on_track': { text: 'On track', bg: '#3b82f6', color: '#ffffff' },
            'overdue': { text: 'Overdue', bg: '#ef4444', color: '#ffffff' },
            'not_set': { text: 'Not set', bg: '#9ca3af', color: '#ffffff' }
          };
          const config = badgeConfig[status] || badgeConfig['not_set'];
          objectiveBadgeEl.textContent = config.text;
          objectiveBadgeEl.style.background = config.bg;
          objectiveBadgeEl.style.color = config.color;
          objectiveBadgeEl.style.display = 'inline-block';
        }
        
        // Re-render objective content (reuse existing logic from earlier in the file)
        const objectiveContentEl = document.getElementById('optimisation-drawer-objective-content');
        if (objectiveContentEl) {
          const objective = cycleTask.objective || null;
          const objectiveProgress = cycleTask.objective_progress || null;
          const objectiveTitle = objective?.title || cycleTask.objective_title || null;
          const objectiveKpi = objective?.kpi || cycleTask.primary_kpi || null;
          const objectiveMetric = objective?.kpi || cycleTask.primary_kpi || null;
          // Handle target_type: 'delta' means increase/decrease, 'absolute' means at_least/at_most
          let objectiveDirection = null;
          if (objective?.target_type === 'delta') {
            // For delta, check if target is positive (increase) or negative (decrease)
            const targetVal = objective?.target != null ? objective.target : (cycleTask.target_value != null ? cycleTask.target_value : null);
            objectiveDirection = targetVal != null && targetVal >= 0 ? 'increase' : 'decrease';
          } else if (objective?.target_type === 'absolute') {
            // For absolute, we need to determine from KPI direction (higher_better vs lower_better)
            // For now, default to 'at_least' for most KPIs, 'at_most' for rank
            objectiveDirection = (objectiveKpi && objectiveKpi.includes('rank')) ? 'at_most' : 'at_least';
          } else {
            // Fallback to legacy target_direction
            objectiveDirection = cycleTask.target_direction || null;
          }
          const objectiveTargetValue = objective?.target != null ? objective.target : (cycleTask.target_value != null ? cycleTask.target_value : null);
          const objectiveTimeframe = objective?.due_at ? null : (cycleTask.timeframe_days != null ? cycleTask.timeframe_days : null);
          const objectivePlan = objective?.plan || cycleTask.plan || null;
          const cycleStartedAt = cycleTask.cycle_start_date || null;

          // Debug logging
          console.log('[loadCycleData] Cycle objective data:', {
            objective,
            objectiveTitle,
            objectiveKpi,
            objectiveMetric,
            objectiveDirection,
            objectiveTargetValue,
            cycleTask
          });

          if (objective || objectiveTitle || objectiveKpi || objectiveMetric || objectiveDirection || objectiveTargetValue != null) {
            let leftColumn = '';
            let rightColumn = '';
            
            if (objectiveTitle) {
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Title:</strong> ${escapeHtml(objectiveTitle)}</div>`;
            }
            if (objectiveKpi) {
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>KPI:</strong> ${escapeHtml(objectiveKpi)}</div>`;
            }
            // Show target if we have a target value (direction is optional)
            if (objectiveTargetValue != null) {
              const directionLabels = {
                'increase': 'Increase by',
                'decrease': 'Decrease by',
                'at_least': 'At least',
                'at_most': 'At most'
              };
              let targetText = '';
              if (objectiveDirection) {
                targetText = `${directionLabels[objectiveDirection] || objectiveDirection} ${objectiveTargetValue}`;
              } else {
                // If no direction specified, just show the target value
                targetText = `${objectiveTargetValue}`;
              }
              if (objectiveMetric === 'ctr_28d' || (objectiveKpi && objectiveKpi.includes('ctr'))) {
                targetText += '%';
              }
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Target:</strong> ${escapeHtml(targetText)}</div>`;
            } else if (objectiveDirection) {
              // Show direction even if no target value
              const directionLabels = {
                'increase': 'Increase',
                'decrease': 'Decrease',
                'at_least': 'At least',
                'at_most': 'At most'
              };
              leftColumn += `<div style="margin-bottom: 0.4rem;"><strong>Direction:</strong> ${escapeHtml(directionLabels[objectiveDirection] || objectiveDirection)}</div>`;
            }
            
            if (objectiveTimeframe || cycleTask.objective_due_at) {
              let timeframeText = '';
              const dueAt = cycleTask.objective_due_at || null;
              if (dueAt) {
                const dueDate = new Date(dueAt).toLocaleDateString('en-GB');
                timeframeText = `Due: ${dueDate}`;
              } else if (objectiveTimeframe && cycleStartedAt) {
                timeframeText = `${objectiveTimeframe} days`;
                const startDate = new Date(cycleStartedAt);
                const dueDate = new Date(startDate.getTime() + objectiveTimeframe * 24 * 60 * 60 * 1000);
                timeframeText += ` (Due: ${dueDate.toLocaleDateString('en-GB')})`;
              }
              if (timeframeText) {
                rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>Timeframe:</strong> ${timeframeText}</div>`;
              }
            }
            
            if (objectiveProgress && objectiveProgress.baseline_value != null && objectiveProgress.latest_value != null) {
              const baselineVal = objectiveProgress.baseline_value;
              const latestVal = objectiveProgress.latest_value;
              const target = objectiveProgress.target != null ? objectiveProgress.target : objectiveTargetValue;
              const targetType = objective?.target_type || 'delta';
              const kpiKey = objectiveKpi || objectiveMetric;
              
              if (kpiKey) {
                // Use single source of truth helper for correct delta math
                const progressLine = computeObjectiveProgressLine({
                  kpiKey: kpiKey,
                  baselineValue: baselineVal,
                  latestValue: latestVal,
                  targetValue: target,
                  direction: targetType
                });
                
                rightColumn += `<div style="margin-bottom: 0.4rem;"><strong>Progress:</strong> ${progressLine.baselineDisp}  ${progressLine.latestDisp} (<span style="color: ${progressLine.deltaColor} !important; font-weight: 600;">${progressLine.deltaDisp}</span>) vs target ${progressLine.targetDisp}</div>`;
              }
            }
            
            let objectiveHtml = `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
              <div>${leftColumn || '<div style="color: #999; font-style: italic;"></div>'}</div>
              <div>${rightColumn || '<div style="color: #999; font-style: italic;"></div>'}</div>
            </div>`;
            
            if (objectivePlan) {
              objectiveHtml += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #e2e8f0;"><strong>Plan:</strong> ${escapeHtml(objectivePlan)}</div>`;
            }
            objectiveContentEl.innerHTML = objectiveHtml || '<div style="color: #666; font-style: italic;">No objective set</div>';
          } else {
            objectiveContentEl.innerHTML = '<div style="color: #666; font-style: italic;">No objective set</div>';
          }
        }
      }

      // Fetch baseline and latest metrics for selected cycle
      await renderOptimisationMetricsSnapshotForCycle(taskId, cycleId, cycleNo);

      // Load measurement history (for selected cycle)
      await loadOptimisationMeasurementHistory(taskId, cycleId, cycleNo);

      // Load events (filtered to selected cycle)
      await loadOptimisationTaskEventsForCycle(taskId, cycleId, cycleNo);
    }

    // Phase 6: Render metrics snapshot for a specific cycle
    async function renderOptimisationMetricsSnapshotForCycle(taskId, cycleId, cycleNo) {
      // Fetch events for this cycle to get baseline and latest
      const headers = window.getOptimisationHeaders();
      const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/events?cycle_id=${cycleId || ''}&cycle_number=${cycleNo || ''}&event_type=measurement`), {
        headers: headers
      });

      let baselineMetrics = null;
      let latestMetrics = null;

      if (response.ok) {
        const data = await response.json();
        const measurements = data.events || [];
        
        if (measurements.length > 0) {
          // Sort by created_at ascending
          const sorted = [...measurements].sort((a, b) => {
            const dateA = new Date(a.created_at || a.event_at || 0);
            const dateB = new Date(b.created_at || b.event_at || 0);
            return dateA - dateB;
          });
          
          baselineMetrics = sorted[0]?.metrics || null;
          latestMetrics = sorted[sorted.length - 1]?.metrics || null;
          
          // Add captured_at to metrics
          if (baselineMetrics && sorted[0].created_at) {
            baselineMetrics.captured_at = sorted[0].created_at;
          }
          if (latestMetrics && sorted[sorted.length - 1].created_at) {
            latestMetrics.captured_at = sorted[sorted.length - 1].created_at;
          }
        }
      }

      // Render with cycle-specific metrics
      const cycleTask = {
        baseline_metrics: baselineMetrics,
        latest_metrics: latestMetrics
      };
      renderOptimisationMetricsSnapshot(cycleTask);
    }

    // Phase 6: Load events filtered to selected cycle
    async function loadOptimisationTaskEventsForCycle(taskId, cycleId, cycleNo) {
      const eventsContainer = document.getElementById('optimisation-drawer-events');
      if (!eventsContainer) return;

      try {
        const headers = window.getOptimisationHeaders();
        let url = apiUrl(`/api/optimisation/task/${taskId}/events`);
        if (cycleId) {
          url += `?cycle_id=${cycleId}`;
        } else if (cycleNo) {
          url += `?cycle_number=${cycleNo}`;
        }
        
        const response = await fetch(url, {
          method: 'GET',
          headers: headers
        });

        if (!response.ok) {
          throw new Error(`Failed to load events: ${response.status}`);
        }

        const data = await response.json();
        let events = data.events || [];

        // Filter to selected cycle if not already filtered by API
        if (cycleId || cycleNo) {
          events = events.filter(e => {
            if (cycleId) return e.cycle_id === cycleId;
            if (cycleNo) return e.cycle_number === cycleNo;
            return true;
          });
        }

        if (events.length === 0) {
          eventsContainer.innerHTML = `<div style="color: #666; font-style: italic;">No events for Cycle ${cycleNo || 'this cycle'}</div>`;
          return;
        }

        // Group events by cycle for display
        const eventsByCycle = {};
        events.forEach(event => {
          const cycleKey = event.cycle_number || 'unknown';
          if (!eventsByCycle[cycleKey]) {
            eventsByCycle[cycleKey] = [];
          }
          eventsByCycle[cycleKey].push(event);
        });

        eventsContainer.innerHTML = Object.keys(eventsByCycle).sort((a, b) => {
          if (a === 'unknown') return 1;
          if (b === 'unknown') return -1;
          return parseInt(b) - parseInt(a);
        }).map(cycleKey => {
          const cycleEvents = eventsByCycle[cycleKey];
          const cycleLabel = cycleKey === 'unknown' ? 'Other' : `Cycle ${cycleKey}`;
          return `
            <div style="margin-bottom: 1.5rem;">
              <div style="font-weight: 700; color: #1e293b; margin-bottom: 0.5rem; padding-bottom: 0.25rem; border-bottom: 2px solid #e2e8f0;">${cycleLabel}</div>
              ${cycleEvents.map(event => {
                const date = new Date(event.event_at || event.created_at).toLocaleString('en-GB', { timeZone: 'UTC' });
                return `
                  <div style="margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid #eee;">
                    <div style="font-weight: 600; color: #2563eb;">${escapeHtml(event.event_type || 'note')}</div>
                    <div style="color: #666; font-size: 0.875rem; margin-top: 0.25rem;">${date}</div>
                    ${event.note ? `<div style="margin-top: 0.5rem;">${escapeHtml(event.note)}</div>` : ''}
                  </div>
                `;
              }).join('')}
            </div>
          `;
        }).join('');
      } catch (error) {
        console.error('[Optimisation Module] Error loading events:', error);
        eventsContainer.innerHTML = '<div style="color: #ef4444;">Error loading events</div>';
      }
    }

    // Phase 8: KPI-specific formatting metadata (Phase 9: add get methods)
    const KPI_DISPLAY_METADATA = {
      clicks_28d: {
        label: 'Clicks (28d)',
        get: (m) => m?.clicks_28d ?? m?.gsc_clicks_28d ?? null,
        formatValue: (val) => val != null ? Math.round(val).toLocaleString('en-GB') : '',
        formatDelta: (delta) => {
          if (delta == null) return '';
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Math.round(delta).toLocaleString('en-GB')}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toLocaleString('en-GB');
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target).toLocaleString('en-GB')}`;
        }
      },
      impressions_28d: {
        label: 'Impressions (28d)',
        get: (m) => m?.impressions_28d ?? m?.gsc_impressions_28d ?? null,
        formatValue: (val) => {
          if (val == null) return '';
          if (val >= 1000) {
            return (val / 1000).toFixed(1) + 'k';
          }
          return Math.round(val).toLocaleString('en-GB');
        },
        formatDelta: (delta) => {
          if (delta == null) return '';
          const sign = delta >= 0 ? '+' : '';
          if (Math.abs(delta) >= 1000) {
            return `${sign}${(delta / 1000).toFixed(1)}k`;
          }
          return `${sign}${Math.round(delta).toLocaleString('en-GB')}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            if (target >= 1000) {
              return (target / 1000).toFixed(1) + 'k';
            }
            return Math.round(target).toLocaleString('en-GB');
          }
          const sign = target >= 0 ? '+' : '';
          if (Math.abs(target) >= 1000) {
            return `${sign}${(target / 1000).toFixed(1)}k`;
          }
          return `${sign}${Math.round(target).toLocaleString('en-GB')}`;
        }
      },
      ctr_28d: {
        formatValue: (val) => {
          if (val == null) return '';
          return (val * 100).toFixed(2) + '%';
        },
        formatDelta: (delta) => {
          if (delta == null) return '';
          // Delta is in decimal (0-1), convert to percentage points (pp)
          const deltaPp = delta * 100;
          const sign = deltaPp >= 0 ? '+' : '';
          return `${sign}${deltaPp.toFixed(2)}pp`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            // Absolute target is stored as decimal (0-1), display as %
            return (target * 100).toFixed(2) + '%';
          }
          // Delta target: for CTR, show as percentage points
          // The target is the absolute delta in decimal units
          const targetPp = target * 100;
          const sign = target >= 0 ? '+' : '';
          return `${sign}${targetPp.toFixed(2)}pp`;
        }
      },
      current_rank: {
        label: 'Current Rank',
        get: (m) => m?.current_rank ?? m?.rank ?? null,
        formatValue: (val) => val != null ? Math.round(val).toString() : '',
        formatDelta: (delta) => {
          if (delta == null) return '';
          // For rank, positive delta means improvement (rank went down)
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Math.round(delta)}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toString();
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target)}`;
        }
      },
      opportunity_score: {
        label: 'Opportunity Score',
        get: (m) => m?.opportunity_score ?? null,
        formatValue: (val) => val != null ? Math.round(val).toString() : '',
        formatDelta: (delta) => {
          if (delta == null) return '';
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Math.round(delta)}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toString();
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target)}`;
        }
      },
      ai_overview: {
        label: 'AI Overview',
        get: (m) => m?.ai_overview ?? false,
        formatValue: (val) => val === true ? 'On' : (val === false ? 'Off' : ''),
        formatDelta: (delta) => {
          if (delta == null) return '';
          if (delta > 0) return '+1';
          if (delta < 0) return '-1';
          return '0';
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          return target === true ? 'On' : 'Off';
        }
      },
      ai_citations: {
        label: 'AI Citations',
        get: (m) => m?.ai_citations ?? null,
        formatValue: (val) => val != null ? Math.round(val).toString() : '',
        formatDelta: (delta) => {
          if (delta == null) return '';
          const sign = delta >= 0 ? '+' : '';
          return `${sign}${Math.round(delta)}`;
        },
        formatTarget: (target, targetType, baseline) => {
          if (target == null) return '';
          if (targetType === 'absolute') {
            return Math.round(target).toString();
          }
          const sign = target >= 0 ? '+' : '';
          return `${sign}${Math.round(target)}`;
        }
      }
    };

    // Helper: Compute objective progress line with correct delta math (single source of truth)
    // Always calculates delta as latest - baseline (or baseline - latest for rank)
    function computeObjectiveProgressLine({ kpiKey, baselineValue, latestValue, targetValue, direction }) {
      // If baseline/latest missing, return placeholder
      if (baselineValue == null || latestValue == null) {
        return { text: 'Progress: ', delta: null, deltaColor: '#666' };
      }
      
      // Calculate raw delta (always from baseline to latest)
      let deltaRaw = latestValue - baselineValue;
      
      // For rank, lower is better, so invert: improvement = baseline - latest (positive when rank decreases)
      if (kpiKey === 'current_rank') {
        deltaRaw = baselineValue - latestValue;
      }
      
      // Format values based on KPI type
      let baselineDisp, latestDisp, deltaDisp;
      
      if (kpiKey === 'ctr_28d') {
        baselineDisp = (baselineValue * 100).toFixed(2) + '%';
        latestDisp = (latestValue * 100).toFixed(2) + '%';
        const deltaPp = (latestValue - baselineValue) * 100;
        deltaDisp = (deltaPp >= 0 ? '+' : '') + deltaPp.toFixed(2) + 'pp';
      } else if (kpiKey === 'current_rank') {
        baselineDisp = baselineValue.toFixed(1);
        latestDisp = latestValue.toFixed(1);
        // For rank, deltaRaw is already inverted (baseline - latest), so positive = improvement
        deltaDisp = (deltaRaw >= 0 ? '+' : '') + deltaRaw.toFixed(1);
      } else {
        // For other metrics, use number formatting
        const displayMeta = KPI_DISPLAY_METADATA[kpiKey];
        if (displayMeta) {
          baselineDisp = displayMeta.formatValue(baselineValue);
          latestDisp = displayMeta.formatValue(latestValue);
          deltaDisp = displayMeta.formatDelta(deltaRaw);
        } else {
          baselineDisp = baselineValue.toLocaleString('en-GB');
          latestDisp = latestValue.toLocaleString('en-GB');
          deltaDisp = (deltaRaw >= 0 ? '+' : '') + deltaRaw.toLocaleString('en-GB');
        }
      }
      
      // Determine color: green for positive, red for negative, amber for zero
      let deltaColor = '#f59e0b'; // Amber for no change
      if (deltaRaw > 0) deltaColor = '#10b981'; // Green for positive/improvement
      else if (deltaRaw < 0) deltaColor = '#ef4444'; // Red for negative/worsening
      
      // Format target display
      let targetDisp = '';
      if (targetValue != null) {
        const displayMeta = KPI_DISPLAY_METADATA[kpiKey];
        if (displayMeta && displayMeta.formatTarget) {
          targetDisp = displayMeta.formatTarget(targetValue, direction || 'delta', baselineValue);
        } else {
          // Fallback formatting
          if (direction === 'delta') {
            targetDisp = (targetValue >= 0 ? '+' : '') + targetValue.toLocaleString('en-GB');
          } else {
            targetDisp = targetValue.toLocaleString('en-GB');
          }
        }
      }
      
      // Build progress line text with colored delta
      const text = `Progress: ${baselineDisp}  ${latestDisp} (<span style="color: ${deltaColor} !important; font-weight: 600;">${deltaDisp}</span>) vs target ${targetDisp}`;
      
      return {
        text,
        delta: deltaRaw,
        deltaColor,
        baselineDisp,
        latestDisp,
        deltaDisp,
        targetDisp
      };
    }
    
    // Legacy formatProgressValue function (kept for backward compatibility)
    function formatProgressValue(value, kpi) {
      if (value == null || value === undefined) return '';
      
      const displayMeta = kpi ? KPI_DISPLAY_METADATA[kpi] : null;
      if (displayMeta) {
        return displayMeta.formatValue(value);
      }
      
      // Fallback for unknown KPIs
      if (typeof value === 'number') {
        if (Math.abs(value) < 1 && value !== 0) {
          return value.toFixed(2);
        }
        if (Number.isInteger(value) || Math.abs(value) >= 1) {
          return value.toLocaleString('en-GB', { maximumFractionDigits: 2 });
        }
        return value.toFixed(2);
      }
      
      return String(value);
    }
    
    // Phase 8: Compute goal progress with proper formatting
    function computeGoalProgress({ kpiKey, baseline, latest, targetValue, targetType }) {
      const displayMeta = KPI_DISPLAY_METADATA[kpiKey];
      if (!displayMeta) {
        return {
          baselineLabel: baseline != null ? String(baseline) : '',
          latestLabel: latest != null ? String(latest) : '',
          deltaLabel: '',
          targetLabel: targetValue != null ? String(targetValue) : '',
          progressLabel: ''
        };
      }

      // Calculate delta
      let delta = null;
      if (baseline != null && latest != null) {
        // For rank, improvement is positive when rank decreases
        if (kpiKey === 'current_rank') {
          delta = baseline - latest;
        } else {
          delta = latest - baseline;
        }
      }

      // Format labels
      const baselineLabel = displayMeta.formatValue(baseline);
      const latestLabel = displayMeta.formatValue(latest);
      const deltaLabel = displayMeta.formatDelta(delta);
      const targetLabel = displayMeta.formatTarget(targetValue, targetType, baseline);
      
      // Calculate remaining to target
      let remainingToTarget = null;
      if (targetType === 'delta' && delta != null && targetValue != null) {
        remainingToTarget = Math.max(0, targetValue - delta);
      } else if (targetType === 'absolute' && latest != null && targetValue != null) {
        if (kpiKey === 'current_rank') {
          remainingToTarget = Math.max(0, latest - targetValue);
        } else {
          remainingToTarget = Math.max(0, targetValue - latest);
        }
      }

      // Build progress label
      let progressLabel = '';
      if (baseline != null && latest != null && targetValue != null) {
        if (targetType === 'delta') {
          if (remainingToTarget != null && remainingToTarget > 0) {
            progressLabel = `${deltaLabel}/${targetLabel} (${displayMeta.formatDelta(remainingToTarget)} remaining)`;
          } else if (delta != null && delta >= targetValue) {
            progressLabel = `${deltaLabel}/${targetLabel} (Met)`;
          } else {
            progressLabel = `${deltaLabel}/${targetLabel}`;
          }
        } else {
          if (remainingToTarget != null && remainingToTarget > 0) {
            progressLabel = `${latestLabel}/${targetLabel} (${displayMeta.formatValue(remainingToTarget)} remaining)`;
          } else if (latest != null && ((kpiKey === 'current_rank' && latest <= targetValue) || (kpiKey !== 'current_rank' && latest >= targetValue))) {
            progressLabel = `${latestLabel}/${targetLabel} (Met)`;
          } else {
            progressLabel = `${latestLabel}/${targetLabel}`;
          }
        }
      }

      return {
        baselineLabel,
        latestLabel,
        deltaLabel,
        targetLabel,
        progressLabel,
        remainingToTarget
      };
    }

    // Phase 9: Helper functions for dashboard features
    
    // Render sparkline SVG
    function renderSparkline(points, width = 80, height = 24) {
      if (!points || points.length < 2) return '';
      
      const filtered = points.filter(p => p != null);
      if (filtered.length < 2) return '';
      
      const min = Math.min(...filtered);
      const max = Math.max(...filtered);
      const range = max - min || 1; // Avoid division by zero
      
      const padding = 2;
      const plotWidth = width - padding * 2;
      const plotHeight = height - padding * 2;
      
      const path = filtered.map((val, idx) => {
        const x = padding + (idx / (filtered.length - 1)) * plotWidth;
        const y = padding + plotHeight - ((val - min) / range) * plotHeight;
        return `${x},${y}`;
      }).join(' ');
      
      const color = filtered[filtered.length - 1] >= filtered[0] ? '#10b981' : '#ef4444';
      
      return `<svg width="${width}" height="${height}" style="display: block;">
        <polyline points="${path}" fill="none" stroke="${color}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>`;
    }
    
    // Update KPI tiles
    function updateKPITiles() {
      let tasks = window.optimisationModuleState.allTasks || [];
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      // Recalculate tiles from filtered tasks
      const tiles = {
        ctr: { on_track: 0, at_risk: 0, overdue: 0 },
        rank: { improved: 0, worse: 0, flat: 0 },
        ai_gap: 0,
        needs_measurement: 0,
        overdue_cycles: 0,
      };
      
      for (const task of tasks) {
        const objectiveRag = task.objectiveRag || task.objective_status || 'no_data';
        const objectiveKpiKey = task.objectiveKpiKey || task.objective?.kpi;
        const delta = task.delta != null ? task.delta : 0;
        
        // CTR tiles
        if (objectiveKpiKey === 'ctr_28d' && objectiveRag !== 'no_data') {
          if (objectiveRag === 'on_track') tiles.ctr.on_track++;
          else if (objectiveRag === 'at_risk') tiles.ctr.at_risk++;
          else if (objectiveRag === 'overdue') tiles.ctr.overdue++;
        }
        
        // Rank tiles
        if (objectiveKpiKey === 'current_rank' && delta != null) {
          if (delta > 0) tiles.rank.improved++;
          else if (delta < 0) tiles.rank.worse++;
          else tiles.rank.flat++;
        }
        
        // AI Gap
        if (task.latestValue != null && objectiveKpiKey === 'ai_citations') {
          // Check if AI overview is on but citations = 0
          const latestMetrics = task.latest_metrics || {};
          if (latestMetrics.ai_overview === true && (latestMetrics.ai_citations === 0 || latestMetrics.ai_citations == null)) {
            tiles.ai_gap++;
          }
        }
        
        // Needs Measurement
        if (task.needsMeasurement) {
          tiles.needs_measurement++;
        }
        
        // Overdue Cycles
        if (objectiveRag === 'overdue') {
          tiles.overdue_cycles++;
        }
      }
      
      if (tiles.ctr) {
        const onTrackEl = document.getElementById('kpi-ctr-on-track');
        const atRiskEl = document.getElementById('kpi-ctr-at-risk');
        const overdueEl = document.getElementById('kpi-ctr-overdue');
        if (onTrackEl) onTrackEl.textContent = tiles.ctr.on_track || 0;
        if (atRiskEl) atRiskEl.textContent = tiles.ctr.at_risk || 0;
        if (overdueEl) overdueEl.textContent = tiles.ctr.overdue || 0;
      }
      
      if (tiles.rank) {
        const improvedEl = document.getElementById('kpi-rank-improved');
        const worseEl = document.getElementById('kpi-rank-worse');
        const flatEl = document.getElementById('kpi-rank-flat');
        if (improvedEl) improvedEl.textContent = tiles.rank.improved || 0;
        if (worseEl) worseEl.textContent = tiles.rank.worse || 0;
        if (flatEl) flatEl.textContent = tiles.rank.flat || 0;
      }
      
      const aiGapEl = document.getElementById('kpi-ai-gap');
      const needsMeasEl = document.getElementById('kpi-needs-measurement');
      const overdueCyclesEl = document.getElementById('kpi-overdue-cycles');
      if (aiGapEl) aiGapEl.textContent = tiles.ai_gap || 0;
      if (needsMeasEl) needsMeasEl.textContent = tiles.needs_measurement || 0;
      if (overdueCyclesEl) overdueCyclesEl.textContent = tiles.overdue_cycles || 0;
    }
    
    // Update impact tiles
    function updateImpactTiles() {
      let tasks = window.optimisationModuleState.allTasks || [];
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      // Recalculate impact from filtered tasks
      let estimatedExtraClicks = 0;
      let aiCitationGapCount = 0;
      
      for (const task of tasks) {
        const objectiveKpiKey = task.objectiveKpiKey || task.objective?.kpi;
        const baselineValue = task.baselineValue;
        const latestValue = task.latestValue;
        const latestMetrics = task.latest_metrics || {};
        
        // Estimated extra clicks for CTR tasks
        if (objectiveKpiKey === 'ctr_28d' && baselineValue != null && latestValue != null) {
          const impressions = latestMetrics.impressions_28d || 0;
          if (impressions > 0 && task.objective) {
            let goalCtr = null;
            if (task.objective.target_type === 'delta') {
              goalCtr = baselineValue + task.objective.target;
            } else {
              goalCtr = task.objective.target;
            }
            if (goalCtr != null && goalCtr > latestValue) {
              const extraClicks = impressions * (goalCtr - latestValue);
              estimatedExtraClicks += extraClicks;
            }
          }
        }
        
        // AI Citation Gap
        if (latestMetrics.ai_overview === true && (latestMetrics.ai_citations === 0 || latestMetrics.ai_citations == null)) {
          aiCitationGapCount++;
        }
      }
      
      const extraClicksEl = document.getElementById('impact-extra-clicks');
      const extraClicksCard = document.getElementById('impact-extra-clicks-card');
      if (extraClicksEl) {
        extraClicksEl.textContent = estimatedExtraClicks >= 1000 
          ? (estimatedExtraClicks / 1000).toFixed(1) + 'k' 
          : Math.round(estimatedExtraClicks).toLocaleString('en-GB');
      }
      
      // Set bronze/silver/gold background based on impact
      if (extraClicksCard) {
        // Remove existing medal classes
        extraClicksCard.classList.remove('impact-bronze', 'impact-silver', 'impact-gold');
        
        // Bronze: < 50 clicks (low impact)
        // Silver: 50-200 clicks (medium impact)
        // Gold: > 200 clicks (high impact)
        if (estimatedExtraClicks < 50) {
          extraClicksCard.classList.add('impact-bronze');
        } else if (estimatedExtraClicks >= 50 && estimatedExtraClicks < 200) {
          extraClicksCard.classList.add('impact-silver');
        } else {
          extraClicksCard.classList.add('impact-gold');
        }
      }
      
      const aiGapEl = document.getElementById('impact-ai-gap');
      if (aiGapEl) aiGapEl.textContent = aiCitationGapCount || 0;
    }
    
    // Handle traffic light pill click
    window.handleTrafficLightClick = function(metricKey, bucket) {
      const currentFilter = window.optimisationModuleState.metricTrafficFilter;
      
      // Toggle: if clicking the same pill, clear filter
      if (currentFilter && currentFilter.metricKey === metricKey && currentFilter.bucket === bucket) {
        window.optimisationModuleState.metricTrafficFilter = null;
      } else {
        window.optimisationModuleState.metricTrafficFilter = { metricKey, bucket };
      }
      
      // Update visual state (highlighting)
      updateTrafficLightVisuals();
      
      // Apply filters (this will update filteredTasks)
      applyOptimisationFilters();
      
      // Update charts with new filtered data
      updateTimeseriesCharts();
      
      // Only sort if there's an active filter
      if (window.optimisationModuleState.metricTrafficFilter) {
        const filter = window.optimisationModuleState.metricTrafficFilter;
        let tasks = [...window.optimisationModuleState.filteredTasks];
        const scope = window.optimisationModuleState.scope || 'active_cycle';
        const metricKeys = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
        
        // Sort tasks by their classification for this metric
        tasks.sort((a, b) => {
          // Get classifications for both tasks
          const aActiveCycle = scope === 'active_cycle' 
            ? (a.cycles?.find(c => c.is_active || c.id === a.active_cycle_id) || null)
            : null;
          const bActiveCycle = scope === 'active_cycle' 
            ? (b.cycles?.find(c => c.is_active || c.id === b.active_cycle_id) || null)
            : null;
          
          const aMeasurements = a.measurements || [];
          const bMeasurements = b.measurements || [];
          
          const aBaselineLatest = getBaselineLatest(aMeasurements, scope, aActiveCycle);
          const bBaselineLatest = getBaselineLatest(bMeasurements, scope, bActiveCycle);
          
          let aClass, bClass;
          
          if (filter.metricKey === 'all_metrics') {
            // For all_metrics, find majority classification (at least 3 out of 6)
            const aClasses = [];
            const bClasses = [];
            
            if (aBaselineLatest) {
              for (const mk of metricKeys) {
                const cls = classifyMetric(mk, aBaselineLatest.baseline, aBaselineLatest.latest);
                if (cls) aClasses.push(cls);
              }
            }
            
            if (bBaselineLatest) {
              for (const mk of metricKeys) {
                const cls = classifyMetric(mk, bBaselineLatest.baseline, bBaselineLatest.latest);
                if (cls) bClasses.push(cls);
              }
            }
            
            // Find majority classification for task A
            if (aClasses.length >= 4) {
              const aCounts = { worse: 0, same: 0, better: 0 };
              aClasses.forEach(c => aCounts[c]++);
              const aMajority = Math.max(aCounts.worse, aCounts.same, aCounts.better);
              aClass = aCounts.worse === aMajority ? 'worse' :
                       aCounts.same === aMajority ? 'same' :
                       aCounts.better === aMajority ? 'better' : null;
              // Only use if majority is at least 4
              if (aMajority < 4) aClass = null;
            } else {
              aClass = null;
            }
            
            // Find majority classification for task B
            if (bClasses.length >= 4) {
              const bCounts = { worse: 0, same: 0, better: 0 };
              bClasses.forEach(c => bCounts[c]++);
              const bMajority = Math.max(bCounts.worse, bCounts.same, bCounts.better);
              bClass = bCounts.worse === bMajority ? 'worse' :
                       bCounts.same === bMajority ? 'same' :
                       bCounts.better === bMajority ? 'better' : null;
              // Only use if majority is at least 4
              if (bMajority < 4) bClass = null;
            } else {
              bClass = null;
            }
          } else {
            // Single metric
            aClass = aBaselineLatest ? classifyMetric(filter.metricKey, aBaselineLatest.baseline, aBaselineLatest.latest) : null;
            bClass = bBaselineLatest ? classifyMetric(filter.metricKey, bBaselineLatest.baseline, bBaselineLatest.latest) : null;
          }
          
          // Priority: better (2) > same (1) > worse (0) > null (-1)
          const getPriority = (cls) => {
            if (cls === 'better') return 2;
            if (cls === 'same') return 1;
            if (cls === 'worse') return 0;
            return -1;
          };
          
          const aPriority = getPriority(aClass);
          const bPriority = getPriority(bClass);
          
          // Sort descending (better first)
          return bPriority - aPriority;
        });
        
        window.optimisationModuleState.filteredTasks = tasks;
      }
      
      // Re-render table with new filter and sort
      renderOptimisationTasksTable();
    };
    
    // Update visual state of traffic light pills (selected/not selected)
    function updateTrafficLightVisuals() {
      const filter = window.optimisationModuleState.metricTrafficFilter;
      const pills = document.querySelectorAll('.traffic-light-pill');
      
      pills.forEach(pill => {
        const metricKey = pill.dataset.metric;
        const bucket = pill.dataset.bucket;
        const isSelected = filter && filter.metricKey === metricKey && filter.bucket === bucket;
        
        if (isSelected) {
          // Active state: bright orange border, strong glow, and brighter background
          pill.style.border = '3px solid var(--dark-brand)';
          pill.style.boxShadow = '0 0 16px rgba(245, 158, 11, 0.8), 0 0 8px rgba(245, 158, 11, 0.6)';
          pill.style.transform = 'scale(1.05)';
          pill.style.zIndex = '10';
          // Make background brighter when selected
          if (bucket === 'worse') {
            pill.style.background = 'rgba(239, 68, 68, 0.4) !important';
          } else if (bucket === 'same') {
            pill.style.background = 'rgba(245, 158, 11, 0.4) !important';
          } else {
            pill.style.background = 'rgba(16, 185, 129, 0.4) !important';
          }
        } else {
          // Inactive state: normal border, no glow, normal size
          pill.style.border = '2px solid var(--dark-border)';
          pill.style.boxShadow = 'none';
          pill.style.transform = 'scale(1)';
          pill.style.zIndex = '1';
          // Restore default background
          if (bucket === 'worse') {
            pill.style.background = 'rgba(239, 68, 68, 0.2)';
          } else if (bucket === 'same') {
            pill.style.background = 'rgba(245, 158, 11, 0.2)';
          } else {
            pill.style.background = 'rgba(16, 185, 129, 0.2)';
          }
        }
      });
    }
    
    // Helper to restore hover state (considering selection) - no longer needed with CSS hover
    window.updateTrafficLightHover = function(element) {
      // CSS handles hover now, but keep for compatibility
    };
    
    // Update traffic light counts and display
    function updateTrafficLights() {
      let tasks = window.optimisationModuleState.allTasks || [];
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      // Apply other existing filters (keyword, url, type, status) - same as table uses
      // Get filter values
      const keywordFilter = document.getElementById('optimisation-filter-keyword')?.value?.toLowerCase().trim() || '';
      const urlFilter = document.getElementById('optimisation-filter-url')?.value?.toLowerCase().trim() || '';
      const typeFilter = document.getElementById('optimisation-filter-type')?.value || '';
      const statusFilter = document.getElementById('optimisation-filter-status')?.value || '';
      
      // Apply filters
      if (keywordFilter) {
        tasks = tasks.filter(t => (t.keyword || '').toLowerCase().includes(keywordFilter));
      }
      if (urlFilter) {
        tasks = tasks.filter(t => (t.target_url || '').toLowerCase().includes(urlFilter));
      }
      if (typeFilter) {
        tasks = tasks.filter(t => t.task_type === typeFilter);
      }
      if (statusFilter) {
        tasks = tasks.filter(t => t.status === statusFilter);
      }
      
      // Get scope
      const scope = window.optimisationModuleState.scope || 'active_cycle';
      
      // Compute traffic light counts
      const counts = computeTrafficLightCounts(tasks, scope);
      
      // Update display
      const metricMap = {
        all_metrics: 'all-metrics',
        ctr_28d: 'ctr',
        impressions_28d: 'impressions',
        clicks_28d: 'clicks',
        current_rank: 'rank',
        ai_citations: 'ai-citations',
        ai_overview: 'ai-overview',
        opportunity_score: 'opportunity-score'
      };
      
      for (const [metricKey, displayKey] of Object.entries(metricMap)) {
        const worseEl = document.getElementById(`objective-${displayKey}-red`);
        const sameEl = document.getElementById(`objective-${displayKey}-amber`);
        const betterEl = document.getElementById(`objective-${displayKey}-green`);
        
        if (worseEl) worseEl.textContent = counts[metricKey].worse || 0;
        if (sameEl) sameEl.textContent = counts[metricKey].same || 0;
        if (betterEl) betterEl.textContent = counts[metricKey].better || 0;
      }
    }
    
    // Apply all filters to filteredTasks (including metric traffic filter)
    function applyOptimisationFilters() {
      let tasks = [...window.optimisationModuleState.allTasks];
      
      // Filter out test tasks if checkbox is unchecked
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (!includeTestCheckbox || !includeTestCheckbox.checked) {
        tasks = tasks.filter(t => !t.is_test_task);
      }
      
      // Apply keyword filter
      const keywordFilter = document.getElementById('optimisation-filter-keyword')?.value?.toLowerCase().trim() || '';
      if (keywordFilter) {
        tasks = tasks.filter(t => (t.keyword || '').toLowerCase().includes(keywordFilter));
      }
      
      // Apply URL filter
      const urlFilter = document.getElementById('optimisation-filter-url')?.value?.toLowerCase().trim() || '';
      if (urlFilter) {
        tasks = tasks.filter(t => (t.target_url || '').toLowerCase().includes(urlFilter));
      }
      
      // Apply type filter
      const typeFilter = document.getElementById('optimisation-filter-type')?.value || '';
      if (typeFilter) {
        tasks = tasks.filter(t => t.task_type === typeFilter);
      }
      
      // Apply status filter
      const statusFilter = document.getElementById('optimisation-filter-status')?.value || '';
      if (statusFilter) {
        tasks = tasks.filter(t => t.status === statusFilter);
      }
      
      // Apply metric traffic filter
      const metricTrafficFilter = window.optimisationModuleState.metricTrafficFilter;
      if (metricTrafficFilter) {
        const scope = window.optimisationModuleState.scope || 'active_cycle';
        const metricKeys = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
        
        tasks = tasks.filter(task => {
          // Only active tasks can match
          if (!isActiveStatus(task.status)) {
            return false;
          }
          
          // Get active cycle if scope is 'active_cycle'
          const activeCycle = scope === 'active_cycle' 
            ? (task.cycles?.find(c => c.is_active || c.id === task.active_cycle_id) || null)
            : null;
          
          // Get measurements
          const measurements = task.measurements || [];
          const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);
          
          if (!baselineLatest) {
            // Task doesn't have enough measurements, exclude
            return false;
          }
          
          // Handle "all_metrics" filter: check that majority of metrics (at least 3 out of 6) match the bucket
          if (metricTrafficFilter.metricKey === 'all_metrics') {
            const classifications = [];
            for (const metricKey of metricKeys) {
              const classification = classifyMetric(
                metricKey,
                baselineLatest.baseline,
                baselineLatest.latest
              );
              if (classification) {
                classifications.push(classification);
              }
            }
            
            // Count occurrences of the filter bucket
            const bucketCount = classifications.filter(cls => cls === metricTrafficFilter.bucket).length;
            
            // At least 4 metrics must match the bucket (majority)
            return bucketCount >= 4;
          } else {
            // Single metric filter
            const classification = classifyMetric(
              metricTrafficFilter.metricKey,
              baselineLatest.baseline,
              baselineLatest.latest
            );
            
            // Include only if classification matches the filter bucket
            return classification === metricTrafficFilter.bucket;
          }
        });
      }
      
      window.optimisationModuleState.filteredTasks = tasks;
    }
    
    // Helper: Compute estimated extra clicks (28d) for a single task
    function computeEstimatedExtraClicks28d(task) {
      const objectiveKpiKey = task.objectiveKpiKey || task.objective?.kpi;
      const baselineValue = task.baselineValue;
      const latestValue = task.latestValue;
      const latestMetrics = task.latest_metrics || {};
      
      // Only compute for CTR tasks with objectives
      if (objectiveKpiKey === 'ctr_28d' && baselineValue != null && latestValue != null) {
        const impressions = latestMetrics.impressions_28d || 0;
        if (impressions > 0 && task.objective) {
          let goalCtr = null;
          if (task.objective.target_type === 'delta') {
            goalCtr = baselineValue + task.objective.target;
          } else {
            goalCtr = task.objective.target;
          }
          if (goalCtr != null && goalCtr > latestValue) {
            return impressions * (goalCtr - latestValue);
          }
        }
      }
      return 0;
    }

    // Build Chart 1: Estimated Extra Clicks (28d) by KPI
    function buildEstimatedClicksByKpi(filteredTasks) {
      const kpiBuckets = {
        'ctr_28d': { label: 'CTR (28d)', sum: 0, count: 0 },
        'impressions_28d': { label: 'Impressions (28d)', sum: 0, count: 0 },
        'clicks_28d': { label: 'Clicks (28d)', sum: 0, count: 0 },
        'current_rank': { label: 'Rank', sum: 0, count: 0 },
        'ai_citations': { label: 'AI Citations', sum: 0, count: 0 },
        'ai_overview': { label: 'AI Overview', sum: 0, count: 0 },
        'opportunity_score': { label: 'Opportunity Score', sum: 0, count: 0 },
        'no_objective': { label: 'No objective KPI', sum: 0, count: 0 }
      };
      
      for (const task of filteredTasks) {
        const extraClicks = computeEstimatedExtraClicks28d(task);
        const objectiveKpiKey = task.objectiveKpiKey || task.objective?.kpi;
        
        if (objectiveKpiKey && kpiBuckets[objectiveKpiKey]) {
          kpiBuckets[objectiveKpiKey].sum += extraClicks;
          kpiBuckets[objectiveKpiKey].count += 1;
        } else {
          kpiBuckets['no_objective'].sum += extraClicks;
          kpiBuckets['no_objective'].count += 1;
        }
      }
      
      // Filter out buckets with zero sum and zero count, but keep "no_objective" if it has tasks
      const result = [];
      for (const [kpi, data] of Object.entries(kpiBuckets)) {
        if (data.sum > 0 || data.count > 0) {
          result.push({ kpi, label: data.label, sum: data.sum, count: data.count });
        }
      }
      
      return result;
    }

    // Build Chart 2: Median Delta Over Time for Selected KPI
    function buildMedianDeltaTrend(filteredTasks, selectedKpi, scope, weeks = 12) {
      if (!selectedKpi) return { weeks: [], medians: [], sampleSizes: [] };
      
      // Get measurements for all tasks in scope
      const weekDeltas = new Map(); // weekKey -> [deltas from all tasks]
      
      for (const task of filteredTasks) {
        const activeCycle = scope === 'active_cycle' 
          ? (task.cycles?.find(c => c.is_active || c.id === task.active_cycle_id) || null)
          : null;
        const measurements = task.measurements || [];
        
        // Filter measurements by scope
        let eligibleMeasurements = [...measurements];
        if (scope === 'active_cycle' && activeCycle) {
          const cycleStartDate = activeCycle.start_date ? new Date(activeCycle.start_date) : 
                                (activeCycle.started_at ? new Date(activeCycle.started_at) : null);
          if (cycleStartDate) {
            eligibleMeasurements = eligibleMeasurements.filter(m => {
              const mDate = m.captured_at ? new Date(m.captured_at) : null;
              return mDate && mDate >= cycleStartDate;
            });
          }
        }
        
        if (eligibleMeasurements.length < 2) continue;
        
        // Sort by date
        eligibleMeasurements.sort((a, b) => {
          const dateA = a.captured_at ? new Date(a.captured_at) : new Date(0);
          const dateB = b.captured_at ? new Date(b.captured_at) : new Date(0);
          return dateA - dateB;
        });
        
        // Group measurements by week
        const measurementsByWeek = new Map();
        for (const m of eligibleMeasurements) {
          if (!m.captured_at) continue;
          const weekKey = weekStartISO(m.captured_at);
          if (!measurementsByWeek.has(weekKey)) {
            measurementsByWeek.set(weekKey, []);
          }
          measurementsByWeek.get(weekKey).push(m);
        }
        
        // For each week, compute delta if we have at least 2 measurements
        for (const [weekKey, weekMeasurements] of measurementsByWeek.entries()) {
          if (weekMeasurements.length < 2) continue;
          
          // Sort by date within week
          weekMeasurements.sort((a, b) => {
            const dateA = a.captured_at ? new Date(a.captured_at) : new Date(0);
            const dateB = b.captured_at ? new Date(b.captured_at) : new Date(0);
            return dateA - dateB;
          });
          
          const startValue = getMetricValue(weekMeasurements[0], selectedKpi);
          const endValue = getMetricValue(weekMeasurements[weekMeasurements.length - 1], selectedKpi);
          
          if (startValue == null || endValue == null) continue;
          
          // Compute delta with correct units
          let delta;
          if (selectedKpi === 'ctr_28d') {
            delta = (endValue - startValue) * 100; // percentage points
          } else if (selectedKpi === 'current_rank') {
            delta = startValue - endValue; // lower is better, so invert
          } else {
            delta = endValue - startValue;
          }
          
          if (!weekDeltas.has(weekKey)) {
            weekDeltas.set(weekKey, []);
          }
          weekDeltas.get(weekKey).push(delta);
        }
      }
      
      // Get last N weeks
      const now = new Date();
      const weekKeys = [];
      for (let i = weeks - 1; i >= 0; i--) {
        const weekDate = new Date(now);
        weekDate.setDate(weekDate.getDate() - (i * 7));
        weekKeys.push(weekStartISO(weekDate));
      }
      
      // Compute medians for each week
      const result = {
        weeks: [],
        medians: [],
        sampleSizes: []
      };
      
      for (const weekKey of weekKeys) {
        const deltas = weekDeltas.get(weekKey) || [];
        result.weeks.push(weekKey);
        if (deltas.length > 0) {
          result.medians.push(median(deltas));
          result.sampleSizes.push(deltas.length);
        } else {
          result.medians.push(null);
          result.sampleSizes.push(0);
        }
      }
      
      return result;
    }

    // Update timeseries charts
    function updateTimeseriesCharts() {
      // Use the SAME filteredTasks as the table (includes all filters + scope + traffic-pill filter)
      let filteredTasks = window.optimisationModuleState.filteredTasks || [];
      const scope = window.optimisationModuleState.scope || 'active_cycle';
      
      // PART 1: Estimated Extra Clicks (28d) by KPI
      const estimatedClicksByKpi = buildEstimatedClicksByKpi(filteredTasks);
      
      // PART 1B: Median Delta Over Time for Selected KPI
      const selectedKpiForTrend = window.optimisationModuleState?.selectedKpiForTrend || 'ctr_28d';
      const medianDeltaTrend = buildMedianDeltaTrend(filteredTasks, selectedKpiForTrend, scope, 12);
      
      // PART 2: Median Delta by KPI (Last 30d) - only tasks with latest measurement in last 30 days
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      
      const eligibleTasks = filteredTasks.filter(task => {
        const latestMeasurement = getLatestMeasurementInScope(task, scope);
        if (!latestMeasurement || !latestMeasurement.captured_at) {
          return false;
        }
        const latestDate = new Date(latestMeasurement.captured_at);
        return latestDate >= thirtyDaysAgo;
      });
      
      // Compute deltas for each KPI
      const deltasByKpi = {};
      const kpiList = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
      
      for (const task of eligibleTasks) {
        const activeCycle = scope === 'active_cycle' 
          ? (task.cycles?.find(c => c.is_active || c.id === task.active_cycle_id) || null)
          : null;
        const measurements = task.measurements || [];
        const baselineLatest = getBaselineLatest(measurements, scope, activeCycle);
        
        if (!baselineLatest) {
          continue;
        }
        
        // Compute delta for each KPI
        for (const kpi of kpiList) {
          const delta = computeDeltaForKPI(kpi, baselineLatest.baseline, baselineLatest.latest);
          if (delta != null) {
            if (!deltasByKpi[kpi]) {
              deltasByKpi[kpi] = [];
            }
            deltasByKpi[kpi].push(delta);
          }
        }
      }
      
      // Compute medians
      const medianDeltaByKpi = [];
      for (const [kpi, deltas] of Object.entries(deltasByKpi)) {
        if (deltas.length > 0) {
          const med = median(deltas);
          if (med != null) {
            medianDeltaByKpi.push({ kpi, value: med });
          }
        }
      }
      
      // Sort to match traffic light order: CTR, Impressions, Clicks, Rank, AI Citations, AI Overview
      const kpiOrder = ['ctr_28d', 'impressions_28d', 'clicks_28d', 'current_rank', 'ai_citations', 'ai_overview'];
      medianDeltaByKpi.sort((a, b) => {
        const indexA = kpiOrder.indexOf(a.kpi);
        const indexB = kpiOrder.indexOf(b.kpi);
        // If KPI not in order list, put it at the end
        if (indexA === -1 && indexB === -1) return a.kpi.localeCompare(b.kpi);
        if (indexA === -1) return 1;
        if (indexB === -1) return -1;
        return indexA - indexB;
      });
      
      const timeseries = {
        estimatedClicksByKpi,
        medianDeltaTrend,
        selectedKpiForTrend,
        medianDeltaByKpi
      };
      
      // Render Chart 1: Estimated Extra Clicks (28d) by KPI
      const clicksCanvas = document.getElementById('chart-estimated-clicks-by-kpi');
      if (clicksCanvas && timeseries.estimatedClicksByKpi) {
        const ctx = clicksCanvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const displayWidth = clicksCanvas.offsetWidth || 400;
        const displayHeight = 280;
        
        clicksCanvas.width = displayWidth * dpr;
        clicksCanvas.height = displayHeight * dpr;
        clicksCanvas.style.width = displayWidth + 'px';
        clicksCanvas.style.height = displayHeight + 'px';
        ctx.scale(dpr, dpr);
        
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        
        const data = timeseries.estimatedClicksByKpi;
        if (!data || data.length === 0) {
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No data', displayWidth / 2, displayHeight / 2);
        } else {
          const maxSum = Math.max(...data.map(d => d.sum), 1);
          const padding = { top: 20, right: 20, bottom: 70, left: 60 };
          const chartWidth = displayWidth - padding.left - padding.right;
          const chartHeight = displayHeight - padding.top - padding.bottom;
          const barWidth = chartWidth / data.length * 0.7;
          const barSpacing = chartWidth / data.length * 0.3;
          
          // Draw axes
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(padding.left, padding.top);
          ctx.lineTo(padding.left, displayHeight - padding.bottom);
          ctx.lineTo(displayWidth - padding.right, displayHeight - padding.bottom);
          ctx.stroke();
          
          // Draw y-axis label
          ctx.save();
          ctx.translate(15, displayHeight / 2);
          ctx.rotate(-Math.PI / 2);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 18px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Estimated Extra Clicks (28d)', 0, 0);
          ctx.restore();
          
          // Draw y-axis ticks and labels
          const yTicks = 5;
          for (let i = 0; i <= yTicks; i++) {
            const value = (maxSum / yTicks) * i;
            const y = displayHeight - padding.bottom - (i / yTicks) * chartHeight;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(padding.left, y);
            ctx.lineTo(displayWidth - padding.right, y);
            ctx.stroke();
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'right';
            const labelText = value >= 1000 ? (value / 1000).toFixed(1) + 'k' : Math.round(value).toString();
            ctx.fillText(labelText, padding.left - 10, y + 4);
          }
          
          // Draw bars
          data.forEach((d, i) => {
            const x = padding.left + i * (barWidth + barSpacing) + barSpacing / 2;
            const barHeight = (d.sum / maxSum) * chartHeight;
            const y = displayHeight - padding.bottom - barHeight;
            
            // Green bars
            ctx.fillStyle = '#10b981';
            ctx.fillRect(x, y, barWidth, barHeight);
            
            // Label below bar
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            const labelLines = d.label.split(' ');
            labelLines.forEach((line, lineIdx) => {
              ctx.fillText(line, x + barWidth / 2, displayHeight - padding.bottom + 12 + (lineIdx * 12));
            });
          });
        }
      }
      
      // Render Chart 2: Median Delta Over Time for Selected KPI
      const trendCanvas = document.getElementById('chart-median-delta-trend');
      if (trendCanvas && timeseries.medianDeltaTrend) {
        const ctx = trendCanvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const displayWidth = trendCanvas.offsetWidth || 400;
        const displayHeight = 280;
        
        trendCanvas.width = displayWidth * dpr;
        trendCanvas.height = displayHeight * dpr;
        trendCanvas.style.width = displayWidth + 'px';
        trendCanvas.style.height = displayHeight + 'px';
        ctx.scale(dpr, dpr);
        
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        
        const trend = timeseries.medianDeltaTrend;
        const kpiLabels = {
          'ctr_28d': 'CTR (pp)',
          'impressions_28d': 'Impressions',
          'clicks_28d': 'Clicks',
          'current_rank': 'Rank  (lower better)',
          'ai_citations': 'AI Citations',
          'opportunity_score': 'Opportunity Score'
        };
        
        if (!trend.weeks || trend.weeks.length === 0 || trend.medians.every(m => m == null)) {
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Not enough history', displayWidth / 2, displayHeight / 2);
        } else {
          const validMedians = trend.medians.filter(m => m != null);
          if (validMedians.length === 0) {
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Not enough history', displayWidth / 2, displayHeight / 2);
          } else {
            const maxAbs = Math.max(...validMedians.map(m => Math.abs(m)), 1);
            const padding = { top: 20, right: 20, bottom: 70, left: 60 };
            const chartWidth = displayWidth - padding.left - padding.right;
            const chartHeight = displayHeight - padding.top - padding.bottom;
            const zeroY = displayHeight - padding.bottom - (maxAbs / (maxAbs * 2)) * chartHeight;
            
            // Draw axes
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, displayHeight - padding.bottom);
            ctx.lineTo(displayWidth - padding.right, displayHeight - padding.bottom);
            ctx.stroke();
            
            // Draw zero line
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, zeroY);
            ctx.lineTo(displayWidth - padding.right, zeroY);
            ctx.stroke();
            
            // Draw y-axis label
            ctx.save();
            ctx.translate(15, displayHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'center';
            const yLabel = kpiLabels[timeseries.selectedKpiForTrend] || 'Median Delta';
            ctx.fillText(`Median Delta (${yLabel})`, 0, 0);
            ctx.restore();
            
            // Draw y-axis ticks and labels
            const yTicks = 5;
            for (let i = 0; i <= yTicks; i++) {
              const value = (maxAbs * 2 / yTicks) * i - maxAbs;
              const y = displayHeight - padding.bottom - (i / yTicks) * chartHeight;
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
              ctx.lineWidth = 0.5;
              ctx.beginPath();
              ctx.moveTo(padding.left, y);
              ctx.lineTo(displayWidth - padding.right, y);
              ctx.stroke();
              
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 14px sans-serif';
              ctx.textAlign = 'right';
              ctx.fillText(value.toFixed(1), padding.left - 10, y + 4);
            }
            
            // Draw x-axis week labels
            trend.weeks.forEach((weekKey, i) => {
              const x = padding.left + (i / (trend.weeks.length - 1 || 1)) * chartWidth;
              const weekDate = new Date(weekKey);
              const day = weekDate.getDate();
              const month = weekDate.getMonth() + 1;
              const weekLabel = `${day}/${month}`;
              
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 11px sans-serif';
              ctx.textAlign = 'center';
              ctx.fillText(weekLabel, x, displayHeight - padding.bottom + 18);
            });
            
            // Draw line
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            let hasMoved = false;
            trend.medians.forEach((med, i) => {
              if (med != null) {
                const x = padding.left + (i / (trend.weeks.length - 1 || 1)) * chartWidth;
                const y = displayHeight - padding.bottom - ((med + maxAbs) / (maxAbs * 2)) * chartHeight;
                if (!hasMoved) {
                  ctx.moveTo(x, y);
                  hasMoved = true;
                } else {
                  ctx.lineTo(x, y);
                }
              }
            });
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = '#3b82f6';
            trend.medians.forEach((med, i) => {
              if (med != null) {
                const x = padding.left + (i / (trend.weeks.length - 1 || 1)) * chartWidth;
                const y = displayHeight - padding.bottom - ((med + maxAbs) / (maxAbs * 2)) * chartHeight;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
              }
            });
          }
        }
      }

      // Render Median Delta by KPI chart (with device pixel ratio for crisp rendering)
      const deltaCanvas = document.getElementById('chart-median-delta');
      if (deltaCanvas && timeseries.medianDeltaByKpi) {
        const ctx = deltaCanvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const displayWidth = deltaCanvas.offsetWidth || 400;
        const displayHeight = 280;
        
        // Set canvas internal size accounting for device pixel ratio for crisp rendering
        deltaCanvas.width = displayWidth * dpr;
        deltaCanvas.height = displayHeight * dpr;
        
        // Scale canvas CSS size to display size
        deltaCanvas.style.width = displayWidth + 'px';
        deltaCanvas.style.height = displayHeight + 'px';
        
        // Scale context to match device pixel ratio
        ctx.scale(dpr, dpr);
        
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        
        const data = timeseries.medianDeltaByKpi;
        if (data.length === 0) {
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No data', displayWidth / 2, displayHeight / 2);
        } else {
          const maxAbs = Math.max(...data.map(d => Math.abs(d.value)), 1);
          const padding = { top: 20, right: 20, bottom: 70, left: 60 };
          const chartWidth = displayWidth - padding.left - padding.right;
          const chartHeight = displayHeight - padding.top - padding.bottom;
          const barWidth = chartWidth / data.length * 0.7;
          const barSpacing = chartWidth / data.length * 0.3;
          const zeroY = displayHeight - padding.bottom - (maxAbs / (maxAbs * 2)) * chartHeight;
          
          // KPI label mapping
          const kpiLabels = {
            'ctr_28d': 'CTR (pp)',
            'impressions_28d': 'Impressions',
            'clicks_28d': 'Clicks',
            'current_rank': 'Rank (, lower better)',
            'ai_citations': 'AI Citations',
            'ai_overview': 'AI Overview'
          };
          
          // Draw y-axis label - bright white and much larger
          ctx.save();
          ctx.translate(15, displayHeight / 2);
          ctx.rotate(-Math.PI / 2);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 18px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Median Delta', 0, 0);
          ctx.restore();
          
          // Draw zero line - white
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(padding.left, zeroY);
          ctx.lineTo(displayWidth - padding.right, zeroY);
          ctx.stroke();
          
          // Draw y-axis ticks and labels - white and larger
          const yTicks = 5;
          for (let i = 0; i <= yTicks; i++) {
            const value = (maxAbs * 2 / yTicks) * i - maxAbs;
            const y = displayHeight - padding.bottom - (i / yTicks) * chartHeight;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(padding.left, y);
            ctx.lineTo(displayWidth - padding.right, y);
            ctx.stroke();
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'right';
            const label = value >= 0 ? `+${value.toFixed(1)}` : value.toFixed(1);
            ctx.fillText(label, padding.left - 10, y + 4);
          }
          
          // Draw bars
          data.forEach((d, i) => {
            const x = padding.left + i * (barWidth + barSpacing) + barSpacing / 2;
            // For rank, the delta is already inverted (baseline - latest), so positive = improvement
            // For other metrics, positive = improvement
            const isRank = d.kpi === 'current_rank';
            const barHeight = (Math.abs(d.value) / maxAbs) * chartHeight;
            const y = d.value >= 0 ? zeroY - barHeight : zeroY;
            
            // Rank: positive delta (lower rank = better) is green, negative (higher rank = worse) is red
            // Other metrics: positive delta (higher = better) is green, negative (lower = worse) is red
            ctx.fillStyle = d.value >= 0 ? '#10b981' : '#ef4444';
            ctx.fillRect(x, y, barWidth, barHeight);
            
            // Draw KPI label (horizontal, wrapped) - white and much larger
            const label = kpiLabels[d.kpi] || d.kpi.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            const labelX = x + barWidth / 2;
            const labelMaxWidth = barWidth * 0.95;
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            
            // Simple word wrapping: split on spaces if needed
            const words = label.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (const word of words) {
              const testLine = currentLine ? `${currentLine} ${word}` : word;
              const metrics = ctx.measureText(testLine);
              if (metrics.width > labelMaxWidth && currentLine) {
                lines.push(currentLine);
                currentLine = word;
              } else {
                currentLine = testLine;
              }
            }
            if (currentLine) lines.push(currentLine);
            
            // Draw lines centered under the bar
            const lineHeight = 12;
            const startY = displayHeight - padding.bottom + 15;
            lines.forEach((line, lineIdx) => {
              ctx.fillText(line, labelX, startY + (lineIdx * lineHeight));
            });
          });
        }
      }
      
      // Setup toggle buttons for left chart
      const clicksToggle = document.getElementById('chart-left-toggle-clicks');
      const trendToggle = document.getElementById('chart-left-toggle-trend');
      const kpiSelect = document.getElementById('chart-trend-kpi-select');
      // clicksCanvas and trendCanvas are already declared above in the chart rendering section
      
      if (clicksToggle && trendToggle) {
        // Set initial state
        const currentView = window.optimisationModuleState.leftChartView || 'clicks';
        if (currentView === 'clicks') {
          if (clicksCanvas) clicksCanvas.style.display = 'block';
          if (trendCanvas) trendCanvas.style.display = 'none';
          if (kpiSelect) kpiSelect.style.display = 'none';
          clicksToggle.classList.add('active');
          clicksToggle.style.background = 'var(--dark-brand)';
          clicksToggle.style.color = '#000';
          trendToggle.classList.remove('active');
          trendToggle.style.background = 'var(--dark-panel)';
          trendToggle.style.color = 'var(--dark-text)';
        } else {
          if (clicksCanvas) clicksCanvas.style.display = 'none';
          if (trendCanvas) trendCanvas.style.display = 'block';
          if (kpiSelect) kpiSelect.style.display = 'block';
          trendToggle.classList.add('active');
          trendToggle.style.background = 'var(--dark-brand)';
          trendToggle.style.color = '#000';
          clicksToggle.classList.remove('active');
          clicksToggle.style.background = 'var(--dark-panel)';
          clicksToggle.style.color = 'var(--dark-text)';
        }
        
        // Handle clicks toggle
        clicksToggle.addEventListener('click', () => {
          window.optimisationModuleState.leftChartView = 'clicks';
          if (clicksCanvas) clicksCanvas.style.display = 'block';
          if (trendCanvas) trendCanvas.style.display = 'none';
          if (kpiSelect) kpiSelect.style.display = 'none';
          clicksToggle.classList.add('active');
          clicksToggle.style.background = 'var(--dark-brand)';
          clicksToggle.style.color = '#000';
          trendToggle.classList.remove('active');
          trendToggle.style.background = 'var(--dark-panel)';
          trendToggle.style.color = 'var(--dark-text)';
          // Re-render chart
          updateTimeseriesCharts();
        });
        
        // Handle trend toggle
        trendToggle.addEventListener('click', () => {
          window.optimisationModuleState.leftChartView = 'trend';
          if (clicksCanvas) clicksCanvas.style.display = 'none';
          if (trendCanvas) trendCanvas.style.display = 'block';
          if (kpiSelect) kpiSelect.style.display = 'block';
          trendToggle.classList.add('active');
          trendToggle.style.background = 'var(--dark-brand)';
          trendToggle.style.color = '#000';
          clicksToggle.classList.remove('active');
          clicksToggle.style.background = 'var(--dark-panel)';
          clicksToggle.style.color = 'var(--dark-text)';
          // Re-render chart
          updateTimeseriesCharts();
        });
      }
      
      // Handle KPI select change
      if (kpiSelect) {
        kpiSelect.value = window.optimisationModuleState.selectedKpiForTrend || 'ctr_28d';
        kpiSelect.addEventListener('change', (e) => {
          window.optimisationModuleState.selectedKpiForTrend = e.target.value;
          updateTimeseriesCharts();
        });
      }
    }
    
    // Simple line chart renderer
    function renderLineChart(canvas, data, valueKey, label) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width || canvas.offsetWidth || 400;
      const height = canvas.height || canvas.offsetHeight || 200;
      canvas.width = width;
      canvas.height = height;
      
      ctx.clearRect(0, 0, width, height);
      
      if (!data || data.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No data', width / 2, height / 2);
        return;
      }
      
      const padding = 40;
      const plotWidth = width - padding * 2;
      const plotHeight = height - padding * 2;
      
      const values = data.map(d => d[valueKey] || 0);
      const max = Math.max(...values, 1);
      
      ctx.strokeStyle = '#3b82f6';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      data.forEach((d, idx) => {
        const x = padding + (idx / (data.length - 1 || 1)) * plotWidth;
        const y = padding + plotHeight - ((d[valueKey] || 0) / max) * plotHeight;
        if (idx === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      
      ctx.stroke();
      
      // Draw points
      ctx.fillStyle = '#3b82f6';
      data.forEach((d, idx) => {
        const x = padding + (idx / (data.length - 1 || 1)) * plotWidth;
        const y = padding + plotHeight - ((d[valueKey] || 0) / max) * plotHeight;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      });
    }
    
    // Simple bar chart renderer
    function renderBarChart(canvas, data, valueKey, label) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width || canvas.offsetWidth || 400;
      const height = canvas.height || canvas.offsetHeight || 200;
      canvas.width = width;
      canvas.height = height;
      
      ctx.clearRect(0, 0, width, height);
      
      if (!data || data.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No data', width / 2, height / 2);
        return;
      }
      
      const padding = 40;
      const plotWidth = width - padding * 2;
      const plotHeight = height - padding * 2;
      const barWidth = plotWidth / data.length;
      
      const values = data.map(d => d[valueKey] || 0);
      const max = Math.max(...values.map(Math.abs), 1);
      
      data.forEach((d, idx) => {
        const value = d[valueKey] || 0;
        const barHeight = (Math.abs(value) / max) * plotHeight;
        const x = padding + idx * barWidth;
        const y = padding + plotHeight - barHeight;
        
        ctx.fillStyle = value >= 0 ? '#10b981' : '#ef4444';
        ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
        
        // Label
        ctx.fillStyle = '#333';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        const kpiLabel = d.kpi ? d.kpi.replace(/_/g, ' ').substring(0, 10) : '';
        ctx.fillText(kpiLabel, x + barWidth / 2, height - 5);
      });
    }
    
    // Filter functions for KPI tiles
    window.filterByKPIRAG = function(kpi, rag) {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        return t.objectiveKpiKey === (kpi === 'ctr' ? 'ctr_28d' : null) && t.objectiveRag === rag;
      });
      renderOptimisationTasksTable();
    };
    
    window.filterByRankDelta = function(direction) {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        if (t.objectiveKpiKey !== 'current_rank' || t.delta == null) return false;
        if (direction === 'improved') return t.delta > 0;
        if (direction === 'worse') return t.delta < 0;
        if (direction === 'flat') return t.delta === 0;
        return false;
      });
      renderOptimisationTasksTable();
    };
    
    window.filterByAIGap = function() {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        return t.objectiveKpiKey === 'ai_citations' && t.latestValue === 0;
      });
      renderOptimisationTasksTable();
    };
    
    window.filterByNeedsMeasurement = function() {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        return t.needsMeasurement === true;
      });
      renderOptimisationTasksTable();
    };
    
    window.filterByOverdueCycles = function() {
      window.optimisationModuleState.filteredTasks = window.optimisationModuleState.allTasks.filter(t => {
        return t.objectiveRag === 'overdue';
      });
      renderOptimisationTasksTable();
    };

    // Load task events (B3)

    // Load task events (B3)
    // Render metrics snapshot (baseline + latest + deltas)
    function renderOptimisationMetricsSnapshot(task) {
      const container = document.getElementById('optimisation-metrics-snapshot');
      if (!container) return;

      const baseline = task.baseline_metrics || null;
      const latest = task.latest_metrics || null;

      if (!baseline && !latest) {
        container.innerHTML = '<div style="color: #666; font-style: italic; grid-column: 1 / -1;">No metrics snapshot available yet.</div>';
        return;
      }

      // Helper to format numbers
      const formatNum = (val) => {
        if (val == null) return '';
        if (typeof val === 'number') {
          if (val >= 1000) return (val / 1000).toFixed(1) + 'k';
          return val.toLocaleString();
        }
        return val;
      };

      // Helper to calculate delta
      const calcDelta = (latestVal, baselineVal) => {
        if (latestVal == null || baselineVal == null) return null;
        if (typeof latestVal === 'number' && typeof baselineVal === 'number') {
          return latestVal - baselineVal;
        }
        return null;
      };

      // Helper to format delta with color (handles rank where lower is better)
      const formatDelta = (delta, metricKey) => {
        if (delta == null) return { text: '', color: '#666' };
        // For rank, lower is better (negative delta means improved rank = good)
        if (metricKey === 'current_rank') {
          const absDelta = Math.abs(delta);
          const roundedDelta = Math.round(absDelta * 10) / 10; // Round to 1 decimal place
          if (delta < 0) return { text: `${roundedDelta}`, color: '#10b981' }; // Improved (rank went down = better) - green with up arrow
          if (delta > 0) return { text: `${roundedDelta}`, color: '#ef4444' }; // Worsened (rank went up = worse) - red with down arrow
          return { text: '0', color: '#f59e0b' }; // No change - amber
        }
        // For other metrics, higher is typically better
        if (delta > 0) return { text: `+${formatNum(delta)}`, color: '#10b981' }; // Up - green
        if (delta < 0) return { text: formatNum(delta), color: '#ef4444' }; // Down - red
        return { text: '0', color: '#f59e0b' }; // No change - amber
      };

      // Build metrics table
      const metrics = [
        { label: 'Clicks (28d)', baselineKey: 'gsc_clicks_28d', latestKey: 'gsc_clicks_28d', higherIsBetter: true },
        { label: 'Impressions (28d)', baselineKey: 'gsc_impressions_28d', latestKey: 'gsc_impressions_28d', higherIsBetter: true },
        { label: 'CTR (28d)', baselineKey: 'gsc_ctr_28d', latestKey: 'gsc_ctr_28d', higherIsBetter: true, format: (v) => v != null ? (v * 100).toFixed(2) + '%' : '' },
        { label: 'Current Rank', baselineKey: 'current_rank', latestKey: 'current_rank', higherIsBetter: false },
        { label: 'AI Overview', baselineKey: 'ai_overview', latestKey: 'ai_overview', format: (v) => v ? 'On' : 'Off' },
        { label: 'AI Citations', baselineKey: 'ai_citations', latestKey: 'ai_citations', higherIsBetter: true }
      ];

      let html = `
        <div style="font-weight: 700; padding: 0.5rem; background: var(--dark-panel); border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.9rem; color: var(--dark-text);">Metric</div>
        <div style="font-weight: 700; padding: 0.5rem; background: var(--dark-panel); border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.9rem; color: var(--dark-text);">Baseline</div>
        <div style="font-weight: 700; padding: 0.5rem; background: var(--dark-panel); border: 1px solid var(--dark-border); border-radius: 4px; font-size: 0.9rem; color: var(--dark-text);">Latest</div>
      `;

      metrics.forEach(metric => {
        const baselineVal = baseline?.[metric.baselineKey];
        const latestVal = latest?.[metric.latestKey];
        const delta = calcDelta(latestVal, baselineVal);
        const deltaFormatted = formatDelta(delta, metric.latestKey);

        const formatValue = (val) => {
          if (metric.format) return metric.format(val);
          return formatNum(val);
        };

        html += `
          <div style="padding: 0.5rem; border-bottom: 1px solid #e5e7eb; font-weight: 600; font-size: 0.9rem; color: #1e293b;">${metric.label}</div>
          <div style="padding: 0.5rem; border-bottom: 1px solid #e5e7eb; font-weight: 700; font-size: 1rem; color: #1e293b;">${formatValue(baselineVal)}</div>
          <div style="padding: 0.5rem; border-bottom: 1px solid #e5e7eb; font-weight: 700; font-size: 1rem; color: #1e293b;">
            ${formatValue(latestVal)}
            ${delta != null ? `<span style="margin-left: 0.5rem; color: ${deltaFormatted.color} !important; font-weight: 700;">(${deltaFormatted.text})</span>` : ''}
          </div>
        `;
      });

      // Add captured_at timestamps (use created_at from event if captured_at not in metrics)
      const baselineDate = baseline?.captured_at || baseline?.created_at;
      const latestDate = latest?.captured_at || latest?.created_at;
      if (baselineDate || latestDate) {
        html += `
          <div style="padding: 0.5rem; border-top: 2px solid #e5e7eb; font-size: 0.85rem; color: #1e293b; font-weight: 600;">Captured</div>
          <div style="padding: 0.5rem; border-top: 2px solid #e5e7eb; font-size: 0.85rem; color: #1e293b; font-weight: 700;">
            ${baselineDate ? new Date(baselineDate).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' }) : ''}
          </div>
          <div style="padding: 0.5rem; border-top: 2px solid #e5e7eb; font-size: 0.85rem; color: #1e293b; font-weight: 700;">
            ${latestDate ? new Date(latestDate).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' }) : ''}
          </div>
        `;
      }

      container.innerHTML = html;
    }

    // Load and render measurement history for a task
    async function loadOptimisationMeasurementHistory(taskId, cycleId, cycleNo) {
      const container = document.getElementById('optimisation-measurement-history');
      if (!container) return;

      try {
        // Fetch last 10 measurement events for this task (current cycle only)
        const cycleFilter = cycleId ? `&cycle_id=${cycleId}` : (cycleNo ? `&cycle_number=${cycleNo}` : '');
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/events?event_type=measurement&limit=10${cycleFilter}`), {
          headers: window.getOptimisationHeaders()
        });

        if (!response.ok) {
          container.innerHTML = '<div style="color: #ef4444; font-size: 0.875rem;">Failed to load measurement history</div>';
          return;
        }

        const data = await response.json();
        const events = data.events || [];
        
        if (!events || events.length === 0) {
          container.innerHTML = '<div style="color: #666; font-style: italic; font-size: 0.875rem;">No measurements captured yet for this cycle</div>';
          return;
        }

        // Filter to current cycle and sort by created_at descending (most recent first)
        const cycleEvents = events.filter(e => {
          if (cycleId) return e.cycle_id === cycleId;
          if (cycleNo) return e.cycle_number === cycleNo;
          return true;
        }).sort((a, b) => {
          const dateA = new Date(a.created_at || a.event_at || 0);
          const dateB = new Date(b.created_at || b.event_at || 0);
          return dateB - dateA;
        });

        if (cycleEvents.length === 0) {
          container.innerHTML = '<div style="color: #666; font-style: italic; font-size: 0.875rem;">No measurements captured yet for this cycle</div>';
          return;
        }

        // Build history table
        let html = `
          <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
            <thead>
              <tr style="background: #f3f4f6; border-bottom: 2px solid #d1d5db;">
                <th style="padding: 0.5rem; text-align: left; font-weight: 600;">Date</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">Clicks</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">Impr.</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">CTR</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">Rank</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;">AI Cit.</th>
                <th style="padding: 0.5rem; text-align: right; font-weight: 600;"> vs Prev</th>
              </tr>
            </thead>
            <tbody>
        `;

        cycleEvents.forEach((event, idx) => {
          const metrics = event.metrics || {};
          const capturedAt = event.created_at || event.event_at || event.metrics?.captured_at;
          const prevEvent = idx < cycleEvents.length - 1 ? cycleEvents[idx + 1] : null;
          const prevMetrics = prevEvent?.metrics || {};

          // Calculate deltas vs previous measurement
          const deltaClicks = metrics.gsc_clicks_28d != null && prevMetrics.gsc_clicks_28d != null 
            ? metrics.gsc_clicks_28d - prevMetrics.gsc_clicks_28d : null;
          const deltaImpr = metrics.gsc_impressions_28d != null && prevMetrics.gsc_impressions_28d != null
            ? metrics.gsc_impressions_28d - prevMetrics.gsc_impressions_28d : null;
          const deltaCTR = metrics.gsc_ctr_28d != null && prevMetrics.gsc_ctr_28d != null
            ? ((metrics.gsc_ctr_28d - prevMetrics.gsc_ctr_28d) * 100).toFixed(2) : null;
          const deltaRank = metrics.current_rank != null && prevMetrics.current_rank != null
            ? metrics.current_rank - prevMetrics.current_rank : null;
          const deltaAICit = metrics.ai_citations != null && prevMetrics.ai_citations != null
            ? metrics.ai_citations - prevMetrics.ai_citations : null;

          const formatDelta = (val, isRank = false) => {
            if (val == null) return '';
            if (isRank) {
              if (val < 0) return `<span style="color: #10b981;">${Math.abs(val)}</span>`;
              if (val > 0) return `<span style="color: #ef4444;">${val}</span>`;
              return '0';
            }
            if (val > 0) return `<span style="color: #10b981;">+${val}</span>`;
            if (val < 0) return `<span style="color: #ef4444;">${val}</span>`;
            return '0';
          };

          html += `
            <tr style="border-bottom: 1px solid #e5e7eb;">
              <td style="padding: 0.5rem; white-space: nowrap;">
                ${capturedAt ? new Date(capturedAt).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' }) : ''}
              </td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.gsc_clicks_28d != null ? metrics.gsc_clicks_28d.toLocaleString() : ''}</td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.gsc_impressions_28d != null ? metrics.gsc_impressions_28d.toLocaleString() : ''}</td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.gsc_ctr_28d != null ? (metrics.gsc_ctr_28d * 100).toFixed(2) + '%' : ''}</td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.current_rank != null ? metrics.current_rank : ''}</td>
              <td style="padding: 0.5rem; text-align: right;">${metrics.ai_citations != null ? metrics.ai_citations : ''}</td>
              <td style="padding: 0.5rem; text-align: right; font-size: 0.8rem;">
                ${prevEvent ? `
                  <div>${formatDelta(deltaClicks)}</div>
                  <div>${formatDelta(deltaImpr)}</div>
                  <div>${formatDelta(deltaCTR)}</div>
                  <div>${formatDelta(deltaRank, true)}</div>
                  <div>${formatDelta(deltaAICit)}</div>
                ` : '<span style="color: #9ca3af;">Baseline</span>'}
              </td>
            </tr>
          `;
        });

        html += `
            </tbody>
          </table>
        `;

        container.innerHTML = html;
      } catch (error) {
        console.error('[Optimisation] Error loading measurement history:', error);
        container.innerHTML = '<div style="color: #ef4444; font-size: 0.875rem;">Error loading measurement history</div>';
      }
    }

    async function loadOptimisationTaskEvents(taskId) {
      const eventsContainer = document.getElementById('optimisation-drawer-events');
      if (!eventsContainer) return;

      try {
        const headers = window.getOptimisationHeaders();
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/events`), {
          method: 'GET',
          headers: headers
        });

        if (!response.ok) {
          throw new Error(`Failed to load events: ${response.status}`);
        }

        const data = await response.json();
        const events = data.events || [];

        if (events.length === 0) {
          eventsContainer.innerHTML = '<div style="color: #666; font-style: italic;">No events yet</div>';
          return;
        }

        eventsContainer.innerHTML = events.map(event => {
          const date = new Date(event.event_at || event.created_at).toLocaleString('en-GB');
          // Format event type for display (replace underscores with spaces, capitalize)
          const eventTypeDisplay = (event.event_type || 'note')
            .replace(/_/g, ' ')
            .replace(/\b\w/g, l => l.toUpperCase());
          // Use different colors for different event types
          let eventColor = '#2563eb'; // Default blue
          if (event.event_type === 'cycle_completed') eventColor = '#10b981'; // Green
          if (event.event_type === 'cycle_archived') eventColor = '#6b7280'; // Grey
          if (event.event_type === 'cycle_start') eventColor = '#3b82f6'; // Blue
          if (event.event_type === 'measurement') eventColor = '#8b5cf6'; // Purple
          if (event.event_type === 'status_changed') eventColor = '#f59e0b'; // Orange
          
          return `
            <div style="margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid #eee;">
              <div style="font-weight: 600; color: ${eventColor};">${escapeHtml(eventTypeDisplay)}</div>
              <div style="color: #666; font-size: 0.875rem; margin-top: 0.25rem;">${date}</div>
              ${event.note ? `<div style="margin-top: 0.5rem;">${escapeHtml(event.note)}</div>` : ''}
            </div>
          `;
        }).join('');
      } catch (error) {
        console.error('[Optimisation Module] Error loading events:', error);
        eventsContainer.innerHTML = '<div style="color: #ef4444;">Error loading events</div>';
      }
    }

    // Initialize Optimisation Tracking module
    function initOptimisationTrackingModule() {
      // Set initial active tab
      if (!window.optimisationModuleState.activeTab) {
        window.optimisationModuleState.activeTab = 'active';
      }
      
      // Update tab button states on init
      document.querySelectorAll('.optimisation-tab-btn').forEach(btn => {
        btn.classList.toggle('metric-pill--active', btn.dataset.tab === window.optimisationModuleState.activeTab);
      });
      
      // Tab button handlers
      document.querySelectorAll('.optimisation-tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          switchOptimisationTab(btn.dataset.tab);
        });
      });

      // Drawer buttons
      const closeBtn = document.getElementById('optimisation-drawer-close');
      if (closeBtn) {
        closeBtn.addEventListener('click', closeOptimisationTaskDrawer);
      }
      
      const closeBottomBtn = document.getElementById('optimisation-drawer-close-bottom');
      if (closeBottomBtn) {
        closeBottomBtn.addEventListener('click', closeOptimisationTaskDrawer);
      }
      
      const minimizeBtn = document.getElementById('optimisation-drawer-minimize');
      if (minimizeBtn) {
        minimizeBtn.addEventListener('click', minimizeOptimisationDrawer);
      }
      
      const maximizeBtn = document.getElementById('optimisation-drawer-maximize');
      if (maximizeBtn) {
        maximizeBtn.addEventListener('click', maximizeOptimisationDrawer);
      }
      
      // Edit Objective button
      const editObjectiveBtn = document.getElementById('optimisation-edit-objective-btn');
      if (editObjectiveBtn) {
        editObjectiveBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (typeof window.editObjective === 'function') {
            window.editObjective();
          }
        });
      }

      // Save Objective button
      const saveObjectiveBtn = document.getElementById('optimisation-save-objective-btn');
      if (saveObjectiveBtn) {
        saveObjectiveBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (typeof window.saveObjective === 'function') {
            window.saveObjective();
          }
        });
      }

      // Cancel Edit Objective button
      const cancelEditObjectiveBtn = document.getElementById('optimisation-cancel-edit-objective-btn');
      if (cancelEditObjectiveBtn) {
        cancelEditObjectiveBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (typeof window.cancelEditObjective === 'function') {
            window.cancelEditObjective();
          }
        });
      }

      // Measurement history toggle
      const measurementHistoryToggle = document.getElementById('optimisation-measurement-history-toggle');
      const measurementHistoryContainer = document.getElementById('optimisation-measurement-history');
      if (measurementHistoryToggle && measurementHistoryContainer) {
        measurementHistoryToggle.addEventListener('click', () => {
          const isVisible = measurementHistoryContainer.style.display !== 'none';
          measurementHistoryContainer.style.display = isVisible ? 'none' : 'block';
          measurementHistoryToggle.textContent = isVisible ? 'Show' : 'Hide';
        });
      }

      // Update due date when timeframe changes
      const timeframeInput = document.getElementById('optimisation-edit-objective-timeframe');
      if (timeframeInput) {
        timeframeInput.addEventListener('input', updateObjectiveDueDate);
      }

      // Backdrop click to close (but not when clicking on drawer)
      const backdrop = document.getElementById('optimisation-task-drawer-backdrop');
      if (backdrop) {
        backdrop.addEventListener('click', (e) => {
          if (e.target === backdrop) {
            closeOptimisationTaskDrawer();
          }
        });
      }
      
      // Initialize dragging
      initOptimisationDrawerDragging();

      // Bulk update button
      const bulkUpdateBtn = document.getElementById('optimisation-bulk-update-btn');
      if (bulkUpdateBtn) {
        bulkUpdateBtn.addEventListener('click', async () => {
          if (typeof window.bulkUpdateAllTasks === 'function') {
            await window.bulkUpdateAllTasks();
          }
        });
      }

      // Timeline toggle (collapsed by default)
      const timelineHeader = document.getElementById('optimisation-timeline-header');
      const timelineToggle = document.getElementById('optimisation-timeline-toggle');
      const timelineContainer = document.getElementById('optimisation-drawer-events-container');
      if (timelineHeader && timelineToggle && timelineContainer) {
        timelineHeader.addEventListener('click', () => {
          const isCollapsed = timelineContainer.style.display === 'none';
          timelineContainer.style.display = isCollapsed ? 'block' : 'none';
          timelineToggle.textContent = isCollapsed ? '' : '';
        });
        // Ensure it starts collapsed
        timelineContainer.style.display = 'none';
        timelineToggle.textContent = '';
      }

      // Filter handlers
      const filterStatus = document.getElementById('optimisation-filter-status');
      const filterType = document.getElementById('optimisation-filter-type');
      const filterKeyword = document.getElementById('optimisation-filter-keyword');
      const filterUrl = document.getElementById('optimisation-filter-url');
      const clearFilters = document.getElementById('optimisation-clear-filters');

      const applyFilters = () => {
        // Apply base filters (test tasks, keyword, url, type, status, metric traffic)
        applyOptimisationFilters();
        
        // Apply additional button filters on top of base filters
        let filtered = [...window.optimisationModuleState.filteredTasks];
        
        // Apply status/type/keyword/url filters (using field name variations)
        if (filterStatus && filterStatus.value) {
          filtered = filtered.filter(t => t.status === filterStatus.value);
        }
        if (filterType && filterType.value) {
          filtered = filtered.filter(t => t.task_type === filterType.value);
        }
        if (filterKeyword && filterKeyword.value) {
          const keyword = filterKeyword.value.toLowerCase();
          filtered = filtered.filter(t => 
            (t.keyword_text || t.keyword || '').toLowerCase().includes(keyword)
          );
        }
        if (filterUrl && filterUrl.value) {
          const url = filterUrl.value.toLowerCase();
          filtered = filtered.filter(t => 
            (t.target_url_clean || t.target_url || '').toLowerCase().includes(url)
          );
        }
        
        // "Needs Update" filter: tasks with no measurement or measurement older than 30 days
        const needsUpdateBtn = document.getElementById('optimisation-filter-needs-update');
        if (needsUpdateBtn && needsUpdateBtn.classList.contains('active')) {
          const thirtyDaysAgo = new Date();
          thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
          
          filtered = filtered.filter(t => {
            // Check if task has latest_metrics
            if (!t.latest_metrics) {
              return true; // No measurement = needs update
            }
            
            // Check captured_at from latest_metrics
            const capturedAt = t.latest_metrics.captured_at;
            if (!capturedAt) {
              return true; // No capture date = needs update
            }
            
            const latestCapturedDate = new Date(capturedAt);
            return latestCapturedDate < thirtyDaysAgo; // Older than 30 days = needs update
          });
        }
        
        // "Active Cycle Only" filter: tasks with an active cycle (not completed/archived)
        const activeCycleBtn = document.getElementById('optimisation-filter-active-cycle');
        if (activeCycleBtn && activeCycleBtn.classList.contains('active')) {
          filtered = filtered.filter(t => {
            return t.active_cycle_id != null; // Has an active cycle
          });
        }
        
        // "Overdue Cycle" filter: tasks with overdue current cycle
        const overdueCycleBtn = document.getElementById('optimisation-filter-overdue-cycle');
        if (overdueCycleBtn && overdueCycleBtn.classList.contains('active')) {
          filtered = filtered.filter(t => {
            // Check if current cycle is overdue
            const status = t.objective_status || t.goal_state;
            return status === 'overdue';
          });
        }

        window.optimisationModuleState.filteredTasks = filtered;
        // Reset pagination when filters change
        optimisationPaginationState.currentPage = 1;
        updateTrafficLights(); // Update traffic lights when filters change
        updateTrafficLightVisuals(); // Update visual state of pills
        updateTimeseriesCharts(); // Update charts with filtered data
        renderOptimisationTasksTable();
      };

      if (filterStatus) filterStatus.addEventListener('change', applyFilters);
      if (filterType) filterType.addEventListener('change', applyFilters);
      if (filterKeyword) filterKeyword.addEventListener('input', applyFilters);
      if (filterUrl) filterUrl.addEventListener('input', applyFilters);
      
      // Attach click handlers to all traffic light pills (for pills that don't have onclick yet)
      setTimeout(() => {
        const metricMap = {
          'objective-impressions': 'impressions_28d',
          'objective-clicks': 'clicks_28d',
          'objective-rank': 'current_rank',
          'objective-ai-citations': 'ai_citations',
          'objective-ai-overview': 'ai_overview'
        };
        
        for (const [prefix, metricKey] of Object.entries(metricMap)) {
          const worseEl = document.getElementById(`${prefix}-red`);
          const sameEl = document.getElementById(`${prefix}-amber`);
          const betterEl = document.getElementById(`${prefix}-green`);
          
          if (worseEl && !worseEl.closest('.traffic-light-pill')) {
            const pill = worseEl.closest('div[style*="background"]');
            if (pill) {
              pill.classList.add('traffic-light-pill');
              pill.dataset.metric = metricKey;
              pill.dataset.bucket = 'worse';
              pill.style.background = 'rgba(239, 68, 68, 0.2)';
              pill.onclick = () => handleTrafficLightClick(metricKey, 'worse');
              // Remove any inline hover handlers - CSS handles it now
              pill.removeAttribute('onmouseover');
              pill.removeAttribute('onmouseout');
            }
          }
          
          if (sameEl && !sameEl.closest('.traffic-light-pill')) {
            const pill = sameEl.closest('div[style*="background"]');
            if (pill) {
              pill.classList.add('traffic-light-pill');
              pill.dataset.metric = metricKey;
              pill.dataset.bucket = 'same';
              pill.style.background = 'rgba(245, 158, 11, 0.2)';
              pill.onclick = () => handleTrafficLightClick(metricKey, 'same');
              // Remove any inline hover handlers - CSS handles it now
              pill.removeAttribute('onmouseover');
              pill.removeAttribute('onmouseout');
            }
          }
          
          if (betterEl && !betterEl.closest('.traffic-light-pill')) {
            const pill = betterEl.closest('div[style*="background"]');
            if (pill) {
              pill.classList.add('traffic-light-pill');
              pill.dataset.metric = metricKey;
              pill.dataset.bucket = 'better';
              pill.style.background = 'rgba(16, 185, 129, 0.2)';
              pill.onclick = () => handleTrafficLightClick(metricKey, 'better');
              // Remove any inline hover handlers - CSS handles it now
              pill.removeAttribute('onmouseover');
              pill.removeAttribute('onmouseout');
            }
          }
        }
        
        // Update visual state on initial load
        updateTrafficLightVisuals();
      }, 100);
      
      const needsUpdateBtn = document.getElementById('optimisation-filter-needs-update');
      if (needsUpdateBtn) {
        needsUpdateBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('[Optimisation] Needs Update button clicked');
          needsUpdateBtn.classList.toggle('active');
          if (needsUpdateBtn.classList.contains('active')) {
            needsUpdateBtn.style.background = '#3b82f6';
            needsUpdateBtn.style.color = '#ffffff';
          } else {
            needsUpdateBtn.style.background = '';
            needsUpdateBtn.style.color = '';
          }
          console.log('[Optimisation] Needs Update filter active:', needsUpdateBtn.classList.contains('active'));
          applyFilters();
        });
      } else {
        console.error('[Optimisation] Needs Update button not found!');
      }
      
      // Active Cycle Only filter button
      const activeCycleBtn = document.getElementById('optimisation-filter-active-cycle');
      if (activeCycleBtn) {
        activeCycleBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          activeCycleBtn.classList.toggle('active');
          if (activeCycleBtn.classList.contains('active')) {
            activeCycleBtn.style.background = '#3b82f6';
            activeCycleBtn.style.color = '#ffffff';
          } else {
            activeCycleBtn.style.background = '';
            activeCycleBtn.style.color = '';
          }
          applyFilters();
        });
      }
      
      // Overdue Cycle filter button
      const overdueCycleBtn = document.getElementById('optimisation-filter-overdue-cycle');
      if (overdueCycleBtn) {
        overdueCycleBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          overdueCycleBtn.classList.toggle('active');
          if (overdueCycleBtn.classList.contains('active')) {
            overdueCycleBtn.style.background = '#ef4444';
            overdueCycleBtn.style.color = '#ffffff';
          } else {
            overdueCycleBtn.style.background = '';
            overdueCycleBtn.style.color = '';
          }
          applyFilters();
        });
      }
      
      // Objective filter pills
      const goalNotSet = document.getElementById('optimisation-goal-filter-not-set');
      const goalOnTrack = document.getElementById('optimisation-goal-filter-on-track');
      const goalOverdue = document.getElementById('optimisation-goal-filter-overdue');
      const goalMet = document.getElementById('optimisation-goal-filter-met');
      
      const updateObjectiveFilterUI = () => {
        const active = window.optimisationModuleState.activeObjectiveFilter;
        [goalNotSet, goalOnTrack, goalOverdue, goalMet].forEach((el, idx) => {
          if (!el) return;
          const states = ['not_set', 'on_track', 'overdue', 'met'];
          if (active === states[idx]) {
            el.style.opacity = '1';
            el.style.fontWeight = '600';
            el.style.border = '2px solid #3b82f6';
          } else {
            el.style.opacity = active ? '0.6' : '1';
            el.style.fontWeight = '';
            el.style.border = '';
          }
        });
      };
      
      if (goalNotSet) {
        goalNotSet.addEventListener('click', () => {
          if (window.optimisationModuleState.activeObjectiveFilter === 'not_set') {
            window.optimisationModuleState.activeObjectiveFilter = null;
          } else {
            window.optimisationModuleState.activeObjectiveFilter = 'not_set';
          }
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      if (goalOnTrack) {
        goalOnTrack.addEventListener('click', () => {
          if (window.optimisationModuleState.activeObjectiveFilter === 'on_track') {
            window.optimisationModuleState.activeObjectiveFilter = null;
          } else {
            window.optimisationModuleState.activeObjectiveFilter = 'on_track';
          }
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      if (goalOverdue) {
        goalOverdue.addEventListener('click', () => {
          if (window.optimisationModuleState.activeObjectiveFilter === 'overdue') {
            window.optimisationModuleState.activeObjectiveFilter = null;
          } else {
            window.optimisationModuleState.activeObjectiveFilter = 'overdue';
          }
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      if (goalMet) {
        goalMet.addEventListener('click', () => {
          if (window.optimisationModuleState.activeObjectiveFilter === 'met') {
            window.optimisationModuleState.activeObjectiveFilter = null;
          } else {
            window.optimisationModuleState.activeObjectiveFilter = 'met';
          }
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      
      if (clearFilters) {
        clearFilters.addEventListener('click', () => {
          if (filterStatus) filterStatus.value = '';
          if (filterType) filterType.value = '';
          if (filterKeyword) filterKeyword.value = '';
          if (filterUrl) filterUrl.value = '';
          // Clear metric traffic filter
          window.optimisationModuleState.metricTrafficFilter = null;
          updateTrafficLightVisuals();
          if (needsUpdateBtn) {
            needsUpdateBtn.classList.remove('active');
            needsUpdateBtn.style.background = '';
            needsUpdateBtn.style.color = '';
          }
          const activeCycleBtn = document.getElementById('optimisation-filter-active-cycle');
          if (activeCycleBtn) {
            activeCycleBtn.classList.remove('active');
            activeCycleBtn.style.background = '';
            activeCycleBtn.style.color = '';
          }
          const overdueCycleBtn = document.getElementById('optimisation-filter-overdue-cycle');
          if (overdueCycleBtn) {
            overdueCycleBtn.classList.remove('active');
            overdueCycleBtn.style.background = '';
            overdueCycleBtn.style.color = '';
          }
          const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
          if (includeTestCheckbox) {
            includeTestCheckbox.checked = false;
          }
          window.optimisationModuleState.activeObjectiveFilter = null;
          updateObjectiveFilterUI();
          applyFilters();
        });
      }
      
      // Include test tasks checkbox
      const includeTestCheckbox = document.getElementById('optimisation-filter-include-test');
      if (includeTestCheckbox) {
        includeTestCheckbox.addEventListener('change', () => {
          applyFilters();
          updateOptimisationSummaryCards();
          updateKPITiles();
          updateImpactTiles();
          updateTimeseriesCharts();
        });
      }
      
      // Scope toggle
      const scopeSelect = document.getElementById('optimisation-scope-select');
      const scopeDescription = document.getElementById('optimisation-scope-description');
      if (scopeSelect) {
        scopeSelect.value = window.optimisationModuleState.scope || 'active_cycle';
        scopeSelect.addEventListener('change', () => {
          window.optimisationModuleState.scope = scopeSelect.value;
          if (scopeDescription) {
            scopeDescription.textContent = scopeSelect.value === 'active_cycle' 
              ? 'Showing metrics for tasks with active cycles only'
              : 'Showing metrics for all tasks';
          }
          window.loadAllOptimisationTasks();
        });
        if (scopeDescription) {
          scopeDescription.textContent = scopeSelect.value === 'active_cycle' 
            ? 'Showing metrics for tasks with active cycles only'
            : 'Showing metrics for all tasks';
        }
      }

      // Drawer action handlers
      const addEventBtn = document.getElementById('optimisation-add-event-btn');
      if (addEventBtn) {
        addEventBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          const eventType = document.getElementById('optimisation-event-type').value;
          const note = document.getElementById('optimisation-event-note').value;

          if (!note.trim()) {
            alert('Please enter a note');
            return;
          }

          try {
            const headers = window.getOptimisationHeaders();
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/event`), {
              method: 'POST',
              headers: headers,
              body: JSON.stringify({ event_type: eventType, note })
            });

            if (!response.ok) throw new Error('Failed to add event');

            document.getElementById('optimisation-event-note').value = '';
            await loadOptimisationTaskEvents(taskId);
            await window.loadAllOptimisationTasks();
            
            // If it was a measurement event, refresh the modal to update badge with fresh goal_state
            if (eventType === 'measurement') {
              if (typeof debugLog === 'function') {
                debugLog(`[Optimisation] Measurement added, refreshing modal to update badge state`, 'info');
              }
              await openOptimisationTaskDrawer(taskId);
            }
          } catch (error) {
            if (typeof debugLog === 'function') {
              debugLog(`[Optimisation] Error adding event: ${error.message}`, 'error');
            }
            console.error('[Optimisation Module] Error adding event:', error);
            alert('Failed to add event: ' + error.message);
          }
        });
      }

      const saveStatusBtn = document.getElementById('optimisation-save-status-btn');
      if (saveStatusBtn) {
        saveStatusBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          const newStatus = document.getElementById('optimisation-change-status').value;
          if (!newStatus) {
            alert('Please select a status');
            return;
          }

          try {
            await window.submitStatusChange(newStatus, taskId);
            await window.loadAllOptimisationTasks();
            await openOptimisationTaskDrawer(taskId);
          } catch (error) {
            console.error('[Optimisation Module] Error changing status:', error);
            alert('Failed to change status: ' + error.message);
          }
        });
      }

      // Complete Cycle button
      const completeCycleBtn = document.getElementById('optimisation-complete-cycle-btn');
      if (completeCycleBtn) {
        completeCycleBtn.addEventListener('click', async () => {
          // Get task ID from state
          let taskId = window.optimisationModuleState?.currentTaskId;
          
          // If not in state, try to get from the drawer's displayed content
          if (!taskId && window.optimisationModuleState?.allTasks?.length > 0) {
            // Find the task that has an active cycle (most likely the one being viewed)
            const taskWithActiveCycle = window.optimisationModuleState.allTasks.find(t => t.active_cycle_id);
            if (taskWithActiveCycle) {
              taskId = taskWithActiveCycle.id;
            }
          }
          
          if (!taskId) {
            alert('No task selected. Please open a task first.');
            return;
          }

          const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
          if (!task) {
            alert('Task not found. Please refresh the page.');
            return;
          }
          
          if (!task.active_cycle_id) {
            alert('No active cycle to complete');
            return;
          }

          if (!confirm(`Complete Cycle ${task.cycle_no || task.cycle_active || 'current'}? This will close the cycle and mark it as completed.`)) {
            return;
          }

          try {
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/cycle/complete`), {
              method: 'POST',
              headers: { ...window.getOptimisationHeaders(), 'Content-Type': 'application/json' },
              body: JSON.stringify({
                action: 'complete',
                cycle_id: task.active_cycle_id
              })
            });

            if (!response.ok) {
              const error = await response.json().catch(() => ({ error: 'Unknown error' }));
              throw new Error(error.error || 'Failed to complete cycle');
            }

            const result = await response.json();
            console.log('[Optimisation] Cycle completed successfully:', result);
            
            // Update task in state
            const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
            if (taskIndex >= 0 && result.task) {
              window.optimisationModuleState.allTasks[taskIndex] = result.task;
            }

            // Reload tasks to get fresh data
            if (typeof window.loadAllOptimisationTasks === 'function') {
              await window.loadAllOptimisationTasks();
            }
            
            // Refresh drawer if it's still open for this task
            if (window.optimisationModuleState.currentTaskId === taskId) {
              if (typeof window.openOptimisationTaskDrawer === 'function') {
                await window.openOptimisationTaskDrawer(taskId);
              }
            }

            // Refresh table
            if (typeof renderOptimisationTasksTable === 'function') {
              renderOptimisationTasksTable();
            }
            
            // Show success message
            alert(`Cycle ${task.cycle_no || task.cycle_active || 'current'} has been completed successfully.`);
          } catch (error) {
            console.error('[Optimisation] Error completing cycle:', error);
            alert('Failed to complete cycle: ' + error.message);
          }
        });
      }

      // Archive Cycle button
      const archiveCycleBtn = document.getElementById('optimisation-archive-cycle-btn');
      if (archiveCycleBtn) {
        archiveCycleBtn.addEventListener('click', async () => {
          // Get task ID from state
          let taskId = window.optimisationModuleState?.currentTaskId;
          
          // If not in state, try to get from the drawer's displayed content
          if (!taskId && window.optimisationModuleState?.allTasks?.length > 0) {
            // Find the task that has an active cycle (most likely the one being viewed)
            const taskWithActiveCycle = window.optimisationModuleState.allTasks.find(t => t.active_cycle_id);
            if (taskWithActiveCycle) {
              taskId = taskWithActiveCycle.id;
            }
          }
          
          if (!taskId) {
            alert('No task selected. Please open a task first.');
            return;
          }

          const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
          if (!task) {
            alert('Task not found. Please refresh the page.');
            return;
          }
          
          if (!task.active_cycle_id) {
            alert('No active cycle to archive');
            return;
          }

          if (!confirm(`Archive Cycle ${task.cycle_no || task.cycle_active || 'current'}? This will mark the cycle as archived (for abandoned work).`)) {
            return;
          }

          try {
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/cycle/complete`), {
              method: 'POST',
              headers: { ...window.getOptimisationHeaders(), 'Content-Type': 'application/json' },
              body: JSON.stringify({
                action: 'archive',
                cycle_id: task.active_cycle_id
              })
            });

            if (!response.ok) {
              const error = await response.json().catch(() => ({ error: 'Unknown error' }));
              throw new Error(error.error || 'Failed to archive cycle');
            }

            const result = await response.json();
            console.log('[Optimisation] Cycle archived successfully:', result);
            
            // Update task in state
            const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
            if (taskIndex >= 0 && result.task) {
              window.optimisationModuleState.allTasks[taskIndex] = result.task;
            }

            // Reload tasks to get fresh data
            if (typeof window.loadAllOptimisationTasks === 'function') {
              await window.loadAllOptimisationTasks();
            }
            
            // Refresh drawer if it's still open for this task
            if (window.optimisationModuleState.currentTaskId === taskId) {
              if (typeof window.openOptimisationTaskDrawer === 'function') {
                await window.openOptimisationTaskDrawer(taskId);
              }
            }

            // Refresh table
            if (typeof renderOptimisationTasksTable === 'function') {
              renderOptimisationTasksTable();
            }
            
            // Show success message
            alert(`Cycle ${task.cycle_no || task.cycle_active || 'current'} has been archived successfully.`);
          } catch (error) {
            console.error('[Optimisation] Error archiving cycle:', error);
            alert('Failed to archive cycle: ' + error.message);
          }
        });
      }

      const startCycleBtn = document.getElementById('optimisation-start-cycle-btn');
      if (startCycleBtn) {
        startCycleBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          try {
            await window.startNewCycle();
            await window.loadAllOptimisationTasks();
            await openOptimisationTaskDrawer(taskId);
          } catch (error) {
            console.error('[Optimisation Module] Error starting cycle:', error);
            alert('Failed to start cycle: ' + error.message);
          }
        });
      }

      const cancelTaskBtn = document.getElementById('optimisation-cancel-task-btn');
      if (cancelTaskBtn) {
        cancelTaskBtn.addEventListener('click', async () => {
          if (!confirm('Cancel this task? It will be marked as cancelled but history will be preserved.')) {
            return;
          }

          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          try {
            await window.stopTracking();
            await window.loadAllOptimisationTasks();
            closeOptimisationTaskDrawer();
          } catch (error) {
            console.error('[Optimisation Module] Error cancelling task:', error);
            alert('Failed to cancel task: ' + error.message);
          }
        });
      }

      const deleteTaskBtn = document.getElementById('optimisation-delete-task-btn');
      if (deleteTaskBtn) {
        deleteTaskBtn.addEventListener('click', async () => {
          try {
            await window.deleteTask();
          } catch (error) {
            alert('Failed to delete task: ' + error.message);
          }

          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          try {
            await window.deleteTask();
            await window.loadAllOptimisationTasks();
            // Refresh Ranking & AI table if it's visible
            if (typeof window.renderRankingAiTab === 'function') {
              await window.renderRankingAiTab();
            }
            closeOptimisationTaskDrawer();
          } catch (error) {
            console.error('[Optimisation Module] Error deleting task:', error);
            alert('Failed to delete task: ' + error.message);
          }
        });
      }

      const addMeasurementBtn = document.getElementById('optimisation-add-measurement-btn');
      if (addMeasurementBtn) {
        addMeasurementBtn.addEventListener('click', async () => {
          const taskId = window.optimisationModuleState.currentTaskId;
          if (!taskId) return;

          // Try to get current row data from Ranking & AI table if available
          const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
          if (!task) {
            alert('Task not found. Please refresh the page.');
            return;
          }

          // Try to ensure Ranking & AI data is loaded
          if (typeof window.renderRankingAiTab === 'function') {
            try {
              await window.renderRankingAiTab();
              // Small delay to let data load
              await new Promise(resolve => setTimeout(resolve, 500));
            } catch (e) {
              console.warn('[Optimisation] Could not refresh Ranking & AI data:', e);
            }
          }

          // Try to find matching row in Ranking & AI data
          let currentMetrics = null;
          let matchingRow = null;
          
          // First try RankingAiModule state
          if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
            const { combinedRows } = RankingAiModule.state();
            console.log('[Optimisation] Searching in combinedRows:', combinedRows?.length, 'rows');
            
            // Normalize URLs for comparison
            const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
            const taskUrlPath = taskUrlClean.includes('/') ? taskUrlClean.split('/').slice(1).join('/') : '';
            
            matchingRow = combinedRows?.find(r => {
              const keywordMatch = (r.keyword || '').toLowerCase() === (task.keyword_text || '').toLowerCase();
              if (!keywordMatch) return false;
              
              // Try multiple URL matching strategies
              const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
              const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
              const rowUrlPath = rowUrlClean.includes('/') ? rowUrlClean.split('/').slice(1).join('/') : '';
              
              return rowUrl === taskUrlClean || 
                     rowUrlClean === taskUrlClean ||
                     rowUrlPath === taskUrlPath ||
                     rowUrl.includes(taskUrlClean) ||
                     taskUrlClean.includes(rowUrlClean);
            });
            
            console.log('[Optimisation] Found matching row:', matchingRow ? 'YES' : 'NO', { 
              taskKeyword: task.keyword_text, 
              taskUrl: task.target_url_clean || task.target_url,
              matchingRowKeyword: matchingRow?.keyword,
              matchingRowUrl: matchingRow?.best_url || matchingRow?.targetUrl
            });
            
            if (matchingRow) {
              // Get queryTotal data for clicks, impressions, and CTR (same as submitTrackKeyword)
              let queryTotal = null;
              if (typeof getQueryTotalForKeyword === 'function') {
                queryTotal = getQueryTotalForKeyword(task.keyword_text);
              }
              
              currentMetrics = {
                gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
                gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
                // queryTotal.ctr is a percentage (0-100), convert to decimal for storage
                gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
                current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
                opportunity_score: matchingRow.opportunityScore || null,
                ai_overview: matchingRow.has_ai_overview || false,
                ai_citations: matchingRow.ai_alan_citations_count || 0,
                ai_citations_total: matchingRow.ai_total_citations || 0,
                classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
                page_type: matchingRow.pageType || null,
                segment: matchingRow.segment || null,
                captured_at: new Date().toISOString()
              };
            }
          }
          
          // If still no data, try to get from window.rankingAiData
          if (!matchingRow && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
            console.log('[Optimisation] Searching in window.rankingAiData:', window.rankingAiData.length, 'rows');
            
            const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
            const taskUrlPath = taskUrlClean.includes('/') ? taskUrlClean.split('/').slice(1).join('/') : '';
            
            matchingRow = window.rankingAiData.find(r => {
              const keywordMatch = (r.keyword || '').toLowerCase() === (task.keyword_text || '').toLowerCase();
              if (!keywordMatch) return false;
              
              const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
              const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
              const rowUrlPath = rowUrlClean.includes('/') ? rowUrlClean.split('/').slice(1).join('/') : '';
              
              return rowUrl === taskUrlClean || 
                     rowUrlClean === taskUrlClean ||
                     rowUrlPath === taskUrlPath ||
                     rowUrl.includes(taskUrlClean) ||
                     taskUrlClean.includes(rowUrlClean);
            });
            
            console.log('[Optimisation] Found matching row in window.rankingAiData:', matchingRow ? 'YES' : 'NO');
            
          }
          
          // Build metrics from matching row if found
          if (matchingRow) {
            // Get queryTotal data for clicks, impressions, and CTR (same as submitTrackKeyword)
            let queryTotal = null;
            if (typeof getQueryTotalForKeyword === 'function') {
              queryTotal = getQueryTotalForKeyword(task.keyword_text);
              console.log('[Optimisation] QueryTotal for keyword:', queryTotal);
            }
            
            currentMetrics = {
              gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
              gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
              // queryTotal.ctr is a percentage (0-100), convert to decimal for storage
              gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
              current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
              opportunity_score: matchingRow.opportunityScore || null,
              ai_overview: matchingRow.has_ai_overview || false,
              ai_citations: matchingRow.ai_alan_citations_count || 0,
              ai_citations_total: matchingRow.ai_total_citations || 0,
              classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
              page_type: matchingRow.pageType || null,
              segment: matchingRow.segment || null,
              captured_at: new Date().toISOString()
            };
            
            console.log('[Optimisation] Built currentMetrics from matching row:', currentMetrics);
          }

          // If no current data, try to use baseline metrics (if no new audit, current = baseline)
          if (!currentMetrics) {
            console.warn('[Optimisation] No matching row found for:', {
              keyword: task.keyword_text,
              url: task.target_url_clean || task.target_url
            });
            
            // Check if we have baseline metrics to reuse
            const baselineMetrics = task.baseline_metrics;
            if (baselineMetrics && typeof baselineMetrics === 'object') {
              console.log('[Optimisation] Using baseline metrics as current (no new audit data found)');
              // Reuse baseline metrics but update captured_at to current timestamp
              currentMetrics = {
                ...baselineMetrics,
                captured_at: new Date().toISOString()
              };
            } else {
              // No baseline either, ask user
              const proceed = confirm('Could not find current ranking data for this keyword/URL. Create measurement with current timestamp only?');
              if (!proceed) return;
              
              // Create minimal metrics with just captured_at
              currentMetrics = {
                captured_at: new Date().toISOString()
              };
            }
          }

          try {
            const headers = window.getOptimisationHeaders();
            console.log('[Optimisation] Adding measurement with metrics:', currentMetrics);
            
            const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/measurement`), {
              method: 'POST',
              headers: headers,
              body: JSON.stringify({
                metrics: currentMetrics,
                note: 'Measurement snapshot'
              })
            });

            if (!response.ok) {
              const errorText = await response.text();
              console.error('[Optimisation] Measurement error response:', errorText);
              throw new Error(errorText || 'Failed to add measurement');
            }

            const responseData = await response.json();
            console.log('[Optimisation] Measurement response:', responseData);

            // Reload tasks to get fresh data from view
            await window.loadAllOptimisationTasks();
            
            // If the response includes updated task data, use it to update state immediately
            if (responseData.task) {
              const taskIndex = window.optimisationModuleState.allTasks.findIndex(t => t.id === taskId);
              if (taskIndex >= 0) {
                window.optimisationModuleState.allTasks[taskIndex] = responseData.task;
                console.log('[Optimisation] Updated task in state with latest_metrics:', responseData.task.latest_metrics);
              } else {
                // Task not in state yet, add it
                window.optimisationModuleState.allTasks.push(responseData.task);
              }
            }
            
            // Refresh drawer with updated data
            await openOptimisationTaskDrawer(taskId);
            
            alert('Measurement added successfully!');
          } catch (error) {
            console.error('[Optimisation Module] Error adding measurement:', error);
            alert('Failed to add measurement: ' + error.message);
          }
        });
      }
    }

    // Bulk update all tasks with latest data
    window.bulkUpdateAllTasks = async function bulkUpdateAllTasks() {
      if (!window.optimisationModuleState || !window.optimisationModuleState.allTasks) {
        alert('No tasks loaded. Please wait for tasks to load first.');
        return;
      }

      // Get active tasks (not done/cancelled/deleted)
      const activeTasks = window.optimisationModuleState.allTasks.filter(
        t => !['done', 'cancelled', 'deleted'].includes(t.status)
      );

      if (activeTasks.length === 0) {
        alert('No active tasks to update.');
        return;
      }

      const confirmMsg = `Update ${activeTasks.length} task(s) with latest ranking data? This will create a new measurement for each task.`;
      if (!confirm(confirmMsg)) {
        return;
      }

      // Ensure Ranking & AI data is loaded
      if (typeof window.renderRankingAiTab === 'function') {
        try {
          await window.renderRankingAiTab();
          await new Promise(resolve => setTimeout(resolve, 1000)); // Give time for data to load
        } catch (e) {
          console.warn('[Optimisation] Could not refresh Ranking & AI data:', e);
        }
      }

      // Get ranking data sources
      let combinedRows = [];
      if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
        const state = RankingAiModule.state();
        combinedRows = state.combinedRows || [];
      }
      if (combinedRows.length === 0 && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
        combinedRows = window.rankingAiData;
      }

      if (combinedRows.length === 0) {
        alert('No ranking data available. Please run a Ranking & AI check first.');
        return;
      }

      const bulkUpdateBtn = document.getElementById('optimisation-bulk-update-btn');
      const originalText = bulkUpdateBtn ? bulkUpdateBtn.textContent : '';
      if (bulkUpdateBtn) {
        bulkUpdateBtn.disabled = true;
        bulkUpdateBtn.textContent = 'Updating...';
      }

      let successCount = 0;
      let skippedCount = 0;
      let failCount = 0;
      const errors = [];

      try {
        // Process sequentially to avoid rate limits (max 3 concurrent)
        const maxConcurrent = 3;
        for (let i = 0; i < activeTasks.length; i += maxConcurrent) {
          const batch = activeTasks.slice(i, i + maxConcurrent);
          
          await Promise.all(batch.map(async (task, batchIdx) => {
            const taskNum = i + batchIdx + 1;
            if (bulkUpdateBtn) {
              bulkUpdateBtn.textContent = `Updating ${taskNum}/${activeTasks.length}...`;
            }

          // Find matching row
          const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
          const taskUrlPath = taskUrlClean.includes('/') ? taskUrlClean.split('/').slice(1).join('/') : '';
          
          const matchingRow = combinedRows.find(r => {
            const keywordMatch = (r.keyword || '').toLowerCase() === (task.keyword_text || '').toLowerCase();
            if (!keywordMatch) return false;
            
            const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
            const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
            const rowUrlPath = rowUrlClean.includes('/') ? rowUrlClean.split('/').slice(1).join('/') : '';
            
            return rowUrl === taskUrlClean || 
                   rowUrlClean === taskUrlClean ||
                   rowUrlPath === taskUrlPath ||
                   rowUrl.includes(taskUrlClean) ||
                   taskUrlClean.includes(rowUrlClean);
          });

          let currentMetrics = null;

          if (matchingRow) {
            // Get queryTotal data for clicks, impressions, and CTR
            let queryTotal = null;
            if (typeof getQueryTotalForKeyword === 'function') {
              queryTotal = getQueryTotalForKeyword(task.keyword_text);
            }
            
            currentMetrics = {
              gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
              gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
              gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
              current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
              opportunity_score: matchingRow.opportunityScore || null,
              ai_overview: matchingRow.has_ai_overview || false,
              ai_citations: matchingRow.ai_alan_citations_count || 0,
              ai_citations_total: matchingRow.ai_total_citations || 0,
              classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
              page_type: matchingRow.pageType || null,
              segment: matchingRow.segment || null,
              captured_at: new Date().toISOString()
            };
          } else if (task.baseline_metrics) {
            // Fallback to baseline if no current data found
            console.log(`[Optimisation] No current data for ${task.keyword_text}, using baseline`);
            currentMetrics = { ...task.baseline_metrics, captured_at: new Date().toISOString() };
            // Remove null GSC metrics to avoid stale nulls
            if (currentMetrics.gsc_clicks_28d === null) delete currentMetrics.gsc_clicks_28d;
            if (currentMetrics.gsc_impressions_28d === null) delete currentMetrics.gsc_impressions_28d;
            if (currentMetrics.gsc_ctr_28d === null) delete currentMetrics.gsc_ctr_28d;
          }

          if (!currentMetrics) {
            failCount++;
            errors.push(`${task.keyword_text}: No data found`);
            return;
          }

            // Create measurement
            try {
              const headers = window.getOptimisationHeaders();
              const response = await fetch(apiUrl(`/api/optimisation/task/${task.id}/measurement`), {
                method: 'POST',
                headers: { ...headers, 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  metrics: currentMetrics,
                  note: 'Bulk update - latest data snapshot'
                })
              });

              if (!response.ok) {
                const error = await response.json().catch(() => ({ error: 'Unknown error' }));
                throw new Error(error.error || 'Failed to create measurement');
              }

              const result = await response.json();
              if (result.skipped) {
                skippedCount++;
              } else {
                successCount++;
              }
            } catch (error) {
              failCount++;
              errors.push(`${task.keyword_text}: ${error.message}`);
              console.error(`[Optimisation] Error updating task ${task.id}:`, error);
            }
          }));
        }

        // Reload tasks to show updated data
        await window.loadAllOptimisationTasks();

        // Show results in modal
        showBulkUpdateResultsModal(successCount, skippedCount, failCount, errors, activeTasks.length);

      } catch (error) {
        console.error('[Optimisation] Bulk update error:', error);
        showBulkUpdateResultsModal(0, 0, activeTasks.length, [`Bulk update failed: ${error.message}`], activeTasks.length);
      } finally {
        if (bulkUpdateBtn) {
          bulkUpdateBtn.disabled = false;
          bulkUpdateBtn.textContent = originalText;
        }
      }
    };

    // Show bulk update results modal
    function showBulkUpdateResultsModal(successCount, skippedCount, failCount, errors, totalTasks) {
      const modal = document.getElementById('optimisation-bulk-update-results-modal');
      const content = document.getElementById('bulk-update-results-content');
      
      if (!modal || !content) {
        // Fallback to alert if modal not found
        let message = `Updated ${successCount} task(s) successfully.`;
        if (skippedCount > 0) {
          message += ` Skipped ${skippedCount} (recent measurement within 5 minutes).`;
        }
        if (failCount > 0) {
          message += `\n\nFailed to update ${failCount} task(s):\n${errors.slice(0, 5).join('\n')}`;
          if (errors.length > 5) {
            message += `\n... and ${errors.length - 5} more.`;
          }
        }
        alert(message);
        return;
      }

      // Build summary HTML
      let html = '<div style="margin-bottom: 1.5rem;">';
      
      // Summary stats
      html += '<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 1.5rem;">';
      html += `<div style="padding: 1rem; background: #f0fdf4; border-left: 4px solid #10b981; border-radius: 4px;">
        <div style="font-size: 2rem; font-weight: 700; color: #10b981;">${successCount}</div>
        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">Successfully Updated</div>
      </div>`;
      html += `<div style="padding: 1rem; background: #fef3c7; border-left: 4px solid #f59e0b; border-radius: 4px;">
        <div style="font-size: 2rem; font-weight: 700; color: #f59e0b;">${skippedCount}</div>
        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">Skipped</div>
      </div>`;
      html += `<div style="padding: 1rem; background: #fee2e2; border-left: 4px solid #ef4444; border-radius: 4px;">
        <div style="font-size: 2rem; font-weight: 700; color: #ef4444;">${failCount}</div>
        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">Failed</div>
      </div>`;
      html += `<div style="padding: 1rem; background: #f3f4f6; border-left: 4px solid #6b7280; border-radius: 4px;">
        <div style="font-size: 2rem; font-weight: 700; color: #6b7280;">${totalTasks}</div>
        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">Total Tasks</div>
      </div>`;
      html += '</div>';

      // Skipped tasks explanation
      if (skippedCount > 0) {
        html += '<div style="padding: 1rem; background: #fef3c7; border-left: 4px solid #f59e0b; border-radius: 4px; margin-bottom: 1rem;">';
        html += '<div style="font-weight: 600; color: #92400e; margin-bottom: 0.5rem;">Why were tasks skipped?</div>';
        html += '<div style="font-size: 0.875rem; color: #78350f;">Tasks were skipped because they already have a recent measurement (within the last 5 minutes). This prevents duplicate measurements if you click the update button multiple times.</div>';
        html += '</div>';
      }

      // Failed tasks details
      if (failCount > 0 && errors.length > 0) {
        html += '<div style="padding: 1rem; background: #fee2e2; border-left: 4px solid #ef4444; border-radius: 4px; margin-bottom: 1rem;">';
        html += '<div style="font-weight: 600; color: #991b1b; margin-bottom: 0.75rem;">Failed Tasks:</div>';
        html += '<div style="max-height: 300px; overflow-y: auto; font-size: 0.875rem;">';
        html += '<ul style="margin: 0; padding-left: 1.5rem; color: #7f1d1d;">';
        errors.forEach(error => {
          html += `<li style="margin-bottom: 0.5rem;">${escapeHtml(error)}</li>`;
        });
        html += '</ul>';
        html += '</div>';
        html += '<div style="margin-top: 0.75rem; font-size: 0.875rem; color: #7f1d1d;">';
        html += '<strong>Common reasons for failures:</strong><ul style="margin-top: 0.5rem; padding-left: 1.5rem;">';
        html += '<li>No matching data found in Ranking & AI results</li>';
        html += '<li>Task keyword or URL doesn\'t match any ranking data</li>';
        html += '<li>Network or server error during update</li>';
        html += '<li>Task is missing required fields</li>';
        html += '</ul>';
        html += '</div>';
        html += '</div>';
      }

      // Success message
      if (successCount > 0) {
        html += '<div style="padding: 1rem; background: #f0fdf4; border-left: 4px solid #10b981; border-radius: 4px;">';
        html += '<div style="font-weight: 600; color: #065f46; margin-bottom: 0.5rem;"> Update Complete</div>';
        html += '<div style="font-size: 0.875rem; color: #047857;">Successfully updated measurements for ' + successCount + ' task(s). The table has been refreshed to show the latest data.</div>';
        html += '</div>';
      }

      html += '</div>';

      content.innerHTML = html;
      modal.style.display = 'flex';
    }

    // Close bulk update results modal
    window.closeBulkUpdateResultsModal = function closeBulkUpdateResultsModal() {
      const modal = document.getElementById('optimisation-bulk-update-results-modal');
      if (modal) {
        modal.style.display = 'none';
      }
    };

    // Update latest metrics for a single task
    window.updateTaskLatest = async function updateTaskLatest(taskId) {
      const task = window.optimisationModuleState.allTasks.find(t => t.id === taskId);
      if (!task) {
        alert('Task not found. Please refresh the page.');
        return;
      }

      // Ensure Ranking & AI data is loaded
      if (typeof window.renderRankingAiTab === 'function') {
        try {
          await window.renderRankingAiTab();
          await new Promise(resolve => setTimeout(resolve, 500));
        } catch (e) {
          console.warn('[Optimisation] Could not refresh Ranking & AI data:', e);
        }
      }

      // Get ranking data sources
      let combinedRows = [];
      if (typeof RankingAiModule !== 'undefined' && RankingAiModule.state) {
        const state = RankingAiModule.state();
        combinedRows = state.combinedRows || [];
      }
      if (combinedRows.length === 0 && typeof window.rankingAiData !== 'undefined' && Array.isArray(window.rankingAiData)) {
        combinedRows = window.rankingAiData;
      }

      // Find matching row
      const taskUrlClean = (task.target_url_clean || task.target_url || '').replace(/^https?:\/\//, '').replace(/^www\./, '').toLowerCase();
      const taskUrlPath = taskUrlClean.includes('/') ? taskUrlClean.split('/').slice(1).join('/') : '';
      
      const matchingRow = combinedRows.find(r => {
        const keywordMatch = (r.keyword || '').toLowerCase() === (task.keyword_text || '').toLowerCase();
        if (!keywordMatch) return false;
        
        const rowUrl = (r.best_url || r.targetUrl || r.ranking_url || '').toLowerCase();
        const rowUrlClean = rowUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');
        const rowUrlPath = rowUrlClean.includes('/') ? rowUrlClean.split('/').slice(1).join('/') : '';
        
        return rowUrl === taskUrlClean || 
               rowUrlClean === taskUrlClean ||
               rowUrlPath === taskUrlPath ||
               rowUrl.includes(taskUrlClean) ||
               taskUrlClean.includes(rowUrlClean);
      });

      let currentMetrics = null;

      if (matchingRow) {
        // Get queryTotal data for clicks, impressions, and CTR
        let queryTotal = null;
        if (typeof getQueryTotalForKeyword === 'function') {
          queryTotal = getQueryTotalForKeyword(task.keyword_text);
        }
        
        currentMetrics = {
          gsc_clicks_28d: queryTotal?.clicks || matchingRow.gsc_clicks_28d || matchingRow.clicks_28d || null,
          gsc_impressions_28d: queryTotal?.impressions || matchingRow.gsc_impressions_28d || matchingRow.impressions_28d || null,
          gsc_ctr_28d: queryTotal?.ctr != null ? (queryTotal.ctr / 100) : (matchingRow.gsc_ctr_28d || matchingRow.ctr_28d || null),
          current_rank: matchingRow.best_rank_group || matchingRow.current_rank || null,
          opportunity_score: matchingRow.opportunityScore || null,
          ai_overview: matchingRow.has_ai_overview || false,
          ai_citations: matchingRow.ai_alan_citations_count || 0,
          ai_citations_total: matchingRow.ai_total_citations || 0,
          classic_ranking_url: matchingRow.best_url || matchingRow.targetUrl || matchingRow.ranking_url || null,
          page_type: matchingRow.pageType || null,
          segment: matchingRow.segment || null,
          captured_at: new Date().toISOString()
        };
      } else if (task.baseline_metrics) {
        // Fallback to baseline if no current data found
        currentMetrics = { ...task.baseline_metrics, captured_at: new Date().toISOString() };
        if (currentMetrics.gsc_clicks_28d === null) delete currentMetrics.gsc_clicks_28d;
        if (currentMetrics.gsc_impressions_28d === null) delete currentMetrics.gsc_impressions_28d;
        if (currentMetrics.gsc_ctr_28d === null) delete currentMetrics.gsc_ctr_28d;
      }

      if (!currentMetrics) {
        alert('No ranking data available for this task. Please run a Ranking & AI check first.');
        return;
      }

      // Find the Update button to show loading state
      const updateBtn = event?.target;
      const originalText = updateBtn?.textContent || 'Update';
      if (updateBtn) {
        updateBtn.disabled = true;
        updateBtn.textContent = 'Updating...';
      }

      try {
        const headers = window.getOptimisationHeaders();
        const response = await fetch(apiUrl(`/api/optimisation/task/${taskId}/measurement`), {
          method: 'POST',
          headers: { ...headers, 'Content-Type': 'application/json' },
          body: JSON.stringify({
            metrics: currentMetrics,
            note: 'Latest measurement captured'
          })
        });

        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: 'Unknown error' }));
          throw new Error(error.error || 'Failed to create measurement');
        }

        const result = await response.json();
        
        // Reload tasks to show updated data
        await window.loadAllOptimisationTasks();
        
        // Show success message
        if (result.skipped) {
          if (typeof debugLog === 'function') {
            debugLog(`[Optimisation] Measurement skipped (recent): ${task.keyword_text}`, 'info');
          }
          // Show brief feedback
          if (updateBtn) {
            updateBtn.textContent = 'Skipped';
            setTimeout(() => {
              if (updateBtn) {
                updateBtn.disabled = false;
                updateBtn.textContent = originalText;
              }
            }, 2000);
          }
        } else {
          if (typeof debugLog === 'function') {
            debugLog(`[Optimisation] Measurement updated: ${task.keyword_text}`, 'success');
          }
          // Show brief success feedback
          if (updateBtn) {
            updateBtn.textContent = '';
            setTimeout(() => {
              if (updateBtn) {
                updateBtn.disabled = false;
                updateBtn.textContent = originalText;
              }
            }, 2000);
          }
        }
      } catch (error) {
        console.error(`[Optimisation] Error updating task ${taskId}:`, error);
        alert(`Failed to update task: ${error.message}`);
        if (updateBtn) {
          updateBtn.disabled = false;
          updateBtn.textContent = originalText;
        }
      }
    };

    // Add to ensurePanelRendered
    const originalEnsurePanelRendered = ensurePanelRendered;
    ensurePanelRendered = function(panelId) {
      originalEnsurePanelRendered(panelId);
      
      if (panelId === 'optimisation') {
        if (!window.optimisationModuleInitialized) {
          initOptimisationTrackingModule();
          window.optimisationModuleInitialized = true;
        }
        window.loadAllOptimisationTasks();
      }
    };

    // ======================
    // GSC Date Range Configuration
    // ======================
    // Centralized constant for GSC window (matches GSC UI default)
    const GSC_WINDOW_DAYS = 28;
    
    /**
     * Get GSC date range helper (matches backend utils.js getGscDateRange)
     * @param {number} daysBack - Number of days to look back (default: GSC_WINDOW_DAYS)
     * @param {number} endOffsetDays - Days to subtract from today for end date (default: 1 = yesterday)
     * @returns {Object} { startDate, endDate } as ISO strings (YYYY-MM-DD)
     */
    function getGscDateRange(daysBack = GSC_WINDOW_DAYS, endOffsetDays = 1) {
      // End date = yesterday (matches GSC UI behavior - today is often partial)
      const end = new Date();
      end.setDate(end.getDate() - endOffsetDays);
      end.setHours(0, 0, 0, 0);
      
      // Start date = end date - (daysBack - 1) days (inclusive range)
      const start = new Date(end);
      start.setDate(start.getDate() - (daysBack - 1));
      start.setHours(0, 0, 0, 0);
      
      // Format as YYYY-MM-DD
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      return {
        startDate: formatDate(start),
        endDate: formatDate(end)
      };
    }
    
    function safeSetLocalStorage(key, value) {
      try {
        const valueString = typeof value === 'string' ? value : JSON.stringify(value);
        // Check size before saving (localStorage limit is typically 5-10MB)
        if (valueString.length > 4 * 1024 * 1024) {
          debugLog(` Data too large for localStorage (${Math.round(valueString.length / 1024)}KB), skipping save. Supabase is source of truth.`, 'warn');
          return false;
        }
        localStorage.setItem(key, valueString);
        return true;
      } catch (error) {
        if (error.name === 'QuotaExceededError' || error.message.includes('quota')) {
          debugLog(` localStorage quota exceeded for ${key}, skipping save. Supabase is source of truth.`, 'warn');
          return false;
        } else {
          debugLog(` Error saving to localStorage (${key}): ${error.message}`, 'error');
          return false;
        }
      }
    }
    
    // ======================
    // CRITICAL: Define buildMoneyPageMetrics at GLOBAL SCOPE first
    // This ensures it's available when displayDashboard runs
    // ======================
    console.log('[Money Pages] Defining buildMoneyPageMetrics at global scope...');
    
    // Define helper functions that buildMoneyPageMetrics depends on (if not already defined)
    // These will be defined later in the script, but we need to ensure buildMoneyPageMetrics
    // can be called even if these helpers aren't ready yet
    
    // Placeholder - will be replaced by actual function when script loads
    // This is a fallback used only if no external Money Pages module is wired.
    // It returns empty metrics so the UI can show "No data" rather than crash.
    // Diagnostic function to check keyword matching issues AND missing search volume
    window.diagnoseKeywordMatching = function() {
      try {
        const savedAudit = loadAuditResultsSync();
        if (!savedAudit || !savedAudit.searchData) {
          debugLog(' No audit data found. Cannot diagnose keyword matching.', 'warn');
          return;
        }
        
        // Get keywords from ranking data
        let rankingData = [];
        if (window.RankingAiModule && typeof window.RankingAiModule.state === 'function') {
          const state = window.RankingAiModule.state();
          rankingData = state.combinedRows || [];
        }
        
        if (!rankingData || rankingData.length === 0) {
          debugLog(' No ranking keywords found. Cannot diagnose.', 'warn');
          return;
        }
        
        const allKeywords = rankingData.map(r => r.keyword).filter(k => k && k.trim());
        const queryTotals = savedAudit.searchData.queryTotals || [];
        
        debugLog(` Diagnostic: Checking ${allKeywords.length} keywords`, 'info');
        
        // CRITICAL: Check for missing search_volume (this is what the UI shows as "")
        const missingSearchVolume = [];
        const hasSearchVolume = [];
        
        rankingData.forEach(row => {
          const searchVolume = row.search_volume;
          // IMPORTANT: Only treat as missing if null/undefined, not if 0 (0 is a valid value)
          if (searchVolume == null || searchVolume === undefined) {
            missingSearchVolume.push({ keyword: row.keyword, search_volume: searchVolume });
          } else {
            hasSearchVolume.push({ keyword: row.keyword, search_volume: searchVolume });
          }
        });
        
        debugLog(` Search Volume Analysis:`, 'info');
        debugLog(`   Has search volume: ${hasSearchVolume.length} keywords`, 'success');
        debugLog(`   Missing search volume: ${missingSearchVolume.length} keywords`, missingSearchVolume.length > 0 ? 'warn' : 'success');
        if (missingSearchVolume.length > 0) {
          const missingList = missingSearchVolume.slice(0, 20).map(m => m.keyword).join(', ');
          debugLog(`  Missing search volume keywords: ${missingList}${missingSearchVolume.length > 20 ? ` ... (${missingSearchVolume.length - 20} more)` : ''}`, 'warn');
        }
        
        // Also check queryTotals matching (for impressions/CTR)
        const missingQueryTotals = [];
        const matchedQueryTotals = [];
        const zeroImpressionKeywords = [];
        
        allKeywords.forEach(keyword => {
          const normalizedKeyword = normalizeKeywordForMatching(keyword);
          const queryTotal = queryTotals.find(
            qt => {
              if (!qt.query) return false;
              const normalizedQuery = normalizeKeywordForMatching(qt.query);
              return normalizedQuery === normalizedKeyword || 
                     normalizedQuery.includes(normalizedKeyword) || 
                     normalizedKeyword.includes(normalizedQuery);
            }
          );
          
          if (!queryTotal) {
            missingQueryTotals.push(keyword);
          } else {
            matchedQueryTotals.push(keyword);
            if (queryTotal.impressions === 0 || queryTotal.impressions == null) {
              zeroImpressionKeywords.push({ keyword, query: queryTotal.query, impressions: queryTotal.impressions });
            }
          }
        });
        
        debugLog(` QueryTotals Analysis (for impressions/CTR):`, 'info');
        debugLog(`   Matched: ${matchedQueryTotals.length} keywords`, 'success');
        debugLog(`   Missing: ${missingQueryTotals.length} keywords`, missingQueryTotals.length > 0 ? 'warn' : 'info');
        if (missingQueryTotals.length > 0) {
          debugLog(`  Missing queryTotals: ${missingQueryTotals.slice(0, 20).join(', ')}${missingQueryTotals.length > 20 ? ` ... (${missingQueryTotals.length - 20} more)` : ''}`, 'warn');
        }
        
        debugLog(` Zero impressions: ${zeroImpressionKeywords.length} keywords`, zeroImpressionKeywords.length > 0 ? 'info' : 'success');
        if (zeroImpressionKeywords.length > 0) {
          const sample = zeroImpressionKeywords.slice(0, 10).map(z => `${z.keyword} (query: "${z.query}", impressions: ${z.impressions})`).join(', ');
          debugLog(`Sample zero-impression keywords: ${sample}${zeroImpressionKeywords.length > 10 ? '...' : ''}`, 'info');
        }
        
        // Check for queries in queryTotals that don't match any keywords (orphaned queries)
        const orphanedQueries = queryTotals.filter(qt => {
          const normalizedQuery = normalizeKeywordForMatching(qt.query || '');
          return !allKeywords.some(k => {
            const normalizedKeyword = normalizeKeywordForMatching(k);
            return normalizedQuery === normalizedKeyword || 
                   normalizedQuery.includes(normalizedKeyword) || 
                   normalizedKeyword.includes(normalizedQuery);
          });
        });
        
        if (orphanedQueries.length > 0) {
          debugLog(` Found ${orphanedQueries.length} orphaned queries in queryTotals (don't match any keywords)`, 'warn');
          const sample = orphanedQueries.slice(0, 10).map(qt => qt.query || '(no query)').join(', ');
          debugLog(`Sample orphaned queries: ${sample}${orphanedQueries.length > 10 ? '...' : ''}`, 'warn');
        }
        
        return {
          totalKeywords: allKeywords.length,
          totalQueryTotals: queryTotals.length,
          // Search volume analysis (what UI shows as "")
          missingSearchVolume: missingSearchVolume.length,
          missingSearchVolumeKeywords: missingSearchVolume,
          hasSearchVolume: hasSearchVolume.length,
          // QueryTotals analysis (for impressions/CTR)
          matched: matchedQueryTotals.length,
          missing: missingQueryTotals.length,
          missingKeywords: missingQueryTotals,
          zeroImpression: zeroImpressionKeywords.length,
          zeroImpressionKeywords: zeroImpressionKeywords,
          orphaned: orphanedQueries.length,
          orphanedQueries: orphanedQueries
        };
      } catch (error) {
        debugLog(` Error diagnosing keyword matching: ${error.message}`, 'error');
        return null;
      }
    };
    
    // Function to check Supabase database for missing search volume
    window.checkSupabaseSearchVolume = async function() {
      try {
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        if (!propertyUrl) {
          debugLog(' No property URL found. Cannot query Supabase.', 'warn');
          return;
        }
        
        debugLog(` Querying Supabase for missing search volume...`, 'info');
        
        const response = await fetch(apiUrl(`/api/supabase/get-latest-audit?propertyUrl=${encodeURIComponent(propertyUrl)}`));
        if (!response.ok) {
          const errorText = await response.text();
          debugLog(` Failed to fetch from Supabase: ${response.status} - ${errorText}`, 'warn');
          return;
        }
        
        const data = await response.json();
        if (data.status !== 'ok' || !data.data || !data.data.rankingAiData || !data.data.rankingAiData.combinedRows) {
          debugLog(' No ranking data found in Supabase response', 'warn');
          return;
        }
        
        const keywords = data.data.rankingAiData.combinedRows || [];
        const missingSearchVolume = keywords.filter(k => k.search_volume == null || k.search_volume === undefined);
        const hasSearchVolume = keywords.filter(k => k.search_volume != null && k.search_volume !== undefined);
        
        debugLog(` Supabase Search Volume Analysis:`, 'info');
        debugLog(`  Total keywords in DB: ${keywords.length}`, 'info');
        debugLog(`   Has search volume: ${hasSearchVolume.length} keywords`, 'success');
        debugLog(`   Missing search volume: ${missingSearchVolume.length} keywords`, missingSearchVolume.length > 0 ? 'warn' : 'success');
        
        if (missingSearchVolume.length > 0) {
          const missingList = missingSearchVolume.slice(0, 30).map(k => k.keyword).join(', ');
          debugLog(`  Missing search volume keywords: ${missingList}${missingSearchVolume.length > 30 ? ` ... (${missingSearchVolume.length - 30} more)` : ''}`, 'warn');
        }
        
        return {
          total: keywords.length,
          hasSearchVolume: hasSearchVolume.length,
          missingSearchVolume: missingSearchVolume.length,
          missingKeywords: missingSearchVolume.map(k => k.keyword)
        };
      } catch (error) {
        debugLog(` Error checking Supabase: ${error.message}`, 'error');
        return null;
      }
    };
    
    // Manual function to fetch and save queryTotals (for debugging/fixing missing data)
    window.fetchQueryTotalsManually = async function() {
      try {
        const savedAudit = loadAuditResultsSync();
        if (!savedAudit || !savedAudit.searchData) {
          debugLog(' No audit data found in localStorage. Please run a full audit first.', 'warn');
          return;
        }
        
        // Get keywords from ranking data
        let rankingData = [];
        
        // Try to get from RankingAiModule state first
        if (window.RankingAiModule && typeof window.RankingAiModule.state === 'function') {
          const state = window.RankingAiModule.state();
          rankingData = state.combinedRows || [];
          debugLog(` Found ${rankingData.length} keywords from RankingAiModule state`, 'info');
        }
        
        // Fallback: try to get from localStorage
        if (!rankingData || rankingData.length === 0) {
          try {
            const storedData = localStorage.getItem('ranking_ai_data');
            if (storedData) {
              const parsed = JSON.parse(storedData);
              if (parsed && parsed.combinedRows && Array.isArray(parsed.combinedRows)) {
                rankingData = parsed.combinedRows;
                debugLog(` Found ${rankingData.length} keywords from localStorage`, 'info');
              }
            }
          } catch (e) {
            debugLog(` Failed to parse ranking data from localStorage: ${e.message}`, 'warn');
          }
        }
        
        // Fallback: try to get from saved audit's keyword_rankings
        if (!rankingData || rankingData.length === 0) {
          if (savedAudit.keywordRankings && Array.isArray(savedAudit.keywordRankings)) {
            rankingData = savedAudit.keywordRankings;
            debugLog(` Found ${rankingData.length} keywords from saved audit`, 'info');
          }
        }
        
        if (!rankingData || rankingData.length === 0) {
          debugLog(' No ranking keywords found. Please run the ranking scan first.', 'warn');
          return;
        }
        
        const allKeywords = rankingData.map(r => r.keyword).filter(k => k && k.trim());
        if (allKeywords.length === 0) {
          debugLog(' No valid keywords found in ranking data.', 'warn');
          return;
        }
        
        debugLog(` Manually fetching queryTotals for ${allKeywords.length} keywords...`, 'info');
        const propertyUrl = localStorage.getItem('gsc_property_url') || localStorage.getItem('last_property_url') || '';
        const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '28');
        
        // Fetch queryTotals from GSC API
        const keywordsParam = encodeURIComponent(JSON.stringify(allKeywords));
        const propertyParam = encodeURIComponent(propertyUrl);
        const gscResponse = await fetch(apiUrl(`/api/aigeo/gsc-entity-metrics?property=${propertyParam}&keywords=${keywordsParam}&days=${dateRange}`));
        
        if (gscResponse.ok) {
          const gscData = await gscResponse.json();
          if (gscData.status === 'ok' && gscData.data && Array.isArray(gscData.data.queryTotals)) {
            const queryTotals = gscData.data.queryTotals;
            debugLog(` Fetched queryTotals for ${queryTotals.length} keywords from GSC`, 'success');
            
            // Merge queryTotals into searchData
            savedAudit.searchData.queryTotals = queryTotals;
            
            // Use the SAME audit_date as the existing audit
            let auditDate = new Date().toISOString().split('T')[0];
            if (savedAudit.timestamp) {
              try {
                auditDate = new Date(savedAudit.timestamp).toISOString().split('T')[0];
              } catch (e) {
                // Use today as fallback
              }
            }
            
            // Save to Supabase
            const saveResponse = await fetch(apiUrl('/api/supabase/save-audit'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                propertyUrl: propertyUrl,
                auditDate: auditDate,
                searchData: savedAudit.searchData
              })
            });
            
            if (saveResponse.ok) {
              debugLog(` Saved queryTotals to Supabase (${queryTotals.length} keywords)`, 'success');
              
              // Update localStorage
              try {
                safeSetLocalStorage('last_audit_results', savedAudit);
                debugLog(` Updated localStorage with queryTotals`, 'success');
              } catch (localStorageErr) {
                debugLog(` Failed to update localStorage: ${localStorageErr.message}`, 'warn');
              }
              
              // Re-render the table to show the new data
              renderRankingAiTab();
              debugLog(' Table re-rendered with queryTotals data', 'success');
            } else {
              const errorText = await saveResponse.text();
              debugLog(` Failed to save queryTotals to Supabase: ${saveResponse.status} - ${errorText}`, 'warn');
            }
          } else {
            debugLog(` GSC API did not return queryTotals data`, 'warn');
          }
        } else {
          const errorText = await gscResponse.text();
          debugLog(` Failed to fetch queryTotals from GSC: ${gscResponse.status} - ${errorText}`, 'warn');
        }
      } catch (error) {
        debugLog(` Error manually fetching queryTotals: ${error.message}`, 'error');
      }
    };
    
    window.buildMoneyPageMetrics = function(topPages, schemaAudit) {
      console.warn('[Money Pages]  buildMoneyPageMetrics placeholder called - full implementation not loaded yet. This is a fallback to prevent crashes. The UI will show "No data" until the full implementation loads.');
      // Return empty array as fallback so UI can gracefully handle missing data
      return [];
    };
    
    console.log('[Money Pages]  buildMoneyPageMetrics placeholder assigned to window');
    
    // ======================
    // Ranking & AI module - DEFINE FIRST to ensure it's available
    // ======================
    console.log('[RankingAiModule] Starting module definition at top of script...');
    window.RankingAiModule = (function () {
      console.log('[RankingAiModule] IIFE executing...');
      // Core tracked keywords. Real queries, no mock values.
      // Include both Money and Education terms.
      const TRACKED_KEYWORDS = [
        "alan ranger",
        "beginner photography classes",
        "beginner photography courses",
        "beginners photography course near me",
        "beginning photography lessons",
        "best photography classes",
        "best photography course",
        "best photography workshops",
        "camera courses for beginners",
        "commercial photographer",
        "commercial photography services",
        "corporate photography",
        "free online photography course",
        "hire a photographer",
        "hire a professional photographer",
        "landscape photography courses",
        "landscape photography workshop",
        "Landscape Photography Workshops",
        "landscape photography workshops uk",
        "landscape workshops",
        "lightroom courses",
        "one day photography workshops",
        "online photography courses",
        "online photography lesson",
        "photo editing course",
        "photo workshops",
        "photographer coventry",
        "photographer in coventry",
        "photographic workshops",
        "photography classes",
        "photography classes near me",
        "photography classes online",
        "photography course online",
        "photography courses",
        "photography courses coventry",
        "photography courses for beginners",
        "photography courses near me",
        "photography evening classes",
        "photography gift card",
        "photography gift voucher",
        "photography holidays uk",
        "photography lessons",
        "photography lessons near me",
        "photography lessons online",
        "photography masterclasses",
        "photography mentor",
        "photography presents",
        "photography training",
        "photography tuition",
        "photography tutor",
        "photography vouchers",
        "photography workshops",
        "photography workshops near me",
        "photography workshops uk",
        "private photography lessons",
        "private photography tuition",
        "professional commercial photography",
        "professional photographer",
        "professional photographer coventry",
        "professional photographer near me",
        "rps courses",
        "rps distinctions",
        "uk photography workshops"
      ];

      // API endpoints  adjust if the deployed paths differ.
      // window.apiUrl is already defined at the top level, so we can use it here
      // Also create a local const for use within this scope
      const apiUrl = window.apiUrl;
      
      const SERP_RANK_ENDPOINT = apiUrl('/api/aigeo/serp-rank-test');
      const AI_MODE_ENDPOINT = apiUrl('/api/aigeo/ai-mode-serp-batch-test'); // Using batch endpoint

      let hasLoadedOnce = false;
      let isLoading = false;
      let combinedRows = [];
      let summary = null;

      function normaliseKeyword(k) {
        return (k || "").trim().toLowerCase();
      }

      // Intent-based keyword segment classifier (client-side version)
      function classifyKeywordSegment(keyword, bestUrl) {
        if (!keyword || typeof keyword !== 'string') {
          return 'other';
        }
        
        const normalizedKeyword = keyword.trim().toLowerCase();
        
        // Priority 1: Brand (highest priority)
        const brandTerms = ['alan ranger', 'alanranger', 'alan ranger photography', 'photography academy', 'alan ranger academy'];
        if (brandTerms.some(term => normalizedKeyword.includes(term.toLowerCase()))) {
          return 'brand';
        }
        
        // Priority 2: Money (transactional OR local intent)
        const moneyTerms = ['lesson', 'lessons', 'class', 'classes', 'course', 'courses', 'training', 'workshop', 'workshops', 'mentoring', 'mentor', '1-2-1', '1:1', 'private', 'hire', 'service', 'services', 'photographer', 'booking', 'book', 'price', 'cost', 'voucher', 'gift'];
        const localModifiers = ['near me', 'in coventry', 'coventry', 'birmingham', 'warwick', 'leamington', 'solihull', 'rugby'];
        const hasMoneyTerm = moneyTerms.some(term => normalizedKeyword.includes(term.toLowerCase()));
        const hasLocalModifier = localModifiers.some(term => normalizedKeyword.includes(term.toLowerCase()));
        const hasPostcode = /\b([A-Z]{1,2}\d{1,2}\s?\d?[A-Z]{0,2})\b/i.test(normalizedKeyword);
        
        if (hasMoneyTerm || hasLocalModifier || hasPostcode) {
          return 'money';
        }
        
        // Priority 3: Education (informational/learning intent)
        const educationTerms = ['how to', 'what is', 'guide', 'tutorial', 'tips', 'settings', 'meaning', 'vs', 'difference', 'examples', 'best way to'];
        const techniqueTopics = ['aperture', 'shutter speed', 'iso', 'depth of field', 'histogram', 'dynamic range', 'composition'];
        const hasEducationTerm = educationTerms.some(term => normalizedKeyword.includes(term.toLowerCase()));
        const hasTechniqueTopic = techniqueTopics.some(term => normalizedKeyword.includes(term.toLowerCase()));
        
        if (hasEducationTerm || hasTechniqueTopic) {
          return 'education';
        }
        
        // Priority 4: Other (fallback)
        return 'other';
      }
      
      function classifyPageTypeForKeyword(bestUrl) {
        // Use shared classification function
        if (typeof window.classifyUrlForRankingAi === 'function') {
          const classification = window.classifyUrlForRankingAi(bestUrl || '');
          return classification.pageType;
        }
        return "Landing"; // Default fallback
      }

        const module = {
        TRACKED_KEYWORDS,
        SERP_RANK_ENDPOINT,
        AI_MODE_ENDPOINT,
        normaliseKeyword,
        classifyKeywordSegment,
        classifyPageTypeForKeyword,
        state: () => ({ hasLoadedOnce, isLoading, combinedRows, summary }),
        setLoadedOnce: (value) => { hasLoadedOnce = value; },
        setLoading: (value) => { isLoading = value; },
        setData: (rows, sum) => { 
          // Normalize rows: add segment_norm, segment_display, page_type_norm, page_type_display, impressions30d
          // Use window references since functions may be defined later
          const normSeg = window.normalizeSegment || ((input) => {
            const s = (input ?? "").trim().toLowerCase();
            return s.charAt(0).toUpperCase() + s.slice(1);
          });
          const segLabel = window.segmentLabel || ((s) => s);
          const normPageType = window.normalizePageType || ((pt) => {
            const k = (pt ?? "").trim().toLowerCase();
            return k.charAt(0).toUpperCase() + k.slice(1);
          });
          const pageTypeLab = window.pageTypeLabel || ((pt) => {
            const k = normPageType(pt);
            return k.charAt(0).toUpperCase() + k.slice(1);
          });
          // Get impressions30d for each row using getGscMetricsForKeywordRow (which returns impressions)
          const getGscMetrics = window.getGscMetricsForKeywordRow || (() => null);
          combinedRows = rows.map(r => {
            const segNorm = normSeg(r.segment);
            const segDisplay = segLabel(r.segment);
            const ptNorm = normPageType(r.pageType);
            const ptDisplay = pageTypeLab(r.pageType);
            // Get impressions30d from GSC data - use canonical targetUrl
            const pageUrlForGsc = r.targetUrl || r.ranking_url || r.best_url || '';
            const gscMetrics = getGscMetrics({ query: r.keyword, pageUrl: pageUrlForGsc });
            const impressions30d = gscMetrics && gscMetrics.impressions != null ? gscMetrics.impressions : null;
            return {
              ...r,
              segment_norm: segNorm,
              segment_display: segDisplay,
              page_type_norm: ptNorm,
              page_type_display: ptDisplay,
              impressions30d: impressions30d
            };
          });
          summary = sum; 
        }
      };
      console.log('[RankingAiModule] Module object created:', Object.keys(module));
      return module;
    })();
    
    console.log('[RankingAiModule] Assignment complete. window.RankingAiModule exists:', typeof window.RankingAiModule !== 'undefined');
    console.log('[RankingAiModule] window.RankingAiModule:', window.RankingAiModule);
    
    if (typeof window.RankingAiModule !== 'undefined') {
      console.log('[RankingAiModule]  Successfully assigned to window');
      console.log('[RankingAiModule] TRACKED_KEYWORDS:', window.RankingAiModule.TRACKED_KEYWORDS);
    } else {
      console.error('[RankingAiModule]  FAILED to assign to window');
    }
    
    // Debug logging system
    const debugLogEntries = [];
    let debugLogFilter = 'all'; // 'all', 'warnings-errors'
    
    function debugLog(message, type = 'info') {
      const timestamp = new Date().toISOString();
      const entry = {
        timestamp,
        message,
        type
      };
      debugLogEntries.push(entry);
      
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        // Check if entry should be displayed based on filter
        const shouldShow = debugLogFilter === 'all' || (debugLogFilter === 'warnings-errors' && (type === 'warn' || type === 'error'));
        
        if (shouldShow) {
        const entryDiv = document.createElement('div');
        entryDiv.className = `debug-log-entry ${type}`;
        entryDiv.innerHTML = `<span class="debug-timestamp">[${new Date(timestamp).toLocaleTimeString()}]</span>${message}`;
        logElement.appendChild(entryDiv);
        logElement.scrollTop = logElement.scrollHeight;
        }
      }
      
      // Only log critical errors to browser console (for debugging production issues)
      // All other logs go to UI debug console only
      if (type === 'error') {
        console.error(`[DEBUG ERROR]`, message);
      }
    }
    
    function toggleDebugLogFilter() {
      debugLogFilter = debugLogFilter === 'all' ? 'warnings-errors' : 'all';
      const filterBtn = document.getElementById('debugFilterBtn');
      if (filterBtn) {
        filterBtn.textContent = `Filter: ${debugLogFilter === 'all' ? 'All' : 'Warnings/Errors'}`;
      }
      
      // Re-render all log entries with current filter
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        logElement.innerHTML = '';
        debugLogEntries.forEach(entry => {
          const shouldShow = debugLogFilter === 'all' || (debugLogFilter === 'warnings-errors' && (entry.type === 'warn' || entry.type === 'error'));
          if (shouldShow) {
            const entryDiv = document.createElement('div');
            entryDiv.className = `debug-log-entry ${entry.type}`;
            entryDiv.innerHTML = `<span class="debug-timestamp">[${new Date(entry.timestamp).toLocaleTimeString()}]</span>${entry.message}`;
            logElement.appendChild(entryDiv);
          }
        });
        logElement.scrollTop = logElement.scrollHeight;
      }
    }

    function clearDebugLog() {
      debugLogEntries.length = 0;
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        logElement.innerHTML = '';
      }
      debugLog('Debug log cleared', 'info');
    }
    
    // Initialize filter button text on page load
    window.addEventListener('DOMContentLoaded', () => {
      const filterBtn = document.getElementById('debugFilterBtn');
      if (filterBtn) {
        filterBtn.textContent = `Filter: ${debugLogFilter === 'all' ? 'All' : 'Warnings/Errors'}`;
      }
    });

    function copyDebugLog() {
      // Filter entries based on current filter state
      const filteredEntries = debugLogEntries.filter(entry => {
        return debugLogFilter === 'all' || (debugLogFilter === 'warnings-errors' && (entry.type === 'warn' || entry.type === 'error'));
      });
      
      const logText = filteredEntries.map(entry => 
        `[${entry.timestamp}] [${entry.type.toUpperCase()}] ${entry.message}`
      ).join('\n');
      
      navigator.clipboard.writeText(logText).then(() => {
        debugLog(`Debug log copied to clipboard (${filteredEntries.length} ${debugLogFilter === 'all' ? 'entries' : 'warnings/errors'})`, 'success');
        showStatus(`Debug log copied! (${filteredEntries.length} ${debugLogFilter === 'all' ? 'entries' : 'warnings/errors'})`, 'success');
      }).catch(err => {
        debugLog('Failed to copy log: ' + err.message, 'error');
        showStatus('Failed to copy log', 'error');
      });
    }

    function toggleDebugPanel() {
      const panel = document.getElementById('debugPanel');
      const icon = document.getElementById('debugToggleIcon');
      if (panel.classList.contains('collapsed')) {
        panel.classList.remove('collapsed');
        if (icon) icon.textContent = '';
      } else {
        panel.classList.add('collapsed');
        if (icon) icon.textContent = '';
      }
    }

    // Performance optimization: Defer heavy work to improve INP
    function defer(fn) {
      if (window.requestIdleCallback) {
        requestIdleCallback(fn, { timeout: 800 });
      } else {
        setTimeout(fn, 0);
      }
    }

    const panelInitDone = new Set();

    function setActivePanel(panelId) {
      // 1) fast: toggle active nav styles
      document.querySelectorAll('.aigeo-nav-item').forEach(btn => {
        btn.classList.toggle('is-active', btn.dataset.panel === panelId);
        btn.setAttribute('aria-selected', btn.dataset.panel === panelId ? 'true' : 'false');
      });

      // 2) fast: show/hide panels only (NO rendering work here)
      document.querySelectorAll('.aigeo-panel').forEach(p => {
        const isActive = p.dataset.panel === panelId;
        p.classList.toggle('is-active', isActive);
        p.hidden = !isActive; // Explicitly set hidden attribute
      });
    }

    function ensurePanelRendered(panelId) {
      if (panelInitDone.has(panelId)) return;

      // IMPORTANT: only do heavy first-time render here
      // e.g. build big tables, compute summaries, populate dropdowns
      if (panelId === 'ranking') {
        // Fix DOM structure first
        fixRankingPanelStructure();
        // Load data and render ranking panel
        (async () => {
          debugLog(' Ranking panel: Loading data from storage...', 'info');
          const storedData = await loadRankingAiDataFromStorage(false);
          if (storedData && storedData.combinedRows && storedData.summary) {
            const mod = window.RankingAiModule;
            if (mod) {
              const normalizedSummary = normalizeSummaryFields(storedData.summary);
              mod.setData(storedData.combinedRows, normalizedSummary);
              mod.setLoadedOnce(true);
              renderRankingAiTab();
              const lastRunEl = document.getElementById("ranking-ai-last-run");
              if (lastRunEl && storedData.timestamp) {
                const date = new Date(storedData.timestamp);
                // Format in GMT/UTC: "DD MMM YYYY, HH:MM:SS GMT"
                const day = String(date.getUTCDate()).padStart(2, '0');
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const month = monthNames[date.getUTCMonth()];
                const year = date.getUTCFullYear();
                const hours = String(date.getUTCHours()).padStart(2, '0');
                const minutes = String(date.getUTCMinutes()).padStart(2, '0');
                const seconds = String(date.getUTCSeconds()).padStart(2, '0');
                const formatted = `${day} ${month} ${year}, ${hours}:${minutes}:${seconds} GMT`;
                lastRunEl.textContent = `Last run: ${formatted}`;
              }
            }
          } else {
            const mod = window.RankingAiModule;
            if (mod) {
              mod.setData([], { total_keywords: 0, keywords_with_rank: 0, keywords_with_ai_overview: 0, keywords_with_ai_citations: 0, top10: 0, top3: 0 });
              renderRankingAiTab();
            }
          }
          
          // CRITICAL: After initial render, check if queryTotals are available and re-render if needed
          // This ensures CTR/Impressions columns are populated even if loadAuditResults() completes after initial render
          (async () => {
            try {
              debugLog(` Checking for queryTotals after initial render...`, 'info');
              const savedAudit = await loadAuditResults();
              debugLog(` loadAuditResults() completed - savedAudit=${!!savedAudit}, searchData=${!!savedAudit?.searchData}, queryTotals=${savedAudit?.searchData?.queryTotals?.length || 0}`, savedAudit?.searchData?.queryTotals?.length > 0 ? 'success' : 'warn');
              if (savedAudit && savedAudit.searchData && Array.isArray(savedAudit.searchData.queryTotals) && savedAudit.searchData.queryTotals.length > 0) {
                debugLog(` queryTotals loaded (${savedAudit.searchData.queryTotals.length} keywords), re-rendering table to show CTR/Impressions`, 'success');
                // Re-render the table to show CTR/Impressions data
                if (typeof renderRankingAiTab === 'function') {
                  renderRankingAiTab();
                  debugLog(` Table re-rendered with queryTotals data`, 'success');
                } else {
                  debugLog(` renderRankingAiTab function not found`, 'warn');
                }
              } else {
                debugLog(` No queryTotals found in savedAudit - searchData=${!!savedAudit?.searchData}, queryTotals type=${typeof savedAudit?.searchData?.queryTotals}, length=${savedAudit?.searchData?.queryTotals?.length || 0}`, 'warn');
                if (savedAudit && savedAudit.searchData) {
                  debugLog(` searchData keys: ${Object.keys(savedAudit.searchData).join(', ')}`, 'warn');
                }
              }
            } catch (err) {
              debugLog(` Error loading queryTotals for re-render: ${err.message}`, 'error');
              debugLog(` Error stack: ${err.stack}`, 'error');
            }
          })();
          
          // Wire up filters and sorting after render
          setTimeout(() => {
            // Fix DOM structure after render
            fixRankingPanelStructure();
            if (typeof wireRankingAiButton === 'function') wireRankingAiButton();
            if (typeof wireRankingFilters === 'function') wireRankingFilters();
            if (typeof wireRankingSorting === 'function') wireRankingSorting();
            if (typeof wireRankingPagination === 'function') wireRankingPagination();
          }, 100);
        })();
      } else if (panelId === 'ai-sources') {
        setTimeout(() => {
          if (typeof wireAiSourcesFilters === 'function') wireAiSourcesFilters();
        }, 100);
        (async () => {
          debugLog(' AI Sources & Influence tab clicked - loading data...', 'info');
          const storedData = await loadRankingAiDataFromStorage(false);
          if (storedData && storedData.combinedRows && storedData.combinedRows.length > 0) {
            const mod = window.RankingAiModule;
            if (mod) {
              const normalizedSummary = normalizeSummaryFields(storedData.summary);
              mod.setData(storedData.combinedRows, normalizedSummary);
              debugLog(` AI Sources tab: Rendering with ${storedData.combinedRows.length} keywords`, 'success');
              if (typeof renderAiSourcesTab === 'function') {
                renderAiSourcesTab();
              }
            }
          } else {
            debugLog(' AI Sources tab: No keyword data available. Run a Ranking & AI check first.', 'warn');
            if (typeof renderAiSourcesTab === 'function') {
              renderAiSourcesTab(); // Will show empty state
            }
          }
        })();
      } else if (panelId === 'overview') {
        setTimeout(async () => {
          // Use async loadAuditResults to ensure we get latest data from Supabase (including localSignals with locations)
          const saved = await loadAuditResults();
          if (saved && saved.scores && saved.searchData) {
            const trendCanvas = document.getElementById('trendChart');
            if (trendCanvas && typeof displayDashboard === 'function') {
              debugLog('Re-rendering Score Trends chart for Overview tab', 'info');
              // DEBUG: Log localSignals structure when loading Overview tab
              if (saved.localSignals) {
                debugLog(`[Overview Tab] localSignals structure: status=${saved.localSignals.status}, hasData=${!!saved.localSignals.data}, hasLocations=${!!saved.localSignals.data?.locations}, locationsCount=${saved.localSignals.data?.locations?.length || 0}`, 'info');
              } else {
                debugLog(`[Overview Tab]  localSignals is missing from saved audit data`, 'warn');
              }
              try {
                await displayDashboard(saved.scores, saved.searchData, saved.snippetReadiness || 0, saved.schemaAudit || null, saved.localSignals || null);
              } catch (err) {
                debugLog(`Error re-rendering trend chart: ${err.message}`, 'warn');
              }
            }
          }
        }, 200);
      } else if (panelId === 'money') {
        setTimeout(() => {
          const saved = loadAuditResultsSync();
          
          if (typeof renderMoneyPagesTable === 'function') {
            const priorityData = window.moneyPagePriorityData || (saved && saved.moneyPagePriorityData) || [];
            if (priorityData && priorityData.length > 0) {
              debugLog('Re-rendering Money Pages Priority Matrix table', 'info');
              renderMoneyPagesTable(priorityData);
            }
          }
          
          if (typeof renderMoneyPagesSection === 'function' && saved && saved.scores && saved.scores.moneyPagesMetrics) {
            debugLog('Re-rendering Money Pages section', 'info');
            renderMoneyPagesSection(saved.scores.moneyPagesMetrics);
            
            // Wait for HTML structure to be created before rendering charts
            setTimeout(() => {
              // Opportunity Mix: render after layout settles (Money tab activation can report 0x0)
              if (saved && saved.scores && saved.scores.moneyPagesMetrics && typeof renderMoneyPagesCategoryChart === 'function') {
                requestAnimationFrame(() => {
                  requestAnimationFrame(() => {
                    renderMoneyPagesCategoryChart(saved.scores.moneyPagesMetrics, 0);
                  });
                });
              }
            }, 200); // Give renderMoneyPagesSection time to create HTML structure
          } else if (saved && saved.scores && saved.scores.moneyPagesMetrics && typeof renderMoneyPagesCategoryChart === 'function') {
            // If renderMoneyPagesSection wasn't called, still try to render charts (structure might already exist)
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                renderMoneyPagesCategoryChart(saved.scores.moneyPagesMetrics, 0);
              });
            });
          }
          
          // Render charts only when panel is visible and canvas has dimensions
          // Wait a bit longer to ensure HTML structure is created
          setTimeout(() => {
            const renderMoneyCharts = () => {
            const moneyPanel = document.querySelector('.aigeo-panel[data-panel="money"]');
            const isPanelVisible = moneyPanel && moneyPanel.classList.contains('is-active') && 
                                   window.getComputedStyle(moneyPanel).display !== 'none';
            
            if (!isPanelVisible) {
              debugLog(' Money Pages charts: Panel not visible yet, will retry', 'warn');
              setTimeout(renderMoneyCharts, 200);
              return;
            }
            
            const volumeCanvas = document.getElementById('moneyPagesVolumeChart');
            const rateCanvas = document.getElementById('moneyPagesRateChart');
            if ((volumeCanvas || rateCanvas) && typeof renderMoneyPagesTrendChart === 'function') {
              const volumeRect = volumeCanvas ? volumeCanvas.getBoundingClientRect() : { width: 0, height: 0 };
              const rateRect = rateCanvas ? rateCanvas.getBoundingClientRect() : { width: 0, height: 0 };
              if ((volumeRect.width === 0 || volumeRect.height === 0) && (rateRect.width === 0 || rateRect.height === 0)) {
                debugLog(' Money Pages trend charts: Canvases have zero dimensions, will retry', 'warn');
                setTimeout(renderMoneyCharts, 200);
                return;
              }
              
              const propertyUrl = document.getElementById('propertyUrl')?.value;
              if (propertyUrl) {
                const endDate = new Date();
                const startDate = new Date();
                startDate.setFullYear(startDate.getFullYear() - 1);
                const startDateStr = startDate.toISOString().split('T')[0];
                const endDateStr = endDate.toISOString().split('T')[0];
                
                // Use apiUrl helper so this works both on Vercel and when opened locally (file://)
                const urlHelper = window.apiUrl || ((path) => {
                  const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || !window.location.hostname;
                  const baseUrl = isLocal ? 'https://ai-geo-audit.vercel.app' : '';
                  const cleanPath = path.startsWith('/') ? path : `/${path}`;
                  return `${baseUrl}${cleanPath}`;
                });
                fetch(urlHelper(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDateStr}`))
                  .then(res => res.json())
                  .then(json => {
                    if (json.status === 'ok' && json.data) {
                      // Extract last GSC timeseries date from API response if available
                      if (json.timeseries && Array.isArray(json.timeseries) && json.timeseries.length > 0) {
                        const timeseriesDates = json.timeseries
                          .map(ts => ts.date)
                          .filter(date => date)
                          .sort()
                          .reverse();
                        if (timeseriesDates.length > 0) {
                          window.lastGscTimeseriesDate = timeseriesDates[0];
                          debugLog(`Money Pages Trend: Set last GSC timeseries date from API: ${window.lastGscTimeseriesDate}`, 'info');
                        }
                      } else {
                        debugLog(`Money Pages Trend: No timeseries data in API response`, 'warn');
                      }
                      
                      debugLog(`Money Pages Trend: About to render chart with ${json.data ? json.data.length : 0} history records`, 'info');
                      
                      requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                          const volumeCanvas = document.getElementById('moneyPagesVolumeChart');
                          const rateCanvas = document.getElementById('moneyPagesRateChart');
                          if (volumeCanvas && rateCanvas) {
                            const volumeRect = volumeCanvas.getBoundingClientRect();
                            const rateRect = rateCanvas.getBoundingClientRect();
                            debugLog(`Money Pages Trend: Canvas dimensions - Volume: ${volumeRect.width}x${volumeRect.height}, Rate: ${rateRect.width}x${rateRect.height}`, 'info');
                            if (volumeRect.width > 0 && volumeRect.height > 0 && rateRect.width > 0 && rateRect.height > 0) {
                              debugLog(`Money Pages Trend: Calling renderMoneyPagesTrendChart with ${json.data.length} records`, 'info');
                              renderMoneyPagesTrendChart(json.data);
                            } else {
                              debugLog(' Money Pages trend charts: Canvases still have zero dimensions, retrying...', 'warn');
                              // Set explicit dimensions and retry
                              [volumeCanvas, rateCanvas].forEach(canvas => {
                                canvas.width = canvas.offsetWidth || canvas.parentElement?.clientWidth || 800;
                                canvas.height = canvas.offsetHeight || 300;
                              });
                              setTimeout(() => {
                                const volumeRect2 = volumeCanvas.getBoundingClientRect();
                                const rateRect2 = rateCanvas.getBoundingClientRect();
                                if (volumeRect2.width > 0 && volumeRect2.height > 0 && rateRect2.width > 0 && rateRect2.height > 0) {
                                  renderMoneyPagesTrendChart(json.data);
                                } else {
                                  setTimeout(() => renderMoneyCharts(), 200);
                                }
                              }, 100);
                            }
                          } else {
                            debugLog(' Money Pages trend charts: Canvas elements not found', 'warn');
                          }
                        });
                      });
                    } else {
                      debugLog(` Money Pages trend chart: API returned error or no data. Status: ${json.status}`, 'warn');
                    }
                  })
                  .catch(err => {
                    debugLog(` Error fetching history for trend chart: ${err.message}`, 'error');
                    debugLog(`Money Pages trend chart fetch error details: ${err.stack || err.toString()}`, 'error');
                  });
              }
            }
            
            const sparklineCanvas = document.getElementById('money-kpi-sparkline');
            if (sparklineCanvas && typeof loadAuditHistoryAndRenderKpis === 'function') {
              const rect = sparklineCanvas.getBoundingClientRect();
              if (rect.width === 0 || rect.height === 0) {
                debugLog(' Money KPI sparkline: Canvas has zero dimensions, will retry', 'warn');
                setTimeout(renderMoneyCharts, 200);
                return;
              }
              
              const propertyUrl = document.getElementById('propertyUrl')?.value;
              if (propertyUrl) {
                requestAnimationFrame(() => {
                  requestAnimationFrame(() => {
                    const canvas = document.getElementById('money-kpi-sparkline');
                    if (canvas) {
                      const rect = canvas.getBoundingClientRect();
                      if (rect.width > 0 && rect.height > 0) {
                        loadAuditHistoryAndRenderKpis(propertyUrl);
                      } else {
                        debugLog(' Money KPI sparkline: Canvas still has zero dimensions, retrying...', 'warn');
                        setTimeout(() => renderMoneyCharts(), 200);
                      }
                    }
                  });
                });
              }
            }
            };
            
            // Start rendering charts with retry logic
            renderMoneyCharts();
          }, 300); // Wait 300ms to ensure HTML structure is created
          
          // Wire up KPI metric selector
          if (typeof window.wireMoneyKpiMetricSelector === 'function') {
            window.wireMoneyKpiMetricSelector();
          }
          
          if (typeof window.wireTopLevelFilter === 'function') {
            window.wireTopLevelFilter();
          }
          if (typeof window.wirePriorityActionsFilters === 'function') {
            window.wirePriorityActionsFilters();
          }
        }, 100);
      }

      // Mark panel as initialized
      panelInitDone.add(panelId);
    }

    // Fix ranking panel DOM structure - ensure sections are siblings, not nested
    function fixRankingPanelStructure() {
      const rankingPanel = document.querySelector('.aigeo-panel[data-panel="ranking"]');
      if (!rankingPanel) return;

      const sideBySide = rankingPanel.querySelector('.ranking-cards-side-by-side');
      const priority = rankingPanel.querySelector('#ranking-priority-matrix-section');
      const table = rankingPanel.querySelector('.ranking-table-section');
      const details = rankingPanel.querySelector('.ranking-details-grid');

      if (!sideBySide) return;

      // Check if sections are incorrectly nested inside side-by-side container
      const sideBySideChildren = Array.from(sideBySide.children);
      const needsFix = sideBySideChildren.includes(priority) || 
                       sideBySideChildren.includes(table) || 
                       sideBySideChildren.includes(details);

      if (needsFix) {
        // Move sections out of side-by-side container to be siblings
        if (priority && sideBySide.contains(priority)) {
          sideBySide.parentElement.insertBefore(priority, sideBySide.nextSibling);
        }
        if (table && sideBySide.contains(table)) {
          sideBySide.parentElement.insertBefore(table, priority?.nextSibling || sideBySide.nextSibling);
        }
        if (details && sideBySide.contains(details)) {
          sideBySide.parentElement.insertBefore(details, table?.nextSibling || priority?.nextSibling || sideBySide.nextSibling);
        }
      }

      // Ensure correct order: side-by-side, priority, table, details
      const allSections = [sideBySide, priority, table, details].filter(Boolean);
      allSections.forEach((section, index) => {
        if (section.parentElement === rankingPanel) {
          const currentIndex = Array.from(rankingPanel.children).indexOf(section);
          const expectedIndex = Array.from(rankingPanel.children).indexOf(allSections[0]) + index;
          if (currentIndex !== expectedIndex && expectedIndex >= 0) {
            rankingPanel.insertBefore(section, rankingPanel.children[expectedIndex] || null);
          }
        }
      });
    }

    function toggleCalculationExplanation() {
      const explanation = document.getElementById('calculationExplanation');
      const content = document.getElementById('calculationContent');
      const toggle = document.getElementById('calculationToggle');
      if (explanation.classList.contains('collapsed')) {
        explanation.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '';
      } else {
        explanation.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '';
      }
    }

    function toggleFrameworkExplanation() {
      const explanation = document.getElementById('frameworkExplanation');
      const content = document.getElementById('frameworkContent');
      const toggle = document.getElementById('frameworkToggle');
      if (!explanation || !content) return;
      if (explanation.classList.contains('collapsed')) {
        explanation.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '';
      } else {
        explanation.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '';
      }
    }
    
    window.toggleCsvSection = function(sectionId) {
      const section = document.getElementById(sectionId);
      const contentId = sectionId === 'urlListSection' ? 'urlListContent' : 'backlinkCsvContentWrapper';
      const toggleId = sectionId === 'urlListSection' ? 'urlListToggle' : 'backlinkCsvToggle';
      const content = document.getElementById(contentId);
      const toggle = document.getElementById(toggleId);
      
      if (section.classList.contains('collapsed')) {
        section.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '';
      } else {
        section.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '';
      }
    }

    // Debug panel is always visible at bottom, start collapsed by default
    window.addEventListener('DOMContentLoaded', () => {
      const debugPanel = document.getElementById('debugPanel');
      const debugToggleIcon = document.getElementById('debugToggleIcon');
      if (debugPanel) {
        debugPanel.style.display = 'flex';
        // Start collapsed by default
        debugPanel.classList.add('collapsed');
        if (debugToggleIcon) {
          debugToggleIcon.textContent = '';
        }
      }
    });

    // Initialize Money Pages Priority Matrix global state early
    window.moneyPagePriorityData = window.moneyPagePriorityData || [];
    window.moneySegmentMetrics = window.moneySegmentMetrics || null;
    window.moneyMatrixFilterState = window.moneyMatrixFilterState || { impact: null, diff: null };
    
    // Verify RankingAiModule is available
    if (typeof window.RankingAiModule === 'undefined') {
      debugLog(' RankingAiModule not found in window on page load', 'warn');
    } else {
      debugLog(' RankingAiModule verified on page load', 'success');
    }

    // Fix ranking panel structure on page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(fixRankingPanelStructure, 100);
      });
    } else {
      setTimeout(fixRankingPanelStructure, 100);
    }

    // Load saved configuration
    async function loadConfig() {
      debugLog('=== PAGE LOAD: Starting configuration load ===', 'info');
      
      // Check if Chart.js is loaded
      debugLog('Checking Chart.js library...', 'info');
      if (typeof Chart !== 'undefined') {
        debugLog(' Chart.js library loaded successfully', 'success');
      } else {
        debugLog(' Chart.js library NOT loaded', 'error');
      }
      
      // Try to fetch API key from Vercel environment variable (via API endpoint)
      let vercelApiKey = null;
      try {
        debugLog('Checking Vercel environment variable...', 'info');
        const response = await fetch(apiUrl('/api/get-api-key'));
        if (response.ok) {
          const data = await response.json();
          if (data.apiKey) {
            vercelApiKey = data.apiKey;
            debugLog(' API key loaded from Vercel environment variable', 'success');
          }
        }
      } catch (e) {
        debugLog('Vercel env var endpoint not available (expected for static site)', 'info');
      }
      
      // Check config.js
      debugLog('Checking for config.js...', 'info');
      if (window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey) {
        debugLog(' config.js found with API key', 'success');
      } else {
        debugLog(' config.js not found or no API key', 'warn');
      }
      
      // Check localStorage
      debugLog('Checking localStorage...', 'info');
      const configApiKey = window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey;
      const apiKey = vercelApiKey || configApiKey || localStorage.getItem('gsc_api_key');
      const propertyUrl = localStorage.getItem('gsc_property_url');
      const dateRange = localStorage.getItem('gsc_date_range');
      
      const apiKeySource = vercelApiKey ? 'Vercel env var' : configApiKey ? 'config.js' : localStorage.getItem('gsc_api_key') ? 'localStorage' : 'none';
      debugLog(`API Key source: ${apiKeySource}`, 'info');
      debugLog(`Property URL: ${propertyUrl || 'not set'}`, 'info');
      debugLog(`Date Range: ${dateRange || 'not set'}`, 'info');
      
      if (apiKey) {
        debugLog(' API key loaded from environment', 'success');
        // Store in a hidden variable for use in runAudit
        window._loadedApiKey = apiKey;
      } else {
        debugLog(' No API key found', 'warn');
      }
      
      if (propertyUrl) {
        document.getElementById('propertyUrl').value = propertyUrl;
        debugLog(' Property URL loaded', 'success');
      }
      if (dateRange) {
        document.getElementById('dateRange').value = dateRange;
        // Set active button based on saved date range
        const savedDays = parseInt(dateRange);
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          btn.classList.remove('active');
          const btnDays = parseInt(btn.getAttribute('data-days'));
          if (btnDays === savedDays) {
            btn.classList.add('active');
          }
        });
        // If no preset matches, show custom
        const presetDays = [7, 30, 90, 180, 365];
        if (!presetDays.includes(savedDays)) {
          document.getElementById('customDateBtn').classList.add('active');
          document.getElementById('customDays').value = savedDays;
          document.getElementById('customDateRange').style.display = 'block';
        }
        debugLog(' Date range loaded', 'success');
      }
      
      // Load manual URL list if saved
      const savedUrlList = localStorage.getItem('manual_url_list');
      if (savedUrlList) {
        try {
          const urls = JSON.parse(savedUrlList);
          const statusDiv = document.getElementById('urlListStatus');
          if (statusDiv) {
            statusDiv.innerHTML = `<span style="color: #10b981;"> ${urls.length} URLs loaded from saved list</span>`;
          }
          debugLog(` Manual URL list loaded: ${urls.length} URLs`, 'success');
        } catch (e) {
          debugLog(' Failed to load saved URL list', 'warn');
        }
      }
      
      // Load backlink CSV content if saved
      const savedBacklinkCsv = localStorage.getItem('backlink_csv_content');
      if (savedBacklinkCsv) {
        const textarea = document.getElementById('backlinkCsvContent');
        if (textarea) {
          textarea.value = savedBacklinkCsv;
        }
        // Check if backlink metrics are already uploaded
        try {
          const backlinkResponse = await fetch(apiUrl('/api/aigeo/backlink-metrics'));
          if (backlinkResponse.ok) {
            const backlinkData = await backlinkResponse.json();
            if (backlinkData.status === 'ok' && backlinkData.data && backlinkData.data.totalBacklinks > 0) {
              const metrics = backlinkData.data;
              const statusDiv = document.getElementById('backlinkCsvStatus');
              if (statusDiv) {
                statusDiv.innerHTML = `<span style="color: #10b981;"> Backlink CSV loaded: ${metrics.referringDomains} domains, ${metrics.totalBacklinks} links</span>`;
              }
              debugLog(` Backlink CSV already uploaded: ${metrics.referringDomains} domains`, 'success');
            }
          }
        } catch (e) {
          // Ignore errors - backlink metrics may not be uploaded yet
        }
      }
      
      debugLog('=== Configuration load complete ===', 'info');
    }

    // Save configuration
    // Date range selector functions
    function setDateRange(days) {
      const oldDateRange = parseInt(document.getElementById('dateRange').value) || 30;
      document.getElementById('dateRange').value = days;
      localStorage.setItem('gsc_date_range', days);
      
      // Update active button
      document.querySelectorAll('.date-range-btn').forEach(btn => {
        btn.classList.remove('active');
        const btnDays = parseInt(btn.getAttribute('data-days'));
        if (btnDays === days) {
          btn.classList.add('active');
        }
      });
      
      // Hide custom input if showing
      document.getElementById('customDateRange').style.display = 'none';
      document.getElementById('customDateBtn').classList.remove('active');
      
      debugLog(`Date range set to ${days} days`, 'info');
      
      // Check if saved audit exists and if its date range matches
      const savedAudit = loadAuditResultsSync();
      if (savedAudit && savedAudit.scores) {
        const savedDateRange = savedAudit.dateRange || oldDateRange;
        // Always update if date range changed (even if going back to a previous range)
        // This ensures charts refresh properly when switching between ranges
        if (savedDateRange !== days) {
          // Date range changed - update GSC data and recalculate scores
          debugLog(`Date range changed from ${savedDateRange} to ${days} days. Updating metrics...`, 'info');
          updateAuditForNewDateRange(days, savedAudit);
        } else {
          // Date range matches, but force refresh to ensure charts are updated
          // This handles the case where user switches back to the same range
          debugLog(`Date range is already ${days} days, but refreshing charts to ensure they're up to date...`, 'info');
          // Force a refresh by calling displayDashboard with current data
          if (savedAudit.scores && savedAudit.searchData) {
            displayDashboard(savedAudit.scores, savedAudit.searchData, savedAudit.snippetReadiness, savedAudit.schemaAudit, savedAudit.localSignals);
          }
        }
      }
    }

    function showCustomDateRange() {
      const customDiv = document.getElementById('customDateRange');
      const customBtn = document.getElementById('customDateBtn');
      
      if (customDiv.style.display === 'none') {
        customDiv.style.display = 'block';
        customBtn.classList.add('active');
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          if (btn !== customBtn) btn.classList.remove('active');
        });
      } else {
        customDiv.style.display = 'none';
        customBtn.classList.remove('active');
      }
    }

    function applyCustomDateRange() {
      const customDays = parseInt(document.getElementById('customDays').value);
      if (customDays && customDays > 0) {
        const oldDateRange = parseInt(document.getElementById('dateRange').value) || 30;
        document.getElementById('dateRange').value = customDays;
        localStorage.setItem('gsc_date_range', customDays);
        document.getElementById('customDateRange').style.display = 'none';
        document.getElementById('customDateBtn').classList.remove('active');
        debugLog(`Custom date range set to ${customDays} days`, 'info');
        
        // Check if saved audit exists and if its date range matches
        const savedAudit = loadAuditResultsSync();
        if (savedAudit && savedAudit.scores) {
          const savedDateRange = savedAudit.dateRange || oldDateRange;
          if (savedDateRange !== customDays) {
            // Date range changed - update GSC data and recalculate scores
            debugLog(`Date range changed from ${savedDateRange} to ${customDays} days. Updating metrics...`, 'info');
            updateAuditForNewDateRange(customDays, savedAudit);
          }
        }
      } else {
        showStatus('Please enter a valid number of days', 'error');
      }
    }

    function saveConfig() {
      localStorage.setItem('gsc_api_key', document.getElementById('apiKey').value);
      localStorage.setItem('gsc_property_url', document.getElementById('propertyUrl').value);
      localStorage.setItem('gsc_date_range', document.getElementById('dateRange').value);
      showStatus('Configuration saved!', 'success');
    }

    window.shareAudit = async function shareAudit() {
      // Check if admin key is set
      const adminKey = window.getAdminKey();
      if (!adminKey) {
        alert('Admin key required. Please set your admin key in the "Optimisation Tracking Security" section.');
        return;
      }

      try {
        // Call share create endpoint
        const response = await fetch(apiUrl('/api/share/create'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-arp-admin-key': adminKey
          },
          body: JSON.stringify({
            expiryDays: 30 // Default to 30 days
          })
        });

        if (!response.ok) {
          let errorMessage = `HTTP ${response.status}`;
          try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorMessage;
          } catch (e) {
            // If JSON parsing fails, try to get text
            try {
              const text = await response.text();
              errorMessage = text || errorMessage;
            } catch (e2) {
              // If that fails too, use status
              errorMessage = `HTTP ${response.status}: ${response.statusText || 'Unknown error'}`;
            }
          }
          throw new Error(errorMessage);
        }

        const data = await response.json();
        const shareUrl = data.shareUrl;
        const expiresAt = data.expiresAt ? new Date(data.expiresAt).toLocaleDateString('en-GB') : 'Unknown';

        // Show share URL in a prompt for easy copying
        const message = `Share URL created!\n\nExpires: ${expiresAt}\n\nShare URL:\n${shareUrl}\n\nClick OK to copy to clipboard.`;
        if (confirm(message)) {
          // Copy to clipboard
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(shareUrl);
            showStatus('Share URL copied to clipboard!', 'success');
          } else {
            // Fallback: select text
            const textarea = document.createElement('textarea');
            textarea.value = shareUrl;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
              document.execCommand('copy');
              showStatus('Share URL copied to clipboard!', 'success');
            } catch (e) {
              showStatus('Share URL created. Please copy it manually.', 'info');
            }
            document.body.removeChild(textarea);
          }
        }
      } catch (error) {
        console.error('[Share Audit] Error:', error);
        alert(`Failed to create share URL: ${error.message}`);
      }
    }

    // Parse CSV and validate column names
    function parseUrlListCsv(csvText) {
      const lines = csvText.split('\n').filter(line => line.trim());
      if (lines.length === 0) {
        throw new Error('CSV is empty');
      }
      
      // Parse header row
      const headerLine = lines[0].trim();
      const headers = headerLine.split(',').map(h => h.trim().replace(/^"|"$/g, '').toLowerCase());
      
      // Check for required 'url' column
      const urlColumnIndex = headers.findIndex(h => h === 'url');
      if (urlColumnIndex === -1) {
        throw new Error(`Required column 'url' not found. Found columns: ${headers.join(', ')}`);
      }
      
      // Extract URLs from the 'url' column
      const urls = [];
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        // Parse CSV line (handle quoted values)
        const columns = [];
        let current = '';
        let inQuotes = false;
        
        for (let j = 0; j < line.length; j++) {
          const char = line[j];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            columns.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        columns.push(current.trim()); // Add last column
        
        // Extract URL from the url column
        if (columns[urlColumnIndex]) {
          const url = columns[urlColumnIndex].replace(/^"|"$/g, '').trim();
          if (url && url.startsWith('http')) {
            urls.push(url);
          }
        }
      }
      
      return {
        headers,
        urls,
        totalRows: lines.length - 1,
        validUrls: urls.length
      };
    }

    // Load URL list from file input
    async function loadUrlListFromFile() {
      const fileInput = document.getElementById('urlListFile');
      const statusDiv = document.getElementById('urlListStatus');
      const textarea = document.getElementById('manualUrlList');
      
      if (!fileInput.files || fileInput.files.length === 0) {
        // If no file, try to parse from textarea
        const csvText = textarea.value.trim();
        if (!csvText) {
          statusDiv.innerHTML = '<span style="color: #ef4444;"> Please select a CSV file or paste CSV content</span>';
          return;
        }
        
        try {
          const result = parseUrlListCsv(csvText);
          localStorage.setItem('manual_url_list', JSON.stringify(result.urls));
          statusDiv.innerHTML = `<span style="color: #10b981;"> Loaded ${result.validUrls} URLs from ${result.totalRows} rows</span>`;
          debugLog(` Manual URL list loaded: ${result.validUrls} URLs from CSV`, 'success');
          showStatus(`URL list loaded! Found ${result.validUrls} URLs.`, 'success');
        } catch (error) {
          statusDiv.innerHTML = `<span style="color: #ef4444;"> ${error.message}</span>`;
          debugLog(` URL list parse error: ${error.message}`, 'error');
          showStatus(`URL list error: ${error.message}`, 'error');
        }
        return;
      }
      
      const file = fileInput.files[0];
      debugLog(`Loading URL list from file: ${file.name} (${file.size} bytes)`, 'info');
      
      try {
        const fileText = await file.text();
        const result = parseUrlListCsv(fileText);
        
        // Store URLs in localStorage
        localStorage.setItem('manual_url_list', JSON.stringify(result.urls));
        
        // Also populate textarea with the CSV content
        textarea.value = fileText;
        
        statusDiv.innerHTML = `<span style="color: #10b981;"> Loaded ${result.validUrls} URLs from ${result.totalRows} rows. Columns: ${result.headers.join(', ')}</span>`;
        debugLog(` URL list loaded from file: ${result.validUrls} URLs`, 'success');
        debugLog(`  File: ${file.name}, Columns: ${result.headers.join(', ')}`, 'info');
        showStatus(`URL list loaded! Found ${result.validUrls} URLs from ${file.name}.`, 'success');
        
        // Clear file input
        fileInput.value = '';
      } catch (error) {
        statusDiv.innerHTML = `<span style="color: #ef4444;"> ${error.message}</span>`;
        debugLog(` URL list file error: ${error.message}`, 'error');
        showStatus(`URL list error: ${error.message}`, 'error');
      }
    }

    // Clear manual URL list
    function clearManualUrlList() {
      const textarea = document.getElementById('manualUrlList');
      const fileInput = document.getElementById('urlListFile');
      const statusDiv = document.getElementById('urlListStatus');
      
      textarea.value = '';
      fileInput.value = '';
      localStorage.removeItem('manual_url_list');
      statusDiv.innerHTML = '<span style="color: #666;">Manual URL list cleared</span>';
      debugLog('Manual URL list cleared', 'info');
      showStatus('Manual URL list cleared', 'success');
    }

    // Load backlink CSV from file (wrapper for uploadBacklinkCsv)
    async function loadBacklinkCsvFromFile() {
      return await uploadBacklinkCsv();
    }

    // Upload backlink CSV file
    async function uploadBacklinkCsv() {
      const fileInput = document.getElementById('backlinkCsvFile');
      const statusDiv = document.getElementById('backlinkCsvStatus');
      const textarea = document.getElementById('backlinkCsvContent');
      
      let csvContent = '';
      
      if (fileInput.files && fileInput.files.length > 0) {
        const file = fileInput.files[0];
        debugLog(`Uploading backlink CSV from file: ${file.name} (${file.size} bytes)`, 'info');
        
        try {
          csvContent = await file.text();
          // Also populate textarea with the CSV content
          textarea.value = csvContent;
        } catch (error) {
          statusDiv.innerHTML = `<span style="color: #ef4444;"> Error reading file: ${error.message}</span>`;
          debugLog(` Backlink CSV file read error: ${error.message}`, 'error');
          showStatus(`Backlink CSV error: ${error.message}`, 'error');
          return;
        }
      } else {
        // If no file, try to get from textarea
        csvContent = textarea.value.trim();
        if (!csvContent) {
          statusDiv.innerHTML = '<span style="color: #ef4444;"> Please select a CSV file or paste CSV content</span>';
          return;
        }
      }

      if (!csvContent) {
        statusDiv.innerHTML = '<span style="color: #ef4444;"> No CSV content to upload</span>';
        return;
      }

      // Validate CSV has required columns
      const lines = csvContent.split('\n').filter(line => line.trim());
      if (lines.length === 0) {
        statusDiv.innerHTML = '<span style="color: #ef4444;"> CSV is empty</span>';
        return;
      }

      const headerLine = lines[0].trim();
      const headers = headerLine.split(',').map(h => h.trim().replace(/^"|"$/g, ''));
      
      // More flexible column matching - check for URL column (required) and Link Type (optional)
      const hasUrlColumn = headers.some(h => {
        const lower = h.toLowerCase();
        return (lower.includes('linking') && lower.includes('url')) ||
               lower.includes('url') ||
               lower.includes('source url') ||
               lower.includes('page url');
      });
      
      const hasLinkType = headers.some(h => {
        const lower = h.toLowerCase();
        return lower.includes('link type') ||
               lower.includes('type') ||
               lower.includes('follow');
      });
      
      if (!hasUrlColumn) {
        statusDiv.innerHTML = `<span style="color: #ef4444;"> Missing URL column. Found columns: ${headers.join(', ')}. Need a column containing 'URL' or 'Linking Page + URL'</span>`;
        debugLog(` Backlink CSV missing URL column. Found: ${headers.join(', ')}`, 'error');
        return;
      }
      
      if (!hasLinkType) {
        statusDiv.innerHTML = `<span style="color: #ef4444;"> Missing Link Type column. Found columns: ${headers.join(', ')}. The Link Type column is required to calculate the follow ratio for the Authority score.</span>`;
        debugLog(` Backlink CSV missing Link Type column. Found: ${headers.join(', ')}`, 'error');
        return;
      }

      // Upload to API
      try {
        statusDiv.innerHTML = '<span style="color: #666;"> Uploading and processing backlink CSV...</span>';
        debugLog('Uploading backlink CSV to API...', 'info');
        
        // Send CSV as JSON since Vercel doesn't parse text/csv automatically
        const response = await fetch(apiUrl('/api/aigeo/backlink-metrics'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ csv: csvContent })
        });

        if (!response.ok) {
          let errorMessage = `HTTP ${response.status}`;
          try {
            const errorData = await response.json();
            errorMessage = errorData.message || errorData.error || errorMessage;
            debugLog(`API error response: ${JSON.stringify(errorData)}`, 'error');
          } catch (e) {
            // If response is not JSON, try to get text
            try {
              const errorText = await response.text();
              if (errorText) {
                errorMessage = errorText.substring(0, 200);
              }
            } catch (e2) {
              // Ignore
            }
          }
          throw new Error(errorMessage);
        }

        const result = await response.json();
        debugLog(`API response: ${JSON.stringify(result).substring(0, 200)}...`, 'info');
        
        if (result.status === 'ok' && result.data) {
          const metrics = result.data;
          statusDiv.innerHTML = `<span style="color: #10b981;"> Backlink CSV uploaded successfully! Found ${metrics.referringDomains} referring domains, ${metrics.totalBacklinks} backlinks, ${Math.round(metrics.followRatio * 100)}% follow ratio</span>`;
          debugLog(` Backlink CSV uploaded: ${metrics.referringDomains} domains, ${metrics.totalBacklinks} links, ${(metrics.followRatio * 100).toFixed(1)}% follow`, 'success');
          showStatus(`Backlink CSV uploaded! ${metrics.referringDomains} referring domains found.`, 'success');
          
          // Store in localStorage for persistence
          localStorage.setItem('backlink_csv_content', csvContent);
          localStorage.setItem('backlink_metrics', JSON.stringify(metrics));
          debugLog(` Backlink metrics stored in localStorage`, 'success');
        } else {
          // Error response - log debug info to UI
          const errorMsg = result.message || result.error || 'Upload failed - invalid response format';
          statusDiv.innerHTML = `<span style="color: #ef4444;"> ${errorMsg}</span>`;
          debugLog(` Backlink CSV upload error: ${errorMsg}`, 'error');
          
          // Log debug info if available
          if (result.debug) {
            debugLog(`[DEBUG] CSV Length: ${result.debug.csvLength || 'N/A'}`, 'info');
            debugLog(`[DEBUG] Logical Lines: ${result.debug.logicalLines || 'N/A'}`, 'info');
            debugLog(`[DEBUG] Headers Found: ${result.debug.headers ? result.debug.headers.join(', ') : 'N/A'}`, 'info');
            if (result.debug.firstChars) {
              debugLog(`[DEBUG] First 500 chars: ${result.debug.firstChars}`, 'info');
            }
            if (result.debug.rowCount !== undefined) {
              debugLog(`[DEBUG] Rows parsed: ${result.debug.rowCount}`, 'info');
            }
            if (result.debug.firstRowKeys) {
              debugLog(`[DEBUG] First row keys: ${result.debug.firstRowKeys.join(', ')}`, 'info');
            }
            if (result.debug.error) {
              debugLog(`[DEBUG] Error details: ${result.debug.error}`, 'error');
            }
          }
          
          // Also log full error response for debugging
          debugLog(`[DEBUG] Full error response: ${JSON.stringify(result, null, 2)}`, 'error');
          showStatus(`Backlink CSV error: ${errorMsg}`, 'error');
        }
      } catch (error) {
        const errorMsg = error.message || error.toString() || 'Unknown error';
        statusDiv.innerHTML = `<span style="color: #ef4444;"> ${errorMsg}</span>`;
        debugLog(` Backlink CSV upload error: ${errorMsg}`, 'error');
        debugLog(`Error stack: ${error.stack || 'No stack trace'}`, 'error');
        showStatus(`Backlink CSV error: ${errorMsg}`, 'error');
      }
    }

    // Clear backlink CSV
    function clearBacklinkCsv() {
      const textarea = document.getElementById('backlinkCsvContent');
      const fileInput = document.getElementById('backlinkCsvFile');
      const statusDiv = document.getElementById('backlinkCsvStatus');
      
      textarea.value = '';
      fileInput.value = '';
      localStorage.removeItem('backlink_csv_content');
      statusDiv.innerHTML = '<span style="color: #666;">Backlink CSV cleared</span>';
      debugLog('Backlink CSV cleared', 'info');
      showStatus('Backlink CSV cleared', 'success');
    }

    // Sync CSV from alan-shared-resources
    async function syncCSV() {
      const btn = document.getElementById('syncCsvBtn');
      const btnText = document.getElementById('syncCsvBtnText');
      const originalText = btnText.textContent;
      
      debugLog('=== CSV SYNC: Starting CSV sync verification ===', 'info');
      debugLog('Button clicked - initiating CSV sync check...', 'info');
      
      // Disable button and show loading state
      btn.disabled = true;
      btnText.textContent = ' Syncing...';
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      debugLog('Button state: disabled, showing loading indicator', 'info');
      
      try {
        debugLog('Fetching /api/sync-csv endpoint...', 'info');
        const response = await fetch(apiUrl('/api/sync-csv'), {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
        });
        
        debugLog(`API response status: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
        
        const data = await response.json();
        debugLog(`API response data: ${JSON.stringify(data).substring(0, 200)}...`, 'info');
        
        if (response.ok && data.status === 'ok') {
          const urlCount = data.data.totalUrls || 0;
          const source = data.source || 'unknown';
          
          debugLog(` CSV fetched successfully from ${source}`, 'success');
          debugLog(`  CSV URL: ${data.csvUrl || 'not provided'}`, 'info');
          debugLog(`  Total URLs fetched: ${urlCount}`, 'success');
          debugLog(`  CSV size: ${data.data.csvSize} bytes`, 'info');
          debugLog(`  Lines processed: ${data.data.linesProcessed || 'N/A'}`, 'info');
          debugLog(`  Fetched at: ${data.data.fetchedAt}`, 'info');
          
          // Show toast with URL count
          showStatus(` CSV synced from ${source}! Fetched ${urlCount} URLs.`, 'success');
          btnText.textContent = ` ${urlCount} URLs`;
          
          // Reset button after 3 seconds
          setTimeout(() => {
            btnText.textContent = originalText;
            btn.style.opacity = '1';
            debugLog('Button reset to original state', 'info');
          }, 3000);
        } else {
          debugLog(` CSV sync failed`, 'error');
          debugLog(`  Error message: ${data.message || 'Unknown error'}`, 'error');
          debugLog(`  CSV URL attempted: ${data.csvUrl || 'not provided'}`, 'error');
          if (data.suggestion) {
            debugLog(`  Suggestion: ${data.suggestion}`, 'warn');
          }
          showStatus(`CSV sync failed: ${data.message}. ${data.suggestion || ''}`, 'error');
          btnText.textContent = ' Sync Failed';
          
          // Reset button after 5 seconds
          setTimeout(() => {
            btnText.textContent = originalText;
            btn.style.opacity = '1';
            debugLog('Button reset to original state after error', 'info');
          }, 5000);
        }
      } catch (error) {
        debugLog(` CSV sync error occurred`, 'error');
        debugLog(`  Error type: ${error.name || 'Unknown'}`, 'error');
        debugLog(`  Error message: ${error.message}`, 'error');
        if (error.stack) {
          debugLog(`  Stack trace: ${error.stack.substring(0, 300)}...`, 'error');
        }
        showStatus(`CSV sync error: ${error.message}. Please run "npm run sync:csv" locally.`, 'error');
        btnText.textContent = ' Error';
        
        // Reset button after 5 seconds
        setTimeout(() => {
          btnText.textContent = originalText;
          btn.style.opacity = '1';
          debugLog('Button reset to original state after exception', 'info');
        }, 5000);
      } finally {
        btn.disabled = false;
        btn.style.cursor = 'pointer';
        debugLog('=== CSV SYNC: Complete ===', 'info');
      }
    }

    // Update progress bar
    function updateProgress(percent, statusText) {
      const progressBar = document.getElementById('progressBar');
      const progressStatus = document.getElementById('progressStatus');
      if (progressBar) {
        progressBar.style.width = Math.min(100, Math.max(0, percent)) + '%';
        progressBar.textContent = Math.round(percent) + '%';
      }
      if (progressStatus) {
        progressStatus.textContent = statusText || 'Processing...';
      }
    }

    // Show status message
    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = `status ${type} show`;
      setTimeout(() => {
        status.classList.remove('show');
      }, 5000);
    }

    // Show completion summary modal
    function showCompletionModal(schemaAudit) {
      debugLog('showCompletionModal called', 'info');
      const modal = document.getElementById('completionModal');
      const content = document.getElementById('completionSummaryContent');
      
      debugLog(`Modal element found: ${modal ? 'yes' : 'no'}`, 'info');
      debugLog(`Content element found: ${content ? 'yes' : 'no'}`, 'info');
      
      if (!modal || !content) {
        debugLog(' Modal or content element not found, cannot show modal', 'error');
        return;
      }
      
      let html = '';
      
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const data = schemaAudit.data;
        const meta = schemaAudit.meta || {};
        const diag = meta.diagnostic || {};
        
        const totalPages = data.totalPages || diag.totalPages || 0;
        const successfulPages = diag.successfulPages || (totalPages - (data.missingSchemaCount || 0));
        const failedPages = diag.failedPages || data.missingSchemaCount || 0;
        const isComplete = failedPages === 0;
        
        html += `<div style="margin-bottom: 1.5rem;">`;
        html += `<div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">`;
        html += `<span style="font-size: 2rem;">${isComplete ? '' : ''}</span>`;
        html += `<h3 style="margin: 0; color: ${isComplete ? '#10b981' : '#f59e0b'};">
          ${isComplete ? 'Complete' : 'Incomplete'} Data
        </h3>`;
        html += `</div>`;
        
        html += `<div style="background: ${isComplete ? '#f0fdf4' : '#fffbeb'}; border-left: 4px solid ${isComplete ? '#10b981' : '#f59e0b'}; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">`;
        html += `<p style="margin: 0; color: #555; line-height: 1.6;">`;
        if (isComplete) {
          html += `All pages were successfully crawled. Dashboard data is complete and accurate.`;
        } else {
          html += `<strong>Warning:</strong> ${failedPages} page${failedPages !== 1 ? 's' : ''} failed to crawl. Dashboard data may be incomplete. Failed pages are counted as missing schema.`;
        }
        html += `</p>`;
        html += `</div>`;
        
        html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">`;
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Total URLs Scanned</div>`;
        html += `<div style="font-size: 1.5rem; font-weight: 600; color: #333;">${totalPages}</div>`;
        html += `</div>`;
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Successful Crawls</div>`;
        html += `<div style="font-size: 1.5rem; font-weight: 600; color: #10b981;">${successfulPages}</div>`;
        html += `</div>`;
        html += `</div>`;
        
        if (failedPages > 0) {
          // Get failed URLs from missingSchemaPages that have errors
          const failedUrls = (data.missingSchemaPages || []).filter(p => p.error).map(p => p.url);
          
          html += `<div style="background: #fef2f2; border-left: 4px solid #ef4444; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">`;
          html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Failed Crawls</div>`;
          html += `<div style="font-size: 1.5rem; font-weight: 600; color: #ef4444;">${failedPages}</div>`;
          
          if (diag.errorTypes && Object.keys(diag.errorTypes).length > 0) {
            html += `<div style="margin-top: 0.75rem; font-size: 0.85rem; color: #666;">`;
            html += `<strong>Error Breakdown:</strong><br>`;
            Object.entries(diag.errorTypes).forEach(([type, count]) => {
              html += `${type}: ${count}<br>`;
            });
            html += `</div>`;
          }
          
          // Add retry button if there are failed URLs
          if (failedUrls.length > 0) {
            html += `<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #fee2e2;">`;
            html += `<button id="retryFailedUrls" class="btn" style="background: #10b981; color: white; border-color: #10b981; width: 100%;" title="Retry crawling the ${failedUrls.length} failed URLs. This will rescan only the URLs that failed during the initial audit.">`;
            html += ` Retry Failed URLs (${failedUrls.length})`;
            html += `</button>`;
            html += `<div style="font-size: 0.8rem; color: #666; margin-top: 0.5rem; text-align: center;">Click to rescan only the failed URLs</div>`;
            html += `</div>`;
          }
          
          html += `</div>`;
        }
        
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px; margin-top: 1rem;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;"><strong>Schema Coverage</strong></div>`;
        // Ensure coverage is a number, not an object
        const coverageValue = typeof data.coverage === 'number' && !isNaN(data.coverage) 
          ? data.coverage 
          : (() => {
              // Calculate from pagesWithSchema and totalPages if coverage is not a number
              const pagesWithSchemaCount = Array.isArray(data.pagesWithSchema) 
                ? data.pagesWithSchema.length 
                : (typeof data.pagesWithSchema === 'number' ? data.pagesWithSchema : 0);
              const totalPagesCount = typeof data.totalPages === 'number' ? data.totalPages : totalPages;
              return totalPagesCount > 0 ? ((pagesWithSchemaCount / totalPagesCount) * 100) : 0;
            })();
        html += `<div style="font-size: 1.25rem; font-weight: 600; color: #333;">${coverageValue.toFixed(1)}%</div>`;
        const pagesWithSchemaCount = Array.isArray(data.pagesWithSchema) 
          ? data.pagesWithSchema.length 
          : (typeof data.pagesWithSchema === 'number' ? data.pagesWithSchema : 0);
        html += `<div style="font-size: 0.85rem; color: #666; margin-top: 0.25rem;">${pagesWithSchemaCount} pages with inline schema</div>`;
        
        // Display schema types if available, properly formatted
        if (data.schemaTypes && Array.isArray(data.schemaTypes) && data.schemaTypes.length > 0) {
          const formattedTypes = data.schemaTypes
            .filter(t => t !== null && t !== undefined)
            .map(t => {
              if (typeof t === 'string') return t;
              if (t && typeof t === 'object' && t.type && typeof t.type === 'string') return t.type;
              return null;
            })
            .filter(t => t !== null && typeof t === 'string')
            .slice(0, 10)
            .join(', ');
          if (formattedTypes) {
            html += `<div style="font-size: 0.75rem; color: #666; margin-top: 0.5rem; line-height: 1.4;">Schema types: ${formattedTypes}${data.schemaTypes.length > 10 ? '...' : ''}</div>`;
          }
        }
        html += `</div>`;
        
        html += `</div>`;
      } else {
        // Provide more helpful error message
        let errorMsg = 'Unable to load audit summary data.';
        if (!schemaAudit) {
          errorMsg = 'Schema audit data is missing. The audit may have failed or data was not saved properly.';
        } else if (schemaAudit.status !== 'ok') {
          errorMsg = `Schema audit failed with status: ${schemaAudit.status}. ${schemaAudit.error || schemaAudit.message || ''}`;
        } else if (!schemaAudit.data) {
          errorMsg = 'Schema audit completed but data is missing. Please check the console for errors.';
        }
        html += `<div style="background: #fef2f2; border-left: 4px solid #ef4444; padding: 1rem; border-radius: 4px;">`;
        html += `<p style="margin: 0; color: #991b1b; line-height: 1.6;">${errorMsg}</p>`;
        html += `<p style="margin: 0.5rem 0 0 0; font-size: 0.85rem; color: #666;">Check the debug log at the bottom of the page for more details.</p>`;
        html += `</div>`;
        debugLog(` Completion modal error: schemaAudit=${!!schemaAudit}, status=${schemaAudit?.status}, hasData=${!!schemaAudit?.data}, hasMeta=${!!schemaAudit?.meta}`, 'warn');
      }
      
      content.innerHTML = html;
      modal.style.display = 'block';
      debugLog('Modal display set to block', 'info');
      debugLog(`Modal is now visible: ${modal.style.display}`, 'info');
      
      // Attach retry button handler if it exists
      const retryButton = document.getElementById('retryFailedUrls');
      if (retryButton) {
        retryButton.onclick = function() {
          retryFailedUrls(schemaAudit);
        };
      }
    }
    
    // Retry failed URLs from schema audit
    async function retryFailedUrls(schemaAudit) {
      if (!schemaAudit || !schemaAudit.data || !schemaAudit.data.missingSchemaPages) {
        debugLog(' No failed URLs to retry', 'error');
        showStatus('No failed URLs found to retry', 'error');
        return;
      }
      
      // Extract failed URLs (those with errors)
      const failedUrls = schemaAudit.data.missingSchemaPages
        .filter(p => p.error)
        .map(p => p.url);
      
      if (failedUrls.length === 0) {
        debugLog(' No failed URLs to retry', 'error');
        showStatus('No failed URLs found to retry', 'error');
        return;
      }
      
      debugLog(` Retrying ${failedUrls.length} failed URLs...`, 'info');
      showStatus(`Retrying ${failedUrls.length} failed URLs...`, 'info');
      
      // Close the modal
      closeCompletionModal();
      
      // Show loading indicator
      document.getElementById('loading').classList.add('show');
      document.getElementById('dashboard').style.display = 'none';
      updateProgress(0, `Retrying ${failedUrls.length} failed URLs...`);
      
      try {
        updateProgress(20, 'Scanning failed URLs for schema markup...');
        debugLog(`Sending retry request for ${failedUrls.length} URLs`, 'info');
        
        // Call schema-audit API with only the failed URLs
        const schemaResponse = await fetch(apiUrl('/api/schema-audit'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ urls: failedUrls })
        });
        
        if (!schemaResponse.ok) {
          throw new Error(`Schema audit API returned error: ${schemaResponse.status}`);
        }
        
        const retrySchemaAudit = await schemaResponse.json();
        
        if (retrySchemaAudit.status !== 'ok') {
          throw new Error(retrySchemaAudit.message || 'Schema audit failed');
        }
        
        const retryData = retrySchemaAudit.data;
        const retrySuccessful = retryData.pagesWithSchema || 0;
        const retryStillFailed = (retryData.missingSchemaCount || 0);
        
        debugLog(` Retry completed: ${retrySuccessful} pages now have schema, ${retryStillFailed} still failed`, 'success');
        updateProgress(60, 'Merging retry results with original audit...');
        
        // Load original audit results from localStorage or Supabase
        const savedAudit = await loadAuditResults();
        if (savedAudit && savedAudit.schemaAudit && savedAudit.schemaAudit.data) {
          // Merge retry results with original schema audit
          const originalData = savedAudit.schemaAudit.data;
          const originalPages = originalData.pagesWithSchema || 0;
          const originalFailed = originalData.missingSchemaCount || 0;
          
          // Create merged schema audit data
          const mergedSchemaAudit = {
            ...savedAudit.schemaAudit,
            data: {
              ...originalData,
              // Update counts: add retry successful pages, remove retry successful from failed
              pagesWithSchema: originalPages + retrySuccessful,
              missingSchemaCount: Math.max(0, originalFailed - retrySuccessful),
              // Update missingSchemaPages: remove successfully retried URLs
              missingSchemaPages: (originalData.missingSchemaPages || []).filter(p => {
                // Keep only pages that weren't in the retry list or still failed
                return !failedUrls.includes(p.url) || (retryData.missingSchemaPages || []).some(rp => rp.url === p.url);
              }),
              // Update coverage
              coverage: ((originalPages + retrySuccessful) / originalData.totalPages) * 100
            }
          };
          
          // Update saved audit with merged results
          const mergedAudit = {
            ...savedAudit,
            schemaAudit: mergedSchemaAudit
          };
          
          // Recalculate scores with merged data (use saved localSignals if available)
          // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
          const normalizedSiteReviews = getTrustpilotSnapshot(savedAudit.siteReviews || null);
          const mergedScores = await calculatePillarScores(savedAudit.searchData, mergedSchemaAudit, savedAudit.localSignals || null, normalizedSiteReviews, savedAudit.backlinkMetrics || null);
          const mergedSnippetReadiness = calculateSnippetReadiness(mergedScores, savedAudit.searchData);
          
          // Save merged results (preserve localSignals, siteReviews, and backlinkMetrics)
          saveAuditResults(mergedScores, savedAudit.searchData, mergedSnippetReadiness, mergedSchemaAudit, savedAudit.localSignals || null, normalizedSiteReviews, savedAudit.backlinkMetrics || null);
          
          // Update retry button visibility
          updateRetryButtonVisibility(mergedSchemaAudit);
          
          // Refresh dashboard with merged results
          updateProgress(80, 'Refreshing dashboard with merged results...');
          displayDashboard(mergedScores, savedAudit.searchData, mergedSnippetReadiness, mergedSchemaAudit, savedAudit.localSignals || null);
          
          updateProgress(100, 'Retry completed and dashboard updated!');
          showStatus(`Retry completed: ${retrySuccessful} URLs now have schema. Dashboard updated with merged results.`, 'success');
          
          // Show completion modal with merged results
          showCompletionModal(mergedSchemaAudit);
        } else {
          // No saved audit found, just show retry results
          updateProgress(80, 'Retry completed!');
          showCompletionModal(retrySchemaAudit);
          updateProgress(100, 'Retry completed!');
          showStatus(`Retry completed: ${retrySuccessful} URLs now have schema, ${retryStillFailed} still failed`, 'success');
          debugLog(' No saved audit found to merge with. Run full audit to see complete results.', 'warn');
        }
        
      } catch (error) {
        debugLog(` Retry error: ${error.message}`, 'error');
        showStatus(`Error retrying failed URLs: ${error.message}`, 'error');
      } finally {
        document.getElementById('loading').classList.remove('show');
        setTimeout(() => {
          updateProgress(0, 'Initializing audit scan...');
        }, 500);
      }
    }

    // Save audit results to localStorage
    function saveAuditResults(scores, searchData, snippetReadiness, schemaAudit, localSignals = null, siteReviews = null, backlinkMetrics = null, preserveTimestamp = false) {
      try {
        const dateRange = parseInt(document.getElementById('dateRange')?.value) || 30;
        // Get property URL from input field or from searchData
        const propertyUrl = document.getElementById('propertyUrl')?.value || 
                           searchData?.propertyUrl || 
                           searchData?.property_url ||
                           localStorage.getItem('gsc_property_url') ||
                           'https://www.alanranger.com'; // Fallback default
        
        // Get existing audit data to preserve timestamp if requested
        let existingTimestamp = null;
        if (preserveTimestamp) {
          try {
            const existing = localStorage.getItem('last_audit_results');
            if (existing) {
              const parsed = JSON.parse(existing);
              existingTimestamp = parsed.timestamp;
            }
          } catch (e) {
            // Ignore errors when reading existing data
          }
        }
        
        const auditData = {
          scores,
          searchData,
          snippetReadiness,
          schemaAudit,
          localSignals, // Store local signals data for future use
          siteReviews, // Store site reviews data for future use (preserve on retry)
          backlinkMetrics, // Store backlink metrics data
          dateRange, // Store the date range used for this audit
          propertyUrl, // CRITICAL: Save property URL so we can fetch from Supabase later
          timestamp: preserveTimestamp && existingTimestamp ? existingTimestamp : new Date().toISOString(),
          // Save Money Pages Priority Matrix data for persistence
          moneyPagePriorityData: window.moneyPagePriorityData || null,
          moneySegmentMetrics: window.moneySegmentMetrics || null
        };
        
        // Try to save to localStorage, but don't fail if quota exceeded (Supabase is source of truth)
        if (safeSetLocalStorage('last_audit_results', auditData)) {
          debugLog(` Audit results saved to localStorage (propertyUrl: ${propertyUrl})`, 'success');
        }
        // Also save property URL separately for easy access
        if (propertyUrl) {
          localStorage.setItem('gsc_property_url', propertyUrl);
        }
        debugLog(` Audit results saved to localStorage (propertyUrl: ${propertyUrl})`, 'success');
        
        // Update timestamp display
        updateAuditTimestamp(auditData.timestamp);
      } catch (error) {
        debugLog(` Error saving audit results: ${error.message}`, 'error');
      }
    }
    
    // Show full-screen loading overlay
    function showFullScreenLoading(message = 'Loading...') {
      // Remove any existing overlay
      const existing = document.getElementById('fullScreenLoadingOverlay');
      if (existing) existing.remove();
      
      // Create overlay
      const overlay = document.createElement('div');
      overlay.id = 'fullScreenLoadingOverlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(4px);
      `;
      
      // Create spinner container
      const spinnerContainer = document.createElement('div');
      spinnerContainer.style.cssText = `
        background: white;
        padding: 3rem 4rem;
        border-radius: 12px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        text-align: center;
        min-width: 300px;
      `;
      
      // Create spinner
      const spinner = document.createElement('div');
      spinner.style.cssText = `
        width: 60px;
        height: 60px;
        border: 6px solid #e2e8f0;
        border-top-color: #3b82f6;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 1.5rem;
      `;
      
      // Create message
      const messageDiv = document.createElement('div');
      messageDiv.style.cssText = 'font-size: 1.1rem; color: #1f2937; font-weight: 500;';
      messageDiv.textContent = message;
      
      // Add spin animation if not already in stylesheet
      if (!document.getElementById('full-screen-spin-style')) {
        const style = document.createElement('style');
        style.id = 'full-screen-spin-style';
        style.textContent = '@keyframes spin { to { transform: rotate(360deg); } }';
        document.head.appendChild(style);
      }
      
      spinnerContainer.appendChild(spinner);
      spinnerContainer.appendChild(messageDiv);
      overlay.appendChild(spinnerContainer);
      document.body.appendChild(overlay);
    }
    
    // Hide full-screen loading overlay
    function hideFullScreenLoading() {
      const overlay = document.getElementById('fullScreenLoadingOverlay');
      if (overlay) overlay.remove();
    }
    
    // Update audit results for new date range without full rescan
    async function updateAuditForNewDateRange(newDateRange, savedAudit) {
      // Show full-screen loading overlay
      showFullScreenLoading(`Updating metrics for ${newDateRange} day period...`);
      
      try {
        showStatus(`Updating metrics for ${newDateRange} day period...`, 'info');
        
        const propertyUrl = document.getElementById('propertyUrl')?.value || savedAudit.propertyUrl || '';
        if (!propertyUrl) {
          // Remove loading spinner
          if (trendCanvas && trendCanvas.parentElement) {
            const loadingDiv = trendCanvas.parentElement.querySelector('.trend-chart-loading');
            if (loadingDiv) loadingDiv.remove();
          }
          clearDashboard();
          showStatus(`Date range changed to ${newDateRange} days. Please run a new audit to see updated metrics.`, 'info');
          return;
        }
        
        // Get API key (needed for fetchSearchConsoleData signature, but not actually used)
        let apiKey = window._loadedApiKey || '';
        
        // Fetch new GSC data for the new date range (will use Supabase cache)
        debugLog(`Fetching GSC data for ${newDateRange} day period...`, 'info');
        const searchData = await fetchSearchConsoleData(apiKey, propertyUrl, newDateRange);
        
        // Fetch local signals (Business Profile data doesn't change with date range, but fetch to ensure it's fresh)
        let localSignals = savedAudit.localSignals || null;
        
        // Normalize cached localSignals structure if needed (handle old format where it might just be {data: {...}})
        if (localSignals && localSignals.data && !localSignals.status) {
          debugLog(`[Local Signals] Normalizing cached data structure - wrapping in status/data format`, 'info');
          localSignals = { status: 'ok', data: localSignals.data || localSignals };
        }
        
        try {
          const localSignalsResponse = await fetch(apiUrl(`/api/aigeo/local-signals?property=${encodeURIComponent(propertyUrl)}`));
          if (localSignalsResponse.ok) {
            const freshLocalSignals = await localSignalsResponse.json();
            debugLog(`[Local Signals API] Response received - status: ${freshLocalSignals.status}, has data: ${!!freshLocalSignals.data}, locations count: ${freshLocalSignals.data?.locations?.length || 0}, structure keys: ${Object.keys(freshLocalSignals).join(', ')}`, 'info');
            
            // Use fresh data if API returned successfully
            if (freshLocalSignals.status === 'ok' && freshLocalSignals.data) {
              // Always use fresh data if API returned successfully, even if locations is 0
              // (API might return 0 locations legitimately, or we want to update cached data)
              localSignals = freshLocalSignals;
              debugLog(` Local signals data fetched successfully - Locations: ${freshLocalSignals.data.locations?.length || 0}, Service Areas: ${freshLocalSignals.data.serviceAreas?.length || 0}, NAP: ${freshLocalSignals.data.napConsistencyScore}`, 'success');
            } else if (freshLocalSignals.status === 'error') {
              debugLog(` Local signals API error: ${freshLocalSignals.error?.message || 'Unknown error'}, keeping cached data`, 'warn');
              // Keep using cached data - don't overwrite with error response
            } else {
              debugLog(` Local signals API returned unexpected status (status: ${freshLocalSignals.status}, has data: ${!!freshLocalSignals.data}, locations: ${freshLocalSignals.data?.locations?.length || 0}), keeping cached data`, 'warn');
              // Keep using cached data - don't overwrite with unexpected response
            }
          }
        } catch (localSignalsError) {
          debugLog(` Local signals error: ${localSignalsError.message}, using cached data if available`, 'warn');
        }
        
        // Final normalization - ensure localSignals always has the correct structure
        if (localSignals && localSignals.data && !localSignals.status) {
          localSignals = { status: 'ok', data: localSignals.data || localSignals };
        }
        
        // Recalculate pillar scores based on new GSC data
        // Keep existing schema audit data (doesn't change with date range)
        // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
        const normalizedSiteReviews = getTrustpilotSnapshot(savedAudit.siteReviews || null);
        // Get backlinkMetrics from savedAudit (it should be there from the last audit)
        const backlinkMetrics = savedAudit.backlinkMetrics || null;
        const scores = await calculatePillarScores(searchData, savedAudit.schemaAudit, localSignals, normalizedSiteReviews, backlinkMetrics);
        const snippetReadiness = calculateSnippetReadiness(scores, searchData);
        
        debugLog(`Recalculated scores for ${newDateRange} days: ${JSON.stringify(scores)}`, 'info');
        
        // Update saved audit with new data
        // Preserve the original audit timestamp - don't update it when changing date range
        const updatedAudit = {
          ...savedAudit,
          dateRange: newDateRange,
          searchData: searchData,
          scores: scores,
          snippetReadiness: snippetReadiness,
          localSignals: localSignals, // Store local signals for future use
          timestamp: savedAudit.timestamp || new Date().toISOString(), // Preserve original timestamp
          // Preserve Money Pages Priority Matrix data if it exists
          moneyPagePriorityData: window.moneyPagePriorityData || savedAudit.moneyPagePriorityData || null,
          moneySegmentMetrics: window.moneySegmentMetrics || savedAudit.moneySegmentMetrics || null
        };
        
        // Save updated audit
        