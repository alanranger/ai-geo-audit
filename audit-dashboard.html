<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>AI GEO Audit Dashboard - Automated SEO Analysis (v 80c0dd8)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script>
    // Try to load config.js if it exists (for local development)
    // Note: config.js is gitignored and won't be deployed to Vercel
    // Silently fail if config.js doesn't exist (expected on Vercel)
    try {
      const configScript = document.createElement('script');
      configScript.src = 'config.js';
      configScript.onerror = function() {
        // Silently ignore - config.js is optional
      };
      document.head.appendChild(configScript);
    } catch (e) {
      // Silently ignore - config.js is optional
    }
  </script>
  <style>
    :root {
      --brand-orange: #E57200;
      --brand-dark: #222222;
      --brand-grey: #555555;
      --bg-page: #f2f2f2;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg-page);
      color: var(--brand-dark);
      line-height: 1.5;
    }
    .header {
      background: linear-gradient(135deg, var(--brand-orange) 0%, #ff8c42 100%);
      color: white;
      padding: 2rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .header h1 {
      margin: 0 0 0.5rem 0;
      font-size: 2rem;
    }
    .header p {
      margin: 0;
      opacity: 0.9;
    }
    .container {
      max-width: 1800px;
      margin: 0 auto;
      padding: 2rem;
      padding-bottom: 60px; /* Space for debug panel */
    }
    .config-panel {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      margin-bottom: 2rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .config-panel h2 {
      margin: 0 0 1rem 0;
      color: var(--brand-dark);
      font-size: 1.25rem;
    }
    .form-group {
      margin-bottom: 1rem;
    }
    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      color: var(--brand-grey);
    }
    .form-group input {
      width: 100%;
      padding: 0.75rem;
      border: 2px solid #e2e8f0;
      border-radius: 6px;
      font-size: 1rem;
    }
    .form-group input:focus {
      outline: none;
      border-color: var(--brand-orange);
    }
    .btn {
      background: var(--brand-orange);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    .btn:hover {
      background: #d46200;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    .btn-secondary {
      background: var(--brand-grey);
    }
    .btn-secondary:hover {
      background: #444;
    }
    .status {
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      display: none;
    }
    .status.success {
      background: #d1fae5;
      color: #065f46;
      border-left: 4px solid var(--success);
    }
    .status.error {
      background: #fee2e2;
      color: #991b1b;
      border-left: 4px solid var(--danger);
    }
    .status.info {
      background: #dbeafe;
      color: #1e40af;
      border-left: 4px solid #3b82f6;
    }
    .status.show {
      display: block;
    }
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    .pillar-card {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: relative;
    }
    .pillar-card h3 {
      margin: 0 0 0.75rem 0;
      color: var(--brand-dark);
      font-size: 1.1rem;
    }
    .pillar-score {
      font-size: 3rem;
      font-weight: 700;
      margin: 0.5rem 0;
      line-height: 1;
    }
    .pillar-score.rag-red {
      color: var(--danger);
    }
    .pillar-score.rag-amber {
      color: var(--warning);
    }
    .pillar-score.rag-green {
      color: var(--success);
    }
    .rag-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.875rem;
      font-weight: 600;
      margin-top: 0.75rem;
      margin-bottom: 0.5rem;
    }
    .rag-badge.red {
      background: #fee2e2;
      color: #991b1b;
    }
    .rag-badge.amber {
      background: #fef3c7;
      color: #92400e;
    }
    .rag-badge.green {
      background: #d1fae5;
      color: #065f46;
    }
    .chart-container {
      background: linear-gradient(135deg, #f0f4f8 0%, #e2e8f0 100%);
      padding: 1.5rem;
      padding-bottom: 3rem; /* Extra padding at bottom for rotated axis labels */
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 6rem; /* extra breathing room below charts */
      height: 400px;
      border: 1px solid rgba(100, 116, 139, 0.2);
      overflow: visible; /* Allow axis labels to extend beyond container */
    }
    .chart-container.large {
      height: 1200px;
      min-height: 1200px;
      padding: 2rem;
    }
    .dashboard-two-column {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-three-column {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-four-column {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    @media (max-width: 1200px) {
      .dashboard-four-column {
        grid-template-columns: repeat(2, 1fr);
      }
      .dashboard-three-column {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    @media (max-width: 768px) {
      .dashboard-two-column,
      .dashboard-three-column,
      .dashboard-four-column {
        grid-template-columns: 1fr;
      }
    }
    .chart-container h3 {
      margin: 0 0 0.5rem 0;
      color: var(--brand-dark);
    }
    .chart-container p {
      margin: 0 0 1rem 0;
    }
    .trend-summary-row {
      display: flex;
      gap: 1.5rem;
      font-size: 0.9rem;
      margin-bottom: 0.75rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .trend-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.7);
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.06);
      border: 1px solid rgba(148, 163, 184, 0.3);
    }
    .trend-pill span.label {
      font-weight: 600;
      color: #374151;
    }
    .trend-pill span.value.up {
      font-weight: 700;
      color: #10b981; /* green */
    }
    .trend-pill span.value.down {
      font-weight: 700;
      color: #ef4444; /* red */
    }
    .metrics-section {
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border: 1px solid rgba(59, 130, 246, 0.1);
    }
    .scorecard-section {
      margin-top: 4rem;  /* push scorecard further below charts */
      margin-bottom: 3rem;
    }
    .scorecard-section h3 {
      margin-bottom: 1.5rem;
    }
    .metrics-section {
      margin-top: 3rem;
      margin-bottom: 3rem;
    }
    .metrics-section h3 {
      margin-bottom: 1.5rem;
    }
    .section-break {
      margin-top: 4rem;
      margin-bottom: 4rem;
      border-top: 2px solid #e2e8f0;
      padding-top: 2rem;
    }
    .calculation-explanation {
      background: #f8f9fa;
      border: 2px solid var(--brand-orange);
      border-radius: 8px;
      margin-bottom: 2rem;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(229, 114, 0, 0.15);
    }
    .calculation-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: linear-gradient(135deg, #fff5f0 0%, #ffe8d6 100%);
      border-bottom: 2px solid var(--brand-orange);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    .calculation-explanation.collapsed .calculation-header {
      border-bottom: none;
    }
    .calculation-header:hover {
      background: linear-gradient(135deg, #ffe8d6 0%, #ffd9b3 100%);
    }
    .calculation-header h4 {
      margin: 0;
      color: var(--brand-orange);
      font-size: 1.1rem;
      font-weight: 600;
    }
    .calculation-toggle {
      font-size: 1.2rem;
      color: var(--brand-orange);
      font-weight: bold;
      transition: transform 0.3s;
    }
    .calculation-explanation.collapsed .calculation-toggle {
      transform: rotate(-90deg);
    }
    .calculation-content {
      padding: 1.5rem;
      color: #555;
      line-height: 1.8;
    }
    .calculation-content.collapsed {
      display: none;
    }
    .calculation-content h5 {
      color: var(--brand-dark);
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-size: 1rem;
      font-weight: 600;
      border-bottom: 2px solid var(--brand-orange);
      padding-bottom: 0.5rem;
    }
    .calculation-content h5:first-child {
      margin-top: 0;
    }
    .calculation-content ul {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
    }
    .calculation-content li {
      margin: 0.5rem 0;
    }
    .calculation-content code {
      background: #e2e8f0;
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #c53030;
    }
    .calculation-content .formula {
      background: #f0f4f8;
      padding: 0.75rem;
      border-left: 3px solid var(--brand-orange);
      margin: 0.75rem 0;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
    }
    .calculation-content .note {
      background: #fff3cd;
      border-left: 3px solid #f59e0b;
      padding: 0.75rem;
      margin: 1rem 0;
      font-size: 0.9rem;
    }
    .date-range-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .date-range-btn {
      padding: 0.5rem 1rem;
      border: 2px solid #e2e8f0;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    .date-range-btn:hover {
      border-color: var(--brand-orange);
      background: #fff5f0;
    }
    .date-range-btn.active {
      background: var(--brand-orange);
      color: white;
      border-color: var(--brand-orange);
    }
    .snippet-readiness-gauge {
      background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 3rem;
      border: 1px solid rgba(16, 185, 129, 0.1);
    }
    .gauge-container {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      flex: 1;
      position: relative;
    }
    .gauge-wrapper {
      position: relative;
      width: 300px;
      height: 300px;
    }
    .gauge-svg {
      transform: rotate(-90deg);
      width: 100%;
      height: 100%;
    }
    .gauge-background {
      fill: none;
      stroke: #e2e8f0;
      stroke-width: 20;
    }
    .gauge-fill {
      fill: none;
      stroke-width: 20;
      stroke-linecap: round;
      transition: stroke-dashoffset 1s ease-in-out;
    }
    .gauge-fill.green {
      stroke: #10b981;
    }
    .gauge-fill.amber {
      stroke: #f59e0b;
    }
    .gauge-fill.red {
      stroke: #ef4444;
    }
    .gauge-value {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      font-weight: 700;
      text-align: center;
      z-index: 10;
    }
    .gauge-value.green {
      color: #10b981;
    }
    .gauge-value.amber {
      color: #f59e0b;
    }
    .gauge-value.red {
      color: #ef4444;
    }
    .gauge-label {
      text-align: center;
      color: var(--brand-grey);
      margin-top: 1rem;
      font-size: 1rem;
      font-weight: 600;
    }
    .gauge-status {
      text-align: center;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      font-weight: 500;
    }
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }
    .metric-card {
      background: white;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
    }
    .metric-card .value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--brand-orange);
      margin: 0.5rem 0;
    }
    .metric-card .label {
      color: var(--brand-grey);
      font-size: 0.875rem;
    }
    .loading {
      display: none;
      text-align: center;
      padding: 2rem;
    }
    .loading.show {
      display: block;
    }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--brand-orange);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .progress-container {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1rem 0;
    }
    .progress-bar-wrapper {
      width: 100%;
      background: #e2e8f0;
      border-radius: 10px;
      height: 24px;
      overflow: hidden;
      margin: 1rem 0;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--brand-orange), #ff8c42);
      border-radius: 10px;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 0.85rem;
      min-width: 0;
    }
    .progress-status {
      font-size: 0.95rem;
      color: #555;
      margin-top: 0.5rem;
      font-weight: 500;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      overflow: auto;
    }
    .modal-content {
      background-color: white;
      margin: 5% auto;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      animation: modalSlideIn 0.3s ease;
    }
    @keyframes modalSlideIn {
      from {
        transform: translateY(-50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    .help-text {
      font-size: 0.875rem;
      color: var(--brand-grey);
      margin-top: 0.25rem;
    }

    .debug-panel-bottom {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1a1a1a;
      border-top: 3px solid #E57200;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      z-index: 1000;
      box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.5);
      max-height: 50vh;
      display: flex;
      flex-direction: column;
    }

    .debug-panel-bottom.collapsed {
      max-height: 50px;
    }

    .debug-panel-bottom.collapsed .debug-content {
      display: none !important;
    }

    .debug-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #333;
      background: #252525;
      user-select: none;
    }

    .debug-header h3 {
      margin: 0;
      color: #fff;
      font-size: 1rem;
    }

    .debug-actions {
      display: flex;
      gap: 0.5rem;
    }

    .btn-small {
      padding: 0.25rem 0.75rem;
      font-size: 0.75rem;
      background: #333;
      color: #fff;
      border: 1px solid #555;
    }

    .btn-small:hover {
      background: #444;
    }

    .debug-content {
      color: #fff;
      line-height: 1.6;
      padding: 1rem;
      overflow-y: auto;
      flex: 1;
      max-height: calc(50vh - 60px);
    }

    .debug-log-entry {
      margin-bottom: 0.25rem;
      padding: 0.25rem 0;
      border-left: 2px solid transparent;
      padding-left: 0.5rem;
    }

    .debug-log-entry.error {
      color: #f44;
      border-left-color: #f44;
    }

    .debug-log-entry.warn {
      color: #fa4;
      border-left-color: #fa4;
    }

    .debug-log-entry.info {
      color: #9cf;
      border-left-color: #4af;
    }

    .debug-log-entry.success {
      color: #9f9;
      border-left-color: #4f4;
    }

    .debug-timestamp {
      color: #aaa;
      margin-right: 0.5rem;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>AI GEO Audit Dashboard</h1>
    <p>Automated SEO Analysis & Pillar Score Tracking</p>
    <p style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 1; background: rgba(0,0,0,0.3); padding: 0.25rem 0.5rem; border-radius: 4px; display: inline-block;">
      <strong>Version: 80c0dd8</strong> | Built: 2025-01-27 19:20 UTC | 
      <span id="loadTime" style="color: #4f4;">Loaded: <script>document.write(new Date().toLocaleTimeString())</script></span>
    </p>
  </div>

  <div class="container">
    <div class="config-panel">
      <h2>Configuration</h2>
      <div class="info-box" style="background: #e8f4f8; border-left: 4px solid #2196F3; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #1565C0;"><strong>Entity-Level Audit:</strong> This dashboard analyzes <strong>www.alanranger.com</strong> as a global entity, tracking AI-powered search visibility, entity recognition, and SERP behavior across the entire domain.</p>
      </div>
      <div class="form-group">
        <label for="propertyUrl">Property URL</label>
        <input type="text" id="propertyUrl" placeholder="https://yourwebsite.com" value="https://www.alanranger.com">
        <div class="help-text">The domain being audited (entity-level analysis)</div>
      </div>
      <div class="form-group">
        <label for="dateRange">Date Range</label>
        <div class="date-range-selector">
          <button class="date-range-btn active" onclick="setDateRange(30)" data-days="30" title="Analyze search performance data from the last 30 days">Last 30 Days</button>
          <button class="date-range-btn" onclick="setDateRange(60)" data-days="60" title="Analyze search performance data from the last 60 days">Last 60 Days</button>
          <button class="date-range-btn" onclick="setDateRange(90)" data-days="90" title="Analyze search performance data from the last 90 days">Last 90 Days</button>
          <button class="date-range-btn" onclick="setDateRange(120)" data-days="120" title="Analyze search performance data from the last 120 days">Last 120 Days</button>
          <button class="date-range-btn" onclick="setDateRange(180)" data-days="180" title="Analyze search performance data from the last 6 months (180 days)">Last 6 Months</button>
          <button class="date-range-btn" onclick="setDateRange(365)" data-days="365" title="Analyze search performance data from the last 12 months (365 days)">Last 12 Months</button>
          <button class="date-range-btn" onclick="setDateRange(540)" data-days="540" title="Analyze search performance data from the last 18 months (540 days)">Last 18 Months</button>
          <button class="date-range-btn" onclick="showCustomDateRange()" id="customDateBtn" title="Set a custom date range for analysis (enter number of days)">Custom</button>
        </div>
        <input type="number" id="dateRange" value="30" min="1" style="display: none;">
        <div id="customDateRange" style="display: none; margin-top: 0.5rem;">
          <input type="number" id="customDays" placeholder="Enter days" min="1" style="width: 150px; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px;">
          <button class="btn btn-small" onclick="applyCustomDateRange()" style="margin-left: 0.5rem; padding: 0.5rem 1rem;" title="Apply the custom date range you entered">Apply</button>
        </div>
        <div class="help-text">Analysis period for historical data</div>
      </div>
      <div style="background: #f0f0f0; padding: 0.75rem; border-radius: 4px; margin-bottom: 1rem; font-size: 0.85rem; color: #555;">
        <strong>API Key:</strong> Loaded automatically from Vercel environment variables. No manual entry required.
      </div>
      <div class="form-group">
        <label for="manualUrlList">Manual URL List (Optional)</label>
        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">
          Load list of site URLs from a CSV file
        </div>
        <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
          <input type="file" id="urlListFile" accept=".csv" style="flex: 1; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem;">
          <button class="btn btn-small" onclick="loadUrlListFromFile()" style="padding: 0.5rem 1rem;" title="Load a CSV file containing site URLs. The CSV must have a 'url' column in the header row. URLs will be used for schema audit instead of the default CSV source.">Load CSV</button>
          <button class="btn btn-small" onclick="clearManualUrlList()" style="padding: 0.5rem 1rem; background: #ef4444; color: white; border-color: #ef4444;" title="Clear the manually loaded URL list and revert to using the default CSV source for schema audit">Clear</button>
        </div>
        <textarea id="manualUrlList" placeholder="Or paste CSV content here (must include 'url' column in header row)..." style="width: 100%; min-height: 100px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace; resize: vertical;"></textarea>
        <div class="help-text">
          <strong>Required column:</strong> <code>url</code> (case-insensitive). CSV must have a header row. URLs will be extracted from the 'url' column.
        </div>
        <div id="urlListStatus" style="margin-top: 0.5rem; font-size: 0.85rem;"></div>
      </div>
      <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
        <button class="btn" onclick="runAudit()" title="Start a comprehensive audit scan. Fetches Google Search Console data and performs schema audit on all site URLs. Results will appear in the dashboard below.">Run Audit Scan</button>
        <button class="btn btn-secondary" id="retryFailedUrlsBtn" onclick="retryFailedUrlsFromLastAudit()" style="background: #f59e0b; color: white; border-color: #f59e0b; display: none;" title="Retry scanning the failed URLs from the last audit. This will rescan only the URLs that failed during the previous audit scan.">
          üîÑ Retry Failed URLs
        </button>
        <button class="btn btn-secondary" onclick="saveConfig()" title="Save your current configuration (property URL and date range) to browser localStorage. Settings will be restored when you reload the page.">Save Configuration</button>
        <button class="btn btn-secondary" onclick="syncCSV()" id="syncCsvBtn" style="background: #10b981; color: white; border-color: #10b981;" title="Sync the site URLs CSV file from GitHub. This updates the list of URLs that will be scanned during schema audit.">
          <span id="syncCsvBtnText">üîÑ Sync CSV</span>
        </button>
      </div>
    </div>

    <div class="status" id="status"></div>

    <div class="loading" id="loading">
      <div class="progress-container">
        <div class="spinner"></div>
        <div class="progress-bar-wrapper">
          <div class="progress-bar" id="progressBar" style="width: 0%;">0%</div>
        </div>
        <div class="progress-status" id="progressStatus">Initializing audit scan...</div>
      </div>
    </div>

    <!-- Completion Summary Modal -->
    <div id="completionModal" class="modal" style="display: none;">
      <div class="modal-content" style="max-width: 600px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Audit Complete</h2>
          <button onclick="closeCompletionModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;" title="Close the audit completion summary modal">&times;</button>
        </div>
        <div id="completionSummaryContent"></div>
        <div style="margin-top: 1.5rem; text-align: right;">
          <button class="btn" onclick="closeCompletionModal()" style="background: var(--brand-orange); color: white; border-color: var(--brand-orange);" title="Close the audit completion summary modal and return to the dashboard">Close</button>
        </div>
      </div>
    </div>

    <div id="dashboard" style="display: none;">
      <div id="auditTimestamp" style="background: #e8f5e9; padding: 0.75rem 1rem; border-radius: 6px; margin-bottom: 1rem; border-left: 4px solid #10b981; font-size: 0.9rem; color: #555;">
        <strong>Last Audit:</strong> <span id="lastAuditTime">Not yet run</span>
      </div>
      <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px; margin-bottom: 3rem; border-left: 4px solid var(--brand-orange);">
        <h3 style="margin-top: 0; color: var(--brand-orange);">Five-Pillar Framework</h3>
        <p style="color: #555; line-height: 1.6; margin-bottom: 1rem;">
          This audit analyzes <strong>www.alanranger.com</strong> as a global entity using a five-pillar framework to assess AI-powered search visibility, entity recognition, and SERP behavior. Each pillar is scored 0-100 and assigned a RAG (Red/Amber/Green) status based on performance thresholds.
        </p>
        <p style="color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
          <strong>Data Sources:</strong> Scores are calculated using data from Google Search Console API (impressions, clicks, position, queries), schema markup validation, local pack visibility metrics, and SERP feature tracking (featured snippets, AI Overviews, rich results).
        </p>
        <p style="color: #555; line-height: 1.6; margin-bottom: 0;">
          <strong>Score Calculation:</strong> Each pillar combines multiple weighted factors: Local Entity (brand consistency, entity signals, NAP data), Service Area (geographic coverage, location schema), Authority (E-A-T: Experience, Expertise, Authoritativeness, Trustworthiness - content depth, backlinks, reviews, credentials, citations), Visibility (ranking positions, SERP features, CTR), and Content/Schema (Foundation schemas 30% + Rich Results 35% + Coverage 20% + Diversity 15%). Scores are normalized to 0-100 scale with thresholds: Green (70-100), Amber (40-69), Red (0-39).
        </p>
      </div>

      <div class="calculation-explanation collapsed" id="calculationExplanation">
        <div class="calculation-header" onclick="toggleCalculationExplanation()">
          <h4>üìä Detailed Calculation Explanation</h4>
          <span class="calculation-toggle" id="calculationToggle">‚ñ∂</span>
        </div>
        <div class="calculation-content collapsed" id="calculationContent">
          <h5>1. Visibility</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Primary: Average position from Google Search Console (1-40 mapped to 100-10)</li>
            <li>Formula: <code>posScore = 100 - ((clampedPosition - 1) / 39) * 90</code></li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: impressions, clicks, average position, CTR</li>
            <li>SERP feature tracking: featured snippets, AI Overviews, rich results</li>
          </ul>
          <p><strong>Data Checked:</strong> Search Console impressions/clicks, average position, CTR, featured snippet appearances, local pack visibility, SERP feature presence, ranking distribution.</p>

          <h5>2. Authority (E-A-T)</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Blend of CTR (60%) and position score (40%)</li>
            <li>Formula: <code>authority = 0.6 * ctrScore + 0.4 * posScore</code></li>
            <li>CTR mapped: 0-10% ‚Üí 0-100 (0.10 = 100)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: CTR, position</li>
            <li>Backlink analysis (planned)</li>
            <li>Review data (planned)</li>
          </ul>
          <p><strong>Data Checked:</strong> Content depth (word count, comprehensiveness), backlink quality/quantity, review counts/ratings, author credentials, citations in content, external mentions, case studies, certifications displayed.</p>

          <h5>3. Local Entity</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Anchored around 60, adjusted by position and CTR</li>
            <li>Formula: <code>localEntity = 60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50)</code></li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: position, CTR</li>
            <li>Schema markup validation (planned)</li>
            <li>Knowledge panel tracking (planned)</li>
          </ul>
          <p><strong>Data Checked:</strong> LocalBusiness schema presence, NAP consistency across site, entity mentions in content, knowledge panel presence, author markup, Organization schema.</p>

          <h5>4. Service Area</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Derived from Local Entity, slightly lower</li>
            <li>Formula: <code>serviceArea = localEntity - 5</code></li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API (via Local Entity calculation)</li>
            <li>Schema markup validation (planned)</li>
            <li>Google Business Profile data (planned)</li>
          </ul>
          <p><strong>Data Checked:</strong> ServiceArea schema markup, geographic keywords in content, location pages, Google Business Profile service areas, address/location schema.</p>

          <h5>5. Content/Schema</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Weighted calculation based on four components: Foundation schemas, Rich Results, Coverage, and Diversity</li>
            <li>Formula: <code>contentSchema = (Foundation √ó 30%) + (Rich Results √ó 35%) + (Coverage √ó 20%) + (Diversity √ó 15%)</code></li>
            <li><strong>Foundation Schemas (30%):</strong> Organization, Person, WebSite, BreadcrumbList presence. Score = (types present / 4) √ó 100</li>
            <li><strong>Rich Results (35%):</strong> Article, Event, Course, FAQ, HowTo, VideoObject, Recipe, Product, LocalBusiness, Review eligibility. Score = (eligible types / 10) √ó 100</li>
            <li><strong>Coverage (20%):</strong> Pages with schema / total pages. Score = coverage percentage</li>
            <li><strong>Diversity (15%):</strong> Number of unique schema types across site. Score = min((unique types / 15) √ó 100, 100)</li>
            <li><strong>Data Source:</strong> Schema audit API (crawls actual pages for JSON-LD markup)</li>
            <li>Uses real schema coverage from CSV-based audit (when available)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Schema Audit API: CSV-based domain crawl of all site URLs</li>
            <li>Schema markup detection and type counting</li>
            <li>Foundation schema presence detection (Organization, Person, WebSite, BreadcrumbList)</li>
            <li>Rich result eligibility detection (Article, Event, Course, FAQ, HowTo, VideoObject, Recipe, Product, LocalBusiness, Review)</li>
          </ul>
          <p><strong>Data Checked:</strong> Total pages scanned, pages with schema, schema coverage percentage, schema types present (Organization, Person, LocalBusiness, Article, Course, Event, FAQ, HowTo, etc.), missing schema types, rich result eligibility (Article, Event, FAQ, Product, LocalBusiness, Course, Review, HowTo).</p>

          <div class="note">
            <strong>Current Implementation Status:</strong><br>
            <strong>Currently Active:</strong> Google Search Console API integration (real-time data) - Total clicks, Total impressions, Average position, CTR calculation, Top queries.<br><br>
            <strong>Planned/Future Enhancements:</strong> Schema markup validation and analysis, Backlink quality/quantity analysis, Review aggregation, Knowledge panel tracking, Local pack visibility metrics, SERP feature detection, Rich result eligibility checks.<br><br>
            <strong>Note:</strong> Currently, most pillars are calculated from GSC metrics (position, CTR, impressions, clicks). The formulas are deterministic and stable, but full implementation will require additional data sources for complete accuracy.
          </div>
        </div>
      </div>

      <div class="dashboard-grid" id="pillarCards"></div>

      <div class="section-break"></div>

      <div class="metrics-section">
        <h3 style="color: var(--brand-orange); margin-bottom: 0.5rem;">Key Performance Indicators</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Core metrics from Google Search Console showing overall search performance for the entity. <strong>Note:</strong> Small differences from live GSC may occur due to data processing delays (up to 48 hours) and exact date range calculations.</p>
        <div class="metrics-grid" id="metricsGrid"></div>
      </div>

      <div class="section-break"></div>

      <div class="dashboard-two-column">
        <div class="chart-container large">
          <h3>Pillar Scores Overview</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Radar chart showing current performance across all five pillars. The larger the area, the stronger your overall entity recognition.</p>
          
          <!-- Audit Timestamp for Radar Chart -->
          <div id="radarChartTimestamp" style="background: #fff3cd; padding: 0.5rem 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #f59e0b; font-size: 0.8rem; color: #856404; display: none;">
            <strong>Current data as of:</strong> <span id="radarChartAuditTime">-</span> <span style="color: #666; font-size: 0.75rem;">(Not historical - reflects last audit scan)</span>
          </div>
          
          <canvas id="radarChart"></canvas>
        </div>

        <div class="snippet-readiness-gauge">
          <h3 style="margin-top: 0; color: var(--brand-orange);">Snippet Readiness Gauge</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Snippet readiness summarises how likely your content is to be lifted into featured snippets and AI answers. It reflects three ingredients: snippet-friendly answer blocks, suitable schema (FAQ/HowTo/Article/Course/Event) and existing rich-result behaviour.</p>
          
          <!-- Audit Timestamp for Snippet Readiness -->
          <div id="snippetReadinessTimestamp" style="background: #fff3cd; padding: 0.5rem 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #f59e0b; font-size: 0.8rem; color: #856404; display: none;">
            <strong>Current data as of:</strong> <span id="snippetReadinessAuditTime">-</span> <span style="color: #666; font-size: 0.75rem;">(Not historical - reflects last audit scan)</span>
          </div>
          
          <div id="contentSchemaExplanation" style="display: none; background: #f0f9ff; border-left: 4px solid #3b82f6; padding: 1rem; margin-bottom: 1rem; border-radius: 4px; font-size: 0.85rem; color: #1e40af;">
            <strong>Why is Content/Schema 77%?</strong> The score is calculated from four weighted components:
            <ul style="margin: 0.5rem 0 0 1.5rem; padding: 0;">
              <li><strong>Foundation (30%):</strong> <span id="explainFoundation">-</span> - Missing foundation schemas reduce this component</li>
              <li><strong>Rich Results (35%):</strong> <span id="explainRich">-</span> - Not all rich result types are eligible yet</li>
              <li><strong>Coverage (20%):</strong> <span id="explainCoverage">-</span> - Some pages still lack schema markup</li>
              <li><strong>Diversity (15%):</strong> <span id="explainDiversity">-</span> - Limited schema type variety across the site</li>
            </ul>
            <div style="margin-top: 0.5rem; font-weight: 600;">Formula: (Foundation √ó 30%) + (Rich Results √ó 35%) + (Coverage √ó 20%) + (Diversity √ó 15%) = 77%</div>
          </div>
          
          <!-- Overall Combined Score -->
          <div style="text-align: center; margin-bottom: 1.5rem;">
            <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">Overall Snippet Readiness</div>
            <div id="snippetReadinessScore" style="font-size: 3rem; font-weight: 700; color: var(--brand-orange); line-height: 1;">0</div>
            <div id="gaugeStatus" style="font-size: 0.9rem; color: #666; margin-top: 0.25rem;">Calculating...</div>
          </div>
          
          <!-- Pie Chart Container -->
          <div style="display: flex; align-items: center; justify-content: center; gap: 1.5rem; flex-wrap: wrap;">
            <div style="flex: 2; min-width: 400px; max-width: 500px;">
              <canvas id="snippetReadinessPieChart"></canvas>
            </div>
            <div style="flex: 1; min-width: 180px; max-width: 250px;">
              <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--brand-dark);">Component Breakdown:</div>
              <div id="snippetReadinessLegend" style="display: flex; flex-direction: column; gap: 0.5rem;">
                <!-- Legend will be populated by JavaScript -->
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="section-break"></div>

      <div class="chart-container">
        <h3>Score Trends</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Historical performance tracking for all five pillars (Local Entity, Service Area, Authority, Visibility, Content/Schema) over the selected date range.</p>
        <div id="trendSummaryRow" class="trend-summary-row"></div>
        <canvas id="trendChart"></canvas>
      </div>

    </div>

    <!-- Debug Panel - Fixed at bottom, collapsible -->
    <div class="debug-panel-bottom" id="debugPanel">
      <div class="debug-header" onclick="toggleDebugPanel()" style="cursor: pointer;">
        <h3>üîç Debug Log (v80c0dd8)</h3>
        <div class="debug-actions">
          <button class="btn btn-small" onclick="event.stopPropagation(); clearDebugLog();" title="Clear all debug log entries. Useful for starting fresh during troubleshooting.">Clear</button>
          <button class="btn btn-small" onclick="event.stopPropagation(); copyDebugLog();" title="Copy the entire debug log to your clipboard. Useful for sharing logs or troubleshooting issues.">Copy Log</button>
          <span id="debugToggleIcon" style="color: #fff; font-size: 1.2rem;">‚ñº</span>
        </div>
      </div>
      <div class="debug-content" id="debugLog" style="display: block;">
        <div class="debug-log-entry info">
          <span class="debug-timestamp">[Initializing...]</span>Debug panel loaded. Waiting for page initialization...
        </div>
      </div>
    </div>
  </div>

  <script>
    // Immediate console log to verify script is running
    console.log('%c=== AI GEO AUDIT DASHBOARD v80c0dd8 LOADED (Fixed async/await) ===', 'color: #E57200; font-size: 16px; font-weight: bold;');
    console.log('%cDebug panel should be visible at bottom with orange border', 'color: #E57200; font-size: 14px;');
    console.log('Current time:', new Date().toISOString());
    console.log('Page URL:', window.location.href);
    
    // Debug logging system
    const debugLogEntries = [];
    
    function debugLog(message, type = 'info') {
      const timestamp = new Date().toISOString();
      const entry = {
        timestamp,
        message,
        type
      };
      debugLogEntries.push(entry);
      
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        const entryDiv = document.createElement('div');
        entryDiv.className = `debug-log-entry ${type}`;
        entryDiv.innerHTML = `<span class="debug-timestamp">[${new Date(timestamp).toLocaleTimeString()}]</span>${message}`;
        logElement.appendChild(entryDiv);
        logElement.scrollTop = logElement.scrollHeight;
      }
      
      // Also log to console
      const consoleMethod = type === 'error' ? 'error' : type === 'warn' ? 'warn' : 'log';
      console[consoleMethod](`[DEBUG ${type.toUpperCase()}]`, message);
    }

    function clearDebugLog() {
      debugLogEntries.length = 0;
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        logElement.innerHTML = '';
      }
      debugLog('Debug log cleared', 'info');
    }

    function copyDebugLog() {
      const logText = debugLogEntries.map(entry => 
        `[${entry.timestamp}] [${entry.type.toUpperCase()}] ${entry.message}`
      ).join('\n');
      
      navigator.clipboard.writeText(logText).then(() => {
        debugLog('Debug log copied to clipboard', 'success');
        showStatus('Debug log copied to clipboard!', 'success');
      }).catch(err => {
        debugLog('Failed to copy log: ' + err.message, 'error');
        showStatus('Failed to copy log', 'error');
      });
    }

    function toggleDebugPanel() {
      const panel = document.getElementById('debugPanel');
      const icon = document.getElementById('debugToggleIcon');
      if (panel.classList.contains('collapsed')) {
        panel.classList.remove('collapsed');
        if (icon) icon.textContent = '‚ñº';
      } else {
        panel.classList.add('collapsed');
        if (icon) icon.textContent = '‚ñ≤';
      }
    }

    function toggleCalculationExplanation() {
      const explanation = document.getElementById('calculationExplanation');
      const content = document.getElementById('calculationContent');
      const toggle = document.getElementById('calculationToggle');
      if (explanation.classList.contains('collapsed')) {
        explanation.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '‚ñº';
      } else {
        explanation.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '‚ñ∂';
      }
    }

    // Debug panel is always visible at bottom, start collapsed by default
    window.addEventListener('DOMContentLoaded', () => {
      const debugPanel = document.getElementById('debugPanel');
      const debugToggleIcon = document.getElementById('debugToggleIcon');
      if (debugPanel) {
        debugPanel.style.display = 'flex';
        // Start collapsed by default
        debugPanel.classList.add('collapsed');
        if (debugToggleIcon) {
          debugToggleIcon.textContent = '‚ñ≤';
        }
      }
    });

    // Load saved configuration
    async function loadConfig() {
      debugLog('=== PAGE LOAD: Starting configuration load ===', 'info');
      
      // Check if Chart.js is loaded
      debugLog('Checking Chart.js library...', 'info');
      if (typeof Chart !== 'undefined') {
        debugLog('‚úì Chart.js library loaded successfully', 'success');
      } else {
        debugLog('‚úó Chart.js library NOT loaded', 'error');
      }
      
      // Try to fetch API key from Vercel environment variable (via API endpoint)
      let vercelApiKey = null;
      try {
        debugLog('Checking Vercel environment variable...', 'info');
        const response = await fetch('/api/get-api-key');
        if (response.ok) {
          const data = await response.json();
          if (data.apiKey) {
            vercelApiKey = data.apiKey;
            debugLog('‚úì API key loaded from Vercel environment variable', 'success');
          }
        }
      } catch (e) {
        debugLog('Vercel env var endpoint not available (expected for static site)', 'info');
      }
      
      // Check config.js
      debugLog('Checking for config.js...', 'info');
      if (window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey) {
        debugLog('‚úì config.js found with API key', 'success');
      } else {
        debugLog('‚úó config.js not found or no API key', 'warn');
      }
      
      // Check localStorage
      debugLog('Checking localStorage...', 'info');
      const configApiKey = window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey;
      const apiKey = vercelApiKey || configApiKey || localStorage.getItem('gsc_api_key');
      const propertyUrl = localStorage.getItem('gsc_property_url');
      const dateRange = localStorage.getItem('gsc_date_range');
      
      const apiKeySource = vercelApiKey ? 'Vercel env var' : configApiKey ? 'config.js' : localStorage.getItem('gsc_api_key') ? 'localStorage' : 'none';
      debugLog(`API Key source: ${apiKeySource}`, 'info');
      debugLog(`Property URL: ${propertyUrl || 'not set'}`, 'info');
      debugLog(`Date Range: ${dateRange || 'not set'}`, 'info');
      
      if (apiKey) {
        debugLog('‚úì API key loaded from environment', 'success');
        // Store in a hidden variable for use in runAudit
        window._loadedApiKey = apiKey;
      } else {
        debugLog('‚úó No API key found', 'warn');
      }
      
      if (propertyUrl) {
        document.getElementById('propertyUrl').value = propertyUrl;
        debugLog('‚úì Property URL loaded', 'success');
      }
      if (dateRange) {
        document.getElementById('dateRange').value = dateRange;
        // Set active button based on saved date range
        const savedDays = parseInt(dateRange);
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          btn.classList.remove('active');
          const btnDays = parseInt(btn.getAttribute('data-days'));
          if (btnDays === savedDays) {
            btn.classList.add('active');
          }
        });
        // If no preset matches, show custom
        const presetDays = [7, 30, 90, 180, 365];
        if (!presetDays.includes(savedDays)) {
          document.getElementById('customDateBtn').classList.add('active');
          document.getElementById('customDays').value = savedDays;
          document.getElementById('customDateRange').style.display = 'block';
        }
        debugLog('‚úì Date range loaded', 'success');
      }
      
      // Load manual URL list if saved
      const savedUrlList = localStorage.getItem('manual_url_list');
      if (savedUrlList) {
        try {
          const urls = JSON.parse(savedUrlList);
          const statusDiv = document.getElementById('urlListStatus');
          if (statusDiv) {
            statusDiv.innerHTML = `<span style="color: #10b981;">‚úì ${urls.length} URLs loaded from saved list</span>`;
          }
          debugLog(`‚úì Manual URL list loaded: ${urls.length} URLs`, 'success');
        } catch (e) {
          debugLog('‚ö† Failed to load saved URL list', 'warn');
        }
      }
      
      debugLog('=== Configuration load complete ===', 'info');
    }

    // Save configuration
    // Date range selector functions
    function setDateRange(days) {
      document.getElementById('dateRange').value = days;
      localStorage.setItem('gsc_date_range', days);
      
      // Update active button
      document.querySelectorAll('.date-range-btn').forEach(btn => {
        btn.classList.remove('active');
        const btnDays = parseInt(btn.getAttribute('data-days'));
        if (btnDays === days) {
          btn.classList.add('active');
        }
      });
      
      // Hide custom input if showing
      document.getElementById('customDateRange').style.display = 'none';
      document.getElementById('customDateBtn').classList.remove('active');
      
      debugLog(`Date range set to ${days} days`, 'info');
    }

    function showCustomDateRange() {
      const customDiv = document.getElementById('customDateRange');
      const customBtn = document.getElementById('customDateBtn');
      
      if (customDiv.style.display === 'none') {
        customDiv.style.display = 'block';
        customBtn.classList.add('active');
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          if (btn !== customBtn) btn.classList.remove('active');
        });
      } else {
        customDiv.style.display = 'none';
        customBtn.classList.remove('active');
      }
    }

    function applyCustomDateRange() {
      const customDays = parseInt(document.getElementById('customDays').value);
      if (customDays && customDays > 0) {
        document.getElementById('dateRange').value = customDays;
        localStorage.setItem('gsc_date_range', customDays);
        document.getElementById('customDateRange').style.display = 'none';
        document.getElementById('customDateBtn').classList.remove('active');
        debugLog(`Custom date range set to ${customDays} days`, 'info');
      } else {
        showStatus('Please enter a valid number of days', 'error');
      }
    }

    function saveConfig() {
      localStorage.setItem('gsc_api_key', document.getElementById('apiKey').value);
      localStorage.setItem('gsc_property_url', document.getElementById('propertyUrl').value);
      localStorage.setItem('gsc_date_range', document.getElementById('dateRange').value);
      showStatus('Configuration saved!', 'success');
    }

    // Parse CSV and validate column names
    function parseUrlListCsv(csvText) {
      const lines = csvText.split('\n').filter(line => line.trim());
      if (lines.length === 0) {
        throw new Error('CSV is empty');
      }
      
      // Parse header row
      const headerLine = lines[0].trim();
      const headers = headerLine.split(',').map(h => h.trim().replace(/^"|"$/g, '').toLowerCase());
      
      // Check for required 'url' column
      const urlColumnIndex = headers.findIndex(h => h === 'url');
      if (urlColumnIndex === -1) {
        throw new Error(`Required column 'url' not found. Found columns: ${headers.join(', ')}`);
      }
      
      // Extract URLs from the 'url' column
      const urls = [];
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        // Parse CSV line (handle quoted values)
        const columns = [];
        let current = '';
        let inQuotes = false;
        
        for (let j = 0; j < line.length; j++) {
          const char = line[j];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            columns.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        columns.push(current.trim()); // Add last column
        
        // Extract URL from the url column
        if (columns[urlColumnIndex]) {
          const url = columns[urlColumnIndex].replace(/^"|"$/g, '').trim();
          if (url && url.startsWith('http')) {
            urls.push(url);
          }
        }
      }
      
      return {
        headers,
        urls,
        totalRows: lines.length - 1,
        validUrls: urls.length
      };
    }

    // Load URL list from file input
    async function loadUrlListFromFile() {
      const fileInput = document.getElementById('urlListFile');
      const statusDiv = document.getElementById('urlListStatus');
      const textarea = document.getElementById('manualUrlList');
      
      if (!fileInput.files || fileInput.files.length === 0) {
        // If no file, try to parse from textarea
        const csvText = textarea.value.trim();
        if (!csvText) {
          statusDiv.innerHTML = '<span style="color: #ef4444;">‚ö† Please select a CSV file or paste CSV content</span>';
          return;
        }
        
        try {
          const result = parseUrlListCsv(csvText);
          localStorage.setItem('manual_url_list', JSON.stringify(result.urls));
          statusDiv.innerHTML = `<span style="color: #10b981;">‚úì Loaded ${result.validUrls} URLs from ${result.totalRows} rows</span>`;
          debugLog(`‚úì Manual URL list loaded: ${result.validUrls} URLs from CSV`, 'success');
          showStatus(`URL list loaded! Found ${result.validUrls} URLs.`, 'success');
        } catch (error) {
          statusDiv.innerHTML = `<span style="color: #ef4444;">‚úó ${error.message}</span>`;
          debugLog(`‚úó URL list parse error: ${error.message}`, 'error');
          showStatus(`URL list error: ${error.message}`, 'error');
        }
        return;
      }
      
      const file = fileInput.files[0];
      debugLog(`Loading URL list from file: ${file.name} (${file.size} bytes)`, 'info');
      
      try {
        const fileText = await file.text();
        const result = parseUrlListCsv(fileText);
        
        // Store URLs in localStorage
        localStorage.setItem('manual_url_list', JSON.stringify(result.urls));
        
        // Also populate textarea with the CSV content
        textarea.value = fileText;
        
        statusDiv.innerHTML = `<span style="color: #10b981;">‚úì Loaded ${result.validUrls} URLs from ${result.totalRows} rows. Columns: ${result.headers.join(', ')}</span>`;
        debugLog(`‚úì URL list loaded from file: ${result.validUrls} URLs`, 'success');
        debugLog(`  File: ${file.name}, Columns: ${result.headers.join(', ')}`, 'info');
        showStatus(`URL list loaded! Found ${result.validUrls} URLs from ${file.name}.`, 'success');
        
        // Clear file input
        fileInput.value = '';
      } catch (error) {
        statusDiv.innerHTML = `<span style="color: #ef4444;">‚úó ${error.message}</span>`;
        debugLog(`‚úó URL list file error: ${error.message}`, 'error');
        showStatus(`URL list error: ${error.message}`, 'error');
      }
    }

    // Clear manual URL list
    function clearManualUrlList() {
      const textarea = document.getElementById('manualUrlList');
      const fileInput = document.getElementById('urlListFile');
      const statusDiv = document.getElementById('urlListStatus');
      
      textarea.value = '';
      fileInput.value = '';
      localStorage.removeItem('manual_url_list');
      statusDiv.innerHTML = '<span style="color: #666;">Manual URL list cleared</span>';
      debugLog('Manual URL list cleared', 'info');
      showStatus('Manual URL list cleared', 'success');
    }

    // Sync CSV from alan-shared-resources
    async function syncCSV() {
      const btn = document.getElementById('syncCsvBtn');
      const btnText = document.getElementById('syncCsvBtnText');
      const originalText = btnText.textContent;
      
      debugLog('=== CSV SYNC: Starting CSV sync verification ===', 'info');
      debugLog('Button clicked - initiating CSV sync check...', 'info');
      
      // Disable button and show loading state
      btn.disabled = true;
      btnText.textContent = '‚è≥ Syncing...';
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      debugLog('Button state: disabled, showing loading indicator', 'info');
      
      try {
        debugLog('Fetching /api/sync-csv endpoint...', 'info');
        const response = await fetch('/api/sync-csv', {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
        });
        
        debugLog(`API response status: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
        
        const data = await response.json();
        debugLog(`API response data: ${JSON.stringify(data).substring(0, 200)}...`, 'info');
        
        if (response.ok && data.status === 'ok') {
          const urlCount = data.data.totalUrls || 0;
          const source = data.source || 'unknown';
          
          debugLog(`‚úì CSV fetched successfully from ${source}`, 'success');
          debugLog(`  CSV URL: ${data.csvUrl || 'not provided'}`, 'info');
          debugLog(`  Total URLs fetched: ${urlCount}`, 'success');
          debugLog(`  CSV size: ${data.data.csvSize} bytes`, 'info');
          debugLog(`  Lines processed: ${data.data.linesProcessed || 'N/A'}`, 'info');
          debugLog(`  Fetched at: ${data.data.fetchedAt}`, 'info');
          
          // Show toast with URL count
          showStatus(`‚úÖ CSV synced from ${source}! Fetched ${urlCount} URLs.`, 'success');
          btnText.textContent = `‚úÖ ${urlCount} URLs`;
          
          // Reset button after 3 seconds
          setTimeout(() => {
            btnText.textContent = originalText;
            btn.style.opacity = '1';
            debugLog('Button reset to original state', 'info');
          }, 3000);
        } else {
          debugLog(`‚úó CSV sync failed`, 'error');
          debugLog(`  Error message: ${data.message || 'Unknown error'}`, 'error');
          debugLog(`  CSV URL attempted: ${data.csvUrl || 'not provided'}`, 'error');
          if (data.suggestion) {
            debugLog(`  Suggestion: ${data.suggestion}`, 'warn');
          }
          showStatus(`CSV sync failed: ${data.message}. ${data.suggestion || ''}`, 'error');
          btnText.textContent = '‚ùå Sync Failed';
          
          // Reset button after 5 seconds
          setTimeout(() => {
            btnText.textContent = originalText;
            btn.style.opacity = '1';
            debugLog('Button reset to original state after error', 'info');
          }, 5000);
        }
      } catch (error) {
        debugLog(`‚úó CSV sync error occurred`, 'error');
        debugLog(`  Error type: ${error.name || 'Unknown'}`, 'error');
        debugLog(`  Error message: ${error.message}`, 'error');
        if (error.stack) {
          debugLog(`  Stack trace: ${error.stack.substring(0, 300)}...`, 'error');
        }
        showStatus(`CSV sync error: ${error.message}. Please run "npm run sync:csv" locally.`, 'error');
        btnText.textContent = '‚ùå Error';
        
        // Reset button after 5 seconds
        setTimeout(() => {
          btnText.textContent = originalText;
          btn.style.opacity = '1';
          debugLog('Button reset to original state after exception', 'info');
        }, 5000);
      } finally {
        btn.disabled = false;
        btn.style.cursor = 'pointer';
        debugLog('=== CSV SYNC: Complete ===', 'info');
      }
    }

    // Update progress bar
    function updateProgress(percent, statusText) {
      const progressBar = document.getElementById('progressBar');
      const progressStatus = document.getElementById('progressStatus');
      if (progressBar) {
        progressBar.style.width = Math.min(100, Math.max(0, percent)) + '%';
        progressBar.textContent = Math.round(percent) + '%';
      }
      if (progressStatus) {
        progressStatus.textContent = statusText || 'Processing...';
      }
    }

    // Show status message
    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = `status ${type} show`;
      setTimeout(() => {
        status.classList.remove('show');
      }, 5000);
    }

    // Show completion summary modal
    function showCompletionModal(schemaAudit) {
      debugLog('showCompletionModal called', 'info');
      const modal = document.getElementById('completionModal');
      const content = document.getElementById('completionSummaryContent');
      
      debugLog(`Modal element found: ${modal ? 'yes' : 'no'}`, 'info');
      debugLog(`Content element found: ${content ? 'yes' : 'no'}`, 'info');
      
      if (!modal || !content) {
        debugLog('‚ö† Modal or content element not found, cannot show modal', 'error');
        return;
      }
      
      let html = '';
      
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data && schemaAudit.meta) {
        const data = schemaAudit.data;
        const meta = schemaAudit.meta;
        const diag = meta.diagnostic || {};
        
        const totalPages = data.totalPages || diag.totalPages || 0;
        const successfulPages = diag.successfulPages || totalPages;
        const failedPages = diag.failedPages || data.missingSchemaCount || 0;
        const isComplete = failedPages === 0;
        
        html += `<div style="margin-bottom: 1.5rem;">`;
        html += `<div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">`;
        html += `<span style="font-size: 2rem;">${isComplete ? '‚úÖ' : '‚ö†Ô∏è'}</span>`;
        html += `<h3 style="margin: 0; color: ${isComplete ? '#10b981' : '#f59e0b'};">
          ${isComplete ? 'Complete' : 'Incomplete'} Data
        </h3>`;
        html += `</div>`;
        
        html += `<div style="background: ${isComplete ? '#f0fdf4' : '#fffbeb'}; border-left: 4px solid ${isComplete ? '#10b981' : '#f59e0b'}; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">`;
        html += `<p style="margin: 0; color: #555; line-height: 1.6;">`;
        if (isComplete) {
          html += `All pages were successfully crawled. Dashboard data is complete and accurate.`;
        } else {
          html += `<strong>Warning:</strong> ${failedPages} page${failedPages !== 1 ? 's' : ''} failed to crawl. Dashboard data may be incomplete. Failed pages are counted as missing schema.`;
        }
        html += `</p>`;
        html += `</div>`;
        
        html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">`;
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Total URLs Scanned</div>`;
        html += `<div style="font-size: 1.5rem; font-weight: 600; color: #333;">${totalPages}</div>`;
        html += `</div>`;
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Successful Crawls</div>`;
        html += `<div style="font-size: 1.5rem; font-weight: 600; color: #10b981;">${successfulPages}</div>`;
        html += `</div>`;
        html += `</div>`;
        
        if (failedPages > 0) {
          // Get failed URLs from missingSchemaPages that have errors
          const failedUrls = (data.missingSchemaPages || []).filter(p => p.error).map(p => p.url);
          
          html += `<div style="background: #fef2f2; border-left: 4px solid #ef4444; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">`;
          html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Failed Crawls</div>`;
          html += `<div style="font-size: 1.5rem; font-weight: 600; color: #ef4444;">${failedPages}</div>`;
          
          if (diag.errorTypes && Object.keys(diag.errorTypes).length > 0) {
            html += `<div style="margin-top: 0.75rem; font-size: 0.85rem; color: #666;">`;
            html += `<strong>Error Breakdown:</strong><br>`;
            Object.entries(diag.errorTypes).forEach(([type, count]) => {
              html += `${type}: ${count}<br>`;
            });
            html += `</div>`;
          }
          
          // Add retry button if there are failed URLs
          if (failedUrls.length > 0) {
            html += `<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #fee2e2;">`;
            html += `<button id="retryFailedUrls" class="btn" style="background: #10b981; color: white; border-color: #10b981; width: 100%;" title="Retry crawling the ${failedUrls.length} failed URLs. This will rescan only the URLs that failed during the initial audit.">`;
            html += `üîÑ Retry Failed URLs (${failedUrls.length})`;
            html += `</button>`;
            html += `<div style="font-size: 0.8rem; color: #666; margin-top: 0.5rem; text-align: center;">Click to rescan only the failed URLs</div>`;
            html += `</div>`;
          }
          
          html += `</div>`;
        }
        
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px; margin-top: 1rem;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;"><strong>Schema Coverage</strong></div>`;
        html += `<div style="font-size: 1.25rem; font-weight: 600; color: #333;">${data.coverage || 0}%</div>`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-top: 0.25rem;">${data.pagesWithSchema || 0} pages with inline schema</div>`;
        html += `</div>`;
        
        html += `</div>`;
      } else {
        html += `<p>Unable to load audit summary data.</p>`;
      }
      
      content.innerHTML = html;
      modal.style.display = 'block';
      debugLog('Modal display set to block', 'info');
      debugLog(`Modal is now visible: ${modal.style.display}`, 'info');
      
      // Attach retry button handler if it exists
      const retryButton = document.getElementById('retryFailedUrls');
      if (retryButton) {
        retryButton.onclick = function() {
          retryFailedUrls(schemaAudit);
        };
      }
    }
    
    // Retry failed URLs from schema audit
    async function retryFailedUrls(schemaAudit) {
      if (!schemaAudit || !schemaAudit.data || !schemaAudit.data.missingSchemaPages) {
        debugLog('‚úó No failed URLs to retry', 'error');
        showStatus('No failed URLs found to retry', 'error');
        return;
      }
      
      // Extract failed URLs (those with errors)
      const failedUrls = schemaAudit.data.missingSchemaPages
        .filter(p => p.error)
        .map(p => p.url);
      
      if (failedUrls.length === 0) {
        debugLog('‚úó No failed URLs to retry', 'error');
        showStatus('No failed URLs found to retry', 'error');
        return;
      }
      
      debugLog(`üîÑ Retrying ${failedUrls.length} failed URLs...`, 'info');
      showStatus(`Retrying ${failedUrls.length} failed URLs...`, 'info');
      
      // Close the modal
      closeCompletionModal();
      
      // Show loading indicator
      document.getElementById('loading').classList.add('show');
      document.getElementById('dashboard').style.display = 'none';
      updateProgress(0, `Retrying ${failedUrls.length} failed URLs...`);
      
      try {
        updateProgress(20, 'Scanning failed URLs for schema markup...');
        debugLog(`Sending retry request for ${failedUrls.length} URLs`, 'info');
        
        // Call schema-audit API with only the failed URLs
        const schemaResponse = await fetch('/api/schema-audit', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ urls: failedUrls })
        });
        
        if (!schemaResponse.ok) {
          throw new Error(`Schema audit API returned error: ${schemaResponse.status}`);
        }
        
        const retrySchemaAudit = await schemaResponse.json();
        
        if (retrySchemaAudit.status !== 'ok') {
          throw new Error(retrySchemaAudit.message || 'Schema audit failed');
        }
        
        const retryData = retrySchemaAudit.data;
        const retrySuccessful = retryData.pagesWithSchema || 0;
        const retryStillFailed = (retryData.missingSchemaCount || 0);
        
        debugLog(`‚úì Retry completed: ${retrySuccessful} pages now have schema, ${retryStillFailed} still failed`, 'success');
        updateProgress(60, 'Merging retry results with original audit...');
        
        // Load original audit results from localStorage
        const savedAudit = loadAuditResults();
        if (savedAudit && savedAudit.schemaAudit && savedAudit.schemaAudit.data) {
          // Merge retry results with original schema audit
          const originalData = savedAudit.schemaAudit.data;
          const originalPages = originalData.pagesWithSchema || 0;
          const originalFailed = originalData.missingSchemaCount || 0;
          
          // Create merged schema audit data
          const mergedSchemaAudit = {
            ...savedAudit.schemaAudit,
            data: {
              ...originalData,
              // Update counts: add retry successful pages, remove retry successful from failed
              pagesWithSchema: originalPages + retrySuccessful,
              missingSchemaCount: Math.max(0, originalFailed - retrySuccessful),
              // Update missingSchemaPages: remove successfully retried URLs
              missingSchemaPages: (originalData.missingSchemaPages || []).filter(p => {
                // Keep only pages that weren't in the retry list or still failed
                return !failedUrls.includes(p.url) || (retryData.missingSchemaPages || []).some(rp => rp.url === p.url);
              }),
              // Update coverage
              coverage: ((originalPages + retrySuccessful) / originalData.totalPages) * 100
            }
          };
          
          // Update saved audit with merged results
          const mergedAudit = {
            ...savedAudit,
            schemaAudit: mergedSchemaAudit
          };
          
          // Recalculate scores with merged data
          const mergedScores = calculatePillarScores(savedAudit.searchData, mergedSchemaAudit);
          const mergedSnippetReadiness = calculateSnippetReadiness(mergedScores, savedAudit.searchData);
          
          // Save merged results
          saveAuditResults(mergedScores, savedAudit.searchData, mergedSnippetReadiness, mergedSchemaAudit);
          
          // Update retry button visibility
          updateRetryButtonVisibility(mergedSchemaAudit);
          
          // Refresh dashboard with merged results
          updateProgress(80, 'Refreshing dashboard with merged results...');
          displayDashboard(mergedScores, savedAudit.searchData, mergedSnippetReadiness, mergedSchemaAudit);
          
          updateProgress(100, 'Retry completed and dashboard updated!');
          showStatus(`Retry completed: ${retrySuccessful} URLs now have schema. Dashboard updated with merged results.`, 'success');
          
          // Show completion modal with merged results
          showCompletionModal(mergedSchemaAudit);
        } else {
          // No saved audit found, just show retry results
          updateProgress(80, 'Retry completed!');
          showCompletionModal(retrySchemaAudit);
          updateProgress(100, 'Retry completed!');
          showStatus(`Retry completed: ${retrySuccessful} URLs now have schema, ${retryStillFailed} still failed`, 'success');
          debugLog('‚ö† No saved audit found to merge with. Run full audit to see complete results.', 'warn');
        }
        
      } catch (error) {
        debugLog(`‚úó Retry error: ${error.message}`, 'error');
        showStatus(`Error retrying failed URLs: ${error.message}`, 'error');
      } finally {
        document.getElementById('loading').classList.remove('show');
        setTimeout(() => {
          updateProgress(0, 'Initializing audit scan...');
        }, 500);
      }
    }

    // Save audit results to localStorage
    function saveAuditResults(scores, searchData, snippetReadiness, schemaAudit) {
      try {
        const auditData = {
          scores,
          searchData,
          snippetReadiness,
          schemaAudit,
          timestamp: new Date().toISOString()
        };
        localStorage.setItem('last_audit_results', JSON.stringify(auditData));
        debugLog('‚úì Audit results saved to localStorage', 'success');
        
        // Update timestamp display
        updateAuditTimestamp(auditData.timestamp);
      } catch (error) {
        debugLog(`‚úó Error saving audit results: ${error.message}`, 'error');
      }
    }
    
    // Load audit results from localStorage
    function loadAuditResults() {
      try {
        const saved = localStorage.getItem('last_audit_results');
        if (saved) {
          const auditData = JSON.parse(saved);
          debugLog('‚úì Audit results loaded from localStorage', 'success');
          return auditData;
        }
      } catch (error) {
        debugLog(`‚úó Error loading audit results: ${error.message}`, 'error');
      }
      return null;
    }
    
    // Update audit timestamp display
    function updateAuditTimestamp(timestamp) {
      const timestampElement = document.getElementById('lastAuditTime');
      const snippetTimestampElement = document.getElementById('snippetReadinessAuditTime');
      const snippetTimestampContainer = document.getElementById('snippetReadinessTimestamp');
      const radarTimestampElement = document.getElementById('radarChartAuditTime');
      const radarTimestampContainer = document.getElementById('radarChartTimestamp');
      
      if (timestamp) {
        const date = new Date(timestamp);
        const formatted = date.toLocaleString('en-GB', {
          day: '2-digit',
          month: 'short',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        if (timestampElement) {
          timestampElement.textContent = formatted;
        }
        
        // Update snippet readiness timestamp
        if (snippetTimestampElement) {
          snippetTimestampElement.textContent = formatted;
        }
        if (snippetTimestampContainer) {
          snippetTimestampContainer.style.display = 'block';
        }
        
        // Update radar chart timestamp
        if (radarTimestampElement) {
          radarTimestampElement.textContent = formatted;
        }
        if (radarTimestampContainer) {
          radarTimestampContainer.style.display = 'block';
        }
      } else {
        if (timestampElement) {
          timestampElement.textContent = 'Not yet run';
        }
        if (snippetTimestampContainer) {
          snippetTimestampContainer.style.display = 'none';
        }
        if (radarTimestampContainer) {
          radarTimestampContainer.style.display = 'none';
        }
      }
    }
    
    // Save audit results to Supabase for historical tracking
    async function saveAuditToSupabase(propertyUrl, scores, searchData, snippetReadiness, schemaAudit) {
      try {
        const auditDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
        
        const response = await fetch('/api/supabase/save-audit', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            propertyUrl,
            auditDate,
            schemaAudit,
            scores,
            searchData,
            snippetReadiness
          })
        });
        
        if (response.ok) {
          const result = await response.json();
          debugLog('‚úì Audit results saved to Supabase', 'success');
        } else {
          const error = await response.json();
          // Don't show error to user - Supabase is optional for now
          debugLog(`‚ö† Could not save to Supabase: ${error.message || 'Unknown error'}`, 'warn');
        }
      } catch (error) {
        // Don't show error to user - Supabase is optional for now
        debugLog(`‚ö† Supabase save error: ${error.message}`, 'warn');
      }
    }
    
    // Fetch historical Content/Schema data from Supabase
    async function fetchContentSchemaHistory(propertyUrl, startDate, endDate) {
      try {
        const response = await fetch(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDate}&endDate=${endDate}`);
        
        if (response.ok) {
          const result = await response.json();
          if (result.status === 'ok' && result.data) {
            debugLog(`‚úì Fetched ${result.count} historical Content/Schema records from Supabase`, 'success');
            return result.data;
          }
        } else {
          const error = await response.json();
          debugLog(`‚ö† Could not fetch from Supabase: ${error.message || 'Unknown error'}`, 'warn');
        }
      } catch (error) {
        debugLog(`‚ö† Supabase fetch error: ${error.message}`, 'warn');
      }
      return [];
    }
    
    // Update retry button visibility based on failed URLs
    function updateRetryButtonVisibility(schemaAudit) {
      const retryBtn = document.getElementById('retryFailedUrlsBtn');
      if (!retryBtn) return;
      
      if (schemaAudit && schemaAudit.data && schemaAudit.data.missingSchemaPages) {
        const failedUrls = schemaAudit.data.missingSchemaPages.filter(p => p.error);
        if (failedUrls.length > 0) {
          retryBtn.style.display = 'inline-block';
          retryBtn.textContent = `üîÑ Retry Failed URLs (${failedUrls.length})`;
        } else {
          retryBtn.style.display = 'none';
        }
      } else {
        retryBtn.style.display = 'none';
      }
    }

    // Close completion modal
    function closeCompletionModal() {
      const modal = document.getElementById('completionModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    // Close modal when clicking outside
    window.onclick = function(event) {
      const modal = document.getElementById('completionModal');
      if (event.target === modal) {
        closeCompletionModal();
      }
    }

    // Calculate RAG status from score
    function getRAGStatus(score) {
      if (score >= 70) return { status: 'green', label: 'Green' };
      if (score >= 40) return { status: 'amber', label: 'Amber' };
      return { status: 'red', label: 'Red' };
    }

    // Helper: clamp score to 0-100 and round
    function clampScore(value) {
      return Math.max(0, Math.min(100, Math.round(value)));
    }

    // Calculate pillar scores (deterministic, based on GSC data and schema audit)
    function calculatePillarScores(data, schemaAudit = null) {
      // Use new API response format - get values from GSC overview
      const position = data.averagePosition || 40; // 1 (best) - 100 (worst)
      const ctr = data.ctr || 0; // 0-100 percentage from API (e.g., 10 = 10%)

      // Map average position (1-40) -> 100-10 (better position => higher score)
      const posScore = (() => {
        const clampedPos = Math.max(1, Math.min(40, position));
        const scale = (clampedPos - 1) / 39; // 0 to 1
        return 100 - scale * 90; // 100 to 10
      })();

      // Visibility is primarily driven by position
      const visibility = clampScore(posScore);

      // Authority: use exact formula with GSC values
      // Convert ctr from percentage (0-100) to decimal (0-1), then apply formula
      const ctrDecimal = ctr / 100; // Convert percentage to decimal (e.g., 10% -> 0.10)
      const ctrScore = Math.min((ctrDecimal / 0.10) * 100, 100);
      const authority = clampScore(0.6 * ctrScore + 0.4 * posScore);

      // Local Entity: slightly smoother blend, anchored around 60
      const localEntity = clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));

      // Service Area: currently derived from Local Entity but slightly lower
      const serviceArea = clampScore(localEntity - 5);

      // Content/Schema: weighted calculation based on foundation schemas, rich results, coverage, and diversity
      let contentSchema;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        const allTypes = new Set();
        
        // Collect all schema types from schemaTypes array
        if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          schemaData.schemaTypes.forEach(item => {
            if (item.type) allTypes.add(item.type);
          });
        }
        
        // 1. Foundation Schemas Score (30% weight): Organization, Person, WebSite, BreadcrumbList
        const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
        const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
        const foundationScore = (foundationPresent / foundationTypes.length) * 100;
        
        // 2. Rich Result Eligibility Score (35% weight): Count eligible rich result types
        const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'Recipe'];
        const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
        const richResultScore = (richEligibleCount / richResultTypes.length) * 100;
        
        // 3. Coverage Score (20% weight): Pages with schema / total pages
        const coverageScore = schemaData.coverage || 0;
        
        // 4. Type Diversity Score (15% weight): Number of unique schema types (normalized to 15 types)
        const uniqueTypesCount = allTypes.size;
        const diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
        
        // Weighted calculation: 30% foundation + 35% rich results + 20% coverage + 15% diversity
        contentSchema = clampScore(
          foundationScore * 0.30 +
          richResultScore * 0.35 +
          coverageScore * 0.20 +
          diversityScore * 0.15
        );
        
        debugLog(`Content/Schema calculation: Foundation=${foundationScore.toFixed(1)}% (${foundationPresent}/4), Rich Results=${richResultScore.toFixed(1)}% (${richEligibleCount}/10), Coverage=${coverageScore.toFixed(1)}%, Diversity=${diversityScore.toFixed(1)}% (${uniqueTypesCount} types)`, 'info');
      } else {
        // Fallback: if no schema audit data, return 0 (can't calculate without data)
        contentSchema = 0;
        debugLog('‚ö† No schema audit data available, Content/Schema score set to 0', 'warn');
      }

      const scores = {
        localEntity,
        serviceArea,
        authority,
        visibility,
        contentSchema
      };

      debugLog(`Deterministic pillar scores: ${JSON.stringify(scores)}`, 'info');
      return scores;
    }

    function calculateSnippetReadiness(scores, data) {
      // Snippet readiness combines:
      // 1. Content/Schema score (structured data quality)
      // 2. Visibility score (SERP feature presence)
      // 3. Authority score (content depth and trust)
      // Weighted average: 40% Content/Schema, 35% Visibility, 25% Authority
      const readiness = (
        scores.contentSchema * 0.4 +
        scores.visibility * 0.35 +
        scores.authority * 0.25
      );
      return Math.round(Math.min(100, Math.max(0, readiness)));
    }

    // Fetch real data from Google Search Console API using unified endpoint
    // Note: apiKey parameter kept for compatibility but not used (endpoint uses OAuth2)
    async function fetchSearchConsoleData(apiKey, propertyUrl, days) {
      debugLog(`Fetching real GSC data for ${days} days...`, 'info');
      
      // Calculate date range
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);
      
      // Format dates as YYYY-MM-DD
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      const startDateStr = formatDate(startDate);
      const endDateStr = formatDate(endDate);
      
      debugLog(`Date range: ${startDateStr} to ${endDateStr}`, 'info');
      
      try {
        // Call unified GSC entity metrics endpoint
        const response = await fetch(`/api/aigeo/gsc-entity-metrics?property=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDateStr}`);

        if (!response.ok) {
          const errorData = await response.json();
          debugLog(`‚úó GSC API error: ${errorData.message || errorData.error}`, 'error');
          if (errorData.details) {
            debugLog(`Details: ${errorData.details}`, 'error');
          }
          
          // If OAuth not configured, show helpful message
          if (errorData.message && errorData.message.includes('OAuth2 credentials not configured')) {
            throw new Error('Google Search Console OAuth2 credentials not configured. Please set GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, and GOOGLE_REFRESH_TOKEN in Vercel environment variables.');
          }
          
          throw new Error(errorData.message || errorData.error || 'Failed to fetch Search Console data');
        }

        const gsc = await response.json();
        
        if (gsc.status !== 'ok') {
          throw new Error(gsc.message || 'Failed to fetch Search Console data');
        }
        
        debugLog(`‚úì Real GSC data fetched: ${gsc.data.overview.totalClicks} clicks, ${gsc.data.overview.totalImpressions} impressions`, 'success');
        
        // Return data in format expected by existing code
        return {
          totalClicks: gsc.data.overview.totalClicks || 0,
          totalImpressions: gsc.data.overview.totalImpressions || 0,
          averagePosition: gsc.data.overview.avgPosition || 0,
          ctr: gsc.data.overview.ctr || 0, // Already 0-100 from API
          topQueries: gsc.data.topQueries || [],
          timeseries: gsc.data.timeseries || [], // For trend chart
          dateRange: days,
          // Store full GSC response for trend chart access
          _gscResponse: gsc
        };
      } catch (error) {
        debugLog(`‚úó Error fetching GSC data: ${error.message}`, 'error');
        throw error;
      }
    }

    // Run the audit
    async function runAudit() {
      debugLog('=== AUDIT START: Beginning audit scan ===', 'info');
      
      // Get API key - prioritize Vercel env var, then loaded key, then localStorage
      let apiKey = window._loadedApiKey;
      
      // Try Vercel environment variable first
      if (!apiKey) {
        try {
          debugLog('Fetching API key from Vercel environment variable...', 'info');
          const response = await fetch('/api/get-api-key');
          if (response.ok) {
            const data = await response.json();
            if (data.apiKey) {
              apiKey = data.apiKey;
              debugLog('‚úì Using API key from Vercel environment variable', 'success');
              window._loadedApiKey = apiKey;
            }
          }
        } catch (e) {
          debugLog('Vercel env var endpoint not available', 'info');
        }
      }
      
      // Fall back to config.js
      if (!apiKey && window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey) {
        apiKey = window.API_CONFIG.googleSearchConsoleApiKey;
        debugLog('‚úì Using API key from config.js', 'success');
        window._loadedApiKey = apiKey;
      }
      
      // Fall back to localStorage
      if (!apiKey) {
        apiKey = localStorage.getItem('gsc_api_key');
        if (apiKey) {
          debugLog('‚úì Using API key from localStorage', 'success');
          window._loadedApiKey = apiKey;
        }
      }
      
      const propertyUrl = document.getElementById('propertyUrl').value;
      const dateRange = parseInt(document.getElementById('dateRange').value);
      
      debugLog(`Property URL: ${propertyUrl}`, 'info');
      debugLog(`Date Range: ${dateRange} days`, 'info');

      // Note: API key no longer required - new endpoint uses OAuth2 from env vars
      if (!propertyUrl) {
        debugLog('‚úó No property URL provided', 'error');
        showStatus('Please enter your property URL', 'error');
        return;
      }

      debugLog('Showing loading indicator...', 'info');
      document.getElementById('loading').classList.add('show');
      document.getElementById('dashboard').style.display = 'none';
      updateProgress(0, 'Initializing audit scan...');

      // Declare schemaAudit outside try block so it's accessible in finally
      let schemaAudit = null;

      try {
        updateProgress(10, 'Fetching Search Console data...');
        debugLog('Fetching Search Console data...', 'info');
        // Fetch data
        const searchData = await fetchSearchConsoleData(apiKey, propertyUrl, dateRange);
        debugLog('‚úì Search Console data fetched successfully', 'success');
        debugLog(`Data: ${JSON.stringify(searchData).substring(0, 200)}...`, 'info');
        
        updateProgress(40, 'Fetching schema audit data...');
        debugLog('Fetching schema audit data...', 'info');
        // Fetch schema audit data
        try {
          // Check if manual URL list is available
          const manualUrlList = localStorage.getItem('manual_url_list');
          let schemaRequest;
          
          if (manualUrlList) {
            try {
              const urls = JSON.parse(manualUrlList);
              debugLog(`Using manual URL list: ${urls.length} URLs`, 'info');
              updateProgress(45, `Crawling ${urls.length} URLs for schema markup...`);
              schemaRequest = fetch('/api/schema-audit', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ urls })
              });
            } catch (e) {
              debugLog('‚ö† Failed to parse manual URL list, using default CSV', 'warn');
              updateProgress(45, 'Loading URLs from CSV and crawling for schema markup...');
              schemaRequest = fetch('/api/schema-audit');
            }
          } else {
            debugLog('No manual URL list, using default CSV source', 'info');
            updateProgress(45, 'Loading URLs from CSV and crawling for schema markup...');
            schemaRequest = fetch('/api/schema-audit');
          }
          
          const schemaResponse = await schemaRequest;
          if (schemaResponse.ok) {
            schemaAudit = await schemaResponse.json();
            if (schemaAudit.status === 'ok') {
              debugLog('‚úì Schema audit data fetched successfully', 'success');
              debugLog(`Schema coverage: ${schemaAudit.data.coverage}%`, 'info');
              if (manualUrlList) {
                debugLog('  Source: Manual URL list', 'info');
              } else {
                debugLog('  Source: CSV (GitHub/hosted)', 'info');
              }
              
              // Log comprehensive diagnostic info if available
              if (schemaAudit.meta && schemaAudit.meta.diagnostic) {
                const diag = schemaAudit.meta.diagnostic;
                debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                debugLog('üìä SCHEMA AUDIT DIAGNOSTICS', 'info');
                debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                debugLog('üìà PAGE COUNTS:', 'info');
                debugLog(`  ‚Ä¢ Total pages scanned: ${diag.totalPages}`, 'info');
                debugLog(`  ‚Ä¢ Successful crawls: ${diag.successfulPages || diag.totalPages}`, 'info');
                debugLog(`  ‚Ä¢ Failed crawls: ${diag.failedPages || 0}`, diag.failedPages > 0 ? 'warn' : 'info');
                if (diag.failedPages > 0) {
                  debugLog(`    ‚ö† Failed crawls are counted as pages without schema`, 'warn');
                  
                  // Show error breakdown if available
                  if (diag.errorTypes && Object.keys(diag.errorTypes).length > 0) {
                    debugLog('', 'info'); // Empty line
                    debugLog('  üîç ERROR BREAKDOWN:', 'warn');
                    Object.entries(diag.errorTypes).forEach(([type, count]) => {
                      debugLog(`    ‚Ä¢ ${type}: ${count} pages`, 'warn');
                      if (diag.errorExamples && diag.errorExamples[type]) {
                        const example = diag.errorExamples[type];
                        debugLog(`      Example: ${example.url}`, 'info');
                        debugLog(`      Error: ${example.error}`, 'info');
                      }
                    });
                  }
                }
                debugLog(`  ‚Ä¢ Pages with inline schema: ${diag.pagesWithInlineSchema}`, 'info');
                debugLog(`  ‚Ä¢ Pages without inline schema: ${diag.pagesWithoutInlineSchema}`, 'info');
                if (diag.failedPages > 0) {
                  debugLog(`    (includes ${diag.failedPages} failed crawls)`, 'info');
                }
                debugLog(`  ‚Ä¢ Pages with inherited schema: ${diag.pagesWithInheritedSchema}`, 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                if (diag.urlsWithoutSchemas && diag.urlsWithoutSchemas.length > 0) {
                  debugLog('üîó URLs WITHOUT SCHEMAS:', 'info');
                  diag.urlsWithoutSchemas.forEach(url => {
                    debugLog(`  ‚Ä¢ ${url}`, 'info');
                  });
                  if (diag.pagesWithoutInlineSchema > diag.urlsWithoutSchemas.length) {
                    debugLog(`  ... and ${diag.pagesWithoutInlineSchema - diag.urlsWithoutSchemas.length} more`, 'info');
                  }
                  debugLog('', 'info'); // Empty line for spacing
                }
                
                debugLog('üîç MISSING SCHEMA BREAKDOWN:', 'info');
                debugLog(`  ‚Ä¢ Pages with parent but no inherited: ${diag.pagesWithParentButNoInherited}`, 'info');
                debugLog(`  ‚Ä¢ Pages with parent but not checked: ${diag.pagesWithParentButNotChecked}`, diag.pagesWithParentButNotChecked > 0 ? 'warn' : 'info');
                debugLog(`  ‚Ä¢ Pages without parent page: ${diag.pagesWithoutParent}`, 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                debugLog('‚úÖ VALIDATION:', 'info');
                debugLog(`  ‚Ä¢ Total missing pages (calculated): ${diag.totalMissing}`, 'info');
                debugLog(`  ‚Ä¢ Expected missing (total - inline - inherited): ${diag.expectedMissing}`, 'info');
                
                if (diag.mismatch) {
                  debugLog('', 'info'); // Empty line for spacing
                  debugLog(`  ‚ùå MISMATCH DETECTED!`, 'error');
                  debugLog(`  ${diag.mismatchDetails}`, 'error');
                  debugLog(`  This indicates pages are being double-counted or missed in the calculation.`, 'error');
                } else {
                  debugLog(`  ‚úì Counts match correctly`, 'success');
                }
                
                debugLog('', 'info'); // Empty line for spacing
                debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
              }
            } else {
              debugLog('‚ö† Schema audit returned error, using fallback', 'warn');
            }
          } else {
            debugLog('‚ö† Schema audit endpoint not available, using fallback', 'warn');
          }
        } catch (schemaError) {
          debugLog(`‚ö† Schema audit error: ${schemaError.message}, using fallback`, 'warn');
        }
        
        updateProgress(70, 'Calculating pillar scores...');
        debugLog('Calculating pillar scores...', 'info');
        // Calculate scores (pass schema audit data)
        const scores = calculatePillarScores(searchData, schemaAudit);
        debugLog('‚úì Pillar scores calculated', 'success');
        debugLog(`Scores: ${JSON.stringify(scores)}`, 'info');

        updateProgress(85, 'Calculating snippet readiness...');
        debugLog('Calculating snippet readiness...', 'info');
        const snippetReadiness = calculateSnippetReadiness(scores, searchData);
        debugLog(`Snippet readiness: ${snippetReadiness}`, 'info');

        updateProgress(95, 'Generating dashboard...');
        debugLog('Displaying dashboard...', 'info');
        // Display results (pass schema audit data)
        displayDashboard(scores, searchData, snippetReadiness, schemaAudit);
        
        updateProgress(100, 'Audit completed successfully!');
        debugLog('=== AUDIT COMPLETE: Success ===', 'success');
        
        // Save audit results to localStorage
        saveAuditResults(scores, searchData, snippetReadiness, schemaAudit);
        
        // Save audit results to Supabase for historical tracking
        saveAuditToSupabase(propertyUrl, scores, searchData, snippetReadiness, schemaAudit);
        
        showStatus('Audit completed successfully!', 'success');
      } catch (error) {
        debugLog(`‚úó AUDIT ERROR: ${error.message}`, 'error');
        debugLog(`Stack trace: ${error.stack}`, 'error');
        showStatus('Error running audit: ' + error.message, 'error');
        console.error(error);
      } finally {
        debugLog('Hiding loading indicator...', 'info');
        document.getElementById('loading').classList.remove('show');
        
        // Show completion summary modal
        debugLog(`Schema audit available for modal: ${schemaAudit ? 'yes' : 'no'}`, 'info');
        if (schemaAudit) {
          debugLog('Showing completion modal...', 'info');
          setTimeout(() => {
            showCompletionModal(schemaAudit);
          }, 500);
        } else {
          debugLog('‚ö† No schema audit data available for modal', 'warn');
        }
        
        // Reset progress bar for next run
        setTimeout(() => {
          updateProgress(0, 'Initializing audit scan...');
        }, 500);
      }
    }

    // Display dashboard
    async function displayDashboard(scores, data, snippetReadiness = 0, schemaAudit = null) {
      // Update timestamp if this is a fresh display
      const saved = loadAuditResults();
      if (saved && saved.timestamp) {
        updateAuditTimestamp(saved.timestamp);
      }
      
      // Update retry button visibility
      updateRetryButtonVisibility(schemaAudit);
      
      debugLog('=== DISPLAY DASHBOARD: Starting ===', 'info');
      
      // Show dashboard first (canvas elements need to be visible for Chart.js)
      const dashboardDiv = document.getElementById('dashboard');
      if (!dashboardDiv) {
        debugLog('‚úó Dashboard div not found', 'error');
        console.error('Dashboard div not found');
        return;
      }
      debugLog('‚úì Dashboard div found', 'success');
      dashboardDiv.style.display = 'block';
      debugLog('Dashboard div displayed', 'info');
      
      // Update trend chart description with date range
      const dateRange = parseInt(document.getElementById('dateRange').value) || 30;
      const trendDesc = document.getElementById('trendChartDescription');
      if (trendDesc) {
        let rangeText = '';
        if (dateRange === 30) rangeText = 'Last 30 Days';
        else if (dateRange === 60) rangeText = 'Last 60 Days';
        else if (dateRange === 90) rangeText = 'Last 90 Days';
        else if (dateRange === 120) rangeText = 'Last 120 Days';
        else if (dateRange === 180) rangeText = 'Last 6 Months';
        else if (dateRange === 365) rangeText = 'Last 12 Months';
        else if (dateRange === 540) rangeText = 'Last 18 Months';
        else rangeText = `Last ${dateRange} Days`;
        trendDesc.textContent = `Historical performance tracking for Local Entity, Visibility, and Authority pillars over ${rangeText.toLowerCase()}.`;
      }
      
      const pillarNames = {
        localEntity: 'Local Entity',
        serviceArea: 'Service Area',
        authority: 'Authority',
        visibility: 'Visibility',
        contentSchema: 'Content / Schema'
      };
      
      // Define pillar weightings and order by weight (highest to lowest)
      const pillarWeights = {
        authority: 0.30,        // 30% - E-A-T is crucial for AI trust
        contentSchema: 0.25,     // 25% - Structured data is key for AI understanding
        visibility: 0.20,        // 20% - How AI surfaces your content
        localEntity: 0.15,       // 15% - Entity recognition important but not critical
        serviceArea: 0.10         // 10% - Less critical for AI search
      };
      
      // Sort pillars by weight (highest to lowest) for consistent ordering
      const getOrderedPillars = (scoresObj) => {
        return Object.entries(scoresObj).sort((a, b) => {
          return (pillarWeights[b[0]] || 0) - (pillarWeights[a[0]] || 0);
        });
      };

      // Create pillar cards (ordered by weight)
      const pillarCards = document.getElementById('pillarCards');
      pillarCards.innerHTML = '';

      getOrderedPillars(scores).forEach(([key, score]) => {
        const rag = getRAGStatus(score);
        const card = document.createElement('div');
        card.className = 'pillar-card';
        
        // Get pillar description with data source info
        const descriptions = {
          localEntity: 'How clearly your business and you as a person are recognised as entities by AI search systems. <strong>Data Source:</strong> ‚ö†Ô∏è Currently derived from search performance (GSC position/CTR). Real local signals API integration pending.',
          serviceArea: 'How well AI understands where you operate and which regions you serve. <strong>Data Source:</strong> ‚ö†Ô∏è Currently derived from Local Entity score. Real service area data from Google Business Profile pending.',
          authority: 'E-A-T (Experience, Expertise, Authoritativeness, Trustworthiness): Perceived expertise and trust in the topic space. <strong>Data Source:</strong> ‚úÖ Live data from Google Search Console (CTR + position). Backlink metrics pending.',
          visibility: 'How prominently your content appears in AI-powered search results and featured snippets. <strong>Data Source:</strong> ‚úÖ Live data from Google Search Console (impressions, clicks, position, SERP features).',
          contentSchema: 'Quality and completeness of structured data markup across your domain. <strong>Data Source:</strong> ‚úÖ Live data from schema audit. <strong>Calculation:</strong> Foundation schemas (30%) + Rich Results (35%) + Coverage (20%) + Diversity (15%).'
        };
        
        card.innerHTML = `
          <h3>${pillarNames[key]}</h3>
          <div class="pillar-score rag-${rag.status}">${Math.round(score)}</div>
          <div class="rag-badge ${rag.status}">${rag.label}</div>
          <p style="font-size: 0.85rem; color: #666; margin-top: 0.5rem; line-height: 1.5; flex-grow: 1;">${descriptions[key] || ''}</p>
        `;
        pillarCards.appendChild(card);
      });
      
      // Remove existing scorecard table if it exists
      const existingScorecard = pillarCards.parentNode.querySelector('.scorecard-section');
      if (existingScorecard) {
        existingScorecard.remove();
      }
      
      // Add pillar scorecard table
      const scorecardTable = document.createElement('div');
      scorecardTable.className = 'scorecard-section';
      scorecardTable.innerHTML = `
        <h3 style="margin: 0 0 1rem 0; color: var(--brand-orange);">Pillar Scorecard</h3>
        <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow-x: auto;">
          <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
            <thead>
              <tr style="background: #f5f5f5;">
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600;">Pillar</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600;">Score</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600;">Weight</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600;">Status</th>
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 45%;">Description</th>
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 20%;">Improvement Suggestions</th>
              </tr>
            </thead>
            <tbody>
              ${getOrderedPillars(scores).map(([key, score], index) => {
                const rag = getRAGStatus(score);
                
                // Build Content/Schema description with schema audit data
                let contentSchemaDesc = 'Quality and completeness of structured data markup across your domain. <strong>AI Importance:</strong> Structured data is the primary way AI understands your content. Schema markup directly feeds AI systems, enabling them to extract facts, relationships, and context for use in AI Overviews and answer generation. <strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from schema audit (crawls actual website pages for JSON-LD markup). <strong>Calculation:</strong> Weighted score based on Foundation schemas (30%), Rich Result eligibility (35%), Coverage (20%), and Type Diversity (15%).';
                
                if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
                  const schemaData = schemaAudit.data;
                  const { coverage, totalPages, pagesWithSchema, missingSchemaCount, missingSchemaPages, schemaTypes } = schemaData;
                  
                  // Calculate foundation schemas
                  const allTypes = new Set();
                  if (schemaTypes && Array.isArray(schemaTypes)) {
                    schemaTypes.forEach(item => {
                      if (item.type) allTypes.add(item.type);
                    });
                  }
                  const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
                  const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
                  
                  // Count rich result types
                  const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
                  const uniqueTypesCount = allTypes.size;
                  
                  contentSchemaDesc += ` <strong>Data Checked:</strong> Foundation schemas: ${foundationPresent}/4 (${foundationTypes.filter(t => allTypes.has(t)).join(', ') || 'none'}), Rich result types: ${richEligibleCount}/10 eligible, Coverage: ${coverage}% (${pagesWithSchema}/${totalPages} pages), Type diversity: ${uniqueTypesCount} unique types. `;
                  
                  if (schemaTypes && schemaTypes.length > 0) {
                    const topTypes = schemaTypes.slice(0, 10).map(t => `${t.type} (${t.count})`).join(', ');
                    contentSchemaDesc += `Schema types found: ${topTypes}. `;
                  }
                  
                  if (schemaData.missingTypes && schemaData.missingTypes.length > 0) {
                    contentSchemaDesc += `Missing foundation types: ${schemaData.missingTypes.join(', ')}. `;
                  }
                  
                  const richTypes = Object.entries(schemaData.richEligible || {})
                    .filter(([type, eligible]) => eligible)
                    .map(([type]) => type);
                  if (richTypes.length > 0) {
                    contentSchemaDesc += `Rich result eligible: ${richTypes.join(', ')}.`;
                  }
                } else {
                  contentSchemaDesc += ' <strong>Data Checked:</strong> Foundation schemas (Organization, Person, WebSite, BreadcrumbList), Rich result eligibility (Article, Event, Course, FAQ, HowTo, VideoObject, Recipe, Product, LocalBusiness, Review), schema coverage percentage, schema type diversity.';
                }
                
                const descriptions = {
                  localEntity: 'Consistency and clarity of brand, person and business entity signals. <strong>AI Importance:</strong> AI systems rely on clear entity signals to understand who you are and connect your brand across platforms. Strong entity recognition helps AI include you in knowledge panels and entity-based results. <strong>Data Source:</strong> ‚ö†Ô∏è <span style="color: #f59e0b;">Derived calculation</span> from GSC position/CTR (not using real local signals yet). <strong>Data Checked:</strong> Currently calculated from search performance metrics. Real data pending: LocalBusiness schema presence, NAP consistency, Google Business Profile data, knowledge panel detection.',
                  serviceArea: 'How clearly AI understands where lessons/workshops run and which regions you cover. <strong>AI Importance:</strong> AI uses geographic signals to match queries with local intent. Clear service area data helps AI surface your content for location-specific searches and local AI Overviews. <strong>Data Source:</strong> ‚ö†Ô∏è <span style="color: #f59e0b;">Derived calculation</span> from Local Entity score (not using real service area data yet). <strong>Data Checked:</strong> Currently calculated from Local Entity. Real data pending: ServiceArea schema markup, Google Business Profile service areas, geographic keywords, location pages.',
                  authority: 'E-A-T (Experience, Expertise, Authoritativeness, Trustworthiness): Depth of educational content, references, reviews, external citations, and demonstrated expertise. <strong>AI Importance:</strong> E-A-T is critical for AI systems - they prioritize authoritative, trustworthy sources. Strong E-A-T signals help AI confidently feature your content in AI Overviews and answer boxes. <strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from Google Search Console API. <strong>Data Checked:</strong> CTR (${data.ctr ? data.ctr.toFixed(2) : 0}%), average position (${data.averagePosition ? data.averagePosition.toFixed(1) : 0}), clicks (${data.totalClicks || 0}), impressions (${data.totalImpressions || 0}). Backlink metrics pending integration.',
                  visibility: 'Frequency and prominence in organic search, local pack, snippets and AI Overviews. <strong>AI Importance:</strong> AI systems learn from existing search performance. Higher visibility signals quality and relevance, making AI more likely to surface your content in AI-powered results and featured snippets. <strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from Google Search Console API. <strong>Data Checked:</strong> Average position (${data.averagePosition ? data.averagePosition.toFixed(1) : 0}), CTR (${data.ctr ? data.ctr.toFixed(2) : 0}%), total clicks (${data.totalClicks || 0}), total impressions (${data.totalImpressions || 0}), SERP feature appearances.',
                  contentSchema: contentSchemaDesc
                };
                
                // Generate dynamic next steps based on actual data and scores
                const getNextSteps = (pillarKey, pillarScore, gscData, schemaData) => {
                  const steps = [];
                  
                  switch(pillarKey) {
                    case 'contentSchema':
                      if (schemaData && schemaData.status === 'ok' && schemaData.data) {
                        const schemaAuditData = schemaData.data;
                        const { coverage, missingSchemaCount, totalPages, pagesWithSchema, schemaTypes, richEligible, missingTypes } = schemaAuditData;
                        
                        // Collect all types for analysis
                        const allTypes = new Set();
                        if (schemaTypes && Array.isArray(schemaTypes)) {
                          schemaTypes.forEach(item => {
                            if (item.type) allTypes.add(item.type);
                          });
                        }
                        
                        // 1. Foundation Schemas (30% weight)
                        const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
                        const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
                        const foundationMissing = foundationTypes.filter(type => !allTypes.has(type));
                        
                        if (foundationPresent < 4) {
                          steps.push(`<strong>Foundation schemas (30%):</strong> ${foundationPresent}/4 present. Add: ${foundationMissing.join(', ')}`);
                        } else {
                          steps.push(`<strong>Foundation schemas (30%):</strong> ‚úÖ All 4 present (Organization, Person, WebSite, BreadcrumbList)`);
                        }
                        
                        // 2. Rich Result Eligibility (35% weight)
                        const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'Recipe'];
                        const richEligibleCount = Object.values(richEligible || {}).filter(eligible => eligible === true).length;
                        const richMissing = richResultTypes.filter(type => !richEligible[type]);
                        
                        if (richEligibleCount < 10) {
                          steps.push(`<strong>Rich results (35%):</strong> ${richEligibleCount}/10 eligible. Add: ${richMissing.slice(0, 3).join(', ')}${richMissing.length > 3 ? '...' : ''}`);
                        } else {
                          steps.push(`<strong>Rich results (35%):</strong> ‚úÖ All 10 types eligible`);
                        }
                        
                        // 3. Coverage (20% weight)
                        if (coverage < 100) {
                          steps.push(`<strong>Coverage (20%):</strong> ${coverage}% - Add schema to ${missingSchemaCount || 0} pages without markup`);
                        } else {
                          steps.push(`<strong>Coverage (20%):</strong> ‚úÖ 100% - All pages have schema`);
                        }
                        
                        // 4. Type Diversity (15% weight)
                        const uniqueTypesCount = allTypes.size;
                        if (uniqueTypesCount < 15) {
                          steps.push(`<strong>Diversity (15%):</strong> ${uniqueTypesCount} unique types. Add more schema types to reach 15+ for maximum score`);
                        } else {
                          steps.push(`<strong>Diversity (15%):</strong> ‚úÖ ${uniqueTypesCount} unique types (excellent diversity)`);
                        }
                      } else {
                        steps.push(`<strong>Status:</strong> Schema audit data not available - run audit to see detailed metrics`);
                      }
                      break;
                      
                    case 'visibility':
                      if (gscData) {
                        const position = gscData.averagePosition || 0;
                        const ctr = gscData.ctr || 0;
                        
                        if (position > 10) {
                          steps.push(`<strong>Average position: ${position.toFixed(1)}</strong> - Target top 10 positions (currently ranking ${position > 20 ? 'below' : 'in'} page ${Math.ceil(position / 10)})`);
                        } else {
                          steps.push(`<strong>Average position: ${position.toFixed(1)}</strong> - Excellent! Maintain top 10 rankings`);
                        }
                        
                        if (ctr < 2.0) {
                          steps.push(`<strong>CTR: ${ctr.toFixed(2)}%</strong> - Improve click-through rate (target: 2%+) with better titles/meta descriptions`);
                        } else {
                          steps.push(`<strong>CTR: ${ctr.toFixed(2)}%</strong> - Good CTR! Continue optimizing for featured snippets`);
                        }
                        
                        if (gscData.totalImpressions < 1000) {
                          steps.push(`<strong>Impressions: ${gscData.totalImpressions}</strong> - Increase visibility by targeting more keywords`);
                        }
                      }
                      break;
                      
                    case 'authority':
                      if (gscData) {
                        const ctr = gscData.ctr || 0;
                        const position = gscData.averagePosition || 0;
                        
                        if (ctr < 1.5) {
                          steps.push(`<strong>CTR: ${ctr.toFixed(2)}%</strong> - Low click-through indicates trust issues. Improve E-A-T signals`);
                        } else {
                          steps.push(`<strong>CTR: ${ctr.toFixed(2)}%</strong> - Good engagement. Build more backlinks to strengthen authority`);
                        }
                        
                        if (position > 15) {
                          steps.push(`<strong>Position: ${position.toFixed(1)}</strong> - Improve rankings through comprehensive, expert content`);
                        }
                        
                        steps.push(`<strong>Next:</strong> Integrate backlink metrics API to measure domain authority`);
                      }
                      break;
                      
                    case 'localEntity':
                      steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using derived calculation from search performance`);
                      steps.push(`<strong>Priority:</strong> Integrate Google Business Profile API to use real local signals data`);
                      if (pillarScore < 70) {
                        steps.push(`<strong>Action:</strong> Add LocalBusiness schema markup and ensure NAP consistency`);
                      }
                      break;
                      
                    case 'serviceArea':
                      steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using derived calculation from Local Entity`);
                      steps.push(`<strong>Priority:</strong> Integrate Google Business Profile API to get real service area data`);
                      if (pillarScore < 70) {
                        steps.push(`<strong>Action:</strong> Add ServiceArea schema and create location-specific pages`);
                      }
                      break;
                  }
                  
                  // If no specific steps generated, add generic ones
                  if (steps.length === 0) {
                    if (pillarScore >= 70) {
                      steps.push('Maintain current performance');
                      steps.push('Monitor for any score drops');
                    } else if (pillarScore >= 40) {
                      steps.push('Focus on improving this pillar');
                      steps.push('Review specific metrics above');
                    } else {
                      steps.push('Critical: Immediate action required');
                      steps.push('Review all data sources and implement fixes');
                    }
                  }
                  
                  return steps.slice(0, 3).map(s => `‚Ä¢ ${s}`).join('<br>') || 'No next steps available';
                };
                
                // Generate suggestions based on pillar and score (fallback)
                const getSuggestions = (pillarKey, pillarScore) => {
                  const suggestions = {
                    localEntity: {
                      high: ['Maintain consistent NAP (Name, Address, Phone) across all platforms', 'Continue building personal brand mentions and citations', 'Monitor entity recognition in knowledge panels'],
                      medium: ['Add LocalBusiness schema markup to all location pages', 'Ensure consistent business name and person name across website', 'Build more local citations and directory listings', 'Create an About page with clear entity information', 'Add author markup to content'],
                      low: ['Implement LocalBusiness schema markup immediately', 'Create consistent NAP (Name, Address, Phone) across all platforms', 'Build local citations in relevant directories', 'Add clear About page with entity information', 'Ensure consistent branding across all touchpoints']
                    },
                    serviceArea: {
                      high: ['Continue maintaining clear service area information', 'Update location pages as service areas expand'],
                      medium: ['Add ServiceArea schema markup to location pages', 'Create dedicated pages for each service area/region', 'Include clear geographic information in content', 'Add location-specific keywords naturally', 'Update Google Business Profile with service areas'],
                      low: ['Implement ServiceArea schema markup immediately', 'Create location-specific landing pages', 'Add clear geographic service information to homepage', 'Update all location pages with service area details', 'Include city/region names in page titles and content']
                    },
                    authority: {
                      high: ['Continue producing in-depth, expert content', 'Maintain citation and backlink building efforts', 'Seek opportunities for expert quotes and mentions', 'Keep author bios and credentials up to date'],
                      medium: ['Create more comprehensive, long-form content (2000+ words)', 'Build backlinks from authoritative photography/education sites', 'Seek guest posting opportunities on relevant blogs', 'Collect and display customer reviews/testimonials', 'Create case studies and detailed tutorials', 'Get cited in industry publications', 'Add author bylines with credentials and experience', 'Display certifications, qualifications, and awards', 'Showcase real-world experience and portfolio work', 'Build trust signals (secure site, clear contact info, privacy policy)'],
                      low: ['Produce comprehensive, expert-level content immediately', 'Build backlinks from authoritative sources', 'Create detailed case studies and tutorials', 'Seek media mentions and expert quotes', 'Display customer reviews prominently', 'Build relationships with industry publications', 'Add clear author credentials and experience to all content', 'Display qualifications, certifications, and professional memberships', 'Create About page highlighting expertise and experience', 'Build trust signals (HTTPS, clear contact, privacy policy, terms)']
                    },
                    visibility: {
                      high: ['Continue optimizing for featured snippets', 'Maintain strong ranking positions', 'Monitor SERP feature opportunities'],
                      medium: ['Optimize content for featured snippets (answer boxes)', 'Target long-tail keywords with lower competition', 'Improve page load speed and Core Web Vitals', 'Create FAQ schema for common questions', 'Optimize for "People Also Ask" sections', 'Build internal linking structure'],
                      low: ['Optimize for featured snippets immediately', 'Target low-competition long-tail keywords', 'Improve page speed and mobile experience', 'Add FAQ schema markup', 'Create content targeting "People Also Ask" queries', 'Build strong internal linking structure']
                    },
                    contentSchema: {
                      high: ['Continue maintaining all foundation schemas (Organization, Person, WebSite, BreadcrumbList)', 'Expand rich result eligible types (Article, Event, Course, FAQ, HowTo)', 'Monitor schema validation errors', 'Add more schema type diversity'],
                      medium: ['Add missing foundation schemas (Organization, Person, WebSite, BreadcrumbList)', 'Add rich result eligible types (Article, Event, Course, FAQ, HowTo, VideoObject, Recipe)', 'Ensure 100% schema coverage across all pages', 'Increase schema type diversity (target 15+ unique types)', 'Validate all schema using Google Rich Results Test'],
                      low: ['Implement foundation schemas immediately (Organization, Person, WebSite, BreadcrumbList)', 'Add rich result eligible schemas (Article, Event, Course, FAQ, HowTo)', 'Ensure schema coverage reaches 100%', 'Add schema type diversity (target 15+ unique types)', 'Validate all schema using Google Rich Results Test']
                    }
                  };
                  
                  const pillarSuggestions = suggestions[pillarKey];
                  if (!pillarSuggestions) return 'No suggestions available';
                  
                  let selectedSuggestions = [];
                  if (pillarScore >= 70) {
                    selectedSuggestions = pillarSuggestions.high || [];
                  } else if (pillarScore >= 40) {
                    selectedSuggestions = pillarSuggestions.medium || [];
                  } else {
                    selectedSuggestions = pillarSuggestions.low || [];
                  }
                  
                  // Return top 3-4 suggestions as bullet points
                  return selectedSuggestions.slice(0, 4).map(s => `‚Ä¢ ${s}`).join('<br>') || 'No suggestions available';
                };
                
                const weight = pillarWeights[key] || 0;
                const isEven = index % 2 === 0;
                
                // Add CSV download button for Content/Schema
                let descriptionCell = descriptions[key] || '';
                if (key === 'contentSchema' && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
                  const schemaData = schemaAudit.data;
                  const missingSchemaCount = schemaData.missingSchemaCount || 0;
                  const missingSchemaPages = schemaData.missingSchemaPages || [];
                  
                  // Always show button, but disable if no missing pages
                  const buttonDisabled = missingSchemaCount === 0;
                  const buttonStyle = buttonDisabled 
                    ? 'padding: 0.4rem 0.8rem; font-size: 0.8rem; background: #9ca3af; color: white; border: none; border-radius: 4px; cursor: not-allowed; opacity: 0.6;'
                    : 'padding: 0.4rem 0.8rem; font-size: 0.8rem; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;';
                  const buttonText = missingSchemaCount > 0 
                    ? `Download pages without schema (CSV) - ${missingSchemaCount} pages`
                    : 'Download pages without schema (CSV) - No missing pages';
                  
                  const downloadTooltip = missingSchemaCount > 0 
                    ? `Download a CSV file containing ${missingSchemaCount} page URLs that are missing schema markup. Use this list to prioritize which pages need schema added.`
                    : 'All pages have schema markup. No download available.';
                  descriptionCell += `<div style="margin-top: 0.75rem;"><button id="download-missing-schema" class="btn-small" style="${buttonStyle}" ${buttonDisabled ? 'disabled' : ''} title="${downloadTooltip}">${buttonText}</button></div>`;
                }
                
                return `
                  <tr style="border-bottom: 1px solid #eee; background: ${isEven ? '#ffffff' : '#fafafa'};">
                    <td style="padding: 0.75rem; font-weight: 500;">${pillarNames[key]}</td>
                    <td style="padding: 0.75rem; text-align: center; font-size: 1.1rem; font-weight: 600; color: ${rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444'};">
                      ${Math.round(score)}
                    </td>
                    <td style="padding: 0.75rem; text-align: center; font-size: 0.9rem; font-weight: 600; color: #666;">
                      ${(weight * 100).toFixed(0)}%
                    </td>
                    <td style="padding: 0.75rem; text-align: center;">
                      <span class="rag-badge ${rag.status}" style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.8rem;">
                        ${rag.label}
                      </span>
                    </td>
                    <td style="padding: 0.75rem; color: #666; font-size: 0.85rem; line-height: 1.6; width: 45%;">${descriptionCell}</td>
                    <td style="padding: 0.75rem; color: #555; font-size: 0.85rem; line-height: 1.6; width: 20%;">${getNextSteps(key, score, data, schemaAudit)}</td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
        <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-top: 1rem; border-left: 4px solid var(--brand-orange);">
          <p style="margin: 0; font-size: 0.9rem; color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
            <strong>RAG Status Guide:</strong> 
            <span style="color: #10b981; font-weight: 600;">Green (70-100)</span> = Strong performance, 
            <span style="color: #f59e0b; font-weight: 600;">Amber (40-69)</span> = Needs improvement, 
            <span style="color: #ef4444; font-weight: 600;">Red (0-39)</span> = Critical issues
          </p>
          <p style="margin: 0; font-size: 0.9rem; color: #555; line-height: 1.6;">
            <strong>Weighting:</strong> Pillars are weighted by their importance for AI search systems. Authority (30%) and Content/Schema (25%) are most critical, as AI relies heavily on E-A-T signals and structured data. Visibility (20%) reflects how AI learns from existing performance, while Local Entity (15%) and Service Area (10%) are less critical for AI-powered results.
          </p>
        </div>
      `;
      // Insert scorecard table after Score Trends chart (at the end)
      const trendChart = document.getElementById('trendChart');
      if (trendChart && trendChart.parentElement && trendChart.parentElement.parentNode) {
        // Find the chart container (parent of canvas) and insert after it
        const trendChartContainer = trendChart.parentElement;
        trendChartContainer.parentNode.insertBefore(scorecardTable, trendChartContainer.nextSibling);
      } else {
        // Fallback: insert at end of dashboard container
        const dashboardContainer = document.getElementById('dashboard');
        if (dashboardContainer) {
          dashboardContainer.appendChild(scorecardTable);
        } else {
          // Last resort: insert after pillar cards
          pillarCards.parentNode.insertBefore(scorecardTable, pillarCards.nextSibling);
        }
      }

      // Add CSV download handler for missing schema pages
      const downloadBtn = document.getElementById('download-missing-schema');
      if (downloadBtn && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        const missingSchemaCount = schemaData.missingSchemaCount || 0;
        const missingSchemaPages = schemaData.missingSchemaPages || [];
        
        debugLog(`Missing schema pages: count=${missingSchemaCount}, pages=${missingSchemaPages.length}`, 'info');
        debugLog(`Missing schema data: ${JSON.stringify(missingSchemaPages)}`, 'info');
        
        if (missingSchemaCount > 0 && missingSchemaPages.length > 0) {
          downloadBtn.addEventListener('click', () => {
            // Check if any pages have error field to determine CSV columns
            const hasErrors = missingSchemaPages.some(p => p.error);
            const headers = hasErrors ? ['url', 'parentUrl', 'error'] : ['url', 'parentUrl'];
            
            const rows = [
              headers,
              ...missingSchemaPages.map(p => [
                p.url, 
                p.parentUrl || '', 
                ...(hasErrors ? [p.error || ''] : [])
              ]),
            ];
            
            const csv = rows
              .map(r => r.map(v => `"${(v || '').replace(/"/g, '""')}"`).join(','))
              .join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ai-geo-missing-schema-pages.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          });
        } else {
          // Button is already disabled in the HTML, just log
          debugLog(`No missing schema pages to download (count: ${missingSchemaCount})`, 'info');
        }
      } else if (!downloadBtn) {
        debugLog('Download button not found in DOM', 'warn');
      }

      // Display snippet readiness with pie chart visualization
      const snippetScoreElement = document.getElementById('snippetReadinessScore');
      const gaugeStatus = document.getElementById('gaugeStatus');
      const legendElement = document.getElementById('snippetReadinessLegend');
      
      if (snippetScoreElement) {
        snippetScoreElement.textContent = snippetReadiness;
        
        // Color code overall score based on value
        let colorClass = '#ef4444'; // red
        let statusText = 'Critical';
        if (snippetReadiness >= 70) {
          colorClass = '#10b981'; // green
          statusText = 'Strong';
        } else if (snippetReadiness >= 40) {
          colorClass = '#f59e0b'; // amber
          statusText = 'Needs Improvement';
        }
        
        snippetScoreElement.style.color = colorClass;
        
        // Update status text
        if (gaugeStatus) {
          gaugeStatus.textContent = statusText;
          gaugeStatus.style.color = colorClass;
        }
      }
      
      // Create pie chart showing weighted components
      const pieChartCanvas = document.getElementById('snippetReadinessPieChart');
      if (pieChartCanvas && scores) {
        // Destroy existing chart if it exists
        if (window.snippetReadinessChart) {
          window.snippetReadinessChart.destroy();
        }
        
        const contentSchemaScore = Math.round(scores.contentSchema || 0);
        const visibilityScore = Math.round(scores.visibility || 0);
        const authorityScore = Math.round(scores.authority || 0);
        
        // Show Content/Schema explanation if schema audit data is available
        const explanationDiv = document.getElementById('contentSchemaExplanation');
        if (explanationDiv && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
          const schemaData = schemaAudit.data;
          const allTypes = new Set();
          if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
            schemaData.schemaTypes.forEach(item => {
              if (item.type) allTypes.add(item.type);
            });
          }
          
          const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
          const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
          const foundationScore = (foundationPresent / foundationTypes.length) * 100;
          
          const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'Recipe'];
          const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
          const richResultScore = (richEligibleCount / richResultTypes.length) * 100;
          
          const coverageScore = schemaData.coverage || 0;
          const uniqueTypesCount = allTypes.size;
          const diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
          
          document.getElementById('explainFoundation').textContent = `${foundationScore.toFixed(0)}% (${foundationPresent}/4 types present)`;
          document.getElementById('explainRich').textContent = `${richResultScore.toFixed(0)}% (${richEligibleCount}/10 types eligible)`;
          document.getElementById('explainCoverage').textContent = `${coverageScore.toFixed(1)}% (${schemaData.pagesWithSchema || 0}/${schemaData.totalPages || 0} pages)`;
          document.getElementById('explainDiversity').textContent = `${diversityScore.toFixed(0)}% (${uniqueTypesCount} unique types, target: 15+)`;
          
          explanationDiv.style.display = 'block';
        } else if (explanationDiv) {
          explanationDiv.style.display = 'none';
        }
        
        // Calculate weighted contribution of each component
        const contentSchemaContribution = (contentSchemaScore * 0.4).toFixed(1);
        const visibilityContribution = (visibilityScore * 0.35).toFixed(1);
        const authorityContribution = (authorityScore * 0.25).toFixed(1);
        
        // Create nested pie chart with fill percentages
        // Outer ring: Weighting (40%, 35%, 25%)
        // Inner fill: Score percentage within each segment (like fuel gauge)
        
        const weights = [40, 35, 25];
        const scoresArray = [contentSchemaScore, visibilityScore, authorityScore];
        // Match trend chart colors (avoid red/amber/green to prevent RAG confusion)
        const colors = ['#6b7280', '#2563eb', '#eab308']; // Grey (Content/Schema), Blue (Visibility), Yellow (Authority)
        
        // Calculate outer ring data (weighting percentages)
        const outerData = weights;
        
        // Inner ring: Same segment sizes as outer, but we'll use custom drawing to fill only the score percentage
        // The inner data must match outer segment sizes so they align
        const innerData = weights; // Same sizes as outer
        
        // Create chart with custom drawing for inner fill segments
        window.snippetReadinessChart = new Chart(pieChartCanvas, {
          type: 'doughnut',
          data: {
            labels: [
              `Content/Schema`,
              `Visibility`,
              `Authority`
            ],
            datasets: [
              {
                // Outer ring: Weighting percentages (40%, 35%, 25%)
                label: 'Weight',
                data: outerData,
                backgroundColor: colors,
                borderWidth: 4,
                borderColor: '#ffffff',
                cutout: '60%' // Leave room for inner fill
              },
              {
                // Inner ring: Same segment sizes, but will be custom-drawn to show score fill
                label: 'Score Fill',
                data: innerData,
                backgroundColor: colors.map((color, i) => {
                  // Use darker version of segment color for unfilled portion
                  return color + '40'; // Add transparency
                }),
                borderWidth: 4,
                borderColor: '#ffffff',
                cutout: '75%' // Inner ring showing fill
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                display: false // We'll use custom legend
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const datasetIndex = context.datasetIndex;
                    const index = context.dataIndex;
                    
                    if (datasetIndex === 0) {
                      // Outer ring: Show weighting
                      return `Weight: ${weights[index]}%`;
                    } else {
                      // Inner fill: Show score and fill percentage
                      const score = scoresArray[index];
                      const fillPercent = (score / 100) * 100;
                      return `Score: ${score}% (${fillPercent.toFixed(0)}% of segment filled)`;
                    }
                  }
                }
              }
            }
          },
          plugins: [{
            id: 'innerFillAndLabels',
            afterDraw: (chart) => {
              const ctx = chart.ctx;
              const outerMeta = chart.getDatasetMeta(0); // Outer ring
              const innerMeta = chart.getDatasetMeta(1); // Inner ring
              const centerX = chart.chartArea.left + (chart.chartArea.right - chart.chartArea.left) / 2;
              const centerY = chart.chartArea.top + (chart.chartArea.bottom - chart.chartArea.top) / 2;
              const outerRadius = (chart.chartArea.right - chart.chartArea.left) / 2;
              const innerRadius = outerRadius * 0.75; // 75% cutout
              const outerInnerRadius = outerRadius * 0.60; // 60% cutout (where inner ring starts)
              
              // First, clear the inner ring segments (they're drawn by Chart.js but we'll redraw them)
              // Then draw custom filled portions based on scores
              
              outerMeta.data.forEach((outerSegment, index) => {
                const score = scoresArray[index];
                const scorePercent = score / 100; // 0 to 1
                const startAngle = outerSegment.startAngle;
                const endAngle = outerSegment.endAngle;
                const segmentAngle = endAngle - startAngle;
                const filledAngle = segmentAngle * scorePercent;
                const filledEndAngle = startAngle + filledAngle;
                
                // Get RAG color for fill
                let fillColor;
                if (score >= 70) fillColor = '#10b981'; // Green
                else if (score >= 40) fillColor = '#f59e0b'; // Amber
                else fillColor = '#ef4444'; // Red
                
                // Draw the filled portion of this inner segment (fuel gauge effect)
                ctx.save();
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerInnerRadius, startAngle, filledEndAngle, false);
                ctx.arc(centerX, centerY, innerRadius, filledEndAngle, startAngle, true);
                ctx.closePath();
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.restore();
                
                // Draw weight percentage in outer segment (larger, white for grey segment, black for others)
                const outerSegmentMidAngle = (startAngle + endAngle) / 2;
                // Position closer to outer edge but still inside segment (about 75% of outer ring width)
                const outerSegmentTextRadius = outerRadius - ((outerRadius - outerInnerRadius) * 0.25);
                const weightTextX = centerX + Math.cos(outerSegmentMidAngle) * outerSegmentTextRadius;
                const weightTextY = centerY + Math.sin(outerSegmentMidAngle) * outerSegmentTextRadius;
                
                ctx.save();
                // Use white text for grey segment (Content/Schema), black for others
                const textColor = colors[index] === '#6b7280' ? '#ffffff' : '#000000';
                ctx.fillStyle = textColor;
                ctx.font = 'bold 18px system-ui'; // Increased from 14px to 18px
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // Add shadow for readability (dark shadow for white text, light shadow for black text)
                if (textColor === '#ffffff') {
                  ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                } else {
                  ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
                }
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.fillText(`${weights[index]}%`, weightTextX, weightTextY);
                ctx.restore();
                
                // Draw label in the center area, aligned to segment
                const midAngle = (startAngle + endAngle) / 2;
                // Position label in center area (about 30% from center, well inside the 75% cutout)
                const labelRadius = outerRadius * 0.25; // Position in center area
                const labelX = centerX + Math.cos(midAngle) * labelRadius;
                const labelY = centerY + Math.sin(midAngle) * labelRadius;
                
                // Get component names
                const componentNames = ['Content/Schema', 'Visibility', 'Authority'];
                const weight = weights[index];
                
                // Calculate text bounds to avoid arrow overlap
                // Estimate text height: 3 lines with spacing ‚âà 45px total height
                const textHeight = 45;
                const textWidth = 80; // Approximate max text width
                
                // Draw dotted arrow from label to segment edge, routing around text
                ctx.save();
                ctx.strokeStyle = colors[index];
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // Dotted line
                ctx.beginPath();
                
                // Start arrow from edge of text area with more padding to avoid overlap
                // Calculate perpendicular offset to route around text
                const perpAngle = midAngle + Math.PI / 2; // Perpendicular to segment angle
                const textOffset = 35; // Increased from 25 to 35 - more padding from text edge
                const perpOffset = (textHeight / 2) + 8; // Increased padding perpendicular to text
                const arrowStartX = labelX + Math.cos(midAngle) * textOffset + Math.cos(perpAngle) * perpOffset;
                const arrowStartY = labelY + Math.sin(midAngle) * textOffset + Math.sin(perpAngle) * perpOffset;
                
                // End at inner ring edge
                const segmentEdgeX = centerX + Math.cos(midAngle) * innerRadius;
                const segmentEdgeY = centerY + Math.sin(midAngle) * innerRadius;
                
                // Draw curved path around text (simple two-segment path)
                const midX = (arrowStartX + segmentEdgeX) / 2;
                const midY = (arrowStartY + segmentEdgeY) / 2;
                // Offset midpoint further outward to curve around text with more clearance
                const curveOffset = 25; // Increased from 15 to 25 for more clearance
                const curveMidX = midX + Math.cos(perpAngle) * curveOffset;
                const curveMidY = midY + Math.sin(perpAngle) * curveOffset;
                
                ctx.moveTo(arrowStartX, arrowStartY);
                ctx.quadraticCurveTo(curveMidX, curveMidY, segmentEdgeX, segmentEdgeY);
                ctx.stroke();
                
                // Draw arrowhead
                const arrowLength = 8;
                const arrowAngle = Math.atan2(segmentEdgeY - curveMidY, segmentEdgeX - curveMidX);
                ctx.setLineDash([]); // Solid for arrowhead
                ctx.beginPath();
                ctx.moveTo(segmentEdgeX, segmentEdgeY);
                ctx.lineTo(
                  segmentEdgeX - arrowLength * Math.cos(arrowAngle - Math.PI / 6),
                  segmentEdgeY - arrowLength * Math.sin(arrowAngle - Math.PI / 6)
                );
                ctx.moveTo(segmentEdgeX, segmentEdgeY);
                ctx.lineTo(
                  segmentEdgeX - arrowLength * Math.cos(arrowAngle + Math.PI / 6),
                  segmentEdgeY - arrowLength * Math.sin(arrowAngle + Math.PI / 6)
                );
                ctx.stroke();
                ctx.restore();
                
                // Draw text labels without circles (to prevent overlap)
                ctx.save();
                // Add text shadow for better readability without background
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Draw text with readable fonts
                ctx.fillStyle = colors[index];
                ctx.font = 'bold 13px system-ui';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // First line: Component name
                ctx.fillText(`${componentNames[index]}`, labelX, labelY - 8);
                // Second line: Score percentage (colored) - weight removed, now in outer segment
                ctx.fillStyle = fillColor;
                ctx.font = 'bold 15px system-ui';
                ctx.fillText(`Score: ${score}%`, labelX, labelY + 8);
                
                ctx.restore();
              });
            }
          }]
        });
        
        // Create custom legend with scores
        if (legendElement) {
          const getRAGColor = (score) => {
            if (score >= 70) return '#10b981';
            if (score >= 40) return '#f59e0b';
            return '#ef4444';
          };
          
          const getRAGLabel = (score) => {
            if (score >= 70) return 'Green';
            if (score >= 40) return 'Amber';
            return 'Red';
          };
          
          legendElement.innerHTML = `
            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #6b7280;">
              <div style="width: 12px; height: 12px; background: #6b7280; border-radius: 2px; flex-shrink: 0;"></div>
              <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Content/Schema</div>
                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 40%<br>Score: <strong style="color: ${getRAGColor(contentSchemaScore)};">${contentSchemaScore}</strong> (${getRAGLabel(contentSchemaScore)})<br>Contribution: ${contentSchemaContribution} pts</div>
              </div>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #2563eb;">
              <div style="width: 12px; height: 12px; background: #2563eb; border-radius: 2px; flex-shrink: 0;"></div>
              <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Visibility</div>
                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 35%<br>Score: <strong style="color: ${getRAGColor(visibilityScore)};">${visibilityScore}</strong> (${getRAGLabel(visibilityScore)})<br>Contribution: ${visibilityContribution} pts</div>
              </div>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #eab308;">
              <div style="width: 12px; height: 12px; background: #eab308; border-radius: 2px; flex-shrink: 0;"></div>
              <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Authority</div>
                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 25%<br>Score: <strong style="color: ${getRAGColor(authorityScore)};">${authorityScore}</strong> (${getRAGLabel(authorityScore)})<br>Contribution: ${authorityContribution} pts</div>
              </div>
            </div>
          `;
        }
      }

      // Format numbers for display
      const formatNumber = (num) => {
        if (num >= 1000000) {
          return (num / 1000000).toFixed(1) + 'M';
        } else if (num >= 1000) {
          return (num / 1000).toFixed(0) + 'K';
        }
        return num.toLocaleString();
      };

      // Display metrics
      const metricsGrid = document.getElementById('metricsGrid');
      metricsGrid.innerHTML = `
        <div class="metric-card">
          <div class="value">${formatNumber(data.totalClicks)}</div>
          <div class="label">Total Clicks</div>
        </div>
        <div class="metric-card">
          <div class="value">${formatNumber(data.totalImpressions)}</div>
          <div class="label">Total Impressions</div>
        </div>
        <div class="metric-card">
          <div class="value">${data.averagePosition.toFixed(1)}</div>
          <div class="label">Avg Position</div>
        </div>
        <div class="metric-card">
          <div class="value">${(data.ctr || 0).toFixed(2)}%</div>
          <div class="label">CTR</div>
        </div>
      `;

      // Wait a moment for DOM to update, then create charts (charts need visible canvas)
      setTimeout(async () => {
        debugLog('Starting chart creation (setTimeout callback)...', 'info');
        
        // Check if Chart.js is loaded
        debugLog('Checking Chart.js availability...', 'info');
        if (typeof Chart === 'undefined') {
          debugLog('‚úó Chart.js library not loaded', 'error');
          console.error('Chart.js library not loaded');
          showStatus('Chart.js library failed to load. Please refresh the page.', 'error');
          return;
        }
        debugLog('‚úì Chart.js library available', 'success');
        debugLog(`Chart constructor: ${typeof Chart}`, 'info');

        // Create radar chart
        debugLog('Creating radar chart...', 'info');
        const radarCanvas = document.getElementById('radarChart');
        if (!radarCanvas) {
          debugLog('‚úó Radar chart canvas not found', 'error');
          console.error('Radar chart canvas not found');
          return;
        }
        debugLog('‚úì Radar chart canvas found', 'success');
        
        // Safely destroy existing chart if it exists
        debugLog(`Checking for existing radarChart: ${window.radarChart ? 'exists' : 'null'}`, 'info');
        try {
          if (window.radarChart) {
            debugLog(`radarChart type: ${typeof window.radarChart}`, 'info');
            debugLog(`radarChart instanceof Chart: ${window.radarChart instanceof Chart}`, 'info');
            debugLog(`radarChart.destroy type: ${typeof window.radarChart.destroy}`, 'info');
            
            // Check if it's actually a Chart instance
            if (window.radarChart instanceof Chart && typeof window.radarChart.destroy === 'function') {
              debugLog('Destroying existing radar chart...', 'info');
              window.radarChart.destroy();
              debugLog('‚úì Existing radar chart destroyed', 'success');
            } else {
              debugLog('Existing radarChart is not a valid Chart instance, clearing...', 'info');
            }
            window.radarChart = null;
          } else {
            debugLog('No existing radar chart to destroy', 'info');
          }
        } catch (e) {
          debugLog(`‚úó Error destroying existing radar chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.warn('Error destroying existing radar chart:', e);
          window.radarChart = null;
        }
        
        const radarCtx = radarCanvas.getContext('2d');
        debugLog('Creating new Chart instance for radar chart...', 'info');
        try {
          // Use ordered pillars for consistent ordering
          const orderedPillars = getOrderedPillars(scores);
          const orderedLabels = orderedPillars.map(([key]) => pillarNames[key]);
          const orderedData = orderedPillars.map(([, score]) => score);
          
          window.radarChart = new Chart(radarCtx, {
            type: 'radar',
            data: {
              labels: orderedLabels,
              datasets: [{
                label: 'Current Scores',
                data: orderedData,
                backgroundColor: 'rgba(59, 130, 246, 0.2)',
                borderColor: 'rgba(37, 99, 235, 1)',
                pointBackgroundColor: 'rgba(37, 99, 235, 1)',
                pointBorderColor: '#fff',
                pointHoverBackgroundColor: '#fff',
                pointHoverBorderColor: 'rgba(37, 99, 235, 1)'
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              layout: {
                padding: {
                  top: 20,
                  bottom: 20,
                  left: 20,
                  right: 20
                }
              },
              scales: {
                r: {
                  beginAtZero: true,
                  max: 100,
                  ticks: {
                    stepSize: 20,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    color: '#1e293b'
                  },
                  pointLabels: {
                    font: {
                      size: 16,
                      weight: 'bold'
                    },
                    color: '#1e293b',
                    padding: 15
                  },
                  grid: {
                    color: 'rgba(100, 116, 139, 0.2)'
                  },
                  angleLines: {
                    color: 'rgba(100, 116, 139, 0.3)'
                  }
                }
              },
              plugins: {
                legend: {
                  labels: {
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    padding: 15
                  }
                }
              }
            }
          });
          debugLog('‚úì Radar chart created successfully', 'success');
          debugLog(`radarChart type after creation: ${typeof window.radarChart}`, 'info');
          debugLog(`radarChart instanceof Chart: ${window.radarChart instanceof Chart}`, 'info');
        } catch (e) {
          debugLog(`‚úó Error creating radar chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.error('Error creating radar chart:', e);
        }

        // Create trend chart (mock data for now)
        debugLog('Creating trend chart...', 'info');
        const trendCanvas = document.getElementById('trendChart');
        if (!trendCanvas) {
          debugLog('‚úó Trend chart canvas not found', 'error');
          console.error('Trend chart canvas not found');
          return;
        }
        debugLog('‚úì Trend chart canvas found', 'success');
        
        // Safely destroy existing chart if it exists
        debugLog(`Checking for existing trendChart: ${window.trendChart ? 'exists' : 'null'}`, 'info');
        try {
          if (window.trendChart) {
            debugLog(`trendChart type: ${typeof window.trendChart}`, 'info');
            debugLog(`trendChart instanceof Chart: ${window.trendChart instanceof Chart}`, 'info');
            debugLog(`trendChart.destroy type: ${typeof window.trendChart.destroy}`, 'info');
            // Check if it's actually a Chart instance
            if (window.trendChart instanceof Chart && typeof window.trendChart.destroy === 'function') {
              debugLog('Destroying existing trend chart...', 'info');
              window.trendChart.destroy();
              debugLog('‚úì Existing trend chart destroyed', 'success');
            } else {
              debugLog('Existing trendChart is not a valid Chart instance, clearing...', 'info');
            }
            window.trendChart = null;
          } else {
            debugLog('No existing trend chart to destroy', 'info');
          }
        } catch (e) {
          debugLog(`‚úó Error destroying existing trend chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.warn('Error destroying existing trend chart:', e);
          window.trendChart = null;
        }
        
        const trendCtx = trendCanvas.getContext('2d');
        const dateRange = parseInt(document.getElementById('dateRange').value) || 30;
        debugLog(`Creating trend chart for date range: ${dateRange} days`, 'info');
        
        // Determine number of data points and label frequency based on date range
        let numDataPoints, labelStep, dateFormat;
        if (dateRange <= 30) {
          // For 30 days or less: show daily data, all labels
          numDataPoints = dateRange;
          labelStep = 1;
          dateFormat = { month: 'short', day: 'numeric' };
        } else if (dateRange <= 90) {
          // For 90 days: show daily data, label every 3-5 days
          numDataPoints = dateRange;
          labelStep = Math.ceil(dateRange / 20); // ~20 labels max
          dateFormat = { month: 'short', day: 'numeric' };
        } else if (dateRange <= 180) {
          // For 6 months: show weekly data, label every week
          numDataPoints = Math.ceil(dateRange / 7);
          labelStep = 1;
          dateFormat = { month: 'short', day: 'numeric' };
        } else {
          // For 12 months: show weekly data, label every 2-4 weeks
          numDataPoints = Math.ceil(dateRange / 7);
          labelStep = Math.ceil(numDataPoints / 15); // ~15 labels max
          dateFormat = { month: 'short', day: 'numeric' };
        }
        
        // Generate date labels and store Date objects
        const allDates = Array.from({ length: numDataPoints }, (_, i) => {
          const d = new Date();
          if (dateRange <= 90) {
            // Daily data
            d.setDate(d.getDate() - (numDataPoints - 1 - i));
          } else {
            // Weekly data
            d.setDate(d.getDate() - ((numDataPoints - 1 - i) * 7));
          }
          return d;
        });
        
        // Store Date objects for period detection (for mock data)
        const mockDateObjects = allDates.slice();
        
        // Create labels array with appropriate spacing and year detection
        let lastVisibleYear = null;
        const dates = allDates.map((d, i) => {
          if (i % labelStep === 0 || i === allDates.length - 1) {
            const currentYear = d.getFullYear();
            const formattedDate = d.toLocaleDateString('en-GB', dateFormat);
            
            // Add year if it changed from the last visible label
            if (lastVisibleYear !== null && currentYear !== lastVisibleYear) {
              lastVisibleYear = currentYear;
              return `${formattedDate} ${currentYear}`;
            }
            
            lastVisibleYear = currentYear;
            return formattedDate;
          }
          return ''; // Empty string for labels we don't want to show
        });
        
        // Store date objects for mock data (will be updated if timeseries data exists)
        chartDateObjects = mockDateObjects;
        debugLog('Creating new Chart instance for trend chart...', 'info');
        try {
          // Use real timeseries data from GSC API
          const timeseries = data.timeseries || [];
          debugLog(`Using ${timeseries.length} timeseries data points from GSC API`, 'info');
          
          // Check if we have data
          if (!data || !data.timeseries || data.timeseries.length === 0) {
            debugLog('‚ö† No timeseries data available. Chart will show mock data. Run a new audit to get real GSC historical data.', 'warn');
            // Show message to user
            const trendCanvas = document.getElementById('trendChart');
            if (trendCanvas && trendCanvas.parentElement) {
              const messageDiv = document.createElement('div');
              messageDiv.style.cssText = 'background: #fff3cd; padding: 1rem; border-radius: 4px; border-left: 3px solid #f59e0b; margin-bottom: 1rem; font-size: 0.9rem; color: #856404;';
              messageDiv.innerHTML = '<strong>No historical data available.</strong> The trend chart requires timeseries data from Google Search Console. Please run a new audit to populate the chart with real historical data.';
              trendCanvas.parentElement.insertBefore(messageDiv, trendCanvas);
            }
          }
          
          // If we have timeseries data, use it; otherwise fall back to mock data
          let localEntityData, serviceAreaData, authorityData, visibilityData, contentSchemaData;
          let chartDates = dates;
          let chartDateObjects = []; // Store Date objects for period detection
          
          if (timeseries.length > 0) {
            // Fetch historical Content/Schema data from Supabase (async operation)
            const propertyUrl = document.getElementById('propertyUrl')?.value || '';
            const endDate = new Date().toISOString().split('T')[0];
            const startDateObj = new Date();
            startDateObj.setDate(startDateObj.getDate() - dateRange);
            const startDate = startDateObj.toISOString().split('T')[0];
            
            let contentSchemaHistory = [];
            let contentSchemaMap = new Map();
            const currentContentSchema = scores.contentSchema || 0;
            
            // Fetch historical data asynchronously
            if (propertyUrl) {
              try {
                contentSchemaHistory = await fetchContentSchemaHistory(propertyUrl, startDate, endDate);
                // Create a map of dates to Content/Schema scores from Supabase
                contentSchemaHistory.forEach(record => {
                  contentSchemaMap.set(record.date, record.contentSchemaScore);
                });
                
                const hasHistoricalData = contentSchemaHistory.length > 0;
                if (hasHistoricalData) {
                  debugLog(`Using ${contentSchemaHistory.length} historical Content/Schema records from Supabase`, 'info');
                } else {
                  debugLog(`No historical Content/Schema data found. Using current score (${currentContentSchema}) for all points. Dashed line will indicate estimated data.`, 'info');
                }
              } catch (error) {
                debugLog(`‚ö† Error fetching historical data: ${error.message}`, 'warn');
                contentSchemaHistory = [];
              }
            } else {
              debugLog(`No historical Content/Schema data found. Using current score (${currentContentSchema}) for all points. Dashed line will indicate estimated data.`, 'info');
            }
            
            // Calculate pillar scores for each timeseries point
            const calculatePillarFromMetrics = (position, ctr) => {
              // Position score (same formula as main calculation)
              const clampedPos = Math.max(1, Math.min(40, position));
              const scale = (clampedPos - 1) / 39;
              const posScore = 100 - scale * 90;
              
              // Authority: use exact formula with GSC values (same as main calculation)
              // Convert ctr from percentage (0-100) to decimal (0-1), then apply formula
              const ctrDecimal = ctr / 100; // Convert percentage to decimal (e.g., 10% -> 0.10)
              const ctrScore = Math.min((ctrDecimal / 0.10) * 100, 100);
              
              // Calculate each pillar (same formulas as main calculation)
              const visibility = clampScore(posScore);
              const authority = clampScore(0.6 * ctrScore + 0.4 * posScore);
              const localEntity = clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
              const serviceArea = clampScore(localEntity - 5);
              
              return { visibility, authority, localEntity, serviceArea };
            };
            
            // Extract data arrays from timeseries
            localEntityData = [];
            serviceAreaData = [];
            authorityData = [];
            visibilityData = [];
            contentSchemaData = [];
            const contentSchemaDataEstimated = []; // For dashed line (dates without real data)
            const allDateObjects = []; // Store Date objects for year detection
            const allDates = [];
            
            timeseries.forEach(point => {
              const pillarScores = calculatePillarFromMetrics(point.position, point.ctr);
              localEntityData.push(pillarScores.localEntity);
              serviceAreaData.push(pillarScores.serviceArea);
              authorityData.push(pillarScores.authority);
              visibilityData.push(pillarScores.visibility);
              
              // Check if we have real historical data for this date
              const pointDate = point.date; // YYYY-MM-DD format
              const realScore = contentSchemaMap.get(pointDate);
              
              if (realScore !== undefined) {
                // We have real data for this date
                contentSchemaData.push(realScore);
                contentSchemaDataEstimated.push(null); // No estimated value
              } else {
                // No real data - use current score as estimate
                contentSchemaData.push(null); // No real value
                contentSchemaDataEstimated.push(currentContentSchema); // Estimated value
              }
              
              // Format date for chart (timeseries dates are YYYY-MM-DD)
              const dateObj = new Date(point.date);
              allDateObjects.push(dateObj);
              allDates.push(dateObj.toLocaleDateString('en-GB', dateFormat));
            });
            
            // Apply label spacing to dates with year detection (show every labelStep-th label)
            let lastVisibleYear = null;
            chartDates = allDates.map((d, i) => {
              if (i % labelStep === 0 || i === allDates.length - 1) {
                const currentYear = allDateObjects[i].getFullYear();
                
                // Add year if it changed from the last visible label
                if (lastVisibleYear !== null && currentYear !== lastVisibleYear) {
                  lastVisibleYear = currentYear;
                  return `${d} ${currentYear}`;
                }
                
                lastVisibleYear = currentYear;
                return d;
              }
              return ''; // Empty string for labels we don't want to show
            });
            
            // Store date objects for timeseries data
            chartDateObjects = allDateObjects;
          } else {
            // Fallback to mock data if no timeseries available
            debugLog('No timeseries data available, using mock data', 'warn');
            const makeSeries = (baseScore, seed) => {
              const arr = [];
              for (let i = 0; i < numDataPoints; i++) {
                const angle = (i / numDataPoints) * Math.PI * 4;
                const wave = Math.sin(angle + seed) * 3;
                const trendTilt = (i - numDataPoints / 2) * 0.02;
                const value = baseScore + wave + trendTilt;
                arr.push(Math.max(0, Math.min(100, value)));
              }
              return arr;
            };
            
            localEntityData = makeSeries(scores.localEntity, 0.5);
            serviceAreaData = makeSeries(scores.serviceArea, 0.8);
            authorityData = makeSeries(scores.authority, 1.9);
            visibilityData = makeSeries(scores.visibility, 1.1);
            contentSchemaData = makeSeries(scores.contentSchema, 1.4);
          }
          
          // Calculate min and max across all datasets
          const allData = [...localEntityData, ...serviceAreaData, ...authorityData, ...visibilityData, ...contentSchemaData];
          const dataMin = Math.min(...allData);
          const dataMax = Math.max(...allData);
          const dataRange = dataMax - dataMin;
          
          // Calculate dynamic Y-axis range
          // Minimum range of 30, or actual range + padding if larger
          const minRange = 30;
          const padding = 5; // Add 5 points padding above and below
          const actualRange = Math.max(minRange, dataRange + (padding * 2));
          
          // Calculate Y-axis min and max
          let yAxisMin = Math.max(0, Math.floor(dataMin - padding));
          // Ensure the red risk band (30-39) is always visible in the chart area
          // by never allowing the bottom of the axis to sit above 30.
          if (yAxisMin > 30) {
            yAxisMin = 30;
          }
          const yAxisMax = Math.min(100, Math.ceil(yAxisMin + actualRange));
          
          // Adjust step size based on range (smaller steps for smaller ranges)
          let stepSize = 10;
          if (actualRange <= 40) {
            stepSize = 5;
          } else if (actualRange <= 60) {
            stepSize = 10;
          } else {
            stepSize = 20;
          }
          
          debugLog(`Y-axis range: ${yAxisMin} to ${yAxisMax} (range: ${actualRange}, step: ${stepSize})`, 'info');
          
          // Calculate trend percentages for each dataset
          const calculateTrend = (data) => {
            if (data.length < 2) return { percent: 0, isUp: false };
            const first = data[0];
            const last = data[data.length - 1];
            // Handle division by zero (when first value is 0) or NaN
            if (first === 0 || isNaN(first) || isNaN(last)) {
              // If first is 0 and last is also 0, no change
              if (last === 0 || isNaN(last)) {
                return { percent: 0, isUp: false };
              }
              // If first is 0 but last has value, show as 100% increase
              return { percent: 100, isUp: true };
            }
            const percent = ((last - first) / first) * 100;
            // Handle NaN result
            if (isNaN(percent) || !isFinite(percent)) {
              return { percent: 0, isUp: false };
            }
            return { percent: Math.abs(percent), isUp: percent > 0 };
          };
          
          const localEntityTrend = calculateTrend(localEntityData);
          const serviceAreaTrend = calculateTrend(serviceAreaData);
          const authorityTrend = calculateTrend(authorityData);
          const visibilityTrend = calculateTrend(visibilityData);
          const contentSchemaTrend = calculateTrend(contentSchemaData);

          // Update HTML trend summary row
          const trendSummaryRow = document.getElementById('trendSummaryRow');
          if (trendSummaryRow) {
            const buildPill = (label, trend) => {
              const arrow = trend.isUp ? '‚Üë' : '‚Üì';
              const sign = trend.isUp ? '+' : '';
              const cls = trend.isUp ? 'up' : 'down';
              return `
                <div class="trend-pill">
                  <span class="label">${label}</span>
                  <span class="value ${cls}">${arrow} ${sign}${trend.percent.toFixed(1)}%</span>
                </div>
              `;
            };
            trendSummaryRow.innerHTML = [
              buildPill('Local Entity', localEntityTrend),
              buildPill('Service Area', serviceAreaTrend),
              buildPill('Authority', authorityTrend),
              buildPill('Visibility', visibilityTrend),
              buildPill('Content/Schema', contentSchemaTrend)
            ].join('');
          }
          
          // Plugin to make year transition labels bold
          const yearLabelBoldPlugin = {
            id: 'yearLabelBold',
            afterDraw: (chart) => {
              const xScale = chart.scales.x;
              const ctx = chart.ctx;
              const rotation = -45 * (Math.PI / 180); // -45 degrees in radians
              
              // Get the chart dates array from the chart's data labels (original labels before callback)
              const chartDates = chart.data.labels || [];
              
              // Iterate through all data points to find year labels
              chartDates.forEach((originalLabel, dataIndex) => {
                // Check if original label contains a year (4-digit number at the end)
                if (originalLabel && /\d{4}$/.test(originalLabel)) {
                  const label = originalLabel;
                  // Get pixel position for this data point
                  const tickPosition = xScale.getPixelForValue(dataIndex);
                  const yPosition = chart.chartArea.bottom + 25;
                  
                  // Save context
                  ctx.save();
                  
                  // Translate to tick position and rotate
                  ctx.translate(tickPosition, yPosition);
                  ctx.rotate(rotation);
                  
                  // Set bold font with larger size
                  ctx.font = 'bold 14px Arial';
                  ctx.fillStyle = '#000';
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  
                  // Measure text to clear area properly
                  const metrics = ctx.measureText(label);
                  const textWidth = metrics.width;
                  const textHeight = 18;
                  
                  // Clear a larger area to remove the original label
                  ctx.globalCompositeOperation = 'destination-out';
                  ctx.fillRect(-textWidth/2 - 6, -textHeight/2 - 3, textWidth + 12, textHeight + 6);
                  
                  // Switch back to normal drawing
                  ctx.globalCompositeOperation = 'source-over';
                  
                  // Draw bold label
                  ctx.fillText(label, 0, 0);
                  
                  // Restore context
                  ctx.restore();
                }
              });
            }
          };
          
          // Plugin to add RAG background bands with stronger contrast
          const ragBackgroundPlugin = {
            id: 'ragBackground',
            beforeDraw: (chart) => {
              const ctx = chart.ctx;
              const chartArea = chart.chartArea;
              const yScale = chart.scales.y;
              
              // Red zone (0-39) - increased opacity and saturation
              if (yAxisMin <= 39) {
                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(0, yAxisMin)));
                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(39, yAxisMax)));
                ctx.fillStyle = 'rgba(220, 38, 38, 0.18)'; // More saturated red, higher opacity
                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
              }
              
              // Amber zone (40-69) - increased opacity and saturation
              if (yAxisMin <= 69 && yAxisMax >= 40) {
                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(40, yAxisMin)));
                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(69, yAxisMax)));
                ctx.fillStyle = 'rgba(234, 179, 8, 0.18)'; // More saturated amber/yellow, higher opacity
                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
              }
              
              // Green zone (70-100) - increased opacity and saturation
              if (yAxisMax >= 70) {
                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(70, yAxisMin)));
                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(100, yAxisMax)));
                ctx.fillStyle = 'rgba(22, 163, 74, 0.18)'; // More saturated green, higher opacity
                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
              }
            }
          };
          
          // Plugin to draw vertical dividing lines at period transitions (months and years)
          const periodDividingLinePlugin = {
            id: 'periodDividingLine',
            afterDraw: (chart) => {
              const xScale = chart.scales.x;
              const ctx = chart.ctx;
              const chartArea = chart.chartArea;
              
              // Detect period transitions (month and year changes)
              const periodTransitions = [];
              let lastMonth = null;
              let lastYear = null;
              
              // Use stored date objects to detect month/year changes
              chartDateObjects.forEach((dateObj, index) => {
                if (dateObj instanceof Date) {
                  const currentMonth = dateObj.getMonth(); // 0-11
                  const currentYear = dateObj.getFullYear();
                  
                  // Check for month or year transition
                  if (lastMonth !== null && lastYear !== null) {
                    if (currentYear !== lastYear || currentMonth !== lastMonth) {
                      periodTransitions.push(index);
                    }
                  }
                  
                  lastMonth = currentMonth;
                  lastYear = currentYear;
                }
              });
              
              // Draw vertical dotted lines at period transitions
              periodTransitions.forEach((dataIndex) => {
                // Get pixel position for this data point
                const tickPosition = xScale.getPixelForValue(dataIndex);
                
                // Only draw if within chart area horizontally
                if (tickPosition >= chartArea.left && tickPosition <= chartArea.right) {
                  ctx.save();
                  ctx.strokeStyle = 'rgba(120, 120, 120, 0.7)'; // Medium grey, more visible
                  ctx.lineWidth = 3; // Thicker lines
                  ctx.setLineDash([3, 4]); // Dotted line pattern
                  ctx.beginPath();
                  // Extend line beyond chart area to reach axis labels
                  const lineTop = chartArea.top - 10; // Extend above chart
                  const lineBottom = chartArea.bottom + 50; // Extend below chart to reach axis labels
                  ctx.moveTo(tickPosition, lineTop);
                  ctx.lineTo(tickPosition, lineBottom);
                  ctx.stroke();
                  ctx.restore();
                }
              });
            }
          };
          
          window.trendChart = new Chart(trendCtx, {
            type: 'line',
            data: {
              labels: chartDates,
              datasets: [
                {
                  label: 'Local Entity',
                  data: localEntityData,
                  borderColor: 'rgba(147, 51, 234, 1)', // Purple
                  backgroundColor: 'rgba(147, 51, 234, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5
                },
                {
                  label: 'Service Area',
                  data: serviceAreaData,
                  borderColor: 'rgba(20, 184, 166, 1)', // Teal
                  backgroundColor: 'rgba(20, 184, 166, 0.1)',
                  borderWidth: 2.5,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5
                },
                {
                  label: 'Authority',
                  data: authorityData,
                  borderColor: 'rgba(234, 179, 8, 1)', // Yellow
                  backgroundColor: 'rgba(234, 179, 8, 0.1)',
                  borderWidth: 4,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5
                },
                {
                  label: 'Visibility',
                  data: visibilityData,
                  borderColor: 'rgba(37, 99, 235, 1)', // Blue
                  backgroundColor: 'rgba(59, 130, 246, 0.1)',
                  borderWidth: 2.5,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5
                },
                {
                  label: 'Content / Schema',
                  data: contentSchemaData,
                  borderColor: 'rgba(107, 114, 128, 1)', // Grey
                  backgroundColor: 'rgba(107, 114, 128, 0.1)',
                  borderWidth: 2.5,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5,
                  spanGaps: true // Connect across null values
                },
                // Estimated Content/Schema data (dashed line for dates without real data)
                ...(contentSchemaDataEstimated && contentSchemaDataEstimated.some(v => v !== null) ? [{
                  label: 'Content / Schema (Estimated)',
                  data: contentSchemaDataEstimated,
                  borderColor: 'rgba(107, 114, 128, 0.5)', // Lighter grey
                  backgroundColor: 'rgba(107, 114, 128, 0.05)',
                  borderWidth: 2,
                  borderDash: [5, 5], // Dashed line
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5,
                  spanGaps: true
                }] : [])
              ]
            },
            plugins: [ragBackgroundPlugin, yearLabelBoldPlugin, periodDividingLinePlugin],
            options: {
              responsive: true,
              maintainAspectRatio: false,
              animation: false, // Disable animation for better performance when changing periods
              layout: {
                padding: {
                  bottom: 60, // Extra padding for rotated X-axis labels and extended lines
                  left: 10,
                  right: 10,
                  top: 10
                }
              },
              scales: {
                x: {
                  ticks: {
                    maxRotation: 45,
                    minRotation: 45,
                    font: {
                      size: 11,
                      weight: 'normal'
                    },
                    callback: function(value, index) {
                      // Only show non-empty labels
                      const label = this.getLabelForValue(value);
                      // Hide year labels (they'll be drawn by plugin in bold)
                      if (label && /\d{4}$/.test(label)) {
                        return ''; // Return empty to hide, plugin will draw it
                      }
                      return label || '';
                    }
                  },
                  grid: {
                    display: true,
                    color: 'rgba(0, 0, 0, 0.05)'
                  }
                },
                y: {
                  min: yAxisMin,
                  max: yAxisMax,
                  position: 'left',
                  ticks: {
                    stepSize: stepSize,
                    font: {
                      size: 12,
                      weight: 'bold'
                    }
                  },
                  grid: {
                    color: 'rgba(0, 0, 0, 0.1)',
                    drawBorder: true
                  }
                },
                y1: {
                  min: yAxisMin,
                  max: yAxisMax,
                  position: 'right',
                  ticks: {
                    stepSize: stepSize,
                    font: {
                      size: 12,
                      weight: 'bold'
                    }
                  },
                  grid: {
                    display: false,
                    drawBorder: false
                  }
                }
              },
              plugins: {
                legend: {
                  display: true,
                  position: 'top',
                  labels: {
                    font: {
                      size: 16,
                      weight: 'bold'
                    },
                    padding: 25,
                    usePointStyle: false,
                    boxWidth: 60,
                    boxHeight: 4,
                    // Use default legend labels (pillar names only, no trends)
                    generateLabels: function(chart) {
                      const original = Chart.defaults.plugins.legend.labels.generateLabels;
                      return original.call(this, chart);
                    }
                  }
                },
                tooltip: {
                  mode: 'index',
                  intersect: false
                }
              }
            }
          });
          debugLog('‚úì Trend chart created successfully', 'success');
          debugLog(`trendChart type after creation: ${typeof window.trendChart}`, 'info');
          debugLog(`trendChart instanceof Chart: ${window.trendChart instanceof Chart}`, 'info');
          debugLog('=== DISPLAY DASHBOARD: Complete ===', 'success');
        } catch (e) {
          debugLog(`‚úó Error creating trend chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.error('Error creating trend chart:', e);
        }
      }, 100);
    }

    // Initialize on load
    window.addEventListener('DOMContentLoaded', () => {
      debugLog('=== PAGE LOAD: DOMContentLoaded event fired ===', 'info');
      debugLog(`Window location: ${window.location.href}`, 'info');
      debugLog(`User agent: ${navigator.userAgent}`, 'info');
      loadConfig();
      
      // Load and display last audit results if available
      const savedAudit = loadAuditResults();
      if (savedAudit && savedAudit.scores && savedAudit.searchData) {
        debugLog('Loading last audit results from localStorage...', 'info');
        // Show dashboard immediately with saved results
        document.getElementById('dashboard').style.display = 'block';
        document.getElementById('loading').classList.remove('show');
        displayDashboard(
          savedAudit.scores,
          savedAudit.searchData,
          savedAudit.snippetReadiness || 0,
          savedAudit.schemaAudit || null
        );
        debugLog('‚úì Last audit results displayed', 'success');
      }
      
      debugLog('=== PAGE LOAD: Initialization complete ===', 'success');
    });
  </script>
</body>
</html>

