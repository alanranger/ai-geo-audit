<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>AI GEO Audit Dashboard - Automated SEO Analysis</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script>
    // Try to load config.js if it exists (for local development)
    // Note: config.js is gitignored and won't be deployed to Vercel
    // Silently fail if config.js doesn't exist (expected on Vercel)
    try {
      // First check if file exists via fetch to avoid syntax errors
      fetch('config.js')
        .then(response => {
          if (response.ok && response.headers.get('content-type')?.includes('javascript')) {
            const configScript = document.createElement('script');
            configScript.src = 'config.js';
            configScript.type = 'text/javascript';
            configScript.onerror = function() {
              // Silently ignore
            };
            document.head.appendChild(configScript);
          }
        })
        .catch(() => {
          // Silently ignore - config.js is optional
        });
    } catch (e) {
      // Silently ignore - config.js is optional
    }
  </script>
  <style>
    :root {
      --brand-orange: #E57200;
      --brand-dark: #222222;
      --brand-grey: #555555;
      --bg-page: #f2f2f2;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg-page);
      color: var(--brand-dark);
      line-height: 1.5;
    }
    .header {
      background: linear-gradient(135deg, var(--brand-orange) 0%, #ff8c42 100%);
      color: white;
      padding: 2rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .header h1 {
      margin: 0 0 0.5rem 0;
      font-size: 2rem;
    }
    .header p {
      margin: 0;
      opacity: 0.9;
    }
    .container {
      max-width: 1800px;
      margin: 0 auto;
      padding: 2rem;
      padding-bottom: 60px; /* Space for debug panel */
    }
    .config-panel {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      margin-bottom: 2rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .config-panel h2 {
      margin: 0 0 1rem 0;
      color: var(--brand-dark);
      font-size: 1.25rem;
    }
    .form-group {
      margin-bottom: 1rem;
    }
    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      color: var(--brand-grey);
    }
    .form-group input {
      width: 100%;
      padding: 0.75rem;
      border: 2px solid #e2e8f0;
      border-radius: 6px;
      font-size: 1rem;
    }
    .form-group input:focus {
      outline: none;
      border-color: var(--brand-orange);
    }
    .btn {
      background: var(--brand-orange);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    .btn:hover {
      background: #d46200;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    .btn-secondary {
      background: var(--brand-grey);
    }
    .btn-secondary:hover {
      background: #444;
    }
    .status {
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      display: none;
    }
    .status.success {
      background: #d1fae5;
      color: #065f46;
      border-left: 4px solid var(--success);
    }
    .status.error {
      background: #fee2e2;
      color: #991b1b;
      border-left: 4px solid var(--danger);
    }
    .status.info {
      background: #dbeafe;
      color: #1e40af;
      border-left: 4px solid #3b82f6;
    }
    .status.show {
      display: block;
    }
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    .pillar-card {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: relative;
      display: flex;
      flex-direction: column;
      min-height: 100%; /* Ensure all cards have same minimum height */
    }
    .pillar-card h3 {
      margin: 0 0 0.75rem 0;
      color: var(--brand-dark);
      font-size: 1.1rem;
    }
    .pillar-score {
      font-size: 3rem;
      font-weight: 700;
      margin: 0.5rem 0;
      line-height: 1;
    }
    .pillar-score.rag-red {
      color: var(--danger);
    }
    .pillar-score.rag-amber {
      color: var(--warning);
    }
    .pillar-score.rag-green {
      color: var(--success);
    }
    .rag-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.875rem;
      font-weight: 600;
      margin-top: 0.75rem;
      margin-bottom: 0.5rem;
    }
    .rag-badge.red {
      background: #fee2e2;
      color: #991b1b;
    }
    .rag-badge.amber {
      background: #fef3c7;
      color: #92400e;
    }
    .rag-badge.green {
      background: #d1fae5;
      color: #065f46;
    }
    .chart-container {
      background: linear-gradient(135deg, #f0f4f8 0%, #e2e8f0 100%);
      padding: 1.5rem;
      padding-bottom: 12rem; /* Extra padding at bottom for rotated 45-degree axis labels - need significant space for diagonal labels */
      padding-right: 3rem; /* Extra padding on right for Y-axis labels */
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 6rem; /* extra breathing room below charts */
      height: 1000px; /* Doubled from 500px to 1000px for better chart visibility and less bunching */
      min-height: 1000px; /* Ensure minimum height */
      border: 1px solid rgba(100, 116, 139, 0.2);
      overflow: hidden; /* Change to hidden to clip content that extends beyond container */
    }
    .chart-container.large {
      height: 1200px;
      min-height: 1200px;
      padding: 2rem;
    }
    .dashboard-two-column {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-three-column {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-four-column {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    @media (max-width: 1200px) {
      .dashboard-four-column {
        grid-template-columns: repeat(2, 1fr);
      }
      .dashboard-three-column {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    @media (max-width: 768px) {
      .dashboard-two-column,
      .dashboard-three-column,
      .dashboard-four-column {
        grid-template-columns: 1fr;
      }
    }
    .chart-container h3 {
      margin: 0 0 0.5rem 0;
      color: var(--brand-dark);
    }
    .chart-container p {
      margin: 0 0 1rem 0;
    }
    .trend-summary-row {
      display: flex;
      gap: 1.5rem;
      font-size: 0.9rem;
      margin-bottom: 0.75rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .trend-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.7);
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.06);
      border: 1px solid rgba(148, 163, 184, 0.3);
    }
    .trend-pill span.label {
      font-weight: 600;
      color: #374151;
    }
    .trend-pill span.value.up {
      font-weight: 700;
      color: #10b981; /* green */
    }
    .trend-pill span.value.down {
      font-weight: 700;
      color: #ef4444; /* red */
    }
    .trend-pill span.value.neutral {
      font-weight: 700;
      color: #1f2937; /* black/dark gray for no change */
    }
    .metrics-section {
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border: 1px solid rgba(59, 130, 246, 0.1);
    }
    .scorecard-section {
      margin-top: 4rem;  /* push scorecard further below charts */
      margin-bottom: 3rem;
    }
    .scorecard-section h3 {
      margin-bottom: 1.5rem;
    }
    .metrics-section {
      margin-top: 3rem;
      margin-bottom: 3rem;
    }
    .metrics-section h3 {
      margin-bottom: 1.5rem;
    }
    .section-break {
      margin-top: 4rem;
      margin-bottom: 4rem;
      border-top: 2px solid #e2e8f0;
      padding-top: 2rem;
    }
    .calculation-explanation {
      background: #f8f9fa;
      border: 2px solid var(--brand-orange);
      border-radius: 8px;
      margin-bottom: 2rem;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(229, 114, 0, 0.15);
    }
    .calculation-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: linear-gradient(135deg, #fff5f0 0%, #ffe8d6 100%);
      border-bottom: 2px solid var(--brand-orange);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    .calculation-explanation.collapsed .calculation-header {
      border-bottom: none;
    }
    .calculation-header:hover {
      background: linear-gradient(135deg, #ffe8d6 0%, #ffd9b3 100%);
    }
    .calculation-header h4 {
      margin: 0;
      color: var(--brand-orange);
      font-size: 1.1rem;
      font-weight: 600;
    }
    .calculation-toggle {
      font-size: 1.2rem;
      color: var(--brand-orange);
      font-weight: bold;
      transition: transform 0.3s;
    }
    .calculation-explanation.collapsed .calculation-toggle {
      transform: rotate(-90deg);
    }
    .calculation-content {
      padding: 1.5rem;
      color: #555;
      line-height: 1.8;
    }
    .calculation-content.collapsed {
      display: none;
    }
    .calculation-content h5 {
      color: var(--brand-dark);
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-size: 1rem;
      font-weight: 600;
      border-bottom: 2px solid var(--brand-orange);
      padding-bottom: 0.5rem;
    }
    .calculation-content h5:first-child {
      margin-top: 0;
    }
    .calculation-content ul {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
    }
    .calculation-content li {
      margin: 0.5rem 0;
    }
    .calculation-content code {
      background: #e2e8f0;
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #c53030;
    }
    .calculation-content .formula {
      background: #f0f4f8;
      padding: 0.75rem;
      border-left: 3px solid var(--brand-orange);
      margin: 0.75rem 0;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
    }
    .calculation-content .note {
      background: #fff3cd;
      border-left: 3px solid #f59e0b;
      padding: 0.75rem;
      margin: 1rem 0;
      font-size: 0.9rem;
    }
    .date-range-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .date-range-btn {
      padding: 0.5rem 1rem;
      border: 2px solid #e2e8f0;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    .date-range-btn:hover {
      border-color: var(--brand-orange);
      background: #fff5f0;
    }
    .date-range-btn.active {
      background: var(--brand-orange);
      color: white;
      border-color: var(--brand-orange);
    }
    .snippet-readiness-gauge {
      background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 3rem;
      border: 1px solid rgba(16, 185, 129, 0.1);
    }
    .gauge-container {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      flex: 1;
      position: relative;
    }
    .gauge-wrapper {
      position: relative;
      width: 300px;
      height: 300px;
    }
    .gauge-svg {
      transform: rotate(-90deg);
      width: 100%;
      height: 100%;
    }
    .gauge-background {
      fill: none;
      stroke: #e2e8f0;
      stroke-width: 20;
    }
    .gauge-fill {
      fill: none;
      stroke-width: 20;
      stroke-linecap: round;
      transition: stroke-dashoffset 1s ease-in-out;
    }
    .gauge-fill.green {
      stroke: #10b981;
    }
    .gauge-fill.amber {
      stroke: #f59e0b;
    }
    .gauge-fill.red {
      stroke: #ef4444;
    }
    .gauge-value {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      font-weight: 700;
      text-align: center;
      z-index: 10;
    }
    .gauge-value.green {
      color: #10b981;
    }
    .gauge-value.amber {
      color: #f59e0b;
    }
    .gauge-value.red {
      color: #ef4444;
    }
    .gauge-label {
      text-align: center;
      color: var(--brand-grey);
      margin-top: 1rem;
      font-size: 1rem;
      font-weight: 600;
    }
    .gauge-status {
      text-align: center;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      font-weight: 500;
    }
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }
    .metric-card {
      background: white;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
    }
    .metric-card .value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--brand-orange);
      margin: 0.5rem 0;
    }
    .metric-card .label {
      color: var(--brand-grey);
      font-size: 0.875rem;
    }
    .loading {
      display: none;
      text-align: center;
      padding: 2rem;
    }
    .loading.show {
      display: block;
    }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--brand-orange);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .progress-container {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1rem 0;
    }
    .progress-bar-wrapper {
      width: 100%;
      background: #e2e8f0;
      border-radius: 10px;
      height: 24px;
      overflow: hidden;
      margin: 1rem 0;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--brand-orange), #ff8c42);
      border-radius: 10px;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 0.85rem;
      min-width: 0;
    }
    .progress-status {
      font-size: 0.95rem;
      color: #555;
      margin-top: 0.5rem;
      font-weight: 500;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      overflow: auto;
    }
    .modal-content {
      background-color: white;
      margin: 5% auto;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      animation: modalSlideIn 0.3s ease;
    }
    @keyframes modalSlideIn {
      from {
        transform: translateY(-50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    .help-text {
      font-size: 0.875rem;
      color: var(--brand-grey);
      margin-top: 0.25rem;
    }

    .debug-panel-bottom {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1a1a1a;
      border-top: 3px solid #E57200;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      z-index: 1000;
      box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.5);
      max-height: 50vh;
      display: flex;
      flex-direction: column;
    }

    .debug-panel-bottom.collapsed {
      max-height: 50px;
    }

    .debug-panel-bottom.collapsed .debug-content {
      display: none !important;
    }

    .debug-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #333;
      background: #252525;
      user-select: none;
    }

    .debug-header h3 {
      margin: 0;
      color: #fff;
      font-size: 1rem;
    }

    .debug-actions {
      display: flex;
      gap: 0.5rem;
    }

    .btn-small {
      padding: 0.25rem 0.75rem;
      font-size: 0.75rem;
      background: #333;
      color: #fff;
      border: 1px solid #555;
    }

    .btn-small:hover {
      background: #444;
    }

    .debug-content {
      color: #fff;
      line-height: 1.6;
      padding: 1rem;
      overflow-y: auto;
      flex: 1;
      max-height: calc(50vh - 60px);
    }

    .debug-log-entry {
      margin-bottom: 0.25rem;
      padding: 0.25rem 0;
      border-left: 2px solid transparent;
      padding-left: 0.5rem;
    }

    .debug-log-entry.error {
      color: #f44;
      border-left-color: #f44;
    }

    .debug-log-entry.warn {
      color: #fa4;
      border-left-color: #fa4;
    }

    .debug-log-entry.info {
      color: #9cf;
      border-left-color: #4af;
    }

    .debug-log-entry.success {
      color: #9f9;
      border-left-color: #4f4;
    }

    .debug-timestamp {
      color: #aaa;
      margin-right: 0.5rem;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>AI GEO Audit Dashboard</h1>
    <p>Automated SEO Analysis & Pillar Score Tracking</p>
    <p style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 1; background: rgba(0,0,0,0.3); padding: 0.25rem 0.5rem; border-radius: 4px; display: inline-block;">
      <strong>Version: <span id="gitVersion">37685db</span></strong> | Built: <span id="buildDate"></span> | 
      <span id="loadTime" style="color: #4f4;">Loaded: <span id="loadTimeValue"></span></span>
    </p>
    <script>
      // Set build date to today in GMT
      const now = new Date();
      const gmtDate = now.toISOString().split('T')[0]; // YYYY-MM-DD
      const gmtTime = now.toISOString().split('T')[1].split('.')[0]; // HH:MM:SS
      document.getElementById('buildDate').textContent = gmtDate + ' ' + gmtTime + ' GMT';
      document.getElementById('loadTimeValue').textContent = now.toLocaleTimeString();
    </script>
  </div>

  <div class="container">
    <div class="config-panel">
      <h2>Configuration</h2>
      <div class="info-box" style="background: #e8f4f8; border-left: 4px solid #2196F3; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #1565C0;"><strong>Entity-Level Audit:</strong> This dashboard analyzes <strong>www.alanranger.com</strong> as a global entity, tracking AI-powered search visibility, entity recognition, and SERP behavior across the entire domain.</p>
      </div>
      <div class="form-group">
        <label for="propertyUrl">Property URL</label>
        <input type="text" id="propertyUrl" placeholder="https://yourwebsite.com" value="https://www.alanranger.com">
        <div class="help-text">The domain being audited (entity-level analysis)</div>
      </div>
      <div class="form-group">
        <label for="dateRange">Date Range</label>
        <div class="date-range-selector">
          <button class="date-range-btn active" onclick="setDateRange(30)" data-days="30" title="Analyze search performance data from the last 30 days">Last 30 Days</button>
          <button class="date-range-btn" onclick="setDateRange(60)" data-days="60" title="Analyze search performance data from the last 60 days">Last 60 Days</button>
          <button class="date-range-btn" onclick="setDateRange(90)" data-days="90" title="Analyze search performance data from the last 90 days">Last 90 Days</button>
          <button class="date-range-btn" onclick="setDateRange(120)" data-days="120" title="Analyze search performance data from the last 120 days">Last 120 Days</button>
          <button class="date-range-btn" onclick="setDateRange(180)" data-days="180" title="Analyze search performance data from the last 6 months (180 days)">Last 6 Months</button>
          <button class="date-range-btn" onclick="setDateRange(365)" data-days="365" title="Analyze search performance data from the last 12 months (365 days)">Last 12 Months</button>
          <button class="date-range-btn" onclick="setDateRange(540)" data-days="540" title="Analyze search performance data from the last 18 months (540 days)">Last 18 Months</button>
          <button class="date-range-btn" onclick="showCustomDateRange()" id="customDateBtn" title="Set a custom date range for analysis (enter number of days)">Custom</button>
        </div>
        <input type="number" id="dateRange" value="30" min="1" style="display: none;">
        <div id="customDateRange" style="display: none; margin-top: 0.5rem;">
          <input type="number" id="customDays" placeholder="Enter days" min="1" style="width: 150px; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px;">
          <button class="btn btn-small" onclick="applyCustomDateRange()" style="margin-left: 0.5rem; padding: 0.5rem 1rem;" title="Apply the custom date range you entered">Apply</button>
        </div>
        <div class="help-text">Analysis period for historical data</div>
      </div>
      <div style="background: #f0f0f0; padding: 0.75rem; border-radius: 4px; margin-bottom: 1rem; font-size: 0.85rem; color: #555;">
        <strong>API Key:</strong> Loaded automatically from Vercel environment variables. No manual entry required.
      </div>
      <div class="form-group">
        <label for="manualUrlList">Manual URL List (Optional)</label>
        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">
          Load list of site URLs from a CSV file
        </div>
        <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
          <input type="file" id="urlListFile" accept=".csv" style="flex: 1; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem;">
          <button class="btn btn-small" onclick="loadUrlListFromFile()" style="padding: 0.5rem 1rem;" title="Load a CSV file containing site URLs. The CSV must have a 'url' column in the header row. URLs will be used for schema audit instead of the default CSV source.">Load CSV</button>
          <button class="btn btn-small" onclick="clearManualUrlList()" style="padding: 0.5rem 1rem; background: #ef4444; color: white; border-color: #ef4444;" title="Clear the manually loaded URL list and revert to using the default CSV source for schema audit">Clear</button>
        </div>
        <textarea id="manualUrlList" placeholder="Or paste CSV content here (must include 'url' column in header row)..." style="width: 100%; min-height: 100px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace; resize: vertical;"></textarea>
        <div class="help-text">
          <strong>Required column:</strong> <code>url</code> (case-insensitive). CSV must have a header row. URLs will be extracted from the 'url' column.
        </div>
        <div id="urlListStatus" style="margin-top: 0.5rem; font-size: 0.85rem;"></div>
      </div>
      <div class="form-group">
        <label for="backlinkCsvFile">Backlink CSV Upload (Optional)</label>
        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">
          Upload backlink data CSV file for Authority score calculation. Can be uploaded independently of site URLs CSV.
        </div>
        <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
          <input type="file" id="backlinkCsvFile" accept=".csv" style="flex: 1; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem;">
          <button class="btn btn-small" onclick="uploadBacklinkCsv()" style="padding: 0.5rem 1rem;" title="Upload a CSV file containing backlink data. The CSV must have 'Linking Page + URL' and 'Link Type' columns. This data is used to calculate the Backlink component of the Authority score.">Upload CSV</button>
          <button class="btn btn-small" onclick="clearBacklinkCsv()" style="padding: 0.5rem 1rem; background: #ef4444; color: white; border-color: #ef4444;" title="Clear the uploaded backlink CSV data">Clear</button>
        </div>
        <textarea id="backlinkCsvContent" placeholder="Or paste backlink CSV content here (must include 'Linking Page + URL' and 'Link Type' columns in header row)..." style="width: 100%; min-height: 100px; padding: 0.75rem; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.9rem; font-family: monospace; resize: vertical;"></textarea>
        <div class="help-text">
          <strong>Required columns:</strong> <code>Linking Page + URL</code> (contains page title and URL), <code>Link Type</code> (DoFollow, Follow, Nofollow, etc.). Other columns are optional. This CSV is used only for Authority score calculation and is independent of the site URLs CSV.
        </div>
        <div id="backlinkCsvStatus" style="margin-top: 0.5rem; font-size: 0.85rem;"></div>
      </div>
      <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
        <button class="btn" onclick="runAudit()" title="Start a comprehensive audit scan. Fetches Google Search Console data, performs schema audit (if site URLs CSV loaded), and uses backlink data (if backlink CSV uploaded). Results will appear in the dashboard below.">Run Audit Scan</button>
        <button class="btn btn-secondary" id="retryFailedUrlsBtn" onclick="retryFailedUrlsFromLastAudit()" style="background: #f59e0b; color: white; border-color: #f59e0b; display: none;" title="Retry scanning the failed URLs from the last audit. This will rescan only the URLs that failed during the previous audit scan.">
          üîÑ Retry Failed URLs
        </button>
        <button class="btn btn-secondary" onclick="saveConfig()" title="Save your current configuration (property URL and date range) to browser localStorage. Settings will be restored when you reload the page.">Save Configuration</button>
        <button class="btn btn-secondary" onclick="syncCSV()" id="syncCsvBtn" style="background: #10b981; color: white; border-color: #10b981;" title="Sync the site URLs CSV file from GitHub. This updates the list of URLs that will be scanned during schema audit.">
          <span id="syncCsvBtnText">üîÑ Sync CSV</span>
        </button>
      </div>
    </div>

    <!-- Reporting Section -->
    <div class="config-panel" style="margin-top: 2rem;">
      <h2>Reporting</h2>
      <div class="info-box" style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #856404;"><strong>Generate Reports:</strong> Create comprehensive PDF reports containing all audit data, charts, and pillar score definitions.</p>
      </div>
      <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
        <button class="btn" onclick="try { console.log('[PDF] Button clicked!'); generatePDFReport(); } catch(e) { console.error('[PDF] Error in onclick:', e); alert('Error generating PDF: ' + e.message); }" id="generatePdfBtn" style="background: #dc2626; color: white; border-color: #dc2626;" title="Generate a comprehensive PDF report containing all audit data, charts, pillar scores, definitions, and metrics. The report will include all sections from the dashboard.">
          üìÑ Generate PDF Report
        </button>
        <div id="pdfStatus" style="font-size: 0.85rem; color: #666; margin-left: 0.5rem;"></div>
      </div>
    </div>

    <div class="status" id="status"></div>

    <div class="loading" id="loading">
      <div class="progress-container">
        <div class="spinner"></div>
        <div class="progress-bar-wrapper">
          <div class="progress-bar" id="progressBar" style="width: 0%;">0%</div>
        </div>
        <div class="progress-status" id="progressStatus">Initializing audit scan...</div>
      </div>
    </div>

    <!-- Completion Summary Modal -->
    <div id="completionModal" class="modal" style="display: none;">
      <div class="modal-content" style="max-width: 600px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: var(--brand-orange);">Audit Complete</h2>
          <button onclick="closeCompletionModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;" title="Close the audit completion summary modal">&times;</button>
        </div>
        <div id="completionSummaryContent"></div>
        <div style="margin-top: 1.5rem; text-align: right;">
          <button class="btn" onclick="closeCompletionModal()" style="background: var(--brand-orange); color: white; border-color: var(--brand-orange);" title="Close the audit completion summary modal and return to the dashboard">Close</button>
        </div>
      </div>
    </div>

    <div id="dashboard" style="display: none;">
      <div id="auditTimestamp" style="background: #e8f5e9; padding: 0.75rem 1rem; border-radius: 6px; margin-bottom: 1rem; border-left: 4px solid #10b981; font-size: 0.9rem; color: #555;">
        <strong>Last Audit:</strong> <span id="lastAuditTime">Not yet run</span>
      </div>
      <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px; margin-bottom: 3rem; border-left: 4px solid var(--brand-orange);">
        <h3 style="margin-top: 0; color: var(--brand-orange);">Five-Pillar Framework</h3>
        <p style="color: #555; line-height: 1.6; margin-bottom: 1rem;">
          This audit analyzes <strong>www.alanranger.com</strong> as a global entity using a five-pillar framework to assess AI-powered search visibility, entity recognition, and SERP behavior. Each pillar is scored 0-100 and assigned a RAG (Red/Amber/Green) status based on performance thresholds.
        </p>
        <p style="color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
          <strong>Data Sources:</strong> Scores are calculated using data from Google Search Console API (impressions, clicks, position, queries), schema markup validation, local pack visibility metrics, and SERP feature tracking (featured snippets, AI Overviews, rich results).
        </p>
        <p style="color: #555; line-height: 1.6; margin-bottom: 0;">
          <strong>Score Calculation:</strong> Each pillar combines multiple weighted factors: Local Entity (brand consistency, entity signals, NAP data), Service Area (geographic coverage, location schema), Authority (E-A-T: Behaviour 40% + Ranking 20% + Backlinks 20% + Reviews 20%), Visibility (ranking positions, SERP features, CTR), and Content/Schema (Foundation schemas 30% + Rich Results 35% + Coverage 20% + Diversity 15%). Scores are normalized to 0-100 scale with thresholds: Green (70-100), Amber (40-69), Red (0-39).
        </p>
      </div>

      <div class="calculation-explanation collapsed" id="calculationExplanation">
        <div class="calculation-header" onclick="toggleCalculationExplanation()">
          <h4>üìä Detailed Calculation Explanation</h4>
          <span class="calculation-toggle" id="calculationToggle">‚ñ∂</span>
        </div>
        <div class="calculation-content collapsed" id="calculationContent">
          <h5>1. Visibility</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Primary: Average position from Google Search Console (1-40 mapped to 100-10)</li>
            <li>Formula: <code>posScore = 100 - ((clampedPosition - 1) / 39) * 90</code></li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: impressions, clicks, average position, CTR</li>
            <li>SERP feature tracking: featured snippets, AI Overviews, rich results</li>
          </ul>
          <p><strong>Data Checked:</strong> Search Console impressions/clicks, average position, CTR, featured snippet appearances, local pack visibility, SERP feature presence, ranking distribution.</p>

          <h5>2. Authority (E-E-A-T)</h5>
          <p><strong>What Authority Represents:</strong></p>
          <p>Authority is not "how good the content is", it's "how much the outside world and searchers trust and choose you". It approximates E-E-A-T using four ingredients:</p>
          <ul>
            <li><strong>Behavioural signals</strong> ‚Äì do people click your results when they see them?</li>
            <li><strong>Ranking strength</strong> ‚Äì how often do you show near the top of organic results?</li>
            <li><strong>Off-site credibility</strong> ‚Äì backlinks from other domains (Phase 3)</li>
            <li><strong>Reputation & reviews</strong> ‚Äì ratings and review volume across GBP + website</li>
          </ul>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Four-component model: Behaviour (40%), Ranking (20%), Backlinks (20%), Reviews (20%)</li>
            <li>Formula: <code>authority = 0.4 * behaviourScore + 0.2 * rankingScore + 0.2 * backlinkScore + 0.2 * reviewScore</code></li>
            <li>Each sub-score is normalized to 0-100, then combined with weights above</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>2.1 Behaviour Score (40%):</strong></p>
          <ul>
            <li>From Google Search Console: Only uses queries where average position ‚â§ 20</li>
            <li>Computes: ctrAll = CTR for all ranking queries, ctrTop10 = CTR for impressions where position ‚â§ 10</li>
            <li>Maps: ctrAll 0-5% ‚Üí 0-100 (values >5% capped at 100), ctrTop10 0-10% ‚Üí 0-100</li>
            <li>Combines: <code>BehaviourScore = 0.5 * score(ctrAll) + 0.5 * score(ctrTop10)</code></li>
            <li>This stops long-tail / low-rank pages dragging the whole site down</li>
          </ul>
          <p><strong>2.2 Ranking Score (20%):</strong></p>
          <ul>
            <li>From GSC, again only for position ‚â§ 20</li>
            <li>avgPos = impression-weighted average position</li>
            <li>top10Share = % of impressions where position ‚â§ 10</li>
            <li>posScore = map(avgPos, 1 ‚Üí 100, 20 ‚Üí 0) (clamped)</li>
            <li>top10Score = top10Share as a % (0-100)</li>
            <li>Combines: <code>RankingScore = 0.5 * posScore + 0.5 * top10Score</code></li>
          </ul>
          <p><strong>2.3 Review Score (20%):</strong></p>
          <ul>
            <li>Inputs: From GBP API (gbpRating 0-5, gbpReviewCount) and Trustpilot snapshot (siteRating 4.6, siteReviewCount 610)</li>
            <li>Per source: ratingScore = (rating/5)*100, countScore = min(reviewCount, 500)/500*100</li>
            <li>sourceScore = 0.6 * ratingScore + 0.4 * countScore</li>
            <li>Final: <code>ReviewScore = 0.6 * gbpSourceScore + 0.4 * siteSourceScore</code></li>
            <li>If one source missing, falls back to the other; if both missing, uses neutral default (50)</li>
          </ul>
          <p><strong>2.4 Backlink Score (20%):</strong></p>
          <ul>
            <li>Phase 3 ‚Äì using CSVs: refDomainCount, qualityDomains, qualityRatio</li>
            <li>countScore = map(refDomainCount, 0 ‚Üí 0, N ‚Üí 100) where N is cap (e.g. 150-200)</li>
            <li>qualityScore = qualityRatio * 100</li>
            <li>Combines: <code>BacklinkScore = 0.5 * countScore + 0.5 * qualityScore</code></li>
            <li>Currently placeholder (50) until Phase 3 is implemented</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API (CTR, position, impressions by position bucket)</li>
            <li>Google Business Profile API (ratings, review count)</li>
            <li>Trustpilot reviews (historic snapshot: rating 4.6, count 610)</li>
            <li>Backlink CSV upload (referring domains, quality metrics) - Phase 3</li>
          </ul>
          <p><strong>How to Improve Authority:</strong></p>
          <ul>
            <li><strong>Behaviour:</strong> Improve titles/meta descriptions on pages already in top 10-20. Focus on high-impression queries in GSC.</li>
            <li><strong>Ranking:</strong> Push more core pages into top 10 (content refreshes, internal links, stronger schema).</li>
            <li><strong>Reviews:</strong> Keep growing GBP and Trustpilot reviews; higher rating and more volume both help.</li>
            <li><strong>Backlinks:</strong> Acquire more distinct linking domains, favouring sites with real traffic/authority (Phase 3).</li>
          </ul>

          <h5>3. Local Entity</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Anchored around 60, adjusted by position and CTR</li>
            <li>Formula: <code>localEntity = 60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50)</code></li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API: position, CTR</li>
            <li>Schema markup validation (planned)</li>
            <li>Knowledge panel tracking (planned)</li>
          </ul>
          <p><strong>Data Checked:</strong> LocalBusiness schema presence, NAP consistency across site, entity mentions in content, knowledge panel presence, author markup, Organization schema.</p>

          <h5>4. Service Area</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Derived from Local Entity, slightly lower</li>
            <li>Formula: <code>serviceArea = localEntity - 5</code></li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Google Search Console API (via Local Entity calculation)</li>
            <li>Schema markup validation (planned)</li>
            <li>Google Business Profile data (planned)</li>
          </ul>
          <p><strong>Data Checked:</strong> ServiceArea schema markup, geographic keywords in content, location pages, Google Business Profile service areas, address/location schema.</p>

          <h5>5. Content/Schema</h5>
          <p><strong>Measurement:</strong></p>
          <ul>
            <li>Weighted calculation based on four components: Foundation schemas, Rich Results, Coverage, and Diversity</li>
            <li>Formula: <code>contentSchema = (Foundation √ó 30%) + (Rich Results √ó 35%) + (Coverage √ó 20%) + (Diversity √ó 15%)</code></li>
            <li><strong>Foundation Schemas (30%):</strong> Organization, Person, WebSite, BreadcrumbList presence. Score = (types present / 4) √ó 100</li>
            <li><strong>Rich Results (35%):</strong> Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList eligibility. Score = (eligible types / 11) √ó 100</li>
            <li><strong>Coverage (20%):</strong> Pages with schema / total pages. Score = coverage percentage</li>
            <li><strong>Diversity (15%):</strong> Number of unique schema types across site. Score = min((unique types / 15) √ó 100, 100)</li>
            <li><strong>Data Source:</strong> Schema audit API (crawls actual pages for JSON-LD markup)</li>
            <li>Uses real schema coverage from CSV-based audit (when available)</li>
            <li>Score range: 0-100</li>
          </ul>
          <p><strong>Data Sources:</strong></p>
          <ul>
            <li>Schema Audit API: CSV-based domain crawl of all site URLs</li>
            <li>Schema markup detection and type counting</li>
            <li>Foundation schema presence detection (Organization, Person, WebSite, BreadcrumbList)</li>
            <li>Rich result eligibility detection (Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList)</li>
          </ul>
          <p><strong>Data Checked:</strong> Total pages scanned, pages with schema, schema coverage percentage, schema types present (Organization, Person, LocalBusiness, Article, Course, Event, FAQ, HowTo, etc.), missing schema types, rich result eligibility (Article, Event, FAQ, Product, LocalBusiness, Course, Review, HowTo).</p>

          <div class="note">
            <strong>Current Implementation Status:</strong><br>
            <strong>Currently Active:</strong> Google Search Console API integration (real-time data) - Total clicks, Total impressions, Average position, CTR calculation, Top queries.<br><br>
            <strong>Planned/Future Enhancements:</strong> Schema markup validation and analysis, Backlink quality/quantity analysis, Review aggregation, Knowledge panel tracking, Local pack visibility metrics, SERP feature detection, Rich result eligibility checks.<br><br>
            <strong>Note:</strong> Currently, most pillars are calculated from GSC metrics (position, CTR, impressions, clicks). The formulas are deterministic and stable, but full implementation will require additional data sources for complete accuracy.
          </div>
        </div>
      </div>

      <div class="dashboard-grid" id="pillarCards"></div>

      <div class="section-break"></div>

      <div class="metrics-section">
        <h3 style="color: var(--brand-orange); margin-bottom: 0.5rem;">Key Performance Indicators</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Core metrics from Google Search Console showing overall search performance for the entity. <strong>Note:</strong> Small differences from live GSC may occur due to data processing delays (up to 48 hours) and exact date range calculations.</p>
        <div class="metrics-grid" id="metricsGrid"></div>
      </div>

      <div class="section-break"></div>

      <div class="dashboard-two-column">
        <div class="chart-container large">
          <h3>Pillar Scores Overview</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Radar chart showing current performance across all five pillars. The larger the area, the stronger your overall entity recognition.</p>
          
          <!-- Audit Timestamp for Radar Chart -->
          <div id="radarChartTimestamp" style="background: #fff3cd; padding: 0.5rem 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #f59e0b; font-size: 0.8rem; color: #856404; display: none;">
            <strong>Current data as of:</strong> <span id="radarChartAuditTime">-</span> <span style="color: #666; font-size: 0.75rem;">(Not historical - reflects last audit scan)</span>
          </div>
          
          <canvas id="radarChart"></canvas>
        </div>

        <div class="snippet-readiness-gauge">
          <h3 style="margin-top: 0; color: var(--brand-orange);">Snippet Readiness Gauge</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Snippet readiness summarises how likely your content is to be lifted into featured snippets and AI answers. It reflects three ingredients: snippet-friendly answer blocks, suitable schema (FAQ/HowTo/Article/Course/Event) and existing rich-result behaviour.</p>
          
          <!-- Audit Timestamp for Snippet Readiness -->
          <div id="snippetReadinessTimestamp" style="background: #fff3cd; padding: 0.5rem 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #f59e0b; font-size: 0.8rem; color: #856404; display: none;">
            <strong>Current data as of:</strong> <span id="snippetReadinessAuditTime">-</span> <span style="color: #666; font-size: 0.75rem;">(Not historical - reflects last audit scan)</span>
          </div>
          
          <div id="snippetReadinessExplanation" style="display: none; background: #fde68a; border-left: 4px solid #f59e0b; padding: 1rem; margin-bottom: 1rem; border-radius: 4px; font-size: 0.85rem; color: #78350f;">
            <strong id="explanationTitle" style="color: #78350f;">Top 5 Actions to Improve Snippet Readiness</strong>
            <p style="margin: 0.5rem 0; color: #78350f;">Prioritized actions based on your current scores and their impact on overall snippet readiness:</p>
            <ol id="topActionsList" style="margin: 0.5rem 0 0 1.5rem; padding: 0; list-style-type: decimal;">
              <!-- Top 5 actions will be populated dynamically -->
            </ol>
          </div>
          
          <!-- Overall Combined Score -->
          <div style="text-align: center; margin-bottom: 1.5rem;">
            <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">Overall Snippet Readiness</div>
            <div id="snippetReadinessScore" style="font-size: 3rem; font-weight: 700; color: var(--brand-orange); line-height: 1;">0</div>
            <div id="gaugeStatus" style="font-size: 0.9rem; color: #666; margin-top: 0.25rem;">Calculating...</div>
          </div>
          
          <!-- Pie Chart Container -->
          <div style="display: flex; align-items: center; justify-content: center; gap: 1.5rem; flex-wrap: wrap;">
            <div style="flex: 2; min-width: 400px; max-width: 500px;">
              <canvas id="snippetReadinessPieChart"></canvas>
            </div>
            <div style="flex: 1; min-width: 180px; max-width: 250px;">
              <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--brand-dark);">Component Breakdown:</div>
              <div id="snippetReadinessLegend" style="display: flex; flex-direction: column; gap: 0.5rem;">
                <!-- Legend will be populated by JavaScript -->
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="section-break"></div>

      <div class="chart-container">
        <h3>Score Trends</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Historical performance tracking for all five pillars (Local Entity, Service Area, Authority, Visibility, Content/Schema) over the selected date range.</p>
        <div id="trendAuthorityModeToggle" class="authority-mode-toggle" style="margin-bottom: 1rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; display: none;">
          <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
            <span style="font-weight: 600; color: #666;">Authority Mode:</span>
            <button id="trend-mode-all" class="authority-mode-btn" data-mode="all" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: #10b981; color: white; cursor: pointer; font-size: 0.75rem;">
              All pages
            </button>
            <button id="trend-mode-nonEducation" class="authority-mode-btn" data-mode="nonEducation" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
              Exclude education
            </button>
            <button id="trend-mode-money" class="authority-mode-btn" data-mode="money" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
              Money pages only
            </button>
          </div>
        </div>
        <div id="trendSummaryRow" class="trend-summary-row"></div>
        <canvas id="trendChart"></canvas>
      </div>

    </div>

    <!-- Debug Panel - Fixed at bottom, collapsible -->
    <div class="debug-panel-bottom" id="debugPanel">
      <div class="debug-header" onclick="toggleDebugPanel()" style="cursor: pointer;">
        <h3>üîç Debug Log</h3>
        <div class="debug-actions">
          <button class="btn btn-small" onclick="event.stopPropagation(); clearDebugLog();" title="Clear all debug log entries. Useful for starting fresh during troubleshooting.">Clear</button>
          <button class="btn btn-small" onclick="event.stopPropagation(); copyDebugLog();" title="Copy the entire debug log to your clipboard. Useful for sharing logs or troubleshooting issues.">Copy Log</button>
          <span id="debugToggleIcon" style="color: #fff; font-size: 1.2rem;">‚ñº</span>
        </div>
      </div>
      <div class="debug-content" id="debugLog" style="display: block;">
        <div class="debug-log-entry info">
          <span class="debug-timestamp">[Initializing...]</span>Debug panel loaded. Waiting for page initialization...
        </div>
      </div>
    </div>
  </div>

  <script>
    // Immediate console log to verify script is running
    console.log('%c=== AI GEO AUDIT DASHBOARD LOADED ===', 'color: #E57200; font-size: 16px; font-weight: bold;');
    console.log('%cDebug panel should be visible at bottom with orange border', 'color: #E57200; font-size: 14px;');
    console.log('Current time:', new Date().toISOString());
    console.log('Page URL:', window.location.href);
    
    // Debug logging system
    const debugLogEntries = [];
    
    function debugLog(message, type = 'info') {
      const timestamp = new Date().toISOString();
      const entry = {
        timestamp,
        message,
        type
      };
      debugLogEntries.push(entry);
      
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        const entryDiv = document.createElement('div');
        entryDiv.className = `debug-log-entry ${type}`;
        entryDiv.innerHTML = `<span class="debug-timestamp">[${new Date(timestamp).toLocaleTimeString()}]</span>${message}`;
        logElement.appendChild(entryDiv);
        logElement.scrollTop = logElement.scrollHeight;
      }
      
      // Only log critical errors to browser console (for debugging production issues)
      // All other logs go to UI debug console only
      if (type === 'error') {
        console.error(`[DEBUG ERROR]`, message);
      }
    }

    function clearDebugLog() {
      debugLogEntries.length = 0;
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        logElement.innerHTML = '';
      }
      debugLog('Debug log cleared', 'info');
    }

    function copyDebugLog() {
      const logText = debugLogEntries.map(entry => 
        `[${entry.timestamp}] [${entry.type.toUpperCase()}] ${entry.message}`
      ).join('\n');
      
      navigator.clipboard.writeText(logText).then(() => {
        debugLog('Debug log copied to clipboard', 'success');
        showStatus('Debug log copied to clipboard!', 'success');
      }).catch(err => {
        debugLog('Failed to copy log: ' + err.message, 'error');
        showStatus('Failed to copy log', 'error');
      });
    }

    function toggleDebugPanel() {
      const panel = document.getElementById('debugPanel');
      const icon = document.getElementById('debugToggleIcon');
      if (panel.classList.contains('collapsed')) {
        panel.classList.remove('collapsed');
        if (icon) icon.textContent = '‚ñº';
      } else {
        panel.classList.add('collapsed');
        if (icon) icon.textContent = '‚ñ≤';
      }
    }

    function toggleCalculationExplanation() {
      const explanation = document.getElementById('calculationExplanation');
      const content = document.getElementById('calculationContent');
      const toggle = document.getElementById('calculationToggle');
      if (explanation.classList.contains('collapsed')) {
        explanation.classList.remove('collapsed');
        content.classList.remove('collapsed');
        if (toggle) toggle.textContent = '‚ñº';
      } else {
        explanation.classList.add('collapsed');
        content.classList.add('collapsed');
        if (toggle) toggle.textContent = '‚ñ∂';
      }
    }

    // Debug panel is always visible at bottom, start collapsed by default
    window.addEventListener('DOMContentLoaded', () => {
      const debugPanel = document.getElementById('debugPanel');
      const debugToggleIcon = document.getElementById('debugToggleIcon');
      if (debugPanel) {
        debugPanel.style.display = 'flex';
        // Start collapsed by default
        debugPanel.classList.add('collapsed');
        if (debugToggleIcon) {
          debugToggleIcon.textContent = '‚ñ≤';
        }
      }
    });

    // Load saved configuration
    async function loadConfig() {
      debugLog('=== PAGE LOAD: Starting configuration load ===', 'info');
      
      // Check if Chart.js is loaded
      debugLog('Checking Chart.js library...', 'info');
      if (typeof Chart !== 'undefined') {
        debugLog('‚úì Chart.js library loaded successfully', 'success');
      } else {
        debugLog('‚úó Chart.js library NOT loaded', 'error');
      }
      
      // Try to fetch API key from Vercel environment variable (via API endpoint)
      let vercelApiKey = null;
      try {
        debugLog('Checking Vercel environment variable...', 'info');
        const response = await fetch('/api/get-api-key');
        if (response.ok) {
          const data = await response.json();
          if (data.apiKey) {
            vercelApiKey = data.apiKey;
            debugLog('‚úì API key loaded from Vercel environment variable', 'success');
          }
        }
      } catch (e) {
        debugLog('Vercel env var endpoint not available (expected for static site)', 'info');
      }
      
      // Check config.js
      debugLog('Checking for config.js...', 'info');
      if (window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey) {
        debugLog('‚úì config.js found with API key', 'success');
      } else {
        debugLog('‚úó config.js not found or no API key', 'warn');
      }
      
      // Check localStorage
      debugLog('Checking localStorage...', 'info');
      const configApiKey = window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey;
      const apiKey = vercelApiKey || configApiKey || localStorage.getItem('gsc_api_key');
      const propertyUrl = localStorage.getItem('gsc_property_url');
      const dateRange = localStorage.getItem('gsc_date_range');
      
      const apiKeySource = vercelApiKey ? 'Vercel env var' : configApiKey ? 'config.js' : localStorage.getItem('gsc_api_key') ? 'localStorage' : 'none';
      debugLog(`API Key source: ${apiKeySource}`, 'info');
      debugLog(`Property URL: ${propertyUrl || 'not set'}`, 'info');
      debugLog(`Date Range: ${dateRange || 'not set'}`, 'info');
      
      if (apiKey) {
        debugLog('‚úì API key loaded from environment', 'success');
        // Store in a hidden variable for use in runAudit
        window._loadedApiKey = apiKey;
      } else {
        debugLog('‚úó No API key found', 'warn');
      }
      
      if (propertyUrl) {
        document.getElementById('propertyUrl').value = propertyUrl;
        debugLog('‚úì Property URL loaded', 'success');
      }
      if (dateRange) {
        document.getElementById('dateRange').value = dateRange;
        // Set active button based on saved date range
        const savedDays = parseInt(dateRange);
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          btn.classList.remove('active');
          const btnDays = parseInt(btn.getAttribute('data-days'));
          if (btnDays === savedDays) {
            btn.classList.add('active');
          }
        });
        // If no preset matches, show custom
        const presetDays = [7, 30, 90, 180, 365];
        if (!presetDays.includes(savedDays)) {
          document.getElementById('customDateBtn').classList.add('active');
          document.getElementById('customDays').value = savedDays;
          document.getElementById('customDateRange').style.display = 'block';
        }
        debugLog('‚úì Date range loaded', 'success');
      }
      
      // Load manual URL list if saved
      const savedUrlList = localStorage.getItem('manual_url_list');
      if (savedUrlList) {
        try {
          const urls = JSON.parse(savedUrlList);
          const statusDiv = document.getElementById('urlListStatus');
          if (statusDiv) {
            statusDiv.innerHTML = `<span style="color: #10b981;">‚úì ${urls.length} URLs loaded from saved list</span>`;
          }
          debugLog(`‚úì Manual URL list loaded: ${urls.length} URLs`, 'success');
        } catch (e) {
          debugLog('‚ö† Failed to load saved URL list', 'warn');
        }
      }
      
      // Load backlink CSV content if saved
      const savedBacklinkCsv = localStorage.getItem('backlink_csv_content');
      if (savedBacklinkCsv) {
        const textarea = document.getElementById('backlinkCsvContent');
        if (textarea) {
          textarea.value = savedBacklinkCsv;
        }
        // Check if backlink metrics are already uploaded
        try {
          const backlinkResponse = await fetch('/api/aigeo/backlink-metrics');
          if (backlinkResponse.ok) {
            const backlinkData = await backlinkResponse.json();
            if (backlinkData.status === 'ok' && backlinkData.data && backlinkData.data.totalBacklinks > 0) {
              const metrics = backlinkData.data;
              const statusDiv = document.getElementById('backlinkCsvStatus');
              if (statusDiv) {
                statusDiv.innerHTML = `<span style="color: #10b981;">‚úì Backlink CSV loaded: ${metrics.referringDomains} domains, ${metrics.totalBacklinks} links</span>`;
              }
              debugLog(`‚úì Backlink CSV already uploaded: ${metrics.referringDomains} domains`, 'success');
            }
          }
        } catch (e) {
          // Ignore errors - backlink metrics may not be uploaded yet
        }
      }
      
      debugLog('=== Configuration load complete ===', 'info');
    }

    // Save configuration
    // Date range selector functions
    function setDateRange(days) {
      const oldDateRange = parseInt(document.getElementById('dateRange').value) || 30;
      document.getElementById('dateRange').value = days;
      localStorage.setItem('gsc_date_range', days);
      
      // Update active button
      document.querySelectorAll('.date-range-btn').forEach(btn => {
        btn.classList.remove('active');
        const btnDays = parseInt(btn.getAttribute('data-days'));
        if (btnDays === days) {
          btn.classList.add('active');
        }
      });
      
      // Hide custom input if showing
      document.getElementById('customDateRange').style.display = 'none';
      document.getElementById('customDateBtn').classList.remove('active');
      
      debugLog(`Date range set to ${days} days`, 'info');
      
      // Check if saved audit exists and if its date range matches
      const savedAudit = loadAuditResults();
      if (savedAudit && savedAudit.scores) {
        const savedDateRange = savedAudit.dateRange || oldDateRange;
        if (savedDateRange !== days) {
          // Date range changed - update GSC data and recalculate scores
          debugLog(`Date range changed from ${savedDateRange} to ${days} days. Updating metrics...`, 'info');
          updateAuditForNewDateRange(days, savedAudit);
        }
      }
    }

    function showCustomDateRange() {
      const customDiv = document.getElementById('customDateRange');
      const customBtn = document.getElementById('customDateBtn');
      
      if (customDiv.style.display === 'none') {
        customDiv.style.display = 'block';
        customBtn.classList.add('active');
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          if (btn !== customBtn) btn.classList.remove('active');
        });
      } else {
        customDiv.style.display = 'none';
        customBtn.classList.remove('active');
      }
    }

    function applyCustomDateRange() {
      const customDays = parseInt(document.getElementById('customDays').value);
      if (customDays && customDays > 0) {
        const oldDateRange = parseInt(document.getElementById('dateRange').value) || 30;
        document.getElementById('dateRange').value = customDays;
        localStorage.setItem('gsc_date_range', customDays);
        document.getElementById('customDateRange').style.display = 'none';
        document.getElementById('customDateBtn').classList.remove('active');
        debugLog(`Custom date range set to ${customDays} days`, 'info');
        
        // Check if saved audit exists and if its date range matches
        const savedAudit = loadAuditResults();
        if (savedAudit && savedAudit.scores) {
          const savedDateRange = savedAudit.dateRange || oldDateRange;
          if (savedDateRange !== customDays) {
            // Date range changed - update GSC data and recalculate scores
            debugLog(`Date range changed from ${savedDateRange} to ${customDays} days. Updating metrics...`, 'info');
            updateAuditForNewDateRange(customDays, savedAudit);
          }
        }
      } else {
        showStatus('Please enter a valid number of days', 'error');
      }
    }

    function saveConfig() {
      localStorage.setItem('gsc_api_key', document.getElementById('apiKey').value);
      localStorage.setItem('gsc_property_url', document.getElementById('propertyUrl').value);
      localStorage.setItem('gsc_date_range', document.getElementById('dateRange').value);
      showStatus('Configuration saved!', 'success');
    }

    // Parse CSV and validate column names
    function parseUrlListCsv(csvText) {
      const lines = csvText.split('\n').filter(line => line.trim());
      if (lines.length === 0) {
        throw new Error('CSV is empty');
      }
      
      // Parse header row
      const headerLine = lines[0].trim();
      const headers = headerLine.split(',').map(h => h.trim().replace(/^"|"$/g, '').toLowerCase());
      
      // Check for required 'url' column
      const urlColumnIndex = headers.findIndex(h => h === 'url');
      if (urlColumnIndex === -1) {
        throw new Error(`Required column 'url' not found. Found columns: ${headers.join(', ')}`);
      }
      
      // Extract URLs from the 'url' column
      const urls = [];
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        // Parse CSV line (handle quoted values)
        const columns = [];
        let current = '';
        let inQuotes = false;
        
        for (let j = 0; j < line.length; j++) {
          const char = line[j];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            columns.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        columns.push(current.trim()); // Add last column
        
        // Extract URL from the url column
        if (columns[urlColumnIndex]) {
          const url = columns[urlColumnIndex].replace(/^"|"$/g, '').trim();
          if (url && url.startsWith('http')) {
            urls.push(url);
          }
        }
      }
      
      return {
        headers,
        urls,
        totalRows: lines.length - 1,
        validUrls: urls.length
      };
    }

    // Load URL list from file input
    async function loadUrlListFromFile() {
      const fileInput = document.getElementById('urlListFile');
      const statusDiv = document.getElementById('urlListStatus');
      const textarea = document.getElementById('manualUrlList');
      
      if (!fileInput.files || fileInput.files.length === 0) {
        // If no file, try to parse from textarea
        const csvText = textarea.value.trim();
        if (!csvText) {
          statusDiv.innerHTML = '<span style="color: #ef4444;">‚ö† Please select a CSV file or paste CSV content</span>';
          return;
        }
        
        try {
          const result = parseUrlListCsv(csvText);
          localStorage.setItem('manual_url_list', JSON.stringify(result.urls));
          statusDiv.innerHTML = `<span style="color: #10b981;">‚úì Loaded ${result.validUrls} URLs from ${result.totalRows} rows</span>`;
          debugLog(`‚úì Manual URL list loaded: ${result.validUrls} URLs from CSV`, 'success');
          showStatus(`URL list loaded! Found ${result.validUrls} URLs.`, 'success');
        } catch (error) {
          statusDiv.innerHTML = `<span style="color: #ef4444;">‚úó ${error.message}</span>`;
          debugLog(`‚úó URL list parse error: ${error.message}`, 'error');
          showStatus(`URL list error: ${error.message}`, 'error');
        }
        return;
      }
      
      const file = fileInput.files[0];
      debugLog(`Loading URL list from file: ${file.name} (${file.size} bytes)`, 'info');
      
      try {
        const fileText = await file.text();
        const result = parseUrlListCsv(fileText);
        
        // Store URLs in localStorage
        localStorage.setItem('manual_url_list', JSON.stringify(result.urls));
        
        // Also populate textarea with the CSV content
        textarea.value = fileText;
        
        statusDiv.innerHTML = `<span style="color: #10b981;">‚úì Loaded ${result.validUrls} URLs from ${result.totalRows} rows. Columns: ${result.headers.join(', ')}</span>`;
        debugLog(`‚úì URL list loaded from file: ${result.validUrls} URLs`, 'success');
        debugLog(`  File: ${file.name}, Columns: ${result.headers.join(', ')}`, 'info');
        showStatus(`URL list loaded! Found ${result.validUrls} URLs from ${file.name}.`, 'success');
        
        // Clear file input
        fileInput.value = '';
      } catch (error) {
        statusDiv.innerHTML = `<span style="color: #ef4444;">‚úó ${error.message}</span>`;
        debugLog(`‚úó URL list file error: ${error.message}`, 'error');
        showStatus(`URL list error: ${error.message}`, 'error');
      }
    }

    // Clear manual URL list
    function clearManualUrlList() {
      const textarea = document.getElementById('manualUrlList');
      const fileInput = document.getElementById('urlListFile');
      const statusDiv = document.getElementById('urlListStatus');
      
      textarea.value = '';
      fileInput.value = '';
      localStorage.removeItem('manual_url_list');
      statusDiv.innerHTML = '<span style="color: #666;">Manual URL list cleared</span>';
      debugLog('Manual URL list cleared', 'info');
      showStatus('Manual URL list cleared', 'success');
    }

    // Upload backlink CSV file
    async function uploadBacklinkCsv() {
      const fileInput = document.getElementById('backlinkCsvFile');
      const statusDiv = document.getElementById('backlinkCsvStatus');
      const textarea = document.getElementById('backlinkCsvContent');
      
      let csvContent = '';
      
      if (fileInput.files && fileInput.files.length > 0) {
        const file = fileInput.files[0];
        debugLog(`Uploading backlink CSV from file: ${file.name} (${file.size} bytes)`, 'info');
        
        try {
          csvContent = await file.text();
          // Also populate textarea with the CSV content
          textarea.value = csvContent;
        } catch (error) {
          statusDiv.innerHTML = `<span style="color: #ef4444;">‚úó Error reading file: ${error.message}</span>`;
          debugLog(`‚úó Backlink CSV file read error: ${error.message}`, 'error');
          showStatus(`Backlink CSV error: ${error.message}`, 'error');
          return;
        }
      } else {
        // If no file, try to get from textarea
        csvContent = textarea.value.trim();
        if (!csvContent) {
          statusDiv.innerHTML = '<span style="color: #ef4444;">‚ö† Please select a CSV file or paste CSV content</span>';
          return;
        }
      }

      if (!csvContent) {
        statusDiv.innerHTML = '<span style="color: #ef4444;">‚ö† No CSV content to upload</span>';
        return;
      }

      // Validate CSV has required columns
      const lines = csvContent.split('\n').filter(line => line.trim());
      if (lines.length === 0) {
        statusDiv.innerHTML = '<span style="color: #ef4444;">‚úó CSV is empty</span>';
        return;
      }

      const headerLine = lines[0].trim();
      const headers = headerLine.split(',').map(h => h.trim().replace(/^"|"$/g, ''));
      
      // More flexible column matching - check for URL column (required) and Link Type (optional)
      const hasUrlColumn = headers.some(h => {
        const lower = h.toLowerCase();
        return (lower.includes('linking') && lower.includes('url')) ||
               lower.includes('url') ||
               lower.includes('source url') ||
               lower.includes('page url');
      });
      
      const hasLinkType = headers.some(h => {
        const lower = h.toLowerCase();
        return lower.includes('link type') ||
               lower.includes('type') ||
               lower.includes('follow');
      });
      
      if (!hasUrlColumn) {
        statusDiv.innerHTML = `<span style="color: #ef4444;">‚úó Missing URL column. Found columns: ${headers.join(', ')}. Need a column containing 'URL' or 'Linking Page + URL'</span>`;
        debugLog(`‚úó Backlink CSV missing URL column. Found: ${headers.join(', ')}`, 'error');
        return;
      }
      
      if (!hasLinkType) {
        statusDiv.innerHTML = `<span style="color: #ef4444;">‚úó Missing Link Type column. Found columns: ${headers.join(', ')}. The Link Type column is required to calculate the follow ratio for the Authority score.</span>`;
        debugLog(`‚úó Backlink CSV missing Link Type column. Found: ${headers.join(', ')}`, 'error');
        return;
      }

      // Upload to API
      try {
        statusDiv.innerHTML = '<span style="color: #666;">‚è≥ Uploading and processing backlink CSV...</span>';
        debugLog('Uploading backlink CSV to API...', 'info');
        
        // Send CSV as JSON since Vercel doesn't parse text/csv automatically
        const response = await fetch('/api/aigeo/backlink-metrics', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ csv: csvContent })
        });

        if (!response.ok) {
          let errorMessage = `HTTP ${response.status}`;
          try {
            const errorData = await response.json();
            errorMessage = errorData.message || errorData.error || errorMessage;
            debugLog(`API error response: ${JSON.stringify(errorData)}`, 'error');
          } catch (e) {
            // If response is not JSON, try to get text
            try {
              const errorText = await response.text();
              if (errorText) {
                errorMessage = errorText.substring(0, 200);
              }
            } catch (e2) {
              // Ignore
            }
          }
          throw new Error(errorMessage);
        }

        const result = await response.json();
        debugLog(`API response: ${JSON.stringify(result).substring(0, 200)}...`, 'info');
        
        if (result.status === 'ok' && result.data) {
          const metrics = result.data;
          statusDiv.innerHTML = `<span style="color: #10b981;">‚úì Backlink CSV uploaded successfully! Found ${metrics.referringDomains} referring domains, ${metrics.totalBacklinks} backlinks, ${Math.round(metrics.followRatio * 100)}% follow ratio</span>`;
          debugLog(`‚úì Backlink CSV uploaded: ${metrics.referringDomains} domains, ${metrics.totalBacklinks} links, ${(metrics.followRatio * 100).toFixed(1)}% follow`, 'success');
          showStatus(`Backlink CSV uploaded! ${metrics.referringDomains} referring domains found.`, 'success');
          
          // Store in localStorage for persistence
          localStorage.setItem('backlink_csv_content', csvContent);
          localStorage.setItem('backlink_metrics', JSON.stringify(metrics));
          debugLog(`‚úì Backlink metrics stored in localStorage`, 'success');
        } else {
          // Error response - log debug info to UI
          const errorMsg = result.message || result.error || 'Upload failed - invalid response format';
          statusDiv.innerHTML = `<span style="color: #ef4444;">‚úó ${errorMsg}</span>`;
          debugLog(`‚úó Backlink CSV upload error: ${errorMsg}`, 'error');
          
          // Log debug info if available
          if (result.debug) {
            debugLog(`[DEBUG] CSV Length: ${result.debug.csvLength || 'N/A'}`, 'info');
            debugLog(`[DEBUG] Logical Lines: ${result.debug.logicalLines || 'N/A'}`, 'info');
            debugLog(`[DEBUG] Headers Found: ${result.debug.headers ? result.debug.headers.join(', ') : 'N/A'}`, 'info');
            if (result.debug.firstChars) {
              debugLog(`[DEBUG] First 500 chars: ${result.debug.firstChars}`, 'info');
            }
            if (result.debug.rowCount !== undefined) {
              debugLog(`[DEBUG] Rows parsed: ${result.debug.rowCount}`, 'info');
            }
            if (result.debug.firstRowKeys) {
              debugLog(`[DEBUG] First row keys: ${result.debug.firstRowKeys.join(', ')}`, 'info');
            }
            if (result.debug.error) {
              debugLog(`[DEBUG] Error details: ${result.debug.error}`, 'error');
            }
          }
          
          // Also log full error response for debugging
          debugLog(`[DEBUG] Full error response: ${JSON.stringify(result, null, 2)}`, 'error');
          showStatus(`Backlink CSV error: ${errorMsg}`, 'error');
        }
      } catch (error) {
        const errorMsg = error.message || error.toString() || 'Unknown error';
        statusDiv.innerHTML = `<span style="color: #ef4444;">‚úó ${errorMsg}</span>`;
        debugLog(`‚úó Backlink CSV upload error: ${errorMsg}`, 'error');
        debugLog(`Error stack: ${error.stack || 'No stack trace'}`, 'error');
        showStatus(`Backlink CSV error: ${errorMsg}`, 'error');
      }
    }

    // Clear backlink CSV
    function clearBacklinkCsv() {
      const textarea = document.getElementById('backlinkCsvContent');
      const fileInput = document.getElementById('backlinkCsvFile');
      const statusDiv = document.getElementById('backlinkCsvStatus');
      
      textarea.value = '';
      fileInput.value = '';
      localStorage.removeItem('backlink_csv_content');
      statusDiv.innerHTML = '<span style="color: #666;">Backlink CSV cleared</span>';
      debugLog('Backlink CSV cleared', 'info');
      showStatus('Backlink CSV cleared', 'success');
    }

    // Sync CSV from alan-shared-resources
    async function syncCSV() {
      const btn = document.getElementById('syncCsvBtn');
      const btnText = document.getElementById('syncCsvBtnText');
      const originalText = btnText.textContent;
      
      debugLog('=== CSV SYNC: Starting CSV sync verification ===', 'info');
      debugLog('Button clicked - initiating CSV sync check...', 'info');
      
      // Disable button and show loading state
      btn.disabled = true;
      btnText.textContent = '‚è≥ Syncing...';
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      debugLog('Button state: disabled, showing loading indicator', 'info');
      
      try {
        debugLog('Fetching /api/sync-csv endpoint...', 'info');
        const response = await fetch('/api/sync-csv', {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
        });
        
        debugLog(`API response status: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
        
        const data = await response.json();
        debugLog(`API response data: ${JSON.stringify(data).substring(0, 200)}...`, 'info');
        
        if (response.ok && data.status === 'ok') {
          const urlCount = data.data.totalUrls || 0;
          const source = data.source || 'unknown';
          
          debugLog(`‚úì CSV fetched successfully from ${source}`, 'success');
          debugLog(`  CSV URL: ${data.csvUrl || 'not provided'}`, 'info');
          debugLog(`  Total URLs fetched: ${urlCount}`, 'success');
          debugLog(`  CSV size: ${data.data.csvSize} bytes`, 'info');
          debugLog(`  Lines processed: ${data.data.linesProcessed || 'N/A'}`, 'info');
          debugLog(`  Fetched at: ${data.data.fetchedAt}`, 'info');
          
          // Show toast with URL count
          showStatus(`‚úÖ CSV synced from ${source}! Fetched ${urlCount} URLs.`, 'success');
          btnText.textContent = `‚úÖ ${urlCount} URLs`;
          
          // Reset button after 3 seconds
          setTimeout(() => {
            btnText.textContent = originalText;
            btn.style.opacity = '1';
            debugLog('Button reset to original state', 'info');
          }, 3000);
        } else {
          debugLog(`‚úó CSV sync failed`, 'error');
          debugLog(`  Error message: ${data.message || 'Unknown error'}`, 'error');
          debugLog(`  CSV URL attempted: ${data.csvUrl || 'not provided'}`, 'error');
          if (data.suggestion) {
            debugLog(`  Suggestion: ${data.suggestion}`, 'warn');
          }
          showStatus(`CSV sync failed: ${data.message}. ${data.suggestion || ''}`, 'error');
          btnText.textContent = '‚ùå Sync Failed';
          
          // Reset button after 5 seconds
          setTimeout(() => {
            btnText.textContent = originalText;
            btn.style.opacity = '1';
            debugLog('Button reset to original state after error', 'info');
          }, 5000);
        }
      } catch (error) {
        debugLog(`‚úó CSV sync error occurred`, 'error');
        debugLog(`  Error type: ${error.name || 'Unknown'}`, 'error');
        debugLog(`  Error message: ${error.message}`, 'error');
        if (error.stack) {
          debugLog(`  Stack trace: ${error.stack.substring(0, 300)}...`, 'error');
        }
        showStatus(`CSV sync error: ${error.message}. Please run "npm run sync:csv" locally.`, 'error');
        btnText.textContent = '‚ùå Error';
        
        // Reset button after 5 seconds
        setTimeout(() => {
          btnText.textContent = originalText;
          btn.style.opacity = '1';
          debugLog('Button reset to original state after exception', 'info');
        }, 5000);
      } finally {
        btn.disabled = false;
        btn.style.cursor = 'pointer';
        debugLog('=== CSV SYNC: Complete ===', 'info');
      }
    }

    // Update progress bar
    function updateProgress(percent, statusText) {
      const progressBar = document.getElementById('progressBar');
      const progressStatus = document.getElementById('progressStatus');
      if (progressBar) {
        progressBar.style.width = Math.min(100, Math.max(0, percent)) + '%';
        progressBar.textContent = Math.round(percent) + '%';
      }
      if (progressStatus) {
        progressStatus.textContent = statusText || 'Processing...';
      }
    }

    // Show status message
    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = `status ${type} show`;
      setTimeout(() => {
        status.classList.remove('show');
      }, 5000);
    }

    // Show completion summary modal
    function showCompletionModal(schemaAudit) {
      debugLog('showCompletionModal called', 'info');
      const modal = document.getElementById('completionModal');
      const content = document.getElementById('completionSummaryContent');
      
      debugLog(`Modal element found: ${modal ? 'yes' : 'no'}`, 'info');
      debugLog(`Content element found: ${content ? 'yes' : 'no'}`, 'info');
      
      if (!modal || !content) {
        debugLog('‚ö† Modal or content element not found, cannot show modal', 'error');
        return;
      }
      
      let html = '';
      
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data && schemaAudit.meta) {
        const data = schemaAudit.data;
        const meta = schemaAudit.meta;
        const diag = meta.diagnostic || {};
        
        const totalPages = data.totalPages || diag.totalPages || 0;
        const successfulPages = diag.successfulPages || totalPages;
        const failedPages = diag.failedPages || data.missingSchemaCount || 0;
        const isComplete = failedPages === 0;
        
        html += `<div style="margin-bottom: 1.5rem;">`;
        html += `<div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">`;
        html += `<span style="font-size: 2rem;">${isComplete ? '‚úÖ' : '‚ö†Ô∏è'}</span>`;
        html += `<h3 style="margin: 0; color: ${isComplete ? '#10b981' : '#f59e0b'};">
          ${isComplete ? 'Complete' : 'Incomplete'} Data
        </h3>`;
        html += `</div>`;
        
        html += `<div style="background: ${isComplete ? '#f0fdf4' : '#fffbeb'}; border-left: 4px solid ${isComplete ? '#10b981' : '#f59e0b'}; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">`;
        html += `<p style="margin: 0; color: #555; line-height: 1.6;">`;
        if (isComplete) {
          html += `All pages were successfully crawled. Dashboard data is complete and accurate.`;
        } else {
          html += `<strong>Warning:</strong> ${failedPages} page${failedPages !== 1 ? 's' : ''} failed to crawl. Dashboard data may be incomplete. Failed pages are counted as missing schema.`;
        }
        html += `</p>`;
        html += `</div>`;
        
        html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">`;
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Total URLs Scanned</div>`;
        html += `<div style="font-size: 1.5rem; font-weight: 600; color: #333;">${totalPages}</div>`;
        html += `</div>`;
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Successful Crawls</div>`;
        html += `<div style="font-size: 1.5rem; font-weight: 600; color: #10b981;">${successfulPages}</div>`;
        html += `</div>`;
        html += `</div>`;
        
        if (failedPages > 0) {
          // Get failed URLs from missingSchemaPages that have errors
          const failedUrls = (data.missingSchemaPages || []).filter(p => p.error).map(p => p.url);
          
          html += `<div style="background: #fef2f2; border-left: 4px solid #ef4444; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">`;
          html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Failed Crawls</div>`;
          html += `<div style="font-size: 1.5rem; font-weight: 600; color: #ef4444;">${failedPages}</div>`;
          
          if (diag.errorTypes && Object.keys(diag.errorTypes).length > 0) {
            html += `<div style="margin-top: 0.75rem; font-size: 0.85rem; color: #666;">`;
            html += `<strong>Error Breakdown:</strong><br>`;
            Object.entries(diag.errorTypes).forEach(([type, count]) => {
              html += `${type}: ${count}<br>`;
            });
            html += `</div>`;
          }
          
          // Add retry button if there are failed URLs
          if (failedUrls.length > 0) {
            html += `<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #fee2e2;">`;
            html += `<button id="retryFailedUrls" class="btn" style="background: #10b981; color: white; border-color: #10b981; width: 100%;" title="Retry crawling the ${failedUrls.length} failed URLs. This will rescan only the URLs that failed during the initial audit.">`;
            html += `üîÑ Retry Failed URLs (${failedUrls.length})`;
            html += `</button>`;
            html += `<div style="font-size: 0.8rem; color: #666; margin-top: 0.5rem; text-align: center;">Click to rescan only the failed URLs</div>`;
            html += `</div>`;
          }
          
          html += `</div>`;
        }
        
        html += `<div style="background: #f8f9fa; padding: 1rem; border-radius: 6px; margin-top: 1rem;">`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;"><strong>Schema Coverage</strong></div>`;
        html += `<div style="font-size: 1.25rem; font-weight: 600; color: #333;">${data.coverage || 0}%</div>`;
        html += `<div style="font-size: 0.85rem; color: #666; margin-top: 0.25rem;">${data.pagesWithSchema || 0} pages with inline schema</div>`;
        html += `</div>`;
        
        html += `</div>`;
      } else {
        html += `<p>Unable to load audit summary data.</p>`;
      }
      
      content.innerHTML = html;
      modal.style.display = 'block';
      debugLog('Modal display set to block', 'info');
      debugLog(`Modal is now visible: ${modal.style.display}`, 'info');
      
      // Attach retry button handler if it exists
      const retryButton = document.getElementById('retryFailedUrls');
      if (retryButton) {
        retryButton.onclick = function() {
          retryFailedUrls(schemaAudit);
        };
      }
    }
    
    // Retry failed URLs from schema audit
    async function retryFailedUrls(schemaAudit) {
      if (!schemaAudit || !schemaAudit.data || !schemaAudit.data.missingSchemaPages) {
        debugLog('‚úó No failed URLs to retry', 'error');
        showStatus('No failed URLs found to retry', 'error');
        return;
      }
      
      // Extract failed URLs (those with errors)
      const failedUrls = schemaAudit.data.missingSchemaPages
        .filter(p => p.error)
        .map(p => p.url);
      
      if (failedUrls.length === 0) {
        debugLog('‚úó No failed URLs to retry', 'error');
        showStatus('No failed URLs found to retry', 'error');
        return;
      }
      
      debugLog(`üîÑ Retrying ${failedUrls.length} failed URLs...`, 'info');
      showStatus(`Retrying ${failedUrls.length} failed URLs...`, 'info');
      
      // Close the modal
      closeCompletionModal();
      
      // Show loading indicator
      document.getElementById('loading').classList.add('show');
      document.getElementById('dashboard').style.display = 'none';
      updateProgress(0, `Retrying ${failedUrls.length} failed URLs...`);
      
      try {
        updateProgress(20, 'Scanning failed URLs for schema markup...');
        debugLog(`Sending retry request for ${failedUrls.length} URLs`, 'info');
        
        // Call schema-audit API with only the failed URLs
        const schemaResponse = await fetch('/api/schema-audit', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ urls: failedUrls })
        });
        
        if (!schemaResponse.ok) {
          throw new Error(`Schema audit API returned error: ${schemaResponse.status}`);
        }
        
        const retrySchemaAudit = await schemaResponse.json();
        
        if (retrySchemaAudit.status !== 'ok') {
          throw new Error(retrySchemaAudit.message || 'Schema audit failed');
        }
        
        const retryData = retrySchemaAudit.data;
        const retrySuccessful = retryData.pagesWithSchema || 0;
        const retryStillFailed = (retryData.missingSchemaCount || 0);
        
        debugLog(`‚úì Retry completed: ${retrySuccessful} pages now have schema, ${retryStillFailed} still failed`, 'success');
        updateProgress(60, 'Merging retry results with original audit...');
        
        // Load original audit results from localStorage
        const savedAudit = loadAuditResults();
        if (savedAudit && savedAudit.schemaAudit && savedAudit.schemaAudit.data) {
          // Merge retry results with original schema audit
          const originalData = savedAudit.schemaAudit.data;
          const originalPages = originalData.pagesWithSchema || 0;
          const originalFailed = originalData.missingSchemaCount || 0;
          
          // Create merged schema audit data
          const mergedSchemaAudit = {
            ...savedAudit.schemaAudit,
            data: {
              ...originalData,
              // Update counts: add retry successful pages, remove retry successful from failed
              pagesWithSchema: originalPages + retrySuccessful,
              missingSchemaCount: Math.max(0, originalFailed - retrySuccessful),
              // Update missingSchemaPages: remove successfully retried URLs
              missingSchemaPages: (originalData.missingSchemaPages || []).filter(p => {
                // Keep only pages that weren't in the retry list or still failed
                return !failedUrls.includes(p.url) || (retryData.missingSchemaPages || []).some(rp => rp.url === p.url);
              }),
              // Update coverage
              coverage: ((originalPages + retrySuccessful) / originalData.totalPages) * 100
            }
          };
          
          // Update saved audit with merged results
          const mergedAudit = {
            ...savedAudit,
            schemaAudit: mergedSchemaAudit
          };
          
          // Recalculate scores with merged data (use saved localSignals if available)
          // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
          const normalizedSiteReviews = getTrustpilotSnapshot(savedAudit.siteReviews || null);
          const mergedScores = calculatePillarScores(savedAudit.searchData, mergedSchemaAudit, savedAudit.localSignals || null, normalizedSiteReviews, savedAudit.backlinkMetrics || null);
          const mergedSnippetReadiness = calculateSnippetReadiness(mergedScores, savedAudit.searchData);
          
          // Save merged results (preserve localSignals, siteReviews, and backlinkMetrics)
          saveAuditResults(mergedScores, savedAudit.searchData, mergedSnippetReadiness, mergedSchemaAudit, savedAudit.localSignals || null, normalizedSiteReviews, savedAudit.backlinkMetrics || null);
          
          // Update retry button visibility
          updateRetryButtonVisibility(mergedSchemaAudit);
          
          // Refresh dashboard with merged results
          updateProgress(80, 'Refreshing dashboard with merged results...');
          displayDashboard(mergedScores, savedAudit.searchData, mergedSnippetReadiness, mergedSchemaAudit, savedAudit.localSignals || null);
          
          updateProgress(100, 'Retry completed and dashboard updated!');
          showStatus(`Retry completed: ${retrySuccessful} URLs now have schema. Dashboard updated with merged results.`, 'success');
          
          // Show completion modal with merged results
          showCompletionModal(mergedSchemaAudit);
        } else {
          // No saved audit found, just show retry results
          updateProgress(80, 'Retry completed!');
          showCompletionModal(retrySchemaAudit);
          updateProgress(100, 'Retry completed!');
          showStatus(`Retry completed: ${retrySuccessful} URLs now have schema, ${retryStillFailed} still failed`, 'success');
          debugLog('‚ö† No saved audit found to merge with. Run full audit to see complete results.', 'warn');
        }
        
      } catch (error) {
        debugLog(`‚úó Retry error: ${error.message}`, 'error');
        showStatus(`Error retrying failed URLs: ${error.message}`, 'error');
      } finally {
        document.getElementById('loading').classList.remove('show');
        setTimeout(() => {
          updateProgress(0, 'Initializing audit scan...');
        }, 500);
      }
    }

    // Save audit results to localStorage
    function saveAuditResults(scores, searchData, snippetReadiness, schemaAudit, localSignals = null, siteReviews = null, backlinkMetrics = null) {
      try {
        const dateRange = parseInt(document.getElementById('dateRange')?.value) || 30;
        const auditData = {
          scores,
          searchData,
          snippetReadiness,
          schemaAudit,
          localSignals, // Store local signals data for future use
          siteReviews, // Store site reviews data for future use (preserve on retry)
          backlinkMetrics, // Store backlink metrics data
          dateRange, // Store the date range used for this audit
          timestamp: new Date().toISOString()
        };
        localStorage.setItem('last_audit_results', JSON.stringify(auditData));
        debugLog('‚úì Audit results saved to localStorage', 'success');
        
        // Update timestamp display
        updateAuditTimestamp(auditData.timestamp);
      } catch (error) {
        debugLog(`‚úó Error saving audit results: ${error.message}`, 'error');
      }
    }
    
    // Update audit results for new date range without full rescan
    async function updateAuditForNewDateRange(newDateRange, savedAudit) {
      try {
        showStatus(`Updating metrics for ${newDateRange} day period...`, 'info');
        
        const propertyUrl = document.getElementById('propertyUrl')?.value || savedAudit.propertyUrl || '';
        if (!propertyUrl) {
          clearDashboard();
          showStatus(`Date range changed to ${newDateRange} days. Please run a new audit to see updated metrics.`, 'info');
          return;
        }
        
        // Get API key (needed for fetchSearchConsoleData signature, but not actually used)
        let apiKey = window._loadedApiKey || '';
        
        // Fetch new GSC data for the new date range (will use Supabase cache)
        debugLog(`Fetching GSC data for ${newDateRange} day period...`, 'info');
        const searchData = await fetchSearchConsoleData(apiKey, propertyUrl, newDateRange);
        
        // Fetch local signals (Business Profile data doesn't change with date range, but fetch to ensure it's fresh)
        let localSignals = savedAudit.localSignals || null;
        try {
          const localSignalsResponse = await fetch(`/api/aigeo/local-signals?property=${encodeURIComponent(propertyUrl)}`);
          if (localSignalsResponse.ok) {
            localSignals = await localSignalsResponse.json();
            if (localSignals.status === 'ok') {
              debugLog('‚úì Local signals data fetched successfully', 'success');
            }
          }
        } catch (localSignalsError) {
          debugLog(`‚ö† Local signals error: ${localSignalsError.message}, using cached data if available`, 'warn');
        }
        
        // Recalculate pillar scores based on new GSC data
        // Keep existing schema audit data (doesn't change with date range)
        // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
        const normalizedSiteReviews = getTrustpilotSnapshot(savedAudit.siteReviews || null);
        const scores = calculatePillarScores(searchData, savedAudit.schemaAudit, localSignals, normalizedSiteReviews, savedAudit.backlinkMetrics || null);
        const snippetReadiness = calculateSnippetReadiness(scores, searchData);
        
        debugLog(`Recalculated scores for ${newDateRange} days: ${JSON.stringify(scores)}`, 'info');
        
        // Update saved audit with new data
        const updatedAudit = {
          ...savedAudit,
          dateRange: newDateRange,
          searchData: searchData,
          scores: scores,
          snippetReadiness: snippetReadiness,
          localSignals: localSignals, // Store local signals for future use
          timestamp: new Date().toISOString()
        };
        
        // Save updated audit
        // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
        const normalizedSiteReviewsForLoad = getTrustpilotSnapshot(savedAudit.siteReviews || null);
        saveAuditResults(scores, searchData, snippetReadiness, savedAudit.schemaAudit, localSignals, normalizedSiteReviewsForLoad, savedAudit.backlinkMetrics || null);
        localStorage.setItem('last_audit_results', JSON.stringify(updatedAudit));
        
        // Also save to Supabase for historical tracking
        if (propertyUrl) {
          saveAuditToSupabase(propertyUrl, scores, searchData, snippetReadiness, savedAudit.schemaAudit, localSignals);
        }
        
        // Update dashboard with new data - ensure scores object has all required properties
        debugLog(`Updating dashboard with scores: ${JSON.stringify(scores)}`, 'info');
        displayDashboard(scores, searchData, snippetReadiness, savedAudit.schemaAudit, localSignals);
        
        showStatus(`Metrics updated for ${newDateRange} day period.`, 'success');
        debugLog(`‚úì Audit updated for ${newDateRange} day period`, 'success');
        
      } catch (error) {
        debugLog(`‚úó Error updating audit for new date range: ${error.message}`, 'error');
        clearDashboard();
        showStatus(`Date range changed to ${newDateRange} days. Please run a new audit to see updated metrics.`, 'info');
      }
    }
    
    // Clear dashboard and show message that new audit is needed
    function clearDashboard() {
      const dashboard = document.getElementById('dashboard');
      if (dashboard) {
        dashboard.style.display = 'none';
      }
      // Clear any charts
      if (window.radarChart) {
        window.radarChart.destroy();
        window.radarChart = null;
      }
      if (window.trendChart) {
        window.trendChart.destroy();
        window.trendChart = null;
      }
      if (window.snippetReadinessChart) {
        window.snippetReadinessChart.destroy();
        window.snippetReadinessChart = null;
      }
    }
    
    // Load audit results from localStorage
    function loadAuditResults() {
      try {
        const saved = localStorage.getItem('last_audit_results');
        if (saved) {
          const auditData = JSON.parse(saved);
          debugLog('‚úì Audit results loaded from localStorage', 'success');
          return auditData;
        }
      } catch (error) {
        debugLog(`‚úó Error loading audit results: ${error.message}`, 'error');
      }
      return null;
    }
    
    // Update audit timestamp display
    function updateAuditTimestamp(timestamp) {
      const timestampElement = document.getElementById('lastAuditTime');
      const snippetTimestampElement = document.getElementById('snippetReadinessAuditTime');
      const snippetTimestampContainer = document.getElementById('snippetReadinessTimestamp');
      const radarTimestampElement = document.getElementById('radarChartAuditTime');
      const radarTimestampContainer = document.getElementById('radarChartTimestamp');
      
      if (timestamp) {
        const date = new Date(timestamp);
        const formatted = date.toLocaleString('en-GB', {
          day: '2-digit',
          month: 'short',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        if (timestampElement) {
          timestampElement.textContent = formatted;
        }
        
        // Update snippet readiness timestamp
        if (snippetTimestampElement) {
          snippetTimestampElement.textContent = formatted;
        }
        if (snippetTimestampContainer) {
          snippetTimestampContainer.style.display = 'block';
        }
        
        // Update radar chart timestamp
        if (radarTimestampElement) {
          radarTimestampElement.textContent = formatted;
        }
        if (radarTimestampContainer) {
          radarTimestampContainer.style.display = 'block';
        }
      } else {
        if (timestampElement) {
          timestampElement.textContent = 'Not yet run';
        }
        if (snippetTimestampContainer) {
          snippetTimestampContainer.style.display = 'none';
        }
        if (radarTimestampContainer) {
          radarTimestampContainer.style.display = 'none';
        }
      }
    }
    
    // Save audit results to Supabase for historical tracking
    async function saveAuditToSupabase(propertyUrl, scores, searchData, snippetReadiness, schemaAudit, localSignals = null) {
      try {
        const auditDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
        
        const response = await fetch('/api/supabase/save-audit', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            propertyUrl,
            auditDate,
            schemaAudit,
            scores,
            searchData,
            snippetReadiness,
            localSignals // Pass Business Profile data for storage
          })
        });
        
        if (response.ok) {
          const result = await response.json();
          debugLog('‚úì Audit results saved to Supabase', 'success');
        } else {
          const error = await response.json();
          // Don't show error to user - Supabase is optional for now
          debugLog(`‚ö† Could not save to Supabase: ${error.message || 'Unknown error'}`, 'warn');
        }
      } catch (error) {
        // Don't show error to user - Supabase is optional for now
        debugLog(`‚ö† Supabase save error: ${error.message}`, 'warn');
      }
    }
    
    // Fetch historical Content/Schema data from Supabase
    async function fetchContentSchemaHistory(propertyUrl, startDate, endDate) {
      try {
        const response = await fetch(`/api/supabase/get-audit-history?propertyUrl=${encodeURIComponent(propertyUrl)}&startDate=${startDate}&endDate=${endDate}`);
        
        if (response.ok) {
          const result = await response.json();
          if (result.status === 'ok' && result.data) {
            debugLog(`‚úì Fetched ${result.count} historical Content/Schema records from Supabase`, 'success');
            return result.data;
          }
        } else {
          const error = await response.json();
          debugLog(`‚ö† Could not fetch from Supabase: ${error.message || 'Unknown error'}`, 'warn');
        }
      } catch (error) {
        debugLog(`‚ö† Supabase fetch error: ${error.message}`, 'warn');
      }
      return [];
    }
    
    // Update retry button visibility based on failed URLs
    function updateRetryButtonVisibility(schemaAudit) {
      const retryBtn = document.getElementById('retryFailedUrlsBtn');
      if (!retryBtn) return;
      
      if (schemaAudit && schemaAudit.data && schemaAudit.data.missingSchemaPages) {
        const failedUrls = schemaAudit.data.missingSchemaPages.filter(p => p.error);
        if (failedUrls.length > 0) {
          retryBtn.style.display = 'inline-block';
          retryBtn.textContent = `üîÑ Retry Failed URLs (${failedUrls.length})`;
        } else {
          retryBtn.style.display = 'none';
        }
      } else {
        retryBtn.style.display = 'none';
      }
    }

    // Close completion modal
    function closeCompletionModal() {
      const modal = document.getElementById('completionModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    // Close modal when clicking outside
    window.onclick = function(event) {
      const modal = document.getElementById('completionModal');
      if (event.target === modal) {
        closeCompletionModal();
      }
    }

    // Calculate RAG status from score
    function getRAGStatus(score) {
      if (score >= 70) return { status: 'green', label: 'Green' };
      if (score >= 40) return { status: 'amber', label: 'Amber' };
      return { status: 'red', label: 'Red' };
    }

    // Helper: clamp score to 0-100 and round
    function clampScore(value) {
      return Math.max(0, Math.min(100, Math.round(value)));
    }

    // Calculate pillar scores (deterministic, based on GSC data and schema audit)
    
    // Page Segment Classifier
    // NOTE: PageSegment classification is derived from the canonical site-urls CSV.
    // GSC page URLs are matched by path against this inventory and then classified by
    // classifyPageSegment(...) to keep behaviour/ranking segments aligned with the UI.
    const PageSegment = {
      EDUCATION: 'education',
      MONEY: 'money',
      SUPPORT: 'support',
      SYSTEM: 'system'
    };
    
    function normalisePath(rawUrlOrPath) {
      try {
        let url;
        if (rawUrlOrPath && rawUrlOrPath.startsWith('http')) {
          url = new URL(rawUrlOrPath);
        } else {
          url = new URL(rawUrlOrPath || '/', 'https://www.alanranger.com');
        }
        let p = url.pathname.toLowerCase();
        if (p.length > 1 && p.endsWith('/')) p = p.slice(0, -1);
        return p;
      } catch {
        return '/';
      }
    }
    
    function isFineArtGalleryPage(path) {
      const p = path.toLowerCase();
      // Explicit known fine-art URLs from 06-site-urls.csv
      if (
        p === '/fine-art-prints' ||
        p === '/photography-services-near-me/fine-art-photography-prints-unframed' ||
        p === '/photography-services-near-me/framed-fine-art-photography-prints' ||
        p === '/photography-services-near-me/fine-art-photography-prints-canvas'
      ) {
        return true;
      }
      // Safety net: treat any future fine-art print variants as gallery/info too
      return (
        p.includes('fine-art-prints') ||
        p.includes('fine-art-photography-prints')
      );
    }
    
    function classifyPageSegment(rawUrlOrPath, title = null, kindOverride = null) {
      const path = normalisePath(rawUrlOrPath);
      
      // Manual overrides via CSV column
      if (kindOverride) {
        const v = kindOverride.toLowerCase().trim();
        if (v === 'education' || v === 'educational') return PageSegment.EDUCATION;
        if (v === 'money' || v === 'commercial') return PageSegment.MONEY;
        if (v === 'support') return PageSegment.SUPPORT;
        if (v === 'system') return PageSegment.SYSTEM;
      }
      
      // Education ‚Äî all blogs + free course + calculator + tips hub
      if (path.startsWith('/blog-on-photography/')) return PageSegment.EDUCATION;
      if (
        path === '/blog-on-photography' ||
        path === '/free-online-photography-course' ||
        path === '/outdoor-photography-exposure-calculator' ||
        path === '/free-photography-tips' ||
        path === '/photography-news-blog'
      ) {
        return PageSegment.EDUCATION;
      }
      
      // Fine-art gallery pages ‚Äî portfolio/informational, NOT money pages
      // These must be checked BEFORE money classification
      if (isFineArtGalleryPage(path)) return PageSegment.SYSTEM;
      
      // Money ‚Äî explicit slugs
      const MONEY_EXACT = new Set([
        '/photography-workshops', '/photography-workshops-near-me', '/photography-workshops-uk',
        '/landscape-photography-workshops', '/outdoor-photography-workshops',
        '/photographic-workshops-near-me', '/photographic-workshops-uk',
        '/photography-courses-coventry', '/course-finder-photography-classes-near-me',
        '/photography-tuition-services', '/photography-services-near-me', '/photography-shop-services',
        '/rps-courses-mentoring-distinctions', '/hire-a-professional-photographer-in-coventry',
        '/professional-commercial-photographer-coventry', '/professional-photographer-near-me',
        '/coventry-photographer', '/photographer-in-coventry', '/photography-mentoring-programme',
        '/photography-academy-membership', '/photography-academy', '/photography-session-vouchers',
        '/photography-gift-vouchers', '/photography-presents-for-photographers',
        // NOTE: '/fine-art-prints' removed from MONEY_EXACT - now handled by isFineArtGalleryPage()
        '/batsford-arboretum-photography', '/bluebell-woods-near-me',
      ]);
      if (MONEY_EXACT.has(path)) return PageSegment.MONEY;
      
      // Money by keyword heuristics (exclude fine-art print pages)
      if (!isFineArtGalleryPage(path)) {
        const MONEY_KEYWORDS = [
          'workshop', 'workshops', 'lesson', 'lessons', 'course', 'courses', 'course-finder',
          'class', 'classes', 'training', 'tuition', 'mentoring', 'academy',
          'gift-voucher', 'gift-vouchers', 'presents-for-photographers', 'session-vouchers',
          'photography-services-near-me', 'photography-services', 'photography-shop',
          '1-2-1', 'hire-a-professional-photographer', 'prints',
          // NOTE: 'fine-art-prints' removed - fine-art pages handled separately above
          'print-preparation-service', 'special-offers',
        ];
        if (MONEY_KEYWORDS.some((k) => path.includes(k))) return PageSegment.MONEY;
      }
      
      // Support
      const SUPPORT_EXACT = new Set([
        '/', '/about-alan-ranger', '/testimonials-customer-reviews', '/awards-and-qualifications',
        '/gallery-image-portfolios', '/help-site-map', '/help-portrait-uk-coventry',
        '/photography-equipment-recommendations', '/newsletter-signup-form',
        '/which-photography-style-is-right-for-you', '/contact-us',
      ]);
      if (SUPPORT_EXACT.has(path)) return PageSegment.SUPPORT;
      
      // Everything else = system
      return PageSegment.SYSTEM;
    }
    
    // Helper functions for Authority score calculation
    function normalisePct(value, max) {
      // value in 0-1 range; scale to 0-100 and cap
      const pct = Math.max(0, Math.min(1, value / max));
      return pct * 100;
    }

    function normalisePosition(pos, minPos, maxPos) {
      // map [minPos..maxPos] -> [100..10], clamp outside range
      const clamped = Math.max(minPos, Math.min(maxPos, pos));
      const t = (clamped - minPos) / (maxPos - minPos); // 0..1
      return 100 - t * 90; // 100 at best, 10 at worst
    }

    // Raw Behaviour score calculation (internal, used by segmented version)
    function computeBehaviourScoreRaw(queries) {
      if (!queries || !Array.isArray(queries) || queries.length === 0) {
        return 50; // neutral fallback
      }

      // Filter to ranking queries (position > 0, <= 20, with impressions)
      const ranking = queries.filter(q => q.position > 0 && q.position <= 20 && q.impressions > 0);

      if (ranking.length === 0) {
        return 50; // neutral fallback
      }

      // Calculate CTR for all ranking queries
      const totalClicks = ranking.reduce((s, q) => s + q.clicks, 0);
      const totalImpr = ranking.reduce((s, q) => s + q.impressions, 0);
      const ctrAll = totalImpr > 0 ? totalClicks / totalImpr : 0; // 0-1

      // Calculate CTR for top-10 queries
      const top10 = ranking.filter(q => q.position <= 10);
      const top10Clicks = top10.reduce((s, q) => s + q.clicks, 0);
      const top10Impr = top10.reduce((s, q) => s + q.impressions, 0);
      const ctrTop10 = top10Impr > 0 ? top10Clicks / top10Impr : ctrAll;

      // Normalize CTR scores: 5% CTR = 100 for all ranking, 10% CTR = 100 for top-10
      // ctrAll 0-5% ‚Üí 0-100 (values >5% capped at 100)
      // ctrTop10 0-10% ‚Üí 0-100 (values >10% capped at 100)
      const ctrScoreAll = normalisePct(ctrAll, 0.05); // 5% overall CTR -> 100
      const ctrScoreTop10 = normalisePct(ctrTop10, 0.10); // 10% top-10 CTR -> 100

      // Combine: 50% ctrAll + 50% ctrTop10
      return 0.5 * ctrScoreAll + 0.5 * ctrScoreTop10; // 0-100
    }
    
    // Public Behaviour score (backward compatible, uses all queries)
    function computeBehaviourScore(queries) {
      return computeBehaviourScoreRaw(queries);
    }
    
    // Segmented Behaviour score calculation
    // queryPages: Array of {query, page, clicks, impressions, ctr, position}
    // Returns: {all, nonBlog, money}
    function computeBehaviourScoreWithSegment(queryPages) {
      if (!queryPages || !Array.isArray(queryPages) || queryPages.length === 0) {
        return { all: 50, nonBlog: 50, money: 50 };
      }
      
      // Classify each query+page row by page segment
      const withSegment = queryPages.map(row => {
        const segment = classifyPageSegment(row.page || row.url || '/');
        return { ...row, __segment: segment };
      });
      
      // Convert to format expected by computeBehaviourScoreRaw
      const toQueryFormat = (rows) => rows.map(r => ({
        clicks: r.clicks || 0,
        impressions: r.impressions || 0,
        ctr: (r.ctr || 0) / 100, // Convert percentage to decimal
        position: r.position || 0
      }));
      
      // All queries
      const all = computeBehaviourScoreRaw(toQueryFormat(withSegment));
      
      // Non-blog (exclude education)
      const nonBlog = computeBehaviourScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment !== PageSegment.EDUCATION))
      );
      
      // Money pages only
      const money = computeBehaviourScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment === PageSegment.MONEY))
      );
      
      return { all, nonBlog, money };
    }

    // Raw Ranking score calculation (internal, used by segmented version)
    function computeRankingScoreRaw(queries) {
      if (!queries || !Array.isArray(queries) || queries.length === 0) {
        return 50; // neutral fallback
      }

      // Filter to ranking queries (position > 0, <= 20, with impressions)
      const ranking = queries.filter(q => q.position > 0 && q.position <= 20 && q.impressions > 0);

      if (ranking.length === 0) {
        return 50; // neutral fallback
      }

      // Calculate impression-weighted average position
      const totalImpr = ranking.reduce((s, q) => s + q.impressions, 0);
      const avgPos = totalImpr > 0
        ? ranking.reduce((s, q) => s + q.position * q.impressions, 0) / totalImpr
        : 0;

      // Map position: 1 ‚Üí 100, 20 ‚Üí 0 (clamped)
      const clampedPos = Math.max(1, Math.min(20, avgPos));
      const posScore = normalisePosition(clampedPos, 1, 20); // 0-100

      // Calculate top-10 impression share (% of impressions where position ‚â§ 10)
      const top10Impr = ranking
        .filter(q => q.position <= 10)
        .reduce((s, q) => s + q.impressions, 0);
      const top10Share = totalImpr > 0 ? top10Impr / totalImpr : 0; // 0-1
      const top10Score = top10Share * 100; // 0-100 (as a percentage)

      // Combine: 50% posScore + 50% top10Score
      return 0.5 * posScore + 0.5 * top10Score; // 0-100
    }
    
    // Public Ranking score (backward compatible, uses all queries)
    function computeRankingScore(queries) {
      return computeRankingScoreRaw(queries);
    }
    
    // Segmented Ranking score calculation
    // queryPages: Array of {query, page, clicks, impressions, ctr, position}
    // Returns: {all, nonBlog, money}
    function computeRankingScoreWithSegment(queryPages) {
      if (!queryPages || !Array.isArray(queryPages) || queryPages.length === 0) {
        return { all: 50, nonBlog: 50, money: 50 };
      }
      
      // Classify each query+page row by page segment
      const withSegment = queryPages.map(row => {
        const segment = classifyPageSegment(row.page || row.url || '/');
        return { ...row, __segment: segment };
      });
      
      // Convert to format expected by computeRankingScoreRaw
      const toQueryFormat = (rows) => rows.map(r => ({
        clicks: r.clicks || 0,
        impressions: r.impressions || 0,
        ctr: (r.ctr || 0) / 100, // Convert percentage to decimal
        position: r.position || 0
      }));
      
      // All queries
      const all = computeRankingScoreRaw(toQueryFormat(withSegment));
      
      // Non-blog (exclude education)
      const nonBlog = computeRankingScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment !== PageSegment.EDUCATION))
      );
      
      // Money pages only
      const money = computeRankingScoreRaw(
        toQueryFormat(withSegment.filter(r => r.__segment === PageSegment.MONEY))
      );
      
      return { all, nonBlog, money };
    }

    function computeReviewScore(opts) {
      const {
        gbpRating = null,
        gbpCount = null,
        siteRating = null,
        siteCount = null
      } = opts || {};

      // Check if sources have valid data (not null, not 0, not undefined)
      const hasGBP = (gbpRating !== null && gbpRating !== undefined && gbpRating > 0) || 
                     (gbpCount !== null && gbpCount !== undefined && gbpCount > 0);
      const hasSite = (siteRating !== null && siteRating !== undefined && siteRating > 0) || 
                      (siteCount !== null && siteCount !== undefined && siteCount > 0);

      // If neither source exists, return neutral default
      if (!hasGBP && !hasSite) {
        debugLog('Review Score: No review data available (GBP or site), using neutral default (50)', 'warn');
        return 50;
      }

      const maxCount = 500; // cap so a few extra reviews don't blow up score

      let reviewScore;

      if (hasGBP && hasSite) {
        // Both sources exist: 60% GBP + 40% site
        const gbpRatingScore = ((gbpRating || 0) / 5) * 100;
        const gbpCountScore = Math.min((gbpCount || 0) / maxCount, 1) * 100;
        const gbpScore = 0.6 * gbpRatingScore + 0.4 * gbpCountScore;

        const siteRatingScore = ((siteRating || 0) / 5) * 100;
        const siteCountScore = Math.min((siteCount || 0) / maxCount, 1) * 100;
        const siteScore = 0.6 * siteRatingScore + 0.4 * siteCountScore;

        reviewScore = 0.6 * gbpScore + 0.4 * siteScore;
      } else if (hasGBP) {
        // Only GBP exists: 100% GBP
        const gbpRatingScore = ((gbpRating || 0) / 5) * 100;
        const gbpCountScore = Math.min((gbpCount || 0) / maxCount, 1) * 100;
        reviewScore = 0.6 * gbpRatingScore + 0.4 * gbpCountScore;
      } else {
        // Only site reviews exist: 100% site
        const siteRatingScore = ((siteRating || 0) / 5) * 100;
        const siteCountScore = Math.min((siteCount || 0) / maxCount, 1) * 100;
        reviewScore = 0.6 * siteRatingScore + 0.4 * siteCountScore;
      }

      return clampScore(reviewScore);
    }

    /**
     * Compute Backlink Score from backlink metrics
     * @param {Object|undefined} m - Backlink metrics object with referringDomains, totalBacklinks, followRatio
     * @returns {number} Score 0-100
     */
    function computeBacklinkScore(m) {
      if (!m) {
        // If metrics not present at all, return 0 (no backlink data)
        return 0;
      }

      const rd = m.referringDomains ?? 0;
      // If followRatio is missing, it means data integrity issue - log warning and use 0
      const fb = m.followRatio ?? (() => {
        debugLog('‚ö† Backlink metrics missing followRatio - data integrity issue', 'warn');
        return 0;
      })();

      // If no backlinks at all, score is 0
      if (rd === 0 && (m.totalBacklinks ?? 0) === 0) {
        return 0;
      }

      // Referring domains score: 100+ domains = max score (100)
      const rdScore = Math.min(rd / 100, 1) * 100;
      
      // Follow ratio score: clamp 0-1 ‚Üí 0-100
      const followScore = Math.max(0, Math.min(fb, 1)) * 100;

      // Combined: 70% referring domains, 30% follow ratio
      const score = 0.7 * rdScore + 0.3 * followScore;
      
      return Math.round(clampScore(score));
    }

    // Helper function to always return correct Trustpilot snapshot values
    // This ensures we never use old cached values (4.80, 127) - always use (4.6, 610)
    function getTrustpilotSnapshot(siteReviews = null) {
      const TRUSTPILOT_SNAPSHOT = {
        siteRating: 4.6,
        siteReviewCount: 610,
        lastUpdated: '2025-12-07',
        notes: 'Fixed Trustpilot snapshot for Authority score calculation. Update manually when Trustpilot metrics change significantly.'
      };
      
      // Always return the correct snapshot, regardless of input
      if (!siteReviews || siteReviews.siteRating !== 4.6 || siteReviews.siteReviewCount !== 610) {
        return TRUSTPILOT_SNAPSHOT;
      }
      return siteReviews;
    }

    // Helper function to get color for score (same thresholds as main pillars)
    function getScoreColor(score) {
      if (score >= 70) return { color: '#10b981', label: 'Green', bg: '#d1fae5' }; // Green
      if (score >= 40) return { color: '#f59e0b', label: 'Amber', bg: '#fef3c7' }; // Amber
      return { color: '#ef4444', label: 'Red', bg: '#fee2e2' }; // Red
    }

    // Helper function to get tooltip text for each component
    function getComponentTooltip(label) {
      const tooltips = {
        // Authority components
        'Behaviour': 'Overall CTR Score (50% weight) + Top-10 Ranked Search Terms CTR Score (50% weight). Measures CTR for all ranking search terms vs. search terms ranking in positions 1-10. Indicates how well your titles/descriptions convert impressions to clicks.',
        'Ranking': 'Average Position Score (50% weight) + Top-10 Impression Share (50% weight). Measures how high you rank on average and what percentage of impressions appear in positions 1-10.',
        'Backlinks': 'Referring Domains Score (70% weight) + Follow Ratio Score (30% weight). Measures domain authority from external links.',
        'Reviews': 'Google Business Profile Reviews (60% weight if both exist) + Trustpilot Reviews (40% weight if both exist). Each source combines rating (60%) and count (40%). Measures trust signals from customer reviews.',
        // Content/Schema components
        'Foundation': 'Foundation Schemas (30% weight): Presence of Organization, Person, WebSite, and BreadcrumbList schemas. These core schemas establish your entity identity and site structure for AI systems.',
        'Rich Results': 'Rich Result Eligibility (35% weight): Count of eligible rich result types (Article, Event, FAQPage, Product, LocalBusiness, Course, Review, HowTo, VideoObject, ImageObject, ItemList). More types = better AI understanding.',
        'Coverage': 'Schema Coverage (20% weight): Percentage of pages with structured data markup. Higher coverage means more pages are machine-readable.',
        'Diversity': 'Type Diversity (15% weight): Number of unique schema types detected across your domain. More diverse types indicate richer structured data.',
        // Visibility components
        'Position': 'Average Position Score: Derived from Google Search Console average position (1-40 scale). Better positions (lower numbers) = higher score. Measures how prominently your content appears in search results.',
        'CTR': 'Click-Through Rate Score: Derived from Google Search Console CTR percentage. Higher CTR indicates better title/description effectiveness and user engagement.',
        // Local Entity components
        'NAP Consistency': 'Name, Address, Phone consistency score (0-100%). Measures how consistently your business information appears across Google Business Profile. Higher consistency improves entity recognition.',
        'Knowledge Panel': 'Knowledge Panel Detection: Whether Google has detected and displays a knowledge panel for your entity. Indicates strong entity recognition by AI systems.',
        'Locations': 'Location Count: Number of physical locations listed in Google Business Profile. Having at least one location improves local entity recognition.',
        // Service Area components
        'Service Areas': 'Service Area Count: Number of service areas defined in Google Business Profile. More service areas (8+) indicate broader geographic coverage and better AI understanding of your operational regions.',
        'NAP Consistency': 'Name, Address, Phone consistency score (0-100%). Measures how consistently your business information appears across Google Business Profile. Higher consistency improves service area recognition.'
      };
      return tooltips[label] || '';
    }

    // Helper function to format component score with color, scale indicator, and tooltip
    function formatComponentScore(label, score) {
      const rounded = Math.round(score);
      const colorInfo = getScoreColor(rounded);
      const tooltip = getComponentTooltip(label);
      return `
        <div style="display: flex; align-items: center; gap: 0.5rem;">
          <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background-color: ${colorInfo.color};"></span>
          <span style="color: #666; position: relative; cursor: help; border-bottom: 1px dotted #999;" title="${tooltip}">${label}:</span>
          <strong style="color: ${colorInfo.color};">${rounded}</strong>
          <span style="color: #999; font-size: 0.75em;">/100</span>
        </div>
      `;
    }

    function calculatePillarScores(data, schemaAudit = null, localSignals = null, siteReviews = null, backlinkMetrics = null) {
      // Use new API response format - get values from GSC overview
      const position = data.averagePosition || 40; // 1 (best) - 100 (worst)
      const ctr = data.ctr || 0; // 0-100 percentage from API (e.g., 10 = 10%)
      const topQueries = data.topQueries || []; // Array of query objects with clicks, impressions, ctr, position
      const queryPages = data.queryPages || []; // Array of query+page objects for segmentation

      // Map average position (1-40) -> 100-10 (better position => higher score)
      const posScore = (() => {
        const clampedPos = Math.max(1, Math.min(40, position));
        const scale = (clampedPos - 1) / 39; // 0 to 1
        return 100 - scale * 90; // 100 to 10
      })();

      // Visibility is primarily driven by position
      const visibility = clampScore(posScore);

      // Authority: New 4-component model with segmentation support
      let behaviourScore, rankingScore;
      let behaviourScoresSegmented = null;
      let rankingScoresSegmented = null;
      
      // If we have queryPages data, use segmented calculation
      if (queryPages && queryPages.length > 0) {
        debugLog(`üìä Segmentation: Received ${queryPages.length} query+page combinations from GSC API`, 'info');
        
        // Classify all pages and show distribution
        const segmentCounts = {};
        queryPages.forEach(row => {
          const segment = classifyPageSegment(row.page || row.url || '/');
          segmentCounts[segment] = (segmentCounts[segment] || 0) + 1;
        });
        
        debugLog(`üìä Segmentation: Page distribution - Education: ${segmentCounts[PageSegment.EDUCATION] || 0}, Money: ${segmentCounts[PageSegment.MONEY] || 0}, Support: ${segmentCounts[PageSegment.SUPPORT] || 0}, System: ${segmentCounts[PageSegment.SYSTEM] || 0}`, 'info');
        
        // Use segmented calculation
        debugLog('üìä Segmentation: Calculating Behaviour scores for all segments...', 'info');
        behaviourScoresSegmented = computeBehaviourScoreWithSegment(queryPages);
        debugLog(`üìä Segmentation: Behaviour scores - All: ${behaviourScoresSegmented.all.toFixed(1)}, Non-blog: ${behaviourScoresSegmented.nonBlog.toFixed(1)}, Money: ${behaviourScoresSegmented.money.toFixed(1)}`, 'success');
        
        debugLog('üìä Segmentation: Calculating Ranking scores for all segments...', 'info');
        rankingScoresSegmented = computeRankingScoreWithSegment(queryPages);
        debugLog(`üìä Segmentation: Ranking scores - All: ${rankingScoresSegmented.all.toFixed(1)}, Non-blog: ${rankingScoresSegmented.nonBlog.toFixed(1)}, Money: ${rankingScoresSegmented.money.toFixed(1)}`, 'success');
        
        // Use 'all' segment for main Authority score (backward compatible)
        behaviourScore = behaviourScoresSegmented.all;
        rankingScore = rankingScoresSegmented.all;
        
        debugLog(`‚úì Using segmented calculation (queryPages available). Main scores use 'all' segment.`, 'success');
      } else {
        // Fallback to non-segmented calculation (backward compatible)
        debugLog('‚ö† Segmentation: queryPages not available, using non-segmented calculation (backward compatible)', 'warn');
        const queriesForCalculation = topQueries.map(q => ({
          clicks: q.clicks || 0,
          impressions: q.impressions || 0,
          ctr: (q.ctr || 0) / 100, // Convert percentage to decimal
          position: q.position || 0
        }));
        behaviourScore = computeBehaviourScore(queriesForCalculation);
        rankingScore = computeRankingScore(queriesForCalculation);
        debugLog(`‚ö† Non-segmented scores: Behaviour=${behaviourScore.toFixed(1)}, Ranking=${rankingScore.toFixed(1)}`, 'warn');
      }

      // Review Score: Phase 2 - Use real review data if available
      // Get GBP data (may be null if not available, don't default to 0)
      const gbpRating = (localSignals && localSignals.status === 'ok' && localSignals.data) 
        ? (localSignals.data.gbpRating !== null && localSignals.data.gbpRating !== undefined ? localSignals.data.gbpRating : null)
        : null;
      const gbpCount = (localSignals && localSignals.status === 'ok' && localSignals.data) 
        ? (localSignals.data.gbpReviewCount !== null && localSignals.data.gbpReviewCount !== undefined ? localSignals.data.gbpReviewCount : null)
        : null;
      
      // Get site review data - ALWAYS use correct Trustpilot snapshot (4.6, 610)
      const normalizedSiteReviews = getTrustpilotSnapshot(siteReviews);
      const siteRating = normalizedSiteReviews?.siteRating !== null && normalizedSiteReviews?.siteRating !== undefined ? normalizedSiteReviews.siteRating : null;
      const siteCount = normalizedSiteReviews?.siteReviewCount !== null && normalizedSiteReviews?.siteReviewCount !== undefined ? normalizedSiteReviews.siteReviewCount : null;
      
      // Calculate review score (handles optional sources internally)
      const reviewScore = computeReviewScore({
        gbpRating,
        gbpCount,
        siteRating,
        siteCount
      });
      
      // Log the calculation details
      const gbpInfo = gbpRating !== null || gbpCount !== null 
        ? `GBP (rating=${gbpRating !== null ? gbpRating : 'N/A'}, count=${gbpCount !== null ? gbpCount : 'N/A'})`
        : 'GBP (no data)';
      const siteInfo = siteRating !== null || siteCount !== null
        ? `Trustpilot snapshot (rating=${siteRating !== null ? siteRating : 'N/A'}, count=${siteCount !== null ? siteCount : 'N/A'})`
        : 'Trustpilot snapshot (no data)';
      debugLog(`Review Score: ${gbpInfo}, ${siteInfo}, Final=${reviewScore.toFixed(1)}`, 'info');

      // Backlink Score: Phase 3 - Use real backlink metrics if available
      // backlinkMetrics is passed as a parameter (fetched from API)
      const backlinkScore = computeBacklinkScore(backlinkMetrics);

      // Authority weights (constant across all segments)
      const AUTHORITY_WEIGHTS = {
        behaviour: 0.4,
        ranking: 0.2,
        backlinks: 0.2,
        reviews: 0.2
      };
      
      // Helper to compute Authority from component scores
      function computeAuthorityFromComponents(components) {
        const total = clampScore(
          AUTHORITY_WEIGHTS.behaviour * components.behaviour +
          AUTHORITY_WEIGHTS.ranking * components.ranking +
          AUTHORITY_WEIGHTS.backlinks * components.backlinks +
          AUTHORITY_WEIGHTS.reviews * components.reviews
        );
        return {
          behaviour: clampScore(components.behaviour),
          ranking: clampScore(components.ranking),
          backlinks: clampScore(components.backlinks),
          reviews: clampScore(components.reviews),
          total: total
        };
      }
      
      // Base Authority (all pages) - current behaviour
      const authorityAll = computeAuthorityFromComponents({
        behaviour: behaviourScore,
        ranking: rankingScore,
        backlinks: backlinkScore,
        reviews: reviewScore
      });
      
      // Per-segment Authority scores (if segmentation available)
      // Helper function to compute top pages for a segment
      function computeTopPagesForSegment(pageRows, max = 10) {
        if (!pageRows || !Array.isArray(pageRows) || pageRows.length === 0) {
          return [];
        }
        
        // Aggregate by page URL (sum clicks, impressions, weighted position)
        const pageMap = new Map();
        
        pageRows.forEach(row => {
          const url = row.page || row.url || '';
          if (!url) return;
          
          if (!pageMap.has(url)) {
            pageMap.set(url, {
              url: url,
              clicks: 0,
              impressions: 0,
              totalPositionWeight: 0,
              count: 0
            });
          }
          
          const page = pageMap.get(url);
          page.clicks += row.clicks || 0;
          page.impressions += row.impressions || 0;
          page.totalPositionWeight += (row.position || 0) * (row.impressions || 0);
          page.count += 1;
        });
        
        // Convert to top pages format
        const topPages = Array.from(pageMap.values())
          .map(page => ({
            url: page.url,
            clicks: page.clicks,
            impressions: page.impressions,
            ctr: page.impressions > 0 ? (page.clicks / page.impressions) * 100 : 0,
            avgPosition: page.impressions > 0 ? page.totalPositionWeight / page.impressions : 0
          }))
          .filter(page => page.impressions > 0) // Only pages with impressions
          .sort((a, b) => b.impressions - a.impressions) // Sort by impressions descending
          .slice(0, max);
        
        return topPages;
      }
      
      let authorityBySegment = null;
      if (behaviourScoresSegmented && rankingScoresSegmented) {
        // Get page-level data for top pages computation
        const queryPagesData = data.queryPages || [];
        
        // Filter to ranking pages (position 1-20, with impressions)
        const rankingPages = queryPagesData.filter(row => {
          const pos = row.position || 0;
          const impr = row.impressions || 0;
          return pos > 0 && pos <= 20 && impr > 0;
        });
        
        // Classify pages by segment
        const allPages = rankingPages;
        const excludeEduPages = rankingPages.filter(row => {
          const segment = classifyPageSegment(row.page || row.url || '/');
          return segment !== PageSegment.EDUCATION;
        });
        const moneyPages = rankingPages.filter(row => {
          const segment = classifyPageSegment(row.page || row.url || '/');
          return segment === PageSegment.MONEY;
        });
        
        // Compute top pages for each segment
        const allTopPages = computeTopPagesForSegment(allPages, 10);
        const excludeEduTopPages = computeTopPagesForSegment(excludeEduPages, 10);
        const moneyTopPages = computeTopPagesForSegment(moneyPages, 10);
        
        // Non-education (exclude education pages)
        const authorityNonEducation = computeAuthorityFromComponents({
          behaviour: behaviourScoresSegmented.nonBlog,
          ranking: rankingScoresSegmented.nonBlog,
          backlinks: backlinkScore, // Same across all segments
          reviews: reviewScore      // Same across all segments
        });
        
        // Money pages only
        const authorityMoney = computeAuthorityFromComponents({
          behaviour: behaviourScoresSegmented.money,
          ranking: rankingScoresSegmented.money,
          backlinks: backlinkScore, // Same across all segments
          reviews: reviewScore      // Same across all segments
        });
        
        // Helper to compute GSC metrics for a segment from queryPages data
        const computeGSCMetricsForSegment = (queryPagesData, segmentFilter) => {
          if (!queryPagesData || queryPagesData.length === 0) {
            return { siteCtr: 0, top10Ctr: 0, avgPosition: 0, top10Share: 0 };
          }
          
          // Filter by segment if filter function provided
          let filteredData = queryPagesData;
          if (segmentFilter) {
            filteredData = queryPagesData.filter(row => {
              const segment = classifyPageSegment(row.page || row.url || '/');
              return segmentFilter(segment);
            });
          }
          
          // Filter to ranking queries (position 1-20, with impressions)
          const rankingQueries = filteredData.filter(q => {
            const pos = q.position || 0;
            const impr = q.impressions || 0;
            return pos > 0 && pos <= 20 && impr > 0;
          });
          const top10Queries = rankingQueries.filter(q => (q.position || 0) <= 10);
          
          let siteCtr = 0;
          let top10Ctr = 0;
          let avgPosition = 0;
          let top10Share = 0;
          
          if (rankingQueries.length > 0) {
            const totalClicks = rankingQueries.reduce((s, q) => s + (q.clicks || 0), 0);
            const totalImpr = rankingQueries.reduce((s, q) => s + (q.impressions || 0), 0);
            siteCtr = totalImpr > 0 ? (totalClicks / totalImpr) * 100 : 0;
            
            const top10Clicks = top10Queries.reduce((s, q) => s + (q.clicks || 0), 0);
            const top10Impr = top10Queries.reduce((s, q) => s + (q.impressions || 0), 0);
            top10Ctr = top10Impr > 0 ? (top10Clicks / top10Impr) * 100 : 0;
            
            avgPosition = totalImpr > 0
              ? rankingQueries.reduce((s, q) => s + (q.position || 0) * (q.impressions || 0), 0) / totalImpr
              : 0;
            
            top10Share = totalImpr > 0 ? (top10Impr / totalImpr) : 0; // Store as 0-1 fraction
          }
          
          return { siteCtr, top10Ctr, avgPosition, top10Share };
        };
        
        // Compute GSC metrics for each segment using full queryPages data (not pre-filtered rankingPages)
        const allGSCMetrics = computeGSCMetricsForSegment(queryPagesData, null); // All pages
        const excludeEduGSCMetrics = computeGSCMetricsForSegment(queryPagesData, (seg) => seg !== PageSegment.EDUCATION);
        const moneyGSCMetrics = computeGSCMetricsForSegment(queryPagesData, (seg) => seg === PageSegment.MONEY);
        
        debugLog(`üìä GSC Metrics - All: CTR=${allGSCMetrics.siteCtr.toFixed(2)}%, Pos=${allGSCMetrics.avgPosition.toFixed(1)}`, 'info');
        debugLog(`üìä GSC Metrics - ExcludeEdu: CTR=${excludeEduGSCMetrics.siteCtr.toFixed(2)}%, Pos=${excludeEduGSCMetrics.avgPosition.toFixed(1)}`, 'info');
        debugLog(`üìä GSC Metrics - Money: CTR=${moneyGSCMetrics.siteCtr.toFixed(2)}%, Pos=${moneyGSCMetrics.avgPosition.toFixed(1)}`, 'info');
        
        authorityBySegment = {
          all: { 
            ...authorityAll, 
            topPages: allTopPages,
            siteCtr: allGSCMetrics.siteCtr,
            top10Ctr: allGSCMetrics.top10Ctr,
            avgPosition: allGSCMetrics.avgPosition,
            top10Share: allGSCMetrics.top10Share
          },
          nonEducation: { 
            ...authorityNonEducation, 
            topPages: excludeEduTopPages,
            siteCtr: excludeEduGSCMetrics.siteCtr,
            top10Ctr: excludeEduGSCMetrics.top10Ctr,
            avgPosition: excludeEduGSCMetrics.avgPosition,
            top10Share: excludeEduGSCMetrics.top10Share
          },
          money: { 
            ...authorityMoney, 
            topPages: moneyTopPages,
            siteCtr: moneyGSCMetrics.siteCtr,
            top10Ctr: moneyGSCMetrics.top10Ctr,
            avgPosition: moneyGSCMetrics.avgPosition,
            top10Share: moneyGSCMetrics.top10Share
          }
        };
        
        debugLog(`üìä Authority by segment - All: ${authorityAll.total.toFixed(1)}, Non-education: ${authorityNonEducation.total.toFixed(1)}, Money: ${authorityMoney.total.toFixed(1)}`, 'info');
      }
      
      // Main Authority score (default: all pages)
      const authority = authorityAll.total;
      
      debugLog(`Authority calculation: Behaviour=${behaviourScore.toFixed(1)}, Ranking=${rankingScore.toFixed(1)}, Backlinks=${backlinkScore}, Reviews=${reviewScore}, Final=${authority}`, 'info');
      
      // Store component scores for historical tracking (backward compatible)
      const authorityComponents = {
        behaviour: authorityAll.behaviour,
        ranking: authorityAll.ranking,
        backlinks: authorityAll.backlinks,
        reviews: authorityAll.reviews,
        // Segmented scores (if available) - for backward compatibility
        behaviourScoreAll: behaviourScoresSegmented ? clampScore(behaviourScoresSegmented.all) : clampScore(behaviourScore),
        behaviourScoreNonBlog: behaviourScoresSegmented ? clampScore(behaviourScoresSegmented.nonBlog) : null,
        behaviourScoreMoney: behaviourScoresSegmented ? clampScore(behaviourScoresSegmented.money) : null,
        rankingScoreAll: rankingScoresSegmented ? clampScore(rankingScoresSegmented.all) : clampScore(rankingScore),
        rankingScoreNonBlog: rankingScoresSegmented ? clampScore(rankingScoresSegmented.nonBlog) : null,
        rankingScoreMoney: rankingScoresSegmented ? clampScore(rankingScoresSegmented.money) : null
      };
      
      // Log final segmented scores stored
      if (behaviourScoresSegmented) {
        debugLog(`üìä Segmentation: Final stored scores - Behaviour: All=${authorityComponents.behaviourScoreAll}, NonBlog=${authorityComponents.behaviourScoreNonBlog}, Money=${authorityComponents.behaviourScoreMoney}`, 'info');
        debugLog(`üìä Segmentation: Final stored scores - Ranking: All=${authorityComponents.rankingScoreAll}, NonBlog=${authorityComponents.rankingScoreNonBlog}, Money=${authorityComponents.rankingScoreMoney}`, 'info');
      }

      // Local Entity: Use real Business Profile data if available, otherwise fallback to derived calculation
      let localEntity;
      if (localSignals && localSignals.status === 'ok' && localSignals.data) {
        const localData = localSignals.data;
        // Base score from NAP consistency (0-100)
        let baseScore = localData.napConsistencyScore || 0;
        
        // Bonus for knowledge panel detection (+10 points)
        if (localData.knowledgePanelDetected) {
          baseScore = Math.min(100, baseScore + 10);
        }
        
        // Bonus for having at least one location (+5 points)
        if (localData.locations && localData.locations.length > 0) {
          baseScore = Math.min(100, baseScore + 5);
        }
        
        localEntity = clampScore(baseScore);
        debugLog(`Local Entity: NAP=${localData.napConsistencyScore || 0}, Knowledge Panel=${localData.knowledgePanelDetected}, Locations=${localData.locations?.length || 0}, Final=${localEntity}`, 'info');
      } else {
        // Fallback: derived calculation (old method)
        // Calculate ctrScore from ctr (which is 0-100 percentage)
        const ctrDecimal = ctr / 100; // Convert percentage to decimal (e.g., 10% -> 0.10)
        const ctrScore = Math.min((ctrDecimal / 0.10) * 100, 100);
        localEntity = clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
        debugLog('Local Entity: Using fallback calculation (no Business Profile data)', 'warn');
      }

      // Service Area: Use real Business Profile service areas count if available, otherwise fallback
      let serviceArea;
      if (localSignals && localSignals.status === 'ok' && localSignals.data) {
        const localData = localSignals.data;
        const serviceAreasCount = localData.serviceAreas?.length || 0;
        
        // Normalize service areas count to 0-100 score
        // 0 areas = 0, 8+ areas = 100 (more reasonable threshold)
        // Linear scale: 1 area = 12.5 points (8 areas = 100)
        if (serviceAreasCount === 0) {
          serviceArea = 0;
        } else if (serviceAreasCount >= 8) {
          serviceArea = 100;
        } else {
          // Linear scale: 1 area = 12.5 points, 2 = 25, ..., 8 = 100
          serviceArea = Math.min(100, serviceAreasCount * 12.5);
        }
        
        // Apply NAP consistency as a multiplier (if NAP is low, reduce service area score)
        if (localData.napConsistencyScore !== null && localData.napConsistencyScore < 100) {
          const napMultiplier = localData.napConsistencyScore / 100;
          serviceArea = Math.round(serviceArea * napMultiplier);
        }
        
        serviceArea = clampScore(serviceArea);
        debugLog(`Service Area: Count=${serviceAreasCount}, NAP Multiplier=${localData.napConsistencyScore !== null ? (localData.napConsistencyScore / 100).toFixed(2) : 'N/A'}, Final=${serviceArea}`, 'info');
      } else {
        // Fallback: derived from Local Entity (old method)
        serviceArea = clampScore(localEntity - 5);
        debugLog('Service Area: Using fallback calculation (no Business Profile data)', 'warn');
      }

      // Content/Schema: weighted calculation based on foundation schemas, rich results, coverage, and diversity
      let contentSchema;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        const allTypes = new Set();
        
        // Use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
        if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
          // Use all detected types for accurate calculation
          schemaData.allDetectedTypes.forEach(type => {
            if (type) allTypes.add(type);
          });
        } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          // Fallback: collect from schemaTypes array (contains all types, sorted by count)
          schemaData.schemaTypes.forEach(item => {
            if (item.type) allTypes.add(item.type);
          });
        }
        
        // 1. Foundation Schemas Score (30% weight): Organization, Person, WebSite, BreadcrumbList
        const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
        const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
        const foundationScore = (foundationPresent / foundationTypes.length) * 100;
        
        // 2. Rich Result Eligibility Score (35% weight): Count eligible rich result types
        // Note: This list must match RICH_RESULT_TYPES in api/schema-audit.js
        const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
        const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
        const richResultScore = (richEligibleCount / richResultTypes.length) * 100;
        
        // 3. Coverage Score (20% weight): Pages with schema / total pages
        const coverageScore = schemaData.coverage || 0;
        
        // 4. Type Diversity Score (15% weight): Number of unique schema types (normalized to 15 types)
        const uniqueTypesCount = allTypes.size;
        const diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
        
        // Weighted calculation: 30% foundation + 35% rich results + 20% coverage + 15% diversity
        contentSchema = clampScore(
          foundationScore * 0.30 +
          richResultScore * 0.35 +
          coverageScore * 0.20 +
          diversityScore * 0.15
        );
        
        debugLog(`Content/Schema calculation: Foundation=${foundationScore.toFixed(1)}% (${foundationPresent}/4), Rich Results=${richResultScore.toFixed(1)}% (${richEligibleCount}/${richResultTypes.length}), Coverage=${coverageScore.toFixed(1)}%, Diversity=${diversityScore.toFixed(1)}% (${uniqueTypesCount} types)`, 'info');
      } else {
        // Fallback: if no schema audit data, return 0 (can't calculate without data)
        contentSchema = 0;
        debugLog('‚ö† No schema audit data available, Content/Schema score set to 0', 'warn');
      }

      // Extract coverage and diversity scores from contentSchema calculation for AI GEO health
      let coverageScore = 0;
      let diversityScore = 0;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        // Coverage: Pages with schema / total pages (0-100)
        coverageScore = schemaData.coverage || 0;
        
        // Diversity: Number of unique schema types (normalized to 15 types, 0-100)
        const allTypes = new Set();
        if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
          schemaData.allDetectedTypes.forEach(type => {
            if (type) allTypes.add(type);
          });
        } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          schemaData.schemaTypes.forEach(item => {
            if (item.type) allTypes.add(item.type);
          });
        }
        const uniqueTypesCount = allTypes.size;
        diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
      }

      const scores = {
        localEntity,
        serviceArea,
        authority: {
          score: authority, // Main score (default: all pages)
          bySegment: authorityBySegment // Per-segment Authority scores (if available)
        },
        visibility,
        contentSchema,
        // Authority component scores for historical tracking (backward compatible)
        authorityComponents: authorityComponents,
        // AI GEO health components (extracted from contentSchema)
        coverage: coverageScore,
        diversity: diversityScore
      };

      debugLog(`Deterministic pillar scores: ${JSON.stringify(scores)}`, 'info');
      return scores;
    }
    
    // Calculate AI GEO Health Score
    function calculateAiGeoScore(scores, schemaAudit = null) {
      // AI GEO weights
      const AIGEO_WEIGHTS = {
        authority: 0.30,
        content: 0.25,
        coverage: 0.15,
        diversity: 0.15,
        locations: 0.15
      };
      
      // Extract scores
      const authorityScore = (typeof scores.authority === 'object' && scores.authority !== null) 
        ? scores.authority.score 
        : scores.authority || 0;
      const contentScore = scores.contentSchema || 0;
      
      // Extract coverage and diversity from schema audit or scores
      let coverage = scores.coverage || 0;
      let diversity = scores.diversity || 0;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        coverage = schemaData.coverage || 0;
        const allTypes = new Set();
        if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
          schemaData.allDetectedTypes.forEach(type => {
            if (type) allTypes.add(type);
          });
        } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          schemaData.schemaTypes.forEach(item => {
            if (item.type) allTypes.add(item.type);
          });
        }
        const uniqueTypesCount = allTypes.size;
        diversity = Math.min((uniqueTypesCount / 15) * 100, 100);
      }
      
      // Locations: average of localEntity and serviceArea
      const locationsScore = ((scores.localEntity || 0) + (scores.serviceArea || 0)) / 2;
      
      // Calculate weighted score
      const aiGeoScore = Math.round(
        authorityScore * AIGEO_WEIGHTS.authority +
        contentScore * AIGEO_WEIGHTS.content +
        coverage * AIGEO_WEIGHTS.coverage +
        diversity * AIGEO_WEIGHTS.diversity +
        locationsScore * AIGEO_WEIGHTS.locations
      );
      
      return {
        aiGeoScore,
        aiGeoStatus: aiGeoScore >= 70 ? 'green' : aiGeoScore >= 50 ? 'amber' : 'red',
        aiSummaryLikelihood: calculateAiSummaryLikelihood({
          aiGeoScore,
          authority: authorityScore,
          content: contentScore,
          coverage: coverage
        })
      };
    }
    
    // Calculate AI Summary Likelihood
    function calculateAiSummaryLikelihood({ aiGeoScore, authority, content, coverage }) {
      const strongAuthority = authority >= 65;
      const strongContent = content >= 70;
      const strongCoverage = coverage >= 80;
      
      if (aiGeoScore >= 75 && strongAuthority && strongContent && strongCoverage) {
        return 'high';
      }
      if (aiGeoScore >= 55) {
        return 'medium';
      }
      return 'low';
    }

    function calculateSnippetReadiness(scores, data) {
      // Snippet readiness combines:
      // 1. Content/Schema score (structured data quality)
      // 2. Visibility score (SERP feature presence)
      // 3. Authority score (content depth and trust)
      // Weighted average: 40% Content/Schema, 35% Visibility, 25% Authority
      // Handle both old format (number) and new format (object with score)
      const authorityScore = typeof scores.authority === 'object' ? scores.authority.score : scores.authority;
      const readiness = (
        scores.contentSchema * 0.4 +
        scores.visibility * 0.35 +
        authorityScore * 0.25
      );
      return Math.round(Math.min(100, Math.max(0, readiness)));
    }

    // Fetch real data from Google Search Console API using unified endpoint
    // Note: apiKey parameter kept for compatibility but not used (endpoint uses OAuth2)
    async function fetchSearchConsoleData(apiKey, propertyUrl, days) {
      debugLog(`Fetching real GSC data for ${days} days...`, 'info');
      
      // Calculate date range
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);
      
      // Format dates as YYYY-MM-DD
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      const startDateStr = formatDate(startDate);
      const endDateStr = formatDate(endDate);
      
      debugLog(`Date range: ${startDateStr} to ${endDateStr}`, 'info');
      
      try {
        // Call unified GSC entity metrics endpoint
        const response = await fetch(`/api/aigeo/gsc-entity-metrics?property=${encodeURIComponent(propertyUrl)}&startDate=${startDateStr}&endDate=${endDateStr}`);

        if (!response.ok) {
          const errorData = await response.json();
          debugLog(`‚úó GSC API error: ${errorData.message || errorData.error}`, 'error');
          if (errorData.details) {
            debugLog(`Details: ${errorData.details}`, 'error');
          }
          
          // If OAuth not configured, show helpful message
          if (errorData.message && errorData.message.includes('OAuth2 credentials not configured')) {
            throw new Error('Google Search Console OAuth2 credentials not configured. Please set GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, and GOOGLE_REFRESH_TOKEN in Vercel environment variables.');
          }
          
          throw new Error(errorData.message || errorData.error || 'Failed to fetch Search Console data');
        }

        const gsc = await response.json();
        
        if (gsc.status !== 'ok') {
          throw new Error(gsc.message || 'Failed to fetch Search Console data');
        }
        
        debugLog(`‚úì Real GSC data fetched: ${gsc.data.overview.totalClicks} clicks, ${gsc.data.overview.totalImpressions} impressions`, 'success');
        
        // Log segmentation data availability
        if (gsc.data.queryPages && gsc.data.queryPages.length > 0) {
          debugLog(`‚úì GSC API returned ${gsc.data.queryPages.length} query+page combinations for segmentation`, 'success');
        } else {
          debugLog('‚ö† GSC API did not return queryPages data. Segmentation will use fallback calculation.', 'warn');
        }
        
        // Return data in format expected by existing code
        return {
          totalClicks: gsc.data.overview.totalClicks || 0,
          totalImpressions: gsc.data.overview.totalImpressions || 0,
          averagePosition: gsc.data.overview.avgPosition || 0,
          ctr: gsc.data.overview.ctr || 0, // Already 0-100 from API
          topQueries: gsc.data.topQueries || [],
          queryPages: gsc.data.queryPages || [], // Query+page combinations for segmentation
          timeseries: gsc.data.timeseries || [], // For trend chart
          dateRange: days,
          // Store full GSC response for trend chart access
          _gscResponse: gsc
        };
      } catch (error) {
        debugLog(`‚úó Error fetching GSC data: ${error.message}`, 'error');
        throw error;
      }
    }

    // Run the audit
    async function runAudit() {
      debugLog('=== AUDIT START: Beginning audit scan ===', 'info');
      
      // Get API key - prioritize Vercel env var, then loaded key, then localStorage
      let apiKey = window._loadedApiKey;
      
      // Try Vercel environment variable first
      if (!apiKey) {
        try {
          debugLog('Fetching API key from Vercel environment variable...', 'info');
          const response = await fetch('/api/get-api-key');
          if (response.ok) {
            const data = await response.json();
            if (data.apiKey) {
              apiKey = data.apiKey;
              debugLog('‚úì Using API key from Vercel environment variable', 'success');
              window._loadedApiKey = apiKey;
            }
          }
        } catch (e) {
          debugLog('Vercel env var endpoint not available', 'info');
        }
      }
      
      // Fall back to config.js
      if (!apiKey && window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey) {
        apiKey = window.API_CONFIG.googleSearchConsoleApiKey;
        debugLog('‚úì Using API key from config.js', 'success');
        window._loadedApiKey = apiKey;
      }
      
      // Fall back to localStorage
      if (!apiKey) {
        apiKey = localStorage.getItem('gsc_api_key');
        if (apiKey) {
          debugLog('‚úì Using API key from localStorage', 'success');
          window._loadedApiKey = apiKey;
        }
      }
      
      const propertyUrl = document.getElementById('propertyUrl').value;
      const dateRange = parseInt(document.getElementById('dateRange').value);
      
      debugLog(`Property URL: ${propertyUrl}`, 'info');
      debugLog(`Date Range: ${dateRange} days`, 'info');

      // Note: API key no longer required - new endpoint uses OAuth2 from env vars
      if (!propertyUrl) {
        debugLog('‚úó No property URL provided', 'error');
        showStatus('Please enter your property URL', 'error');
        return;
      }

      debugLog('Showing loading indicator...', 'info');
      document.getElementById('loading').classList.add('show');
      document.getElementById('dashboard').style.display = 'none';
      updateProgress(0, 'Initializing audit scan...');

      // Load saved audit data first to use as defaults (preserve data when sources unavailable)
      let savedAudit = null;
      try {
        const saved = localStorage.getItem('last_audit_results');
        if (saved) {
          savedAudit = JSON.parse(saved);
          debugLog('‚úì Loaded previous audit data for fallback', 'info');
        }
      } catch (e) {
        debugLog(`‚ö† Could not load previous audit data: ${e.message}`, 'warn');
      }

      // Declare schemaAudit outside try block so it's accessible in finally
      // Initialize with saved data if available (preserves Content/Schema when endpoint unavailable)
      let schemaAudit = savedAudit?.schemaAudit || null;
      let localSignals = savedAudit?.localSignals || null;
      // Don't use cached siteReviews - always fetch fresh Trustpilot snapshot
      // Old cached values (4.8, 127) should be replaced with new snapshot (4.6, 610)
      let siteReviews = null; // Always fetch fresh
      let backlinkMetrics = savedAudit?.backlinkMetrics || null;

      try {
        updateProgress(10, 'Fetching Search Console data...');
        debugLog('Fetching Search Console data...', 'info');
        // Fetch data
        const searchData = await fetchSearchConsoleData(apiKey, propertyUrl, dateRange);
        debugLog('‚úì Search Console data fetched successfully', 'success');
        debugLog(`Data: ${JSON.stringify(searchData).substring(0, 200)}...`, 'info');
        
        updateProgress(35, 'Fetching local signals data...');
        debugLog('Fetching local signals data...', 'info');
        // Fetch local signals (Business Profile) data
        // Only fetch if we don't have saved data, or always fetch fresh (Business Profile can change)
        try {
          const localSignalsResponse = await fetch(`/api/aigeo/local-signals?property=${encodeURIComponent(propertyUrl)}`);
          if (localSignalsResponse.ok) {
            const freshLocalSignals = await localSignalsResponse.json();
            if (freshLocalSignals.status === 'ok') {
              localSignals = freshLocalSignals;
              debugLog('‚úì Local signals data fetched successfully', 'success');
              debugLog(`Service areas: ${localSignals.data.serviceAreas?.length || 0}, NAP score: ${localSignals.data.napConsistencyScore || 'N/A'}`, 'info');
            } else {
              debugLog('‚ö† Local signals returned error, using saved data if available', 'warn');
            }
          } else {
            debugLog('‚ö† Local signals endpoint not available, using saved data if available', 'warn');
          }
        } catch (localSignalsError) {
          debugLog(`‚ö† Local signals error: ${localSignalsError.message}, using saved data if available`, 'warn');
        }
        
        // If fetch failed but we have saved data, keep using it
        if (!localSignals && savedAudit?.localSignals) {
          localSignals = savedAudit.localSignals;
          debugLog('‚úì Using saved local signals data', 'info');
        }
        
        updateProgress(37, 'Fetching Trustpilot snapshot data...');
        debugLog('Fetching Trustpilot snapshot data...', 'info');
        // Always fetch fresh Trustpilot snapshot data (it's a fixed snapshot, so should always work)
        try {
          const siteReviewsResponse = await fetch('/api/reviews/site-reviews');
          if (siteReviewsResponse.ok) {
            const siteReviewsData = await siteReviewsResponse.json();
            if (siteReviewsData.status === 'ok' && siteReviewsData.data) {
              siteReviews = siteReviewsData.data;
              debugLog('‚úì Trustpilot snapshot data fetched successfully', 'success');
              debugLog(`Trustpilot snapshot: rating=${siteReviews.siteRating}, count=${siteReviews.siteReviewCount}`, 'info');
            } else {
              debugLog('‚ö† Trustpilot snapshot returned error, using saved data if available', 'warn');
              // Fallback to saved data only if API completely fails
              if (savedAudit?.siteReviews) {
                siteReviews = savedAudit.siteReviews;
                debugLog('‚ö† Using saved Trustpilot data as fallback (will override with correct values)', 'warn');
              }
            }
          } else {
            debugLog('‚ö† Trustpilot snapshot endpoint not available, using saved data if available', 'warn');
            // Fallback to saved data only if API completely fails
            if (savedAudit?.siteReviews) {
              siteReviews = savedAudit.siteReviews;
              debugLog('‚ö† Using saved Trustpilot data as fallback (will override with correct values)', 'warn');
            }
          }
        } catch (siteReviewsError) {
          debugLog(`‚ö† Trustpilot snapshot error: ${siteReviewsError.message}, using saved data if available`, 'warn');
          // Fallback to saved data only if API completely fails
          if (savedAudit?.siteReviews) {
            siteReviews = savedAudit.siteReviews;
            debugLog('‚ö† Using saved Trustpilot data as fallback (will override with correct values)', 'warn');
          }
        }
        
        // ALWAYS force correct Trustpilot snapshot values (4.6, 610) - override ANY old values
        // This ensures we always use the correct snapshot regardless of API response or cached data
        const TRUSTPILOT_SNAPSHOT = {
          siteRating: 4.6,
          siteReviewCount: 610,
          lastUpdated: '2025-12-07',
          notes: 'Fixed Trustpilot snapshot for Authority score calculation. Update manually when Trustpilot metrics change significantly.'
        };
        
        if (!siteReviews || siteReviews.siteRating !== 4.6 || siteReviews.siteReviewCount !== 610) {
          if (siteReviews) {
            debugLog(`‚ö† Overriding old Trustpilot values (${siteReviews.siteRating}, ${siteReviews.siteReviewCount}) with correct snapshot (4.6, 610)`, 'warn');
          } else {
            debugLog('‚ö† Using default Trustpilot snapshot values (4.6, 610)', 'warn');
          }
          siteReviews = TRUSTPILOT_SNAPSHOT;
        } else {
          debugLog('‚úì Trustpilot snapshot verified (4.6, 610)', 'success');
        }
        
        updateProgress(38, 'Fetching backlink metrics data...');
        debugLog('Fetching backlink metrics data...', 'info');
        // Fetch backlink metrics - try localStorage first (from CSV upload), then API
        let backlinkMetrics = null;
        
        // First, try to get from localStorage (stored when CSV was uploaded)
        try {
          const storedMetrics = localStorage.getItem('backlink_metrics');
          if (storedMetrics) {
            backlinkMetrics = JSON.parse(storedMetrics);
            debugLog('‚úì Backlink metrics loaded from localStorage', 'success');
            debugLog(`Backlink metrics: domains=${backlinkMetrics.referringDomains}, links=${backlinkMetrics.totalBacklinks}, followRatio=${(backlinkMetrics.followRatio * 100).toFixed(1)}%`, 'info');
          }
        } catch (e) {
          debugLog(`‚ö† Error reading backlink metrics from localStorage: ${e.message}`, 'warn');
        }
        
        // If not in localStorage, try API (for cases where metrics were uploaded via API directly)
        if (!backlinkMetrics) {
          try {
            const backlinkResponse = await fetch('/api/aigeo/backlink-metrics');
            if (backlinkResponse.ok) {
              const backlinkData = await backlinkResponse.json();
              if (backlinkData.status === 'ok' && backlinkData.data && backlinkData.data.totalBacklinks > 0) {
                backlinkMetrics = backlinkData.data;
                // Store in localStorage for next time
                localStorage.setItem('backlink_metrics', JSON.stringify(backlinkMetrics));
                debugLog('‚úì Backlink metrics data fetched from API and stored', 'success');
                debugLog(`Backlink metrics: domains=${backlinkMetrics.referringDomains}, links=${backlinkMetrics.totalBacklinks}, followRatio=${(backlinkMetrics.followRatio * 100).toFixed(1)}%`, 'info');
              } else {
                debugLog('‚ö† Backlink metrics returned empty/zero, using saved data if available', 'warn');
              }
            } else {
              debugLog('‚ö† Backlink metrics endpoint not available, using saved data if available', 'warn');
            }
          } catch (backlinkError) {
            debugLog(`‚ö† Backlink metrics error: ${backlinkError.message}, using saved data if available`, 'warn');
          }
        }
        
        // If fetch failed but we have saved data, keep using it
        if (!backlinkMetrics && savedAudit?.backlinkMetrics) {
          backlinkMetrics = savedAudit.backlinkMetrics;
          debugLog('‚úì Using saved backlink metrics data', 'info');
        }
        
        updateProgress(40, 'Fetching schema audit data...');
        debugLog('Fetching schema audit data...', 'info');
        // Fetch schema audit data
        try {
          // Check if manual URL list is available
          const manualUrlList = localStorage.getItem('manual_url_list');
          let schemaRequest;
          
          if (manualUrlList) {
            try {
              const urls = JSON.parse(manualUrlList);
              debugLog(`Using manual URL list: ${urls.length} URLs`, 'info');
              updateProgress(45, `Crawling ${urls.length} URLs for schema markup...`);
              schemaRequest = fetch('/api/schema-audit', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ urls })
              });
            } catch (e) {
              debugLog('‚ö† Failed to parse manual URL list, using default CSV', 'warn');
              updateProgress(45, 'Loading URLs from CSV and crawling for schema markup...');
              schemaRequest = fetch('/api/schema-audit');
            }
          } else {
            debugLog('No manual URL list, using default CSV source', 'info');
            updateProgress(45, 'Loading URLs from CSV and crawling for schema markup...');
            schemaRequest = fetch('/api/schema-audit');
          }
          
          const schemaResponse = await schemaRequest;
          if (schemaResponse.ok) {
            schemaAudit = await schemaResponse.json();
            if (schemaAudit.status === 'ok') {
              debugLog('‚úì Schema audit data fetched successfully', 'success');
              debugLog(`Schema coverage: ${schemaAudit.data.coverage}%`, 'info');
              if (manualUrlList) {
                debugLog('  Source: Manual URL list', 'info');
              } else {
                debugLog('  Source: CSV (GitHub/hosted)', 'info');
              }
              
              // Log comprehensive diagnostic info if available
              if (schemaAudit.meta && schemaAudit.meta.diagnostic) {
                const diag = schemaAudit.meta.diagnostic;
                debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                debugLog('üìä SCHEMA AUDIT DIAGNOSTICS', 'info');
                debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                debugLog('üìà PAGE COUNTS:', 'info');
                debugLog(`  ‚Ä¢ Total pages scanned: ${diag.totalPages}`, 'info');
                debugLog(`  ‚Ä¢ Successful crawls: ${diag.successfulPages || diag.totalPages}`, 'info');
                debugLog(`  ‚Ä¢ Failed crawls: ${diag.failedPages || 0}`, diag.failedPages > 0 ? 'warn' : 'info');
                if (diag.failedPages > 0) {
                  debugLog(`    ‚ö† Failed crawls are counted as pages without schema`, 'warn');
                  
                  // Show error breakdown if available
                  if (diag.errorTypes && Object.keys(diag.errorTypes).length > 0) {
                    debugLog('', 'info'); // Empty line
                    debugLog('  üîç ERROR BREAKDOWN:', 'warn');
                    Object.entries(diag.errorTypes).forEach(([type, count]) => {
                      debugLog(`    ‚Ä¢ ${type}: ${count} pages`, 'warn');
                      if (diag.errorExamples && diag.errorExamples[type]) {
                        const example = diag.errorExamples[type];
                        debugLog(`      Example: ${example.url}`, 'info');
                        debugLog(`      Error: ${example.error}`, 'info');
                      }
                    });
                  }
                }
                debugLog(`  ‚Ä¢ Pages with inline schema: ${diag.pagesWithInlineSchema}`, 'info');
                debugLog(`  ‚Ä¢ Pages without inline schema: ${diag.pagesWithoutInlineSchema}`, 'info');
                if (diag.failedPages > 0) {
                  debugLog(`    (includes ${diag.failedPages} failed crawls)`, 'info');
                }
                debugLog(`  ‚Ä¢ Pages with inherited schema: ${diag.pagesWithInheritedSchema}`, 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                if (diag.urlsWithoutSchemas && diag.urlsWithoutSchemas.length > 0) {
                  debugLog('üîó URLs WITHOUT SCHEMAS:', 'info');
                  diag.urlsWithoutSchemas.forEach(url => {
                    debugLog(`  ‚Ä¢ ${url}`, 'info');
                  });
                  if (diag.pagesWithoutInlineSchema > diag.urlsWithoutSchemas.length) {
                    debugLog(`  ... and ${diag.pagesWithoutInlineSchema - diag.urlsWithoutSchemas.length} more`, 'info');
                  }
                  debugLog('', 'info'); // Empty line for spacing
                }
                
                debugLog('üîç MISSING SCHEMA BREAKDOWN:', 'info');
                debugLog(`  ‚Ä¢ Pages with parent but no inherited: ${diag.pagesWithParentButNoInherited}`, 'info');
                debugLog(`  ‚Ä¢ Pages with parent but not checked: ${diag.pagesWithParentButNotChecked}`, diag.pagesWithParentButNotChecked > 0 ? 'warn' : 'info');
                debugLog(`  ‚Ä¢ Pages without parent page: ${diag.pagesWithoutParent}`, 'info');
                debugLog('', 'info'); // Empty line for spacing
                
                debugLog('‚úÖ VALIDATION:', 'info');
                debugLog(`  ‚Ä¢ Total missing pages (calculated): ${diag.totalMissing}`, 'info');
                debugLog(`  ‚Ä¢ Expected missing (total - inline - inherited): ${diag.expectedMissing}`, 'info');
                
                if (diag.mismatch) {
                  debugLog('', 'info'); // Empty line for spacing
                  debugLog(`  ‚ùå MISMATCH DETECTED!`, 'error');
                  debugLog(`  ${diag.mismatchDetails}`, 'error');
                  debugLog(`  This indicates pages are being double-counted or missed in the calculation.`, 'error');
                } else {
                  debugLog(`  ‚úì Counts match correctly`, 'success');
                }
                
                debugLog('', 'info'); // Empty line for spacing
                debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
              }
            } else {
              debugLog('‚ö† Schema audit returned error, using fallback', 'warn');
            }
          } else {
            debugLog('‚ö† Schema audit endpoint not available, using saved data', 'warn');
            // schemaAudit already initialized with saved data at start, so it's preserved
            if (schemaAudit) {
              debugLog('‚úì Using saved schema audit data from previous audit', 'success');
              debugLog(`Schema coverage: ${schemaAudit.data?.coverage || 'N/A'}%`, 'info');
            } else {
              debugLog('‚ö† No saved schema audit data available', 'warn');
            }
          }
        } catch (schemaError) {
          debugLog(`‚ö† Schema audit error: ${schemaError.message}, using saved data`, 'warn');
          // schemaAudit already initialized with saved data at start, so it's preserved
          if (schemaAudit) {
            debugLog('‚úì Using saved schema audit data from previous audit (fallback)', 'success');
            debugLog(`Schema coverage: ${schemaAudit.data?.coverage || 'N/A'}%`, 'info');
          } else {
            debugLog('‚ö† No saved schema audit data available', 'warn');
          }
        }
        
        updateProgress(70, 'Calculating pillar scores...');
        debugLog('Calculating pillar scores...', 'info');
        // Calculate scores (pass schema audit data, local signals, site reviews, and backlink metrics)
        const scores = calculatePillarScores(searchData, schemaAudit, localSignals, siteReviews, backlinkMetrics);
        debugLog('‚úì Pillar scores calculated', 'success');
        debugLog(`Scores: ${JSON.stringify(scores)}`, 'info');

        updateProgress(85, 'Calculating snippet readiness...');
        debugLog('Calculating snippet readiness...', 'info');
        const snippetReadiness = calculateSnippetReadiness(scores, searchData);
        debugLog(`Snippet readiness: ${snippetReadiness}`, 'info');

        updateProgress(95, 'Generating dashboard...');
        debugLog('Displaying dashboard...', 'info');
        // Display results (pass current audit data including localSignals)
        displayDashboard(scores, searchData, snippetReadiness, schemaAudit, localSignals);
        
        updateProgress(100, 'Audit completed successfully!');
        debugLog('=== AUDIT COMPLETE: Success ===', 'success');
        
        // Save audit results to localStorage
        saveAuditResults(scores, searchData, snippetReadiness, schemaAudit, localSignals, siteReviews, backlinkMetrics);
        
        // Save audit results to Supabase for historical tracking
        saveAuditToSupabase(propertyUrl, scores, searchData, snippetReadiness, schemaAudit, localSignals);
        
        showStatus('Audit completed successfully!', 'success');
      } catch (error) {
        debugLog(`‚úó AUDIT ERROR: ${error.message}`, 'error');
        debugLog(`Stack trace: ${error.stack}`, 'error');
        showStatus('Error running audit: ' + error.message, 'error');
        console.error(error);
      } finally {
        debugLog('Hiding loading indicator...', 'info');
        document.getElementById('loading').classList.remove('show');
        
        // Show completion summary modal
        debugLog(`Schema audit available for modal: ${schemaAudit ? 'yes' : 'no'}`, 'info');
        if (schemaAudit) {
          debugLog('Showing completion modal...', 'info');
          setTimeout(() => {
            showCompletionModal(schemaAudit);
          }, 500);
        } else {
          debugLog('‚ö† No schema audit data available for modal', 'warn');
        }
        
        // Reset progress bar for next run
        setTimeout(() => {
          updateProgress(0, 'Initializing audit scan...');
        }, 500);
      }
    }

    // Display dashboard
    async function displayDashboard(scores, data, snippetReadiness = 0, schemaAudit = null, localSignals = null) {
      // Update timestamp if this is a fresh display
      const saved = loadAuditResults();
      if (saved && saved.timestamp) {
        updateAuditTimestamp(saved.timestamp);
      }
      
      // Use current audit data (passed as parameter) or fallback to saved data
      // This ensures we always use the most recent audit run data, not stale localStorage
      const currentLocalSignals = localSignals || (saved && saved.localSignals) || null;
      
      // Update retry button visibility
      updateRetryButtonVisibility(schemaAudit);
      
      debugLog('=== DISPLAY DASHBOARD: Starting ===', 'info');
      debugLog(`Using current audit data: schemaAudit=${schemaAudit ? 'yes' : 'no'}, localSignals=${currentLocalSignals ? 'yes' : 'no'}`, 'info');
      
      // Show dashboard first (canvas elements need to be visible for Chart.js)
      const dashboardDiv = document.getElementById('dashboard');
      if (!dashboardDiv) {
        debugLog('‚úó Dashboard div not found', 'error');
        console.error('Dashboard div not found');
        return;
      }
      debugLog('‚úì Dashboard div found', 'success');
      dashboardDiv.style.display = 'block';
      debugLog('Dashboard div displayed', 'info');
      
      // Update trend chart description with date range
      const dateRange = parseInt(document.getElementById('dateRange').value) || 30;
      const trendDesc = document.getElementById('trendChartDescription');
      if (trendDesc) {
        let rangeText = '';
        if (dateRange === 30) rangeText = 'Last 30 Days';
        else if (dateRange === 60) rangeText = 'Last 60 Days';
        else if (dateRange === 90) rangeText = 'Last 90 Days';
        else if (dateRange === 120) rangeText = 'Last 120 Days';
        else if (dateRange === 180) rangeText = 'Last 6 Months';
        else if (dateRange === 365) rangeText = 'Last 12 Months';
        else if (dateRange === 540) rangeText = 'Last 18 Months';
        else rangeText = `Last ${dateRange} Days`;
        trendDesc.textContent = `Historical performance tracking for Local Entity, Visibility, and Authority pillars over ${rangeText.toLowerCase()}.`;
      }
      
      const pillarNames = {
        localEntity: 'Local Entity',
        serviceArea: 'Service Area',
        authority: 'Authority',
        visibility: 'Visibility',
        contentSchema: 'Content / Schema'
      };
      
      // Define pillar weightings and order by weight (highest to lowest)
      const pillarWeights = {
        authority: 0.30,        // 30% - E-A-T is crucial for AI trust
        contentSchema: 0.25,     // 25% - Structured data is key for AI understanding
        visibility: 0.20,        // 20% - How AI surfaces your content
        localEntity: 0.15,       // 15% - Entity recognition important but not critical
        serviceArea: 0.10         // 10% - Less critical for AI search
      };
      
      // Sort pillars by weight (highest to lowest) for consistent ordering
      const getOrderedPillars = (scoresObj) => {
        // Filter out non-pillar keys (like authorityComponents)
        const validPillars = ['localEntity', 'serviceArea', 'authority', 'visibility', 'contentSchema'];
        return Object.entries(scoresObj)
          .filter(([key]) => validPillars.includes(key))
          .map(([key, scoreValue]) => {
            // Handle new Authority structure (object with score) or legacy (number)
            let score = scoreValue;
            if (key === 'authority' && typeof scoreValue === 'object' && scoreValue !== null) {
              score = scoreValue.score || 0;
            }
            return [key, score];
          })
          .sort((a, b) => {
            return (pillarWeights[b[0]] || 0) - (pillarWeights[a[0]] || 0);
          });
      };

      // Use current audit data (passed as parameter) for health dashboard
      // This ensures we use the most recent audit run data, not stale localStorage
      const hasLocalSignals = currentLocalSignals && currentLocalSignals.status === 'ok' && currentLocalSignals.data;
      const localSignalsData = hasLocalSignals ? currentLocalSignals.data : null;
      
      // Calculate AI GEO Health Score
      const aiGeoHealth = calculateAiGeoScore(scores, schemaAudit);
      debugLog(`AI GEO Health: Score=${aiGeoHealth.aiGeoScore}, Status=${aiGeoHealth.aiGeoStatus}, Likelihood=${aiGeoHealth.aiSummaryLikelihood}`, 'info');
      
      // Extract component scores for health dashboard
      const authorityScore = (typeof scores.authority === 'object' && scores.authority !== null) 
        ? scores.authority.score 
        : scores.authority || 0;
      const contentScore = scores.contentSchema || 0;
      
      // Extract coverage and diversity from schema audit (same logic as calculateAiGeoScore)
      let coverageScore = scores.coverage || 0;
      let diversityScore = scores.diversity || 0;
      if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        coverageScore = schemaData.coverage || 0;
        const allTypes = new Set();
        if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
          schemaData.allDetectedTypes.forEach(type => {
            if (type) allTypes.add(type);
          });
        } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
          schemaData.schemaTypes.forEach(item => {
            if (item.type) allTypes.add(item.type);
          });
        }
        const uniqueTypesCount = allTypes.size;
        diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
      }
      
      const locationsScore = ((scores.localEntity || 0) + (scores.serviceArea || 0)) / 2;
      
      // Create AI GEO Health Dashboard (insert before pillar cards)
      const healthDashboard = document.createElement('div');
      healthDashboard.id = 'ai-geo-health-dashboard';
      healthDashboard.style.marginBottom = '2rem';
      
      // Get pillar hints/comments for the comparison table
      const getPillarHint = (pillarKey, score, scoresObj, schemaAuditData, localSignalsData) => {
        switch(pillarKey) {
          case 'authority':
            const authComponents = scoresObj?.authorityComponents;
            if (authComponents) {
              if (authComponents.behaviour < 30 && authComponents.backlinks >= 50 && authComponents.reviews >= 50) {
                return 'Backlinks and reviews strong; CTR weak';
              } else if (authComponents.behaviour >= 50 && authComponents.ranking < 30) {
                return 'CTR strong; ranking needs improvement';
              } else if (authComponents.behaviour < 30) {
                return 'Behaviour is weak; backlinks/reviews strong';
              }
            }
            return 'E-A-T signals balanced';
          case 'content':
            if (score >= 90) return 'Fully structured, rich schema';
            if (score >= 70) return 'Good schema coverage';
            return 'Schema needs improvement';
          case 'coverage':
            if (score >= 90) return 'All priority pages ingested';
            if (score >= 70) return 'Most pages covered';
            return 'Coverage gaps present';
          case 'diversity':
            if (score >= 80) return 'Good mix of topics and formats';
            if (score >= 60) return 'Moderate diversity';
            return 'Limited schema diversity';
          case 'locations':
            if (score >= 85) return 'GBP + core locations covered well';
            if (score >= 70) return 'Local entity and service areas solid';
            return 'Location signals need strengthening';
          default:
            return '';
        }
      };
      
      // Generate priorities list from pillar diagnostics
      const getPriorities = (scoresObj, schemaAuditData, localSignalsData, authorityComponents) => {
        const priorities = [];
        
        // Authority priorities
        if (authorityComponents) {
          if (authorityComponents.behaviour < 30) {
            priorities.push({
              pillar: 'Authority',
              severity: 'high',
              message: 'Improve Top-10 CTR on money pages (Authority ‚Üí Behaviour table, status = Poor)',
              link: '#authority-top-pages-section'
            });
          }
          if (authorityComponents.ranking < 30) {
            priorities.push({
              pillar: 'Authority',
              severity: 'medium',
              message: 'Improve average position and top-10 impression share',
              link: '#authority-top-pages-section'
            });
          }
        }
        
        // Content/Schema priorities
        if (schemaAuditData && schemaAuditData.status === 'ok' && schemaAuditData.data) {
          const schemaData = schemaAuditData.data;
          if (schemaData.coverage < 100) {
            // Use missingSchemaCount if available, otherwise calculate from coverage
            const missingCount = schemaData.missingSchemaCount || 
              (schemaData.totalPages ? Math.round((100 - schemaData.coverage) / 100 * schemaData.totalPages) : 0);
            priorities.push({
              pillar: 'Content',
              severity: 'medium',
              message: `Add schema to ${missingCount > 0 ? missingCount : 'remaining'} pages (Content/Schema ‚Üí coverage ${schemaData.coverage.toFixed(0)}%)`,
              link: '#pillarCards'
            });
          }
          const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
          const allTypes = new Set();
          if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
            schemaData.allDetectedTypes.forEach(type => {
              if (type) allTypes.add(type);
            });
          } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
            schemaData.schemaTypes.forEach(item => {
              if (item.type) allTypes.add(item.type);
            });
          }
          const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
          if (foundationPresent < 4) {
            priorities.push({
              pillar: 'Content',
              severity: 'high',
              message: `Add missing foundation schemas: ${foundationTypes.filter(t => !allTypes.has(t)).join(', ')}`,
              link: '#pillarCards'
            });
          }
        }
        
        // Locations priorities
        if (localSignalsData) {
          if (localSignalsData.napConsistencyScore < 100) {
            priorities.push({
              pillar: 'Locations',
              severity: 'medium',
              message: `Improve NAP consistency (currently ${localSignalsData.napConsistencyScore}%)`,
              link: '#pillarCards'
            });
          }
          const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
          if (serviceAreasCount < 5) {
            priorities.push({
              pillar: 'Locations',
              severity: 'low',
              message: `Add more service areas to Google Business Profile (currently ${serviceAreasCount}, target: 5+)`,
              link: '#pillarCards'
            });
          }
        }
        
        // Sort by severity (high > medium > low) and limit to top 5
        const severityOrder = { high: 3, medium: 2, low: 1 };
        return priorities
          .sort((a, b) => severityOrder[b.severity] - severityOrder[a.severity])
          .slice(0, 5);
      };
      
      const priorities = getPriorities(scores, schemaAudit, localSignalsData, scores.authorityComponents);
      
      healthDashboard.innerHTML = `
        <div style="background: white; padding: 2rem; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-bottom: 2rem;">
          <!-- Section Title -->
          <h2 style="font-size: 2rem; font-weight: 700; color: #1e293b; margin-bottom: 2rem; text-align: center; letter-spacing: -0.02em;">
            Site AI Health Score
          </h2>
          <!-- AI GEO Health Top Card -->
          <div style="text-align: center; margin-bottom: 3rem; padding: 2rem 0; border-bottom: 2px solid #e2e8f0;">
            <div style="display: flex; align-items: center; justify-content: center; gap: 4rem; margin-bottom: 2rem; flex-wrap: wrap;">
              <!-- Circular Progress Ring - Speedometer Style -->
              <div style="position: relative; width: 340px; height: 340px; margin: 0 auto;">
                ${(() => {
                  const score = aiGeoHealth.aiGeoScore;
                  const center = 170;
                  const radius = 140;
                  const strokeWidth = 18;
                  const normalizedRadius = radius - strokeWidth / 2;
                  const circumference = normalizedRadius * 2 * Math.PI;
                  
                  // Determine colors based on status
                  const color = aiGeoHealth.aiGeoStatus === 'green' ? '#10b981' : 
                               aiGeoHealth.aiGeoStatus === 'amber' ? '#f59e0b' : '#ef4444';
                  const bgColor = aiGeoHealth.aiGeoStatus === 'green' ? '#d1fae5' : 
                                 aiGeoHealth.aiGeoStatus === 'amber' ? '#fef3c7' : '#fee2e2';
                  
                  // Angle calculations: 0% at 12:05 (-85¬∞), 50% at 6pm (90¬∞), 100% at 12pm (-90¬∞)
                  // Progress goes clockwise from 0% to 100%
                  const startAngle = -85; // 12:05 position (5 minutes past 12)
                  const endAngle = -90; // 12pm position
                  const angleRange = 360 - 5; // Full circle minus 5¬∞ gap
                  
                  // Segment lengths as percentages of circumference
                  const redLength = circumference * 0.5;      // 0-50%
                  const amberLength = circumference * 0.2;     // 50-70%
                  const greenLength = circumference * 0.3;      // 70-100%
                  
                  // Calculate dash offsets to position segments correctly
                  // Start from 12:05, so we need to offset by the start angle
                  const startOffset = (startAngle + 90) / 360 * circumference;
                  
                  return `
                    <svg width="340" height="340" style="filter: drop-shadow(0 4px 12px rgba(0,0,0,0.08));">
                      <!-- Background circle -->
                      <circle
                        cx="${center}"
                        cy="${center}"
                        r="${normalizedRadius}"
                        fill="none"
                        stroke="#f1f5f9"
                        stroke-width="${strokeWidth}"
                      />
                      
                      <!-- Red segment: 0-50% -->
                      <circle
                        cx="${center}"
                        cy="${center}"
                        r="${normalizedRadius}"
                        fill="none"
                        stroke="#ef4444"
                        stroke-width="${strokeWidth}"
                        stroke-dasharray="${redLength} ${circumference - redLength}"
                        stroke-dashoffset="${-startOffset}"
                        stroke-linecap="round"
                        transform="rotate(-90 ${center} ${center})"
                      />
                      
                      <!-- Amber segment: 50-70% -->
                      <circle
                        cx="${center}"
                        cy="${center}"
                        r="${normalizedRadius}"
                        fill="none"
                        stroke="#f59e0b"
                        stroke-width="${strokeWidth}"
                        stroke-dasharray="${amberLength} ${circumference - amberLength}"
                        stroke-dashoffset="${-startOffset - redLength}"
                        stroke-linecap="round"
                        transform="rotate(-90 ${center} ${center})"
                      />
                      
                      <!-- Green segment: 70-100% -->
                      <circle
                        cx="${center}"
                        cy="${center}"
                        r="${normalizedRadius}"
                        fill="none"
                        stroke="#10b981"
                        stroke-width="${strokeWidth}"
                        stroke-dasharray="${greenLength} ${circumference - greenLength}"
                        stroke-dashoffset="${-startOffset - redLength - amberLength}"
                        stroke-linecap="round"
                        transform="rotate(-90 ${center} ${center})"
                      />
                      
                      <!-- Progress indicator (current score) - thicker overlay -->
                      ${score > 0 ? (() => {
                        const progressLength = (score / 100) * circumference * (angleRange / 360);
                        const progressOffset = circumference - progressLength + startOffset;
                        return `
                          <circle
                            cx="${center}"
                            cy="${center}"
                            r="${normalizedRadius}"
                            fill="none"
                            stroke="${color}"
                            stroke-width="${strokeWidth + 3}"
                            stroke-dasharray="${progressLength} ${circumference}"
                            stroke-dashoffset="${progressOffset}"
                            stroke-linecap="round"
                            opacity="0.95"
                            transform="rotate(-90 ${center} ${center})"
                            style="transition: stroke-dashoffset 1.2s cubic-bezier(0.4, 0, 0.2, 1); filter: drop-shadow(0 0 10px ${color}70);"
                          />
                        `;
                      })() : ''}
                      
                      <!-- Proportional tick marks (every 10%) -->
                      <g>
                        ${Array.from({ length: 11 }, (_, i) => {
                          const value = i * 10;
                          const angle = startAngle + (value / 100) * angleRange;
                          const rad = (angle * Math.PI) / 180;
                          const isMajor = value % 50 === 0;
                          const tickLength = isMajor ? 20 : 12;
                          const tickWidth = isMajor ? 3 : 2;
                          
                          const tickX1 = center + (normalizedRadius - tickLength) * Math.cos(rad);
                          const tickY1 = center + (normalizedRadius - tickLength) * Math.sin(rad);
                          const tickX2 = center + (normalizedRadius + tickLength) * Math.cos(rad);
                          const tickY2 = center + (normalizedRadius + tickLength) * Math.sin(rad);
                          
                          return `
                            <line x1="${tickX1}" y1="${tickY1}" 
                                  x2="${tickX2}" y2="${tickY2}" 
                                  stroke="${isMajor ? '#1e293b' : '#94a3b8'}" 
                                  stroke-width="${tickWidth}" 
                                  stroke-linecap="round"/>
                          `;
                        }).join('')}
                      </g>
                      
                      <!-- Major labels: 0%, 50%, 100% -->
                      <g>
                        ${(() => {
                          const majorMarkers = [
                            { value: 0, angle: startAngle },      // 12:05
                            { value: 50, angle: startAngle + angleRange * 0.5 },  // 6pm
                            { value: 100, angle: startAngle + angleRange }        // 12pm
                          ];
                          
                          return majorMarkers.map(m => {
                            const rad = (m.angle * Math.PI) / 180;
                            const labelOffset = 38;
                            const labelX = center + (normalizedRadius + labelOffset) * Math.cos(rad);
                            const labelY = center + (normalizedRadius + labelOffset) * Math.sin(rad);
                            
                            // Determine color for label
                            const labelColor = m.value === 0 ? '#ef4444' : m.value === 50 ? '#f59e0b' : '#10b981';
                            
                            return `
                              <text x="${labelX}" y="${labelY}" 
                                    text-anchor="middle" dominant-baseline="middle"
                                    fill="${labelColor}" 
                                    font-size="16" font-weight="700">${m.value}</text>
                            `;
                          }).join('');
                        })()}
                      </g>
                    </svg>
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; width: 100%; pointer-events: none;">
                      <div style="font-size: 5.5rem; font-weight: 800; color: ${color}; line-height: 1; margin-bottom: 0.5rem; letter-spacing: -0.03em; text-shadow: 0 2px 12px ${color}25;">
                        ${score}
                      </div>
                      <div style="font-size: 0.9rem; color: #64748b; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; margin-bottom: 0.75rem;">
                        AI GEO Score
                      </div>
                      <div style="padding: 0.5rem 1rem; background: ${bgColor}; border-radius: 24px; display: inline-block;">
                        <span style="font-size: 0.875rem; color: ${color}; font-weight: 700;">
                          ${aiGeoHealth.aiGeoStatus === 'green' ? '‚úì Excellent' : aiGeoHealth.aiGeoStatus === 'amber' ? '‚ö† Good' : '‚úó Needs Work'}
                        </span>
                      </div>
                    </div>
                  `;
                })()}
              </div>
              <div style="display: flex; flex-direction: column; align-items: center; gap: 1.5rem; justify-content: center;">
                <div>
                  <span class="rag-badge ${aiGeoHealth.aiGeoStatus}" style="display: inline-block; padding: 0.75rem 1.5rem; border-radius: 8px; font-size: 1.25rem; font-weight: 600;">
                    ${aiGeoHealth.aiGeoStatus === 'green' ? 'Green' : aiGeoHealth.aiGeoStatus === 'amber' ? 'Amber' : 'Red'}
                  </span>
                </div>
                <div style="text-align: center;">
                  <div style="font-size: 0.9rem; color: #64748b; margin-bottom: 0.5rem; font-weight: 500;">AI summary likelihood:</div>
                  <span style="display: inline-block; padding: 0.5rem 1rem; border-radius: 6px; font-size: 1rem; font-weight: 600; background: ${aiGeoHealth.aiSummaryLikelihood === 'high' ? '#d1fae5' : aiGeoHealth.aiSummaryLikelihood === 'medium' ? '#fef3c7' : '#fee2e2'}; color: ${aiGeoHealth.aiSummaryLikelihood === 'high' ? '#065f46' : aiGeoHealth.aiSummaryLikelihood === 'medium' ? '#92400e' : '#991b1b'};">
                    ${aiGeoHealth.aiSummaryLikelihood === 'high' ? 'High' : aiGeoHealth.aiSummaryLikelihood === 'medium' ? 'Medium' : 'Low'}
                  </span>
                  <span style="font-size: 0.75rem; color: #94a3b8; cursor: help; margin-left: 0.5rem;" title="High = score ‚â•75 and solid content/coverage. Medium = score ‚â•55. Low = score <55.">‚ÑπÔ∏è</span>
                </div>
              </div>
            </div>
            <p style="margin: 0; font-size: 0.95rem; color: #475569; font-weight: 500;">
              Based on Authority, Content & Schema, Coverage, Diversity and Locations.
            </p>
          </div>
          
          <!-- Pillar Snapshot Strip -->
          <div style="margin-bottom: 2rem;">
            <h3 style="margin: 0 0 1rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">Pillar Overview</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 1rem;">
              ${[
                { key: 'authority', name: 'Authority', score: authorityScore },
                { key: 'content', name: 'Content', score: contentScore },
                { key: 'coverage', name: 'Coverage', score: coverageScore },
                { key: 'diversity', name: 'Diversity', score: diversityScore },
                { key: 'locations', name: 'Locations', score: locationsScore }
              ].map(({ key, name, score }) => {
                const rag = getRAGStatus(score);
                const hint = getPillarHint(key, score, scores, schemaAudit, localSignalsData);
                const pillarColor = key === 'authority' ? '#99004C' : key === 'content' ? 'rgba(107, 114, 128, 1)' : key === 'coverage' ? 'rgba(37, 99, 235, 1)' : key === 'diversity' ? 'rgba(147, 51, 234, 1)' : '#00FFFF';
                return `
                  <div onclick="document.getElementById('pillarCards')?.scrollIntoView({ behavior: 'smooth', block: 'start' });" style="background: ${rag.status === 'green' ? '#f0fdf4' : rag.status === 'amber' ? '#fffbeb' : '#fef2f2'}; border: 2px solid ${rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444'}; border-radius: 8px; padding: 1rem; cursor: pointer; transition: all 0.2s; text-align: center;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.15)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                      <div style="width: 12px; height: 12px; background: ${pillarColor}; border-radius: 2px;"></div>
                      <h4 style="margin: 0; font-size: 0.9rem; font-weight: 600; color: #1e293b;">${name}</h4>
                    </div>
                    <div style="font-size: 1.5rem; font-weight: 700; color: ${rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444'}; margin-bottom: 0.25rem;">${Math.round(score)}</div>
                    <span class="rag-badge ${rag.status}" style="display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; margin-bottom: 0.5rem;">${rag.label}</span>
                    <p style="margin: 0; font-size: 0.75rem; color: #64748b; line-height: 1.4;">${hint}</p>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
          
          <!-- This Month's Priorities -->
          ${priorities.length > 0 ? `
          <div>
            <h3 style="margin: 0 0 1rem 0; font-size: 1.1rem; font-weight: 700; color: #1e293b;">This Month's Priorities</h3>
            <div style="background: #f8f9fa; border-radius: 8px; padding: 1rem; border-left: 4px solid #ef4444;">
              <ul style="margin: 0; padding-left: 1.5rem; list-style: none;">
                ${priorities.map((p, idx) => {
                  const severityColor = p.severity === 'high' ? '#ef4444' : p.severity === 'medium' ? '#f59e0b' : '#10b981';
                  return `
                    <li style="margin-bottom: ${idx < priorities.length - 1 ? '0.75rem' : '0'}; padding-left: 0.5rem; position: relative;">
                      <span style="position: absolute; left: -1.5rem; color: ${severityColor}; font-weight: 700;">‚Ä¢</span>
                      <a href="${p.link}" style="color: #1e293b; text-decoration: none; font-weight: 500; border-bottom: 1px solid transparent; transition: border-color 0.2s;" onmouseover="this.style.borderBottomColor='#1e293b';" onmouseout="this.style.borderBottomColor='transparent';">
                        ${p.message}
                      </a>
                    </li>
                  `;
                }).join('')}
              </ul>
            </div>
          </div>
          ` : ''}
        </div>
      `;
      
      // Insert health dashboard before pillar cards
      const pillarCards = document.getElementById('pillarCards');
      if (!pillarCards) {
        debugLog('‚úó Pillar cards container not found', 'error');
        console.error('Pillar cards container (id="pillarCards") not found in DOM');
        return;
      }
      debugLog('‚úì Pillar cards container found', 'success');
      
      // Remove existing health dashboard if present
      const existingHealth = document.getElementById('ai-geo-health-dashboard');
      if (existingHealth) {
        existingHealth.remove();
      }
      
      // Insert health dashboard before pillar cards
      pillarCards.parentNode.insertBefore(healthDashboard, pillarCards);
      debugLog('‚úì AI GEO Health Dashboard created', 'success');
      
      // Circular progress ring is SVG-based, no additional drawing needed
      
      // Clear pillar cards for fresh render
      pillarCards.innerHTML = '';
      
      const orderedPillars = getOrderedPillars(scores);
      debugLog(`Creating ${orderedPillars.length} pillar cards from scores: ${JSON.stringify(scores)}`, 'info');
      
      if (orderedPillars.length === 0) {
        debugLog('‚ö† No pillars found in scores object!', 'warn');
        console.warn('No pillars found in scores:', scores);
      }
      
      orderedPillars.forEach(([key, scoreValue]) => {
        // Handle new Authority structure (object with score and bySegment) or legacy (number)
        // Note: getOrderedPillars extracts the score, so we need to get bySegment from original scores object
        let score = scoreValue;
        let authorityBySegment = null;
        if (key === 'authority') {
          // Get the original Authority object from scores (not from getOrderedPillars result)
          const authorityObj = scores.authority;
          if (typeof authorityObj === 'object' && authorityObj !== null) {
            score = authorityObj.score || 0;
            authorityBySegment = authorityObj.bySegment || null;
          }
        }
        
        const rag = getRAGStatus(score);
        const card = document.createElement('div');
        card.className = 'pillar-card';
        
        // Get pillar description with data source info (dynamic based on whether we have real data)
        let localEntityDesc, serviceAreaDesc;
        if (hasLocalSignals && localSignalsData) {
          const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
          const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
          const locationsCount = localSignalsData.locations?.length || 0;
          localEntityDesc = `How clearly your business and you as a person are recognised as entities by AI search systems. <strong>Data Source:</strong> ‚úÖ Live data from Google Business Profile API. <strong>Data Checked:</strong> NAP consistency (${napScore}%), knowledge panel (${localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected'}), locations (${locationsCount}).`;
          serviceAreaDesc = `How well AI understands where you operate and which regions you serve. <strong>Data Source:</strong> ‚úÖ Live data from Google Business Profile API. <strong>Data Checked:</strong> Service areas (${serviceAreasCount}), NAP consistency (${napScore}%).`;
        } else {
          localEntityDesc = 'How clearly your business and you as a person are recognised as entities by AI search systems. <strong>Data Source:</strong> ‚ö†Ô∏è Currently derived from search performance (GSC position/CTR). Real local signals API integration pending.';
          serviceAreaDesc = 'How well AI understands where you operate and which regions you serve. <strong>Data Source:</strong> ‚ö†Ô∏è Currently derived from Local Entity score. Real service area data from Google Business Profile pending.';
        }
        
        const descriptions = {
          localEntity: localEntityDesc,
          serviceArea: serviceAreaDesc,
          authority: 'E-A-T (Experience, Expertise, Authoritativeness, Trustworthiness): Perceived expertise and trust in the topic space. <strong>Calculation:</strong> Behaviour (40%) + Ranking (20%) + Backlinks (20%) + Reviews (20%). <strong>Data Source:</strong> ‚úÖ Live data from Google Search Console, Google Business Profile API, historic Trustpilot reviews snapshot, and backlink CSV upload.',
          visibility: 'How prominently your content appears in AI-powered search results and featured snippets. <strong>Data Source:</strong> ‚úÖ Live data from Google Search Console (impressions, clicks, position, SERP features).',
          contentSchema: 'Quality and completeness of structured data markup across your domain. <strong>Data Source:</strong> ‚úÖ Live data from schema audit. <strong>Calculation:</strong> Foundation schemas (30%) + Rich Results (35%) + Coverage (20%) + Diversity (15%).'
        };
        
        // Build breakdown and details sections for all pillars (for consistency)
        let pillarBreakdown = '';
        let pillarDetails = '';
        let authorityBreakdown = '';
        let authorityDetails = '';
        let authorityModeToggle = '';
        
        // Get saved audit data for breakdown calculations (reuse saved from function start to avoid redeclaration)
        // Use schemaAudit parameter if available, otherwise fall back to saved
        const schemaAuditData = schemaAudit || saved?.schemaAudit;
        const searchDataForBreakdown = data || saved?.searchData;
        // Note: hasLocalSignals and localSignalsData are already defined at function level (line 3688-3689), reuse them
        
        if (key === 'authority') {
          const savedAudit = loadAuditResults();
          const backlinkMetrics = savedAudit?.backlinkMetrics;
          const localSignals = savedAudit?.localSignals;
          // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
          const siteReviews = getTrustpilotSnapshot(savedAudit?.siteReviews);
          const searchData = savedAudit?.searchData;
          
          // Authority mode state (stored per card instance)
          const modeId = `authority-mode-${Date.now()}`;
          let currentMode = 'all'; // Default mode
          
          // Get selected Authority scores based on mode
          const getAuthorityForMode = (mode) => {
            if (authorityBySegment && authorityBySegment[mode]) {
              return authorityBySegment[mode];
            }
            // Fallback to all or legacy structure
            if (authorityBySegment && authorityBySegment.all) {
              return authorityBySegment.all;
            }
            // Legacy fallback
            const components = scores.authorityComponents || {};
            return {
              total: score,
              behaviour: components.behaviour || 0,
              ranking: components.ranking || 0,
              backlinks: components.backlinks || 0,
              reviews: components.reviews || 0
            };
          };
          
          // Get current Authority data
          let selectedAuthority = getAuthorityForMode(currentMode);
          
          // Build mode toggle UI (only if bySegment is available)
          if (authorityBySegment) {
            authorityModeToggle = `
              <div class="authority-mode-toggle" style="margin-top: 0.5rem; margin-bottom: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem;">
                <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                  <span style="font-weight: 600; color: #666;">Mode:</span>
                  <button id="${modeId}-all" class="authority-mode-btn" data-mode="all" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: #10b981; color: white; cursor: pointer; font-size: 0.75rem;">
                    All pages
                  </button>
                  <button id="${modeId}-nonEducation" class="authority-mode-btn" data-mode="nonEducation" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
                    Exclude education
                  </button>
                  <button id="${modeId}-money" class="authority-mode-btn" data-mode="money" style="padding: 0.25rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: white; color: #666; cursor: pointer; font-size: 0.75rem;">
                    Money pages only
                  </button>
                </div>
              </div>
            `;
          }
          
          // Build breakdown display with color-coded scores (will be updated by mode toggle)
          const updateAuthorityDisplay = () => {
            const mode = card._authorityMode || currentMode;
            selectedAuthority = getAuthorityForMode(mode);
            const breakdownDiv = document.getElementById(`${modeId}-breakdown`);
            const scoreDiv = document.getElementById(`${modeId}-score`);
            if (breakdownDiv) {
              breakdownDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('Behaviour', selectedAuthority.behaviour)}
                  ${formatComponentScore('Ranking', selectedAuthority.ranking)}
                  ${formatComponentScore('Backlinks', selectedAuthority.backlinks)}
                  ${formatComponentScore('Reviews', selectedAuthority.reviews)}
                </div>
              `;
            }
            if (scoreDiv) {
              scoreDiv.textContent = Math.round(selectedAuthority.total);
              const newRag = getRAGStatus(selectedAuthority.total);
              scoreDiv.className = `pillar-score rag-${newRag.status}`;
            }
          };
          
          // Initial breakdown (with consistent spacing for alignment)
          authorityBreakdown = `
            <div id="${modeId}-breakdown" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                ${formatComponentScore('Behaviour', selectedAuthority.behaviour)}
                ${formatComponentScore('Ranking', selectedAuthority.ranking)}
                ${formatComponentScore('Backlinks', selectedAuthority.backlinks)}
                ${formatComponentScore('Reviews', selectedAuthority.reviews)}
              </div>
            </div>
          `;
          
          // Store update function for mode toggle handlers
          card._updateAuthorityDisplay = updateAuthorityDisplay;
          card._authorityMode = currentMode;
          card._authorityBySegment = authorityBySegment;
          card._modeId = modeId;
          
          // Build details panel (hidden by default, toggled by button)
          const detailsId = `authority-details-${Date.now()}`;
          const buttonId = `authority-details-btn-${Date.now()}`;
          
          // Get GSC metrics for details (segment-aware)
          // Store queryPages and searchData on card for access in update functions
          card._queryPages = searchData?.queryPages || [];
          card._topQueries = searchData?.topQueries || [];
          const queryPages = card._queryPages;
          const topQueries = card._topQueries;
          
          // Function to calculate GSC metrics for a specific segment
          const getGSCMetricsForSegment = (mode, queryPagesData, topQueriesData) => {
            let dataToUse = [];
            
            // Use the passed data (from card storage) to ensure we have latest
            const qp = queryPagesData || queryPages;
            const tq = topQueriesData || topQueries;
            
            if (qp && qp.length > 0) {
              // Use queryPages with segmentation
              let filtered = qp;
              if (mode === 'nonEducation') {
                filtered = qp.filter(row => {
                  const segment = classifyPageSegment(row.page || row.url || '/');
                  return segment !== PageSegment.EDUCATION;
                });
              } else if (mode === 'money') {
                filtered = qp.filter(row => {
                  const segment = classifyPageSegment(row.page || row.url || '/');
                  return segment === PageSegment.MONEY;
                });
              }
              
              debugLog(`üìä GSC Metrics for ${mode}: Filtered ${filtered.length} rows from ${qp.length} total queryPages`, 'info');
              
              // Convert to query format for calculation
              dataToUse = filtered.map(row => ({
                query: row.query || '',
                clicks: row.clicks || 0,
                impressions: row.impressions || 0,
                ctr: (row.ctr || 0) / 100,
                position: row.position || 0
              }));
            } else {
              // Fallback to topQueries (all pages)
              dataToUse = tq.map(q => ({
                query: q.query || '',
                clicks: q.clicks || 0,
                impressions: q.impressions || 0,
                ctr: (q.ctr || 0) / 100,
                position: q.position || 0
              }));
            }
            
            const rankingQueries = dataToUse.filter(q => q.position > 0 && q.position <= 20 && q.impressions > 0);
            const top10Queries = rankingQueries.filter(q => q.position <= 10);
            
            let siteCtr = 0;
            let top10Ctr = 0;
            let avgPosition = 0;
            let top10ImpressionShare = 0;
            
            if (rankingQueries.length > 0) {
              const totalClicks = rankingQueries.reduce((s, q) => s + (q.clicks || 0), 0);
              const totalImpr = rankingQueries.reduce((s, q) => s + (q.impressions || 0), 0);
              siteCtr = totalImpr > 0 ? (totalClicks / totalImpr) * 100 : 0;
              
              const top10Clicks = top10Queries.reduce((s, q) => s + (q.clicks || 0), 0);
              const top10Impr = top10Queries.reduce((s, q) => s + (q.impressions || 0), 0);
              top10Ctr = top10Impr > 0 ? (top10Clicks / top10Impr) * 100 : 0;
              
              avgPosition = totalImpr > 0
                ? rankingQueries.reduce((s, q) => s + (q.position || 0) * (q.impressions || 0), 0) / totalImpr
                : 0;
              
              top10ImpressionShare = totalImpr > 0 ? (top10Impr / totalImpr) * 100 : 0;
            }
            
            return { siteCtr, top10Ctr, avgPosition, top10ImpressionShare };
          };
          
          // Get initial metrics (all pages)
          let gscMetrics = getGSCMetricsForSegment(currentMode, queryPages, topQueries);
          let siteCtr = gscMetrics.siteCtr;
          let top10Ctr = gscMetrics.top10Ctr;
          let avgPosition = gscMetrics.avgPosition;
          let top10ImpressionShare = gscMetrics.top10ImpressionShare;
          
          // Function to update GSC metrics display
          const updateGSCMetrics = (mode) => {
            // Get fresh data from card storage
            const qp = card._queryPages || [];
            const tq = card._topQueries || [];
            const metrics = getGSCMetricsForSegment(mode, qp, tq);
            const metricsDiv = document.getElementById(`${modeId}-gsc-metrics`);
            if (metricsDiv) {
              debugLog(`üìä Updating GSC metrics for mode ${mode}: CTR=${metrics.siteCtr.toFixed(2)}%, Position=${metrics.avgPosition.toFixed(1)}`, 'info');
              metricsDiv.innerHTML = `
                <div style="margin-bottom: 0.5rem;"><strong>Behaviour & Ranking:</strong></div>
                <div style="margin-bottom: 0.25rem; font-size: 0.7rem; color: #999;">Segment: ${mode === 'all' ? 'All pages' : mode === 'nonEducation' ? 'Exclude education (blogs / free course)' : 'Money pages only'}</div>
                <div>Site CTR (ranking queries): ${metrics.siteCtr.toFixed(2)}%</div>
                <div>Top-10 CTR: ${metrics.top10Ctr.toFixed(2)}%</div>
                <div>Avg position (ranking): ${metrics.avgPosition.toFixed(1)}</div>
                <div>Top-10 impression share: ${metrics.top10ImpressionShare.toFixed(1)}%</div>
              `;
            } else {
              debugLog(`‚ö† GSC metrics div not found: ${modeId}-gsc-metrics`, 'warn');
            }
          };
          
          // Store update function and data
          card._updateGSCMetrics = updateGSCMetrics;
          card._getGSCMetricsForSegment = getGSCMetricsForSegment;
          
          // Get review data
          const gbpRating = (localSignals && localSignals.status === 'ok' && localSignals.data) 
            ? (localSignals.data.gbpRating !== null ? localSignals.data.gbpRating : null)
            : null;
          const gbpReviewCount = (localSignals && localSignals.status === 'ok' && localSignals.data) 
            ? (localSignals.data.gbpReviewCount !== null ? localSignals.data.gbpReviewCount : null)
            : null;
          const siteRating = siteReviews?.siteRating !== null ? siteReviews?.siteRating : null;
          const siteReviewCount = siteReviews?.siteReviewCount !== null ? siteReviews?.siteReviewCount : null;
          
          authorityDetails = `
            <div style="margin-top: 0.5rem;">
              <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                Show details
              </button>
              <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                <div id="${modeId}-gsc-metrics">
                  <div style="margin-bottom: 0.5rem;"><strong>Behaviour & Ranking:</strong></div>
                  <div style="margin-bottom: 0.25rem; font-size: 0.7rem; color: #999;">Segment: ${currentMode === 'all' ? 'All pages' : currentMode === 'nonEducation' ? 'Exclude education (blogs / free course)' : 'Money pages only'}</div>
                  <div>Site CTR (ranking queries): ${siteCtr.toFixed(2)}%</div>
                  <div>Top-10 CTR: ${top10Ctr.toFixed(2)}%</div>
                  <div>Avg position (ranking): ${avgPosition.toFixed(1)}</div>
                  <div>Top-10 impression share: ${top10ImpressionShare.toFixed(1)}%</div>
                </div>
                ${backlinkMetrics ? `
                  <div style="margin-top: 0.75rem; margin-bottom: 0.5rem;"><strong>Backlink Metrics:</strong></div>
                  <div>Referring domains: ${backlinkMetrics.referringDomains || 0}</div>
                  <div>Total backlinks: ${backlinkMetrics.totalBacklinks || 0}</div>
                  <div>Follow ratio: ${backlinkMetrics.followRatio ? Math.round(backlinkMetrics.followRatio * 100) : 50}%</div>
                ` : `
                  <div style="margin-top: 0.75rem; margin-bottom: 0.5rem;"><strong>Backlink Metrics:</strong></div>
                  <div>No backlink data uploaded</div>
                `}
                <div style="margin-top: 0.75rem; margin-bottom: 0.5rem;"><strong>Review Metrics:</strong></div>
                <div>GBP rating: ${gbpRating !== null ? gbpRating.toFixed(2) : 'N/A'} (${gbpReviewCount !== null ? gbpReviewCount : 'N/A'} reviews)</div>
                <div>Trustpilot (snapshot): ${siteRating !== null ? siteRating.toFixed(2) : 'N/A'} (${siteReviewCount !== null ? siteReviewCount : 'N/A'} reviews)</div>
              </div>
            </div>
          `;
          
          // Store topPages data on card for access in update functions
          card._topPages = {
            all: authorityBySegment?.all?.topPages || [],
            nonEducation: authorityBySegment?.nonEducation?.topPages || [],
            money: authorityBySegment?.money?.topPages || []
          };
          
          // Function to render top pages table
          function renderTopPagesTable(mode, authorityBySegment) {
            const topPages = mode === 'all' 
              ? (authorityBySegment?.all?.topPages || [])
              : mode === 'nonEducation'
              ? (authorityBySegment?.nonEducation?.topPages || [])
              : (authorityBySegment?.money?.topPages || []);
            
            if (!topPages || topPages.length === 0) {
              return '<div style="font-size: 0.75rem; color: #999;">No page data available for this segment.</div>';
            }
            
            const segmentLabel = mode === 'all' 
              ? 'All pages'
              : mode === 'nonEducation'
              ? 'Exclude education (blogs / free course)'
              : 'Money pages only';
            
            const copyButtonId = `${modeId}-copy-urls`;
            
            let tableHtml = `
              <div style="margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                <h4 style="margin: 0; font-size: 0.95rem; font-weight: 600;">Top pages in this segment (by impressions)</h4>
                <button id="${copyButtonId}" type="button" style="font-size: 0.8rem; padding: 0.35rem 0.6rem; border-radius: 4px; border: 1px solid #ddd; background: white; cursor: pointer; color: #666;">
                  Copy URLs
                </button>
              </div>
              <p style="margin: 0 0 0.5rem 0; font-size: 0.75rem; color: #999;">Segment: ${segmentLabel}</p>
              <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse; font-size: 0.75rem;">
                  <thead>
                    <tr style="border-bottom: 1px solid #e2e8f0;">
                      <th style="text-align: left; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">#</th>
                      <th style="text-align: left; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">URL</th>
                      <th style="text-align: right; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">CTR</th>
                      <th style="text-align: right; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">Impr.</th>
                      <th style="text-align: right; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">Clicks</th>
                      <th style="text-align: right; padding: 0.25rem 0.4rem; font-weight: 600; color: #666;">Avg pos.</th>
                    </tr>
                  </thead>
                  <tbody>
            `;
            
            topPages.forEach((page, idx) => {
              tableHtml += `
                <tr style="border-bottom: 1px solid #f1f5f9;">
                  <td style="padding: 0.25rem 0.4rem; color: #666;">${idx + 1}</td>
                  <td style="padding: 0.25rem 0.4rem; word-break: break-all; color: #333;">${page.url}</td>
                  <td style="padding: 0.25rem 0.4rem; text-align: right; color: #666;">${page.ctr.toFixed(2)}%</td>
                  <td style="padding: 0.25rem 0.4rem; text-align: right; color: #666;">${page.impressions.toLocaleString()}</td>
                  <td style="padding: 0.25rem 0.4rem; text-align: right; color: #666;">${page.clicks.toLocaleString()}</td>
                  <td style="padding: 0.25rem 0.4rem; text-align: right; color: #666;">${page.avgPosition.toFixed(1)}</td>
                </tr>
              `;
            });
            
            tableHtml += `
                  </tbody>
                </table>
              </div>
            `;
            
            // Store copy button ID and current mode for later event handler attachment
            card._copyButtonId = copyButtonId;
            card._topPagesForCopy = topPages;
            card._currentTopPagesMode = mode;
            
            return tableHtml;
          }
          
          // Function to update top pages table when mode changes
          const updateTopPagesTable = (mode) => {
            const topPagesDiv = document.getElementById(`${modeId}-top-pages`);
            if (topPagesDiv && authorityBySegment) {
              topPagesDiv.innerHTML = renderTopPagesTable(mode, authorityBySegment);
              
              // Re-attach copy button handler
              setTimeout(() => {
                const copyBtn = document.getElementById(card._copyButtonId);
                if (copyBtn) {
                  // Remove existing listener if any
                  const newCopyBtn = copyBtn.cloneNode(true);
                  copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
                  
                  newCopyBtn.addEventListener('click', async () => {
                    const currentTopPages = mode === 'all'
                      ? (authorityBySegment?.all?.topPages || [])
                      : mode === 'nonEducation'
                      ? (authorityBySegment?.nonEducation?.topPages || [])
                      : (authorityBySegment?.money?.topPages || []);
                    
                    const text = currentTopPages.map(p => p.url).join('\n');
                    try {
                      await navigator.clipboard.writeText(text);
                      newCopyBtn.textContent = 'Copied!';
                      newCopyBtn.style.color = '#10b981';
                      setTimeout(() => {
                        newCopyBtn.textContent = 'Copy URLs';
                        newCopyBtn.style.color = '#666';
                      }, 2000);
                    } catch (err) {
                      console.error('Failed to copy URLs:', err);
                      newCopyBtn.textContent = 'Copy failed';
                      setTimeout(() => {
                        newCopyBtn.textContent = 'Copy URLs';
                      }, 2000);
                    }
                  });
                }
              }, 0);
            }
          };
          
          // Store update function
          card._updateTopPagesTable = updateTopPagesTable;
          
          // Add click handlers for details toggle and mode toggle
          setTimeout(() => {
            const btn = document.getElementById(buttonId);
            const details = document.getElementById(detailsId);
            if (btn && details) {
              btn.addEventListener('click', () => {
                const isVisible = details.style.display !== 'none';
                details.style.display = isVisible ? 'none' : 'block';
                btn.textContent = isVisible ? 'Show details' : 'Hide details';
              });
            }
            
            // Add initial copy button handler
            const copyBtn = document.getElementById(card._copyButtonId);
            if (copyBtn) {
              copyBtn.addEventListener('click', async () => {
                const currentTopPages = currentMode === 'all'
                  ? (authorityBySegment?.all?.topPages || [])
                  : currentMode === 'nonEducation'
                  ? (authorityBySegment?.nonEducation?.topPages || [])
                  : (authorityBySegment?.money?.topPages || []);
                
                const text = currentTopPages.map(p => p.url).join('\n');
                try {
                  await navigator.clipboard.writeText(text);
                  copyBtn.textContent = 'Copied!';
                  copyBtn.style.color = '#10b981';
                  setTimeout(() => {
                    copyBtn.textContent = 'Copy URLs';
                    copyBtn.style.color = '#666';
                  }, 2000);
                } catch (err) {
                  console.error('Failed to copy URLs:', err);
                  copyBtn.textContent = 'Copy failed';
                  setTimeout(() => {
                    copyBtn.textContent = 'Copy URLs';
                  }, 2000);
                }
              });
            }
            
            // Add mode toggle handlers
            if (authorityBySegment) {
              ['all', 'nonEducation', 'money'].forEach(mode => {
                const modeBtn = document.getElementById(`${modeId}-${mode}`);
                if (modeBtn) {
                  modeBtn.addEventListener('click', () => {
                    // Update current mode
                    currentMode = mode;
                    card._authorityMode = mode;
                    
                    // Update button styles
                    ['all', 'nonEducation', 'money'].forEach(m => {
                      const btn = document.getElementById(`${modeId}-${m}`);
                      if (btn) {
                        if (m === mode) {
                          btn.style.background = '#10b981';
                          btn.style.color = 'white';
                        } else {
                          btn.style.background = 'white';
                          btn.style.color = '#666';
                        }
                      }
                    });
                    
                    // Update Authority score and breakdown
                    if (card._updateAuthorityDisplay) {
                      card._updateAuthorityDisplay();
                    }
                    
                    // Update GSC metrics
                    if (card._updateGSCMetrics) {
                      card._updateGSCMetrics(mode);
                    }
                    
                    // Update top pages section (full width, below pillars)
                    window.currentAuthorityMode = mode;
                    if (window.updateTopPagesSection) {
                      window.updateTopPagesSection(mode);
                    }
                    
                    debugLog(`üìä Authority mode changed to: ${mode === 'all' ? 'All pages' : mode === 'nonEducation' ? 'Exclude education' : 'Money pages only'}`, 'info');
                  });
                }
              });
            }
          }, 0);
        }
        
        // Build breakdown and details for other pillars (Content/Schema, Visibility, Local Entity, Service Area)
        if (key !== 'authority') {
          const breakdownId = `${key}-breakdown-${Date.now()}`;
          const detailsId = `${key}-details-${Date.now()}`;
          const buttonId = `${key}-details-btn-${Date.now()}`;
          
          if (key === 'contentSchema' && schemaAuditData && schemaAuditData.status === 'ok' && schemaAuditData.data) {
            const schemaData = schemaAuditData.data;
            const allTypes = new Set();
            if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
              schemaData.allDetectedTypes.forEach(type => { if (type) allTypes.add(type); });
            } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
              schemaData.schemaTypes.forEach(item => { if (item.type) allTypes.add(item.type); });
            }
            
            const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
            const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
            const foundationScore = (foundationPresent / foundationTypes.length) * 100;
            
            const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
            const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
            const richResultScore = (richEligibleCount / richResultTypes.length) * 100;
            
            const coverageScore = schemaData.coverage || 0;
            const uniqueTypesCount = allTypes.size;
            const diversityScore = Math.min((uniqueTypesCount / 15) * 100, 100);
            
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('Foundation', foundationScore)}
                  ${formatComponentScore('Rich Results', richResultScore)}
                  ${formatComponentScore('Coverage', coverageScore)}
                  ${formatComponentScore('Diversity', diversityScore)}
                </div>
              </div>
            `;
            
            pillarDetails = `
              <div style="margin-top: 0.5rem;">
                <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                  Show details
                </button>
                <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                  <div style="margin-bottom: 0.5rem;"><strong>Schema Details:</strong></div>
                  <div>Foundation schemas: ${foundationPresent}/4 (${foundationTypes.filter(t => allTypes.has(t)).join(', ') || 'none'})</div>
                  <div>Rich result types: ${richEligibleCount}/${richResultTypes.length} eligible</div>
                  <div>Coverage: ${coverageScore.toFixed(1)}% (${schemaData.pagesWithSchema || 0}/${schemaData.totalPages || 0} pages)</div>
                  <div>Type diversity: ${uniqueTypesCount} unique types</div>
                </div>
              </div>
            `;
            
            setTimeout(() => {
              const btn = document.getElementById(buttonId);
              const details = document.getElementById(detailsId);
              if (btn && details) {
                btn.addEventListener('click', () => {
                  const isVisible = details.style.display !== 'none';
                  details.style.display = isVisible ? 'none' : 'block';
                  btn.textContent = isVisible ? 'Show details' : 'Hide details';
                });
              }
            }, 0);
          } else if (key === 'visibility' && searchDataForBreakdown) {
            const avgPos = searchDataForBreakdown.averagePosition || 40;
            const clampedPos = Math.max(1, Math.min(40, avgPos));
            const scale = (clampedPos - 1) / 39;
            const posScore = 100 - scale * 90;
            
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('Position', clampScore(posScore))}
                  ${formatComponentScore('CTR', Math.min((searchDataForBreakdown.ctr || 0) / 0.10 * 100, 100))}
                </div>
              </div>
            `;
            
            pillarDetails = `
              <div style="margin-top: 0.5rem;">
                <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                  Show details
                </button>
                <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                  <div style="margin-bottom: 0.5rem;"><strong>GSC Metrics:</strong></div>
                  <div>Average position: ${avgPos.toFixed(1)}</div>
                  <div>CTR: ${(searchDataForBreakdown.ctr || 0).toFixed(2)}%</div>
                  <div>Total clicks: ${(searchDataForBreakdown.totalClicks || 0).toLocaleString()}</div>
                  <div>Total impressions: ${(searchDataForBreakdown.totalImpressions || 0).toLocaleString()}</div>
                </div>
              </div>
            `;
            
            setTimeout(() => {
              const btn = document.getElementById(buttonId);
              const details = document.getElementById(detailsId);
              if (btn && details) {
                btn.addEventListener('click', () => {
                  const isVisible = details.style.display !== 'none';
                  details.style.display = isVisible ? 'none' : 'block';
                  btn.textContent = isVisible ? 'Show details' : 'Hide details';
                });
              }
            }, 0);
          } else if (key === 'localEntity' && hasLocalSignals && localSignalsData) {
            const napScore = localSignalsData.napConsistencyScore || 0;
            const knowledgePanelScore = localSignalsData.knowledgePanelDetected ? 100 : 0;
            const locationsScore = (localSignalsData.locations?.length || 0) > 0 ? 100 : 0;
            
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('NAP Consistency', napScore)}
                  ${formatComponentScore('Knowledge Panel', knowledgePanelScore)}
                  ${formatComponentScore('Locations', locationsScore)}
                </div>
              </div>
            `;
            
            pillarDetails = `
              <div style="margin-top: 0.5rem;">
                <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                  Show details
                </button>
                <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                  <div style="margin-bottom: 0.5rem;"><strong>Business Profile Data:</strong></div>
                  <div>NAP consistency: ${napScore}%</div>
                  <div>Knowledge panel: ${localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected'}</div>
                  <div>Locations: ${localSignalsData.locations?.length || 0}</div>
                </div>
              </div>
            `;
            
            setTimeout(() => {
              const btn = document.getElementById(buttonId);
              const details = document.getElementById(detailsId);
              if (btn && details) {
                btn.addEventListener('click', () => {
                  const isVisible = details.style.display !== 'none';
                  details.style.display = isVisible ? 'none' : 'block';
                  btn.textContent = isVisible ? 'Show details' : 'Hide details';
                });
              }
            }, 0);
          } else if (key === 'serviceArea' && hasLocalSignals && localSignalsData) {
            const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
            const serviceAreasScore = serviceAreasCount >= 8 ? 100 : Math.min(100, serviceAreasCount * 12.5);
            const napScore = localSignalsData.napConsistencyScore || 0;
            
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                  ${formatComponentScore('Service Areas', serviceAreasScore)}
                  ${formatComponentScore('NAP Consistency', napScore)}
                </div>
              </div>
            `;
            
            pillarDetails = `
              <div style="margin-top: 0.5rem;">
                <button id="${buttonId}" type="button" style="font-size: 0.75rem; color: #3b82f6; text-decoration: underline; background: none; border: none; cursor: pointer; padding: 0;">
                  Show details
                </button>
                <div id="${detailsId}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem; color: #666; line-height: 1.6;">
                  <div style="margin-bottom: 0.5rem;"><strong>Service Area Data:</strong></div>
                  <div>Service areas: ${serviceAreasCount}</div>
                  <div>NAP consistency: ${napScore}%</div>
                </div>
              </div>
            `;
            
            setTimeout(() => {
              const btn = document.getElementById(buttonId);
              const details = document.getElementById(detailsId);
              if (btn && details) {
                btn.addEventListener('click', () => {
                  const isVisible = details.style.display !== 'none';
                  details.style.display = isVisible ? 'none' : 'block';
                  btn.textContent = isVisible ? 'Show details' : 'Hide details';
                });
              }
            }, 0);
          } else {
            // No breakdown available - add empty section for consistent spacing
            pillarBreakdown = `
              <div id="${breakdownId}" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; font-size: 0.8rem; min-height: 4.5rem;">
              </div>
            `;
            pillarDetails = `
              <div style="margin-top: 0.5rem; min-height: 1.5rem;">
              </div>
            `;
          }
        }
        
        // Define pillar colors for consistency across all reports
        const pillarColors = {
          localEntity: 'rgba(147, 51, 234, 1)', // Purple
          serviceArea: '#00FFFF', // Cyan (not RAG color)
          authority: '#99004C', // Dark pink/magenta
          visibility: 'rgba(37, 99, 235, 1)', // Blue
          contentSchema: 'rgba(107, 114, 128, 1)' // Grey
        };
        
        const pillarColor = pillarColors[key] || '#666';
        
        card.innerHTML = `
          <div style="flex: 1; display: flex; flex-direction: column; position: relative;">
            <div style="position: absolute; top: 0; right: 0; width: 20px; height: 20px; background: ${pillarColor}; border-radius: 3px; border: 1px solid rgba(0,0,0,0.1);" title="Color key for ${pillarNames[key]} in all reports"></div>
            <h3>${pillarNames[key]}</h3>
            <div id="${key === 'authority' ? card._modeId + '-score' : ''}" class="pillar-score rag-${rag.status}">${Math.round(score)}</div>
            <div class="rag-badge ${rag.status}">${rag.label}</div>
            <p style="font-size: 0.85rem; color: #666; margin-top: 0.5rem; line-height: 1.5; flex-grow: 1;">${descriptions[key] || ''}</p>
            ${key === 'authority' ? authorityModeToggle : '<div style="min-height: 2.5rem;"></div>'}
            ${key === 'authority' ? authorityBreakdown : pillarBreakdown}
          </div>
          <div style="margin-top: auto;">
            ${key === 'authority' ? authorityDetails : pillarDetails}
          </div>
        `;
        pillarCards.appendChild(card);
        debugLog(`‚úì Added pillar card for ${key} (score: ${score})`, 'info');
      });
      
      debugLog(`‚úì Created ${orderedPillars.length} pillar cards total`, 'success');
      
      // Shared functions for Top Pages section (used by both createTopPagesSection functions)
      
      // Classification functions for metric status
      function classifySiteCtr(v) {
        // v is already a percentage (0-100), not a decimal
        if (v < 1) return 'poor';      // <1%
        if (v < 3) return 'ok';        // 1-3%
        return 'strong';                  // 3%+
      }
      
      function classifyTop10Ctr(v) {
        // v is already a percentage (0-100), not a decimal
        if (v < 2) return 'poor';      // <2%
        if (v < 5) return 'ok';        // 2-5%
        return 'strong';                  // 5%+
      }
      
      function classifyAvgPos(p) {
        if (p > 10) return 'poor';        // mostly bottom of page 1 / page 2
        if (p > 5) return 'ok';           // mid-page 1
        return 'strong';                  // positions 1-5
      }
      
      function classifyTop10Share(v) {
        // v is stored as decimal (0-1), needs to be converted to percentage for comparison
        const pct = v * 100;
        if (pct < 60) return 'poor';       // <60% of impressions in top 10
        if (pct < 80) return 'ok';         // 60-80%
        return 'strong';                  // 80%+
      }
      
      // Helper to format percentage
      // For CTR values: already percentages (0-100), just format
      // For top10Share: stored as decimal (0-1), convert to percentage
      function pct(v, isDecimal = false) {
        if (isDecimal) {
          return `${(v * 100).toFixed(2)}%`;
        }
        return `${v.toFixed(2)}%`;
      }
      
      // Helper to extract target value from target text
      function extractTargetValue(targetText, metricType) {
        if (metricType === 'ctr' || metricType === 'percentage') {
          // Extract range like "2‚Äì3%+" or "75‚Äì85%+"
          const match = targetText.match(/(\d+(?:\.\d+)?)[‚Äì-](\d+(?:\.\d+)?)%/);
          if (match) {
            const min = parseFloat(match[1]);
            const max = parseFloat(match[2]);
            return (min + max) / 2; // Return midpoint
          }
        } else if (metricType === 'position') {
          // Extract range like "3‚Äì6"
          const match = targetText.match(/(\d+(?:\.\d+)?)[‚Äì-](\d+(?:\.\d+)?)/);
          if (match) {
            const min = parseFloat(match[1]);
            const max = parseFloat(match[2]);
            return (min + max) / 2; // Return midpoint
          }
        }
        return null;
      }
      
      // Build recommendation rows from segment metrics
      function buildBehaviourRankingRecommendations(segment, m) {
        const rows = [];
        
        // Site CTR recommendation
        const siteStatus = classifySiteCtr(m.siteCtr);
        const siteCurrent = m.siteCtr;
        const siteTargetText = 'Aim for 2‚Äì3%+ overall CTR';
        const siteTargetValue = extractTargetValue(siteTargetText, 'ctr'); // 2.5%
        const siteDiff = siteTargetValue ? (siteCurrent - siteTargetValue) : null; // Keep sign for display
        rows.push({
          metric: 'Overall CTR (all ranking queries)',
          status: siteStatus,
          value: pct(m.siteCtr),
          currentValue: siteCurrent,
          target: siteTargetText,
          targetValue: siteTargetValue,
          difference: siteDiff,
          action: siteStatus === 'poor'
            ? (segment === 'money'
                ? 'Rewrite titles and descriptions on the top money pages (table above). Add intent phrases ("workshop", "course", "near me") and stronger benefits to lift clicks for your money pages.'
                : 'Focus on high-impression pages with weak CTR in this segment. Tighten titles and descriptions so they clearly answer the search intent and highlight the benefit.')
            : siteStatus === 'ok'
            ? (segment === 'money'
                ? 'CTR is reasonable for your money pages. Prioritise the worst pages in the table above for A/B-style tests on titles and descriptions.'
                : 'CTR is reasonable for this segment. Prioritise the worst pages in the table above for A/B-style tests on titles and descriptions.')
            : 'CTR is strong for this segment. Keep monitoring but prioritise ranking and impression share improvements.'
        });
        
        // Top-10 CTR recommendation
        const top10Status = classifyTop10Ctr(m.top10Ctr);
        const top10Current = m.top10Ctr;
        const top10TargetText = 'Aim for 3‚Äì5%+ in top-10';
        const top10TargetValue = extractTargetValue(top10TargetText, 'ctr'); // 4%
        const top10Diff = top10TargetValue ? (top10Current - top10TargetValue) : null; // Keep sign for display
        rows.push({
          metric: 'Top-10 CTR (positions 1‚Äì10)',
          status: top10Status,
          value: pct(m.top10Ctr),
          currentValue: top10Current,
          target: top10TargetText,
          targetValue: top10TargetValue,
          difference: top10Diff,
          action: top10Status === 'poor'
            ? (segment === 'money'
                ? 'When your money pages are already in positions 1‚Äì10 but clicks are low, re-write titles/meta to be more specific: include location, level (beginner/advanced), and outcome ("learn to‚Ä¶", "master‚Ä¶").'
                : 'When you are already in positions 1‚Äì10 but clicks are low, re-write titles/meta to be more specific: include location, level (beginner/advanced), and outcome ("learn to‚Ä¶", "master‚Ä¶").')
            : top10Status === 'ok'
            ? (segment === 'money'
                ? 'Identify top-10 money pages with below-average CTR and iterate on their SERP snippet (titles, descriptions, rich results where available).'
                : 'Identify top-10 pages with below-average CTR and iterate on their SERP snippet (titles, descriptions, rich results where available).')
            : 'Top-10 CTR is healthy. Focus on pushing more queries into the top-10 (see avg position & top-10 share).'
        });
        
        // Average position recommendation
        const posStatus = classifyAvgPos(m.avgPosition);
        const posCurrent = m.avgPosition;
        const posTargetText = 'Aim for average position 3‚Äì6 on core queries';
        const posTargetValue = extractTargetValue(posTargetText, 'position'); // 4.5
        const posDiff = posTargetValue ? (posCurrent - posTargetValue) : null; // Keep sign for display (positive = worse)
        rows.push({
          metric: 'Average position (ranking queries)',
          status: posStatus,
          value: m.avgPosition.toFixed(1),
          currentValue: posCurrent,
          target: posTargetText,
          targetValue: posTargetValue,
          difference: posDiff,
          action: posStatus === 'poor'
            ? (segment === 'money'
                ? 'Most impressions for money pages are coming from low positions. Strengthen internal links to money pages, add more supporting content, and build links from relevant blogs/assignments into these URLs.'
                : 'Most impressions are coming from low positions. Strengthen internal links to key pages, add more supporting content, and build links from relevant blogs/assignments into these URLs.')
            : posStatus === 'ok'
            ? (segment === 'money'
                ? 'Your money pages are mid-page 1 on average. Use on-page tuning (H1, sub-heads, FAQs) and internal links from strong blogs to nudge key money URLs into positions 1‚Äì3.'
                : 'You are mid-page 1 on average. Use on-page tuning (H1, sub-heads, FAQs) and internal links from strong blogs to nudge key URLs into positions 1‚Äì3.')
            : 'Positions are strong overall. Concentrate on CTR and expanding coverage to more relevant queries.'
        });
        
        // Top-10 share recommendation
        const shareStatus = classifyTop10Share(m.top10Share);
        const shareCurrent = m.top10Share * 100; // Convert to percentage
        const shareTargetText = 'Aim for 75‚Äì85%+ of impressions in top-10';
        const shareTargetValue = extractTargetValue(shareTargetText, 'percentage'); // 80%
        const shareDiff = shareTargetValue ? (shareCurrent - shareTargetValue) : null; // Keep sign for display
        rows.push({
          metric: 'Top-10 impression share',
          status: shareStatus,
          value: pct(m.top10Share, true), // top10Share is stored as decimal (0-1)
          currentValue: shareCurrent,
          target: shareTargetText,
          targetValue: shareTargetValue,
          difference: shareDiff,
          action: shareStatus === 'poor'
            ? (segment === 'money'
                ? 'Large share of impressions for money pages are outside the top-10. Review which queries are generating impressions but no clicks and decide: improve those money pages or deliberately de-optimise low-value queries.'
                : 'Large share of impressions are outside the top-10. Review which queries are generating impressions but no clicks and decide: improve those pages or deliberately de-optimise low-value queries.')
            : shareStatus === 'ok'
            ? (segment === 'money'
                ? 'Gradually push more money page impressions into the top-10 by strengthening key hub pages (workshops, courses, tuition) and consolidating thin or overlapping content.'
                : 'Gradually push more impressions into the top-10 by strengthening key hub pages (workshops, courses, tuition) and consolidating thin or overlapping content.')
            : 'Most impressions are already top-10. Shift effort to CTR and conversion on the URLs listed above.'
        });
        
        return rows;
      }
      
      // Render recommendations table
      function renderRecommendationsTable(segment, metrics, segmentLabel, dateRangeText = '30 days') {
        if (!metrics) {
          return '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">No metrics available for recommendations.</div>';
        }
        
        const recommendations = buildBehaviourRankingRecommendations(segment, metrics);
        
        // Determine priority row: poor status first, or largest gap if no poor
        let priorityIdx = -1;
        const poorRows = recommendations.map((r, i) => ({ idx: i, row: r })).filter(({ row }) => row.status === 'poor');
        if (poorRows.length > 0) {
          // Find poor row with largest gap (use absolute value for comparison)
          priorityIdx = poorRows.reduce((max, curr) => {
            const currGap = Math.abs(curr.row.difference || 0);
            const maxGap = Math.abs(max.row.difference || 0);
            return currGap > maxGap ? curr : max;
          }, poorRows[0]).idx;
        } else {
          // No poor rows, find row with largest gap (use absolute value)
          priorityIdx = recommendations.reduce((maxIdx, row, idx) => {
            const currGap = Math.abs(row.difference || 0);
            const maxGap = Math.abs(recommendations[maxIdx]?.difference || 0);
            return currGap > maxGap ? idx : maxIdx;
          }, 0);
        }
        
        const getStatusPill = (status) => {
          const colors = {
            poor: { bg: '#fee2e2', text: '#991b1b', label: 'Poor' },
            ok: { bg: '#fef3c7', text: '#92400e', label: 'OK' },
            strong: { bg: '#d1fae5', text: '#065f46', label: 'Strong' }
          };
          const color = colors[status] || colors.ok;
          return `<span style="display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; background: ${color.bg}; color: ${color.text}; font-size: 0.75rem; font-weight: 600;">${color.label}</span>`;
        };
        
        // Get segment display name
        const segmentDisplayName = segmentLabel || (segment === 'all' ? 'All pages' : segment === 'nonEducation' ? 'Exclude education (blogs / free course)' : 'Money pages only');
        
        let tableHtml = `
          <div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
            <h4 style="margin: 0 0 0.25rem 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Recommended actions for this segment</h4>
            <p style="margin: 0 0 0.5rem 0; font-size: 0.75rem; color: #334155; font-weight: 500;">Segment: <strong>${segmentDisplayName}</strong> (last ${dateRangeText})</p>
            <p style="margin: 0; font-size: 0.75rem; color: #334155; font-weight: 400;">Based on last ${dateRangeText} of Google Search Console data for the currently selected segment.</p>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px;">Metric</th>
                  <th style="text-align: center; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px;">Status</th>
                  <th style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px;">Current</th>
                  <th style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px;">Target</th>
                  <th style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px;">To Target</th>
                  <th style="text-align: left; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px;">Suggested action</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        recommendations.forEach((row, idx) => {
          const isEven = idx % 2 === 0;
          const isPriority = idx === priorityIdx;
          
          // Determine metric type and format accordingly
          let currentDisplay = row.value;
          let targetDisplay = row.target;
          let diffDisplay = '‚Äî';
          
          if (row.metric.includes('CTR')) {
            // CTR metrics: show as percentages (1 decimal)
            currentDisplay = `${row.currentValue.toFixed(1)}%`;
            if (row.targetValue !== null && row.targetValue !== undefined) {
              targetDisplay = `${row.targetValue.toFixed(1)}%`;
              if (row.difference !== null && row.difference !== undefined) {
                // Show sign and color based on status
                const gap = row.difference; // Already calculated as current - target
                if (gap >= 0) {
                  // At or above target
                  diffDisplay = '<span style="color: #10b981; font-weight: 600;">‚úì On target</span>';
                } else {
                  // Below target - show with sign
                  const gapColor = row.status === 'poor' ? '#ef4444' : row.status === 'ok' ? '#f59e0b' : '#10b981';
                  diffDisplay = `<span style="color: ${gapColor}; font-weight: 600;">${gap.toFixed(2)}%</span>`;
                }
              }
            }
          } else if (row.metric.includes('position')) {
            // Position metrics: show as numbers (1 decimal)
            currentDisplay = row.currentValue.toFixed(1);
            if (row.targetValue !== null && row.targetValue !== undefined) {
              targetDisplay = row.targetValue.toFixed(1);
              if (row.difference !== null && row.difference !== undefined) {
                // For position, lower is better, so if current <= target, we're good
                const gap = row.difference; // Already calculated as current - target
                if (gap <= 0) {
                  // At or better than target
                  diffDisplay = '<span style="color: #10b981; font-weight: 600;">‚úì On target</span>';
                } else {
                  // Above target (worse position) - show with sign
                  const gapColor = row.status === 'poor' ? '#ef4444' : row.status === 'ok' ? '#f59e0b' : '#10b981';
                  diffDisplay = `<span style="color: ${gapColor}; font-weight: 600;">+${gap.toFixed(1)}</span>`;
                }
              }
            }
          } else if (row.metric.includes('impression share')) {
            // Share metrics: show as percentages (1 decimal)
            currentDisplay = `${row.currentValue.toFixed(1)}%`;
            if (row.targetValue !== null && row.targetValue !== undefined) {
              targetDisplay = `${row.targetValue.toFixed(1)}%`;
              if (row.difference !== null && row.difference !== undefined) {
                // For share, higher is better
                const gap = row.difference; // Already calculated as current - target
                if (gap >= 0) {
                  // At or above target
                  diffDisplay = '<span style="color: #10b981; font-weight: 600;">‚úì On target</span>';
                } else {
                  // Below target - show with sign
                  const gapColor = row.status === 'poor' ? '#ef4444' : row.status === 'ok' ? '#f59e0b' : '#10b981';
                  diffDisplay = `<span style="color: ${gapColor}; font-weight: 600;">${gap.toFixed(2)}%</span>`;
                }
              }
            }
          }
          
          // Priority row styling: left border and optional priority badge
          const priorityStyle = isPriority ? 'border-left: 4px solid #ef4444; background: #fef2f2;' : '';
          const priorityBadge = isPriority ? '<span style="display: inline-block; margin-left: 0.5rem; padding: 0.15rem 0.4rem; background: #ef4444; color: white; border-radius: 4px; font-size: 0.7rem; font-weight: 600;">Priority</span>' : '';
          
          tableHtml += `
            <tr style="border-bottom: 1px solid #f1f5f9; background: ${isEven ? '#ffffff' : '#fafafa'}; ${priorityStyle} transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa';" onmouseout="this.style.background='${isEven ? '#ffffff' : '#fafafa'}';">
              <td style="padding: 0.75rem; color: #0f172a; font-weight: 600;">${row.metric}${priorityBadge}</td>
              <td style="padding: 0.75rem; text-align: center;">${getStatusPill(row.status)}</td>
              <td style="padding: 0.75rem; text-align: right; color: #0f172a; font-weight: 600;">${currentDisplay}</td>
              <td style="padding: 0.75rem; text-align: right; color: #0f172a; font-weight: 600;">${targetDisplay}</td>
              <td style="padding: 0.75rem; text-align: right; font-weight: 600;">${diffDisplay}</td>
              <td style="padding: 0.75rem; color: #0f172a; font-weight: 400; line-height: 1.5;">${row.action}</td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        return tableHtml;
      }
      
      // Function to render full-width top pages table (shared by both createTopPagesSection functions)
      function renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText = '30 days') {
        if (!topPages || topPages.length === 0) {
          return '<div style="font-size: 0.85rem; color: #999; padding: 1rem; text-align: center;">No page data available for this segment. This table shows the latest snapshot from your most recent audit (static data, not affected by time period selections). If you see this message, the data may not have been computed during the last audit. Make sure your audit includes Google Search Console query+page metrics (queryPages dimension) and that you have uploaded site-urls.csv for segmentation.</div>';
        }
        
        // Store original data for sorting
        if (!window.topPagesData) {
          window.topPagesData = topPages;
          window.topPagesSortColumn = null;
          window.topPagesSortDirection = 'desc';
        }
        
        // Sort data if needed
        let sortedPages = [...topPages];
        if (window.topPagesSortColumn) {
          sortedPages.sort((a, b) => {
            let aVal, bVal;
            switch(window.topPagesSortColumn) {
              case 'ctr':
                aVal = a.ctr || 0;
                bVal = b.ctr || 0;
                break;
              case 'impressions':
                aVal = a.impressions || 0;
                bVal = b.impressions || 0;
                break;
              case 'clicks':
                aVal = a.clicks || 0;
                bVal = b.clicks || 0;
                break;
              case 'position':
                aVal = a.avgPosition || 0;
                bVal = b.avgPosition || 0;
                break;
              default:
                return 0;
            }
            const diff = aVal - bVal;
            return window.topPagesSortDirection === 'asc' ? diff : -diff;
          });
        }
        
        // Helper function to get sort icon (must be defined before use in template)
        const getSortIcon = (column) => {
          if (!window.topPagesSortColumn || window.topPagesSortColumn !== column) {
            return '<span style="color: #475569; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 600;">‚Üï</span>';
          }
          return window.topPagesSortDirection === 'asc' 
            ? '<span style="color: #99004C; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 700;">‚Üë</span>'
            : '<span style="color: #99004C; margin-left: 0.25rem; font-size: 0.75rem; font-weight: 700;">‚Üì</span>';
        };
        
        let tableHtml = `
          <div style="margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
            <div>
              <h4 style="margin: 0 0 0.25rem 0; font-size: 1rem; font-weight: 700; color: #1e293b;">Top 10 pages by impressions</h4>
              <span style="font-size: 0.75rem; color: #334155; font-weight: 500;">Data period: Last ${dateRangeText}</span>
            </div>
            <button id="top-pages-copy-urls" type="button" style="font-size: 0.8rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #2563eb; background: #2563eb; cursor: pointer; color: white; font-weight: 600; transition: all 0.2s; box-shadow: 0 1px 2px rgba(0,0,0,0.1);" onmouseover="this.style.background='#1d4ed8'; this.style.borderColor='#1d4ed8';" onmouseout="this.style.background='#2563eb'; this.style.borderColor='#2563eb';">
              Copy URLs
            </button>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px;">#</th>
                  <th style="text-align: left; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px;">URL</th>
                  <th id="sort-ctr" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by CTR">
                    CTR${getSortIcon('ctr')}
                  </th>
                  <th id="sort-impressions" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Impressions">
                    Impressions${getSortIcon('impressions')}
                  </th>
                  <th id="sort-clicks" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Clicks">
                    Clicks${getSortIcon('clicks')}
                  </th>
                  <th id="sort-position" style="text-align: right; padding: 0.75rem; font-weight: 700; color: #1e293b; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; user-select: none; transition: background 0.2s;" onmouseover="this.style.background='#e2e8f0';" onmouseout="this.style.background='transparent';" title="Click to sort by Avg Position">
                    Avg Position${getSortIcon('position')}
                  </th>
                </tr>
              </thead>
              <tbody>
        `;
        
        sortedPages.forEach((page, idx) => {
          const isEven = idx % 2 === 0;
          const ctrColor = page.ctr >= 2 ? '#10b981' : page.ctr >= 1 ? '#f59e0b' : '#ef4444';
          const posColor = page.avgPosition <= 5 ? '#10b981' : page.avgPosition <= 10 ? '#f59e0b' : '#ef4444';
          tableHtml += `
            <tr style="border-bottom: 1px solid #f1f5f9; background: ${isEven ? '#ffffff' : '#fafafa'}; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa';" onmouseout="this.style.background='${isEven ? '#ffffff' : '#fafafa'}';">
              <td style="padding: 0.75rem; color: #0f172a; font-weight: 600;">${idx + 1}</td>
              <td style="padding: 0.75rem; word-break: break-all;">
                <a href="${page.url}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none; font-weight: 500; border-bottom: 1px solid transparent; transition: all 0.2s;" onmouseover="this.style.color='#1d4ed8'; this.style.borderBottomColor='#1d4ed8';" onmouseout="this.style.color='#2563eb'; this.style.borderBottomColor='transparent';" title="Open ${page.url} in new tab">${page.url}</a>
              </td>
              <td style="padding: 0.75rem; text-align: right; color: ${ctrColor}; font-weight: 600;">${page.ctr.toFixed(2)}%</td>
              <td style="padding: 0.75rem; text-align: right; color: #0f172a; font-weight: 500;">${page.impressions.toLocaleString()}</td>
              <td style="padding: 0.75rem; text-align: right; color: #0f172a; font-weight: 500;">${page.clicks.toLocaleString()}</td>
              <td style="padding: 0.75rem; text-align: right; color: ${posColor}; font-weight: 600;">${page.avgPosition.toFixed(1)}</td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        return tableHtml;
      }
      
      // Helper to attach sort handlers after table is in DOM (shared by both createTopPagesSection functions)
      function attachSortHandlers() {
        setTimeout(() => {
          ['ctr', 'impressions', 'clicks', 'position'].forEach(col => {
            const th = document.getElementById(`sort-${col}`);
            if (th) {
              // Remove existing listeners by cloning
              const newTh = th.cloneNode(true);
              th.parentNode.replaceChild(newTh, th);
              newTh.addEventListener('click', () => {
                if (window.handleSort) {
                  window.handleSort(col);
                } else {
                  console.error('window.handleSort is not defined');
                }
              });
            } else {
              console.warn(`Sort header not found: sort-${col}`);
            }
          });
        }, 50);
      }
      
      // Make handleSort available globally (shared by both createTopPagesSection functions)
      if (!window.handleSort) {
        window.handleSort = function(column) {
          console.log('handleSort called with column:', column);
          if (window.topPagesSortColumn === column) {
            window.topPagesSortDirection = window.topPagesSortDirection === 'asc' ? 'desc' : 'asc';
          } else {
            window.topPagesSortColumn = column;
            window.topPagesSortDirection = 'desc';
          }
          
          // Get current data from stored source
          const currentMode = window.currentAuthorityMode || 'all';
          let topPages = window.topPagesData || [];
          
          // If no stored data, try to get from authorityBySegment
          if (!topPages || topPages.length === 0) {
            const segData = window.authorityBySegment;
            if (segData) {
              topPages = currentMode === 'all'
                ? (segData.all?.topPages || [])
                : currentMode === 'nonEducation'
                ? (segData.nonEducation?.topPages || [])
                : (segData.money?.topPages || []);
              window.topPagesData = topPages;
            }
          }
          
          const segmentLabel = currentMode === 'all'
            ? 'All pages'
            : currentMode === 'nonEducation'
            ? 'Exclude education (blogs / free course)'
            : 'Money pages only';
          
          // Get date range for display
          const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
          const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
          
          const tableContainer = document.getElementById('top-pages-table-container');
          if (tableContainer) {
            tableContainer.innerHTML = renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText);
            // attachCopyButtonHandler and attachSortHandlers are in shared scope, so they're accessible
            attachSortHandlers();
            // attachCopyButtonHandler is defined inside createTopPagesSection, so we need to find it or define it globally
            // For now, attach the copy button handler directly
            setTimeout(() => {
              const copyBtn = document.getElementById('top-pages-copy-urls');
              if (copyBtn) {
                const newCopyBtn = copyBtn.cloneNode(true);
                copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
                newCopyBtn.addEventListener('click', async () => {
                  const currentMode = window.currentAuthorityMode || 'all';
                  const segData = window.authorityBySegment;
                  const currentTopPages = currentMode === 'all'
                    ? (segData?.all?.topPages || [])
                    : currentMode === 'nonEducation'
                    ? (segData?.nonEducation?.topPages || [])
                    : (segData?.money?.topPages || []);
                  const text = currentTopPages.map(p => p.url).join('\n');
                  try {
                    await navigator.clipboard.writeText(text);
                    newCopyBtn.textContent = 'Copied!';
                    newCopyBtn.style.color = '#10b981';
                    setTimeout(() => {
                      newCopyBtn.textContent = 'Copy URLs';
                      newCopyBtn.style.color = '#666';
                    }, 2000);
                  } catch (err) {
                    console.error('Failed to copy URLs:', err);
                    newCopyBtn.textContent = 'Copy failed';
                    setTimeout(() => {
                      newCopyBtn.textContent = 'Copy URLs';
                    }, 2000);
                  }
                });
              }
            }, 50);
          } else {
            console.error('top-pages-table-container not found');
          }
        };
      }
      
      // Function to render segment comparison table (shared by both createTopPagesSection functions)
      function renderSegmentComparisonTable(authorityBySegment, currentMode) {
        const segments = [
          { key: 'all', label: 'All pages', data: authorityBySegment.all },
          { key: 'nonEducation', label: 'Exclude education (blogs / free course)', data: authorityBySegment.nonEducation },
          { key: 'money', label: 'Money pages only', data: authorityBySegment.money }
        ];
        
        let tableHtml = `
          <div style="margin-bottom: 0.5rem;">
            <h4 style="margin: 0 0 0.5rem 0; font-size: 0.95rem; font-weight: 700; color: #1e293b;">Segment overview (CTR & ranking)</h4>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.8rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.5rem 0.75rem; font-weight: 700; color: #475569; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Segment</th>
                  <th style="text-align: right; padding: 0.5rem 0.75rem; font-weight: 700; color: #475569; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Site CTR</th>
                  <th style="text-align: right; padding: 0.5rem 0.75rem; font-weight: 700; color: #475569; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Top-10 CTR</th>
                  <th style="text-align: right; padding: 0.5rem 0.75rem; font-weight: 700; color: #475569; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Avg pos.</th>
                  <th style="text-align: right; padding: 0.5rem 0.75rem; font-weight: 700; color: #475569; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Top-10 share</th>
                  <th style="text-align: right; padding: 0.5rem 0.75rem; font-weight: 700; color: #475569; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Behaviour</th>
                  <th style="text-align: right; padding: 0.5rem 0.75rem; font-weight: 700; color: #475569; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Ranking</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        segments.forEach(({ key, label, data }, idx) => {
          const isActive = key === currentMode;
          const siteCtr = data?.siteCtr || 0;
          const top10Ctr = data?.top10Ctr || 0;
          const avgPosition = data?.avgPosition || 0;
          const top10Share = (data?.top10Share || 0) * 100;
          const behaviourScore = data?.behaviour || 0;
          const rankingScore = data?.ranking || 0;
          
          tableHtml += `
            <tr 
              onclick="window.currentAuthorityMode = '${key}'; if(window.updateTopPagesSection) window.updateTopPagesSection('${key}');"
              style="
                cursor: pointer;
                border-bottom: 1px solid #f1f5f9;
                background: ${isActive ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : (idx % 2 === 0 ? '#ffffff' : '#fafafa')};
                transition: all 0.2s;
              "
              onmouseover="this.style.background='${isActive ? 'linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%)' : '#f8f9fa'}';"
              onmouseout="this.style.background='${isActive ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : (idx % 2 === 0 ? '#ffffff' : '#fafafa')}';"
            >
              <td style="padding: 0.5rem 0.75rem; font-weight: ${isActive ? '600' : '500'}; color: #0f172a;">
                ${label}
                ${isActive ? '<span style="margin-left: 0.5rem; font-size: 0.7rem; padding: 0.15rem 0.5rem; border-radius: 999px; background: #10b981; color: white; font-weight: 600;">current</span>' : ''}
              </td>
              <td style="padding: 0.5rem 0.75rem; text-align: right; color: #0f172a; font-weight: 500;">${siteCtr.toFixed(2)}%</td>
              <td style="padding: 0.5rem 0.75rem; text-align: right; color: #0f172a; font-weight: 500;">${top10Ctr.toFixed(2)}%</td>
              <td style="padding: 0.5rem 0.75rem; text-align: right; color: #0f172a; font-weight: 500;">${avgPosition.toFixed(1)}</td>
              <td style="padding: 0.5rem 0.75rem; text-align: right; color: #0f172a; font-weight: 500;">${top10Share.toFixed(1)}%</td>
              <td style="padding: 0.5rem 0.75rem; text-align: right; color: #0f172a; font-weight: 600;">${Math.round(behaviourScore)}</td>
              <td style="padding: 0.5rem 0.75rem; text-align: right; color: #0f172a; font-weight: 600;">${Math.round(rankingScore)}</td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        return tableHtml;
      }
      
      // Function to create Top Pages section (full width, below pillar cards)
      function createTopPagesSection(scores, saved) {
        // Get Authority segment data from current scores (latest snapshot, not historical)
        // This uses the most recent audit data, not historical Supabase data
        const authorityObj = scores?.authority;
        let authorityBySegment = (typeof authorityObj === 'object' && authorityObj !== null) 
          ? authorityObj.bySegment 
          : null;
        
        // If no segment data in scores, try to get from saved audit (latest audit data from localStorage)
        if (!authorityBySegment && saved) {
          const savedScores = saved.scores;
          if (savedScores && savedScores.authority) {
            const savedAuthorityObj = savedScores.authority;
            if (typeof savedAuthorityObj === 'object' && savedAuthorityObj !== null) {
              authorityBySegment = savedAuthorityObj.bySegment || null;
              debugLog('üìä Top Pages: Using Authority segment data from saved audit (latest snapshot)', 'info');
            }
          }
        }
        
        if (!authorityBySegment) {
          debugLog('‚ö† No Authority segment data available for Top Pages table. This requires GSC queryPages data from your most recent audit.', 'warn');
          // Still create the section but show a helpful message - don't return early
        }
        
        // Remove existing top pages section if it exists
        const existingTopPages = document.getElementById('authority-top-pages-section');
        if (existingTopPages) {
          existingTopPages.remove();
        }
        
        // Create new section
        const topPagesSection = document.createElement('div');
        topPagesSection.id = 'authority-top-pages-section';
        topPagesSection.className = 'section-break';
        topPagesSection.style.marginTop = '2rem';
        topPagesSection.style.marginBottom = '2rem';
        
        // Get current mode from Authority card toggle (default to 'all')
        let currentMode = 'all';
        const authorityCard = Array.from(document.querySelectorAll('.pillar-card')).find(card => {
          const h3 = card.querySelector('h3');
          return h3 && h3.textContent === 'Authority';
        });
        
        if (authorityCard && authorityCard._authorityMode) {
          currentMode = authorityCard._authorityMode;
        }
        
        // Get top pages for current mode
        const topPages = currentMode === 'all'
          ? (authorityBySegment?.all?.topPages || [])
          : currentMode === 'nonEducation'
          ? (authorityBySegment?.nonEducation?.topPages || [])
          : (authorityBySegment?.money?.topPages || []);
        
        const segmentLabel = currentMode === 'all'
          ? 'All pages'
          : currentMode === 'nonEducation'
          ? 'Exclude education (blogs / free course)'
          : 'Money pages only';
        
        debugLog(`üìä Top Pages: Found ${topPages.length} pages for segment "${currentMode}"`, 'info');
        if (topPages.length > 0) {
          debugLog(`üìä Top Pages: First page URL: ${topPages[0].url}, Impressions: ${topPages[0].impressions}`, 'info');
        }
        
        // Create section HTML
        topPagesSection.innerHTML = `
          <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 1rem 0; color: var(--brand-dark);">Authority - Behaviour & Ranking</h3>
            <div style="margin-bottom: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 4px; font-size: 0.85rem; line-height: 1.6; color: #666;">
              <p style="margin: 0 0 0.75rem 0;"><strong>Behaviour:</strong> Measures click-through rate (CTR) performance. Combines Overall CTR (50% weight) for all ranking search terms and Top-10 Ranked Search Terms CTR (50% weight) for queries ranking in positions 1-10. Indicates how well your titles and descriptions convert impressions to clicks. Data source: Google Search Console query+page metrics.</p>
              <p style="margin: 0;"><strong>Ranking:</strong> Measures search visibility and position quality. Combines Average Position Score (50% weight) and Top-10 Impression Share (50% weight). Shows how high you rank on average and what percentage of impressions appear in positions 1-10. Data source: Google Search Console query+page metrics.</p>
            </div>
            <div style="margin-bottom: 1rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem;">
              <span style="font-weight: 600; color: #666;">Current Segment:</span>
              <span id="top-pages-segment-label" style="color: #333; margin-left: 0.5rem;">${segmentLabel}</span>
            </div>
            <div id="top-pages-table-container">
              ${renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText)}
            </div>
            
            ${authorityBySegment && authorityBySegment[currentMode] ? `
            <div id="top-pages-recommendations-container" style="margin-top: 2rem;">
              ${renderRecommendationsTable(currentMode, {
                siteCtr: authorityBySegment[currentMode].siteCtr || 0,
                top10Ctr: authorityBySegment[currentMode].top10Ctr || 0,
                avgPosition: authorityBySegment[currentMode].avgPosition || 0,
                top10Share: authorityBySegment[currentMode].top10Share || 0,
                behaviourScore: authorityBySegment[currentMode].behaviour || 0,
                rankingScore: authorityBySegment[currentMode].ranking || 0
              }, segmentLabel, dateRangeText)}
            </div>
            ` : ''}
          </div>
        `;
        
        // Insert after pillar cards
        pillarCards.parentNode.insertBefore(topPagesSection, pillarCards.nextSibling);
        
        // Store authorityBySegment globally so updateTopPagesSection can access it
        window.authorityBySegment = authorityBySegment;
        
        // Store update function globally so Authority mode toggle can call it
        window.updateTopPagesSection = function(mode) {
          const topPages = mode === 'all'
            ? (authorityBySegment?.all?.topPages || [])
            : mode === 'nonEducation'
            ? (authorityBySegment?.nonEducation?.topPages || [])
            : (authorityBySegment?.money?.topPages || []);
          
          const segmentLabel = mode === 'all'
            ? 'All pages'
            : mode === 'nonEducation'
            ? 'Exclude education (blogs / free course)'
            : 'Money pages only';
          
          debugLog(`üìä Top Pages: Updating to segment "${mode}", found ${topPages.length} pages`, 'info');
          
          // Update segment label
          const labelEl = document.getElementById('top-pages-segment-label');
          if (labelEl) labelEl.textContent = segmentLabel;
          
          // Update summary if available
          const getSegmentSummary = (m) => {
            if (!authorityBySegment || !authorityBySegment[m]) return null;
            const segmentData = authorityBySegment[m];
            return {
              behaviour: segmentData.behaviour || 0,
              ranking: segmentData.ranking || 0,
              total: segmentData.total || segmentData.score || 0
            };
          };
          
          const summary = getSegmentSummary(mode);
          const summaryDiv = document.getElementById('top-pages-segment-summary');
          if (summary && summaryDiv) {
            const rag = getRAGStatus(summary.total);
            summaryDiv.innerHTML = `
              ${formatComponentScore('Behaviour', summary.behaviour)}
              ${formatComponentScore('Ranking', summary.ranking)}
            `;
            // Update RAG badge and score
            const ragBadge = summaryDiv.parentElement.querySelector('.rag-badge');
            const scoreSpan = summaryDiv.parentElement.querySelector('span[style*="font-size: 1.5rem"]');
            if (ragBadge) {
              ragBadge.className = `rag-badge ${rag.status}`;
              ragBadge.textContent = rag.label;
            }
            if (scoreSpan) {
              scoreSpan.textContent = Math.round(summary.total);
              scoreSpan.style.color = rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444';
            }
          }
          
          // Update toggle buttons
          ['all', 'nonEducation', 'money'].forEach(m => {
            const btn = document.getElementById(`top-pages-mode-${m}`);
            if (btn) {
              if (m === mode) {
                btn.style.background = '#10b981';
                btn.style.color = 'white';
                btn.style.fontWeight = '600';
              } else {
                btn.style.background = 'white';
                btn.style.color = '#666';
                btn.style.fontWeight = '400';
              }
            }
          });
          
          // Update comparison table
          const comparisonDiv = document.getElementById('top-pages-comparison-table');
          if (comparisonDiv && authorityBySegment) {
            comparisonDiv.innerHTML = renderSegmentComparisonTable(authorityBySegment, mode);
          }
          
          // Get date range for display
          const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
          const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
          
          // Update table (reset sort when switching segments)
          window.topPagesData = topPages;
          window.topPagesSortColumn = null;
          window.topPagesSortDirection = 'desc';
          const tableContainer = document.getElementById('top-pages-table-container');
          if (tableContainer) {
            tableContainer.innerHTML = renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText);
            attachCopyButtonHandler();
            attachSortHandlers();
          }
          
          // Update recommendations table
          const recommendationsContainer = document.getElementById('top-pages-recommendations-container');
          if (recommendationsContainer && authorityBySegment && authorityBySegment[mode]) {
            const segmentLabel = mode === 'all'
              ? 'All pages'
              : mode === 'nonEducation'
              ? 'Exclude education (blogs / free course)'
              : 'Money pages only';
            const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
            const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
            recommendationsContainer.innerHTML = renderRecommendationsTable(mode, {
              siteCtr: authorityBySegment[mode].siteCtr || 0,
              top10Ctr: authorityBySegment[mode].top10Ctr || 0,
              avgPosition: authorityBySegment[mode].avgPosition || 0,
              top10Share: authorityBySegment[mode].top10Share || 0,
              behaviourScore: authorityBySegment[mode].behaviour || 0,
              rankingScore: authorityBySegment[mode].ranking || 0
            }, segmentLabel, dateRangeText);
          }
        };
        
        // window.handleSort is now defined in shared scope above
        
        // Attach toggle button handlers
        setTimeout(() => {
          ['all', 'nonEducation', 'money'].forEach(mode => {
            const btn = document.getElementById(`top-pages-mode-${mode}`);
            if (btn) {
              btn.addEventListener('click', () => {
                window.currentAuthorityMode = mode;
                window.updateTopPagesSection(mode);
                // Also update Authority pillar card if it exists
                const authorityCard = Array.from(document.querySelectorAll('.pillar-card')).find(card => {
                  const h3 = card.querySelector('h3');
                  return h3 && h3.textContent === 'Authority';
                });
                if (authorityCard && authorityCard._updateAuthorityDisplay) {
                  authorityCard._authorityMode = mode;
                  authorityCard._updateAuthorityDisplay();
                  // Update Authority pillar toggle buttons
                  const modeId = authorityCard._modeId;
                  ['all', 'nonEducation', 'money'].forEach(m => {
                    const authBtn = document.getElementById(`${modeId}-${m}`);
                    if (authBtn) {
                      if (m === mode) {
                        authBtn.style.background = '#10b981';
                        authBtn.style.color = 'white';
                      } else {
                        authBtn.style.background = 'white';
                        authBtn.style.color = '#666';
                      }
                    }
                  });
                }
              });
            }
          });
        }, 0);
        
        // Attach initial copy button handler
        attachCopyButtonHandler();
        
        function attachCopyButtonHandler() {
          setTimeout(() => {
            const copyBtn = document.getElementById('top-pages-copy-urls');
            if (copyBtn) {
              // Remove existing listener
              const newCopyBtn = copyBtn.cloneNode(true);
              copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
              
              newCopyBtn.addEventListener('click', async () => {
                const currentMode = window.currentAuthorityMode || 'all';
                const currentTopPages = currentMode === 'all'
                  ? (authorityBySegment?.all?.topPages || [])
                  : currentMode === 'nonEducation'
                  ? (authorityBySegment?.nonEducation?.topPages || [])
                  : (authorityBySegment?.money?.topPages || []);
                
                const text = currentTopPages.map(p => p.url).join('\n');
                try {
                  await navigator.clipboard.writeText(text);
                  newCopyBtn.textContent = 'Copied!';
                  newCopyBtn.style.color = '#10b981';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                    newCopyBtn.style.color = '#666';
                  }, 2000);
                } catch (err) {
                  console.error('Failed to copy URLs:', err);
                  newCopyBtn.textContent = 'Copy failed';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                  }, 2000);
                }
              });
            }
          }, 0);
        }
        // renderFullWidthTopPagesTable is now defined in shared scope above
      }
      
      // Create Top Pages section (full width, below pillar cards)
      createTopPagesSection(scores, saved);
      
      // Remove existing scorecard table if it exists
      const existingScorecard = pillarCards.parentNode.querySelector('.scorecard-section');
      if (existingScorecard) {
        existingScorecard.remove();
      }
      
      // Function to render segment comparison table (shared by both createTopPagesSection functions)
      function renderSegmentComparisonTable(authorityBySegment, currentMode) {
        const segments = [
          { key: 'all', label: 'All pages', data: authorityBySegment.all },
          { key: 'nonEducation', label: 'Exclude education (blogs / free course)', data: authorityBySegment.nonEducation },
          { key: 'money', label: 'Money pages only', data: authorityBySegment.money }
        ];
        
        let tableHtml = `
          <div style="margin-bottom: 0.5rem;">
            <h4 style="margin: 0 0 0.5rem 0; font-size: 0.95rem; font-weight: 700; color: #1e293b;">Segment overview (CTR & ranking)</h4>
          </div>
          <div style="overflow-x: auto; border-radius: 6px; border: 1px solid #e2e8f0;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.8rem;">
              <thead>
                <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-bottom: 2px solid #e2e8f0;">
                  <th style="text-align: left; padding: 0.5rem 0.75rem; font-weight: 700; color: #475569; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Segment</th>
                  <th style="text-align: right; padding: 0.5rem 0.75rem; font-weight: 700; color: #475569; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Site CTR</th>
                  <th style="text-align: right; padding: 0.5rem 0.75rem; font-weight: 700; color: #475569; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Top-10 CTR</th>
                  <th style="text-align: right; padding: 0.5rem 0.75rem; font-weight: 700; color: #475569; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Avg pos.</th>
                  <th style="text-align: right; padding: 0.5rem 0.75rem; font-weight: 700; color: #475569; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Top-10 share</th>
                  <th style="text-align: right; padding: 0.5rem 0.75rem; font-weight: 700; color: #475569; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Behaviour</th>
                  <th style="text-align: right; padding: 0.5rem 0.75rem; font-weight: 700; color: #475569; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Ranking</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        segments.forEach(({ key, label, data }, idx) => {
          const isActive = key === currentMode;
          const siteCtr = data?.siteCtr || 0;
          const top10Ctr = data?.top10Ctr || 0;
          const avgPosition = data?.avgPosition || 0;
          const top10Share = (data?.top10Share || 0) * 100;
          const behaviourScore = data?.behaviour || 0;
          const rankingScore = data?.ranking || 0;
          
          tableHtml += `
            <tr 
              onclick="window.currentAuthorityMode = '${key}'; if(window.updateTopPagesSection) window.updateTopPagesSection('${key}');"
              style="
                cursor: pointer;
                border-bottom: 1px solid #f1f5f9;
                background: ${isActive ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : (idx % 2 === 0 ? '#ffffff' : '#fafafa')};
                transition: all 0.2s;
              "
              onmouseover="this.style.background='${isActive ? 'linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%)' : '#f8f9fa'}';"
              onmouseout="this.style.background='${isActive ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : (idx % 2 === 0 ? '#ffffff' : '#fafafa')}';"
            >
              <td style="padding: 0.5rem 0.75rem; font-weight: ${isActive ? '600' : '500'}; color: #0f172a;">
                ${label}
                ${isActive ? '<span style="margin-left: 0.5rem; font-size: 0.7rem; padding: 0.15rem 0.5rem; border-radius: 999px; background: #10b981; color: white; font-weight: 600;">current</span>' : ''}
              </td>
              <td style="padding: 0.5rem 0.75rem; text-align: right; color: #0f172a; font-weight: 500;">${siteCtr.toFixed(2)}%</td>
              <td style="padding: 0.5rem 0.75rem; text-align: right; color: #0f172a; font-weight: 500;">${top10Ctr.toFixed(2)}%</td>
              <td style="padding: 0.5rem 0.75rem; text-align: right; color: #0f172a; font-weight: 500;">${avgPosition.toFixed(1)}</td>
              <td style="padding: 0.5rem 0.75rem; text-align: right; color: #0f172a; font-weight: 500;">${top10Share.toFixed(1)}%</td>
              <td style="padding: 0.5rem 0.75rem; text-align: right; color: #0f172a; font-weight: 600;">${Math.round(behaviourScore)}</td>
              <td style="padding: 0.5rem 0.75rem; text-align: right; color: #0f172a; font-weight: 600;">${Math.round(rankingScore)}</td>
            </tr>
          `;
        });
        
        tableHtml += `
              </tbody>
            </table>
          </div>
        `;
        
        return tableHtml;
      }
      
      // Function to create Top Pages section (full width, below pillar cards)
      function createTopPagesSection(scores, saved) {
        // Get Authority segment data from current scores (latest snapshot, not historical)
        // This uses the most recent audit data, not historical Supabase data
        const authorityObj = scores?.authority;
        let authorityBySegment = (typeof authorityObj === 'object' && authorityObj !== null) 
          ? authorityObj.bySegment 
          : null;
        
        // If no segment data in scores, try to get from saved audit (latest audit data from localStorage)
        if (!authorityBySegment && saved) {
          const savedScores = saved.scores;
          if (savedScores && savedScores.authority) {
            const savedAuthorityObj = savedScores.authority;
            if (typeof savedAuthorityObj === 'object' && savedAuthorityObj !== null) {
              authorityBySegment = savedAuthorityObj.bySegment || null;
              debugLog('üìä Top Pages: Using Authority segment data from saved audit (latest snapshot)', 'info');
            }
          }
        }
        
        if (!authorityBySegment) {
          debugLog('‚ö† No Authority segment data available for Top Pages table. This requires GSC queryPages data from your most recent audit.', 'warn');
          // Still create the section but show a helpful message - don't return early
        }
        
        // Remove existing top pages section if it exists
        const existingTopPages = document.getElementById('authority-top-pages-section');
        if (existingTopPages) {
          existingTopPages.remove();
        }
        
        // Create new section
        const topPagesSection = document.createElement('div');
        topPagesSection.id = 'authority-top-pages-section';
        topPagesSection.className = 'section-break';
        topPagesSection.style.marginTop = '2rem';
        topPagesSection.style.marginBottom = '2rem';
        
        // Get current mode from Authority card toggle (default to 'all')
        let currentMode = 'all';
        const authorityCard = Array.from(document.querySelectorAll('.pillar-card')).find(card => {
          const h3 = card.querySelector('h3');
          return h3 && h3.textContent === 'Authority';
        });
        
        if (authorityCard && authorityCard._authorityMode) {
          currentMode = authorityCard._authorityMode;
        }
        
        // Get top pages for current mode
        const topPages = currentMode === 'all'
          ? (authorityBySegment?.all?.topPages || [])
          : currentMode === 'nonEducation'
          ? (authorityBySegment?.nonEducation?.topPages || [])
          : (authorityBySegment?.money?.topPages || []);
        
        const segmentLabel = currentMode === 'all'
          ? 'All pages'
          : currentMode === 'nonEducation'
          ? 'Exclude education (blogs / free course)'
          : 'Money pages only';
        
        // Get segment metrics for summary display
        const getSegmentSummary = (mode) => {
          if (!authorityBySegment || !authorityBySegment[mode]) return null;
          const segmentData = authorityBySegment[mode];
          return {
            behaviour: segmentData.behaviour || 0,
            ranking: segmentData.ranking || 0,
            total: segmentData.total || segmentData.score || 0
          };
        };
        
        const currentSummary = getSegmentSummary(currentMode);
        const rag = currentSummary ? getRAGStatus(currentSummary.total) : { status: 'amber', label: 'N/A' };
        
        // Get date range for display
        const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
        const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
        
        // Create section HTML with improved styling and pastel background
        topPagesSection.innerHTML = `
          <div style="background: #F5F0F5; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border-left: 4px solid #99004C;">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem;">
              <div style="flex: 1;">
                <h3 style="margin: 0 0 0.5rem 0; color: var(--brand-dark); font-size: 1.25rem; font-weight: 700;">Authority - Behaviour & Ranking</h3>
                <div style="margin-bottom: 1rem; padding: 1rem; background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); border-radius: 6px; font-size: 0.85rem; line-height: 1.6; color: #555; border-left: 3px solid #99004C;">
                  <p style="margin: 0 0 0.75rem 0;"><strong style="color: #99004C;">Behaviour:</strong> Measures click-through rate (CTR) performance. Combines Overall CTR (50% weight) for all ranking search terms and Top-10 Ranked Search Terms CTR (50% weight) for queries ranking in positions 1-10. Indicates how well your titles and descriptions convert impressions to clicks. Data source: Google Search Console query+page metrics.</p>
                  <p style="margin: 0;"><strong style="color: #99004C;">Ranking:</strong> Measures search visibility and position quality. Combines Average Position Score (50% weight) and Top-10 Impression Share (50% weight). Shows how high you rank on average and what percentage of impressions appear in positions 1-10. Data source: Google Search Console query+page metrics.</p>
                </div>
              </div>
            </div>
            
            ${currentSummary ? `
            <div style="margin-bottom: 1rem; padding: 1rem; background: rgba(221, 160, 221, 0.2); border-radius: 6px; border: 1px solid #e2e8f0;">
              <div style="text-align: center; margin-bottom: 0.75rem;">
                <span style="font-weight: 600; color: #333; font-size: 1.08rem;">Segment Summary: </span>
                <span id="top-pages-segment-label" style="color: #666; font-size: 0.85rem; padding: 0.25rem 0.75rem; background: #f1f5f9; border-radius: 4px;">${segmentLabel}</span>
              </div>
              <div style="display: flex; justify-content: center; align-items: center; gap: 1.5rem; flex-wrap: wrap;">
                <div id="top-pages-segment-summary" style="display: flex; align-items: center; gap: 1.5rem; font-size: 1rem;">
                  ${formatComponentScore('Behaviour', currentSummary.behaviour)}
                  ${formatComponentScore('Ranking', currentSummary.ranking)}
                </div>
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                  <span style="font-size: 1.5rem; font-weight: 700; color: ${rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444'};">${Math.round(currentSummary.total)}</span>
                  <span class="rag-badge ${rag.status}" style="display: inline-block; padding: 0.35rem 0.85rem; border-radius: 4px; font-size: 0.85rem; font-weight: 600;">${rag.label}</span>
                </div>
              </div>
            </div>
            ` : `
            <div style="margin-bottom: 1rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem;">
              <span style="font-weight: 600; color: #666;">Current Segment:</span>
              <span id="top-pages-segment-label" style="color: #333; margin-left: 0.5rem;">${segmentLabel}</span>
            </div>
            `}
            
            ${authorityBySegment ? `
            <div style="margin-bottom: 1rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.75rem;">
              <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                <span style="font-weight: 600; color: #666;">View:</span>
                <button id="top-pages-mode-all" class="authority-mode-btn" data-mode="all" style="padding: 0.35rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: ${currentMode === 'all' ? '#10b981' : 'white'}; color: ${currentMode === 'all' ? 'white' : '#666'}; cursor: pointer; font-size: 0.75rem; font-weight: ${currentMode === 'all' ? '600' : '400'}; transition: all 0.2s;">
                  All pages
                </button>
                <button id="top-pages-mode-nonEducation" class="authority-mode-btn" data-mode="nonEducation" style="padding: 0.35rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: ${currentMode === 'nonEducation' ? '#10b981' : 'white'}; color: ${currentMode === 'nonEducation' ? 'white' : '#666'}; cursor: pointer; font-size: 0.75rem; font-weight: ${currentMode === 'nonEducation' ? '600' : '400'}; transition: all 0.2s;">
                  Exclude education
                </button>
                <button id="top-pages-mode-money" class="authority-mode-btn" data-mode="money" style="padding: 0.35rem 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; background: ${currentMode === 'money' ? '#10b981' : 'white'}; color: ${currentMode === 'money' ? 'white' : '#666'}; cursor: pointer; font-size: 0.75rem; font-weight: ${currentMode === 'money' ? '600' : '400'}; transition: all 0.2s;">
                  Money pages only
                </button>
              </div>
            </div>
            ` : ''}
            
            ${authorityBySegment ? `
            <div id="top-pages-comparison-table" style="margin-bottom: 1.5rem;">
              ${renderSegmentComparisonTable(authorityBySegment, currentMode)}
            </div>
            ` : ''}
            
            <div id="top-pages-table-container">
              ${renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText)}
            </div>
            
            ${authorityBySegment && authorityBySegment[currentMode] ? `
            <div id="top-pages-recommendations-container" style="margin-top: 2rem;">
              ${renderRecommendationsTable(currentMode, {
                siteCtr: authorityBySegment[currentMode].siteCtr || 0,
                top10Ctr: authorityBySegment[currentMode].top10Ctr || 0,
                avgPosition: authorityBySegment[currentMode].avgPosition || 0,
                top10Share: authorityBySegment[currentMode].top10Share || 0,
                behaviourScore: authorityBySegment[currentMode].behaviour || 0,
                rankingScore: authorityBySegment[currentMode].ranking || 0
              }, segmentLabel, dateRangeText)}
            </div>
            ` : ''}
          </div>
        `;
        
        // Insert after pillar cards
        pillarCards.parentNode.insertBefore(topPagesSection, pillarCards.nextSibling);
        
        // Store authorityBySegment globally so updateTopPagesSection can access it
        window.authorityBySegment = authorityBySegment;
        
        // Attach toggle button handlers
        setTimeout(() => {
          ['all', 'nonEducation', 'money'].forEach(mode => {
            const btn = document.getElementById(`top-pages-mode-${mode}`);
            if (btn) {
              // Remove existing listeners by cloning
              const newBtn = btn.cloneNode(true);
              btn.parentNode.replaceChild(newBtn, btn);
              
              newBtn.addEventListener('click', () => {
                window.currentAuthorityMode = mode;
                if (window.updateTopPagesSection) {
                  window.updateTopPagesSection(mode);
                }
                // Also update Authority pillar card if it exists
                const authorityCard = Array.from(document.querySelectorAll('.pillar-card')).find(card => {
                  const h3 = card.querySelector('h3');
                  return h3 && h3.textContent === 'Authority';
                });
                if (authorityCard && authorityCard._updateAuthorityDisplay) {
                  authorityCard._authorityMode = mode;
                  authorityCard._updateAuthorityDisplay();
                  // Update Authority pillar toggle buttons
                  const modeId = authorityCard._modeId;
                  ['all', 'nonEducation', 'money'].forEach(m => {
                    const authBtn = document.getElementById(`${modeId}-${m}`);
                    if (authBtn) {
                      if (m === mode) {
                        authBtn.style.background = '#10b981';
                        authBtn.style.color = 'white';
                      } else {
                        authBtn.style.background = 'white';
                        authBtn.style.color = '#666';
                      }
                    }
                  });
                }
              });
            }
          });
        }, 100);
        
        // Store update function globally so Authority mode toggle can call it
        window.updateTopPagesSection = function(mode) {
          // Get fresh authorityBySegment from global or try to get from current scores
          let segData = window.authorityBySegment;
          if (!segData) {
            // Try to get from current scores
            const authorityObj = scores?.authority;
            segData = (typeof authorityObj === 'object' && authorityObj !== null) 
              ? authorityObj.bySegment 
              : null;
          }
          
          const topPages = mode === 'all'
            ? (segData?.all?.topPages || [])
            : mode === 'nonEducation'
            ? (segData?.nonEducation?.topPages || [])
            : (segData?.money?.topPages || []);
          
          const segmentLabel = mode === 'all'
            ? 'All pages'
            : mode === 'nonEducation'
            ? 'Exclude education (blogs / free course)'
            : 'Money pages only';
          
          debugLog(`üìä Top Pages: Updating to segment "${mode}", found ${topPages.length} pages`, 'info');
          
          // Update segment label
          const labelEl = document.getElementById('top-pages-segment-label');
          if (labelEl) labelEl.textContent = segmentLabel;
          
          // Update summary if available
          const getSegmentSummary = (m) => {
            if (!segData || !segData[m]) return null;
            const segmentData = segData[m];
            return {
              behaviour: segmentData.behaviour || 0,
              ranking: segmentData.ranking || 0,
              total: segmentData.total || segmentData.score || 0
            };
          };
          
          const summary = getSegmentSummary(mode);
          const summaryDiv = document.getElementById('top-pages-segment-summary');
          if (summary && summaryDiv) {
            const rag = getRAGStatus(summary.total);
            summaryDiv.innerHTML = `
              ${formatComponentScore('Behaviour', summary.behaviour)}
              ${formatComponentScore('Ranking', summary.ranking)}
            `;
            // Update RAG badge and score
            const ragBadge = summaryDiv.parentElement.querySelector('.rag-badge');
            const scoreSpan = summaryDiv.parentElement.querySelector('span[style*="font-size: 1.5rem"]');
            if (ragBadge) {
              ragBadge.className = `rag-badge ${rag.status}`;
              ragBadge.textContent = rag.label;
            }
            if (scoreSpan) {
              scoreSpan.textContent = Math.round(summary.total);
              scoreSpan.style.color = rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444';
            }
          }
          
          // Update toggle buttons
          ['all', 'nonEducation', 'money'].forEach(m => {
            const btn = document.getElementById(`top-pages-mode-${m}`);
            if (btn) {
              if (m === mode) {
                btn.style.background = '#10b981';
                btn.style.color = 'white';
                btn.style.fontWeight = '600';
              } else {
                btn.style.background = 'white';
                btn.style.color = '#666';
                btn.style.fontWeight = '400';
              }
            }
          });
          
          // Update comparison table
          const comparisonDiv = document.getElementById('top-pages-comparison-table');
          if (comparisonDiv && segData) {
            comparisonDiv.innerHTML = renderSegmentComparisonTable(segData, mode);
          }
          
          // Get date range for display
          const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
          const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
          
          // Update table (reset sort when switching segments)
          window.topPagesData = topPages;
          window.topPagesSortColumn = null;
          window.topPagesSortDirection = 'desc';
          const tableContainer = document.getElementById('top-pages-table-container');
          if (tableContainer) {
            tableContainer.innerHTML = renderFullWidthTopPagesTable(topPages, segmentLabel, dateRangeText);
            attachCopyButtonHandler();
            attachSortHandlers();
          }
          
          // Update recommendations table
          const recommendationsContainer = document.getElementById('top-pages-recommendations-container');
          if (recommendationsContainer && segData && segData[mode]) {
            const segmentLabel = mode === 'all'
              ? 'All pages'
              : mode === 'nonEducation'
              ? 'Exclude education (blogs / free course)'
              : 'Money pages only';
            const dateRange = parseInt(localStorage.getItem('gsc_date_range') || '30', 10);
            const dateRangeText = dateRange === 30 ? '30 days' : dateRange === 60 ? '60 days' : dateRange === 90 ? '90 days' : dateRange === 120 ? '120 days' : dateRange === 180 ? '180 days' : dateRange === 365 ? '365 days' : dateRange === 540 ? '540 days' : `${dateRange} days`;
            recommendationsContainer.innerHTML = renderRecommendationsTable(mode, {
              siteCtr: segData[mode].siteCtr || 0,
              top10Ctr: segData[mode].top10Ctr || 0,
              avgPosition: segData[mode].avgPosition || 0,
              top10Share: segData[mode].top10Share || 0,
              behaviourScore: segData[mode].behaviour || 0,
              rankingScore: segData[mode].ranking || 0
            }, segmentLabel, dateRangeText);
          }
        };
        
        // Helper to attach sort handlers after table is in DOM
        function attachSortHandlers() {
          setTimeout(() => {
            ['ctr', 'impressions', 'clicks', 'position'].forEach(col => {
              const th = document.getElementById(`sort-${col}`);
              if (th) {
                // Remove existing listeners by cloning
                const newTh = th.cloneNode(true);
                th.parentNode.replaceChild(newTh, th);
                newTh.addEventListener('click', () => {
                  if (window.handleSort) {
                    window.handleSort(col);
                  }
                });
              }
            });
          }, 50);
        }
        
        // Attach initial handlers after section is created
        setTimeout(() => {
          attachCopyButtonHandler();
          attachSortHandlers();
        }, 150);
        
        function attachCopyButtonHandler() {
          setTimeout(() => {
            const copyBtn = document.getElementById('top-pages-copy-urls');
            if (copyBtn) {
              // Remove existing listener
              const newCopyBtn = copyBtn.cloneNode(true);
              copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
              
              newCopyBtn.addEventListener('click', async () => {
                const currentMode = window.currentAuthorityMode || 'all';
                const currentTopPages = currentMode === 'all'
                  ? (authorityBySegment?.all?.topPages || [])
                  : currentMode === 'nonEducation'
                  ? (authorityBySegment?.nonEducation?.topPages || [])
                  : (authorityBySegment?.money?.topPages || []);
                
                const text = currentTopPages.map(p => p.url).join('\n');
                try {
                  await navigator.clipboard.writeText(text);
                  newCopyBtn.textContent = 'Copied!';
                  newCopyBtn.style.color = '#10b981';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                    newCopyBtn.style.color = '#666';
                  }, 2000);
                } catch (err) {
                  console.error('Failed to copy URLs:', err);
                  newCopyBtn.textContent = 'Copy failed';
                  setTimeout(() => {
                    newCopyBtn.textContent = 'Copy URLs';
                  }, 2000);
                }
              });
            }
          }, 0);
        }
      }
      
      // Add pillar scorecard table
      // Use current audit data (from function parameters) instead of stale localStorage data
      const auditTimestamp = saved?.timestamp;
      
      // Define schemaAuditData in scope accessible to scorecard table
      const schemaAuditData = schemaAudit || saved?.schemaAudit;
      
      // Get last GSC data date from current data (for Authority and Visibility)
      let gscLastDate = null;
      if (data) {
        // Try timeseries first
        if (data.timeseries && Array.isArray(data.timeseries) && data.timeseries.length > 0) {
          const lastTimeseriesPoint = data.timeseries[data.timeseries.length - 1];
          if (lastTimeseriesPoint && lastTimeseriesPoint.date) {
            gscLastDate = lastTimeseriesPoint.date;
          }
        }
        // Fallback to date from current data if available
        if (!gscLastDate && data.date) {
          gscLastDate = data.date;
        }
      }
      
      // Format date for display
      function formatDataDate(dateStr) {
        if (!dateStr) return '';
        const date = new Date(dateStr + 'T00:00:00'); // Add time to avoid timezone issues
        return date.toLocaleDateString('en-GB', {
          day: '2-digit',
          month: 'short',
          year: 'numeric'
        });
      }
      
      // Format timestamp for display
      function formatTimestamp(timestamp) {
        if (!timestamp) return '';
        const date = new Date(timestamp);
        return date.toLocaleString('en-GB', {
          day: '2-digit',
          month: 'short',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
      }
      
      // Get data date for each pillar
      function getPillarDataDate(pillarKey) {
        if (pillarKey === 'authority' || pillarKey === 'visibility') {
          // GSC-based pillars - use last GSC data date
          return gscLastDate ? formatDataDate(gscLastDate) : (auditTimestamp ? formatTimestamp(auditTimestamp) : '');
        } else {
          // Business Profile and schema audit - use audit timestamp
          return auditTimestamp ? formatTimestamp(auditTimestamp) : '';
        }
      }
      
      const scorecardTable = document.createElement('div');
      scorecardTable.className = 'scorecard-section';
      scorecardTable.innerHTML = `
        <h3 style="margin: 0 0 1rem 0; color: var(--brand-orange);">Pillar Scorecard</h3>
        <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow-x: auto;">
          <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
            <thead>
              <tr style="background: #f5f5f5;">
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 10%;">Pillar</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 6%;">Score</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 6%;">Weight</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 8%;">Status</th>
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 42%;">Description</th>
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 22%;">Improvement Suggestions</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600; width: 6%;">Data Date</th>
              </tr>
            </thead>
            <tbody>
              ${getOrderedPillars(scores).map(([key, score], index) => {
                const rag = getRAGStatus(score);
                
                // Define pillar colors for scorecard table (matching charts)
                const scorecardPillarColors = {
                  localEntity: 'rgba(147, 51, 234, 1)', // Purple
                  serviceArea: '#00FFFF', // Cyan
                  authority: '#99004C', // Dark pink/magenta
                  visibility: 'rgba(37, 99, 235, 1)', // Blue
                  contentSchema: 'rgba(107, 114, 128, 1)' // Grey
                };
                
                const pillarColor = scorecardPillarColors[key] || '#666';
                
                // Build Content/Schema description with schema audit data
                let contentSchemaDesc = 'Quality and completeness of structured data markup across your domain.<br><strong>AI Importance:</strong> Structured data is the primary way AI understands your content. Schema markup directly feeds AI systems, enabling them to extract facts, relationships, and context for use in AI Overviews and answer generation.<br><strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from schema audit (crawls actual website pages for JSON-LD markup).<br><strong>Calculation:</strong> Weighted score based on Foundation schemas (30%), Rich Result eligibility (35%), Coverage (20%), and Type Diversity (15%).';
                
                if (schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
                  const schemaData = schemaAudit.data;
                  const { coverage, totalPages, pagesWithSchema, missingSchemaCount, missingSchemaPages, schemaTypes } = schemaData;
                  
                  // Calculate foundation schemas - use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
                  const allTypes = new Set();
                  if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
                    // Use all detected types for accurate calculation
                    schemaData.allDetectedTypes.forEach(type => {
                      if (type) allTypes.add(type);
                    });
                  } else if (schemaTypes && Array.isArray(schemaTypes)) {
                    // Fallback: collect from schemaTypes array (contains all types, sorted by count)
                    schemaTypes.forEach(item => {
                      if (item.type) allTypes.add(item.type);
                    });
                  }
                  const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
                  const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
                  
                  // Count rich result types
                  const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
                  const uniqueTypesCount = allTypes.size;
                  
                  const richResultTypesList = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
                  contentSchemaDesc += ` <strong>Data Checked:</strong> Foundation schemas: ${foundationPresent}/4 (${foundationTypes.filter(t => allTypes.has(t)).join(', ') || 'none'}), Rich result types: ${richEligibleCount}/${richResultTypesList.length} eligible, Coverage: ${coverage}% (${pagesWithSchema}/${totalPages} pages), Type diversity: ${uniqueTypesCount} unique types. `;
                  
                  if (schemaTypes && schemaTypes.length > 0) {
                    // Show top 15 most common types for readability (still sorted by count)
                    const topTypes = schemaTypes.slice(0, 15).map(t => `${t.type} (${t.count})`).join(', ');
                    contentSchemaDesc += `Schema types found: ${topTypes}${schemaTypes.length > 15 ? '...' : ''}. `;
                  }
                  
                  if (schemaData.missingTypes && schemaData.missingTypes.length > 0) {
                    contentSchemaDesc += `Missing foundation types: ${schemaData.missingTypes.join(', ')}. `;
                  }
                  
                  const richTypes = Object.entries(schemaData.richEligible || {})
                    .filter(([type, eligible]) => eligible)
                    .map(([type]) => type);
                  if (richTypes.length > 0) {
                    contentSchemaDesc += `Rich result eligible: ${richTypes.join(', ')}. `;
                  }
                  
                  // Check if Review schema is detected (even if not in top 10 types)
                  const hasReviewSchema = allTypes.has('Review');
                  if (hasReviewSchema) {
                    // Try to get count from schemaTypes array first, otherwise check schemaData for actual count
                    let reviewCount = schemaTypes?.find(t => t.type === 'Review')?.count || 0;
                    // If not in top 10, check if we have schemaData with all types info
                    if (reviewCount === 0 && schemaData.schemaTypes) {
                      // schemaTypes in response is top 10, but we need to check if Review exists
                      // Since it's in allTypes, it exists, but we don't have the exact count
                      // Just indicate it's detected without showing 0
                      contentSchemaDesc += `Review schema detected - matches GSC review snippets data. `;
                    } else if (reviewCount > 0) {
                      contentSchemaDesc += `Review schema detected (${reviewCount} instances) - matches GSC review snippets data. `;
                    } else {
                      contentSchemaDesc += `Review schema detected - matches GSC review snippets data. `;
                    }
                  }
                } else {
                  contentSchemaDesc += ' <strong>Data Checked:</strong> Foundation schemas (Organization, Person, WebSite, BreadcrumbList), Rich result eligibility (Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList), schema coverage percentage, schema type diversity.';
                }
                
                // Build Local Entity and Service Area descriptions based on whether we have real Business Profile data
                let localEntityDesc, serviceAreaDesc;
                if (hasLocalSignals && localSignalsData) {
                  const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                  const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
                  const locationsCount = localSignalsData.locations?.length || 0;
                  const knowledgePanel = localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected';
                  localEntityDesc = `Consistency and clarity of brand, person and business entity signals.<br><strong>AI Importance:</strong> AI systems rely on clear entity signals to understand who you are and connect your brand across platforms. Strong entity recognition helps AI include you in knowledge panels and entity-based results.<br><strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from Google Business Profile API.<br><strong>Data Checked:</strong> NAP consistency (${napScore}%), knowledge panel (${knowledgePanel}), locations (${locationsCount}), LocalBusiness schema presence, Google Business Profile data.`;
                  serviceAreaDesc = `How clearly AI understands where lessons/workshops run and which regions you cover.<br><strong>AI Importance:</strong> AI uses geographic signals to match queries with local intent. Clear service area data helps AI surface your content for location-specific searches and local AI Overviews.<br><strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from Google Business Profile API.<br><strong>Data Checked:</strong> Service areas (${serviceAreasCount}), NAP consistency (${napScore}%), Google Business Profile service areas.`;
                } else {
                  localEntityDesc = 'Consistency and clarity of brand, person and business entity signals.<br><strong>AI Importance:</strong> AI systems rely on clear entity signals to understand who you are and connect your brand across platforms. Strong entity recognition helps AI include you in knowledge panels and entity-based results.<br><strong>Data Source:</strong> ‚ö†Ô∏è <span style="color: #f59e0b;">Derived calculation</span> from GSC position/CTR (not using real local signals yet).<br><strong>Data Checked:</strong> Currently calculated from search performance metrics. Real data pending: LocalBusiness schema presence, NAP consistency, Google Business Profile data, knowledge panel detection.';
                  serviceAreaDesc = 'How clearly AI understands where lessons/workshops run and which regions you cover.<br><strong>AI Importance:</strong> AI uses geographic signals to match queries with local intent. Clear service area data helps AI surface your content for location-specific searches and local AI Overviews.<br><strong>Data Source:</strong> ‚ö†Ô∏è <span style="color: #f59e0b;">Derived calculation</span> from Local Entity score (not using real service area data yet).<br><strong>Data Checked:</strong> Currently calculated from Local Entity. Real data pending: ServiceArea schema markup, Google Business Profile service areas, geographic keywords, location pages.';
                }
                
                // Format GSC data for display - use current data parameter
                const currentGSCData = data || searchDataForBreakdown || {};
                const ctr = currentGSCData.ctr || 0;
                const avgPosition = currentGSCData.averagePosition || 0;
                const totalClicks = currentGSCData.totalClicks || 0;
                const totalImpressions = currentGSCData.totalImpressions || 0;
                
                const descriptions = {
                  localEntity: localEntityDesc,
                  serviceArea: serviceAreaDesc,
                  authority: `E-A-T (Experience, Expertise, Authoritativeness, Trustworthiness): Depth of educational content, references, reviews, external citations, and demonstrated expertise.<br><strong>AI Importance:</strong> E-A-T is critical for AI systems - they prioritize authoritative, trustworthy sources. Strong E-A-T signals help AI confidently feature your content in AI Overviews and answer boxes.<br><strong>Calculation:</strong> Behaviour Score (40%): CTR for ranking queries + top-10 CTR. Ranking Score (20%): Average position + top-10 impression share. Backlink Score (20%): Referring domains + quality. Review Score (20%): Combined ratings and counts from GBP + Trustpilot snapshot.<br><strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from Google Search Console API, Google Business Profile API, historic Trustpilot reviews snapshot, and backlink CSV upload.<br><strong>Data Checked:</strong> CTR ${ctr.toFixed(2)}%, average position ${avgPosition.toFixed(1)}, clicks ${totalClicks.toLocaleString()}, impressions ${totalImpressions.toLocaleString()}, ranking query performance, backlink metrics, review ratings and counts.`,
                  visibility: `Frequency and prominence in organic search, local pack, snippets and AI Overviews.<br><strong>AI Importance:</strong> AI systems learn from existing search performance. Higher visibility signals quality and relevance, making AI more likely to surface your content in AI-powered results and featured snippets.<br><strong>Data Source:</strong> ‚úÖ <span style="color: #10b981;">Live data</span> from Google Search Console API.<br><strong>Data Checked:</strong> Average position ${avgPosition.toFixed(1)}, CTR ${ctr.toFixed(2)}%, total clicks ${totalClicks.toLocaleString()}, total impressions ${totalImpressions.toLocaleString()}, SERP feature appearances.`,
                  contentSchema: contentSchemaDesc
                };
                
                // Generate dynamic next steps based on actual data and scores
                // Use current data from function parameters
                const getNextSteps = (pillarKey, pillarScore, gscData, schemaData) => {
                  // Use the schemaData parameter passed to this function
                  const currentSchemaData = schemaData;
                  const steps = [];
                  
                  switch(pillarKey) {
                    case 'contentSchema':
                      if (schemaData && schemaData.status === 'ok' && schemaData.data) {
                        const schemaAuditData = schemaData.data;
                        const { coverage, missingSchemaCount, totalPages, pagesWithSchema, schemaTypes, richEligible, missingTypes } = schemaAuditData;
                        
                        // Collect all types for analysis - use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
                        const allTypes = new Set();
                        if (schemaAuditData.allDetectedTypes && Array.isArray(schemaAuditData.allDetectedTypes)) {
                          // Use all detected types for accurate calculation
                          schemaAuditData.allDetectedTypes.forEach(type => {
                            if (type) allTypes.add(type);
                          });
                        } else if (schemaTypes && Array.isArray(schemaTypes)) {
                          // Fallback: collect from schemaTypes array (contains all types, sorted by count)
                          schemaTypes.forEach(item => {
                            if (item.type) allTypes.add(item.type);
                          });
                        }
                        
                        // 1. Foundation Schemas (30% weight)
                        const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
                        const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
                        const foundationMissing = foundationTypes.filter(type => !allTypes.has(type));
                        
                        if (foundationPresent < 4) {
                          steps.push(`<strong>Foundation schemas (30%):</strong> ${foundationPresent}/4 present. Add: ${foundationMissing.join(', ')}`);
                        } else {
                          steps.push(`<strong>Foundation schemas (30%):</strong> ‚úÖ All 4 present (Organization, Person, WebSite, BreadcrumbList)`);
                        }
                        
                        // 2. Rich Result Eligibility (35% weight)
                        const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
                        const richEligibleCount = Object.values(richEligible || {}).filter(eligible => eligible === true).length;
                        const richMissing = richResultTypes.filter(type => !richEligible[type]);
                        
                        if (richEligibleCount < richResultTypes.length) {
                          steps.push(`<strong>Rich results (35%):</strong> ${richEligibleCount}/${richResultTypes.length} eligible. Add: ${richMissing.slice(0, 3).join(', ')}${richMissing.length > 3 ? '...' : ''}`);
                        } else {
                          steps.push(`<strong>Rich results (35%):</strong> ‚úÖ All ${richResultTypes.length} types eligible`);
                        }
                        
                        // 3. Coverage (20% weight)
                        if (coverage < 100) {
                          steps.push(`<strong>Coverage (20%):</strong> ${coverage}% - Add schema to ${missingSchemaCount || 0} pages without markup`);
                        } else {
                          steps.push(`<strong>Coverage (20%):</strong> ‚úÖ 100% - All pages have schema`);
                        }
                        
                        // 4. Type Diversity (15% weight)
                        const uniqueTypesCount = allTypes.size;
                        if (uniqueTypesCount < 15) {
                          steps.push(`<strong>Diversity (15%):</strong> ${uniqueTypesCount} unique types. Add more schema types to reach 15+ for maximum score`);
                        } else {
                          steps.push(`<strong>Diversity (15%):</strong> ‚úÖ ${uniqueTypesCount} unique types (excellent diversity)`);
                        }
                      } else {
                        steps.push(`<strong>Status:</strong> Schema audit data not available - run audit to see detailed metrics`);
                      }
                      break;
                      
                    case 'visibility':
                      // Use current data from function parameters
                      const currentGSCForVisibility = data || searchDataForBreakdown || {};
                      if (currentGSCForVisibility) {
                        const position = currentGSCForVisibility.averagePosition || 0;
                        const ctr = currentGSCForVisibility.ctr || 0;
                        
                        if (position > 10) {
                          steps.push(`<strong>Average position: ${position.toFixed(1)}</strong> - Target top 10 positions (currently ranking ${position > 20 ? 'below' : 'in'} page ${Math.ceil(position / 10)})`);
                        } else {
                          steps.push(`<strong>Average position: ${position.toFixed(1)}</strong> - Excellent! Maintain top 10 rankings`);
                        }
                        
                        if (ctr < 2.0) {
                          steps.push(`<strong>CTR: ${ctr.toFixed(2)}%</strong> - Improve click-through rate (target: 2%+) with better titles/meta descriptions`);
                        } else {
                          steps.push(`<strong>CTR: ${ctr.toFixed(2)}%</strong> - Good CTR! Continue optimizing for featured snippets`);
                        }
                        
                        if (currentGSCForVisibility.totalImpressions < 1000) {
                          steps.push(`<strong>Impressions: ${currentGSCForVisibility.totalImpressions}</strong> - Increase visibility by targeting more keywords`);
                        }
                      }
                      break;
                      
                    case 'authority':
                      // Use current data from function parameters, not stale localStorage
                      const currentGSCForAuthority = data || searchDataForBreakdown || {};
                      if (currentGSCForAuthority) {
                        const ctr = currentGSCForAuthority.ctr || 0;
                        const position = currentGSCForAuthority.averagePosition || 0;
                        // Use current saved data (already loaded at function start)
                        const authorityComponents = scores?.authorityComponents;
                        const backlinkMetrics = saved?.backlinkMetrics;
                        const localSignals = saved?.localSignals;
                        // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
                        const siteReviews = getTrustpilotSnapshot(saved?.siteReviews);
                        
                        // Show component-specific suggestions
                        if (authorityComponents) {
                          if (authorityComponents.behaviour < 50) {
                            steps.push(`<strong>Behaviour Score (${Math.round(authorityComponents.behaviour)}):</strong> Improve CTR for ranking queries. Target 5%+ CTR for all queries, 10%+ for top-10 positions`);
                          }
                          
                          if (authorityComponents.ranking < 50) {
                            steps.push(`<strong>Ranking Score (${Math.round(authorityComponents.ranking)}):</strong> Improve average position and increase top-10 impression share`);
                          }
                          
                          if (authorityComponents.backlinks < 50) {
                            if (backlinkMetrics && backlinkMetrics.referringDomains > 0) {
                              steps.push(`<strong>Backlink Score (${Math.round(authorityComponents.backlinks)}):</strong> Increase referring domains (current: ${backlinkMetrics.referringDomains}, target: 100+) and improve follow ratio (current: ${Math.round((backlinkMetrics.followRatio || 0) * 100)}%)`);
                            } else {
                              steps.push(`<strong>Backlink Score (${Math.round(authorityComponents.backlinks)}):</strong> Upload backlink CSV to measure domain authority`);
                            }
                          }
                          
                          if (authorityComponents.reviews < 50) {
                            const gbpRating = (localSignals && localSignals.status === 'ok' && localSignals.data) ? localSignals.data.gbpRating : null;
                            const gbpCount = (localSignals && localSignals.status === 'ok' && localSignals.data) ? localSignals.data.gbpReviewCount : null;
                            const siteRating = siteReviews?.siteRating || null;
                            const siteCount = siteReviews?.siteReviewCount || null;
                            
                            if (!gbpRating && !siteRating) {
                              steps.push(`<strong>Review Score (${Math.round(authorityComponents.reviews)}):</strong> Add GBP and Trustpilot reviews to build trust signals`);
                            } else {
                              steps.push(`<strong>Review Score (${Math.round(authorityComponents.reviews)}):</strong> Increase review count and maintain high ratings (target: 4.5+ rating, 100+ reviews)`);
                            }
                          }
                        } else {
                          // Fallback to general suggestions if components not available
                          if (ctr < 1.5) {
                            steps.push(`<strong>CTR: ${ctr.toFixed(2)}%</strong> - Low click-through indicates trust issues. Improve E-A-T signals`);
                          }
                          
                          if (position > 15) {
                            steps.push(`<strong>Position: ${position.toFixed(1)}</strong> - Improve rankings through comprehensive, expert content`);
                          }
                        }
                      }
                      break;
                      
                    case 'localEntity':
                      if (hasLocalSignals && localSignalsData) {
                        const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                        const locationsCount = localSignalsData.locations?.length || 0;
                        const knowledgePanel = localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected';
                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using real Business Profile data`);
                        steps.push(`<strong>Data:</strong> NAP consistency: ${napScore}%, Knowledge panel: ${knowledgePanel}, Locations: ${locationsCount}`);
                        if (pillarScore < 70) {
                          if (napScore < 100) {
                            steps.push(`<strong>Action:</strong> Improve NAP consistency (currently ${napScore}%) - ensure Name, Address, and Phone are consistent across all platforms`);
                          }
                          if (!localSignalsData.knowledgePanelDetected) {
                            steps.push(`<strong>Action:</strong> Work on knowledge panel detection - improve entity signals and citations`);
                          }
                          if (locationsCount === 0) {
                            steps.push(`<strong>Action:</strong> Add business location to Google Business Profile`);
                          }
                        } else {
                          steps.push(`<strong>Status:</strong> ‚úÖ Strong local entity signals detected`);
                        }
                      } else {
                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using derived calculation from search performance`);
                        steps.push(`<strong>Priority:</strong> Integrate Google Business Profile API to use real local signals data`);
                        if (pillarScore < 70) {
                          steps.push(`<strong>Action:</strong> Add LocalBusiness schema markup and ensure NAP consistency`);
                        }
                      }
                      break;
                      
                    case 'serviceArea':
                      if (hasLocalSignals && localSignalsData) {
                        const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
                        const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using real Business Profile data`);
                        steps.push(`<strong>Data:</strong> Service areas: ${serviceAreasCount}, NAP consistency: ${napScore}%`);
                        if (pillarScore < 70) {
                          if (serviceAreasCount < 5) {
                            steps.push(`<strong>Action:</strong> Add more service areas to Google Business Profile (currently ${serviceAreasCount}, target: 5+)`);
                          }
                          if (napScore < 100) {
                            steps.push(`<strong>Action:</strong> Improve NAP consistency to boost service area score (currently ${napScore}%)`);
                          }
                        } else {
                          steps.push(`<strong>Status:</strong> ‚úÖ Good service area coverage`);
                        }
                      } else {
                        steps.push(`<strong>Current score: ${Math.round(pillarScore)}</strong> - Using derived calculation from Local Entity`);
                        steps.push(`<strong>Priority:</strong> Integrate Google Business Profile API to get real service area data`);
                        if (pillarScore < 70) {
                          steps.push(`<strong>Action:</strong> Add ServiceArea schema and create location-specific pages`);
                        }
                      }
                      break;
                  }
                  
                  // If no specific steps generated, add generic ones
                  if (steps.length === 0) {
                    if (pillarScore >= 70) {
                      steps.push('Maintain current performance');
                      steps.push('Monitor for any score drops');
                    } else if (pillarScore >= 40) {
                      steps.push('Focus on improving this pillar');
                      steps.push('Review specific metrics above');
                    } else {
                      steps.push('Critical: Immediate action required');
                      steps.push('Review all data sources and implement fixes');
                    }
                  }
                  
                  return steps.slice(0, 3).map(s => `‚Ä¢ ${s}`).join('<br>') || 'No next steps available';
                };
                
                // Generate suggestions based on pillar and score (fallback)
                const getSuggestions = (pillarKey, pillarScore) => {
                  const suggestions = {
                    localEntity: {
                      high: ['Maintain consistent NAP (Name, Address, Phone) across all platforms', 'Continue building personal brand mentions and citations', 'Monitor entity recognition in knowledge panels'],
                      medium: ['Add LocalBusiness schema markup to all location pages', 'Ensure consistent business name and person name across website', 'Build more local citations and directory listings', 'Create an About page with clear entity information', 'Add author markup to content'],
                      low: ['Implement LocalBusiness schema markup immediately', 'Create consistent NAP (Name, Address, Phone) across all platforms', 'Build local citations in relevant directories', 'Add clear About page with entity information', 'Ensure consistent branding across all touchpoints']
                    },
                    serviceArea: {
                      high: ['Continue maintaining clear service area information', 'Update location pages as service areas expand'],
                      medium: ['Add ServiceArea schema markup to location pages', 'Create dedicated pages for each service area/region', 'Include clear geographic information in content', 'Add location-specific keywords naturally', 'Update Google Business Profile with service areas'],
                      low: ['Implement ServiceArea schema markup immediately', 'Create location-specific landing pages', 'Add clear geographic service information to homepage', 'Update all location pages with service area details', 'Include city/region names in page titles and content']
                    },
                    authority: {
                      high: ['Continue producing in-depth, expert content', 'Maintain citation and backlink building efforts', 'Seek opportunities for expert quotes and mentions', 'Keep author bios and credentials up to date'],
                      medium: ['Create more comprehensive, long-form content (2000+ words)', 'Build backlinks from authoritative photography/education sites', 'Seek guest posting opportunities on relevant blogs', 'Collect and display customer reviews/testimonials', 'Create case studies and detailed tutorials', 'Get cited in industry publications', 'Add author bylines with credentials and experience', 'Display certifications, qualifications, and awards', 'Showcase real-world experience and portfolio work', 'Build trust signals (secure site, clear contact info, privacy policy)'],
                      low: ['Produce comprehensive, expert-level content immediately', 'Build backlinks from authoritative sources', 'Create detailed case studies and tutorials', 'Seek media mentions and expert quotes', 'Display customer reviews prominently', 'Build relationships with industry publications', 'Add clear author credentials and experience to all content', 'Display qualifications, certifications, and professional memberships', 'Create About page highlighting expertise and experience', 'Build trust signals (HTTPS, clear contact, privacy policy, terms)']
                    },
                    visibility: {
                      high: ['Continue optimizing for featured snippets', 'Maintain strong ranking positions', 'Monitor SERP feature opportunities'],
                      medium: ['Optimize content for featured snippets (answer boxes)', 'Target long-tail keywords with lower competition', 'Improve page load speed and Core Web Vitals', 'Create FAQ schema for common questions', 'Optimize for "People Also Ask" sections', 'Build internal linking structure'],
                      low: ['Optimize for featured snippets immediately', 'Target low-competition long-tail keywords', 'Improve page speed and mobile experience', 'Add FAQ schema markup', 'Create content targeting "People Also Ask" queries', 'Build strong internal linking structure']
                    },
                    contentSchema: {
                      high: ['Continue maintaining all foundation schemas (Organization, Person, WebSite, BreadcrumbList)', 'Expand rich result eligible types (Article, Event, Course, FAQ, HowTo)', 'Monitor schema validation errors', 'Add more schema type diversity'],
                      medium: ['Add missing foundation schemas (Organization, Person, WebSite, BreadcrumbList)', 'Add rich result eligible types (Article, Event, Course, FAQ, HowTo, VideoObject, Product, LocalBusiness, Review, ImageObject, ItemList)', 'Ensure 100% schema coverage across all pages', 'Increase schema type diversity (target 15+ unique types)', 'Validate all schema using Google Rich Results Test'],
                      low: ['Implement foundation schemas immediately (Organization, Person, WebSite, BreadcrumbList)', 'Add rich result eligible schemas (Article, Event, Course, FAQ, HowTo)', 'Ensure schema coverage reaches 100%', 'Add schema type diversity (target 15+ unique types)', 'Validate all schema using Google Rich Results Test']
                    }
                  };
                  
                  const pillarSuggestions = suggestions[pillarKey];
                  if (!pillarSuggestions) return 'No suggestions available';
                  
                  let selectedSuggestions = [];
                  if (pillarScore >= 70) {
                    selectedSuggestions = pillarSuggestions.high || [];
                  } else if (pillarScore >= 40) {
                    selectedSuggestions = pillarSuggestions.medium || [];
                  } else {
                    selectedSuggestions = pillarSuggestions.low || [];
                  }
                  
                  // Return top 3-4 suggestions as bullet points
                  return selectedSuggestions.slice(0, 4).map(s => `‚Ä¢ ${s}`).join('<br>') || 'No suggestions available';
                };
                
                const weight = pillarWeights[key] || 0;
                const isEven = index % 2 === 0;
                
                // Add CSV download button for Content/Schema
                let descriptionCell = descriptions[key] || '';
                if (key === 'contentSchema' && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
                  const schemaData = schemaAudit.data;
                  const missingSchemaCount = schemaData.missingSchemaCount || 0;
                  const missingSchemaPages = schemaData.missingSchemaPages || [];
                  
                  // Always show button, but disable if no missing pages
                  const buttonDisabled = missingSchemaCount === 0;
                  const buttonStyle = buttonDisabled 
                    ? 'padding: 0.4rem 0.8rem; font-size: 0.8rem; background: #9ca3af; color: white; border: none; border-radius: 4px; cursor: not-allowed; opacity: 0.6;'
                    : 'padding: 0.4rem 0.8rem; font-size: 0.8rem; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;';
                  const buttonText = missingSchemaCount > 0 
                    ? `Download pages without schema (CSV) - ${missingSchemaCount} pages`
                    : 'Download pages without schema (CSV) - No missing pages';
                  
                  const downloadTooltip = missingSchemaCount > 0 
                    ? `Download a CSV file containing ${missingSchemaCount} page URLs that are missing schema markup. Use this list to prioritize which pages need schema added.`
                    : 'All pages have schema markup. No download available.';
                  descriptionCell += `<div style="margin-top: 0.75rem;"><button id="download-missing-schema" class="btn-small" style="${buttonStyle}" ${buttonDisabled ? 'disabled' : ''} title="${downloadTooltip}">${buttonText}</button></div>`;
                }
                
                // Get data date for this pillar
                const pillarDataDate = getPillarDataDate(key);
                const dataDateDisplay = pillarDataDate 
                  ? `<span style="font-size: 0.8rem; color: #666;">${pillarDataDate}</span>`
                  : '<span style="font-size: 0.8rem; color: #999;">N/A</span>';
                
                return `
                  <tr style="border-bottom: 1px solid #eee; background: ${isEven ? '#ffffff' : '#fafafa'};">
                    <td style="padding: 0.75rem; font-weight: 500;">
                      <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <div style="width: 16px; height: 16px; background: ${pillarColor}; border-radius: 2px; border: 1px solid rgba(0,0,0,0.1); flex-shrink: 0;" title="Color key for ${pillarNames[key]} in all reports"></div>
                        <span>${pillarNames[key]}</span>
                      </div>
                    </td>
                    <td style="padding: 0.75rem; text-align: center; font-size: 1.1rem; font-weight: 600; color: ${rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444'};">
                      ${Math.round(score)}
                    </td>
                    <td style="padding: 0.75rem; text-align: center; font-size: 0.9rem; font-weight: 600; color: #666;">
                      ${(weight * 100).toFixed(0)}%
                    </td>
                    <td style="padding: 0.75rem; text-align: center;">
                      <span class="rag-badge ${rag.status}" style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.8rem;">
                        ${rag.label}
                      </span>
                    </td>
                    <td style="padding: 0.75rem; color: #666; font-size: 0.85rem; line-height: 1.6; width: 42%;">${descriptionCell}</td>
                    <td style="padding: 0.75rem; color: #555; font-size: 0.85rem; line-height: 1.6; width: 22%;">${getNextSteps(key, score, currentGSCData, schemaAuditData)}</td>
                    <td style="padding: 0.75rem; text-align: center; width: 6%;">${dataDateDisplay}</td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
        <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-top: 1rem; border-left: 4px solid var(--brand-orange);">
          <p style="margin: 0; font-size: 0.9rem; color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
            <strong>RAG Status Guide:</strong> 
            <span style="color: #10b981; font-weight: 600;">Green (70-100)</span> = Strong performance, 
            <span style="color: #f59e0b; font-weight: 600;">Amber (40-69)</span> = Needs improvement, 
            <span style="color: #ef4444; font-weight: 600;">Red (0-39)</span> = Critical issues
          </p>
          <p style="margin: 0; font-size: 0.9rem; color: #555; line-height: 1.6;">
            <strong>Weighting:</strong> Pillars are weighted by their importance for AI search systems. Authority (30%) and Content/Schema (25%) are most critical, as AI relies heavily on E-A-T signals and structured data. Visibility (20%) reflects how AI learns from existing performance, while Local Entity (15%) and Service Area (10%) are less critical for AI-powered results.
          </p>
        </div>
      `;
      // Insert scorecard table after Score Trends chart (at the end)
      const trendChart = document.getElementById('trendChart');
      if (trendChart && trendChart.parentElement && trendChart.parentElement.parentNode) {
        // Find the chart container (parent of canvas) and insert after it
        const trendChartContainer = trendChart.parentElement;
        trendChartContainer.parentNode.insertBefore(scorecardTable, trendChartContainer.nextSibling);
      } else {
        // Fallback: insert at end of dashboard container
        const dashboardContainer = document.getElementById('dashboard');
        if (dashboardContainer) {
          dashboardContainer.appendChild(scorecardTable);
        } else {
          // Last resort: insert after pillar cards
          pillarCards.parentNode.insertBefore(scorecardTable, pillarCards.nextSibling);
        }
      }

      // Add CSV download handler for missing schema pages
      const downloadBtn = document.getElementById('download-missing-schema');
      if (downloadBtn && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
        const schemaData = schemaAudit.data;
        const missingSchemaCount = schemaData.missingSchemaCount || 0;
        const missingSchemaPages = schemaData.missingSchemaPages || [];
        
        debugLog(`Missing schema pages: count=${missingSchemaCount}, pages=${missingSchemaPages.length}`, 'info');
        debugLog(`Missing schema data: ${JSON.stringify(missingSchemaPages)}`, 'info');
        
        if (missingSchemaCount > 0 && missingSchemaPages.length > 0) {
          downloadBtn.addEventListener('click', () => {
            // Check if any pages have error field to determine CSV columns
            const hasErrors = missingSchemaPages.some(p => p.error);
            const headers = hasErrors ? ['url', 'parentUrl', 'error'] : ['url', 'parentUrl'];
            
            const rows = [
              headers,
              ...missingSchemaPages.map(p => [
                p.url, 
                p.parentUrl || '', 
                ...(hasErrors ? [p.error || ''] : [])
              ]),
            ];
            
            const csv = rows
              .map(r => r.map(v => `"${(v || '').replace(/"/g, '""')}"`).join(','))
              .join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ai-geo-missing-schema-pages.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          });
        } else {
          // Button is already disabled in the HTML, just log
          debugLog(`No missing schema pages to download (count: ${missingSchemaCount})`, 'info');
        }
      } else if (!downloadBtn) {
        debugLog('Download button not found in DOM', 'warn');
      }

      // Display snippet readiness with pie chart visualization
      const snippetScoreElement = document.getElementById('snippetReadinessScore');
      const gaugeStatus = document.getElementById('gaugeStatus');
      const legendElement = document.getElementById('snippetReadinessLegend');
      
      if (snippetScoreElement) {
        snippetScoreElement.textContent = snippetReadiness;
        
        // Color code overall score based on value
        let colorClass = '#ef4444'; // red
        let statusText = 'Critical';
        if (snippetReadiness >= 70) {
          colorClass = '#10b981'; // green
          statusText = 'Strong';
        } else if (snippetReadiness >= 40) {
          colorClass = '#f59e0b'; // amber
          statusText = 'Needs Improvement';
        }
        
        snippetScoreElement.style.color = colorClass;
        
        // Update status text
        if (gaugeStatus) {
          gaugeStatus.textContent = statusText;
          gaugeStatus.style.color = colorClass;
        }
      }
      
      // Create pie chart showing weighted components
      const pieChartCanvas = document.getElementById('snippetReadinessPieChart');
      if (pieChartCanvas && scores) {
        // Destroy existing chart if it exists
        if (window.snippetReadinessChart) {
          window.snippetReadinessChart.destroy();
        }
        
        const contentSchemaScore = Math.round(scores.contentSchema || 0);
        const visibilityScore = Math.round(scores.visibility || 0);
        const authorityScore = Math.round(typeof scores.authority === 'object' ? (scores.authority.score || 0) : (scores.authority || 0));
        
        // Generate top 5 actionable levers to improve snippet readiness
        const explanationDiv = document.getElementById('snippetReadinessExplanation');
        const topActionsList = document.getElementById('topActionsList');
        if (explanationDiv && topActionsList && scores) {
          const contentSchemaScore = Math.round(scores.contentSchema || 0);
          const visibilityScore = Math.round(scores.visibility || 0);
          const authorityScore = Math.round(typeof scores.authority === 'object' ? (scores.authority.score || 0) : (scores.authority || 0));
          
          const actions = [];
          
          // Authority (25% weight) - usually lowest, highest impact potential
          if (authorityScore < 70) {
            const potentialGain = (70 - authorityScore) * 0.25; // Max potential points if improved to 70
            if (data && data.ctr !== undefined) {
              const ctr = data.ctr || 0;
              if (ctr < 1.5) {
                actions.push({
                  priority: 1,
                  impact: potentialGain,
                  text: `Improve Authority (currently ${authorityScore}%): Increase CTR from ${ctr.toFixed(2)}% to 2%+ by optimizing titles and meta descriptions. Potential gain: +${potentialGain.toFixed(1)} points.`
                });
              } else {
                actions.push({
                  priority: 1,
                  impact: potentialGain,
                  text: `Improve Authority (currently ${authorityScore}%): Build backlinks and improve E-A-T signals. Potential gain: +${potentialGain.toFixed(1)} points.`
                });
              }
            } else {
              actions.push({
                priority: 1,
                impact: potentialGain,
                text: `Improve Authority (currently ${authorityScore}%): Build backlinks, improve E-A-T signals, and optimize CTR. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            }
          }
          
          // Content/Schema (40% weight) - highest weight
          if (contentSchemaScore < 100 && schemaAudit && schemaAudit.status === 'ok' && schemaAudit.data) {
            const schemaData = schemaAudit.data;
            const allTypes = new Set();
            // Use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
            if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
              schemaData.allDetectedTypes.forEach(type => {
                if (type) allTypes.add(type);
              });
            } else if (schemaData.schemaTypes && Array.isArray(schemaData.schemaTypes)) {
              schemaData.schemaTypes.forEach(item => {
                if (item.type) allTypes.add(item.type);
              });
            }
            
            const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
            const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
            const richEligibleCount = Object.values(schemaData.richEligible || {}).filter(eligible => eligible === true).length;
            const uniqueTypesCount = allTypes.size;
            
            // Calculate potential improvements
            if (foundationPresent < 4) {
              const missingFoundation = foundationTypes.filter(type => !allTypes.has(type));
              const potentialGain = ((4 - foundationPresent) / 4) * 30 * 0.4; // 30% weight of 40% total
              actions.push({
                priority: 2,
                impact: potentialGain,
                text: `Add missing foundation schemas: ${missingFoundation.join(', ')}. Currently ${foundationPresent}/4. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            }
            
            // Get list of all rich result types (must match api/schema-audit.js)
            const richResultTypes = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'];
            const totalRichResultTypes = richResultTypes.length;
            
            if (richEligibleCount < totalRichResultTypes) {
              const potentialGain = ((totalRichResultTypes - richEligibleCount) / totalRichResultTypes) * 35 * 0.4; // 35% weight of 40% total
              
              // Get list of which rich result types are missing
              const applicableMissingTypes = richResultTypes.filter(type => {
                return !schemaData.richEligible || !schemaData.richEligible[type];
              });
              
              // Build suggestion text
              let suggestionText;
              if (applicableMissingTypes.length > 0) {
                suggestionText = `Add more rich result types. Currently ${richEligibleCount}/${totalRichResultTypes} eligible. Add: ${applicableMissingTypes.join(', ')} schemas. Potential gain: +${potentialGain.toFixed(1)} points.`;
              } else {
                suggestionText = `Add more rich result types. Currently ${richEligibleCount}/${totalRichResultTypes} eligible. Potential gain: +${potentialGain.toFixed(1)} points.`;
              }
              
              actions.push({
                priority: 3,
                impact: potentialGain,
                text: suggestionText
              });
            }
            
            if (uniqueTypesCount < 15) {
              const potentialGain = ((15 - uniqueTypesCount) / 15) * 15 * 0.4; // 15% weight of 40% total
              actions.push({
                priority: 4,
                impact: potentialGain,
                text: `Increase schema diversity. Currently ${uniqueTypesCount} types (target: 15+). Add more schema types across different page types. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            }
          }
          
          // Visibility (35% weight)
          if (visibilityScore < 90 && data && data.averagePosition !== undefined) {
            const position = data.averagePosition || 0;
            const ctr = data.ctr || 0;
            const potentialGain = (90 - visibilityScore) * 0.35;
            
            if (position > 10) {
              actions.push({
                priority: 5,
                impact: potentialGain,
                text: `Improve Visibility (currently ${visibilityScore}%): Target top 10 positions. Current average position: ${position.toFixed(1)}. Optimize for featured snippets. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            } else if (ctr < 2.0) {
              actions.push({
                priority: 5,
                impact: potentialGain,
                text: `Improve Visibility (currently ${visibilityScore}%): Increase CTR from ${ctr.toFixed(2)}% to 2%+ with better titles and meta descriptions. Potential gain: +${potentialGain.toFixed(1)} points.`
              });
            }
          }
          
          // Sort by impact (highest first) and take top 5
          actions.sort((a, b) => b.impact - a.impact);
          const top5Actions = actions.slice(0, 5);
          
          // Update the list
          topActionsList.innerHTML = top5Actions.map((action, index) => 
            `<li style="margin: 0.5rem 0; line-height: 1.5; color: #78350f;">${action.text}</li>`
          ).join('');
          
          if (top5Actions.length === 0) {
            topActionsList.innerHTML = '<li style="margin: 0.5rem 0;">All components are performing well! Maintain current performance.</li>';
          }
          
          explanationDiv.style.display = 'block';
        } else if (explanationDiv) {
          explanationDiv.style.display = 'none';
        }
        
        // Calculate weighted contribution of each component
        const contentSchemaContribution = (contentSchemaScore * 0.4).toFixed(1);
        const visibilityContribution = (visibilityScore * 0.35).toFixed(1);
        const authorityContribution = (authorityScore * 0.25).toFixed(1);
        
        // Create nested pie chart with fill percentages
        // Outer ring: Weighting (40%, 35%, 25%)
        // Inner fill: Score percentage within each segment (like fuel gauge)
        
        const weights = [40, 35, 25];
        const scoresArray = [contentSchemaScore, visibilityScore, authorityScore];
        // Match trend chart colors (avoid red/amber/green to prevent RAG confusion)
        const colors = ['#6b7280', '#2563eb', '#99004C']; // Grey (Content/Schema), Blue (Visibility), Dark pink/magenta (Authority)
        
        // Calculate outer ring data (weighting percentages)
        const outerData = weights;
        
        // Inner ring: Same segment sizes as outer, but we'll use custom drawing to fill only the score percentage
        // The inner data must match outer segment sizes so they align
        const innerData = weights; // Same sizes as outer
        
        // Create chart with custom drawing for inner fill segments
        window.snippetReadinessChart = new Chart(pieChartCanvas, {
          type: 'doughnut',
          data: {
            labels: [
              `Content/Schema`,
              `Visibility`,
              `Authority`
            ],
            datasets: [
              {
                // Outer ring: Weighting percentages (40%, 35%, 25%)
                label: 'Weight',
                data: outerData,
                backgroundColor: colors,
                borderWidth: 4,
                borderColor: '#ffffff',
                cutout: '60%' // Leave room for inner fill
              },
              {
                // Inner ring: Same segment sizes, but will be custom-drawn to show score fill
                label: 'Score Fill',
                data: innerData,
                backgroundColor: colors.map((color, i) => {
                  // Use darker version of segment color for unfilled portion
                  return color + '40'; // Add transparency
                }),
                borderWidth: 4,
                borderColor: '#ffffff',
                cutout: '75%' // Inner ring showing fill
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                display: false // We'll use custom legend
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const datasetIndex = context.datasetIndex;
                    const index = context.dataIndex;
                    
                    if (datasetIndex === 0) {
                      // Outer ring: Show weighting
                      return `Weight: ${weights[index]}%`;
                    } else {
                      // Inner fill: Show score and fill percentage
                      const score = scoresArray[index];
                      const fillPercent = (score / 100) * 100;
                      return `Score: ${score}% (${fillPercent.toFixed(0)}% of segment filled)`;
                    }
                  }
                }
              }
            }
          },
          plugins: [{
            id: 'innerFillAndLabels',
            afterDraw: (chart) => {
              const ctx = chart.ctx;
              const outerMeta = chart.getDatasetMeta(0); // Outer ring
              const innerMeta = chart.getDatasetMeta(1); // Inner ring
              const centerX = chart.chartArea.left + (chart.chartArea.right - chart.chartArea.left) / 2;
              const centerY = chart.chartArea.top + (chart.chartArea.bottom - chart.chartArea.top) / 2;
              const outerRadius = (chart.chartArea.right - chart.chartArea.left) / 2;
              const innerRadius = outerRadius * 0.75; // 75% cutout
              const outerInnerRadius = outerRadius * 0.60; // 60% cutout (where inner ring starts)
              
              // First, clear the inner ring segments (they're drawn by Chart.js but we'll redraw them)
              // Then draw custom filled portions based on scores
              
              outerMeta.data.forEach((outerSegment, index) => {
                const score = scoresArray[index];
                const scorePercent = score / 100; // 0 to 1
                const startAngle = outerSegment.startAngle;
                const endAngle = outerSegment.endAngle;
                const segmentAngle = endAngle - startAngle;
                const filledAngle = segmentAngle * scorePercent;
                const filledEndAngle = startAngle + filledAngle;
                
                // Get RAG color for fill
                let fillColor;
                if (score >= 70) fillColor = '#10b981'; // Green
                else if (score >= 40) fillColor = '#f59e0b'; // Amber
                else fillColor = '#ef4444'; // Red
                
                // Draw the filled portion of this inner segment (fuel gauge effect)
                ctx.save();
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerInnerRadius, startAngle, filledEndAngle, false);
                ctx.arc(centerX, centerY, innerRadius, filledEndAngle, startAngle, true);
                ctx.closePath();
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.restore();
                
                // Draw weight percentage in outer segment (larger, white for grey and blue segments, black for yellow)
                const outerSegmentMidAngle = (startAngle + endAngle) / 2;
                // Position closer to outer edge but still inside segment (about 75% of outer ring width)
                const outerSegmentTextRadius = outerRadius - ((outerRadius - outerInnerRadius) * 0.25);
                const weightTextX = centerX + Math.cos(outerSegmentMidAngle) * outerSegmentTextRadius;
                const weightTextY = centerY + Math.sin(outerSegmentMidAngle) * outerSegmentTextRadius;
                
                ctx.save();
                // Use white text for grey (Content/Schema), blue (Visibility), and dark pink (Authority) segments
                const textColor = (colors[index] === '#6b7280' || colors[index] === '#2563eb' || colors[index] === '#99004C') ? '#ffffff' : '#000000';
                ctx.fillStyle = textColor;
                ctx.font = 'bold 18px system-ui'; // Increased from 14px to 18px
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // Add shadow for readability (dark shadow for white text, light shadow for black text)
                if (textColor === '#ffffff') {
                  ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                } else {
                  ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
                }
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.fillText(`${weights[index]}%`, weightTextX, weightTextY);
                ctx.restore();
                
                // Draw label in the center area, aligned to segment
                const midAngle = (startAngle + endAngle) / 2;
                // Position label in center area (about 30% from center, well inside the 75% cutout)
                const labelRadius = outerRadius * 0.25; // Position in center area
                const labelX = centerX + Math.cos(midAngle) * labelRadius;
                const labelY = centerY + Math.sin(midAngle) * labelRadius;
                
                // Get component names
                const componentNames = ['Content/Schema', 'Visibility', 'Authority'];
                const weight = weights[index];
                
                // Calculate text bounds to avoid arrow overlap
                // Estimate text height: 3 lines with spacing ‚âà 45px total height
                const textHeight = 45;
                const textWidth = 80; // Approximate max text width
                
                // Draw dotted arrow from label to segment edge, routing around text
                ctx.save();
                ctx.strokeStyle = colors[index];
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // Dotted line
                ctx.beginPath();
                
                // Start arrow from edge of text area with more padding to avoid overlap
                // Calculate perpendicular offset to route around text
                const perpAngle = midAngle + Math.PI / 2; // Perpendicular to segment angle
                const textOffset = 35; // Increased from 25 to 35 - more padding from text edge
                const perpOffset = (textHeight / 2) + 8; // Increased padding perpendicular to text
                const arrowStartX = labelX + Math.cos(midAngle) * textOffset + Math.cos(perpAngle) * perpOffset;
                const arrowStartY = labelY + Math.sin(midAngle) * textOffset + Math.sin(perpAngle) * perpOffset;
                
                // End at inner ring edge
                const segmentEdgeX = centerX + Math.cos(midAngle) * innerRadius;
                const segmentEdgeY = centerY + Math.sin(midAngle) * innerRadius;
                
                // Draw curved path around text (simple two-segment path)
                const midX = (arrowStartX + segmentEdgeX) / 2;
                const midY = (arrowStartY + segmentEdgeY) / 2;
                // Offset midpoint further outward to curve around text with more clearance
                const curveOffset = 25; // Increased from 15 to 25 for more clearance
                const curveMidX = midX + Math.cos(perpAngle) * curveOffset;
                const curveMidY = midY + Math.sin(perpAngle) * curveOffset;
                
                ctx.moveTo(arrowStartX, arrowStartY);
                ctx.quadraticCurveTo(curveMidX, curveMidY, segmentEdgeX, segmentEdgeY);
                ctx.stroke();
                
                // Draw arrowhead
                const arrowLength = 8;
                const arrowAngle = Math.atan2(segmentEdgeY - curveMidY, segmentEdgeX - curveMidX);
                ctx.setLineDash([]); // Solid for arrowhead
                ctx.beginPath();
                ctx.moveTo(segmentEdgeX, segmentEdgeY);
                ctx.lineTo(
                  segmentEdgeX - arrowLength * Math.cos(arrowAngle - Math.PI / 6),
                  segmentEdgeY - arrowLength * Math.sin(arrowAngle - Math.PI / 6)
                );
                ctx.moveTo(segmentEdgeX, segmentEdgeY);
                ctx.lineTo(
                  segmentEdgeX - arrowLength * Math.cos(arrowAngle + Math.PI / 6),
                  segmentEdgeY - arrowLength * Math.sin(arrowAngle + Math.PI / 6)
                );
                ctx.stroke();
                ctx.restore();
                
                // Draw text labels without circles (to prevent overlap)
                ctx.save();
                // Add text shadow for better readability without background
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Draw text with readable fonts
                ctx.fillStyle = colors[index];
                ctx.font = 'bold 13px system-ui';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // First line: Component name
                ctx.fillText(`${componentNames[index]}`, labelX, labelY - 8);
                // Second line: Score percentage (colored) - weight removed, now in outer segment
                ctx.fillStyle = fillColor;
                ctx.font = 'bold 15px system-ui';
                ctx.fillText(`Score: ${score}%`, labelX, labelY + 8);
                
                ctx.restore();
              });
            }
          }]
        });
        
        // Create custom legend with scores
        if (legendElement) {
          const getRAGColor = (score) => {
            if (score >= 70) return '#10b981';
            if (score >= 40) return '#f59e0b';
            return '#ef4444';
          };
          
          const getRAGLabel = (score) => {
            if (score >= 70) return 'Green';
            if (score >= 40) return 'Amber';
            return 'Red';
          };
          
          legendElement.innerHTML = `
            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #6b7280;">
              <div style="width: 12px; height: 12px; background: #6b7280; border-radius: 2px; flex-shrink: 0;"></div>
              <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Content/Schema</div>
                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 40%<br>Score: <strong style="color: ${getRAGColor(contentSchemaScore)};">${contentSchemaScore}</strong> (${getRAGLabel(contentSchemaScore)})<br>Contribution: ${contentSchemaContribution} pts</div>
              </div>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #2563eb;">
              <div style="width: 12px; height: 12px; background: #2563eb; border-radius: 2px; flex-shrink: 0;"></div>
              <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Visibility</div>
                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 35%<br>Score: <strong style="color: ${getRAGColor(visibilityScore)};">${visibilityScore}</strong> (${getRAGLabel(visibilityScore)})<br>Contribution: ${visibilityContribution} pts</div>
              </div>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #99004C;">
              <div style="width: 12px; height: 12px; background: #99004C; border-radius: 2px; flex-shrink: 0;"></div>
              <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 0.85rem; color: var(--brand-dark);">Authority</div>
                <div style="font-size: 0.75rem; color: #666; line-height: 1.3;">Weight: 25%<br>Score: <strong style="color: ${getRAGColor(authorityScore)};">${authorityScore}</strong> (${getRAGLabel(authorityScore)})<br>Contribution: ${authorityContribution} pts</div>
              </div>
            </div>
          `;
        }
      }

      // Format numbers for display
      const formatNumber = (num) => {
        if (num >= 1000000) {
          return (num / 1000000).toFixed(2) + 'M';
        } else if (num >= 1000) {
          return (num / 1000).toFixed(2) + 'K';
        }
        return num.toLocaleString();
      };

      // Display metrics
      const metricsGrid = document.getElementById('metricsGrid');
      metricsGrid.innerHTML = `
        <div class="metric-card">
          <div class="value">${formatNumber(data.totalClicks)}</div>
          <div class="label">Total Clicks</div>
        </div>
        <div class="metric-card">
          <div class="value">${formatNumber(data.totalImpressions)}</div>
          <div class="label">Total Impressions</div>
        </div>
        <div class="metric-card">
          <div class="value">${data.averagePosition.toFixed(1)}</div>
          <div class="label">Avg Position</div>
        </div>
        <div class="metric-card">
          <div class="value">${(data.ctr || 0).toFixed(2)}%</div>
          <div class="label">CTR</div>
        </div>
      `;

      // Wait a moment for DOM to update, then create charts (charts need visible canvas)
      setTimeout(async () => {
        debugLog('Starting chart creation (setTimeout callback)...', 'info');
        
        // Check if Chart.js is loaded
        debugLog('Checking Chart.js availability...', 'info');
        if (typeof Chart === 'undefined') {
          debugLog('‚úó Chart.js library not loaded', 'error');
          console.error('Chart.js library not loaded');
          showStatus('Chart.js library failed to load. Please refresh the page.', 'error');
          return;
        }
        debugLog('‚úì Chart.js library available', 'success');
        debugLog(`Chart constructor: ${typeof Chart}`, 'info');

        // Create radar chart
        debugLog('Creating radar chart...', 'info');
        const radarCanvas = document.getElementById('radarChart');
        if (!radarCanvas) {
          debugLog('‚úó Radar chart canvas not found', 'error');
          console.error('Radar chart canvas not found');
          return;
        }
        debugLog('‚úì Radar chart canvas found', 'success');
        
        // Safely destroy existing chart if it exists
        debugLog(`Checking for existing radarChart: ${window.radarChart ? 'exists' : 'null'}`, 'info');
        try {
          if (window.radarChart) {
            debugLog(`radarChart type: ${typeof window.radarChart}`, 'info');
            debugLog(`radarChart instanceof Chart: ${window.radarChart instanceof Chart}`, 'info');
            debugLog(`radarChart.destroy type: ${typeof window.radarChart.destroy}`, 'info');
            
            // Check if it's actually a Chart instance
            if (window.radarChart instanceof Chart && typeof window.radarChart.destroy === 'function') {
              debugLog('Destroying existing radar chart...', 'info');
              window.radarChart.destroy();
              debugLog('‚úì Existing radar chart destroyed', 'success');
            } else {
              debugLog('Existing radarChart is not a valid Chart instance, clearing...', 'info');
            }
            window.radarChart = null;
          } else {
            debugLog('No existing radar chart to destroy', 'info');
          }
        } catch (e) {
          debugLog(`‚úó Error destroying existing radar chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.warn('Error destroying existing radar chart:', e);
          window.radarChart = null;
        }
        
        const radarCtx = radarCanvas.getContext('2d');
        debugLog('Creating new Chart instance for radar chart...', 'info');
        try {
          // Use ordered pillars for consistent ordering
          const orderedPillars = getOrderedPillars(scores);
          const orderedLabels = orderedPillars.map(([key]) => pillarNames[key]);
          const orderedData = orderedPillars.map(([, score]) => score);
          
          // Define pillar colors for radar chart (matching trend chart)
          const radarPillarColors = {
            'Local Entity': 'rgba(147, 51, 234, 1)', // Purple
            'Service Area': '#00FFFF', // Cyan (not RAG color)
            'Authority': '#99004C', // Dark pink/magenta
            'Visibility': 'rgba(37, 99, 235, 1)', // Blue
            'Content / Schema': 'rgba(107, 114, 128, 1)' // Grey
          };
          
          window.radarChart = new Chart(radarCtx, {
            type: 'radar',
            data: {
              labels: orderedLabels,
              datasets: [{
                label: 'Current Scores',
                data: orderedData,
                backgroundColor: 'rgba(59, 130, 246, 0.2)',
                borderColor: 'rgba(37, 99, 235, 1)',
                pointBackgroundColor: 'rgba(37, 99, 235, 1)',
                pointBorderColor: '#fff',
                pointHoverBackgroundColor: '#fff',
                pointHoverBorderColor: 'rgba(37, 99, 235, 1)'
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              layout: {
                padding: {
                  top: 20,
                  bottom: 20,
                  left: 20,
                  right: 20
                }
              },
              scales: {
                r: {
                  beginAtZero: false,
                  min: 20,
                  max: 100,
                  ticks: {
                    stepSize: 20,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    color: '#1e293b'
                  },
                  pointLabels: {
                    font: {
                      size: 16,
                      weight: 'bold'
                    },
                    color: '#1e293b',
                    padding: 20
                  },
                  grid: {
                    color: 'rgba(100, 116, 139, 0.2)'
                  },
                  angleLines: {
                    color: 'rgba(100, 116, 139, 0.3)'
                  }
                }
              },
              plugins: {
                legend: {
                  labels: {
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    padding: 15
                  }
                }
              }
            },
            plugins: [{
              id: 'radarScoreLabels',
              afterDraw: (chart) => {
                const ctx = chart.ctx;
                const scale = chart.scales.r;
                const pointLabelItems = scale._pointLabelItems || [];
                const dataset = chart.data.datasets[0];
                const meta = chart.getDatasetMeta(0);
                
                // Color each point with its pillar color (Chart.js already draws the lines)
                pointLabelItems.forEach((item, index) => {
                  if (item && orderedData[index] !== undefined) {
                    const score = orderedData[index];
                    const label = orderedLabels[index];
                    const color = radarPillarColors[label] || 'rgba(37, 99, 235, 1)';
                    
                    // Get the point for this index
                    const point = meta.data[index];
                    if (point) {
                      // Draw point in pillar color (Chart.js already draws the connecting lines)
                      ctx.save();
                      ctx.fillStyle = color;
                      ctx.beginPath();
                      ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                      ctx.fill();
                      ctx.strokeStyle = '#fff';
                      ctx.lineWidth = 2;
                      ctx.stroke();
                      ctx.restore();
                    }
                    
                    // Get RAG color based on score for text
                    let ragColor = '#1e293b'; // Default dark
                    if (score >= 70) ragColor = '#10b981'; // Green
                    else if (score >= 40) ragColor = '#f59e0b'; // Amber
                    else ragColor = '#ef4444'; // Red
                    
                    // Draw the score percentage directly below the label
                    ctx.save();
                    ctx.fillStyle = ragColor;
                    ctx.font = 'bold 14px system-ui';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
                    ctx.shadowBlur = 4;
                    // Position it 20px below the label
                    const scoreY = item.y + 20;
                    ctx.fillText(`${Math.round(score)}%`, item.x, scoreY);
                    ctx.restore();
                  }
                });
              }
            }]
          });
          debugLog('‚úì Radar chart created successfully', 'success');
          debugLog(`radarChart type after creation: ${typeof window.radarChart}`, 'info');
          debugLog(`radarChart instanceof Chart: ${window.radarChart instanceof Chart}`, 'info');
        } catch (e) {
          debugLog(`‚úó Error creating radar chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.error('Error creating radar chart:', e);
        }

        // Create trend chart (mock data for now)
        debugLog('Creating trend chart...', 'info');
        const trendCanvas = document.getElementById('trendChart');
        if (!trendCanvas) {
          debugLog('‚úó Trend chart canvas not found', 'error');
          console.error('Trend chart canvas not found');
          return;
        }
        debugLog('‚úì Trend chart canvas found', 'success');
        
        // Safely destroy existing chart if it exists
        debugLog(`Checking for existing trendChart: ${window.trendChart ? 'exists' : 'null'}`, 'info');
        try {
          if (window.trendChart) {
            debugLog(`trendChart type: ${typeof window.trendChart}`, 'info');
            debugLog(`trendChart instanceof Chart: ${window.trendChart instanceof Chart}`, 'info');
            debugLog(`trendChart.destroy type: ${typeof window.trendChart.destroy}`, 'info');
            // Check if it's actually a Chart instance
            if (window.trendChart instanceof Chart && typeof window.trendChart.destroy === 'function') {
              debugLog('Destroying existing trend chart...', 'info');
              window.trendChart.destroy();
              debugLog('‚úì Existing trend chart destroyed', 'success');
            } else {
              debugLog('Existing trendChart is not a valid Chart instance, clearing...', 'info');
            }
            window.trendChart = null;
          } else {
            debugLog('No existing trend chart to destroy', 'info');
          }
        } catch (e) {
          debugLog(`‚úó Error destroying existing trend chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.warn('Error destroying existing trend chart:', e);
          window.trendChart = null;
        }
        
        const trendCtx = trendCanvas.getContext('2d');
        const dateRange = parseInt(document.getElementById('dateRange').value) || 30;
        debugLog(`Creating trend chart for date range: ${dateRange} days`, 'info');
        
        // Determine number of data points and label frequency based on date range
        let numDataPoints, labelStep, dateFormat;
        if (dateRange <= 30) {
          // For 30 days or less: show daily data, all labels
          numDataPoints = dateRange;
          labelStep = 1;
          dateFormat = { month: 'short', day: 'numeric' };
        } else if (dateRange <= 90) {
          // For 90 days: show daily data, label every 3-5 days
          numDataPoints = dateRange;
          labelStep = Math.ceil(dateRange / 20); // ~20 labels max
          dateFormat = { month: 'short', day: 'numeric' };
        } else if (dateRange <= 180) {
          // For 6 months: show weekly data, label every week
          numDataPoints = Math.ceil(dateRange / 7);
          labelStep = 1;
          dateFormat = { month: 'short', day: 'numeric' };
        } else {
          // For 12 months: show weekly data, label every 2-4 weeks
          numDataPoints = Math.ceil(dateRange / 7);
          labelStep = Math.ceil(numDataPoints / 15); // ~15 labels max
          dateFormat = { month: 'short', day: 'numeric' };
        }
        
        // Generate date labels and store Date objects
        const allDates = Array.from({ length: numDataPoints }, (_, i) => {
          const d = new Date();
          if (dateRange <= 90) {
            // Daily data
            d.setDate(d.getDate() - (numDataPoints - 1 - i));
          } else {
            // Weekly data
            d.setDate(d.getDate() - ((numDataPoints - 1 - i) * 7));
          }
          return d;
        });
        
        // Store Date objects for period detection (for mock data)
        const mockDateObjects = allDates.slice();
        
        // Create labels array with appropriate spacing and year detection
        let lastVisibleYear = null;
        const dates = allDates.map((d, i) => {
          if (i % labelStep === 0 || i === allDates.length - 1) {
            const currentYear = d.getFullYear();
            const formattedDate = d.toLocaleDateString('en-GB', dateFormat);
            
            // Add year if it changed from the last visible label
            if (lastVisibleYear !== null && currentYear !== lastVisibleYear) {
              lastVisibleYear = currentYear;
              return `${formattedDate} ${currentYear}`;
            }
            
            lastVisibleYear = currentYear;
            return formattedDate;
          }
          return ''; // Empty string for labels we don't want to show
        });
        
        // Store date objects for mock data (will be updated if timeseries data exists)
        chartDateObjects = mockDateObjects;
        debugLog('Creating new Chart instance for trend chart...', 'info');
        try {
          // Use real timeseries data from GSC API
          const timeseries = data.timeseries || [];
          debugLog(`Using ${timeseries.length} timeseries data points from GSC API`, 'info');
          
          // Check if we have data
          if (!data || !data.timeseries || data.timeseries.length === 0) {
            debugLog('‚ö† No timeseries data available. Chart will show mock data. Run a new audit to get real GSC historical data.', 'warn');
            // Show message to user (only if message doesn't already exist)
            const trendCanvas = document.getElementById('trendChart');
            if (trendCanvas && trendCanvas.parentElement) {
              // Check if message already exists
              const existingMessage = trendCanvas.parentElement.querySelector('.trend-chart-warning');
              if (!existingMessage) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'trend-chart-warning';
                messageDiv.style.cssText = 'background: #fff3cd; padding: 1rem; border-radius: 4px; border-left: 3px solid #f59e0b; margin-bottom: 1rem; font-size: 0.9rem; color: #856404;';
                messageDiv.innerHTML = '<strong>No historical data available.</strong> The trend chart requires timeseries data from Google Search Console. Please run a new audit to populate the chart with real historical data.';
                trendCanvas.parentElement.insertBefore(messageDiv, trendCanvas);
              }
            }
          }
          
          // If we have timeseries data, use it; otherwise fall back to mock data
          let localEntityData, serviceAreaData, authorityData, visibilityData, contentSchemaData;
          let contentSchemaDataEstimated = []; // Declare in outer scope for use in chart creation
          let chartDates = dates;
          let chartDateObjects = []; // Store Date objects for period detection
          
          // Declare maps in outer scope so they're accessible everywhere
          let contentSchemaHistory = [];
          let contentSchemaMap = new Map();
          let localEntityMap = new Map();
          let serviceAreaMap = new Map();
          let authorityMap = new Map(); // Store historical Authority scores from Supabase (legacy: single value)
          let authorityBySegmentMap = new Map(); // Store historical segmented Authority scores from Supabase (new: {all, nonEducation, money})
          const currentContentSchema = scores.contentSchema || 0;
          
          if (timeseries.length > 0) {
            // Fetch historical Content/Schema data from Supabase (async operation)
            const propertyUrl = document.getElementById('propertyUrl')?.value || '';
            // Use the actual date range from timeseries data (not calculated from today)
            // This ensures we query the correct year (2024 vs 2025)
            const timeseriesStartDate = timeseries[0].date; // First date in timeseries
            const timeseriesEndDate = timeseries[timeseries.length - 1].date; // Last date in timeseries
            // Use today's date (declare as 'let' so it can be reused later)
            let today = new Date();
            let todayStr = today.toISOString().split('T')[0];
            // Query from timeseries start to today (to catch any data beyond timeseries)
            const startDate = timeseriesStartDate;
            const endDate = todayStr; // Use today, not timeseries end date
            
            debugLog(`Fetching Content/Schema history from Supabase: ${startDate} to ${endDate}`, 'info');
            debugLog(`Timeseries date range: ${timeseriesStartDate} to ${timeseriesEndDate}`, 'info');
            
            // Fetch historical data asynchronously (includes Content/Schema AND Business Profile data)
            if (propertyUrl) {
              try {
                contentSchemaHistory = await fetchContentSchemaHistory(propertyUrl, startDate, endDate);
                // Create maps of dates to scores from Supabase
                // Normalize dates to YYYY-MM-DD format (Supabase might return with timezone)
                contentSchemaHistory.forEach(record => {
                  // Ensure date is in YYYY-MM-DD format (strip time if present)
                  // Handle both date strings and Date objects
                  let normalizedDate = null;
                  if (record.date) {
                    if (typeof record.date === 'string') {
                      normalizedDate = record.date.split('T')[0];
                    } else if (record.date instanceof Date) {
                      normalizedDate = record.date.toISOString().split('T')[0];
                    } else {
                      normalizedDate = String(record.date).split('T')[0];
                    }
                  }
                  
                  if (normalizedDate) {
                    // Content/Schema data
                    if (record.contentSchemaScore !== null && record.contentSchemaScore !== undefined) {
                      contentSchemaMap.set(normalizedDate, record.contentSchemaScore);
                      debugLog(`Mapped Content/Schema: ${normalizedDate} = ${record.contentSchemaScore}`, 'info');
                    }
                    // Business Profile data (Local Entity and Service Area)
                    if (record.localEntityScore !== null && record.localEntityScore !== undefined) {
                      localEntityMap.set(normalizedDate, record.localEntityScore);
                      debugLog(`Mapped Local Entity: ${normalizedDate} = ${record.localEntityScore}`, 'info');
                    }
                    if (record.serviceAreaScore !== null && record.serviceAreaScore !== undefined) {
                      serviceAreaMap.set(normalizedDate, record.serviceAreaScore);
                      debugLog(`Mapped Service Area: ${normalizedDate} = ${record.serviceAreaScore}`, 'info');
                    }
                    // Authority data (use stored Authority score if available, calculated with new formula)
                    if (record.authorityScore !== null && record.authorityScore !== undefined) {
                      authorityMap.set(normalizedDate, record.authorityScore);
                      debugLog(`Mapped Authority: ${normalizedDate} = ${record.authorityScore}`, 'info');
                    }
                    // Segmented Authority data (new: store segmented scores for historical tracking)
                    if (record.authorityBySegment !== null && record.authorityBySegment !== undefined) {
                      // authorityBySegment is a JSON object: {all: {total, behaviour, ranking, backlinks, reviews}, nonEducation: {...}, money: {...}}
                      authorityBySegmentMap.set(normalizedDate, record.authorityBySegment);
                      debugLog(`Mapped Authority by Segment: ${normalizedDate} = ${JSON.stringify(record.authorityBySegment)}`, 'info');
                    }
                  }
                });
                
                const hasHistoricalData = contentSchemaHistory.length > 0;
                if (hasHistoricalData) {
                  debugLog(`Using ${contentSchemaHistory.length} historical audit records from Supabase`, 'info');
                } else {
                  debugLog(`No historical data found. Will use current scores for all points.`, 'info');
                }
              } catch (error) {
                debugLog(`‚ö† Error fetching historical data: ${error.message}`, 'warn');
                contentSchemaHistory = [];
              }
            } else {
              debugLog(`No property URL found. Cannot fetch historical data.`, 'info');
            }
            
            // Get current Business Profile data for Local Entity and Service Area (fallback if no historical data)
            const hasLocalSignals = saved && saved.localSignals && saved.localSignals.status === 'ok' && saved.localSignals.data;
            const localSignalsData = hasLocalSignals ? saved.localSignals.data : null;
            
            // Calculate current Local Entity and Service Area scores from Business Profile data (if available)
            // These will be used as fallback when historical data is not available for a specific date
            let currentLocalEntity, currentServiceArea;
            if (hasLocalSignals && localSignalsData) {
              // Local Entity: NAP consistency + bonuses
              let baseScore = localSignalsData.napConsistencyScore || 0;
              if (localSignalsData.knowledgePanelDetected) {
                baseScore = Math.min(100, baseScore + 10);
              }
              if (localSignalsData.locations && localSignalsData.locations.length > 0) {
                baseScore = Math.min(100, baseScore + 5);
              }
              currentLocalEntity = clampScore(baseScore);
              
              // Service Area: based on service areas count
              const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
              if (serviceAreasCount === 0) {
                currentServiceArea = 0;
              } else if (serviceAreasCount >= 8) {
                // 8+ service areas = 100 (more reasonable threshold)
                currentServiceArea = 100;
              } else {
                // Linear scale: 1 area = 12.5 points (8 areas = 100)
                currentServiceArea = Math.min(100, serviceAreasCount * 12.5);
              }
              
              // Apply NAP consistency as a multiplier (if NAP is low, reduce service area score)
              if (localSignalsData.napConsistencyScore !== null && localSignalsData.napConsistencyScore < 100) {
                const napMultiplier = localSignalsData.napConsistencyScore / 100;
                currentServiceArea = Math.round(currentServiceArea * napMultiplier);
              }
              currentServiceArea = clampScore(currentServiceArea);
              
              debugLog(`Trend chart: Current Business Profile data - Local Entity=${currentLocalEntity}, Service Area=${currentServiceArea} (used as fallback)`, 'info');
            } else {
              // Fallback: use derived calculation
              currentLocalEntity = null;
              currentServiceArea = null;
              debugLog('Trend chart: No Business Profile data available, will use derived calculation for dates without historical data', 'warn');
            }
            
            // Calculate pillar scores for each timeseries point
            // For Local Entity and Service Area: use historical Business Profile data if available,
            // otherwise use calculated data from GSC (derived calculation)
            const calculatePillarFromMetrics = (position, ctr, dateStr = null, topQueries = null, backlinkMetrics = null, localSignals = null, siteReviews = null) => {
              // Position score (same formula as main calculation)
              const clampedPos = Math.max(1, Math.min(40, position));
              const scale = (clampedPos - 1) / 39;
              const posScore = 100 - scale * 90;
              
              // CTR score (needed for Local Entity calculation and Authority fallback)
              // Convert ctr from percentage (0-100) to decimal (0-1), then apply formula
              const ctrDecimal = ctr / 100; // Convert percentage to decimal (e.g., 10% -> 0.10)
              const ctrScore = Math.min((ctrDecimal / 0.10) * 100, 100);
              
              // Calculate each pillar (same formulas as main calculation)
              const visibility = clampScore(posScore);
              
              // Authority: New 4-component model
              // Check if we have stored Authority component scores for this date
              let authority;
              if (dateStr && authorityMap && authorityMap.has(dateStr)) {
                // Use stored Authority score from Supabase (calculated with new formula)
                authority = authorityMap.get(dateStr);
                debugLog(`Authority: Using stored score (${authority}) for ${dateStr}`, 'info');
              } else if (topQueries && Array.isArray(topQueries) && topQueries.length > 0) {
                // We have topQueries data - use full 4-component calculation
                const queriesForCalculation = topQueries.map(q => ({
                  clicks: q.clicks || 0,
                  impressions: q.impressions || 0,
                  ctr: (q.ctr || 0) / 100, // Convert percentage to decimal
                  position: q.position || 0
                }));
                
                const behaviourScore = computeBehaviourScore(queriesForCalculation);
                const rankingScore = computeRankingScore(queriesForCalculation);
                
                // Use real backlink and review scores if available (for today's date)
                const backlinkScore = computeBacklinkScore(backlinkMetrics);
                
                // Get review data
                const gbpRating = (localSignals && localSignals.status === 'ok' && localSignals.data) 
                  ? (localSignals.data.gbpRating !== null && localSignals.data.gbpRating !== undefined ? localSignals.data.gbpRating : null)
                  : null;
                const gbpCount = (localSignals && localSignals.status === 'ok' && localSignals.data) 
                  ? (localSignals.data.gbpReviewCount !== null && localSignals.data.gbpReviewCount !== undefined ? localSignals.data.gbpReviewCount : null)
                  : null;
                const siteRating = siteReviews?.siteRating !== null && siteReviews?.siteRating !== undefined ? siteReviews.siteRating : null;
                const siteCount = siteReviews?.siteReviewCount !== null && siteReviews?.siteReviewCount !== undefined ? siteReviews.siteReviewCount : null;
                
                const reviewScore = computeReviewScore({
                  gbpRating,
                  gbpCount,
                  siteRating,
                  siteCount
                });
                
                authority = clampScore(
                  0.4 * behaviourScore +
                  0.2 * rankingScore +
                  0.2 * backlinkScore +
                  0.2 * reviewScore
                );
                debugLog(`Authority: Calculated from topQueries for ${dateStr || 'current'}: Behaviour=${behaviourScore.toFixed(1)}, Ranking=${rankingScore.toFixed(1)}, Backlinks=${backlinkScore}, Reviews=${reviewScore}, Final=${authority}`, 'info');
              } else {
                // Fallback: Simplified Authority calculation from aggregate metrics
                // Estimate Behaviour and Ranking scores from aggregate metrics
                // Behaviour: Use aggregate CTR as proxy (simplified)
                const estimatedBehaviourScore = Math.min(ctrScore * 0.7, 70); // Max 70 points
                
                // Ranking: Use position score (simplified)
                const estimatedRankingScore = posScore * 0.6; // Max 60 points (position) + 40 (share estimate)
                const estimatedShareScore = 20; // Conservative estimate for top-10 share
                const estimatedRanking = estimatedRankingScore + estimatedShareScore;
                
                const backlinkScore = 50; // Placeholder
                const reviewScore = 50; // Placeholder
                
                authority = clampScore(
                  0.4 * estimatedBehaviourScore +
                  0.2 * estimatedRanking +
                  0.2 * backlinkScore +
                  0.2 * reviewScore
                );
                debugLog(`Authority: Using simplified calculation from aggregate metrics for ${dateStr || 'current'}: Estimated Behaviour=${estimatedBehaviourScore.toFixed(1)}, Estimated Ranking=${estimatedRanking.toFixed(1)}, Final=${authority}`, 'info');
              }
              
              // For Local Entity and Service Area:
              // 1. Check for historical Business Profile data for this specific date
              // 2. If no historical data, use calculated data from GSC (derived calculation)
              // 3. Only use current Business Profile data as last resort (for recent dates without historical data)
              let localEntity, serviceArea;
              
              if (dateStr) {
                const historicalLocalEntity = localEntityMap.get(dateStr);
                const historicalServiceArea = serviceAreaMap.get(dateStr);
                
                if (historicalLocalEntity !== null && historicalLocalEntity !== undefined) {
                  // Use historical Business Profile data
                  localEntity = historicalLocalEntity;
                } else {
                  // Use calculated data from GSC (derived calculation) for historical dates
                  localEntity = clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
                }
                
                if (historicalServiceArea !== null && historicalServiceArea !== undefined) {
                  // Use historical Business Profile data
                  serviceArea = historicalServiceArea;
                } else {
                  // Use calculated data from GSC (derived calculation) for historical dates
                  serviceArea = clampScore(localEntity - 5);
                }
              } else {
                // No date provided - use current Business Profile data if available, otherwise calculated
                localEntity = currentLocalEntity !== null 
                  ? currentLocalEntity 
                  : clampScore(60 + 0.3 * (posScore - 50) + 0.2 * (ctrScore - 50));
                serviceArea = currentServiceArea !== null 
                  ? currentServiceArea 
                  : clampScore(localEntity - 5);
              }
              
              return { visibility, authority, localEntity, serviceArea };
            };
            
            // Extract data arrays from timeseries
            localEntityData = [];
            serviceAreaData = [];
            authorityData = [];
            visibilityData = [];
            contentSchemaData = [];
            contentSchemaDataEstimated = []; // Reset array for timeseries data
            const allDateObjects = []; // Store Date objects for year detection
            const allDates = [];
            
            debugLog(`Content/Schema map has ${contentSchemaMap.size} entries: ${Array.from(contentSchemaMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
            debugLog(`Local Entity map has ${localEntityMap.size} entries: ${Array.from(localEntityMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
            debugLog(`Service Area map has ${serviceAreaMap.size} entries: ${Array.from(serviceAreaMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
            debugLog(`Timeseries has ${timeseries.length} points`, 'info');
            
            // Get current audit data for today's full Authority calculation
            const savedAuditForTrend = loadAuditResults();
            const currentTopQueries = savedAuditForTrend?.searchData?.topQueries || null;
            const currentBacklinkMetrics = savedAuditForTrend?.backlinkMetrics || null;
            const currentLocalSignals = savedAuditForTrend?.localSignals || null;
            // Always use correct Trustpilot snapshot (4.6, 610) - override any old cached values
            const currentSiteReviews = getTrustpilotSnapshot(savedAuditForTrend?.siteReviews || null);
            const currentScores = savedAuditForTrend?.scores;
            
            // Check if segmentation data is available and show/hide toggle
            const authorityBySegment = currentScores?.authority?.bySegment || null;
            const trendToggle = document.getElementById('trendAuthorityModeToggle');
            if (trendToggle) {
              if (authorityBySegment) {
                trendToggle.style.display = 'block';
                // Initialize mode if not set
                if (!window.trendAuthorityMode) {
                  window.trendAuthorityMode = 'all';
                }
              } else {
                trendToggle.style.display = 'none';
                window.trendAuthorityMode = 'all'; // Default to all
              }
            }
            
            // Get Authority score for selected mode
            const getAuthorityForMode = (mode) => {
              if (authorityBySegment && authorityBySegment[mode]) {
                return authorityBySegment[mode].total || authorityBySegment[mode].score || 0;
              }
              // Fallback to all or main score
              if (authorityBySegment && authorityBySegment.all) {
                return authorityBySegment.all.total || authorityBySegment.all.score || 0;
              }
              // Legacy fallback
              const authObj = currentScores?.authority;
              if (typeof authObj === 'object' && authObj !== null) {
                return authObj.score || 0;
              }
              return authObj || 0;
            };
            
            timeseries.forEach(point => {
              const pointDate = point.date; // YYYY-MM-DD format
              
              // Check if this is today's date - if so, use full Authority calculation
              const isToday = pointDate === todayStr;
              
              // Check if we have historical data from Supabase for Local Entity, Service Area, and Authority
              const historicalLocalEntity = localEntityMap.get(pointDate);
              const historicalServiceArea = serviceAreaMap.get(pointDate);
              const historicalAuthority = authorityMap.get(pointDate);
              
              // For today's date, use current topQueries, backlinkMetrics, and reviews for full calculation
              // For historical dates, pass null (will use simplified calculation)
              const topQueriesForDate = isToday ? currentTopQueries : null;
              const backlinkMetricsForDate = isToday ? currentBacklinkMetrics : null;
              const localSignalsForDate = isToday ? currentLocalSignals : null;
              const siteReviewsForDate = isToday ? currentSiteReviews : null;
              
              // Pass date to calculatePillarFromMetrics so it can check for historical data
              // For today, pass topQueries and other data for full calculation
              // For historical dates, pass null (will use simplified calculation)
              const pillarScores = calculatePillarFromMetrics(
                point.position, 
                point.ctr, 
                pointDate, 
                topQueriesForDate,
                backlinkMetricsForDate,
                localSignalsForDate,
                siteReviewsForDate
              );
              
              // Use historical data from Supabase if available, otherwise use calculated scores
              if (historicalLocalEntity !== undefined && historicalLocalEntity !== null) {
                localEntityData.push(historicalLocalEntity);
                debugLog(`Using historical Local Entity (${historicalLocalEntity}) for ${pointDate}`, 'info');
              } else {
                localEntityData.push(pillarScores.localEntity);
              }
              
              if (historicalServiceArea !== undefined && historicalServiceArea !== null) {
                serviceAreaData.push(historicalServiceArea);
                debugLog(`Using historical Service Area (${historicalServiceArea}) for ${pointDate}`, 'info');
              } else {
                serviceAreaData.push(pillarScores.serviceArea);
              }
              
              // Use Authority score based on selected mode, prioritizing segmented historical data when available
              // Check if we have segmented Authority data for this date in Supabase
              const historicalAuthorityBySegment = authorityBySegmentMap.get(pointDate);
              const selectedMode = window.trendAuthorityMode || 'all';
              
              if (historicalAuthorityBySegment && historicalAuthorityBySegment[selectedMode]) {
                // Use segmented Authority score from Supabase for the selected mode
                const modeScore = historicalAuthorityBySegment[selectedMode].total || historicalAuthorityBySegment[selectedMode].score || historicalAuthorityBySegment[selectedMode];
                authorityData.push(modeScore);
                debugLog(`Using historical segmented Authority (${modeScore}) for ${pointDate} (mode: ${selectedMode})`, 'info');
              } else if (isToday && authorityBySegment) {
                // For today, use current segmented Authority scores (allows toggling between segments)
                const modeScore = getAuthorityForMode(selectedMode);
                authorityData.push(modeScore);
                debugLog(`Using current Authority score (${modeScore}) for ${pointDate} (mode: ${selectedMode}, today)`, 'info');
              } else if (historicalAuthority !== undefined && historicalAuthority !== null) {
                // Fallback: use legacy historical Authority from Supabase (single value, not segmented)
                authorityData.push(historicalAuthority);
                debugLog(`Using legacy historical Authority (${historicalAuthority}) for ${pointDate}`, 'info');
              } else {
                // Fallback: use calculated Authority score
                const authScore = typeof pillarScores.authority === 'object' ? pillarScores.authority.score : pillarScores.authority;
                authorityData.push(authScore);
                debugLog(`Using calculated Authority (${authScore}) for ${pointDate}`, 'info');
              }
              
              visibilityData.push(pillarScores.visibility);
              
              // Check if we have real historical data for this date
              const realScore = contentSchemaMap.get(pointDate);
              
              if (realScore !== undefined && realScore !== null) {
                // We have real data for this date
                contentSchemaData.push(realScore);
                contentSchemaDataEstimated.push(null); // No estimated value
                debugLog(`Content/Schema: Added ${realScore} for ${pointDate}`, 'info');
              } else {
                // No real data for this date - use null (don't show estimated line)
                contentSchemaData.push(null);
                contentSchemaDataEstimated.push(null);
              }
              
              // Format date for chart (timeseries dates are YYYY-MM-DD)
              const dateObj = new Date(point.date);
              allDateObjects.push(dateObj);
              allDates.push(dateObj.toLocaleDateString('en-GB', dateFormat));
            });
            
            // Log Content/Schema data array summary after timeseries loop
            const contentSchemaValid = contentSchemaData.filter(v => v !== null && v !== undefined);
            debugLog(`Content/Schema data after timeseries: ${contentSchemaValid.length} valid values out of ${contentSchemaData.length} total. Values: ${contentSchemaValid.join(', ')}`, 'info');
            
            // Fill in missing dates between last GSC date and today
            // GSC data is delayed by 2-3 days, so we need to add missing dates
            // Reuse 'today' and 'todayStr' variables (already declared above)
            today = new Date();
            today.setHours(0, 0, 0, 0); // Normalize to start of day
            todayStr = today.toISOString().split('T')[0];
            const lastTimeseriesDate = timeseries.length > 0 ? timeseries[timeseries.length - 1].date : null;
            
            // Check if we're missing recent dates (likely due to GSC delay)
            let hasRecentMissingDates = false;
            if (lastTimeseriesDate) {
              const lastDate = new Date(lastTimeseriesDate);
              lastDate.setHours(0, 0, 0, 0);
              const daysSinceLastData = Math.floor((today - lastDate) / (1000 * 60 * 60 * 24));
              hasRecentMissingDates = daysSinceLastData > 1; // More than 1 day gap indicates GSC delay
              
              // Show a note about GSC delay if we're missing recent dates
              if (hasRecentMissingDates) {
                const trendCanvas = document.getElementById('trendChart');
                if (trendCanvas && trendCanvas.parentElement) {
                  // Check if note already exists
                  const existingNote = trendCanvas.parentElement.querySelector('.gsc-delay-note');
                  if (!existingNote) {
                    const noteDiv = document.createElement('div');
                    noteDiv.className = 'gsc-delay-note';
                    noteDiv.style.cssText = 'background: #e0f2fe; padding: 0.75rem; border-radius: 4px; border-left: 3px solid #0284c7; margin-bottom: 1rem; font-size: 0.85rem; color: #0c4a6e;';
                    noteDiv.innerHTML = `<strong>Note:</strong> Google Search Console data is typically delayed by 2-3 days. Recent dates (last ${daysSinceLastData} day${daysSinceLastData > 1 ? 's' : ''}) may show no data until GSC updates.`;
                    trendCanvas.parentElement.insertBefore(noteDiv, trendCanvas);
                  }
                }
              }
            }
            
            if (lastTimeseriesDate) {
              const lastDate = new Date(lastTimeseriesDate);
              lastDate.setHours(0, 0, 0, 0);
              
              debugLog(`Last GSC date: ${lastTimeseriesDate}, Today: ${todayStr}`, 'info');
              debugLog(`Content/Schema map has ${contentSchemaMap.size} entries before filling missing dates`, 'info');
              debugLog(`Content/Schema map entries: ${Array.from(contentSchemaMap.entries()).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
              
              // Add all missing dates from day after last GSC date to today
              const currentDate = new Date(lastDate);
              currentDate.setDate(currentDate.getDate() + 1); // Start from day after last GSC date
              
              // Compare dates as strings to avoid timezone issues
              const todayDateStr = today.toISOString().split('T')[0];
              
              while (currentDate.toISOString().split('T')[0] <= todayDateStr) {
                const dateStr = currentDate.toISOString().split('T')[0];
                const dateObj = new Date(dateStr);
                
                allDateObjects.push(dateObj);
                allDates.push(dateObj.toLocaleDateString('en-GB', dateFormat));
                
                // For GSC-based pillars (Authority, Visibility), use current audit data if available
                // Check if this is today or recent date - if so, use current audit data
                const isTodayOrRecent = dateStr === todayStr || (currentDate >= lastDate && currentDate <= today);
                if (isTodayOrRecent && savedAuditForTrend) {
                  // Use current audit data for Authority and Visibility
                  const currentSearchData = savedAuditForTrend?.searchData;
                  const currentScores = savedAuditForTrend?.scores;
                  
                  if (currentSearchData) {
                    // Calculate Visibility from current position
                    const currentPosition = currentSearchData.averagePosition || 40;
                    const clampedPos = Math.max(1, Math.min(40, currentPosition));
                    const scale = (clampedPos - 1) / 39;
                    const posScore = 100 - scale * 90;
                    const visibility = clampScore(posScore);
                    visibilityData.push(visibility);
                    debugLog(`‚úì Added Visibility score (${visibility}) for ${dateStr} from current audit`, 'info');
                    
                    // Calculate Authority from current audit scores using selected mode
                    const selectedMode = window.trendAuthorityMode || 'all';
                    const currentAuthority = getAuthorityForMode(selectedMode);
                    if (currentAuthority !== null && currentAuthority !== undefined) {
                      authorityData.push(currentAuthority);
                      debugLog(`‚úì Added Authority score (${currentAuthority}) for ${dateStr} from current audit (mode: ${selectedMode})`, 'info');
                    } else {
                      // Fallback: calculate Authority from current data
                      const pillarScores = calculatePillarFromMetrics(
                        currentPosition,
                        currentSearchData.ctr || 0,
                        dateStr,
                        currentTopQueries,
                        currentBacklinkMetrics,
                        currentLocalSignals,
                        currentSiteReviews
                      );
                      const authScore = typeof pillarScores.authority === 'object' ? pillarScores.authority.score : pillarScores.authority;
                      authorityData.push(authScore);
                      debugLog(`‚úì Calculated Authority score (${authScore}) for ${dateStr} from current audit data`, 'info');
                    }
                  } else {
                    // No current search data - use null
                    authorityData.push(null);
                    visibilityData.push(null);
                  }
                } else {
                  // Not today/recent - no data yet due to GSC delay
                  authorityData.push(null);
                  visibilityData.push(null);
                }
                
                // For Local Entity and Service Area, check if we have historical data from Supabase
                const historicalLocalEntity = localEntityMap.get(dateStr);
                const historicalServiceArea = serviceAreaMap.get(dateStr);
                
                if (historicalLocalEntity !== undefined && historicalLocalEntity !== null) {
                  localEntityData.push(historicalLocalEntity);
                  debugLog(`‚úì Added Local Entity score (${historicalLocalEntity}) for ${dateStr} from Supabase`, 'info');
                } else {
                  localEntityData.push(null);
                  debugLog(`No Local Entity data for ${dateStr}`, 'info');
                }
                
                if (historicalServiceArea !== undefined && historicalServiceArea !== null) {
                  serviceAreaData.push(historicalServiceArea);
                  debugLog(`‚úì Added Service Area score (${historicalServiceArea}) for ${dateStr} from Supabase`, 'info');
                } else {
                  serviceAreaData.push(null);
                  debugLog(`No Service Area data for ${dateStr}`, 'info');
                }
                
                // For Content/Schema, check if we have real data for this date
                const realScore = contentSchemaMap.get(dateStr);
                if (realScore !== undefined && realScore !== null) {
                  // We have real data for this date
                  contentSchemaData.push(realScore);
                  contentSchemaDataEstimated.push(null);
                  debugLog(`‚úì Added Content/Schema score (${realScore}) for ${dateStr} from Supabase`, 'info');
                } else {
                  // No real data - use null (don't show estimated)
                  contentSchemaData.push(null);
                  contentSchemaDataEstimated.push(null);
                  debugLog(`No Content/Schema data for ${dateStr} (checked map, not found)`, 'info');
                }
                
                // Move to next day
                currentDate.setDate(currentDate.getDate() + 1);
              }
              
              debugLog(`Filled missing dates: added ${allDateObjects.length - timeseries.length} additional dates`, 'info');
            } else if (timeseries.length === 0) {
              // No timeseries data at all - just add today
              const todayDateObj = new Date(todayStr);
              allDateObjects.push(todayDateObj);
              allDates.push(todayDateObj.toLocaleDateString('en-GB', dateFormat));
              
              // For GSC-based pillars (Authority, Visibility), use current audit data if available
              if (savedAuditForTrend) {
                const currentSearchData = savedAuditForTrend?.searchData;
                const currentScores = savedAuditForTrend?.scores;
                
                if (currentSearchData) {
                  // Calculate Visibility from current position
                  const currentPosition = currentSearchData.averagePosition || 40;
                  const clampedPos = Math.max(1, Math.min(40, currentPosition));
                  const scale = (clampedPos - 1) / 39;
                  const posScore = 100 - scale * 90;
                  const visibility = clampScore(posScore);
                  visibilityData.push(visibility);
                  debugLog(`‚úì Added Visibility score (${visibility}) for today from current audit`, 'info');
                  
                  // Use current Authority score if available
                  const currentAuthority = currentScores?.authority || null;
                  if (currentAuthority !== null && currentAuthority !== undefined) {
                    authorityData.push(currentAuthority);
                    debugLog(`‚úì Added Authority score (${currentAuthority}) for today from current audit`, 'info');
                  } else {
                    // Fallback: calculate Authority from current data
                    const pillarScores = calculatePillarFromMetrics(
                      currentPosition,
                      currentSearchData.ctr || 0,
                      todayStr,
                      currentTopQueries,
                      currentBacklinkMetrics,
                      currentLocalSignals,
                        currentSiteReviews
                      );
                    const authScore = typeof pillarScores.authority === 'object' ? pillarScores.authority.score : pillarScores.authority;
                    authorityData.push(authScore);
                    debugLog(`‚úì Calculated Authority score (${authScore}) for today from current audit data`, 'info');
                  }
                } else {
                  // No current search data - use null
                  authorityData.push(null);
                  visibilityData.push(null);
                }
              } else {
                // No saved audit data - use null
                authorityData.push(null);
                visibilityData.push(null);
              }
              
              // For today, use current Business Profile data if available, otherwise calculated
              if (currentLocalEntity !== null) {
                localEntityData.push(currentLocalEntity);
              } else {
                localEntityData.push(null);
              }
              if (currentServiceArea !== null) {
                serviceAreaData.push(currentServiceArea);
              } else {
                serviceAreaData.push(null);
              }
              
              // For Content/Schema, check if we have real data for today
              const todayRealScore = contentSchemaMap.get(todayStr);
              if (todayRealScore !== undefined) {
                contentSchemaData.push(todayRealScore);
                contentSchemaDataEstimated.push(null);
                debugLog(`‚úì Added today's Content/Schema score (${todayRealScore}) from Supabase`, 'info');
              } else {
                contentSchemaData.push(null);
                contentSchemaDataEstimated.push(currentContentSchema);
                debugLog(`Using current Content/Schema score (${currentContentSchema}) as estimate for today`, 'info');
              }
            }
            
            // Apply label spacing to dates with year detection (show every labelStep-th label)
            let lastVisibleYear = null;
            chartDates = allDates.map((d, i) => {
              if (i % labelStep === 0 || i === allDates.length - 1) {
                const currentYear = allDateObjects[i].getFullYear();
                
                // Add year if it changed from the last visible label
                if (lastVisibleYear !== null && currentYear !== lastVisibleYear) {
                  lastVisibleYear = currentYear;
                  return `${d} ${currentYear}`;
                }
                
                lastVisibleYear = currentYear;
                return d;
              }
              return ''; // Empty string for labels we don't want to show
            });
            
            // Store date objects for timeseries data
            chartDateObjects = allDateObjects;
          } else {
            // No timeseries data available - use all nulls (no mock data)
            debugLog('No timeseries data available - chart will show empty with null values', 'warn');
            
            // Use all null values - no mock/estimated data
            localEntityData = new Array(numDataPoints).fill(null);
            serviceAreaData = new Array(numDataPoints).fill(null);
            authorityData = new Array(numDataPoints).fill(null);
            visibilityData = new Array(numDataPoints).fill(null);
            contentSchemaData = new Array(numDataPoints).fill(null);
            contentSchemaDataEstimated = new Array(numDataPoints).fill(null);
            
            // Generate dates for the date range
            const fallbackDates = [];
            const fallbackDateObjects = [];
            for (let i = 0; i < numDataPoints; i++) {
              const dateObj = new Date();
              if (dateRange <= 90) {
                // Daily data
                dateObj.setDate(dateObj.getDate() - (numDataPoints - 1 - i));
              } else {
                // Weekly data
                dateObj.setDate(dateObj.getDate() - ((numDataPoints - 1 - i) * 7));
              }
              fallbackDateObjects.push(dateObj);
              fallbackDates.push(dateObj.toLocaleDateString('en-GB', dateFormat));
            }
            chartDates = fallbackDates;
            chartDateObjects = fallbackDateObjects;
          }
          
          // Calculate min and max across all datasets (filter out null values)
          const allData = [...localEntityData, ...serviceAreaData, ...authorityData, ...visibilityData, ...contentSchemaData].filter(v => v !== null && v !== undefined && !isNaN(v));
          const dataMin = allData.length > 0 ? Math.min(...allData) : 0;
          const dataMax = allData.length > 0 ? Math.max(...allData) : 100;
          const dataRange = dataMax - dataMin;
          
          // Debug: Log Content/Schema data to see what we have
          const contentSchemaValid = contentSchemaData.filter(v => v !== null && v !== undefined && !isNaN(v));
          debugLog(`Content/Schema dataset: ${contentSchemaValid.length} valid values out of ${contentSchemaData.length} total. Values: ${contentSchemaValid.join(', ')}`, 'info');
          debugLog(`Content/Schema data array length: ${contentSchemaData.length}, chart dates length: ${chartDates.length}`, 'info');
          debugLog(`Last few Content/Schema values: ${contentSchemaData.slice(-5).join(', ')}`, 'info');
          debugLog(`Content/Schema map size: ${contentSchemaMap.size}, map entries: ${Array.from(contentSchemaMap.entries()).slice(-10).map(([d, s]) => `${d}=${s}`).join(', ')}`, 'info');
          
          // Debug: Log Local Entity and Service Area data arrays
          const localEntityValid = localEntityData.filter(v => v !== null && v !== undefined && !isNaN(v));
          const serviceAreaValid = serviceAreaData.filter(v => v !== null && v !== undefined && !isNaN(v));
          debugLog(`Local Entity dataset: ${localEntityValid.length} valid values out of ${localEntityData.length} total. Last 5 values: ${localEntityData.slice(-5).join(', ')}`, 'info');
          debugLog(`Service Area dataset: ${serviceAreaValid.length} valid values out of ${serviceAreaData.length} total. Last 5 values: ${serviceAreaData.slice(-5).join(', ')}`, 'info');
          debugLog(`Local Entity map size: ${localEntityMap.size}, Service Area map size: ${serviceAreaMap.size}`, 'info');
          
          // If Content/Schema has no valid data, log a warning
          if (contentSchemaValid.length === 0) {
            debugLog(`‚ö† WARNING: Content/Schema dataset has NO valid values! Map has ${contentSchemaMap.size} entries.`, 'error');
            debugLog(`Content/Schema history fetched: ${contentSchemaHistory.length} records`, 'info');
          }
          
          // Calculate dynamic Y-axis range
          // Minimum range of 30, or actual range + padding if larger
          const minRange = 30;
          const padding = 5; // Add 5 points padding above and below
          const actualRange = Math.max(minRange, dataRange + (padding * 2));
          
          // Calculate Y-axis min and max
          let yAxisMin = Math.max(0, Math.floor(dataMin - padding));
          // Ensure the red risk band (30-39) is always visible in the chart area
          // by never allowing the bottom of the axis to sit above 30.
          if (yAxisMin > 30) {
            yAxisMin = 30;
          }
          const yAxisMax = Math.min(100, Math.ceil(yAxisMin + actualRange));
          
          // Adjust step size based on range (smaller steps for smaller ranges)
          let stepSize = 10;
          if (actualRange <= 40) {
            stepSize = 5;
          } else if (actualRange <= 60) {
            stepSize = 10;
          } else {
            stepSize = 20;
          }
          
          debugLog(`Y-axis range: ${yAxisMin} to ${yAxisMax} (range: ${actualRange}, step: ${stepSize})`, 'info');
          
          // Calculate trend percentages for each dataset
          // Filter out null values to get actual first and last data points
          const calculateTrend = (data) => {
            // Filter out null/undefined values
            const validData = data.filter(v => v !== null && v !== undefined && !isNaN(v));
            if (validData.length < 2) return { percent: 0, isUp: false, isNeutral: true };
            
            const first = validData[0];
            const last = validData[validData.length - 1];
            
            // Handle division by zero (when first value is 0)
            if (first === 0) {
              // If first is 0 and last is also 0, no change
              if (last === 0) {
                return { percent: 0, isUp: false, isNeutral: true };
              }
              // If first is 0 but last has value, show as 100% increase
              return { percent: 100, isUp: true, isNeutral: false };
            }
            
            const percent = ((last - first) / first) * 100;
            
            // Handle NaN or infinite result
            if (isNaN(percent) || !isFinite(percent)) {
              return { percent: 0, isUp: false, isNeutral: true };
            }
            
            // Cap at 100% to avoid showing unrealistic percentages
            const cappedPercent = Math.min(Math.abs(percent), 100);
            // Consider values very close to 0 as neutral (within 0.1% threshold)
            const isNeutral = Math.abs(percent) < 0.1;
            return { 
              percent: cappedPercent, 
              isUp: percent > 0, 
              isNeutral: isNeutral 
            };
          };
          
          const localEntityTrend = calculateTrend(localEntityData);
          const serviceAreaTrend = calculateTrend(serviceAreaData);
          const authorityTrend = calculateTrend(authorityData);
          const visibilityTrend = calculateTrend(visibilityData);
          const contentSchemaTrend = calculateTrend(contentSchemaData);

          // Update HTML trend summary row
          const trendSummaryRow = document.getElementById('trendSummaryRow');
          if (trendSummaryRow) {
            const buildPill = (label, trend) => {
              let arrow, sign, cls;
              if (trend.isNeutral) {
                arrow = '‚Üí';
                sign = '';
                cls = 'neutral';
              } else {
                arrow = trend.isUp ? '‚Üë' : '‚Üì';
                sign = trend.isUp ? '+' : '';
                cls = trend.isUp ? 'up' : 'down';
              }
              return `
                <div class="trend-pill">
                  <span class="label">${label}</span>
                  <span class="value ${cls}">${arrow} ${sign}${trend.percent.toFixed(1)}%</span>
                </div>
              `;
            };
            trendSummaryRow.innerHTML = [
              buildPill('Local Entity', localEntityTrend),
              buildPill('Service Area', serviceAreaTrend),
              buildPill('Authority', authorityTrend),
              buildPill('Visibility', visibilityTrend),
              buildPill('Content/Schema', contentSchemaTrend)
            ].join('');
          }
          
          // Plugin to make year transition labels bold
          const yearLabelBoldPlugin = {
            id: 'yearLabelBold',
            afterDraw: (chart) => {
              const xScale = chart.scales.x;
              const ctx = chart.ctx;
              const rotation = -45 * (Math.PI / 180); // -45 degrees in radians
              
              // Get the chart dates array from the chart's data labels (original labels before callback)
              const chartDates = chart.data.labels || [];
              
              // Iterate through all data points to find year labels
              chartDates.forEach((originalLabel, dataIndex) => {
                // Check if original label contains a year (4-digit number at the end)
                if (originalLabel && /\d{4}$/.test(originalLabel)) {
                  const label = originalLabel;
                  // Get pixel position for this data point
                  const tickPosition = xScale.getPixelForValue(dataIndex);
                  const yPosition = chart.chartArea.bottom + 25;
                  
                  // Save context
                  ctx.save();
                  
                  // Translate to tick position and rotate
                  ctx.translate(tickPosition, yPosition);
                  ctx.rotate(rotation);
                  
                  // Set bold font with larger size
                  ctx.font = 'bold 14px Arial';
                  ctx.fillStyle = '#000';
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  
                  // Measure text to clear area properly
                  const metrics = ctx.measureText(label);
                  const textWidth = metrics.width;
                  const textHeight = 18;
                  
                  // Clear a larger area to remove the original label
                  ctx.globalCompositeOperation = 'destination-out';
                  ctx.fillRect(-textWidth/2 - 6, -textHeight/2 - 3, textWidth + 12, textHeight + 6);
                  
                  // Switch back to normal drawing
                  ctx.globalCompositeOperation = 'source-over';
                  
                  // Draw bold label
                  ctx.fillText(label, 0, 0);
                  
                  // Restore context
                  ctx.restore();
                }
              });
            }
          };
          
          // Plugin to add RAG background bands with stronger contrast
          const ragBackgroundPlugin = {
            id: 'ragBackground',
            beforeDraw: (chart) => {
              const ctx = chart.ctx;
              const chartArea = chart.chartArea;
              const yScale = chart.scales.y;
              
              // Red zone (0-39) - increased opacity and saturation
              if (yAxisMin <= 39) {
                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(0, yAxisMin)));
                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(39, yAxisMax)));
                ctx.fillStyle = 'rgba(220, 38, 38, 0.18)'; // More saturated red, higher opacity
                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
              }
              
              // Amber zone (40-69) - increased opacity and saturation
              if (yAxisMin <= 69 && yAxisMax >= 40) {
                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(40, yAxisMin)));
                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(69, yAxisMax)));
                ctx.fillStyle = 'rgba(234, 179, 8, 0.18)'; // More saturated amber/yellow, higher opacity
                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
              }
              
              // Green zone (70-100) - increased opacity and saturation
              if (yAxisMax >= 70) {
                const start = Math.max(chartArea.top, yScale.getPixelForValue(Math.max(70, yAxisMin)));
                const end = Math.min(chartArea.bottom, yScale.getPixelForValue(Math.min(100, yAxisMax)));
                ctx.fillStyle = 'rgba(22, 163, 74, 0.18)'; // More saturated green, higher opacity
                ctx.fillRect(chartArea.left, start, chartArea.right - chartArea.left, end - start);
              }
            }
          };
          
          // Plugin to draw vertical dividing lines at period transitions (months and years)
          const periodDividingLinePlugin = {
            id: 'periodDividingLine',
            afterDraw: (chart) => {
              const xScale = chart.scales.x;
              const ctx = chart.ctx;
              const chartArea = chart.chartArea;
              
              // Detect period transitions (month and year changes)
              const periodTransitions = [];
              let lastMonth = null;
              let lastYear = null;
              
              // Use stored date objects to detect month/year changes
              chartDateObjects.forEach((dateObj, index) => {
                if (dateObj instanceof Date) {
                  const currentMonth = dateObj.getMonth(); // 0-11
                  const currentYear = dateObj.getFullYear();
                  
                  // Check for month or year transition
                  if (lastMonth !== null && lastYear !== null) {
                    if (currentYear !== lastYear || currentMonth !== lastMonth) {
                      periodTransitions.push(index);
                    }
                  }
                  
                  lastMonth = currentMonth;
                  lastYear = currentYear;
                }
              });
              
              // Draw vertical dotted lines at period transitions
              periodTransitions.forEach((dataIndex) => {
                // Get pixel position for this data point
                const tickPosition = xScale.getPixelForValue(dataIndex);
                
                // Only draw if within chart area horizontally
                if (tickPosition >= chartArea.left && tickPosition <= chartArea.right) {
                  ctx.save();
                  ctx.strokeStyle = 'rgba(120, 120, 120, 0.7)'; // Medium grey, more visible
                  ctx.lineWidth = 3; // Thicker lines
                  ctx.setLineDash([3, 4]); // Dotted line pattern
                  ctx.beginPath();
                  // Extend line beyond chart area to reach axis labels
                  const lineTop = chartArea.top - 10; // Extend above chart
                  const lineBottom = chartArea.bottom + 50; // Extend below chart to reach axis labels
                  ctx.moveTo(tickPosition, lineTop);
                  ctx.lineTo(tickPosition, lineBottom);
                  ctx.stroke();
                  ctx.restore();
                }
              });
            }
          };
          
          // Debug: Log the actual data arrays being passed to the chart
          debugLog(`Chart creation: Local Entity data length=${localEntityData.length}, last 3 values=${localEntityData.slice(-3).join(', ')}, Service Area data length=${serviceAreaData.length}, last 3 values=${serviceAreaData.slice(-3).join(', ')}`, 'info');
          
          window.trendChart = new Chart(trendCtx, {
            type: 'line',
            data: {
              labels: chartDates,
              datasets: [
                {
                  label: 'Local Entity',
                  data: localEntityData,
                  borderColor: 'rgba(147, 51, 234, 1)', // Purple
                  backgroundColor: 'rgba(147, 51, 234, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5,
                  spanGaps: true // Connect across null values to show continuous line
                },
                {
                  label: 'Service Area',
                  data: serviceAreaData,
                  borderColor: '#00FFFF', // Cyan (not RAG color)
                  backgroundColor: 'rgba(0, 255, 255, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5,
                  spanGaps: true // Connect across null values to show continuous line
                },
                {
                  label: 'Authority',
                  data: authorityData,
                  borderColor: '#99004C', // Dark pink/magenta
                  backgroundColor: 'rgba(153, 0, 76, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5
                  // No spanGaps - stop at last available GSC data (Dec 4)
                },
                {
                  label: 'Visibility',
                  data: visibilityData,
                  borderColor: 'rgba(37, 99, 235, 1)', // Blue
                  backgroundColor: 'rgba(59, 130, 246, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0,
                  pointHoverRadius: 5
                  // No spanGaps - stop at last available GSC data (Dec 4)
                },
                {
                  label: 'Content / Schema',
                  data: contentSchemaData,
                  borderColor: 'rgba(107, 114, 128, 1)', // Grey
                  backgroundColor: 'rgba(107, 114, 128, 0.1)',
                  borderWidth: 3,
                  tension: 0.4,
                  pointRadius: 0, // Hide points - show as solid line
                  pointHoverRadius: 5,
                  spanGaps: true, // Connect across null values to show continuous line
                  pointBackgroundColor: 'rgba(107, 114, 128, 1)',
                  pointBorderColor: '#ffffff',
                  pointBorderWidth: 2
                }
              ]
            },
            plugins: [ragBackgroundPlugin, yearLabelBoldPlugin, periodDividingLinePlugin],
            options: {
              responsive: true,
              maintainAspectRatio: false,
              animation: false, // Disable animation for better performance when changing periods
              layout: {
                padding: {
                  bottom: 100, // Extra padding for rotated 45-degree X-axis labels (need space for diagonal text)
                  left: 15, // Space for left Y-axis labels
                  right: 50, // Extra space for right Y-axis labels (100, 80, 60, 40, 29)
                  top: 10
                }
              },
              scales: {
                x: {
                  ticks: {
                    maxRotation: 45,
                    minRotation: 45,
                    font: {
                      size: 11,
                      weight: 'normal'
                    },
                    callback: function(value, index) {
                      // Only show non-empty labels
                      const label = this.getLabelForValue(value);
                      // Hide year labels (they'll be drawn by plugin in bold)
                      if (label && /\d{4}$/.test(label)) {
                        return ''; // Return empty to hide, plugin will draw it
                      }
                      return label || '';
                    }
                  },
                  grid: {
                    display: true,
                    color: 'rgba(0, 0, 0, 0.05)'
                  }
                },
                y: {
                  min: yAxisMin,
                  max: yAxisMax,
                  position: 'left',
                  ticks: {
                    stepSize: stepSize,
                    font: {
                      size: 12,
                      weight: 'bold'
                    }
                  },
                  grid: {
                    color: 'rgba(0, 0, 0, 0.1)',
                    drawBorder: true
                  }
                },
                y1: {
                  min: yAxisMin,
                  max: yAxisMax,
                  position: 'right',
                  ticks: {
                    stepSize: stepSize,
                    font: {
                      size: 12,
                      weight: 'bold'
                    }
                  },
                  grid: {
                    display: false,
                    drawBorder: false
                  }
                }
              },
              plugins: {
                legend: {
                  display: true,
                  position: 'top',
                  labels: {
                    font: {
                      size: 16,
                      weight: 'bold'
                    },
                    padding: 25,
                    usePointStyle: false,
                    boxWidth: 60,
                    boxHeight: 4,
                    // Use default legend labels (pillar names only, no trends)
                    generateLabels: function(chart) {
                      const original = Chart.defaults.plugins.legend.labels.generateLabels;
                      return original.call(this, chart);
                    }
                  }
                },
                tooltip: {
                  mode: 'index',
                  intersect: false
                }
              }
            }
          });
          debugLog('‚úì Trend chart created successfully', 'success');
          debugLog(`trendChart type after creation: ${typeof window.trendChart}`, 'info');
          debugLog(`trendChart instanceof Chart: ${window.trendChart instanceof Chart}`, 'info');
          debugLog(`Chart data points: Local Entity=${localEntityData.length}, Visibility=${visibilityData.length}, Authority=${authorityData.length}`, 'info');
          
          // Add event listeners for Authority mode toggle buttons (sync with KPI toggle)
          ['all', 'nonEducation', 'money'].forEach(mode => {
            const btn = document.getElementById(`trend-mode-${mode}`);
            if (btn) {
              btn.addEventListener('click', () => {
                // Update selected mode (shared with KPI toggle)
                window.trendAuthorityMode = mode;
                debugLog(`üìä Trend chart Authority mode changed to: ${mode === 'all' ? 'All pages' : mode === 'nonEducation' ? 'Exclude education' : 'Money pages only'}`, 'info');
                
                // Update button styles for both KPI and trend toggles
                ['all', 'nonEducation', 'money'].forEach(m => {
                  // Update trend toggle buttons
                  const trendBtn = document.getElementById(`trend-mode-${m}`);
                  if (trendBtn) {
                    if (m === mode) {
                      trendBtn.style.background = '#10b981';
                      trendBtn.style.color = 'white';
                    } else {
                      trendBtn.style.background = 'white';
                      trendBtn.style.color = '#666';
                    }
                  }
                  // Update KPI toggle buttons
                  const kpiBtn = document.getElementById(`kpi-mode-${m}`);
                  if (kpiBtn) {
                    if (m === mode) {
                      kpiBtn.style.background = '#10b981';
                      kpiBtn.style.color = 'white';
                    } else {
                      kpiBtn.style.background = 'white';
                      kpiBtn.style.color = '#666';
                    }
                  }
                });
                
                // Redraw the chart with new Authority data
                if (window.trendChart && typeof displayDashboard === 'function') {
                  // Re-run displayDashboard to recalculate with new mode
                  displayDashboard();
                }
              });
            }
          });
          
          debugLog('=== DISPLAY DASHBOARD: Complete ===', 'success');
        } catch (e) {
          debugLog(`‚úó Error creating trend chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.error('Error creating trend chart:', e);
          // Show error message to user
          const trendCanvas = document.getElementById('trendChart');
          if (trendCanvas && trendCanvas.parentElement) {
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'background: #fee2e2; padding: 1rem; border-radius: 4px; border-left: 3px solid #ef4444; margin-bottom: 1rem; font-size: 0.9rem; color: #991b1b;';
            errorDiv.innerHTML = `<strong>Error loading trend chart:</strong> ${e.message}. Please refresh the page or run a new audit.`;
            trendCanvas.parentElement.insertBefore(errorDiv, trendCanvas);
          }
        }
      }, 100);
    }

    // Initialize on load
    window.addEventListener('DOMContentLoaded', () => {
      debugLog('=== PAGE LOAD: DOMContentLoaded event fired ===', 'info');
      debugLog(`Window location: ${window.location.href}`, 'info');
      debugLog(`User agent: ${navigator.userAgent}`, 'info');
      loadConfig();
      
      // Load and display last audit results if available
      // Wait a tick to ensure loadConfig() has finished updating the date range input
      setTimeout(() => {
        const savedAudit = loadAuditResults();
        if (savedAudit && savedAudit.scores && savedAudit.searchData) {
          // If saved audit has a date range, use it to set the input field and button
          // This ensures the UI matches the saved audit's date range
          if (savedAudit.dateRange) {
            const savedDateRange = savedAudit.dateRange;
            document.getElementById('dateRange').value = savedDateRange;
            // Update active button to match saved date range
            document.querySelectorAll('.date-range-btn').forEach(btn => {
              btn.classList.remove('active');
              const btnDays = parseInt(btn.getAttribute('data-days'));
              if (btnDays === savedDateRange) {
                btn.classList.add('active');
              }
            });
            // Update localStorage to match
            localStorage.setItem('gsc_date_range', savedDateRange);
            debugLog(`Set date range to ${savedDateRange} to match saved audit`, 'info');
          }
          
          // Now check if they match (they should, since we just set it)
          const currentDateRange = parseInt(document.getElementById('dateRange')?.value) || 30;
          const savedDateRange = savedAudit.dateRange || currentDateRange;
          
          debugLog(`Checking date range match: saved=${savedDateRange}, current=${currentDateRange}`, 'info');
          
          if (savedDateRange === currentDateRange) {
            debugLog('Loading last audit results from localStorage...', 'info');
            // Show dashboard immediately with saved results
            document.getElementById('dashboard').style.display = 'block';
            document.getElementById('loading').classList.remove('show');
            displayDashboard(
              savedAudit.scores,
              savedAudit.searchData,
              savedAudit.snippetReadiness || 0,
              savedAudit.schemaAudit || null,
              savedAudit.localSignals || null
            );
            debugLog('‚úì Last audit results displayed', 'success');
          } else {
            debugLog(`Saved audit date range (${savedDateRange}) doesn't match current (${currentDateRange}). Dashboard not displayed.`, 'warn');
            // Don't show dashboard - user needs to run new audit
          }
        }
      }, 100); // Increased delay to ensure loadConfig completes
      
      debugLog('=== PAGE LOAD: Initialization complete ===', 'success');
    });

    // PDF Report Generation
    async function generatePDFReport() {
      console.log('[PDF] ===== PDF GENERATION STARTED =====');
      
      const btn = document.getElementById('generatePdfBtn');
      const statusDiv = document.getElementById('pdfStatus');
      
      if (!btn) {
        console.error('[PDF] Generate PDF button not found!');
        alert('Error: Generate PDF button not found. Please refresh the page.');
        return;
      }
      
      if (!statusDiv) {
        console.error('[PDF] PDF status div not found!');
      }
      
      // Check if html2pdf is available
      if (typeof html2pdf === 'undefined') {
        const errorMsg = '‚ùå PDF library not loaded. Please refresh the page.';
        if (statusDiv) {
          statusDiv.textContent = errorMsg;
          statusDiv.style.color = '#dc2626';
        }
        console.error('[PDF] html2pdf is not defined');
        alert(errorMsg);
        return;
      }
      
      console.log('[PDF] html2pdf library is available');
      
      // Check if dashboard has data
      const dashboard = document.getElementById('dashboard');
      if (!dashboard || dashboard.style.display === 'none') {
        const errorMsg = '‚ö†Ô∏è Please run an audit first to generate a report.';
        if (statusDiv) {
          statusDiv.textContent = errorMsg;
          statusDiv.style.color = '#dc2626';
        }
        console.warn('[PDF] Dashboard not available or hidden');
        return;
      }

      console.log('[PDF] Dashboard is available and visible');

      // Disable button and show status
      btn.disabled = true;
      btn.style.opacity = '0.6';
      if (statusDiv) {
        statusDiv.textContent = '‚è≥ Generating PDF report...';
        statusDiv.style.color = '#2563eb';
      }
      
      console.log('[PDF] Starting PDF generation process...');

      try {
        // Load saved audit data
        const savedAudit = loadAuditResults();
        if (!savedAudit || !savedAudit.scores) {
          throw new Error('No audit data available. Please run an audit first.');
        }

        // Get property URL and date range
        const propertyUrl = document.getElementById('propertyUrl')?.value || 'N/A';
        const dateRange = document.getElementById('dateRange')?.value || 30;
        const auditDate = savedAudit.auditDate || new Date().toISOString().split('T')[0];

        // Convert charts to images first (before creating HTML)
        console.log('[PDF] Converting charts to images...');
        
        // Create temporary canvas elements to capture charts
        const radarCanvas = document.getElementById('radarChart');
        const trendCanvas = document.getElementById('trendChart');
        const snippetCanvas = document.getElementById('snippetReadinessPieChart');
        
        let radarImgData = '';
        let trendImgData = '';
        let snippetImgData = '';
        
        if (radarCanvas && window.radarChart) {
          radarImgData = radarCanvas.toDataURL('image/png');
          console.log('[PDF] Radar chart converted to image');
        }
        
        if (trendCanvas && window.trendChart) {
          trendImgData = trendCanvas.toDataURL('image/png');
          console.log('[PDF] Trend chart converted to image');
        }
        
        if (snippetCanvas && window.snippetReadinessChart) {
          snippetImgData = snippetCanvas.toDataURL('image/png');
          console.log('[PDF] Snippet readiness chart converted to image');
        }

        // Create report HTML with embedded chart images
        console.log('[PDF] Creating report HTML...');
        const reportHTML = createReportHTML(savedAudit, propertyUrl, dateRange, auditDate, {
          radarChart: radarImgData,
          trendChart: trendImgData,
          snippetReadinessChart: snippetImgData
        });

        // Verify reportHTML has content
        if (!reportHTML || reportHTML.length < 100) {
          console.error('[PDF] Report HTML is empty or too short:', reportHTML ? reportHTML.length : 'null/undefined');
          throw new Error('Report HTML is empty or too short. Cannot generate PDF.');
        }
        
        console.log('[PDF] Report HTML created successfully');
        console.log('[PDF] Report HTML length:', reportHTML.length);
        console.log('[PDF] Report HTML starts with:', reportHTML.substring(0, 100));
        console.log('[PDF] Report HTML ends with:', reportHTML.substring(reportHTML.length - 100));
        
        // Check if reportHTML contains expected content
        if (!reportHTML.includes('AI GEO Audit Report')) {
          console.warn('[PDF] Warning: Report HTML may not contain expected content');
        }
        
        // Use Workshop Planner approach: exactly match printJourney pattern from print-export-dialog.tsx
        const printWindow = window.open('', '_blank');
        if (!printWindow) {
          throw new Error('Could not open print window. Please allow popups for this site.');
        }
        
        console.log('[PDF] Print window opened');
        console.log('[PDF] Writing HTML content (length:', reportHTML.length, ')');
        
        // Write the complete report HTML directly (it already includes full HTML structure)
        printWindow.document.write(reportHTML);
        printWindow.document.close();
        
        console.log('[PDF] HTML written and document closed');
        
        // Add a slight delay before triggering print to ensure content is fully loaded (exactly like printJourney)
        setTimeout(function() {
          try {
            console.log('[PDF] Attempting to print styled report...');
            printWindow.focus();
            printWindow.print();
            console.log('[PDF] Print dialog triggered');
            
            if (statusDiv) {
              statusDiv.textContent = '‚úÖ Print dialog opened. Save as PDF from the print dialog.';
              statusDiv.style.color = '#10b981';
              setTimeout(() => {
                statusDiv.textContent = '';
              }, 5000);
            }
          } catch (error) {
            console.error('[PDF] Print error:', error);
            if (statusDiv) {
              statusDiv.textContent = '‚ùå Error opening print dialog. Please try again.';
              statusDiv.style.color = '#dc2626';
            }
            alert('Failed to open print dialog: ' + error.message);
          }
        }, 1500); // Increased timeout to ensure content is fully loaded (matches printJourney)

      } catch (error) {
        console.error('[PDF] ===== PDF GENERATION ERROR =====');
        console.error('[PDF] Error message:', error.message);
        console.error('[PDF] Error stack:', error.stack);
        console.error('[PDF] Error object:', error);
        
        const errorMsg = `‚ùå Error: ${error.message}`;
        if (statusDiv) {
          statusDiv.textContent = errorMsg;
          statusDiv.style.color = '#dc2626';
        }
        
        // Also show alert so user definitely sees the error
        alert(`PDF Generation Failed:\n\n${error.message}\n\nCheck the browser console for more details.`);
      } finally {
        btn.disabled = false;
        btn.style.opacity = '1';
        console.log('[PDF] ===== PDF GENERATION COMPLETE =====');
      }
    }

    // Convert Chart.js charts to images
    async function convertChartsToImages(container) {
      console.log('[PDF] Converting charts to images...');
      
      // Convert radar chart
      const radarCanvas = document.getElementById('radarChart');
      if (radarCanvas && window.radarChart) {
        console.log('[PDF] Converting radar chart...');
        const radarImg = radarCanvas.toDataURL('image/png');
        const radarImgElement = container.querySelector('#radarChartImg');
        if (radarImgElement) {
          radarImgElement.src = radarImg;
          radarImgElement.style.display = 'block';
          console.log('[PDF] Radar chart image set, data URL length:', radarImg.length);
        } else {
          console.warn('[PDF] Radar chart image element not found in container');
        }
      } else {
        console.warn('[PDF] Radar chart canvas or chart instance not found');
      }

      // Convert trend chart
      const trendCanvas = document.getElementById('trendChart');
      if (trendCanvas && window.trendChart) {
        console.log('[PDF] Converting trend chart...');
        const trendImg = trendCanvas.toDataURL('image/png');
        const trendImgElement = container.querySelector('#trendChartImg');
        if (trendImgElement) {
          trendImgElement.src = trendImg;
          trendImgElement.style.display = 'block';
          console.log('[PDF] Trend chart image set, data URL length:', trendImg.length);
        } else {
          console.warn('[PDF] Trend chart image element not found in container');
        }
      } else {
        console.warn('[PDF] Trend chart canvas or chart instance not found');
      }

      // Convert snippet readiness chart
      const snippetCanvas = document.getElementById('snippetReadinessPieChart');
      if (snippetCanvas && window.snippetReadinessChart) {
        console.log('[PDF] Converting snippet readiness chart...');
        const snippetImg = snippetCanvas.toDataURL('image/png');
        const snippetImgElement = container.querySelector('#snippetReadinessChartImg');
        if (snippetImgElement) {
          snippetImgElement.src = snippetImg;
          snippetImgElement.style.display = 'block';
          console.log('[PDF] Snippet readiness chart image set, data URL length:', snippetImg.length);
        } else {
          console.warn('[PDF] Snippet readiness chart image element not found in container');
        }
      } else {
        console.warn('[PDF] Snippet readiness chart canvas or chart instance not found');
      }
      
      console.log('[PDF] Chart conversion complete');
    }

    // Create report HTML content
    function createReportHTML(auditData, propertyUrl, dateRange, auditDate, chartImages = {}) {
      const scores = auditData.scores || {};
      const searchData = auditData.searchData || {};
      const schemaAudit = auditData.schemaAudit || {};
      const snippetReadiness = auditData.snippetReadiness || 0;
      const localSignals = auditData.localSignals || null;
      const hasLocalSignals = localSignals && localSignals.status === 'ok' && localSignals.data;
      const localSignalsData = hasLocalSignals ? localSignals.data : null;

      // Helper function for RAG status
      const getRAGStatus = (score) => {
        if (score >= 70) return { color: '#10b981', label: 'Green', text: 'Good' };
        if (score >= 40) return { color: '#f59e0b', label: 'Amber', text: 'Needs Improvement' };
        return { color: '#ef4444', label: 'Red', text: 'Poor' };
      };

      // Get next steps (create a helper function similar to the one in displayDashboard)
      const getNextStepsForPDF = (scores, searchData, schemaAudit) => {
        const nextSteps = {};
        
        Object.entries(scores).forEach(([key, score]) => {
          const steps = [];
          
          switch(key) {
            case 'contentSchema':
              if (schemaAudit && schemaAudit.data) {
                const schemaData = schemaAudit.data;
                const { coverage, schemaTypes, richEligible } = schemaData;
                
                // Use allDetectedTypes if available (all types), otherwise use schemaTypes (all types, sorted by count)
                const allTypes = new Set();
                if (schemaData.allDetectedTypes && Array.isArray(schemaData.allDetectedTypes)) {
                  // Use all detected types for accurate calculation
                  schemaData.allDetectedTypes.forEach(type => {
                    if (type) allTypes.add(type);
                  });
                } else if (schemaTypes && Array.isArray(schemaTypes)) {
                  // Fallback: collect from schemaTypes array (contains all types, sorted by count)
                  schemaTypes.forEach(item => {
                    if (item.type) allTypes.add(item.type);
                  });
                }
                
                const foundationTypes = ['Organization', 'Person', 'WebSite', 'BreadcrumbList'];
                const foundationPresent = foundationTypes.filter(type => allTypes.has(type)).length;
                const foundationMissing = foundationTypes.filter(type => !allTypes.has(type));
                
                if (foundationPresent < 4) {
                  steps.push(`Foundation schemas (30%): ${foundationPresent}/4 present. Add: ${foundationMissing.join(', ')}`);
                } else {
                  steps.push(`Foundation schemas (30%): All 4 present`);
                }
                
                const richEligibleCount = Object.values(richEligible || {}).filter(eligible => eligible === true).length;
                const richResultTypesCount = ['Article', 'Event', 'FAQPage', 'Product', 'LocalBusiness', 'Course', 'Review', 'HowTo', 'VideoObject', 'ImageObject', 'ItemList'].length;
                if (richEligibleCount < richResultTypesCount) {
                  steps.push(`Rich results (35%): ${richEligibleCount}/${richResultTypesCount} eligible. Add more rich result types`);
                } else {
                  steps.push(`Rich results (35%): All ${richResultTypesCount} types eligible`);
                }
                
                if (coverage < 100) {
                  steps.push(`Coverage (20%): ${coverage.toFixed(1)}% - Add schema to pages without markup`);
                } else {
                  steps.push(`Coverage (20%): 100% - All pages have schema`);
                }
                
                const uniqueTypesCount = allTypes.size;
                if (uniqueTypesCount < 15) {
                  steps.push(`Diversity (15%): ${uniqueTypesCount} unique types. Add more schema types to reach 15+`);
                } else {
                  steps.push(`Diversity (15%): ${uniqueTypesCount} unique types (excellent)`);
                }
              } else {
                steps.push('Schema audit data not available - run audit to see detailed metrics');
              }
              break;
              
            case 'visibility':
              if (searchData) {
                const position = searchData.averagePosition || 0;
                const ctr = searchData.ctr || 0;
                
                if (position > 10) {
                  steps.push(`Average position: ${position.toFixed(1)} - Target top 10 positions`);
                } else {
                  steps.push(`Average position: ${position.toFixed(1)} - Excellent! Maintain top 10 rankings`);
                }
                
                if (ctr < 2.0) {
                  steps.push(`CTR: ${ctr.toFixed(2)}% - Improve click-through rate (target: 2%+)`);
                } else {
                  steps.push(`CTR: ${ctr.toFixed(2)}% - Good CTR! Continue optimizing`);
                }
              }
              break;
              
            case 'authority':
              if (searchData) {
                const ctr = searchData.ctr || 0;
                const position = searchData.averagePosition || 0;
                
                if (ctr < 1.5) {
                  steps.push(`CTR: ${ctr.toFixed(2)}% - Low click-through indicates trust issues. Improve E-A-T signals`);
                } else {
                  steps.push(`CTR: ${ctr.toFixed(2)}% - Good engagement. Build more backlinks to strengthen authority`);
                }
                
                if (position > 15) {
                  steps.push(`Position: ${position.toFixed(1)} - Improve rankings through comprehensive, expert content`);
                }
              }
              break;
              
            case 'localEntity':
              if (hasLocalSignals && localSignalsData) {
                const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                const locationsCount = localSignalsData.locations?.length || 0;
                const knowledgePanel = localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected';
                steps.push(`Current score: ${Math.round(score)} - Using real Business Profile data`);
                steps.push(`Data: NAP consistency: ${napScore}%, Knowledge panel: ${knowledgePanel}, Locations: ${locationsCount}`);
                if (score < 70) {
                  if (napScore < 100) {
                    steps.push(`Action: Improve NAP consistency (currently ${napScore}%)`);
                  }
                  if (!localSignalsData.knowledgePanelDetected) {
                    steps.push(`Action: Work on knowledge panel detection`);
                  }
                }
              } else {
                steps.push(`Current score: ${Math.round(score)} - Using derived calculation from search performance`);
                steps.push(`Priority: Integrate Google Business Profile API to use real local signals data`);
                if (score < 70) {
                  steps.push(`Action: Add LocalBusiness schema markup and ensure NAP consistency`);
                }
              }
              break;
              
            case 'serviceArea':
              if (hasLocalSignals && localSignalsData) {
                const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
                const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                steps.push(`Current score: ${Math.round(score)} - Using real Business Profile data`);
                steps.push(`Data: Service areas: ${serviceAreasCount}, NAP consistency: ${napScore}%`);
                if (score < 70) {
                  if (serviceAreasCount < 5) {
                    steps.push(`Action: Add more service areas (currently ${serviceAreasCount}, target: 5+)`);
                  }
                  if (napScore < 100) {
                    steps.push(`Action: Improve NAP consistency (currently ${napScore}%)`);
                  }
                }
              } else {
                steps.push(`Current score: ${Math.round(score)} - Using derived calculation from Local Entity`);
                steps.push(`Priority: Integrate Google Business Profile API to get real service area data`);
                if (score < 70) {
                  steps.push(`Action: Add ServiceArea schema and create location-specific pages`);
                }
              }
              break;
          }
          
          if (steps.length === 0) {
            if (score >= 70) {
              steps.push('Maintain current performance');
              steps.push('Monitor for any score drops');
            } else if (score >= 40) {
              steps.push('Focus on improving this pillar');
              steps.push('Review specific metrics above');
            } else {
              steps.push('Critical: Immediate action required');
              steps.push('Review all data sources and implement fixes');
            }
          }
          
          nextSteps[key] = steps;
        });
        
        return nextSteps;
      };
      
      const nextSteps = getNextStepsForPDF(scores, searchData, schemaAudit);

      return `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <style>
            body {
              font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
              color: #333;
              line-height: 1.6;
              margin: 0;
              padding: 0;
            }
            .report-header {
              text-align: center;
              border-bottom: 3px solid #f97316;
              padding-bottom: 20px;
              margin-bottom: 30px;
            }
            .report-header h1 {
              color: #f97316;
              margin: 0 0 10px 0;
              font-size: 28px;
            }
            .report-header .meta {
              color: #666;
              font-size: 14px;
            }
            .section {
              margin-bottom: 40px;
              page-break-inside: avoid;
            }
            .section-title {
              background: #f97316;
              color: white;
              padding: 12px 20px;
              margin: 0 0 20px 0;
              font-size: 20px;
              font-weight: bold;
              border-radius: 4px;
            }
            .pillar-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
              gap: 15px;
              margin-bottom: 30px;
            }
            .pillar-card {
              border: 2px solid #e2e8f0;
              border-radius: 8px;
              padding: 15px;
              background: #f8f9fa;
            }
            .pillar-card h3 {
              margin: 0 0 10px 0;
              font-size: 16px;
              color: #333;
            }
            .pillar-score {
              font-size: 36px;
              font-weight: bold;
              margin: 10px 0;
            }
            .rag-indicator {
              display: inline-block;
              width: 12px;
              height: 12px;
              border-radius: 50%;
              margin-right: 5px;
            }
            .metrics-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
              gap: 15px;
              margin-bottom: 30px;
            }
            .metric-card {
              border: 1px solid #e2e8f0;
              border-radius: 6px;
              padding: 15px;
              text-align: center;
              background: #ffffff;
            }
            .metric-value {
              font-size: 28px;
              font-weight: bold;
              color: #2563eb;
              margin: 10px 0;
            }
            .metric-label {
              color: #666;
              font-size: 14px;
            }
            .chart-container {
              text-align: center;
              margin: 30px 0;
              page-break-inside: avoid;
            }
            .chart-container img {
              max-width: 100%;
              height: auto;
              border: 1px solid #e2e8f0;
              border-radius: 4px;
            }
            .chart-title {
              font-size: 18px;
              font-weight: bold;
              margin-bottom: 15px;
              color: #333;
            }
            .definition-box {
              background: #f0f9ff;
              border-left: 4px solid #2563eb;
              padding: 15px;
              margin: 20px 0;
              border-radius: 4px;
            }
            .definition-box h4 {
              margin: 0 0 10px 0;
              color: #2563eb;
            }
            .next-steps {
              background: #fff7ed;
              border-left: 4px solid #f59e0b;
              padding: 15px;
              margin: 20px 0;
              border-radius: 4px;
            }
            .next-steps h4 {
              margin: 0 0 10px 0;
              color: #f59e0b;
            }
            .next-steps ul {
              margin: 10px 0;
              padding-left: 20px;
            }
            .next-steps li {
              margin: 8px 0;
            }
            table {
              width: 100%;
              border-collapse: collapse;
              margin: 20px 0;
            }
            table th, table td {
              border: 1px solid #e2e8f0;
              padding: 10px;
              text-align: left;
            }
            table th {
              background: #f8f9fa;
              font-weight: bold;
            }
            .footer {
              margin-top: 50px;
              padding-top: 20px;
              border-top: 1px solid #e2e8f0;
              text-align: center;
              color: #666;
              font-size: 12px;
            }
          </style>
        </head>
        <body>
          <div class="report-header">
            <h1>AI GEO Audit Report</h1>
            <div class="meta">
              <strong>Property:</strong> ${propertyUrl}<br>
              <strong>Date Range:</strong> Last ${dateRange} days<br>
              <strong>Audit Date:</strong> ${new Date(auditDate).toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' })}
            </div>
          </div>

          <!-- Executive Summary -->
          <div class="section">
            <div class="section-title">Executive Summary</div>
            <div style="margin-bottom: 20px;">
              <p><strong>Overall Snippet Readiness:</strong> <span style="font-size: 24px; font-weight: bold; color: ${getRAGStatus(snippetReadiness).color};">${snippetReadiness}%</span> 
              <span class="rag-indicator" style="background-color: ${getRAGStatus(snippetReadiness).color};"></span>${getRAGStatus(snippetReadiness).text}</p>
              <p>The Snippet Readiness score indicates how likely your content is to appear in featured snippets and AI answers. It combines Content/Schema (40%), Visibility (35%), and Authority (25%).</p>
            </div>
          </div>

          <!-- Pillar Scores -->
          <div class="section">
            <div class="section-title">Pillar Scores Overview</div>
            <div class="pillar-grid">
              ${Object.entries(scores).map(([key, score]) => {
                const rag = getRAGStatus(score);
                const pillarNames = {
                  localEntity: 'Local Entity',
                  serviceArea: 'Service Area',
                  authority: 'Authority',
                  visibility: 'Visibility',
                  contentSchema: 'Content/Schema'
                };
                return `
                  <div class="pillar-card">
                    <h3>${pillarNames[key] || key}</h3>
                    <div class="pillar-score" style="color: ${rag.color};">${score}%</div>
                    <div>
                      <span class="rag-indicator" style="background-color: ${rag.color};"></span>
                      <strong>${rag.label}</strong> - ${rag.text}
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>

          <!-- Charts -->
          <div class="section">
            <div class="section-title">Visual Analytics</div>
            
            <div class="chart-container">
              <div class="chart-title">Pillar Scores Radar Chart</div>
              ${chartImages.radarChart ? '<img src="' + chartImages.radarChart + '" alt="Radar Chart" style="max-width: 600px; margin: 0 auto; display: block;">' : '<p style="color: #999;">Chart not available</p>'}
              <p style="color: #666; font-size: 14px; margin-top: 10px;">Radar chart showing current performance across all five pillars. The larger the area, the stronger your overall entity recognition.</p>
            </div>
            
            <div class="chart-container">
              <div class="chart-title">Performance Trends</div>
              ${chartImages.trendChart ? '<img src="' + chartImages.trendChart + '" alt="Trend Chart" style="max-width: 100%; margin: 0 auto; display: block;">' : '<p style="color: #999;">Chart not available</p>'}
              <p style="color: #666; font-size: 14px; margin-top: 10px;">Historical performance trends showing clicks, impressions, CTR, position, and Content/Schema scores over the selected date range.</p>
            </div>
            
            <div class="chart-container">
              <div class="chart-title">Snippet Readiness Gauge</div>
              ${chartImages.snippetReadinessChart ? '<img src="' + chartImages.snippetReadinessChart + '" alt="Snippet Readiness Chart" style="max-width: 500px; margin: 0 auto; display: block;">' : '<p style="color: #999;">Chart not available</p>'}
              <p style="color: #666; font-size: 14px; margin-top: 10px;">Nested doughnut chart showing weighted breakdown of snippet readiness components with actual performance scores.</p>
            </div>
          </div>

          <!-- Metrics -->
          <div class="section">
            <div class="section-title">Key Metrics</div>
            <div class="metrics-grid">
              <div class="metric-card">
                <div class="metric-value">${(searchData.totalClicks || 0).toLocaleString()}</div>
                <div class="metric-label">Total Clicks</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(searchData.totalImpressions || 0).toLocaleString()}</div>
                <div class="metric-label">Total Impressions</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(searchData.ctr || 0).toFixed(2)}%</div>
                <div class="metric-label">Average CTR</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(searchData.averagePosition || 0).toFixed(1)}</div>
                <div class="metric-label">Average Position</div>
              </div>
            </div>
          </div>

          <!-- Pillar Definitions -->
          <div class="section">
            <div class="section-title">Pillar Definitions & Current Status</div>
            ${Object.entries(scores).map(([key, score]) => {
              const rag = getRAGStatus(score);
              const pillarNames = {
                localEntity: 'Local Entity',
                serviceArea: 'Service Area',
                authority: 'Authority',
                visibility: 'Visibility',
                contentSchema: 'Content/Schema'
              };
              // Build definitions dynamically based on whether we have real Business Profile data
              let localEntityDef, serviceAreaDef;
              if (hasLocalSignals && localSignalsData) {
                const napScore = localSignalsData.napConsistencyScore !== null ? localSignalsData.napConsistencyScore : 'N/A';
                const serviceAreasCount = localSignalsData.serviceAreas?.length || 0;
                const locationsCount = localSignalsData.locations?.length || 0;
                localEntityDef = `Measures how well your business is recognized as a local entity. Uses real data from Google Business Profile API: NAP consistency (${napScore}%), knowledge panel (${localSignalsData.knowledgePanelDetected ? 'detected' : 'not detected'}), locations (${locationsCount}).`;
                serviceAreaDef = `Assesses your service area coverage and geographic relevance. Uses real data from Google Business Profile API: ${serviceAreasCount} service areas, NAP consistency (${napScore}%).`;
              } else {
                localEntityDef = 'Measures how well your business is recognized as a local entity. Based on LocalBusiness schema presence, NAP consistency, and knowledge panel detection. Currently uses derived calculations from GSC data.';
                serviceAreaDef = 'Assesses your service area coverage and geographic relevance. Derived from Local Entity score. Will use real service area data when Google Business Profile API is integrated.';
              }
              
              const definitions = {
                localEntity: localEntityDef,
                serviceArea: serviceAreaDef,
                authority: 'Evaluates your domain authority and trust signals. Calculated from four components: Behaviour Score (40%): CTR for ranking queries + top-10 CTR. Ranking Score (20%): Average position + top-10 impression share. Backlink Score (20%): Referring domains + quality from CSV upload. Review Score (20%): Combined ratings and counts from Google Business Profile + on-site/Trustpilot reviews.',
                visibility: 'Tracks your search visibility and ranking performance. Based on average position from Google Search Console (1 = best, 40 = worst). Score ranges from 10 to 100.',
                contentSchema: 'Measures schema markup quality and completeness. Weighted calculation: Foundation Schemas (30%), Rich Results (35%), Coverage (20%), Diversity (15%).'
              };
              return `
                <div class="definition-box">
                  <h4>${pillarNames[key] || key} - ${score}% 
                    <span class="rag-indicator" style="background-color: ${rag.color};"></span>${rag.label}
                  </h4>
                  <p>${definitions[key] || 'No definition available.'}</p>
                </div>
              `;
            }).join('')}
          </div>

          <!-- Next Steps -->
          <div class="section">
            <div class="section-title">Recommended Next Steps</div>
            ${Object.entries(nextSteps).map(([pillar, steps]) => {
              if (!steps || steps.length === 0) return '';
              const pillarNames = {
                localEntity: 'Local Entity',
                serviceArea: 'Service Area',
                authority: 'Authority',
                visibility: 'Visibility',
                contentSchema: 'Content/Schema'
              };
              return `
                <div class="next-steps">
                  <h4>${pillarNames[pillar] || pillar}</h4>
                  <ul>
                    ${steps.map(step => `<li>${step}</li>`).join('')}
                  </ul>
                </div>
              `;
            }).join('')}
          </div>

          <!-- Schema Audit Summary -->
          ${schemaAudit.data ? `
          <div class="section">
            <div class="section-title">Schema Audit Summary</div>
            <div class="metrics-grid">
              <div class="metric-card">
                <div class="metric-value">${schemaAudit.data.totalPages || 0}</div>
                <div class="metric-label">Total Pages Scanned</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${schemaAudit.data.pagesWithSchema || 0}</div>
                <div class="metric-label">Pages With Schema</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(schemaAudit.data.coverage || 0).toFixed(1)}%</div>
                <div class="metric-label">Schema Coverage</div>
              </div>
              <div class="metric-card">
                <div class="metric-value">${(schemaAudit.data.schemaTypes || []).length}</div>
                <div class="metric-label">Schema Types Found</div>
              </div>
            </div>
            ${schemaAudit.data.missingSchemaPages && schemaAudit.data.missingSchemaPages.length > 0 ? `
              <div style="margin-top: 20px;">
                <h4>Pages Missing Schema (${schemaAudit.data.missingSchemaPages.length}):</h4>
                <ul style="font-size: 12px; max-height: 200px; overflow-y: auto;">
                  ${schemaAudit.data.missingSchemaPages.slice(0, 20).map(url => `<li>${url}</li>`).join('')}
                  ${schemaAudit.data.missingSchemaPages.length > 20 ? `<li><em>... and ${schemaAudit.data.missingSchemaPages.length - 20} more</em></li>` : ''}
                </ul>
              </div>
            ` : ''}
          </div>
          ` : ''}

          <!-- Top Queries -->
          ${searchData.topQueries && searchData.topQueries.length > 0 ? `
          <div class="section">
            <div class="section-title">Top Queries</div>
            <table>
              <thead>
                <tr>
                  <th>Query</th>
                  <th>Clicks</th>
                  <th>Impressions</th>
                  <th>CTR</th>
                  <th>Position</th>
                </tr>
              </thead>
              <tbody>
                ${searchData.topQueries.slice(0, 20).map(query => `
                  <tr>
                    <td>${query.query || 'N/A'}</td>
                    <td>${(query.clicks || 0).toLocaleString()}</td>
                    <td>${(query.impressions || 0).toLocaleString()}</td>
                    <td>${(query.ctr || 0).toFixed(2)}%</td>
                    <td>${(query.position || 0).toFixed(1)}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
          ` : ''}

          <div class="footer">
            <p>Generated by AI GEO Audit Dashboard on ${new Date().toLocaleString('en-GB')}</p>
            <p>This report contains data from Google Search Console API and schema audit results.</p>
          </div>
        </body>
        </html>
      `;
    }
  </script>
</body>
</html>

