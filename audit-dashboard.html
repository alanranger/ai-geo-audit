<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>AI GEO Audit Dashboard - Automated SEO Analysis (v 80c0dd8)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script>
    // Try to load config.js if it exists (for local development)
    // Note: config.js is gitignored and won't be deployed to Vercel
    // Silently fail if config.js doesn't exist (expected on Vercel)
    try {
      const configScript = document.createElement('script');
      configScript.src = 'config.js';
      configScript.onerror = function() {
        // Silently ignore - config.js is optional
      };
      document.head.appendChild(configScript);
    } catch (e) {
      // Silently ignore - config.js is optional
    }
  </script>
  <style>
    :root {
      --brand-orange: #E57200;
      --brand-dark: #222222;
      --brand-grey: #555555;
      --bg-page: #f2f2f2;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg-page);
      color: var(--brand-dark);
      line-height: 1.5;
    }
    .header {
      background: linear-gradient(135deg, var(--brand-orange) 0%, #ff8c42 100%);
      color: white;
      padding: 2rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .header h1 {
      margin: 0 0 0.5rem 0;
      font-size: 2rem;
    }
    .header p {
      margin: 0;
      opacity: 0.9;
    }
    .container {
      max-width: 1800px;
      margin: 0 auto;
      padding: 2rem;
      padding-bottom: 60px; /* Space for debug panel */
    }
    .config-panel {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      margin-bottom: 2rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .config-panel h2 {
      margin: 0 0 1rem 0;
      color: var(--brand-dark);
      font-size: 1.25rem;
    }
    .form-group {
      margin-bottom: 1rem;
    }
    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      color: var(--brand-grey);
    }
    .form-group input {
      width: 100%;
      padding: 0.75rem;
      border: 2px solid #e2e8f0;
      border-radius: 6px;
      font-size: 1rem;
    }
    .form-group input:focus {
      outline: none;
      border-color: var(--brand-orange);
    }
    .btn {
      background: var(--brand-orange);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    .btn:hover {
      background: #d46200;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    .btn-secondary {
      background: var(--brand-grey);
    }
    .btn-secondary:hover {
      background: #444;
    }
    .status {
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      display: none;
    }
    .status.success {
      background: #d1fae5;
      color: #065f46;
      border-left: 4px solid var(--success);
    }
    .status.error {
      background: #fee2e2;
      color: #991b1b;
      border-left: 4px solid var(--danger);
    }
    .status.info {
      background: #dbeafe;
      color: #1e40af;
      border-left: 4px solid #3b82f6;
    }
    .status.show {
      display: block;
    }
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    .pillar-card {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: relative;
    }
    .pillar-card h3 {
      margin: 0 0 0.75rem 0;
      color: var(--brand-dark);
      font-size: 1.1rem;
    }
    .pillar-score {
      font-size: 3rem;
      font-weight: 700;
      margin: 0.5rem 0;
      line-height: 1;
    }
    .pillar-score.rag-red {
      color: var(--danger);
    }
    .pillar-score.rag-amber {
      color: var(--warning);
    }
    .pillar-score.rag-green {
      color: var(--success);
    }
    .rag-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.875rem;
      font-weight: 600;
      margin-top: 0.75rem;
      margin-bottom: 0.5rem;
    }
    .rag-badge.red {
      background: #fee2e2;
      color: #991b1b;
    }
    .rag-badge.amber {
      background: #fef3c7;
      color: #92400e;
    }
    .rag-badge.green {
      background: #d1fae5;
      color: #065f46;
    }
    .chart-container {
      background: linear-gradient(135deg, #f0f4f8 0%, #e2e8f0 100%);
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 3rem;
      height: 400px;
      border: 1px solid rgba(100, 116, 139, 0.2);
    }
    .chart-container.large {
      height: 700px;
      min-height: 700px;
      padding: 2rem;
    }
    .dashboard-two-column {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-three-column {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    .dashboard-four-column {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2rem;
      margin-bottom: 3rem;
    }
    @media (max-width: 1200px) {
      .dashboard-four-column {
        grid-template-columns: repeat(2, 1fr);
      }
      .dashboard-three-column {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    @media (max-width: 768px) {
      .dashboard-two-column,
      .dashboard-three-column,
      .dashboard-four-column {
        grid-template-columns: 1fr;
      }
    }
    .chart-container h3 {
      margin: 0 0 0.5rem 0;
      color: var(--brand-dark);
    }
    .chart-container p {
      margin: 0 0 1rem 0;
    }
    .metrics-section {
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border: 1px solid rgba(59, 130, 246, 0.1);
    }
    .scorecard-section {
      margin-top: 3rem;
      margin-bottom: 3rem;
    }
    .scorecard-section h3 {
      margin-bottom: 1.5rem;
    }
    .metrics-section {
      margin-top: 3rem;
      margin-bottom: 3rem;
    }
    .metrics-section h3 {
      margin-bottom: 1.5rem;
    }
    .section-break {
      margin-top: 4rem;
      margin-bottom: 4rem;
      border-top: 2px solid #e2e8f0;
      padding-top: 2rem;
    }
    .date-range-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .date-range-btn {
      padding: 0.5rem 1rem;
      border: 2px solid #e2e8f0;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    .date-range-btn:hover {
      border-color: var(--brand-orange);
      background: #fff5f0;
    }
    .date-range-btn.active {
      background: var(--brand-orange);
      color: white;
      border-color: var(--brand-orange);
    }
    .snippet-readiness-gauge {
      background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 3rem;
      border: 1px solid rgba(16, 185, 129, 0.1);
      height: 700px;
      min-height: 700px;
      display: flex;
      flex-direction: column;
    }
    .gauge-container {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      flex: 1;
      position: relative;
    }
    .gauge-wrapper {
      position: relative;
      width: 300px;
      height: 300px;
    }
    .gauge-svg {
      transform: rotate(-90deg);
      width: 100%;
      height: 100%;
    }
    .gauge-background {
      fill: none;
      stroke: #e2e8f0;
      stroke-width: 20;
    }
    .gauge-fill {
      fill: none;
      stroke-width: 20;
      stroke-linecap: round;
      transition: stroke-dashoffset 1s ease-in-out;
    }
    .gauge-fill.green {
      stroke: #10b981;
    }
    .gauge-fill.amber {
      stroke: #f59e0b;
    }
    .gauge-fill.red {
      stroke: #ef4444;
    }
    .gauge-value {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      font-weight: 700;
      text-align: center;
      z-index: 10;
    }
    .gauge-value.green {
      color: #10b981;
    }
    .gauge-value.amber {
      color: #f59e0b;
    }
    .gauge-value.red {
      color: #ef4444;
    }
    .gauge-label {
      text-align: center;
      color: var(--brand-grey);
      margin-top: 1rem;
      font-size: 1rem;
      font-weight: 600;
    }
    .gauge-status {
      text-align: center;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      font-weight: 500;
    }
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }
    .metric-card {
      background: white;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
    }
    .metric-card .value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--brand-orange);
      margin: 0.5rem 0;
    }
    .metric-card .label {
      color: var(--brand-grey);
      font-size: 0.875rem;
    }
    .loading {
      display: none;
      text-align: center;
      padding: 2rem;
    }
    .loading.show {
      display: block;
    }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--brand-orange);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .help-text {
      font-size: 0.875rem;
      color: var(--brand-grey);
      margin-top: 0.25rem;
    }

    .debug-panel-bottom {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1a1a1a;
      border-top: 3px solid #E57200;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      z-index: 1000;
      box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.5);
      max-height: 50vh;
      display: flex;
      flex-direction: column;
    }

    .debug-panel-bottom.collapsed {
      max-height: 50px;
    }

    .debug-panel-bottom.collapsed .debug-content {
      display: none !important;
    }

    .debug-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #333;
      background: #252525;
      user-select: none;
    }

    .debug-header h3 {
      margin: 0;
      color: #fff;
      font-size: 1rem;
    }

    .debug-actions {
      display: flex;
      gap: 0.5rem;
    }

    .btn-small {
      padding: 0.25rem 0.75rem;
      font-size: 0.75rem;
      background: #333;
      color: #fff;
      border: 1px solid #555;
    }

    .btn-small:hover {
      background: #444;
    }

    .debug-content {
      color: #fff;
      line-height: 1.6;
      padding: 1rem;
      overflow-y: auto;
      flex: 1;
      max-height: calc(50vh - 60px);
    }

    .debug-log-entry {
      margin-bottom: 0.25rem;
      padding: 0.25rem 0;
      border-left: 2px solid transparent;
      padding-left: 0.5rem;
    }

    .debug-log-entry.error {
      color: #f44;
      border-left-color: #f44;
    }

    .debug-log-entry.warn {
      color: #fa4;
      border-left-color: #fa4;
    }

    .debug-log-entry.info {
      color: #9cf;
      border-left-color: #4af;
    }

    .debug-log-entry.success {
      color: #9f9;
      border-left-color: #4f4;
    }

    .debug-timestamp {
      color: #aaa;
      margin-right: 0.5rem;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>AI GEO Audit Dashboard</h1>
    <p>Automated SEO Analysis & Pillar Score Tracking</p>
    <p style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 1; background: rgba(0,0,0,0.3); padding: 0.25rem 0.5rem; border-radius: 4px; display: inline-block;">
      <strong>Version: 80c0dd8</strong> | Built: 2025-01-27 19:20 UTC | 
      <span id="loadTime" style="color: #4f4;">Loaded: <script>document.write(new Date().toLocaleTimeString())</script></span>
    </p>
  </div>

  <div class="container">
    <div class="config-panel">
      <h2>Configuration</h2>
      <div class="info-box" style="background: #e8f4f8; border-left: 4px solid #2196F3; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #1565C0;"><strong>Entity-Level Audit:</strong> This dashboard analyzes <strong>www.alanranger.com</strong> as a global entity, tracking AI-powered search visibility, entity recognition, and SERP behavior across the entire domain.</p>
      </div>
      <div class="form-group">
        <label for="propertyUrl">Property URL</label>
        <input type="text" id="propertyUrl" placeholder="https://yourwebsite.com" value="https://www.alanranger.com">
        <div class="help-text">The domain being audited (entity-level analysis)</div>
      </div>
      <div class="form-group">
        <label for="dateRange">Date Range</label>
        <div class="date-range-selector">
          <button class="date-range-btn" onclick="setDateRange(7)" data-days="7">Last 7 Days</button>
          <button class="date-range-btn active" onclick="setDateRange(30)" data-days="30">Last 30 Days</button>
          <button class="date-range-btn" onclick="setDateRange(90)" data-days="90">Last 90 Days</button>
          <button class="date-range-btn" onclick="setDateRange(180)" data-days="180">Last 6 Months</button>
          <button class="date-range-btn" onclick="setDateRange(365)" data-days="365">Last 12 Months</button>
          <button class="date-range-btn" onclick="showCustomDateRange()" id="customDateBtn">Custom</button>
        </div>
        <input type="number" id="dateRange" value="30" min="1" style="display: none;">
        <div id="customDateRange" style="display: none; margin-top: 0.5rem;">
          <input type="number" id="customDays" placeholder="Enter days" min="1" style="width: 150px; padding: 0.5rem; border: 2px solid #e2e8f0; border-radius: 6px;">
          <button class="btn btn-small" onclick="applyCustomDateRange()" style="margin-left: 0.5rem; padding: 0.5rem 1rem;">Apply</button>
        </div>
        <div class="help-text">Analysis period for historical data</div>
      </div>
      <div style="background: #f0f0f0; padding: 0.75rem; border-radius: 4px; margin-bottom: 1rem; font-size: 0.85rem; color: #555;">
        <strong>API Key:</strong> Loaded automatically from Vercel environment variables. No manual entry required.
      </div>
      <button class="btn" onclick="runAudit()">Run Audit Scan</button>
      <button class="btn btn-secondary" onclick="saveConfig()" style="margin-left: 0.5rem;">Save Configuration</button>
    </div>

    <div class="status" id="status"></div>

    <div class="loading" id="loading">
      <div class="spinner"></div>
      <p>Running audit scan...</p>
    </div>

    <div id="dashboard" style="display: none;">
      <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px; margin-bottom: 3rem; border-left: 4px solid var(--brand-orange);">
        <h3 style="margin-top: 0; color: var(--brand-orange);">Five-Pillar Framework</h3>
        <p style="color: #555; line-height: 1.6; margin-bottom: 1rem;">
          This audit analyzes <strong>www.alanranger.com</strong> as a global entity using a five-pillar framework to assess AI-powered search visibility, entity recognition, and SERP behavior. Each pillar is scored 0-100 and assigned a RAG (Red/Amber/Green) status based on performance thresholds.
        </p>
        <p style="color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
          <strong>Data Sources:</strong> Scores are calculated using data from Google Search Console API (impressions, clicks, position, queries), schema markup validation, local pack visibility metrics, and SERP feature tracking (featured snippets, AI Overviews, rich results).
        </p>
        <p style="color: #555; line-height: 1.6; margin-bottom: 0;">
          <strong>Score Calculation:</strong> Each pillar combines multiple weighted factors: Local Entity (brand consistency, entity signals, NAP data), Service Area (geographic coverage, location schema), Authority (E-A-T: Experience, Expertise, Authoritativeness, Trustworthiness - content depth, backlinks, reviews, credentials, citations), Visibility (ranking positions, SERP features, CTR), and Content/Schema (structured data completeness, validation, rich result eligibility). Scores are normalized to 0-100 scale with thresholds: Green (70-100), Amber (40-69), Red (0-39).
        </p>
      </div>

      <div class="dashboard-grid" id="pillarCards"></div>

      <div class="section-break"></div>

      <div class="dashboard-two-column">
        <div class="chart-container large">
          <h3>Pillar Scores Overview</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Radar chart showing current performance across all five pillars. The larger the area, the stronger your overall entity recognition.</p>
          <canvas id="radarChart"></canvas>
        </div>

        <div class="snippet-readiness-gauge">
          <h3 style="margin-top: 0; color: var(--brand-orange);">Snippet Readiness Gauge</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1.5rem;">Snippet readiness summarises how likely your content is to be lifted into featured snippets and AI answers. It reflects three ingredients: snippet-friendly answer blocks, suitable schema (FAQ/HowTo/Article/Course/Event) and existing rich-result behaviour.</p>
          <div class="gauge-container">
            <div class="gauge-wrapper">
              <svg class="gauge-svg" viewBox="0 0 200 200">
                <circle class="gauge-background" cx="100" cy="100" r="80"></circle>
                <circle class="gauge-fill" id="gaugeFill" cx="100" cy="100" r="80" 
                        stroke-dasharray="502.65" 
                        stroke-dashoffset="502.65"></circle>
              </svg>
              <div class="gauge-value" id="snippetReadinessScore">0</div>
            </div>
            <div style="text-align: center; margin-top: 1rem;">
              <div class="gauge-label">Readiness Score</div>
              <div class="gauge-status" id="gaugeStatus">Calculating...</div>
            </div>
          </div>
        </div>
      </div>

      <div class="section-break"></div>

      <div class="chart-container">
        <h3>Score Trends</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Historical performance tracking for Local Entity, Visibility, and Authority pillars over the selected date range.</p>
        <canvas id="trendChart"></canvas>
      </div>

      <div class="section-break"></div>

      <div class="metrics-section">
        <h3 style="color: var(--brand-orange); margin-bottom: 0.5rem;">Key Performance Indicators</h3>
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Core metrics from Google Search Console showing overall search performance for the entity. <strong>Note:</strong> Small differences from live GSC may occur due to data processing delays (up to 48 hours) and exact date range calculations.</p>
        <div class="metrics-grid" id="metricsGrid"></div>
      </div>
    </div>

    <!-- Debug Panel - Fixed at bottom, collapsible -->
    <div class="debug-panel-bottom" id="debugPanel">
      <div class="debug-header" onclick="toggleDebugPanel()" style="cursor: pointer;">
        <h3>üîç Debug Log (v80c0dd8)</h3>
        <div class="debug-actions">
          <button class="btn btn-small" onclick="event.stopPropagation(); clearDebugLog();">Clear</button>
          <button class="btn btn-small" onclick="event.stopPropagation(); copyDebugLog();">Copy Log</button>
          <span id="debugToggleIcon" style="color: #fff; font-size: 1.2rem;">‚ñº</span>
        </div>
      </div>
      <div class="debug-content" id="debugLog" style="display: block;">
        <div class="debug-log-entry info">
          <span class="debug-timestamp">[Initializing...]</span>Debug panel loaded. Waiting for page initialization...
        </div>
      </div>
    </div>
  </div>

  <script>
    // Immediate console log to verify script is running
    console.log('%c=== AI GEO AUDIT DASHBOARD v80c0dd8 LOADED ===', 'color: #E57200; font-size: 16px; font-weight: bold;');
    console.log('%cDebug panel should be visible at bottom with orange border', 'color: #E57200; font-size: 14px;');
    console.log('Current time:', new Date().toISOString());
    console.log('Page URL:', window.location.href);
    
    // Debug logging system
    const debugLogEntries = [];
    
    function debugLog(message, type = 'info') {
      const timestamp = new Date().toISOString();
      const entry = {
        timestamp,
        message,
        type
      };
      debugLogEntries.push(entry);
      
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        const entryDiv = document.createElement('div');
        entryDiv.className = `debug-log-entry ${type}`;
        entryDiv.innerHTML = `<span class="debug-timestamp">[${new Date(timestamp).toLocaleTimeString()}]</span>${message}`;
        logElement.appendChild(entryDiv);
        logElement.scrollTop = logElement.scrollHeight;
      }
      
      // Also log to console
      const consoleMethod = type === 'error' ? 'error' : type === 'warn' ? 'warn' : 'log';
      console[consoleMethod](`[DEBUG ${type.toUpperCase()}]`, message);
    }

    function clearDebugLog() {
      debugLogEntries.length = 0;
      const logElement = document.getElementById('debugLog');
      if (logElement) {
        logElement.innerHTML = '';
      }
      debugLog('Debug log cleared', 'info');
    }

    function copyDebugLog() {
      const logText = debugLogEntries.map(entry => 
        `[${entry.timestamp}] [${entry.type.toUpperCase()}] ${entry.message}`
      ).join('\n');
      
      navigator.clipboard.writeText(logText).then(() => {
        debugLog('Debug log copied to clipboard', 'success');
        showStatus('Debug log copied to clipboard!', 'success');
      }).catch(err => {
        debugLog('Failed to copy log: ' + err.message, 'error');
        showStatus('Failed to copy log', 'error');
      });
    }

    function toggleDebugPanel() {
      const panel = document.getElementById('debugPanel');
      const icon = document.getElementById('debugToggleIcon');
      if (panel.classList.contains('collapsed')) {
        panel.classList.remove('collapsed');
        if (icon) icon.textContent = '‚ñº';
      } else {
        panel.classList.add('collapsed');
        if (icon) icon.textContent = '‚ñ≤';
      }
    }

    // Debug panel is always visible at bottom, start collapsed by default
    window.addEventListener('DOMContentLoaded', () => {
      const debugPanel = document.getElementById('debugPanel');
      const debugToggleIcon = document.getElementById('debugToggleIcon');
      if (debugPanel) {
        debugPanel.style.display = 'flex';
        // Start collapsed by default
        debugPanel.classList.add('collapsed');
        if (debugToggleIcon) {
          debugToggleIcon.textContent = '‚ñ≤';
        }
      }
    });

    // Load saved configuration
    async function loadConfig() {
      debugLog('=== PAGE LOAD: Starting configuration load ===', 'info');
      
      // Check if Chart.js is loaded
      debugLog('Checking Chart.js library...', 'info');
      if (typeof Chart !== 'undefined') {
        debugLog('‚úì Chart.js library loaded successfully', 'success');
      } else {
        debugLog('‚úó Chart.js library NOT loaded', 'error');
      }
      
      // Try to fetch API key from Vercel environment variable (via API endpoint)
      let vercelApiKey = null;
      try {
        debugLog('Checking Vercel environment variable...', 'info');
        const response = await fetch('/api/get-api-key');
        if (response.ok) {
          const data = await response.json();
          if (data.apiKey) {
            vercelApiKey = data.apiKey;
            debugLog('‚úì API key loaded from Vercel environment variable', 'success');
          }
        }
      } catch (e) {
        debugLog('Vercel env var endpoint not available (expected for static site)', 'info');
      }
      
      // Check config.js
      debugLog('Checking for config.js...', 'info');
      if (window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey) {
        debugLog('‚úì config.js found with API key', 'success');
      } else {
        debugLog('‚úó config.js not found or no API key', 'warn');
      }
      
      // Check localStorage
      debugLog('Checking localStorage...', 'info');
      const configApiKey = window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey;
      const apiKey = vercelApiKey || configApiKey || localStorage.getItem('gsc_api_key');
      const propertyUrl = localStorage.getItem('gsc_property_url');
      const dateRange = localStorage.getItem('gsc_date_range');
      
      const apiKeySource = vercelApiKey ? 'Vercel env var' : configApiKey ? 'config.js' : localStorage.getItem('gsc_api_key') ? 'localStorage' : 'none';
      debugLog(`API Key source: ${apiKeySource}`, 'info');
      debugLog(`Property URL: ${propertyUrl || 'not set'}`, 'info');
      debugLog(`Date Range: ${dateRange || 'not set'}`, 'info');
      
      if (apiKey) {
        debugLog('‚úì API key loaded from environment', 'success');
        // Store in a hidden variable for use in runAudit
        window._loadedApiKey = apiKey;
      } else {
        debugLog('‚úó No API key found', 'warn');
      }
      
      if (propertyUrl) {
        document.getElementById('propertyUrl').value = propertyUrl;
        debugLog('‚úì Property URL loaded', 'success');
      }
      if (dateRange) {
        document.getElementById('dateRange').value = dateRange;
        // Set active button based on saved date range
        const savedDays = parseInt(dateRange);
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          btn.classList.remove('active');
          const btnDays = parseInt(btn.getAttribute('data-days'));
          if (btnDays === savedDays) {
            btn.classList.add('active');
          }
        });
        // If no preset matches, show custom
        const presetDays = [7, 30, 90, 180, 365];
        if (!presetDays.includes(savedDays)) {
          document.getElementById('customDateBtn').classList.add('active');
          document.getElementById('customDays').value = savedDays;
          document.getElementById('customDateRange').style.display = 'block';
        }
        debugLog('‚úì Date range loaded', 'success');
      }
      
      debugLog('=== Configuration load complete ===', 'info');
    }

    // Save configuration
    // Date range selector functions
    function setDateRange(days) {
      document.getElementById('dateRange').value = days;
      localStorage.setItem('gsc_date_range', days);
      
      // Update active button
      document.querySelectorAll('.date-range-btn').forEach(btn => {
        btn.classList.remove('active');
        const btnDays = parseInt(btn.getAttribute('data-days'));
        if (btnDays === days) {
          btn.classList.add('active');
        }
      });
      
      // Hide custom input if showing
      document.getElementById('customDateRange').style.display = 'none';
      document.getElementById('customDateBtn').classList.remove('active');
      
      debugLog(`Date range set to ${days} days`, 'info');
    }

    function showCustomDateRange() {
      const customDiv = document.getElementById('customDateRange');
      const customBtn = document.getElementById('customDateBtn');
      
      if (customDiv.style.display === 'none') {
        customDiv.style.display = 'block';
        customBtn.classList.add('active');
        document.querySelectorAll('.date-range-btn').forEach(btn => {
          if (btn !== customBtn) btn.classList.remove('active');
        });
      } else {
        customDiv.style.display = 'none';
        customBtn.classList.remove('active');
      }
    }

    function applyCustomDateRange() {
      const customDays = parseInt(document.getElementById('customDays').value);
      if (customDays && customDays > 0) {
        document.getElementById('dateRange').value = customDays;
        localStorage.setItem('gsc_date_range', customDays);
        document.getElementById('customDateRange').style.display = 'none';
        document.getElementById('customDateBtn').classList.remove('active');
        debugLog(`Custom date range set to ${customDays} days`, 'info');
      } else {
        showStatus('Please enter a valid number of days', 'error');
      }
    }

    function saveConfig() {
      localStorage.setItem('gsc_api_key', document.getElementById('apiKey').value);
      localStorage.setItem('gsc_property_url', document.getElementById('propertyUrl').value);
      localStorage.setItem('gsc_date_range', document.getElementById('dateRange').value);
      showStatus('Configuration saved!', 'success');
    }

    // Show status message
    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = `status ${type} show`;
      setTimeout(() => {
        status.classList.remove('show');
      }, 5000);
    }

    // Calculate RAG status from score
    function getRAGStatus(score) {
      if (score >= 70) return { status: 'green', label: 'Green' };
      if (score >= 40) return { status: 'amber', label: 'Amber' };
      return { status: 'red', label: 'Red' };
    }

    // Calculate pillar scores (basic version - will be enhanced with real API data)
    function calculatePillarScores(data) {
      // These are placeholder calculations - will be replaced with real API data
      const scores = {
        localEntity: Math.min(100, Math.max(0, 65 + Math.random() * 10 - 5)),
        serviceArea: Math.min(100, Math.max(0, 55 + Math.random() * 10 - 5)),
        authority: Math.min(100, Math.max(0, 70 + Math.random() * 10 - 5)),
        visibility: Math.min(100, Math.max(0, 60 + Math.random() * 10 - 5)),
        contentSchema: Math.min(100, Math.max(0, 75 + Math.random() * 10 - 5))
      };
      return scores;
    }

    function calculateSnippetReadiness(scores, data) {
      // Snippet readiness combines:
      // 1. Content/Schema score (structured data quality)
      // 2. Visibility score (SERP feature presence)
      // 3. Authority score (content depth and trust)
      // Weighted average: 40% Content/Schema, 35% Visibility, 25% Authority
      const readiness = (
        scores.contentSchema * 0.4 +
        scores.visibility * 0.35 +
        scores.authority * 0.25
      );
      return Math.round(Math.min(100, Math.max(0, readiness)));
    }

    // Fetch real data from Google Search Console API
    async function fetchSearchConsoleData(apiKey, propertyUrl, days) {
      debugLog(`Fetching real GSC data for ${days} days...`, 'info');
      
      // Calculate date range
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);
      
      // Format dates as YYYY-MM-DD
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      const startDateStr = formatDate(startDate);
      const endDateStr = formatDate(endDate);
      
      debugLog(`Date range: ${startDateStr} to ${endDateStr}`, 'info');
      
      try {
        // Call serverless function to fetch real GSC data
        const response = await fetch('/api/fetch-search-console', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            propertyUrl: propertyUrl,
            startDate: startDateStr,
            endDate: endDateStr
          }),
        });

        if (!response.ok) {
          const errorData = await response.json();
          debugLog(`‚úó GSC API error: ${errorData.error}`, 'error');
          if (errorData.details) {
            debugLog(`Details: ${errorData.details}`, 'error');
          }
          
          // If OAuth not configured, show helpful message
          if (errorData.error && errorData.error.includes('OAuth2 credentials not configured')) {
            throw new Error('Google Search Console OAuth2 credentials not configured. Please set GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, and GOOGLE_REFRESH_TOKEN in Vercel environment variables.');
          }
          
          throw new Error(errorData.error || 'Failed to fetch Search Console data');
        }

        const data = await response.json();
        debugLog(`‚úì Real GSC data fetched: ${data.totalClicks} clicks, ${data.totalImpressions} impressions`, 'success');
        
        return {
          totalClicks: data.totalClicks || 0,
          totalImpressions: data.totalImpressions || 0,
          averagePosition: data.averagePosition || 0,
          topQueries: data.topQueries || [],
          dateRange: days
        };
      } catch (error) {
        debugLog(`‚úó Error fetching GSC data: ${error.message}`, 'error');
        throw error;
      }
    }

    // Run the audit
    async function runAudit() {
      debugLog('=== AUDIT START: Beginning audit scan ===', 'info');
      
      // Get API key - prioritize Vercel env var, then loaded key, then localStorage
      let apiKey = window._loadedApiKey;
      
      // Try Vercel environment variable first
      if (!apiKey) {
        try {
          debugLog('Fetching API key from Vercel environment variable...', 'info');
          const response = await fetch('/api/get-api-key');
          if (response.ok) {
            const data = await response.json();
            if (data.apiKey) {
              apiKey = data.apiKey;
              debugLog('‚úì Using API key from Vercel environment variable', 'success');
              window._loadedApiKey = apiKey;
            }
          }
        } catch (e) {
          debugLog('Vercel env var endpoint not available', 'info');
        }
      }
      
      // Fall back to config.js
      if (!apiKey && window.API_CONFIG && window.API_CONFIG.googleSearchConsoleApiKey) {
        apiKey = window.API_CONFIG.googleSearchConsoleApiKey;
        debugLog('‚úì Using API key from config.js', 'success');
        window._loadedApiKey = apiKey;
      }
      
      // Fall back to localStorage
      if (!apiKey) {
        apiKey = localStorage.getItem('gsc_api_key');
        if (apiKey) {
          debugLog('‚úì Using API key from localStorage', 'success');
          window._loadedApiKey = apiKey;
        }
      }
      
      const propertyUrl = document.getElementById('propertyUrl').value;
      const dateRange = parseInt(document.getElementById('dateRange').value);
      
      debugLog(`Property URL: ${propertyUrl}`, 'info');
      debugLog(`Date Range: ${dateRange} days`, 'info');

      if (!apiKey) {
        debugLog('‚úó No API key available', 'error');
        showStatus('Please enter your Google Search Console API key or add it to config.js', 'error');
        return;
      }
      
      if (!propertyUrl) {
        debugLog('‚úó No property URL provided', 'error');
        showStatus('Please enter your property URL', 'error');
        return;
      }

      debugLog('Showing loading indicator...', 'info');
      document.getElementById('loading').classList.add('show');
      document.getElementById('dashboard').style.display = 'none';

      try {
        debugLog('Fetching Search Console data...', 'info');
        // Fetch data
        const searchData = await fetchSearchConsoleData(apiKey, propertyUrl, dateRange);
        debugLog('‚úì Search Console data fetched successfully', 'success');
        debugLog(`Data: ${JSON.stringify(searchData).substring(0, 200)}...`, 'info');
        
        debugLog('Calculating pillar scores...', 'info');
        // Calculate scores
        const scores = calculatePillarScores(searchData);
        debugLog('‚úì Pillar scores calculated', 'success');
        debugLog(`Scores: ${JSON.stringify(scores)}`, 'info');

        debugLog('Calculating snippet readiness...', 'info');
        const snippetReadiness = calculateSnippetReadiness(scores, searchData);
        debugLog(`Snippet readiness: ${snippetReadiness}`, 'info');

        debugLog('Displaying dashboard...', 'info');
        // Display results
        displayDashboard(scores, searchData, snippetReadiness);
        
        debugLog('=== AUDIT COMPLETE: Success ===', 'success');
        showStatus('Audit completed successfully!', 'success');
      } catch (error) {
        debugLog(`‚úó AUDIT ERROR: ${error.message}`, 'error');
        debugLog(`Stack trace: ${error.stack}`, 'error');
        showStatus('Error running audit: ' + error.message, 'error');
        console.error(error);
      } finally {
        debugLog('Hiding loading indicator...', 'info');
        document.getElementById('loading').classList.remove('show');
      }
    }

    // Display dashboard
    function displayDashboard(scores, data, snippetReadiness = 0) {
      debugLog('=== DISPLAY DASHBOARD: Starting ===', 'info');
      
      // Show dashboard first (canvas elements need to be visible for Chart.js)
      const dashboardDiv = document.getElementById('dashboard');
      if (!dashboardDiv) {
        debugLog('‚úó Dashboard div not found', 'error');
        console.error('Dashboard div not found');
        return;
      }
      debugLog('‚úì Dashboard div found', 'success');
      dashboardDiv.style.display = 'block';
      debugLog('Dashboard div displayed', 'info');
      
      // Update trend chart description with date range
      const dateRange = parseInt(document.getElementById('dateRange').value) || 30;
      const trendDesc = document.getElementById('trendChartDescription');
      if (trendDesc) {
        let rangeText = '';
        if (dateRange === 7) rangeText = 'Last 7 Days';
        else if (dateRange === 30) rangeText = 'Last 30 Days';
        else if (dateRange === 90) rangeText = 'Last 90 Days';
        else if (dateRange === 180) rangeText = 'Last 6 Months';
        else if (dateRange === 365) rangeText = 'Last 12 Months';
        else rangeText = `Last ${dateRange} Days`;
        trendDesc.textContent = `Historical performance tracking for Local Entity, Visibility, and Authority pillars over ${rangeText.toLowerCase()}.`;
      }
      
      const pillarNames = {
        localEntity: 'Local Entity',
        serviceArea: 'Service Area',
        authority: 'Authority',
        visibility: 'Visibility',
        contentSchema: 'Content / Schema'
      };
      
      // Define pillar weightings and order by weight (highest to lowest)
      const pillarWeights = {
        authority: 0.30,        // 30% - E-A-T is crucial for AI trust
        contentSchema: 0.25,     // 25% - Structured data is key for AI understanding
        visibility: 0.20,        // 20% - How AI surfaces your content
        localEntity: 0.15,       // 15% - Entity recognition important but not critical
        serviceArea: 0.10         // 10% - Less critical for AI search
      };
      
      // Sort pillars by weight (highest to lowest) for consistent ordering
      const getOrderedPillars = (scoresObj) => {
        return Object.entries(scoresObj).sort((a, b) => {
          return (pillarWeights[b[0]] || 0) - (pillarWeights[a[0]] || 0);
        });
      };

      // Create pillar cards (ordered by weight)
      const pillarCards = document.getElementById('pillarCards');
      pillarCards.innerHTML = '';

      getOrderedPillars(scores).forEach(([key, score]) => {
        const rag = getRAGStatus(score);
        const card = document.createElement('div');
        card.className = 'pillar-card';
        
        // Get pillar description
        const descriptions = {
          localEntity: 'How clearly your business and you as a person are recognised as entities by AI search systems.',
          serviceArea: 'How well AI understands where you operate and which regions you serve.',
          authority: 'E-A-T (Experience, Expertise, Authoritativeness, Trustworthiness): Perceived expertise and trust in the topic space (content depth, reviews, citations, credentials, demonstrated experience).',
          visibility: 'How prominently your content appears in AI-powered search results and featured snippets.',
          contentSchema: 'Quality and completeness of structured data markup across your domain.'
        };
        
        card.innerHTML = `
          <h3>${pillarNames[key]}</h3>
          <div class="pillar-score rag-${rag.status}">${Math.round(score)}</div>
          <div class="rag-badge ${rag.status}">${rag.label}</div>
          <p style="font-size: 0.85rem; color: #666; margin-top: 0.5rem; line-height: 1.5; flex-grow: 1;">${descriptions[key] || ''}</p>
        `;
        pillarCards.appendChild(card);
      });
      
      // Remove existing scorecard table if it exists
      const existingScorecard = pillarCards.parentNode.querySelector('.scorecard-section');
      if (existingScorecard) {
        existingScorecard.remove();
      }
      
      // Add pillar scorecard table
      const scorecardTable = document.createElement('div');
      scorecardTable.className = 'scorecard-section';
      scorecardTable.innerHTML = `
        <h3 style="margin: 0 0 1rem 0; color: var(--brand-orange);">Pillar Scorecard</h3>
        <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow-x: auto;">
          <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
            <thead>
              <tr style="background: #f5f5f5;">
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600;">Pillar</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600;">Score</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600;">Weight</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #ddd; font-weight: 600;">Status</th>
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600; width: 25%;">Description</th>
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600;">Improvement Suggestions</th>
              </tr>
            </thead>
            <tbody>
              ${getOrderedPillars(scores).map(([key, score], index) => {
                const rag = getRAGStatus(score);
                
                const descriptions = {
                  localEntity: 'Consistency and clarity of brand, person and business entity signals. <strong>AI Importance:</strong> AI systems rely on clear entity signals to understand who you are and connect your brand across platforms. Strong entity recognition helps AI include you in knowledge panels and entity-based results. <strong>Data Checked:</strong> LocalBusiness schema presence, NAP consistency across site, entity mentions in content, knowledge panel presence, author markup, Organization schema.',
                  serviceArea: 'How clearly AI understands where lessons/workshops run and which regions you cover. <strong>AI Importance:</strong> AI uses geographic signals to match queries with local intent. Clear service area data helps AI surface your content for location-specific searches and local AI Overviews. <strong>Data Checked:</strong> ServiceArea schema markup, geographic keywords in content, location pages, Google Business Profile service areas, address/location schema.',
                  authority: 'E-A-T (Experience, Expertise, Authoritativeness, Trustworthiness): Depth of educational content, references, reviews, external citations, and demonstrated expertise. <strong>AI Importance:</strong> E-A-T is critical for AI systems - they prioritize authoritative, trustworthy sources. Strong E-A-T signals help AI confidently feature your content in AI Overviews and answer boxes. <strong>Data Checked:</strong> Content depth (word count, comprehensiveness), backlink quality/quantity, review counts/ratings, author credentials, citations in content, external mentions, case studies, certifications displayed.',
                  visibility: 'Frequency and prominence in organic search, local pack, snippets and AI Overviews. <strong>AI Importance:</strong> AI systems learn from existing search performance. Higher visibility signals quality and relevance, making AI more likely to surface your content in AI-powered results and featured snippets. <strong>Data Checked:</strong> Search Console impressions/clicks, average position, CTR, featured snippet appearances, local pack visibility, SERP feature presence, ranking distribution.',
                  contentSchema: 'Quality and completeness of structured data markup across your domain. <strong>AI Importance:</strong> Structured data is the primary way AI understands your content. Schema markup directly feeds AI systems, enabling them to extract facts, relationships, and context for use in AI Overviews and answer generation. <strong>Data Checked:</strong> Schema types present (Organization, Person, LocalBusiness, Article, Course, Event, FAQ, HowTo), schema validation errors, coverage percentage, breadcrumb schema, review schema, rich result eligibility.'
                };
                
                // Generate suggestions based on pillar and score
                const getSuggestions = (pillarKey, pillarScore) => {
                  const suggestions = {
                    localEntity: {
                      high: ['Maintain consistent NAP (Name, Address, Phone) across all platforms', 'Continue building personal brand mentions and citations', 'Monitor entity recognition in knowledge panels'],
                      medium: ['Add LocalBusiness schema markup to all location pages', 'Ensure consistent business name and person name across website', 'Build more local citations and directory listings', 'Create an About page with clear entity information', 'Add author markup to content'],
                      low: ['Implement LocalBusiness schema markup immediately', 'Create consistent NAP (Name, Address, Phone) across all platforms', 'Build local citations in relevant directories', 'Add clear About page with entity information', 'Ensure consistent branding across all touchpoints']
                    },
                    serviceArea: {
                      high: ['Continue maintaining clear service area information', 'Update location pages as service areas expand'],
                      medium: ['Add ServiceArea schema markup to location pages', 'Create dedicated pages for each service area/region', 'Include clear geographic information in content', 'Add location-specific keywords naturally', 'Update Google Business Profile with service areas'],
                      low: ['Implement ServiceArea schema markup immediately', 'Create location-specific landing pages', 'Add clear geographic service information to homepage', 'Update all location pages with service area details', 'Include city/region names in page titles and content']
                    },
                    authority: {
                      high: ['Continue producing in-depth, expert content', 'Maintain citation and backlink building efforts', 'Seek opportunities for expert quotes and mentions', 'Keep author bios and credentials up to date'],
                      medium: ['Create more comprehensive, long-form content (2000+ words)', 'Build backlinks from authoritative photography/education sites', 'Seek guest posting opportunities on relevant blogs', 'Collect and display customer reviews/testimonials', 'Create case studies and detailed tutorials', 'Get cited in industry publications', 'Add author bylines with credentials and experience', 'Display certifications, qualifications, and awards', 'Showcase real-world experience and portfolio work', 'Build trust signals (secure site, clear contact info, privacy policy)'],
                      low: ['Produce comprehensive, expert-level content immediately', 'Build backlinks from authoritative sources', 'Create detailed case studies and tutorials', 'Seek media mentions and expert quotes', 'Display customer reviews prominently', 'Build relationships with industry publications', 'Add clear author credentials and experience to all content', 'Display qualifications, certifications, and professional memberships', 'Create About page highlighting expertise and experience', 'Build trust signals (HTTPS, clear contact, privacy policy, terms)']
                    },
                    visibility: {
                      high: ['Continue optimizing for featured snippets', 'Maintain strong ranking positions', 'Monitor SERP feature opportunities'],
                      medium: ['Optimize content for featured snippets (answer boxes)', 'Target long-tail keywords with lower competition', 'Improve page load speed and Core Web Vitals', 'Create FAQ schema for common questions', 'Optimize for "People Also Ask" sections', 'Build internal linking structure'],
                      low: ['Optimize for featured snippets immediately', 'Target low-competition long-tail keywords', 'Improve page speed and mobile experience', 'Add FAQ schema markup', 'Create content targeting "People Also Ask" queries', 'Build strong internal linking structure']
                    },
                    contentSchema: {
                      high: ['Continue maintaining schema markup', 'Expand schema types as new content is added', 'Monitor for schema errors'],
                      medium: ['Add missing schema types (Article, Course, Event, FAQ)', 'Validate all schema markup using Google Rich Results Test', 'Ensure schema is on all relevant pages', 'Add breadcrumb schema to all pages', 'Implement Organization and Person schema', 'Add Review schema where applicable'],
                      low: ['Implement comprehensive schema markup immediately', 'Add Organization, Person, and LocalBusiness schema', 'Validate all schema using Google Rich Results Test', 'Add Article schema to all blog posts', 'Implement breadcrumb schema site-wide', 'Add FAQ and HowTo schema where relevant']
                    }
                  };
                  
                  const pillarSuggestions = suggestions[pillarKey];
                  if (!pillarSuggestions) return 'No suggestions available';
                  
                  let selectedSuggestions = [];
                  if (pillarScore >= 70) {
                    selectedSuggestions = pillarSuggestions.high || [];
                  } else if (pillarScore >= 40) {
                    selectedSuggestions = pillarSuggestions.medium || [];
                  } else {
                    selectedSuggestions = pillarSuggestions.low || [];
                  }
                  
                  // Return top 3-4 suggestions as bullet points
                  return selectedSuggestions.slice(0, 4).map(s => `‚Ä¢ ${s}`).join('<br>') || 'No suggestions available';
                };
                
                const weight = pillarWeights[key] || 0;
                const isEven = index % 2 === 0;
                
                return `
                  <tr style="border-bottom: 1px solid #eee; background: ${isEven ? '#ffffff' : '#fafafa'};">
                    <td style="padding: 0.75rem; font-weight: 500;">${pillarNames[key]}</td>
                    <td style="padding: 0.75rem; text-align: center; font-size: 1.1rem; font-weight: 600; color: ${rag.status === 'green' ? '#10b981' : rag.status === 'amber' ? '#f59e0b' : '#ef4444'};">
                      ${Math.round(score)}
                    </td>
                    <td style="padding: 0.75rem; text-align: center; font-size: 0.9rem; font-weight: 600; color: #666;">
                      ${(weight * 100).toFixed(0)}%
                    </td>
                    <td style="padding: 0.75rem; text-align: center;">
                      <span class="rag-badge ${rag.status}" style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.8rem;">
                        ${rag.label}
                      </span>
                    </td>
                    <td style="padding: 0.75rem; color: #666; font-size: 0.85rem; line-height: 1.6; width: 25%;">${descriptions[key] || ''}</td>
                    <td style="padding: 0.75rem; color: #555; font-size: 0.85rem; line-height: 1.6;">${getSuggestions(key, score)}</td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
        <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-top: 1rem; border-left: 4px solid var(--brand-orange);">
          <p style="margin: 0; font-size: 0.9rem; color: #555; line-height: 1.6; margin-bottom: 0.5rem;">
            <strong>RAG Status Guide:</strong> 
            <span style="color: #10b981; font-weight: 600;">Green (70-100)</span> = Strong performance, 
            <span style="color: #f59e0b; font-weight: 600;">Amber (40-69)</span> = Needs improvement, 
            <span style="color: #ef4444; font-weight: 600;">Red (0-39)</span> = Critical issues
          </p>
          <p style="margin: 0; font-size: 0.9rem; color: #555; line-height: 1.6;">
            <strong>Weighting:</strong> Pillars are weighted by their importance for AI search systems. Authority (30%) and Content/Schema (25%) are most critical, as AI relies heavily on E-A-T signals and structured data. Visibility (20%) reflects how AI learns from existing performance, while Local Entity (15%) and Service Area (10%) are less critical for AI-powered results.
          </p>
        </div>
      `;
      pillarCards.parentNode.insertBefore(scorecardTable, pillarCards.nextSibling);

      // Display snippet readiness with gauge visualization
      const snippetScoreElement = document.getElementById('snippetReadinessScore');
      const gaugeFill = document.getElementById('gaugeFill');
      const gaugeStatus = document.getElementById('gaugeStatus');
      
      if (snippetScoreElement && gaugeFill) {
        snippetScoreElement.textContent = snippetReadiness;
        
        // Calculate gauge fill (circumference = 2 * œÄ * r = 2 * œÄ * 80 ‚âà 502.65)
        const circumference = 2 * Math.PI * 80;
        const offset = circumference - (snippetReadiness / 100) * circumference;
        
        // Color code based on score
        let colorClass = 'red';
        let statusText = 'Critical';
        if (snippetReadiness >= 70) {
          colorClass = 'green';
          statusText = 'Strong';
        } else if (snippetReadiness >= 40) {
          colorClass = 'amber';
          statusText = 'Needs Improvement';
        }
        
        // Update gauge fill
        gaugeFill.classList.remove('green', 'amber', 'red');
        gaugeFill.classList.add(colorClass);
        gaugeFill.style.strokeDashoffset = offset;
        
        // Update score color
        snippetScoreElement.classList.remove('green', 'amber', 'red');
        snippetScoreElement.classList.add(colorClass);
        
        // Update status text
        if (gaugeStatus) {
          gaugeStatus.textContent = statusText;
          gaugeStatus.style.color = snippetScoreElement.style.color;
        }
      }

      // Format numbers for display
      const formatNumber = (num) => {
        if (num >= 1000000) {
          return (num / 1000000).toFixed(1) + 'M';
        } else if (num >= 1000) {
          return (num / 1000).toFixed(0) + 'K';
        }
        return num.toLocaleString();
      };

      // Display metrics
      const metricsGrid = document.getElementById('metricsGrid');
      metricsGrid.innerHTML = `
        <div class="metric-card">
          <div class="value">${formatNumber(data.totalClicks)}</div>
          <div class="label">Total Clicks</div>
        </div>
        <div class="metric-card">
          <div class="value">${formatNumber(data.totalImpressions)}</div>
          <div class="label">Total Impressions</div>
        </div>
        <div class="metric-card">
          <div class="value">${data.averagePosition.toFixed(1)}</div>
          <div class="label">Avg Position</div>
        </div>
        <div class="metric-card">
          <div class="value">${((data.totalClicks / data.totalImpressions) * 100).toFixed(2)}%</div>
          <div class="label">CTR</div>
        </div>
      `;

      // Wait a moment for DOM to update, then create charts (charts need visible canvas)
      setTimeout(() => {
        debugLog('Starting chart creation (setTimeout callback)...', 'info');
        
        // Check if Chart.js is loaded
        debugLog('Checking Chart.js availability...', 'info');
        if (typeof Chart === 'undefined') {
          debugLog('‚úó Chart.js library not loaded', 'error');
          console.error('Chart.js library not loaded');
          showStatus('Chart.js library failed to load. Please refresh the page.', 'error');
          return;
        }
        debugLog('‚úì Chart.js library available', 'success');
        debugLog(`Chart constructor: ${typeof Chart}`, 'info');

        // Create radar chart
        debugLog('Creating radar chart...', 'info');
        const radarCanvas = document.getElementById('radarChart');
        if (!radarCanvas) {
          debugLog('‚úó Radar chart canvas not found', 'error');
          console.error('Radar chart canvas not found');
          return;
        }
        debugLog('‚úì Radar chart canvas found', 'success');
        
        // Safely destroy existing chart if it exists
        debugLog(`Checking for existing radarChart: ${window.radarChart ? 'exists' : 'null'}`, 'info');
        try {
          if (window.radarChart) {
            debugLog(`radarChart type: ${typeof window.radarChart}`, 'info');
            debugLog(`radarChart instanceof Chart: ${window.radarChart instanceof Chart}`, 'info');
            debugLog(`radarChart.destroy type: ${typeof window.radarChart.destroy}`, 'info');
            
            // Check if it's actually a Chart instance
            if (window.radarChart instanceof Chart && typeof window.radarChart.destroy === 'function') {
              debugLog('Destroying existing radar chart...', 'info');
              window.radarChart.destroy();
              debugLog('‚úì Existing radar chart destroyed', 'success');
            } else {
              debugLog('‚ö† Existing radarChart is not a valid Chart instance, clearing...', 'warn');
            }
            window.radarChart = null;
          } else {
            debugLog('No existing radar chart to destroy', 'info');
          }
        } catch (e) {
          debugLog(`‚úó Error destroying existing radar chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.warn('Error destroying existing radar chart:', e);
          window.radarChart = null;
        }
        
        const radarCtx = radarCanvas.getContext('2d');
        debugLog('Creating new Chart instance for radar chart...', 'info');
        try {
          // Use ordered pillars for consistent ordering
          const orderedPillars = getOrderedPillars(scores);
          const orderedLabels = orderedPillars.map(([key]) => pillarNames[key]);
          const orderedData = orderedPillars.map(([, score]) => score);
          
          window.radarChart = new Chart(radarCtx, {
            type: 'radar',
            data: {
              labels: orderedLabels,
              datasets: [{
                label: 'Current Scores',
                data: orderedData,
                backgroundColor: 'rgba(229, 114, 0, 0.2)',
                borderColor: 'rgba(229, 114, 0, 1)',
                pointBackgroundColor: 'rgba(229, 114, 0, 1)',
                pointBorderColor: '#fff',
                pointHoverBackgroundColor: '#fff',
                pointHoverBorderColor: 'rgba(229, 114, 0, 1)'
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              layout: {
                padding: {
                  top: 20,
                  bottom: 20,
                  left: 20,
                  right: 20
                }
              },
              scales: {
                r: {
                  beginAtZero: true,
                  max: 100,
                  ticks: {
                    stepSize: 20,
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    color: '#1e293b'
                  },
                  pointLabels: {
                    font: {
                      size: 16,
                      weight: 'bold'
                    },
                    color: '#1e293b',
                    padding: 15
                  },
                  grid: {
                    color: 'rgba(100, 116, 139, 0.2)'
                  },
                  angleLines: {
                    color: 'rgba(100, 116, 139, 0.3)'
                  }
                }
              },
              plugins: {
                legend: {
                  labels: {
                    font: {
                      size: 14,
                      weight: 'bold'
                    },
                    padding: 15
                  }
                }
              }
            }
          });
          debugLog('‚úì Radar chart created successfully', 'success');
          debugLog(`radarChart type after creation: ${typeof window.radarChart}`, 'info');
          debugLog(`radarChart instanceof Chart: ${window.radarChart instanceof Chart}`, 'info');
        } catch (e) {
          debugLog(`‚úó Error creating radar chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.error('Error creating radar chart:', e);
        }

        // Create trend chart (mock data for now)
        debugLog('Creating trend chart...', 'info');
        const trendCanvas = document.getElementById('trendChart');
        if (!trendCanvas) {
          debugLog('‚úó Trend chart canvas not found', 'error');
          console.error('Trend chart canvas not found');
          return;
        }
        debugLog('‚úì Trend chart canvas found', 'success');
        
        // Safely destroy existing chart if it exists
        debugLog(`Checking for existing trendChart: ${window.trendChart ? 'exists' : 'null'}`, 'info');
        try {
          if (window.trendChart) {
            debugLog(`trendChart type: ${typeof window.trendChart}`, 'info');
            debugLog(`trendChart instanceof Chart: ${window.trendChart instanceof Chart}`, 'info');
            debugLog(`trendChart.destroy type: ${typeof window.trendChart.destroy}`, 'info');
            // Check if it's actually a Chart instance
            if (window.trendChart instanceof Chart && typeof window.trendChart.destroy === 'function') {
              debugLog('Destroying existing trend chart...', 'info');
              window.trendChart.destroy();
              debugLog('‚úì Existing trend chart destroyed', 'success');
            } else {
              debugLog('‚ö† Existing trendChart is not a valid Chart instance, clearing...', 'warn');
            }
            window.trendChart = null;
          } else {
            debugLog('No existing trend chart to destroy', 'info');
          }
        } catch (e) {
          debugLog(`‚úó Error destroying existing trend chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.warn('Error destroying existing trend chart:', e);
          window.trendChart = null;
        }
        
        const trendCtx = trendCanvas.getContext('2d');
        const dateRange = parseInt(document.getElementById('dateRange').value) || 30;
        debugLog(`Creating trend chart for date range: ${dateRange} days`, 'info');
        
        // Determine number of data points and label frequency based on date range
        let numDataPoints, labelStep, dateFormat;
        if (dateRange <= 30) {
          // For 30 days or less: show daily data, all labels
          numDataPoints = dateRange;
          labelStep = 1;
          dateFormat = { month: 'short', day: 'numeric' };
        } else if (dateRange <= 90) {
          // For 90 days: show daily data, label every 3-5 days
          numDataPoints = dateRange;
          labelStep = Math.ceil(dateRange / 20); // ~20 labels max
          dateFormat = { month: 'short', day: 'numeric' };
        } else if (dateRange <= 180) {
          // For 6 months: show weekly data, label every week
          numDataPoints = Math.ceil(dateRange / 7);
          labelStep = 1;
          dateFormat = { month: 'short', day: 'numeric' };
        } else {
          // For 12 months: show weekly data, label every 2-4 weeks
          numDataPoints = Math.ceil(dateRange / 7);
          labelStep = Math.ceil(numDataPoints / 15); // ~15 labels max
          dateFormat = { month: 'short', day: 'numeric' };
        }
        
        // Generate date labels
        const allDates = Array.from({ length: numDataPoints }, (_, i) => {
          const d = new Date();
          if (dateRange <= 90) {
            // Daily data
            d.setDate(d.getDate() - (numDataPoints - 1 - i));
          } else {
            // Weekly data
            d.setDate(d.getDate() - ((numDataPoints - 1 - i) * 7));
          }
          return d;
        });
        
        // Create labels array with appropriate spacing
        const dates = allDates.map((d, i) => {
          if (i % labelStep === 0 || i === allDates.length - 1) {
            return d.toLocaleDateString('en-GB', dateFormat);
          }
          return ''; // Empty string for labels we don't want to show
        });
        debugLog('Creating new Chart instance for trend chart...', 'info');
        try {
          window.trendChart = new Chart(trendCtx, {
            type: 'line',
            data: {
              labels: dates,
              datasets: [
                {
                  label: 'Local Entity',
                  data: Array.from({ length: numDataPoints }, () => {
                    const base = scores.localEntity;
                    const variation = (Math.random() * 10 - 5);
                    return Math.max(0, Math.min(100, base + variation));
                  }),
                  borderColor: 'rgba(239, 68, 68, 1)',
                  backgroundColor: 'rgba(239, 68, 68, 0.1)',
                  tension: 0.4,
                  pointRadius: dateRange <= 90 ? 3 : 2,
                  pointHoverRadius: 5
                },
                {
                  label: 'Visibility',
                  data: Array.from({ length: numDataPoints }, () => {
                    const base = scores.visibility;
                    const variation = (Math.random() * 10 - 5);
                    return Math.max(0, Math.min(100, base + variation));
                  }),
                  borderColor: 'rgba(229, 114, 0, 1)',
                  backgroundColor: 'rgba(229, 114, 0, 0.1)',
                  tension: 0.4,
                  pointRadius: dateRange <= 90 ? 3 : 2,
                  pointHoverRadius: 5
                },
                {
                  label: 'Authority',
                  data: Array.from({ length: numDataPoints }, () => {
                    const base = scores.authority;
                    const variation = (Math.random() * 10 - 5);
                    return Math.max(0, Math.min(100, base + variation));
                  }),
                  borderColor: 'rgba(16, 185, 129, 1)',
                  backgroundColor: 'rgba(16, 185, 129, 0.1)',
                  tension: 0.4,
                  pointRadius: dateRange <= 90 ? 3 : 2,
                  pointHoverRadius: 5
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                x: {
                  ticks: {
                    maxRotation: 45,
                    minRotation: 45,
                    font: {
                      size: 11,
                      weight: 'bold'
                    },
                    callback: function(value, index) {
                      // Only show non-empty labels
                      const label = this.getLabelForValue(value);
                      return label || '';
                    }
                  },
                  grid: {
                    display: true,
                    color: 'rgba(0, 0, 0, 0.05)'
                  }
                },
                y: {
                  beginAtZero: true,
                  max: 100,
                  ticks: {
                    stepSize: 10,
                    font: {
                      size: 12,
                      weight: 'bold'
                    }
                  },
                  grid: {
                    color: 'rgba(0, 0, 0, 0.1)'
                  }
                }
              },
              plugins: {
                legend: {
                  display: true,
                  position: 'top',
                  labels: {
                    font: {
                      size: 13,
                      weight: 'bold'
                    },
                    padding: 15,
                    usePointStyle: true
                  }
                },
                tooltip: {
                  mode: 'index',
                  intersect: false
                }
              }
            }
          });
          debugLog('‚úì Trend chart created successfully', 'success');
          debugLog(`trendChart type after creation: ${typeof window.trendChart}`, 'info');
          debugLog(`trendChart instanceof Chart: ${window.trendChart instanceof Chart}`, 'info');
          debugLog('=== DISPLAY DASHBOARD: Complete ===', 'success');
        } catch (e) {
          debugLog(`‚úó Error creating trend chart: ${e.message}`, 'error');
          debugLog(`Stack: ${e.stack}`, 'error');
          console.error('Error creating trend chart:', e);
        }
      }, 100);
    }

    // Initialize on load
    window.addEventListener('DOMContentLoaded', () => {
      debugLog('=== PAGE LOAD: DOMContentLoaded event fired ===', 'info');
      debugLog(`Window location: ${window.location.href}`, 'info');
      debugLog(`User agent: ${navigator.userAgent}`, 'info');
      loadConfig();
      debugLog('=== PAGE LOAD: Initialization complete ===', 'success');
    });
  </script>
</body>
</html>

